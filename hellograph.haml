!!!
%html
  %head
    %title Hello Graph
    / <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    / <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    %link{:crossorigin => "anonymous", :href => "https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css", :integrity => "sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh", :rel => "stylesheet"}/
    %link{:href => "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css", :rel => "stylesheet"}/
    %script{:src => "./axios.min.js"}
    %script{:src => "./vis-network.min.js"}
    %script{:src => "./lib/dat.gui.min.js"}
    %script{:src => "./manipulations.js"}
    %script{:src => "./lib/pg_parser_browserified.js", :type => "text/javascript"}
    %script{:src => "./lib/json2pg_browserified.js", :type => "text/javascript"}
    :css
      #network-popUp {
          display: none;
          position: absolute;
          top: 350px;
          left: 170px;
          z-index: 299;
          width: 250px;
          background-color: #f9f9f9;
          border-style: solid;
          border-width: 3px;
          border-color: #5394ed;
          padding: 10px;
          text-align: center;
      }
  %body
    #network-popUp
      %span#operation node
      %br/
      %table{:style => "margin: auto"}
        %tbody#popup-table
      %input#saveButton{:type => "button", :value => "save"}/
      %input#cancelButton{:type => "button", :value => "cancel"}/
    .row
      .col-6.pr-0.pl-4
        %input#search-input.form-control{"aria-label" => "", :placeholder => "Free Search", :type => "text"}/
      .col-2.mx-0.px-0
        %button.mx-0.btn.btn-info#search-button{:type => "button"}
          %span.fa.fa-search#search-icon
          Search
    .row
      .col-12
        #graph.vh-100.bg-light
    #input-area
      %input#pgfile{:type => "file"}/
      %input#url-input/
      %textarea#graph-input{:style => "resize: none; width: 100%; height: 80px;"}
    :javascript
      'use strict';
          const q = document.querySelector.bind(document);
          const qa = document.querySelectorAll.bind(document);
          const nodeSize = 25;
          let timerId = 0;
          let localMode = false;
          let groups = new Set();
          let data, nodes, nodeDataSet, edgeDataSet, expandedNodes = [], network;
          let clickedPosition;
          let graph, nodeMap = new Map(), edgeMap = new Map();
          let edgeColorMap;
          let domain;
          let displayedTimeProp = "submittedDate"; 
          let timeLineEnabled = false;
          let nodeProps, edgeProps;
          let minTime =  new Date(8640000000000000), maxTime = new Date(-8640000000000000);
          let timeInterval = 1;
          let timeProperties = new Set();
          let timeScale = 100.0;
          const gui = new dat.GUI();
          const nodeFolder = gui.addFolder('Node');
          const edgeFolder = gui.addFolder('Edge');
          const timeLineFolder = gui.addFolder('TimeLine');
          const physicsController = gui.add({physics: false}, 'physics');
          const timeLineEnabledController = timeLineFolder.add({enabled: timeLineEnabled}, 'enabled');
          const timeLinePropertyController = timeLineFolder.add({property: displayedTimeProp}, 'property', [displayedTimeProp]);
          
          function onNodeControllerChange(){
            let displayedProps = displayedNodeProps();
            nodeDataSet.update(graph.nodes.map((node) => {
                return {
                  id: node.id,
                  label: createLabelText(node, displayedProps)
                };
              })
            );
          };
          
          function updateTimeLineNodes() {
              if(timeLineEnabled && timeInterval > 0) {
                nodeDataSet.update([
                  {
                    id:"hellograph-min",
                    label: "\n" + minTime.toLocaleDateString(),
                    shape: 'star',
                    physics: false,
                    fixed: true,
                    x: -timeScale / 2,
                    y: 0,
                    color: 'green',
                  },
                  {
                    id:"hellograph-max",
                    label: maxTime.toLocaleDateString(),
                    shape: 'star',
                    physics: false,
                    fixed: true,
                    x: timeScale / 2,
                    y: 0,
                    color: 'green',
                  },
                ]);
              } else {
                nodeDataSet.remove(["hellograph-min", "hellograph-max"])
              }
          }
          
          function calcNodePosition(pgNode) {
              let x, y, fixed;
              if(timeLineEnabled) {
                if(pgNode.properties[displayedTimeProp] && timeInterval > 0) {
                  x = timeScale * ((new Date(pgNode.properties[displayedTimeProp]).getTime()) - minTime.getTime()) * 1.0 / timeInterval - timeScale * 0.5; 
                  fixed = true;
                } else {
                  x = 0;
                  fixed = false;
                }
                y = 0;
              }
              else {
                x = null;
                y = null;
                fixed = false;
              }
              return {x, y, fixed};
          }
          
          function retrieveHttpUrl(node) {
            for(let props of Object.values(node.properties)) { 
              for(let prop of props) {
                if(typeof(prop) === 'string' && (prop.startsWith("https://") || prop.startsWith("http://"))) {
                  return prop;
                }
              }
            }
            return null;
          }
      
          function toVisNode(pgNode, group, props, extraOptions = null) {
              let x, y, fixed;
              ({x, y, fixed} = calcNodePosition(pgNode));
              
              let url = retrieveHttpUrl(pgNode);
              let expanded = expandedNodes.includes(pgNode.id);
              
              let degree =  pgNode.properties['degree'];
              if(degree !== undefined) {
                degree = degree[0];
              }
              
              let attrs = {
                  id: pgNode.id,
                  group: group,
                  label: createLabelText(pgNode, props),
                  shape: degree === 1 ? 'text' : (expanded ? 'square' : 'dot'),
                  size: expanded ? 25 : (2 + degree * 8),
                  degree: degree,
                  title: createTitleText(pgNode),
                  fixed: {
                    x: fixed,
                    y: false
                  },
                  borderWidth: url ? 3 : 1,
                  url: url,
                  x: x,
                  y: y,
                  font: {
                    color: url ? 'blue' : 'black'
                  },                  
              };
              attrs = Object.assign(attrs, extraOptions);
              return attrs;
          }
          
          function toVisEdge(pgEdge, group, props) {
              return {
                  id: pgEdge.properties.id[0],
                  from: pgEdge.from,
                  to: pgEdge.to,
                  color: edgeColorMap[group],
                  label: createLabelText(pgEdge, props),
                  title: createTitleText(pgEdge),
                  remoteId: pgEdge.properties.id[0]
              }
          }
          
          function wrapText(str, asHtml) {
            if(!str)
              return str;
            if(Array.isArray(str))
              str = str[0];
            const maxWidth = 20;
            let newLineStr = asHtml ? "<br>" : "\n", res = '';
            while (str.length > maxWidth) {
              res += str.slice(0, maxWidth) + newLineStr;
              str = str.slice(maxWidth);
            }
            return res + str;
          }
      
          function createLabelText(elem, props = null) {
              if(props != null) {
                  // Use whitespace instead of empty string if no props are specified because Vis.js cannot update label with empty string)
                return props.length ? props.map((prop) => prop == 'label' ? elem.labels : wrapText(elem.properties[prop])).filter((val) => val).join('\n') : ' ';
              }
              else if (elem.id) // for nodes
                  return elem.id;
              else // for edges
                  return elem.labels.join("\n");
          }
      
          function createTitleText(elem) {
              let flattend_props = Object.entries(elem.properties).reduce((acc, prop) =>
                  acc.concat(`<tr><td>${prop[0]}</td><td>${wrapText(prop[1], true)}</td></tr>`), []);
              if (elem.id) // for nodes
                  flattend_props.push(`<tr><td>label</td><td>${elem.labels.join(':')}</td></tr>`);
              return `<table>${flattend_props.join('')}</table>`;
          }
      
          function getRandomColor() {
              let letters = '0123456789ABCDEF';
              let color = '#';
              for (let i = 0; i < 6; i++) {
                  color += letters[Math.floor(Math.random() * 16)];
              }
              return color;
          }
      
          function retrieveGraph(node_id, add = false) {
              node_id = node_id || 1;
              domain = q('#url-input').value;
              if (!domain.endsWith('/'))
                  domain += '/';
              domain = 'http://' + domain;
              if(add) {
                const existing = nodeDataSet.get(node_id);
                if(existing.shape != 'text') // For nodes with degree > 1
                  nodeDataSet.update({
                    id: node_id,
                    shape: "square",
                    size: 25,
                    fixed: true
                  });
              }
              // TODO: use query which does not modify of backend
              const subquery = `MATCH p=(n)-[r]-(another) WHERE id(n) in [${node_id}] WITH p, another, size((another)--()) as degree SET another.degree = degree RETURN p`;
              axios.get(domain + `query?q=${subquery}`).then((response) => {
                  if (add) {
                      addGraph(response.data.pg);
                      expandedNodes.push(node_id.toString());
                  } else {
                      expandedNodes = [node_id.toString()];
                      updateGraph(response.data.pg);
                  }
              });
          }
          
          function setSearchState(searching) {
            const icon =  q('#search-icon');
            if(searching) {
              icon.classList.remove("fa-search");
              icon.classList.add("fa-spinner");
              icon.classList.add("fa-spin");
            } else {
              icon.classList.add("fa-search");
              icon.classList.remove("fa-spinner");
              icon.classList.remove("fa-spin");
            }
          }
      
          function searchGraph() {  
              setSearchState(true);
              const keyword = q('#search-input').value;
              domain = q('#url-input').value;
              if (!domain.endsWith('/'))
                  domain += '/';
              domain = 'http://' + domain;
              const keywordPart = encodeURI(keyword.split(" ").map((word) => `\\"${word}\\"`).join(' AND '));
              const query = `CALL db.index.fulltext.queryNodes("allProperties", "${keywordPart}") YIELD node RETURN node`;
              console.log(query);
              axios.get(domain + `query?q=${query}`).then((response) => {
                  expandedNodes = response.data.pg.nodes.map((node) => node.id);
                  
                  // TODO: use query which does not modify of backend
                  const subquery = `MATCH p=(n)-[r]-(another) WHERE id(n) in [${expandedNodes.join(',')}] WITH p, another, size((another)--()) as degree SET another.degree = degree RETURN p`
                  axios.get(domain + `query?q=${subquery}`).then((subresponse) => {
                    updateGraph(subresponse.data.pg);
                    setSearchState(false);
                  });
              });
          }
          
          
          function displayedNodeProps() {
            return nodeFolder.__controllers.map((con) =>
                  con.__checkbox.checked ? con.property : null).filter((prop) => prop);
          }
          
          function displayedEdgeProps() {
            return edgeFolder.__controllers.map((con) =>
                  con.__checkbox.checked ? con.property : null).filter((prop) => prop);
          }
          
          function isDateString(str) {
            return isNaN(str) && !isNaN(Date.parse(str))
          }
          
      
          function updateGraph(input) {
              groups = new Set();
              edgeColorMap = {};
      
              input = input || q('#graph-input').value;
              if (typeof input === 'string' || input instanceof String) {
                  try {
                      graph = JSON.parse(input);
                  } catch (err) {
                      if (err instanceof SyntaxError)
                          graph = pgParser.parse(input);
                      else
                          throw err;
                  }
              } else {
                  graph = input;
              }
              
              minTime =  new Date(8640000000000000), maxTime = new Date(-8640000000000000);
              
              let nodeCountWithTime = 0;
              
              graph.nodes.forEach(node => { 
                for(let prop of Object.keys(node.properties)) {
                  if(!timeProperties.has(prop) && isDateString(node.properties[prop])){
                    timeProperties.add(prop);
                  }
                }
                nodeMap[node.id] = node;
                let time = node.properties[displayedTimeProp];
                if(time) {
                  ++nodeCountWithTime;
                  time = new Date(time);
                  minTime = time < minTime ? time : minTime;
                  maxTime = time > maxTime ? time : maxTime;
                }
              });
              timeLinePropertyController.options(Array.from(timeProperties));
              timeInterval = maxTime.getTime() - minTime.getTime();
              timeScale = nodeCountWithTime * 100;
              
              
              graph.edges.forEach(edge => edgeMap[edge.id] = edge);
              
              nodeProps = new Set(['label']);
              edgeProps = new Set(['label']);
              graph.nodes.forEach((node) => {
                  Object.keys(node.properties).filter((prop) => prop != 'degree').forEach(nodeProps.add, nodeProps);
              });
              graph.edges.forEach((edge) => {
                  Object.keys(edge.properties).forEach(edgeProps.add, edgeProps);
              });
              
              const defaultPropsFilter = new RegExp('name|title', 'i');
              let defaultNodeProps = displayedNodeProps();
              let defaultEdgeProps = displayedEdgeProps();
              
              if(defaultNodeProps.length == 0) { // Initial value
                defaultNodeProps = Array.from(nodeProps).filter((prop) => defaultPropsFilter.test(prop));
                defaultEdgeProps = Array.from(edgeProps).filter((prop) => defaultPropsFilter.test(prop));
              }

              
              if(defaultNodeProps.length == 0) defaultNodeProps = ['id'];
              
      
              nodeDataSet = new vis.DataSet();
              nodeDataSet.add(graph.nodes.map((node) => {
                  const groupName = node.labels.join('_');
                  groups.add(groupName);
                  return toVisNode(node, groupName, defaultNodeProps)
              }));
              
              updateTimeLineNodes();

              edgeDataSet = new vis.DataSet(graph.edges.map((edge) => {
                  const edgeLabel = edge.labels.join('_');
                  if (!edgeColorMap[edgeLabel]) {
                      edgeColorMap[edgeLabel] = getRandomColor();
                  }
                  return toVisEdge(edge, edgeLabel, defaultEdgeProps);                   
              }));
              // create a network
              let container = document.getElementById('graph');
              data = {
                  nodes: nodeDataSet,
                  edges: edgeDataSet
              };
              
              
              while(nodeFolder.__controllers.length > 0) nodeFolder.__controllers[0].remove();
              while(edgeFolder.__controllers.length > 0) edgeFolder.__controllers[0].remove();
              
              nodeProps.forEach(prop => {
                  const controller = nodeFolder.add({[prop]: defaultNodeProps.includes(prop)}, prop)
                  controller.onChange(onNodeControllerChange);
                }
              );
              
              const onEdgeControllerChange = () => {
                let displayedProps = displayedEdgeProps();
                edgeDataSet.update(graph.edges.map((edge) => {
                    return { id:edge.properties.id[0],
                     label: createLabelText(edge, displayedProps) };
                  }
                ));
              }
              
              edgeProps.forEach(prop => {
                  const controller = edgeFolder.add({[prop]: defaultEdgeProps.includes(prop)}, prop)
                  controller.onChange(onEdgeControllerChange);
                }
              );
              
              
              let options = {
                  groups: Object.keys(groups).reduce((acc, group) => {
                      acc[group] = {color: getRandomColor()}
                  }, {}),
                  layout: {
                      randomSeed: 1,
                  },
                  interaction: {
                      hover: true
                  },
                  physics: {
                    stabilization: {
                        enabled: false,
                        iterations: 200,
                        updateInterval: 25
                    }
                  },
                  manipulation: false,

                  edges: {
                      arrows: {
                          to: {
                              enabled: true,
                              scaleFactor: 0.3,
                              type: "arrow"
                          },
                      }
                  }
              };
              network = new vis.Network(container, data, options);
              
              
              network.on('zoom', (opt) => {
                if(timeLineEnabled) {
                  nodeDataSet.update([
                    {
                      id: 'hellograph-min',
                      size: 15 / opt.scale,
                    },
                    {
                      id: 'hellograph-max',
                      size: 15 / opt.scale,
                    }
                  ]);
                }
              })

              if (!localMode) {
                  let selectTimer = null;
                  network.on('selectNode', (e) => {
                      if (e.nodes.length > 0)
                          selectTimer = setTimeout(() => retrieveGraph(e.nodes[0], true), 300);
                  });
                  network.on('doubleClick', (e) => {
                      if (e.nodes.length > 0)
                          retrieveGraph(e.nodes[0]);
                  });
                  network.on('dragStart', (e) => {
                      clearTimeout(selectTimer);
                  });
              }
              
              network.on("hoverNode", (params) => {
                  network.canvas.body.container.style.cursor = 'default';
                  const node = nodeDataSet.get(params.node);
                  if(node.url) {
                    network.canvas.body.container.style.cursor = 'pointer';
                    nodeDataSet.update({
                      id: params.node,
                      color: '#8888ff',
                    });
                  } else if(node.degree > 1 && !expandedNodes.includes(params.node)) {
                    network.canvas.body.container.style.cursor = 'pointer';
                  }
              });
              network.on("blurNode", (params) => {
                  network.canvas.body.container.style.cursor = 'default';
                  if(nodeDataSet.get(params.node).url) {
                    nodeDataSet.update({
                      id: params.node,
                      color: null,
                    });
                  }
              });
          
              network.on("click", (e) => {
                 network.stopSimulation();
                 if(e.nodes.length > 0) {
                    let node = nodeDataSet.get(e.nodes[0]);
                    if(node.url)
                      window.open(node.url,'_blank');
                 }
              });
              network.on("stabilizationIterationsDone", function () {
                  console.log('stabilized');
                  network.setOptions({physics: {enabled:physicsController.getValue()}});
              });
          }
      
          function addGraph(newGraph) {
              let newNodes = newGraph.nodes.filter((n) => !nodeDataSet._data.has(n.id));
              let newEdges = newGraph.edges.filter((e) => !(expandedNodes.includes(e.from) || expandedNodes.includes(e.to)));
              graph.nodes = graph.nodes.concat(newNodes);
              graph.edges = graph.edges.concat(newEdges);
      
              nodeDataSet.add(newNodes.map((node) => {
                  const groupName = node.labels.join('_');
                  groups.add(groupName);
                  return toVisNode(node, groupName, displayedNodeProps());
              }));
              
              edgeDataSet.add(newEdges.map((edge) => {
                  const edgeLabel = edge.labels.join('_');
                  if (!edgeColorMap[edgeLabel]) {
                      edgeColorMap[edgeLabel] = getRandomColor();
                  }
                  return toVisEdge(edge, edgeLabel, displayedEdgeProps());     
              }));
      
          }
          
      
          function handleFileSelect(evt) {
              let files = evt.target.files; // FileList object
              // use the 1st file from the list
              const f = files[0];
              let reader = new FileReader();
      
      
              // Closure to capture the file information.
              reader.onload = (function (theFile) {
                  return function (e) {
                      q('#graph-input').value = e.target.result;
                      updateGraph();
                  };
              })(f);
              // Read in the image file as a data URL.
              reader.readAsText(f);
          };
      
          document.addEventListener('mousemove', (e) => { 
            clickedPosition = {x: e.clientX, y: e.clientY}; 
          });
          q('#pgfile').addEventListener('change', handleFileSelect, false);
          q('#graph-input').value =
              `node1 :You name:"your name"
      node2 :Graph type:"graph"
      node1 -> node2 :Hello! on:"today"`;
          q('#url-input').value = 'localhost:3000';
          // retrieveGraph();
          /*  updateGraph(); */
          
          q('#graph-input').addEventListener('input', () => {
              clearTimeout(timerId);
              localMode = true;
              timerId = setTimeout(updateGraph, 1000);
          });
          
          q('#search-input').addEventListener('keyup', () => {
            if (event.keyCode == 13) // Enter
              q('#search-button').click(); 
          });
      
          q('#search-button').addEventListener('click', () => {
            searchGraph();
          });
      
          q('#url-input').addEventListener('change', () => {
              clearTimeout(timerId);
              localMode = false;
              timerId = setTimeout(retrieveGraph, 1000);
          });
          
          q('#search-input').value = '情報通信';
          searchGraph();

%script{:src => "./gui.js"}
%script{:src => "./animation.js"}