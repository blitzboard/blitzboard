!!!
%html
  %head
    %title Hello Graph
    %link{:crossorigin => "anonymous", :href => "https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css", :integrity => "sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh", :rel => "stylesheet"}/
    %link{:href => "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css", :rel => "stylesheet"}/
    %link{:href => "https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css", :rel => "stylesheet"}/
    %link{:href => "./css/jquery-ui.min.css", :rel => "stylesheet"}/
    %link{:href => "./lib/codemirror/codemirror.css", :rel => "stylesheet"}/
    %link{:href => "./lib/monokai.css", :rel => "stylesheet"}/
    %link{:href => "./lib/codemirror/addon/show-hint.css", :rel => "stylesheet"}/
    %link{:href => "./favicon.ico", :rel => "shortcut icon", :type => "image/x-icon"}/
    %script{:src => "./axios.min.js"}
    %script{:src => "./vis-network.min.js"}
    %script{:src => "./lib/dat.gui.min.js"}
    %script{:src => "./manipulations.js"}
    %script{:src => "./lib/jquery-3.5.1.min.js"}
    %script{:src => "./lib/jquery-ui.min.js"}
    %script{:src => "./lib/pg_parser_browserified.js", :type => "text/javascript"}
    %script{:src => "./lib/json2pg_browserified.js", :type => "text/javascript"}
    %script{:src => "./lib/codemirror/codemirror.js"}
    %script{:src => "./lib/codemirror/simple.js"}
    %script{:src => "./lib/codemirror/pg_mode.js"}
    %script{:src => "./lib/codemirror/mark-selection.js"}
    %script{:src => "./lib/codemirror/addon/show-hint.js"}
    %script{:src => "./lib/codemirror/addon/anyword-hint.js"}
    %script{:src => "./lib/util.js"}
    %script{:src => "./lib/diff.js"}
    %script{:src => "./config.js"}
    %script{:src => "./gui.js"}
    %script{:src => "./animation.js"}

    :css
      #network-popUp {
          display: none;
          position: absolute;
          top: 350px;
          left: 170px;
          z-index: 299;
          width: 250px;
          background-color: #f9f9f9;
          border-style: solid;
          border-width: 3px;
          border-color: #5394ed;
          padding: 10px;
          text-align: center;
      }

      .dg.main .close-button {
          background-color: rgba(0, 0, 0, 0.7);
      }

      .dg.main .close-button:hover {
          background-color: rgba(0, 0, 0, 0.7);
      }

      .dg li:not(.folder) {
          background: rgba(0, 0, 0, 0.7);
      }

      .dg li.title {
          background: rgba(0, 0, 0, 0.7) url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;
      }

      #pg-area {
        height:100%
      }


      #search-area {
        position: absolute;
        left: 50px;
        top: 50px;
        width: 600px;
        z-index: 999;
      }

      #search-input {
        background: rgba(255, 255, 255, 0.7);
      }

      #search-button {
        background: rgba(0, 160, 160, 0.7);
      }

      #input-area {
        left: 0;
        width: 50%;
      }

      #config-area {
        flex: 1;
        height: 0%;
      }

      #graph-pane {
        flex: 1;
      }

      .ui-resizable-handle {
        background: #cccccc;
      }
      
      #main-area {
        display: inline-flex;
        width: 100%;
        height: 100%;
      }


      .btn {
        position: absolute;
        width: 40px;
        height: 40px;
        right: 10px;
        bottom: 10px;
      }

      #share-btn {
        right: 10px;
      }

      #export-btn {
        right: 60px;
      }

      #config-btn {
        left: 10px;
        z-index: 999;
      }
      
      span .highlighted {
        background: rgba(200, 200, 0, 0.5);
      }

      .CodeMirror-selected  { background-color: rgba(200, 200, 100, 0.5) !important; }

  %body
    #network-popUp
      %span#operation node
      %br/
      %table{:style => "margin: auto"}
        %tbody#popup-table
      %input#saveButton{:type => "button", :value => "save"}/
      %input#cancelButton{:type => "button", :value => "cancel"}/
    #search-area.d-none
      .row
        .col-6.pr-0.pl-4
          %input#search-input.form-control{"aria-label" => "", :placeholder => "Free Search", :type => "text"}/
        .col-2.mx-0.px-0
          %button.mx-0.btn.btn-info#search-button{:type => "button"}
            %span.fa.fa-search#search-icon
            Search
    #main-area
      #input-area.vh-100
        #pg-area
          -#%input#pgfile{:type => "file"}/
          %input#url-input.d-none/
          %textarea.vh-100#graph-input{:style => "height: 100%; width: 100%;"}
            I :person name:"your name"
            You :person
            Graph :graph
            I -> Graph :say word:Hello date:today
            You -> I :say word:Goodbye date:yesterday
        #config-area
          %textarea#config-input{:style => "height: 100%; width: 100%;"}
      #graph-pane.vh-100
        #graph.bg-light.vh-100
      #config-btn.btn.btn-info{:title => "Config"}
        %span{:class => "ion-android-settings"}
      #export-btn.btn.btn-success{:title => "Export"}
        %span{:class => "ion-android-download"}
      #share-btn.btn.btn-info{:title => "Share"}
        %span{:class => "ion-android-share-alt"}
    :javascript
      'use strict';
          const q = document.querySelector.bind(document);
          const qa = document.querySelectorAll.bind(document);
          const nodeSize = 25;
          const thresholdToReload = 100;
          let timerId = 0;
          let editor, configEditor;
          let localMode = true;
          let groups = new Set();
          let data, nodeDataSet, edgeDataSet, expandedNodes = [], network;
          let clickedPosition;
          let graph, nodeMap = {}, nodeLineMap = {}, edgeMap = {}, edgeLineMap = {};
          let edgeColorMap;
          let domain;
          let byProgram = false;
          let displayedTimeProps = ["submittedDate"];
          let timeLineEnabled = false;
          let nodeProps, edgeProps;
          let minTime =  new Date(8640000000000000), maxTime = new Date(-8640000000000000);
          let timeInterval = 1;
          let timeProperties = new Set();
          let timeScale = 100.0;
          let lineStart = null, lineEnd = null, srcNode = null;
          let listDisplayedNodeProps, listDisplayedEdgeProps;
          let groupColorMap = {};
          const gui = new dat.GUI({hideable: false});
          const nodeFolder = gui.addFolder('Node');
          const edgeFolder = gui.addFolder('Edge');
          const timeLineFolder = gui.addFolder('TimeLine');

          function onNodeControllerChange(){
            if(!graph)
              return;
            let displayedProps = displayedNodeProps();
            nodeDataSet.update(graph.nodes.map((node) => {
                return {
                  id: node.id,
                  label: createLabelText(node, displayedProps)
                };
              })
            );
            localStorage.setItem('displayedNodeProps', displayedProps);
          };
          
          function onEdgeControllerChange(){
            if(!graph)
              return;

            let displayedProps = displayedEdgeProps();

            edgeDataSet.update(graph.edges.map((edge) => {
                return { id: edge.properties.id ? edge.properties.id[0] : `${edge.from}-${edge.to}`,
                 label: createLabelText(edge, displayedProps) };
              }
            ));
            
            localStorage.setItem('displayedEdgeProps', displayedProps);
          }

          function scrollToLine(loc) {
            byProgram = true;
            editor.scrollIntoView({line: loc.start.line - 1, ch: loc.start.column - 1}, 200);
            editor.setSelection({line: loc.start.line - 1, ch: loc.start.column - 1}, {line: loc.end.line - 1, ch: loc.end.column - 1});
            editor.focus();
          }
          
          function updateTimeLineNodes() {
              if(timeLineEnabled) {
                let nodeCountWithTime = 0;
                graph.nodes.forEach(node => {
                  for(let prop of displayedTimeProps) {
                    let time = node.properties[prop];
                    if(time) {
                      ++nodeCountWithTime;
                      time = new Date(time);
                      minTime = time < minTime ? time : minTime;
                      maxTime = time > maxTime ? time : maxTime;
                    }
                  }
                });
                timeInterval = maxTime.getTime() - minTime.getTime();
                timeScale = nodeCountWithTime * 100;
              }
          }
          
          function calcNodePosition(pgNode) {
              let x, y, fixed, width;
              if(timeLineEnabled) {
                x = null;
                fixed = false;
                let positions = [];
                for(let prop of displayedTimeProps) {
                  if(pgNode.properties[prop] && timeInterval > 0) {
                    positions.push(timeScale * ((new Date(pgNode.properties[prop]).getTime()) - minTime.getTime()) * 1.0 / timeInterval - timeScale * 0.5);
                  }
                }
                if(positions.length > 0) {
                  fixed = true;
                  let max = Math.max(...positions), min = Math.min(...positions);
                  x = (max + min) / 2;
                  width = max - min; 
                } else {
                  x = 0;
                }
                y = 0;
              }
              else {
                if(config.layout == 'custom' &&
                  (pgNode.properties[config.layoutSettings.x] ||
                   pgNode.properties[config.layoutSettings.y])
                  ) {
                  x = parseInt(pgNode.properties[config.layoutSettings.x][0]);
                  y = parseInt(pgNode.properties[config.layoutSettings.y][0]);
                  fixed = true;
                } else {
                  x = null;
                  y = null;
                  fixed = false;
                  width = null;
                }
              }
              return {x, y, fixed, width};
          }
          
          function retrieveHttpUrl(node) {
            let candidates = [];
            for(let entry of Object.entries(node.properties)) { 
              for(let prop of entry[1]) {
                if(typeof(prop) === 'string' && (prop.startsWith("https://") || prop.startsWith("http://"))) {
                  if(entry[0].toLowerCase() == 'url')
                    return prop;
                  candidates.push([entry[0], prop]);
                }
              }
            }
            return candidates[0];
          }
          
          function retrieveThumbnailUrl(node) {
            for(let entry of Object.entries(node.properties)) {
              if(entry[0].toLowerCase() == 'thumbnail') {
                return entry[1][0]
              }
            }
            return null;
          }
      
          function toVisNode(pgNode, props, extraOptions = null) {
              const group = pgNode.labels.join('_');
              groups.add(group);

              let x, y, fixed, width;
              ({x, y, fixed, width} = calcNodePosition(pgNode));
              
              let url = retrieveHttpUrl(pgNode);
              let thumbnailUrl = retrieveThumbnailUrl(pgNode);
              let expanded = expandedNodes.includes(pgNode.id);
              
              let degree =  pgNode.properties['degree'];
              if(degree !== undefined) {
                degree = degree[0];
              } else {
                degree = 2; // assume degree to be two (default)
              }

              let attrs = {
                  id: pgNode.id,
                  group: group,
                  label: createLabelText(pgNode, props),
                  shape: fixed ? 'square' : (degree === 1 || expanded ? 'text' : 'dot'),
                  size: expanded ? 25 : (2 + degree * 8),
                  degree: degree,
                  title: createTitleText(pgNode),
                  fixed: {
                    x: fixed,
                    y: fixed
                  },
                  borderWidth: url ? 3 : 1,
                  url: url,
                  x: x,
                  y: y,
                  font: {
                    color: url ? 'blue' : 'black'
                  },
                  fixedByTime: fixed
              };

              let icon;
              if(icon = config.node.icon[group]) {
                let code = String.fromCharCode(parseInt(icon, 16));
                attrs['shape'] = 'icon';
                attrs['icon'] = {
                  face: 'Ionicons',
                  size: attrs.size * 1.5,
                  code: code,
                  color: 'white'
                };
              }
              
              if(thumbnailUrl) {
                attrs['shape'] = 'image';
                attrs['image'] = thumbnailUrl;
              }
              if(width) {
                attrs['shape'] = 'box';
                attrs['widthConstraint'] = {
                  minimum: width,
                  maximum: width
                }
              }
              attrs = Object.assign(attrs, extraOptions);
              return attrs;
          }
          
          function toVisEdge(pgEdge, props) {
              const edgeLabel = pgEdge.labels.join('_');
              if (!edgeColorMap[edgeLabel]) {
                  edgeColorMap[edgeLabel] = getRandomColor(edgeLabel, config.edge.saturation || '0%', config.edge.brightness || '30%');
              }
              let length = null, lengthProp, width = null, widthProp;
              if(lengthProp = pgEdge.properties[config?.edge?.length?.[edgeLabel]]) {
                length = lengthProp[0];
              }
              if(widthProp = pgEdge.properties[config?.edge?.width?.[edgeLabel]]) {
                width = parseFloat(widthProp[0]);
              }

              const id = pgEdge.properties.id ? pgEdge.properties.id[0] : `${pgEdge.from}-${pgEdge.to}`;
              return {
                  id: id,
                  from: pgEdge.from,
                  to: pgEdge.to,
                  color: edgeColorMap[edgeLabel],
                  label: createLabelText(pgEdge, props),
                  title: createTitleText(pgEdge),
                  remoteId: id,
                  length: length,
                  width: width,
                  hoverWidth: 0.5,
                  smooth:
                  {
                    roundness:1
                  },
                  arrows: {
                    to: {
                      enabled: pgEdge.direction == '->' || pgEdge.undirected === 'false'
                    },
                  }
              }
          }
          
          function wrapText(str, asHtml) {
            if(!str)
              return str;
            if(Array.isArray(str))
              str = str[0];
            const maxWidth = 40;
            let newLineStr = asHtml ? "<br>" : "\n", res = '';
            while (str.length > maxWidth) {
              res += str.slice(0, maxWidth) + newLineStr;
              str = str.slice(maxWidth);
            }
            return res + str;
          }
      
          function createLabelText(elem, props = null) {
              if(props != null) {
                  // Use whitespace instead of empty string if no props are specified because Vis.js cannot update label with empty string)
                return props.length ? props.map((prop) => prop === 'id' ? elem.id : (prop === 'label' ? elem.labels : wrapText(elem.properties[prop]))).filter((val) => val).join('\n') : ' ';
              }
              else if (elem.id) // for nodes
                  return elem.id;
              else // for edges
                  return elem.labels.join("\n");
          }
      
          function createTitleText(elem) {
              let flattend_props = Object.entries(elem.properties).reduce((acc, prop) =>
                  acc.concat(`<tr><td>${prop[0]}</td><td>${wrapText(prop[1], true)}</td></tr>`), []);
              if (elem.id) // for nodes
              {
                  let idText = `<tr><td><b>${elem.id}</b></tr></td>`;
                  flattend_props.splice(0, 0, idText);
                  flattend_props.push(`<tr><td width="100px">label</td><td width="200px">${wrapText(elem.labels.join(':'), true)}</td></tr>`);
              }
              return htmlTitle(`<table style='fixed'>${flattend_props.join('')}</table>`);
          }

          // Create random colors, with str as seed, and with fixed saturation and lightness
          function getRandomColor(str, saturation, brightness) {
              let hash = 0;
              for (let i = 0; i < str.length; i++) {
                  hash = str.charCodeAt(i) + ((hash << 5) - hash);
                  hash = hash & hash;
              }
              let hue = hash % 360;
              return 'hsl(' + hue + `, ${saturation}, ${brightness})`;
          }
      
          function retrieveGraph(node_id, add = false) {
              node_id = node_id || 1;
              domain = q('#url-input').value;
              if (!domain.endsWith('/'))
                  domain += '/';
              domain = 'http://' + domain;
              if(add) {
                const existing = nodeDataSet.get(node_id);
                nodeDataSet.update({
                  id: node_id,
                  shape: existing.fixedByTime ? existing.shape : 'text',
                  size: 25,
                  fixed: true
                });
              }
              // TODO: use query which does not modify of backend
              const subquery = `MATCH p=(n)-[r]-(another) WHERE id(n) in [${node_id}] WITH p, another, size((another)--()) as degree SET another.degree = degree RETURN p`;
              axios.get(domain + `query?q=${subquery}`).then((response) => {
                  if (add) {
                      addGraph(response.data.pg);
                      expandedNodes.push(node_id.toString());
                  } else {
                      expandedNodes = [node_id.toString()];
                      updateGraph(response.data.pg);
                  }
              });
          }
          
          function setSearchState(searching) {
            const icon =  q('#search-icon');
            if(searching) {
              icon.classList.remove("fa-search");
              icon.classList.add("fa-spinner");
              icon.classList.add("fa-spin");
            } else {
              icon.classList.add("fa-search");
              icon.classList.remove("fa-spinner");
              icon.classList.remove("fa-spin");
            }
          }
      
          function searchGraph() {  
              setSearchState(true);
              const keyword = q('#search-input').value;
              // timeProperties.clear();
              domain = q('#url-input').value;
              if (!domain.endsWith('/'))
                  domain += '/';
              domain = 'http://' + domain;
              const keywordPart = encodeURI(keyword.split(" ").map((word) => `\\"${word}\\"`).join(' AND '));
              const query = `CALL db.index.fulltext.queryNodes("allProperties", "${keywordPart}") YIELD node RETURN node`;
              axios.get(domain + `query?q=${query}`).then((response) => {
                  expandedNodes = response.data.pg.nodes.map((node) => node.id);
                  
                  // TODO: use query which does not modify of backend
                  const subquery = `MATCH p=(n)-[r]-(another) WHERE id(n) in [${expandedNodes.join(',')}] WITH p, another, size((another)--()) as degree SET another.degree = degree RETURN p`
                  axios.get(domain + `query?q=${subquery}`).then((subresponse) => {
                    updateGraph(subresponse.data.pg);
                    setSearchState(false);
                  });
              });
          }
          
          
          function displayedNodeProps() {
            return nodeFolder.__controllers.map((con) =>
                  con.__checkbox.checked ? con.property : null).filter((prop) => prop);
          }
          
          function displayedEdgeProps() {
            return edgeFolder.__controllers.map((con) =>
                  con.__checkbox.checked ? con.property : null).filter((prop) => prop);
          }
          
          function isDateString(str) {
            return isNaN(str) && !isNaN(Date.parse(str))
          }
          
          function updateGraph(input, applyDiff = false) {
              groups = new Set();
              edgeColorMap = {};

              let newContent = editor.getValue();
              localStorage.setItem('pg', newContent);
              applyDiff = applyDiff && nodeDataSet && edgeDataSet;
              let lineCount = 0;
              let oldLineCount = 0;
              let diffCount = 0;
              if(applyDiff) {
                let newNodeLineMap = new Map();
                let newEdgeLineMap = new Map();
                Diff.diffLines(oldContent, newContent).forEach(diff => {
                  if(diff.removed) {
                    for(let i = 1; i <= diff.count; ++i) {
                      let existingNode = nodeLineMap[oldLineCount + i];
                      let existingEdge = edgeLineMap[oldLineCount + i];
                      if(existingNode) {
                        delete nodeMap[existingNode.id];
                        nodeDataSet.remove(existingNode);
                        graph.nodes = graph.nodes.filter(item => item.id != existingNode.id);
                      }
                      if(existingEdge) {
                        delete edgeMap[existingEdge.id];
                        edgeDataSet.remove(existingEdge);
                        graph.edges = graph.edges.filter(item => item.from != existingEdge.from && item.to != existingEdge.to);
                      }
                    }
                    diffCount += diff.count;
                    oldLineCount += diff.count;
                  }
                  else if(diff.added) {
                    let addedPg = pgParser.parse(diff.value);
                    addedPg.nodes.forEach(node => {
                      if(nodeMap[node.id]) return;
                      node.line += lineCount;
                      let visNode = toVisNode(node);
                      nodeDataSet.update(visNode);
                      newNodeLineMap[node.line] = node;
                      nodeMap[node.id] = node;                      
                    })
                    graph.nodes = graph.nodes.concat(addedPg.nodes);
                    addedPg.edges.forEach(edge => {
                      edge.line += lineCount;
                      let visEdge = toVisEdge(edge);
                      edgeDataSet.update(visEdge);
                      newEdgeLineMap[edge.line] = visEdge;
                      edgeMap[visEdge.id] = edge;
                    })
                    graph.edges = graph.edges.concat(addedPg.edges);
                    diffCount += diff.count;
                    lineCount += diff.count;
                  } else {
                    for(let i = 1; i <= diff.count; ++i) {
                      let existingNode = nodeLineMap[oldLineCount + i];
                      let existingEdge = edgeLineMap[oldLineCount + i];
                      if(existingNode)
                        existingNode.line = lineCount + i;
                      if(existingEdge) {
                        existingEdge.line = lineCount + i;
                        edgeMap[existingEdge.id].line = existingEdge.line;
                      }
                      newNodeLineMap[lineCount + i] = existingNode;
                      newEdgeLineMap[lineCount + i] = existingEdge;
                    }
                    lineCount += diff.count;
                    oldLineCount += diff.count;
                  }
                });
                nodeLineMap = newNodeLineMap;
                edgeLineMap = newEdgeLineMap;
              }
              oldContent = newContent;
              if(applyDiff && diffCount < thresholdToReload) return;

      
              input = input || editor.getValue();
              if (typeof input === 'string' || input instanceof String) {
                  try {
                      graph = JSON.parse(input);
                  } catch (err) {
                      if (err instanceof SyntaxError)
                          graph = pgParser.parse(input);
                      else
                          throw err;
                  }
              } else {
                  graph = input;
              }
              
              minTime =  new Date(8640000000000000), maxTime = new Date(-8640000000000000);
              
              
              graph.nodes.forEach(node => { 
                for(let prop of Object.keys(node.properties)) {
                  if(!timeProperties.has(prop) && isDateString(node.properties[prop])){
                    timeProperties.add(prop);
                  }
                }
              });
              
              
              while(timeLineFolder.__controllers.length > 0) timeLineFolder.__controllers[0].remove();
              
              for(let prop of timeProperties) {
                let controller = timeLineFolder.add({[prop]: false}, prop, false);
                controller.onChange(onTimeLinePropertyController);
              }

              nodeProps = new Set(['id', 'label']);
              edgeProps = new Set(['label']);
              graph.nodes.forEach((node) => {
                nodeMap[node.id] = node;
                for(let i = node.location.start.line; i <= node.location.end.line; i++)
                  nodeLineMap[i] = node;
                Object.keys(node.properties).filter((prop) => prop != 'degree').forEach(nodeProps.add, nodeProps);
              });
              graph.edges.forEach((edge) => {
                Object.keys(edge.properties).forEach(edgeProps.add, edgeProps);
              });
              
              const defaultNodePropsFilter = new RegExp('name|title', 'i');
              const defaultEdgePropsFilter = new RegExp('label', 'i');
              let defaultNodeProps = displayedNodeProps();
              let defaultEdgeProps = displayedEdgeProps();
              
              if(defaultNodeProps.length == 0) { // Initial value
                defaultNodeProps = Array.from(nodeProps).filter((prop) => defaultNodePropsFilter.test(prop));
                defaultEdgeProps = Array.from(edgeProps).filter((prop) => defaultEdgePropsFilter.test(prop));
              }

              
              if(defaultNodeProps.length == 0) defaultNodeProps = ['id'];

              nodeDataSet = new vis.DataSet();
              nodeDataSet.add(graph.nodes.map((node) => {
                  return toVisNode(node, defaultNodeProps);
              }));
              
              updateTimeLineNodes();

              edgeDataSet = new vis.DataSet(graph.edges.map((edge) => {
                  const edgeLabel = edge.labels.join('_');
                  let visEdge = toVisEdge(edge, defaultEdgeProps);
                  edgeMap[visEdge.id] = edge;
                  for(let i = edge.location.start.line; i <= edge.location.end.line; i++)
                      edgeLineMap[i] = visEdge;
                  return visEdge;
              }));
              // create a network
              let container = document.getElementById('graph');
              data = {
                  nodes: nodeDataSet,
                  edges: edgeDataSet
              };
              
              
              while(nodeFolder.__controllers.length > 0) nodeFolder.__controllers[0].remove();
              while(edgeFolder.__controllers.length > 0) edgeFolder.__controllers[0].remove();
              
              nodeProps.forEach(prop => {
                  const controller = nodeFolder.add({[prop]: defaultNodeProps.includes(prop)}, prop)
                  controller.onChange(onNodeControllerChange);
                }
              );
              
              edgeProps.forEach(prop => {
                  const controller = edgeFolder.add({[prop]: defaultEdgeProps.includes(prop)}, prop)
                  controller.onChange(onEdgeControllerChange);
                }
              );

              let layout = {
                randomSeed: 1
              };
              
              if(config.layout == 'hierarchical') {
                layout.hierarchical = config.layoutSettings;
              }

              groupColorMap =  [...groups].reduce((acc, group) => {
                      acc[group] = {color: getRandomColor(group, config.node.saturation || '100%', config.node.brightness || '40%')}; return acc;
              }, {});

              let options = {
                  groups: groupColorMap,
                  layout:
                    layout,
                  interaction: {
                      hover: true
                  },
                  physics: {
                    barnesHut: {
                      springConstant: 0.016
                    },
                    stabilization: {
                        enabled: false,
                        iterations: 200,
                        updateInterval: 25
                    }
                  },
                  manipulation: false,

                  edges: {
                      arrows: {
                          to: {
                              enabled: true,
                              scaleFactor: 0.3,
                              type: "arrow"
                          },
                      },
                  },
                  nodes: {
                      title: 'hover',
                  }
              };
              network = new vis.Network(container, data, options);

              let selectTimer = null;
              network.on('selectNode', (e) => { 
                  if (e.nodes.length > 0) {
                    if(!localMode) {
                      selectTimer = setTimeout(() => retrieveGraph(e.nodes[0], true), 300);
                    }
                  }
              });

              network.on('doubleClick', (e) => {
                  if (localMode) {
                    if(e.nodes.length == 0) {
                      let newNode = {
                        id: newNodeId(),
                        labels: ['New'],
                        properties: {},
                      };
                      addNewNode(newNode, e.pointer.canvas.x, e.pointer.canvas.y);
                    } else {
                       const position = e.pointer.canvas;
                       const node = e.nodes[0];
                       lineStart = position;
                       srcNode = node;
                       nodeDataSet.update({id: node, fixed: {x: true, y: true}});
                    }
                  }
                  else if (e.nodes.length > 0)
                      retrieveGraph(e.nodes[0]);
              });

              network.on('dragStart', (e) => {
                  clearTimeout(selectTimer);
                  srcNode = lineStart = lineEnd = null;
                  const node = nodeDataSet.get(e.nodes[0]);
                  if(e.nodes.length > 0) {
                    nodeDataSet.update({
                      id: e.nodes[0],
                      fixed: node.fixedByTime ? {x: true, y: true } : false
                    });
                  }
              });

              if (!localMode) {
                  network.on('doubleClick', (e) => {
                      if (e.nodes.length > 0)
                          retrieveGraph(e.nodes[0]);
                  });
                  network.on('dragEnd', (e) => {
                      if(e.nodes.length > 0) {
                        const node = nodeDataSet.get(e.nodes[0]);
                        if(!node.fixed && expandedNodes.includes(e.nodes[0]) )
                        nodeDataSet.update({
                          id: e.nodes[0],
                          fixed: true
                        });
                      }
                  });
              }
              let canvas = q(".vis-network canvas");

              function getMousePos(canvas, evt) {
                var rect = canvas.getBoundingClientRect();
                return {
                  x: evt.clientX - rect.left,
                  y: evt.clientY - rect.top
                };
              }
              canvas.addEventListener('mousemove', event =>
              {
                if(lineStart) {
                  lineEnd = network.DOMtoCanvas(getMousePos(canvas, event));
                  network.redraw();
                }
              });
              
              network.on("hoverNode", (e) => {
                network.canvas.body.container.style.cursor = 'default';
                const node = nodeDataSet.get(e.node);
                if(node && node.url) {
                  network.canvas.body.container.style.cursor = 'pointer';
                  nodeDataSet.update({
                    id: e.node,
                    color: '#8888ff',
                  });
                } else if(node && node.degree > 1 && !expandedNodes.includes(e.node)) {
                  network.canvas.body.container.style.cursor = 'pointer';
                }
              });
              
              function plotTimes(startTime, interval, intervalUnit, timeForOnePixel, offsetX, offsetY, rightMostX, context, scale) {
                let currentTime = new Date(startTime);
                switch(intervalUnit) {
                  case 'year':
                    currentTime = new Date(currentTime.getFullYear(), 0, 1);
                    break; 
                  case 'month':
                    currentTime = new Date(currentTime.getFullYear(), currentTime.getMonth() - currentTime.getMonth() % interval, 1);
                    break; 
                  case 'day':
                    currentTime = new Date(currentTime.getFullYear(), currentTime.getMonth(), currentTime.getDate());
                    break;
                  default:
                    return; 
                }
                while(true) {
                  const nextPosition = -offsetX + (currentTime - startTime) / timeForOnePixel;
                  if(nextPosition > rightMostX) break;
                  context.fillText(currentTime.toLocaleDateString(), nextPosition, -offsetY);
                  context.moveTo(nextPosition, -offsetY);
                  context.lineTo(nextPosition, -offsetY + 25 / scale);
                  context.stroke();
                  switch(intervalUnit) {
                    case 'year':
                      currentTime.setFullYear(currentTime.getFullYear() + interval);
                      break; 
                    case 'month':
                      currentTime.setMonth(currentTime.getMonth() + interval);
                      break; 
                    case 'day':
                      currentTime.setDate(currentTime.getDate() + interval);
                      break;
                    default:
                      return; 
                  }
                }
              }

              network.on("beforeDrawing", (ctx) => {
                for(let node of graph.nodes) {
                  node = nodeDataSet.get(node.id);
                  if(node.shape == 'icon') {
                    let position = network.getPosition(node.id);
                    let color = groupColorMap[node.group]?.color || getRandomColor('', config.node.saturation || '100%', config.node.brightness || '40%');
                    ctx.strokeStyle = "#294475";
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(
                      position.x,
                      position.y,
                      node.size,
                      0,
                      2 * Math.PI,
                      false
                    );
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                  }
                }
              });
              
              network.on("afterDrawing", (ctx) => {
                if(lineStart && lineEnd) {
                  ctx.beginPath();
                  ctx.moveTo(lineStart.x, lineStart.y);
                  ctx.lineTo(lineEnd.x, lineEnd.y);
                  ctx.stroke();
                }
                if(timeLineEnabled){
                  const context = network.canvas.getContext("2d");
                  const view = network.canvas.body.view;
                  const offsetY = view.translation.y / view.scale;
                  const offsetX = view.translation.x / view.scale;
                  const timeForOnePixel = (maxTime - minTime) / timeScale;
                  const timeOnLeftEdge = new Date(((maxTime.getTime() + minTime.getTime()) / 2) - timeForOnePixel * offsetX);
                  const clientWidth = network.canvas.body.container.clientWidth;
                  const rightMost = -offsetX + clientWidth / view.scale;
                  const oneMonth = 31 * 24 * 60 * 60 * 1000;
                  const oneDay = 24 * 60 * 60 * 1000;
                  const twoMonth = oneMonth * 2;
                  const fourMonth = twoMonth * 2;
                  const oneYear = 365 * oneDay;
                  const minDistance = 300;
                  context.font = (20 / view.scale).toString() + "px Arial";
                  const minimumInterval = timeForOnePixel * minDistance / view.scale;
                  if(minimumInterval > oneYear ) {
                    plotTimes(timeOnLeftEdge, 1, 'year', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
                  }
                  else if(minimumInterval > fourMonth ) {
                    plotTimes(timeOnLeftEdge, 4, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
                  }
                  else if(minimumInterval > twoMonth) {
                    plotTimes(timeOnLeftEdge, 2, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
                  }
                  else if(minimumInterval > oneMonth) {
                    plotTimes(timeOnLeftEdge, 1, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
                  } else if(minimumInterval > oneDay * 16) {
                    plotTimes(timeOnLeftEdge, 16, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
                  } else if(minimumInterval > oneDay * 8) {
                    plotTimes(timeOnLeftEdge, 8, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
                  } else if(minimumInterval > oneDay * 4) {
                    plotTimes(timeOnLeftEdge, 4, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
                  } else if(minimumInterval > oneDay * 2) {
                    plotTimes(timeOnLeftEdge, 2, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
                  } else {
                    plotTimes(timeOnLeftEdge, 1, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
                  }
                }
              });
              network.on("blurNode", (params) => {
                  network.canvas.body.container.style.cursor = 'default';
                  let node = nodeDataSet.get(params.node);
                  if(node && node.url) {
                    nodeDataSet.update({
                      id: params.node,
                      color: null,
                    });
                  }
              });
          
              network.on("click", (e) => {
                 network.stopSimulation();
                 if(e.nodes.length > 0) {
                    let node = nodeDataSet.get(e.nodes[0]);
                    if(srcNode) {
                      let newEdge = {
                        from: srcNode,
                        to: node.id,
                        undirected: false,
                        labels: [],
                        properties: {}
                      };
                      graph.edges.push(newEdge);
                      let visEdge = toVisEdge(newEdge);
                      edgeMap[visEdge.id] = newEdge
                      edgeDataSet.add(visEdge);

                      let oldPg = editor.getValue();
                      newEdge.line = numberOfLines(oldPg) + 1;
                      byProgram = true;
                      editor.setValue(oldPg + `\n"${newEdge.from}" -> "${newEdge.to}" ${newEdge.labels.map((label) => ':' + label).join(' ')} `);
                      // scrollToLine({start: newEdge.line, end: newEdge.line});
                      srcNode = null;
                      lineStart = null;
                      lineEnd = null;
                    } else if(localMode) {
                      scrollToLine(nodeMap[e.nodes[0]].location);
                    }
                    if(node && node.url)
                      window.open(node.url,'_blank');
                } else if(e.edges.length > 0) {
                  scrollToLine(edgeMap[e.edges[0]].location);
                }
              });
          }
      
          function addGraph(newGraph) {
              let newNodes = newGraph.nodes.filter((n) => !nodeDataSet._data.has(n.id));
              let newEdges = newGraph.edges.filter((e) => !(expandedNodes.includes(e.from) || expandedNodes.includes(e.to)));
              graph.nodes = graph.nodes.concat(newNodes);
              graph.edges = graph.edges.concat(newEdges);
      
              nodeDataSet.add(newNodes.map((node) => {
                  return toVisNode(node, displayedNodeProps());
              }));
              
              edgeDataSet.add(newEdges.map((edge) => {
                  let visEdge = toVisEdge(edge, displayedEdgeProps());
                  edgeMap[visEdge.id] = edge;
                  return visEdge;
              }));
      
          }
          
      
          function handleFileSelect(evt) {
              let files = evt.target.files; // FileList object
              // use the 1st file from the list
              const f = files[0];
              let reader = new FileReader();
      
      
              // Closure to capture the file information.
              reader.onload = (function (theFile) {
                  return function (e) {
                      editor.setValue(e.target.result);
                      updateGraph();
                  };
              })(f);
              // Read in the image file as a data URL.
              reader.readAsText(f);
          };

          editor = CodeMirror.fromTextArea(q('#graph-input'), {
            lineNumbers: true,
            viewportMargin: Infinity,
            theme: "monokai",
            lineWrapping: true,
            mode: "pgMode",
            extraKeys: {
              Tab: 'autocomplete'
            },
            hintOptions: {
              completeSingle: false
            }
          });
          editor.setSize('100%', '100%');

          configEditor = CodeMirror.fromTextArea(q('#config-input'), {
            viewportMargin: Infinity,
            theme: "monokai",
            lineWrapping: true,
            extraKeys: {
              Tab: 'autocomplete'
            },
            hintOptions: {
              completeSingle: false
            }
          });
          configEditor.setSize('100%', '100%');
          
          const urlParams = new URLSearchParams(window.location.search);
          let pgInParam = urlParams.get('pg'), nodePropInParam = urlParams.get('displayedNodeProps'),
              edgePropInParam = urlParams.get('displayedEdgeProps');
          if(pgInParam || nodePropInParam || edgePropInParam) {
            if(pgInParam)
              localStorage.setItem('pg', pgInParam);
            if(nodePropInParam)
              localStorage.setItem('displayedNodeProps', nodePropInParam);
            if(edgePropInParam)
              localStorage.setItem('displayedEdgeProps', edgePropInParam);
            window.location.href = window.location.href.split('?')[0]; // Jump to URL without query parameter
          }


          
          let query = urlParams.get('query');
          let initialPg = loadConfig('pg');
          if(query) {
            editor.setValue('');
            axios.get(config.remoteUrl + query).then((response) => {
              editor.setValue(json2pg.translate(JSON.stringify(response.data.pg)));
            });
          }
          else if(initialPg) {
            editor.setValue(initialPg);
          }

          if (loadConfig('config') != '') {
            config = JSON.parse(loadConfig('config'));
          }
          configEditor.setValue(JSON.stringify(config, null, 2));
          configEditor.on('change', (delta) => {
            clearTimeout(timerId);
            timerId = setTimeout(() => {
              localStorage.setItem('config', configEditor.getValue());
              config = JSON.parse(configEditor.getValue());
              updateGraph(null, false);
            }, 1000);            
          });
          
          document.addEventListener('mousemove', (e) => {
            clickedPosition = {x: e.clientX, y: e.clientY};
          });
          // q('#pgfile').addEventListener('change', handleFileSelect, false);

          q('#url-input').value = 'localhost:3000';
          // retrieveGraph();
          /*  updateGraph(); */

          let oldContent = '';

          editor.on("inputRead", (instance) => {
            editor.execCommand('autocomplete', { completeSingle: false });
          });

          editor.on('change', (delta) => {
            if(!byProgram) {
              clearTimeout(timerId);
              localMode = true;
              timerId = setTimeout(updateGraph, 1000);
            } else {
              byProgram = false;
            }
          });
          
          editor.on('cursorActivity', (doc) => {
            if(!byProgram) {
              const node = nodeLineMap[doc.getCursor().line + 1];
              const edge = edgeLineMap[doc.getCursor().line + 1];

              if(node) {
                scrollIntoView(network.getPosition(node.id));
                network.selectNodes([node.id]);
              } else if(edge){
                const from = network.getPosition(edge.from);
                const to = network.getPosition(edge.to);
                scrollIntoView({ x: (from.x + to.x) / 2, y: (from.y + to.y) /2 });
                network.selectEdges([edge.id]);
              }
            } else {
              byProgram = false;
            }
          });

          q('#search-input').addEventListener('keyup', () => {
            if (event.keyCode == 13) // Enter
              q('#search-button').click(); 
          });
      
          q('#search-button').addEventListener('click', () => {
            searchGraph();
          });
      
          q('#url-input').addEventListener('change', () => {
              clearTimeout(timerId);
              localMode = false;
              timerId = setTimeout(retrieveGraph, 1000);
          });

          q('#share-btn').addEventListener('click', () => {
            let url = `https://g2glab.github.io/hellograph?pg=${encodeURIComponent(editor.getValue())}` +
                      `&displayedNodeProps=${encodeURIComponent(listDisplayedNodeProps)}` +
                      `&displayedEdgeProps=${encodeURIComponent(listDisplayedEdgeProps)}`;
            let data = [new ClipboardItem({ 'text/plain': new Blob([url], { type: "text/plain"})})];
            navigator.clipboard.write(data).then(function() {
              alert("Your graph is now on clipboard!")
            });
          });

          q('#export-btn').addEventListener('click', () => {
            download(editor.getValue(), 'graph_' + currentTimeString() + '.pg', 'text/plain');
          });

          q('#config-btn').addEventListener('click', () => {
            let x = $('#config-area').css('height');
            if ($('#config-area').css('height') == '0px') {
              $('#pg-area').css('height', '50%');
              $('#config-area').css('height', '50%');
            } else {
              $('#pg-area').css('height', '100%');
              $('#config-area').css('height', '0%');
            }
            onConfigResize(null, null);
          });
          
          // searchGraph();
          if (document.fonts) {
          // Decent browsers: Make sure the fonts are loaded.
          document.fonts.load('normal normal 400 24px/1 "FontAwesome"')
            .catch(
              console.error.bind(console, "Failed to load Font Awesome 4.")
            ).then(function () {
              // create a network
              updateGraph();
            })
            .catch(
              console.error.bind(
                console,
                "Failed to render the network with Font Awesome 4."
              )
            );
          }


          function onResize(event, ui) {
            const totalWidth = $("#main-area").width();
            let width = $("#input-area").width();
            if(width > totalWidth) {
                width = totalWidth;
                $('#input-area').css('width', width);
            }
            $('#graph-pane').css('width', (totalWidth - width) - 100);
          };

          function onConfigResize(event, ui) {
            const totalHeight = $("#input-area").height();
            let height = $("#pg-area").height();
            if(height > totalHeight) {
                height = totalHeight;
            }
            $('#pg-area').css('height', height);
            $('#config-area').css('height', (totalHeight - height));
            $('#config-btn').css('bottom', (totalHeight - height) + 10);
          };


          $('#input-area').resizable({handles: "e,s", grid: [1, 10000]}).bind( "resize", onResize);
          $('#pg-area').resizable({handles: "s", grid: [10000, 1]}).bind("resize", onConfigResize);
          
          listDisplayedNodeProps = loadConfig('displayedNodeProps');

          if(listDisplayedNodeProps) {
            nodeFolder.__controllers.forEach(con => {
              con.__checkbox.checked = listDisplayedNodeProps.includes(con.property);
            });
            onNodeControllerChange();
          }
          
          listDisplayedEdgeProps = loadConfig('displayedEdgeProps') || ['label', 'word']; // Show 'word' if pg is default
          if(listDisplayedEdgeProps) {
            edgeFolder.__controllers.forEach(con => {
              con.__checkbox.checked = listDisplayedEdgeProps.includes(con.property);
            });
            onEdgeControllerChange();
          }
