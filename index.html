<!DOCTYPE html>
<html>
<head>
<title>Hello Graph</title>
<link crossorigin='anonymous' href='https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css' integrity='sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css' rel='stylesheet'>
<link href='./css/jquery-ui.min.css' rel='stylesheet'>
<link href='./lib/codemirror/codemirror.css' rel='stylesheet'>
<link href='./lib/monokai.css' rel='stylesheet'>
<script src='./axios.min.js'></script>
<script src='./vis-network.min.js'></script>
<script src='./lib/dat.gui.min.js'></script>
<script src='./manipulations.js'></script>
<script src='./lib/jquery-3.5.1.min.js'></script>
<script src='./lib/jquery-ui.min.js'></script>
<script src='./lib/pg_parser_browserified.js' type='text/javascript'></script>
<script src='./lib/json2pg_browserified.js' type='text/javascript'></script>
<script src='./lib/codemirror/codemirror.js'></script>
<script src='./lib/codemirror/simple.js'></script>
<script src='./lib/codemirror/pg_mode.js'></script>
<style>
  #network-popUp {
      display: none;
      position: absolute;
      top: 350px;
      left: 170px;
      z-index: 299;
      width: 250px;
      background-color: #f9f9f9;
      border-style: solid;
      border-width: 3px;
      border-color: #5394ed;
      padding: 10px;
      text-align: center;
  }
  
  .dg.main .close-button {
      background-color: rgba(0, 0, 0, 0.7);
  }
  
  .dg.main .close-button:hover {
      background-color: rgba(0, 0, 0, 0.7);
  }
  
  .dg li:not(.folder) {
      background: rgba(0, 0, 0, 0.7);
  }
  
  .dg li.title {
      background: rgba(0, 0, 0, 0.7) url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;
  }
  
  #search-area {
    position: absolute;
    left: 50px;
    top: 50px;
    width: 600px;
    z-index: 999;
  }
  
  #search-input {
    background: rgba(255, 255, 255, 0.7);
  }
  
  #search-button {
    background: rgba(0, 160, 160, 0.7);
  }
  
  #input-area {
    left: 0;
    width: 50%;
  }
  
  #graph-pane {
    flex: 1;
  }
  
  .ui-resizable-e {
    background: #cccccc;
  }
  #main-area {
    display: inline-flex;
    width: 100%;
    height: 100%;
  }
</style>
</head>
<body>
<div id='network-popUp'>
<span id='operation'>node</span>
<br>
<table style='margin: auto'>
<tbody id='popup-table'></tbody>
</table>
<input id='saveButton' type='button' value='save'>
<input id='cancelButton' type='button' value='cancel'>
</div>
<div class='d-none' id='search-area'>
<div class='row'>
<div class='col-6 pr-0 pl-4'>
<input aria-label='' class='form-control' id='search-input' placeholder='Free Search' type='text'>
</div>
<div class='col-2 mx-0 px-0'>
<button class='mx-0 btn btn-info' id='search-button' type='button'>
<span class='fa fa-search' id='search-icon'></span>
Search
</button>
</div>
</div>
</div>
<div id='main-area'>
<div class='vh-100' id='input-area'>
<input class='d-none' id='url-input'>
<textarea class='vh-100' id='graph-input' style='height: 100%; width: 100%;'>node1 :You name:"your name"
node2 :Graph type:"graph"
node1 -> node2 :Hello! on:"today"</textarea>
</div>
<div class='vh-100' id='graph-pane'>
<div class='bg-light vh-100' id='graph'></div>
</div>
</div>
<script>
  'use strict';
      const q = document.querySelector.bind(document);
      const qa = document.querySelectorAll.bind(document);
      const nodeSize = 25;
      let timerId = 0;
      let editor;
      let localMode = false;
      let groups = new Set();
      let data, nodeDataSet, edgeDataSet, expandedNodes = [], network;
      let clickedPosition;
      let graph, nodeMap = new Map(), edgeMap = new Map();
      let edgeColorMap;
      let domain;
      let displayedTimeProps = ["submittedDate"]; 
      let timeLineEnabled = false;
      let nodeProps, edgeProps;
      let minTime =  new Date(8640000000000000), maxTime = new Date(-8640000000000000);
      let timeInterval = 1;
      let timeProperties = new Set();
      let timeScale = 100.0;
      const gui = new dat.GUI({hideable: false});
      const nodeFolder = gui.addFolder('Node');
      const edgeFolder = gui.addFolder('Edge');
      const timeLineFolder = gui.addFolder('TimeLine');
      const physicsController = gui.add({physics: false}, 'physics');
      
      function onNodeControllerChange(){
        let displayedProps = displayedNodeProps();
        nodeDataSet.update(graph.nodes.map((node) => {
            return {
              id: node.id,
              label: createLabelText(node, displayedProps)
            };
          })
        );
      };
      
      function updateTimeLineNodes() {
          if(timeLineEnabled) {
            let nodeCountWithTime = 0;
            graph.nodes.forEach(node => { 
              nodeMap[node.id] = node;
              for(let prop of displayedTimeProps) {
                let time = node.properties[prop];
                if(time) {
                  ++nodeCountWithTime;
                  time = new Date(time);
                  minTime = time < minTime ? time : minTime;
                  maxTime = time > maxTime ? time : maxTime;
                }
              }
            });
            timeInterval = maxTime.getTime() - minTime.getTime();
            timeScale = nodeCountWithTime * 100;
          }
      }
      
      function calcNodePosition(pgNode) {
          let x, y, fixed, width;
          if(timeLineEnabled) {
            x = null;
            fixed = false;
            let positions = [];
            for(let prop of displayedTimeProps) {
              if(pgNode.properties[prop] && timeInterval > 0) {
                positions.push(timeScale * ((new Date(pgNode.properties[prop]).getTime()) - minTime.getTime()) * 1.0 / timeInterval - timeScale * 0.5);
              }
            }
            if(positions.length > 0) {
              fixed = true;
              let max = Math.max(...positions), min = Math.min(...positions);
              x = (max + min) / 2;
              width = max - min; 
            } else {
              x = 0;
            }
            y = 0;
          }
          else {
            x = null;
            y = null;
            fixed = false;
            width = null;
          }
          return {x, y, fixed, width};
      }
      
      function retrieveHttpUrl(node) {
        let candidates = [];
        for(let entry of Object.entries(node.properties)) { 
          for(let prop of entry[1]) {
            if(typeof(prop) === 'string' && (prop.startsWith("https://") || prop.startsWith("http://"))) {
              if(entry[0].toLowerCase() == 'url')
                return prop;
              candidates.push([entry[0], prop]);
            }
          }
        }
        return candidates[0];
      }
      
      function retrieveThumbnailUrl(node) {
        for(let entry of Object.entries(node.properties)) {
          if(entry[0].toLowerCase() == 'thumbnail') {
            return entry[1][0]
          }
        }
        return null;
      }
  
      function toVisNode(pgNode, group, props, extraOptions = null) {
          let x, y, fixed, width;
          ({x, y, fixed, width} = calcNodePosition(pgNode));
          
          let url = retrieveHttpUrl(pgNode);
          let thumbnailUrl = retrieveThumbnailUrl(pgNode);
          let expanded = expandedNodes.includes(pgNode.id);
          
          let degree =  pgNode.properties['degree'];
          if(degree !== undefined) {
            degree = degree[0];
          } else {
            degree = 2; // assume degree to be two (default)
          }
  
          let attrs = {
              id: pgNode.id,
              group: group,
              label: createLabelText(pgNode, props),
              shape: fixed ? 'square' : (degree === 1 || expanded ? 'text' : 'dot'),
              size: expanded ? 25 : (2 + degree * 8),
              degree: degree,
              title: createTitleText(pgNode),
              fixed: {
                x: fixed,
                y: false
              },
              borderWidth: url ? 3 : 1,
              url: url,
              x: x,
              y: y,
              font: {
                color: url ? 'blue' : 'black'
              },
              fixedByTime: fixed
          };
          if(thumbnailUrl) {
            attrs['shape'] = 'image';
            attrs['image'] = thumbnailUrl;
          }
          if(width) {
            attrs['shape'] = 'box';
            attrs['widthConstraint'] = {
              minimum: width,
              maximum: width
            }
          }
          attrs = Object.assign(attrs, extraOptions);
          return attrs;
      }
      
      function toVisEdge(pgEdge, group, props) {
          const id = pgEdge.properties.id ? pgEdge.properties.id[0] : `${pgEdge.from}-${pgEdge.to}`;
          return {
              id: id,
              from: pgEdge.from,
              to: pgEdge.to,
              color: edgeColorMap[group],
              label: createLabelText(pgEdge, props),
              title: createTitleText(pgEdge),
              remoteId: id
          }
      }
      
      function wrapText(str, asHtml) {
        if(!str)
          return str;
        if(Array.isArray(str))
          str = str[0];
        const maxWidth = 20;
        let newLineStr = asHtml ? "<br>" : "\n", res = '';
        while (str.length > maxWidth) {
          res += str.slice(0, maxWidth) + newLineStr;
          str = str.slice(maxWidth);
        }
        return res + str;
      }
  
      function createLabelText(elem, props = null) {
          if(props != null) {
              // Use whitespace instead of empty string if no props are specified because Vis.js cannot update label with empty string)
            return props.length ? props.map((prop) => prop == 'label' ? elem.labels : wrapText(elem.properties[prop])).filter((val) => val).join('\n') : ' ';
          }
          else if (elem.id) // for nodes
              return elem.id;
          else // for edges
              return elem.labels.join("\n");
      }
  
      function createTitleText(elem) {
          let flattend_props = Object.entries(elem.properties).reduce((acc, prop) =>
              acc.concat(`<tr><td>${prop[0]}</td><td>${wrapText(prop[1], true)}</td></tr>`), []);
          if (elem.id) // for nodes
              flattend_props.push(`<tr><td>label</td><td>${elem.labels.join(':')}</td></tr>`);
          return `<table>${flattend_props.join('')}</table>`;
      }
  
      function getRandomColor() {
          let letters = '0123456789ABCDEF';
          let color = '#';
          for (let i = 0; i < 6; i++) {
              color += letters[Math.floor(Math.random() * 16)];
          }
          return color;
      }
  
      function retrieveGraph(node_id, add = false) {
          node_id = node_id || 1;
          domain = q('#url-input').value;
          if (!domain.endsWith('/'))
              domain += '/';
          domain = 'http://' + domain;
          if(add) {
            const existing = nodeDataSet.get(node_id);
            nodeDataSet.update({
              id: node_id,
              shape: existing.fixedByTime ? existing.shape : 'text',
              size: 25,
              fixed: true
            });
          }
          // TODO: use query which does not modify of backend
          const subquery = `MATCH p=(n)-[r]-(another) WHERE id(n) in [${node_id}] WITH p, another, size((another)--()) as degree SET another.degree = degree RETURN p`;
          axios.get(domain + `query?q=${subquery}`).then((response) => {
              if (add) {
                  addGraph(response.data.pg);
                  expandedNodes.push(node_id.toString());
              } else {
                  expandedNodes = [node_id.toString()];
                  updateGraph(response.data.pg);
              }
          });
      }
      
      function setSearchState(searching) {
        const icon =  q('#search-icon');
        if(searching) {
          icon.classList.remove("fa-search");
          icon.classList.add("fa-spinner");
          icon.classList.add("fa-spin");
        } else {
          icon.classList.add("fa-search");
          icon.classList.remove("fa-spinner");
          icon.classList.remove("fa-spin");
        }
      }
  
      function searchGraph() {  
          setSearchState(true);
          const keyword = q('#search-input').value;
          // timeProperties.clear();
          domain = q('#url-input').value;
          if (!domain.endsWith('/'))
              domain += '/';
          domain = 'http://' + domain;
          const keywordPart = encodeURI(keyword.split(" ").map((word) => `\\"${word}\\"`).join(' AND '));
          const query = `CALL db.index.fulltext.queryNodes("allProperties", "${keywordPart}") YIELD node RETURN node`;
          console.log(query);
          axios.get(domain + `query?q=${query}`).then((response) => {
              expandedNodes = response.data.pg.nodes.map((node) => node.id);
              
              // TODO: use query which does not modify of backend
              const subquery = `MATCH p=(n)-[r]-(another) WHERE id(n) in [${expandedNodes.join(',')}] WITH p, another, size((another)--()) as degree SET another.degree = degree RETURN p`
              axios.get(domain + `query?q=${subquery}`).then((subresponse) => {
                updateGraph(subresponse.data.pg);
                setSearchState(false);
              });
          });
      }
      
      
      function displayedNodeProps() {
        return nodeFolder.__controllers.map((con) =>
              con.__checkbox.checked ? con.property : null).filter((prop) => prop);
      }
      
      function displayedEdgeProps() {
        return edgeFolder.__controllers.map((con) =>
              con.__checkbox.checked ? con.property : null).filter((prop) => prop);
      }
      
      function isDateString(str) {
        return isNaN(str) && !isNaN(Date.parse(str))
      }
      
  
      function updateGraph(input) {
          groups = new Set();
          edgeColorMap = {};
  
          input = input || editor.getValue();
          if (typeof input === 'string' || input instanceof String) {
              try {
                  graph = JSON.parse(input);
              } catch (err) {
                  if (err instanceof SyntaxError)
                      graph = pgParser.parse(input);
                  else
                      throw err;
              }
          } else {
              graph = input;
          }
          
          minTime =  new Date(8640000000000000), maxTime = new Date(-8640000000000000);
          
          
          graph.nodes.forEach(node => { 
            for(let prop of Object.keys(node.properties)) {
              if(!timeProperties.has(prop) && isDateString(node.properties[prop])){
                timeProperties.add(prop);
              }
            }
          });
          
          
          while(timeLineFolder.__controllers.length > 0) timeLineFolder.__controllers[0].remove();
          
          for(let prop of timeProperties) {
            let controller = timeLineFolder.add({[prop]: false}, prop, false);
            controller.onChange(onTimeLinePropertyController);
          }
  
          graph.edges.forEach(edge => edgeMap[edge.id] = edge);
          
          nodeProps = new Set(['label']);
          edgeProps = new Set(['label']);
          graph.nodes.forEach((node) => {
              Object.keys(node.properties).filter((prop) => prop != 'degree').forEach(nodeProps.add, nodeProps);
          });
          graph.edges.forEach((edge) => {
              Object.keys(edge.properties).forEach(edgeProps.add, edgeProps);
          });
          
          const defaultPropsFilter = new RegExp('name|title', 'i');
          let defaultNodeProps = displayedNodeProps();
          let defaultEdgeProps = displayedEdgeProps();
          
          if(defaultNodeProps.length == 0) { // Initial value
            defaultNodeProps = Array.from(nodeProps).filter((prop) => defaultPropsFilter.test(prop));
            defaultEdgeProps = Array.from(edgeProps).filter((prop) => defaultPropsFilter.test(prop));
          }
  
          
          if(defaultNodeProps.length == 0) defaultNodeProps = ['id'];
  
          nodeDataSet = new vis.DataSet();
          nodeDataSet.add(graph.nodes.map((node) => {
              const groupName = node.labels.join('_');
              groups.add(groupName);
              return toVisNode(node, groupName, defaultNodeProps)
          }));
          
          updateTimeLineNodes();
  
          edgeDataSet = new vis.DataSet(graph.edges.map((edge) => {
              const edgeLabel = edge.labels.join('_');
              if (!edgeColorMap[edgeLabel]) {
                  edgeColorMap[edgeLabel] = getRandomColor();
              }
              return toVisEdge(edge, edgeLabel, defaultEdgeProps);                   
          }));
          // create a network
          let container = document.getElementById('graph');
          data = {
              nodes: nodeDataSet,
              edges: edgeDataSet
          };
          
          
          while(nodeFolder.__controllers.length > 0) nodeFolder.__controllers[0].remove();
          while(edgeFolder.__controllers.length > 0) edgeFolder.__controllers[0].remove();
          
          nodeProps.forEach(prop => {
              const controller = nodeFolder.add({[prop]: defaultNodeProps.includes(prop)}, prop)
              controller.onChange(onNodeControllerChange);
            }
          );
          
          const onEdgeControllerChange = () => {
            let displayedProps = displayedEdgeProps();
  
            edgeDataSet.update(graph.edges.map((edge) => {
                return { id: edge.properties.id ? edge.properties.id[0] : `${edge.from}-${edge.to}`,
                 label: createLabelText(edge, displayedProps) };
              }
            ));
          }
          
          edgeProps.forEach(prop => {
              const controller = edgeFolder.add({[prop]: defaultEdgeProps.includes(prop)}, prop)
              controller.onChange(onEdgeControllerChange);
            }
          );
          
          
          let options = {
              groups: Object.keys(groups).reduce((acc, group) => {
                  acc[group] = {color: getRandomColor()}
              }, {}),
              layout: {
                  randomSeed: 1,
              },
              interaction: {
                  hover: true
              },
              physics: {
                stabilization: {
                    enabled: false,
                    iterations: 200,
                    updateInterval: 25
                }
              },
              manipulation: false,
  
              edges: {
                  arrows: {
                      to: {
                          enabled: true,
                          scaleFactor: 0.3,
                          type: "arrow"
                      },
                  }
              }
          };
          network = new vis.Network(container, data, options);
  
  
          if (!localMode) {
              let selectTimer = null;
              network.on('selectNode', (e) => {
                  if (e.nodes.length > 0)
                      selectTimer = setTimeout(() => retrieveGraph(e.nodes[0], true), 300);
              });
              network.on('doubleClick', (e) => {
                  if (e.nodes.length > 0)
                      retrieveGraph(e.nodes[0]);
              });
              network.on('dragStart', (e) => {
                  clearTimeout(selectTimer);
                  const node = nodeDataSet.get(e.nodes[0]);
                  if(e.nodes.length > 0) {
                    nodeDataSet.update({
                      id: e.nodes[0],
                      fixed: timeLineEnabled && node.fixedByTime ? {x: true, y: false } : false
                    });
                  }
              });
              network.on('dragEnd', (e) => {
                  if(e.nodes.length > 0) {
                    const node = nodeDataSet.get(e.nodes[0]);
                    if(!node.fixed && expandedNodes.includes(e.nodes[0]) )
                    nodeDataSet.update({
                      id: e.nodes[0],
                      fixed: true
                    });
                  }
              });
          }
          
          network.on("hoverNode", (params) => {
              network.canvas.body.container.style.cursor = 'default';
              const node = nodeDataSet.get(params.node);
              if(node.url) {
                network.canvas.body.container.style.cursor = 'pointer';
                nodeDataSet.update({
                  id: params.node,
                  color: '#8888ff',
                });
              } else if(node.degree > 1 && !expandedNodes.includes(params.node)) {
                network.canvas.body.container.style.cursor = 'pointer';
              }
          });
          
          function plotTimes(startTime, interval, intervalUnit, timeForOnePixel, offsetX, offsetY, rightMostX, context, scale) {
            let currentTime = new Date(startTime);
            switch(intervalUnit) {
              case 'year':
                currentTime = new Date(currentTime.getFullYear(), 0, 1);
                break; 
              case 'month':
                currentTime = new Date(currentTime.getFullYear(), currentTime.getMonth() - currentTime.getMonth() % interval, 1);
                break; 
              case 'day':
                currentTime = new Date(currentTime.getFullYear(), currentTime.getMonth(), currentTime.getDate());
                break;
              default:
                return; 
            }
            while(true) {
              const nextPosition = -offsetX + (currentTime - startTime) / timeForOnePixel;
              if(nextPosition > rightMostX) break;
              context.fillText(currentTime.toLocaleDateString(), nextPosition, -offsetY);
              context.moveTo(nextPosition, -offsetY);
              context.lineTo(nextPosition, -offsetY + 25 / scale);
              context.stroke();
              switch(intervalUnit) {
                case 'year':
                  currentTime.setFullYear(currentTime.getFullYear() + interval);
                  break; 
                case 'month':
                  currentTime.setMonth(currentTime.getMonth() + interval);
                  break; 
                case 'day':
                  currentTime.setDate(currentTime.getDate() + interval);
                  break;
                default:
                  return; 
              }
            }
          }
          
          network.on("afterDrawing", (e) => {
            if(timeLineEnabled){
              const context = network.canvas.getContext("2d");
              const view = network.canvas.body.view;
              const offsetY = view.translation.y / view.scale;
              const offsetX = view.translation.x / view.scale;
              const timeForOnePixel = (maxTime - minTime) / timeScale;
              const timeOnLeftEdge = new Date(((maxTime.getTime() + minTime.getTime()) / 2) - timeForOnePixel * offsetX);
              const clientWidth = network.canvas.body.container.clientWidth;
              const rightMost = -offsetX + clientWidth / view.scale;
              const oneMonth = 31 * 24 * 60 * 60 * 1000;
              const oneDay = 24 * 60 * 60 * 1000;
              const twoMonth = oneMonth * 2;
              const fourMonth = twoMonth * 2;
              const oneYear = 365 * oneDay;
              const minDistance = 300;
              context.font = (20 / view.scale).toString() + "px Arial";
              const minimumInterval = timeForOnePixel * minDistance / view.scale;
              if(minimumInterval > oneYear ) {
                plotTimes(timeOnLeftEdge, 1, 'year', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              }
              else if(minimumInterval > fourMonth ) {
                plotTimes(timeOnLeftEdge, 4, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              }
              else if(minimumInterval > twoMonth) {
                plotTimes(timeOnLeftEdge, 2, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              }
              else if(minimumInterval > oneMonth) {
                plotTimes(timeOnLeftEdge, 1, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              } else if(minimumInterval > oneDay * 16) {
                plotTimes(timeOnLeftEdge, 16, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              } else if(minimumInterval > oneDay * 8) {
                plotTimes(timeOnLeftEdge, 8, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              } else if(minimumInterval > oneDay * 4) {
                plotTimes(timeOnLeftEdge, 4, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              } else if(minimumInterval > oneDay * 2) {
                plotTimes(timeOnLeftEdge, 2, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              } else {
                plotTimes(timeOnLeftEdge, 1, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              }
            }
          });
          network.on("blurNode", (params) => {
              network.canvas.body.container.style.cursor = 'default';
              if(nodeDataSet.get(params.node).url) {
                nodeDataSet.update({
                  id: params.node,
                  color: null,
                });
              }
          });
      
          network.on("click", (e) => {
             network.stopSimulation();
             if(e.nodes.length > 0) {
                let node = nodeDataSet.get(e.nodes[0]);
                if(node.url)
                  window.open(node.url,'_blank');
             }
          });
          network.on("stabilizationIterationsDone", function () {
              console.log('stabilized');
              network.setOptions({physics: {enabled:physicsController.getValue()}});
          });
      }
  
      function addGraph(newGraph) {
          let newNodes = newGraph.nodes.filter((n) => !nodeDataSet._data.has(n.id));
          let newEdges = newGraph.edges.filter((e) => !(expandedNodes.includes(e.from) || expandedNodes.includes(e.to)));
          graph.nodes = graph.nodes.concat(newNodes);
          graph.edges = graph.edges.concat(newEdges);
  
          nodeDataSet.add(newNodes.map((node) => {
              const groupName = node.labels.join('_');
              groups.add(groupName);
              return toVisNode(node, groupName, displayedNodeProps());
          }));
          
          edgeDataSet.add(newEdges.map((edge) => {
              const edgeLabel = edge.labels.join('_');
              if (!edgeColorMap[edgeLabel]) {
                  edgeColorMap[edgeLabel] = getRandomColor();
              }
              return toVisEdge(edge, edgeLabel, displayedEdgeProps());     
          }));
  
      }
      
  
      function handleFileSelect(evt) {
          let files = evt.target.files; // FileList object
          // use the 1st file from the list
          const f = files[0];
          let reader = new FileReader();
  
  
          // Closure to capture the file information.
          reader.onload = (function (theFile) {
              return function (e) {
                  editor.setValue(e.target.result);
                  updateGraph();
              };
          })(f);
          // Read in the image file as a data URL.
          reader.readAsText(f);
      };
  
      editor = CodeMirror.fromTextArea(q('#graph-input'), {
        lineNumbers: true,
        theme: "monokai",
        mode: "pgMode",
      });
      editor.setSize('100%', '100%');
  
      document.addEventListener('mousemove', (e) => {
        clickedPosition = {x: e.clientX, y: e.clientY}; 
      });
      // q('#pgfile').addEventListener('change', handleFileSelect, false);
  
      q('#url-input').value = 'localhost:3000';
      // retrieveGraph();
      /*  updateGraph(); */
  
      editor.on('change', (delta) => {
          clearTimeout(timerId);
          localMode = true;
          timerId = setTimeout(updateGraph, 1000);
      });
  
      q('#search-input').addEventListener('keyup', () => {
        if (event.keyCode == 13) // Enter
          q('#search-button').click(); 
      });
  
      q('#search-button').addEventListener('click', () => {
        searchGraph();
      });
  
      q('#url-input').addEventListener('change', () => {
          clearTimeout(timerId);
          localMode = false;
          timerId = setTimeout(retrieveGraph, 1000);
      });
      
      q('#search-input').value = '情報通信';
      // searchGraph();
      updateGraph();
  
      function onResize(event, ui) {
        const totalWidth = $("#main-area").width();
        let width = $("#input-area").width();
        if(width > totalWidth) {
            width = totalWidth;
            $('#input-area').css('width', width);
        }
        $('#graph-pane').css('width', (totalWidth - width) - 100);
      };
  
      $('#input-area').resizable({handles: "e", grid: [1, 10000]}).bind( "resize", onResize);
</script>
</body>
</html>
<script src='./gui.js'></script>
<script src='./animation.js'></script>
