<!DOCTYPE html>
<html>
<head>
<title>Hello Graph</title>
<link crossorigin='anonymous' href='https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css' integrity='sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css' rel='stylesheet'>
<link href='https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css' rel='stylesheet'>
<link href='./css/jquery-ui.min.css' rel='stylesheet'>
<link href='./lib/codemirror/codemirror.css' rel='stylesheet'>
<link href='./lib/monokai.css' rel='stylesheet'>
<link href='./lib/codemirror/addon/show-hint.css' rel='stylesheet'>
<script src='./axios.min.js'></script>
<script src='./vis-network.min.js'></script>
<script src='./lib/dat.gui.min.js'></script>
<script src='./manipulations.js'></script>
<script src='./lib/jquery-3.5.1.min.js'></script>
<script src='./lib/jquery-ui.min.js'></script>
<script src='./lib/pg_parser_browserified.js' type='text/javascript'></script>
<script src='./lib/json2pg_browserified.js' type='text/javascript'></script>
<script src='./lib/codemirror/codemirror.js'></script>
<script src='./lib/codemirror/simple.js'></script>
<script src='./lib/codemirror/pg_mode.js'></script>
<script src='./lib/codemirror/mark-selection.js'></script>
<script src='./lib/codemirror/addon/show-hint.js'></script>
<script src='./lib/codemirror/addon/anyword-hint.js'></script>
<script src='./lib/util.js'></script>
<script src='./lib/diff.js'></script>
<script src='./config.js'></script>
<style>
  #network-popUp {
      display: none;
      position: absolute;
      top: 350px;
      left: 170px;
      z-index: 299;
      width: 250px;
      background-color: #f9f9f9;
      border-style: solid;
      border-width: 3px;
      border-color: #5394ed;
      padding: 10px;
      text-align: center;
  }
  
  .dg.main .close-button {
      background-color: rgba(0, 0, 0, 0.7);
  }
  
  .dg.main .close-button:hover {
      background-color: rgba(0, 0, 0, 0.7);
  }
  
  .dg li:not(.folder) {
      background: rgba(0, 0, 0, 0.7);
  }
  
  .dg li.title {
      background: rgba(0, 0, 0, 0.7) url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;
  }
  
  #search-area {
    position: absolute;
    left: 50px;
    top: 50px;
    width: 600px;
    z-index: 999;
  }
  
  #search-input {
    background: rgba(255, 255, 255, 0.7);
  }
  
  #search-button {
    background: rgba(0, 160, 160, 0.7);
  }
  
  #input-area {
    left: 0;
    width: 50%;
  }
  
  #graph-pane {
    flex: 1;
  }
  
  .ui-resizable-e {
    background: #cccccc;
  }
  #main-area {
    display: inline-flex;
    width: 100%;
    height: 100%;
  }
  
  
  .btn {
    position: absolute;
    width: 100px;
    height: 40px;
    right: 10px;
    bottom: 10px;
  }
  
  #share-btn {
    position: absolute;
    right: 10px;
    bottom: 10px;
  }
  
  #export-btn {
    position: absolute;
    right: 130px;
    bottom: 10px;
  }
  
  span .highlighted {
    background: rgba(200, 200, 0, 0.5);
  }
  
  .CodeMirror-selected  { background-color: rgba(200, 200, 100, 0.5) !important; }
</style>
</head>
<body>
<div id='network-popUp'>
<span id='operation'>node</span>
<br>
<table style='margin: auto'>
<tbody id='popup-table'></tbody>
</table>
<input id='saveButton' type='button' value='save'>
<input id='cancelButton' type='button' value='cancel'>
</div>
<div class='d-none' id='search-area'>
<div class='row'>
<div class='col-6 pr-0 pl-4'>
<input aria-label='' class='form-control' id='search-input' placeholder='Free Search' type='text'>
</div>
<div class='col-2 mx-0 px-0'>
<button class='mx-0 btn btn-info' id='search-button' type='button'>
<span class='fa fa-search' id='search-icon'></span>
Search
</button>
</div>
</div>
</div>
<div id='main-area'>
<div class='vh-100' id='input-area'>
<input class='d-none' id='url-input'>
<textarea class='vh-100' id='graph-input' style='height: 100%; width: 100%;'>I :person name:"your name"
You :person
Graph :graph
I -> Graph :say word:Hello date:today
You -> I :say word:Goodbye date:yesterday</textarea>
</div>
<div class='vh-100' id='graph-pane'>
<div class='bg-light vh-100' id='graph'></div>
</div>
<div class='btn btn-success' id='export-btn'>
Export
</div>
<div class='btn btn-info' id='share-btn'>
Share!
</div>
</div>
<script>
  'use strict';
      const q = document.querySelector.bind(document);
      const qa = document.querySelectorAll.bind(document);
      const nodeSize = 25;
      const thresholdToReload = 100;
      let timerId = 0;
      let editor;
      let localMode = true;
      let groups = new Set();
      let data, nodeDataSet, edgeDataSet, expandedNodes = [], network;
      let clickedPosition;
      let graph, nodeMap = {}, nodeLineMap = {}, edgeMap = {}, edgeLineMap = {};
      let edgeColorMap;
      let domain;
      let byProgram = false;
      let displayedTimeProps = ["submittedDate"];
      let timeLineEnabled = false;
      let nodeProps, edgeProps;
      let minTime =  new Date(8640000000000000), maxTime = new Date(-8640000000000000);
      let timeInterval = 1;
      let timeProperties = new Set();
      let timeScale = 100.0;
      let lineStart = null, lineEnd = null, srcNode = null;
      let listDisplayedNodeProps, listDisplayedEdgeProps;
      const gui = new dat.GUI({hideable: false});
      const nodeFolder = gui.addFolder('Node');
      const edgeFolder = gui.addFolder('Edge');
      const timeLineFolder = gui.addFolder('TimeLine');
  
      function onNodeControllerChange(){
        let displayedProps = displayedNodeProps();
        nodeDataSet.update(graph.nodes.map((node) => {
            return {
              id: node.id,
              label: createLabelText(node, displayedProps)
            };
          })
        );
        localStorage.setItem('displayedNodeProps', displayedProps);
      };
      
      function onEdgeControllerChange(){
        let displayedProps = displayedEdgeProps();
  
        edgeDataSet.update(graph.edges.map((edge) => {
            return { id: edge.properties.id ? edge.properties.id[0] : `${edge.from}-${edge.to}`,
             label: createLabelText(edge, displayedProps) };
          }
        ));
        
        localStorage.setItem('displayedEdgeProps', displayedProps);
      }
  
      function scrollToLine(line) {
        byProgram = true;
        editor.scrollIntoView({line, ch:0}, 200);
        editor.setSelection({line, ch: Infinity}, {line, ch: 0});
        editor.focus();
      }
      
      function updateTimeLineNodes() {
          if(timeLineEnabled) {
            let nodeCountWithTime = 0;
            graph.nodes.forEach(node => {
              for(let prop of displayedTimeProps) {
                let time = node.properties[prop];
                if(time) {
                  ++nodeCountWithTime;
                  time = new Date(time);
                  minTime = time < minTime ? time : minTime;
                  maxTime = time > maxTime ? time : maxTime;
                }
              }
            });
            timeInterval = maxTime.getTime() - minTime.getTime();
            timeScale = nodeCountWithTime * 100;
          }
      }
      
      function calcNodePosition(pgNode) {
          let x, y, fixed, width;
          if(timeLineEnabled) {
            x = null;
            fixed = false;
            let positions = [];
            for(let prop of displayedTimeProps) {
              if(pgNode.properties[prop] && timeInterval > 0) {
                positions.push(timeScale * ((new Date(pgNode.properties[prop]).getTime()) - minTime.getTime()) * 1.0 / timeInterval - timeScale * 0.5);
              }
            }
            if(positions.length > 0) {
              fixed = true;
              let max = Math.max(...positions), min = Math.min(...positions);
              x = (max + min) / 2;
              width = max - min; 
            } else {
              x = 0;
            }
            y = 0;
          }
          else {
            if(config.layout == 'custom' &&
              (pgNode.properties[config.layoutMapping.x] ||
               pgNode.properties[config.layoutMapping.y])
              ) {
              x = parseInt(pgNode.properties[config.layoutMapping.x][0]);
              y = parseInt(pgNode.properties[config.layoutMapping.y][0]);
              fixed = true;
            } else {
              x = null;
              y = null;
              fixed = false;
              width = null;
            }
          }
          return {x, y, fixed, width};
      }
      
      function retrieveHttpUrl(node) {
        let candidates = [];
        for(let entry of Object.entries(node.properties)) { 
          for(let prop of entry[1]) {
            if(typeof(prop) === 'string' && (prop.startsWith("https://") || prop.startsWith("http://"))) {
              if(entry[0].toLowerCase() == 'url')
                return prop;
              candidates.push([entry[0], prop]);
            }
          }
        }
        return candidates[0];
      }
      
      function retrieveThumbnailUrl(node) {
        for(let entry of Object.entries(node.properties)) {
          if(entry[0].toLowerCase() == 'thumbnail') {
            return entry[1][0]
          }
        }
        return null;
      }
  
      function toVisNode(pgNode, props, extraOptions = null) {
          const group = pgNode.labels.join('_');
          groups.add(group);
  
          let x, y, fixed, width;
          ({x, y, fixed, width} = calcNodePosition(pgNode));
          
          let url = retrieveHttpUrl(pgNode);
          let thumbnailUrl = retrieveThumbnailUrl(pgNode);
          let expanded = expandedNodes.includes(pgNode.id);
          
          let degree =  pgNode.properties['degree'];
          if(degree !== undefined) {
            degree = degree[0];
          } else {
            degree = 2; // assume degree to be two (default)
          }
  
          let attrs = {
              id: pgNode.id,
              group: group,
              label: createLabelText(pgNode, props),
              shape: fixed ? 'square' : (degree === 1 || expanded ? 'text' : 'dot'),
              size: expanded ? 25 : (2 + degree * 8),
              degree: degree,
              title: createTitleText(pgNode),
              fixed: {
                x: fixed,
                y: fixed
              },
              borderWidth: url ? 3 : 1,
              url: url,
              x: x,
              y: y,
              font: {
                color: url ? 'blue' : 'black'
              },
              fixedByTime: fixed
          };
  
          let icon;
          if(icon = config.node.icon[group]) {
            let code = String.fromCharCode(parseInt(icon, 16));
            attrs['shape'] = 'icon';
            attrs['icon'] = {
              face: 'Ionicons',
              code: code,
              weight: 'bold',
              color: getRandomColor(group, '70%'),
            };              
          }
          
          if(thumbnailUrl) {
            attrs['shape'] = 'image';
            attrs['image'] = thumbnailUrl;
          }
          if(width) {
            attrs['shape'] = 'box';
            attrs['widthConstraint'] = {
              minimum: width,
              maximum: width
            }
          }
          attrs = Object.assign(attrs, extraOptions);
          return attrs;
      }
      
      function toVisEdge(pgEdge, props) {
          const edgeLabel = pgEdge.labels.join('_');
          if (!edgeColorMap[edgeLabel]) {
              edgeColorMap[edgeLabel] = getRandomColor(edgeLabel);
          }
          let length = null, lengthProp, width = null, widthProp;
          if(lengthProp = pgEdge.properties[config?.edge?.length?.[edgeLabel]]) {
            length = lengthProp[0];
          }
          if(widthProp = pgEdge.properties[config?.edge?.width?.[edgeLabel]]) {
            width = parseFloat(widthProp[0]);
          }
  
          const id = pgEdge.properties.id ? pgEdge.properties.id[0] : `${pgEdge.from}-${pgEdge.to}`;
          return {
              id: id,
              from: pgEdge.from,
              to: pgEdge.to,
              color: edgeColorMap[edgeLabel],
              label: createLabelText(pgEdge, props),
              title: createTitleText(pgEdge),
              remoteId: id,
              length: length,
              width: width,
              hoverWidth: 0.5,
              smooth:
              {
                roundness:1
              },
              arrows: {
                to: {
                  enabled: pgEdge.direction == '->' || pgEdge.undirected === 'false'
                },
              }
          }
      }
      
      function wrapText(str, asHtml) {
        if(!str)
          return str;
        if(Array.isArray(str))
          str = str[0];
        const maxWidth = 40;
        let newLineStr = asHtml ? "<br>" : "\n", res = '';
        while (str.length > maxWidth) {
          res += str.slice(0, maxWidth) + newLineStr;
          str = str.slice(maxWidth);
        }
        return res + str;
      }
  
      function createLabelText(elem, props = null) {
          if(props != null) {
              // Use whitespace instead of empty string if no props are specified because Vis.js cannot update label with empty string)
            return props.length ? props.map((prop) => prop === 'id' ? elem.id : (prop === 'label' ? elem.labels : wrapText(elem.properties[prop]))).filter((val) => val).join('\n') : ' ';
          }
          else if (elem.id) // for nodes
              return elem.id;
          else // for edges
              return elem.labels.join("\n");
      }
  
      function createTitleText(elem) {
          let flattend_props = Object.entries(elem.properties).reduce((acc, prop) =>
              acc.concat(`<tr><td>${prop[0]}</td><td>${wrapText(prop[1], true)}</td></tr>`), []);
          if (elem.id) // for nodes
          {
              let idText = `<tr><td><b>${elem.id}</b></tr></td>`;
              flattend_props.splice(0, 0, idText);
              flattend_props.push(`<tr><td width="100px">label</td><td width="200px">${wrapText(elem.labels.join(':'), true)}</td></tr>`);
          }
          return htmlTitle(`<table style='fixed'>${flattend_props.join('')}</table>`);
      }
  
      // Create random colors, with str as seed, and with fixed saturation and lightness
      function getRandomColor(str, brightness = '40%') {
          let hash = 0;
          for (let i = 0; i < str.length; i++) {
              hash = str.charCodeAt(i) + ((hash << 5) - hash);
              hash = hash & hash;
          }
          let hue = hash % 360;
          return 'hsl(' + hue + `, 100%, ${brightness})`;
      }
  
      function retrieveGraph(node_id, add = false) {
          node_id = node_id || 1;
          domain = q('#url-input').value;
          if (!domain.endsWith('/'))
              domain += '/';
          domain = 'http://' + domain;
          if(add) {
            const existing = nodeDataSet.get(node_id);
            nodeDataSet.update({
              id: node_id,
              shape: existing.fixedByTime ? existing.shape : 'text',
              size: 25,
              fixed: true
            });
          }
          // TODO: use query which does not modify of backend
          const subquery = `MATCH p=(n)-[r]-(another) WHERE id(n) in [${node_id}] WITH p, another, size((another)--()) as degree SET another.degree = degree RETURN p`;
          axios.get(domain + `query?q=${subquery}`).then((response) => {
              if (add) {
                  addGraph(response.data.pg);
                  expandedNodes.push(node_id.toString());
              } else {
                  expandedNodes = [node_id.toString()];
                  updateGraph(response.data.pg);
              }
          });
      }
      
      function setSearchState(searching) {
        const icon =  q('#search-icon');
        if(searching) {
          icon.classList.remove("fa-search");
          icon.classList.add("fa-spinner");
          icon.classList.add("fa-spin");
        } else {
          icon.classList.add("fa-search");
          icon.classList.remove("fa-spinner");
          icon.classList.remove("fa-spin");
        }
      }
  
      function searchGraph() {  
          setSearchState(true);
          const keyword = q('#search-input').value;
          // timeProperties.clear();
          domain = q('#url-input').value;
          if (!domain.endsWith('/'))
              domain += '/';
          domain = 'http://' + domain;
          const keywordPart = encodeURI(keyword.split(" ").map((word) => `\\"${word}\\"`).join(' AND '));
          const query = `CALL db.index.fulltext.queryNodes("allProperties", "${keywordPart}") YIELD node RETURN node`;
          axios.get(domain + `query?q=${query}`).then((response) => {
              expandedNodes = response.data.pg.nodes.map((node) => node.id);
              
              // TODO: use query which does not modify of backend
              const subquery = `MATCH p=(n)-[r]-(another) WHERE id(n) in [${expandedNodes.join(',')}] WITH p, another, size((another)--()) as degree SET another.degree = degree RETURN p`
              axios.get(domain + `query?q=${subquery}`).then((subresponse) => {
                updateGraph(subresponse.data.pg);
                setSearchState(false);
              });
          });
      }
      
      
      function displayedNodeProps() {
        return nodeFolder.__controllers.map((con) =>
              con.__checkbox.checked ? con.property : null).filter((prop) => prop);
      }
      
      function displayedEdgeProps() {
        return edgeFolder.__controllers.map((con) =>
              con.__checkbox.checked ? con.property : null).filter((prop) => prop);
      }
      
      function isDateString(str) {
        return isNaN(str) && !isNaN(Date.parse(str))
      }
      
      function updateGraph(input) {
          groups = new Set();
          edgeColorMap = {};
  
          let newContent = editor.getValue();
          let applyDiff = nodeDataSet && edgeDataSet;
          let lineCount = 0;
          let oldLineCount = 0;
          let diffCount = 0;
          if(applyDiff) {
            let newNodeLineMap = new Map();
            let newEdgeLineMap = new Map();
            Diff.diffLines(oldContent, newContent).forEach(diff => {
              if(diff.removed) {
                for(let i = 1; i <= diff.count; ++i) {
                  let existingNode = nodeLineMap[oldLineCount + i];
                  let existingEdge = edgeLineMap[oldLineCount + i];
                  if(existingNode) {
                    delete nodeMap[existingNode.id];
                    nodeDataSet.remove(existingNode);
                    graph.nodes = graph.nodes.filter(item => item.id != existingNode.id);
                  }
                  if(existingEdge) {
                    delete edgeMap[existingEdge.id];
                    edgeDataSet.remove(existingEdge);
                    graph.edges = graph.edges.filter(item => item.from != existingEdge.from && item.to != existingEdge.to);
                  }
                }
                diffCount += diff.count;
                oldLineCount += diff.count;
              }
              else if(diff.added) {
                let addedPg = pgParser.parse(diff.value);
                addedPg.nodes.forEach(node => {
                  node.line += lineCount;
                  let visNode = toVisNode(node);
                  nodeDataSet.update(visNode);
                  newNodeLineMap[node.line] = node;
                  nodeMap[node.id] = node;                      
                })
                graph.nodes = graph.nodes.concat(addedPg.nodes);
                addedPg.edges.forEach(edge => {
                  edge.line += lineCount;
                  let visEdge = toVisEdge(edge);
                  edgeDataSet.update(visEdge);
                  newEdgeLineMap[edge.line] = visEdge;
                  edgeMap[visEdge.id] = edge;
                })
                graph.edges = graph.edges.concat(addedPg.edges);
                diffCount += diff.count;
                lineCount += diff.count;
              } else {
                for(let i = 1; i <= diff.count; ++i) {
                  let existingNode = nodeLineMap[oldLineCount + i];
                  let existingEdge = edgeLineMap[oldLineCount + i];
                  if(existingNode)
                    existingNode.line = lineCount + i;
                  if(existingEdge) {
                    existingEdge.line = lineCount + i;
                    edgeMap[existingEdge.id].line = existingEdge.line;
                  }
                  newNodeLineMap[lineCount + i] = existingNode;
                  newEdgeLineMap[lineCount + i] = existingEdge;
                }
                lineCount += diff.count;
                oldLineCount += diff.count;
              }
            });
            nodeLineMap = newNodeLineMap;
            edgeLineMap = newEdgeLineMap;
          }
          oldContent = newContent;
          localStorage.setItem('pg', newContent);
          if(applyDiff && diffCount < thresholdToReload) return;
  
  
          input = input || editor.getValue();
          if (typeof input === 'string' || input instanceof String) {
              try {
                  graph = JSON.parse(input);
              } catch (err) {
                  if (err instanceof SyntaxError)
                      graph = pgParser.parse(input);
                  else
                      throw err;
              }
          } else {
              graph = input;
          }
          
          minTime =  new Date(8640000000000000), maxTime = new Date(-8640000000000000);
          
          
          graph.nodes.forEach(node => { 
            for(let prop of Object.keys(node.properties)) {
              if(!timeProperties.has(prop) && isDateString(node.properties[prop])){
                timeProperties.add(prop);
              }
            }
          });
          
          
          while(timeLineFolder.__controllers.length > 0) timeLineFolder.__controllers[0].remove();
          
          for(let prop of timeProperties) {
            let controller = timeLineFolder.add({[prop]: false}, prop, false);
            controller.onChange(onTimeLinePropertyController);
          }
  
          nodeProps = new Set(['id', 'label']);
          edgeProps = new Set(['label']);
          graph.nodes.forEach((node) => {
            nodeMap[node.id] = node;
            nodeLineMap[node.line] = node;
            Object.keys(node.properties).filter((prop) => prop != 'degree').forEach(nodeProps.add, nodeProps);
          });
          graph.edges.forEach((edge) => {
            Object.keys(edge.properties).forEach(edgeProps.add, edgeProps);
          });
          
          const defaultNodePropsFilter = new RegExp('name|title', 'i');
          const defaultEdgePropsFilter = new RegExp('label', 'i');
          let defaultNodeProps = displayedNodeProps();
          let defaultEdgeProps = displayedEdgeProps();
          
          if(defaultNodeProps.length == 0) { // Initial value
            defaultNodeProps = Array.from(nodeProps).filter((prop) => defaultNodePropsFilter.test(prop));
            defaultEdgeProps = Array.from(edgeProps).filter((prop) => defaultEdgePropsFilter.test(prop));
          }
  
          
          if(defaultNodeProps.length == 0) defaultNodeProps = ['id'];
  
          nodeDataSet = new vis.DataSet();
          nodeDataSet.add(graph.nodes.map((node) => {
              return toVisNode(node, defaultNodeProps);
          }));
          
          updateTimeLineNodes();
  
          edgeDataSet = new vis.DataSet(graph.edges.map((edge) => {
              const edgeLabel = edge.labels.join('_');
              let visEdge = toVisEdge(edge, defaultEdgeProps);
              edgeMap[visEdge.id] = edge;
              edgeLineMap[edge.line] = visEdge;
              return visEdge;
          }));
          // create a network
          let container = document.getElementById('graph');
          data = {
              nodes: nodeDataSet,
              edges: edgeDataSet
          };
          
          
          while(nodeFolder.__controllers.length > 0) nodeFolder.__controllers[0].remove();
          while(edgeFolder.__controllers.length > 0) edgeFolder.__controllers[0].remove();
          
          nodeProps.forEach(prop => {
              const controller = nodeFolder.add({[prop]: defaultNodeProps.includes(prop)}, prop)
              controller.onChange(onNodeControllerChange);
            }
          );
          
          edgeProps.forEach(prop => {
              const controller = edgeFolder.add({[prop]: defaultEdgeProps.includes(prop)}, prop)
              controller.onChange(onEdgeControllerChange);
            }
          );
  
          let layout = {
            randomSeed: 1
          };
          
          if(config.layout == 'hierarchical') {
            layout = {
              hierarchical: {
                enabled: true,
                sortMethod: 'directed',
              }
            };
          }
  
          let options = {
              groups: [...groups].reduce((acc, group) => {
                  acc[group] = {color: getRandomColor(group, '70%')}; return acc;
              }, {}),
              layout:
                layout,
              interaction: {
                  hover: true
              },
              physics: {
                stabilization: {
                    enabled: false,
                    iterations: 200,
                    updateInterval: 25
                }
              },
              manipulation: false,
  
              edges: {
                  arrows: {
                      to: {
                          enabled: true,
                          scaleFactor: 0.3,
                          type: "arrow"
                      },
                  }
              },
              nodes: {
                  title: 'hover',
              }
          };
          network = new vis.Network(container, data, options);
  
          let selectTimer = null;
          network.on('selectNode', (e) => { 
              if (e.nodes.length > 0) {
                if(!localMode) {
                  selectTimer = setTimeout(() => retrieveGraph(e.nodes[0], true), 300);
                }
              }
          });
  
          network.on('doubleClick', (e) => {
              if (localMode) {
                if(e.nodes.length == 0) {
                  let newNode = {
                    id: newNodeId(),
                    labels: ['New'],
                    properties: {},
                  };
                  addNewNode(newNode, e.pointer.canvas.x, e.pointer.canvas.y);
                } else {
                   const position = e.pointer.canvas;
                   const node = e.nodes[0];
                   lineStart = position;
                   srcNode = node;
                   nodeDataSet.update({id: node, fixed: {x: true, y: true}});
                }
              }
              else if (e.nodes.length > 0)
                  retrieveGraph(e.nodes[0]);
          });
  
          network.on('dragStart', (e) => {
              clearTimeout(selectTimer);
              srcNode = lineStart = lineEnd = null;
              const node = nodeDataSet.get(e.nodes[0]);
              if(e.nodes.length > 0) {
                nodeDataSet.update({
                  id: e.nodes[0],
                  fixed: node.fixedByTime ? {x: true, y: true } : false
                });
              }
          });
  
          if (!localMode) {
              network.on('doubleClick', (e) => {
                  if (e.nodes.length > 0)
                      retrieveGraph(e.nodes[0]);
              });
              network.on('dragEnd', (e) => {
                  if(e.nodes.length > 0) {
                    const node = nodeDataSet.get(e.nodes[0]);
                    if(!node.fixed && expandedNodes.includes(e.nodes[0]) )
                    nodeDataSet.update({
                      id: e.nodes[0],
                      fixed: true
                    });
                  }
              });
          }
          let canvas = q(".vis-network canvas");
  
          function getMousePos(canvas, evt) {
            var rect = canvas.getBoundingClientRect();
            return {
              x: evt.clientX - rect.left,
              y: evt.clientY - rect.top
            };
          }
          canvas.addEventListener('mousemove', event =>
          {
            if(lineStart) {
              lineEnd = network.DOMtoCanvas(getMousePos(canvas, event));
              network.redraw();
            }
          });
          
          network.on("hoverNode", (e) => {
            network.canvas.body.container.style.cursor = 'default';
            const node = nodeDataSet.get(e.node);
            if(node && node.url) {
              network.canvas.body.container.style.cursor = 'pointer';
              nodeDataSet.update({
                id: e.node,
                color: '#8888ff',
              });
            } else if(node && node.degree > 1 && !expandedNodes.includes(e.node)) {
              network.canvas.body.container.style.cursor = 'pointer';
            }
          });
          
          function plotTimes(startTime, interval, intervalUnit, timeForOnePixel, offsetX, offsetY, rightMostX, context, scale) {
            let currentTime = new Date(startTime);
            switch(intervalUnit) {
              case 'year':
                currentTime = new Date(currentTime.getFullYear(), 0, 1);
                break; 
              case 'month':
                currentTime = new Date(currentTime.getFullYear(), currentTime.getMonth() - currentTime.getMonth() % interval, 1);
                break; 
              case 'day':
                currentTime = new Date(currentTime.getFullYear(), currentTime.getMonth(), currentTime.getDate());
                break;
              default:
                return; 
            }
            while(true) {
              const nextPosition = -offsetX + (currentTime - startTime) / timeForOnePixel;
              if(nextPosition > rightMostX) break;
              context.fillText(currentTime.toLocaleDateString(), nextPosition, -offsetY);
              context.moveTo(nextPosition, -offsetY);
              context.lineTo(nextPosition, -offsetY + 25 / scale);
              context.stroke();
              switch(intervalUnit) {
                case 'year':
                  currentTime.setFullYear(currentTime.getFullYear() + interval);
                  break; 
                case 'month':
                  currentTime.setMonth(currentTime.getMonth() + interval);
                  break; 
                case 'day':
                  currentTime.setDate(currentTime.getDate() + interval);
                  break;
                default:
                  return; 
              }
            }
          }
          
          network.on("afterDrawing", (ctx) => {
            if(lineStart && lineEnd) {
              ctx.beginPath();
              ctx.moveTo(lineStart.x, lineStart.y);
              ctx.lineTo(lineEnd.x, lineEnd.y);
              ctx.stroke();
            }
            if(timeLineEnabled){
              const context = network.canvas.getContext("2d");
              const view = network.canvas.body.view;
              const offsetY = view.translation.y / view.scale;
              const offsetX = view.translation.x / view.scale;
              const timeForOnePixel = (maxTime - minTime) / timeScale;
              const timeOnLeftEdge = new Date(((maxTime.getTime() + minTime.getTime()) / 2) - timeForOnePixel * offsetX);
              const clientWidth = network.canvas.body.container.clientWidth;
              const rightMost = -offsetX + clientWidth / view.scale;
              const oneMonth = 31 * 24 * 60 * 60 * 1000;
              const oneDay = 24 * 60 * 60 * 1000;
              const twoMonth = oneMonth * 2;
              const fourMonth = twoMonth * 2;
              const oneYear = 365 * oneDay;
              const minDistance = 300;
              context.font = (20 / view.scale).toString() + "px Arial";
              const minimumInterval = timeForOnePixel * minDistance / view.scale;
              if(minimumInterval > oneYear ) {
                plotTimes(timeOnLeftEdge, 1, 'year', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              }
              else if(minimumInterval > fourMonth ) {
                plotTimes(timeOnLeftEdge, 4, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              }
              else if(minimumInterval > twoMonth) {
                plotTimes(timeOnLeftEdge, 2, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              }
              else if(minimumInterval > oneMonth) {
                plotTimes(timeOnLeftEdge, 1, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              } else if(minimumInterval > oneDay * 16) {
                plotTimes(timeOnLeftEdge, 16, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              } else if(minimumInterval > oneDay * 8) {
                plotTimes(timeOnLeftEdge, 8, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              } else if(minimumInterval > oneDay * 4) {
                plotTimes(timeOnLeftEdge, 4, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              } else if(minimumInterval > oneDay * 2) {
                plotTimes(timeOnLeftEdge, 2, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              } else {
                plotTimes(timeOnLeftEdge, 1, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
              }
            }
          });
          network.on("blurNode", (params) => {
              network.canvas.body.container.style.cursor = 'default';
              let node = nodeDataSet.get(params.node);
              if(node && node.url) {
                nodeDataSet.update({
                  id: params.node,
                  color: null,
                });
              }
          });
      
          network.on("click", (e) => {
             network.stopSimulation();
             if(e.nodes.length > 0) {
                let node = nodeDataSet.get(e.nodes[0]);
                if(srcNode) {
                  let newEdge = {
                    from: srcNode,
                    to: node.id,
                    undirected: false,
                    labels: [],
                    properties: {}
                  };
                  graph.edges.push(newEdge);
                  let visEdge = toVisEdge(newEdge);
                  edgeMap[visEdge.id] = newEdge
                  edgeDataSet.add(visEdge);
  
                  let oldPg = editor.getValue();
                  newEdge.line = numberOfLines(oldPg) + 1;
                  byProgram = true;
                  editor.setValue(oldPg + `\n"${newEdge.from}" -> "${newEdge.to}" ${newEdge.labels.map((label) => ':' + label).join(' ')} `);
                  scrollToLine(newEdge.line - 1);
                  srcNode = null;
                  lineStart = null;
                  lineEnd = null;
                } else if(localMode) {
                  let line = nodeMap[e.nodes[0]].line - 1;
                  scrollToLine(line);
                }
                if(node && node.url)
                  window.open(node.url,'_blank');
            } else if(e.edges.length > 0) {
              let line = edgeMap[e.edges[0]].line - 1;
              scrollToLine(line);
            }
          });
      }
  
      function addGraph(newGraph) {
          let newNodes = newGraph.nodes.filter((n) => !nodeDataSet._data.has(n.id));
          let newEdges = newGraph.edges.filter((e) => !(expandedNodes.includes(e.from) || expandedNodes.includes(e.to)));
          graph.nodes = graph.nodes.concat(newNodes);
          graph.edges = graph.edges.concat(newEdges);
  
          nodeDataSet.add(newNodes.map((node) => {
              return toVisNode(node, displayedNodeProps());
          }));
          
          edgeDataSet.add(newEdges.map((edge) => {
              let visEdge = toVisEdge(edge, displayedEdgeProps());
              edgeMap[visEdge.id] = edge;
              return visEdge;
          }));
  
      }
      
  
      function handleFileSelect(evt) {
          let files = evt.target.files; // FileList object
          // use the 1st file from the list
          const f = files[0];
          let reader = new FileReader();
  
  
          // Closure to capture the file information.
          reader.onload = (function (theFile) {
              return function (e) {
                  editor.setValue(e.target.result);
                  updateGraph();
              };
          })(f);
          // Read in the image file as a data URL.
          reader.readAsText(f);
      };
  
  
      editor = CodeMirror.fromTextArea(q('#graph-input'), {
        lineNumbers: true,
        viewportMargin: Infinity,
        theme: "monokai",
        lineWrapping: true,
        mode: "pgMode",
        extraKeys: {
          Tab: 'autocomplete'
        },
        hintOptions: {
          completeSingle: false
        }
      });
      editor.setSize('100%', '100%');
  
      const urlParams = new URLSearchParams(window.location.search);
      let pgInParam = urlParams.get('pg'), nodePropInParam = urlParams.get('displayedNodeProps'),
          edgePropInParam = urlParams.get('displayedEdgeProps');
      if(pgInParam || nodePropInParam || edgePropInParam) {
        if(pgInParam)
          localStorage.setItem('pg', pgInParam);
        if(nodePropInParam)
          localStorage.setItem('displayedNodeProps', nodePropInParam);
        if(edgePropInParam)
          localStorage.setItem('displayedEdgeProps', edgePropInParam);
        window.location.href = window.location.href.split('?')[0]; // Jump to URL without query parameter
      }
  
      let initialPg = loadConfig('pg');
      if(initialPg) {
        editor.setValue(initialPg);
      }
      
      document.addEventListener('mousemove', (e) => {
        clickedPosition = {x: e.clientX, y: e.clientY};
      });
      // q('#pgfile').addEventListener('change', handleFileSelect, false);
  
      q('#url-input').value = 'localhost:3000';
      // retrieveGraph();
      /*  updateGraph(); */
  
      let oldContent = '';
  
      editor.on("inputRead", (instance) => {
        editor.execCommand('autocomplete', { completeSingle: false });
      });
  
      editor.on('change', (delta) => {
        if(!byProgram) {
          clearTimeout(timerId);
          localMode = true;
          timerId = setTimeout(updateGraph, 1000);
        } else {
          byProgram = false;
        }
      });
      
      editor.on('cursorActivity', (doc) => {
        if(!byProgram) {
          const node = nodeLineMap[doc.getCursor().line + 1];
          const edge = edgeLineMap[doc.getCursor().line + 1];
  
          if(node) {
            scrollIntoView(network.getPosition(node.id));
            network.selectNodes([node.id]);
          } else if(edge){
            const from = network.getPosition(edge.from);
            const to = network.getPosition(edge.to);
            scrollIntoView({ x: (from.x + to.x) / 2, y: (from.y + to.y) /2 });
            network.selectEdges([edge.id]);
          }
        } else {
          byProgram = false;
        }
      });
  
      q('#search-input').addEventListener('keyup', () => {
        if (event.keyCode == 13) // Enter
          q('#search-button').click(); 
      });
  
      q('#search-button').addEventListener('click', () => {
        searchGraph();
      });
  
      q('#url-input').addEventListener('change', () => {
          clearTimeout(timerId);
          localMode = false;
          timerId = setTimeout(retrieveGraph, 1000);
      });
  
      q('#share-btn').addEventListener('click', () => {
        let url = `https://g2glab.github.io/hellograph?pg=${encodeURIComponent(editor.getValue())}` +
                  `&displayedNodeProps=${encodeURIComponent(listDisplayedNodeProps)}` +
                  `&displayedEdgeProps=${encodeURIComponent(listDisplayedEdgeProps)}`;
        let data = [new ClipboardItem({ 'text/plain': new Blob([url], { type: "text/plain"})})];
        navigator.clipboard.write(data).then(function() {
          alert("Your graph is now on clipboard!")
        });
      });
  
      q('#export-btn').addEventListener('click', () => {
        download(editor.getValue(), 'graph_' + currentTimeString() + '.pg', 'text/plain');
      });
  
      
      q('#search-input').value = '情報通信';
      // searchGraph();
      if (document.fonts) {
      // Decent browsers: Make sure the fonts are loaded.
      document.fonts.load('normal normal 400 24px/1 "FontAwesome"')
        .catch(
          console.error.bind(console, "Failed to load Font Awesome 4.")
        ).then(function () {
          // create a network
          updateGraph();
        })
        .catch(
          console.error.bind(
            console,
            "Failed to render the network with Font Awesome 4."
          )
        );
      }
  
  
      function onResize(event, ui) {
        const totalWidth = $("#main-area").width();
        let width = $("#input-area").width();
        if(width > totalWidth) {
            width = totalWidth;
            $('#input-area').css('width', width);
        }
        $('#graph-pane').css('width', (totalWidth - width) - 100);
      };
  
      $('#input-area').resizable({handles: "e", grid: [1, 10000]}).bind( "resize", onResize);
      
      listDisplayedNodeProps = loadConfig('displayedNodeProps');
  
      if(listDisplayedNodeProps) {
        nodeFolder.__controllers.forEach(con => {
          con.__checkbox.checked = listDisplayedNodeProps.includes(con.property);
        });
        onNodeControllerChange();
      }
      
      listDisplayedEdgeProps = loadConfig('displayedEdgeProps') || ['label', 'word']; // Show 'word' if pg is default
      if(listDisplayedEdgeProps) {
        edgeFolder.__controllers.forEach(con => {
          con.__checkbox.checked = listDisplayedEdgeProps.includes(con.property);
        });
        onEdgeControllerChange();
      }
</script>
</body>
</html>
<script src='./gui.js'></script>
<script src='./animation.js'></script>
