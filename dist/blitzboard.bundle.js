(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Blitzboard"] = factory();
	else
		root["Blitzboard"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@iconify/iconify/dist/iconify.min.js":
/*!***********************************************************!*\
  !*** ./node_modules/@iconify/iconify/dist/iconify.min.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
* (c) Iconify
*
* For the full copyright and license information, please view the license.txt or license.gpl.txt
* files at https://github.com/iconify/iconify
*
* Licensed under Apache 2.0 or GPL 2.0 at your option.
* If derivative product is not compatible with one of licenses, you can pick one of licenses.
*
* @license Apache 2.0
* @license GPL 2.0
*/
var Iconify=function(){"use strict";function e(e,n,t){return e(t={path:n,exports:{},require:function(e,n){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}(null==n&&t.path)}},t.exports),t.exports}var n=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.fullIcon=n.iconDefaults=n.minifyProps=n.matchName=void 0,n.matchName=/^[a-z0-9]+(-[a-z0-9]+)*$/,n.minifyProps=["width","height","top","left"],n.iconDefaults=Object.freeze({left:0,top:0,width:16,height:16,rotate:0,vFlip:!1,hFlip:!1}),n.fullIcon=function(e){return Object.assign({},n.iconDefaults,e)}})),t=e((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.mergeIconData=void 0,t.mergeIconData=function(e,t){var r=Object.assign({},e);for(var o in n.iconDefaults){var i=o;if(void 0!==t[i]){var a=t[i];if(void 0===r[i]){r[i]=a;continue}switch(i){case"rotate":r[i]=(r[i]+a)%4;break;case"hFlip":case"vFlip":r[i]=a!==r[i];break;default:r[i]=a}}}return r}})),r=e((function(e,r){Object.defineProperty(r,"__esModule",{value:!0}),r.parseIconSet=void 0;var o=Object.keys(n.iconDefaults);function i(e,n,r,o){void 0===o&&(o=0);var a=e.parent;if(void 0!==n[a])return t.mergeIconData(n[a],e);if(void 0!==r[a]){if(o>2)return null;var c=i(r[a],n,r,o+1);if(c)return t.mergeIconData(c,e)}return null}r.parseIconSet=function(e,t,r){void 0===r&&(r="none");var a=[];if("object"!=typeof e)return"none"!==r&&a;if(e.not_found instanceof Array&&e.not_found.forEach((function(e){t(e,null),"all"===r&&a.push(e)})),"object"!=typeof e.icons)return"none"!==r&&a;var c=Object.create(null);o.forEach((function(n){void 0!==e[n]&&"object"!=typeof e[n]&&(c[n]=e[n])}));var u=e.icons;if(Object.keys(u).forEach((function(e){var r=u[e];"string"==typeof r.body&&(t(e,Object.freeze(Object.assign({},n.iconDefaults,c,r))),a.push(e))})),"object"==typeof e.aliases){var f=e.aliases;Object.keys(f).forEach((function(e){var r=i(f[e],u,f,1);r&&(t(e,Object.freeze(Object.assign({},n.iconDefaults,c,r))),a.push(e))}))}return"none"===r?a.length>0:a}})),o=e((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.validateIcon=t.stringToIcon=void 0;t.stringToIcon=function(e,n,r,o){void 0===o&&(o="");var i=e.split(":");if("@"===e.slice(0,1)){if(i.length<2||i.length>3)return null;o=i.shift().slice(1)}if(i.length>3||!i.length)return null;if(i.length>1){var a=i.pop(),c=i.pop(),u={provider:i.length>0?i[0]:o,prefix:c,name:a};return n&&!t.validateIcon(u)?null:u}var f=i[0],l=f.split("-");if(l.length>1){var s={provider:o,prefix:l.shift(),name:l.join("-")};return n&&!t.validateIcon(s)?null:s}if(r&&""===o){var d={provider:o,prefix:"",name:f};return n&&!t.validateIcon(d,r)?null:d}return null};t.validateIcon=function(e,t){return!!e&&!(""!==e.provider&&!e.provider.match(n.matchName)||!(t&&""===e.prefix||e.prefix.match(n.matchName))||!e.name.match(n.matchName))}})),i=e((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.listIcons=t.getIcon=t.iconExists=t.addIcon=t.addIconSet=t.getStorage=t.newStorage=void 0;var o=Object.create(null);function i(e,n){return{provider:e,prefix:n,icons:Object.create(null),missing:Object.create(null)}}function a(e,n){void 0===o[e]&&(o[e]=Object.create(null));var t=o[e];return void 0===t[n]&&(t[n]=i(e,n)),t[n]}t.newStorage=i,t.getStorage=a,t.addIconSet=function(e,n,t){void 0===t&&(t="none");var o=Date.now();return r.parseIconSet(n,(function(n,t){null===t?e.missing[n]=o:e.icons[n]=t}),t)},t.addIcon=function(e,t,r){try{if("string"==typeof r.body)return e.icons[t]=Object.freeze(n.fullIcon(r)),!0}catch(e){}return!1},t.iconExists=function(e,n){return void 0!==e.icons[n]},t.getIcon=function(e,n){var t=e.icons[n];return void 0===t?null:t},t.listIcons=function(e,n){var t=[];return("string"==typeof e?[e]:Object.keys(o)).forEach((function(e){("string"==typeof e&&"string"==typeof n?[n]:void 0===o[e]?[]:Object.keys(o[e])).forEach((function(n){var r=a(e,n),o=Object.keys(r.icons).map((function(t){return(""!==e?"@"+e+":":"")+n+":"+t}));t=t.concat(o)}))})),t}})),a=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.storageFunctions=n.addCollection=n.addIcon=n.getIconData=n.allowSimpleNames=void 0;var t=!1;function a(e){var n="string"==typeof e?o.stringToIcon(e,!0,t):e;return n?i.getIcon(i.getStorage(n.provider,n.prefix),n.name):null}function c(e,n){var r=o.stringToIcon(e,!0,t);if(!r)return!1;var a=i.getStorage(r.provider,r.prefix);return i.addIcon(a,r.name,n)}function u(e,n){if("object"!=typeof e)return!1;if("string"!=typeof n&&(n="string"==typeof e.provider?e.provider:""),t&&""===n&&("string"!=typeof e.prefix||""===e.prefix)){var a=!1;return r.parseIconSet(e,(function(e,n){null!==n&&c(e,n)&&(a=!0)})),a}if("string"!=typeof e.prefix||!o.validateIcon({provider:n,prefix:e.prefix,name:"a"}))return!1;var u=i.getStorage(n,e.prefix);return!!i.addIconSet(u,e)}n.allowSimpleNames=function(e){return"boolean"==typeof e&&(t=e),t},n.getIconData=a,n.addIcon=c,n.addCollection=u,n.storageFunctions={iconExists:function(e){return null!==a(e)},getIcon:function(e){var n=a(e);return n?Object.assign({},n):null},listIcons:i.listIcons,addIcon:c,addCollection:u}})),c=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.replaceIDs=void 0;var t=/\sid="(\S+)"/g,r="([^A-Za-z0-9_-])";var o="IconifyId-"+Date.now().toString(16)+"-"+(16777216*Math.random()|0).toString(16)+"-",i=0;n.replaceIDs=function(e,n){void 0===n&&(n=o);for(var a,c=[];a=t.exec(e);)c.push(a[1]);return c.length?(c.forEach((function(t){var o="function"==typeof n?n():n+i++;e=e.replace(new RegExp(r+"("+(t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")+")")+r,"g"),"$1"+o+"$3")})),e):e}})),u=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.calculateSize=void 0;var t=/(-?[0-9.]*[0-9]+[0-9.]*)/g,r=/^-?[0-9.]*[0-9]+[0-9.]*$/g;n.calculateSize=function(e,n,o){if(1===n)return e;if(o=void 0===o?100:o,"number"==typeof e)return Math.ceil(e*n*o)/o;if("string"!=typeof e)return e;var i=e.split(t);if(null===i||!i.length)return e;for(var a=[],c=i.shift(),u=r.test(c);;){if(u){var f=parseFloat(c);isNaN(f)?a.push(c):a.push(Math.ceil(f*n*o)/o)}else a.push(c);if(void 0===(c=i.shift()))return a.join("");u=!u}}})),f=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.mergeCustomisations=n.defaults=void 0,n.defaults=Object.freeze({inline:!1,width:null,height:null,hAlign:"center",vAlign:"middle",slice:!1,hFlip:!1,vFlip:!1,rotate:0}),n.mergeCustomisations=function(e,n){var t={};for(var r in e){var o=r;if(t[o]=e[o],void 0!==n[o]){var i=n[o];switch(o){case"inline":case"slice":"boolean"==typeof i&&(t[o]=i);break;case"hFlip":case"vFlip":!0===i&&(t[o]=!t[o]);break;case"hAlign":case"vAlign":"string"==typeof i&&""!==i&&(t[o]=i);break;case"width":case"height":("string"==typeof i&&""!==i||"number"==typeof i&&i||null===i)&&(t[o]=i);break;case"rotate":"number"==typeof i&&(t[o]+=i)}}}return t}})),l=e((function(e,n){function t(e){var n="";switch(e.hAlign){case"left":n+="xMin";break;case"right":n+="xMax";break;default:n+="xMid"}switch(e.vAlign){case"top":n+="YMin";break;case"bottom":n+="YMax";break;default:n+="YMid"}return n+=e.slice?" slice":" meet"}Object.defineProperty(n,"__esModule",{value:!0}),n.iconToSVG=void 0,n.iconToSVG=function(e,n){var r,o,i={left:e.left,top:e.top,width:e.width,height:e.height},a=e.body;[e,n].forEach((function(e){var n,t=[],r=e.hFlip,o=e.vFlip,c=e.rotate;switch(r?o?c+=2:(t.push("translate("+(i.width+i.left)+" "+(0-i.top)+")"),t.push("scale(-1 1)"),i.top=i.left=0):o&&(t.push("translate("+(0-i.left)+" "+(i.height+i.top)+")"),t.push("scale(1 -1)"),i.top=i.left=0),c<0&&(c-=4*Math.floor(c/4)),c%=4){case 1:n=i.height/2+i.top,t.unshift("rotate(90 "+n+" "+n+")");break;case 2:t.unshift("rotate(180 "+(i.width/2+i.left)+" "+(i.height/2+i.top)+")");break;case 3:n=i.width/2+i.left,t.unshift("rotate(-90 "+n+" "+n+")")}c%2==1&&(0===i.left&&0===i.top||(n=i.left,i.left=i.top,i.top=n),i.width!==i.height&&(n=i.width,i.width=i.height,i.height=n)),t.length&&(a='<g transform="'+t.join(" ")+'">'+a+"</g>")})),null===n.width&&null===n.height?(o="1em",r=u.calculateSize(o,i.width/i.height)):null!==n.width&&null!==n.height?(r=n.width,o=n.height):null!==n.height?(o=n.height,r=u.calculateSize(o,i.width/i.height)):(r=n.width,o=u.calculateSize(r,i.height/i.width)),"auto"===r&&(r=i.width),"auto"===o&&(o=i.height);var c={attributes:{width:r="string"==typeof r?r:r+"",height:o="string"==typeof o?o:o+"",preserveAspectRatio:t(n),viewBox:i.left+" "+i.top+" "+i.width+" "+i.height},body:a};return n.inline&&(c.inline=!0),c}})),s=e((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.builderFunctions=void 0,t.builderFunctions={replaceIDs:c.replaceIDs,calculateSize:u.calculateSize,buildIcon:function(e,t){return l.iconToSVG(n.fullIcon(e),f.mergeCustomisations(f.defaults,t))}}})),d=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.coreModules=void 0,n.coreModules={}})),v=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.storeCache=n.loadCache=n.mock=n.emptyList=n.count=n.config=void 0;var t="iconify2",r="iconify",o="iconify-count",a="iconify-version",c=36e5;n.config={local:!0,session:!0};var u=!1;n.count={local:0,session:0},n.emptyList={local:[],session:[]};var f="undefined"==typeof window?{}:window;function l(e){var t=e+"Storage";try{if(f&&f[t]&&"number"==typeof f[t].length)return f[t]}catch(e){}return n.config[e]=!1,null}function s(e,t,r){try{return e.setItem(o,r+""),n.count[t]=r,!0}catch(e){return!1}}function d(e){var n=e.getItem(o);if(n){var t=parseInt(n);return t||0}return 0}n.mock=function(e){u=!1,f=e};n.loadCache=function(){if(!u){u=!0;var e=Math.floor(Date.now()/c)-168;for(var o in n.config)f(o)}function f(o){var c=l(o);if(c){var u=function(n){var t=r+n,o=c.getItem(t);if("string"!=typeof o)return!1;var a=!0;try{var u=JSON.parse(o);if("object"!=typeof u||"number"!=typeof u.cached||u.cached<e||"string"!=typeof u.provider||"object"!=typeof u.data||"string"!=typeof u.data.prefix)a=!1;else{var f=u.provider,l=u.data.prefix,s=i.getStorage(f,l);a=i.addIconSet(s,u.data)}}catch(e){a=!1}return a||c.removeItem(t),a};try{var f=c.getItem(a);if(f!==t)return f&&function(e){try{for(var n=d(e),t=0;t<n;t++)e.removeItem(r+t)}catch(e){}}(c),void function(e,n){try{e.setItem(a,t)}catch(e){}s(e,n,0)}(c,o);for(var v=d(c),p=v-1;p>=0;p--)u(p)||(p===v-1?v--:n.emptyList[o].push(p));s(c,o,v)}catch(e){}}}};n.storeCache=function(e,t){function o(o){if(!n.config[o])return!1;var i=l(o);if(!i)return!1;var a=n.emptyList[o].shift();if(void 0===a&&!s(i,o,(a=n.count[o])+1))return!1;try{var u={cached:Math.floor(Date.now()/c),provider:e,data:t};i.setItem(r+a,JSON.stringify(u))}catch(e){return!1}return!0}u||n.loadCache(),o("local")||o("session")}})),p=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.toggleBrowserCache=void 0,n.toggleBrowserCache=function(e,n){switch(e){case"local":case"session":v.config[e]=n;break;case"all":for(var t in v.config)v.config[t]=n}}})),h=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.defaultConfig=void 0,n.defaultConfig={resources:[],index:0,timeout:2e3,rotate:750,random:!1,dataAfterTimeout:!1}})),g=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.sendQuery=void 0,n.sendQuery=function(e,n,t,r,o){var i,a=e.resources.length,c=e.random?Math.floor(Math.random()*a):e.index;if(e.random){var u=e.resources.slice(0);for(i=[];u.length>1;){var f=Math.floor(Math.random()*u.length);i.push(u[f]),u=u.slice(0,f).concat(u.slice(f+1))}i=i.concat(u)}else i=e.resources.slice(c).concat(e.resources.slice(0,c));var l=Date.now(),s="pending",d=0,v=void 0,p=null,h=[],g=[];function m(){p&&(clearTimeout(p),p=null)}function b(){"pending"===s&&(s="aborted"),m(),h.forEach((function(e){e.abort&&e.abort(),"pending"===e.status&&(e.status="aborted")})),h=[]}function y(e,n){n&&(g=[]),"function"==typeof e&&g.push(e)}function I(){return{startTime:l,payload:n,status:s,queriesSent:d,queriesPending:h.length,subscribe:y,abort:b}}function j(){s="failed",g.forEach((function(e){e(void 0,v)}))}function x(){h=h.filter((function(e){return"pending"===e.status&&(e.status="aborted"),e.abort&&e.abort(),!1}))}function O(){if("pending"===s){m();var r=i.shift();if(void 0!==r){var a={getQueryStatus:I,status:"pending",resource:r,done:function(n,t){!function(n,t,r){var a=void 0===t;switch(h=h.filter((function(e){return e!==n})),s){case"pending":break;case"failed":if(a||!e.dataAfterTimeout)return;break;default:return}if(a)return void 0!==r&&(v=r),void(h.length||(i.length?O():j()));if(m(),x(),o&&!e.random){var c=e.resources.indexOf(n.resource);-1!==c&&c!==e.index&&o(c)}s="completed",g.forEach((function(e){e(t)}))}(a,n,t)}};h.push(a),d++;var c="function"==typeof e.rotate?e.rotate(d,l):e.rotate;p=setTimeout(O,c),t(r,n,a)}else{if(h.length){var u="function"==typeof e.timeout?e.timeout(l):e.timeout;if(u)return void(p=setTimeout((function(){m(),"pending"===s&&(x(),j())}),u))}j()}}}return"function"==typeof r&&g.push(r),setTimeout(O),I}})),m=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.initRedundancy=void 0,n.initRedundancy=function(e){var n=function(e){if(!("object"==typeof e&&"object"==typeof e.resources&&e.resources instanceof Array&&e.resources.length))throw new Error("Invalid Reduncancy configuration");var n,t=Object.create(null);for(n in h.defaultConfig)void 0!==e[n]?t[n]=e[n]:t[n]=h.defaultConfig[n];return t}(e),t=[];function r(){t=t.filter((function(e){return"pending"===e().status}))}return{query:function(e,o,i){var a=g.sendQuery(n,e,o,(function(e,n){r(),i&&i(e,n)}),(function(e){n.index=e}));return t.push(a),a},find:function(e){var n=t.find((function(n){return e(n)}));return void 0!==n?n:null},setIndex:function(e){n.index=e},getIndex:function(){return n.index},cleanup:r}}})),b=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.sortIcons=void 0,n.sortIcons=function(e){var n={loaded:[],missing:[],pending:[]},t=Object.create(null);e.sort((function(e,n){return e.provider!==n.provider?e.provider.localeCompare(n.provider):e.prefix!==n.prefix?e.prefix.localeCompare(n.prefix):e.name.localeCompare(n.name)}));var r={provider:"",prefix:"",name:""};return e.forEach((function(e){if(r.name!==e.name||r.prefix!==e.prefix||r.provider!==e.provider){r=e;var o=e.provider,a=e.prefix,c=e.name;void 0===t[o]&&(t[o]=Object.create(null));var u=t[o];void 0===u[a]&&(u[a]=i.getStorage(o,a));var f=u[a],l={provider:o,prefix:a,name:c};(void 0!==f.icons[c]?n.loaded:""===a||void 0!==f.missing[c]?n.missing:n.pending).push(l)}})),n}})),y=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.storeCallback=n.updateCallbacks=n.callbacks=void 0,n.callbacks=Object.create(null);var t=Object.create(null);function r(e,t){e.forEach((function(e){var r=e.provider;if(void 0!==n.callbacks[r]){var o=n.callbacks[r],i=e.prefix,a=o[i];a&&(o[i]=a.filter((function(e){return e.id!==t})))}}))}n.updateCallbacks=function(e,o){void 0===t[e]&&(t[e]=Object.create(null));var a=t[e];a[o]||(a[o]=!0,setTimeout((function(){if(a[o]=!1,void 0!==n.callbacks[e]&&void 0!==n.callbacks[e][o]){var t=n.callbacks[e][o].slice(0);if(t.length){var c=i.getStorage(e,o),u=!1;t.forEach((function(n){var t=n.icons,i=t.pending.length;t.pending=t.pending.filter((function(n){if(n.prefix!==o)return!0;var r=n.name;if(void 0!==c.icons[r])t.loaded.push({provider:e,prefix:o,name:r});else{if(void 0===c.missing[r])return u=!0,!0;t.missing.push({provider:e,prefix:o,name:r})}return!1})),t.pending.length!==i&&(u||r([{provider:e,prefix:o}],n.id),n.callback(t.loaded.slice(0),t.missing.slice(0),t.pending.slice(0),n.abort))}))}}})))};var o=0;n.storeCallback=function(e,t,i){var a=o++,c=r.bind(null,i,a);if(!t.pending.length)return c;var u={id:a,icons:t,callback:e,abort:c};return i.forEach((function(e){var t=e.provider,r=e.prefix;void 0===n.callbacks[t]&&(n.callbacks[t]=Object.create(null));var o=n.callbacks[t];void 0===o[r]&&(o[r]=[]),o[r].push(u)})),c}})),I=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.getAPIModule=n.setAPIModule=void 0;var t=Object.create(null);n.setAPIModule=function(e,n){t[e]=n},n.getAPIModule=function(e){return void 0===t[e]?t[""]:t[e]}})),j=e((function(e,n){function t(e){var n;if("string"==typeof e.resources)n=[e.resources];else if(!((n=e.resources)instanceof Array&&n.length))return null;return{resources:n,path:void 0===e.path?"/":e.path,maxURL:e.maxURL?e.maxURL:500,rotate:e.rotate?e.rotate:750,timeout:e.timeout?e.timeout:5e3,random:!0===e.random,index:e.index?e.index:0,dataAfterTimeout:!1!==e.dataAfterTimeout}}Object.defineProperty(n,"__esModule",{value:!0}),n.getAPIConfig=n.setAPIConfig=void 0;for(var r=Object.create(null),o=["https://api.simplesvg.com","https://api.unisvg.com"],i=[];o.length>0;)1===o.length||Math.random()>.5?i.push(o.shift()):i.push(o.pop());r[""]=t({resources:["https://api.iconify.design"].concat(i)}),n.setAPIConfig=function(e,n){var o=t(n);return null!==o&&(r[e]=o,!0)};n.getAPIConfig=function(e){return r[e]}})),x=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.getProviders=n.listToIcons=void 0,n.listToIcons=function(e,n,t){void 0===n&&(n=!0),void 0===t&&(t=!1);var r=[];return e.forEach((function(e){var i="string"==typeof e?o.stringToIcon(e,!1,t):e;n&&!o.validateIcon(i,t)||r.push({provider:i.provider,prefix:i.prefix,name:i.name})})),r},n.getProviders=function(e){var n=Object.create(null);return e.forEach((function(e){n[e.provider]=!0})),Object.keys(n)}})),O=e((function(e,n){function t(){}Object.defineProperty(n,"__esModule",{value:!0}),n.API=n.getRedundancyCache=void 0;var r=Object.create(null),o=Object.create(null),c=Object.create(null),u=Object.create(null),f=Object.create(null);function l(e){if(void 0===f[e]){var n=j.getAPIConfig(e);if(!n)return;var t={config:n,redundancy:m.initRedundancy(n)};f[e]=t}return f[e]}n.getRedundancyCache=l;var s=Object.create(null);function v(e,n,t){function a(){var t=(""===e?"":"@"+e+":")+n,r=Math.floor(Date.now()/6e4);s[t]<r&&(s[t]=r,console.error('Unable to retrieve icons for "'+t+'" because API is not configured properly.'))}void 0===o[e]&&(o[e]=Object.create(null));var f=o[e];void 0===u[e]&&(u[e]=Object.create(null));var v=u[e];void 0===r[e]&&(r[e]=Object.create(null));var p,h=r[e];void 0===f[n]?f[n]=t:f[n]=f[n].concat(t).sort(),v[n]||(v[n]=!0,setTimeout((function(){v[n]=!1;var t=f[n];delete f[n];var r=I.getAPIModule(e);if(r){if(void 0===p){var o=l(e);if(void 0===o)return void a();p=o}r.prepare(e,n,t).forEach((function(t){p.redundancy.query(t,r.send,(function(r,o){var a=i.getStorage(e,n);if("object"!=typeof r){if(404!==o)return;var u=Date.now();t.icons.forEach((function(e){a.missing[e]=u}))}else try{var f=i.addIconSet(a,r,"all");if("boolean"==typeof f)return;var l=h[n];f.forEach((function(e){delete l[e]})),d.coreModules.cache&&d.coreModules.cache(e,r)}catch(e){console.error(e)}!function(e,n){void 0===c[e]&&(c[e]=Object.create(null));var t=c[e];t[n]||(t[n]=!0,setTimeout((function(){t[n]=!1,y.updateCallbacks(e,n)})))}(e,n)}))}))}else a()})))}n.API={isPending:function(e){return void 0!==r[e.provider]&&void 0!==r[e.provider][e.prefix]&&void 0!==r[e.provider][e.prefix][e.name]},loadIcons:function(e,n){var o=x.listToIcons(e,!0,a.allowSimpleNames()),i=b.sortIcons(o);if(!i.pending.length){var c=!0;return n&&setTimeout((function(){c&&n(i.loaded,i.missing,i.pending,t)})),function(){c=!1}}var u,f,l=Object.create(null),s=[];i.pending.forEach((function(e){var n=e.provider,t=e.prefix;if(t!==f||n!==u){u=n,f=t,s.push({provider:n,prefix:t}),void 0===r[n]&&(r[n]=Object.create(null));var o=r[n];void 0===o[t]&&(o[t]=Object.create(null)),void 0===l[n]&&(l[n]=Object.create(null));var i=l[n];void 0===i[t]&&(i[t]=[])}}));var d=Date.now();return i.pending.forEach((function(e){var n=e.provider,t=e.prefix,o=e.name,i=r[n][t];void 0===i[o]&&(i[o]=d,l[n][t].push(o))})),s.forEach((function(e){var n=e.provider,t=e.prefix;l[n][t].length&&v(n,t,l[n][t])})),n?y.storeCallback(n,i,s):t}}})),P=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.APIInternalFunctions=n.APIFunctions=void 0,n.APIFunctions={loadIcons:O.API.loadIcons,addAPIProvider:j.setAPIConfig},n.APIInternalFunctions={getAPI:O.getRedundancyCache,getAPIConfig:j.getAPIConfig,setAPIModule:I.setAPIModule}})),w=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.getAPIModule=void 0;var t=null,r="{prefix}.js?icons={icons}&callback={callback}",o=Object.create(null),i=Object.create(null);function a(){if(null===t){var e=self,n="Iconify",o=".cb";if(void 0===e[n])o="",void 0===e[n="IconifyJSONP"]&&(e[n]=Object.create(null)),t=e[n];else{var i=e[n];void 0===i.cb&&(i.cb=Object.create(null)),t=i.cb}r=r.replace("{callback}",n+o+".{cb}")}return t}n.getAPIModule=function(e){return{prepare:function(n,t,c){var u=[],f=o[n+":"+t];void 0===f&&(f=function(n,t){var c,u=e(n);if(!u)return 0;if(u.maxURL){var f=0;u.resources.forEach((function(e){var n=e;f=Math.max(f,n.length)})),a(),c=u.maxURL-f-u.path.length-r.replace("{provider}",n).replace("{prefix}",t).replace("{icons}","").length-3}else c=0;var l=n+":"+t;return i[l]=u.path,o[l]=c,c}(n,t));var l={provider:n,prefix:t,icons:[]},s=0;return c.forEach((function(e,r){(s+=e.length+1)>=f&&r>0&&(u.push(l),l={provider:n,prefix:t,icons:[]},s=e.length),l.icons.push(e)})),u.push(l),u},send:function(e,n,t){for(var o=n.provider,c=n.prefix,u=n.icons.join(","),f=o+":"+c,l=c.split("-").shift().slice(0,3),s=a(),d=function(e){var n,t=0;for(n=e.length-1;n>=0;n--)t+=e.charCodeAt(n);return t%999}(o+":"+e+":"+c+":"+u);void 0!==s[l+d];)d++;var v=l+d,p=i[f]+r.replace("{provider}",o).replace("{prefix}",c).replace("{icons}",u).replace("{cb}",v);s[v]=function(e){delete s[v],t.done(e)};var h=e+p,g=document.createElement("script");g.type="text/javascript",g.async=!0,g.src=h,document.head.appendChild(g)}}}})),M=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.getAPIModule=n.setFetch=void 0;var t="{prefix}.json?icons={icons}",r=Object.create(null),o=Object.create(null),i=null;try{i=fetch}catch(e){}n.setFetch=function(e){i=e};n.getAPIModule=function(e){return{prepare:function(n,i,a){var c=[],u=r[i];void 0===u&&(u=function(n,i){var a,c=e(n);if(!c)return 0;if(c.maxURL){var u=0;c.resources.forEach((function(e){var n=e;u=Math.max(u,n.length)})),a=c.maxURL-u-c.path.length-t.replace("{provider}",n).replace("{prefix}",i).replace("{icons}","").length}else a=0;var f=n+":"+i;return o[f]=c.path,r[f]=a,a}(n,i));var f={provider:n,prefix:i,icons:[]},l=0;return a.forEach((function(e,t){(l+=e.length+1)>=u&&t>0&&(c.push(f),f={provider:n,prefix:i,icons:[]},l=e.length),f.icons.push(e)})),c.push(f),c},send:function(e,n,r){var a=n.provider,c=n.prefix,u=n.icons.join(","),f=o[a+":"+c]+t.replace("{provider}",a).replace("{prefix}",c).replace("{icons}",u);i?i(e+f).then((function(e){if(200===e.status)return e.json();r.done(void 0,e.status)})).then((function(e){"object"==typeof e&&null!==e&&r.done(e)})).catch((function(e){r.done(void 0,e.errno)})):r.done(void 0,424)}}}})),A="iconifyFinder"+Date.now(),S="iconifyData"+Date.now();function _(e,n,t,r){var o;try{o=document.createElement("span")}catch(e){return r?"":null}var i=l.iconToSVG(t,f.mergeCustomisations(f.defaults,n)),a=e.element,u=e.finder,s=e.name,d=a?a.getAttribute("class"):"",v=u?u.classFilter(d?d.split(/\s+/):[]):[],p='<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="'+("iconify iconify--"+s.prefix+(""===s.provider?"":" iconify--"+s.provider)+(v.length?" "+v.join(" "):""))+'">'+c.replaceIDs(i.body)+"</svg>";o.innerHTML=p;var h=o.childNodes[0],g=h.style,m=i.attributes;if(Object.keys(m).forEach((function(e){h.setAttribute(e,m[e])})),i.inline&&(g.verticalAlign="-0.125em"),a){for(var b=a.attributes,y=0;y<b.length;y++){var I=b.item(y);if(I){var j=I.name;if("class"!==j&&"style"!==j&&void 0===m[j])try{h.setAttribute(j,I.value)}catch(e){}}}for(var x=a.style,O=0;O<x.length;O++){var P=x[O];g[P]=x[P]}}if(u){var w={name:s,status:"loaded",customisations:n};h[S]=w,h[A]=u}var M=r?o.innerHTML:h;return a&&a.parentNode?a.parentNode.replaceChild(h,a):o.removeChild(h),M}var E=[];function k(e){for(var n=0;n<E.length;n++){var t=E[n];if(("function"==typeof t.node?t.node():t.node)===e)return t}}function C(e,n){void 0===n&&(n=!1);var t=k(e);return t?(t.temporary&&(t.temporary=n),t):(t={node:e,temporary:n},E.push(t),t)}function F(){return E}var T=null,D={childList:!0,subtree:!0,attributes:!0};function N(e){if(e.observer){var n=e.observer;n.pendingScan||(n.pendingScan=setTimeout((function(){delete n.pendingScan,T&&T(e)})))}}function L(e,n){if(e.observer){var t=e.observer;if(!t.pendingScan)for(var r=0;r<n.length;r++){var o=n[r];if(o.addedNodes&&o.addedNodes.length>0||"attributes"===o.type&&void 0!==o.target[A])return void(t.paused||N(e))}}}function z(e,n){e.observer.instance.observe(n,D)}function R(e){var n=e.observer;if(!n||!n.instance){var t="function"==typeof e.node?e.node():e.node;t&&(n||(n={paused:0},e.observer=n),n.instance=new MutationObserver(L.bind(null,e)),z(e,t),n.paused||N(e))}}function q(){F().forEach(R)}function U(e){if(e.observer){var n=e.observer;n.pendingScan&&(clearTimeout(n.pendingScan),delete n.pendingScan),n.instance&&(n.instance.disconnect(),delete n.instance)}}function V(e){var n=null!==T;T!==e&&(T=e,n&&F().forEach(U)),n?q():function(e){var n=document;"complete"===n.readyState||"loading"!==n.readyState&&!n.documentElement.doScroll?e():(n.addEventListener("DOMContentLoaded",e),window.addEventListener("load",e))}(q)}function G(e){(e?[e]:F()).forEach((function(e){if(e.observer){var n=e.observer;if(n.paused++,!(n.paused>1)&&n.instance)n.instance.disconnect()}else e.observer={paused:1}}))}function $(e){(e?[e]:F()).forEach((function(e){if(e.observer){var n=e.observer;if(n.paused&&(n.paused--,!n.paused)){var t="function"==typeof e.node?e.node():e.node;if(!t)return;n.instance?z(e,t):R(e)}}else R(e)}))}function B(e,n){void 0===n&&(n=!1);var t=C(e,n);return R(t),t}function Q(e){var n=k(e);n&&(U(n),function(e){E=E.filter((function(n){var t="function"==typeof n.node?n.node():n.node;return e!==t}))}(e))}var H=[];function J(e){return"string"==typeof e&&(e=o.stringToIcon(e)),null!==e&&o.validateIcon(e)?e:null}function Y(e){var n=[];H.forEach((function(t){var r=t.find(e);Array.prototype.forEach.call(r,(function(e){var r=e;if(void 0===r[A]||r[A]===t){var o=J(t.name(r));if(null!==o){r[A]=t;var i={element:r,finder:t,name:o};n.push(i)}}}))}));var t=e.querySelectorAll("svg.iconify");return Array.prototype.forEach.call(t,(function(e){var t=e,r=t[A],o=t[S];if(r&&o){var i=J(r.name(t));if(null!==i){var a,c=!1;if(i.prefix!==o.name.prefix||i.name!==o.name.name?c=!0:(a=r.customisations(t),function(e,n){var t=Object.keys(e),r=Object.keys(n);if(t.length!==r.length)return!1;for(var o=0;o<t.length;o++){var i=t[o];if(n[i]!==e[i])return!1}return!0}(o.customisations,a)||(c=!0)),c){var u={element:t,finder:r,name:i,customisations:a};n.push(u)}}}})),n}var Z=!1;function K(){Z||(Z=!0,setTimeout((function(){Z&&(Z=!1,W())})))}function W(e,n){void 0===n&&(n=!1),Z=!1;var t=Object.create(null);if((e?[e]:F()).forEach((function(e){var r="function"==typeof e.node?e.node():e.node;if(r&&r.querySelectorAll){var o=!1,a=!1;Y(r).forEach((function(n){var r,c,u=n.element,f=n.name,l=f.provider,s=f.prefix,v=f.name,p=u[S];if(void 0!==p&&(r=p.name,c=f,null!==r&&null!==c&&r.name===c.name&&r.prefix===c.prefix))switch(p.status){case"missing":return;case"loading":if(d.coreModules.api&&d.coreModules.api.isPending({provider:l,prefix:s,name:v}))return void(o=!0)}var h=i.getStorage(l,s);if(void 0===h.icons[v]){if(h.missing[v])return p={name:f,status:"missing",customisations:{}},void(u[S]=p);if(d.coreModules.api&&!d.coreModules.api.isPending({provider:l,prefix:s,name:v})){void 0===t[l]&&(t[l]=Object.create(null));var g=t[l];void 0===g[s]&&(g[s]=Object.create(null)),g[s][v]=!0}p={name:f,status:"loading",customisations:{}},u[S]=p,o=!0}else{!a&&e.observer&&(G(e),a=!0);var m=void 0!==n.customisations?n.customisations:n.finder.customisations(u);_(n,m,i.getIcon(h,v))}})),e.temporary&&!o?Q(r):n&&o?B(r,!0):a&&e.observer&&$(e)}})),d.coreModules.api){var r=d.coreModules.api;Object.keys(t).forEach((function(e){var n=t[e];Object.keys(n).forEach((function(t){r.loadIcons(Object.keys(n[t]).map((function(n){return{provider:e,prefix:t,name:n}})),K)}))}))}}var X=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.rotateFromString=void 0,n.rotateFromString=function(e){var n=e.replace(/^-?[0-9.]*/,"");function t(e){for(;e<0;)e+=4;return e%4}if(""===n){var r=parseInt(e);return isNaN(r)?0:t(r)}if(n!==e){var o=0;switch(n){case"%":o=25;break;case"deg":o=90}if(o){var i=parseFloat(e.slice(0,e.length-n.length));return isNaN(i)?0:(i/=o)%1==0?t(i):0}}return 0}})),ee=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.alignmentFromString=n.flipFromString=void 0;var t=/[\s,]+/;n.flipFromString=function(e,n){n.split(t).forEach((function(n){switch(n.trim()){case"horizontal":e.hFlip=!0;break;case"vertical":e.vFlip=!0}}))},n.alignmentFromString=function(e,n){n.split(t).forEach((function(n){var t=n.trim();switch(t){case"left":case"center":case"right":e.hAlign=t;break;case"top":case"middle":case"bottom":e.vAlign=t;break;case"slice":case"crop":e.slice=!0;break;case"meet":e.slice=!1}}))}}));function ne(e,n){return e.hasAttribute(n)}function te(e,n){return e.getAttribute(n)}var re=["inline","hFlip","vFlip"],oe=["width","height"],ie="iconify-inline",ae={find:function(e){return e.querySelectorAll("i.iconify, span.iconify, i.iconify-inline, span.iconify-inline")},name:function(e){return ne(e,"data-icon")?te(e,"data-icon"):null},customisations:function(e,n){void 0===n&&(n={inline:!1});var t=n,r=e.getAttribute("class");if(-1!==(r?r.split(/\s+/):[]).indexOf(ie)&&(t.inline=!0),ne(e,"data-rotate")){var o=X.rotateFromString(te(e,"data-rotate"));o&&(t.rotate=o)}return ne(e,"data-flip")&&ee.flipFromString(t,te(e,"data-flip")),ne(e,"data-align")&&ee.alignmentFromString(t,te(e,"data-align")),re.forEach((function(n){if(ne(e,"data-"+n)){var r=function(e,n){var t=e.getAttribute(n);return t===n||"true"===t||""!==t&&"false"!==t&&null}(e,"data-"+n);"boolean"==typeof r&&(t[n]=r)}})),oe.forEach((function(n){if(ne(e,"data-"+n)){var r=te(e,"data-"+n);""!==r&&(t[n]=r)}})),t},classFilter:function(e){var n=[];return e.forEach((function(e){"iconify"!==e&&""!==e&&"iconify--"!==e.slice(0,9)&&n.push(e)})),n}};function ce(e,n,t){var r=a.getIconData(e);return r?_({name:o.stringToIcon(e)},f.mergeCustomisations(f.defaults,"object"==typeof n?n:{}),r,t):null}var ue={getVersion:function(){return"2.0.4"},renderSVG:function(e,n){return ce(e,n,!1)},renderHTML:function(e,n){return ce(e,n,!0)},renderIcon:function(e,n){var t=a.getIconData(e);if(!t)return null;var r=f.mergeCustomisations(f.defaults,"object"==typeof n?n:{});return l.iconToSVG(t,r)},scan:function(e){e?function(e){var n=k(e);n?W(n):W({node:e,temporary:!0},!0)}(e):W()},observe:function(e){B(e)},stopObserving:function(e){Q(e)},pauseObserver:function(e){if(e){var n=k(e);n&&G(n)}else G()},resumeObserver:function(e){if(e){var n=k(e);n&&$(n)}else $()}};if("undefined"!=typeof document&&"undefined"!=typeof window){!function(){if(document.documentElement)return C(document.documentElement);E.push({node:function(){return document.documentElement}})}(),function(e){-1===H.indexOf(e)&&H.push(e)}(ae);var fe=window;if(void 0!==fe.IconifyPreload){var le=fe.IconifyPreload,se="Invalid IconifyPreload syntax.";"object"==typeof le&&null!==le&&(le instanceof Array?le:[le]).forEach((function(e){try{("object"!=typeof e||null===e||e instanceof Array||"object"!=typeof e.icons||"string"!=typeof e.prefix||!a.storageFunctions.addCollection(e))&&console.error(se)}catch(e){console.error(se)}}))}setTimeout((function(){V(W),W()}))}var de={enableCache:function(e,n){return p.toggleBrowserCache(e,!1!==n)},disableCache:function(e){return p.toggleBrowserCache(e,!0)}},ve={_api:P.APIInternalFunctions};[a.storageFunctions,s.builderFunctions,ue,de,P.APIFunctions].forEach((function(e){for(var n in e)ve[n]=e[n]})),d.coreModules.api=O.API;var pe=M.getAPIModule;try{"undefined"!=typeof document&&"undefined"!=typeof window&&(pe="function"==typeof fetch&&"function"==typeof Promise?M.getAPIModule:w.getAPIModule)}catch(se){}if(I.setAPIModule("",pe(j.getAPIConfig)),ve._api.setFetch=function(e){M.setFetch(e),pe!==M.getAPIModule&&(pe=M.getAPIModule,I.setAPIModule("",pe(j.getAPIConfig)))},"undefined"!=typeof document&&"undefined"!=typeof window){d.coreModules.cache=v.storeCache,v.loadCache();var he=window;if(void 0!==he.IconifyProviders){var ge=he.IconifyProviders;if("object"==typeof ge&&null!==ge)for(var me in ge){var be="IconifyProviders["+me+"] is invalid.";try{var ye=ge[me];if("object"!=typeof ye||!ye||void 0===ye.resources)continue;j.setAPIConfig(me,ye)||console.error(be)}catch(e){console.error(be)}}}}return ve}();try{void 0===self.Iconify&&(self.Iconify=Iconify)}catch(e){}if(true)try{exports.__esModule=!0,exports["default"]=Iconify}catch(e){}


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/leaflet/dist/leaflet.css":
/*!*************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/leaflet/dist/leaflet.css ***!
  \*************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! images/layers.png */ "./node_modules/leaflet/dist/images/layers.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! images/layers-2x.png */ "./node_modules/leaflet/dist/images/layers-2x.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(/*! images/marker-icon.png */ "./node_modules/leaflet/dist/images/marker-icon.png"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* required styles */\r\n\r\n.leaflet-pane,\r\n.leaflet-tile,\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow,\r\n.leaflet-tile-container,\r\n.leaflet-pane > svg,\r\n.leaflet-pane > canvas,\r\n.leaflet-zoom-box,\r\n.leaflet-image-layer,\r\n.leaflet-layer {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\t}\r\n.leaflet-container {\r\n\toverflow: hidden;\r\n\t}\r\n.leaflet-tile,\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow {\r\n\t-webkit-user-select: none;\r\n\t   -moz-user-select: none;\r\n\t        user-select: none;\r\n\t  -webkit-user-drag: none;\r\n\t}\r\n/* Prevents IE11 from highlighting tiles in blue */\r\n.leaflet-tile::selection {\r\n\tbackground: transparent;\r\n}\r\n/* Safari renders non-retina tile on retina better with this, but Chrome is worse */\r\n.leaflet-safari .leaflet-tile {\r\n\timage-rendering: -webkit-optimize-contrast;\r\n\t}\r\n/* hack that prevents hw layers \"stretching\" when loading new tiles */\r\n.leaflet-safari .leaflet-tile-container {\r\n\twidth: 1600px;\r\n\theight: 1600px;\r\n\t-webkit-transform-origin: 0 0;\r\n\t}\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow {\r\n\tdisplay: block;\r\n\t}\r\n/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */\r\n/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */\r\n.leaflet-container .leaflet-overlay-pane svg,\r\n.leaflet-container .leaflet-marker-pane img,\r\n.leaflet-container .leaflet-shadow-pane img,\r\n.leaflet-container .leaflet-tile-pane img,\r\n.leaflet-container img.leaflet-image-layer,\r\n.leaflet-container .leaflet-tile {\r\n\tmax-width: none !important;\r\n\tmax-height: none !important;\r\n\t}\r\n\r\n.leaflet-container.leaflet-touch-zoom {\r\n\t-ms-touch-action: pan-x pan-y;\r\n\ttouch-action: pan-x pan-y;\r\n\t}\r\n.leaflet-container.leaflet-touch-drag {\r\n\t-ms-touch-action: pinch-zoom;\r\n\t/* Fallback for FF which doesn't support pinch-zoom */\r\n\ttouch-action: none;\r\n\ttouch-action: pinch-zoom;\r\n}\r\n.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {\r\n\t-ms-touch-action: none;\r\n\ttouch-action: none;\r\n}\r\n.leaflet-container {\r\n\t-webkit-tap-highlight-color: transparent;\r\n}\r\n.leaflet-container a {\r\n\t-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);\r\n}\r\n.leaflet-tile {\r\n\tfilter: inherit;\r\n\tvisibility: hidden;\r\n\t}\r\n.leaflet-tile-loaded {\r\n\tvisibility: inherit;\r\n\t}\r\n.leaflet-zoom-box {\r\n\twidth: 0;\r\n\theight: 0;\r\n\t-moz-box-sizing: border-box;\r\n\t     box-sizing: border-box;\r\n\tz-index: 800;\r\n\t}\r\n/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */\r\n.leaflet-overlay-pane svg {\r\n\t-moz-user-select: none;\r\n\t}\r\n\r\n.leaflet-pane         { z-index: 400; }\r\n\r\n.leaflet-tile-pane    { z-index: 200; }\r\n.leaflet-overlay-pane { z-index: 400; }\r\n.leaflet-shadow-pane  { z-index: 500; }\r\n.leaflet-marker-pane  { z-index: 600; }\r\n.leaflet-tooltip-pane   { z-index: 650; }\r\n.leaflet-popup-pane   { z-index: 700; }\r\n\r\n.leaflet-map-pane canvas { z-index: 100; }\r\n.leaflet-map-pane svg    { z-index: 200; }\r\n\r\n.leaflet-vml-shape {\r\n\twidth: 1px;\r\n\theight: 1px;\r\n\t}\r\n.lvml {\r\n\tbehavior: url(#default#VML);\r\n\tdisplay: inline-block;\r\n\tposition: absolute;\r\n\t}\r\n\r\n\r\n/* control positioning */\r\n\r\n.leaflet-control {\r\n\tposition: relative;\r\n\tz-index: 800;\r\n\tpointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\r\n\tpointer-events: auto;\r\n\t}\r\n.leaflet-top,\r\n.leaflet-bottom {\r\n\tposition: absolute;\r\n\tz-index: 1000;\r\n\tpointer-events: none;\r\n\t}\r\n.leaflet-top {\r\n\ttop: 0;\r\n\t}\r\n.leaflet-right {\r\n\tright: 0;\r\n\t}\r\n.leaflet-bottom {\r\n\tbottom: 0;\r\n\t}\r\n.leaflet-left {\r\n\tleft: 0;\r\n\t}\r\n.leaflet-control {\r\n\tfloat: left;\r\n\tclear: both;\r\n\t}\r\n.leaflet-right .leaflet-control {\r\n\tfloat: right;\r\n\t}\r\n.leaflet-top .leaflet-control {\r\n\tmargin-top: 10px;\r\n\t}\r\n.leaflet-bottom .leaflet-control {\r\n\tmargin-bottom: 10px;\r\n\t}\r\n.leaflet-left .leaflet-control {\r\n\tmargin-left: 10px;\r\n\t}\r\n.leaflet-right .leaflet-control {\r\n\tmargin-right: 10px;\r\n\t}\r\n\r\n\r\n/* zoom and fade animations */\r\n\r\n.leaflet-fade-anim .leaflet-tile {\r\n\twill-change: opacity;\r\n\t}\r\n.leaflet-fade-anim .leaflet-popup {\r\n\topacity: 0;\r\n\t-webkit-transition: opacity 0.2s linear;\r\n\t   -moz-transition: opacity 0.2s linear;\r\n\t        transition: opacity 0.2s linear;\r\n\t}\r\n.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {\r\n\topacity: 1;\r\n\t}\r\n.leaflet-zoom-animated {\r\n\t-webkit-transform-origin: 0 0;\r\n\t    -ms-transform-origin: 0 0;\r\n\t        transform-origin: 0 0;\r\n\t}\r\n.leaflet-zoom-anim .leaflet-zoom-animated {\r\n\twill-change: transform;\r\n\t}\r\n.leaflet-zoom-anim .leaflet-zoom-animated {\r\n\t-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);\r\n\t   -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);\r\n\t        transition:         transform 0.25s cubic-bezier(0,0,0.25,1);\r\n\t}\r\n.leaflet-zoom-anim .leaflet-tile,\r\n.leaflet-pan-anim .leaflet-tile {\r\n\t-webkit-transition: none;\r\n\t   -moz-transition: none;\r\n\t        transition: none;\r\n\t}\r\n\r\n.leaflet-zoom-anim .leaflet-zoom-hide {\r\n\tvisibility: hidden;\r\n\t}\r\n\r\n\r\n/* cursors */\r\n\r\n.leaflet-interactive {\r\n\tcursor: pointer;\r\n\t}\r\n.leaflet-grab {\r\n\tcursor: -webkit-grab;\r\n\tcursor:    -moz-grab;\r\n\tcursor:         grab;\r\n\t}\r\n.leaflet-crosshair,\r\n.leaflet-crosshair .leaflet-interactive {\r\n\tcursor: crosshair;\r\n\t}\r\n.leaflet-popup-pane,\r\n.leaflet-control {\r\n\tcursor: auto;\r\n\t}\r\n.leaflet-dragging .leaflet-grab,\r\n.leaflet-dragging .leaflet-grab .leaflet-interactive,\r\n.leaflet-dragging .leaflet-marker-draggable {\r\n\tcursor: move;\r\n\tcursor: -webkit-grabbing;\r\n\tcursor:    -moz-grabbing;\r\n\tcursor:         grabbing;\r\n\t}\r\n\r\n/* marker & overlays interactivity */\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow,\r\n.leaflet-image-layer,\r\n.leaflet-pane > svg path,\r\n.leaflet-tile-container {\r\n\tpointer-events: none;\r\n\t}\r\n\r\n.leaflet-marker-icon.leaflet-interactive,\r\n.leaflet-image-layer.leaflet-interactive,\r\n.leaflet-pane > svg path.leaflet-interactive,\r\nsvg.leaflet-image-layer.leaflet-interactive path {\r\n\tpointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\r\n\tpointer-events: auto;\r\n\t}\r\n\r\n/* visual tweaks */\r\n\r\n.leaflet-container {\r\n\tbackground: #ddd;\r\n\toutline: 0;\r\n\t}\r\n.leaflet-container a {\r\n\tcolor: #0078A8;\r\n\t}\r\n.leaflet-container a.leaflet-active {\r\n\toutline: 2px solid orange;\r\n\t}\r\n.leaflet-zoom-box {\r\n\tborder: 2px dotted #38f;\r\n\tbackground: rgba(255,255,255,0.5);\r\n\t}\r\n\r\n\r\n/* general typography */\r\n.leaflet-container {\r\n\tfont: 12px/1.5 \"Helvetica Neue\", Arial, Helvetica, sans-serif;\r\n\t}\r\n\r\n\r\n/* general toolbar styles */\r\n\r\n.leaflet-bar {\r\n\tbox-shadow: 0 1px 5px rgba(0,0,0,0.65);\r\n\tborder-radius: 4px;\r\n\t}\r\n.leaflet-bar a,\r\n.leaflet-bar a:hover {\r\n\tbackground-color: #fff;\r\n\tborder-bottom: 1px solid #ccc;\r\n\twidth: 26px;\r\n\theight: 26px;\r\n\tline-height: 26px;\r\n\tdisplay: block;\r\n\ttext-align: center;\r\n\ttext-decoration: none;\r\n\tcolor: black;\r\n\t}\r\n.leaflet-bar a,\r\n.leaflet-control-layers-toggle {\r\n\tbackground-position: 50% 50%;\r\n\tbackground-repeat: no-repeat;\r\n\tdisplay: block;\r\n\t}\r\n.leaflet-bar a:hover {\r\n\tbackground-color: #f4f4f4;\r\n\t}\r\n.leaflet-bar a:first-child {\r\n\tborder-top-left-radius: 4px;\r\n\tborder-top-right-radius: 4px;\r\n\t}\r\n.leaflet-bar a:last-child {\r\n\tborder-bottom-left-radius: 4px;\r\n\tborder-bottom-right-radius: 4px;\r\n\tborder-bottom: none;\r\n\t}\r\n.leaflet-bar a.leaflet-disabled {\r\n\tcursor: default;\r\n\tbackground-color: #f4f4f4;\r\n\tcolor: #bbb;\r\n\t}\r\n\r\n.leaflet-touch .leaflet-bar a {\r\n\twidth: 30px;\r\n\theight: 30px;\r\n\tline-height: 30px;\r\n\t}\r\n.leaflet-touch .leaflet-bar a:first-child {\r\n\tborder-top-left-radius: 2px;\r\n\tborder-top-right-radius: 2px;\r\n\t}\r\n.leaflet-touch .leaflet-bar a:last-child {\r\n\tborder-bottom-left-radius: 2px;\r\n\tborder-bottom-right-radius: 2px;\r\n\t}\r\n\r\n/* zoom control */\r\n\r\n.leaflet-control-zoom-in,\r\n.leaflet-control-zoom-out {\r\n\tfont: bold 18px 'Lucida Console', Monaco, monospace;\r\n\ttext-indent: 1px;\r\n\t}\r\n\r\n.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {\r\n\tfont-size: 22px;\r\n\t}\r\n\r\n\r\n/* layers control */\r\n\r\n.leaflet-control-layers {\r\n\tbox-shadow: 0 1px 5px rgba(0,0,0,0.4);\r\n\tbackground: #fff;\r\n\tborder-radius: 5px;\r\n\t}\r\n.leaflet-control-layers-toggle {\r\n\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\r\n\twidth: 36px;\r\n\theight: 36px;\r\n\t}\r\n.leaflet-retina .leaflet-control-layers-toggle {\r\n\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ");\r\n\tbackground-size: 26px 26px;\r\n\t}\r\n.leaflet-touch .leaflet-control-layers-toggle {\r\n\twidth: 44px;\r\n\theight: 44px;\r\n\t}\r\n.leaflet-control-layers .leaflet-control-layers-list,\r\n.leaflet-control-layers-expanded .leaflet-control-layers-toggle {\r\n\tdisplay: none;\r\n\t}\r\n.leaflet-control-layers-expanded .leaflet-control-layers-list {\r\n\tdisplay: block;\r\n\tposition: relative;\r\n\t}\r\n.leaflet-control-layers-expanded {\r\n\tpadding: 6px 10px 6px 6px;\r\n\tcolor: #333;\r\n\tbackground: #fff;\r\n\t}\r\n.leaflet-control-layers-scrollbar {\r\n\toverflow-y: scroll;\r\n\toverflow-x: hidden;\r\n\tpadding-right: 5px;\r\n\t}\r\n.leaflet-control-layers-selector {\r\n\tmargin-top: 2px;\r\n\tposition: relative;\r\n\ttop: 1px;\r\n\t}\r\n.leaflet-control-layers label {\r\n\tdisplay: block;\r\n\t}\r\n.leaflet-control-layers-separator {\r\n\theight: 0;\r\n\tborder-top: 1px solid #ddd;\r\n\tmargin: 5px -10px 5px -6px;\r\n\t}\r\n\r\n/* Default icon URLs */\r\n.leaflet-default-icon-path {\r\n\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ");\r\n\t}\r\n\r\n\r\n/* attribution and scale controls */\r\n\r\n.leaflet-container .leaflet-control-attribution {\r\n\tbackground: #fff;\r\n\tbackground: rgba(255, 255, 255, 0.7);\r\n\tmargin: 0;\r\n\t}\r\n.leaflet-control-attribution,\r\n.leaflet-control-scale-line {\r\n\tpadding: 0 5px;\r\n\tcolor: #333;\r\n\t}\r\n.leaflet-control-attribution a {\r\n\ttext-decoration: none;\r\n\t}\r\n.leaflet-control-attribution a:hover {\r\n\ttext-decoration: underline;\r\n\t}\r\n.leaflet-container .leaflet-control-attribution,\r\n.leaflet-container .leaflet-control-scale {\r\n\tfont-size: 11px;\r\n\t}\r\n.leaflet-left .leaflet-control-scale {\r\n\tmargin-left: 5px;\r\n\t}\r\n.leaflet-bottom .leaflet-control-scale {\r\n\tmargin-bottom: 5px;\r\n\t}\r\n.leaflet-control-scale-line {\r\n\tborder: 2px solid #777;\r\n\tborder-top: none;\r\n\tline-height: 1.1;\r\n\tpadding: 2px 5px 1px;\r\n\tfont-size: 11px;\r\n\twhite-space: nowrap;\r\n\toverflow: hidden;\r\n\t-moz-box-sizing: border-box;\r\n\t     box-sizing: border-box;\r\n\r\n\tbackground: #fff;\r\n\tbackground: rgba(255, 255, 255, 0.5);\r\n\t}\r\n.leaflet-control-scale-line:not(:first-child) {\r\n\tborder-top: 2px solid #777;\r\n\tborder-bottom: none;\r\n\tmargin-top: -2px;\r\n\t}\r\n.leaflet-control-scale-line:not(:first-child):not(:last-child) {\r\n\tborder-bottom: 2px solid #777;\r\n\t}\r\n\r\n.leaflet-touch .leaflet-control-attribution,\r\n.leaflet-touch .leaflet-control-layers,\r\n.leaflet-touch .leaflet-bar {\r\n\tbox-shadow: none;\r\n\t}\r\n.leaflet-touch .leaflet-control-layers,\r\n.leaflet-touch .leaflet-bar {\r\n\tborder: 2px solid rgba(0,0,0,0.2);\r\n\tbackground-clip: padding-box;\r\n\t}\r\n\r\n\r\n/* popup */\r\n\r\n.leaflet-popup {\r\n\tposition: absolute;\r\n\ttext-align: center;\r\n\tmargin-bottom: 20px;\r\n\t}\r\n.leaflet-popup-content-wrapper {\r\n\tpadding: 1px;\r\n\ttext-align: left;\r\n\tborder-radius: 12px;\r\n\t}\r\n.leaflet-popup-content {\r\n\tmargin: 13px 19px;\r\n\tline-height: 1.4;\r\n\t}\r\n.leaflet-popup-content p {\r\n\tmargin: 18px 0;\r\n\t}\r\n.leaflet-popup-tip-container {\r\n\twidth: 40px;\r\n\theight: 20px;\r\n\tposition: absolute;\r\n\tleft: 50%;\r\n\tmargin-left: -20px;\r\n\toverflow: hidden;\r\n\tpointer-events: none;\r\n\t}\r\n.leaflet-popup-tip {\r\n\twidth: 17px;\r\n\theight: 17px;\r\n\tpadding: 1px;\r\n\r\n\tmargin: -10px auto 0;\r\n\r\n\t-webkit-transform: rotate(45deg);\r\n\t   -moz-transform: rotate(45deg);\r\n\t    -ms-transform: rotate(45deg);\r\n\t        transform: rotate(45deg);\r\n\t}\r\n.leaflet-popup-content-wrapper,\r\n.leaflet-popup-tip {\r\n\tbackground: white;\r\n\tcolor: #333;\r\n\tbox-shadow: 0 3px 14px rgba(0,0,0,0.4);\r\n\t}\r\n.leaflet-container a.leaflet-popup-close-button {\r\n\tposition: absolute;\r\n\ttop: 0;\r\n\tright: 0;\r\n\tpadding: 4px 4px 0 0;\r\n\tborder: none;\r\n\ttext-align: center;\r\n\twidth: 18px;\r\n\theight: 14px;\r\n\tfont: 16px/14px Tahoma, Verdana, sans-serif;\r\n\tcolor: #c3c3c3;\r\n\ttext-decoration: none;\r\n\tfont-weight: bold;\r\n\tbackground: transparent;\r\n\t}\r\n.leaflet-container a.leaflet-popup-close-button:hover {\r\n\tcolor: #999;\r\n\t}\r\n.leaflet-popup-scrolled {\r\n\toverflow: auto;\r\n\tborder-bottom: 1px solid #ddd;\r\n\tborder-top: 1px solid #ddd;\r\n\t}\r\n\r\n.leaflet-oldie .leaflet-popup-content-wrapper {\r\n\tzoom: 1;\r\n\t}\r\n.leaflet-oldie .leaflet-popup-tip {\r\n\twidth: 24px;\r\n\tmargin: 0 auto;\r\n\r\n\t-ms-filter: \"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)\";\r\n\tfilter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);\r\n\t}\r\n.leaflet-oldie .leaflet-popup-tip-container {\r\n\tmargin-top: -1px;\r\n\t}\r\n\r\n.leaflet-oldie .leaflet-control-zoom,\r\n.leaflet-oldie .leaflet-control-layers,\r\n.leaflet-oldie .leaflet-popup-content-wrapper,\r\n.leaflet-oldie .leaflet-popup-tip {\r\n\tborder: 1px solid #999;\r\n\t}\r\n\r\n\r\n/* div icon */\r\n\r\n.leaflet-div-icon {\r\n\tbackground: #fff;\r\n\tborder: 1px solid #666;\r\n\t}\r\n\r\n\r\n/* Tooltip */\r\n/* Base styles for the element that has a tooltip */\r\n.leaflet-tooltip {\r\n\tposition: absolute;\r\n\tpadding: 6px;\r\n\tbackground-color: #fff;\r\n\tborder: 1px solid #fff;\r\n\tborder-radius: 3px;\r\n\tcolor: #222;\r\n\twhite-space: nowrap;\r\n\t-webkit-user-select: none;\r\n\t-moz-user-select: none;\r\n\t-ms-user-select: none;\r\n\tuser-select: none;\r\n\tpointer-events: none;\r\n\tbox-shadow: 0 1px 3px rgba(0,0,0,0.4);\r\n\t}\r\n.leaflet-tooltip.leaflet-clickable {\r\n\tcursor: pointer;\r\n\tpointer-events: auto;\r\n\t}\r\n.leaflet-tooltip-top:before,\r\n.leaflet-tooltip-bottom:before,\r\n.leaflet-tooltip-left:before,\r\n.leaflet-tooltip-right:before {\r\n\tposition: absolute;\r\n\tpointer-events: none;\r\n\tborder: 6px solid transparent;\r\n\tbackground: transparent;\r\n\tcontent: \"\";\r\n\t}\r\n\r\n/* Directions */\r\n\r\n.leaflet-tooltip-bottom {\r\n\tmargin-top: 6px;\r\n}\r\n.leaflet-tooltip-top {\r\n\tmargin-top: -6px;\r\n}\r\n.leaflet-tooltip-bottom:before,\r\n.leaflet-tooltip-top:before {\r\n\tleft: 50%;\r\n\tmargin-left: -6px;\r\n\t}\r\n.leaflet-tooltip-top:before {\r\n\tbottom: 0;\r\n\tmargin-bottom: -12px;\r\n\tborder-top-color: #fff;\r\n\t}\r\n.leaflet-tooltip-bottom:before {\r\n\ttop: 0;\r\n\tmargin-top: -12px;\r\n\tmargin-left: -6px;\r\n\tborder-bottom-color: #fff;\r\n\t}\r\n.leaflet-tooltip-left {\r\n\tmargin-left: -6px;\r\n}\r\n.leaflet-tooltip-right {\r\n\tmargin-left: 6px;\r\n}\r\n.leaflet-tooltip-left:before,\r\n.leaflet-tooltip-right:before {\r\n\ttop: 50%;\r\n\tmargin-top: -6px;\r\n\t}\r\n.leaflet-tooltip-left:before {\r\n\tright: 0;\r\n\tmargin-right: -12px;\r\n\tborder-left-color: #fff;\r\n\t}\r\n.leaflet-tooltip-right:before {\r\n\tleft: 0;\r\n\tmargin-left: -12px;\r\n\tborder-right-color: #fff;\r\n\t}\r\n", "",{"version":3,"sources":["webpack://./node_modules/leaflet/dist/leaflet.css"],"names":[],"mappings":"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","sourcesContent":["/* required styles */\r\n\r\n.leaflet-pane,\r\n.leaflet-tile,\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow,\r\n.leaflet-tile-container,\r\n.leaflet-pane > svg,\r\n.leaflet-pane > canvas,\r\n.leaflet-zoom-box,\r\n.leaflet-image-layer,\r\n.leaflet-layer {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\t}\r\n.leaflet-container {\r\n\toverflow: hidden;\r\n\t}\r\n.leaflet-tile,\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow {\r\n\t-webkit-user-select: none;\r\n\t   -moz-user-select: none;\r\n\t        user-select: none;\r\n\t  -webkit-user-drag: none;\r\n\t}\r\n/* Prevents IE11 from highlighting tiles in blue */\r\n.leaflet-tile::selection {\r\n\tbackground: transparent;\r\n}\r\n/* Safari renders non-retina tile on retina better with this, but Chrome is worse */\r\n.leaflet-safari .leaflet-tile {\r\n\timage-rendering: -webkit-optimize-contrast;\r\n\t}\r\n/* hack that prevents hw layers \"stretching\" when loading new tiles */\r\n.leaflet-safari .leaflet-tile-container {\r\n\twidth: 1600px;\r\n\theight: 1600px;\r\n\t-webkit-transform-origin: 0 0;\r\n\t}\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow {\r\n\tdisplay: block;\r\n\t}\r\n/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */\r\n/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */\r\n.leaflet-container .leaflet-overlay-pane svg,\r\n.leaflet-container .leaflet-marker-pane img,\r\n.leaflet-container .leaflet-shadow-pane img,\r\n.leaflet-container .leaflet-tile-pane img,\r\n.leaflet-container img.leaflet-image-layer,\r\n.leaflet-container .leaflet-tile {\r\n\tmax-width: none !important;\r\n\tmax-height: none !important;\r\n\t}\r\n\r\n.leaflet-container.leaflet-touch-zoom {\r\n\t-ms-touch-action: pan-x pan-y;\r\n\ttouch-action: pan-x pan-y;\r\n\t}\r\n.leaflet-container.leaflet-touch-drag {\r\n\t-ms-touch-action: pinch-zoom;\r\n\t/* Fallback for FF which doesn't support pinch-zoom */\r\n\ttouch-action: none;\r\n\ttouch-action: pinch-zoom;\r\n}\r\n.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {\r\n\t-ms-touch-action: none;\r\n\ttouch-action: none;\r\n}\r\n.leaflet-container {\r\n\t-webkit-tap-highlight-color: transparent;\r\n}\r\n.leaflet-container a {\r\n\t-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);\r\n}\r\n.leaflet-tile {\r\n\tfilter: inherit;\r\n\tvisibility: hidden;\r\n\t}\r\n.leaflet-tile-loaded {\r\n\tvisibility: inherit;\r\n\t}\r\n.leaflet-zoom-box {\r\n\twidth: 0;\r\n\theight: 0;\r\n\t-moz-box-sizing: border-box;\r\n\t     box-sizing: border-box;\r\n\tz-index: 800;\r\n\t}\r\n/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */\r\n.leaflet-overlay-pane svg {\r\n\t-moz-user-select: none;\r\n\t}\r\n\r\n.leaflet-pane         { z-index: 400; }\r\n\r\n.leaflet-tile-pane    { z-index: 200; }\r\n.leaflet-overlay-pane { z-index: 400; }\r\n.leaflet-shadow-pane  { z-index: 500; }\r\n.leaflet-marker-pane  { z-index: 600; }\r\n.leaflet-tooltip-pane   { z-index: 650; }\r\n.leaflet-popup-pane   { z-index: 700; }\r\n\r\n.leaflet-map-pane canvas { z-index: 100; }\r\n.leaflet-map-pane svg    { z-index: 200; }\r\n\r\n.leaflet-vml-shape {\r\n\twidth: 1px;\r\n\theight: 1px;\r\n\t}\r\n.lvml {\r\n\tbehavior: url(#default#VML);\r\n\tdisplay: inline-block;\r\n\tposition: absolute;\r\n\t}\r\n\r\n\r\n/* control positioning */\r\n\r\n.leaflet-control {\r\n\tposition: relative;\r\n\tz-index: 800;\r\n\tpointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\r\n\tpointer-events: auto;\r\n\t}\r\n.leaflet-top,\r\n.leaflet-bottom {\r\n\tposition: absolute;\r\n\tz-index: 1000;\r\n\tpointer-events: none;\r\n\t}\r\n.leaflet-top {\r\n\ttop: 0;\r\n\t}\r\n.leaflet-right {\r\n\tright: 0;\r\n\t}\r\n.leaflet-bottom {\r\n\tbottom: 0;\r\n\t}\r\n.leaflet-left {\r\n\tleft: 0;\r\n\t}\r\n.leaflet-control {\r\n\tfloat: left;\r\n\tclear: both;\r\n\t}\r\n.leaflet-right .leaflet-control {\r\n\tfloat: right;\r\n\t}\r\n.leaflet-top .leaflet-control {\r\n\tmargin-top: 10px;\r\n\t}\r\n.leaflet-bottom .leaflet-control {\r\n\tmargin-bottom: 10px;\r\n\t}\r\n.leaflet-left .leaflet-control {\r\n\tmargin-left: 10px;\r\n\t}\r\n.leaflet-right .leaflet-control {\r\n\tmargin-right: 10px;\r\n\t}\r\n\r\n\r\n/* zoom and fade animations */\r\n\r\n.leaflet-fade-anim .leaflet-tile {\r\n\twill-change: opacity;\r\n\t}\r\n.leaflet-fade-anim .leaflet-popup {\r\n\topacity: 0;\r\n\t-webkit-transition: opacity 0.2s linear;\r\n\t   -moz-transition: opacity 0.2s linear;\r\n\t        transition: opacity 0.2s linear;\r\n\t}\r\n.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {\r\n\topacity: 1;\r\n\t}\r\n.leaflet-zoom-animated {\r\n\t-webkit-transform-origin: 0 0;\r\n\t    -ms-transform-origin: 0 0;\r\n\t        transform-origin: 0 0;\r\n\t}\r\n.leaflet-zoom-anim .leaflet-zoom-animated {\r\n\twill-change: transform;\r\n\t}\r\n.leaflet-zoom-anim .leaflet-zoom-animated {\r\n\t-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);\r\n\t   -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);\r\n\t        transition:         transform 0.25s cubic-bezier(0,0,0.25,1);\r\n\t}\r\n.leaflet-zoom-anim .leaflet-tile,\r\n.leaflet-pan-anim .leaflet-tile {\r\n\t-webkit-transition: none;\r\n\t   -moz-transition: none;\r\n\t        transition: none;\r\n\t}\r\n\r\n.leaflet-zoom-anim .leaflet-zoom-hide {\r\n\tvisibility: hidden;\r\n\t}\r\n\r\n\r\n/* cursors */\r\n\r\n.leaflet-interactive {\r\n\tcursor: pointer;\r\n\t}\r\n.leaflet-grab {\r\n\tcursor: -webkit-grab;\r\n\tcursor:    -moz-grab;\r\n\tcursor:         grab;\r\n\t}\r\n.leaflet-crosshair,\r\n.leaflet-crosshair .leaflet-interactive {\r\n\tcursor: crosshair;\r\n\t}\r\n.leaflet-popup-pane,\r\n.leaflet-control {\r\n\tcursor: auto;\r\n\t}\r\n.leaflet-dragging .leaflet-grab,\r\n.leaflet-dragging .leaflet-grab .leaflet-interactive,\r\n.leaflet-dragging .leaflet-marker-draggable {\r\n\tcursor: move;\r\n\tcursor: -webkit-grabbing;\r\n\tcursor:    -moz-grabbing;\r\n\tcursor:         grabbing;\r\n\t}\r\n\r\n/* marker & overlays interactivity */\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow,\r\n.leaflet-image-layer,\r\n.leaflet-pane > svg path,\r\n.leaflet-tile-container {\r\n\tpointer-events: none;\r\n\t}\r\n\r\n.leaflet-marker-icon.leaflet-interactive,\r\n.leaflet-image-layer.leaflet-interactive,\r\n.leaflet-pane > svg path.leaflet-interactive,\r\nsvg.leaflet-image-layer.leaflet-interactive path {\r\n\tpointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\r\n\tpointer-events: auto;\r\n\t}\r\n\r\n/* visual tweaks */\r\n\r\n.leaflet-container {\r\n\tbackground: #ddd;\r\n\toutline: 0;\r\n\t}\r\n.leaflet-container a {\r\n\tcolor: #0078A8;\r\n\t}\r\n.leaflet-container a.leaflet-active {\r\n\toutline: 2px solid orange;\r\n\t}\r\n.leaflet-zoom-box {\r\n\tborder: 2px dotted #38f;\r\n\tbackground: rgba(255,255,255,0.5);\r\n\t}\r\n\r\n\r\n/* general typography */\r\n.leaflet-container {\r\n\tfont: 12px/1.5 \"Helvetica Neue\", Arial, Helvetica, sans-serif;\r\n\t}\r\n\r\n\r\n/* general toolbar styles */\r\n\r\n.leaflet-bar {\r\n\tbox-shadow: 0 1px 5px rgba(0,0,0,0.65);\r\n\tborder-radius: 4px;\r\n\t}\r\n.leaflet-bar a,\r\n.leaflet-bar a:hover {\r\n\tbackground-color: #fff;\r\n\tborder-bottom: 1px solid #ccc;\r\n\twidth: 26px;\r\n\theight: 26px;\r\n\tline-height: 26px;\r\n\tdisplay: block;\r\n\ttext-align: center;\r\n\ttext-decoration: none;\r\n\tcolor: black;\r\n\t}\r\n.leaflet-bar a,\r\n.leaflet-control-layers-toggle {\r\n\tbackground-position: 50% 50%;\r\n\tbackground-repeat: no-repeat;\r\n\tdisplay: block;\r\n\t}\r\n.leaflet-bar a:hover {\r\n\tbackground-color: #f4f4f4;\r\n\t}\r\n.leaflet-bar a:first-child {\r\n\tborder-top-left-radius: 4px;\r\n\tborder-top-right-radius: 4px;\r\n\t}\r\n.leaflet-bar a:last-child {\r\n\tborder-bottom-left-radius: 4px;\r\n\tborder-bottom-right-radius: 4px;\r\n\tborder-bottom: none;\r\n\t}\r\n.leaflet-bar a.leaflet-disabled {\r\n\tcursor: default;\r\n\tbackground-color: #f4f4f4;\r\n\tcolor: #bbb;\r\n\t}\r\n\r\n.leaflet-touch .leaflet-bar a {\r\n\twidth: 30px;\r\n\theight: 30px;\r\n\tline-height: 30px;\r\n\t}\r\n.leaflet-touch .leaflet-bar a:first-child {\r\n\tborder-top-left-radius: 2px;\r\n\tborder-top-right-radius: 2px;\r\n\t}\r\n.leaflet-touch .leaflet-bar a:last-child {\r\n\tborder-bottom-left-radius: 2px;\r\n\tborder-bottom-right-radius: 2px;\r\n\t}\r\n\r\n/* zoom control */\r\n\r\n.leaflet-control-zoom-in,\r\n.leaflet-control-zoom-out {\r\n\tfont: bold 18px 'Lucida Console', Monaco, monospace;\r\n\ttext-indent: 1px;\r\n\t}\r\n\r\n.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {\r\n\tfont-size: 22px;\r\n\t}\r\n\r\n\r\n/* layers control */\r\n\r\n.leaflet-control-layers {\r\n\tbox-shadow: 0 1px 5px rgba(0,0,0,0.4);\r\n\tbackground: #fff;\r\n\tborder-radius: 5px;\r\n\t}\r\n.leaflet-control-layers-toggle {\r\n\tbackground-image: url(images/layers.png);\r\n\twidth: 36px;\r\n\theight: 36px;\r\n\t}\r\n.leaflet-retina .leaflet-control-layers-toggle {\r\n\tbackground-image: url(images/layers-2x.png);\r\n\tbackground-size: 26px 26px;\r\n\t}\r\n.leaflet-touch .leaflet-control-layers-toggle {\r\n\twidth: 44px;\r\n\theight: 44px;\r\n\t}\r\n.leaflet-control-layers .leaflet-control-layers-list,\r\n.leaflet-control-layers-expanded .leaflet-control-layers-toggle {\r\n\tdisplay: none;\r\n\t}\r\n.leaflet-control-layers-expanded .leaflet-control-layers-list {\r\n\tdisplay: block;\r\n\tposition: relative;\r\n\t}\r\n.leaflet-control-layers-expanded {\r\n\tpadding: 6px 10px 6px 6px;\r\n\tcolor: #333;\r\n\tbackground: #fff;\r\n\t}\r\n.leaflet-control-layers-scrollbar {\r\n\toverflow-y: scroll;\r\n\toverflow-x: hidden;\r\n\tpadding-right: 5px;\r\n\t}\r\n.leaflet-control-layers-selector {\r\n\tmargin-top: 2px;\r\n\tposition: relative;\r\n\ttop: 1px;\r\n\t}\r\n.leaflet-control-layers label {\r\n\tdisplay: block;\r\n\t}\r\n.leaflet-control-layers-separator {\r\n\theight: 0;\r\n\tborder-top: 1px solid #ddd;\r\n\tmargin: 5px -10px 5px -6px;\r\n\t}\r\n\r\n/* Default icon URLs */\r\n.leaflet-default-icon-path {\r\n\tbackground-image: url(images/marker-icon.png);\r\n\t}\r\n\r\n\r\n/* attribution and scale controls */\r\n\r\n.leaflet-container .leaflet-control-attribution {\r\n\tbackground: #fff;\r\n\tbackground: rgba(255, 255, 255, 0.7);\r\n\tmargin: 0;\r\n\t}\r\n.leaflet-control-attribution,\r\n.leaflet-control-scale-line {\r\n\tpadding: 0 5px;\r\n\tcolor: #333;\r\n\t}\r\n.leaflet-control-attribution a {\r\n\ttext-decoration: none;\r\n\t}\r\n.leaflet-control-attribution a:hover {\r\n\ttext-decoration: underline;\r\n\t}\r\n.leaflet-container .leaflet-control-attribution,\r\n.leaflet-container .leaflet-control-scale {\r\n\tfont-size: 11px;\r\n\t}\r\n.leaflet-left .leaflet-control-scale {\r\n\tmargin-left: 5px;\r\n\t}\r\n.leaflet-bottom .leaflet-control-scale {\r\n\tmargin-bottom: 5px;\r\n\t}\r\n.leaflet-control-scale-line {\r\n\tborder: 2px solid #777;\r\n\tborder-top: none;\r\n\tline-height: 1.1;\r\n\tpadding: 2px 5px 1px;\r\n\tfont-size: 11px;\r\n\twhite-space: nowrap;\r\n\toverflow: hidden;\r\n\t-moz-box-sizing: border-box;\r\n\t     box-sizing: border-box;\r\n\r\n\tbackground: #fff;\r\n\tbackground: rgba(255, 255, 255, 0.5);\r\n\t}\r\n.leaflet-control-scale-line:not(:first-child) {\r\n\tborder-top: 2px solid #777;\r\n\tborder-bottom: none;\r\n\tmargin-top: -2px;\r\n\t}\r\n.leaflet-control-scale-line:not(:first-child):not(:last-child) {\r\n\tborder-bottom: 2px solid #777;\r\n\t}\r\n\r\n.leaflet-touch .leaflet-control-attribution,\r\n.leaflet-touch .leaflet-control-layers,\r\n.leaflet-touch .leaflet-bar {\r\n\tbox-shadow: none;\r\n\t}\r\n.leaflet-touch .leaflet-control-layers,\r\n.leaflet-touch .leaflet-bar {\r\n\tborder: 2px solid rgba(0,0,0,0.2);\r\n\tbackground-clip: padding-box;\r\n\t}\r\n\r\n\r\n/* popup */\r\n\r\n.leaflet-popup {\r\n\tposition: absolute;\r\n\ttext-align: center;\r\n\tmargin-bottom: 20px;\r\n\t}\r\n.leaflet-popup-content-wrapper {\r\n\tpadding: 1px;\r\n\ttext-align: left;\r\n\tborder-radius: 12px;\r\n\t}\r\n.leaflet-popup-content {\r\n\tmargin: 13px 19px;\r\n\tline-height: 1.4;\r\n\t}\r\n.leaflet-popup-content p {\r\n\tmargin: 18px 0;\r\n\t}\r\n.leaflet-popup-tip-container {\r\n\twidth: 40px;\r\n\theight: 20px;\r\n\tposition: absolute;\r\n\tleft: 50%;\r\n\tmargin-left: -20px;\r\n\toverflow: hidden;\r\n\tpointer-events: none;\r\n\t}\r\n.leaflet-popup-tip {\r\n\twidth: 17px;\r\n\theight: 17px;\r\n\tpadding: 1px;\r\n\r\n\tmargin: -10px auto 0;\r\n\r\n\t-webkit-transform: rotate(45deg);\r\n\t   -moz-transform: rotate(45deg);\r\n\t    -ms-transform: rotate(45deg);\r\n\t        transform: rotate(45deg);\r\n\t}\r\n.leaflet-popup-content-wrapper,\r\n.leaflet-popup-tip {\r\n\tbackground: white;\r\n\tcolor: #333;\r\n\tbox-shadow: 0 3px 14px rgba(0,0,0,0.4);\r\n\t}\r\n.leaflet-container a.leaflet-popup-close-button {\r\n\tposition: absolute;\r\n\ttop: 0;\r\n\tright: 0;\r\n\tpadding: 4px 4px 0 0;\r\n\tborder: none;\r\n\ttext-align: center;\r\n\twidth: 18px;\r\n\theight: 14px;\r\n\tfont: 16px/14px Tahoma, Verdana, sans-serif;\r\n\tcolor: #c3c3c3;\r\n\ttext-decoration: none;\r\n\tfont-weight: bold;\r\n\tbackground: transparent;\r\n\t}\r\n.leaflet-container a.leaflet-popup-close-button:hover {\r\n\tcolor: #999;\r\n\t}\r\n.leaflet-popup-scrolled {\r\n\toverflow: auto;\r\n\tborder-bottom: 1px solid #ddd;\r\n\tborder-top: 1px solid #ddd;\r\n\t}\r\n\r\n.leaflet-oldie .leaflet-popup-content-wrapper {\r\n\tzoom: 1;\r\n\t}\r\n.leaflet-oldie .leaflet-popup-tip {\r\n\twidth: 24px;\r\n\tmargin: 0 auto;\r\n\r\n\t-ms-filter: \"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)\";\r\n\tfilter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);\r\n\t}\r\n.leaflet-oldie .leaflet-popup-tip-container {\r\n\tmargin-top: -1px;\r\n\t}\r\n\r\n.leaflet-oldie .leaflet-control-zoom,\r\n.leaflet-oldie .leaflet-control-layers,\r\n.leaflet-oldie .leaflet-popup-content-wrapper,\r\n.leaflet-oldie .leaflet-popup-tip {\r\n\tborder: 1px solid #999;\r\n\t}\r\n\r\n\r\n/* div icon */\r\n\r\n.leaflet-div-icon {\r\n\tbackground: #fff;\r\n\tborder: 1px solid #666;\r\n\t}\r\n\r\n\r\n/* Tooltip */\r\n/* Base styles for the element that has a tooltip */\r\n.leaflet-tooltip {\r\n\tposition: absolute;\r\n\tpadding: 6px;\r\n\tbackground-color: #fff;\r\n\tborder: 1px solid #fff;\r\n\tborder-radius: 3px;\r\n\tcolor: #222;\r\n\twhite-space: nowrap;\r\n\t-webkit-user-select: none;\r\n\t-moz-user-select: none;\r\n\t-ms-user-select: none;\r\n\tuser-select: none;\r\n\tpointer-events: none;\r\n\tbox-shadow: 0 1px 3px rgba(0,0,0,0.4);\r\n\t}\r\n.leaflet-tooltip.leaflet-clickable {\r\n\tcursor: pointer;\r\n\tpointer-events: auto;\r\n\t}\r\n.leaflet-tooltip-top:before,\r\n.leaflet-tooltip-bottom:before,\r\n.leaflet-tooltip-left:before,\r\n.leaflet-tooltip-right:before {\r\n\tposition: absolute;\r\n\tpointer-events: none;\r\n\tborder: 6px solid transparent;\r\n\tbackground: transparent;\r\n\tcontent: \"\";\r\n\t}\r\n\r\n/* Directions */\r\n\r\n.leaflet-tooltip-bottom {\r\n\tmargin-top: 6px;\r\n}\r\n.leaflet-tooltip-top {\r\n\tmargin-top: -6px;\r\n}\r\n.leaflet-tooltip-bottom:before,\r\n.leaflet-tooltip-top:before {\r\n\tleft: 50%;\r\n\tmargin-left: -6px;\r\n\t}\r\n.leaflet-tooltip-top:before {\r\n\tbottom: 0;\r\n\tmargin-bottom: -12px;\r\n\tborder-top-color: #fff;\r\n\t}\r\n.leaflet-tooltip-bottom:before {\r\n\ttop: 0;\r\n\tmargin-top: -12px;\r\n\tmargin-left: -6px;\r\n\tborder-bottom-color: #fff;\r\n\t}\r\n.leaflet-tooltip-left {\r\n\tmargin-left: -6px;\r\n}\r\n.leaflet-tooltip-right {\r\n\tmargin-left: 6px;\r\n}\r\n.leaflet-tooltip-left:before,\r\n.leaflet-tooltip-right:before {\r\n\ttop: 50%;\r\n\tmargin-top: -6px;\r\n\t}\r\n.leaflet-tooltip-left:before {\r\n\tright: 0;\r\n\tmargin-right: -12px;\r\n\tborder-left-color: #fff;\r\n\t}\r\n.leaflet-tooltip-right:before {\r\n\tleft: 0;\r\n\tmargin-left: -12px;\r\n\tborder-right-color: #fff;\r\n\t}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }

  if (!url) {
    return url;
  }

  url = String(url.__esModule ? url.default : url); // If url is already wrapped in quotes, remove them

  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }

  if (options.hash) {
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }

  return url;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/leaflet/dist/leaflet-src.js":
/*!**************************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet-src.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

/* @preserve
 * Leaflet 1.6.0, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */

(function (global, factory) {
	 true ? factory(exports) :
	0;
}(this, (function (exports) { 'use strict';

var version = "1.6.0";

/*
 * @namespace Util
 *
 * Various utility functions, used by Leaflet internally.
 */

var freeze = Object.freeze;
Object.freeze = function (obj) { return obj; };

// @function extend(dest: Object, src?: Object): Object
// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
function extend(dest) {
	var i, j, len, src;

	for (j = 1, len = arguments.length; j < len; j++) {
		src = arguments[j];
		for (i in src) {
			dest[i] = src[i];
		}
	}
	return dest;
}

// @function create(proto: Object, properties?: Object): Object
// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
var create = Object.create || (function () {
	function F() {}
	return function (proto) {
		F.prototype = proto;
		return new F();
	};
})();

// @function bind(fn: Function, …): Function
// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
// Has a `L.bind()` shortcut.
function bind(fn, obj) {
	var slice = Array.prototype.slice;

	if (fn.bind) {
		return fn.bind.apply(fn, slice.call(arguments, 1));
	}

	var args = slice.call(arguments, 2);

	return function () {
		return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
	};
}

// @property lastId: Number
// Last unique ID used by [`stamp()`](#util-stamp)
var lastId = 0;

// @function stamp(obj: Object): Number
// Returns the unique ID of an object, assigning it one if it doesn't have it.
function stamp(obj) {
	/*eslint-disable */
	obj._leaflet_id = obj._leaflet_id || ++lastId;
	return obj._leaflet_id;
	/* eslint-enable */
}

// @function throttle(fn: Function, time: Number, context: Object): Function
// Returns a function which executes function `fn` with the given scope `context`
// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
// `fn` will be called no more than one time per given amount of `time`. The arguments
// received by the bound function will be any arguments passed when binding the
// function, followed by any arguments passed when invoking the bound function.
// Has an `L.throttle` shortcut.
function throttle(fn, time, context) {
	var lock, args, wrapperFn, later;

	later = function () {
		// reset lock and call if queued
		lock = false;
		if (args) {
			wrapperFn.apply(context, args);
			args = false;
		}
	};

	wrapperFn = function () {
		if (lock) {
			// called too soon, queue to call later
			args = arguments;

		} else {
			// call and lock until later
			fn.apply(context, arguments);
			setTimeout(later, time);
			lock = true;
		}
	};

	return wrapperFn;
}

// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
// Returns the number `num` modulo `range` in such a way so it lies within
// `range[0]` and `range[1]`. The returned value will be always smaller than
// `range[1]` unless `includeMax` is set to `true`.
function wrapNum(x, range, includeMax) {
	var max = range[1],
	    min = range[0],
	    d = max - min;
	return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
}

// @function falseFn(): Function
// Returns a function which always returns `false`.
function falseFn() { return false; }

// @function formatNum(num: Number, digits?: Number): Number
// Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.
function formatNum(num, digits) {
	var pow = Math.pow(10, (digits === undefined ? 6 : digits));
	return Math.round(num * pow) / pow;
}

// @function trim(str: String): String
// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
function trim(str) {
	return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

// @function splitWords(str: String): String[]
// Trims and splits the string on whitespace and returns the array of parts.
function splitWords(str) {
	return trim(str).split(/\s+/);
}

// @function setOptions(obj: Object, options: Object): Object
// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
function setOptions(obj, options) {
	if (!obj.hasOwnProperty('options')) {
		obj.options = obj.options ? create(obj.options) : {};
	}
	for (var i in options) {
		obj.options[i] = options[i];
	}
	return obj.options;
}

// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
// be appended at the end. If `uppercase` is `true`, the parameter names will
// be uppercased (e.g. `'?A=foo&B=bar'`)
function getParamString(obj, existingUrl, uppercase) {
	var params = [];
	for (var i in obj) {
		params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
	}
	return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
}

var templateRe = /\{ *([\w_-]+) *\}/g;

// @function template(str: String, data: Object): String
// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
// `('Hello foo, bar')`. You can also specify functions instead of strings for
// data values — they will be evaluated passing `data` as an argument.
function template(str, data) {
	return str.replace(templateRe, function (str, key) {
		var value = data[key];

		if (value === undefined) {
			throw new Error('No value provided for variable ' + str);

		} else if (typeof value === 'function') {
			value = value(data);
		}
		return value;
	});
}

// @function isArray(obj): Boolean
// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
var isArray = Array.isArray || function (obj) {
	return (Object.prototype.toString.call(obj) === '[object Array]');
};

// @function indexOf(array: Array, el: Object): Number
// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
function indexOf(array, el) {
	for (var i = 0; i < array.length; i++) {
		if (array[i] === el) { return i; }
	}
	return -1;
}

// @property emptyImageUrl: String
// Data URI string containing a base64-encoded empty GIF image.
// Used as a hack to free memory from unused images on WebKit-powered
// mobile devices (by setting image `src` to this string).
var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

function getPrefixed(name) {
	return window['webkit' + name] || window['moz' + name] || window['ms' + name];
}

var lastTime = 0;

// fallback for IE 7-8
function timeoutDefer(fn) {
	var time = +new Date(),
	    timeToCall = Math.max(0, 16 - (time - lastTime));

	lastTime = time + timeToCall;
	return window.setTimeout(fn, timeToCall);
}

var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
		getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };

// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
// `context` if given. When `immediate` is set, `fn` is called immediately if
// the browser doesn't have native support for
// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
function requestAnimFrame(fn, context, immediate) {
	if (immediate && requestFn === timeoutDefer) {
		fn.call(context);
	} else {
		return requestFn.call(window, bind(fn, context));
	}
}

// @function cancelAnimFrame(id: Number): undefined
// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
function cancelAnimFrame(id) {
	if (id) {
		cancelFn.call(window, id);
	}
}


var Util = (Object.freeze || Object)({
	freeze: freeze,
	extend: extend,
	create: create,
	bind: bind,
	lastId: lastId,
	stamp: stamp,
	throttle: throttle,
	wrapNum: wrapNum,
	falseFn: falseFn,
	formatNum: formatNum,
	trim: trim,
	splitWords: splitWords,
	setOptions: setOptions,
	getParamString: getParamString,
	template: template,
	isArray: isArray,
	indexOf: indexOf,
	emptyImageUrl: emptyImageUrl,
	requestFn: requestFn,
	cancelFn: cancelFn,
	requestAnimFrame: requestAnimFrame,
	cancelAnimFrame: cancelAnimFrame
});

// @class Class
// @aka L.Class

// @section
// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

function Class() {}

Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		checkDeprecatedMixinEvents(props.includes);
		extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = extend(create(proto.options), props.options);
	}

	// mix given properties into the prototype
	extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// @function include(properties: Object): this
// [Includes a mixin](#class-includes) into the current class.
Class.include = function (props) {
	extend(this.prototype, props);
	return this;
};

// @function mergeOptions(options: Object): this
// [Merges `options`](#class-options) into the defaults of the class.
Class.mergeOptions = function (options) {
	extend(this.prototype.options, options);
	return this;
};

// @function addInitHook(fn: Function): this
// Adds a [constructor hook](#class-constructor-hooks) to the class.
Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
	return this;
};

function checkDeprecatedMixinEvents(includes) {
	if (typeof L === 'undefined' || !L || !L.Mixin) { return; }

	includes = isArray(includes) ? includes : [includes];

	for (var i = 0; i < includes.length; i++) {
		if (includes[i] === L.Mixin.Events) {
			console.warn('Deprecated include of L.Mixin.Events: ' +
				'this property will be removed in future releases, ' +
				'please inherit from L.Evented instead.', new Error().stack);
		}
	}
}

/*
 * @class Evented
 * @aka L.Evented
 * @inherits Class
 *
 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
 *
 * @example
 *
 * ```js
 * map.on('click', function(e) {
 * 	alert(e.latlng);
 * } );
 * ```
 *
 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
 *
 * ```js
 * function onClick(e) { ... }
 *
 * map.on('click', onClick);
 * map.off('click', onClick);
 * ```
 */

var Events = {
	/* @method on(type: String, fn: Function, context?: Object): this
	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
	 *
	 * @alternative
	 * @method on(eventMap: Object): this
	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	 */
	on: function (types, fn, context) {

		// types can be a map of types/handlers
		if (typeof types === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}

		} else {
			// types can be a string of space-separated words
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	/* @method off(type: String, fn?: Function, context?: Object): this
	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
	 *
	 * @alternative
	 * @method off(eventMap: Object): this
	 * Removes a set of type/listener pairs.
	 *
	 * @alternative
	 * @method off: this
	 * Removes all listeners to all events on the object. This includes implicitly attached events.
	 */
	off: function (types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;

		} else if (typeof types === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}

		} else {
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function (type, fn, context) {
		this._events = this._events || {};

		/* get/init listeners for type */
		var typeListeners = this._events[type];
		if (!typeListeners) {
			typeListeners = [];
			this._events[type] = typeListeners;
		}

		if (context === this) {
			// Less memory footprint.
			context = undefined;
		}
		var newListener = {fn: fn, ctx: context},
		    listeners = typeListeners;

		// check if fn already there
		for (var i = 0, len = listeners.length; i < len; i++) {
			if (listeners[i].fn === fn && listeners[i].ctx === context) {
				return;
			}
		}

		listeners.push(newListener);
	},

	_off: function (type, fn, context) {
		var listeners,
		    i,
		    len;

		if (!this._events) { return; }

		listeners = this._events[type];

		if (!listeners) {
			return;
		}

		if (!fn) {
			// Set all removed listeners to noop so they are not called if remove happens in fire
			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].fn = falseFn;
			}
			// clear all listeners for a type if function isn't specified
			delete this._events[type];
			return;
		}

		if (context === this) {
			context = undefined;
		}

		if (listeners) {

			// find fn and remove it
			for (i = 0, len = listeners.length; i < len; i++) {
				var l = listeners[i];
				if (l.ctx !== context) { continue; }
				if (l.fn === fn) {

					// set the removed listener to noop so that's not called if remove happens in fire
					l.fn = falseFn;

					if (this._firingCount) {
						/* copy array in case events are being fired */
						this._events[type] = listeners = listeners.slice();
					}
					listeners.splice(i, 1);

					return;
				}
			}
		}
	},

	// @method fire(type: String, data?: Object, propagate?: Boolean): this
	// Fires an event of the specified type. You can optionally provide an data
	// object — the first argument of the listener function will contain its
	// properties. The event can optionally be propagated to event parents.
	fire: function (type, data, propagate) {
		if (!this.listens(type, propagate)) { return this; }

		var event = extend({}, data, {
			type: type,
			target: this,
			sourceTarget: data && data.sourceTarget || this
		});

		if (this._events) {
			var listeners = this._events[type];

			if (listeners) {
				this._firingCount = (this._firingCount + 1) || 1;
				for (var i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					l.fn.call(l.ctx || this, event);
				}

				this._firingCount--;
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	// @method listens(type: String): Boolean
	// Returns `true` if a particular event type has any listeners attached to it.
	listens: function (type, propagate) {
		var listeners = this._events && this._events[type];
		if (listeners && listeners.length) { return true; }

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) { return true; }
			}
		}
		return false;
	},

	// @method once(…): this
	// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
	once: function (types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = bind(function () {
			this
			    .off(types, fn, context)
			    .off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this
		    .on(types, fn, context)
		    .on(types, handler, context);
	},

	// @method addEventParent(obj: Evented): this
	// Adds an event parent - an `Evented` that will receive propagated events
	addEventParent: function (obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[stamp(obj)] = obj;
		return this;
	},

	// @method removeEventParent(obj: Evented): this
	// Removes an event parent, so it will stop receiving propagated events
	removeEventParent: function (obj) {
		if (this._eventParents) {
			delete this._eventParents[stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function (e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, extend({
				layer: e.target,
				propagatedFrom: e.target
			}, e), true);
		}
	}
};

// aliases; we should ditch those eventually

// @method addEventListener(…): this
// Alias to [`on(…)`](#evented-on)
Events.addEventListener = Events.on;

// @method removeEventListener(…): this
// Alias to [`off(…)`](#evented-off)

// @method clearAllEventListeners(…): this
// Alias to [`off()`](#evented-off)
Events.removeEventListener = Events.clearAllEventListeners = Events.off;

// @method addOneTimeEventListener(…): this
// Alias to [`once(…)`](#evented-once)
Events.addOneTimeEventListener = Events.once;

// @method fireEvent(…): this
// Alias to [`fire(…)`](#evented-fire)
Events.fireEvent = Events.fire;

// @method hasEventListeners(…): Boolean
// Alias to [`listens(…)`](#evented-listens)
Events.hasEventListeners = Events.listens;

var Evented = Class.extend(Events);

/*
 * @class Point
 * @aka L.Point
 *
 * Represents a point with `x` and `y` coordinates in pixels.
 *
 * @example
 *
 * ```js
 * var point = L.point(200, 300);
 * ```
 *
 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
 *
 * ```js
 * map.panBy([200, 300]);
 * map.panBy(L.point(200, 300));
 * ```
 *
 * Note that `Point` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function Point(x, y, round) {
	// @property x: Number; The `x` coordinate of the point
	this.x = (round ? Math.round(x) : x);
	// @property y: Number; The `y` coordinate of the point
	this.y = (round ? Math.round(y) : y);
}

var trunc = Math.trunc || function (v) {
	return v > 0 ? Math.floor(v) : Math.ceil(v);
};

Point.prototype = {

	// @method clone(): Point
	// Returns a copy of the current point.
	clone: function () {
		return new Point(this.x, this.y);
	},

	// @method add(otherPoint: Point): Point
	// Returns the result of addition of the current and the given points.
	add: function (point) {
		// non-destructive, returns a new point
		return this.clone()._add(toPoint(point));
	},

	_add: function (point) {
		// destructive, used directly for performance in situations where it's safe to modify existing point
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	// @method subtract(otherPoint: Point): Point
	// Returns the result of subtraction of the given point from the current.
	subtract: function (point) {
		return this.clone()._subtract(toPoint(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	// @method divideBy(num: Number): Point
	// Returns the result of division of the current point by the given number.
	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	// @method multiplyBy(num: Number): Point
	// Returns the result of multiplication of the current point by the given number.
	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	// @method scaleBy(scale: Point): Point
	// Multiply each coordinate of the current point by each coordinate of
	// `scale`. In linear algebra terms, multiply the point by the
	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
	// defined by `scale`.
	scaleBy: function (point) {
		return new Point(this.x * point.x, this.y * point.y);
	},

	// @method unscaleBy(scale: Point): Point
	// Inverse of `scaleBy`. Divide each coordinate of the current point by
	// each coordinate of `scale`.
	unscaleBy: function (point) {
		return new Point(this.x / point.x, this.y / point.y);
	},

	// @method round(): Point
	// Returns a copy of the current point with rounded coordinates.
	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	// @method floor(): Point
	// Returns a copy of the current point with floored coordinates (rounded down).
	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	// @method ceil(): Point
	// Returns a copy of the current point with ceiled coordinates (rounded up).
	ceil: function () {
		return this.clone()._ceil();
	},

	_ceil: function () {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	// @method trunc(): Point
	// Returns a copy of the current point with truncated coordinates (rounded towards zero).
	trunc: function () {
		return this.clone()._trunc();
	},

	_trunc: function () {
		this.x = trunc(this.x);
		this.y = trunc(this.y);
		return this;
	},

	// @method distanceTo(otherPoint: Point): Number
	// Returns the cartesian distance between the current and the given points.
	distanceTo: function (point) {
		point = toPoint(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	// @method equals(otherPoint: Point): Boolean
	// Returns `true` if the given point has the same coordinates.
	equals: function (point) {
		point = toPoint(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	// @method contains(otherPoint: Point): Boolean
	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
	contains: function (point) {
		point = toPoint(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	// @method toString(): String
	// Returns a string representation of the point for debugging purposes.
	toString: function () {
		return 'Point(' +
		        formatNum(this.x) + ', ' +
		        formatNum(this.y) + ')';
	}
};

// @factory L.point(x: Number, y: Number, round?: Boolean)
// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative
// @factory L.point(coords: Number[])
// Expects an array of the form `[x, y]` instead.

// @alternative
// @factory L.point(coords: Object)
// Expects a plain object of the form `{x: Number, y: Number}` instead.
function toPoint(x, y, round) {
	if (x instanceof Point) {
		return x;
	}
	if (isArray(x)) {
		return new Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	if (typeof x === 'object' && 'x' in x && 'y' in x) {
		return new Point(x.x, x.y);
	}
	return new Point(x, y, round);
}

/*
 * @class Bounds
 * @aka L.Bounds
 *
 * Represents a rectangular area in pixel coordinates.
 *
 * @example
 *
 * ```js
 * var p1 = L.point(10, 10),
 * p2 = L.point(40, 60),
 * bounds = L.bounds(p1, p2);
 * ```
 *
 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * otherBounds.intersects([[10, 10], [40, 60]]);
 * ```
 *
 * Note that `Bounds` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function Bounds(a, b) {
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
}

Bounds.prototype = {
	// @method extend(point: Point): this
	// Extends the bounds to contain the given point.
	extend: function (point) { // (Point)
		point = toPoint(point);

		// @property min: Point
		// The top left corner of the rectangle.
		// @property max: Point
		// The bottom right corner of the rectangle.
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	// @method getCenter(round?: Boolean): Point
	// Returns the center point of the bounds.
	getCenter: function (round) {
		return new Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	// @method getBottomLeft(): Point
	// Returns the bottom-left point of the bounds.
	getBottomLeft: function () {
		return new Point(this.min.x, this.max.y);
	},

	// @method getTopRight(): Point
	// Returns the top-right point of the bounds.
	getTopRight: function () { // -> Point
		return new Point(this.max.x, this.min.y);
	},

	// @method getTopLeft(): Point
	// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
	getTopLeft: function () {
		return this.min; // left, top
	},

	// @method getBottomRight(): Point
	// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
	getBottomRight: function () {
		return this.max; // right, bottom
	},

	// @method getSize(): Point
	// Returns the size of the given bounds
	getSize: function () {
		return this.max.subtract(this.min);
	},

	// @method contains(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle contains the given one.
	// @alternative
	// @method contains(point: Point): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) {
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof Point) {
			obj = toPoint(obj);
		} else {
			obj = toBounds(obj);
		}

		if (obj instanceof Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	// @method intersects(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds
	// intersect if they have at least one point in common.
	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
	// overlap if their intersection is an area.
	overlaps: function (bounds) { // (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
		    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

		return xOverlaps && yOverlaps;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};


// @factory L.bounds(corner1: Point, corner2: Point)
// Creates a Bounds object from two corners coordinate pairs.
// @alternative
// @factory L.bounds(points: Point[])
// Creates a Bounds object from the given array of points.
function toBounds(a, b) {
	if (!a || a instanceof Bounds) {
		return a;
	}
	return new Bounds(a, b);
}

/*
 * @class LatLngBounds
 * @aka L.LatLngBounds
 *
 * Represents a rectangular geographical area on a map.
 *
 * @example
 *
 * ```js
 * var corner1 = L.latLng(40.712, -74.227),
 * corner2 = L.latLng(40.774, -74.125),
 * bounds = L.latLngBounds(corner1, corner2);
 * ```
 *
 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * map.fitBounds([
 * 	[40.712, -74.227],
 * 	[40.774, -74.125]
 * ]);
 * ```
 *
 * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
 *
 * Note that `LatLngBounds` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
	if (!corner1) { return; }

	var latlngs = corner2 ? [corner1, corner2] : corner1;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
}

LatLngBounds.prototype = {

	// @method extend(latlng: LatLng): this
	// Extend the bounds to contain the given point

	// @alternative
	// @method extend(otherBounds: LatLngBounds): this
	// Extend the bounds to contain the given bounds
	extend: function (obj) {
		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof LatLng) {
			sw2 = obj;
			ne2 = obj;

		} else if (obj instanceof LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) { return this; }

		} else {
			return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new LatLng(sw2.lat, sw2.lng);
			this._northEast = new LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// @method pad(bufferRatio: Number): LatLngBounds
	// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
	// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
	// Negative values will retract the bounds.
	pad: function (bufferRatio) {
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new LatLngBounds(
		        new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	// @method getCenter(): LatLng
	// Returns the center point of the bounds.
	getCenter: function () {
		return new LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	// @method getSouthWest(): LatLng
	// Returns the south-west point of the bounds.
	getSouthWest: function () {
		return this._southWest;
	},

	// @method getNorthEast(): LatLng
	// Returns the north-east point of the bounds.
	getNorthEast: function () {
		return this._northEast;
	},

	// @method getNorthWest(): LatLng
	// Returns the north-west point of the bounds.
	getNorthWest: function () {
		return new LatLng(this.getNorth(), this.getWest());
	},

	// @method getSouthEast(): LatLng
	// Returns the south-east point of the bounds.
	getSouthEast: function () {
		return new LatLng(this.getSouth(), this.getEast());
	},

	// @method getWest(): Number
	// Returns the west longitude of the bounds
	getWest: function () {
		return this._southWest.lng;
	},

	// @method getSouth(): Number
	// Returns the south latitude of the bounds
	getSouth: function () {
		return this._southWest.lat;
	},

	// @method getEast(): Number
	// Returns the east longitude of the bounds
	getEast: function () {
		return this._northEast.lng;
	},

	// @method getNorth(): Number
	// Returns the north latitude of the bounds
	getNorth: function () {
		return this._northEast.lat;
	},

	// @method contains(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle contains the given one.

	// @alternative
	// @method contains (latlng: LatLng): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
			obj = toLatLng(obj);
		} else {
			obj = toLatLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	// @method intersects(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
	intersects: function (bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
	overlaps: function (bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
		    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

		return latOverlaps && lngOverlaps;
	},

	// @method toBBoxString(): String
	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
	equals: function (bounds, maxMargin) {
		if (!bounds) { return false; }

		bounds = toLatLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest(), maxMargin) &&
		       this._northEast.equals(bounds.getNorthEast(), maxMargin);
	},

	// @method isValid(): Boolean
	// Returns `true` if the bounds are properly initialized.
	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

// TODO International date line?

// @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
// Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

// @alternative
// @factory L.latLngBounds(latlngs: LatLng[])
// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
function toLatLngBounds(a, b) {
	if (a instanceof LatLngBounds) {
		return a;
	}
	return new LatLngBounds(a, b);
}

/* @class LatLng
 * @aka L.LatLng
 *
 * Represents a geographical point with a certain latitude and longitude.
 *
 * @example
 *
 * ```
 * var latlng = L.latLng(50.5, 30.5);
 * ```
 *
 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
 *
 * ```
 * map.panTo([50, 30]);
 * map.panTo({lon: 30, lat: 50});
 * map.panTo({lat: 50, lng: 30});
 * map.panTo(L.latLng(50, 30));
 * ```
 *
 * Note that `LatLng` does not inherit from Leaflet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function LatLng(lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	// @property lat: Number
	// Latitude in degrees
	this.lat = +lat;

	// @property lng: Number
	// Longitude in degrees
	this.lng = +lng;

	// @property alt: Number
	// Altitude in meters (optional)
	if (alt !== undefined) {
		this.alt = +alt;
	}
}

LatLng.prototype = {
	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
	equals: function (obj, maxMargin) {
		if (!obj) { return false; }

		obj = toLatLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	// @method toString(): String
	// Returns a string representation of the point (for debugging purposes).
	toString: function (precision) {
		return 'LatLng(' +
		        formatNum(this.lat, precision) + ', ' +
		        formatNum(this.lng, precision) + ')';
	},

	// @method distanceTo(otherLatLng: LatLng): Number
	// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
	distanceTo: function (other) {
		return Earth.distance(this, toLatLng(other));
	},

	// @method wrap(): LatLng
	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
	wrap: function () {
		return Earth.wrapLatLng(this);
	},

	// @method toBounds(sizeInMeters: Number): LatLngBounds
	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
	toBounds: function (sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
		    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

		return toLatLngBounds(
		        [this.lat - latAccuracy, this.lng - lngAccuracy],
		        [this.lat + latAccuracy, this.lng + lngAccuracy]);
	},

	clone: function () {
		return new LatLng(this.lat, this.lng, this.alt);
	}
};



// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative
// @factory L.latLng(coords: Array): LatLng
// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative
// @factory L.latLng(coords: Object): LatLng
// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

function toLatLng(a, b, c) {
	if (a instanceof LatLng) {
		return a;
	}
	if (isArray(a) && typeof a[0] !== 'object') {
		if (a.length === 3) {
			return new LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new LatLng(a, b, c);
}

/*
 * @namespace CRS
 * @crs L.CRS.Base
 * Object that defines coordinate reference systems for projecting
 * geographical points into pixel (screen) coordinates and back (and to
 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
 *
 * Leaflet defines the most usual CRSs by default. If you want to use a
 * CRS not defined by default, take a look at the
 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
 *
 * Note that the CRS instances do not inherit from Leafet's `Class` object,
 * and can't be instantiated. Also, new classes can't inherit from them,
 * and methods can't be added to them with the `include` function.
 */

var CRS = {
	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
	// Projects geographical coordinates into pixel coordinates for a given zoom.
	latLngToPoint: function (latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// @method pointToLatLng(point: Point, zoom: Number): LatLng
	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
	// zoom into geographical coordinates.
	pointToLatLng: function (point, zoom) {
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// @method project(latlng: LatLng): Point
	// Projects geographical coordinates into coordinates in units accepted for
	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
	project: function (latlng) {
		return this.projection.project(latlng);
	},

	// @method unproject(point: Point): LatLng
	// Given a projected coordinate returns the corresponding LatLng.
	// The inverse of `project`.
	unproject: function (point) {
		return this.projection.unproject(point);
	},

	// @method scale(zoom: Number): Number
	// Returns the scale used when transforming projected coordinates into
	// pixel coordinates for a particular zoom. For example, it returns
	// `256 * 2^zoom` for Mercator-based CRS.
	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// @method zoom(scale: Number): Number
	// Inverse of `scale()`, returns the zoom level corresponding to a scale
	// factor of `scale`.
	zoom: function (scale) {
		return Math.log(scale / 256) / Math.LN2;
	},

	// @method getProjectedBounds(zoom: Number): Bounds
	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
	getProjectedBounds: function (zoom) {
		if (this.infinite) { return null; }

		var b = this.projection.bounds,
		    s = this.scale(zoom),
		    min = this.transformation.transform(b.min, s),
		    max = this.transformation.transform(b.max, s);

		return new Bounds(min, max);
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates.

	// @property code: String
	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
	//
	// @property wrapLng: Number[]
	// An array of two numbers defining whether the longitude (horizontal) coordinate
	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
	//
	// @property wrapLat: Number[]
	// Like `wrapLng`, but for the latitude (vertical) axis.

	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// @property infinite: Boolean
	// If true, the coordinate space will be unbounded (infinite in both axes)
	infinite: false,

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where lat and lng has been wrapped according to the
	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
	wrapLatLng: function (latlng) {
		var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
		    lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
		    alt = latlng.alt;

		return new LatLng(lat, lng, alt);
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring
	// that its center is within the CRS's bounds.
	// Only accepts actual `L.LatLngBounds` instances, not arrays.
	wrapLatLngBounds: function (bounds) {
		var center = bounds.getCenter(),
		    newCenter = this.wrapLatLng(center),
		    latShift = center.lat - newCenter.lat,
		    lngShift = center.lng - newCenter.lng;

		if (latShift === 0 && lngShift === 0) {
			return bounds;
		}

		var sw = bounds.getSouthWest(),
		    ne = bounds.getNorthEast(),
		    newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
		    newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);

		return new LatLngBounds(newSw, newNe);
	}
};

/*
 * @namespace CRS
 * @crs L.CRS.Earth
 *
 * Serves as the base for CRS that are global such that they cover the earth.
 * Can only be used as the base for other CRS and cannot be used directly,
 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
 * meters.
 */

var Earth = extend({}, CRS, {
	wrapLng: [-180, 180],

	// Mean Earth Radius, as recommended for use by
	// the International Union of Geodesy and Geophysics,
	// see http://rosettacode.org/wiki/Haversine_formula
	R: 6371000,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function (latlng1, latlng2) {
		var rad = Math.PI / 180,
		    lat1 = latlng1.lat * rad,
		    lat2 = latlng2.lat * rad,
		    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
		    sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
		    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
		    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
		return this.R * c;
	}
});

/*
 * @namespace Projection
 * @projection L.Projection.SphericalMercator
 *
 * Spherical Mercator projection — the most common projection for online maps,
 * used by almost all free and commercial tile providers. Assumes that Earth is
 * a sphere. Used by the `EPSG:3857` CRS.
 */

var earthRadius = 6378137;

var SphericalMercator = {

	R: earthRadius,
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) {
		var d = Math.PI / 180,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    sin = Math.sin(lat * d);

		return new Point(
			this.R * latlng.lng * d,
			this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function (point) {
		var d = 180 / Math.PI;

		return new LatLng(
			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
			point.x * d / this.R);
	},

	bounds: (function () {
		var d = earthRadius * Math.PI;
		return new Bounds([-d, -d], [d, d]);
	})()
};

/*
 * @class Transformation
 * @aka L.Transformation
 *
 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
 * the reverse. Used by Leaflet in its projections code.
 *
 * @example
 *
 * ```js
 * var transformation = L.transformation(2, 5, -1, 10),
 * 	p = L.point(1, 2),
 * 	p2 = transformation.transform(p), //  L.point(7, 8)
 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
 * ```
 */


// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
// Creates a `Transformation` object with the given coefficients.
function Transformation(a, b, c, d) {
	if (isArray(a)) {
		// use array properties
		this._a = a[0];
		this._b = a[1];
		this._c = a[2];
		this._d = a[3];
		return;
	}
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
}

Transformation.prototype = {
	// @method transform(point: Point, scale?: Number): Point
	// Returns a transformed point, optionally multiplied by the given scale.
	// Only accepts actual `L.Point` instances, not arrays.
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	// @method untransform(point: Point, scale?: Number): Point
	// Returns the reverse transformation of the given point, optionally divided
	// by the given scale. Only accepts actual `L.Point` instances, not arrays.
	untransform: function (point, scale) {
		scale = scale || 1;
		return new Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};

// factory L.transformation(a: Number, b: Number, c: Number, d: Number)

// @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
// Instantiates a Transformation object with the given coefficients.

// @alternative
// @factory L.transformation(coefficients: Array): Transformation
// Expects an coefficients array of the form
// `[a: Number, b: Number, c: Number, d: Number]`.

function toTransformation(a, b, c, d) {
	return new Transformation(a, b, c, d);
}

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3857
 *
 * The most common CRS for online maps, used by almost all free and commercial
 * tile providers. Uses Spherical Mercator projection. Set in by default in
 * Map's `crs` option.
 */

var EPSG3857 = extend({}, Earth, {
	code: 'EPSG:3857',
	projection: SphericalMercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * SphericalMercator.R);
		return toTransformation(scale, 0.5, -scale, 0.5);
	}())
});

var EPSG900913 = extend({}, EPSG3857, {
	code: 'EPSG:900913'
});

// @namespace SVG; @section
// There are several static functions which can be called without instantiating L.SVG:

// @function create(name: String): SVGElement
// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
// corresponding to the class name passed. For example, using 'line' will return
// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
function svgCreate(name) {
	return document.createElementNS('http://www.w3.org/2000/svg', name);
}

// @function pointsToPath(rings: Point[], closed: Boolean): String
// Generates a SVG path string for multiple rings, with each ring turning
// into "M..L..L.." instructions
function pointsToPath(rings, closed) {
	var str = '',
	i, j, len, len2, points, p;

	for (i = 0, len = rings.length; i < len; i++) {
		points = rings[i];

		for (j = 0, len2 = points.length; j < len2; j++) {
			p = points[j];
			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
		}

		// closes the ring for polygons; "x" is VML syntax
		str += closed ? (svg ? 'z' : 'x') : '';
	}

	// SVG complains about empty path strings
	return str || 'M0 0';
}

/*
 * @namespace Browser
 * @aka L.Browser
 *
 * A namespace with static properties for browser/feature detection used by Leaflet internally.
 *
 * @example
 *
 * ```js
 * if (L.Browser.ielt9) {
 *   alert('Upgrade your browser, dude!');
 * }
 * ```
 */

var style$1 = document.documentElement.style;

// @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
var ie = 'ActiveXObject' in window;

// @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
var ielt9 = ie && !document.addEventListener;

// @property edge: Boolean; `true` for the Edge web browser.
var edge = 'msLaunchUri' in navigator && !('documentMode' in document);

// @property webkit: Boolean;
// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
var webkit = userAgentContains('webkit');

// @property android: Boolean
// `true` for any browser running on an Android platform.
var android = userAgentContains('android');

// @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.
var android23 = userAgentContains('android 2') || userAgentContains('android 3');

/* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
// @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)
var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);

// @property opera: Boolean; `true` for the Opera browser
var opera = !!window.opera;

// @property chrome: Boolean; `true` for the Chrome browser.
var chrome = userAgentContains('chrome');

// @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

// @property safari: Boolean; `true` for the Safari browser.
var safari = !chrome && userAgentContains('safari');

var phantom = userAgentContains('phantom');

// @property opera12: Boolean
// `true` for the Opera browser supporting CSS transforms (version 12 or later).
var opera12 = 'OTransition' in style$1;

// @property win: Boolean; `true` when the browser is running in a Windows platform
var win = navigator.platform.indexOf('Win') === 0;

// @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
var ie3d = ie && ('transition' in style$1);

// @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;

// @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
var gecko3d = 'MozPerspective' in style$1;

// @property any3d: Boolean
// `true` for all browsers supporting CSS transforms.
var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

// @property mobile: Boolean; `true` for all browsers running in a mobile device.
var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

// @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
var mobileWebkit = mobile && webkit;

// @property mobileWebkit3d: Boolean
// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
var mobileWebkit3d = mobile && webkit3d;

// @property msPointer: Boolean
// `true` for browsers implementing the Microsoft touch events model (notably IE10).
var msPointer = !window.PointerEvent && window.MSPointerEvent;

// @property pointer: Boolean
// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
var pointer = !webkit && !!(window.PointerEvent || msPointer);

// @property touch: Boolean
// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
// This does not necessarily mean that the browser is running in a computer with
// a touchscreen, it only means that the browser is capable of understanding
// touch events.
var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
		(window.DocumentTouch && document instanceof window.DocumentTouch));

// @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
var mobileOpera = mobile && opera;

// @property mobileGecko: Boolean
// `true` for gecko-based browsers running in a mobile device.
var mobileGecko = mobile && gecko;

// @property retina: Boolean
// `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.
var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;

// @property passiveEvents: Boolean
// `true` for browsers that support passive events.
var passiveEvents = (function () {
	var supportsPassiveOption = false;
	try {
		var opts = Object.defineProperty({}, 'passive', {
			get: function () {
				supportsPassiveOption = true;
			}
		});
		window.addEventListener('testPassiveEventSupport', falseFn, opts);
		window.removeEventListener('testPassiveEventSupport', falseFn, opts);
	} catch (e) {
		// Errors can safely be ignored since this is only a browser support test.
	}
	return supportsPassiveOption;
});

// @property canvas: Boolean
// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
var canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

// @property svg: Boolean
// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect);

// @property vml: Boolean
// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
var vml = !svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());


function userAgentContains(str) {
	return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
}


var Browser = (Object.freeze || Object)({
	ie: ie,
	ielt9: ielt9,
	edge: edge,
	webkit: webkit,
	android: android,
	android23: android23,
	androidStock: androidStock,
	opera: opera,
	chrome: chrome,
	gecko: gecko,
	safari: safari,
	phantom: phantom,
	opera12: opera12,
	win: win,
	ie3d: ie3d,
	webkit3d: webkit3d,
	gecko3d: gecko3d,
	any3d: any3d,
	mobile: mobile,
	mobileWebkit: mobileWebkit,
	mobileWebkit3d: mobileWebkit3d,
	msPointer: msPointer,
	pointer: pointer,
	touch: touch,
	mobileOpera: mobileOpera,
	mobileGecko: mobileGecko,
	retina: retina,
	passiveEvents: passiveEvents,
	canvas: canvas,
	svg: svg,
	vml: vml
});

/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */


var POINTER_DOWN =   msPointer ? 'MSPointerDown'   : 'pointerdown';
var POINTER_MOVE =   msPointer ? 'MSPointerMove'   : 'pointermove';
var POINTER_UP =     msPointer ? 'MSPointerUp'     : 'pointerup';
var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';
var TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'];

var _pointers = {};
var _pointerDocListener = false;

// DomEvent.DoubleTap needs to know about this
var _pointersCount = 0;

// Provides a touch events wrapper for (ms)pointer events.
// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

function addPointerListener(obj, type, handler, id) {
	if (type === 'touchstart') {
		_addPointerStart(obj, handler, id);

	} else if (type === 'touchmove') {
		_addPointerMove(obj, handler, id);

	} else if (type === 'touchend') {
		_addPointerEnd(obj, handler, id);
	}

	return this;
}

function removePointerListener(obj, type, id) {
	var handler = obj['_leaflet_' + type + id];

	if (type === 'touchstart') {
		obj.removeEventListener(POINTER_DOWN, handler, false);

	} else if (type === 'touchmove') {
		obj.removeEventListener(POINTER_MOVE, handler, false);

	} else if (type === 'touchend') {
		obj.removeEventListener(POINTER_UP, handler, false);
		obj.removeEventListener(POINTER_CANCEL, handler, false);
	}

	return this;
}

function _addPointerStart(obj, handler, id) {
	var onDown = bind(function (e) {
		if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
			// In IE11, some touch events needs to fire for form controls, or
			// the controls will stop working. We keep a whitelist of tag names that
			// need these events. For other target tags, we prevent default on the event.
			if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
				preventDefault(e);
			} else {
				return;
			}
		}

		_handlePointer(e, handler);
	});

	obj['_leaflet_touchstart' + id] = onDown;
	obj.addEventListener(POINTER_DOWN, onDown, false);

	// need to keep track of what pointers and how many are active to provide e.touches emulation
	if (!_pointerDocListener) {
		// we listen documentElement as any drags that end by moving the touch off the screen get fired there
		document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);
		document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);
		document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);
		document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

		_pointerDocListener = true;
	}
}

function _globalPointerDown(e) {
	_pointers[e.pointerId] = e;
	_pointersCount++;
}

function _globalPointerMove(e) {
	if (_pointers[e.pointerId]) {
		_pointers[e.pointerId] = e;
	}
}

function _globalPointerUp(e) {
	delete _pointers[e.pointerId];
	_pointersCount--;
}

function _handlePointer(e, handler) {
	e.touches = [];
	for (var i in _pointers) {
		e.touches.push(_pointers[i]);
	}
	e.changedTouches = [e];

	handler(e);
}

function _addPointerMove(obj, handler, id) {
	var onMove = function (e) {
		// don't fire touch moves when mouse isn't down
		if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

		_handlePointer(e, handler);
	};

	obj['_leaflet_touchmove' + id] = onMove;
	obj.addEventListener(POINTER_MOVE, onMove, false);
}

function _addPointerEnd(obj, handler, id) {
	var onUp = function (e) {
		_handlePointer(e, handler);
	};

	obj['_leaflet_touchend' + id] = onUp;
	obj.addEventListener(POINTER_UP, onUp, false);
	obj.addEventListener(POINTER_CANCEL, onUp, false);
}

/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';
var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';
var _pre = '_leaflet_';

// inspired by Zepto touch code by Thomas Fuchs
function addDoubleTapListener(obj, handler, id) {
	var last, touch$$1,
	    doubleTap = false,
	    delay = 250;

	function onTouchStart(e) {
		var count;

		if (pointer) {
			if ((!edge) || e.pointerType === 'mouse') { return; }
			count = _pointersCount;
		} else {
			count = e.touches.length;
		}

		if (count > 1) { return; }

		var now = Date.now(),
		    delta = now - (last || now);

		touch$$1 = e.touches ? e.touches[0] : e;
		doubleTap = (delta > 0 && delta <= delay);
		last = now;
	}

	function onTouchEnd(e) {
		if (doubleTap && !touch$$1.cancelBubble) {
			if (pointer) {
				if ((!edge) || e.pointerType === 'mouse') { return; }
				// work around .type being readonly with MSPointer* events
				var newTouch = {},
				    prop, i;

				for (i in touch$$1) {
					prop = touch$$1[i];
					newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
				}
				touch$$1 = newTouch;
			}
			touch$$1.type = 'dblclick';
			touch$$1.button = 0;
			handler(touch$$1);
			last = null;
		}
	}

	obj[_pre + _touchstart + id] = onTouchStart;
	obj[_pre + _touchend + id] = onTouchEnd;
	obj[_pre + 'dblclick' + id] = handler;

	obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? {passive: false} : false);
	obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? {passive: false} : false);

	// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
	// the browser doesn't fire touchend/pointerup events but does fire
	// native dblclicks. See #4127.
	// Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.
	obj.addEventListener('dblclick', handler, false);

	return this;
}

function removeDoubleTapListener(obj, id) {
	var touchstart = obj[_pre + _touchstart + id],
	    touchend = obj[_pre + _touchend + id],
	    dblclick = obj[_pre + 'dblclick' + id];

	obj.removeEventListener(_touchstart, touchstart, passiveEvents ? {passive: false} : false);
	obj.removeEventListener(_touchend, touchend, passiveEvents ? {passive: false} : false);
	if (!edge) {
		obj.removeEventListener('dblclick', dblclick, false);
	}

	return this;
}

/*
 * @namespace DomUtil
 *
 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
 * tree, used by Leaflet internally.
 *
 * Most functions expecting or returning a `HTMLElement` also work for
 * SVG elements. The only difference is that classes refer to CSS classes
 * in HTML and SVG classes in SVG.
 */


// @property TRANSFORM: String
// Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
var TRANSFORM = testProp(
	['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

// @property TRANSITION: String
// Vendor-prefixed transition style name.
var TRANSITION = testProp(
	['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

// @property TRANSITION_END: String
// Vendor-prefixed transitionend event name.
var TRANSITION_END =
	TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';


// @function get(id: String|HTMLElement): HTMLElement
// Returns an element given its DOM id, or returns the element itself
// if it was passed directly.
function get(id) {
	return typeof id === 'string' ? document.getElementById(id) : id;
}

// @function getStyle(el: HTMLElement, styleAttrib: String): String
// Returns the value for a certain style attribute on an element,
// including computed values or values set through CSS.
function getStyle(el, style) {
	var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

	if ((!value || value === 'auto') && document.defaultView) {
		var css = document.defaultView.getComputedStyle(el, null);
		value = css ? css[style] : null;
	}
	return value === 'auto' ? null : value;
}

// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
function create$1(tagName, className, container) {
	var el = document.createElement(tagName);
	el.className = className || '';

	if (container) {
		container.appendChild(el);
	}
	return el;
}

// @function remove(el: HTMLElement)
// Removes `el` from its parent element
function remove(el) {
	var parent = el.parentNode;
	if (parent) {
		parent.removeChild(el);
	}
}

// @function empty(el: HTMLElement)
// Removes all of `el`'s children elements from `el`
function empty(el) {
	while (el.firstChild) {
		el.removeChild(el.firstChild);
	}
}

// @function toFront(el: HTMLElement)
// Makes `el` the last child of its parent, so it renders in front of the other children.
function toFront(el) {
	var parent = el.parentNode;
	if (parent && parent.lastChild !== el) {
		parent.appendChild(el);
	}
}

// @function toBack(el: HTMLElement)
// Makes `el` the first child of its parent, so it renders behind the other children.
function toBack(el) {
	var parent = el.parentNode;
	if (parent && parent.firstChild !== el) {
		parent.insertBefore(el, parent.firstChild);
	}
}

// @function hasClass(el: HTMLElement, name: String): Boolean
// Returns `true` if the element's class attribute contains `name`.
function hasClass(el, name) {
	if (el.classList !== undefined) {
		return el.classList.contains(name);
	}
	var className = getClass(el);
	return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
}

// @function addClass(el: HTMLElement, name: String)
// Adds `name` to the element's class attribute.
function addClass(el, name) {
	if (el.classList !== undefined) {
		var classes = splitWords(name);
		for (var i = 0, len = classes.length; i < len; i++) {
			el.classList.add(classes[i]);
		}
	} else if (!hasClass(el, name)) {
		var className = getClass(el);
		setClass(el, (className ? className + ' ' : '') + name);
	}
}

// @function removeClass(el: HTMLElement, name: String)
// Removes `name` from the element's class attribute.
function removeClass(el, name) {
	if (el.classList !== undefined) {
		el.classList.remove(name);
	} else {
		setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
	}
}

// @function setClass(el: HTMLElement, name: String)
// Sets the element's class.
function setClass(el, name) {
	if (el.className.baseVal === undefined) {
		el.className = name;
	} else {
		// in case of SVG element
		el.className.baseVal = name;
	}
}

// @function getClass(el: HTMLElement): String
// Returns the element's class.
function getClass(el) {
	// Check if the element is an SVGElementInstance and use the correspondingElement instead
	// (Required for linked SVG elements in IE11.)
	if (el.correspondingElement) {
		el = el.correspondingElement;
	}
	return el.className.baseVal === undefined ? el.className : el.className.baseVal;
}

// @function setOpacity(el: HTMLElement, opacity: Number)
// Set the opacity of an element (including old IE support).
// `opacity` must be a number from `0` to `1`.
function setOpacity(el, value) {
	if ('opacity' in el.style) {
		el.style.opacity = value;
	} else if ('filter' in el.style) {
		_setOpacityIE(el, value);
	}
}

function _setOpacityIE(el, value) {
	var filter = false,
	    filterName = 'DXImageTransform.Microsoft.Alpha';

	// filters collection throws an error if we try to retrieve a filter that doesn't exist
	try {
		filter = el.filters.item(filterName);
	} catch (e) {
		// don't set opacity to 1 if we haven't already set an opacity,
		// it isn't needed and breaks transparent pngs.
		if (value === 1) { return; }
	}

	value = Math.round(value * 100);

	if (filter) {
		filter.Enabled = (value !== 100);
		filter.Opacity = value;
	} else {
		el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
	}
}

// @function testProp(props: String[]): String|false
// Goes through the array of style names and returns the first name
// that is a valid style name for an element. If no such name is found,
// it returns false. Useful for vendor-prefixed styles like `transform`.
function testProp(props) {
	var style = document.documentElement.style;

	for (var i = 0; i < props.length; i++) {
		if (props[i] in style) {
			return props[i];
		}
	}
	return false;
}

// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
// and optionally scaled by `scale`. Does not have an effect if the
// browser doesn't support 3D CSS transforms.
function setTransform(el, offset, scale) {
	var pos = offset || new Point(0, 0);

	el.style[TRANSFORM] =
		(ie3d ?
			'translate(' + pos.x + 'px,' + pos.y + 'px)' :
			'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
		(scale ? ' scale(' + scale + ')' : '');
}

// @function setPosition(el: HTMLElement, position: Point)
// Sets the position of `el` to coordinates specified by `position`,
// using CSS translate or top/left positioning depending on the browser
// (used by Leaflet internally to position its layers).
function setPosition(el, point) {

	/*eslint-disable */
	el._leaflet_pos = point;
	/* eslint-enable */

	if (any3d) {
		setTransform(el, point);
	} else {
		el.style.left = point.x + 'px';
		el.style.top = point.y + 'px';
	}
}

// @function getPosition(el: HTMLElement): Point
// Returns the coordinates of an element previously positioned with setPosition.
function getPosition(el) {
	// this method is only used for elements previously positioned using setPosition,
	// so it's safe to cache the position for performance

	return el._leaflet_pos || new Point(0, 0);
}

// @function disableTextSelection()
// Prevents the user from generating `selectstart` DOM events, usually generated
// when the user drags the mouse through a page with text. Used internally
// by Leaflet to override the behaviour of any click-and-drag interaction on
// the map. Affects drag interactions on the whole document.

// @function enableTextSelection()
// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
var disableTextSelection;
var enableTextSelection;
var _userSelect;
if ('onselectstart' in document) {
	disableTextSelection = function () {
		on(window, 'selectstart', preventDefault);
	};
	enableTextSelection = function () {
		off(window, 'selectstart', preventDefault);
	};
} else {
	var userSelectProperty = testProp(
		['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

	disableTextSelection = function () {
		if (userSelectProperty) {
			var style = document.documentElement.style;
			_userSelect = style[userSelectProperty];
			style[userSelectProperty] = 'none';
		}
	};
	enableTextSelection = function () {
		if (userSelectProperty) {
			document.documentElement.style[userSelectProperty] = _userSelect;
			_userSelect = undefined;
		}
	};
}

// @function disableImageDrag()
// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
// for `dragstart` DOM events, usually generated when the user drags an image.
function disableImageDrag() {
	on(window, 'dragstart', preventDefault);
}

// @function enableImageDrag()
// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
function enableImageDrag() {
	off(window, 'dragstart', preventDefault);
}

var _outlineElement;
var _outlineStyle;
// @function preventOutline(el: HTMLElement)
// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
// of the element `el` invisible. Used internally by Leaflet to prevent
// focusable elements from displaying an outline when the user performs a
// drag interaction on them.
function preventOutline(element) {
	while (element.tabIndex === -1) {
		element = element.parentNode;
	}
	if (!element.style) { return; }
	restoreOutline();
	_outlineElement = element;
	_outlineStyle = element.style.outline;
	element.style.outline = 'none';
	on(window, 'keydown', restoreOutline);
}

// @function restoreOutline()
// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
function restoreOutline() {
	if (!_outlineElement) { return; }
	_outlineElement.style.outline = _outlineStyle;
	_outlineElement = undefined;
	_outlineStyle = undefined;
	off(window, 'keydown', restoreOutline);
}

// @function getSizedParentNode(el: HTMLElement): HTMLElement
// Finds the closest parent node which size (width and height) is not null.
function getSizedParentNode(element) {
	do {
		element = element.parentNode;
	} while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
	return element;
}

// @function getScale(el: HTMLElement): Object
// Computes the CSS scale currently applied on the element.
// Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
// and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
function getScale(element) {
	var rect = element.getBoundingClientRect(); // Read-only in old browsers.

	return {
		x: rect.width / element.offsetWidth || 1,
		y: rect.height / element.offsetHeight || 1,
		boundingClientRect: rect
	};
}


var DomUtil = (Object.freeze || Object)({
	TRANSFORM: TRANSFORM,
	TRANSITION: TRANSITION,
	TRANSITION_END: TRANSITION_END,
	get: get,
	getStyle: getStyle,
	create: create$1,
	remove: remove,
	empty: empty,
	toFront: toFront,
	toBack: toBack,
	hasClass: hasClass,
	addClass: addClass,
	removeClass: removeClass,
	setClass: setClass,
	getClass: getClass,
	setOpacity: setOpacity,
	testProp: testProp,
	setTransform: setTransform,
	setPosition: setPosition,
	getPosition: getPosition,
	disableTextSelection: disableTextSelection,
	enableTextSelection: enableTextSelection,
	disableImageDrag: disableImageDrag,
	enableImageDrag: enableImageDrag,
	preventOutline: preventOutline,
	restoreOutline: restoreOutline,
	getSizedParentNode: getSizedParentNode,
	getScale: getScale
});

/*
 * @namespace DomEvent
 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
 */

// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Adds a listener function (`fn`) to a particular DOM event type of the
// element `el`. You can optionally specify the context of the listener
// (object the `this` keyword will point to). You can also pass several
// space-separated types (e.g. `'click dblclick'`).

// @alternative
// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
function on(obj, types, fn, context) {

	if (typeof types === 'object') {
		for (var type in types) {
			addOne(obj, type, types[type], fn);
		}
	} else {
		types = splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			addOne(obj, types[i], fn, context);
		}
	}

	return this;
}

var eventsKey = '_leaflet_events';

// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Removes a previously added listener function.
// Note that if you passed a custom context to on, you must pass the same
// context to `off` in order to remove the listener.

// @alternative
// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
function off(obj, types, fn, context) {

	if (typeof types === 'object') {
		for (var type in types) {
			removeOne(obj, type, types[type], fn);
		}
	} else if (types) {
		types = splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			removeOne(obj, types[i], fn, context);
		}
	} else {
		for (var j in obj[eventsKey]) {
			removeOne(obj, j, obj[eventsKey][j]);
		}
		delete obj[eventsKey];
	}

	return this;
}

function addOne(obj, type, fn, context) {
	var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

	if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

	var handler = function (e) {
		return fn.call(context || obj, e || window.event);
	};

	var originalHandler = handler;

	if (pointer && type.indexOf('touch') === 0) {
		// Needs DomEvent.Pointer.js
		addPointerListener(obj, type, handler, id);

	} else if (touch && (type === 'dblclick') && addDoubleTapListener &&
	           !(pointer && chrome)) {
		// Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener
		// See #5180
		addDoubleTapListener(obj, handler, id);

	} else if ('addEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, passiveEvents ? {passive: false} : false);

		} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
			handler = function (e) {
				e = e || window.event;
				if (isExternalTarget(obj, e)) {
					originalHandler(e);
				}
			};
			obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

		} else {
			if (type === 'click' && android) {
				handler = function (e) {
					filterClick(e, originalHandler);
				};
			}
			obj.addEventListener(type, handler, false);
		}

	} else if ('attachEvent' in obj) {
		obj.attachEvent('on' + type, handler);
	}

	obj[eventsKey] = obj[eventsKey] || {};
	obj[eventsKey][id] = handler;
}

function removeOne(obj, type, fn, context) {

	var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),
	    handler = obj[eventsKey] && obj[eventsKey][id];

	if (!handler) { return this; }

	if (pointer && type.indexOf('touch') === 0) {
		removePointerListener(obj, type, id);

	} else if (touch && (type === 'dblclick') && removeDoubleTapListener &&
	           !(pointer && chrome)) {
		removeDoubleTapListener(obj, id);

	} else if ('removeEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, passiveEvents ? {passive: false} : false);

		} else {
			obj.removeEventListener(
				type === 'mouseenter' ? 'mouseover' :
				type === 'mouseleave' ? 'mouseout' : type, handler, false);
		}

	} else if ('detachEvent' in obj) {
		obj.detachEvent('on' + type, handler);
	}

	obj[eventsKey][id] = null;
}

// @function stopPropagation(ev: DOMEvent): this
// Stop the given event from propagation to parent elements. Used inside the listener functions:
// ```js
// L.DomEvent.on(div, 'click', function (ev) {
// 	L.DomEvent.stopPropagation(ev);
// });
// ```
function stopPropagation(e) {

	if (e.stopPropagation) {
		e.stopPropagation();
	} else if (e.originalEvent) {  // In case of Leaflet event.
		e.originalEvent._stopped = true;
	} else {
		e.cancelBubble = true;
	}
	skipped(e);

	return this;
}

// @function disableScrollPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
function disableScrollPropagation(el) {
	addOne(el, 'mousewheel', stopPropagation);
	return this;
}

// @function disableClickPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
// `'mousedown'` and `'touchstart'` events (plus browser variants).
function disableClickPropagation(el) {
	on(el, 'mousedown touchstart dblclick', stopPropagation);
	addOne(el, 'click', fakeStop);
	return this;
}

// @function preventDefault(ev: DOMEvent): this
// Prevents the default action of the DOM Event `ev` from happening (such as
// following a link in the href of the a element, or doing a POST request
// with page reload when a `<form>` is submitted).
// Use it inside listener functions.
function preventDefault(e) {
	if (e.preventDefault) {
		e.preventDefault();
	} else {
		e.returnValue = false;
	}
	return this;
}

// @function stop(ev: DOMEvent): this
// Does `stopPropagation` and `preventDefault` at the same time.
function stop(e) {
	preventDefault(e);
	stopPropagation(e);
	return this;
}

// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
// Gets normalized mouse position from a DOM event relative to the
// `container` (border excluded) or to the whole page if not specified.
function getMousePosition(e, container) {
	if (!container) {
		return new Point(e.clientX, e.clientY);
	}

	var scale = getScale(container),
	    offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

	return new Point(
		// offset.left/top values are in page scale (like clientX/Y),
		// whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
		(e.clientX - offset.left) / scale.x - container.clientLeft,
		(e.clientY - offset.top) / scale.y - container.clientTop
	);
}

// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
// and Firefox scrolls device pixels, not CSS pixels
var wheelPxFactor =
	(win && chrome) ? 2 * window.devicePixelRatio :
	gecko ? window.devicePixelRatio : 1;

// @function getWheelDelta(ev: DOMEvent): Number
// Gets normalized wheel delta from a mousewheel DOM event, in vertical
// pixels scrolled (negative if scrolling down).
// Events from pointing devices without precise scrolling are mapped to
// a best guess of 60 pixels.
function getWheelDelta(e) {
	return (edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
	       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels
	       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
	       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
	       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
	       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
	       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
	       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
	       0;
}

var skipEvents = {};

function fakeStop(e) {
	// fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
	skipEvents[e.type] = true;
}

function skipped(e) {
	var events = skipEvents[e.type];
	// reset when checking, as it's only used in map container and propagates outside of the map
	skipEvents[e.type] = false;
	return events;
}

// check if element really left/entered the event target (for mouseenter/mouseleave)
function isExternalTarget(el, e) {

	var related = e.relatedTarget;

	if (!related) { return true; }

	try {
		while (related && (related !== el)) {
			related = related.parentNode;
		}
	} catch (err) {
		return false;
	}
	return (related !== el);
}

var lastClick;

// this is a horrible workaround for a bug in Android where a single touch triggers two click events
function filterClick(e, handler) {
	var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
	    elapsed = lastClick && (timeStamp - lastClick);

	// are they closer together than 500ms yet more than 100ms?
	// Android typically triggers them ~300ms apart while multiple listeners
	// on the same event should be triggered far faster;
	// or check if click is simulated on the element, and if it is, reject any non-simulated events

	if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
		stop(e);
		return;
	}
	lastClick = timeStamp;

	handler(e);
}




var DomEvent = (Object.freeze || Object)({
	on: on,
	off: off,
	stopPropagation: stopPropagation,
	disableScrollPropagation: disableScrollPropagation,
	disableClickPropagation: disableClickPropagation,
	preventDefault: preventDefault,
	stop: stop,
	getMousePosition: getMousePosition,
	getWheelDelta: getWheelDelta,
	fakeStop: fakeStop,
	skipped: skipped,
	isExternalTarget: isExternalTarget,
	addListener: on,
	removeListener: off
});

/*
 * @class PosAnimation
 * @aka L.PosAnimation
 * @inherits Evented
 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
 *
 * @example
 * ```js
 * var fx = new L.PosAnimation();
 * fx.run(el, [300, 500], 0.5);
 * ```
 *
 * @constructor L.PosAnimation()
 * Creates a `PosAnimation` object.
 *
 */

var PosAnimation = Evented.extend({

	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
	// Run an animation of a given element to a new position, optionally setting
	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
	// `0.5` by default).
	run: function (el, newPos, duration, easeLinearity) {
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		// @event start: Event
		// Fired when the animation starts
		this.fire('start');

		this._animate();
	},

	// @method stop()
	// Stops the animation (if currently running).
	stop: function () {
		if (!this._inProgress) { return; }

		this._step(true);
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function (round) {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		setPosition(this._el, pos);

		// @event step: Event
		// Fired continuously during the animation.
		this.fire('step');
	},

	_complete: function () {
		cancelAnimFrame(this._animId);

		this._inProgress = false;
		// @event end: Event
		// Fired when the animation ends.
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});

/*
 * @class Map
 * @aka L.Map
 * @inherits Evented
 *
 * The central class of the API — it is used to create a map on a page and manipulate it.
 *
 * @example
 *
 * ```js
 * // initialize the map on the "map" div with a given center and zoom
 * var map = L.map('map', {
 * 	center: [51.505, -0.09],
 * 	zoom: 13
 * });
 * ```
 *
 */

var Map = Evented.extend({

	options: {
		// @section Map State Options
		// @option crs: CRS = L.CRS.EPSG3857
		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
		// sure what it means.
		crs: EPSG3857,

		// @option center: LatLng = undefined
		// Initial geographic center of the map
		center: undefined,

		// @option zoom: Number = undefined
		// Initial map zoom level
		zoom: undefined,

		// @option minZoom: Number = *
		// Minimum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the lowest of their `minZoom` options will be used instead.
		minZoom: undefined,

		// @option maxZoom: Number = *
		// Maximum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the highest of their `maxZoom` options will be used instead.
		maxZoom: undefined,

		// @option layers: Layer[] = []
		// Array of layers that will be added to the map initially
		layers: [],

		// @option maxBounds: LatLngBounds = null
		// When this option is set, the map restricts the view to the given
		// geographical bounds, bouncing the user back if the user tries to pan
		// outside the view. To set the restriction dynamically, use
		// [`setMaxBounds`](#map-setmaxbounds) method.
		maxBounds: undefined,

		// @option renderer: Renderer = *
		// The default method for drawing vector layers on the map. `L.SVG`
		// or `L.Canvas` by default depending on browser support.
		renderer: undefined,


		// @section Animation Options
		// @option zoomAnimation: Boolean = true
		// Whether the map zoom animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		zoomAnimation: true,

		// @option zoomAnimationThreshold: Number = 4
		// Won't animate zoom if the zoom difference exceeds this value.
		zoomAnimationThreshold: 4,

		// @option fadeAnimation: Boolean = true
		// Whether the tile fade animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		fadeAnimation: true,

		// @option markerZoomAnimation: Boolean = true
		// Whether markers animate their zoom with the zoom animation, if disabled
		// they will disappear for the length of the animation. By default it's
		// enabled in all browsers that support CSS3 Transitions except Android.
		markerZoomAnimation: true,

		// @option transform3DLimit: Number = 2^23
		// Defines the maximum size of a CSS translation transform. The default
		// value should not be changed unless a web browser positions layers in
		// the wrong place after doing a large `panBy`.
		transform3DLimit: 8388608, // Precision limit of a 32-bit float

		// @section Interaction Options
		// @option zoomSnap: Number = 1
		// Forces the map's zoom level to always be a multiple of this, particularly
		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
		// By default, the zoom level snaps to the nearest integer; lower values
		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
		zoomSnap: 1,

		// @option zoomDelta: Number = 1
		// Controls how much the map's zoom level will change after a
		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
		zoomDelta: 1,

		// @option trackResize: Boolean = true
		// Whether the map automatically handles browser window resize to update itself.
		trackResize: true
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = setOptions(this, options);

		// Make sure to assign internal flags at the beginning,
		// to avoid inconsistent state in some edge cases.
		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(toLatLng(options.center), options.zoom, {reset: true});
		}

		this.callInitHooks();

		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = TRANSITION && any3d && !mobileOpera &&
				this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			this._createAnimProxy();
			on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
		}

		this._addLayers(this.options.layers);
	},


	// @section Methods for modifying map state

	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) with the given
	// animation options.
	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
		options = options || {};

		this._stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = extend({animate: options.animate}, options.zoom);
				options.pan = extend({animate: options.animate, duration: options.duration}, options.pan);
			}

			// try animating pan or zoom
			var moved = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (moved) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	// @method setZoom(zoom: Number, options?: Zoom/pan options): this
	// Sets the zoom of the map.
	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = zoom;
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	// @method zoomIn(delta?: Number, options?: Zoom options): this
	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomIn: function (delta, options) {
		delta = delta || (any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom + delta, options);
	},

	// @method zoomOut(delta?: Number, options?: Zoom options): this
	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomOut: function (delta, options) {
		delta = delta || (any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom - delta, options);
	},

	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified geographical point on the map
	// stationary (e.g. used internally for scroll zoom and double-click zoom).
	// @alternative
	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	_getBoundsCenterZoom: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);

		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

		if (zoom === Infinity) {
			return {
				center: bounds.getCenter(),
				zoom: zoom
			};
		}

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets a map view that contains the given geographical bounds with the
	// maximum zoom level possible.
	fitBounds: function (bounds, options) {

		bounds = toLatLngBounds(bounds);

		if (!bounds.isValid()) {
			throw new Error('Bounds are not valid.');
		}

		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	// @method fitWorld(options?: fitBounds options): this
	// Sets a map view that mostly contains the whole world with the maximum
	// zoom level possible.
	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	// @method panTo(latlng: LatLng, options?: Pan options): this
	// Pans the map to a given center.
	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	// @method panBy(offset: Point, options?: Pan options): this
	// Pans the map by a given number of pixels (animated).
	panBy: function (offset, options) {
		offset = toPoint(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this.fire('moveend');
		}
		// If we pan too far, Chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset).round();
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) performing a smooth
	// pan-zoom animation.
	flyTo: function (targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false || !any3d) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this._stop();

		var from = this.project(this.getCenter()),
		    to = this.project(targetCenter),
		    size = this.getSize(),
		    startZoom = this._zoom;

		targetCenter = toLatLng(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
		    u1 = (to.distanceTo(from)) || 1,
		    rho = 1.42,
		    rho2 = rho * rho;

		function r(i) {
			var s1 = i ? -1 : 1,
			    s2 = i ? w1 : w0,
			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
			    b1 = 2 * s2 * rho2 * u1,
			    b = t1 / b1,
			    sq = Math.sqrt(b * b + 1) - b;

			    // workaround for floating point precision bug when sq = 0, log = -Infinite,
			    // thus triggering an infinite loop in flyTo
			    var log = sq < 0.000000001 ? -18 : Math.log(sq);

			return log;
		}

		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
		function tanh(n) { return sinh(n) / cosh(n); }

		var r0 = r(0);

		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

		var start = Date.now(),
		    S = (r(1) - r0) / rho,
		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
			    s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = requestAnimFrame(frame, this);

				this._move(
					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
					this.getScaleZoom(w0 / w(s), startZoom),
					{flyTo: true});

			} else {
				this
					._move(targetCenter, targetZoom)
					._moveEnd(true);
			}
		}

		this._moveStart(true, options.noMoveStart);

		frame.call(this);
		return this;
	},

	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
	flyToBounds: function (bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	},

	// @method setMaxBounds(bounds: Bounds): this
	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
	setMaxBounds: function (bounds) {
		bounds = toLatLngBounds(bounds);

		if (!bounds.isValid()) {
			this.options.maxBounds = null;
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	// @method setMinZoom(zoom: Number): this
	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
	setMinZoom: function (zoom) {
		var oldZoom = this.options.minZoom;
		this.options.minZoom = zoom;

		if (this._loaded && oldZoom !== zoom) {
			this.fire('zoomlevelschange');

			if (this.getZoom() < this.options.minZoom) {
				return this.setZoom(zoom);
			}
		}

		return this;
	},

	// @method setMaxZoom(zoom: Number): this
	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
	setMaxZoom: function (zoom) {
		var oldZoom = this.options.maxZoom;
		this.options.maxZoom = zoom;

		if (this._loaded && oldZoom !== zoom) {
			this.fire('zoomlevelschange');

			if (this.getZoom() > this.options.maxZoom) {
				return this.setZoom(zoom);
			}
		}

		return this;
	},

	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
	panInsideBounds: function (bounds, options) {
		this._enforcingBounds = true;
		var center = this.getCenter(),
		    newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

		if (!center.equals(newCenter)) {
			this.panTo(newCenter, options);
		}

		this._enforcingBounds = false;
		return this;
	},

	// @method panInside(latlng: LatLng, options?: options): this
	// Pans the map the minimum amount to make the `latlng` visible. Use
	// `padding`, `paddingTopLeft` and `paddingTopRight` options to fit
	// the display to more restricted bounds, like [`fitBounds`](#map-fitbounds).
	// If `latlng` is already within the (optionally padded) display bounds,
	// the map will not be panned.
	panInside: function (latlng, options) {
		options = options || {};

		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
		    center = this.getCenter(),
		    pixelCenter = this.project(center),
		    pixelPoint = this.project(latlng),
		    pixelBounds = this.getPixelBounds(),
		    halfPixelBounds = pixelBounds.getSize().divideBy(2),
		    paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);

		if (!paddedBounds.contains(pixelPoint)) {
			this._enforcingBounds = true;
			var diff = pixelCenter.subtract(pixelPoint),
			    newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);

			if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {
				newCenter.x = pixelCenter.x - diff.x;
				if (diff.x > 0) {
					newCenter.x += halfPixelBounds.x - paddingTL.x;
				} else {
					newCenter.x -= halfPixelBounds.x - paddingBR.x;
				}
			}
			if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {
				newCenter.y = pixelCenter.y - diff.y;
				if (diff.y > 0) {
					newCenter.y += halfPixelBounds.y - paddingTL.y;
				} else {
					newCenter.y -= halfPixelBounds.y - paddingBR.y;
				}
			}
			this.panTo(this.unproject(newCenter), options);
			this._enforcingBounds = false;
		}
		return this;
	},

	// @method invalidateSize(options: Zoom/pan options): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default. If `options.pan` is `false`, panning will not occur.
	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
	// that it doesn't happen often even if the method is called many
	// times in a row.

	// @alternative
	// @method invalidateSize(animate: Boolean): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default.
	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._lastCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		// @section Map state change events
		// @event resize: ResizeEvent
		// Fired when the map is resized.
		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// @section Methods for modifying map state
	// @method stop(): this
	// Stops the currently running `panTo` or `flyTo` animation, if any.
	stop: function () {
		this.setZoom(this._limitZoom(this._zoom));
		if (!this.options.zoomSnap) {
			this.fire('viewreset');
		}
		return this._stop();
	},

	// @section Geolocation methods
	// @method locate(options?: Locate options): this
	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
	// and optionally sets the map view to the user's location with respect to
	// detection accuracy (or to the world view if geolocation failed).
	// Note that, if your page doesn't use HTTPS, this method will fail in
	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
	// See `Locate options` for more details.
	locate: function (options) {

		options = this._locateOptions = extend({
			timeout: 10000,
			watch: false
			// setView: false
			// maxZoom: <Number>
			// maximumAge: 0
			// enableHighAccuracy: false
		}, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = bind(this._handleGeolocationResponse, this),
		    onError = bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	// @method stopLocate(): this
	// Stops watching location previously initiated by `map.locate({watch: true})`
	// and aborts resetting the map view if map.locate was called with
	// `{setView: true}`.
	stopLocate: function () {
		if (navigator.geolocation && navigator.geolocation.clearWatch) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		// @section Location events
		// @event locationerror: ErrorEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new LatLng(lat, lng),
		    bounds = latlng.toBounds(pos.coords.accuracy * 2),
		    options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		// @event locationfound: LocationEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method)
		// went successfully.
		this.fire('locationfound', data);
	},

	// TODO Appropriate docs section?
	// @section Other Methods
	// @method addHandler(name: String, HandlerClass: Function): this
	// Adds a new `Handler` to the map, given its name and constructor function.
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	// @method remove(): this
	// Destroys the map and clears all related event listeners.
	remove: function () {

		this._initEvents(true);

		if (this._containerId !== this._container._leaflet_id) {
			throw new Error('Map container is being reused by another instance');
		}

		try {
			// throws error in IE6-8
			delete this._container._leaflet_id;
			delete this._containerId;
		} catch (e) {
			/*eslint-disable */
			this._container._leaflet_id = undefined;
			/* eslint-enable */
			this._containerId = undefined;
		}

		if (this._locationWatchId !== undefined) {
			this.stopLocate();
		}

		this._stop();

		remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}
		if (this._resizeRequest) {
			cancelAnimFrame(this._resizeRequest);
			this._resizeRequest = null;
		}

		this._clearHandlers();

		if (this._loaded) {
			// @section Map state change events
			// @event unload: Event
			// Fired when the map is destroyed with [remove](#map-remove) method.
			this.fire('unload');
		}

		var i;
		for (i in this._layers) {
			this._layers[i].remove();
		}
		for (i in this._panes) {
			remove(this._panes[i]);
		}

		this._layers = [];
		this._panes = [];
		delete this._mapPane;
		delete this._renderer;

		return this;
	},

	// @section Other Methods
	// @method createPane(name: String, container?: HTMLElement): HTMLElement
	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
	// then returns it. The pane is created as a child of `container`, or
	// as a child of the main map pane if not set.
	createPane: function (name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
		    pane = create$1('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},

	// @section Methods for Getting Map State

	// @method getCenter(): LatLng
	// Returns the geographical center of the map view
	getCenter: function () {
		this._checkIfLoaded();

		if (this._lastCenter && !this._moved()) {
			return this._lastCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	// @method getZoom(): Number
	// Returns the current zoom level of the map view
	getZoom: function () {
		return this._zoom;
	},

	// @method getBounds(): LatLngBounds
	// Returns the geographical bounds visible in the current map view
	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new LatLngBounds(sw, ne);
	},

	// @method getMinZoom(): Number
	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
	getMinZoom: function () {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	// @method getMaxZoom(): Number
	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
	// Returns the maximum zoom level on which the given bounds fit to the map
	// view in its entirety. If `inside` (optional) is set to `true`, the method
	// instead returns the minimum zoom level on which the map view fits into
	// the given bounds in its entirety.
	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = toLatLngBounds(bounds);
		padding = toPoint(padding || [0, 0]);

		var zoom = this.getZoom() || 0,
		    min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),
		    size = this.getSize().subtract(padding),
		    boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
		    snap = any3d ? this.options.zoomSnap : 1,
		    scalex = size.x / boundsSize.x,
		    scaley = size.y / boundsSize.y,
		    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

		zoom = this.getScaleZoom(scale, zoom);

		if (snap) {
			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
		}

		return Math.max(min, Math.min(max, zoom));
	},

	// @method getSize(): Point
	// Returns the current size of the map container (in pixels).
	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new Point(
				this._container.clientWidth || 0,
				this._container.clientHeight || 0);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	// @method getPixelBounds(): Bounds
	// Returns the bounds of the current map view in projected pixel
	// coordinates (sometimes useful in layer and overlay implementations).
	getPixelBounds: function (center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
	// the map pane? "left point of the map layer" can be confusing, specially
	// since there can be negative offsets.
	// @method getPixelOrigin(): Point
	// Returns the projected pixel coordinates of the top left point of
	// the map layer (useful in custom layer and overlay implementations).
	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	// @method getPixelWorldBounds(zoom?: Number): Bounds
	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
	// If `zoom` is omitted, the map's current zoom level is used.
	getPixelWorldBounds: function (zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	// @section Other Methods

	// @method getPane(pane: String|HTMLElement): HTMLElement
	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
	getPane: function (pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	// @method getPanes(): Object
	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
	// the panes as values.
	getPanes: function () {
		return this._panes;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the map.
	getContainer: function () {
		return this._container;
	},


	// @section Conversion Methods

	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
	// Returns the scale factor to be applied to a map transition from zoom level
	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
	getZoomScale: function (toZoom, fromZoom) {
		// TODO replace with universal implementation after refactoring projections
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
	// level and everything is scaled by a factor of `scale`. Inverse of
	// [`getZoomScale`](#map-getZoomScale).
	getScaleZoom: function (scale, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		var zoom = crs.zoom(scale * crs.scale(fromZoom));
		return isNaN(zoom) ? Infinity : zoom;
	},

	// @method project(latlng: LatLng, zoom: Number): Point
	// Projects a geographical coordinate `LatLng` according to the projection
	// of the map's CRS, then scales it according to `zoom` and the CRS's
	// `Transformation`. The result is pixel coordinate relative to
	// the CRS origin.
	project: function (latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
	},

	// @method unproject(point: Point, zoom: Number): LatLng
	// Inverse of [`project`](#map-project).
	unproject: function (point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(toPoint(point), zoom);
	},

	// @method layerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding geographical coordinate (for the current zoom level).
	layerPointToLatLng: function (point) {
		var projectedPoint = toPoint(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	// @method latLngToLayerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the [origin pixel](#map-getpixelorigin).
	latLngToLayerPoint: function (latlng) {
		var projectedPoint = this.project(toLatLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
	// CRS's bounds.
	// By default this means longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees.
	wrapLatLng: function (latlng) {
		return this.options.crs.wrapLatLng(toLatLng(latlng));
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring that
	// its center is within the CRS's bounds.
	// By default this means the center longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees, and the majority of the bounds
	// overlaps the CRS's bounds.
	wrapLatLngBounds: function (latlng) {
		return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates according to
	// the map's CRS. By default this measures distance in meters.
	distance: function (latlng1, latlng2) {
		return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
	},

	// @method containerPointToLayerPoint(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns the corresponding
	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
	containerPointToLayerPoint: function (point) { // (Point)
		return toPoint(point).subtract(this._getMapPanePos());
	},

	// @method layerPointToContainerPoint(point: Point): Point
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding pixel coordinate relative to the map container.
	layerPointToContainerPoint: function (point) { // (Point)
		return toPoint(point).add(this._getMapPanePos());
	},

	// @method containerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the map container, returns
	// the corresponding geographical coordinate (for the current zoom level).
	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(toPoint(point));
		return this.layerPointToLatLng(layerPoint);
	},

	// @method latLngToContainerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the map container.
	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
	},

	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to the
	// map container where the event took place.
	mouseEventToContainerPoint: function (e) {
		return getMousePosition(e, this._container);
	},

	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to
	// the [origin pixel](#map-getpixelorigin) where the event took place.
	mouseEventToLayerPoint: function (e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
	// Given a MouseEvent object, returns geographical coordinate where the
	// event took place.
	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet_id) {
			throw new Error('Map container is already initialized.');
		}

		on(container, 'scroll', this._onScroll, this);
		this._containerId = stamp(container);
	},

	_initLayout: function () {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && any3d;

		addClass(container, 'leaflet-container' +
			(touch ? ' leaflet-touch' : '') +
			(retina ? ' leaflet-retina' : '') +
			(ielt9 ? ' leaflet-oldie' : '') +
			(safari ? ' leaflet-safari' : '') +
			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};
		this._paneRenderers = {};

		// @section
		//
		// Panes are DOM elements used to control the ordering of layers on the map. You
		// can access panes with [`map.getPane`](#map-getpane) or
		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
		// [`map.createPane`](#map-createpane) method.
		//
		// Every map has the following default panes that differ only in zIndex.
		//
		// @pane mapPane: HTMLElement = 'auto'
		// Pane that contains all other map panes

		this._mapPane = this.createPane('mapPane', this._container);
		setPosition(this._mapPane, new Point(0, 0));

		// @pane tilePane: HTMLElement = 200
		// Pane for `GridLayer`s and `TileLayer`s
		this.createPane('tilePane');
		// @pane overlayPane: HTMLElement = 400
		// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
		this.createPane('shadowPane');
		// @pane shadowPane: HTMLElement = 500
		// Pane for overlay shadows (e.g. `Marker` shadows)
		this.createPane('overlayPane');
		// @pane markerPane: HTMLElement = 600
		// Pane for `Icon`s of `Marker`s
		this.createPane('markerPane');
		// @pane tooltipPane: HTMLElement = 650
		// Pane for `Tooltip`s.
		this.createPane('tooltipPane');
		// @pane popupPane: HTMLElement = 700
		// Pane for `Popup`s.
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			addClass(panes.markerPane, 'leaflet-zoom-hide');
			addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},


	// private methods that modify map state

	// @section Map state change events
	_resetView: function (center, zoom) {
		setPosition(this._mapPane, new Point(0, 0));

		var loading = !this._loaded;
		this._loaded = true;
		zoom = this._limitZoom(zoom);

		this.fire('viewprereset');

		var zoomChanged = this._zoom !== zoom;
		this
			._moveStart(zoomChanged, false)
			._move(center, zoom)
			._moveEnd(zoomChanged);

		// @event viewreset: Event
		// Fired when the map needs to redraw its content (this usually happens
		// on map zoom or load). Very useful for creating custom overlays.
		this.fire('viewreset');

		// @event load: Event
		// Fired when the map is initialized (when its center and zoom are set
		// for the first time).
		if (loading) {
			this.fire('load');
		}
	},

	_moveStart: function (zoomChanged, noMoveStart) {
		// @event zoomstart: Event
		// Fired when the map zoom is about to change (e.g. before zoom animation).
		// @event movestart: Event
		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
		if (zoomChanged) {
			this.fire('zoomstart');
		}
		if (!noMoveStart) {
			this.fire('movestart');
		}
		return this;
	},

	_move: function (center, zoom, data) {
		if (zoom === undefined) {
			zoom = this._zoom;
		}
		var zoomChanged = this._zoom !== zoom;

		this._zoom = zoom;
		this._lastCenter = center;
		this._pixelOrigin = this._getNewPixelOrigin(center);

		// @event zoom: Event
		// Fired repeatedly during any change in zoom level, including zoom
		// and fly animations.
		if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
			this.fire('zoom', data);
		}

		// @event move: Event
		// Fired repeatedly during any movement of the map, including pan and
		// fly animations.
		return this.fire('move', data);
	},

	_moveEnd: function (zoomChanged) {
		// @event zoomend: Event
		// Fired when the map has changed, after any animations.
		if (zoomChanged) {
			this.fire('zoomend');
		}

		// @event moveend: Event
		// Fired when the center of the map stops changing (e.g. user stopped
		// dragging the map).
		return this.fire('moveend');
	},

	_stop: function () {
		cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	_rawPanBy: function (offset) {
		setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function () {
		if (!this._enforcingBounds) {
			this.panInsideBounds(this.options.maxBounds);
		}
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	// @section Interaction events
	_initEvents: function (remove$$1) {
		this._targets = {};
		this._targets[stamp(this._container)] = this;

		var onOff = remove$$1 ? off : on;

		// @event click: MouseEvent
		// Fired when the user clicks (or taps) the map.
		// @event dblclick: MouseEvent
		// Fired when the user double-clicks (or double-taps) the map.
		// @event mousedown: MouseEvent
		// Fired when the user pushes the mouse button on the map.
		// @event mouseup: MouseEvent
		// Fired when the user releases the mouse button on the map.
		// @event mouseover: MouseEvent
		// Fired when the mouse enters the map.
		// @event mouseout: MouseEvent
		// Fired when the mouse leaves the map.
		// @event mousemove: MouseEvent
		// Fired while the mouse moves over the map.
		// @event contextmenu: MouseEvent
		// Fired when the user pushes the right mouse button on the map, prevents
		// default browser context menu from showing if there are listeners on
		// this event. Also fired on mobile when the user holds a single touch
		// for a second (also called long press).
		// @event keypress: KeyboardEvent
		// Fired when the user presses a key from the keyboard that produces a character value while the map is focused.
		// @event keydown: KeyboardEvent
		// Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,
		// the `keydown` event is fired for keys that produce a character value and for keys
		// that do not produce a character value.
		// @event keyup: KeyboardEvent
		// Fired when the user releases a key from the keyboard while the map is focused.
		onOff(this._container, 'click dblclick mousedown mouseup ' +
			'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			onOff(window, 'resize', this._onResize, this);
		}

		if (any3d && this.options.transform3DLimit) {
			(remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
		}
	},

	_onResize: function () {
		cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this);
	},

	_onScroll: function () {
		this._container.scrollTop  = 0;
		this._container.scrollLeft = 0;
	},

	_onMoveEnd: function () {
		var pos = this._getMapPanePos();
		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
			this._resetView(this.getCenter(), this.getZoom());
		}
	},

	_findEventTargets: function (e, type) {
		var targets = [],
		    target,
		    isHover = type === 'mouseout' || type === 'mouseover',
		    src = e.target || e.srcElement,
		    dragging = false;

		while (src) {
			target = this._targets[stamp(src)];
			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
				// Prevent firing click after you just dragged an object.
				dragging = true;
				break;
			}
			if (target && target.listens(type, true)) {
				if (isHover && !isExternalTarget(src, e)) { break; }
				targets.push(target);
				if (isHover) { break; }
			}
			if (src === this._container) { break; }
			src = src.parentNode;
		}
		if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
			targets = [this];
		}
		return targets;
	},

	_handleDOMEvent: function (e) {
		if (!this._loaded || skipped(e)) { return; }

		var type = e.type;

		if (type === 'mousedown' || type === 'keypress' || type === 'keyup' || type === 'keydown') {
			// prevents outline when clicking on keyboard-focusable element
			preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(e, type);
	},

	_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

	_fireDOMEvent: function (e, type, targets) {

		if (e.type === 'click') {
			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
			// @event preclick: MouseEvent
			// Fired before mouse click on the map (sometimes useful when you
			// want something to happen on click before any existing click
			// handlers start running).
			var synth = extend({}, e);
			synth.type = 'preclick';
			this._fireDOMEvent(synth, synth.type, targets);
		}

		if (e._stopped) { return; }

		// Find the layer the event is propagating from and its parents.
		targets = (targets || []).concat(this._findEventTargets(e, type));

		if (!targets.length) { return; }

		var target = targets[0];
		if (type === 'contextmenu' && target.listens(type, true)) {
			preventDefault(e);
		}

		var data = {
			originalEvent: e
		};

		if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {
			var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
			data.containerPoint = isMarker ?
				this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
		}

		for (var i = 0; i < targets.length; i++) {
			targets[i].fire(type, data, true);
			if (data.originalEvent._stopped ||
				(targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1)) { return; }
		}
	},

	_draggableMoved: function (obj) {
		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	// @section Other Methods

	// @method whenReady(fn: Function, context?: Object): this
	// Runs the given function `fn` when the map gets initialized with
	// a view (center and zoom) and at least one layer, or immediately
	// if it's already initialized, optionally passing a function context.
	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, {target: this});
		} else {
			this.on('load', callback, context);
		}
		return this;
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return getPosition(this._mapPane) || new Point(0, 0);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function (center, zoom) {
		var pixelOrigin = center && zoom !== undefined ?
			this._getNewPixelOrigin(center, zoom) :
			this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function (latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return toBounds([
			this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
		]);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		// If offset is less than a pixel, ignore.
		// This prevents unstable projections from getting into
		// an infinite loop of tiny offsets.
		if (offset.round().equals([0, 0])) {
			return center;
		}

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var projectedMaxBounds = toBounds(
		        this.project(maxBounds.getNorthEast(), zoom),
		        this.project(maxBounds.getSouthWest(), zoom)
		    ),
		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

		    dx = this._rebound(minOffset.x, -maxOffset.x),
		    dy = this._rebound(minOffset.y, -maxOffset.y);

		return new Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    snap = any3d ? this.options.zoomSnap : 1;
		if (snap) {
			zoom = Math.round(zoom / snap) * snap;
		}
		return Math.max(min, Math.min(max, zoom));
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._trunc();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	},

	_createAnimProxy: function () {

		var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = TRANSFORM,
			    transform = this._proxy.style[prop];

			setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === this._proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', this._animMoveEnd, this);

		this._on('unload', this._destroyAnimProxy, this);
	},

	_destroyAnimProxy: function () {
		remove(this._proxy);
		this.off('load moveend', this._animMoveEnd, this);
		delete this._proxy;
	},

	_animMoveEnd: function () {
		var c = this.getCenter(),
		    z = this.getZoom();
		setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
	},

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		requestAnimFrame(function () {
			this
			    ._moveStart(true, false)
			    ._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function (center, zoom, startAnim, noUpdate) {
		if (!this._mapPane) { return; }

		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		// @section Other Events
		// @event zoomanim: ZoomAnimEvent
		// Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.
		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			noUpdate: noUpdate
		});

		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
		setTimeout(bind(this._onZoomTransitionEnd, this), 250);
	},

	_onZoomTransitionEnd: function () {
		if (!this._animatingZoom) { return; }

		if (this._mapPane) {
			removeClass(this._mapPane, 'leaflet-zoom-anim');
		}

		this._animatingZoom = false;

		this._move(this._animateToCenter, this._animateToZoom);

		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
		requestAnimFrame(function () {
			this._moveEnd(true);
		}, this);
	}
});

// @section

// @factory L.map(id: String, options?: Map options)
// Instantiates a map object given the DOM ID of a `<div>` element
// and optionally an object literal with `Map options`.
//
// @alternative
// @factory L.map(el: HTMLElement, options?: Map options)
// Instantiates a map object given an instance of a `<div>` HTML element
// and optionally an object literal with `Map options`.
function createMap(id, options) {
	return new Map(id, options);
}

/*
 * @class Control
 * @aka L.Control
 * @inherits Class
 *
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

var Control = Class.extend({
	// @section
	// @aka Control options
	options: {
		// @option position: String = 'topright'
		// The position of the control (one of the map corners). Possible values are `'topleft'`,
		// `'topright'`, `'bottomleft'` or `'bottomright'`
		position: 'topright'
	},

	initialize: function (options) {
		setOptions(this, options);
	},

	/* @section
	 * Classes extending L.Control will inherit the following methods:
	 *
	 * @method getPosition: string
	 * Returns the position of the control.
	 */
	getPosition: function () {
		return this.options.position;
	},

	// @method setPosition(position: string): this
	// Sets the position of the control.
	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTMLElement that contains the control.
	getContainer: function () {
		return this._container;
	},

	// @method addTo(map: Map): this
	// Adds the control to the given map.
	addTo: function (map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		this._map.on('unload', this.remove, this);

		return this;
	},

	// @method remove: this
	// Removes the control from the map it is currently active on.
	remove: function () {
		if (!this._map) {
			return this;
		}

		remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map.off('unload', this.remove, this);
		this._map = null;

		return this;
	},

	_refocusOnMap: function (e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

var control = function (options) {
	return new Control(options);
};

/* @section Extension methods
 * @uninheritable
 *
 * Every control should extend from `L.Control` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): HTMLElement
 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
 *
 * @method onRemove(map: Map)
 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
 */

/* @namespace Map
 * @section Methods for Layers and Controls
 */
Map.include({
	// @method addControl(control: Control): this
	// Adds the given control to the map
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	// @method removeControl(control: Control): this
	// Removes the given control from the map
	removeControl: function (control) {
		control.remove();
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            create$1('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = create$1('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		for (var i in this._controlCorners) {
			remove(this._controlCorners[i]);
		}
		remove(this._controlContainer);
		delete this._controlCorners;
		delete this._controlContainer;
	}
});

/*
 * @class Control.Layers
 * @aka L.Control.Layers
 * @inherits Control
 *
 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
 *
 * @example
 *
 * ```js
 * var baseLayers = {
 * 	"Mapbox": mapbox,
 * 	"OpenStreetMap": osm
 * };
 *
 * var overlays = {
 * 	"Marker": marker,
 * 	"Roads": roadsLayer
 * };
 *
 * L.control.layers(baseLayers, overlays).addTo(map);
 * ```
 *
 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
 *
 * ```js
 * {
 *     "<someName1>": layer1,
 *     "<someName2>": layer2
 * }
 * ```
 *
 * The layer names can contain HTML, which allows you to add additional styling to the items:
 *
 * ```js
 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
 * ```
 */

var Layers = Control.extend({
	// @section
	// @aka Control.Layers options
	options: {
		// @option collapsed: Boolean = true
		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
		collapsed: true,
		position: 'topright',

		// @option autoZIndex: Boolean = true
		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
		autoZIndex: true,

		// @option hideSingleBase: Boolean = false
		// If `true`, the base layers in the control will be hidden when there is only one.
		hideSingleBase: false,

		// @option sortLayers: Boolean = false
		// Whether to sort the layers. When `false`, layers will keep the order
		// in which they were added to the control.
		sortLayers: false,

		// @option sortFunction: Function = *
		// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
		// that will be used for sorting the layers, when `sortLayers` is `true`.
		// The function receives both the `L.Layer` instances and their names, as in
		// `sortFunction(layerA, layerB, nameA, nameB)`.
		// By default, it sorts layers alphabetically by their name.
		sortFunction: function (layerA, layerB, nameA, nameB) {
			return nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);
		}
	},

	initialize: function (baseLayers, overlays, options) {
		setOptions(this, options);

		this._layerControlInputs = [];
		this._layers = [];
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		this._map = map;
		map.on('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.on('add remove', this._onLayerChange, this);
		}

		return this._container;
	},

	addTo: function (map) {
		Control.prototype.addTo.call(this, map);
		// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
		return this._expandIfNotCollapsed();
	},

	onRemove: function () {
		this._map.off('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.off('add remove', this._onLayerChange, this);
		}
	},

	// @method addBaseLayer(layer: Layer, name: String): this
	// Adds a base layer (radio button entry) with the given name to the control.
	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		return (this._map) ? this._update() : this;
	},

	// @method addOverlay(layer: Layer, name: String): this
	// Adds an overlay (checkbox entry) with the given name to the control.
	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		return (this._map) ? this._update() : this;
	},

	// @method removeLayer(layer: Layer): this
	// Remove the given layer from the control.
	removeLayer: function (layer) {
		layer.off('add remove', this._onLayerChange, this);

		var obj = this._getLayer(stamp(layer));
		if (obj) {
			this._layers.splice(this._layers.indexOf(obj), 1);
		}
		return (this._map) ? this._update() : this;
	},

	// @method expand(): this
	// Expand the control container if collapsed.
	expand: function () {
		addClass(this._container, 'leaflet-control-layers-expanded');
		this._section.style.height = null;
		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
		if (acceptableHeight < this._section.clientHeight) {
			addClass(this._section, 'leaflet-control-layers-scrollbar');
			this._section.style.height = acceptableHeight + 'px';
		} else {
			removeClass(this._section, 'leaflet-control-layers-scrollbar');
		}
		this._checkDisabledLayers();
		return this;
	},

	// @method collapse(): this
	// Collapse the control container if expanded.
	collapse: function () {
		removeClass(this._container, 'leaflet-control-layers-expanded');
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = create$1('div', className),
		    collapsed = this.options.collapsed;

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		disableClickPropagation(container);
		disableScrollPropagation(container);

		var section = this._section = create$1('section', className + '-list');

		if (collapsed) {
			this._map.on('click', this.collapse, this);

			if (!android) {
				on(container, {
					mouseenter: this.expand,
					mouseleave: this.collapse
				}, this);
			}
		}

		var link = this._layersLink = create$1('a', className + '-toggle', container);
		link.href = '#';
		link.title = 'Layers';

		if (touch) {
			on(link, 'click', stop);
			on(link, 'click', this.expand, this);
		} else {
			on(link, 'focus', this.expand, this);
		}

		if (!collapsed) {
			this.expand();
		}

		this._baseLayersList = create$1('div', className + '-base', section);
		this._separator = create$1('div', className + '-separator', section);
		this._overlaysList = create$1('div', className + '-overlays', section);

		container.appendChild(section);
	},

	_getLayer: function (id) {
		for (var i = 0; i < this._layers.length; i++) {

			if (this._layers[i] && stamp(this._layers[i].layer) === id) {
				return this._layers[i];
			}
		}
	},

	_addLayer: function (layer, name, overlay) {
		if (this._map) {
			layer.on('add remove', this._onLayerChange, this);
		}

		this._layers.push({
			layer: layer,
			name: name,
			overlay: overlay
		});

		if (this.options.sortLayers) {
			this._layers.sort(bind(function (a, b) {
				return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
			}, this));
		}

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}

		this._expandIfNotCollapsed();
	},

	_update: function () {
		if (!this._container) { return this; }

		empty(this._baseLayersList);
		empty(this._overlaysList);

		this._layerControlInputs = [];
		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

		for (i = 0; i < this._layers.length; i++) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function (e) {
		if (!this._handlingClick) {
			this._update();
		}

		var obj = this._getLayer(stamp(e.target));

		// @namespace Map
		// @section Layer events
		// @event baselayerchange: LayersControlEvent
		// Fired when the base layer is changed through the [layer control](#control-layers).
		// @event overlayadd: LayersControlEvent
		// Fired when an overlay is selected through the [layer control](#control-layers).
		// @event overlayremove: LayersControlEvent
		// Fired when an overlay is deselected through the [layer control](#control-layers).
		// @namespace Control.Layers
		var type = obj.overlay ?
			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'add' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    checked = this._map.hasLayer(obj.layer),
		    input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);
		}

		this._layerControlInputs.push(input);
		input.layerId = stamp(obj.layer);

		on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		// Helps from preventing layer control flicker when checkboxes are disabled
		// https://github.com/Leaflet/Leaflet/issues/2771
		var holder = document.createElement('div');

		label.appendChild(holder);
		holder.appendChild(input);
		holder.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		this._checkDisabledLayers();
		return label;
	},

	_onInputClick: function () {
		var inputs = this._layerControlInputs,
		    input, layer;
		var addedLayers = [],
		    removedLayers = [];

		this._handlingClick = true;

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;

			if (input.checked) {
				addedLayers.push(layer);
			} else if (!input.checked) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			if (this._map.hasLayer(removedLayers[i])) {
				this._map.removeLayer(removedLayers[i]);
			}
		}
		for (i = 0; i < addedLayers.length; i++) {
			if (!this._map.hasLayer(addedLayers[i])) {
				this._map.addLayer(addedLayers[i]);
			}
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_checkDisabledLayers: function () {
		var inputs = this._layerControlInputs,
		    input,
		    layer,
		    zoom = this._map.getZoom();

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
			                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

		}
	},

	_expandIfNotCollapsed: function () {
		if (this._map && !this.options.collapsed) {
			this.expand();
		}
		return this;
	},

	_expand: function () {
		// Backward compatibility, remove me in 1.1.
		return this.expand();
	},

	_collapse: function () {
		// Backward compatibility, remove me in 1.1.
		return this.collapse();
	}

});


// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
var layers = function (baseLayers, overlays, options) {
	return new Layers(baseLayers, overlays, options);
};

/*
 * @class Control.Zoom
 * @aka L.Control.Zoom
 * @inherits Control
 *
 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
 */

var Zoom = Control.extend({
	// @section
	// @aka Control.Zoom options
	options: {
		position: 'topleft',

		// @option zoomInText: String = '+'
		// The text set on the 'zoom in' button.
		zoomInText: '+',

		// @option zoomInTitle: String = 'Zoom in'
		// The title set on the 'zoom in' button.
		zoomInTitle: 'Zoom in',

		// @option zoomOutText: String = '&#x2212;'
		// The text set on the 'zoom out' button.
		zoomOutText: '&#x2212;',

		// @option zoomOutTitle: String = 'Zoom out'
		// The title set on the 'zoom out' button.
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = create$1('div', zoomName + ' leaflet-bar'),
		    options = this.options;

		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function () {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function () {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function (e) {
		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_zoomOut: function (e) {
		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_createButton: function (html, title, className, container, fn) {
		var link = create$1('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		/*
		 * Will force screen readers like VoiceOver to read this as "Zoom in - button"
		 */
		link.setAttribute('role', 'button');
		link.setAttribute('aria-label', title);

		disableClickPropagation(link);
		on(link, 'click', stop);
		on(link, 'click', fn, this);
		on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
		    className = 'leaflet-disabled';

		removeClass(this._zoomInButton, className);
		removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			addClass(this._zoomInButton, className);
		}
	}
});

// @namespace Map
// @section Control options
// @option zoomControl: Boolean = true
// Whether a [zoom control](#control-zoom) is added to the map by default.
Map.mergeOptions({
	zoomControl: true
});

Map.addInitHook(function () {
	if (this.options.zoomControl) {
		// @section Controls
		// @property zoomControl: Control.Zoom
		// The default zoom control (only available if the
		// [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
		this.zoomControl = new Zoom();
		this.addControl(this.zoomControl);
	}
});

// @namespace Control.Zoom
// @factory L.control.zoom(options: Control.Zoom options)
// Creates a zoom control
var zoom = function (options) {
	return new Zoom(options);
};

/*
 * @class Control.Scale
 * @aka L.Control.Scale
 * @inherits Control
 *
 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
 *
 * @example
 *
 * ```js
 * L.control.scale().addTo(map);
 * ```
 */

var Scale = Control.extend({
	// @section
	// @aka Control.Scale options
	options: {
		position: 'bottomleft',

		// @option maxWidth: Number = 100
		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
		maxWidth: 100,

		// @option metric: Boolean = True
		// Whether to show the metric scale line (m/km).
		metric: true,

		// @option imperial: Boolean = True
		// Whether to show the imperial scale line (mi/ft).
		imperial: true

		// @option updateWhenIdle: Boolean = false
		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
	},

	onAdd: function (map) {
		var className = 'leaflet-control-scale',
		    container = create$1('div', className),
		    options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = create$1('div', className, container);
		}
		if (options.imperial) {
			this._iScale = create$1('div', className, container);
		}
	},

	_update: function () {
		var map = this._map,
		    y = map.getSize().y / 2;

		var maxMeters = map.distance(
			map.containerPointToLatLng([0, y]),
			map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function (maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters),
		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function (scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 :
		    d >= 5 ? 5 :
		    d >= 3 ? 3 :
		    d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});


// @factory L.control.scale(options?: Control.Scale options)
// Creates an scale control with the given options.
var scale = function (options) {
	return new Scale(options);
};

/*
 * @class Control.Attribution
 * @aka L.Control.Attribution
 * @inherits Control
 *
 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
 */

var Attribution = Control.extend({
	// @section
	// @aka Control.Attribution options
	options: {
		position: 'bottomright',

		// @option prefix: String = 'Leaflet'
		// The HTML text shown before the attributions. Pass `false` to disable.
		prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		map.attributionControl = this;
		this._container = create$1('div', 'leaflet-control-attribution');
		disableClickPropagation(this._container);

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	// @method setPrefix(prefix: String): this
	// Sets the text before the attributions.
	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	// @method addAttribution(text: String): this
	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
	addAttribution: function (text) {
		if (!text) { return this; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	// @method removeAttribution(text: String): this
	// Removes an attribution text.
	removeAttribution: function (text) {
		if (!text) { return this; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

// @namespace Map
// @section Control options
// @option attributionControl: Boolean = true
// Whether a [attribution control](#control-attribution) is added to the map by default.
Map.mergeOptions({
	attributionControl: true
});

Map.addInitHook(function () {
	if (this.options.attributionControl) {
		new Attribution().addTo(this);
	}
});

// @namespace Control.Attribution
// @factory L.control.attribution(options: Control.Attribution options)
// Creates an attribution control.
var attribution = function (options) {
	return new Attribution(options);
};

Control.Layers = Layers;
Control.Zoom = Zoom;
Control.Scale = Scale;
Control.Attribution = Attribution;

control.layers = layers;
control.zoom = zoom;
control.scale = scale;
control.attribution = attribution;

/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

// @class Handler
// @aka L.Handler
// Abstract class for map interaction handlers

var Handler = Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	// @method enable(): this
	// Enables the handler
	enable: function () {
		if (this._enabled) { return this; }

		this._enabled = true;
		this.addHooks();
		return this;
	},

	// @method disable(): this
	// Disables the handler
	disable: function () {
		if (!this._enabled) { return this; }

		this._enabled = false;
		this.removeHooks();
		return this;
	},

	// @method enabled(): Boolean
	// Returns `true` if the handler is enabled
	enabled: function () {
		return !!this._enabled;
	}

	// @section Extension methods
	// Classes inheriting from `Handler` must implement the two following methods:
	// @method addHooks()
	// Called when the handler is enabled, should add event hooks.
	// @method removeHooks()
	// Called when the handler is disabled, should remove the event hooks added previously.
});

// @section There is static function which can be called without instantiating L.Handler:
// @function addTo(map: Map, name: String): this
// Adds a new Handler to the given map with the given name.
Handler.addTo = function (map, name) {
	map.addHandler(name, this);
	return this;
};

var Mixin = {Events: Events};

/*
 * @class Draggable
 * @aka L.Draggable
 * @inherits Evented
 *
 * A class for making DOM elements draggable (including touch support).
 * Used internally for map and marker dragging. Only works for elements
 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
 *
 * @example
 * ```js
 * var draggable = new L.Draggable(elementToDrag);
 * draggable.enable();
 * ```
 */

var START = touch ? 'touchstart mousedown' : 'mousedown';
var END = {
	mousedown: 'mouseup',
	touchstart: 'touchend',
	pointerdown: 'touchend',
	MSPointerDown: 'touchend'
};
var MOVE = {
	mousedown: 'mousemove',
	touchstart: 'touchmove',
	pointerdown: 'touchmove',
	MSPointerDown: 'touchmove'
};


var Draggable = Evented.extend({

	options: {
		// @section
		// @aka Draggable options
		// @option clickTolerance: Number = 3
		// The max number of pixels a user can shift the mouse pointer during a click
		// for it to be considered a valid click (as opposed to a mouse drag).
		clickTolerance: 3
	},

	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
	initialize: function (element, dragStartTarget, preventOutline$$1, options) {
		setOptions(this, options);

		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline$$1;
	},

	// @method enable()
	// Enables the dragging ability
	enable: function () {
		if (this._enabled) { return; }

		on(this._dragStartTarget, START, this._onDown, this);

		this._enabled = true;
	},

	// @method disable()
	// Disables the dragging ability
	disable: function () {
		if (!this._enabled) { return; }

		// If we're currently dragging this draggable,
		// disabling it counts as first ending the drag.
		if (Draggable._dragging === this) {
			this.finishDrag();
		}

		off(this._dragStartTarget, START, this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		this._moved = false;

		if (hasClass(this._element, 'leaflet-zoom-anim')) { return; }

		if (Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }
		Draggable._dragging = this;  // Prevent dragging multiple objects at once.

		if (this._preventOutline) {
			preventOutline(this._element);
		}

		disableImageDrag();
		disableTextSelection();

		if (this._moving) { return; }

		// @event down: Event
		// Fired when a drag is about to start.
		this.fire('down');

		var first = e.touches ? e.touches[0] : e,
		    sizedParent = getSizedParentNode(this._element);

		this._startPoint = new Point(first.clientX, first.clientY);

		// Cache the scale, so that we can continuously compensate for it during drag (_onMove).
		this._parentScale = getScale(sizedParent);

		on(document, MOVE[e.type], this._onMove, this);
		on(document, END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

		// We assume that the parent container's position, border and scale do not change for the duration of the drag.
		// Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
		// and we can use the cached value for the scale.
		offset.x /= this._parentScale.x;
		offset.y /= this._parentScale.y;

		preventDefault(e);

		if (!this._moved) {
			// @event dragstart: Event
			// Fired when a drag starts
			this.fire('dragstart');

			this._moved = true;
			this._startPos = getPosition(this._element).subtract(offset);

			addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			// IE and Edge do not give the <use> element, so fetch it
			// if necessary
			if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
				this._lastTarget = this._lastTarget.correspondingUseElement;
			}
			addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = requestAnimFrame(this._updatePosition, this, true);
	},

	_updatePosition: function () {
		var e = {originalEvent: this._lastEvent};

		// @event predrag: Event
		// Fired continuously during dragging *before* each corresponding
		// update of the element's position.
		this.fire('predrag', e);
		setPosition(this._element, this._newPos);

		// @event drag: Event
		// Fired continuously during dragging.
		this.fire('drag', e);
	},

	_onUp: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }
		this.finishDrag();
	},

	finishDrag: function () {
		removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in MOVE) {
			off(document, MOVE[i], this._onMove, this);
			off(document, END[i], this._onUp, this);
		}

		enableImageDrag();
		enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			cancelAnimFrame(this._animRequest);

			// @event dragend: DragEndEvent
			// Fired when the drag ends.
			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
		Draggable._dragging = false;
	}

});

/*
 * @namespace LineUtil
 *
 * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
 */

// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
// Improves rendering performance dramatically by lessening the number of points to draw.

// @function simplify(points: Point[], tolerance: Number): Point[]
// Dramatically reduces the number of points in a polyline while retaining
// its shape and returns a new array of simplified points, using the
// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
// Used for a huge performance boost when processing/displaying Leaflet polylines for
// each zoom level and also reducing visual noise. tolerance affects the amount of
// simplification (lesser value means higher quality but slower and with more points).
// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
function simplify(points, tolerance) {
	if (!tolerance || !points.length) {
		return points.slice();
	}

	var sqTolerance = tolerance * tolerance;

	    // stage 1: vertex reduction
	    points = _reducePoints(points, sqTolerance);

	    // stage 2: Douglas-Peucker simplification
	    points = _simplifyDP(points, sqTolerance);

	return points;
}

// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
// Returns the distance between point `p` and segment `p1` to `p2`.
function pointToSegmentDistance(p, p1, p2) {
	return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
}

// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
// Returns the closest point from a point `p` on a segment `p1` to `p2`.
function closestPointOnSegment(p, p1, p2) {
	return _sqClosestPointOnSegment(p, p1, p2);
}

// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
function _simplifyDP(points, sqTolerance) {

	var len = points.length,
	    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
	    markers = new ArrayConstructor(len);

	    markers[0] = markers[len - 1] = 1;

	_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

	var i,
	    newPoints = [];

	for (i = 0; i < len; i++) {
		if (markers[i]) {
			newPoints.push(points[i]);
		}
	}

	return newPoints;
}

function _simplifyDPStep(points, markers, sqTolerance, first, last) {

	var maxSqDist = 0,
	index, i, sqDist;

	for (i = first + 1; i <= last - 1; i++) {
		sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

		if (sqDist > maxSqDist) {
			index = i;
			maxSqDist = sqDist;
		}
	}

	if (maxSqDist > sqTolerance) {
		markers[index] = 1;

		_simplifyDPStep(points, markers, sqTolerance, first, index);
		_simplifyDPStep(points, markers, sqTolerance, index, last);
	}
}

// reduce points that are too close to each other to a single point
function _reducePoints(points, sqTolerance) {
	var reducedPoints = [points[0]];

	for (var i = 1, prev = 0, len = points.length; i < len; i++) {
		if (_sqDist(points[i], points[prev]) > sqTolerance) {
			reducedPoints.push(points[i]);
			prev = i;
		}
	}
	if (prev < len - 1) {
		reducedPoints.push(points[len - 1]);
	}
	return reducedPoints;
}

var _lastCode;

// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
// Clips the segment a to b by rectangular bounds with the
// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
// (modifying the segment points directly!). Used by Leaflet to only show polyline
// points that are on the screen or near, increasing performance.
function clipSegment(a, b, bounds, useLastCode, round) {
	var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
	    codeB = _getBitCode(b, bounds),

	    codeOut, p, newCode;

	    // save 2nd code to avoid calculating it on the next segment
	    _lastCode = codeB;

	while (true) {
		// if a,b is inside the clip window (trivial accept)
		if (!(codeA | codeB)) {
			return [a, b];
		}

		// if a,b is outside the clip window (trivial reject)
		if (codeA & codeB) {
			return false;
		}

		// other cases
		codeOut = codeA || codeB;
		p = _getEdgeIntersection(a, b, codeOut, bounds, round);
		newCode = _getBitCode(p, bounds);

		if (codeOut === codeA) {
			a = p;
			codeA = newCode;
		} else {
			b = p;
			codeB = newCode;
		}
	}
}

function _getEdgeIntersection(a, b, code, bounds, round) {
	var dx = b.x - a.x,
	    dy = b.y - a.y,
	    min = bounds.min,
	    max = bounds.max,
	    x, y;

	if (code & 8) { // top
		x = a.x + dx * (max.y - a.y) / dy;
		y = max.y;

	} else if (code & 4) { // bottom
		x = a.x + dx * (min.y - a.y) / dy;
		y = min.y;

	} else if (code & 2) { // right
		x = max.x;
		y = a.y + dy * (max.x - a.x) / dx;

	} else if (code & 1) { // left
		x = min.x;
		y = a.y + dy * (min.x - a.x) / dx;
	}

	return new Point(x, y, round);
}

function _getBitCode(p, bounds) {
	var code = 0;

	if (p.x < bounds.min.x) { // left
		code |= 1;
	} else if (p.x > bounds.max.x) { // right
		code |= 2;
	}

	if (p.y < bounds.min.y) { // bottom
		code |= 4;
	} else if (p.y > bounds.max.y) { // top
		code |= 8;
	}

	return code;
}

// square distance (to avoid unnecessary Math.sqrt calls)
function _sqDist(p1, p2) {
	var dx = p2.x - p1.x,
	    dy = p2.y - p1.y;
	return dx * dx + dy * dy;
}

// return closest point on segment or distance to that point
function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
	var x = p1.x,
	    y = p1.y,
	    dx = p2.x - x,
	    dy = p2.y - y,
	    dot = dx * dx + dy * dy,
	    t;

	if (dot > 0) {
		t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

		if (t > 1) {
			x = p2.x;
			y = p2.y;
		} else if (t > 0) {
			x += dx * t;
			y += dy * t;
		}
	}

	dx = p.x - x;
	dy = p.y - y;

	return sqDist ? dx * dx + dy * dy : new Point(x, y);
}


// @function isFlat(latlngs: LatLng[]): Boolean
// Returns true if `latlngs` is a flat array, false is nested.
function isFlat(latlngs) {
	return !isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
}

function _flat(latlngs) {
	console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
	return isFlat(latlngs);
}


var LineUtil = (Object.freeze || Object)({
	simplify: simplify,
	pointToSegmentDistance: pointToSegmentDistance,
	closestPointOnSegment: closestPointOnSegment,
	clipSegment: clipSegment,
	_getEdgeIntersection: _getEdgeIntersection,
	_getBitCode: _getBitCode,
	_sqClosestPointOnSegment: _sqClosestPointOnSegment,
	isFlat: isFlat,
	_flat: _flat
});

/*
 * @namespace PolyUtil
 * Various utility functions for polygon geometries.
 */

/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
 * performance. Note that polygon points needs different algorithm for clipping
 * than polyline, so there's a separate method for it.
 */
function clipPolygon(points, bounds, round) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = _getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = _getEdgeIntersection(b, a, edge, bounds, round);
					p._code = _getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = _getEdgeIntersection(b, a, edge, bounds, round);
				p._code = _getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
}


var PolyUtil = (Object.freeze || Object)({
	clipPolygon: clipPolygon
});

/*
 * @namespace Projection
 * @section
 * Leaflet comes with a set of already defined Projections out of the box:
 *
 * @projection L.Projection.LonLat
 *
 * Equirectangular, or Plate Carree projection — the most simple projection,
 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
 * `EPSG:4326` and `Simple` CRS.
 */

var LonLat = {
	project: function (latlng) {
		return new Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new LatLng(point.y, point.x);
	},

	bounds: new Bounds([-180, -90], [180, 90])
};

/*
 * @namespace Projection
 * @projection L.Projection.Mercator
 *
 * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.
 */

var Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function (latlng) {
		var d = Math.PI / 180,
		    r = this.R,
		    y = latlng.lat * d,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new Point(latlng.lng * d * r, y);
	},

	unproject: function (point) {
		var d = 180 / Math.PI,
		    r = this.R,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    ts = Math.exp(-point.y / r),
		    phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new LatLng(phi * d, point.x * d / r);
	}
};

/*
 * @class Projection

 * An object with methods for projecting geographical coordinates of the world onto
 * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).

 * @property bounds: Bounds
 * The bounds (specified in CRS units) where the projection is valid

 * @method project(latlng: LatLng): Point
 * Projects geographical coordinates into a 2D point.
 * Only accepts actual `L.LatLng` instances, not arrays.

 * @method unproject(point: Point): LatLng
 * The inverse of `project`. Projects a 2D point into a geographical location.
 * Only accepts actual `L.Point` instances, not arrays.

 * Note that the projection instances do not inherit from Leafet's `Class` object,
 * and can't be instantiated. Also, new classes can't inherit from them,
 * and methods can't be added to them with the `include` function.

 */




var index = (Object.freeze || Object)({
	LonLat: LonLat,
	Mercator: Mercator,
	SphericalMercator: SphericalMercator
});

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3395
 *
 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
 */
var EPSG3395 = extend({}, Earth, {
	code: 'EPSG:3395',
	projection: Mercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * Mercator.R);
		return toTransformation(scale, 0.5, -scale, 0.5);
	}())
});

/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 *
 * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
 * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
 * with this CRS, ensure that there are two 256x256 pixel tiles covering the
 * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
 * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
 */

var EPSG4326 = extend({}, Earth, {
	code: 'EPSG:4326',
	projection: LonLat,
	transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
});

/*
 * @namespace CRS
 * @crs L.CRS.Simple
 *
 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
 * axis should still be inverted (going from bottom to top). `distance()` returns
 * simple euclidean distance.
 */

var Simple = extend({}, CRS, {
	projection: LonLat,
	transformation: toTransformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	},

	zoom: function (scale) {
		return Math.log(scale) / Math.LN2;
	},

	distance: function (latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
		    dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});

CRS.Earth = Earth;
CRS.EPSG3395 = EPSG3395;
CRS.EPSG3857 = EPSG3857;
CRS.EPSG900913 = EPSG900913;
CRS.EPSG4326 = EPSG4326;
CRS.Simple = Simple;

/*
 * @class Layer
 * @inherits Evented
 * @aka L.Layer
 * @aka ILayer
 *
 * A set of methods from the Layer base class that all Leaflet layers use.
 * Inherits all methods, options and events from `L.Evented`.
 *
 * @example
 *
 * ```js
 * var layer = L.marker(latlng).addTo(map);
 * layer.addTo(map);
 * layer.remove();
 * ```
 *
 * @event add: Event
 * Fired after the layer is added to a map
 *
 * @event remove: Event
 * Fired after the layer is removed from a map
 */


var Layer = Evented.extend({

	// Classes extending `L.Layer` will inherit the following options:
	options: {
		// @option pane: String = 'overlayPane'
		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
		pane: 'overlayPane',

		// @option attribution: String = null
		// String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
		attribution: null,

		bubblingMouseEvents: true
	},

	/* @section
	 * Classes extending `L.Layer` will inherit the following methods:
	 *
	 * @method addTo(map: Map|LayerGroup): this
	 * Adds the layer to the given map or layer group.
	 */
	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	// @method remove: this
	// Removes the layer from the map it is currently active on.
	remove: function () {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	// @method removeFrom(map: Map): this
	// Removes the layer from the given map
	removeFrom: function (obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	// @method getPane(name? : String): HTMLElement
	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
	getPane: function (name) {
		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
	},

	addInteractiveTarget: function (targetEl) {
		this._map._targets[stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function (targetEl) {
		delete this._map._targets[stamp(targetEl)];
		return this;
	},

	// @method getAttribution: String
	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
	getAttribution: function () {
		return this.options.attribution;
	},

	_layerAdd: function (e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) { return; }

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		if (this.getEvents) {
			var events = this.getEvents();
			map.on(events, this);
			this.once('remove', function () {
				map.off(events, this);
			}, this);
		}

		this.onAdd(map);

		if (this.getAttribution && map.attributionControl) {
			map.attributionControl.addAttribution(this.getAttribution());
		}

		this.fire('add');
		map.fire('layeradd', {layer: this});
	}
});

/* @section Extension methods
 * @uninheritable
 *
 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): this
 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
 *
 * @method onRemove(map: Map): this
 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
 *
 * @method getEvents(): Object
 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
 *
 * @method getAttribution(): String
 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
 *
 * @method beforeAdd(map: Map): this
 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
 */


/* @namespace Map
 * @section Layer events
 *
 * @event layeradd: LayerEvent
 * Fired when a new layer is added to the map.
 *
 * @event layerremove: LayerEvent
 * Fired when some layer is removed from the map
 *
 * @section Methods for Layers and Controls
 */
Map.include({
	// @method addLayer(layer: Layer): this
	// Adds the given layer to the map
	addLayer: function (layer) {
		if (!layer._layerAdd) {
			throw new Error('The provided object is not a Layer.');
		}

		var id = stamp(layer);
		if (this._layers[id]) { return this; }
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the map.
	removeLayer: function (layer) {
		var id = stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the map
	hasLayer: function (layer) {
		return !!layer && (stamp(layer) in this._layers);
	},

	/* @method eachLayer(fn: Function, context?: Object): this
	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
	 * ```
	 * map.eachLayer(function(layer){
	 *     layer.bindPopup('Hello');
	 * });
	 * ```
	 */
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function (layers) {
		layers = layers ? (isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function (layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function (layer) {
		var id = stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function () {
		var minZoom = Infinity,
		    maxZoom = -Infinity,
		    oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		// @section Map state change events
		// @event zoomlevelschange: Event
		// Fired when the number of zoomlevels on the map is changed due
		// to adding or removing a layer.
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}

		if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
			this.setZoom(this._layersMaxZoom);
		}
		if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
			this.setZoom(this._layersMinZoom);
		}
	}
});

/*
 * @class LayerGroup
 * @aka L.LayerGroup
 * @inherits Layer
 *
 * Used to group several layers and handle them as one. If you add it to the map,
 * any layers added or removed from the group will be added/removed on the map as
 * well. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.layerGroup([marker1, marker2])
 * 	.addLayer(polyline)
 * 	.addTo(map);
 * ```
 */

var LayerGroup = Layer.extend({

	initialize: function (layers, options) {
		setOptions(this, options);

		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	// @method addLayer(layer: Layer): this
	// Adds the given layer to the group.
	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the group.
	// @alternative
	// @method removeLayer(id: Number): this
	// Removes the layer with the given internal ID from the group.
	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the group.
	// @alternative
	// @method hasLayer(id: Number): Boolean
	// Returns `true` if the given internal ID is currently added to the group.
	hasLayer: function (layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	// @method clearLayers(): this
	// Removes all the layers from the group.
	clearLayers: function () {
		return this.eachLayer(this.removeLayer, this);
	},

	// @method invoke(methodName: String, …): this
	// Calls `methodName` on every layer contained in this group, passing any
	// additional parameters. Has no effect if the layers contained do not
	// implement `methodName`.
	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		this.eachLayer(map.addLayer, map);
	},

	onRemove: function (map) {
		this.eachLayer(map.removeLayer, map);
	},

	// @method eachLayer(fn: Function, context?: Object): this
	// Iterates over the layers of the group, optionally specifying context of the iterator function.
	// ```js
	// group.eachLayer(function (layer) {
	// 	layer.bindPopup('Hello');
	// });
	// ```
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	// @method getLayer(id: Number): Layer
	// Returns the layer with the given internal ID.
	getLayer: function (id) {
		return this._layers[id];
	},

	// @method getLayers(): Layer[]
	// Returns an array of all the layers added to the group.
	getLayers: function () {
		var layers = [];
		this.eachLayer(layers.push, layers);
		return layers;
	},

	// @method setZIndex(zIndex: Number): this
	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	// @method getLayerId(layer: Layer): Number
	// Returns the internal ID for a layer
	getLayerId: function (layer) {
		return stamp(layer);
	}
});


// @factory L.layerGroup(layers?: Layer[], options?: Object)
// Create a layer group, optionally given an initial set of layers and an `options` object.
var layerGroup = function (layers, options) {
	return new LayerGroup(layers, options);
};

/*
 * @class FeatureGroup
 * @aka L.FeatureGroup
 * @inherits LayerGroup
 *
 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
 * handler, it will handle events from any of the layers. This includes mouse events
 * and custom events.
 *  * Has `layeradd` and `layerremove` events
 *
 * @example
 *
 * ```js
 * L.featureGroup([marker1, marker2, polyline])
 * 	.bindPopup('Hello world!')
 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
 * 	.addTo(map);
 * ```
 */

var FeatureGroup = LayerGroup.extend({

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		LayerGroup.prototype.addLayer.call(this, layer);

		// @event layeradd: LayerEvent
		// Fired when a layer is added to this `FeatureGroup`
		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		LayerGroup.prototype.removeLayer.call(this, layer);

		// @event layerremove: LayerEvent
		// Fired when a layer is removed from this `FeatureGroup`
		return this.fire('layerremove', {layer: layer});
	},

	// @method setStyle(style: Path options): this
	// Sets the given path options to each layer of the group that has a `setStyle` method.
	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	// @method bringToFront(): this
	// Brings the layer group to the top of all other layers
	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	// @method bringToBack(): this
	// Brings the layer group to the back of all other layers
	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	// @method getBounds(): LatLngBounds
	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
	getBounds: function () {
		var bounds = new LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

// @factory L.featureGroup(layers: Layer[])
// Create a feature group, optionally given an initial set of layers.
var featureGroup = function (layers) {
	return new FeatureGroup(layers);
};

/*
 * @class Icon
 * @aka L.Icon
 *
 * Represents an icon to provide when creating a marker.
 *
 * @example
 *
 * ```js
 * var myIcon = L.icon({
 *     iconUrl: 'my-icon.png',
 *     iconRetinaUrl: 'my-icon@2x.png',
 *     iconSize: [38, 95],
 *     iconAnchor: [22, 94],
 *     popupAnchor: [-3, -76],
 *     shadowUrl: 'my-icon-shadow.png',
 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
 *     shadowSize: [68, 95],
 *     shadowAnchor: [22, 94]
 * });
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
 *
 */

var Icon = Class.extend({

	/* @section
	 * @aka Icon options
	 *
	 * @option iconUrl: String = null
	 * **(required)** The URL to the icon image (absolute or relative to your script path).
	 *
	 * @option iconRetinaUrl: String = null
	 * The URL to a retina sized version of the icon image (absolute or relative to your
	 * script path). Used for Retina screen devices.
	 *
	 * @option iconSize: Point = null
	 * Size of the icon image in pixels.
	 *
	 * @option iconAnchor: Point = null
	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
	 * will be aligned so that this point is at the marker's geographical location. Centered
	 * by default if size is specified, also can be set in CSS with negative margins.
	 *
	 * @option popupAnchor: Point = [0, 0]
	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
	 *
	 * @option tooltipAnchor: Point = [0, 0]
	 * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
	 *
	 * @option shadowUrl: String = null
	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
	 *
	 * @option shadowRetinaUrl: String = null
	 *
	 * @option shadowSize: Point = null
	 * Size of the shadow image in pixels.
	 *
	 * @option shadowAnchor: Point = null
	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
	 * as iconAnchor if not specified).
	 *
	 * @option className: String = ''
	 * A custom class name to assign to both icon and shadow images. Empty by default.
	 */

	options: {
		popupAnchor: [0, 0],
		tooltipAnchor: [0, 0]
	},

	initialize: function (options) {
		setOptions(this, options);
	},

	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
	// Called internally when the icon has to be shown, returns a `<img>` HTML element
	// styled according to the options.
	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
	// As `createIcon`, but for the shadow beneath it.
	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options;
		var sizeOption = options[name + 'Size'];

		if (typeof sizeOption === 'number') {
			sizeOption = [sizeOption, sizeOption];
		}

		var size = toPoint(sizeOption),
		    anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
		            size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});


// @factory L.icon(options: Icon options)
// Creates an icon instance with the given options.
function icon(options) {
	return new Icon(options);
}

/*
 * @miniclass Icon.Default (Icon)
 * @aka L.Icon.Default
 * @section
 *
 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
 * no icon is specified. Points to the blue marker image distributed with Leaflet
 * releases.
 *
 * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
 * (which is a set of `Icon options`).
 *
 * If you want to _completely_ replace the default icon, override the
 * `L.Marker.prototype.options.icon` with your own icon instead.
 */

var IconDefault = Icon.extend({

	options: {
		iconUrl:       'marker-icon.png',
		iconRetinaUrl: 'marker-icon-2x.png',
		shadowUrl:     'marker-shadow.png',
		iconSize:    [25, 41],
		iconAnchor:  [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [16, -28],
		shadowSize:  [41, 41]
	},

	_getIconUrl: function (name) {
		if (!IconDefault.imagePath) {	// Deprecated, backwards-compatibility only
			IconDefault.imagePath = this._detectIconPath();
		}

		// @option imagePath: String
		// `Icon.Default` will try to auto-detect the location of the
		// blue icon images. If you are placing these images in a non-standard
		// way, set this option to point to the right path.
		return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
	},

	_detectIconPath: function () {
		var el = create$1('div',  'leaflet-default-icon-path', document.body);
		var path = getStyle(el, 'background-image') ||
		           getStyle(el, 'backgroundImage');	// IE8

		document.body.removeChild(el);

		if (path === null || path.indexOf('url') !== 0) {
			path = '';
		} else {
			path = path.replace(/^url\(["']?/, '').replace(/marker-icon\.png["']?\)$/, '');
		}

		return path;
	}
});

/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */


/* @namespace Marker
 * @section Interaction handlers
 *
 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
 *
 * ```js
 * marker.dragging.disable();
 * ```
 *
 * @property dragging: Handler
 * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
 */

var MarkerDrag = Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			predrag: this._onPreDrag,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable.off({
			dragstart: this._onDragStart,
			predrag: this._onPreDrag,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_adjustPan: function (e) {
		var marker = this._marker,
		    map = marker._map,
		    speed = this._marker.options.autoPanSpeed,
		    padding = this._marker.options.autoPanPadding,
		    iconPos = getPosition(marker._icon),
		    bounds = map.getPixelBounds(),
		    origin = map.getPixelOrigin();

		var panBounds = toBounds(
			bounds.min._subtract(origin).add(padding),
			bounds.max._subtract(origin).subtract(padding)
		);

		if (!panBounds.contains(iconPos)) {
			// Compute incremental movement
			var movement = toPoint(
				(Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) -
				(Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),

				(Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) -
				(Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
			).multiplyBy(speed);

			map.panBy(movement, {animate: false});

			this._draggable._newPos._add(movement);
			this._draggable._startPos._add(movement);

			setPosition(marker._icon, this._draggable._newPos);
			this._onDrag(e);

			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
		}
	},

	_onDragStart: function () {
		// @section Dragging events
		// @event dragstart: Event
		// Fired when the user starts dragging the marker.

		// @event movestart: Event
		// Fired when the marker starts moving (because of dragging).

		this._oldLatLng = this._marker.getLatLng();
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onPreDrag: function (e) {
		if (this._marker.options.autoPan) {
			cancelAnimFrame(this._panRequest);
			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
		}
	},

	_onDrag: function (e) {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;
		e.oldLatLng = this._oldLatLng;

		// @event drag: Event
		// Fired repeatedly while the user drags the marker.
		marker
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onDragEnd: function (e) {
		// @event dragend: DragEndEvent
		// Fired when the user stops dragging the marker.

		 cancelAnimFrame(this._panRequest);

		// @event moveend: Event
		// Fired when the marker stops moving (because of dragging).
		delete this._oldLatLng;
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});

/*
 * @class Marker
 * @inherits Interactive layer
 * @aka L.Marker
 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.marker([50.5, 30.5]).addTo(map);
 * ```
 */

var Marker = Layer.extend({

	// @section
	// @aka Marker options
	options: {
		// @option icon: Icon = *
		// Icon instance to use for rendering the marker.
		// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
		// If not specified, a common instance of `L.Icon.Default` is used.
		icon: new IconDefault(),

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option keyboard: Boolean = true
		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
		keyboard: true,

		// @option title: String = ''
		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
		title: '',

		// @option alt: String = ''
		// Text for the `alt` attribute of the icon image (useful for accessibility).
		alt: '',

		// @option zIndexOffset: Number = 0
		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
		zIndexOffset: 0,

		// @option opacity: Number = 1.0
		// The opacity of the marker.
		opacity: 1,

		// @option riseOnHover: Boolean = false
		// If `true`, the marker will get on top of others when you hover the mouse over it.
		riseOnHover: false,

		// @option riseOffset: Number = 250
		// The z-index offset used for the `riseOnHover` feature.
		riseOffset: 250,

		// @option pane: String = 'markerPane'
		// `Map pane` where the markers icon will be added.
		pane: 'markerPane',

		// @option pane: String = 'shadowPane'
		// `Map pane` where the markers shadow will be added.
		shadowPane: 'shadowPane',

		// @option bubblingMouseEvents: Boolean = false
		// When `true`, a mouse event on this marker will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: false,

		// @section Draggable marker options
		// @option draggable: Boolean = false
		// Whether the marker is draggable with mouse/touch or not.
		draggable: false,

		// @option autoPan: Boolean = false
		// Whether to pan the map when dragging this marker near its edge or not.
		autoPan: false,

		// @option autoPanPadding: Point = Point(50, 50)
		// Distance (in pixels to the left/right and to the top/bottom) of the
		// map edge to start panning the map.
		autoPanPadding: [50, 50],

		// @option autoPanSpeed: Number = 10
		// Number of pixels the map should pan by.
		autoPanSpeed: 10
	},

	/* @section
	 *
	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
	 */

	initialize: function (latlng, options) {
		setOptions(this, options);
		this._latlng = toLatLng(latlng);
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		if (this._zoomAnimated) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._initIcon();
		this.update();
	},

	onRemove: function (map) {
		if (this.dragging && this.dragging.enabled()) {
			this.options.draggable = true;
			this.dragging.removeHooks();
		}
		delete this.dragging;

		if (this._zoomAnimated) {
			map.off('zoomanim', this._animateZoom, this);
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function () {
		return {
			zoom: this.update,
			viewreset: this.update
		};
	},

	// @method getLatLng: LatLng
	// Returns the current geographical position of the marker.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Changes the marker position to the given point.
	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = toLatLng(latlng);
		this.update();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
	},

	// @method setZIndexOffset(offset: Number): this
	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	// @method getIcon: Icon
	// Returns the current icon used by the marker
	getIcon: function () {
		return this.options.icon;
	},

	// @method setIcon(icon: Icon): this
	// Changes the marker icon.
	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	getElement: function () {
		return this._icon;
	},

	update: function () {

		if (this._icon && this._map) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
		    addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}

			if (icon.tagName === 'IMG') {
				icon.alt = options.alt || '';
			}
		}

		addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
		    addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			addClass(newShadow, classToAdd);
			newShadow.alt = '';
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		this._initInteraction();
		if (newShadow && addShadow) {
			this.getPane(options.shadowPane).appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {

		if (this._icon) {
			setPosition(this._icon, pos);
		}

		if (this._shadow) {
			setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		if (this._icon) {
			this._icon.style.zIndex = this._zIndex + offset;
		}
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.interactive) { return; }

		addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	// @method setOpacity(opacity: Number): this
	// Changes the opacity of the marker.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		var opacity = this.options.opacity;

		if (this._icon) {
			setOpacity(this._icon, opacity);
		}

		if (this._shadow) {
			setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	},

	_getPopupAnchor: function () {
		return this.options.icon.options.popupAnchor;
	},

	_getTooltipAnchor: function () {
		return this.options.icon.options.tooltipAnchor;
	}
});


// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options)
// Instantiates a Marker object given a geographical point and optionally an options object.
function marker(latlng, options) {
	return new Marker(latlng, options);
}

/*
 * @class Path
 * @aka L.Path
 * @inherits Interactive layer
 *
 * An abstract class that contains options and constants shared between vector
 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
 */

var Path = Layer.extend({

	// @section
	// @aka Path options
	options: {
		// @option stroke: Boolean = true
		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
		stroke: true,

		// @option color: String = '#3388ff'
		// Stroke color
		color: '#3388ff',

		// @option weight: Number = 3
		// Stroke width in pixels
		weight: 3,

		// @option opacity: Number = 1.0
		// Stroke opacity
		opacity: 1,

		// @option lineCap: String= 'round'
		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
		lineCap: 'round',

		// @option lineJoin: String = 'round'
		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
		lineJoin: 'round',

		// @option dashArray: String = null
		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashArray: null,

		// @option dashOffset: String = null
		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashOffset: null,

		// @option fill: Boolean = depends
		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
		fill: false,

		// @option fillColor: String = *
		// Fill color. Defaults to the value of the [`color`](#path-color) option
		fillColor: null,

		// @option fillOpacity: Number = 0.2
		// Fill opacity.
		fillOpacity: 0.2,

		// @option fillRule: String = 'evenodd'
		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
		fillRule: 'evenodd',

		// className: '',

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option bubblingMouseEvents: Boolean = true
		// When `true`, a mouse event on this path will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: true
	},

	beforeAdd: function (map) {
		// Renderer is set here because we need to call renderer.getEvents
		// before this.getEvents.
		this._renderer = map.getRenderer(this);
	},

	onAdd: function () {
		this._renderer._initPath(this);
		this._reset();
		this._renderer._addPath(this);
	},

	onRemove: function () {
		this._renderer._removePath(this);
	},

	// @method redraw(): this
	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
	redraw: function () {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	// @method setStyle(style: Path options): this
	// Changes the appearance of a Path based on the options in the `Path options` object.
	setStyle: function (style) {
		setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
			if (this.options.stroke && style && style.hasOwnProperty('weight')) {
				this._updateBounds();
			}
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all path layers.
	bringToFront: function () {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all path layers.
	bringToBack: function () {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	getElement: function () {
		return this._path;
	},

	_reset: function () {
		// defined in child classes
		this._project();
		this._update();
	},

	_clickTolerance: function () {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
	}
});

/*
 * @class CircleMarker
 * @aka L.CircleMarker
 * @inherits Path
 *
 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
 */

var CircleMarker = Path.extend({

	// @section
	// @aka CircleMarker options
	options: {
		fill: true,

		// @option radius: Number = 10
		// Radius of the circle marker, in pixels
		radius: 10
	},

	initialize: function (latlng, options) {
		setOptions(this, options);
		this._latlng = toLatLng(latlng);
		this._radius = this.options.radius;
	},

	// @method setLatLng(latLng: LatLng): this
	// Sets the position of a circle marker to a new location.
	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = toLatLng(latlng);
		this.redraw();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
	},

	// @method getLatLng(): LatLng
	// Returns the current geographical position of the circle marker
	getLatLng: function () {
		return this._latlng;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle marker. Units are in pixels.
	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of the circle
	getRadius: function () {
		return this._radius;
	},

	setStyle : function (options) {
		var radius = options && options.radius || this._radius;
		Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function () {
		var r = this._radius,
		    r2 = this._radiusY || r,
		    w = this._clickTolerance(),
		    p = [r + w, r2 + w];
		this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function () {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function () {
		this._renderer._updateCircle(this);
	},

	_empty: function () {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function (p) {
		return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
	}
});


// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
// Instantiates a circle marker object given a geographical point, and an optional options object.
function circleMarker(latlng, options) {
	return new CircleMarker(latlng, options);
}

/*
 * @class Circle
 * @aka L.Circle
 * @inherits CircleMarker
 *
 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
 *
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
 *
 * @example
 *
 * ```js
 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
 * ```
 */

var Circle = CircleMarker.extend({

	initialize: function (latlng, options, legacyOptions) {
		if (typeof options === 'number') {
			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
			options = extend({}, legacyOptions, {radius: options});
		}
		setOptions(this, options);
		this._latlng = toLatLng(latlng);

		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

		// @section
		// @aka Circle options
		// @option radius: Number; Radius of the circle, in meters.
		this._mRadius = this.options.radius;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle. Units are in meters.
	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of a circle. Units are in meters.
	getRadius: function () {
		return this._mRadius;
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		var half = [this._radius, this._radiusY || this._radius];

		return new LatLngBounds(
			this._map.layerPointToLatLng(this._point.subtract(half)),
			this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: Path.prototype.setStyle,

	_project: function () {

		var lng = this._latlng.lng,
		    lat = this._latlng.lat,
		    map = this._map,
		    crs = map.options.crs;

		if (crs.distance === Earth.distance) {
			var d = Math.PI / 180,
			    latR = (this._mRadius / Earth.R) / d,
			    top = map.project([lat + latR, lng]),
			    bottom = map.project([lat - latR, lng]),
			    p = top.add(bottom).divideBy(2),
			    lat2 = map.unproject(p).lat,
			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			if (isNaN(lngR) || lngR === 0) {
				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
			}

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
			this._radiusY = p.y - top.y;

		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

// @factory L.circle(latlng: LatLng, options?: Circle options)
// Instantiates a circle object given a geographical point, and an options object
// which contains the circle radius.
// @alternative
// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
// Do not use in new applications or plugins.
function circle(latlng, options, legacyOptions) {
	return new Circle(latlng, options, legacyOptions);
}

/*
 * @class Polyline
 * @aka L.Polyline
 * @inherits Path
 *
 * A class for drawing polyline overlays on a map. Extends `Path`.
 *
 * @example
 *
 * ```js
 * // create a red polyline from an array of LatLng points
 * var latlngs = [
 * 	[45.51, -122.68],
 * 	[37.77, -122.43],
 * 	[34.04, -118.2]
 * ];
 *
 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polyline
 * map.fitBounds(polyline.getBounds());
 * ```
 *
 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
 *
 * ```js
 * // create a red polyline from an array of arrays of LatLng points
 * var latlngs = [
 * 	[[45.51, -122.68],
 * 	 [37.77, -122.43],
 * 	 [34.04, -118.2]],
 * 	[[40.78, -73.91],
 * 	 [41.83, -87.62],
 * 	 [32.76, -96.72]]
 * ];
 * ```
 */


var Polyline = Path.extend({

	// @section
	// @aka Polyline options
	options: {
		// @option smoothFactor: Number = 1.0
		// How much to simplify the polyline on each zoom level. More means
		// better performance and smoother look, and less means more accurate representation.
		smoothFactor: 1.0,

		// @option noClip: Boolean = false
		// Disable polyline clipping.
		noClip: false
	},

	initialize: function (latlngs, options) {
		setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	// @method getLatLngs(): LatLng[]
	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	getLatLngs: function () {
		return this._latlngs;
	},

	// @method setLatLngs(latlngs: LatLng[]): this
	// Replaces all the points in the polyline with the given array of geographical points.
	setLatLngs: function (latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	// @method isEmpty(): Boolean
	// Returns `true` if the Polyline has no LatLngs.
	isEmpty: function () {
		return !this._latlngs.length;
	},

	// @method closestLayerPoint(p: Point): Point
	// Returns the point closest to `p` on the Polyline.
	closestLayerPoint: function (p) {
		var minDistance = Infinity,
		    minPoint = null,
		    closest = _sqClosestPointOnSegment,
		    p1, p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	// @method getCenter(): LatLng
	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, halfDist, segDist, dist, p1, p2, ratio,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([
					p2.x - ratio * (p2.x - p1.x),
					p2.y - ratio * (p2.y - p1.y)
				]);
			}
		}
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		return this._bounds;
	},

	// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
	// Adds a given point to the polyline. By default, adds to the first ring of
	// the polyline in case of a multi-polyline, but can be overridden by passing
	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
	addLatLng: function (latlng, latlngs) {
		latlngs = latlngs || this._defaultShape();
		latlng = toLatLng(latlng);
		latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	_setLatLngs: function (latlngs) {
		this._bounds = new LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	_defaultShape: function () {
		return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function (latlngs) {
		var result = [],
		    flat = isFlat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = toLatLng(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_project: function () {
		var pxBounds = new Bounds();
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

		if (this._bounds.isValid() && pxBounds.isValid()) {
			this._rawPxBounds = pxBounds;
			this._updateBounds();
		}
	},

	_updateBounds: function () {
		var w = this._clickTolerance(),
		    p = new Point(w, w);
		this._pxBounds = new Bounds([
			this._rawPxBounds.min.subtract(p),
			this._rawPxBounds.max.add(p)
		]);
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function (latlngs, result, projectedBounds) {
		var flat = latlngs[0] instanceof LatLng,
		    len = latlngs.length,
		    i, ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
				projectedBounds.extend(ring[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result, projectedBounds);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function () {
		var bounds = this._renderer._bounds;

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		var parts = this._parts,
		    i, j, k, len, len2, segment, points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) { continue; }

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function () {
		var parts = this._parts,
		    tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = simplify(parts[i], tolerance);
		}
	},

	_update: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function () {
		this._renderer._updatePoly(this);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function (p, closed) {
		var i, j, k, len, len2, part,
		    w = this._clickTolerance();

		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

		// hit detection for polylines
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				if (!closed && (j === 0)) { continue; }

				if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
					return true;
				}
			}
		}
		return false;
	}
});

// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
// Instantiates a polyline object given an array of geographical points and
// optionally an options object. You can create a `Polyline` object with
// multiple separate lines (`MultiPolyline`) by passing an array of arrays
// of geographic points.
function polyline(latlngs, options) {
	return new Polyline(latlngs, options);
}

// Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
Polyline._flat = _flat;

/*
 * @class Polygon
 * @aka L.Polygon
 * @inherits Polyline
 *
 * A class for drawing polygon overlays on a map. Extends `Polyline`.
 *
 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
 *
 *
 * @example
 *
 * ```js
 * // create a red polygon from an array of LatLng points
 * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
 *
 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polygon
 * map.fitBounds(polygon.getBounds());
 * ```
 *
 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
 *
 * ```js
 * var latlngs = [
 *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 * ];
 * ```
 *
 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
 *
 * ```js
 * var latlngs = [
 *   [ // first polygon
 *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 *   ],
 *   [ // second polygon
 *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
 *   ]
 * ];
 * ```
 */

var Polygon = Polyline.extend({

	options: {
		fill: true
	},

	isEmpty: function () {
		return !this._latlngs.length || !this._latlngs[0].length;
	},

	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, j, p1, p2, f, area, x, y, center,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function (latlngs) {
		var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
		    len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_setLatLngs: function (latlngs) {
		Polyline.prototype._setLatLngs.call(this, latlngs);
		if (isFlat(this._latlngs)) {
			this._latlngs = [this._latlngs];
		}
	},

	_defaultShape: function () {
		return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
	},

	_clipPoints: function () {
		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
		    w = this.options.weight,
		    p = new Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function () {
		this._renderer._updatePoly(this, true);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function (p) {
		var inside = false,
		    part, p1, p2, i, j, k, len, len2;

		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

		// ray casting algorithm for detecting if point is in polygon
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				p1 = part[j];
				p2 = part[k];

				if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
					inside = !inside;
				}
			}
		}

		// also check if it's on polygon stroke
		return inside || Polyline.prototype._containsPoint.call(this, p, true);
	}

});


// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
function polygon(latlngs, options) {
	return new Polygon(latlngs, options);
}

/*
 * @class GeoJSON
 * @aka L.GeoJSON
 * @inherits FeatureGroup
 *
 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
 *
 * @example
 *
 * ```js
 * L.geoJSON(data, {
 * 	style: function (feature) {
 * 		return {color: feature.properties.color};
 * 	}
 * }).bindPopup(function (layer) {
 * 	return layer.feature.properties.description;
 * }).addTo(map);
 * ```
 */

var GeoJSON = FeatureGroup.extend({

	/* @section
	 * @aka GeoJSON options
	 *
	 * @option pointToLayer: Function = *
	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
	 * The default is to spawn a default `Marker`:
	 * ```js
	 * function(geoJsonPoint, latlng) {
	 * 	return L.marker(latlng);
	 * }
	 * ```
	 *
	 * @option style: Function = *
	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
	 * called internally when data is added.
	 * The default value is to not override any defaults:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return {}
	 * }
	 * ```
	 *
	 * @option onEachFeature: Function = *
	 * A `Function` that will be called once for each created `Feature`, after it has
	 * been created and styled. Useful for attaching events and popups to features.
	 * The default is to do nothing with the newly created layers:
	 * ```js
	 * function (feature, layer) {}
	 * ```
	 *
	 * @option filter: Function = *
	 * A `Function` that will be used to decide whether to include a feature or not.
	 * The default is to include all features:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return true;
	 * }
	 * ```
	 * Note: dynamically changing the `filter` option will have effect only on newly
	 * added data. It will _not_ re-evaluate already included features.
	 *
	 * @option coordsToLatLng: Function = *
	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
	 * The default is the `coordsToLatLng` static method.
	 *
	 * @option markersInheritOptions: Boolean = false
	 * Whether default Markers for "Point" type Features inherit from group options.
	 */

	initialize: function (geojson, options) {
		setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	// @method addData( <GeoJSON> data ): this
	// Adds a GeoJSON object to the layer.
	addData: function (geojson) {
		var features = isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return this; }

		var layer = geometryToLayer(geojson, options);
		if (!layer) {
			return this;
		}
		layer.feature = asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	// @method resetStyle( <Path> layer? ): this
	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
	// If `layer` is omitted, the style of all features in the current layer is reset.
	resetStyle: function (layer) {
		if (layer === undefined) {
			return this.eachLayer(this.resetStyle, this);
		}
		// reset any custom styles
		layer.options = extend({}, layer.defaultOptions);
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	// @method setStyle( <Function> style ): this
	// Changes styles of GeoJSON vector layers with the given style function.
	setStyle: function (style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (layer.setStyle) {
			if (typeof style === 'function') {
				style = style(layer.feature);
			}
			layer.setStyle(style);
		}
	}
});

// @section
// There are several static functions which can be called without instantiating L.GeoJSON:

// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
// Creates a `Layer` from a given GeoJSON feature. Can use a custom
// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
// functions if provided as options.
function geometryToLayer(geojson, options) {

	var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
	    coords = geometry ? geometry.coordinates : null,
	    layers = [],
	    pointToLayer = options && options.pointToLayer,
	    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
	    latlng, latlngs, i, len;

	if (!coords && !geometry) {
		return null;
	}

	switch (geometry.type) {
	case 'Point':
		latlng = _coordsToLatLng(coords);
		return _pointToLayer(pointToLayer, geojson, latlng, options);

	case 'MultiPoint':
		for (i = 0, len = coords.length; i < len; i++) {
			latlng = _coordsToLatLng(coords[i]);
			layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));
		}
		return new FeatureGroup(layers);

	case 'LineString':
	case 'MultiLineString':
		latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
		return new Polyline(latlngs, options);

	case 'Polygon':
	case 'MultiPolygon':
		latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
		return new Polygon(latlngs, options);

	case 'GeometryCollection':
		for (i = 0, len = geometry.geometries.length; i < len; i++) {
			var layer = geometryToLayer({
				geometry: geometry.geometries[i],
				type: 'Feature',
				properties: geojson.properties
			}, options);

			if (layer) {
				layers.push(layer);
			}
		}
		return new FeatureGroup(layers);

	default:
		throw new Error('Invalid GeoJSON object.');
	}
}

function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
	return pointToLayerFn ?
		pointToLayerFn(geojson, latlng) :
		new Marker(latlng, options && options.markersInheritOptions && options);
}

// @function coordsToLatLng(coords: Array): LatLng
// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
function coordsToLatLng(coords) {
	return new LatLng(coords[1], coords[0], coords[2]);
}

// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
	var latlngs = [];

	for (var i = 0, len = coords.length, latlng; i < len; i++) {
		latlng = levelsDeep ?
			coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) :
			(_coordsToLatLng || coordsToLatLng)(coords[i]);

		latlngs.push(latlng);
	}

	return latlngs;
}

// @function latLngToCoords(latlng: LatLng, precision?: Number): Array
// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
function latLngToCoords(latlng, precision) {
	precision = typeof precision === 'number' ? precision : 6;
	return latlng.alt !== undefined ?
		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] :
		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
}

// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
	var coords = [];

	for (var i = 0, len = latlngs.length; i < len; i++) {
		coords.push(levelsDeep ?
			latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) :
			latLngToCoords(latlngs[i], precision));
	}

	if (!levelsDeep && closed) {
		coords.push(coords[0]);
	}

	return coords;
}

function getFeature(layer, newGeometry) {
	return layer.feature ?
		extend({}, layer.feature, {geometry: newGeometry}) :
		asFeature(newGeometry);
}

// @function asFeature(geojson: Object): Object
// Normalize GeoJSON geometries/features into GeoJSON features.
function asFeature(geojson) {
	if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
		return geojson;
	}

	return {
		type: 'Feature',
		properties: {},
		geometry: geojson
	};
}

var PointToGeoJSON = {
	toGeoJSON: function (precision) {
		return getFeature(this, {
			type: 'Point',
			coordinates: latLngToCoords(this.getLatLng(), precision)
		});
	}
};

// @namespace Marker
// @section Other methods
// @method toGeoJSON(precision?: Number): Object
// `precision` is the number of decimal places for coordinates.
// The default value is 6 places.
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
Marker.include(PointToGeoJSON);

// @namespace CircleMarker
// @method toGeoJSON(precision?: Number): Object
// `precision` is the number of decimal places for coordinates.
// The default value is 6 places.
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
Circle.include(PointToGeoJSON);
CircleMarker.include(PointToGeoJSON);


// @namespace Polyline
// @method toGeoJSON(precision?: Number): Object
// `precision` is the number of decimal places for coordinates.
// The default value is 6 places.
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
Polyline.include({
	toGeoJSON: function (precision) {
		var multi = !isFlat(this._latlngs);

		var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'LineString',
			coordinates: coords
		});
	}
});

// @namespace Polygon
// @method toGeoJSON(precision?: Number): Object
// `precision` is the number of decimal places for coordinates.
// The default value is 6 places.
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
Polygon.include({
	toGeoJSON: function (precision) {
		var holes = !isFlat(this._latlngs),
		    multi = holes && !isFlat(this._latlngs[0]);

		var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

		if (!holes) {
			coords = [coords];
		}

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'Polygon',
			coordinates: coords
		});
	}
});


// @namespace LayerGroup
LayerGroup.include({
	toMultiPoint: function (precision) {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON(precision).geometry.coordinates);
		});

		return getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	// @method toGeoJSON(precision?: Number): Object
	// `precision` is the number of decimal places for coordinates.
	// The default value is 6 places.
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
	toGeoJSON: function (precision) {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint(precision);
		}

		var isGeometryCollection = type === 'GeometryCollection',
		    jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON(precision);
				if (isGeometryCollection) {
					jsons.push(json.geometry);
				} else {
					var feature = asFeature(json);
					// Squash nested feature collections
					if (feature.type === 'FeatureCollection') {
						jsons.push.apply(jsons, feature.features);
					} else {
						jsons.push(feature);
					}
				}
			}
		});

		if (isGeometryCollection) {
			return getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

// @namespace GeoJSON
// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
// Creates a GeoJSON layer. Optionally accepts an object in
// [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
// (you can alternatively add it later with `addData` method) and an `options` object.
function geoJSON(geojson, options) {
	return new GeoJSON(geojson, options);
}

// Backward compatibility.
var geoJson = geoJSON;

/*
 * @class ImageOverlay
 * @aka L.ImageOverlay
 * @inherits Interactive layer
 *
 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
 * ```
 */

var ImageOverlay = Layer.extend({

	// @section
	// @aka ImageOverlay options
	options: {
		// @option opacity: Number = 1.0
		// The opacity of the image overlay.
		opacity: 1,

		// @option alt: String = ''
		// Text for the `alt` attribute of the image (useful for accessibility).
		alt: '',

		// @option interactive: Boolean = false
		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
		interactive: false,

		// @option crossOrigin: Boolean|String = false
		// Whether the crossOrigin attribute will be added to the image.
		// If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
		crossOrigin: false,

		// @option errorOverlayUrl: String = ''
		// URL to the overlay image to show in place of the overlay that failed to load.
		errorOverlayUrl: '',

		// @option zIndex: Number = 1
		// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
		zIndex: 1,

		// @option className: String = ''
		// A custom class name to assign to the image. Empty by default.
		className: ''
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = toLatLngBounds(bounds);

		setOptions(this, options);
	},

	onAdd: function () {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function () {
		remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	// @method setOpacity(opacity: Number): this
	// Sets the opacity of the overlay.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function (styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all overlays.
	bringToFront: function () {
		if (this._map) {
			toFront(this._image);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all overlays.
	bringToBack: function () {
		if (this._map) {
			toBack(this._image);
		}
		return this;
	},

	// @method setUrl(url: String): this
	// Changes the URL of the image.
	setUrl: function (url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	// @method setBounds(bounds: LatLngBounds): this
	// Update the bounds that this ImageOverlay covers
	setBounds: function (bounds) {
		this._bounds = toLatLngBounds(bounds);

		if (this._map) {
			this._reset();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			zoom: this._reset,
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @method setZIndex(value: Number): this
	// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
	setZIndex: function (value) {
		this.options.zIndex = value;
		this._updateZIndex();
		return this;
	},

	// @method getBounds(): LatLngBounds
	// Get the bounds that this ImageOverlay covers
	getBounds: function () {
		return this._bounds;
	},

	// @method getElement(): HTMLElement
	// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
	// used by this overlay.
	getElement: function () {
		return this._image;
	},

	_initImage: function () {
		var wasElementSupplied = this._url.tagName === 'IMG';
		var img = this._image = wasElementSupplied ? this._url : create$1('img');

		addClass(img, 'leaflet-image-layer');
		if (this._zoomAnimated) { addClass(img, 'leaflet-zoom-animated'); }
		if (this.options.className) { addClass(img, this.options.className); }

		img.onselectstart = falseFn;
		img.onmousemove = falseFn;

		// @event load: Event
		// Fired when the ImageOverlay layer has loaded its image
		img.onload = bind(this.fire, this, 'load');
		img.onerror = bind(this._overlayOnError, this, 'error');

		if (this.options.crossOrigin || this.options.crossOrigin === '') {
			img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
		}

		if (this.options.zIndex) {
			this._updateZIndex();
		}

		if (wasElementSupplied) {
			this._url = img.src;
			return;
		}

		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function (e) {
		var scale = this._map.getZoomScale(e.zoom),
		    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

		setTransform(this._image, offset, scale);
	},

	_reset: function () {
		var image = this._image,
		    bounds = new Bounds(
		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
		    size = bounds.getSize();

		setPosition(image, bounds.min);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function () {
		setOpacity(this._image, this.options.opacity);
	},

	_updateZIndex: function () {
		if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._image.style.zIndex = this.options.zIndex;
		}
	},

	_overlayOnError: function () {
		// @event error: Event
		// Fired when the ImageOverlay layer fails to load its image
		this.fire('error');

		var errorUrl = this.options.errorOverlayUrl;
		if (errorUrl && this._url !== errorUrl) {
			this._url = errorUrl;
			this._image.src = errorUrl;
		}
	}
});

// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
// Instantiates an image overlay object given the URL of the image and the
// geographical bounds it is tied to.
var imageOverlay = function (url, bounds, options) {
	return new ImageOverlay(url, bounds, options);
};

/*
 * @class VideoOverlay
 * @aka L.VideoOverlay
 * @inherits ImageOverlay
 *
 * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
 *
 * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
 * HTML5 element.
 *
 * @example
 *
 * ```js
 * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
 * 	videoBounds = [[ 32, -130], [ 13, -100]];
 * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
 * ```
 */

var VideoOverlay = ImageOverlay.extend({

	// @section
	// @aka VideoOverlay options
	options: {
		// @option autoplay: Boolean = true
		// Whether the video starts playing automatically when loaded.
		autoplay: true,

		// @option loop: Boolean = true
		// Whether the video will loop back to the beginning when played.
		loop: true,

		// @option keepAspectRatio: Boolean = true
		// Whether the video will save aspect ratio after the projection.
		// Relevant for supported browsers. Browser compatibility- https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit
		keepAspectRatio: true
	},

	_initImage: function () {
		var wasElementSupplied = this._url.tagName === 'VIDEO';
		var vid = this._image = wasElementSupplied ? this._url : create$1('video');

		addClass(vid, 'leaflet-image-layer');
		if (this._zoomAnimated) { addClass(vid, 'leaflet-zoom-animated'); }
		if (this.options.className) { addClass(vid, this.options.className); }

		vid.onselectstart = falseFn;
		vid.onmousemove = falseFn;

		// @event load: Event
		// Fired when the video has finished loading the first frame
		vid.onloadeddata = bind(this.fire, this, 'load');

		if (wasElementSupplied) {
			var sourceElements = vid.getElementsByTagName('source');
			var sources = [];
			for (var j = 0; j < sourceElements.length; j++) {
				sources.push(sourceElements[j].src);
			}

			this._url = (sourceElements.length > 0) ? sources : [vid.src];
			return;
		}

		if (!isArray(this._url)) { this._url = [this._url]; }

		if (!this.options.keepAspectRatio && vid.style.hasOwnProperty('objectFit')) { vid.style['objectFit'] = 'fill'; }
		vid.autoplay = !!this.options.autoplay;
		vid.loop = !!this.options.loop;
		for (var i = 0; i < this._url.length; i++) {
			var source = create$1('source');
			source.src = this._url[i];
			vid.appendChild(source);
		}
	}

	// @method getElement(): HTMLVideoElement
	// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
	// used by this overlay.
});


// @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
// Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
// geographical bounds it is tied to.

function videoOverlay(video, bounds, options) {
	return new VideoOverlay(video, bounds, options);
}

/*
 * @class SVGOverlay
 * @aka L.SVGOverlay
 * @inherits ImageOverlay
 *
 * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.
 *
 * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.
 *
 * @example
 *
 * ```js
 * var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
 * svgElement.setAttribute('xmlns', "http://www.w3.org/2000/svg");
 * svgElement.setAttribute('viewBox', "0 0 200 200");
 * svgElement.innerHTML = '<rect width="200" height="200"/><rect x="75" y="23" width="50" height="50" style="fill:red"/><rect x="75" y="123" width="50" height="50" style="fill:#0013ff"/>';
 * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];
 * L.svgOverlay(svgElement, svgElementBounds).addTo(map);
 * ```
 */

var SVGOverlay = ImageOverlay.extend({
	_initImage: function () {
		var el = this._image = this._url;

		addClass(el, 'leaflet-image-layer');
		if (this._zoomAnimated) { addClass(el, 'leaflet-zoom-animated'); }
		if (this.options.className) { addClass(el, this.options.className); }

		el.onselectstart = falseFn;
		el.onmousemove = falseFn;
	}

	// @method getElement(): SVGElement
	// Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
	// used by this overlay.
});


// @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)
// Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.
// A viewBox attribute is required on the SVG element to zoom in and out properly.

function svgOverlay(el, bounds, options) {
	return new SVGOverlay(el, bounds, options);
}

/*
 * @class DivOverlay
 * @inherits Layer
 * @aka L.DivOverlay
 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
 */

// @namespace DivOverlay
var DivOverlay = Layer.extend({

	// @section
	// @aka DivOverlay options
	options: {
		// @option offset: Point = Point(0, 7)
		// The offset of the popup position. Useful to control the anchor
		// of the popup when opening it on some overlays.
		offset: [0, 7],

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: '',

		// @option pane: String = 'popupPane'
		// `Map pane` where the popup will be added.
		pane: 'popupPane'
	},

	initialize: function (options, source) {
		setOptions(this, options);

		this._source = source;
	},

	onAdd: function (map) {
		this._zoomAnimated = map._zoomAnimated;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			setOpacity(this._container, 1);
		}

		this.bringToFront();
	},

	onRemove: function (map) {
		if (map._fadeAnimated) {
			setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
		} else {
			remove(this._container);
		}
	},

	// @namespace Popup
	// @method getLatLng: LatLng
	// Returns the geographical point of popup.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Sets the geographical point where the popup will open.
	setLatLng: function (latlng) {
		this._latlng = toLatLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	// @method getContent: String|HTMLElement
	// Returns the content of the popup.
	getContent: function () {
		return this._content;
	},

	// @method setContent(htmlContent: String|HTMLElement|Function): this
	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	// @method getElement: String|HTMLElement
	// Alias for [getContent()](#popup-getcontent)
	getElement: function () {
		return this._container;
	},

	// @method update: null
	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function () {
		var events = {
			zoom: this._updatePosition,
			viewreset: this._updatePosition
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	// @method isOpen: Boolean
	// Returns `true` when the popup is visible on the map.
	isOpen: function () {
		return !!this._map && this._map.hasLayer(this);
	},

	// @method bringToFront: this
	// Brings this popup in front of other popups (in the same map pane).
	bringToFront: function () {
		if (this._map) {
			toFront(this._container);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings this popup to the back of other popups (in the same map pane).
	bringToBack: function () {
		if (this._map) {
			toBack(this._container);
		}
		return this;
	},

	_prepareOpen: function (parent, layer, latlng) {
		if (!(layer instanceof Layer)) {
			latlng = layer;
			layer = parent;
		}

		if (layer instanceof FeatureGroup) {
			for (var id in parent._layers) {
				layer = parent._layers[id];
				break;
			}
		}

		if (!latlng) {
			if (layer.getCenter) {
				latlng = layer.getCenter();
			} else if (layer.getLatLng) {
				latlng = layer.getLatLng();
			} else {
				throw new Error('Unable to get source layer LatLng.');
			}
		}

		// set overlay source to this layer
		this._source = layer;

		// update the overlay (content, layout, ect...)
		this.update();

		return latlng;
	},

	_updateContent: function () {
		if (!this._content) { return; }

		var node = this._contentNode;
		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    offset = toPoint(this.options.offset),
		    anchor = this._getAnchor();

		if (this._zoomAnimated) {
			setPosition(this._container, pos.add(anchor));
		} else {
			offset = offset.add(pos).add(anchor);
		}

		var bottom = this._containerBottom = -offset.y,
		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_getAnchor: function () {
		return [0, 0];
	}

});

/*
 * @class Popup
 * @inherits DivOverlay
 * @aka L.Popup
 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
 * open popups while making sure that only one popup is open at one time
 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
 *
 * @example
 *
 * If you want to just bind a popup to marker click and then open it, it's really easy:
 *
 * ```js
 * marker.bindPopup(popupContent).openPopup();
 * ```
 * Path overlays like polylines also have a `bindPopup` method.
 * Here's a more complicated way to open a popup on a map:
 *
 * ```js
 * var popup = L.popup()
 * 	.setLatLng(latlng)
 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
 * 	.openOn(map);
 * ```
 */


// @namespace Popup
var Popup = DivOverlay.extend({

	// @section
	// @aka Popup options
	options: {
		// @option maxWidth: Number = 300
		// Max width of the popup, in pixels.
		maxWidth: 300,

		// @option minWidth: Number = 50
		// Min width of the popup, in pixels.
		minWidth: 50,

		// @option maxHeight: Number = null
		// If set, creates a scrollable container of the given height
		// inside a popup if its content exceeds it.
		maxHeight: null,

		// @option autoPan: Boolean = true
		// Set it to `false` if you don't want the map to do panning animation
		// to fit the opened popup.
		autoPan: true,

		// @option autoPanPaddingTopLeft: Point = null
		// The margin between the popup and the top left corner of the map
		// view after autopanning was performed.
		autoPanPaddingTopLeft: null,

		// @option autoPanPaddingBottomRight: Point = null
		// The margin between the popup and the bottom right corner of the map
		// view after autopanning was performed.
		autoPanPaddingBottomRight: null,

		// @option autoPanPadding: Point = Point(5, 5)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [5, 5],

		// @option keepInView: Boolean = false
		// Set it to `true` if you want to prevent users from panning the popup
		// off of the screen while it is open.
		keepInView: false,

		// @option closeButton: Boolean = true
		// Controls the presence of a close button in the popup.
		closeButton: true,

		// @option autoClose: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the popup closing when another popup is opened.
		autoClose: true,

		// @option closeOnEscapeKey: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the ESC key for closing of the popup.
		closeOnEscapeKey: true,

		// @option closeOnClick: Boolean = *
		// Set it if you want to override the default behavior of the popup closing when user clicks
		// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: ''
	},

	// @namespace Popup
	// @method openOn(map: Map): this
	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onAdd: function (map) {
		DivOverlay.prototype.onAdd.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupopen: PopupEvent
		// Fired when a popup is opened in the map
		map.fire('popupopen', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup bound to this layer is opened
			this._source.fire('popupopen', {popup: this}, true);
			// For non-path layers, we toggle the popup when clicking
			// again the layer, so prevent the map to reopen it.
			if (!(this._source instanceof Path)) {
				this._source.on('preclick', stopPropagation);
			}
		}
	},

	onRemove: function (map) {
		DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupclose: PopupEvent
		// Fired when a popup in the map is closed
		map.fire('popupclose', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup bound to this layer is closed
			this._source.fire('popupclose', {popup: this}, true);
			if (!(this._source instanceof Path)) {
				this._source.off('preclick', stopPropagation);
			}
		}
	},

	getEvents: function () {
		var events = DivOverlay.prototype.getEvents.call(this);

		if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}

		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
		    container = this._container = create$1('div',
			prefix + ' ' + (this.options.className || '') +
			' leaflet-zoom-animated');

		var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
		this._contentNode = create$1('div', prefix + '-content', wrapper);

		disableClickPropagation(wrapper);
		disableScrollPropagation(this._contentNode);
		on(wrapper, 'contextmenu', stopPropagation);

		this._tipContainer = create$1('div', prefix + '-tip-container', container);
		this._tip = create$1('div', prefix + '-tip', this._tipContainer);

		if (this.options.closeButton) {
			var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			on(closeButton, 'click', this._onCloseButtonClick, this);
		}
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			addClass(container, scrolledClass);
		} else {
			removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
		    anchor = this._getAnchor();
		setPosition(this._container, pos.add(anchor));
	},

	_adjustPan: function () {
		if (!this.options.autoPan) { return; }
		if (this._map._panAnim) { this._map._panAnim.stop(); }

		var map = this._map,
		    marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
		    containerHeight = this._container.offsetHeight + marginBottom,
		    containerWidth = this._containerWidth,
		    layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);

		layerPos._add(getPosition(this._container));

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = toPoint(this.options.autoPanPadding),
		    paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		// @namespace Map
		// @section Popup events
		// @event autopanstart: Event
		// Fired when the map starts autopanning when opening a popup.
		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		stop(e);
	},

	_getAnchor: function () {
		// Where should we anchor the popup on the source layer?
		return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
	}

});

// @namespace Popup
// @factory L.popup(options?: Popup options, source?: Layer)
// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
var popup = function (options, source) {
	return new Popup(options, source);
};


/* @namespace Map
 * @section Interaction Options
 * @option closePopupOnClick: Boolean = true
 * Set it to `false` if you don't want popups to close when user clicks the map.
 */
Map.mergeOptions({
	closePopupOnClick: true
});


// @namespace Map
// @section Methods for Layers and Controls
Map.include({
	// @method openPopup(popup: Popup): this
	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
	// @alternative
	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
	// Creates a popup with the specified content and options and opens it in the given point on a map.
	openPopup: function (popup, latlng, options) {
		if (!(popup instanceof Popup)) {
			popup = new Popup(options).setContent(popup);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	// @method closePopup(popup?: Popup): this
	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});

/*
 * @namespace Layer
 * @section Popup methods example
 *
 * All layers share a set of methods convenient for binding popups to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
 * layer.openPopup();
 * layer.closePopup();
 * ```
 *
 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
 */

// @section Popup methods
Layer.include({

	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
	// Binds a popup to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindPopup: function (content, options) {

		if (content instanceof Popup) {
			setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	// @method unbindPopup(): this
	// Removes the popup previously bound with `bindPopup`.
	unbindPopup: function () {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	// @method openPopup(latlng?: LatLng): this
	// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
	openPopup: function (layer, latlng) {
		if (this._popup && this._map) {
			latlng = this._popup._prepareOpen(this, layer, latlng);

			// open the popup on the map
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	// @method closePopup(): this
	// Closes the popup bound to this layer if it is open.
	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	// @method togglePopup(): this
	// Opens or closes the popup bound to this layer depending on its current state.
	togglePopup: function (target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	// @method isPopupOpen(): boolean
	// Returns `true` if the popup bound to this layer is currently open.
	isPopupOpen: function () {
		return (this._popup ? this._popup.isOpen() : false);
	},

	// @method setPopupContent(content: String|HTMLElement|Popup): this
	// Sets the content of the popup bound to this layer.
	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	// @method getPopup(): Popup
	// Returns the popup bound to this layer.
	getPopup: function () {
		return this._popup;
	},

	_openPopup: function (e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// prevent map click
		stop(e);

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	},

	_onKeyPress: function (e) {
		if (e.originalEvent.keyCode === 13) {
			this._openPopup(e);
		}
	}
});

/*
 * @class Tooltip
 * @inherits DivOverlay
 * @aka L.Tooltip
 * Used to display small texts on top of map layers.
 *
 * @example
 *
 * ```js
 * marker.bindTooltip("my tooltip text").openTooltip();
 * ```
 * Note about tooltip offset. Leaflet takes two options in consideration
 * for computing tooltip offsetting:
 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
 *   move it to the bottom. Negatives will move to the left and top.
 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
 *   should adapt this value if you use a custom icon.
 */


// @namespace Tooltip
var Tooltip = DivOverlay.extend({

	// @section
	// @aka Tooltip options
	options: {
		// @option pane: String = 'tooltipPane'
		// `Map pane` where the tooltip will be added.
		pane: 'tooltipPane',

		// @option offset: Point = Point(0, 0)
		// Optional offset of the tooltip position.
		offset: [0, 0],

		// @option direction: String = 'auto'
		// Direction where to open the tooltip. Possible values are: `right`, `left`,
		// `top`, `bottom`, `center`, `auto`.
		// `auto` will dynamically switch between `right` and `left` according to the tooltip
		// position on the map.
		direction: 'auto',

		// @option permanent: Boolean = false
		// Whether to open the tooltip permanently or only on mouseover.
		permanent: false,

		// @option sticky: Boolean = false
		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
		sticky: false,

		// @option interactive: Boolean = false
		// If true, the tooltip will listen to the feature events.
		interactive: false,

		// @option opacity: Number = 0.9
		// Tooltip container opacity.
		opacity: 0.9
	},

	onAdd: function (map) {
		DivOverlay.prototype.onAdd.call(this, map);
		this.setOpacity(this.options.opacity);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipopen: TooltipEvent
		// Fired when a tooltip is opened in the map.
		map.fire('tooltipopen', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip bound to this layer is opened.
			this._source.fire('tooltipopen', {tooltip: this}, true);
		}
	},

	onRemove: function (map) {
		DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipclose: TooltipEvent
		// Fired when a tooltip in the map is closed.
		map.fire('tooltipclose', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip bound to this layer is closed.
			this._source.fire('tooltipclose', {tooltip: this}, true);
		}
	},

	getEvents: function () {
		var events = DivOverlay.prototype.getEvents.call(this);

		if (touch && !this.options.permanent) {
			events.preclick = this._close;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closeTooltip(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-tooltip',
		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		this._contentNode = this._container = create$1('div', className);
	},

	_updateLayout: function () {},

	_adjustPan: function () {},

	_setPosition: function (pos) {
		var map = this._map,
		    container = this._container,
		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
		    tooltipPoint = map.layerPointToContainerPoint(pos),
		    direction = this.options.direction,
		    tooltipWidth = container.offsetWidth,
		    tooltipHeight = container.offsetHeight,
		    offset = toPoint(this.options.offset),
		    anchor = this._getAnchor();

		if (direction === 'top') {
			pos = pos.add(toPoint(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));
		} else if (direction === 'bottom') {
			pos = pos.subtract(toPoint(tooltipWidth / 2 - offset.x, -offset.y, true));
		} else if (direction === 'center') {
			pos = pos.subtract(toPoint(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));
		} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
			direction = 'right';
			pos = pos.add(toPoint(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));
		} else {
			direction = 'left';
			pos = pos.subtract(toPoint(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));
		}

		removeClass(container, 'leaflet-tooltip-right');
		removeClass(container, 'leaflet-tooltip-left');
		removeClass(container, 'leaflet-tooltip-top');
		removeClass(container, 'leaflet-tooltip-bottom');
		addClass(container, 'leaflet-tooltip-' + direction);
		setPosition(container, pos);
	},

	_updatePosition: function () {
		var pos = this._map.latLngToLayerPoint(this._latlng);
		this._setPosition(pos);
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._container) {
			setOpacity(this._container, opacity);
		}
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		this._setPosition(pos);
	},

	_getAnchor: function () {
		// Where should we anchor the tooltip on the source layer?
		return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
	}

});

// @namespace Tooltip
// @factory L.tooltip(options?: Tooltip options, source?: Layer)
// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
var tooltip = function (options, source) {
	return new Tooltip(options, source);
};

// @namespace Map
// @section Methods for Layers and Controls
Map.include({

	// @method openTooltip(tooltip: Tooltip): this
	// Opens the specified tooltip.
	// @alternative
	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
	// Creates a tooltip with the specified content and options and open it.
	openTooltip: function (tooltip, latlng, options) {
		if (!(tooltip instanceof Tooltip)) {
			tooltip = new Tooltip(options).setContent(tooltip);
		}

		if (latlng) {
			tooltip.setLatLng(latlng);
		}

		if (this.hasLayer(tooltip)) {
			return this;
		}

		return this.addLayer(tooltip);
	},

	// @method closeTooltip(tooltip?: Tooltip): this
	// Closes the tooltip given as parameter.
	closeTooltip: function (tooltip) {
		if (tooltip) {
			this.removeLayer(tooltip);
		}
		return this;
	}

});

/*
 * @namespace Layer
 * @section Tooltip methods example
 *
 * All layers share a set of methods convenient for binding tooltips to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
 * layer.openTooltip();
 * layer.closeTooltip();
 * ```
 */

// @section Tooltip methods
Layer.include({

	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
	// Binds a tooltip to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindTooltip: function (content, options) {

		if (content instanceof Tooltip) {
			setOptions(content, options);
			this._tooltip = content;
			content._source = this;
		} else {
			if (!this._tooltip || options) {
				this._tooltip = new Tooltip(options, this);
			}
			this._tooltip.setContent(content);

		}

		this._initTooltipInteractions();

		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
			this.openTooltip();
		}

		return this;
	},

	// @method unbindTooltip(): this
	// Removes the tooltip previously bound with `bindTooltip`.
	unbindTooltip: function () {
		if (this._tooltip) {
			this._initTooltipInteractions(true);
			this.closeTooltip();
			this._tooltip = null;
		}
		return this;
	},

	_initTooltipInteractions: function (remove$$1) {
		if (!remove$$1 && this._tooltipHandlersAdded) { return; }
		var onOff = remove$$1 ? 'off' : 'on',
		    events = {
			remove: this.closeTooltip,
			move: this._moveTooltip
		    };
		if (!this._tooltip.options.permanent) {
			events.mouseover = this._openTooltip;
			events.mouseout = this.closeTooltip;
			if (this._tooltip.options.sticky) {
				events.mousemove = this._moveTooltip;
			}
			if (touch) {
				events.click = this._openTooltip;
			}
		} else {
			events.add = this._openTooltip;
		}
		this[onOff](events);
		this._tooltipHandlersAdded = !remove$$1;
	},

	// @method openTooltip(latlng?: LatLng): this
	// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
	openTooltip: function (layer, latlng) {
		if (this._tooltip && this._map) {
			latlng = this._tooltip._prepareOpen(this, layer, latlng);

			// open the tooltip on the map
			this._map.openTooltip(this._tooltip, latlng);

			// Tooltip container may not be defined if not permanent and never
			// opened.
			if (this._tooltip.options.interactive && this._tooltip._container) {
				addClass(this._tooltip._container, 'leaflet-clickable');
				this.addInteractiveTarget(this._tooltip._container);
			}
		}

		return this;
	},

	// @method closeTooltip(): this
	// Closes the tooltip bound to this layer if it is open.
	closeTooltip: function () {
		if (this._tooltip) {
			this._tooltip._close();
			if (this._tooltip.options.interactive && this._tooltip._container) {
				removeClass(this._tooltip._container, 'leaflet-clickable');
				this.removeInteractiveTarget(this._tooltip._container);
			}
		}
		return this;
	},

	// @method toggleTooltip(): this
	// Opens or closes the tooltip bound to this layer depending on its current state.
	toggleTooltip: function (target) {
		if (this._tooltip) {
			if (this._tooltip._map) {
				this.closeTooltip();
			} else {
				this.openTooltip(target);
			}
		}
		return this;
	},

	// @method isTooltipOpen(): boolean
	// Returns `true` if the tooltip bound to this layer is currently open.
	isTooltipOpen: function () {
		return this._tooltip.isOpen();
	},

	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
	// Sets the content of the tooltip bound to this layer.
	setTooltipContent: function (content) {
		if (this._tooltip) {
			this._tooltip.setContent(content);
		}
		return this;
	},

	// @method getTooltip(): Tooltip
	// Returns the tooltip bound to this layer.
	getTooltip: function () {
		return this._tooltip;
	},

	_openTooltip: function (e) {
		var layer = e.layer || e.target;

		if (!this._tooltip || !this._map) {
			return;
		}
		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
	},

	_moveTooltip: function (e) {
		var latlng = e.latlng, containerPoint, layerPoint;
		if (this._tooltip.options.sticky && e.originalEvent) {
			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
			latlng = this._map.layerPointToLatLng(layerPoint);
		}
		this._tooltip.setLatLng(latlng);
	}
});

/*
 * @class DivIcon
 * @aka L.DivIcon
 * @inherits Icon
 *
 * Represents a lightweight icon for markers that uses a simple `<div>`
 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
 *
 * @example
 * ```js
 * var myIcon = L.divIcon({className: 'my-div-icon'});
 * // you can set .my-div-icon styles in CSS
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
 */

var DivIcon = Icon.extend({
	options: {
		// @section
		// @aka DivIcon options
		iconSize: [12, 12], // also can be set through CSS

		// iconAnchor: (Point),
		// popupAnchor: (Point),

		// @option html: String|HTMLElement = ''
		// Custom HTML code to put inside the div element, empty by default. Alternatively,
		// an instance of `HTMLElement`.
		html: false,

		// @option bgPos: Point = [0, 0]
		// Optional relative position of the background, in pixels
		bgPos: null,

		className: 'leaflet-div-icon'
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		if (options.html instanceof Element) {
			empty(div);
			div.appendChild(options.html);
		} else {
			div.innerHTML = options.html !== false ? options.html : '';
		}

		if (options.bgPos) {
			var bgPos = toPoint(options.bgPos);
			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function () {
		return null;
	}
});

// @factory L.divIcon(options: DivIcon options)
// Creates a `DivIcon` instance with the given options.
function divIcon(options) {
	return new DivIcon(options);
}

Icon.Default = IconDefault;

/*
 * @class GridLayer
 * @inherits Layer
 * @aka L.GridLayer
 *
 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
 *
 *
 * @section Synchronous usage
 * @example
 *
 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords){
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
 *         var ctx = tile.getContext('2d');
 *
 *         // return the tile so it can be rendered on screen
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section Asynchronous usage
 * @example
 *
 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords, done){
 *         var error;
 *
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // draw something asynchronously and pass the tile to the done() callback
 *         setTimeout(function() {
 *             done(error, tile);
 *         }, 1000);
 *
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section
 */


var GridLayer = Layer.extend({

	// @section
	// @aka GridLayer options
	options: {
		// @option tileSize: Number|Point = 256
		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
		tileSize: 256,

		// @option opacity: Number = 1.0
		// Opacity of the tiles. Can be used in the `createTile()` function.
		opacity: 1,

		// @option updateWhenIdle: Boolean = (depends)
		// Load new tiles only when panning ends.
		// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
		// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
		// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
		updateWhenIdle: mobile,

		// @option updateWhenZooming: Boolean = true
		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
		updateWhenZooming: true,

		// @option updateInterval: Number = 200
		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
		updateInterval: 200,

		// @option zIndex: Number = 1
		// The explicit zIndex of the tile layer.
		zIndex: 1,

		// @option bounds: LatLngBounds = undefined
		// If set, tiles will only be loaded inside the set `LatLngBounds`.
		bounds: null,

		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = undefined
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: undefined,

		// @option maxNativeZoom: Number = undefined
		// Maximum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
		// from `maxNativeZoom` level and auto-scaled.
		maxNativeZoom: undefined,

		// @option minNativeZoom: Number = undefined
		// Minimum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
		// from `minNativeZoom` level and auto-scaled.
		minNativeZoom: undefined,

		// @option noWrap: Boolean = false
		// Whether the layer is wrapped around the antimeridian. If `true`, the
		// GridLayer will only be displayed once at low zoom levels. Has no
		// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
		// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
		// tiles outside the CRS limits.
		noWrap: false,

		// @option pane: String = 'tilePane'
		// `Map pane` where the grid layer will be added.
		pane: 'tilePane',

		// @option className: String = ''
		// A custom class name to assign to the tile layer. Empty by default.
		className: '',

		// @option keepBuffer: Number = 2
		// When panning the map, keep this many rows and columns of tiles before unloading them.
		keepBuffer: 2
	},

	initialize: function (options) {
		setOptions(this, options);
	},

	onAdd: function () {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._resetView();
		this._update();
	},

	beforeAdd: function (map) {
		map._addZoomLimit(this);
	},

	onRemove: function (map) {
		this._removeAllTiles();
		remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = undefined;
	},

	// @method bringToFront: this
	// Brings the tile layer to the top of all tile layers.
	bringToFront: function () {
		if (this._map) {
			toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings the tile layer to the bottom of all tile layers.
	bringToBack: function () {
		if (this._map) {
			toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the tiles for this layer.
	getContainer: function () {
		return this._container;
	},

	// @method setOpacity(opacity: Number): this
	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// @method setZIndex(zIndex: Number): this
	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	// @method isLoading: Boolean
	// Returns `true` if any tile in the grid layer has not finished loading.
	isLoading: function () {
		return this._loading;
	},

	// @method redraw: this
	// Causes the layer to clear all the tiles and request them again.
	redraw: function () {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			viewprereset: this._invalidateAll,
			viewreset: this._resetView,
			zoom: this._resetView,
			moveend: this._onMoveEnd
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			if (!this._onMove) {
				this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
			}

			events.move = this._onMove;
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @section Extension methods
	// Layers extending `GridLayer` shall reimplement the following method.
	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, must be overridden by classes extending `GridLayer`.
	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
	// is specified, it must be called when the tile has finished loading and drawing.
	createTile: function () {
		return document.createElement('div');
	},

	// @section
	// @method getTileSize: Point
	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
	getTileSize: function () {
		var s = this.options.tileSize;
		return s instanceof Point ? s : new Point(s, s);
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function () {
		if (!this._map) { return; }

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (ielt9) { return; }

		setOpacity(this._container, this.options.opacity);

		var now = +new Date(),
		    nextFrame = false,
		    willPrune = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded) { continue; }

			var fade = Math.min(1, (now - tile.loaded) / 200);

			setOpacity(tile.el, fade);
			if (fade < 1) {
				nextFrame = true;
			} else {
				if (tile.active) {
					willPrune = true;
				} else {
					this._onOpaqueTile(tile);
				}
				tile.active = true;
			}
		}

		if (willPrune && !this._noPrune) { this._pruneTiles(); }

		if (nextFrame) {
			cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
		}
	},

	_onOpaqueTile: falseFn,

	_initContainer: function () {
		if (this._container) { return; }

		this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function () {

		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom;

		if (zoom === undefined) { return undefined; }

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
				this._onUpdateLevel(z);
			} else {
				remove(this._levels[z].el);
				this._removeTilesAtZoom(z);
				this._onRemoveLevel(z);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
		    map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			falseFn(level.el.offsetWidth);

			this._onCreateLevel(level);
		}

		this._level = level;

		return level;
	},

	_onUpdateLevel: falseFn,

	_onRemoveLevel: falseFn,

	_onCreateLevel: falseFn,

	_pruneTiles: function () {
		if (!this._map) {
			return;
		}

		var key, tile;

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom ||
			zoom < this.options.minZoom) {
			this._removeAllTiles();
			return;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeTilesAtZoom: function (zoom) {
		for (var key in this._tiles) {
			if (this._tiles[key].coords.z !== zoom) {
				continue;
			}
			this._removeTile(key);
		}
	},

	_removeAllTiles: function () {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_invalidateAll: function () {
		for (var z in this._levels) {
			remove(this._levels[z].el);
			this._onRemoveLevel(z);
			delete this._levels[z];
		}
		this._removeAllTiles();

		this._tileZoom = undefined;
	},

	_retainParent: function (x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
		    y2 = Math.floor(y / 2),
		    z2 = z - 1,
		    coords2 = new Point(+x2, +y2);
		coords2.z = +z2;

		var key = this._tileCoordsToKey(coords2),
		    tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;

		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function (x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var coords = new Point(i, j);
				coords.z = z + 1;

				var key = this._tileCoordsToKey(coords),
				    tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;

				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_resetView: function (e) {
		var animating = e && (e.pinch || e.flyTo);
		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
	},

	_animateZoom: function (e) {
		this._setView(e.center, e.zoom, true, e.noUpdate);
	},

	_clampZoom: function (zoom) {
		var options = this.options;

		if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
			return options.minNativeZoom;
		}

		if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
			return options.maxNativeZoom;
		}

		return zoom;
	},

	_setView: function (center, zoom, noPrune, noUpdate) {
		var tileZoom = this._clampZoom(Math.round(zoom));
		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
		    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
			tileZoom = undefined;
		}

		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

		if (!noUpdate || tileZoomChanged) {

			this._tileZoom = tileZoom;

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._updateLevels();
			this._resetGrid();

			if (tileZoom !== undefined) {
				this._update(center);
			}

			if (!noPrune) {
				this._pruneTiles();
			}

			// Flag to prevent _updateOpacity from pruning tiles during
			// a zoom anim or a pinch gesture
			this._noPrune = !!noPrune;
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function (center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function (level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
		    translate = level.origin.multiplyBy(scale)
		        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		if (any3d) {
			setTransform(level.el, translate, scale);
		} else {
			setPosition(level.el, translate);
		}
	},

	_resetGrid: function () {
		var map = this._map,
		    crs = map.options.crs,
		    tileSize = this._tileSize = this.getTileSize(),
		    tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && !this.options.noWrap && [
			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
		];
		this._wrapY = crs.wrapLat && !this.options.noWrap && [
			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
		];
	},

	_onMoveEnd: function () {
		if (!this._map || this._map._animatingZoom) { return; }

		this._update();
	},

	_getTiledPixelBounds: function (center) {
		var map = this._map,
		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
		    scale = map.getZoomScale(mapZoom, this._tileZoom),
		    pixelCenter = map.project(center, this._tileZoom).floor(),
		    halfSize = map.getSize().divideBy(scale * 2);

		return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
	},

	// Private method to load tiles in the grid's active zoom level according to map bounds
	_update: function (center) {
		var map = this._map;
		if (!map) { return; }
		var zoom = this._clampZoom(map.getZoom());

		if (center === undefined) { center = map.getCenter(); }
		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

		var pixelBounds = this._getTiledPixelBounds(center),
		    tileRange = this._pxBoundsToTileRange(pixelBounds),
		    tileCenter = tileRange.getCenter(),
		    queue = [],
		    margin = this.options.keepBuffer,
		    noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
		                              tileRange.getTopRight().add([margin, -margin]));

		// Sanity check: panic if the tile range contains Infinity somewhere.
		if (!(isFinite(tileRange.min.x) &&
		      isFinite(tileRange.min.y) &&
		      isFinite(tileRange.max.x) &&
		      isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }

		for (var key in this._tiles) {
			var c = this._tiles[key].coords;
			if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
				this._tiles[key].current = false;
			}
		}

		// _update just loads more tiles. If the tile zoom level differs too much
		// from the map's, let _setView reset levels and prune old tiles.
		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new Point(i, j);
				coords.z = this._tileZoom;

				if (!this._isValidTile(coords)) { continue; }

				var tile = this._tiles[this._tileCoordsToKey(coords)];
				if (tile) {
					tile.current = true;
				} else {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if it's the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				// @event loading: Event
				// Fired when the grid layer starts loading tiles.
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function (coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
		}

		if (!this.options.bounds) { return true; }

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
	},

	_keyToBounds: function (key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	_tileCoordsToNwSe: function (coords) {
		var map = this._map,
		    tileSize = this.getTileSize(),
		    nwPoint = coords.scaleBy(tileSize),
		    sePoint = nwPoint.add(tileSize),
		    nw = map.unproject(nwPoint, coords.z),
		    se = map.unproject(sePoint, coords.z);
		return [nw, se];
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function (coords) {
		var bp = this._tileCoordsToNwSe(coords),
		    bounds = new LatLngBounds(bp[0], bp[1]);

		if (!this.options.noWrap) {
			bounds = this._map.wrapLatLngBounds(bounds);
		}
		return bounds;
	},
	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function (coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function (key) {
		var k = key.split(':'),
		    coords = new Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		remove(tile.el);

		delete this._tiles[key];

		// @event tileunload: TileEvent
		// Fired when a tile is removed (e.g. when a tile goes off the screen).
		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function (tile) {
		addClass(tile, 'leaflet-tile');

		var tileSize = this.getTileSize();
		tile.style.width = tileSize.x + 'px';
		tile.style.height = tileSize.y + 'px';

		tile.onselectstart = falseFn;
		tile.onmousemove = falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (ielt9 && this.options.opacity < 1) {
			setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (android && !android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function (coords, container) {
		var tilePos = this._getTilePos(coords),
		    key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
		}

		setPosition(tile, tilePos);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		// @event tileloadstart: TileEvent
		// Fired when a tile is requested and starts loading.
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function (coords, err, tile) {
		if (err) {
			// @event tileerror: TileErrorEvent
			// Fired when there is an error loading a tile.
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) { return; }

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			setOpacity(tile.el, 0);
			cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		if (!err) {
			addClass(tile.el, 'leaflet-tile-loaded');

			// @event tileload: TileEvent
			// Fired when a tile loads.
			this.fire('tileload', {
				tile: tile.el,
				coords: coords
			});
		}

		if (this._noTilesToLoad()) {
			this._loading = false;
			// @event load: Event
			// Fired when the grid layer loaded all visible tiles.
			this.fire('load');

			if (ielt9 || !this._map._fadeAnimated) {
				requestAnimFrame(this._pruneTiles, this);
			} else {
				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
				// to trigger a pruning.
				setTimeout(bind(this._pruneTiles, this), 250);
			}
		}
	},

	_getTilePos: function (coords) {
		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
	},

	_wrapCoords: function (coords) {
		var newCoords = new Point(
			this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
			this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function (bounds) {
		var tileSize = this.getTileSize();
		return new Bounds(
			bounds.min.unscaleBy(tileSize).floor(),
			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function () {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) { return false; }
		}
		return true;
	}
});

// @factory L.gridLayer(options?: GridLayer options)
// Creates a new instance of GridLayer with the supplied options.
function gridLayer(options) {
	return new GridLayer(options);
}

/*
 * @class TileLayer
 * @inherits GridLayer
 * @aka L.TileLayer
 * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
 *
 * @example
 *
 * ```js
 * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'}).addTo(map);
 * ```
 *
 * @section URL template
 * @example
 *
 * A string of the following form:
 *
 * ```
 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
 * ```
 *
 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
 *
 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
 *
 * ```
 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
 * ```
 */


var TileLayer = GridLayer.extend({

	// @section
	// @aka TileLayer options
	options: {
		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = 18
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: 18,

		// @option subdomains: String|String[] = 'abc'
		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		subdomains: 'abc',

		// @option errorTileUrl: String = ''
		// URL to the tile image to show in place of the tile that failed to load.
		errorTileUrl: '',

		// @option zoomOffset: Number = 0
		// The zoom number used in tile URLs will be offset with this value.
		zoomOffset: 0,

		// @option tms: Boolean = false
		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
		tms: false,

		// @option zoomReverse: Boolean = false
		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
		zoomReverse: false,

		// @option detectRetina: Boolean = false
		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
		detectRetina: false,

		// @option crossOrigin: Boolean|String = false
		// Whether the crossOrigin attribute will be added to the tiles.
		// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
		crossOrigin: false
	},

	initialize: function (url, options) {

		this._url = url;

		options = setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	// If the URL does not change, the layer will not be redrawn unless
	// the noRedraw parameter is set to false.
	setUrl: function (url, noRedraw) {
		if (this._url === url && noRedraw === undefined) {
			noRedraw = true;
		}

		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function (coords, done) {
		var tile = document.createElement('img');

		on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
		on(tile, 'error', bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin || this.options.crossOrigin === '') {
			tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
		}

		/*
		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
		 http://www.w3.org/TR/WCAG20-TECHS/H67
		*/
		tile.alt = '';

		/*
		 Set role="presentation" to force screen readers to ignore this
		 https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
		*/
		tile.setAttribute('role', 'presentation');

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	// @section Extension methods
	// @uninheritable
	// Layers extending `TileLayer` might reimplement the following method.
	// @method getTileUrl(coords: Object): String
	// Called only internally, returns the URL for a tile given its coordinates.
	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
	getTileUrl: function (coords) {
		var data = {
			r: retina ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: this._getZoomForUrl()
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) {
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		return template(this._url, extend(data, this.options));
	},

	_tileOnLoad: function (done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (ielt9) {
			setTimeout(bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function (done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl && tile.getAttribute('src') !== errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	_onTileRemove: function (e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function () {
		var zoom = this._tileZoom,
		maxZoom = this.options.maxZoom,
		zoomReverse = this.options.zoomReverse,
		zoomOffset = this.options.zoomOffset;

		if (zoomReverse) {
			zoom = maxZoom - zoom;
		}

		return zoom + zoomOffset;
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function () {
		var i, tile;
		for (i in this._tiles) {
			if (this._tiles[i].coords.z !== this._tileZoom) {
				tile = this._tiles[i].el;

				tile.onload = falseFn;
				tile.onerror = falseFn;

				if (!tile.complete) {
					tile.src = emptyImageUrl;
					remove(tile);
					delete this._tiles[i];
				}
			}
		}
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		// Cancels any pending http requests associated with the tile
		// unless we're on Android's stock browser,
		// see https://github.com/Leaflet/Leaflet/issues/137
		if (!androidStock) {
			tile.el.setAttribute('src', emptyImageUrl);
		}

		return GridLayer.prototype._removeTile.call(this, key);
	},

	_tileReady: function (coords, err, tile) {
		if (!this._map || (tile && tile.getAttribute('src') === emptyImageUrl)) {
			return;
		}

		return GridLayer.prototype._tileReady.call(this, coords, err, tile);
	}
});


// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
// Instantiates a tile layer object given a `URL template` and optionally an options object.

function tileLayer(url, options) {
	return new TileLayer(url, options);
}

/*
 * @class TileLayer.WMS
 * @inherits TileLayer
 * @aka L.TileLayer.WMS
 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
 *
 * @example
 *
 * ```js
 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
 * 	layers: 'nexrad-n0r-900913',
 * 	format: 'image/png',
 * 	transparent: true,
 * 	attribution: "Weather data © 2012 IEM Nexrad"
 * });
 * ```
 */

var TileLayerWMS = TileLayer.extend({

	// @section
	// @aka TileLayer.WMS options
	// If any custom options not documented here are used, they will be sent to the
	// WMS server as extra parameters in each request URL. This can be useful for
	// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',

		// @option layers: String = ''
		// **(required)** Comma-separated list of WMS layers to show.
		layers: '',

		// @option styles: String = ''
		// Comma-separated list of WMS styles.
		styles: '',

		// @option format: String = 'image/jpeg'
		// WMS image format (use `'image/png'` for layers with transparency).
		format: 'image/jpeg',

		// @option transparent: Boolean = false
		// If `true`, the WMS service will return images with transparency.
		transparent: false,

		// @option version: String = '1.1.1'
		// Version of the WMS service to use
		version: '1.1.1'
	},

	options: {
		// @option crs: CRS = null
		// Coordinate Reference System to use for the WMS requests, defaults to
		// map CRS. Don't change this if you're not sure what it means.
		crs: null,

		// @option uppercase: Boolean = false
		// If `true`, WMS request parameter keys will be uppercase.
		uppercase: false
	},

	initialize: function (url, options) {

		this._url = url;

		var wmsParams = extend({}, this.defaultWmsParams);

		// all keys that are not TileLayer options go to WMS params
		for (var i in options) {
			if (!(i in this.options)) {
				wmsParams[i] = options[i];
			}
		}

		options = setOptions(this, options);

		var realRetina = options.detectRetina && retina ? 2 : 1;
		var tileSize = this.getTileSize();
		wmsParams.width = tileSize.x * realRetina;
		wmsParams.height = tileSize.y * realRetina;

		this.wmsParams = wmsParams;
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;
		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (coords) {

		var tileBounds = this._tileCoordsToNwSe(coords),
		    crs = this._crs,
		    bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
		    min = bounds.min,
		    max = bounds.max,
		    bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ?
		    [min.y, min.x, max.y, max.x] :
		    [min.x, min.y, max.x, max.y]).join(','),
		    url = TileLayer.prototype.getTileUrl.call(this, coords);
		return url +
			getParamString(this.wmsParams, url, this.options.uppercase) +
			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
	},

	// @method setParams(params: Object, noRedraw?: Boolean): this
	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
	setParams: function (params, noRedraw) {

		extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});


// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
function tileLayerWMS(url, options) {
	return new TileLayerWMS(url, options);
}

TileLayer.WMS = TileLayerWMS;
tileLayer.wms = tileLayerWMS;

/*
 * @class Renderer
 * @inherits Layer
 * @aka L.Renderer
 *
 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
 * DOM container of the renderer, its bounds, and its zoom animation.
 *
 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
 * itself can be added or removed to the map. All paths use a renderer, which can
 * be implicit (the map will decide the type of renderer and use it automatically)
 * or explicit (using the [`renderer`](#path-renderer) option of the path).
 *
 * Do not use this class directly, use `SVG` and `Canvas` instead.
 *
 * @event update: Event
 * Fired when the renderer updates its bounds, center and zoom, for example when
 * its map has moved
 */

var Renderer = Layer.extend({

	// @section
	// @aka Renderer options
	options: {
		// @option padding: Number = 0.1
		// How much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction
		padding: 0.1,

		// @option tolerance: Number = 0
		// How much to extend click tolerance round a path/object on the map
		tolerance : 0
	},

	initialize: function (options) {
		setOptions(this, options);
		stamp(this);
		this._layers = this._layers || {};
	},

	onAdd: function () {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
		this.on('update', this._updatePaths, this);
	},

	onRemove: function () {
		this.off('update', this._updatePaths, this);
		this._destroyContainer();
	},

	getEvents: function () {
		var events = {
			viewreset: this._reset,
			zoom: this._onZoom,
			moveend: this._update,
			zoomend: this._onZoomEnd
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._onAnimZoom;
		}
		return events;
	},

	_onAnimZoom: function (ev) {
		this._updateTransform(ev.center, ev.zoom);
	},

	_onZoom: function () {
		this._updateTransform(this._map.getCenter(), this._map.getZoom());
	},

	_updateTransform: function (center, zoom) {
		var scale = this._map.getZoomScale(zoom, this._zoom),
		    position = getPosition(this._container),
		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
		    currentCenterPoint = this._map.project(this._center, zoom),
		    destCenterPoint = this._map.project(center, zoom),
		    centerOffset = destCenterPoint.subtract(currentCenterPoint),

		    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

		if (any3d) {
			setTransform(this._container, topLeftOffset, scale);
		} else {
			setPosition(this._container, topLeftOffset);
		}
	},

	_reset: function () {
		this._update();
		this._updateTransform(this._center, this._zoom);

		for (var id in this._layers) {
			this._layers[id]._reset();
		}
	},

	_onZoomEnd: function () {
		for (var id in this._layers) {
			this._layers[id]._project();
		}
	},

	_updatePaths: function () {
		for (var id in this._layers) {
			this._layers[id]._update();
		}
	},

	_update: function () {
		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
		// Subclasses are responsible of firing the 'update' event.
		var p = this.options.padding,
		    size = this._map.getSize(),
		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

		this._center = this._map.getCenter();
		this._zoom = this._map.getZoom();
	}
});

/*
 * @class Canvas
 * @inherits Renderer
 * @aka L.Canvas
 *
 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
 * available in all web browsers, notably IE8, and overlapping geometries might
 * not display properly in some edge cases.
 *
 * @example
 *
 * Use Canvas by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.canvas()
 * });
 * ```
 *
 * Use a Canvas renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.canvas({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var Canvas = Renderer.extend({
	getEvents: function () {
		var events = Renderer.prototype.getEvents.call(this);
		events.viewprereset = this._onViewPreReset;
		return events;
	},

	_onViewPreReset: function () {
		// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
		this._postponeUpdatePaths = true;
	},

	onAdd: function () {
		Renderer.prototype.onAdd.call(this);

		// Redraw vectors since canvas is cleared upon removal,
		// in case of removing the renderer itself from the map.
		this._draw();
	},

	_initContainer: function () {
		var container = this._container = document.createElement('canvas');

		on(container, 'mousemove', this._onMouseMove, this);
		on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
		on(container, 'mouseout', this._handleMouseOut, this);

		this._ctx = container.getContext('2d');
	},

	_destroyContainer: function () {
		cancelAnimFrame(this._redrawRequest);
		delete this._ctx;
		remove(this._container);
		off(this._container);
		delete this._container;
	},

	_updatePaths: function () {
		if (this._postponeUpdatePaths) { return; }

		var layer;
		this._redrawBounds = null;
		for (var id in this._layers) {
			layer = this._layers[id];
			layer._update();
		}
		this._redraw();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		Renderer.prototype._update.call(this);

		var b = this._bounds,
		    container = this._container,
		    size = b.getSize(),
		    m = retina ? 2 : 1;

		setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);

		// Tell paths to redraw themselves
		this.fire('update');
	},

	_reset: function () {
		Renderer.prototype._reset.call(this);

		if (this._postponeUpdatePaths) {
			this._postponeUpdatePaths = false;
			this._updatePaths();
		}
	},

	_initPath: function (layer) {
		this._updateDashArray(layer);
		this._layers[stamp(layer)] = layer;

		var order = layer._order = {
			layer: layer,
			prev: this._drawLast,
			next: null
		};
		if (this._drawLast) { this._drawLast.next = order; }
		this._drawLast = order;
		this._drawFirst = this._drawFirst || this._drawLast;
	},

	_addPath: function (layer) {
		this._requestRedraw(layer);
	},

	_removePath: function (layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			this._drawLast = prev;
		}
		if (prev) {
			prev.next = next;
		} else {
			this._drawFirst = next;
		}

		delete layer._order;

		delete this._layers[stamp(layer)];

		this._requestRedraw(layer);
	},

	_updatePath: function (layer) {
		// Redraw the union of the layer's old pixel
		// bounds and the new pixel bounds.
		this._extendRedrawBounds(layer);
		layer._project();
		layer._update();
		// The redraw will extend the redraw bounds
		// with the new pixel bounds.
		this._requestRedraw(layer);
	},

	_updateStyle: function (layer) {
		this._updateDashArray(layer);
		this._requestRedraw(layer);
	},

	_updateDashArray: function (layer) {
		if (typeof layer.options.dashArray === 'string') {
			var parts = layer.options.dashArray.split(/[, ]+/),
			    dashArray = [],
			    dashValue,
			    i;
			for (i = 0; i < parts.length; i++) {
				dashValue = Number(parts[i]);
				// Ignore dash array containing invalid lengths
				if (isNaN(dashValue)) { return; }
				dashArray.push(dashValue);
			}
			layer.options._dashArray = dashArray;
		} else {
			layer.options._dashArray = layer.options.dashArray;
		}
	},

	_requestRedraw: function (layer) {
		if (!this._map) { return; }

		this._extendRedrawBounds(layer);
		this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
	},

	_extendRedrawBounds: function (layer) {
		if (layer._pxBounds) {
			var padding = (layer.options.weight || 0) + 1;
			this._redrawBounds = this._redrawBounds || new Bounds();
			this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
			this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
		}
	},

	_redraw: function () {
		this._redrawRequest = null;

		if (this._redrawBounds) {
			this._redrawBounds.min._floor();
			this._redrawBounds.max._ceil();
		}

		this._clear(); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_clear: function () {
		var bounds = this._redrawBounds;
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
		} else {
			this._ctx.clearRect(0, 0, this._container.width, this._container.height);
		}
	},

	_draw: function () {
		var layer, bounds = this._redrawBounds;
		this._ctx.save();
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.beginPath();
			this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
			this._ctx.clip();
		}

		this._drawing = true;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
				layer._updatePath();
			}
		}

		this._drawing = false;

		this._ctx.restore();  // Restore state before clipping.
	},

	_updatePoly: function (layer, closed) {
		if (!this._drawing) { return; }

		var i, j, len2, p,
		    parts = layer._parts,
		    len = parts.length,
		    ctx = this._ctx;

		if (!len) { return; }

		ctx.beginPath();

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function (layer) {

		if (!this._drawing || layer._empty()) { return; }

		var p = layer._point,
		    ctx = this._ctx,
		    r = Math.max(Math.round(layer._radius), 1),
		    s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function (ctx, layer) {
		var options = layer.options;

		if (options.fill) {
			ctx.globalAlpha = options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			if (ctx.setLineDash) {
				ctx.setLineDash(layer.options && layer.options._dashArray || []);
			}
			ctx.globalAlpha = options.opacity;
			ctx.lineWidth = options.weight;
			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				clickedLayer = layer;
			}
		}
		if (clickedLayer)  {
			fakeStop(e);
			this._fireEvent([clickedLayer], e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e);
		this._handleMouseHover(e, point);
	},


	_handleMouseOut: function (e) {
		var layer = this._hoveredLayer;
		if (layer) {
			// if we're leaving the layer, fire mouseout
			removeClass(this._container, 'leaflet-interactive');
			this._fireEvent([layer], e, 'mouseout');
			this._hoveredLayer = null;
			this._mouseHoverThrottled = false;
		}
	},

	_handleMouseHover: function (e, point) {
		if (this._mouseHoverThrottled) {
			return;
		}

		var layer, candidateHoveredLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point)) {
				candidateHoveredLayer = layer;
			}
		}

		if (candidateHoveredLayer !== this._hoveredLayer) {
			this._handleMouseOut(e);

			if (candidateHoveredLayer) {
				addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent([candidateHoveredLayer], e, 'mouseover');
				this._hoveredLayer = candidateHoveredLayer;
			}
		}

		if (this._hoveredLayer) {
			this._fireEvent([this._hoveredLayer], e);
		}

		this._mouseHoverThrottled = true;
		setTimeout(L.bind(function () {
			this._mouseHoverThrottled = false;
		}, this), 32);
	},

	_fireEvent: function (layers, e, type) {
		this._map._fireDOMEvent(e, type || e.type, layers);
	},

	_bringToFront: function (layer) {
		var order = layer._order;

		if (!order) { return; }

		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			// Already last
			return;
		}
		if (prev) {
			prev.next = next;
		} else if (next) {
			// Update first entry unless this is the
			// single entry
			this._drawFirst = next;
		}

		order.prev = this._drawLast;
		this._drawLast.next = order;

		order.next = null;
		this._drawLast = order;

		this._requestRedraw(layer);
	},

	_bringToBack: function (layer) {
		var order = layer._order;

		if (!order) { return; }

		var next = order.next;
		var prev = order.prev;

		if (prev) {
			prev.next = next;
		} else {
			// Already first
			return;
		}
		if (next) {
			next.prev = prev;
		} else if (prev) {
			// Update last entry unless this is the
			// single entry
			this._drawLast = prev;
		}

		order.prev = null;

		order.next = this._drawFirst;
		this._drawFirst.prev = order;
		this._drawFirst = order;

		this._requestRedraw(layer);
	}
});

// @factory L.canvas(options?: Renderer options)
// Creates a Canvas renderer with the given options.
function canvas$1(options) {
	return canvas ? new Canvas(options) : null;
}

/*
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */


var vmlCreate = (function () {
	try {
		document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
		return function (name) {
			return document.createElement('<lvml:' + name + ' class="lvml">');
		};
	} catch (e) {
		return function (name) {
			return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
		};
	}
})();


/*
 * @class SVG
 *
 *
 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
 * with old versions of Internet Explorer.
 */

// mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
var vmlMixin = {

	_initContainer: function () {
		this._container = create$1('div', 'leaflet-vml-container');
	},

	_update: function () {
		if (this._map._animatingZoom) { return; }
		Renderer.prototype._update.call(this);
		this.fire('update');
	},

	_initPath: function (layer) {
		var container = layer._container = vmlCreate('shape');

		addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = vmlCreate('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
		this._layers[stamp(layer)] = layer;
	},

	_addPath: function (layer) {
		var container = layer._container;
		this._container.appendChild(container);

		if (layer.options.interactive) {
			layer.addInteractiveTarget(container);
		}
	},

	_removePath: function (layer) {
		var container = layer._container;
		remove(container);
		layer.removeInteractiveTarget(container);
		delete this._layers[stamp(layer)];
	},

	_updateStyle: function (layer) {
		var stroke = layer._stroke,
		    fill = layer._fill,
		    options = layer.options,
		    container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = vmlCreate('stroke');
			}
			container.appendChild(stroke);
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;

		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = vmlCreate('fill');
			}
			container.appendChild(fill);
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function (layer) {
		var p = layer._point.round(),
		    r = Math.round(layer._radius),
		    r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' :
			'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
	},

	_setPath: function (layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function (layer) {
		toFront(layer._container);
	},

	_bringToBack: function (layer) {
		toBack(layer._container);
	}
};

var create$2 = vml ? vmlCreate : svgCreate;

/*
 * @class SVG
 * @inherits Renderer
 * @aka L.SVG
 *
 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
 * available in all web browsers, notably Android 2.x and 3.x.
 *
 * Although SVG is not available on IE7 and IE8, these browsers support
 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
 * (a now deprecated technology), and the SVG renderer will fall back to VML in
 * this case.
 *
 * @example
 *
 * Use SVG by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.svg()
 * });
 * ```
 *
 * Use a SVG renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.svg({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var SVG = Renderer.extend({

	getEvents: function () {
		var events = Renderer.prototype.getEvents.call(this);
		events.zoomstart = this._onZoomStart;
		return events;
	},

	_initContainer: function () {
		this._container = create$2('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');

		this._rootGroup = create$2('g');
		this._container.appendChild(this._rootGroup);
	},

	_destroyContainer: function () {
		remove(this._container);
		off(this._container);
		delete this._container;
		delete this._rootGroup;
		delete this._svgSize;
	},

	_onZoomStart: function () {
		// Drag-then-pinch interactions might mess up the center and zoom.
		// In this case, the easiest way to prevent this is re-do the renderer
		//   bounds and padding when the zooming starts.
		this._update();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		Renderer.prototype._update.call(this);

		var b = this._bounds,
		    size = b.getSize(),
		    container = this._container;

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

		this.fire('update');
	},

	// methods below are called by vector layers implementations

	_initPath: function (layer) {
		var path = layer._path = create$2('path');

		// @namespace Path
		// @option className: String = null
		// Custom class name set on an element. Only for SVG renderer.
		if (layer.options.className) {
			addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
		this._layers[stamp(layer)] = layer;
	},

	_addPath: function (layer) {
		if (!this._rootGroup) { this._initContainer(); }
		this._rootGroup.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function (layer) {
		remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
		delete this._layers[stamp(layer)];
	},

	_updatePath: function (layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function (layer) {
		var path = layer._path,
		    options = layer.options;

		if (!path) { return; }

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}
	},

	_updatePoly: function (layer, closed) {
		this._setPath(layer, pointsToPath(layer._parts, closed));
	},

	_updateCircle: function (layer) {
		var p = layer._point,
		    r = Math.max(Math.round(layer._radius), 1),
		    r2 = Math.max(Math.round(layer._radiusY), 1) || r,
		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' :
			'M' + (p.x - r) + ',' + p.y +
			arc + (r * 2) + ',0 ' +
			arc + (-r * 2) + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function (layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function (layer) {
		toFront(layer._path);
	},

	_bringToBack: function (layer) {
		toBack(layer._path);
	}
});

if (vml) {
	SVG.include(vmlMixin);
}

// @namespace SVG
// @factory L.svg(options?: Renderer options)
// Creates a SVG renderer with the given options.
function svg$1(options) {
	return svg || vml ? new SVG(options) : null;
}

Map.include({
	// @namespace Map; @method getRenderer(layer: Path): Renderer
	// Returns the instance of `Renderer` that should be used to render the given
	// `Path`. It will ensure that the `renderer` options of the map and paths
	// are respected, and that the renderers do exist on the map.
	getRenderer: function (layer) {
		// @namespace Path; @option renderer: Renderer
		// Use this specific instance of `Renderer` for this path. Takes
		// precedence over the map's [default renderer](#map-renderer).
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			renderer = this._renderer = this._createRenderer();
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function (name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = this._createRenderer({pane: name});
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	},

	_createRenderer: function (options) {
		// @namespace Map; @option preferCanvas: Boolean = false
		// Whether `Path`s should be rendered on a `Canvas` renderer.
		// By default, all `Path`s are rendered in a `SVG` renderer.
		return (this.options.preferCanvas && canvas$1(options)) || svg$1(options);
	}
});

/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

/*
 * @class Rectangle
 * @aka L.Rectangle
 * @inherits Polygon
 *
 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
 *
 * @example
 *
 * ```js
 * // define rectangle geographical bounds
 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
 *
 * // create an orange rectangle
 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
 *
 * // zoom the map to the rectangle bounds
 * map.fitBounds(bounds);
 * ```
 *
 */


var Rectangle = Polygon.extend({
	initialize: function (latLngBounds, options) {
		Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	// @method setBounds(latLngBounds: LatLngBounds): this
	// Redraws the rectangle with the passed bounds.
	setBounds: function (latLngBounds) {
		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = toLatLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});


// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
function rectangle(latLngBounds, options) {
	return new Rectangle(latLngBounds, options);
}

SVG.create = create$2;
SVG.pointsToPath = pointsToPath;

GeoJSON.geometryToLayer = geometryToLayer;
GeoJSON.coordsToLatLng = coordsToLatLng;
GeoJSON.coordsToLatLngs = coordsToLatLngs;
GeoJSON.latLngToCoords = latLngToCoords;
GeoJSON.latLngsToCoords = latLngsToCoords;
GeoJSON.getFeature = getFeature;
GeoJSON.asFeature = asFeature;

/*
 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
 * (zoom to a selected bounding box), enabled by default.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @option boxZoom: Boolean = true
	// Whether the map can be zoomed to a rectangular area specified by
	// dragging the mouse while pressing the shift key.
	boxZoom: true
});

var BoxZoom = Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
		this._resetStateTimeout = 0;
		map.on('unload', this._destroy, this);
	},

	addHooks: function () {
		on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function () {
		return this._moved;
	},

	_destroy: function () {
		remove(this._pane);
		delete this._pane;
	},

	_resetState: function () {
		this._resetStateTimeout = 0;
		this._moved = false;
	},

	_clearDeferredResetState: function () {
		if (this._resetStateTimeout !== 0) {
			clearTimeout(this._resetStateTimeout);
			this._resetStateTimeout = 0;
		}
	},

	_onMouseDown: function (e) {
		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		// Clear the deferred resetState if it hasn't executed yet, otherwise it
		// will interrupt the interaction and orphan a box element in the container.
		this._clearDeferredResetState();
		this._resetState();

		disableTextSelection();
		disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		on(document, {
			contextmenu: stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._moved = true;

			this._box = create$1('div', 'leaflet-zoom-box', this._container);
			addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new Bounds(this._point, this._startPoint),
		    size = bounds.getSize();

		setPosition(this._box, bounds.min);

		this._box.style.width  = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function () {
		if (this._moved) {
			remove(this._box);
			removeClass(this._container, 'leaflet-crosshair');
		}

		enableTextSelection();
		enableImageDrag();

		off(document, {
			contextmenu: stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function (e) {
		if ((e.which !== 1) && (e.button !== 1)) { return; }

		this._finish();

		if (!this._moved) { return; }
		// Postpone to next JS tick so internal click event handling
		// still see it as "moved".
		this._clearDeferredResetState();
		this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);

		var bounds = new LatLngBounds(
		        this._map.containerPointToLatLng(this._startPoint),
		        this._map.containerPointToLatLng(this._point));

		this._map
			.fitBounds(bounds)
			.fire('boxzoomend', {boxZoomBounds: bounds});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

// @section Handlers
// @property boxZoom: Handler
// Box (shift-drag with mouse) zoom handler.
Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

// @namespace Map
// @section Interaction Options

Map.mergeOptions({
	// @option doubleClickZoom: Boolean|String = true
	// Whether the map can be zoomed in by double clicking on it and
	// zoomed out by double clicking while holding shift. If passed
	// `'center'`, double-click zoom will zoom to the center of the
	//  view regardless of where the mouse was.
	doubleClickZoom: true
});

var DoubleClickZoom = Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    oldZoom = map.getZoom(),
		    delta = map.options.zoomDelta,
		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

// @section Handlers
//
// Map properties include interaction handlers that allow you to control
// interaction behavior in runtime, enabling or disabling certain features such
// as dragging or touch zoom (see `Handler` methods). For example:
//
// ```js
// map.doubleClickZoom.disable();
// ```
//
// @property doubleClickZoom: Handler
// Double click zoom handler.
Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @option dragging: Boolean = true
	// Whether the map be draggable with mouse/touch or not.
	dragging: true,

	// @section Panning Inertia Options
	// @option inertia: Boolean = *
	// If enabled, panning of the map will have an inertia effect where
	// the map builds momentum while dragging and continues moving in
	// the same direction for some time. Feels especially nice on touch
	// devices. Enabled by default unless running on old Android devices.
	inertia: !android23,

	// @option inertiaDeceleration: Number = 3000
	// The rate with which the inertial movement slows down, in pixels/second².
	inertiaDeceleration: 3400, // px/s^2

	// @option inertiaMaxSpeed: Number = Infinity
	// Max speed of the inertial movement, in pixels/second.
	inertiaMaxSpeed: Infinity, // px/s

	// @option easeLinearity: Number = 0.2
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	// @option worldCopyJump: Boolean = false
	// With this option enabled, the map tracks when you pan to another "copy"
	// of the world and seamlessly jumps to the original one so that all overlays
	// like markers and vector layers are still visible.
	worldCopyJump: false,

	// @option maxBoundsViscosity: Number = 0.0
	// If `maxBounds` is set, this option will control how solid the bounds
	// are when dragging the map around. The default value of `0.0` allows the
	// user to drag outside the bounds at normal speed, higher values will
	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
	// solid, preventing the user from dragging outside the bounds.
	maxBoundsViscosity: 0.0
});

var Drag = Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new Draggable(map._mapPane, map._container);

			this._draggable.on({
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			this._draggable.on('predrag', this._onPreDragLimit, this);
			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDragWrap, this);
				map.on('zoomend', this._onZoomEnd, this);

				map.whenReady(this._onZoomEnd, this);
			}
		}
		addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
		this._draggable.enable();
		this._positions = [];
		this._times = [];
	},

	removeHooks: function () {
		removeClass(this._map._container, 'leaflet-grab');
		removeClass(this._map._container, 'leaflet-touch-drag');
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	moving: function () {
		return this._draggable && this._draggable._moving;
	},

	_onDragStart: function () {
		var map = this._map;

		map._stop();
		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
			var bounds = toLatLngBounds(this._map.options.maxBounds);

			this._offsetLimit = toBounds(
				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
					.add(this._map.getSize()));

			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
		} else {
			this._offsetLimit = null;
		}

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function (e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			this._prunePositions(time);
		}

		this._map
		    .fire('move', e)
		    .fire('drag', e);
	},

	_prunePositions: function (time) {
		while (this._positions.length > 1 && time - this._times[0] > 50) {
			this._positions.shift();
			this._times.shift();
		}
	},

	_onZoomEnd: function () {
		var pxCenter = this._map.getSize().divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_viscousLimit: function (value, threshold) {
		return value - (value - threshold) * this._viscosity;
	},

	_onPreDragLimit: function () {
		if (!this._viscosity || !this._offsetLimit) { return; }

		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

		var limit = this._offsetLimit;
		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

		this._draggable._newPos = this._draggable._startPos.add(offset);
	},

	_onPreDragWrap: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,

		    noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {
			this._prunePositions(+new Date());

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x && !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

// @section Handlers
// @property dragging: Handler
// Map dragging handler (by both mouse and touch).
Map.addInitHook('addHandler', 'dragging', Drag);

/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

// @namespace Map
// @section Keyboard Navigation Options
Map.mergeOptions({
	// @option keyboard: Boolean = true
	// Makes the map focusable and allows users to navigate the map with keyboard
	// arrows and `+`/`-` keys.
	keyboard: true,

	// @option keyboardPanDelta: Number = 80
	// Amount of pixels to pan when pressing an arrow key.
	keyboardPanDelta: 80
});

var Keyboard = Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanDelta(map.options.keyboardPanDelta);
		this._setZoomDelta(map.options.zoomDelta);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex <= 0) {
			container.tabIndex = '0';
		}

		on(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function () {
		this._removeHooks();

		off(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanDelta: function (panDelta) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * panDelta, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [panDelta, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, panDelta];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * panDelta];
		}
	},

	_setZoomDelta: function (zoomDelta) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoomDelta;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoomDelta;
		}
	},

	_addHooks: function () {
		on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

		var key = e.keyCode,
		    map = this._map,
		    offset;

		if (key in this._panKeys) {
			if (!map._panAnim || !map._panAnim._inProgress) {
				offset = this._panKeys[key];
				if (e.shiftKey) {
					offset = toPoint(offset).multiplyBy(3);
				}

				map.panBy(offset);

				if (map.options.maxBounds) {
					map.panInsideBounds(map.options.maxBounds);
				}
			}
		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

		} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
			map.closePopup();

		} else {
			return;
		}

		stop(e);
	}
});

// @section Handlers
// @section Handlers
// @property keyboard: Handler
// Keyboard navigation handler.
Map.addInitHook('addHandler', 'keyboard', Keyboard);

/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @section Mousewheel options
	// @option scrollWheelZoom: Boolean|String = true
	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
	// it will zoom to the center of the view regardless of where the mouse was.
	scrollWheelZoom: true,

	// @option wheelDebounceTime: Number = 40
	// Limits the rate at which a wheel can fire (in milliseconds). By default
	// user can't zoom via wheel more often than once per 40 ms.
	wheelDebounceTime: 40,

	// @option wheelPxPerZoomLevel: Number = 60
	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
	// mean a change of one full zoom level. Smaller values will make wheel-zooming
	// faster (and vice versa).
	wheelPxPerZoomLevel: 60
});

var ScrollWheelZoom = Handler.extend({
	addHooks: function () {
		on(this._map._container, 'mousewheel', this._onWheelScroll, this);

		this._delta = 0;
	},

	removeHooks: function () {
		off(this._map._container, 'mousewheel', this._onWheelScroll, this);
	},

	_onWheelScroll: function (e) {
		var delta = getWheelDelta(e);

		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(bind(this._performZoom, this), left);

		stop(e);
	},

	_performZoom: function () {
		var map = this._map,
		    zoom = map.getZoom(),
		    snap = this._map.options.zoomSnap || 0;

		map._stop(); // stop panning and fly animations if any

		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

// @section Handlers
// @property scrollWheelZoom: Handler
// Scroll wheel zoom handler.
Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @section Touch interaction options
	// @option tap: Boolean = true
	// Enables mobile hacks for supporting instant taps (fixing 200ms click
	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
	tap: true,

	// @option tapTolerance: Number = 15
	// The max number of pixels a user can shift his finger during touch
	// for it to be considered a valid tap.
	tapTolerance: 15
});

var Tap = Handler.extend({
	addHooks: function () {
		on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new Point(first.clientX, first.clientY);
		this._simulateEvent('mousemove', first);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

// @section Handlers
// @property tap: Handler
// Mobile touch hacks (quick tap and touch hold) handler.
if (touch && !pointer) {
	Map.addInitHook('addHandler', 'tap', Tap);
}

/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @section Touch interaction options
	// @option touchZoom: Boolean|String = *
	// Whether the map can be zoomed by touch-dragging with two fingers. If
	// passed `'center'`, it will zoom to the center of the view regardless of
	// where the touch events (fingers) were. Enabled for touch-capable web
	// browsers except for old Androids.
	touchZoom: touch && !android23,

	// @option bounceAtZoomLimits: Boolean = true
	// Set it to false if you don't want the map to zoom beyond min/max zoom
	// and then bounce back when pinch-zooming.
	bounceAtZoomLimits: true
});

var TouchZoom = Handler.extend({
	addHooks: function () {
		addClass(this._map._container, 'leaflet-touch-zoom');
		on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		removeClass(this._map._container, 'leaflet-touch-zoom');
		off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

		this._centerPoint = map.getSize()._divideBy(2);
		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
		if (map.options.touchZoom !== 'center') {
			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
		}

		this._startDist = p1.distanceTo(p2);
		this._startZoom = map.getZoom();

		this._moved = false;
		this._zooming = true;

		map._stop();

		on(document, 'touchmove', this._onTouchMove, this);
		on(document, 'touchend', this._onTouchEnd, this);

		preventDefault(e);
	},

	_onTouchMove: function (e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var map = this._map,
		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
		    scale = p1.distanceTo(p2) / this._startDist;

		this._zoom = map.getScaleZoom(scale, this._startZoom);

		if (!map.options.bounceAtZoomLimits && (
			(this._zoom < map.getMinZoom() && scale < 1) ||
			(this._zoom > map.getMaxZoom() && scale > 1))) {
			this._zoom = map._limitZoom(this._zoom);
		}

		if (map.options.touchZoom === 'center') {
			this._center = this._startLatLng;
			if (scale === 1) { return; }
		} else {
			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
		}

		if (!this._moved) {
			map._moveStart(true, false);
			this._moved = true;
		}

		cancelAnimFrame(this._animRequest);

		var moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
		this._animRequest = requestAnimFrame(moveFn, this, true);

		preventDefault(e);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		cancelAnimFrame(this._animRequest);

		off(document, 'touchmove', this._onTouchMove);
		off(document, 'touchend', this._onTouchEnd);

		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
		if (this._map.options.zoomAnimation) {
			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
		} else {
			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
		}
	}
});

// @section Handlers
// @property touchZoom: Handler
// Touch zoom handler.
Map.addInitHook('addHandler', 'touchZoom', TouchZoom);

Map.BoxZoom = BoxZoom;
Map.DoubleClickZoom = DoubleClickZoom;
Map.Drag = Drag;
Map.Keyboard = Keyboard;
Map.ScrollWheelZoom = ScrollWheelZoom;
Map.Tap = Tap;
Map.TouchZoom = TouchZoom;

Object.freeze = freeze;

exports.version = version;
exports.Control = Control;
exports.control = control;
exports.Browser = Browser;
exports.Evented = Evented;
exports.Mixin = Mixin;
exports.Util = Util;
exports.Class = Class;
exports.Handler = Handler;
exports.extend = extend;
exports.bind = bind;
exports.stamp = stamp;
exports.setOptions = setOptions;
exports.DomEvent = DomEvent;
exports.DomUtil = DomUtil;
exports.PosAnimation = PosAnimation;
exports.Draggable = Draggable;
exports.LineUtil = LineUtil;
exports.PolyUtil = PolyUtil;
exports.Point = Point;
exports.point = toPoint;
exports.Bounds = Bounds;
exports.bounds = toBounds;
exports.Transformation = Transformation;
exports.transformation = toTransformation;
exports.Projection = index;
exports.LatLng = LatLng;
exports.latLng = toLatLng;
exports.LatLngBounds = LatLngBounds;
exports.latLngBounds = toLatLngBounds;
exports.CRS = CRS;
exports.GeoJSON = GeoJSON;
exports.geoJSON = geoJSON;
exports.geoJson = geoJson;
exports.Layer = Layer;
exports.LayerGroup = LayerGroup;
exports.layerGroup = layerGroup;
exports.FeatureGroup = FeatureGroup;
exports.featureGroup = featureGroup;
exports.ImageOverlay = ImageOverlay;
exports.imageOverlay = imageOverlay;
exports.VideoOverlay = VideoOverlay;
exports.videoOverlay = videoOverlay;
exports.SVGOverlay = SVGOverlay;
exports.svgOverlay = svgOverlay;
exports.DivOverlay = DivOverlay;
exports.Popup = Popup;
exports.popup = popup;
exports.Tooltip = Tooltip;
exports.tooltip = tooltip;
exports.Icon = Icon;
exports.icon = icon;
exports.DivIcon = DivIcon;
exports.divIcon = divIcon;
exports.Marker = Marker;
exports.marker = marker;
exports.TileLayer = TileLayer;
exports.tileLayer = tileLayer;
exports.GridLayer = GridLayer;
exports.gridLayer = gridLayer;
exports.SVG = SVG;
exports.svg = svg$1;
exports.Renderer = Renderer;
exports.Canvas = Canvas;
exports.canvas = canvas$1;
exports.Path = Path;
exports.CircleMarker = CircleMarker;
exports.circleMarker = circleMarker;
exports.Circle = Circle;
exports.circle = circle;
exports.Polyline = Polyline;
exports.polyline = polyline;
exports.Polygon = Polygon;
exports.polygon = polygon;
exports.Rectangle = Rectangle;
exports.rectangle = rectangle;
exports.Map = Map;
exports.map = createMap;

var oldL = window.L;
exports.noConflict = function() {
	window.L = oldL;
	return this;
}

// Always export us to window global (see #2364)
window.L = exports;

})));
//# sourceMappingURL=leaflet-src.js.map


/***/ }),

/***/ "./node_modules/leaflet/dist/leaflet.css":
/*!***********************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet.css ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_leaflet_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js!./leaflet.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/leaflet/dist/leaflet.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_leaflet_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_leaflet_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_leaflet_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_leaflet_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/vis-data/peer/umd/vis-data.js":
/*!****************************************************!*\
  !*** ./node_modules/vis-data/peer/umd/vis-data.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/**
 * vis-data
 * http://visjs.org/
 *
 * Manage unstructured data using DataSet. Add, update, and remove data, and listen for changes in the data.
 *
 * @version 7.1.4
 * @date    2022-03-15T15:23:59.245Z
 *
 * @copyright (c) 2011-2017 Almende B.V, http://almende.com
 * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs
 *
 * @license
 * vis.js is dual licensed under both
 *
 *   1. The Apache 2.0 License
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   and
 *
 *   2. The MIT License
 *      http://opensource.org/licenses/MIT
 *
 * vis.js may be distributed under either license.
 */

(function (global, factory) {
   true ? factory(exports) :
  0;
})(this, (function (exports) {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

  var defineProperty$e = {exports: {}};

  var check = function (it) {
    return it && it.Math == Math && it;
  }; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


  var global$M = // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
  function () {
    return this;
  }() || Function('return this')();

  var fails$r = function (exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };

  var fails$q = fails$r;
  var functionBindNative = !fails$q(function () {
    var test = function () {
      /* empty */
    }.bind(); // eslint-disable-next-line no-prototype-builtins -- safe


    return typeof test != 'function' || test.hasOwnProperty('prototype');
  });

  var NATIVE_BIND$4 = functionBindNative;
  var FunctionPrototype$3 = Function.prototype;
  var apply$6 = FunctionPrototype$3.apply;
  var call$c = FunctionPrototype$3.call; // eslint-disable-next-line es/no-reflect -- safe

  var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$4 ? call$c.bind(apply$6) : function () {
    return call$c.apply(apply$6, arguments);
  });

  var NATIVE_BIND$3 = functionBindNative;
  var FunctionPrototype$2 = Function.prototype;
  var bind$d = FunctionPrototype$2.bind;
  var call$b = FunctionPrototype$2.call;
  var uncurryThis$t = NATIVE_BIND$3 && bind$d.bind(call$b, call$b);
  var functionUncurryThis = NATIVE_BIND$3 ? function (fn) {
    return fn && uncurryThis$t(fn);
  } : function (fn) {
    return fn && function () {
      return call$b.apply(fn, arguments);
    };
  };

  // https://tc39.es/ecma262/#sec-iscallable

  var isCallable$h = function (argument) {
    return typeof argument == 'function';
  };

  var objectGetOwnPropertyDescriptor = {};

  var fails$p = fails$r; // Detect IE8's incomplete defineProperty implementation

  var descriptors = !fails$p(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty({}, 1, {
      get: function () {
        return 7;
      }
    })[1] != 7;
  });

  var NATIVE_BIND$2 = functionBindNative;
  var call$a = Function.prototype.call;
  var functionCall = NATIVE_BIND$2 ? call$a.bind(call$a) : function () {
    return call$a.apply(call$a, arguments);
  };

  var objectPropertyIsEnumerable = {};

  var $propertyIsEnumerable$2 = {}.propertyIsEnumerable; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

  var getOwnPropertyDescriptor$5 = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

  var NASHORN_BUG = getOwnPropertyDescriptor$5 && !$propertyIsEnumerable$2.call({
    1: 2
  }, 1); // `Object.prototype.propertyIsEnumerable` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable

  objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor$5(this, V);
    return !!descriptor && descriptor.enumerable;
  } : $propertyIsEnumerable$2;

  var createPropertyDescriptor$5 = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var uncurryThis$s = functionUncurryThis;
  var toString$9 = uncurryThis$s({}.toString);
  var stringSlice$1 = uncurryThis$s(''.slice);

  var classofRaw$1 = function (it) {
    return stringSlice$1(toString$9(it), 8, -1);
  };

  var global$L = global$M;
  var uncurryThis$r = functionUncurryThis;
  var fails$o = fails$r;
  var classof$f = classofRaw$1;
  var Object$9 = global$L.Object;
  var split = uncurryThis$r(''.split); // fallback for non-array-like ES3 and non-enumerable old V8 strings

  var indexedObject = fails$o(function () {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins -- safe
    return !Object$9('z').propertyIsEnumerable(0);
  }) ? function (it) {
    return classof$f(it) == 'String' ? split(it, '') : Object$9(it);
  } : Object$9;

  var global$K = global$M;
  var TypeError$j = global$K.TypeError; // `RequireObjectCoercible` abstract operation
  // https://tc39.es/ecma262/#sec-requireobjectcoercible

  var requireObjectCoercible$5 = function (it) {
    if (it == undefined) throw TypeError$j("Can't call method on " + it);
    return it;
  };

  var IndexedObject$3 = indexedObject;
  var requireObjectCoercible$4 = requireObjectCoercible$5;

  var toIndexedObject$b = function (it) {
    return IndexedObject$3(requireObjectCoercible$4(it));
  };

  var isCallable$g = isCallable$h;

  var isObject$f = function (it) {
    return typeof it == 'object' ? it !== null : isCallable$g(it);
  };

  var path$q = {};

  var path$p = path$q;
  var global$J = global$M;
  var isCallable$f = isCallable$h;

  var aFunction = function (variable) {
    return isCallable$f(variable) ? variable : undefined;
  };

  var getBuiltIn$9 = function (namespace, method) {
    return arguments.length < 2 ? aFunction(path$p[namespace]) || aFunction(global$J[namespace]) : path$p[namespace] && path$p[namespace][method] || global$J[namespace] && global$J[namespace][method];
  };

  var uncurryThis$q = functionUncurryThis;
  var objectIsPrototypeOf = uncurryThis$q({}.isPrototypeOf);

  var getBuiltIn$8 = getBuiltIn$9;
  var engineUserAgent = getBuiltIn$8('navigator', 'userAgent') || '';

  var global$I = global$M;
  var userAgent$3 = engineUserAgent;
  var process = global$I.process;
  var Deno = global$I.Deno;
  var versions = process && process.versions || Deno && Deno.version;
  var v8 = versions && versions.v8;
  var match, version;

  if (v8) {
    match = v8.split('.'); // in old Chrome, versions of V8 isn't V8 = Chrome / 10
    // but their correct versions are not interesting for us

    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  } // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
  // so check `userAgent` even if `.v8` exists, but 0


  if (!version && userAgent$3) {
    match = userAgent$3.match(/Edge\/(\d+)/);

    if (!match || match[1] >= 74) {
      match = userAgent$3.match(/Chrome\/(\d+)/);
      if (match) version = +match[1];
    }
  }

  var engineV8Version = version;

  /* eslint-disable es/no-symbol -- required for testing */
  var V8_VERSION$2 = engineV8Version;
  var fails$n = fails$r; // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing

  var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$n(function () {
    var symbol = Symbol(); // Chrome 38 Symbol has incorrect toString conversion
    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances

    return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION$2 && V8_VERSION$2 < 41;
  });

  /* eslint-disable es/no-symbol -- required for testing */
  var NATIVE_SYMBOL$2 = nativeSymbol;
  var useSymbolAsUid = NATIVE_SYMBOL$2 && !Symbol.sham && typeof Symbol.iterator == 'symbol';

  var global$H = global$M;
  var getBuiltIn$7 = getBuiltIn$9;
  var isCallable$e = isCallable$h;
  var isPrototypeOf$i = objectIsPrototypeOf;
  var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
  var Object$8 = global$H.Object;
  var isSymbol$3 = USE_SYMBOL_AS_UID$1 ? function (it) {
    return typeof it == 'symbol';
  } : function (it) {
    var $Symbol = getBuiltIn$7('Symbol');
    return isCallable$e($Symbol) && isPrototypeOf$i($Symbol.prototype, Object$8(it));
  };

  var global$G = global$M;
  var String$4 = global$G.String;

  var tryToString$4 = function (argument) {
    try {
      return String$4(argument);
    } catch (error) {
      return 'Object';
    }
  };

  var global$F = global$M;
  var isCallable$d = isCallable$h;
  var tryToString$3 = tryToString$4;
  var TypeError$i = global$F.TypeError; // `Assert: IsCallable(argument) is true`

  var aCallable$7 = function (argument) {
    if (isCallable$d(argument)) return argument;
    throw TypeError$i(tryToString$3(argument) + ' is not a function');
  };

  var aCallable$6 = aCallable$7; // `GetMethod` abstract operation
  // https://tc39.es/ecma262/#sec-getmethod

  var getMethod$3 = function (V, P) {
    var func = V[P];
    return func == null ? undefined : aCallable$6(func);
  };

  var global$E = global$M;
  var call$9 = functionCall;
  var isCallable$c = isCallable$h;
  var isObject$e = isObject$f;
  var TypeError$h = global$E.TypeError; // `OrdinaryToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-ordinarytoprimitive

  var ordinaryToPrimitive$1 = function (input, pref) {
    var fn, val;
    if (pref === 'string' && isCallable$c(fn = input.toString) && !isObject$e(val = call$9(fn, input))) return val;
    if (isCallable$c(fn = input.valueOf) && !isObject$e(val = call$9(fn, input))) return val;
    if (pref !== 'string' && isCallable$c(fn = input.toString) && !isObject$e(val = call$9(fn, input))) return val;
    throw TypeError$h("Can't convert object to primitive value");
  };

  var shared$4 = {exports: {}};

  var global$D = global$M; // eslint-disable-next-line es/no-object-defineproperty -- safe

  var defineProperty$d = Object.defineProperty;

  var setGlobal$1 = function (key, value) {
    try {
      defineProperty$d(global$D, key, {
        value: value,
        configurable: true,
        writable: true
      });
    } catch (error) {
      global$D[key] = value;
    }

    return value;
  };

  var global$C = global$M;
  var setGlobal = setGlobal$1;
  var SHARED = '__core-js_shared__';
  var store$3 = global$C[SHARED] || setGlobal(SHARED, {});
  var sharedStore = store$3;

  var store$2 = sharedStore;
  (shared$4.exports = function (key, value) {
    return store$2[key] || (store$2[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: '3.21.1',
    mode: 'pure' ,
    copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
    license: 'https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE',
    source: 'https://github.com/zloirock/core-js'
  });

  var global$B = global$M;
  var requireObjectCoercible$3 = requireObjectCoercible$5;
  var Object$7 = global$B.Object; // `ToObject` abstract operation
  // https://tc39.es/ecma262/#sec-toobject

  var toObject$e = function (argument) {
    return Object$7(requireObjectCoercible$3(argument));
  };

  var uncurryThis$p = functionUncurryThis;
  var toObject$d = toObject$e;
  var hasOwnProperty = uncurryThis$p({}.hasOwnProperty); // `HasOwnProperty` abstract operation
  // https://tc39.es/ecma262/#sec-hasownproperty

  var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
    return hasOwnProperty(toObject$d(it), key);
  };

  var uncurryThis$o = functionUncurryThis;
  var id$1 = 0;
  var postfix = Math.random();
  var toString$8 = uncurryThis$o(1.0.toString);

  var uid$4 = function (key) {
    return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$8(++id$1 + postfix, 36);
  };

  var global$A = global$M;
  var shared$3 = shared$4.exports;
  var hasOwn$f = hasOwnProperty_1;
  var uid$3 = uid$4;
  var NATIVE_SYMBOL$1 = nativeSymbol;
  var USE_SYMBOL_AS_UID = useSymbolAsUid;
  var WellKnownSymbolsStore$1 = shared$3('wks');
  var Symbol$2 = global$A.Symbol;
  var symbolFor = Symbol$2 && Symbol$2['for'];
  var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$2 : Symbol$2 && Symbol$2.withoutSetter || uid$3;

  var wellKnownSymbol$j = function (name) {
    if (!hasOwn$f(WellKnownSymbolsStore$1, name) || !(NATIVE_SYMBOL$1 || typeof WellKnownSymbolsStore$1[name] == 'string')) {
      var description = 'Symbol.' + name;

      if (NATIVE_SYMBOL$1 && hasOwn$f(Symbol$2, name)) {
        WellKnownSymbolsStore$1[name] = Symbol$2[name];
      } else if (USE_SYMBOL_AS_UID && symbolFor) {
        WellKnownSymbolsStore$1[name] = symbolFor(description);
      } else {
        WellKnownSymbolsStore$1[name] = createWellKnownSymbol(description);
      }
    }

    return WellKnownSymbolsStore$1[name];
  };

  var global$z = global$M;
  var call$8 = functionCall;
  var isObject$d = isObject$f;
  var isSymbol$2 = isSymbol$3;
  var getMethod$2 = getMethod$3;
  var ordinaryToPrimitive = ordinaryToPrimitive$1;
  var wellKnownSymbol$i = wellKnownSymbol$j;
  var TypeError$g = global$z.TypeError;
  var TO_PRIMITIVE$1 = wellKnownSymbol$i('toPrimitive'); // `ToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-toprimitive

  var toPrimitive$1 = function (input, pref) {
    if (!isObject$d(input) || isSymbol$2(input)) return input;
    var exoticToPrim = getMethod$2(input, TO_PRIMITIVE$1);
    var result;

    if (exoticToPrim) {
      if (pref === undefined) pref = 'default';
      result = call$8(exoticToPrim, input, pref);
      if (!isObject$d(result) || isSymbol$2(result)) return result;
      throw TypeError$g("Can't convert object to primitive value");
    }

    if (pref === undefined) pref = 'number';
    return ordinaryToPrimitive(input, pref);
  };

  var toPrimitive = toPrimitive$1;
  var isSymbol$1 = isSymbol$3; // `ToPropertyKey` abstract operation
  // https://tc39.es/ecma262/#sec-topropertykey

  var toPropertyKey$4 = function (argument) {
    var key = toPrimitive(argument, 'string');
    return isSymbol$1(key) ? key : key + '';
  };

  var global$y = global$M;
  var isObject$c = isObject$f;
  var document$1 = global$y.document; // typeof document.createElement is 'object' in old IE

  var EXISTS$1 = isObject$c(document$1) && isObject$c(document$1.createElement);

  var documentCreateElement$1 = function (it) {
    return EXISTS$1 ? document$1.createElement(it) : {};
  };

  var DESCRIPTORS$h = descriptors;
  var fails$m = fails$r;
  var createElement = documentCreateElement$1; // Thanks to IE8 for its funny defineProperty

  var ie8DomDefine = !DESCRIPTORS$h && !fails$m(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(createElement('div'), 'a', {
      get: function () {
        return 7;
      }
    }).a != 7;
  });

  var DESCRIPTORS$g = descriptors;
  var call$7 = functionCall;
  var propertyIsEnumerableModule$2 = objectPropertyIsEnumerable;
  var createPropertyDescriptor$4 = createPropertyDescriptor$5;
  var toIndexedObject$a = toIndexedObject$b;
  var toPropertyKey$3 = toPropertyKey$4;
  var hasOwn$e = hasOwnProperty_1;
  var IE8_DOM_DEFINE$1 = ie8DomDefine; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

  var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

  objectGetOwnPropertyDescriptor.f = DESCRIPTORS$g ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject$a(O);
    P = toPropertyKey$3(P);
    if (IE8_DOM_DEFINE$1) try {
      return $getOwnPropertyDescriptor$2(O, P);
    } catch (error) {
      /* empty */
    }
    if (hasOwn$e(O, P)) return createPropertyDescriptor$4(!call$7(propertyIsEnumerableModule$2.f, O, P), O[P]);
  };

  var fails$l = fails$r;
  var isCallable$b = isCallable$h;
  var replacement = /#|\.prototype\./;

  var isForced$1 = function (feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true : value == NATIVE ? false : isCallable$b(detection) ? fails$l(detection) : !!detection;
  };

  var normalize = isForced$1.normalize = function (string) {
    return String(string).replace(replacement, '.').toLowerCase();
  };

  var data = isForced$1.data = {};
  var NATIVE = isForced$1.NATIVE = 'N';
  var POLYFILL = isForced$1.POLYFILL = 'P';
  var isForced_1 = isForced$1;

  var uncurryThis$n = functionUncurryThis;
  var aCallable$5 = aCallable$7;
  var NATIVE_BIND$1 = functionBindNative;
  var bind$c = uncurryThis$n(uncurryThis$n.bind); // optional / simple context binding

  var functionBindContext = function (fn, that) {
    aCallable$5(fn);
    return that === undefined ? fn : NATIVE_BIND$1 ? bind$c(fn, that) : function
      /* ...args */
    () {
      return fn.apply(that, arguments);
    };
  };

  var objectDefineProperty = {};

  var DESCRIPTORS$f = descriptors;
  var fails$k = fails$r; // V8 ~ Chrome 36-
  // https://bugs.chromium.org/p/v8/issues/detail?id=3334

  var v8PrototypeDefineBug = DESCRIPTORS$f && fails$k(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(function () {
      /* empty */
    }, 'prototype', {
      value: 42,
      writable: false
    }).prototype != 42;
  });

  var global$x = global$M;
  var isObject$b = isObject$f;
  var String$3 = global$x.String;
  var TypeError$f = global$x.TypeError; // `Assert: Type(argument) is Object`

  var anObject$b = function (argument) {
    if (isObject$b(argument)) return argument;
    throw TypeError$f(String$3(argument) + ' is not an object');
  };

  var global$w = global$M;
  var DESCRIPTORS$e = descriptors;
  var IE8_DOM_DEFINE = ie8DomDefine;
  var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
  var anObject$a = anObject$b;
  var toPropertyKey$2 = toPropertyKey$4;
  var TypeError$e = global$w.TypeError; // eslint-disable-next-line es/no-object-defineproperty -- safe

  var $defineProperty$1 = Object.defineProperty; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

  var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
  var ENUMERABLE = 'enumerable';
  var CONFIGURABLE$1 = 'configurable';
  var WRITABLE = 'writable'; // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty

  objectDefineProperty.f = DESCRIPTORS$e ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
    anObject$a(O);
    P = toPropertyKey$2(P);
    anObject$a(Attributes);

    if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
      var current = $getOwnPropertyDescriptor$1(O, P);

      if (current && current[WRITABLE]) {
        O[P] = Attributes.value;
        Attributes = {
          configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
          enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
          writable: false
        };
      }
    }

    return $defineProperty$1(O, P, Attributes);
  } : $defineProperty$1 : function defineProperty(O, P, Attributes) {
    anObject$a(O);
    P = toPropertyKey$2(P);
    anObject$a(Attributes);
    if (IE8_DOM_DEFINE) try {
      return $defineProperty$1(O, P, Attributes);
    } catch (error) {
      /* empty */
    }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError$e('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };

  var DESCRIPTORS$d = descriptors;
  var definePropertyModule$4 = objectDefineProperty;
  var createPropertyDescriptor$3 = createPropertyDescriptor$5;
  var createNonEnumerableProperty$6 = DESCRIPTORS$d ? function (object, key, value) {
    return definePropertyModule$4.f(object, key, createPropertyDescriptor$3(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var global$v = global$M;
  var apply$5 = functionApply;
  var uncurryThis$m = functionUncurryThis;
  var isCallable$a = isCallable$h;
  var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f;
  var isForced = isForced_1;
  var path$o = path$q;
  var bind$b = functionBindContext;
  var createNonEnumerableProperty$5 = createNonEnumerableProperty$6;
  var hasOwn$d = hasOwnProperty_1;

  var wrapConstructor = function (NativeConstructor) {
    var Wrapper = function (a, b, c) {
      if (this instanceof Wrapper) {
        switch (arguments.length) {
          case 0:
            return new NativeConstructor();

          case 1:
            return new NativeConstructor(a);

          case 2:
            return new NativeConstructor(a, b);
        }

        return new NativeConstructor(a, b, c);
      }

      return apply$5(NativeConstructor, this, arguments);
    };

    Wrapper.prototype = NativeConstructor.prototype;
    return Wrapper;
  };
  /*
    options.target      - name of the target object
    options.global      - target is the global object
    options.stat        - export as static methods of target
    options.proto       - export as prototype methods of target
    options.real        - real prototype method for the `pure` version
    options.forced      - export even if the native feature is available
    options.bind        - bind methods to the target, required for the `pure` version
    options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
    options.unsafe      - use the simple assignment of property instead of delete + defineProperty
    options.sham        - add a flag to not completely full polyfills
    options.enumerable  - export as enumerable property
    options.noTargetGet - prevent calling a getter on target
    options.name        - the .name of the function if it does not match the key
  */


  var _export = function (options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var PROTO = options.proto;
    var nativeSource = GLOBAL ? global$v : STATIC ? global$v[TARGET] : (global$v[TARGET] || {}).prototype;
    var target = GLOBAL ? path$o : path$o[TARGET] || createNonEnumerableProperty$5(path$o, TARGET, {})[TARGET];
    var targetPrototype = target.prototype;
    var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
    var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

    for (key in source) {
      FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contains in native

      USE_NATIVE = !FORCED && nativeSource && hasOwn$d(nativeSource, key);
      targetProperty = target[key];
      if (USE_NATIVE) if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$4(nativeSource, key);
        nativeProperty = descriptor && descriptor.value;
      } else nativeProperty = nativeSource[key]; // export native or implementation

      sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
      if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue; // bind timers to global for call from export context

      if (options.bind && USE_NATIVE) resultProperty = bind$b(sourceProperty, global$v); // wrap global constructors for prevent changs in this version
      else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty); // make static versions for prototype methods
      else if (PROTO && isCallable$a(sourceProperty)) resultProperty = uncurryThis$m(sourceProperty); // default case
      else resultProperty = sourceProperty; // add a flag to not completely full polyfills

      if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty$5(resultProperty, 'sham', true);
      }

      createNonEnumerableProperty$5(target, key, resultProperty);

      if (PROTO) {
        VIRTUAL_PROTOTYPE = TARGET + 'Prototype';

        if (!hasOwn$d(path$o, VIRTUAL_PROTOTYPE)) {
          createNonEnumerableProperty$5(path$o, VIRTUAL_PROTOTYPE, {});
        } // export virtual prototype methods


        createNonEnumerableProperty$5(path$o[VIRTUAL_PROTOTYPE], key, sourceProperty); // export real prototype methods

        if (options.real && targetPrototype && !targetPrototype[key]) {
          createNonEnumerableProperty$5(targetPrototype, key, sourceProperty);
        }
      }
    }
  };

  var $$C = _export;
  var DESCRIPTORS$c = descriptors;
  var defineProperty$c = objectDefineProperty.f; // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  // eslint-disable-next-line es/no-object-defineproperty -- safe

  $$C({
    target: 'Object',
    stat: true,
    forced: Object.defineProperty !== defineProperty$c,
    sham: !DESCRIPTORS$c
  }, {
    defineProperty: defineProperty$c
  });

  var path$n = path$q;
  var Object$6 = path$n.Object;

  var defineProperty$b = defineProperty$e.exports = function defineProperty(it, key, desc) {
    return Object$6.defineProperty(it, key, desc);
  };

  if (Object$6.defineProperty.sham) defineProperty$b.sham = true;

  var parent$V = defineProperty$e.exports;
  var defineProperty$a = parent$V;

  var parent$U = defineProperty$a;
  var defineProperty$9 = parent$U;

  var parent$T = defineProperty$9;
  var defineProperty$8 = parent$T;

  var defineProperty$7 = defineProperty$8;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;

      defineProperty$7(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    defineProperty$7(Constructor, "prototype", {
      writable: false
    });

    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      defineProperty$7(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var uncurryThis$l = functionUncurryThis;
  var arraySlice$5 = uncurryThis$l([].slice);

  var global$u = global$M;
  var uncurryThis$k = functionUncurryThis;
  var aCallable$4 = aCallable$7;
  var isObject$a = isObject$f;
  var hasOwn$c = hasOwnProperty_1;
  var arraySlice$4 = arraySlice$5;
  var NATIVE_BIND = functionBindNative;
  var Function$2 = global$u.Function;
  var concat$6 = uncurryThis$k([].concat);
  var join = uncurryThis$k([].join);
  var factories = {};

  var construct$4 = function (C, argsLength, args) {
    if (!hasOwn$c(factories, argsLength)) {
      for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';

      factories[argsLength] = Function$2('C,a', 'return new C(' + join(list, ',') + ')');
    }

    return factories[argsLength](C, args);
  }; // `Function.prototype.bind` method implementation
  // https://tc39.es/ecma262/#sec-function.prototype.bind


  var functionBind = NATIVE_BIND ? Function$2.bind : function bind(that
  /* , ...args */
  ) {
    var F = aCallable$4(this);
    var Prototype = F.prototype;
    var partArgs = arraySlice$4(arguments, 1);

    var boundFunction = function
      /* args... */
    bound() {
      var args = concat$6(partArgs, arraySlice$4(arguments));
      return this instanceof boundFunction ? construct$4(F, args.length, args) : F.apply(that, args);
    };

    if (isObject$a(Prototype)) boundFunction.prototype = Prototype;
    return boundFunction;
  };

  var $$B = _export;
  var bind$a = functionBind; // `Function.prototype.bind` method
  // https://tc39.es/ecma262/#sec-function.prototype.bind

  $$B({
    target: 'Function',
    proto: true,
    forced: Function.bind !== bind$a
  }, {
    bind: bind$a
  });

  var path$m = path$q;

  var entryVirtual$k = function (CONSTRUCTOR) {
    return path$m[CONSTRUCTOR + 'Prototype'];
  };

  var entryVirtual$j = entryVirtual$k;
  var bind$9 = entryVirtual$j('Function').bind;

  var isPrototypeOf$h = objectIsPrototypeOf;
  var method$e = bind$9;
  var FunctionPrototype$1 = Function.prototype;

  var bind$8 = function (it) {
    var own = it.bind;
    return it === FunctionPrototype$1 || isPrototypeOf$h(FunctionPrototype$1, it) && own === FunctionPrototype$1.bind ? method$e : own;
  };

  var parent$S = bind$8;
  var bind$7 = parent$S;

  var bind$6 = bind$7;

  var ceil = Math.ceil;
  var floor$1 = Math.floor; // `ToIntegerOrInfinity` abstract operation
  // https://tc39.es/ecma262/#sec-tointegerorinfinity

  var toIntegerOrInfinity$4 = function (argument) {
    var number = +argument; // eslint-disable-next-line no-self-compare -- safe

    return number !== number || number === 0 ? 0 : (number > 0 ? floor$1 : ceil)(number);
  };

  var toIntegerOrInfinity$3 = toIntegerOrInfinity$4;
  var min$2 = Math.min; // `ToLength` abstract operation
  // https://tc39.es/ecma262/#sec-tolength

  var toLength$1 = function (argument) {
    return argument > 0 ? min$2(toIntegerOrInfinity$3(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
  };

  var toLength = toLength$1; // `LengthOfArrayLike` abstract operation
  // https://tc39.es/ecma262/#sec-lengthofarraylike

  var lengthOfArrayLike$d = function (obj) {
    return toLength(obj.length);
  };

  var global$t = global$M;
  var aCallable$3 = aCallable$7;
  var toObject$c = toObject$e;
  var IndexedObject$2 = indexedObject;
  var lengthOfArrayLike$c = lengthOfArrayLike$d;
  var TypeError$d = global$t.TypeError; // `Array.prototype.{ reduce, reduceRight }` methods implementation

  var createMethod$5 = function (IS_RIGHT) {
    return function (that, callbackfn, argumentsLength, memo) {
      aCallable$3(callbackfn);
      var O = toObject$c(that);
      var self = IndexedObject$2(O);
      var length = lengthOfArrayLike$c(O);
      var index = IS_RIGHT ? length - 1 : 0;
      var i = IS_RIGHT ? -1 : 1;
      if (argumentsLength < 2) while (true) {
        if (index in self) {
          memo = self[index];
          index += i;
          break;
        }

        index += i;

        if (IS_RIGHT ? index < 0 : length <= index) {
          throw TypeError$d('Reduce of empty array with no initial value');
        }
      }

      for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
        memo = callbackfn(memo, self[index], index, O);
      }

      return memo;
    };
  };

  var arrayReduce = {
    // `Array.prototype.reduce` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduce
    left: createMethod$5(false),
    // `Array.prototype.reduceRight` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduceright
    right: createMethod$5(true)
  };

  var fails$j = fails$r;

  var arrayMethodIsStrict$5 = function (METHOD_NAME, argument) {
    var method = [][METHOD_NAME];
    return !!method && fails$j(function () {
      // eslint-disable-next-line no-useless-call -- required for testing
      method.call(null, argument || function () {
        return 1;
      }, 1);
    });
  };

  var classof$e = classofRaw$1;
  var global$s = global$M;
  var engineIsNode = classof$e(global$s.process) == 'process';

  var $$A = _export;
  var $reduce = arrayReduce.left;
  var arrayMethodIsStrict$4 = arrayMethodIsStrict$5;
  var CHROME_VERSION = engineV8Version;
  var IS_NODE = engineIsNode;
  var STRICT_METHOD$4 = arrayMethodIsStrict$4('reduce'); // Chrome 80-82 has a critical bug
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982

  var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83; // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce

  $$A({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD$4 || CHROME_BUG
  }, {
    reduce: function reduce(callbackfn
    /* , initialValue */
    ) {
      var length = arguments.length;
      return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
    }
  });

  var entryVirtual$i = entryVirtual$k;
  var reduce$3 = entryVirtual$i('Array').reduce;

  var isPrototypeOf$g = objectIsPrototypeOf;
  var method$d = reduce$3;
  var ArrayPrototype$e = Array.prototype;

  var reduce$2 = function (it) {
    var own = it.reduce;
    return it === ArrayPrototype$e || isPrototypeOf$g(ArrayPrototype$e, it) && own === ArrayPrototype$e.reduce ? method$d : own;
  };

  var parent$R = reduce$2;
  var reduce$1 = parent$R;

  var reduce = reduce$1;

  var classof$d = classofRaw$1; // `IsArray` abstract operation
  // https://tc39.es/ecma262/#sec-isarray
  // eslint-disable-next-line es/no-array-isarray -- safe

  var isArray$d = Array.isArray || function isArray(argument) {
    return classof$d(argument) == 'Array';
  };

  var wellKnownSymbol$h = wellKnownSymbol$j;
  var TO_STRING_TAG$3 = wellKnownSymbol$h('toStringTag');
  var test$2 = {};
  test$2[TO_STRING_TAG$3] = 'z';
  var toStringTagSupport = String(test$2) === '[object z]';

  var global$r = global$M;
  var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
  var isCallable$9 = isCallable$h;
  var classofRaw = classofRaw$1;
  var wellKnownSymbol$g = wellKnownSymbol$j;
  var TO_STRING_TAG$2 = wellKnownSymbol$g('toStringTag');
  var Object$5 = global$r.Object; // ES3 wrong here

  var CORRECT_ARGUMENTS = classofRaw(function () {
    return arguments;
  }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (error) {
      /* empty */
    }
  }; // getting tag from ES6+ `Object.prototype.toString`


  var classof$c = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function (it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
    : typeof (tag = tryGet(O = Object$5(it), TO_STRING_TAG$2)) == 'string' ? tag // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable$9(O.callee) ? 'Arguments' : result;
  };

  var uncurryThis$j = functionUncurryThis;
  var isCallable$8 = isCallable$h;
  var store$1 = sharedStore;
  var functionToString = uncurryThis$j(Function.toString); // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper

  if (!isCallable$8(store$1.inspectSource)) {
    store$1.inspectSource = function (it) {
      return functionToString(it);
    };
  }

  var inspectSource$2 = store$1.inspectSource;

  var uncurryThis$i = functionUncurryThis;
  var fails$i = fails$r;
  var isCallable$7 = isCallable$h;
  var classof$b = classof$c;
  var getBuiltIn$6 = getBuiltIn$9;
  var inspectSource$1 = inspectSource$2;

  var noop = function () {
    /* empty */
  };

  var empty = [];
  var construct$3 = getBuiltIn$6('Reflect', 'construct');
  var constructorRegExp = /^\s*(?:class|function)\b/;
  var exec$2 = uncurryThis$i(constructorRegExp.exec);
  var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

  var isConstructorModern = function isConstructor(argument) {
    if (!isCallable$7(argument)) return false;

    try {
      construct$3(noop, empty, argument);
      return true;
    } catch (error) {
      return false;
    }
  };

  var isConstructorLegacy = function isConstructor(argument) {
    if (!isCallable$7(argument)) return false;

    switch (classof$b(argument)) {
      case 'AsyncFunction':
      case 'GeneratorFunction':
      case 'AsyncGeneratorFunction':
        return false;
    }

    try {
      // we can't check .prototype since constructors produced by .bind haven't it
      // `Function#toString` throws on some built-it function in some legacy engines
      // (for example, `DOMQuad` and similar in FF41-)
      return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$1(argument));
    } catch (error) {
      return true;
    }
  };

  isConstructorLegacy.sham = true; // `IsConstructor` abstract operation
  // https://tc39.es/ecma262/#sec-isconstructor

  var isConstructor$4 = !construct$3 || fails$i(function () {
    var called;
    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {
      called = true;
    }) || called;
  }) ? isConstructorLegacy : isConstructorModern;

  var global$q = global$M;
  var isArray$c = isArray$d;
  var isConstructor$3 = isConstructor$4;
  var isObject$9 = isObject$f;
  var wellKnownSymbol$f = wellKnownSymbol$j;
  var SPECIES$3 = wellKnownSymbol$f('species');
  var Array$5 = global$q.Array; // a part of `ArraySpeciesCreate` abstract operation
  // https://tc39.es/ecma262/#sec-arrayspeciescreate

  var arraySpeciesConstructor$1 = function (originalArray) {
    var C;

    if (isArray$c(originalArray)) {
      C = originalArray.constructor; // cross-realm fallback

      if (isConstructor$3(C) && (C === Array$5 || isArray$c(C.prototype))) C = undefined;else if (isObject$9(C)) {
        C = C[SPECIES$3];
        if (C === null) C = undefined;
      }
    }

    return C === undefined ? Array$5 : C;
  };

  var arraySpeciesConstructor = arraySpeciesConstructor$1; // `ArraySpeciesCreate` abstract operation
  // https://tc39.es/ecma262/#sec-arrayspeciescreate

  var arraySpeciesCreate$4 = function (originalArray, length) {
    return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
  };

  var bind$5 = functionBindContext;
  var uncurryThis$h = functionUncurryThis;
  var IndexedObject$1 = indexedObject;
  var toObject$b = toObject$e;
  var lengthOfArrayLike$b = lengthOfArrayLike$d;
  var arraySpeciesCreate$3 = arraySpeciesCreate$4;
  var push$5 = uncurryThis$h([].push); // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation

  var createMethod$4 = function (TYPE) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var IS_FILTER_REJECT = TYPE == 7;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function ($this, callbackfn, that, specificCreate) {
      var O = toObject$b($this);
      var self = IndexedObject$1(O);
      var boundFunction = bind$5(callbackfn, that);
      var length = lengthOfArrayLike$b(self);
      var index = 0;
      var create = specificCreate || arraySpeciesCreate$3;
      var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
      var value, result;

      for (; length > index; index++) if (NO_HOLES || index in self) {
        value = self[index];
        result = boundFunction(value, index, O);

        if (TYPE) {
          if (IS_MAP) target[index] = result; // map
          else if (result) switch (TYPE) {
            case 3:
              return true;
            // some

            case 5:
              return value;
            // find

            case 6:
              return index;
            // findIndex

            case 2:
              push$5(target, value);
            // filter
          } else switch (TYPE) {
            case 4:
              return false;
            // every

            case 7:
              push$5(target, value);
            // filterReject
          }
        }
      }

      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
  };

  var arrayIteration = {
    // `Array.prototype.forEach` method
    // https://tc39.es/ecma262/#sec-array.prototype.foreach
    forEach: createMethod$4(0),
    // `Array.prototype.map` method
    // https://tc39.es/ecma262/#sec-array.prototype.map
    map: createMethod$4(1),
    // `Array.prototype.filter` method
    // https://tc39.es/ecma262/#sec-array.prototype.filter
    filter: createMethod$4(2),
    // `Array.prototype.some` method
    // https://tc39.es/ecma262/#sec-array.prototype.some
    some: createMethod$4(3),
    // `Array.prototype.every` method
    // https://tc39.es/ecma262/#sec-array.prototype.every
    every: createMethod$4(4),
    // `Array.prototype.find` method
    // https://tc39.es/ecma262/#sec-array.prototype.find
    find: createMethod$4(5),
    // `Array.prototype.findIndex` method
    // https://tc39.es/ecma262/#sec-array.prototype.findIndex
    findIndex: createMethod$4(6),
    // `Array.prototype.filterReject` method
    // https://github.com/tc39/proposal-array-filtering
    filterReject: createMethod$4(7)
  };

  var fails$h = fails$r;
  var wellKnownSymbol$e = wellKnownSymbol$j;
  var V8_VERSION$1 = engineV8Version;
  var SPECIES$2 = wellKnownSymbol$e('species');

  var arrayMethodHasSpeciesSupport$5 = function (METHOD_NAME) {
    // We can't use this feature detection in V8 since it causes
    // deoptimization and serious performance degradation
    // https://github.com/zloirock/core-js/issues/677
    return V8_VERSION$1 >= 51 || !fails$h(function () {
      var array = [];
      var constructor = array.constructor = {};

      constructor[SPECIES$2] = function () {
        return {
          foo: 1
        };
      };

      return array[METHOD_NAME](Boolean).foo !== 1;
    });
  };

  var $$z = _export;
  var $filter = arrayIteration.filter;
  var arrayMethodHasSpeciesSupport$4 = arrayMethodHasSpeciesSupport$5;
  var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport$4('filter'); // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  // with adding support of @@species

  $$z({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT$3
  }, {
    filter: function filter(callbackfn
    /* , thisArg */
    ) {
      return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var entryVirtual$h = entryVirtual$k;
  var filter$3 = entryVirtual$h('Array').filter;

  var isPrototypeOf$f = objectIsPrototypeOf;
  var method$c = filter$3;
  var ArrayPrototype$d = Array.prototype;

  var filter$2 = function (it) {
    var own = it.filter;
    return it === ArrayPrototype$d || isPrototypeOf$f(ArrayPrototype$d, it) && own === ArrayPrototype$d.filter ? method$c : own;
  };

  var parent$Q = filter$2;
  var filter$1 = parent$Q;

  var filter = filter$1;

  var $$y = _export;
  var $map = arrayIteration.map;
  var arrayMethodHasSpeciesSupport$3 = arrayMethodHasSpeciesSupport$5;
  var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$3('map'); // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  // with adding support of @@species

  $$y({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT$2
  }, {
    map: function map(callbackfn
    /* , thisArg */
    ) {
      return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var entryVirtual$g = entryVirtual$k;
  var map$6 = entryVirtual$g('Array').map;

  var isPrototypeOf$e = objectIsPrototypeOf;
  var method$b = map$6;
  var ArrayPrototype$c = Array.prototype;

  var map$5 = function (it) {
    var own = it.map;
    return it === ArrayPrototype$c || isPrototypeOf$e(ArrayPrototype$c, it) && own === ArrayPrototype$c.map ? method$b : own;
  };

  var parent$P = map$5;
  var map$4 = parent$P;

  var map$3 = map$4;

  var global$p = global$M;
  var isArray$b = isArray$d;
  var lengthOfArrayLike$a = lengthOfArrayLike$d;
  var bind$4 = functionBindContext;
  var TypeError$c = global$p.TypeError; // `FlattenIntoArray` abstract operation
  // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

  var flattenIntoArray$1 = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
    var targetIndex = start;
    var sourceIndex = 0;
    var mapFn = mapper ? bind$4(mapper, thisArg) : false;
    var element, elementLen;

    while (sourceIndex < sourceLen) {
      if (sourceIndex in source) {
        element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

        if (depth > 0 && isArray$b(element)) {
          elementLen = lengthOfArrayLike$a(element);
          targetIndex = flattenIntoArray$1(target, original, element, elementLen, targetIndex, depth - 1) - 1;
        } else {
          if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError$c('Exceed the acceptable array length');
          target[targetIndex] = element;
        }

        targetIndex++;
      }

      sourceIndex++;
    }

    return targetIndex;
  };

  var flattenIntoArray_1 = flattenIntoArray$1;

  var $$x = _export;
  var flattenIntoArray = flattenIntoArray_1;
  var aCallable$2 = aCallable$7;
  var toObject$a = toObject$e;
  var lengthOfArrayLike$9 = lengthOfArrayLike$d;
  var arraySpeciesCreate$2 = arraySpeciesCreate$4; // `Array.prototype.flatMap` method
  // https://tc39.es/ecma262/#sec-array.prototype.flatmap

  $$x({
    target: 'Array',
    proto: true
  }, {
    flatMap: function flatMap(callbackfn
    /* , thisArg */
    ) {
      var O = toObject$a(this);
      var sourceLen = lengthOfArrayLike$9(O);
      var A;
      aCallable$2(callbackfn);
      A = arraySpeciesCreate$2(O, 0);
      A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      return A;
    }
  });

  var entryVirtual$f = entryVirtual$k;
  var flatMap$3 = entryVirtual$f('Array').flatMap;

  var isPrototypeOf$d = objectIsPrototypeOf;
  var method$a = flatMap$3;
  var ArrayPrototype$b = Array.prototype;

  var flatMap$2 = function (it) {
    var own = it.flatMap;
    return it === ArrayPrototype$b || isPrototypeOf$d(ArrayPrototype$b, it) && own === ArrayPrototype$b.flatMap ? method$a : own;
  };

  var parent$O = flatMap$2;
  var flatMap$1 = parent$O;

  var flatMap = flatMap$1;

  /**
   * Create new data pipe.
   *
   * @param from - The source data set or data view.
   * @remarks
   * Example usage:
   * ```typescript
   * interface AppItem {
   *   whoami: string;
   *   appData: unknown;
   *   visData: VisItem;
   * }
   * interface VisItem {
   *   id: number;
   *   label: string;
   *   color: string;
   *   x: number;
   *   y: number;
   * }
   *
   * const ds1 = new DataSet<AppItem, "whoami">([], { fieldId: "whoami" });
   * const ds2 = new DataSet<VisItem, "id">();
   *
   * const pipe = createNewDataPipeFrom(ds1)
   *   .filter((item): boolean => item.enabled === true)
   *   .map<VisItem, "id">((item): VisItem => item.visData)
   *   .to(ds2);
   *
   * pipe.start();
   * ```
   * @returns A factory whose methods can be used to configure the pipe.
   */
  function createNewDataPipeFrom(from) {
    return new DataPipeUnderConstruction(from);
  }
  /**
   * Internal implementation of the pipe. This should be accessible only through
   * `createNewDataPipeFrom` from the outside.
   *
   * @typeParam SI - Source item type.
   * @typeParam SP - Source item type's id property name.
   * @typeParam TI - Target item type.
   * @typeParam TP - Target item type's id property name.
   */

  var SimpleDataPipe = /*#__PURE__*/function () {
    /**
     * Bound listeners for use with `DataInterface['on' | 'off']`.
     */

    /**
     * Create a new data pipe.
     *
     * @param _source - The data set or data view that will be observed.
     * @param _transformers - An array of transforming functions to be used to
     * filter or transform the items in the pipe.
     * @param _target - The data set or data view that will receive the items.
     */
    function SimpleDataPipe(_source, _transformers, _target) {
      var _context, _context2, _context3;

      _classCallCheck(this, SimpleDataPipe);

      _defineProperty(this, "_source", void 0);

      _defineProperty(this, "_transformers", void 0);

      _defineProperty(this, "_target", void 0);

      _defineProperty(this, "_listeners", {
        add: bind$6(_context = this._add).call(_context, this),
        remove: bind$6(_context2 = this._remove).call(_context2, this),
        update: bind$6(_context3 = this._update).call(_context3, this)
      });

      this._source = _source;
      this._transformers = _transformers;
      this._target = _target;
    }
    /** @inheritDoc */


    _createClass(SimpleDataPipe, [{
      key: "all",
      value: function all() {
        this._target.update(this._transformItems(this._source.get()));

        return this;
      }
      /** @inheritDoc */

    }, {
      key: "start",
      value: function start() {
        this._source.on("add", this._listeners.add);

        this._source.on("remove", this._listeners.remove);

        this._source.on("update", this._listeners.update);

        return this;
      }
      /** @inheritDoc */

    }, {
      key: "stop",
      value: function stop() {
        this._source.off("add", this._listeners.add);

        this._source.off("remove", this._listeners.remove);

        this._source.off("update", this._listeners.update);

        return this;
      }
      /**
       * Apply the transformers to the items.
       *
       * @param items - The items to be transformed.
       * @returns The transformed items.
       */

    }, {
      key: "_transformItems",
      value: function _transformItems(items) {
        var _context4;

        return reduce(_context4 = this._transformers).call(_context4, function (items, transform) {
          return transform(items);
        }, items);
      }
      /**
       * Handle an add event.
       *
       * @param _name - Ignored.
       * @param payload - The payload containing the ids of the added items.
       */

    }, {
      key: "_add",
      value: function _add(_name, payload) {
        if (payload == null) {
          return;
        }

        this._target.add(this._transformItems(this._source.get(payload.items)));
      }
      /**
       * Handle an update event.
       *
       * @param _name - Ignored.
       * @param payload - The payload containing the ids of the updated items.
       */

    }, {
      key: "_update",
      value: function _update(_name, payload) {
        if (payload == null) {
          return;
        }

        this._target.update(this._transformItems(this._source.get(payload.items)));
      }
      /**
       * Handle a remove event.
       *
       * @param _name - Ignored.
       * @param payload - The payload containing the data of the removed items.
       */

    }, {
      key: "_remove",
      value: function _remove(_name, payload) {
        if (payload == null) {
          return;
        }

        this._target.remove(this._transformItems(payload.oldData));
      }
    }]);

    return SimpleDataPipe;
  }();
  /**
   * Internal implementation of the pipe factory. This should be accessible
   * only through `createNewDataPipeFrom` from the outside.
   *
   * @typeParam TI - Target item type.
   * @typeParam TP - Target item type's id property name.
   */


  var DataPipeUnderConstruction = /*#__PURE__*/function () {
    /**
     * Array transformers used to transform items within the pipe. This is typed
     * as any for the sake of simplicity.
     */

    /**
     * Create a new data pipe factory. This is an internal constructor that
     * should never be called from outside of this file.
     *
     * @param _source - The source data set or data view for this pipe.
     */
    function DataPipeUnderConstruction(_source) {
      _classCallCheck(this, DataPipeUnderConstruction);

      _defineProperty(this, "_source", void 0);

      _defineProperty(this, "_transformers", []);

      this._source = _source;
    }
    /**
     * Filter the items.
     *
     * @param callback - A filtering function that returns true if given item
     * should be piped and false if not.
     * @returns This factory for further configuration.
     */


    _createClass(DataPipeUnderConstruction, [{
      key: "filter",
      value: function filter$1(callback) {
        this._transformers.push(function (input) {
          return filter(input).call(input, callback);
        });

        return this;
      }
      /**
       * Map each source item to a new type.
       *
       * @param callback - A mapping function that takes a source item and returns
       * corresponding mapped item.
       * @typeParam TI - Target item type.
       * @typeParam TP - Target item type's id property name.
       * @returns This factory for further configuration.
       */

    }, {
      key: "map",
      value: function map(callback) {
        this._transformers.push(function (input) {
          return map$3(input).call(input, callback);
        });

        return this;
      }
      /**
       * Map each source item to zero or more items of a new type.
       *
       * @param callback - A mapping function that takes a source item and returns
       * an array of corresponding mapped items.
       * @typeParam TI - Target item type.
       * @typeParam TP - Target item type's id property name.
       * @returns This factory for further configuration.
       */

    }, {
      key: "flatMap",
      value: function flatMap$1(callback) {
        this._transformers.push(function (input) {
          return flatMap(input).call(input, callback);
        });

        return this;
      }
      /**
       * Connect this pipe to given data set.
       *
       * @param target - The data set that will receive the items from this pipe.
       * @returns The pipe connected between given data sets and performing
       * configured transformation on the processed items.
       */

    }, {
      key: "to",
      value: function to(target) {
        return new SimpleDataPipe(this._source, this._transformers, target);
      }
    }]);

    return DataPipeUnderConstruction;
  }();

  var global$o = global$M;
  var classof$a = classof$c;
  var String$2 = global$o.String;

  var toString$7 = function (argument) {
    if (classof$a(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
    return String$2(argument);
  };

  var uncurryThis$g = functionUncurryThis;
  var toIntegerOrInfinity$2 = toIntegerOrInfinity$4;
  var toString$6 = toString$7;
  var requireObjectCoercible$2 = requireObjectCoercible$5;
  var charAt$2 = uncurryThis$g(''.charAt);
  var charCodeAt$1 = uncurryThis$g(''.charCodeAt);
  var stringSlice = uncurryThis$g(''.slice);

  var createMethod$3 = function (CONVERT_TO_STRING) {
    return function ($this, pos) {
      var S = toString$6(requireObjectCoercible$2($this));
      var position = toIntegerOrInfinity$2(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
      first = charCodeAt$1(S, position);
      return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt$1(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt$2(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
    };
  };

  var stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod$3(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod$3(true)
  };

  var global$n = global$M;
  var isCallable$6 = isCallable$h;
  var inspectSource = inspectSource$2;
  var WeakMap$1 = global$n.WeakMap;
  var nativeWeakMap = isCallable$6(WeakMap$1) && /native code/.test(inspectSource(WeakMap$1));

  var shared$2 = shared$4.exports;
  var uid$2 = uid$4;
  var keys$7 = shared$2('keys');

  var sharedKey$4 = function (key) {
    return keys$7[key] || (keys$7[key] = uid$2(key));
  };

  var hiddenKeys$6 = {};

  var NATIVE_WEAK_MAP = nativeWeakMap;
  var global$m = global$M;
  var uncurryThis$f = functionUncurryThis;
  var isObject$8 = isObject$f;
  var createNonEnumerableProperty$4 = createNonEnumerableProperty$6;
  var hasOwn$b = hasOwnProperty_1;
  var shared$1 = sharedStore;
  var sharedKey$3 = sharedKey$4;
  var hiddenKeys$5 = hiddenKeys$6;
  var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
  var TypeError$b = global$m.TypeError;
  var WeakMap = global$m.WeakMap;
  var set$3, get, has;

  var enforce = function (it) {
    return has(it) ? get(it) : set$3(it, {});
  };

  var getterFor = function (TYPE) {
    return function (it) {
      var state;

      if (!isObject$8(it) || (state = get(it)).type !== TYPE) {
        throw TypeError$b('Incompatible receiver, ' + TYPE + ' required');
      }

      return state;
    };
  };

  if (NATIVE_WEAK_MAP || shared$1.state) {
    var store = shared$1.state || (shared$1.state = new WeakMap());
    var wmget = uncurryThis$f(store.get);
    var wmhas = uncurryThis$f(store.has);
    var wmset = uncurryThis$f(store.set);

    set$3 = function (it, metadata) {
      if (wmhas(store, it)) throw new TypeError$b(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      wmset(store, it, metadata);
      return metadata;
    };

    get = function (it) {
      return wmget(store, it) || {};
    };

    has = function (it) {
      return wmhas(store, it);
    };
  } else {
    var STATE = sharedKey$3('state');
    hiddenKeys$5[STATE] = true;

    set$3 = function (it, metadata) {
      if (hasOwn$b(it, STATE)) throw new TypeError$b(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      createNonEnumerableProperty$4(it, STATE, metadata);
      return metadata;
    };

    get = function (it) {
      return hasOwn$b(it, STATE) ? it[STATE] : {};
    };

    has = function (it) {
      return hasOwn$b(it, STATE);
    };
  }

  var internalState = {
    set: set$3,
    get: get,
    has: has,
    enforce: enforce,
    getterFor: getterFor
  };

  var DESCRIPTORS$b = descriptors;
  var hasOwn$a = hasOwnProperty_1;
  var FunctionPrototype = Function.prototype; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

  var getDescriptor = DESCRIPTORS$b && Object.getOwnPropertyDescriptor;
  var EXISTS = hasOwn$a(FunctionPrototype, 'name'); // additional protection from minified / mangled / dropped function names

  var PROPER = EXISTS && function something() {
    /* empty */
  }.name === 'something';

  var CONFIGURABLE = EXISTS && (!DESCRIPTORS$b || DESCRIPTORS$b && getDescriptor(FunctionPrototype, 'name').configurable);
  var functionName = {
    EXISTS: EXISTS,
    PROPER: PROPER,
    CONFIGURABLE: CONFIGURABLE
  };

  var objectDefineProperties = {};

  var toIntegerOrInfinity$1 = toIntegerOrInfinity$4;
  var max$3 = Math.max;
  var min$1 = Math.min; // Helper for a popular repeating case of the spec:
  // Let integer be ? ToInteger(index).
  // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

  var toAbsoluteIndex$5 = function (index, length) {
    var integer = toIntegerOrInfinity$1(index);
    return integer < 0 ? max$3(integer + length, 0) : min$1(integer, length);
  };

  var toIndexedObject$9 = toIndexedObject$b;
  var toAbsoluteIndex$4 = toAbsoluteIndex$5;
  var lengthOfArrayLike$8 = lengthOfArrayLike$d; // `Array.prototype.{ indexOf, includes }` methods implementation

  var createMethod$2 = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIndexedObject$9($this);
      var length = lengthOfArrayLike$8(O);
      var index = toAbsoluteIndex$4(fromIndex, length);
      var value; // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare -- NaN check

      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++]; // eslint-disable-next-line no-self-compare -- NaN check

        if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
      } else for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };

  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod$2(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod$2(false)
  };

  var uncurryThis$e = functionUncurryThis;
  var hasOwn$9 = hasOwnProperty_1;
  var toIndexedObject$8 = toIndexedObject$b;
  var indexOf = arrayIncludes.indexOf;
  var hiddenKeys$4 = hiddenKeys$6;
  var push$4 = uncurryThis$e([].push);

  var objectKeysInternal = function (object, names) {
    var O = toIndexedObject$8(object);
    var i = 0;
    var result = [];
    var key;

    for (key in O) !hasOwn$9(hiddenKeys$4, key) && hasOwn$9(O, key) && push$4(result, key); // Don't enum bug & hidden keys


    while (names.length > i) if (hasOwn$9(O, key = names[i++])) {
      ~indexOf(result, key) || push$4(result, key);
    }

    return result;
  };

  var enumBugKeys$3 = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

  var internalObjectKeys$1 = objectKeysInternal;
  var enumBugKeys$2 = enumBugKeys$3; // `Object.keys` method
  // https://tc39.es/ecma262/#sec-object.keys
  // eslint-disable-next-line es/no-object-keys -- safe

  var objectKeys$4 = Object.keys || function keys(O) {
    return internalObjectKeys$1(O, enumBugKeys$2);
  };

  var DESCRIPTORS$a = descriptors;
  var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
  var definePropertyModule$3 = objectDefineProperty;
  var anObject$9 = anObject$b;
  var toIndexedObject$7 = toIndexedObject$b;
  var objectKeys$3 = objectKeys$4; // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  // eslint-disable-next-line es/no-object-defineproperties -- safe

  objectDefineProperties.f = DESCRIPTORS$a && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject$9(O);
    var props = toIndexedObject$7(Properties);
    var keys = objectKeys$3(Properties);
    var length = keys.length;
    var index = 0;
    var key;

    while (length > index) definePropertyModule$3.f(O, key = keys[index++], props[key]);

    return O;
  };

  var getBuiltIn$5 = getBuiltIn$9;
  var html$1 = getBuiltIn$5('document', 'documentElement');

  /* global ActiveXObject -- old IE, WSH */
  var anObject$8 = anObject$b;
  var definePropertiesModule$1 = objectDefineProperties;
  var enumBugKeys$1 = enumBugKeys$3;
  var hiddenKeys$3 = hiddenKeys$6;
  var html = html$1;
  var documentCreateElement = documentCreateElement$1;
  var sharedKey$2 = sharedKey$4;
  var GT = '>';
  var LT = '<';
  var PROTOTYPE$1 = 'prototype';
  var SCRIPT = 'script';
  var IE_PROTO$1 = sharedKey$2('IE_PROTO');

  var EmptyConstructor = function () {
    /* empty */
  };

  var scriptTag = function (content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
  }; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


  var NullProtoObjectViaActiveX = function (activeXDocument) {
    activeXDocument.write(scriptTag(''));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak

    return temp;
  }; // Create object with fake `null` prototype: use iframe Object with cleared prototype


  var NullProtoObjectViaIFrame = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag('document.F=Object'));
    iframeDocument.close();
    return iframeDocument.F;
  }; // Check for document.domain and active x support
  // No need to use active x approach when document.domain is not set
  // see https://github.com/es-shims/es5-shim/issues/150
  // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
  // avoid IE GC bug


  var activeXDocument;

  var NullProtoObject = function () {
    try {
      activeXDocument = new ActiveXObject('htmlfile');
    } catch (error) {
      /* ignore */
    }

    NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE
    : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH

    var length = enumBugKeys$1.length;

    while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys$1[length]];

    return NullProtoObject();
  };

  hiddenKeys$3[IE_PROTO$1] = true; // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create

  var objectCreate = Object.create || function create(O, Properties) {
    var result;

    if (O !== null) {
      EmptyConstructor[PROTOTYPE$1] = anObject$8(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE$1] = null; // add "__proto__" for Object.getPrototypeOf polyfill

      result[IE_PROTO$1] = O;
    } else result = NullProtoObject();

    return Properties === undefined ? result : definePropertiesModule$1.f(result, Properties);
  };

  var fails$g = fails$r;
  var correctPrototypeGetter = !fails$g(function () {
    function F() {
      /* empty */
    }

    F.prototype.constructor = null; // eslint-disable-next-line es/no-object-getprototypeof -- required for testing

    return Object.getPrototypeOf(new F()) !== F.prototype;
  });

  var global$l = global$M;
  var hasOwn$8 = hasOwnProperty_1;
  var isCallable$5 = isCallable$h;
  var toObject$9 = toObject$e;
  var sharedKey$1 = sharedKey$4;
  var CORRECT_PROTOTYPE_GETTER$1 = correctPrototypeGetter;
  var IE_PROTO = sharedKey$1('IE_PROTO');
  var Object$4 = global$l.Object;
  var ObjectPrototype$2 = Object$4.prototype; // `Object.getPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.getprototypeof

  var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER$1 ? Object$4.getPrototypeOf : function (O) {
    var object = toObject$9(O);
    if (hasOwn$8(object, IE_PROTO)) return object[IE_PROTO];
    var constructor = object.constructor;

    if (isCallable$5(constructor) && object instanceof constructor) {
      return constructor.prototype;
    }

    return object instanceof Object$4 ? ObjectPrototype$2 : null;
  };

  var createNonEnumerableProperty$3 = createNonEnumerableProperty$6;

  var redefine$4 = function (target, key, value, options) {
    if (options && options.enumerable) target[key] = value;else createNonEnumerableProperty$3(target, key, value);
  };

  var fails$f = fails$r;
  var isCallable$4 = isCallable$h;
  var create$a = objectCreate;
  var getPrototypeOf$6 = objectGetPrototypeOf;
  var redefine$3 = redefine$4;
  var wellKnownSymbol$d = wellKnownSymbol$j;
  var ITERATOR$5 = wellKnownSymbol$d('iterator');
  var BUGGY_SAFARI_ITERATORS$1 = false; // `%IteratorPrototype%` object
  // https://tc39.es/ecma262/#sec-%iteratorprototype%-object

  var IteratorPrototype$1, PrototypeOfArrayIteratorPrototype, arrayIterator;
  /* eslint-disable es/no-array-prototype-keys -- safe */

  if ([].keys) {
    arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;else {
      PrototypeOfArrayIteratorPrototype = getPrototypeOf$6(getPrototypeOf$6(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;
    }
  }

  var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$1 == undefined || fails$f(function () {
    var test = {}; // FF44- legacy iterators case

    return IteratorPrototype$1[ITERATOR$5].call(test) !== test;
  });
  if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$1 = {};else IteratorPrototype$1 = create$a(IteratorPrototype$1); // `%IteratorPrototype%[@@iterator]()` method
  // https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator

  if (!isCallable$4(IteratorPrototype$1[ITERATOR$5])) {
    redefine$3(IteratorPrototype$1, ITERATOR$5, function () {
      return this;
    });
  }

  var iteratorsCore = {
    IteratorPrototype: IteratorPrototype$1,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
  };

  var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
  var classof$9 = classof$c; // `Object.prototype.toString` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.tostring

  var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {
    return '[object ' + classof$9(this) + ']';
  };

  var TO_STRING_TAG_SUPPORT = toStringTagSupport;
  var defineProperty$6 = objectDefineProperty.f;
  var createNonEnumerableProperty$2 = createNonEnumerableProperty$6;
  var hasOwn$7 = hasOwnProperty_1;
  var toString$5 = objectToString;
  var wellKnownSymbol$c = wellKnownSymbol$j;
  var TO_STRING_TAG$1 = wellKnownSymbol$c('toStringTag');

  var setToStringTag$5 = function (it, TAG, STATIC, SET_METHOD) {
    if (it) {
      var target = STATIC ? it : it.prototype;

      if (!hasOwn$7(target, TO_STRING_TAG$1)) {
        defineProperty$6(target, TO_STRING_TAG$1, {
          configurable: true,
          value: TAG
        });
      }

      if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
        createNonEnumerableProperty$2(target, 'toString', toString$5);
      }
    }
  };

  var iterators = {};

  var IteratorPrototype = iteratorsCore.IteratorPrototype;
  var create$9 = objectCreate;
  var createPropertyDescriptor$2 = createPropertyDescriptor$5;
  var setToStringTag$4 = setToStringTag$5;
  var Iterators$5 = iterators;

  var returnThis$1 = function () {
    return this;
  };

  var createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
    var TO_STRING_TAG = NAME + ' Iterator';
    IteratorConstructor.prototype = create$9(IteratorPrototype, {
      next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next)
    });
    setToStringTag$4(IteratorConstructor, TO_STRING_TAG, false, true);
    Iterators$5[TO_STRING_TAG] = returnThis$1;
    return IteratorConstructor;
  };

  var global$k = global$M;
  var isCallable$3 = isCallable$h;
  var String$1 = global$k.String;
  var TypeError$a = global$k.TypeError;

  var aPossiblePrototype$1 = function (argument) {
    if (typeof argument == 'object' || isCallable$3(argument)) return argument;
    throw TypeError$a("Can't set " + String$1(argument) + ' as a prototype');
  };

  /* eslint-disable no-proto -- safe */
  var uncurryThis$d = functionUncurryThis;
  var anObject$7 = anObject$b;
  var aPossiblePrototype = aPossiblePrototype$1; // `Object.setPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.setprototypeof
  // Works with __proto__ only. Old v8 can't work with null proto objects.
  // eslint-disable-next-line es/no-object-setprototypeof -- safe

  var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;

    try {
      // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
      setter = uncurryThis$d(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
      setter(test, []);
      CORRECT_SETTER = test instanceof Array;
    } catch (error) {
      /* empty */
    }

    return function setPrototypeOf(O, proto) {
      anObject$7(O);
      aPossiblePrototype(proto);
      if (CORRECT_SETTER) setter(O, proto);else O.__proto__ = proto;
      return O;
    };
  }() : undefined);

  var $$w = _export;
  var call$6 = functionCall;
  var FunctionName = functionName;
  var createIteratorConstructor = createIteratorConstructor$1;
  var getPrototypeOf$5 = objectGetPrototypeOf;
  var setToStringTag$3 = setToStringTag$5;
  var redefine$2 = redefine$4;
  var wellKnownSymbol$b = wellKnownSymbol$j;
  var Iterators$4 = iterators;
  var IteratorsCore = iteratorsCore;
  var PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;
  var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$4 = wellKnownSymbol$b('iterator');
  var KEYS = 'keys';
  var VALUES = 'values';
  var ENTRIES = 'entries';

  var returnThis = function () {
    return this;
  };

  var defineIterator$3 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);

    var getIterationMethod = function (KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];

      switch (KIND) {
        case KEYS:
          return function keys() {
            return new IteratorConstructor(this, KIND);
          };

        case VALUES:
          return function values() {
            return new IteratorConstructor(this, KIND);
          };

        case ENTRIES:
          return function entries() {
            return new IteratorConstructor(this, KIND);
          };
      }

      return function () {
        return new IteratorConstructor(this);
      };
    };

    var TO_STRING_TAG = NAME + ' Iterator';
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$4] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY; // fix native

    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf$5(anyNativeIterator.call(new Iterable()));

      if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {


        setToStringTag$3(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
        Iterators$4[TO_STRING_TAG] = returnThis;
      }
    } // fix Array.prototype.{ values, @@iterator }.name in V8 / FF


    if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      {
        INCORRECT_VALUES_NAME = true;

        defaultIterator = function values() {
          return call$6(nativeIterator, this);
        };
      }
    } // export additional methods


    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine$2(IterablePrototype, KEY, methods[KEY]);
        }
      } else $$w({
        target: NAME,
        proto: true,
        forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
      }, methods);
    } // define iterator


    if ((FORCED) && IterablePrototype[ITERATOR$4] !== defaultIterator) {
      redefine$2(IterablePrototype, ITERATOR$4, defaultIterator, {
        name: DEFAULT
      });
    }

    Iterators$4[NAME] = defaultIterator;
    return methods;
  };

  var charAt$1 = stringMultibyte.charAt;
  var toString$4 = toString$7;
  var InternalStateModule$4 = internalState;
  var defineIterator$2 = defineIterator$3;
  var STRING_ITERATOR = 'String Iterator';
  var setInternalState$4 = InternalStateModule$4.set;
  var getInternalState$2 = InternalStateModule$4.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-string.prototype-@@iterator

  defineIterator$2(String, 'String', function (iterated) {
    setInternalState$4(this, {
      type: STRING_ITERATOR,
      string: toString$4(iterated),
      index: 0
    }); // `%StringIteratorPrototype%.next` method
    // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
  }, function next() {
    var state = getInternalState$2(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return {
      value: undefined,
      done: true
    };
    point = charAt$1(string, index);
    state.index += point.length;
    return {
      value: point,
      done: false
    };
  });

  var call$5 = functionCall;
  var anObject$6 = anObject$b;
  var getMethod$1 = getMethod$3;

  var iteratorClose$2 = function (iterator, kind, value) {
    var innerResult, innerError;
    anObject$6(iterator);

    try {
      innerResult = getMethod$1(iterator, 'return');

      if (!innerResult) {
        if (kind === 'throw') throw value;
        return value;
      }

      innerResult = call$5(innerResult, iterator);
    } catch (error) {
      innerError = true;
      innerResult = error;
    }

    if (kind === 'throw') throw value;
    if (innerError) throw innerResult;
    anObject$6(innerResult);
    return value;
  };

  var anObject$5 = anObject$b;
  var iteratorClose$1 = iteratorClose$2; // call something on iterator step with safe closing on error

  var callWithSafeIterationClosing$1 = function (iterator, fn, value, ENTRIES) {
    try {
      return ENTRIES ? fn(anObject$5(value)[0], value[1]) : fn(value);
    } catch (error) {
      iteratorClose$1(iterator, 'throw', error);
    }
  };

  var wellKnownSymbol$a = wellKnownSymbol$j;
  var Iterators$3 = iterators;
  var ITERATOR$3 = wellKnownSymbol$a('iterator');
  var ArrayPrototype$a = Array.prototype; // check on default Array iterator

  var isArrayIteratorMethod$2 = function (it) {
    return it !== undefined && (Iterators$3.Array === it || ArrayPrototype$a[ITERATOR$3] === it);
  };

  var toPropertyKey$1 = toPropertyKey$4;
  var definePropertyModule$2 = objectDefineProperty;
  var createPropertyDescriptor$1 = createPropertyDescriptor$5;

  var createProperty$6 = function (object, key, value) {
    var propertyKey = toPropertyKey$1(key);
    if (propertyKey in object) definePropertyModule$2.f(object, propertyKey, createPropertyDescriptor$1(0, value));else object[propertyKey] = value;
  };

  var classof$8 = classof$c;
  var getMethod = getMethod$3;
  var Iterators$2 = iterators;
  var wellKnownSymbol$9 = wellKnownSymbol$j;
  var ITERATOR$2 = wellKnownSymbol$9('iterator');

  var getIteratorMethod$8 = function (it) {
    if (it != undefined) return getMethod(it, ITERATOR$2) || getMethod(it, '@@iterator') || Iterators$2[classof$8(it)];
  };

  var global$j = global$M;
  var call$4 = functionCall;
  var aCallable$1 = aCallable$7;
  var anObject$4 = anObject$b;
  var tryToString$2 = tryToString$4;
  var getIteratorMethod$7 = getIteratorMethod$8;
  var TypeError$9 = global$j.TypeError;

  var getIterator$7 = function (argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod$7(argument) : usingIterator;
    if (aCallable$1(iteratorMethod)) return anObject$4(call$4(iteratorMethod, argument));
    throw TypeError$9(tryToString$2(argument) + ' is not iterable');
  };

  var global$i = global$M;
  var bind$3 = functionBindContext;
  var call$3 = functionCall;
  var toObject$8 = toObject$e;
  var callWithSafeIterationClosing = callWithSafeIterationClosing$1;
  var isArrayIteratorMethod$1 = isArrayIteratorMethod$2;
  var isConstructor$2 = isConstructor$4;
  var lengthOfArrayLike$7 = lengthOfArrayLike$d;
  var createProperty$5 = createProperty$6;
  var getIterator$6 = getIterator$7;
  var getIteratorMethod$6 = getIteratorMethod$8;
  var Array$4 = global$i.Array; // `Array.from` method implementation
  // https://tc39.es/ecma262/#sec-array.from

  var arrayFrom = function from(arrayLike
  /* , mapfn = undefined, thisArg = undefined */
  ) {
    var O = toObject$8(arrayLike);
    var IS_CONSTRUCTOR = isConstructor$2(this);
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    if (mapping) mapfn = bind$3(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
    var iteratorMethod = getIteratorMethod$6(O);
    var index = 0;
    var length, result, step, iterator, next, value; // if the target is not iterable or it's an array with the default iterator - use a simple case

    if (iteratorMethod && !(this == Array$4 && isArrayIteratorMethod$1(iteratorMethod))) {
      iterator = getIterator$6(O, iteratorMethod);
      next = iterator.next;
      result = IS_CONSTRUCTOR ? new this() : [];

      for (; !(step = call$3(next, iterator)).done; index++) {
        value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
        createProperty$5(result, index, value);
      }
    } else {
      length = lengthOfArrayLike$7(O);
      result = IS_CONSTRUCTOR ? new this(length) : Array$4(length);

      for (; length > index; index++) {
        value = mapping ? mapfn(O[index], index) : O[index];
        createProperty$5(result, index, value);
      }
    }

    result.length = index;
    return result;
  };

  var wellKnownSymbol$8 = wellKnownSymbol$j;
  var ITERATOR$1 = wellKnownSymbol$8('iterator');
  var SAFE_CLOSING = false;

  try {
    var called = 0;
    var iteratorWithReturn = {
      next: function () {
        return {
          done: !!called++
        };
      },
      'return': function () {
        SAFE_CLOSING = true;
      }
    };

    iteratorWithReturn[ITERATOR$1] = function () {
      return this;
    }; // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing


    Array.from(iteratorWithReturn, function () {
      throw 2;
    });
  } catch (error) {
    /* empty */
  }

  var checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;

    try {
      var object = {};

      object[ITERATOR$1] = function () {
        return {
          next: function () {
            return {
              done: ITERATION_SUPPORT = true
            };
          }
        };
      };

      exec(object);
    } catch (error) {
      /* empty */
    }

    return ITERATION_SUPPORT;
  };

  var $$v = _export;
  var from$6 = arrayFrom;
  var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
  var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
    // eslint-disable-next-line es/no-array-from -- required for testing
    Array.from(iterable);
  }); // `Array.from` method
  // https://tc39.es/ecma262/#sec-array.from

  $$v({
    target: 'Array',
    stat: true,
    forced: INCORRECT_ITERATION
  }, {
    from: from$6
  });

  var path$l = path$q;
  var from$5 = path$l.Array.from;

  var parent$N = from$5;
  var from$4 = parent$N;

  var from$3 = from$4;

  var toIndexedObject$6 = toIndexedObject$b;
  var Iterators$1 = iterators;
  var InternalStateModule$3 = internalState;
  objectDefineProperty.f;
  var defineIterator$1 = defineIterator$3;
  var ARRAY_ITERATOR = 'Array Iterator';
  var setInternalState$3 = InternalStateModule$3.set;
  var getInternalState$1 = InternalStateModule$3.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
  // https://tc39.es/ecma262/#sec-array.prototype.entries
  // `Array.prototype.keys` method
  // https://tc39.es/ecma262/#sec-array.prototype.keys
  // `Array.prototype.values` method
  // https://tc39.es/ecma262/#sec-array.prototype.values
  // `Array.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
  // `CreateArrayIterator` internal method
  // https://tc39.es/ecma262/#sec-createarrayiterator

  defineIterator$1(Array, 'Array', function (iterated, kind) {
    setInternalState$3(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject$6(iterated),
      // target
      index: 0,
      // next index
      kind: kind // kind

    }); // `%ArrayIteratorPrototype%.next` method
    // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
  }, function () {
    var state = getInternalState$1(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;

    if (!target || index >= target.length) {
      state.target = undefined;
      return {
        value: undefined,
        done: true
      };
    }

    if (kind == 'keys') return {
      value: index,
      done: false
    };
    if (kind == 'values') return {
      value: target[index],
      done: false
    };
    return {
      value: [index, target[index]],
      done: false
    };
  }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
  // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
  // https://tc39.es/ecma262/#sec-createmappedargumentsobject

  Iterators$1.Arguments = Iterators$1.Array; // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

  var getIteratorMethod$5 = getIteratorMethod$8;
  var getIteratorMethod_1 = getIteratorMethod$5;

  // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods

  var domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };

  var DOMIterables$4 = domIterables;
  var global$h = global$M;
  var classof$7 = classof$c;
  var createNonEnumerableProperty$1 = createNonEnumerableProperty$6;
  var Iterators = iterators;
  var wellKnownSymbol$7 = wellKnownSymbol$j;
  var TO_STRING_TAG = wellKnownSymbol$7('toStringTag');

  for (var COLLECTION_NAME in DOMIterables$4) {
    var Collection = global$h[COLLECTION_NAME];
    var CollectionPrototype = Collection && Collection.prototype;

    if (CollectionPrototype && classof$7(CollectionPrototype) !== TO_STRING_TAG) {
      createNonEnumerableProperty$1(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }

    Iterators[COLLECTION_NAME] = Iterators.Array;
  }

  var parent$M = getIteratorMethod_1;
  var getIteratorMethod$4 = parent$M;

  var parent$L = getIteratorMethod$4;
  var getIteratorMethod$3 = parent$L;

  var parent$K = getIteratorMethod$3;
  var getIteratorMethod$2 = parent$K;

  var getIteratorMethod$1 = getIteratorMethod$2;

  var objectGetOwnPropertyNames = {};

  var internalObjectKeys = objectKeysInternal;
  var enumBugKeys = enumBugKeys$3;
  var hiddenKeys$2 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  // eslint-disable-next-line es/no-object-getownpropertynames -- safe

  objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys$2);
  };

  var objectGetOwnPropertyNamesExternal = {};

  var global$g = global$M;
  var toAbsoluteIndex$3 = toAbsoluteIndex$5;
  var lengthOfArrayLike$6 = lengthOfArrayLike$d;
  var createProperty$4 = createProperty$6;
  var Array$3 = global$g.Array;
  var max$2 = Math.max;

  var arraySliceSimple = function (O, start, end) {
    var length = lengthOfArrayLike$6(O);
    var k = toAbsoluteIndex$3(start, length);
    var fin = toAbsoluteIndex$3(end === undefined ? length : end, length);
    var result = Array$3(max$2(fin - k, 0));

    for (var n = 0; k < fin; k++, n++) createProperty$4(result, n, O[k]);

    result.length = n;
    return result;
  };

  /* eslint-disable es/no-object-getownpropertynames -- safe */
  var classof$6 = classofRaw$1;
  var toIndexedObject$5 = toIndexedObject$b;
  var $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
  var arraySlice$3 = arraySliceSimple;
  var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

  var getWindowNames = function (it) {
    try {
      return $getOwnPropertyNames$1(it);
    } catch (error) {
      return arraySlice$3(windowNames);
    }
  }; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


  objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
    return windowNames && classof$6(it) == 'Window' ? getWindowNames(it) : $getOwnPropertyNames$1(toIndexedObject$5(it));
  };

  var objectGetOwnPropertySymbols = {};

  objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

  var wellKnownSymbolWrapped = {};

  var wellKnownSymbol$6 = wellKnownSymbol$j;
  wellKnownSymbolWrapped.f = wellKnownSymbol$6;

  var path$k = path$q;
  var hasOwn$6 = hasOwnProperty_1;
  var wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;
  var defineProperty$5 = objectDefineProperty.f;

  var defineWellKnownSymbol$l = function (NAME) {
    var Symbol = path$k.Symbol || (path$k.Symbol = {});
    if (!hasOwn$6(Symbol, NAME)) defineProperty$5(Symbol, NAME, {
      value: wrappedWellKnownSymbolModule$1.f(NAME)
    });
  };

  var $$u = _export;
  var global$f = global$M;
  var getBuiltIn$4 = getBuiltIn$9;
  var apply$4 = functionApply;
  var call$2 = functionCall;
  var uncurryThis$c = functionUncurryThis;
  var DESCRIPTORS$9 = descriptors;
  var NATIVE_SYMBOL = nativeSymbol;
  var fails$e = fails$r;
  var hasOwn$5 = hasOwnProperty_1;
  var isArray$a = isArray$d;
  var isCallable$2 = isCallable$h;
  var isObject$7 = isObject$f;
  var isPrototypeOf$c = objectIsPrototypeOf;
  var isSymbol = isSymbol$3;
  var anObject$3 = anObject$b;
  var toObject$7 = toObject$e;
  var toIndexedObject$4 = toIndexedObject$b;
  var toPropertyKey = toPropertyKey$4;
  var $toString = toString$7;
  var createPropertyDescriptor = createPropertyDescriptor$5;
  var nativeObjectCreate = objectCreate;
  var objectKeys$2 = objectKeys$4;
  var getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames;
  var getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;
  var getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;
  var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
  var definePropertyModule$1 = objectDefineProperty;
  var definePropertiesModule = objectDefineProperties;
  var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
  var arraySlice$2 = arraySlice$5;
  var redefine$1 = redefine$4;
  var shared = shared$4.exports;
  var sharedKey = sharedKey$4;
  var hiddenKeys$1 = hiddenKeys$6;
  var uid$1 = uid$4;
  var wellKnownSymbol$5 = wellKnownSymbol$j;
  var wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
  var defineWellKnownSymbol$k = defineWellKnownSymbol$l;
  var setToStringTag$2 = setToStringTag$5;
  var InternalStateModule$2 = internalState;
  var $forEach$1 = arrayIteration.forEach;
  var HIDDEN = sharedKey('hidden');
  var SYMBOL = 'Symbol';
  var PROTOTYPE = 'prototype';
  var TO_PRIMITIVE = wellKnownSymbol$5('toPrimitive');
  var setInternalState$2 = InternalStateModule$2.set;
  var getInternalState = InternalStateModule$2.getterFor(SYMBOL);
  var ObjectPrototype$1 = Object[PROTOTYPE];
  var $Symbol = global$f.Symbol;
  var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
  var TypeError$8 = global$f.TypeError;
  var QObject = global$f.QObject;
  var $stringify$1 = getBuiltIn$4('JSON', 'stringify');
  var nativeGetOwnPropertyDescriptor$1 = getOwnPropertyDescriptorModule$1.f;
  var nativeDefineProperty = definePropertyModule$1.f;
  var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
  var nativePropertyIsEnumerable = propertyIsEnumerableModule$1.f;
  var push$3 = uncurryThis$c([].push);
  var AllSymbols = shared('symbols');
  var ObjectPrototypeSymbols = shared('op-symbols');
  var StringToSymbolRegistry = shared('string-to-symbol-registry');
  var SymbolToStringRegistry = shared('symbol-to-string-registry');
  var WellKnownSymbolsStore = shared('wks'); // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

  var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

  var setSymbolDescriptor = DESCRIPTORS$9 && fails$e(function () {
    return nativeObjectCreate(nativeDefineProperty({}, 'a', {
      get: function () {
        return nativeDefineProperty(this, 'a', {
          value: 7
        }).a;
      }
    })).a != 7;
  }) ? function (O, P, Attributes) {
    var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype$1, P);
    if (ObjectPrototypeDescriptor) delete ObjectPrototype$1[P];
    nativeDefineProperty(O, P, Attributes);

    if (ObjectPrototypeDescriptor && O !== ObjectPrototype$1) {
      nativeDefineProperty(ObjectPrototype$1, P, ObjectPrototypeDescriptor);
    }
  } : nativeDefineProperty;

  var wrap$1 = function (tag, description) {
    var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
    setInternalState$2(symbol, {
      type: SYMBOL,
      tag: tag,
      description: description
    });
    if (!DESCRIPTORS$9) symbol.description = description;
    return symbol;
  };

  var $defineProperty = function defineProperty(O, P, Attributes) {
    if (O === ObjectPrototype$1) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
    anObject$3(O);
    var key = toPropertyKey(P);
    anObject$3(Attributes);

    if (hasOwn$5(AllSymbols, key)) {
      if (!Attributes.enumerable) {
        if (!hasOwn$5(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
        O[HIDDEN][key] = true;
      } else {
        if (hasOwn$5(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
        Attributes = nativeObjectCreate(Attributes, {
          enumerable: createPropertyDescriptor(0, false)
        });
      }

      return setSymbolDescriptor(O, key, Attributes);
    }

    return nativeDefineProperty(O, key, Attributes);
  };

  var $defineProperties = function defineProperties(O, Properties) {
    anObject$3(O);
    var properties = toIndexedObject$4(Properties);
    var keys = objectKeys$2(properties).concat($getOwnPropertySymbols(properties));
    $forEach$1(keys, function (key) {
      if (!DESCRIPTORS$9 || call$2($propertyIsEnumerable$1, properties, key)) $defineProperty(O, key, properties[key]);
    });
    return O;
  };

  var $create = function create(O, Properties) {
    return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
  };

  var $propertyIsEnumerable$1 = function propertyIsEnumerable(V) {
    var P = toPropertyKey(V);
    var enumerable = call$2(nativePropertyIsEnumerable, this, P);
    if (this === ObjectPrototype$1 && hasOwn$5(AllSymbols, P) && !hasOwn$5(ObjectPrototypeSymbols, P)) return false;
    return enumerable || !hasOwn$5(this, P) || !hasOwn$5(AllSymbols, P) || hasOwn$5(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
  };

  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
    var it = toIndexedObject$4(O);
    var key = toPropertyKey(P);
    if (it === ObjectPrototype$1 && hasOwn$5(AllSymbols, key) && !hasOwn$5(ObjectPrototypeSymbols, key)) return;
    var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);

    if (descriptor && hasOwn$5(AllSymbols, key) && !(hasOwn$5(it, HIDDEN) && it[HIDDEN][key])) {
      descriptor.enumerable = true;
    }

    return descriptor;
  };

  var $getOwnPropertyNames = function getOwnPropertyNames(O) {
    var names = nativeGetOwnPropertyNames(toIndexedObject$4(O));
    var result = [];
    $forEach$1(names, function (key) {
      if (!hasOwn$5(AllSymbols, key) && !hasOwn$5(hiddenKeys$1, key)) push$3(result, key);
    });
    return result;
  };

  var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
    var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$1;
    var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject$4(O));
    var result = [];
    $forEach$1(names, function (key) {
      if (hasOwn$5(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$5(ObjectPrototype$1, key))) {
        push$3(result, AllSymbols[key]);
      }
    });
    return result;
  }; // `Symbol` constructor
  // https://tc39.es/ecma262/#sec-symbol-constructor


  if (!NATIVE_SYMBOL) {
    $Symbol = function Symbol() {
      if (isPrototypeOf$c(SymbolPrototype, this)) throw TypeError$8('Symbol is not a constructor');
      var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
      var tag = uid$1(description);

      var setter = function (value) {
        if (this === ObjectPrototype$1) call$2(setter, ObjectPrototypeSymbols, value);
        if (hasOwn$5(this, HIDDEN) && hasOwn$5(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
        setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
      };

      if (DESCRIPTORS$9 && USE_SETTER) setSymbolDescriptor(ObjectPrototype$1, tag, {
        configurable: true,
        set: setter
      });
      return wrap$1(tag, description);
    };

    SymbolPrototype = $Symbol[PROTOTYPE];
    redefine$1(SymbolPrototype, 'toString', function toString() {
      return getInternalState(this).tag;
    });
    redefine$1($Symbol, 'withoutSetter', function (description) {
      return wrap$1(uid$1(description), description);
    });
    propertyIsEnumerableModule$1.f = $propertyIsEnumerable$1;
    definePropertyModule$1.f = $defineProperty;
    definePropertiesModule.f = $defineProperties;
    getOwnPropertyDescriptorModule$1.f = $getOwnPropertyDescriptor;
    getOwnPropertyNamesModule$2.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
    getOwnPropertySymbolsModule$2.f = $getOwnPropertySymbols;

    wrappedWellKnownSymbolModule.f = function (name) {
      return wrap$1(wellKnownSymbol$5(name), name);
    };

    if (DESCRIPTORS$9) {
      // https://github.com/tc39/proposal-Symbol-description
      nativeDefineProperty(SymbolPrototype, 'description', {
        configurable: true,
        get: function description() {
          return getInternalState(this).description;
        }
      });
    }
  }

  $$u({
    global: true,
    wrap: true,
    forced: !NATIVE_SYMBOL,
    sham: !NATIVE_SYMBOL
  }, {
    Symbol: $Symbol
  });
  $forEach$1(objectKeys$2(WellKnownSymbolsStore), function (name) {
    defineWellKnownSymbol$k(name);
  });
  $$u({
    target: SYMBOL,
    stat: true,
    forced: !NATIVE_SYMBOL
  }, {
    // `Symbol.for` method
    // https://tc39.es/ecma262/#sec-symbol.for
    'for': function (key) {
      var string = $toString(key);
      if (hasOwn$5(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
      var symbol = $Symbol(string);
      StringToSymbolRegistry[string] = symbol;
      SymbolToStringRegistry[symbol] = string;
      return symbol;
    },
    // `Symbol.keyFor` method
    // https://tc39.es/ecma262/#sec-symbol.keyfor
    keyFor: function keyFor(sym) {
      if (!isSymbol(sym)) throw TypeError$8(sym + ' is not a symbol');
      if (hasOwn$5(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
    },
    useSetter: function () {
      USE_SETTER = true;
    },
    useSimple: function () {
      USE_SETTER = false;
    }
  });
  $$u({
    target: 'Object',
    stat: true,
    forced: !NATIVE_SYMBOL,
    sham: !DESCRIPTORS$9
  }, {
    // `Object.create` method
    // https://tc39.es/ecma262/#sec-object.create
    create: $create,
    // `Object.defineProperty` method
    // https://tc39.es/ecma262/#sec-object.defineproperty
    defineProperty: $defineProperty,
    // `Object.defineProperties` method
    // https://tc39.es/ecma262/#sec-object.defineproperties
    defineProperties: $defineProperties,
    // `Object.getOwnPropertyDescriptor` method
    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor
  });
  $$u({
    target: 'Object',
    stat: true,
    forced: !NATIVE_SYMBOL
  }, {
    // `Object.getOwnPropertyNames` method
    // https://tc39.es/ecma262/#sec-object.getownpropertynames
    getOwnPropertyNames: $getOwnPropertyNames,
    // `Object.getOwnPropertySymbols` method
    // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
    getOwnPropertySymbols: $getOwnPropertySymbols
  }); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
  // https://bugs.chromium.org/p/v8/issues/detail?id=3443

  $$u({
    target: 'Object',
    stat: true,
    forced: fails$e(function () {
      getOwnPropertySymbolsModule$2.f(1);
    })
  }, {
    getOwnPropertySymbols: function getOwnPropertySymbols(it) {
      return getOwnPropertySymbolsModule$2.f(toObject$7(it));
    }
  }); // `JSON.stringify` method behavior with symbols
  // https://tc39.es/ecma262/#sec-json.stringify

  if ($stringify$1) {
    var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails$e(function () {
      var symbol = $Symbol(); // MS Edge converts symbol values to JSON as {}

      return $stringify$1([symbol]) != '[null]' // WebKit converts symbol values to JSON as null
      || $stringify$1({
        a: symbol
      }) != '{}' // V8 throws on boxed symbols
      || $stringify$1(Object(symbol)) != '{}';
    });
    $$u({
      target: 'JSON',
      stat: true,
      forced: FORCED_JSON_STRINGIFY
    }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      stringify: function stringify(it, replacer, space) {
        var args = arraySlice$2(arguments);
        var $replacer = replacer;
        if (!isObject$7(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

        if (!isArray$a(replacer)) replacer = function (key, value) {
          if (isCallable$2($replacer)) value = call$2($replacer, this, key, value);
          if (!isSymbol(value)) return value;
        };
        args[1] = replacer;
        return apply$4($stringify$1, null, args);
      }
    });
  } // `Symbol.prototype[@@toPrimitive]` method
  // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive


  if (!SymbolPrototype[TO_PRIMITIVE]) {
    var valueOf = SymbolPrototype.valueOf; // eslint-disable-next-line no-unused-vars -- required for .length

    redefine$1(SymbolPrototype, TO_PRIMITIVE, function (hint) {
      // TODO: improve hint logic
      return call$2(valueOf, this);
    });
  } // `Symbol.prototype[@@toStringTag]` property
  // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag


  setToStringTag$2($Symbol, SYMBOL);
  hiddenKeys$1[HIDDEN] = true;

  var path$j = path$q;
  var getOwnPropertySymbols$2 = path$j.Object.getOwnPropertySymbols;

  var parent$J = getOwnPropertySymbols$2;
  var getOwnPropertySymbols$1 = parent$J;

  var getOwnPropertySymbols = getOwnPropertySymbols$1;

  var getOwnPropertyDescriptor$3 = {exports: {}};

  var $$t = _export;
  var fails$d = fails$r;
  var toIndexedObject$3 = toIndexedObject$b;
  var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  var DESCRIPTORS$8 = descriptors;
  var FAILS_ON_PRIMITIVES$3 = fails$d(function () {
    nativeGetOwnPropertyDescriptor(1);
  });
  var FORCED$5 = !DESCRIPTORS$8 || FAILS_ON_PRIMITIVES$3; // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

  $$t({
    target: 'Object',
    stat: true,
    forced: FORCED$5,
    sham: !DESCRIPTORS$8
  }, {
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
      return nativeGetOwnPropertyDescriptor(toIndexedObject$3(it), key);
    }
  });

  var path$i = path$q;
  var Object$3 = path$i.Object;

  var getOwnPropertyDescriptor$2 = getOwnPropertyDescriptor$3.exports = function getOwnPropertyDescriptor(it, key) {
    return Object$3.getOwnPropertyDescriptor(it, key);
  };

  if (Object$3.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor$2.sham = true;

  var parent$I = getOwnPropertyDescriptor$3.exports;
  var getOwnPropertyDescriptor$1 = parent$I;

  var getOwnPropertyDescriptor = getOwnPropertyDescriptor$1;

  var getBuiltIn$3 = getBuiltIn$9;
  var uncurryThis$b = functionUncurryThis;
  var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
  var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
  var anObject$2 = anObject$b;
  var concat$5 = uncurryThis$b([].concat); // all object keys, includes non-enumerable and symbols

  var ownKeys$6 = getBuiltIn$3('Reflect', 'ownKeys') || function ownKeys(it) {
    var keys = getOwnPropertyNamesModule$1.f(anObject$2(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;
    return getOwnPropertySymbols ? concat$5(keys, getOwnPropertySymbols(it)) : keys;
  };

  var $$s = _export;
  var DESCRIPTORS$7 = descriptors;
  var ownKeys$5 = ownKeys$6;
  var toIndexedObject$2 = toIndexedObject$b;
  var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
  var createProperty$3 = createProperty$6; // `Object.getOwnPropertyDescriptors` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors

  $$s({
    target: 'Object',
    stat: true,
    sham: !DESCRIPTORS$7
  }, {
    getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
      var O = toIndexedObject$2(object);
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      var keys = ownKeys$5(O);
      var result = {};
      var index = 0;
      var key, descriptor;

      while (keys.length > index) {
        descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
        if (descriptor !== undefined) createProperty$3(result, key, descriptor);
      }

      return result;
    }
  });

  var path$h = path$q;
  var getOwnPropertyDescriptors$2 = path$h.Object.getOwnPropertyDescriptors;

  var parent$H = getOwnPropertyDescriptors$2;
  var getOwnPropertyDescriptors$1 = parent$H;

  var getOwnPropertyDescriptors = getOwnPropertyDescriptors$1;

  var defineProperties$4 = {exports: {}};

  var $$r = _export;
  var DESCRIPTORS$6 = descriptors;
  var defineProperties$3 = objectDefineProperties.f; // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  // eslint-disable-next-line es/no-object-defineproperties -- safe

  $$r({
    target: 'Object',
    stat: true,
    forced: Object.defineProperties !== defineProperties$3,
    sham: !DESCRIPTORS$6
  }, {
    defineProperties: defineProperties$3
  });

  var path$g = path$q;
  var Object$2 = path$g.Object;

  var defineProperties$2 = defineProperties$4.exports = function defineProperties(T, D) {
    return Object$2.defineProperties(T, D);
  };

  if (Object$2.defineProperties.sham) defineProperties$2.sham = true;

  var parent$G = defineProperties$4.exports;
  var defineProperties$1 = parent$G;

  var defineProperties = defineProperties$1;

  var defineProperty$4 = defineProperty$a;

  var $$q = _export;
  var isArray$9 = isArray$d; // `Array.isArray` method
  // https://tc39.es/ecma262/#sec-array.isarray

  $$q({
    target: 'Array',
    stat: true
  }, {
    isArray: isArray$9
  });

  var path$f = path$q;
  var isArray$8 = path$f.Array.isArray;

  var parent$F = isArray$8;
  var isArray$7 = parent$F;

  var parent$E = isArray$7;
  var isArray$6 = parent$E;

  var parent$D = isArray$6;
  var isArray$5 = parent$D;

  var isArray$4 = isArray$5;

  function _arrayWithHoles(arr) {
    if (isArray$4(arr)) return arr;
  }

  var $$p = _export;
  var global$e = global$M;
  var fails$c = fails$r;
  var isArray$3 = isArray$d;
  var isObject$6 = isObject$f;
  var toObject$6 = toObject$e;
  var lengthOfArrayLike$5 = lengthOfArrayLike$d;
  var createProperty$2 = createProperty$6;
  var arraySpeciesCreate$1 = arraySpeciesCreate$4;
  var arrayMethodHasSpeciesSupport$2 = arrayMethodHasSpeciesSupport$5;
  var wellKnownSymbol$4 = wellKnownSymbol$j;
  var V8_VERSION = engineV8Version;
  var IS_CONCAT_SPREADABLE = wellKnownSymbol$4('isConcatSpreadable');
  var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
  var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';
  var TypeError$7 = global$e.TypeError; // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/679

  var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails$c(function () {
    var array = [];
    array[IS_CONCAT_SPREADABLE] = false;
    return array.concat()[0] !== array;
  });
  var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport$2('concat');

  var isConcatSpreadable = function (O) {
    if (!isObject$6(O)) return false;
    var spreadable = O[IS_CONCAT_SPREADABLE];
    return spreadable !== undefined ? !!spreadable : isArray$3(O);
  };

  var FORCED$4 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method
  // https://tc39.es/ecma262/#sec-array.prototype.concat
  // with adding support of @@isConcatSpreadable and @@species

  $$p({
    target: 'Array',
    proto: true,
    forced: FORCED$4
  }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    concat: function concat(arg) {
      var O = toObject$6(this);
      var A = arraySpeciesCreate$1(O, 0);
      var n = 0;
      var i, k, length, len, E;

      for (i = -1, length = arguments.length; i < length; i++) {
        E = i === -1 ? O : arguments[i];

        if (isConcatSpreadable(E)) {
          len = lengthOfArrayLike$5(E);
          if (n + len > MAX_SAFE_INTEGER$1) throw TypeError$7(MAXIMUM_ALLOWED_INDEX_EXCEEDED);

          for (k = 0; k < len; k++, n++) if (k in E) createProperty$2(A, n, E[k]);
        } else {
          if (n >= MAX_SAFE_INTEGER$1) throw TypeError$7(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
          createProperty$2(A, n++, E);
        }
      }

      A.length = n;
      return A;
    }
  });

  var defineWellKnownSymbol$j = defineWellKnownSymbol$l; // `Symbol.asyncIterator` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.asynciterator

  defineWellKnownSymbol$j('asyncIterator');

  var defineWellKnownSymbol$i = defineWellKnownSymbol$l; // `Symbol.hasInstance` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.hasinstance

  defineWellKnownSymbol$i('hasInstance');

  var defineWellKnownSymbol$h = defineWellKnownSymbol$l; // `Symbol.isConcatSpreadable` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.isconcatspreadable

  defineWellKnownSymbol$h('isConcatSpreadable');

  var defineWellKnownSymbol$g = defineWellKnownSymbol$l; // `Symbol.iterator` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.iterator

  defineWellKnownSymbol$g('iterator');

  var defineWellKnownSymbol$f = defineWellKnownSymbol$l; // `Symbol.match` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.match

  defineWellKnownSymbol$f('match');

  var defineWellKnownSymbol$e = defineWellKnownSymbol$l; // `Symbol.matchAll` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.matchall

  defineWellKnownSymbol$e('matchAll');

  var defineWellKnownSymbol$d = defineWellKnownSymbol$l; // `Symbol.replace` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.replace

  defineWellKnownSymbol$d('replace');

  var defineWellKnownSymbol$c = defineWellKnownSymbol$l; // `Symbol.search` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.search

  defineWellKnownSymbol$c('search');

  var defineWellKnownSymbol$b = defineWellKnownSymbol$l; // `Symbol.species` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.species

  defineWellKnownSymbol$b('species');

  var defineWellKnownSymbol$a = defineWellKnownSymbol$l; // `Symbol.split` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.split

  defineWellKnownSymbol$a('split');

  var defineWellKnownSymbol$9 = defineWellKnownSymbol$l; // `Symbol.toPrimitive` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.toprimitive

  defineWellKnownSymbol$9('toPrimitive');

  var defineWellKnownSymbol$8 = defineWellKnownSymbol$l; // `Symbol.toStringTag` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.tostringtag

  defineWellKnownSymbol$8('toStringTag');

  var defineWellKnownSymbol$7 = defineWellKnownSymbol$l; // `Symbol.unscopables` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.unscopables

  defineWellKnownSymbol$7('unscopables');

  var global$d = global$M;
  var setToStringTag$1 = setToStringTag$5; // JSON[@@toStringTag] property
  // https://tc39.es/ecma262/#sec-json-@@tostringtag

  setToStringTag$1(global$d.JSON, 'JSON', true);

  var path$e = path$q;
  var symbol$5 = path$e.Symbol;

  var parent$C = symbol$5;
  var symbol$4 = parent$C;

  var parent$B = symbol$4;
  var symbol$3 = parent$B;

  var defineWellKnownSymbol$6 = defineWellKnownSymbol$l; // `Symbol.asyncDispose` well-known symbol
  // https://github.com/tc39/proposal-using-statement

  defineWellKnownSymbol$6('asyncDispose');

  var defineWellKnownSymbol$5 = defineWellKnownSymbol$l; // `Symbol.dispose` well-known symbol
  // https://github.com/tc39/proposal-using-statement

  defineWellKnownSymbol$5('dispose');

  var defineWellKnownSymbol$4 = defineWellKnownSymbol$l; // `Symbol.matcher` well-known symbol
  // https://github.com/tc39/proposal-pattern-matching

  defineWellKnownSymbol$4('matcher');

  var defineWellKnownSymbol$3 = defineWellKnownSymbol$l; // `Symbol.metadata` well-known symbol
  // https://github.com/tc39/proposal-decorators

  defineWellKnownSymbol$3('metadata');

  var defineWellKnownSymbol$2 = defineWellKnownSymbol$l; // `Symbol.observable` well-known symbol
  // https://github.com/tc39/proposal-observable

  defineWellKnownSymbol$2('observable');

  var defineWellKnownSymbol$1 = defineWellKnownSymbol$l; // `Symbol.patternMatch` well-known symbol
  // https://github.com/tc39/proposal-pattern-matching

  defineWellKnownSymbol$1('patternMatch');

  var defineWellKnownSymbol = defineWellKnownSymbol$l;
  defineWellKnownSymbol('replaceAll');

  var parent$A = symbol$3; // TODO: Remove from `core-js@4`
  // TODO: Remove from `core-js@4`

  var symbol$2 = parent$A;

  var symbol$1 = symbol$2;

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof symbol$1 !== "undefined" && getIteratorMethod$1(arr) || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  var $$o = _export;
  var global$c = global$M;
  var isArray$2 = isArray$d;
  var isConstructor$1 = isConstructor$4;
  var isObject$5 = isObject$f;
  var toAbsoluteIndex$2 = toAbsoluteIndex$5;
  var lengthOfArrayLike$4 = lengthOfArrayLike$d;
  var toIndexedObject$1 = toIndexedObject$b;
  var createProperty$1 = createProperty$6;
  var wellKnownSymbol$3 = wellKnownSymbol$j;
  var arrayMethodHasSpeciesSupport$1 = arrayMethodHasSpeciesSupport$5;
  var un$Slice = arraySlice$5;
  var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$1('slice');
  var SPECIES$1 = wellKnownSymbol$3('species');
  var Array$2 = global$c.Array;
  var max$1 = Math.max; // `Array.prototype.slice` method
  // https://tc39.es/ecma262/#sec-array.prototype.slice
  // fallback for not array-like ES3 strings and DOM objects

  $$o({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT$1
  }, {
    slice: function slice(start, end) {
      var O = toIndexedObject$1(this);
      var length = lengthOfArrayLike$4(O);
      var k = toAbsoluteIndex$2(start, length);
      var fin = toAbsoluteIndex$2(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible

      var Constructor, result, n;

      if (isArray$2(O)) {
        Constructor = O.constructor; // cross-realm fallback

        if (isConstructor$1(Constructor) && (Constructor === Array$2 || isArray$2(Constructor.prototype))) {
          Constructor = undefined;
        } else if (isObject$5(Constructor)) {
          Constructor = Constructor[SPECIES$1];
          if (Constructor === null) Constructor = undefined;
        }

        if (Constructor === Array$2 || Constructor === undefined) {
          return un$Slice(O, k, fin);
        }
      }

      result = new (Constructor === undefined ? Array$2 : Constructor)(max$1(fin - k, 0));

      for (n = 0; k < fin; k++, n++) if (k in O) createProperty$1(result, n, O[k]);

      result.length = n;
      return result;
    }
  });

  var entryVirtual$e = entryVirtual$k;
  var slice$6 = entryVirtual$e('Array').slice;

  var isPrototypeOf$b = objectIsPrototypeOf;
  var method$9 = slice$6;
  var ArrayPrototype$9 = Array.prototype;

  var slice$5 = function (it) {
    var own = it.slice;
    return it === ArrayPrototype$9 || isPrototypeOf$b(ArrayPrototype$9, it) && own === ArrayPrototype$9.slice ? method$9 : own;
  };

  var parent$z = slice$5;
  var slice$4 = parent$z;

  var parent$y = slice$4;
  var slice$3 = parent$y;

  var parent$x = slice$3;
  var slice$2 = parent$x;

  var slice$1 = slice$2;

  var parent$w = from$4;
  var from$2 = parent$w;

  var parent$v = from$2;
  var from$1 = parent$v;

  var from = from$1;

  function _arrayLikeToArray$4(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _unsupportedIterableToArray$4(o, minLen) {
    var _context;

    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);

    var n = slice$1(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);

    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$4(arr, i) || _nonIterableRest();
  }

  var WrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
  var iterator$5 = WrappedWellKnownSymbolModule.f('iterator');

  var parent$u = iterator$5;
  var iterator$4 = parent$u;

  var parent$t = iterator$4;
  var iterator$3 = parent$t;

  var parent$s = iterator$3;
  var iterator$2 = parent$s;

  var iterator$1 = iterator$2;

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof symbol$1 && "symbol" == typeof iterator$1 ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof symbol$1 && obj.constructor === symbol$1 && obj !== symbol$1.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function _arrayWithoutHoles(arr) {
    if (isArray$4(arr)) return _arrayLikeToArray$4(arr);
  }

  function _iterableToArray(iter) {
    if (typeof symbol$1 !== "undefined" && getIteratorMethod$1(iter) != null || iter["@@iterator"] != null) return from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread();
  }

  var symbol = symbol$4;

  var entryVirtual$d = entryVirtual$k;
  var concat$4 = entryVirtual$d('Array').concat;

  var isPrototypeOf$a = objectIsPrototypeOf;
  var method$8 = concat$4;
  var ArrayPrototype$8 = Array.prototype;

  var concat$3 = function (it) {
    var own = it.concat;
    return it === ArrayPrototype$8 || isPrototypeOf$a(ArrayPrototype$8, it) && own === ArrayPrototype$8.concat ? method$8 : own;
  };

  var parent$r = concat$3;
  var concat$2 = parent$r;

  var concat$1 = concat$2;

  var slice = slice$4;

  var $$n = _export;
  var ownKeys$4 = ownKeys$6; // `Reflect.ownKeys` method
  // https://tc39.es/ecma262/#sec-reflect.ownkeys

  $$n({
    target: 'Reflect',
    stat: true
  }, {
    ownKeys: ownKeys$4
  });

  var path$d = path$q;
  var ownKeys$3 = path$d.Reflect.ownKeys;

  var parent$q = ownKeys$3;
  var ownKeys$2 = parent$q;

  var ownKeys$1 = ownKeys$2;

  var isArray$1 = isArray$7;

  var $$m = _export;
  var toObject$5 = toObject$e;
  var nativeKeys = objectKeys$4;
  var fails$b = fails$r;
  var FAILS_ON_PRIMITIVES$2 = fails$b(function () {
    nativeKeys(1);
  }); // `Object.keys` method
  // https://tc39.es/ecma262/#sec-object.keys

  $$m({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES$2
  }, {
    keys: function keys(it) {
      return nativeKeys(toObject$5(it));
    }
  });

  var path$c = path$q;
  var keys$6 = path$c.Object.keys;

  var parent$p = keys$6;
  var keys$5 = parent$p;

  var keys$4 = keys$5;

  var $$l = _export;
  var global$b = global$M;
  var uncurryThis$a = functionUncurryThis;
  var Date$1 = global$b.Date;
  var getTime = uncurryThis$a(Date$1.prototype.getTime); // `Date.now` method
  // https://tc39.es/ecma262/#sec-date.now

  $$l({
    target: 'Date',
    stat: true
  }, {
    now: function now() {
      return getTime(new Date$1());
    }
  });

  var path$b = path$q;
  path$b.Date.now;

  var $forEach = arrayIteration.forEach;
  var arrayMethodIsStrict$3 = arrayMethodIsStrict$5;
  var STRICT_METHOD$3 = arrayMethodIsStrict$3('forEach'); // `Array.prototype.forEach` method implementation
  // https://tc39.es/ecma262/#sec-array.prototype.foreach

  var arrayForEach = !STRICT_METHOD$3 ? function forEach(callbackfn
  /* , thisArg */
  ) {
    return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); // eslint-disable-next-line es/no-array-prototype-foreach -- safe
  } : [].forEach;

  var $$k = _export;
  var forEach$5 = arrayForEach; // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  // eslint-disable-next-line es/no-array-prototype-foreach -- safe

  $$k({
    target: 'Array',
    proto: true,
    forced: [].forEach != forEach$5
  }, {
    forEach: forEach$5
  });

  var entryVirtual$c = entryVirtual$k;
  var forEach$4 = entryVirtual$c('Array').forEach;

  var parent$o = forEach$4;
  var forEach$3 = parent$o;

  var classof$5 = classof$c;
  var hasOwn$4 = hasOwnProperty_1;
  var isPrototypeOf$9 = objectIsPrototypeOf;
  var method$7 = forEach$3;
  var ArrayPrototype$7 = Array.prototype;
  var DOMIterables$3 = {
    DOMTokenList: true,
    NodeList: true
  };

  var forEach$2 = function (it) {
    var own = it.forEach;
    return it === ArrayPrototype$7 || isPrototypeOf$9(ArrayPrototype$7, it) && own === ArrayPrototype$7.forEach || hasOwn$4(DOMIterables$3, classof$5(it)) ? method$7 : own;
  };

  var forEach$1 = forEach$2;

  var $$j = _export;
  var uncurryThis$9 = functionUncurryThis;
  var isArray = isArray$d;
  var un$Reverse = uncurryThis$9([].reverse);
  var test$1 = [1, 2]; // `Array.prototype.reverse` method
  // https://tc39.es/ecma262/#sec-array.prototype.reverse
  // fix for Safari 12.0 bug
  // https://bugs.webkit.org/show_bug.cgi?id=188794

  $$j({
    target: 'Array',
    proto: true,
    forced: String(test$1) === String(test$1.reverse())
  }, {
    reverse: function reverse() {
      // eslint-disable-next-line no-self-assign -- dirty hack
      if (isArray(this)) this.length = this.length;
      return un$Reverse(this);
    }
  });

  var entryVirtual$b = entryVirtual$k;
  var reverse$3 = entryVirtual$b('Array').reverse;

  var isPrototypeOf$8 = objectIsPrototypeOf;
  var method$6 = reverse$3;
  var ArrayPrototype$6 = Array.prototype;

  var reverse$2 = function (it) {
    var own = it.reverse;
    return it === ArrayPrototype$6 || isPrototypeOf$8(ArrayPrototype$6, it) && own === ArrayPrototype$6.reverse ? method$6 : own;
  };

  var parent$n = reverse$2;
  var reverse$1 = parent$n;

  var reverse = reverse$1;

  var $$i = _export;
  var global$a = global$M;
  var toAbsoluteIndex$1 = toAbsoluteIndex$5;
  var toIntegerOrInfinity = toIntegerOrInfinity$4;
  var lengthOfArrayLike$3 = lengthOfArrayLike$d;
  var toObject$4 = toObject$e;
  var arraySpeciesCreate = arraySpeciesCreate$4;
  var createProperty = createProperty$6;
  var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$5;
  var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
  var TypeError$6 = global$a.TypeError;
  var max = Math.max;
  var min = Math.min;
  var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
  var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method
  // https://tc39.es/ecma262/#sec-array.prototype.splice
  // with adding support of @@species

  $$i({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT
  }, {
    splice: function splice(start, deleteCount
    /* , ...items */
    ) {
      var O = toObject$4(this);
      var len = lengthOfArrayLike$3(O);
      var actualStart = toAbsoluteIndex$1(start, len);
      var argumentsLength = arguments.length;
      var insertCount, actualDeleteCount, A, k, from, to;

      if (argumentsLength === 0) {
        insertCount = actualDeleteCount = 0;
      } else if (argumentsLength === 1) {
        insertCount = 0;
        actualDeleteCount = len - actualStart;
      } else {
        insertCount = argumentsLength - 2;
        actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
      }

      if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
        throw TypeError$6(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
      }

      A = arraySpeciesCreate(O, actualDeleteCount);

      for (k = 0; k < actualDeleteCount; k++) {
        from = actualStart + k;
        if (from in O) createProperty(A, k, O[from]);
      }

      A.length = actualDeleteCount;

      if (insertCount < actualDeleteCount) {
        for (k = actualStart; k < len - actualDeleteCount; k++) {
          from = k + actualDeleteCount;
          to = k + insertCount;
          if (from in O) O[to] = O[from];else delete O[to];
        }

        for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
      } else if (insertCount > actualDeleteCount) {
        for (k = len - actualDeleteCount; k > actualStart; k--) {
          from = k + actualDeleteCount - 1;
          to = k + insertCount - 1;
          if (from in O) O[to] = O[from];else delete O[to];
        }
      }

      for (k = 0; k < insertCount; k++) {
        O[k + actualStart] = arguments[k + 2];
      }

      O.length = len - actualDeleteCount + insertCount;
      return A;
    }
  });

  var entryVirtual$a = entryVirtual$k;
  var splice$3 = entryVirtual$a('Array').splice;

  var isPrototypeOf$7 = objectIsPrototypeOf;
  var method$5 = splice$3;
  var ArrayPrototype$5 = Array.prototype;

  var splice$2 = function (it) {
    var own = it.splice;
    return it === ArrayPrototype$5 || isPrototypeOf$7(ArrayPrototype$5, it) && own === ArrayPrototype$5.splice ? method$5 : own;
  };

  var parent$m = splice$2;
  var splice$1 = parent$m;

  var splice = splice$1;

  var DESCRIPTORS$5 = descriptors;
  var uncurryThis$8 = functionUncurryThis;
  var call$1 = functionCall;
  var fails$a = fails$r;
  var objectKeys$1 = objectKeys$4;
  var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
  var propertyIsEnumerableModule = objectPropertyIsEnumerable;
  var toObject$3 = toObject$e;
  var IndexedObject = indexedObject; // eslint-disable-next-line es/no-object-assign -- safe

  var $assign = Object.assign; // eslint-disable-next-line es/no-object-defineproperty -- required for testing

  var defineProperty$3 = Object.defineProperty;
  var concat = uncurryThis$8([].concat); // `Object.assign` method
  // https://tc39.es/ecma262/#sec-object.assign

  var objectAssign = !$assign || fails$a(function () {
    // should have correct order of operations (Edge bug)
    if (DESCRIPTORS$5 && $assign({
      b: 1
    }, $assign(defineProperty$3({}, 'a', {
      enumerable: true,
      get: function () {
        defineProperty$3(this, 'b', {
          value: 3,
          enumerable: false
        });
      }
    }), {
      b: 2
    })).b !== 1) return true; // should work with symbols and should have deterministic property order (V8 bug)

    var A = {};
    var B = {}; // eslint-disable-next-line es/no-symbol -- safe

    var symbol = Symbol();
    var alphabet = 'abcdefghijklmnopqrst';
    A[symbol] = 7;
    alphabet.split('').forEach(function (chr) {
      B[chr] = chr;
    });
    return $assign({}, A)[symbol] != 7 || objectKeys$1($assign({}, B)).join('') != alphabet;
  }) ? function assign(target, source) {
    // eslint-disable-line no-unused-vars -- required for `.length`
    var T = toObject$3(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    var propertyIsEnumerable = propertyIsEnumerableModule.f;

    while (argumentsLength > index) {
      var S = IndexedObject(arguments[index++]);
      var keys = getOwnPropertySymbols ? concat(objectKeys$1(S), getOwnPropertySymbols(S)) : objectKeys$1(S);
      var length = keys.length;
      var j = 0;
      var key;

      while (length > j) {
        key = keys[j++];
        if (!DESCRIPTORS$5 || call$1(propertyIsEnumerable, S, key)) T[key] = S[key];
      }
    }

    return T;
  } : $assign;

  var $$h = _export;
  var assign$5 = objectAssign; // `Object.assign` method
  // https://tc39.es/ecma262/#sec-object.assign
  // eslint-disable-next-line es/no-object-assign -- required for testing

  $$h({
    target: 'Object',
    stat: true,
    forced: Object.assign !== assign$5
  }, {
    assign: assign$5
  });

  var path$a = path$q;
  var assign$4 = path$a.Object.assign;

  var parent$l = assign$4;
  var assign$3 = parent$l;

  var assign$2 = assign$3;

  var $$g = _export;
  var $includes = arrayIncludes.includes;
  // https://tc39.es/ecma262/#sec-array.prototype.includes

  $$g({
    target: 'Array',
    proto: true
  }, {
    includes: function includes(el
    /* , fromIndex = 0 */
    ) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }
  }); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

  var entryVirtual$9 = entryVirtual$k;
  entryVirtual$9('Array').includes;

  var isObject$4 = isObject$f;
  var classof$4 = classofRaw$1;
  var wellKnownSymbol$2 = wellKnownSymbol$j;
  var MATCH$1 = wellKnownSymbol$2('match'); // `IsRegExp` abstract operation
  // https://tc39.es/ecma262/#sec-isregexp

  var isRegexp = function (it) {
    var isRegExp;
    return isObject$4(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$4(it) == 'RegExp');
  };

  var global$9 = global$M;
  var isRegExp = isRegexp;
  var TypeError$5 = global$9.TypeError;

  var notARegexp = function (it) {
    if (isRegExp(it)) {
      throw TypeError$5("The method doesn't accept regular expressions");
    }

    return it;
  };

  var wellKnownSymbol$1 = wellKnownSymbol$j;
  var MATCH = wellKnownSymbol$1('match');

  var correctIsRegexpLogic = function (METHOD_NAME) {
    var regexp = /./;

    try {
      '/./'[METHOD_NAME](regexp);
    } catch (error1) {
      try {
        regexp[MATCH] = false;
        return '/./'[METHOD_NAME](regexp);
      } catch (error2) {
        /* empty */
      }
    }

    return false;
  };

  var $$f = _export;
  var uncurryThis$7 = functionUncurryThis;
  var notARegExp = notARegexp;
  var requireObjectCoercible$1 = requireObjectCoercible$5;
  var toString$3 = toString$7;
  var correctIsRegExpLogic = correctIsRegexpLogic;
  var stringIndexOf = uncurryThis$7(''.indexOf); // `String.prototype.includes` method
  // https://tc39.es/ecma262/#sec-string.prototype.includes

  $$f({
    target: 'String',
    proto: true,
    forced: !correctIsRegExpLogic('includes')
  }, {
    includes: function includes(searchString
    /* , position = 0 */
    ) {
      return !!~stringIndexOf(toString$3(requireObjectCoercible$1(this)), toString$3(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var entryVirtual$8 = entryVirtual$k;
  entryVirtual$8('String').includes;

  var $$e = _export;
  var fails$9 = fails$r;
  var toObject$2 = toObject$e;
  var nativeGetPrototypeOf = objectGetPrototypeOf;
  var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
  var FAILS_ON_PRIMITIVES$1 = fails$9(function () {
    nativeGetPrototypeOf(1);
  }); // `Object.getPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.getprototypeof

  $$e({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES$1,
    sham: !CORRECT_PROTOTYPE_GETTER
  }, {
    getPrototypeOf: function getPrototypeOf(it) {
      return nativeGetPrototypeOf(toObject$2(it));
    }
  });

  var path$9 = path$q;
  var getPrototypeOf$4 = path$9.Object.getPrototypeOf;

  var parent$k = getPrototypeOf$4;
  var getPrototypeOf$3 = parent$k;

  var DESCRIPTORS$4 = descriptors;
  var uncurryThis$6 = functionUncurryThis;
  var objectKeys = objectKeys$4;
  var toIndexedObject = toIndexedObject$b;
  var $propertyIsEnumerable = objectPropertyIsEnumerable.f;
  var propertyIsEnumerable = uncurryThis$6($propertyIsEnumerable);
  var push$2 = uncurryThis$6([].push); // `Object.{ entries, values }` methods implementation

  var createMethod$1 = function (TO_ENTRIES) {
    return function (it) {
      var O = toIndexedObject(it);
      var keys = objectKeys(O);
      var length = keys.length;
      var i = 0;
      var result = [];
      var key;

      while (length > i) {
        key = keys[i++];

        if (!DESCRIPTORS$4 || propertyIsEnumerable(O, key)) {
          push$2(result, TO_ENTRIES ? [key, O[key]] : O[key]);
        }
      }

      return result;
    };
  };

  var objectToArray = {
    // `Object.entries` method
    // https://tc39.es/ecma262/#sec-object.entries
    entries: createMethod$1(true),
    // `Object.values` method
    // https://tc39.es/ecma262/#sec-object.values
    values: createMethod$1(false)
  };

  var $$d = _export;
  var $values = objectToArray.values; // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values

  $$d({
    target: 'Object',
    stat: true
  }, {
    values: function values(O) {
      return $values(O);
    }
  });

  var path$8 = path$q;
  path$8.Object.values;

  var whitespaces$3 = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' + '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

  var uncurryThis$5 = functionUncurryThis;
  var requireObjectCoercible = requireObjectCoercible$5;
  var toString$2 = toString$7;
  var whitespaces$2 = whitespaces$3;
  var replace$1 = uncurryThis$5(''.replace);
  var whitespace = '[' + whitespaces$2 + ']';
  var ltrim = RegExp('^' + whitespace + whitespace + '*');
  var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

  var createMethod = function (TYPE) {
    return function ($this) {
      var string = toString$2(requireObjectCoercible($this));
      if (TYPE & 1) string = replace$1(string, ltrim, '');
      if (TYPE & 2) string = replace$1(string, rtrim, '');
      return string;
    };
  };

  var stringTrim = {
    // `String.prototype.{ trimLeft, trimStart }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimstart
    start: createMethod(1),
    // `String.prototype.{ trimRight, trimEnd }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimend
    end: createMethod(2),
    // `String.prototype.trim` method
    // https://tc39.es/ecma262/#sec-string.prototype.trim
    trim: createMethod(3)
  };

  var global$8 = global$M;
  var fails$8 = fails$r;
  var uncurryThis$4 = functionUncurryThis;
  var toString$1 = toString$7;
  var trim = stringTrim.trim;
  var whitespaces$1 = whitespaces$3;
  var $parseInt$1 = global$8.parseInt;
  var Symbol$1 = global$8.Symbol;
  var ITERATOR = Symbol$1 && Symbol$1.iterator;
  var hex = /^[+-]?0x/i;
  var exec$1 = uncurryThis$4(hex.exec);
  var FORCED$3 = $parseInt$1(whitespaces$1 + '08') !== 8 || $parseInt$1(whitespaces$1 + '0x16') !== 22 // MS Edge 18- broken with boxed symbols
  || ITERATOR && !fails$8(function () {
    $parseInt$1(Object(ITERATOR));
  }); // `parseInt` method
  // https://tc39.es/ecma262/#sec-parseint-string-radix

  var numberParseInt = FORCED$3 ? function parseInt(string, radix) {
    var S = trim(toString$1(string));
    return $parseInt$1(S, radix >>> 0 || (exec$1(hex, S) ? 16 : 10));
  } : $parseInt$1;

  var $$c = _export;
  var $parseInt = numberParseInt; // `parseInt` method
  // https://tc39.es/ecma262/#sec-parseint-string-radix

  $$c({
    global: true,
    forced: parseInt != $parseInt
  }, {
    parseInt: $parseInt
  });

  var path$7 = path$q;
  path$7.parseInt;

  /* eslint-disable es/no-array-prototype-indexof -- required for testing */


  var $$b = _export;
  var uncurryThis$3 = functionUncurryThis;
  var $IndexOf = arrayIncludes.indexOf;
  var arrayMethodIsStrict$2 = arrayMethodIsStrict$5;
  var un$IndexOf = uncurryThis$3([].indexOf);
  var NEGATIVE_ZERO = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;
  var STRICT_METHOD$2 = arrayMethodIsStrict$2('indexOf'); // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof

  $$b({
    target: 'Array',
    proto: true,
    forced: NEGATIVE_ZERO || !STRICT_METHOD$2
  }, {
    indexOf: function indexOf(searchElement
    /* , fromIndex = 0 */
    ) {
      var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
      return NEGATIVE_ZERO // convert -0 to +0
      ? un$IndexOf(this, searchElement, fromIndex) || 0 : $IndexOf(this, searchElement, fromIndex);
    }
  });

  var entryVirtual$7 = entryVirtual$k;
  entryVirtual$7('Array').indexOf;

  var PROPER_FUNCTION_NAME = functionName.PROPER;
  var fails$7 = fails$r;
  var whitespaces = whitespaces$3;
  var non = '\u200B\u0085\u180E'; // check that a method works with the correct list
  // of whitespaces and has a correct name

  var stringTrimForced = function (METHOD_NAME) {
    return fails$7(function () {
      return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
    });
  };

  var $$a = _export;
  var $trim = stringTrim.trim;
  var forcedStringTrimMethod = stringTrimForced; // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim

  $$a({
    target: 'String',
    proto: true,
    forced: forcedStringTrimMethod('trim')
  }, {
    trim: function trim() {
      return $trim(this);
    }
  });

  var entryVirtual$6 = entryVirtual$k;
  entryVirtual$6('String').trim;

  var $$9 = _export;
  var DESCRIPTORS$3 = descriptors;
  var create$8 = objectCreate; // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create

  $$9({
    target: 'Object',
    stat: true,
    sham: !DESCRIPTORS$3
  }, {
    create: create$8
  });

  var path$6 = path$q;
  var Object$1 = path$6.Object;

  var create$7 = function create(P, D) {
    return Object$1.create(P, D);
  };

  var parent$j = create$7;
  var create$6 = parent$j;

  var create$5 = create$6;

  var $$8 = _export;
  var global$7 = global$M;
  var getBuiltIn$2 = getBuiltIn$9;
  var apply$3 = functionApply;
  var uncurryThis$2 = functionUncurryThis;
  var fails$6 = fails$r;
  var Array$1 = global$7.Array;
  var $stringify = getBuiltIn$2('JSON', 'stringify');
  var exec = uncurryThis$2(/./.exec);
  var charAt = uncurryThis$2(''.charAt);
  var charCodeAt = uncurryThis$2(''.charCodeAt);
  var replace = uncurryThis$2(''.replace);
  var numberToString = uncurryThis$2(1.0.toString);
  var tester = /[\uD800-\uDFFF]/g;
  var low = /^[\uD800-\uDBFF]$/;
  var hi = /^[\uDC00-\uDFFF]$/;

  var fix = function (match, offset, string) {
    var prev = charAt(string, offset - 1);
    var next = charAt(string, offset + 1);

    if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
      return '\\u' + numberToString(charCodeAt(match, 0), 16);
    }

    return match;
  };

  var FORCED$2 = fails$6(function () {
    return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"' || $stringify('\uDEAD') !== '"\\udead"';
  });

  if ($stringify) {
    // `JSON.stringify` method
    // https://tc39.es/ecma262/#sec-json.stringify
    // https://github.com/tc39/proposal-well-formed-stringify
    $$8({
      target: 'JSON',
      stat: true,
      forced: FORCED$2
    }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      stringify: function stringify(it, replacer, space) {
        for (var i = 0, l = arguments.length, args = Array$1(l); i < l; i++) args[i] = arguments[i];

        var result = apply$3($stringify, null, args);
        return typeof result == 'string' ? replace(result, tester, fix) : result;
      }
    });
  }

  var path$5 = path$q;
  var apply$2 = functionApply; // eslint-disable-next-line es/no-json -- safe

  if (!path$5.JSON) path$5.JSON = {
    stringify: JSON.stringify
  }; // eslint-disable-next-line no-unused-vars -- required for `.length`

  var stringify$3 = function stringify(it, replacer, space) {
    return apply$2(path$5.JSON.stringify, null, arguments);
  };

  var parent$i = stringify$3;
  var stringify$2 = parent$i;

  var stringify$1 = stringify$2;

  var global$6 = global$M;
  var TypeError$4 = global$6.TypeError;

  var validateArgumentsLength$1 = function (passed, required) {
    if (passed < required) throw TypeError$4('Not enough arguments');
    return passed;
  };

  var $$7 = _export;
  var global$5 = global$M;
  var apply$1 = functionApply;
  var isCallable$1 = isCallable$h;
  var userAgent$2 = engineUserAgent;
  var arraySlice$1 = arraySlice$5;
  var validateArgumentsLength = validateArgumentsLength$1;
  var MSIE = /MSIE .\./.test(userAgent$2); // <- dirty ie9- check

  var Function$1 = global$5.Function;

  var wrap = function (scheduler) {
    return function (handler, timeout
    /* , ...arguments */
    ) {
      var boundArgs = validateArgumentsLength(arguments.length, 1) > 2;
      var fn = isCallable$1(handler) ? handler : Function$1(handler);
      var args = boundArgs ? arraySlice$1(arguments, 2) : undefined;
      return scheduler(boundArgs ? function () {
        apply$1(fn, this, args);
      } : fn, timeout);
    };
  }; // ie9- setTimeout & setInterval additional parameters fix
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers


  $$7({
    global: true,
    bind: true,
    forced: MSIE
  }, {
    // `setTimeout` method
    // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
    setTimeout: wrap(global$5.setTimeout),
    // `setInterval` method
    // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
    setInterval: wrap(global$5.setInterval)
  });

  var path$4 = path$q;
  var setTimeout$2 = path$4.setTimeout;

  var setTimeout$1 = setTimeout$2;

  var toObject$1 = toObject$e;
  var toAbsoluteIndex = toAbsoluteIndex$5;
  var lengthOfArrayLike$2 = lengthOfArrayLike$d; // `Array.prototype.fill` method implementation
  // https://tc39.es/ecma262/#sec-array.prototype.fill

  var arrayFill = function fill(value
  /* , start = 0, end = @length */
  ) {
    var O = toObject$1(this);
    var length = lengthOfArrayLike$2(O);
    var argumentsLength = arguments.length;
    var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
    var end = argumentsLength > 2 ? arguments[2] : undefined;
    var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

    while (endPos > index) O[index++] = value;

    return O;
  };

  var $$6 = _export;
  var fill = arrayFill;
  // https://tc39.es/ecma262/#sec-array.prototype.fill

  $$6({
    target: 'Array',
    proto: true
  }, {
    fill: fill
  }); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

  var entryVirtual$5 = entryVirtual$k;
  entryVirtual$5('Array').fill;

  var componentEmitter = {exports: {}};

  (function (module) {
    /**
     * Expose `Emitter`.
     */
    {
      module.exports = Emitter;
    }
    /**
     * Initialize a new `Emitter`.
     *
     * @api public
     */


    function Emitter(obj) {
      if (obj) return mixin(obj);
    }
    /**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */

    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }

      return obj;
    }
    /**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */


    Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
      return this;
    };
    /**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */


    Emitter.prototype.once = function (event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }

      on.fn = fn;
      this.on(event, on);
      return this;
    };
    /**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */


    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
      this._callbacks = this._callbacks || {}; // all

      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      } // specific event


      var callbacks = this._callbacks['$' + event];
      if (!callbacks) return this; // remove all handlers

      if (1 == arguments.length) {
        delete this._callbacks['$' + event];
        return this;
      } // remove specific handler


      var cb;

      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];

        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      } // Remove event specific arrays for event types that no
      // one is subscribed for to avoid memory leak.


      if (callbacks.length === 0) {
        delete this._callbacks['$' + event];
      }

      return this;
    };
    /**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */


    Emitter.prototype.emit = function (event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1),
          callbacks = this._callbacks['$' + event];

      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }

      if (callbacks) {
        callbacks = callbacks.slice(0);

        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }

      return this;
    };
    /**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */


    Emitter.prototype.listeners = function (event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks['$' + event] || [];
    };
    /**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */


    Emitter.prototype.hasListeners = function (event) {
      return !!this.listeners(event).length;
    };
  })(componentEmitter);

  var Emitter = componentEmitter.exports;

  /*! Hammer.JS - v2.0.17-rc - 2019-12-16
   * http://naver.github.io/egjs
   *
   * Forked By Naver egjs
   * Copyright (c) hammerjs
   * Licensed under the MIT license */
  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _assertThisInitialized$1(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }
  /**
   * @private
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} target
   * @param {...Object} objects_to_assign
   * @returns {Object} target
   */


  var assign;

  if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var output = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];

        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (source.hasOwnProperty(nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }

      return output;
    };
  } else {
    assign = Object.assign;
  }

  var assign$1 = assign;
  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = typeof document === "undefined" ? {
    style: {}
  } : document.createElement('div');
  var TYPE_FUNCTION = 'function';
  var round = Math.round,
      abs = Math.abs;
  var now = Date.now;
  /**
   * @private
   * get the prefixed property
   * @param {Object} obj
   * @param {String} property
   * @returns {String|Undefined} prefixed
   */

  function prefixed(obj, property) {
    var prefix;
    var prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);
    var i = 0;

    while (i < VENDOR_PREFIXES.length) {
      prefix = VENDOR_PREFIXES[i];
      prop = prefix ? prefix + camelProp : property;

      if (prop in obj) {
        return prop;
      }

      i++;
    }

    return undefined;
  }
  /* eslint-disable no-new-func, no-nested-ternary */


  var win;

  if (typeof window === "undefined") {
    // window is undefined in node.js
    win = {};
  } else {
    win = window;
  }

  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

  function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
      return false;
    }

    var touchMap = {};
    var cssSupports = win.CSS && win.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
      // If css.supports is not supported but there is native touch-action assume it supports
      // all values. This is the case for IE 10 and 11.
      return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
  }

  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented

  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';
  var TOUCH_ACTION_MAP = getTouchActionProps();
  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
  var SUPPORT_TOUCH = ('ontouchstart' in win);
  var SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';
  var COMPUTE_INTERVAL = 25;
  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;
  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;
  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];
  /**
   * @private
   * walk objects and arrays
   * @param {Object} obj
   * @param {Function} iterator
   * @param {Object} context
   */

  function each(obj, iterator, context) {
    var i;

    if (!obj) {
      return;
    }

    if (obj.forEach) {
      obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
      i = 0;

      while (i < obj.length) {
        iterator.call(context, obj[i], i, obj);
        i++;
      }
    } else {
      for (i in obj) {
        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
      }
    }
  }
  /**
   * @private
   * let a boolean value also be a function that must return a boolean
   * this first item in args will be used as the context
   * @param {Boolean|Function} val
   * @param {Array} [args]
   * @returns {Boolean}
   */


  function boolOrFn(val, args) {
    if (typeof val === TYPE_FUNCTION) {
      return val.apply(args ? args[0] || undefined : undefined, args);
    }

    return val;
  }
  /**
   * @private
   * small indexOf wrapper
   * @param {String} str
   * @param {String} find
   * @returns {Boolean} found
   */


  function inStr(str, find) {
    return str.indexOf(find) > -1;
  }
  /**
   * @private
   * when the touchActions are collected they are not a valid value, so we need to clean things up. *
   * @param {String} actions
   * @returns {*}
   */


  function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
      return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning

    if (hasPanX && hasPanY) {
      return TOUCH_ACTION_NONE;
    } // pan-x OR pan-y


    if (hasPanX || hasPanY) {
      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    } // manipulation


    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
      return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
  }
  /**
   * @private
   * Touch Action
   * sets the touchAction property or uses the js alternative
   * @param {Manager} manager
   * @param {String} value
   * @constructor
   */


  var TouchAction = /*#__PURE__*/function () {
    function TouchAction(manager, value) {
      this.manager = manager;
      this.set(value);
    }
    /**
     * @private
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */


    var _proto = TouchAction.prototype;

    _proto.set = function set(value) {
      // find out the touch-action by the event handlers
      if (value === TOUCH_ACTION_COMPUTE) {
        value = this.compute();
      }

      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
      }

      this.actions = value.toLowerCase().trim();
    };
    /**
     * @private
     * just re-set the touchAction value
     */


    _proto.update = function update() {
      this.set(this.manager.options.touchAction);
    };
    /**
     * @private
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */


    _proto.compute = function compute() {
      var actions = [];
      each(this.manager.recognizers, function (recognizer) {
        if (boolOrFn(recognizer.options.enable, [recognizer])) {
          actions = actions.concat(recognizer.getTouchAction());
        }
      });
      return cleanTouchActions(actions.join(' '));
    };
    /**
     * @private
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */


    _proto.preventDefaults = function preventDefaults(input) {
      var srcEvent = input.srcEvent;
      var direction = input.offsetDirection; // if the touch action did prevented once this session

      if (this.manager.session.prevented) {
        srcEvent.preventDefault();
        return;
      }

      var actions = this.actions;
      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

      if (hasNone) {
        // do not prevent defaults if this is a tap gesture
        var isTapPointer = input.pointers.length === 1;
        var isTapMovement = input.distance < 2;
        var isTapTouchTime = input.deltaTime < 250;

        if (isTapPointer && isTapMovement && isTapTouchTime) {
          return;
        }
      }

      if (hasPanX && hasPanY) {
        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
        return;
      }

      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
        return this.preventSrc(srcEvent);
      }
    };
    /**
     * @private
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */


    _proto.preventSrc = function preventSrc(srcEvent) {
      this.manager.session.prevented = true;
      srcEvent.preventDefault();
    };

    return TouchAction;
  }();
  /**
   * @private
   * find if a node is in the given parent
   * @method hasParent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */


  function hasParent(node, parent) {
    while (node) {
      if (node === parent) {
        return true;
      }

      node = node.parentNode;
    }

    return false;
  }
  /**
   * @private
   * get the center of all the pointers
   * @param {Array} pointers
   * @return {Object} center contains `x` and `y` properties
   */


  function getCenter(pointers) {
    var pointersLength = pointers.length; // no need to loop when only one touch

    if (pointersLength === 1) {
      return {
        x: round(pointers[0].clientX),
        y: round(pointers[0].clientY)
      };
    }

    var x = 0;
    var y = 0;
    var i = 0;

    while (i < pointersLength) {
      x += pointers[i].clientX;
      y += pointers[i].clientY;
      i++;
    }

    return {
      x: round(x / pointersLength),
      y: round(y / pointersLength)
    };
  }
  /**
   * @private
   * create a simple clone from the input used for storage of firstInput and firstMultiple
   * @param {Object} input
   * @returns {Object} clonedInputData
   */


  function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;

    while (i < input.pointers.length) {
      pointers[i] = {
        clientX: round(input.pointers[i].clientX),
        clientY: round(input.pointers[i].clientY)
      };
      i++;
    }

    return {
      timeStamp: now(),
      pointers: pointers,
      center: getCenter(pointers),
      deltaX: input.deltaX,
      deltaY: input.deltaY
    };
  }
  /**
   * @private
   * calculate the absolute distance between two points
   * @param {Object} p1 {x, y}
   * @param {Object} p2 {x, y}
   * @param {Array} [props] containing x and y keys
   * @return {Number} distance
   */


  function getDistance(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }

    var x = p2[props[0]] - p1[props[0]];
    var y = p2[props[1]] - p1[props[1]];
    return Math.sqrt(x * x + y * y);
  }
  /**
   * @private
   * calculate the angle between two coordinates
   * @param {Object} p1
   * @param {Object} p2
   * @param {Array} [props] containing x and y keys
   * @return {Number} angle
   */


  function getAngle(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }

    var x = p2[props[0]] - p1[props[0]];
    var y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
  }
  /**
   * @private
   * get the direction between two points
   * @param {Number} x
   * @param {Number} y
   * @return {Number} direction
   */


  function getDirection(x, y) {
    if (x === y) {
      return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }

    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }

  function computeDeltaXY(session, input) {
    var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;
    // jscs throwing error on defalut destructured values and without defaults tests fail

    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
      prevDelta = session.prevDelta = {
        x: prevInput.deltaX || 0,
        y: prevInput.deltaY || 0
      };
      offset = session.offsetDelta = {
        x: center.x,
        y: center.y
      };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
  }
  /**
   * @private
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} x
   * @param {Number} y
   * @return {Object} velocity `x` and `y`
   */


  function getVelocity(deltaTime, x, y) {
    return {
      x: x / deltaTime || 0,
      y: y / deltaTime || 0
    };
  }
  /**
   * @private
   * calculate the scale factor between two pointersets
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} scale
   */


  function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }
  /**
   * @private
   * calculate the rotation degrees between two pointersets
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} rotation
   */


  function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }
  /**
   * @private
   * velocity is calculated every x ms
   * @param {Object} session
   * @param {Object} input
   */


  function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input;
    var deltaTime = input.timeStamp - last.timeStamp;
    var velocity;
    var velocityX;
    var velocityY;
    var direction;

    if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
      var deltaX = input.deltaX - last.deltaX;
      var deltaY = input.deltaY - last.deltaY;
      var v = getVelocity(deltaTime, deltaX, deltaY);
      velocityX = v.x;
      velocityY = v.y;
      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
      direction = getDirection(deltaX, deltaY);
      session.lastInterval = input;
    } else {
      // use latest velocity info if it doesn't overtake a minimum period
      velocity = last.velocity;
      velocityX = last.velocityX;
      velocityY = last.velocityY;
      direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
  }
  /**
  * @private
   * extend the data with some usable properties like scale, rotate, velocity etc
   * @param {Object} manager
   * @param {Object} input
   */


  function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length; // store the first input to calculate the distance and direction

    if (!session.firstInput) {
      session.firstInput = simpleCloneInputData(input);
    } // to compute scale and rotation we need to store the multiple touches


    if (pointersLength > 1 && !session.firstMultiple) {
      session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
      session.firstMultiple = false;
    }

    var firstInput = session.firstInput,
        firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;
    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);
    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);
    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
    computeIntervalInputData(session, input); // find the correct target

    var target = manager.element;
    var srcEvent = input.srcEvent;
    var srcEventTarget;

    if (srcEvent.composedPath) {
      srcEventTarget = srcEvent.composedPath()[0];
    } else if (srcEvent.path) {
      srcEventTarget = srcEvent.path[0];
    } else {
      srcEventTarget = srcEvent.target;
    }

    if (hasParent(srcEventTarget, target)) {
      target = srcEventTarget;
    }

    input.target = target;
  }
  /**
   * @private
   * handle input events
   * @param {Manager} manager
   * @param {String} eventType
   * @param {Object} input
   */


  function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
      manager.session = {};
    } // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'


    input.eventType = eventType; // compute scale, rotation etc

    computeInputData(manager, input); // emit secret event

    manager.emit('hammer.input', input);
    manager.recognize(input);
    manager.session.prevInput = input;
  }
  /**
   * @private
   * split string on whitespace
   * @param {String} str
   * @returns {Array} words
   */


  function splitStr(str) {
    return str.trim().split(/\s+/g);
  }
  /**
   * @private
   * addEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */


  function addEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.addEventListener(type, handler, false);
    });
  }
  /**
   * @private
   * removeEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */


  function removeEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.removeEventListener(type, handler, false);
    });
  }
  /**
   * @private
   * get the window object of an element
   * @param {HTMLElement} element
   * @returns {DocumentView|Window}
   */


  function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return doc.defaultView || doc.parentWindow || window;
  }
  /**
   * @private
   * create new input type manager
   * @param {Manager} manager
   * @param {Function} callback
   * @returns {Input}
   * @constructor
   */


  var Input = /*#__PURE__*/function () {
    function Input(manager, callback) {
      var self = this;
      this.manager = manager;
      this.callback = callback;
      this.element = manager.element;
      this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,
      // so when disabled the input events are completely bypassed.

      this.domHandler = function (ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
          self.handler(ev);
        }
      };

      this.init();
    }
    /**
     * @private
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */


    var _proto = Input.prototype;

    _proto.handler = function handler() {};
    /**
     * @private
     * bind the events
     */


    _proto.init = function init() {
      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    };
    /**
     * @private
     * unbind the events
     */


    _proto.destroy = function destroy() {
      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    };

    return Input;
  }();
  /**
   * @private
   * find if a array contains the object using indexOf or a simple polyFill
   * @param {Array} src
   * @param {String} find
   * @param {String} [findByKey]
   * @return {Boolean|Number} false when not found, or the index
   */


  function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
      return src.indexOf(find);
    } else {
      var i = 0;

      while (i < src.length) {
        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
          // do not use === here, test fails
          return i;
        }

        i++;
      }

      return -1;
    }
  }

  var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
  }; // in IE10 the pointer types is defined as an enum

  var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816

  };
  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive

  if (win.MSPointerEvent && !win.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }
  /**
   * @private
   * Pointer events input
   * @constructor
   * @extends Input
   */


  var PointerEventInput = /*#__PURE__*/function (_Input) {
    _inheritsLoose(PointerEventInput, _Input);

    function PointerEventInput() {
      var _this;

      var proto = PointerEventInput.prototype;
      proto.evEl = POINTER_ELEMENT_EVENTS;
      proto.evWin = POINTER_WINDOW_EVENTS;
      _this = _Input.apply(this, arguments) || this;
      _this.store = _this.manager.session.pointerEvents = [];
      return _this;
    }
    /**
     * @private
     * handle mouse events
     * @param {Object} ev
     */


    var _proto = PointerEventInput.prototype;

    _proto.handler = function handler(ev) {
      var store = this.store;
      var removePointer = false;
      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
      var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store

      var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down

      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
        if (storeIndex < 0) {
          store.push(ev);
          storeIndex = store.length - 1;
        }
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        removePointer = true;
      } // it not found, so the pointer hasn't been down (so it's probably a hover)


      if (storeIndex < 0) {
        return;
      } // update the event in the store


      store[storeIndex] = ev;
      this.callback(this.manager, eventType, {
        pointers: store,
        changedPointers: [ev],
        pointerType: pointerType,
        srcEvent: ev
      });

      if (removePointer) {
        // remove from the store
        store.splice(storeIndex, 1);
      }
    };

    return PointerEventInput;
  }(Input);
  /**
   * @private
   * convert array-like objects to real arrays
   * @param {Object} obj
   * @returns {Array}
   */


  function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  }
  /**
   * @private
   * unique array with objects based on a key (like 'id') or just by the array's value
   * @param {Array} src [{id:1},{id:2},{id:1}]
   * @param {String} [key]
   * @param {Boolean} [sort=False]
   * @returns {Array} [{id:1},{id:2}]
   */


  function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
      var val = key ? src[i][key] : src[i];

      if (inArray(values, val) < 0) {
        results.push(src[i]);
      }

      values[i] = val;
      i++;
    }

    if (sort) {
      if (!key) {
        results = results.sort();
      } else {
        results = results.sort(function (a, b) {
          return a[key] > b[key];
        });
      }
    }

    return results;
  }

  var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
  /**
   * @private
   * Multi-user touch events input
   * @constructor
   * @extends Input
   */

  var TouchInput = /*#__PURE__*/function (_Input) {
    _inheritsLoose(TouchInput, _Input);

    function TouchInput() {
      var _this;

      TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;
      _this = _Input.apply(this, arguments) || this;
      _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;

      return _this;
    }

    var _proto = TouchInput.prototype;

    _proto.handler = function handler(ev) {
      var type = TOUCH_INPUT_MAP[ev.type];
      var touches = getTouches.call(this, ev, type);

      if (!touches) {
        return;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    };

    return TouchInput;
  }(Input);

  function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds; // when there is only one touch, the process can be simplified

    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
      targetIds[allTouches[0].identifier] = true;
      return [allTouches, allTouches];
    }

    var i;
    var targetTouches;
    var changedTouches = toArray(ev.changedTouches);
    var changedTargetTouches = [];
    var target = this.target; // get target touches from touches

    targetTouches = allTouches.filter(function (touch) {
      return hasParent(touch.target, target);
    }); // collect touches

    if (type === INPUT_START) {
      i = 0;

      while (i < targetTouches.length) {
        targetIds[targetTouches[i].identifier] = true;
        i++;
      }
    } // filter changed touches to only contain touches that exist in the collected target ids


    i = 0;

    while (i < changedTouches.length) {
      if (targetIds[changedTouches[i].identifier]) {
        changedTargetTouches.push(changedTouches[i]);
      } // cleanup removed touches


      if (type & (INPUT_END | INPUT_CANCEL)) {
        delete targetIds[changedTouches[i].identifier];
      }

      i++;
    }

    if (!changedTargetTouches.length) {
      return;
    }

    return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
  }

  var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
  };
  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
  /**
   * @private
   * Mouse events input
   * @constructor
   * @extends Input
   */

  var MouseInput = /*#__PURE__*/function (_Input) {
    _inheritsLoose(MouseInput, _Input);

    function MouseInput() {
      var _this;

      var proto = MouseInput.prototype;
      proto.evEl = MOUSE_ELEMENT_EVENTS;
      proto.evWin = MOUSE_WINDOW_EVENTS;
      _this = _Input.apply(this, arguments) || this;
      _this.pressed = false; // mousedown state

      return _this;
    }
    /**
     * @private
     * handle mouse events
     * @param {Object} ev
     */


    var _proto = MouseInput.prototype;

    _proto.handler = function handler(ev) {
      var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down

      if (eventType & INPUT_START && ev.button === 0) {
        this.pressed = true;
      }

      if (eventType & INPUT_MOVE && ev.which !== 1) {
        eventType = INPUT_END;
      } // mouse must be down


      if (!this.pressed) {
        return;
      }

      if (eventType & INPUT_END) {
        this.pressed = false;
      }

      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: INPUT_TYPE_MOUSE,
        srcEvent: ev
      });
    };

    return MouseInput;
  }(Input);
  /**
   * @private
   * Combined touch and mouse input
   *
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
   * This because touch devices also emit mouse events while doing a touch.
   *
   * @constructor
   * @extends Input
   */


  var DEDUP_TIMEOUT = 2500;
  var DEDUP_DISTANCE = 25;

  function setLastTouch(eventData) {
    var _eventData$changedPoi = eventData.changedPointers,
        touch = _eventData$changedPoi[0];

    if (touch.identifier === this.primaryTouch) {
      var lastTouch = {
        x: touch.clientX,
        y: touch.clientY
      };
      var lts = this.lastTouches;
      this.lastTouches.push(lastTouch);

      var removeLastTouch = function removeLastTouch() {
        var i = lts.indexOf(lastTouch);

        if (i > -1) {
          lts.splice(i, 1);
        }
      };

      setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
  }

  function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
      this.primaryTouch = eventData.changedPointers[0].identifier;
      setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
      setLastTouch.call(this, eventData);
    }
  }

  function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX;
    var y = eventData.srcEvent.clientY;

    for (var i = 0; i < this.lastTouches.length; i++) {
      var t = this.lastTouches[i];
      var dx = Math.abs(x - t.x);
      var dy = Math.abs(y - t.y);

      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
        return true;
      }
    }

    return false;
  }

  var TouchMouseInput = /*#__PURE__*/function () {
    var TouchMouseInput = /*#__PURE__*/function (_Input) {
      _inheritsLoose(TouchMouseInput, _Input);

      function TouchMouseInput(_manager, callback) {
        var _this;

        _this = _Input.call(this, _manager, callback) || this;

        _this.handler = function (manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;
          var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;

          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          } // when we're in a touch event, record touches to  de-dupe synthetic mouse event


          if (isTouch) {
            recordTouches.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputData)) {
            return;
          }

          _this.callback(manager, inputEvent, inputData);
        };

        _this.touch = new TouchInput(_this.manager, _this.handler);
        _this.mouse = new MouseInput(_this.manager, _this.handler);
        _this.primaryTouch = null;
        _this.lastTouches = [];
        return _this;
      }
      /**
       * @private
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */


      var _proto = TouchMouseInput.prototype;
      /**
       * @private
       * remove the event listeners
       */

      _proto.destroy = function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
      };

      return TouchMouseInput;
    }(Input);

    return TouchMouseInput;
  }();
  /**
   * @private
   * create new input type manager
   * called by the Manager constructor
   * @param {Hammer} manager
   * @returns {Input}
   */


  function createInputInstance(manager) {
    var Type; // let inputClass = manager.options.inputClass;

    var inputClass = manager.options.inputClass;

    if (inputClass) {
      Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
      Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
      Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
      Type = MouseInput;
    } else {
      Type = TouchMouseInput;
    }

    return new Type(manager, inputHandler);
  }
  /**
   * @private
   * if the argument is an array, we want to execute the fn on each entry
   * if it aint an array we don't want to do a thing.
   * this is used by all the methods that accept a single and array argument.
   * @param {*|Array} arg
   * @param {String} fn
   * @param {Object} [context]
   * @returns {Boolean}
   */


  function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
      each(arg, context[fn], context);
      return true;
    }

    return false;
  }

  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;
  /**
   * @private
   * get a unique id
   * @returns {number} uniqueId
   */

  var _uniqueId = 1;

  function uniqueId() {
    return _uniqueId++;
  }
  /**
   * @private
   * get a recognizer by name if it is bound to a manager
   * @param {Recognizer|String} otherRecognizer
   * @param {Recognizer} recognizer
   * @returns {Recognizer}
   */


  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;

    if (manager) {
      return manager.get(otherRecognizer);
    }

    return otherRecognizer;
  }
  /**
   * @private
   * get a usable string, used as event postfix
   * @param {constant} state
   * @returns {String} state
   */


  function stateStr(state) {
    if (state & STATE_CANCELLED) {
      return 'cancel';
    } else if (state & STATE_ENDED) {
      return 'end';
    } else if (state & STATE_CHANGED) {
      return 'move';
    } else if (state & STATE_BEGAN) {
      return 'start';
    }

    return '';
  }
  /**
   * @private
   * Recognizer flow explained; *
   * All recognizers have the initial state of POSSIBLE when a input session starts.
   * The definition of a input session is from the first input until the last input, with all it's movement in it. *
   * Example session for mouse-input: mousedown -> mousemove -> mouseup
   *
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
   * which determines with state it should be.
   *
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
   * POSSIBLE to give it another change on the next cycle.
   *
   *               Possible
   *                  |
   *            +-----+---------------+
   *            |                     |
   *      +-----+-----+               |
   *      |           |               |
   *   Failed      Cancelled          |
   *                          +-------+------+
   *                          |              |
   *                      Recognized       Began
   *                                         |
   *                                      Changed
   *                                         |
   *                                  Ended/Recognized
   */

  /**
   * @private
   * Recognizer
   * Every recognizer needs to extend from this class.
   * @constructor
   * @param {Object} options
   */


  var Recognizer = /*#__PURE__*/function () {
    function Recognizer(options) {
      if (options === void 0) {
        options = {};
      }

      this.options = _extends({
        enable: true
      }, options);
      this.id = uniqueId();
      this.manager = null; // default is enable true

      this.state = STATE_POSSIBLE;
      this.simultaneous = {};
      this.requireFail = [];
    }
    /**
     * @private
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */


    var _proto = Recognizer.prototype;

    _proto.set = function set(options) {
      assign$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state

      this.manager && this.manager.touchAction.update();
      return this;
    };
    /**
     * @private
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */


    _proto.recognizeWith = function recognizeWith(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
        return this;
      }

      var simultaneous = this.simultaneous;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

      if (!simultaneous[otherRecognizer.id]) {
        simultaneous[otherRecognizer.id] = otherRecognizer;
        otherRecognizer.recognizeWith(this);
      }

      return this;
    };
    /**
     * @private
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */


    _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      delete this.simultaneous[otherRecognizer.id];
      return this;
    };
    /**
     * @private
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */


    _proto.requireFailure = function requireFailure(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
        return this;
      }

      var requireFail = this.requireFail;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

      if (inArray(requireFail, otherRecognizer) === -1) {
        requireFail.push(otherRecognizer);
        otherRecognizer.requireFailure(this);
      }

      return this;
    };
    /**
     * @private
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */


    _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      var index = inArray(this.requireFail, otherRecognizer);

      if (index > -1) {
        this.requireFail.splice(index, 1);
      }

      return this;
    };
    /**
     * @private
     * has require failures boolean
     * @returns {boolean}
     */


    _proto.hasRequireFailures = function hasRequireFailures() {
      return this.requireFail.length > 0;
    };
    /**
     * @private
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */


    _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {
      return !!this.simultaneous[otherRecognizer.id];
    };
    /**
     * @private
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */


    _proto.emit = function emit(input) {
      var self = this;
      var state = this.state;

      function emit(event) {
        self.manager.emit(event, input);
      } // 'panstart' and 'panmove'


      if (state < STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }

      emit(self.options.event); // simple 'eventName' events

      if (input.additionalEvent) {
        // additional event(panleft, panright, pinchin, pinchout...)
        emit(input.additionalEvent);
      } // panend and pancancel


      if (state >= STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }
    };
    /**
     * @private
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */


    _proto.tryEmit = function tryEmit(input) {
      if (this.canEmit()) {
        return this.emit(input);
      } // it's failing anyway


      this.state = STATE_FAILED;
    };
    /**
     * @private
     * can we emit?
     * @returns {boolean}
     */


    _proto.canEmit = function canEmit() {
      var i = 0;

      while (i < this.requireFail.length) {
        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
          return false;
        }

        i++;
      }

      return true;
    };
    /**
     * @private
     * update the recognizer
     * @param {Object} inputData
     */


    _proto.recognize = function recognize(inputData) {
      // make a new copy of the inputData
      // so we can change the inputData without messing up the other recognizers
      var inputDataClone = assign$1({}, inputData); // is is enabled and allow recognizing?

      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
        this.reset();
        this.state = STATE_FAILED;
        return;
      } // reset when we've reached the end


      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
        this.state = STATE_POSSIBLE;
      }

      this.state = this.process(inputDataClone); // the recognizer has recognized a gesture
      // so trigger an event

      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
        this.tryEmit(inputDataClone);
      }
    };
    /**
     * @private
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {constant} STATE
     */

    /* jshint ignore:start */


    _proto.process = function process(inputData) {};
    /* jshint ignore:end */

    /**
     * @private
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */


    _proto.getTouchAction = function getTouchAction() {};
    /**
     * @private
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */


    _proto.reset = function reset() {};

    return Recognizer;
  }();
  /**
   * @private
   * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing
   * a single tap.
   *
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
   * multi-taps being recognized.
   * @constructor
   * @extends Recognizer
   */


  var TapRecognizer = /*#__PURE__*/function (_Recognizer) {
    _inheritsLoose(TapRecognizer, _Recognizer);

    function TapRecognizer(options) {
      var _this;

      if (options === void 0) {
        options = {};
      }

      _this = _Recognizer.call(this, _extends({
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300,
        // max time between the multi-tap taps
        time: 250,
        // max time of the pointer to be down (like finger on the screen)
        threshold: 9,
        // a minimal movement is ok, but keep it low
        posThreshold: 10
      }, options)) || this; // previous time and center,
      // used for tap counting

      _this.pTime = false;
      _this.pCenter = false;
      _this._timer = null;
      _this._input = null;
      _this.count = 0;
      return _this;
    }

    var _proto = TapRecognizer.prototype;

    _proto.getTouchAction = function getTouchAction() {
      return [TOUCH_ACTION_MANIPULATION];
    };

    _proto.process = function process(input) {
      var _this2 = this;

      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTouchTime = input.deltaTime < options.time;
      this.reset();

      if (input.eventType & INPUT_START && this.count === 0) {
        return this.failTimeout();
      } // we only allow little movement
      // and we've reached an end event, so a tap is possible


      if (validMovement && validTouchTime && validPointers) {
        if (input.eventType !== INPUT_END) {
          return this.failTimeout();
        }

        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
        this.pTime = input.timeStamp;
        this.pCenter = input.center;

        if (!validMultiTap || !validInterval) {
          this.count = 1;
        } else {
          this.count += 1;
        }

        this._input = input; // if tap count matches we have recognized it,
        // else it has began recognizing...

        var tapCount = this.count % options.taps;

        if (tapCount === 0) {
          // no failing requirements, immediately trigger the tap event
          // or wait as long as the multitap interval to trigger
          if (!this.hasRequireFailures()) {
            return STATE_RECOGNIZED;
          } else {
            this._timer = setTimeout(function () {
              _this2.state = STATE_RECOGNIZED;

              _this2.tryEmit();
            }, options.interval);
            return STATE_BEGAN;
          }
        }
      }

      return STATE_FAILED;
    };

    _proto.failTimeout = function failTimeout() {
      var _this3 = this;

      this._timer = setTimeout(function () {
        _this3.state = STATE_FAILED;
      }, this.options.interval);
      return STATE_FAILED;
    };

    _proto.reset = function reset() {
      clearTimeout(this._timer);
    };

    _proto.emit = function emit() {
      if (this.state === STATE_RECOGNIZED) {
        this._input.tapCount = this.count;
        this.manager.emit(this.options.event, this._input);
      }
    };

    return TapRecognizer;
  }(Recognizer);
  /**
   * @private
   * This recognizer is just used as a base for the simple attribute recognizers.
   * @constructor
   * @extends Recognizer
   */


  var AttrRecognizer = /*#__PURE__*/function (_Recognizer) {
    _inheritsLoose(AttrRecognizer, _Recognizer);

    function AttrRecognizer(options) {
      if (options === void 0) {
        options = {};
      }

      return _Recognizer.call(this, _extends({
        pointers: 1
      }, options)) || this;
    }
    /**
     * @private
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */


    var _proto = AttrRecognizer.prototype;

    _proto.attrTest = function attrTest(input) {
      var optionPointers = this.options.pointers;
      return optionPointers === 0 || input.pointers.length === optionPointers;
    };
    /**
     * @private
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */


    _proto.process = function process(input) {
      var state = this.state;
      var eventType = input.eventType;
      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
      var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED

      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
        return state | STATE_CANCELLED;
      } else if (isRecognized || isValid) {
        if (eventType & INPUT_END) {
          return state | STATE_ENDED;
        } else if (!(state & STATE_BEGAN)) {
          return STATE_BEGAN;
        }

        return state | STATE_CHANGED;
      }

      return STATE_FAILED;
    };

    return AttrRecognizer;
  }(Recognizer);
  /**
   * @private
   * direction cons to string
   * @param {constant} direction
   * @returns {String}
   */


  function directionStr(direction) {
    if (direction === DIRECTION_DOWN) {
      return 'down';
    } else if (direction === DIRECTION_UP) {
      return 'up';
    } else if (direction === DIRECTION_LEFT) {
      return 'left';
    } else if (direction === DIRECTION_RIGHT) {
      return 'right';
    }

    return '';
  }
  /**
   * @private
   * Pan
   * Recognized when the pointer is down and moved in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */


  var PanRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
    _inheritsLoose(PanRecognizer, _AttrRecognizer);

    function PanRecognizer(options) {
      var _this;

      if (options === void 0) {
        options = {};
      }

      _this = _AttrRecognizer.call(this, _extends({
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
      }, options)) || this;
      _this.pX = null;
      _this.pY = null;
      return _this;
    }

    var _proto = PanRecognizer.prototype;

    _proto.getTouchAction = function getTouchAction() {
      var direction = this.options.direction;
      var actions = [];

      if (direction & DIRECTION_HORIZONTAL) {
        actions.push(TOUCH_ACTION_PAN_Y);
      }

      if (direction & DIRECTION_VERTICAL) {
        actions.push(TOUCH_ACTION_PAN_X);
      }

      return actions;
    };

    _proto.directionTest = function directionTest(input) {
      var options = this.options;
      var hasMoved = true;
      var distance = input.distance;
      var direction = input.direction;
      var x = input.deltaX;
      var y = input.deltaY; // lock to axis?

      if (!(direction & options.direction)) {
        if (options.direction & DIRECTION_HORIZONTAL) {
          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          hasMoved = x !== this.pX;
          distance = Math.abs(input.deltaX);
        } else {
          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          hasMoved = y !== this.pY;
          distance = Math.abs(input.deltaY);
        }
      }

      input.direction = direction;
      return hasMoved && distance > options.threshold && direction & options.direction;
    };

    _proto.attrTest = function attrTest(input) {
      return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call
      this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
    };

    _proto.emit = function emit(input) {
      this.pX = input.deltaX;
      this.pY = input.deltaY;
      var direction = directionStr(input.direction);

      if (direction) {
        input.additionalEvent = this.options.event + direction;
      }

      _AttrRecognizer.prototype.emit.call(this, input);
    };

    return PanRecognizer;
  }(AttrRecognizer);
  /**
   * @private
   * Swipe
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */


  var SwipeRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
    _inheritsLoose(SwipeRecognizer, _AttrRecognizer);

    function SwipeRecognizer(options) {
      if (options === void 0) {
        options = {};
      }

      return _AttrRecognizer.call(this, _extends({
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
      }, options)) || this;
    }

    var _proto = SwipeRecognizer.prototype;

    _proto.getTouchAction = function getTouchAction() {
      return PanRecognizer.prototype.getTouchAction.call(this);
    };

    _proto.attrTest = function attrTest(input) {
      var direction = this.options.direction;
      var velocity;

      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
        velocity = input.overallVelocity;
      } else if (direction & DIRECTION_HORIZONTAL) {
        velocity = input.overallVelocityX;
      } else if (direction & DIRECTION_VERTICAL) {
        velocity = input.overallVelocityY;
      }

      return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    };

    _proto.emit = function emit(input) {
      var direction = directionStr(input.offsetDirection);

      if (direction) {
        this.manager.emit(this.options.event + direction, input);
      }

      this.manager.emit(this.options.event, input);
    };

    return SwipeRecognizer;
  }(AttrRecognizer);
  /**
   * @private
   * Pinch
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
   * @constructor
   * @extends AttrRecognizer
   */


  var PinchRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
    _inheritsLoose(PinchRecognizer, _AttrRecognizer);

    function PinchRecognizer(options) {
      if (options === void 0) {
        options = {};
      }

      return _AttrRecognizer.call(this, _extends({
        event: 'pinch',
        threshold: 0,
        pointers: 2
      }, options)) || this;
    }

    var _proto = PinchRecognizer.prototype;

    _proto.getTouchAction = function getTouchAction() {
      return [TOUCH_ACTION_NONE];
    };

    _proto.attrTest = function attrTest(input) {
      return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    };

    _proto.emit = function emit(input) {
      if (input.scale !== 1) {
        var inOut = input.scale < 1 ? 'in' : 'out';
        input.additionalEvent = this.options.event + inOut;
      }

      _AttrRecognizer.prototype.emit.call(this, input);
    };

    return PinchRecognizer;
  }(AttrRecognizer);
  /**
   * @private
   * Rotate
   * Recognized when two or more pointer are moving in a circular motion.
   * @constructor
   * @extends AttrRecognizer
   */


  var RotateRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
    _inheritsLoose(RotateRecognizer, _AttrRecognizer);

    function RotateRecognizer(options) {
      if (options === void 0) {
        options = {};
      }

      return _AttrRecognizer.call(this, _extends({
        event: 'rotate',
        threshold: 0,
        pointers: 2
      }, options)) || this;
    }

    var _proto = RotateRecognizer.prototype;

    _proto.getTouchAction = function getTouchAction() {
      return [TOUCH_ACTION_NONE];
    };

    _proto.attrTest = function attrTest(input) {
      return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    };

    return RotateRecognizer;
  }(AttrRecognizer);
  /**
   * @private
   * Press
   * Recognized when the pointer is down for x ms without any movement.
   * @constructor
   * @extends Recognizer
   */


  var PressRecognizer = /*#__PURE__*/function (_Recognizer) {
    _inheritsLoose(PressRecognizer, _Recognizer);

    function PressRecognizer(options) {
      var _this;

      if (options === void 0) {
        options = {};
      }

      _this = _Recognizer.call(this, _extends({
        event: 'press',
        pointers: 1,
        time: 251,
        // minimal time of the pointer to be pressed
        threshold: 9
      }, options)) || this;
      _this._timer = null;
      _this._input = null;
      return _this;
    }

    var _proto = PressRecognizer.prototype;

    _proto.getTouchAction = function getTouchAction() {
      return [TOUCH_ACTION_AUTO];
    };

    _proto.process = function process(input) {
      var _this2 = this;

      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTime = input.deltaTime > options.time;
      this._input = input; // we only allow little movement
      // and we've reached an end event, so a tap is possible

      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
        this.reset();
      } else if (input.eventType & INPUT_START) {
        this.reset();
        this._timer = setTimeout(function () {
          _this2.state = STATE_RECOGNIZED;

          _this2.tryEmit();
        }, options.time);
      } else if (input.eventType & INPUT_END) {
        return STATE_RECOGNIZED;
      }

      return STATE_FAILED;
    };

    _proto.reset = function reset() {
      clearTimeout(this._timer);
    };

    _proto.emit = function emit(input) {
      if (this.state !== STATE_RECOGNIZED) {
        return;
      }

      if (input && input.eventType & INPUT_END) {
        this.manager.emit(this.options.event + "up", input);
      } else {
        this._input.timeStamp = now();
        this.manager.emit(this.options.event, this._input);
      }
    };

    return PressRecognizer;
  }(Recognizer);

  var defaults = {
    /**
     * @private
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * @private
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @private
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * @private
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * @private
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * @private
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
      /**
       * @private
       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userSelect: "none",

      /**
       * @private
       * Disable the Windows Phone grippers when pressing an element.
       * @type {String}
       * @default 'none'
       */
      touchSelect: "none",

      /**
       * @private
       * Disables the default callout shown when you touch and hold a touch target.
       * On iOS, when you touch and hold a touch target such as a link, Safari displays
       * a callout containing information about the link. This property allows you to disable that callout.
       * @type {String}
       * @default 'none'
       */
      touchCallout: "none",

      /**
       * @private
       * Specifies whether zooming is enabled. Used by IE10>
       * @type {String}
       * @default 'none'
       */
      contentZooming: "none",

      /**
       * @private
       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userDrag: "none",

      /**
       * @private
       * Overrides the highlight color shown when the user taps a link or a JavaScript
       * clickable element in iOS. This property obeys the alpha value, if specified.
       * @type {String}
       * @default 'rgba(0,0,0,0)'
       */
      tapHighlightColor: "rgba(0,0,0,0)"
    }
  };
  /**
   * @private
   * Default recognizer setup when calling `Hammer()`
   * When creating a new Manager these will be skipped.
   * This is separated with other defaults because of tree-shaking.
   * @type {Array}
   */

  var preset = [[RotateRecognizer, {
    enable: false
  }], [PinchRecognizer, {
    enable: false
  }, ['rotate']], [SwipeRecognizer, {
    direction: DIRECTION_HORIZONTAL
  }], [PanRecognizer, {
    direction: DIRECTION_HORIZONTAL
  }, ['swipe']], [TapRecognizer], [TapRecognizer, {
    event: 'doubletap',
    taps: 2
  }, ['tap']], [PressRecognizer]];
  var STOP = 1;
  var FORCED_STOP = 2;
  /**
   * @private
   * add/remove the css properties as defined in manager.options.cssProps
   * @param {Manager} manager
   * @param {Boolean} add
   */

  function toggleCssProps(manager, add) {
    var element = manager.element;

    if (!element.style) {
      return;
    }

    var prop;
    each(manager.options.cssProps, function (value, name) {
      prop = prefixed(element.style, name);

      if (add) {
        manager.oldCssProps[prop] = element.style[prop];
        element.style[prop] = value;
      } else {
        element.style[prop] = manager.oldCssProps[prop] || "";
      }
    });

    if (!add) {
      manager.oldCssProps = {};
    }
  }
  /**
   * @private
   * trigger dom event
   * @param {String} event
   * @param {Object} data
   */


  function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent("Event");
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
  }
  /**
  * @private
   * Manager
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */


  var Manager = /*#__PURE__*/function () {
    function Manager(element, options) {
      var _this = this;

      this.options = assign$1({}, defaults, options || {});
      this.options.inputTarget = this.options.inputTarget || element;
      this.handlers = {};
      this.session = {};
      this.recognizers = [];
      this.oldCssProps = {};
      this.element = element;
      this.input = createInputInstance(this);
      this.touchAction = new TouchAction(this, this.options.touchAction);
      toggleCssProps(this, true);
      each(this.options.recognizers, function (item) {
        var recognizer = _this.add(new item[0](item[1]));

        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
      }, this);
    }
    /**
     * @private
     * set options
     * @param {Object} options
     * @returns {Manager}
     */


    var _proto = Manager.prototype;

    _proto.set = function set(options) {
      assign$1(this.options, options); // Options that need a little more setup

      if (options.touchAction) {
        this.touchAction.update();
      }

      if (options.inputTarget) {
        // Clean up existing event listeners and reinitialize
        this.input.destroy();
        this.input.target = options.inputTarget;
        this.input.init();
      }

      return this;
    };
    /**
     * @private
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */


    _proto.stop = function stop(force) {
      this.session.stopped = force ? FORCED_STOP : STOP;
    };
    /**
     * @private
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */


    _proto.recognize = function recognize(inputData) {
      var session = this.session;

      if (session.stopped) {
        return;
      } // run the touch-action polyfill


      this.touchAction.preventDefaults(inputData);
      var recognizer;
      var recognizers = this.recognizers; // this holds the recognizer that is being recognized.
      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
      // if no recognizer is detecting a thing, it is set to `null`

      var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized
      // or when we're in a new session

      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
        session.curRecognizer = null;
        curRecognizer = null;
      }

      var i = 0;

      while (i < recognizers.length) {
        recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.
        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
        //      that is being recognized.
        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
        //      this can be setup with the `recognizeWith()` method on the recognizer.

        if (session.stopped !== FORCED_STOP && ( // 1
        !curRecognizer || recognizer === curRecognizer || // 2
        recognizer.canRecognizeWith(curRecognizer))) {
          // 3
          recognizer.recognize(inputData);
        } else {
          recognizer.reset();
        } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
        // current active recognizer. but only if we don't already have an active recognizer


        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
          session.curRecognizer = recognizer;
          curRecognizer = recognizer;
        }

        i++;
      }
    };
    /**
     * @private
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */


    _proto.get = function get(recognizer) {
      if (recognizer instanceof Recognizer) {
        return recognizer;
      }

      var recognizers = this.recognizers;

      for (var i = 0; i < recognizers.length; i++) {
        if (recognizers[i].options.event === recognizer) {
          return recognizers[i];
        }
      }

      return null;
    };
    /**
     * @private add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */


    _proto.add = function add(recognizer) {
      if (invokeArrayArg(recognizer, "add", this)) {
        return this;
      } // remove existing


      var existing = this.get(recognizer.options.event);

      if (existing) {
        this.remove(existing);
      }

      this.recognizers.push(recognizer);
      recognizer.manager = this;
      this.touchAction.update();
      return recognizer;
    };
    /**
     * @private
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */


    _proto.remove = function remove(recognizer) {
      if (invokeArrayArg(recognizer, "remove", this)) {
        return this;
      }

      var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists

      if (recognizer) {
        var recognizers = this.recognizers;
        var index = inArray(recognizers, targetRecognizer);

        if (index !== -1) {
          recognizers.splice(index, 1);
          this.touchAction.update();
        }
      }

      return this;
    };
    /**
     * @private
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */


    _proto.on = function on(events, handler) {
      if (events === undefined || handler === undefined) {
        return this;
      }

      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        handlers[event] = handlers[event] || [];
        handlers[event].push(handler);
      });
      return this;
    };
    /**
     * @private unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */


    _proto.off = function off(events, handler) {
      if (events === undefined) {
        return this;
      }

      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        if (!handler) {
          delete handlers[event];
        } else {
          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
        }
      });
      return this;
    };
    /**
     * @private emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */


    _proto.emit = function emit(event, data) {
      // we also want to trigger dom events
      if (this.options.domEvents) {
        triggerDomEvent(event, data);
      } // no handlers, so skip it all


      var handlers = this.handlers[event] && this.handlers[event].slice();

      if (!handlers || !handlers.length) {
        return;
      }

      data.type = event;

      data.preventDefault = function () {
        data.srcEvent.preventDefault();
      };

      var i = 0;

      while (i < handlers.length) {
        handlers[i](data);
        i++;
      }
    };
    /**
     * @private
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */


    _proto.destroy = function destroy() {
      this.element && toggleCssProps(this, false);
      this.handlers = {};
      this.session = {};
      this.input.destroy();
      this.element = null;
    };

    return Manager;
  }();

  var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
  /**
   * @private
   * Touch events input
   * @constructor
   * @extends Input
   */

  var SingleTouchInput = /*#__PURE__*/function (_Input) {
    _inheritsLoose(SingleTouchInput, _Input);

    function SingleTouchInput() {
      var _this;

      var proto = SingleTouchInput.prototype;
      proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
      proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
      _this = _Input.apply(this, arguments) || this;
      _this.started = false;
      return _this;
    }

    var _proto = SingleTouchInput.prototype;

    _proto.handler = function handler(ev) {
      var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?

      if (type === INPUT_START) {
        this.started = true;
      }

      if (!this.started) {
        return;
      }

      var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state

      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
        this.started = false;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    };

    return SingleTouchInput;
  }(Input);

  function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
      all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
  }
  /**
   * @private
   * wrap a method with a deprecation warning and stack trace
   * @param {Function} method
   * @param {String} name
   * @param {String} message
   * @returns {Function} A new function wrapping the supplied method.
   */


  function deprecate(method, name, message) {
    var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
    return function () {
      var e = new Error('get-stack-trace');
      var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
      var log = window.console && (window.console.warn || window.console.log);

      if (log) {
        log.call(window.console, deprecationMessage, stack);
      }

      return method.apply(this, arguments);
    };
  }
  /**
   * @private
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]
   * @returns {Object} dest
   */


  var extend = deprecate(function (dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;

    while (i < keys.length) {
      if (!merge || merge && dest[keys[i]] === undefined) {
        dest[keys[i]] = src[keys[i]];
      }

      i++;
    }

    return dest;
  }, 'extend', 'Use `assign`.');
  /**
   * @private
   * merge the values from src in the dest.
   * means that properties that exist in dest will not be overwritten by src
   * @param {Object} dest
   * @param {Object} src
   * @returns {Object} dest
   */

  var merge$1 = deprecate(function (dest, src) {
    return extend(dest, src, true);
  }, 'merge', 'Use `assign`.');
  /**
   * @private
   * simple class inheritance
   * @param {Function} child
   * @param {Function} base
   * @param {Object} [properties]
   */

  function inherit(child, base, properties) {
    var baseP = base.prototype;
    var childP;
    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
      assign$1(childP, properties);
    }
  }
  /**
   * @private
   * simple function bind
   * @param {Function} fn
   * @param {Object} context
   * @returns {Function}
   */


  function bindFn(fn, context) {
    return function boundFn() {
      return fn.apply(context, arguments);
    };
  }
  /**
   * @private
   * Simple way to create a manager with a default set of recognizers.
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */


  var Hammer = /*#__PURE__*/function () {
    var Hammer =
    /**
      * @private
      * @const {string}
      */
    function Hammer(element, options) {
      if (options === void 0) {
        options = {};
      }

      return new Manager(element, _extends({
        recognizers: preset.concat()
      }, options));
    };

    Hammer.VERSION = "2.0.17-rc";
    Hammer.DIRECTION_ALL = DIRECTION_ALL;
    Hammer.DIRECTION_DOWN = DIRECTION_DOWN;
    Hammer.DIRECTION_LEFT = DIRECTION_LEFT;
    Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;
    Hammer.DIRECTION_UP = DIRECTION_UP;
    Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
    Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;
    Hammer.DIRECTION_NONE = DIRECTION_NONE;
    Hammer.DIRECTION_DOWN = DIRECTION_DOWN;
    Hammer.INPUT_START = INPUT_START;
    Hammer.INPUT_MOVE = INPUT_MOVE;
    Hammer.INPUT_END = INPUT_END;
    Hammer.INPUT_CANCEL = INPUT_CANCEL;
    Hammer.STATE_POSSIBLE = STATE_POSSIBLE;
    Hammer.STATE_BEGAN = STATE_BEGAN;
    Hammer.STATE_CHANGED = STATE_CHANGED;
    Hammer.STATE_ENDED = STATE_ENDED;
    Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;
    Hammer.STATE_CANCELLED = STATE_CANCELLED;
    Hammer.STATE_FAILED = STATE_FAILED;
    Hammer.Manager = Manager;
    Hammer.Input = Input;
    Hammer.TouchAction = TouchAction;
    Hammer.TouchInput = TouchInput;
    Hammer.MouseInput = MouseInput;
    Hammer.PointerEventInput = PointerEventInput;
    Hammer.TouchMouseInput = TouchMouseInput;
    Hammer.SingleTouchInput = SingleTouchInput;
    Hammer.Recognizer = Recognizer;
    Hammer.AttrRecognizer = AttrRecognizer;
    Hammer.Tap = TapRecognizer;
    Hammer.Pan = PanRecognizer;
    Hammer.Swipe = SwipeRecognizer;
    Hammer.Pinch = PinchRecognizer;
    Hammer.Rotate = RotateRecognizer;
    Hammer.Press = PressRecognizer;
    Hammer.on = addEventListeners;
    Hammer.off = removeEventListeners;
    Hammer.each = each;
    Hammer.merge = merge$1;
    Hammer.extend = extend;
    Hammer.bindFn = bindFn;
    Hammer.assign = assign$1;
    Hammer.inherit = inherit;
    Hammer.bindFn = bindFn;
    Hammer.prefixed = prefixed;
    Hammer.toArray = toArray;
    Hammer.inArray = inArray;
    Hammer.uniqueArray = uniqueArray;
    Hammer.splitStr = splitStr;
    Hammer.boolOrFn = boolOrFn;
    Hammer.hasParent = hasParent;
    Hammer.addEventListeners = addEventListeners;
    Hammer.removeEventListeners = removeEventListeners;
    Hammer.defaults = assign$1({}, defaults, {
      preset: preset
    });
    return Hammer;
  }(); //  style loader but by script tag, not by the loader.
  var RealHammer = Hammer;

  function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$1(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$3(o, minLen) { var _context21; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = slice(_context21 = Object.prototype.toString.call(o)).call(_context21, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

  function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  /**
   * Use this symbol to delete properies in deepObjectAssign.
   */

  var DELETE = symbol("DELETE");
  /**
   * Pure version of deepObjectAssign, it doesn't modify any of it's arguments.
   *
   * @param base - The base object that fullfils the whole interface T.
   * @param updates - Updates that may change or delete props.
   * @returns A brand new instance with all the supplied objects deeply merged.
   */


  function pureDeepObjectAssign(base) {
    var _context;

    for (var _len = arguments.length, updates = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      updates[_key - 1] = arguments[_key];
    }

    return deepObjectAssign.apply(void 0, concat$1(_context = [{}, base]).call(_context, updates));
  }
  /**
   * Deep version of object assign with additional deleting by the DELETE symbol.
   *
   * @param values - Objects to be deeply merged.
   * @returns The first object from values.
   */


  function deepObjectAssign() {
    var merged = deepObjectAssignNonentry.apply(void 0, arguments);
    stripDelete(merged);
    return merged;
  }
  /**
   * Deep version of object assign with additional deleting by the DELETE symbol.
   *
   * @remarks
   * This doesn't strip the DELETE symbols so they may end up in the final object.
   * @param values - Objects to be deeply merged.
   * @returns The first object from values.
   */


  function deepObjectAssignNonentry() {
    for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      values[_key2] = arguments[_key2];
    }

    if (values.length < 2) {
      return values[0];
    } else if (values.length > 2) {
      var _context2;

      return deepObjectAssignNonentry.apply(void 0, concat$1(_context2 = [deepObjectAssign(values[0], values[1])]).call(_context2, _toConsumableArray(slice(values).call(values, 2))));
    }

    var a = values[0];
    var b = values[1];

    var _iterator = _createForOfIteratorHelper$3(ownKeys$1(b)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var prop = _step.value;
        if (!Object.prototype.propertyIsEnumerable.call(b, prop)) ;else if (b[prop] === DELETE) {
          delete a[prop];
        } else if (a[prop] !== null && b[prop] !== null && _typeof(a[prop]) === "object" && _typeof(b[prop]) === "object" && !isArray$1(a[prop]) && !isArray$1(b[prop])) {
          a[prop] = deepObjectAssignNonentry(a[prop], b[prop]);
        } else {
          a[prop] = clone(b[prop]);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return a;
  }
  /**
   * Deep clone given object or array. In case of primitive simply return.
   *
   * @param a - Anything.
   * @returns Deep cloned object/array or unchanged a.
   */


  function clone(a) {
    if (isArray$1(a)) {
      return map$3(a).call(a, function (value) {
        return clone(value);
      });
    } else if (_typeof(a) === "object" && a !== null) {
      return deepObjectAssignNonentry({}, a);
    } else {
      return a;
    }
  }
  /**
   * Strip DELETE from given object.
   *
   * @param a - Object which may contain DELETE but won't after this is executed.
   */


  function stripDelete(a) {
    for (var _i = 0, _Object$keys = keys$4(a); _i < _Object$keys.length; _i++) {
      var prop = _Object$keys[_i];

      if (a[prop] === DELETE) {
        delete a[prop];
      } else if (_typeof(a[prop]) === "object" && a[prop] !== null) {
        stripDelete(a[prop]);
      }
    }
  }
  /**
   * Setup a mock hammer.js object, for unit testing.
   *
   * Inspiration: https://github.com/uber/deck.gl/pull/658
   *
   * @returns {{on: noop, off: noop, destroy: noop, emit: noop, get: get}}
   */


  function hammerMock() {
    var noop = function noop() {};

    return {
      on: noop,
      off: noop,
      destroy: noop,
      emit: noop,
      get: function get() {
        return {
          set: noop
        };
      }
    };
  }

  var Hammer$1 = typeof window !== "undefined" ? window.Hammer || RealHammer : function () {
    // hammer.js is only available in a browser, not in node.js. Replacing it with a mock object.
    return hammerMock();
  };
  /**
   * Turn an element into an clickToUse element.
   * When not active, the element has a transparent overlay. When the overlay is
   * clicked, the mode is changed to active.
   * When active, the element is displayed with a blue border around it, and
   * the interactive contents of the element can be used. When clicked outside
   * the element, the elements mode is changed to inactive.
   *
   * @param {Element} container
   * @class Activator
   */

  function Activator$1(container) {
    var _this = this,
        _context3;

    this._cleanupQueue = [];
    this.active = false;
    this._dom = {
      container: container,
      overlay: document.createElement("div")
    };

    this._dom.overlay.classList.add("vis-overlay");

    this._dom.container.appendChild(this._dom.overlay);

    this._cleanupQueue.push(function () {
      _this._dom.overlay.parentNode.removeChild(_this._dom.overlay);
    });

    var hammer = Hammer$1(this._dom.overlay);
    hammer.on("tap", bind$6(_context3 = this._onTapOverlay).call(_context3, this));

    this._cleanupQueue.push(function () {
      hammer.destroy(); // FIXME: cleaning up hammer instances doesn't work (Timeline not removed
      // from memory)
    }); // block all touch events (except tap)


    var events = ["tap", "doubletap", "press", "pinch", "pan", "panstart", "panmove", "panend"];

    forEach$1(events).call(events, function (event) {
      hammer.on(event, function (event) {
        event.srcEvent.stopPropagation();
      });
    }); // attach a click event to the window, in order to deactivate when clicking outside the timeline


    if (document && document.body) {
      this._onClick = function (event) {
        if (!_hasParent(event.target, container)) {
          _this.deactivate();
        }
      };

      document.body.addEventListener("click", this._onClick);

      this._cleanupQueue.push(function () {
        document.body.removeEventListener("click", _this._onClick);
      });
    } // prepare escape key listener for deactivating when active


    this._escListener = function (event) {
      if ("key" in event ? event.key === "Escape" : event.keyCode === 27
      /* the keyCode is for IE11 */
      ) {
        _this.deactivate();
      }
    };
  } // turn into an event emitter


  Emitter(Activator$1.prototype); // The currently active activator

  Activator$1.current = null;
  /**
   * Destroy the activator. Cleans up all created DOM and event listeners
   */

  Activator$1.prototype.destroy = function () {
    var _context4, _context5;

    this.deactivate();

    var _iterator2 = _createForOfIteratorHelper$3(reverse(_context4 = splice(_context5 = this._cleanupQueue).call(_context5, 0)).call(_context4)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var callback = _step2.value;
        callback();
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  };
  /**
   * Activate the element
   * Overlay is hidden, element is decorated with a blue shadow border
   */


  Activator$1.prototype.activate = function () {
    // we allow only one active activator at a time
    if (Activator$1.current) {
      Activator$1.current.deactivate();
    }

    Activator$1.current = this;
    this.active = true;
    this._dom.overlay.style.display = "none";

    this._dom.container.classList.add("vis-active");

    this.emit("change");
    this.emit("activate"); // ugly hack: bind ESC after emitting the events, as the Network rebinds all
    // keyboard events on a 'change' event

    document.body.addEventListener("keydown", this._escListener);
  };
  /**
   * Deactivate the element
   * Overlay is displayed on top of the element
   */


  Activator$1.prototype.deactivate = function () {
    this.active = false;
    this._dom.overlay.style.display = "block";

    this._dom.container.classList.remove("vis-active");

    document.body.removeEventListener("keydown", this._escListener);
    this.emit("change");
    this.emit("deactivate");
  };
  /**
   * Handle a tap event: activate the container
   *
   * @param {Event}  event   The event
   * @private
   */


  Activator$1.prototype._onTapOverlay = function (event) {
    // activate the container
    this.activate();
    event.srcEvent.stopPropagation();
  };
  /**
   * Test whether the element has the requested parent element somewhere in
   * its chain of parent nodes.
   *
   * @param {HTMLElement} element
   * @param {HTMLElement} parent
   * @returns {boolean} Returns true when the parent is found somewhere in the
   *                    chain of parent nodes.
   * @private
   */


  function _hasParent(element, parent) {
    while (element) {
      if (element === parent) {
        return true;
      }

      element = element.parentNode;
    }

    return false;
  } // utility functions

  var global$4 = global$M;
  var isConstructor = isConstructor$4;
  var tryToString$1 = tryToString$4;
  var TypeError$3 = global$4.TypeError; // `Assert: IsConstructor(argument) is true`

  var aConstructor$1 = function (argument) {
    if (isConstructor(argument)) return argument;
    throw TypeError$3(tryToString$1(argument) + ' is not a constructor');
  };

  var $$5 = _export;
  var getBuiltIn$1 = getBuiltIn$9;
  var apply = functionApply;
  var bind$2 = functionBind;
  var aConstructor = aConstructor$1;
  var anObject$1 = anObject$b;
  var isObject$3 = isObject$f;
  var create$4 = objectCreate;
  var fails$5 = fails$r;
  var nativeConstruct = getBuiltIn$1('Reflect', 'construct');
  var ObjectPrototype = Object.prototype;
  var push$1 = [].push; // `Reflect.construct` method
  // https://tc39.es/ecma262/#sec-reflect.construct
  // MS Edge supports only 2 arguments and argumentsList argument is optional
  // FF Nightly sets third argument as `new.target`, but does not create `this` from it

  var NEW_TARGET_BUG = fails$5(function () {
    function F() {
      /* empty */
    }

    return !(nativeConstruct(function () {
      /* empty */
    }, [], F) instanceof F);
  });
  var ARGS_BUG = !fails$5(function () {
    nativeConstruct(function () {
      /* empty */
    });
  });
  var FORCED$1 = NEW_TARGET_BUG || ARGS_BUG;
  $$5({
    target: 'Reflect',
    stat: true,
    forced: FORCED$1,
    sham: FORCED$1
  }, {
    construct: function construct(Target, args
    /* , newTarget */
    ) {
      aConstructor(Target);
      anObject$1(args);
      var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
      if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);

      if (Target == newTarget) {
        // w/o altered newTarget, optimization for 0-4 arguments
        switch (args.length) {
          case 0:
            return new Target();

          case 1:
            return new Target(args[0]);

          case 2:
            return new Target(args[0], args[1]);

          case 3:
            return new Target(args[0], args[1], args[2]);

          case 4:
            return new Target(args[0], args[1], args[2], args[3]);
        } // w/o altered newTarget, lot of arguments case


        var $args = [null];
        apply(push$1, $args, args);
        return new (apply(bind$2, Target, $args))();
      } // with altered newTarget, not support built-in constructors


      var proto = newTarget.prototype;
      var instance = create$4(isObject$3(proto) ? proto : ObjectPrototype);
      var result = apply(Target, instance, args);
      return isObject$3(result) ? result : instance;
    }
  });

  var path$3 = path$q;
  var construct$2 = path$3.Reflect.construct;

  var parent$h = construct$2;
  var construct$1 = parent$h;

  var construct = construct$1;

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  var parent$g = create$6;
  var create$3 = parent$g;

  var parent$f = create$3;
  var create$2 = parent$f;

  var create$1 = create$2;

  var $$4 = _export;
  var setPrototypeOf$5 = objectSetPrototypeOf; // `Object.setPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.setprototypeof

  $$4({
    target: 'Object',
    stat: true
  }, {
    setPrototypeOf: setPrototypeOf$5
  });

  var path$2 = path$q;
  var setPrototypeOf$4 = path$2.Object.setPrototypeOf;

  var parent$e = setPrototypeOf$4;
  var setPrototypeOf$3 = parent$e;

  var parent$d = setPrototypeOf$3;
  var setPrototypeOf$2 = parent$d;

  var parent$c = setPrototypeOf$2;
  var setPrototypeOf$1 = parent$c;

  var setPrototypeOf = setPrototypeOf$1;

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = create$1(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });

    defineProperty$7(subClass, "prototype", {
      writable: false
    });

    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  var parent$b = getPrototypeOf$3;
  var getPrototypeOf$2 = parent$b;

  var parent$a = getPrototypeOf$2;
  var getPrototypeOf$1 = parent$a;

  var getPrototypeOf = getPrototypeOf$1;

  function _getPrototypeOf(o) {
    _getPrototypeOf = setPrototypeOf ? getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  var runtime = {exports: {}};

  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  (function (module) {
    var runtime = function (exports) {

      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined$1; // More compressible than void 0.

      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      function define(obj, key, value) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }

      try {
        // IE 8 has a broken Object.defineProperty that only works on DOM objects.
        define({}, "");
      } catch (err) {
        define = function (obj, key, value) {
          return obj[key] = value;
        };
      }

      function wrap(innerFn, outerFn, self, tryLocsList) {
        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
        // .throw, and .return methods.

        generator._invoke = makeInvokeMethod(innerFn, self, context);
        return generator;
      }

      exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
      // record like context.tryEntries[i].completion. This interface could
      // have been (and was previously) designed to take a closure to be
      // invoked without arguments, but in all the cases we care about we
      // already have an existing method we want to call, so there's no need
      // to create a new function object. We can even get away with assuming
      // the method takes exactly one argument, since that happens to be true
      // in every case, so we don't have to touch the arguments object. The
      // only additional allocation required is the completion record, which
      // has a stable shape and so hopefully should be cheap to allocate.

      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }

      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
      // breaking out of the dispatch switch statement.

      var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
      // .constructor.prototype properties for functions that return Generator
      // objects. For full spec compliance, you may wish to configure your
      // minifier not to mangle the names of these two functions.

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
      // don't natively support it.


      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function () {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        // This environment has a native %IteratorPrototype%; use it instead
        // of the polyfill.
        IteratorPrototype = NativeIteratorPrototype;
      }

      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      define(Gp, "constructor", GeneratorFunctionPrototype);
      define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
      GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
      // Iterator interface in terms of a single ._invoke method.

      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }

      exports.isGeneratorFunction = function (genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };

      exports.mark = function (genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define(genFun, toStringTagSymbol, "GeneratorFunction");
        }

        genFun.prototype = Object.create(Gp);
        return genFun;
      }; // Within the body of any async function, `await x` is transformed to
      // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
      // `hasOwn.call(value, "__await")` to determine if the yielded value is
      // meant to be awaited.


      exports.awrap = function (arg) {
        return {
          __await: arg
        };
      };

      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);

          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;

            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              });
            }

            return PromiseImpl.resolve(value).then(function (unwrapped) {
              // When a yielded Promise is resolved, its final value becomes
              // the .value of the Promise<{value,done}> result for the
              // current iteration.
              result.value = unwrapped;
              resolve(result);
            }, function (error) {
              // If a rejected Promise was yielded, throw the rejection back
              // into the async generator function so it can be handled there.
              return invoke("throw", error, resolve, reject);
            });
          }
        }

        var previousPromise;

        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } // Define the unified helper method that is used to implement .next,
        // .throw, and .return (see defineIteratorMethods).


        this._invoke = enqueue;
      }

      defineIteratorMethods(AsyncIterator.prototype);
      define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
        return this;
      });
      exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
      // AsyncIterator objects; they just return a Promise for the value of
      // the final result produced by the iterator.

      exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0) PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      };

      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }

          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            } // Be forgiving, per 25.3.3.3.3 of the spec:
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


            return doneResult();
          }

          context.method = method;
          context.arg = arg;

          while (true) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if (context.method === "next") {
              // Setting context._sent for legacy support of Babel's
              // function.sent implementation.
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }

              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }

            state = GenStateExecuting;
            var record = tryCatch(innerFn, self, context);

            if (record.type === "normal") {
              // If an exception is thrown from innerFn, we leave state ===
              // GenStateExecuting and loop back for another invocation.
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;

              if (record.arg === ContinueSentinel) {
                continue;
              }

              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted; // Dispatch the exception by looping back around to the
              // context.dispatchException(context.arg) call above.

              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      } // Call delegate.iterator[context.method](context.arg) and handle the
      // result, either by returning a { value, done } result from the
      // delegate iterator, or by modifying context.method and context.arg,
      // setting context.delegate to null, and returning the ContinueSentinel.


      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];

        if (method === undefined$1) {
          // A .throw or .return when the delegate iterator has no .throw
          // method always terminates the yield* loop.
          context.delegate = null;

          if (context.method === "throw") {
            // Note: ["return"] must be used for ES3 parsing compatibility.
            if (delegate.iterator["return"]) {
              // If the delegate iterator has a return method, give it a
              // chance to clean up.
              context.method = "return";
              context.arg = undefined$1;
              maybeInvokeDelegate(delegate, context);

              if (context.method === "throw") {
                // If maybeInvokeDelegate(context) changed context.method from
                // "return" to "throw", let that override the TypeError below.
                return ContinueSentinel;
              }
            }

            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return ContinueSentinel;
        }

        var record = tryCatch(method, delegate.iterator, context.arg);

        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }

        var info = record.arg;

        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }

        if (info.done) {
          // Assign the result of the finished delegate to the temporary
          // variable specified by delegate.resultName (see delegateYield).
          context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

          context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
          // exception, let the outer generator proceed normally. If
          // context.method was "next", forget context.arg since it has been
          // "consumed" by the delegate iterator. If context.method was
          // "return", allow the original .return call to continue in the
          // outer generator.

          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined$1;
          }
        } else {
          // Re-yield the result returned by the delegate method.
          return info;
        } // The delegate iterator is finished, so forget it and continue with
        // the outer generator.


        context.delegate = null;
        return ContinueSentinel;
      } // Define Generator.prototype.{next,throw,return} in terms of the
      // unified ._invoke helper method.


      defineIteratorMethods(Gp);
      define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
      // @@iterator function is called on it. Some browsers' implementations of the
      // iterator prototype chain incorrectly implement this, causing the Generator
      // object to not be returned from this call. This ensures that doesn't happen.
      // See https://github.com/facebook/regenerator/issues/274 for more details.

      define(Gp, iteratorSymbol, function () {
        return this;
      });
      define(Gp, "toString", function () {
        return "[object Generator]";
      });

      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };

        if (1 in locs) {
          entry.catchLoc = locs[1];
        }

        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }

        this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }

      function Context(tryLocsList) {
        // The root entry object (effectively a try statement without a catch
        // or a finally block) gives us a place to store values thrown from
        // locations where there is no enclosing try statement.
        this.tryEntries = [{
          tryLoc: "root"
        }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }

      exports.keys = function (object) {
        var keys = [];

        for (var key in object) {
          keys.push(key);
        }

        keys.reverse(); // Rather than returning an object with a next method, we keep
        // things simple and return the next function itself.

        return function next() {
          while (keys.length) {
            var key = keys.pop();

            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          } // To avoid creating an additional object, we just hang the .value
          // and .done properties off the next function object itself. This
          // also ensures that the minifier will not anonymize the function.


          next.done = true;
          return next;
        };
      };

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];

          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }

          if (typeof iterable.next === "function") {
            return iterable;
          }

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }

              next.value = undefined$1;
              next.done = true;
              return next;
            };

            return next.next = next;
          }
        } // Return an iterator with no values.


        return {
          next: doneResult
        };
      }

      exports.values = values;

      function doneResult() {
        return {
          value: undefined$1,
          done: true
        };
      }

      Context.prototype = {
        constructor: Context,
        reset: function (skipTempReset) {
          this.prev = 0;
          this.next = 0; // Resetting context._sent for legacy support of Babel's
          // function.sent implementation.

          this.sent = this._sent = undefined$1;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined$1;
          this.tryEntries.forEach(resetTryEntry);

          if (!skipTempReset) {
            for (var name in this) {
              // Not sure about the optimal order of these conditions:
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined$1;
              }
            }
          }
        },
        stop: function () {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;

          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }

          return this.rval;
        },
        dispatchException: function (exception) {
          if (this.done) {
            throw exception;
          }

          var context = this;

          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;

            if (caught) {
              // If the dispatched exception was caught by a catch block,
              // then let that catch block handle the exception normally.
              context.method = "next";
              context.arg = undefined$1;
            }

            return !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;

            if (entry.tryLoc === "root") {
              // Exception thrown outside of any try block that could handle
              // it, so set the completion value of the entire function to
              // throw the exception.
              return handle("end");
            }

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function (type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            // Ignore the finally entry if control is not jumping to a
            // location outside the try/catch block.
            finallyEntry = null;
          }

          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;

          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }

          return this.complete(record);
        },
        complete: function (record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }

          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }

          return ContinueSentinel;
        },
        finish: function (finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function (tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;

              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }

              return thrown;
            }
          } // The context.catch method must only be called with a location
          // argument that corresponds to a known catch block.


          throw new Error("illegal catch attempt");
        },
        delegateYield: function (iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };

          if (this.method === "next") {
            // Deliberately forget the last sent value so that we don't
            // accidentally pass it on to the delegate.
            this.arg = undefined$1;
          }

          return ContinueSentinel;
        }
      }; // Regardless of whether this script is executing as a CommonJS module
      // or not, return the runtime object so that we can declare the variable
      // regeneratorRuntime in the outer scope, which allows this module to be
      // injected easily by `bin/regenerator --include-runtime script.js`.

      return exports;
    }( // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
    module.exports );

    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      // This module should not be running in strict mode, so the above
      // assignment should always work unless something is misconfigured. Just
      // in case runtime.js accidentally runs in strict mode, in modern engines
      // we can explicitly access globalThis. In older engines we can escape
      // strict mode using a global Function call. This could conceivably fail
      // if a Content Security Policy forbids using Function, but in that case
      // the proper solution is to fix the accidental strict mode problem. If
      // you've misconfigured your bundler to force strict mode and applied a
      // CSP to forbid Function, and you're not willing to fix either of those
      // problems, please detail your unique predicament in a GitHub issue.
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  })(runtime);

  var regenerator = runtime.exports;

  var internalMetadata = {exports: {}};

  var fails$4 = fails$r;
  var arrayBufferNonExtensible = fails$4(function () {
    if (typeof ArrayBuffer == 'function') {
      var buffer = new ArrayBuffer(8); // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe

      if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', {
        value: 8
      });
    }
  });

  var fails$3 = fails$r;
  var isObject$2 = isObject$f;
  var classof$3 = classofRaw$1;
  var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible; // eslint-disable-next-line es/no-object-isextensible -- safe

  var $isExtensible = Object.isExtensible;
  var FAILS_ON_PRIMITIVES = fails$3(function () {
    $isExtensible(1);
  }); // `Object.isExtensible` method
  // https://tc39.es/ecma262/#sec-object.isextensible

  var objectIsExtensible = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
    if (!isObject$2(it)) return false;
    if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$3(it) == 'ArrayBuffer') return false;
    return $isExtensible ? $isExtensible(it) : true;
  } : $isExtensible;

  var fails$2 = fails$r;
  var freezing = !fails$2(function () {
    // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
    return Object.isExtensible(Object.preventExtensions({}));
  });

  var $$3 = _export;
  var uncurryThis$1 = functionUncurryThis;
  var hiddenKeys = hiddenKeys$6;
  var isObject$1 = isObject$f;
  var hasOwn$3 = hasOwnProperty_1;
  var defineProperty$2 = objectDefineProperty.f;
  var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
  var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
  var isExtensible = objectIsExtensible;
  var uid = uid$4;
  var FREEZING = freezing;
  var REQUIRED = false;
  var METADATA = uid('meta');
  var id = 0;

  var setMetadata = function (it) {
    defineProperty$2(it, METADATA, {
      value: {
        objectID: 'O' + id++,
        // object ID
        weakData: {} // weak collections IDs

      }
    });
  };

  var fastKey$1 = function (it, create) {
    // return a primitive with prefix
    if (!isObject$1(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

    if (!hasOwn$3(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F'; // not necessary to add metadata

      if (!create) return 'E'; // add missing metadata

      setMetadata(it); // return object ID
    }

    return it[METADATA].objectID;
  };

  var getWeakData = function (it, create) {
    if (!hasOwn$3(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true; // not necessary to add metadata

      if (!create) return false; // add missing metadata

      setMetadata(it); // return the store of weak collections IDs
    }

    return it[METADATA].weakData;
  }; // add metadata on freeze-family methods calling


  var onFreeze = function (it) {
    if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn$3(it, METADATA)) setMetadata(it);
    return it;
  };

  var enable = function () {
    meta.enable = function () {
      /* empty */
    };

    REQUIRED = true;
    var getOwnPropertyNames = getOwnPropertyNamesModule.f;
    var splice = uncurryThis$1([].splice);
    var test = {};
    test[METADATA] = 1; // prevent exposing of metadata key

    if (getOwnPropertyNames(test).length) {
      getOwnPropertyNamesModule.f = function (it) {
        var result = getOwnPropertyNames(it);

        for (var i = 0, length = result.length; i < length; i++) {
          if (result[i] === METADATA) {
            splice(result, i, 1);
            break;
          }
        }

        return result;
      };

      $$3({
        target: 'Object',
        stat: true,
        forced: true
      }, {
        getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
      });
    }
  };

  var meta = internalMetadata.exports = {
    enable: enable,
    fastKey: fastKey$1,
    getWeakData: getWeakData,
    onFreeze: onFreeze
  };
  hiddenKeys[METADATA] = true;

  var global$3 = global$M;
  var bind$1 = functionBindContext;
  var call = functionCall;
  var anObject = anObject$b;
  var tryToString = tryToString$4;
  var isArrayIteratorMethod = isArrayIteratorMethod$2;
  var lengthOfArrayLike$1 = lengthOfArrayLike$d;
  var isPrototypeOf$6 = objectIsPrototypeOf;
  var getIterator$5 = getIterator$7;
  var getIteratorMethod = getIteratorMethod$8;
  var iteratorClose = iteratorClose$2;
  var TypeError$2 = global$3.TypeError;

  var Result = function (stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };

  var ResultPrototype = Result.prototype;

  var iterate$2 = function (iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = bind$1(unboundFunction, that);
    var iterator, iterFn, index, length, result, next, step;

    var stop = function (condition) {
      if (iterator) iteratorClose(iterator, 'normal', condition);
      return new Result(true, condition);
    };

    var callFn = function (value) {
      if (AS_ENTRIES) {
        anObject(value);
        return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
      }

      return INTERRUPTED ? fn(value, stop) : fn(value);
    };

    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (!iterFn) throw TypeError$2(tryToString(iterable) + ' is not iterable'); // optimisation for array iterators

      if (isArrayIteratorMethod(iterFn)) {
        for (index = 0, length = lengthOfArrayLike$1(iterable); length > index; index++) {
          result = callFn(iterable[index]);
          if (result && isPrototypeOf$6(ResultPrototype, result)) return result;
        }

        return new Result(false);
      }

      iterator = getIterator$5(iterable, iterFn);
    }

    next = iterator.next;

    while (!(step = call(next, iterator)).done) {
      try {
        result = callFn(step.value);
      } catch (error) {
        iteratorClose(iterator, 'throw', error);
      }

      if (typeof result == 'object' && result && isPrototypeOf$6(ResultPrototype, result)) return result;
    }

    return new Result(false);
  };

  var global$2 = global$M;
  var isPrototypeOf$5 = objectIsPrototypeOf;
  var TypeError$1 = global$2.TypeError;

  var anInstance$2 = function (it, Prototype) {
    if (isPrototypeOf$5(Prototype, it)) return it;
    throw TypeError$1('Incorrect invocation');
  };

  var $$2 = _export;
  var global$1 = global$M;
  var InternalMetadataModule = internalMetadata.exports;
  var fails$1 = fails$r;
  var createNonEnumerableProperty = createNonEnumerableProperty$6;
  var iterate$1 = iterate$2;
  var anInstance$1 = anInstance$2;
  var isCallable = isCallable$h;
  var isObject = isObject$f;
  var setToStringTag = setToStringTag$5;
  var defineProperty$1 = objectDefineProperty.f;
  var forEach = arrayIteration.forEach;
  var DESCRIPTORS$2 = descriptors;
  var InternalStateModule$1 = internalState;
  var setInternalState$1 = InternalStateModule$1.set;
  var internalStateGetterFor$1 = InternalStateModule$1.getterFor;

  var collection$2 = function (CONSTRUCTOR_NAME, wrapper, common) {
    var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
    var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
    var ADDER = IS_MAP ? 'set' : 'add';
    var NativeConstructor = global$1[CONSTRUCTOR_NAME];
    var NativePrototype = NativeConstructor && NativeConstructor.prototype;
    var exported = {};
    var Constructor;

    if (!DESCRIPTORS$2 || !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$1(function () {
      new NativeConstructor().entries().next();
    }))) {
      // create collection constructor
      Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
      InternalMetadataModule.enable();
    } else {
      Constructor = wrapper(function (target, iterable) {
        setInternalState$1(anInstance$1(target, Prototype), {
          type: CONSTRUCTOR_NAME,
          collection: new NativeConstructor()
        });
        if (iterable != undefined) iterate$1(iterable, target[ADDER], {
          that: target,
          AS_ENTRIES: IS_MAP
        });
      });
      var Prototype = Constructor.prototype;
      var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
      forEach(['add', 'clear', 'delete', 'forEach', 'get', 'has', 'set', 'keys', 'values', 'entries'], function (KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';

        if (KEY in NativePrototype && !(IS_WEAK && KEY == 'clear')) {
          createNonEnumerableProperty(Prototype, KEY, function (a, b) {
            var collection = getInternalState(this).collection;
            if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
            var result = collection[KEY](a === 0 ? 0 : a, b);
            return IS_ADDER ? this : result;
          });
        }
      });
      IS_WEAK || defineProperty$1(Prototype, 'size', {
        configurable: true,
        get: function () {
          return getInternalState(this).collection.size;
        }
      });
    }

    setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);
    exported[CONSTRUCTOR_NAME] = Constructor;
    $$2({
      global: true,
      forced: true
    }, exported);
    if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
    return Constructor;
  };

  var redefine = redefine$4;

  var redefineAll$1 = function (target, src, options) {
    for (var key in src) {
      if (options && options.unsafe && target[key]) target[key] = src[key];else redefine(target, key, src[key], options);
    }

    return target;
  };

  var getBuiltIn = getBuiltIn$9;
  var definePropertyModule = objectDefineProperty;
  var wellKnownSymbol = wellKnownSymbol$j;
  var DESCRIPTORS$1 = descriptors;
  var SPECIES = wellKnownSymbol('species');

  var setSpecies$1 = function (CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
    var defineProperty = definePropertyModule.f;

    if (DESCRIPTORS$1 && Constructor && !Constructor[SPECIES]) {
      defineProperty(Constructor, SPECIES, {
        configurable: true,
        get: function () {
          return this;
        }
      });
    }
  };

  var defineProperty = objectDefineProperty.f;
  var create = objectCreate;
  var redefineAll = redefineAll$1;
  var bind = functionBindContext;
  var anInstance = anInstance$2;
  var iterate = iterate$2;
  var defineIterator = defineIterator$3;
  var setSpecies = setSpecies$1;
  var DESCRIPTORS = descriptors;
  var fastKey = internalMetadata.exports.fastKey;
  var InternalStateModule = internalState;
  var setInternalState = InternalStateModule.set;
  var internalStateGetterFor = InternalStateModule.getterFor;
  var collectionStrong$2 = {
    getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
      var Constructor = wrapper(function (that, iterable) {
        anInstance(that, Prototype);
        setInternalState(that, {
          type: CONSTRUCTOR_NAME,
          index: create(null),
          first: undefined,
          last: undefined,
          size: 0
        });
        if (!DESCRIPTORS) that.size = 0;
        if (iterable != undefined) iterate(iterable, that[ADDER], {
          that: that,
          AS_ENTRIES: IS_MAP
        });
      });
      var Prototype = Constructor.prototype;
      var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

      var define = function (that, key, value) {
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        var previous, index; // change existing entry

        if (entry) {
          entry.value = value; // create new entry
        } else {
          state.last = entry = {
            index: index = fastKey(key, true),
            key: key,
            value: value,
            previous: previous = state.last,
            next: undefined,
            removed: false
          };
          if (!state.first) state.first = entry;
          if (previous) previous.next = entry;
          if (DESCRIPTORS) state.size++;else that.size++; // add to index

          if (index !== 'F') state.index[index] = entry;
        }

        return that;
      };

      var getEntry = function (that, key) {
        var state = getInternalState(that); // fast case

        var index = fastKey(key);
        var entry;
        if (index !== 'F') return state.index[index]; // frozen object case

        for (entry = state.first; entry; entry = entry.next) {
          if (entry.key == key) return entry;
        }
      };

      redefineAll(Prototype, {
        // `{ Map, Set }.prototype.clear()` methods
        // https://tc39.es/ecma262/#sec-map.prototype.clear
        // https://tc39.es/ecma262/#sec-set.prototype.clear
        clear: function clear() {
          var that = this;
          var state = getInternalState(that);
          var data = state.index;
          var entry = state.first;

          while (entry) {
            entry.removed = true;
            if (entry.previous) entry.previous = entry.previous.next = undefined;
            delete data[entry.index];
            entry = entry.next;
          }

          state.first = state.last = undefined;
          if (DESCRIPTORS) state.size = 0;else that.size = 0;
        },
        // `{ Map, Set }.prototype.delete(key)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.delete
        // https://tc39.es/ecma262/#sec-set.prototype.delete
        'delete': function (key) {
          var that = this;
          var state = getInternalState(that);
          var entry = getEntry(that, key);

          if (entry) {
            var next = entry.next;
            var prev = entry.previous;
            delete state.index[entry.index];
            entry.removed = true;
            if (prev) prev.next = next;
            if (next) next.previous = prev;
            if (state.first == entry) state.first = next;
            if (state.last == entry) state.last = prev;
            if (DESCRIPTORS) state.size--;else that.size--;
          }

          return !!entry;
        },
        // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.foreach
        // https://tc39.es/ecma262/#sec-set.prototype.foreach
        forEach: function forEach(callbackfn
        /* , that = undefined */
        ) {
          var state = getInternalState(this);
          var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
          var entry;

          while (entry = entry ? entry.next : state.first) {
            boundFunction(entry.value, entry.key, this); // revert to the last existing entry

            while (entry && entry.removed) entry = entry.previous;
          }
        },
        // `{ Map, Set}.prototype.has(key)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.has
        // https://tc39.es/ecma262/#sec-set.prototype.has
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      redefineAll(Prototype, IS_MAP ? {
        // `Map.prototype.get(key)` method
        // https://tc39.es/ecma262/#sec-map.prototype.get
        get: function get(key) {
          var entry = getEntry(this, key);
          return entry && entry.value;
        },
        // `Map.prototype.set(key, value)` method
        // https://tc39.es/ecma262/#sec-map.prototype.set
        set: function set(key, value) {
          return define(this, key === 0 ? 0 : key, value);
        }
      } : {
        // `Set.prototype.add(value)` method
        // https://tc39.es/ecma262/#sec-set.prototype.add
        add: function add(value) {
          return define(this, value = value === 0 ? 0 : value, value);
        }
      });
      if (DESCRIPTORS) defineProperty(Prototype, 'size', {
        get: function () {
          return getInternalState(this).size;
        }
      });
      return Constructor;
    },
    setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
      var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
      var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
      var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME); // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.entries
      // https://tc39.es/ecma262/#sec-map.prototype.keys
      // https://tc39.es/ecma262/#sec-map.prototype.values
      // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
      // https://tc39.es/ecma262/#sec-set.prototype.entries
      // https://tc39.es/ecma262/#sec-set.prototype.keys
      // https://tc39.es/ecma262/#sec-set.prototype.values
      // https://tc39.es/ecma262/#sec-set.prototype-@@iterator

      defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
        setInternalState(this, {
          type: ITERATOR_NAME,
          target: iterated,
          state: getInternalCollectionState(iterated),
          kind: kind,
          last: undefined
        });
      }, function () {
        var state = getInternalIteratorState(this);
        var kind = state.kind;
        var entry = state.last; // revert to the last existing entry

        while (entry && entry.removed) entry = entry.previous; // get next entry


        if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
          // or finish the iteration
          state.target = undefined;
          return {
            value: undefined,
            done: true
          };
        } // return step by kind


        if (kind == 'keys') return {
          value: entry.key,
          done: false
        };
        if (kind == 'values') return {
          value: entry.value,
          done: false
        };
        return {
          value: [entry.key, entry.value],
          done: false
        };
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // `{ Map, Set }.prototype[@@species]` accessors
      // https://tc39.es/ecma262/#sec-get-map-@@species
      // https://tc39.es/ecma262/#sec-get-set-@@species

      setSpecies(CONSTRUCTOR_NAME);
    }
  };

  var collection$1 = collection$2;
  var collectionStrong$1 = collectionStrong$2; // `Map` constructor
  // https://tc39.es/ecma262/#sec-map-objects

  collection$1('Map', function (init) {
    return function Map() {
      return init(this, arguments.length ? arguments[0] : undefined);
    };
  }, collectionStrong$1);

  var path$1 = path$q;
  var map$2 = path$1.Map;

  var parent$9 = map$2;
  var map$1 = parent$9;

  var map = map$1;

  var $$1 = _export;
  var $some = arrayIteration.some;
  var arrayMethodIsStrict$1 = arrayMethodIsStrict$5;
  var STRICT_METHOD$1 = arrayMethodIsStrict$1('some'); // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some

  $$1({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD$1
  }, {
    some: function some(callbackfn
    /* , thisArg */
    ) {
      return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var entryVirtual$4 = entryVirtual$k;
  var some$3 = entryVirtual$4('Array').some;

  var isPrototypeOf$4 = objectIsPrototypeOf;
  var method$4 = some$3;
  var ArrayPrototype$4 = Array.prototype;

  var some$2 = function (it) {
    var own = it.some;
    return it === ArrayPrototype$4 || isPrototypeOf$4(ArrayPrototype$4, it) && own === ArrayPrototype$4.some ? method$4 : own;
  };

  var parent$8 = some$2;
  var some$1 = parent$8;

  var some = some$1;

  var entryVirtual$3 = entryVirtual$k;
  var keys$3 = entryVirtual$3('Array').keys;

  var parent$7 = keys$3;
  var keys$2 = parent$7;

  var classof$2 = classof$c;
  var hasOwn$2 = hasOwnProperty_1;
  var isPrototypeOf$3 = objectIsPrototypeOf;
  var method$3 = keys$2;
  var ArrayPrototype$3 = Array.prototype;
  var DOMIterables$2 = {
    DOMTokenList: true,
    NodeList: true
  };

  var keys$1 = function (it) {
    var own = it.keys;
    return it === ArrayPrototype$3 || isPrototypeOf$3(ArrayPrototype$3, it) && own === ArrayPrototype$3.keys || hasOwn$2(DOMIterables$2, classof$2(it)) ? method$3 : own;
  };

  var keys = keys$1;

  var arraySlice = arraySliceSimple;
  var floor = Math.floor;

  var mergeSort = function (array, comparefn) {
    var length = array.length;
    var middle = floor(length / 2);
    return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySlice(array, 0, middle), comparefn), mergeSort(arraySlice(array, middle), comparefn), comparefn);
  };

  var insertionSort = function (array, comparefn) {
    var length = array.length;
    var i = 1;
    var element, j;

    while (i < length) {
      j = i;
      element = array[i];

      while (j && comparefn(array[j - 1], element) > 0) {
        array[j] = array[--j];
      }

      if (j !== i++) array[j] = element;
    }

    return array;
  };

  var merge = function (array, left, right, comparefn) {
    var llength = left.length;
    var rlength = right.length;
    var lindex = 0;
    var rindex = 0;

    while (lindex < llength || rindex < rlength) {
      array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
    }

    return array;
  };

  var arraySort = mergeSort;

  var userAgent$1 = engineUserAgent;
  var firefox = userAgent$1.match(/firefox\/(\d+)/i);
  var engineFfVersion = !!firefox && +firefox[1];

  var UA = engineUserAgent;
  var engineIsIeOrEdge = /MSIE|Trident/.test(UA);

  var userAgent = engineUserAgent;
  var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
  var engineWebkitVersion = !!webkit && +webkit[1];

  var $ = _export;
  var uncurryThis = functionUncurryThis;
  var aCallable = aCallable$7;
  var toObject = toObject$e;
  var lengthOfArrayLike = lengthOfArrayLike$d;
  var toString = toString$7;
  var fails = fails$r;
  var internalSort = arraySort;
  var arrayMethodIsStrict = arrayMethodIsStrict$5;
  var FF = engineFfVersion;
  var IE_OR_EDGE = engineIsIeOrEdge;
  var V8 = engineV8Version;
  var WEBKIT = engineWebkitVersion;
  var test = [];
  var un$Sort = uncurryThis(test.sort);
  var push = uncurryThis(test.push); // IE8-

  var FAILS_ON_UNDEFINED = fails(function () {
    test.sort(undefined);
  }); // V8 bug

  var FAILS_ON_NULL = fails(function () {
    test.sort(null);
  }); // Old WebKit

  var STRICT_METHOD = arrayMethodIsStrict('sort');
  var STABLE_SORT = !fails(function () {
    // feature detection can be too slow, so check engines versions
    if (V8) return V8 < 70;
    if (FF && FF > 3) return;
    if (IE_OR_EDGE) return true;
    if (WEBKIT) return WEBKIT < 603;
    var result = '';
    var code, chr, value, index; // generate an array with more 512 elements (Chakra and old V8 fails only in this case)

    for (code = 65; code < 76; code++) {
      chr = String.fromCharCode(code);

      switch (code) {
        case 66:
        case 69:
        case 70:
        case 72:
          value = 3;
          break;

        case 68:
        case 71:
          value = 4;
          break;

        default:
          value = 2;
      }

      for (index = 0; index < 47; index++) {
        test.push({
          k: chr + index,
          v: value
        });
      }
    }

    test.sort(function (a, b) {
      return b.v - a.v;
    });

    for (index = 0; index < test.length; index++) {
      chr = test[index].k.charAt(0);
      if (result.charAt(result.length - 1) !== chr) result += chr;
    }

    return result !== 'DGBEFHACIJK';
  });
  var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;

  var getSortCompare = function (comparefn) {
    return function (x, y) {
      if (y === undefined) return -1;
      if (x === undefined) return 1;
      if (comparefn !== undefined) return +comparefn(x, y) || 0;
      return toString(x) > toString(y) ? 1 : -1;
    };
  }; // `Array.prototype.sort` method
  // https://tc39.es/ecma262/#sec-array.prototype.sort


  $({
    target: 'Array',
    proto: true,
    forced: FORCED
  }, {
    sort: function sort(comparefn) {
      if (comparefn !== undefined) aCallable(comparefn);
      var array = toObject(this);
      if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);
      var items = [];
      var arrayLength = lengthOfArrayLike(array);
      var itemsLength, index;

      for (index = 0; index < arrayLength; index++) {
        if (index in array) push(items, array[index]);
      }

      internalSort(items, getSortCompare(comparefn));
      itemsLength = items.length;
      index = 0;

      while (index < itemsLength) array[index] = items[index++];

      while (index < arrayLength) delete array[index++];

      return array;
    }
  });

  var entryVirtual$2 = entryVirtual$k;
  var sort$3 = entryVirtual$2('Array').sort;

  var isPrototypeOf$2 = objectIsPrototypeOf;
  var method$2 = sort$3;
  var ArrayPrototype$2 = Array.prototype;

  var sort$2 = function (it) {
    var own = it.sort;
    return it === ArrayPrototype$2 || isPrototypeOf$2(ArrayPrototype$2, it) && own === ArrayPrototype$2.sort ? method$2 : own;
  };

  var parent$6 = sort$2;
  var sort$1 = parent$6;

  var sort = sort$1;

  var entryVirtual$1 = entryVirtual$k;
  var values$3 = entryVirtual$1('Array').values;

  var parent$5 = values$3;
  var values$2 = parent$5;

  var classof$1 = classof$c;
  var hasOwn$1 = hasOwnProperty_1;
  var isPrototypeOf$1 = objectIsPrototypeOf;
  var method$1 = values$2;
  var ArrayPrototype$1 = Array.prototype;
  var DOMIterables$1 = {
    DOMTokenList: true,
    NodeList: true
  };

  var values$1 = function (it) {
    var own = it.values;
    return it === ArrayPrototype$1 || isPrototypeOf$1(ArrayPrototype$1, it) && own === ArrayPrototype$1.values || hasOwn$1(DOMIterables$1, classof$1(it)) ? method$1 : own;
  };

  var values = values$1;

  var iterator = iterator$4;

  var entryVirtual = entryVirtual$k;
  var entries$3 = entryVirtual('Array').entries;

  var parent$4 = entries$3;
  var entries$2 = parent$4;

  var classof = classof$c;
  var hasOwn = hasOwnProperty_1;
  var isPrototypeOf = objectIsPrototypeOf;
  var method = entries$2;
  var ArrayPrototype = Array.prototype;
  var DOMIterables = {
    DOMTokenList: true,
    NodeList: true
  };

  var entries$1 = function (it) {
    var own = it.entries;
    return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.entries || hasOwn(DOMIterables, classof(it)) ? method : own;
  };

  var entries = entries$1;

  // Unique ID creation requires a high quality random # generator. In the browser we therefore
  // require the crypto API and do not support built-in fallback to lower quality random number
  // generators (like Math.random()).
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
      // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
      // find the complete implementation of crypto (msCrypto) on IE11.
      getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

      if (!getRandomValues) {
        throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
      }
    }

    return getRandomValues(rnds8);
  }

  var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

  function validate(uuid) {
    return typeof uuid === 'string' && REGEX.test(uuid);
  }

  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */

  var byteToHex = [];

  for (var i = 0; i < 256; ++i) {
    byteToHex.push((i + 0x100).toString(16).substr(1));
  }

  function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields

    if (!validate(uuid)) {
      throw TypeError('Stringified UUID is invalid');
    }

    return uuid;
  }

  function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }

      return buf;
    }

    return stringify(rnds);
  }

  /**
   * Determine whether a value can be used as an id.
   *
   * @param value - Input value of unknown type.
   * @returns True if the value is valid id, false otherwise.
   */
  function isId(value) {
    return typeof value === "string" || typeof value === "number";
  }

  /**
   * A queue.
   *
   * @typeParam T - The type of method names to be replaced by queued versions.
   */
  var Queue = /*#__PURE__*/function () {
    /** Delay in milliseconds. If defined the queue will be periodically flushed. */

    /** Maximum number of entries in the queue before it will be flushed. */

    /**
     * Construct a new Queue.
     *
     * @param options - Queue configuration.
     */
    function Queue(options) {
      _classCallCheck(this, Queue);

      _defineProperty(this, "delay", void 0);

      _defineProperty(this, "max", void 0);

      _defineProperty(this, "_queue", []);

      _defineProperty(this, "_timeout", null);

      _defineProperty(this, "_extended", null);

      // options
      this.delay = null;
      this.max = Infinity;
      this.setOptions(options);
    }
    /**
     * Update the configuration of the queue.
     *
     * @param options - Queue configuration.
     */


    _createClass(Queue, [{
      key: "setOptions",
      value: function setOptions(options) {
        if (options && typeof options.delay !== "undefined") {
          this.delay = options.delay;
        }

        if (options && typeof options.max !== "undefined") {
          this.max = options.max;
        }

        this._flushIfNeeded();
      }
      /**
       * Extend an object with queuing functionality.
       * The object will be extended with a function flush, and the methods provided in options.replace will be replaced with queued ones.
       *
       * @param object - The object to be extended.
       * @param options - Additional options.
       * @returns The created queue.
       */

    }, {
      key: "destroy",
      value:
      /**
       * Destroy the queue. The queue will first flush all queued actions, and in case it has extended an object, will restore the original object.
       */
      function destroy() {
        this.flush();

        if (this._extended) {
          var object = this._extended.object;
          var methods = this._extended.methods;

          for (var i = 0; i < methods.length; i++) {
            var method = methods[i];

            if (method.original) {
              // @TODO: better solution?
              object[method.name] = method.original;
            } else {
              // @TODO: better solution?
              delete object[method.name];
            }
          }

          this._extended = null;
        }
      }
      /**
       * Replace a method on an object with a queued version.
       *
       * @param object - Object having the method.
       * @param method - The method name.
       */

    }, {
      key: "replace",
      value: function replace(object, method) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias -- Function this is necessary in the function bellow, so class this has to be saved into a variable here. */
        var me = this;
        var original = object[method];

        if (!original) {
          throw new Error("Method " + method + " undefined");
        }

        object[method] = function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          // add this call to the queue
          me.queue({
            args: args,
            fn: original,
            context: this
          });
        };
      }
      /**
       * Queue a call.
       *
       * @param entry - The function or entry to be queued.
       */

    }, {
      key: "queue",
      value: function queue(entry) {
        if (typeof entry === "function") {
          this._queue.push({
            fn: entry
          });
        } else {
          this._queue.push(entry);
        }

        this._flushIfNeeded();
      }
      /**
       * Check whether the queue needs to be flushed.
       */

    }, {
      key: "_flushIfNeeded",
      value: function _flushIfNeeded() {
        var _this = this;

        // flush when the maximum is exceeded.
        if (this._queue.length > this.max) {
          this.flush();
        } // flush after a period of inactivity when a delay is configured


        if (this._timeout != null) {
          clearTimeout(this._timeout);
          this._timeout = null;
        }

        if (this.queue.length > 0 && typeof this.delay === "number") {
          this._timeout = setTimeout$1(function () {
            _this.flush();
          }, this.delay);
        }
      }
      /**
       * Flush all queued calls
       */

    }, {
      key: "flush",
      value: function flush() {
        var _context, _context2;

        forEach$1(_context = splice(_context2 = this._queue).call(_context2, 0)).call(_context, function (entry) {
          entry.fn.apply(entry.context || entry.fn, entry.args || []);
        });
      }
    }], [{
      key: "extend",
      value: function extend(object, options) {
        var queue = new Queue(options);

        if (object.flush !== undefined) {
          throw new Error("Target object already has a property flush");
        }

        object.flush = function () {
          queue.flush();
        };

        var methods = [{
          name: "flush",
          original: undefined
        }];

        if (options && options.replace) {
          for (var i = 0; i < options.replace.length; i++) {
            var name = options.replace[i];
            methods.push({
              name: name,
              // @TODO: better solution?
              original: object[name]
            }); // @TODO: better solution?

            queue.replace(object, name);
          }
        }

        queue._extended = {
          object: object,
          methods: methods
        };
        return queue;
      }
    }]);

    return Queue;
  }();

  /**
   * [[DataSet]] code that can be reused in [[DataView]] or other similar implementations of [[DataInterface]].
   *
   * @typeParam Item - Item type that may or may not have an id.
   * @typeParam IdProp - Name of the property that contains the id.
   */
  var DataSetPart = /*#__PURE__*/function () {
    function DataSetPart() {
      _classCallCheck(this, DataSetPart);

      _defineProperty(this, "_subscribers", {
        "*": [],
        add: [],
        remove: [],
        update: []
      });

      _defineProperty(this, "subscribe", DataSetPart.prototype.on);

      _defineProperty(this, "unsubscribe", DataSetPart.prototype.off);
    }

    _createClass(DataSetPart, [{
      key: "_trigger",
      value:
      /**
       * Trigger an event
       *
       * @param event - Event name.
       * @param payload - Event payload.
       * @param senderId - Id of the sender.
       */
      function _trigger(event, payload, senderId) {
        var _context, _context2;

        if (event === "*") {
          throw new Error("Cannot trigger event *");
        }

        forEach$1(_context = concat$1(_context2 = []).call(_context2, _toConsumableArray(this._subscribers[event]), _toConsumableArray(this._subscribers["*"]))).call(_context, function (subscriber) {
          subscriber(event, payload, senderId != null ? senderId : null);
        });
      }
      /**
       * Subscribe to an event, add an event listener.
       *
       * @remarks Non-function callbacks are ignored.
       * @param event - Event name.
       * @param callback - Callback method.
       */

    }, {
      key: "on",
      value: function on(event, callback) {
        if (typeof callback === "function") {
          this._subscribers[event].push(callback);
        } // @TODO: Maybe throw for invalid callbacks?

      }
      /**
       * Unsubscribe from an event, remove an event listener.
       *
       * @remarks If the same callback was subscribed more than once **all** occurences will be removed.
       * @param event - Event name.
       * @param callback - Callback method.
       */

    }, {
      key: "off",
      value: function off(event, callback) {
        var _context3;

        this._subscribers[event] = filter(_context3 = this._subscribers[event]).call(_context3, function (subscriber) {
          return subscriber !== callback;
        });
      }
      /**
       * @deprecated Use on instead (PS: DataView.subscribe === DataView.on).
       */

    }]);

    return DataSetPart;
  }();

  var collection = collection$2;
  var collectionStrong = collectionStrong$2; // `Set` constructor
  // https://tc39.es/ecma262/#sec-set-objects

  collection('Set', function (init) {
    return function Set() {
      return init(this, arguments.length ? arguments[0] : undefined);
    };
  }, collectionStrong);

  var path = path$q;
  var set$2 = path.Set;

  var parent$3 = set$2;
  var set$1 = parent$3;

  var set = set$1;

  var getIterator$4 = getIterator$7;
  var getIterator_1 = getIterator$4;

  var parent$2 = getIterator_1;
  var getIterator$3 = parent$2;

  var parent$1 = getIterator$3;
  var getIterator$2 = parent$1;

  var parent = getIterator$2;
  var getIterator$1 = parent;

  var getIterator = getIterator$1;

  var _Symbol$iterator;

  function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$1(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$2(o, minLen) { var _context10; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = slice(_context10 = Object.prototype.toString.call(o)).call(_context10, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

  function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  _Symbol$iterator = iterator;

  /**
   * Data stream
   *
   * @remarks
   * [[DataStream]] offers an always up to date stream of items from a [[DataSet]] or [[DataView]].
   * That means that the stream is evaluated at the time of iteration, conversion to another data type or when [[cache]] is called, not when the [[DataStream]] was created.
   * Multiple invocations of for example [[toItemArray]] may yield different results (if the data source like for example [[DataSet]] gets modified).
   * @typeParam Item - The item type this stream is going to work with.
   */
  var DataStream = /*#__PURE__*/function () {
    /**
     * Create a new data stream.
     *
     * @param pairs - The id, item pairs.
     */
    function DataStream(pairs) {
      _classCallCheck(this, DataStream);

      _defineProperty(this, "_pairs", void 0);

      this._pairs = pairs;
    }
    /**
     * Return an iterable of key, value pairs for every entry in the stream.
     */


    _createClass(DataStream, [{
      key: _Symbol$iterator,
      value:
      /*#__PURE__*/
      regenerator.mark(function value() {
        var _iterator, _step, _step$value, id, item;

        return regenerator.wrap(function value$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _iterator = _createForOfIteratorHelper$2(this._pairs);
                _context.prev = 1;

                _iterator.s();

              case 3:
                if ((_step = _iterator.n()).done) {
                  _context.next = 9;
                  break;
                }

                _step$value = _slicedToArray(_step.value, 2), id = _step$value[0], item = _step$value[1];
                _context.next = 7;
                return [id, item];

              case 7:
                _context.next = 3;
                break;

              case 9:
                _context.next = 14;
                break;

              case 11:
                _context.prev = 11;
                _context.t0 = _context["catch"](1);

                _iterator.e(_context.t0);

              case 14:
                _context.prev = 14;

                _iterator.f();

                return _context.finish(14);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, value, this, [[1, 11, 14, 17]]);
      })
      /**
       * Return an iterable of key, value pairs for every entry in the stream.
       */

    }, {
      key: "entries",
      value:
      /*#__PURE__*/
      regenerator.mark(function entries() {
        var _iterator2, _step2, _step2$value, id, item;

        return regenerator.wrap(function entries$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _iterator2 = _createForOfIteratorHelper$2(this._pairs);
                _context2.prev = 1;

                _iterator2.s();

              case 3:
                if ((_step2 = _iterator2.n()).done) {
                  _context2.next = 9;
                  break;
                }

                _step2$value = _slicedToArray(_step2.value, 2), id = _step2$value[0], item = _step2$value[1];
                _context2.next = 7;
                return [id, item];

              case 7:
                _context2.next = 3;
                break;

              case 9:
                _context2.next = 14;
                break;

              case 11:
                _context2.prev = 11;
                _context2.t0 = _context2["catch"](1);

                _iterator2.e(_context2.t0);

              case 14:
                _context2.prev = 14;

                _iterator2.f();

                return _context2.finish(14);

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, entries, this, [[1, 11, 14, 17]]);
      })
      /**
       * Return an iterable of keys in the stream.
       */

    }, {
      key: "keys",
      value:
      /*#__PURE__*/
      regenerator.mark(function keys() {
        var _iterator3, _step3, _step3$value, id;

        return regenerator.wrap(function keys$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _iterator3 = _createForOfIteratorHelper$2(this._pairs);
                _context3.prev = 1;

                _iterator3.s();

              case 3:
                if ((_step3 = _iterator3.n()).done) {
                  _context3.next = 9;
                  break;
                }

                _step3$value = _slicedToArray(_step3.value, 1), id = _step3$value[0];
                _context3.next = 7;
                return id;

              case 7:
                _context3.next = 3;
                break;

              case 9:
                _context3.next = 14;
                break;

              case 11:
                _context3.prev = 11;
                _context3.t0 = _context3["catch"](1);

                _iterator3.e(_context3.t0);

              case 14:
                _context3.prev = 14;

                _iterator3.f();

                return _context3.finish(14);

              case 17:
              case "end":
                return _context3.stop();
            }
          }
        }, keys, this, [[1, 11, 14, 17]]);
      })
      /**
       * Return an iterable of values in the stream.
       */

    }, {
      key: "values",
      value:
      /*#__PURE__*/
      regenerator.mark(function values() {
        var _iterator4, _step4, _step4$value, item;

        return regenerator.wrap(function values$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _iterator4 = _createForOfIteratorHelper$2(this._pairs);
                _context4.prev = 1;

                _iterator4.s();

              case 3:
                if ((_step4 = _iterator4.n()).done) {
                  _context4.next = 9;
                  break;
                }

                _step4$value = _slicedToArray(_step4.value, 2), item = _step4$value[1];
                _context4.next = 7;
                return item;

              case 7:
                _context4.next = 3;
                break;

              case 9:
                _context4.next = 14;
                break;

              case 11:
                _context4.prev = 11;
                _context4.t0 = _context4["catch"](1);

                _iterator4.e(_context4.t0);

              case 14:
                _context4.prev = 14;

                _iterator4.f();

                return _context4.finish(14);

              case 17:
              case "end":
                return _context4.stop();
            }
          }
        }, values, this, [[1, 11, 14, 17]]);
      })
      /**
       * Return an array containing all the ids in this stream.
       *
       * @remarks
       * The array may contain duplicities.
       * @returns The array with all ids from this stream.
       */

    }, {
      key: "toIdArray",
      value: function toIdArray() {
        var _context5;

        return map$3(_context5 = _toConsumableArray(this._pairs)).call(_context5, function (pair) {
          return pair[0];
        });
      }
      /**
       * Return an array containing all the items in this stream.
       *
       * @remarks
       * The array may contain duplicities.
       * @returns The array with all items from this stream.
       */

    }, {
      key: "toItemArray",
      value: function toItemArray() {
        var _context6;

        return map$3(_context6 = _toConsumableArray(this._pairs)).call(_context6, function (pair) {
          return pair[1];
        });
      }
      /**
       * Return an array containing all the entries in this stream.
       *
       * @remarks
       * The array may contain duplicities.
       * @returns The array with all entries from this stream.
       */

    }, {
      key: "toEntryArray",
      value: function toEntryArray() {
        return _toConsumableArray(this._pairs);
      }
      /**
       * Return an object map containing all the items in this stream accessible by ids.
       *
       * @remarks
       * In case of duplicate ids (coerced to string so `7 == '7'`) the last encoutered appears in the returned object.
       * @returns The object map of all id → item pairs from this stream.
       */

    }, {
      key: "toObjectMap",
      value: function toObjectMap() {
        var map = create$5(null);

        var _iterator5 = _createForOfIteratorHelper$2(this._pairs),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = _slicedToArray(_step5.value, 2),
                id = _step5$value[0],
                item = _step5$value[1];

            map[id] = item;
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        return map;
      }
      /**
       * Return a map containing all the items in this stream accessible by ids.
       *
       * @returns The map of all id → item pairs from this stream.
       */

    }, {
      key: "toMap",
      value: function toMap() {
        return new map(this._pairs);
      }
      /**
       * Return a set containing all the (unique) ids in this stream.
       *
       * @returns The set of all ids from this stream.
       */

    }, {
      key: "toIdSet",
      value: function toIdSet() {
        return new set(this.toIdArray());
      }
      /**
       * Return a set containing all the (unique) items in this stream.
       *
       * @returns The set of all items from this stream.
       */

    }, {
      key: "toItemSet",
      value: function toItemSet() {
        return new set(this.toItemArray());
      }
      /**
       * Cache the items from this stream.
       *
       * @remarks
       * This method allows for items to be fetched immediatelly and used (possibly multiple times) later.
       * It can also be used to optimize performance as [[DataStream]] would otherwise reevaluate everything upon each iteration.
       *
       * ## Example
       * ```javascript
       * const ds = new DataSet([…])
       *
       * const cachedStream = ds.stream()
       *   .filter(…)
       *   .sort(…)
       *   .map(…)
       *   .cached(…) // Data are fetched, processed and cached here.
       *
       * ds.clear()
       * chachedStream // Still has all the items.
       * ```
       * @returns A new [[DataStream]] with cached items (detached from the original [[DataSet]]).
       */

    }, {
      key: "cache",
      value: function cache() {
        return new DataStream(_toConsumableArray(this._pairs));
      }
      /**
       * Get the distinct values of given property.
       *
       * @param callback - The function that picks and possibly converts the property.
       * @typeParam T - The type of the distinct value.
       * @returns A set of all distinct properties.
       */

    }, {
      key: "distinct",
      value: function distinct(callback) {
        var set$1 = new set();

        var _iterator6 = _createForOfIteratorHelper$2(this._pairs),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var _step6$value = _slicedToArray(_step6.value, 2),
                id = _step6$value[0],
                item = _step6$value[1];

            set$1.add(callback(item, id));
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        return set$1;
      }
      /**
       * Filter the items of the stream.
       *
       * @param callback - The function that decides whether an item will be included.
       * @returns A new data stream with the filtered items.
       */

    }, {
      key: "filter",
      value: function filter(callback) {
        var pairs = this._pairs;
        return new DataStream(_defineProperty({}, iterator, /*#__PURE__*/regenerator.mark(function _callee() {
          var _iterator7, _step7, _step7$value, id, item;

          return regenerator.wrap(function _callee$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _iterator7 = _createForOfIteratorHelper$2(pairs);
                  _context7.prev = 1;

                  _iterator7.s();

                case 3:
                  if ((_step7 = _iterator7.n()).done) {
                    _context7.next = 10;
                    break;
                  }

                  _step7$value = _slicedToArray(_step7.value, 2), id = _step7$value[0], item = _step7$value[1];

                  if (!callback(item, id)) {
                    _context7.next = 8;
                    break;
                  }

                  _context7.next = 8;
                  return [id, item];

                case 8:
                  _context7.next = 3;
                  break;

                case 10:
                  _context7.next = 15;
                  break;

                case 12:
                  _context7.prev = 12;
                  _context7.t0 = _context7["catch"](1);

                  _iterator7.e(_context7.t0);

                case 15:
                  _context7.prev = 15;

                  _iterator7.f();

                  return _context7.finish(15);

                case 18:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee, null, [[1, 12, 15, 18]]);
        })));
      }
      /**
       * Execute a callback for each item of the stream.
       *
       * @param callback - The function that will be invoked for each item.
       */

    }, {
      key: "forEach",
      value: function forEach(callback) {
        var _iterator8 = _createForOfIteratorHelper$2(this._pairs),
            _step8;

        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var _step8$value = _slicedToArray(_step8.value, 2),
                id = _step8$value[0],
                item = _step8$value[1];

            callback(item, id);
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
      }
      /**
       * Map the items into a different type.
       *
       * @param callback - The function that does the conversion.
       * @typeParam Mapped - The type of the item after mapping.
       * @returns A new data stream with the mapped items.
       */

    }, {
      key: "map",
      value: function map(callback) {
        var pairs = this._pairs;
        return new DataStream(_defineProperty({}, iterator, /*#__PURE__*/regenerator.mark(function _callee2() {
          var _iterator9, _step9, _step9$value, id, item;

          return regenerator.wrap(function _callee2$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  _iterator9 = _createForOfIteratorHelper$2(pairs);
                  _context8.prev = 1;

                  _iterator9.s();

                case 3:
                  if ((_step9 = _iterator9.n()).done) {
                    _context8.next = 9;
                    break;
                  }

                  _step9$value = _slicedToArray(_step9.value, 2), id = _step9$value[0], item = _step9$value[1];
                  _context8.next = 7;
                  return [id, callback(item, id)];

                case 7:
                  _context8.next = 3;
                  break;

                case 9:
                  _context8.next = 14;
                  break;

                case 11:
                  _context8.prev = 11;
                  _context8.t0 = _context8["catch"](1);

                  _iterator9.e(_context8.t0);

                case 14:
                  _context8.prev = 14;

                  _iterator9.f();

                  return _context8.finish(14);

                case 17:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee2, null, [[1, 11, 14, 17]]);
        })));
      }
      /**
       * Get the item with the maximum value of given property.
       *
       * @param callback - The function that picks and possibly converts the property.
       * @returns The item with the maximum if found otherwise null.
       */

    }, {
      key: "max",
      value: function max(callback) {
        var iter = getIterator(this._pairs);

        var curr = iter.next();

        if (curr.done) {
          return null;
        }

        var maxItem = curr.value[1];
        var maxValue = callback(curr.value[1], curr.value[0]);

        while (!(curr = iter.next()).done) {
          var _curr$value = _slicedToArray(curr.value, 2),
              id = _curr$value[0],
              item = _curr$value[1];

          var _value = callback(item, id);

          if (_value > maxValue) {
            maxValue = _value;
            maxItem = item;
          }
        }

        return maxItem;
      }
      /**
       * Get the item with the minimum value of given property.
       *
       * @param callback - The function that picks and possibly converts the property.
       * @returns The item with the minimum if found otherwise null.
       */

    }, {
      key: "min",
      value: function min(callback) {
        var iter = getIterator(this._pairs);

        var curr = iter.next();

        if (curr.done) {
          return null;
        }

        var minItem = curr.value[1];
        var minValue = callback(curr.value[1], curr.value[0]);

        while (!(curr = iter.next()).done) {
          var _curr$value2 = _slicedToArray(curr.value, 2),
              id = _curr$value2[0],
              item = _curr$value2[1];

          var _value2 = callback(item, id);

          if (_value2 < minValue) {
            minValue = _value2;
            minItem = item;
          }
        }

        return minItem;
      }
      /**
       * Reduce the items into a single value.
       *
       * @param callback - The function that does the reduction.
       * @param accumulator - The initial value of the accumulator.
       * @typeParam T - The type of the accumulated value.
       * @returns The reduced value.
       */

    }, {
      key: "reduce",
      value: function reduce(callback, accumulator) {
        var _iterator10 = _createForOfIteratorHelper$2(this._pairs),
            _step10;

        try {
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            var _step10$value = _slicedToArray(_step10.value, 2),
                id = _step10$value[0],
                item = _step10$value[1];

            accumulator = callback(accumulator, item, id);
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }

        return accumulator;
      }
      /**
       * Sort the items.
       *
       * @param callback - Item comparator.
       * @returns A new stream with sorted items.
       */

    }, {
      key: "sort",
      value: function sort$1(callback) {
        var _this = this;

        return new DataStream(_defineProperty({}, iterator, function () {
          var _context9;

          return getIterator(sort(_context9 = _toConsumableArray(_this._pairs)).call(_context9, function (_ref, _ref2) {
            var _ref3 = _slicedToArray(_ref, 2),
                idA = _ref3[0],
                itemA = _ref3[1];

            var _ref4 = _slicedToArray(_ref2, 2),
                idB = _ref4[0],
                itemB = _ref4[1];

            return callback(itemA, itemB, idA, idB);
          }));
        }));
      }
    }]);

    return DataStream;
  }();

  function ownKeys(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context10, _context11; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$1(_context10 = ownKeys(Object(source), !0)).call(_context10, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$1(_context11 = ownKeys(Object(source))).call(_context11, function (key) { defineProperty$4(target, key, getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$1(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$1(o, minLen) { var _context9; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = slice(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

  function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Add an id to given item if it doesn't have one already.
   *
   * @remarks
   * The item will be modified.
   * @param item - The item that will have an id after a call to this function.
   * @param idProp - The key of the id property.
   * @typeParam Item - Item type that may or may not have an id.
   * @typeParam IdProp - Name of the property that contains the id.
   * @returns true
   */

  function ensureFullItem(item, idProp) {
    if (item[idProp] == null) {
      // generate an id
      item[idProp] = v4();
    }

    return item;
  }
  /**
   * # DataSet
   *
   * Vis.js comes with a flexible DataSet, which can be used to hold and
   * manipulate unstructured data and listen for changes in the data. The DataSet
   * is key/value based. Data items can be added, updated and removed from the
   * DataSet, and one can subscribe to changes in the DataSet. The data in the
   * DataSet can be filtered and ordered. Data can be normalized when appending it
   * to the DataSet as well.
   *
   * ## Example
   *
   * The following example shows how to use a DataSet.
   *
   * ```javascript
   * // create a DataSet
   * var options = {};
   * var data = new vis.DataSet(options);
   *
   * // add items
   * // note that the data items can contain different properties and data formats
   * data.add([
   *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},
   *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},
   *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},
   *   {id: 4, text: 'item 4'}
   * ]);
   *
   * // subscribe to any change in the DataSet
   * data.on('*', function (event, properties, senderId) {
   *   console.log('event', event, properties);
   * });
   *
   * // update an existing item
   * data.update({id: 2, group: 1});
   *
   * // remove an item
   * data.remove(4);
   *
   * // get all ids
   * var ids = data.getIds();
   * console.log('ids', ids);
   *
   * // get a specific item
   * var item1 = data.get(1);
   * console.log('item1', item1);
   *
   * // retrieve a filtered subset of the data
   * var items = data.get({
   *   filter: function (item) {
   *     return item.group == 1;
   *   }
   * });
   * console.log('filtered items', items);
   * ```
   *
   * @typeParam Item - Item type that may or may not have an id.
   * @typeParam IdProp - Name of the property that contains the id.
   */


  var DataSet = /*#__PURE__*/function (_DataSetPart) {
    _inherits(DataSet, _DataSetPart);

    var _super = _createSuper$1(DataSet);

    /**
     * Construct a new DataSet.
     *
     * @param data - Initial data or options.
     * @param options - Options (type error if data is also options).
     */
    function DataSet(data, options) {
      var _this;

      _classCallCheck(this, DataSet);

      _this = _super.call(this); // correctly read optional arguments

      _defineProperty(_assertThisInitialized(_this), "flush", void 0);

      _defineProperty(_assertThisInitialized(_this), "length", void 0);

      _defineProperty(_assertThisInitialized(_this), "_options", void 0);

      _defineProperty(_assertThisInitialized(_this), "_data", void 0);

      _defineProperty(_assertThisInitialized(_this), "_idProp", void 0);

      _defineProperty(_assertThisInitialized(_this), "_queue", null);

      if (data && !isArray$1(data)) {
        options = data;
        data = [];
      }

      _this._options = options || {};
      _this._data = new map(); // map with data indexed by id

      _this.length = 0; // number of items in the DataSet

      _this._idProp = _this._options.fieldId || "id"; // name of the field containing id
      // add initial data when provided

      if (data && data.length) {
        _this.add(data);
      }

      _this.setOptions(options);

      return _this;
    }
    /**
     * Set new options.
     *
     * @param options - The new options.
     */


    _createClass(DataSet, [{
      key: "idProp",
      get:
      /** Flush all queued calls. */

      /** @inheritDoc */

      /** @inheritDoc */
      function get() {
        return this._idProp;
      }
    }, {
      key: "setOptions",
      value: function setOptions(options) {
        if (options && options.queue !== undefined) {
          if (options.queue === false) {
            // delete queue if loaded
            if (this._queue) {
              this._queue.destroy();

              this._queue = null;
            }
          } else {
            // create queue and update its options
            if (!this._queue) {
              this._queue = Queue.extend(this, {
                replace: ["add", "update", "remove"]
              });
            }

            if (options.queue && _typeof(options.queue) === "object") {
              this._queue.setOptions(options.queue);
            }
          }
        }
      }
      /**
       * Add a data item or an array with items.
       *
       * After the items are added to the DataSet, the DataSet will trigger an event `add`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
       *
       * ## Example
       *
       * ```javascript
       * // create a DataSet
       * const data = new vis.DataSet()
       *
       * // add items
       * const ids = data.add([
       *   { id: 1, text: 'item 1' },
       *   { id: 2, text: 'item 2' },
       *   { text: 'item without an id' }
       * ])
       *
       * console.log(ids) // [1, 2, '<UUIDv4>']
       * ```
       *
       * @param data - Items to be added (ids will be generated if missing).
       * @param senderId - Sender id.
       * @returns addedIds - Array with the ids (generated if not present) of the added items.
       * @throws When an item with the same id as any of the added items already exists.
       */

    }, {
      key: "add",
      value: function add(data, senderId) {
        var _this2 = this;

        var addedIds = [];
        var id;

        if (isArray$1(data)) {
          // Array
          var idsToAdd = map$3(data).call(data, function (d) {
            return d[_this2._idProp];
          });

          if (some(idsToAdd).call(idsToAdd, function (id) {
            return _this2._data.has(id);
          })) {
            throw new Error("A duplicate id was found in the parameter array.");
          }

          for (var i = 0, len = data.length; i < len; i++) {
            id = this._addItem(data[i]);
            addedIds.push(id);
          }
        } else if (data && _typeof(data) === "object") {
          // Single item
          id = this._addItem(data);
          addedIds.push(id);
        } else {
          throw new Error("Unknown dataType");
        }

        if (addedIds.length) {
          this._trigger("add", {
            items: addedIds
          }, senderId);
        }

        return addedIds;
      }
      /**
       * Update existing items. When an item does not exist, it will be created.
       *
       * @remarks
       * The provided properties will be merged in the existing item. When an item does not exist, it will be created.
       *
       * After the items are updated, the DataSet will trigger an event `add` for the added items, and an event `update`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
       *
       * ## Example
       *
       * ```javascript
       * // create a DataSet
       * const data = new vis.DataSet([
       *   { id: 1, text: 'item 1' },
       *   { id: 2, text: 'item 2' },
       *   { id: 3, text: 'item 3' }
       * ])
       *
       * // update items
       * const ids = data.update([
       *   { id: 2, text: 'item 2 (updated)' },
       *   { id: 4, text: 'item 4 (new)' }
       * ])
       *
       * console.log(ids) // [2, 4]
       * ```
       *
       * ## Warning for TypeScript users
       * This method may introduce partial items into the data set. Use add or updateOnly instead for better type safety.
       * @param data - Items to be updated (if the id is already present) or added (if the id is missing).
       * @param senderId - Sender id.
       * @returns updatedIds - The ids of the added (these may be newly generated if there was no id in the item from the data) or updated items.
       * @throws When the supplied data is neither an item nor an array of items.
       */

    }, {
      key: "update",
      value: function update(data, senderId) {
        var _this3 = this;

        var addedIds = [];
        var updatedIds = [];
        var oldData = [];
        var updatedData = [];
        var idProp = this._idProp;

        var addOrUpdate = function addOrUpdate(item) {
          var origId = item[idProp];

          if (origId != null && _this3._data.has(origId)) {
            var fullItem = item; // it has an id, therefore it is a fullitem

            var oldItem = assign$2({}, _this3._data.get(origId)); // update item


            var id = _this3._updateItem(fullItem);

            updatedIds.push(id);
            updatedData.push(fullItem);
            oldData.push(oldItem);
          } else {
            // add new item
            var _id = _this3._addItem(item);

            addedIds.push(_id);
          }
        };

        if (isArray$1(data)) {
          // Array
          for (var i = 0, len = data.length; i < len; i++) {
            if (data[i] && _typeof(data[i]) === "object") {
              addOrUpdate(data[i]);
            } else {
              console.warn("Ignoring input item, which is not an object at index " + i);
            }
          }
        } else if (data && _typeof(data) === "object") {
          // Single item
          addOrUpdate(data);
        } else {
          throw new Error("Unknown dataType");
        }

        if (addedIds.length) {
          this._trigger("add", {
            items: addedIds
          }, senderId);
        }

        if (updatedIds.length) {
          var props = {
            items: updatedIds,
            oldData: oldData,
            data: updatedData
          }; // TODO: remove deprecated property 'data' some day
          //Object.defineProperty(props, 'data', {
          //  'get': (function() {
          //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
          //    return updatedData;
          //  }).bind(this)
          //});

          this._trigger("update", props, senderId);
        }

        return concat$1(addedIds).call(addedIds, updatedIds);
      }
      /**
       * Update existing items. When an item does not exist, an error will be thrown.
       *
       * @remarks
       * The provided properties will be deeply merged into the existing item.
       * When an item does not exist (id not present in the data set or absent), an error will be thrown and nothing will be changed.
       *
       * After the items are updated, the DataSet will trigger an event `update`.
       * When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
       *
       * ## Example
       *
       * ```javascript
       * // create a DataSet
       * const data = new vis.DataSet([
       *   { id: 1, text: 'item 1' },
       *   { id: 2, text: 'item 2' },
       *   { id: 3, text: 'item 3' },
       * ])
       *
       * // update items
       * const ids = data.update([
       *   { id: 2, text: 'item 2 (updated)' }, // works
       *   // { id: 4, text: 'item 4 (new)' }, // would throw
       *   // { text: 'item 4 (new)' }, // would also throw
       * ])
       *
       * console.log(ids) // [2]
       * ```
       * @param data - Updates (the id and optionally other props) to the items in this data set.
       * @param senderId - Sender id.
       * @returns updatedIds - The ids of the updated items.
       * @throws When the supplied data is neither an item nor an array of items, when the ids are missing.
       */

    }, {
      key: "updateOnly",
      value: function updateOnly(data, senderId) {
        var _context,
            _this4 = this;

        if (!isArray$1(data)) {
          data = [data];
        }

        var updateEventData = map$3(_context = map$3(data).call(data, function (update) {
          var oldData = _this4._data.get(update[_this4._idProp]);

          if (oldData == null) {
            throw new Error("Updating non-existent items is not allowed.");
          }

          return {
            oldData: oldData,
            update: update
          };
        })).call(_context, function (_ref) {
          var oldData = _ref.oldData,
              update = _ref.update;
          var id = oldData[_this4._idProp];
          var updatedData = pureDeepObjectAssign(oldData, update);

          _this4._data.set(id, updatedData);

          return {
            id: id,
            oldData: oldData,
            updatedData: updatedData
          };
        });

        if (updateEventData.length) {
          var props = {
            items: map$3(updateEventData).call(updateEventData, function (value) {
              return value.id;
            }),
            oldData: map$3(updateEventData).call(updateEventData, function (value) {
              return value.oldData;
            }),
            data: map$3(updateEventData).call(updateEventData, function (value) {
              return value.updatedData;
            })
          }; // TODO: remove deprecated property 'data' some day
          //Object.defineProperty(props, 'data', {
          //  'get': (function() {
          //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
          //    return updatedData;
          //  }).bind(this)
          //});

          this._trigger("update", props, senderId);

          return props.items;
        } else {
          return [];
        }
      }
      /** @inheritDoc */

    }, {
      key: "get",
      value: function get(first, second) {
        // @TODO: Woudn't it be better to split this into multiple methods?
        // parse the arguments
        var id = undefined;
        var ids = undefined;
        var options = undefined;

        if (isId(first)) {
          // get(id [, options])
          id = first;
          options = second;
        } else if (isArray$1(first)) {
          // get(ids [, options])
          ids = first;
          options = second;
        } else {
          // get([, options])
          options = first;
        } // determine the return type


        var returnType = options && options.returnType === "Object" ? "Object" : "Array"; // @TODO: WTF is this? Or am I missing something?
        // var returnType
        // if (options && options.returnType) {
        //   var allowedValues = ['Array', 'Object']
        //   returnType =
        //     allowedValues.indexOf(options.returnType) == -1
        //       ? 'Array'
        //       : options.returnType
        // } else {
        //   returnType = 'Array'
        // }
        // build options

        var filter$1 = options && filter(options);

        var items = [];
        var item = undefined;
        var itemIds = undefined;
        var itemId = undefined; // convert items

        if (id != null) {
          // return a single item
          item = this._data.get(id);

          if (item && filter$1 && !filter$1(item)) {
            item = undefined;
          }
        } else if (ids != null) {
          // return a subset of items
          for (var i = 0, len = ids.length; i < len; i++) {
            item = this._data.get(ids[i]);

            if (item != null && (!filter$1 || filter$1(item))) {
              items.push(item);
            }
          }
        } else {
          var _context2;

          // return all items
          itemIds = _toConsumableArray(keys(_context2 = this._data).call(_context2));

          for (var _i = 0, _len = itemIds.length; _i < _len; _i++) {
            itemId = itemIds[_i];
            item = this._data.get(itemId);

            if (item != null && (!filter$1 || filter$1(item))) {
              items.push(item);
            }
          }
        } // order the results


        if (options && options.order && id == undefined) {
          this._sort(items, options.order);
        } // filter fields of the items


        if (options && options.fields) {
          var fields = options.fields;

          if (id != undefined && item != null) {
            item = this._filterFields(item, fields);
          } else {
            for (var _i2 = 0, _len2 = items.length; _i2 < _len2; _i2++) {
              items[_i2] = this._filterFields(items[_i2], fields);
            }
          }
        } // return the results


        if (returnType == "Object") {
          var result = {};

          for (var _i3 = 0, _len3 = items.length; _i3 < _len3; _i3++) {
            var resultant = items[_i3]; // @TODO: Shoudn't this be this._fieldId?
            // result[resultant.id] = resultant

            var _id2 = resultant[this._idProp];
            result[_id2] = resultant;
          }

          return result;
        } else {
          if (id != null) {
            var _item;

            // a single item
            return (_item = item) !== null && _item !== void 0 ? _item : null;
          } else {
            // just return our array
            return items;
          }
        }
      }
      /** @inheritDoc */

    }, {
      key: "getIds",
      value: function getIds(options) {
        var data = this._data;

        var filter$1 = options && filter(options);

        var order = options && options.order;

        var itemIds = _toConsumableArray(keys(data).call(data));

        var ids = [];

        if (filter$1) {
          // get filtered items
          if (order) {
            // create ordered list
            var items = [];

            for (var i = 0, len = itemIds.length; i < len; i++) {
              var id = itemIds[i];

              var item = this._data.get(id);

              if (item != null && filter$1(item)) {
                items.push(item);
              }
            }

            this._sort(items, order);

            for (var _i4 = 0, _len4 = items.length; _i4 < _len4; _i4++) {
              ids.push(items[_i4][this._idProp]);
            }
          } else {
            // create unordered list
            for (var _i5 = 0, _len5 = itemIds.length; _i5 < _len5; _i5++) {
              var _id3 = itemIds[_i5];

              var _item2 = this._data.get(_id3);

              if (_item2 != null && filter$1(_item2)) {
                ids.push(_item2[this._idProp]);
              }
            }
          }
        } else {
          // get all items
          if (order) {
            // create an ordered list
            var _items = [];

            for (var _i6 = 0, _len6 = itemIds.length; _i6 < _len6; _i6++) {
              var _id4 = itemIds[_i6];

              _items.push(data.get(_id4));
            }

            this._sort(_items, order);

            for (var _i7 = 0, _len7 = _items.length; _i7 < _len7; _i7++) {
              ids.push(_items[_i7][this._idProp]);
            }
          } else {
            // create unordered list
            for (var _i8 = 0, _len8 = itemIds.length; _i8 < _len8; _i8++) {
              var _id5 = itemIds[_i8];

              var _item3 = data.get(_id5);

              if (_item3 != null) {
                ids.push(_item3[this._idProp]);
              }
            }
          }
        }

        return ids;
      }
      /** @inheritDoc */

    }, {
      key: "getDataSet",
      value: function getDataSet() {
        return this;
      }
      /** @inheritDoc */

    }, {
      key: "forEach",
      value: function forEach(callback, options) {
        var filter$1 = options && filter(options);

        var data = this._data;

        var itemIds = _toConsumableArray(keys(data).call(data));

        if (options && options.order) {
          // execute forEach on ordered list
          var items = this.get(options);

          for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            var id = item[this._idProp];
            callback(item, id);
          }
        } else {
          // unordered
          for (var _i9 = 0, _len9 = itemIds.length; _i9 < _len9; _i9++) {
            var _id6 = itemIds[_i9];

            var _item4 = this._data.get(_id6);

            if (_item4 != null && (!filter$1 || filter$1(_item4))) {
              callback(_item4, _id6);
            }
          }
        }
      }
      /** @inheritDoc */

    }, {
      key: "map",
      value: function map(callback, options) {
        var filter$1 = options && filter(options);

        var mappedItems = [];
        var data = this._data;

        var itemIds = _toConsumableArray(keys(data).call(data)); // convert and filter items


        for (var i = 0, len = itemIds.length; i < len; i++) {
          var id = itemIds[i];

          var item = this._data.get(id);

          if (item != null && (!filter$1 || filter$1(item))) {
            mappedItems.push(callback(item, id));
          }
        } // order items


        if (options && options.order) {
          this._sort(mappedItems, options.order);
        }

        return mappedItems;
      }
      /**
       * Filter the fields of an item.
       *
       * @param item - The item whose fields should be filtered.
       * @param fields - The names of the fields that will be kept.
       * @typeParam K - Field name type.
       * @returns The item without any additional fields.
       */

    }, {
      key: "_filterFields",
      value: function _filterFields(item, fields) {
        var _context3;

        if (!item) {
          // item is null
          return item;
        }

        return reduce(_context3 = isArray$1(fields) ? // Use the supplied array
        fields : // Use the keys of the supplied object
        keys$4(fields)).call(_context3, function (filteredItem, field) {
          filteredItem[field] = item[field];
          return filteredItem;
        }, {});
      }
      /**
       * Sort the provided array with items.
       *
       * @param items - Items to be sorted in place.
       * @param order - A field name or custom sort function.
       * @typeParam T - The type of the items in the items array.
       */

    }, {
      key: "_sort",
      value: function _sort(items, order) {
        if (typeof order === "string") {
          // order by provided field name
          var name = order; // field name

          sort(items).call(items, function (a, b) {
            // @TODO: How to treat missing properties?
            var av = a[name];
            var bv = b[name];
            return av > bv ? 1 : av < bv ? -1 : 0;
          });
        } else if (typeof order === "function") {
          // order by sort function
          sort(items).call(items, order);
        } else {
          // TODO: extend order by an Object {field:string, direction:string}
          //       where direction can be 'asc' or 'desc'
          throw new TypeError("Order must be a function or a string");
        }
      }
      /**
       * Remove an item or multiple items by “reference” (only the id is used) or by id.
       *
       * The method ignores removal of non-existing items, and returns an array containing the ids of the items which are actually removed from the DataSet.
       *
       * After the items are removed, the DataSet will trigger an event `remove` for the removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
       *
       * ## Example
       * ```javascript
       * // create a DataSet
       * const data = new vis.DataSet([
       *   { id: 1, text: 'item 1' },
       *   { id: 2, text: 'item 2' },
       *   { id: 3, text: 'item 3' }
       * ])
       *
       * // remove items
       * const ids = data.remove([2, { id: 3 }, 4])
       *
       * console.log(ids) // [2, 3]
       * ```
       *
       * @param id - One or more items or ids of items to be removed.
       * @param senderId - Sender id.
       * @returns The ids of the removed items.
       */

    }, {
      key: "remove",
      value: function remove(id, senderId) {
        var removedIds = [];
        var removedItems = []; // force everything to be an array for simplicity

        var ids = isArray$1(id) ? id : [id];

        for (var i = 0, len = ids.length; i < len; i++) {
          var item = this._remove(ids[i]);

          if (item) {
            var itemId = item[this._idProp];

            if (itemId != null) {
              removedIds.push(itemId);
              removedItems.push(item);
            }
          }
        }

        if (removedIds.length) {
          this._trigger("remove", {
            items: removedIds,
            oldData: removedItems
          }, senderId);
        }

        return removedIds;
      }
      /**
       * Remove an item by its id or reference.
       *
       * @param id - Id of an item or the item itself.
       * @returns The removed item if removed, null otherwise.
       */

    }, {
      key: "_remove",
      value: function _remove(id) {
        // @TODO: It origianlly returned the item although the docs say id.
        // The code expects the item, so probably an error in the docs.
        var ident; // confirm the id to use based on the args type

        if (isId(id)) {
          ident = id;
        } else if (id && _typeof(id) === "object") {
          ident = id[this._idProp]; // look for the identifier field using ._idProp
        } // do the removing if the item is found


        if (ident != null && this._data.has(ident)) {
          var item = this._data.get(ident) || null;

          this._data.delete(ident);

          --this.length;
          return item;
        }

        return null;
      }
      /**
       * Clear the entire data set.
       *
       * After the items are removed, the [[DataSet]] will trigger an event `remove` for all removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
       *
       * @param senderId - Sender id.
       * @returns removedIds - The ids of all removed items.
       */

    }, {
      key: "clear",
      value: function clear(senderId) {
        var _context4;

        var ids = _toConsumableArray(keys(_context4 = this._data).call(_context4));

        var items = [];

        for (var i = 0, len = ids.length; i < len; i++) {
          items.push(this._data.get(ids[i]));
        }

        this._data.clear();

        this.length = 0;

        this._trigger("remove", {
          items: ids,
          oldData: items
        }, senderId);

        return ids;
      }
      /**
       * Find the item with maximum value of a specified field.
       *
       * @param field - Name of the property that should be searched for max value.
       * @returns Item containing max value, or null if no items.
       */

    }, {
      key: "max",
      value: function max(field) {
        var _context5;

        var max = null;
        var maxField = null;

        var _iterator = _createForOfIteratorHelper$1(values(_context5 = this._data).call(_context5)),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var item = _step.value;
            var itemField = item[field];

            if (typeof itemField === "number" && (maxField == null || itemField > maxField)) {
              max = item;
              maxField = itemField;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return max || null;
      }
      /**
       * Find the item with minimum value of a specified field.
       *
       * @param field - Name of the property that should be searched for min value.
       * @returns Item containing min value, or null if no items.
       */

    }, {
      key: "min",
      value: function min(field) {
        var _context6;

        var min = null;
        var minField = null;

        var _iterator2 = _createForOfIteratorHelper$1(values(_context6 = this._data).call(_context6)),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var item = _step2.value;
            var itemField = item[field];

            if (typeof itemField === "number" && (minField == null || itemField < minField)) {
              min = item;
              minField = itemField;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return min || null;
      }
      /**
       * Find all distinct values of a specified field
       *
       * @param prop - The property name whose distinct values should be returned.
       * @returns Unordered array containing all distinct values. Items without specified property are ignored.
       */

    }, {
      key: "distinct",
      value: function distinct(prop) {
        var data = this._data;

        var itemIds = _toConsumableArray(keys(data).call(data));

        var values = [];
        var count = 0;

        for (var i = 0, len = itemIds.length; i < len; i++) {
          var id = itemIds[i];
          var item = data.get(id);
          var value = item[prop];
          var exists = false;

          for (var j = 0; j < count; j++) {
            if (values[j] == value) {
              exists = true;
              break;
            }
          }

          if (!exists && value !== undefined) {
            values[count] = value;
            count++;
          }
        }

        return values;
      }
      /**
       * Add a single item. Will fail when an item with the same id already exists.
       *
       * @param item - A new item to be added.
       * @returns Added item's id. An id is generated when it is not present in the item.
       */

    }, {
      key: "_addItem",
      value: function _addItem(item) {
        var fullItem = ensureFullItem(item, this._idProp);
        var id = fullItem[this._idProp]; // check whether this id is already taken

        if (this._data.has(id)) {
          // item already exists
          throw new Error("Cannot add item: item with id " + id + " already exists");
        }

        this._data.set(id, fullItem);

        ++this.length;
        return id;
      }
      /**
       * Update a single item: merge with existing item.
       * Will fail when the item has no id, or when there does not exist an item with the same id.
       *
       * @param update - The new item
       * @returns The id of the updated item.
       */

    }, {
      key: "_updateItem",
      value: function _updateItem(update) {
        var id = update[this._idProp];

        if (id == null) {
          throw new Error("Cannot update item: item has no id (item: " + stringify$1(update) + ")");
        }

        var item = this._data.get(id);

        if (!item) {
          // item doesn't exist
          throw new Error("Cannot update item: no item with id " + id + " found");
        }

        this._data.set(id, _objectSpread(_objectSpread({}, item), update));

        return id;
      }
      /** @inheritDoc */

    }, {
      key: "stream",
      value: function stream(ids) {
        if (ids) {
          var data = this._data;
          return new DataStream(_defineProperty({}, iterator, /*#__PURE__*/regenerator.mark(function _callee() {
            var _iterator3, _step3, id, item;

            return regenerator.wrap(function _callee$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _iterator3 = _createForOfIteratorHelper$1(ids);
                    _context7.prev = 1;

                    _iterator3.s();

                  case 3:
                    if ((_step3 = _iterator3.n()).done) {
                      _context7.next = 11;
                      break;
                    }

                    id = _step3.value;
                    item = data.get(id);

                    if (!(item != null)) {
                      _context7.next = 9;
                      break;
                    }

                    _context7.next = 9;
                    return [id, item];

                  case 9:
                    _context7.next = 3;
                    break;

                  case 11:
                    _context7.next = 16;
                    break;

                  case 13:
                    _context7.prev = 13;
                    _context7.t0 = _context7["catch"](1);

                    _iterator3.e(_context7.t0);

                  case 16:
                    _context7.prev = 16;

                    _iterator3.f();

                    return _context7.finish(16);

                  case 19:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee, null, [[1, 13, 16, 19]]);
          })));
        } else {
          var _context8;

          return new DataStream(_defineProperty({}, iterator, bind$6(_context8 = entries(this._data)).call(_context8, this._data)));
        }
      }
    }]);

    return DataSet;
  }(DataSetPart);

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$1(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { var _context5; if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = slice(_context5 = Object.prototype.toString.call(o)).call(_context5, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * DataView
   *
   * A DataView offers a filtered and/or formatted view on a DataSet. One can subscribe to changes in a DataView, and easily get filtered or formatted data without having to specify filters and field types all the time.
   *
   * ## Example
   * ```javascript
   * // create a DataSet
   * var data = new vis.DataSet();
   * data.add([
   *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},
   *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},
   *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},
   *   {id: 4, text: 'item 4'}
   * ]);
   *
   * // create a DataView
   * // the view will only contain items having a property group with value 1,
   * // and will only output fields id, text, and date.
   * var view = new vis.DataView(data, {
   *   filter: function (item) {
   *     return (item.group == 1);
   *   },
   *   fields: ['id', 'text', 'date']
   * });
   *
   * // subscribe to any change in the DataView
   * view.on('*', function (event, properties, senderId) {
   *   console.log('event', event, properties);
   * });
   *
   * // update an item in the data set
   * data.update({id: 2, group: 1});
   *
   * // get all ids in the view
   * var ids = view.getIds();
   * console.log('ids', ids); // will output [1, 2]
   *
   * // get all items in the view
   * var items = view.get();
   * ```
   *
   * @typeParam Item - Item type that may or may not have an id.
   * @typeParam IdProp - Name of the property that contains the id.
   */

  var DataView = /*#__PURE__*/function (_DataSetPart) {
    _inherits(DataView, _DataSetPart);

    var _super = _createSuper(DataView);

    /**
     * Create a DataView.
     *
     * @param data - The instance containing data (directly or indirectly).
     * @param options - Options to configure this data view.
     */
    function DataView(data, options) {
      var _context;

      var _this;

      _classCallCheck(this, DataView);

      _this = _super.call(this);

      _defineProperty(_assertThisInitialized(_this), "length", 0);

      _defineProperty(_assertThisInitialized(_this), "_listener", void 0);

      _defineProperty(_assertThisInitialized(_this), "_data", void 0);

      _defineProperty(_assertThisInitialized(_this), "_ids", new set());

      _defineProperty(_assertThisInitialized(_this), "_options", void 0);

      _this._options = options || {};
      _this._listener = bind$6(_context = _this._onEvent).call(_context, _assertThisInitialized(_this));

      _this.setData(data);

      return _this;
    } // TODO: implement a function .config() to dynamically update things like configured filter
    // and trigger changes accordingly

    /**
     * Set a data source for the view.
     *
     * @param data - The instance containing data (directly or indirectly).
     * @remarks
     * Note that when the data view is bound to a data set it won't be garbage
     * collected unless the data set is too. Use `dataView.setData(null)` or
     * `dataView.dispose()` to enable garbage collection before you lose the last
     * reference.
     */


    _createClass(DataView, [{
      key: "idProp",
      get:
      /** @inheritDoc */

      /** @inheritDoc */
      function get() {
        return this.getDataSet().idProp;
      }
    }, {
      key: "setData",
      value: function setData(data) {
        if (this._data) {
          // unsubscribe from current dataset
          if (this._data.off) {
            this._data.off("*", this._listener);
          } // trigger a remove of all items in memory


          var ids = this._data.getIds({
            filter: filter(this._options)
          });

          var items = this._data.get(ids);

          this._ids.clear();

          this.length = 0;

          this._trigger("remove", {
            items: ids,
            oldData: items
          });
        }

        if (data != null) {
          this._data = data; // trigger an add of all added items

          var _ids = this._data.getIds({
            filter: filter(this._options)
          });

          for (var i = 0, len = _ids.length; i < len; i++) {
            var id = _ids[i];

            this._ids.add(id);
          }

          this.length = _ids.length;

          this._trigger("add", {
            items: _ids
          });
        } else {
          this._data = new DataSet();
        } // subscribe to new dataset


        if (this._data.on) {
          this._data.on("*", this._listener);
        }
      }
      /**
       * Refresh the DataView.
       * Useful when the DataView has a filter function containing a variable parameter.
       */

    }, {
      key: "refresh",
      value: function refresh() {
        var ids = this._data.getIds({
          filter: filter(this._options)
        });

        var oldIds = _toConsumableArray(this._ids);

        var newIds = {};
        var addedIds = [];
        var removedIds = [];
        var removedItems = []; // check for additions

        for (var i = 0, len = ids.length; i < len; i++) {
          var id = ids[i];
          newIds[id] = true;

          if (!this._ids.has(id)) {
            addedIds.push(id);

            this._ids.add(id);
          }
        } // check for removals


        for (var _i = 0, _len = oldIds.length; _i < _len; _i++) {
          var _id = oldIds[_i];

          var item = this._data.get(_id);

          if (item == null) {
            // @TODO: Investigate.
            // Doesn't happen during tests or examples.
            // Is it really impossible or could it eventually happen?
            // How to handle it if it does? The types guarantee non-nullable items.
            console.error("If you see this, report it please.");
          } else if (!newIds[_id]) {
            removedIds.push(_id);
            removedItems.push(item);

            this._ids.delete(_id);
          }
        }

        this.length += addedIds.length - removedIds.length; // trigger events

        if (addedIds.length) {
          this._trigger("add", {
            items: addedIds
          });
        }

        if (removedIds.length) {
          this._trigger("remove", {
            items: removedIds,
            oldData: removedItems
          });
        }
      }
      /** @inheritDoc */

    }, {
      key: "get",
      value: function get(first, second) {
        if (this._data == null) {
          return null;
        } // parse the arguments


        var ids = null;
        var options;

        if (isId(first) || isArray$1(first)) {
          ids = first;
          options = second;
        } else {
          options = first;
        } // extend the options with the default options and provided options


        var viewOptions = assign$2({}, this._options, options); // create a combined filter method when needed


        var thisFilter = filter(this._options);

        var optionsFilter = options && filter(options);

        if (thisFilter && optionsFilter) {
          viewOptions.filter = function (item) {
            return thisFilter(item) && optionsFilter(item);
          };
        }

        if (ids == null) {
          return this._data.get(viewOptions);
        } else {
          return this._data.get(ids, viewOptions);
        }
      }
      /** @inheritDoc */

    }, {
      key: "getIds",
      value: function getIds(options) {
        if (this._data.length) {
          var defaultFilter = filter(this._options);

          var optionsFilter = options != null ? filter(options) : null;
          var filter$1;

          if (optionsFilter) {
            if (defaultFilter) {
              filter$1 = function filter(item) {
                return defaultFilter(item) && optionsFilter(item);
              };
            } else {
              filter$1 = optionsFilter;
            }
          } else {
            filter$1 = defaultFilter;
          }

          return this._data.getIds({
            filter: filter$1,
            order: options && options.order
          });
        } else {
          return [];
        }
      }
      /** @inheritDoc */

    }, {
      key: "forEach",
      value: function forEach(callback, options) {
        if (this._data) {
          var _context2;

          var defaultFilter = filter(this._options);

          var optionsFilter = options && filter(options);

          var filter$1;

          if (optionsFilter) {
            if (defaultFilter) {
              filter$1 = function filter(item) {
                return defaultFilter(item) && optionsFilter(item);
              };
            } else {
              filter$1 = optionsFilter;
            }
          } else {
            filter$1 = defaultFilter;
          }

          forEach$1(_context2 = this._data).call(_context2, callback, {
            filter: filter$1,
            order: options && options.order
          });
        }
      }
      /** @inheritDoc */

    }, {
      key: "map",
      value: function map(callback, options) {
        if (this._data) {
          var _context3;

          var defaultFilter = filter(this._options);

          var optionsFilter = options && filter(options);

          var filter$1;

          if (optionsFilter) {
            if (defaultFilter) {
              filter$1 = function filter(item) {
                return defaultFilter(item) && optionsFilter(item);
              };
            } else {
              filter$1 = optionsFilter;
            }
          } else {
            filter$1 = defaultFilter;
          }

          return map$3(_context3 = this._data).call(_context3, callback, {
            filter: filter$1,
            order: options && options.order
          });
        } else {
          return [];
        }
      }
      /** @inheritDoc */

    }, {
      key: "getDataSet",
      value: function getDataSet() {
        return this._data.getDataSet();
      }
      /** @inheritDoc */

    }, {
      key: "stream",
      value: function stream(ids) {
        var _context4;

        return this._data.stream(ids || _defineProperty({}, iterator, bind$6(_context4 = keys(this._ids)).call(_context4, this._ids)));
      }
      /**
       * Render the instance unusable prior to garbage collection.
       *
       * @remarks
       * The intention of this method is to help discover scenarios where the data
       * view is being used when the programmer thinks it has been garbage collected
       * already. It's stricter version of `dataView.setData(null)`.
       */

    }, {
      key: "dispose",
      value: function dispose() {
        var _this$_data;

        if ((_this$_data = this._data) !== null && _this$_data !== void 0 && _this$_data.off) {
          this._data.off("*", this._listener);
        }

        var message = "This data view has already been disposed of.";
        var replacement = {
          get: function get() {
            throw new Error(message);
          },
          set: function set() {
            throw new Error(message);
          },
          configurable: false
        };

        var _iterator = _createForOfIteratorHelper(ownKeys$1(DataView.prototype)),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var key = _step.value;

            defineProperty$4(this, key, replacement);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      /**
       * Event listener. Will propagate all events from the connected data set to the subscribers of the DataView, but will filter the items and only trigger when there are changes in the filtered data set.
       *
       * @param event - The name of the event.
       * @param params - Parameters of the event.
       * @param senderId - Id supplied by the sender.
       */

    }, {
      key: "_onEvent",
      value: function _onEvent(event, params, senderId) {
        if (!params || !params.items || !this._data) {
          return;
        }

        var ids = params.items;
        var addedIds = [];
        var updatedIds = [];
        var removedIds = [];
        var oldItems = [];
        var updatedItems = [];
        var removedItems = [];

        switch (event) {
          case "add":
            // filter the ids of the added items
            for (var i = 0, len = ids.length; i < len; i++) {
              var id = ids[i];
              var item = this.get(id);

              if (item) {
                this._ids.add(id);

                addedIds.push(id);
              }
            }

            break;

          case "update":
            // determine the event from the views viewpoint: an updated
            // item can be added, updated, or removed from this view.
            for (var _i2 = 0, _len2 = ids.length; _i2 < _len2; _i2++) {
              var _id2 = ids[_i2];

              var _item = this.get(_id2);

              if (_item) {
                if (this._ids.has(_id2)) {
                  updatedIds.push(_id2);
                  updatedItems.push(params.data[_i2]);
                  oldItems.push(params.oldData[_i2]);
                } else {
                  this._ids.add(_id2);

                  addedIds.push(_id2);
                }
              } else {
                if (this._ids.has(_id2)) {
                  this._ids.delete(_id2);

                  removedIds.push(_id2);
                  removedItems.push(params.oldData[_i2]);
                }
              }
            }

            break;

          case "remove":
            // filter the ids of the removed items
            for (var _i3 = 0, _len3 = ids.length; _i3 < _len3; _i3++) {
              var _id3 = ids[_i3];

              if (this._ids.has(_id3)) {
                this._ids.delete(_id3);

                removedIds.push(_id3);
                removedItems.push(params.oldData[_i3]);
              }
            }

            break;
        }

        this.length += addedIds.length - removedIds.length;

        if (addedIds.length) {
          this._trigger("add", {
            items: addedIds
          }, senderId);
        }

        if (updatedIds.length) {
          this._trigger("update", {
            items: updatedIds,
            oldData: oldItems,
            data: updatedItems
          }, senderId);
        }

        if (removedIds.length) {
          this._trigger("remove", {
            items: removedIds,
            oldData: removedItems
          }, senderId);
        }
      }
    }]);

    return DataView;
  }(DataSetPart);

  /**
   * Check that given value is compatible with Vis Data Set interface.
   *
   * @param idProp - The expected property to contain item id.
   * @param v - The value to be tested.
   * @returns True if all expected values and methods match, false otherwise.
   */
  function isDataSetLike(idProp, v) {
    return _typeof(v) === "object" && v !== null && idProp === v.idProp && typeof v.add === "function" && typeof v.clear === "function" && typeof v.distinct === "function" && typeof forEach$1(v) === "function" && typeof v.get === "function" && typeof v.getDataSet === "function" && typeof v.getIds === "function" && typeof v.length === "number" && typeof map$3(v) === "function" && typeof v.max === "function" && typeof v.min === "function" && typeof v.off === "function" && typeof v.on === "function" && typeof v.remove === "function" && typeof v.setOptions === "function" && typeof v.stream === "function" && typeof v.update === "function" && typeof v.updateOnly === "function";
  }

  /**
   * Check that given value is compatible with Vis Data View interface.
   *
   * @param idProp - The expected property to contain item id.
   * @param v - The value to be tested.
   * @returns True if all expected values and methods match, false otherwise.
   */

  function isDataViewLike(idProp, v) {
    return _typeof(v) === "object" && v !== null && idProp === v.idProp && typeof forEach$1(v) === "function" && typeof v.get === "function" && typeof v.getDataSet === "function" && typeof v.getIds === "function" && typeof v.length === "number" && typeof map$3(v) === "function" && typeof v.off === "function" && typeof v.on === "function" && typeof v.stream === "function" && isDataSetLike(idProp, v.getDataSet());
  }

  exports.DELETE = DELETE;
  exports.DataSet = DataSet;
  exports.DataStream = DataStream;
  exports.DataView = DataView;
  exports.Queue = Queue;
  exports.createNewDataPipeFrom = createNewDataPipeFrom;
  exports.isDataSetLike = isDataSetLike;
  exports.isDataViewLike = isDataViewLike;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=vis-data.js.map


/***/ }),

/***/ "./node_modules/vis-data/peer/umd/vis-data.min.js":
/*!********************************************************!*\
  !*** ./node_modules/vis-data/peer/umd/vis-data.min.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/**
 * vis-data
 * http://visjs.org/
 *
 * Manage unstructured data using DataSet. Add, update, and remove data, and listen for changes in the data.
 *
 * @version 7.1.4
 * @date    2022-03-15T15:23:59.245Z
 *
 * @copyright (c) 2011-2017 Almende B.V, http://almende.com
 * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs
 *
 * @license
 * vis.js is dual licensed under both
 *
 *   1. The Apache 2.0 License
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   and
 *
 *   2. The MIT License
 *      http://opensource.org/licenses/MIT
 *
 * vis.js may be distributed under either license.
 */
!function(t,e){ true?e(exports):0}(this,(function(t){function e(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var r="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self?self:{},n={exports:{}},i=function(t){return t&&t.Math==Math&&t},o=i("object"==typeof globalThis&&globalThis)||i("object"==typeof window&&window)||i("object"==typeof self&&self)||i("object"==typeof r&&r)||function(){return this}()||Function("return this")(),a=function(t){try{return!!t()}catch(t){return!0}},u=!a((function(){var t=function(){}.bind();return"function"!=typeof t||t.hasOwnProperty("prototype")})),s=u,c=Function.prototype,f=c.apply,l=c.call,h="object"==typeof Reflect&&Reflect.apply||(s?l.bind(f):function(){return l.apply(f,arguments)}),p=u,v=Function.prototype,d=v.bind,y=v.call,g=p&&d.bind(y,y),m=p?function(t){return t&&g(t)}:function(t){return t&&function(){return y.apply(t,arguments)}},b=function(t){return"function"==typeof t},_={},w=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),O=u,E=Function.prototype.call,T=O?E.bind(E):function(){return E.apply(E,arguments)},x={},k={}.propertyIsEnumerable,S=Object.getOwnPropertyDescriptor,A=S&&!k.call({1:2},1);x.f=A?function(t){var e=S(this,t);return!!e&&e.enumerable}:k;var j,P,I=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}},D=m,L=D({}.toString),C=D("".slice),R=function(t){return C(L(t),8,-1)},M=m,F=a,N=R,z=o.Object,q=M("".split),Y=F((function(){return!z("z").propertyIsEnumerable(0)}))?function(t){return"String"==N(t)?q(t,""):z(t)}:z,G=o.TypeError,X=function(t){if(null==t)throw G("Can't call method on "+t);return t},U=Y,W=X,V=function(t){return U(W(t))},H=b,$=function(t){return"object"==typeof t?null!==t:H(t)},B={},J=B,K=o,Q=b,Z=function(t){return Q(t)?t:void 0},tt=function(t,e){return arguments.length<2?Z(J[t])||Z(K[t]):J[t]&&J[t][e]||K[t]&&K[t][e]},et=m({}.isPrototypeOf),rt=tt("navigator","userAgent")||"",nt=o,it=rt,ot=nt.process,at=nt.Deno,ut=ot&&ot.versions||at&&at.version,st=ut&&ut.v8;st&&(P=(j=st.split("."))[0]>0&&j[0]<4?1:+(j[0]+j[1])),!P&&it&&(!(j=it.match(/Edge\/(\d+)/))||j[1]>=74)&&(j=it.match(/Chrome\/(\d+)/))&&(P=+j[1]);var ct=P,ft=ct,lt=a,ht=!!Object.getOwnPropertySymbols&&!lt((function(){var t=Symbol();return!String(t)||!(Object(t)instanceof Symbol)||!Symbol.sham&&ft&&ft<41})),pt=ht&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,vt=tt,dt=b,yt=et,gt=pt,mt=o.Object,bt=gt?function(t){return"symbol"==typeof t}:function(t){var e=vt("Symbol");return dt(e)&&yt(e.prototype,mt(t))},_t=o.String,wt=function(t){try{return _t(t)}catch(t){return"Object"}},Ot=b,Et=wt,Tt=o.TypeError,xt=function(t){if(Ot(t))return t;throw Tt(Et(t)+" is not a function")},kt=xt,St=function(t,e){var r=t[e];return null==r?void 0:kt(r)},At=T,jt=b,Pt=$,It=o.TypeError,Dt={exports:{}},Lt=o,Ct=Object.defineProperty,Rt=function(t,e){try{Ct(Lt,t,{value:e,configurable:!0,writable:!0})}catch(r){Lt[t]=e}return e},Mt="__core-js_shared__",Ft=o[Mt]||Rt(Mt,{}),Nt=Ft;(Dt.exports=function(t,e){return Nt[t]||(Nt[t]=void 0!==e?e:{})})("versions",[]).push({version:"3.21.1",mode:"pure",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE",source:"https://github.com/zloirock/core-js"});var zt=X,qt=o.Object,Yt=function(t){return qt(zt(t))},Gt=Yt,Xt=m({}.hasOwnProperty),Ut=Object.hasOwn||function(t,e){return Xt(Gt(t),e)},Wt=m,Vt=0,Ht=Math.random(),$t=Wt(1..toString),Bt=function(t){return"Symbol("+(void 0===t?"":t)+")_"+$t(++Vt+Ht,36)},Jt=o,Kt=Dt.exports,Qt=Ut,Zt=Bt,te=ht,ee=pt,re=Kt("wks"),ne=Jt.Symbol,ie=ne&&ne.for,oe=ee?ne:ne&&ne.withoutSetter||Zt,ae=function(t){if(!Qt(re,t)||!te&&"string"!=typeof re[t]){var e="Symbol."+t;te&&Qt(ne,t)?re[t]=ne[t]:re[t]=ee&&ie?ie(e):oe(e)}return re[t]},ue=T,se=$,ce=bt,fe=St,le=function(t,e){var r,n;if("string"===e&&jt(r=t.toString)&&!Pt(n=At(r,t)))return n;if(jt(r=t.valueOf)&&!Pt(n=At(r,t)))return n;if("string"!==e&&jt(r=t.toString)&&!Pt(n=At(r,t)))return n;throw It("Can't convert object to primitive value")},he=ae,pe=o.TypeError,ve=he("toPrimitive"),de=function(t,e){if(!se(t)||ce(t))return t;var r,n=fe(t,ve);if(n){if(void 0===e&&(e="default"),r=ue(n,t,e),!se(r)||ce(r))return r;throw pe("Can't convert object to primitive value")}return void 0===e&&(e="number"),le(t,e)},ye=bt,ge=function(t){var e=de(t,"string");return ye(e)?e:e+""},me=$,be=o.document,_e=me(be)&&me(be.createElement),we=function(t){return _e?be.createElement(t):{}},Oe=we,Ee=!w&&!a((function(){return 7!=Object.defineProperty(Oe("div"),"a",{get:function(){return 7}}).a})),Te=w,xe=T,ke=x,Se=I,Ae=V,je=ge,Pe=Ut,Ie=Ee,De=Object.getOwnPropertyDescriptor;_.f=Te?De:function(t,e){if(t=Ae(t),e=je(e),Ie)try{return De(t,e)}catch(t){}if(Pe(t,e))return Se(!xe(ke.f,t,e),t[e])};var Le=a,Ce=b,Re=/#|\.prototype\./,Me=function(t,e){var r=Ne[Fe(t)];return r==qe||r!=ze&&(Ce(e)?Le(e):!!e)},Fe=Me.normalize=function(t){return String(t).replace(Re,".").toLowerCase()},Ne=Me.data={},ze=Me.NATIVE="N",qe=Me.POLYFILL="P",Ye=Me,Ge=xt,Xe=u,Ue=m(m.bind),We=function(t,e){return Ge(t),void 0===e?t:Xe?Ue(t,e):function(){return t.apply(e,arguments)}},Ve={},He=w&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype})),$e=o,Be=$,Je=$e.String,Ke=$e.TypeError,Qe=function(t){if(Be(t))return t;throw Ke(Je(t)+" is not an object")},Ze=w,tr=Ee,er=He,rr=Qe,nr=ge,ir=o.TypeError,or=Object.defineProperty,ar=Object.getOwnPropertyDescriptor,ur="enumerable",sr="configurable",cr="writable";Ve.f=Ze?er?function(t,e,r){if(rr(t),e=nr(e),rr(r),"function"==typeof t&&"prototype"===e&&"value"in r&&cr in r&&!r.writable){var n=ar(t,e);n&&n.writable&&(t[e]=r.value,r={configurable:sr in r?r.configurable:n.configurable,enumerable:ur in r?r.enumerable:n.enumerable,writable:!1})}return or(t,e,r)}:or:function(t,e,r){if(rr(t),e=nr(e),rr(r),tr)try{return or(t,e,r)}catch(t){}if("get"in r||"set"in r)throw ir("Accessors not supported");return"value"in r&&(t[e]=r.value),t};var fr=Ve,lr=I,hr=w?function(t,e,r){return fr.f(t,e,lr(1,r))}:function(t,e,r){return t[e]=r,t},pr=o,vr=h,dr=m,yr=b,gr=_.f,mr=Ye,br=B,_r=We,wr=hr,Or=Ut,Er=function(t){var e=function(r,n,i){if(this instanceof e){switch(arguments.length){case 0:return new t;case 1:return new t(r);case 2:return new t(r,n)}return new t(r,n,i)}return vr(t,this,arguments)};return e.prototype=t.prototype,e},Tr=function(t,e){var r,n,i,o,a,u,s,c,f=t.target,l=t.global,h=t.stat,p=t.proto,v=l?pr:h?pr[f]:(pr[f]||{}).prototype,d=l?br:br[f]||wr(br,f,{})[f],y=d.prototype;for(i in e)r=!mr(l?i:f+(h?".":"#")+i,t.forced)&&v&&Or(v,i),a=d[i],r&&(u=t.noTargetGet?(c=gr(v,i))&&c.value:v[i]),o=r&&u?u:e[i],r&&typeof a==typeof o||(s=t.bind&&r?_r(o,pr):t.wrap&&r?Er(o):p&&yr(o)?dr(o):o,(t.sham||o&&o.sham||a&&a.sham)&&wr(s,"sham",!0),wr(d,i,s),p&&(Or(br,n=f+"Prototype")||wr(br,n,{}),wr(br[n],i,o),t.real&&y&&!y[i]&&wr(y,i,o)))},xr=Tr,kr=w,Sr=Ve.f;xr({target:"Object",stat:!0,forced:Object.defineProperty!==Sr,sham:!kr},{defineProperty:Sr});var Ar=B.Object,jr=n.exports=function(t,e,r){return Ar.defineProperty(t,e,r)};Ar.defineProperty.sham&&(jr.sham=!0);var Pr=n.exports,Ir=Pr;function Dr(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Ir(t,n.key,n)}}function Lr(t,e,r){return e&&Dr(t.prototype,e),r&&Dr(t,r),Ir(t,"prototype",{writable:!1}),t}function Cr(t,e,r){return e in t?Ir(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var Rr=m([].slice),Mr=m,Fr=xt,Nr=$,zr=Ut,qr=Rr,Yr=u,Gr=o.Function,Xr=Mr([].concat),Ur=Mr([].join),Wr={},Vr=function(t,e,r){if(!zr(Wr,e)){for(var n=[],i=0;i<e;i++)n[i]="a["+i+"]";Wr[e]=Gr("C,a","return new C("+Ur(n,",")+")")}return Wr[e](t,r)},Hr=Yr?Gr.bind:function(t){var e=Fr(this),r=e.prototype,n=qr(arguments,1),i=function(){var r=Xr(n,qr(arguments));return this instanceof i?Vr(e,r.length,r):e.apply(t,r)};return Nr(r)&&(i.prototype=r),i},$r=Hr;Tr({target:"Function",proto:!0,forced:Function.bind!==$r},{bind:$r});var Br=B,Jr=function(t){return Br[t+"Prototype"]},Kr=Jr("Function").bind,Qr=et,Zr=Kr,tn=Function.prototype,en=function(t){var e=t.bind;return t===tn||Qr(tn,t)&&e===tn.bind?Zr:e},rn=Math.ceil,nn=Math.floor,on=function(t){var e=+t;return e!=e||0===e?0:(e>0?nn:rn)(e)},an=on,un=Math.min,sn=function(t){return t>0?un(an(t),9007199254740991):0},cn=function(t){return sn(t.length)},fn=xt,ln=Yt,hn=Y,pn=cn,vn=o.TypeError,dn=function(t){return function(e,r,n,i){fn(r);var o=ln(e),a=hn(o),u=pn(o),s=t?u-1:0,c=t?-1:1;if(n<2)for(;;){if(s in a){i=a[s],s+=c;break}if(s+=c,t?s<0:u<=s)throw vn("Reduce of empty array with no initial value")}for(;t?s>=0:u>s;s+=c)s in a&&(i=r(i,a[s],s,o));return i}},yn={left:dn(!1),right:dn(!0)},gn=a,mn=function(t,e){var r=[][t];return!!r&&gn((function(){r.call(null,e||function(){return 1},1)}))},bn="process"==R(o.process),_n=yn.left,wn=ct,On=bn;Tr({target:"Array",proto:!0,forced:!mn("reduce")||!On&&wn>79&&wn<83},{reduce:function(t){var e=arguments.length;return _n(this,t,e,e>1?arguments[1]:void 0)}});var En=Jr("Array").reduce,Tn=et,xn=En,kn=Array.prototype,Sn=function(t){var e=t.reduce;return t===kn||Tn(kn,t)&&e===kn.reduce?xn:e},An=R,jn=Array.isArray||function(t){return"Array"==An(t)},Pn={};Pn[ae("toStringTag")]="z";var In="[object z]"===String(Pn),Dn=o,Ln=In,Cn=b,Rn=R,Mn=ae("toStringTag"),Fn=Dn.Object,Nn="Arguments"==Rn(function(){return arguments}()),zn=Ln?Rn:function(t){var e,r,n;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=function(t,e){try{return t[e]}catch(t){}}(e=Fn(t),Mn))?r:Nn?Rn(e):"Object"==(n=Rn(e))&&Cn(e.callee)?"Arguments":n},qn=b,Yn=Ft,Gn=m(Function.toString);qn(Yn.inspectSource)||(Yn.inspectSource=function(t){return Gn(t)});var Xn=Yn.inspectSource,Un=m,Wn=a,Vn=b,Hn=zn,$n=Xn,Bn=function(){},Jn=[],Kn=tt("Reflect","construct"),Qn=/^\s*(?:class|function)\b/,Zn=Un(Qn.exec),ti=!Qn.exec(Bn),ei=function(t){if(!Vn(t))return!1;try{return Kn(Bn,Jn,t),!0}catch(t){return!1}},ri=function(t){if(!Vn(t))return!1;switch(Hn(t)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return ti||!!Zn(Qn,$n(t))}catch(t){return!0}};ri.sham=!0;var ni=!Kn||Wn((function(){var t;return ei(ei.call)||!ei(Object)||!ei((function(){t=!0}))||t}))?ri:ei,ii=o,oi=jn,ai=ni,ui=$,si=ae("species"),ci=ii.Array,fi=function(t){var e;return oi(t)&&(e=t.constructor,(ai(e)&&(e===ci||oi(e.prototype))||ui(e)&&null===(e=e[si]))&&(e=void 0)),void 0===e?ci:e},li=function(t,e){return new(fi(t))(0===e?0:e)},hi=We,pi=Y,vi=Yt,di=cn,yi=li,gi=m([].push),mi=function(t){var e=1==t,r=2==t,n=3==t,i=4==t,o=6==t,a=7==t,u=5==t||o;return function(s,c,f,l){for(var h,p,v=vi(s),d=pi(v),y=hi(c,f),g=di(d),m=0,b=l||yi,_=e?b(s,g):r||a?b(s,0):void 0;g>m;m++)if((u||m in d)&&(p=y(h=d[m],m,v),t))if(e)_[m]=p;else if(p)switch(t){case 3:return!0;case 5:return h;case 6:return m;case 2:gi(_,h)}else switch(t){case 4:return!1;case 7:gi(_,h)}return o?-1:n||i?i:_}},bi={forEach:mi(0),map:mi(1),filter:mi(2),some:mi(3),every:mi(4),find:mi(5),findIndex:mi(6),filterReject:mi(7)},_i=a,wi=ct,Oi=ae("species"),Ei=function(t){return wi>=51||!_i((function(){var e=[];return(e.constructor={})[Oi]=function(){return{foo:1}},1!==e[t](Boolean).foo}))},Ti=bi.filter;Tr({target:"Array",proto:!0,forced:!Ei("filter")},{filter:function(t){return Ti(this,t,arguments.length>1?arguments[1]:void 0)}});var xi=Jr("Array").filter,ki=et,Si=xi,Ai=Array.prototype,ji=function(t){var e=t.filter;return t===Ai||ki(Ai,t)&&e===Ai.filter?Si:e},Pi=bi.map;Tr({target:"Array",proto:!0,forced:!Ei("map")},{map:function(t){return Pi(this,t,arguments.length>1?arguments[1]:void 0)}});var Ii=Jr("Array").map,Di=et,Li=Ii,Ci=Array.prototype,Ri=function(t){var e=t.map;return t===Ci||Di(Ci,t)&&e===Ci.map?Li:e},Mi=jn,Fi=cn,Ni=We,zi=o.TypeError,qi=function(t,e,r,n,i,o,a,u){for(var s,c,f=i,l=0,h=!!a&&Ni(a,u);l<n;){if(l in r){if(s=h?h(r[l],l,e):r[l],o>0&&Mi(s))c=Fi(s),f=qi(t,e,s,c,f,o-1)-1;else{if(f>=9007199254740991)throw zi("Exceed the acceptable array length");t[f]=s}f++}l++}return f},Yi=qi,Gi=xt,Xi=Yt,Ui=cn,Wi=li;Tr({target:"Array",proto:!0},{flatMap:function(t){var e,r=Xi(this),n=Ui(r);return Gi(t),(e=Wi(r,0)).length=Yi(e,r,r,n,0,1,t,arguments.length>1?arguments[1]:void 0),e}});var Vi=Jr("Array").flatMap,Hi=et,$i=Vi,Bi=Array.prototype,Ji=function(t){var e=t.flatMap;return t===Bi||Hi(Bi,t)&&e===Bi.flatMap?$i:e};var Ki,Qi,Zi,to=function(){function t(r,n,i){var o,a,u;e(this,t),Cr(this,"_source",void 0),Cr(this,"_transformers",void 0),Cr(this,"_target",void 0),Cr(this,"_listeners",{add:en(o=this._add).call(o,this),remove:en(a=this._remove).call(a,this),update:en(u=this._update).call(u,this)}),this._source=r,this._transformers=n,this._target=i}return Lr(t,[{key:"all",value:function(){return this._target.update(this._transformItems(this._source.get())),this}},{key:"start",value:function(){return this._source.on("add",this._listeners.add),this._source.on("remove",this._listeners.remove),this._source.on("update",this._listeners.update),this}},{key:"stop",value:function(){return this._source.off("add",this._listeners.add),this._source.off("remove",this._listeners.remove),this._source.off("update",this._listeners.update),this}},{key:"_transformItems",value:function(t){var e;return Sn(e=this._transformers).call(e,(function(t,e){return e(t)}),t)}},{key:"_add",value:function(t,e){null!=e&&this._target.add(this._transformItems(this._source.get(e.items)))}},{key:"_update",value:function(t,e){null!=e&&this._target.update(this._transformItems(this._source.get(e.items)))}},{key:"_remove",value:function(t,e){null!=e&&this._target.remove(this._transformItems(e.oldData))}}]),t}(),eo=function(){function t(r){e(this,t),Cr(this,"_source",void 0),Cr(this,"_transformers",[]),this._source=r}return Lr(t,[{key:"filter",value:function(t){return this._transformers.push((function(e){return ji(e).call(e,t)})),this}},{key:"map",value:function(t){return this._transformers.push((function(e){return Ri(e).call(e,t)})),this}},{key:"flatMap",value:function(t){return this._transformers.push((function(e){return Ji(e).call(e,t)})),this}},{key:"to",value:function(t){return new to(this._source,this._transformers,t)}}]),t}(),ro=zn,no=o.String,io=function(t){if("Symbol"===ro(t))throw TypeError("Cannot convert a Symbol value to a string");return no(t)},oo=m,ao=on,uo=io,so=X,co=oo("".charAt),fo=oo("".charCodeAt),lo=oo("".slice),ho=function(t){return function(e,r){var n,i,o=uo(so(e)),a=ao(r),u=o.length;return a<0||a>=u?t?"":void 0:(n=fo(o,a))<55296||n>56319||a+1===u||(i=fo(o,a+1))<56320||i>57343?t?co(o,a):n:t?lo(o,a,a+2):i-56320+(n-55296<<10)+65536}},po={codeAt:ho(!1),charAt:ho(!0)},vo=b,yo=Xn,go=o.WeakMap,mo=vo(go)&&/native code/.test(yo(go)),bo=Dt.exports,_o=Bt,wo=bo("keys"),Oo=function(t){return wo[t]||(wo[t]=_o(t))},Eo={},To=mo,xo=o,ko=m,So=$,Ao=hr,jo=Ut,Po=Ft,Io=Oo,Do=Eo,Lo="Object already initialized",Co=xo.TypeError,Ro=xo.WeakMap;if(To||Po.state){var Mo=Po.state||(Po.state=new Ro),Fo=ko(Mo.get),No=ko(Mo.has),zo=ko(Mo.set);Ki=function(t,e){if(No(Mo,t))throw new Co(Lo);return e.facade=t,zo(Mo,t,e),e},Qi=function(t){return Fo(Mo,t)||{}},Zi=function(t){return No(Mo,t)}}else{var qo=Io("state");Do[qo]=!0,Ki=function(t,e){if(jo(t,qo))throw new Co(Lo);return e.facade=t,Ao(t,qo,e),e},Qi=function(t){return jo(t,qo)?t[qo]:{}},Zi=function(t){return jo(t,qo)}}var Yo={set:Ki,get:Qi,has:Zi,enforce:function(t){return Zi(t)?Qi(t):Ki(t,{})},getterFor:function(t){return function(e){var r;if(!So(e)||(r=Qi(e)).type!==t)throw Co("Incompatible receiver, "+t+" required");return r}}},Go=w,Xo=Ut,Uo=Function.prototype,Wo=Go&&Object.getOwnPropertyDescriptor,Vo=Xo(Uo,"name"),Ho={EXISTS:Vo,PROPER:Vo&&"something"===function(){}.name,CONFIGURABLE:Vo&&(!Go||Go&&Wo(Uo,"name").configurable)},$o={},Bo=on,Jo=Math.max,Ko=Math.min,Qo=function(t,e){var r=Bo(t);return r<0?Jo(r+e,0):Ko(r,e)},Zo=V,ta=Qo,ea=cn,ra=function(t){return function(e,r,n){var i,o=Zo(e),a=ea(o),u=ta(n,a);if(t&&r!=r){for(;a>u;)if((i=o[u++])!=i)return!0}else for(;a>u;u++)if((t||u in o)&&o[u]===r)return t||u||0;return!t&&-1}},na={includes:ra(!0),indexOf:ra(!1)},ia=Ut,oa=V,aa=na.indexOf,ua=Eo,sa=m([].push),ca=function(t,e){var r,n=oa(t),i=0,o=[];for(r in n)!ia(ua,r)&&ia(n,r)&&sa(o,r);for(;e.length>i;)ia(n,r=e[i++])&&(~aa(o,r)||sa(o,r));return o},fa=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],la=ca,ha=fa,pa=Object.keys||function(t){return la(t,ha)},va=w,da=He,ya=Ve,ga=Qe,ma=V,ba=pa;$o.f=va&&!da?Object.defineProperties:function(t,e){ga(t);for(var r,n=ma(e),i=ba(e),o=i.length,a=0;o>a;)ya.f(t,r=i[a++],n[r]);return t};var _a,wa=tt("document","documentElement"),Oa=Qe,Ea=$o,Ta=fa,xa=Eo,ka=wa,Sa=we,Aa=Oo("IE_PROTO"),ja=function(){},Pa=function(t){return"<script>"+t+"</"+"script>"},Ia=function(t){t.write(Pa("")),t.close();var e=t.parentWindow.Object;return t=null,e},Da=function(){try{_a=new ActiveXObject("htmlfile")}catch(t){}var t,e;Da="undefined"!=typeof document?document.domain&&_a?Ia(_a):((e=Sa("iframe")).style.display="none",ka.appendChild(e),e.src=String("javascript:"),(t=e.contentWindow.document).open(),t.write(Pa("document.F=Object")),t.close(),t.F):Ia(_a);for(var r=Ta.length;r--;)delete Da.prototype[Ta[r]];return Da()};xa[Aa]=!0;var La,Ca,Ra,Ma=Object.create||function(t,e){var r;return null!==t?(ja.prototype=Oa(t),r=new ja,ja.prototype=null,r[Aa]=t):r=Da(),void 0===e?r:Ea.f(r,e)},Fa=!a((function(){function t(){}return t.prototype.constructor=null,Object.getPrototypeOf(new t)!==t.prototype})),Na=o,za=Ut,qa=b,Ya=Yt,Ga=Fa,Xa=Oo("IE_PROTO"),Ua=Na.Object,Wa=Ua.prototype,Va=Ga?Ua.getPrototypeOf:function(t){var e=Ya(t);if(za(e,Xa))return e[Xa];var r=e.constructor;return qa(r)&&e instanceof r?r.prototype:e instanceof Ua?Wa:null},Ha=hr,$a=function(t,e,r,n){n&&n.enumerable?t[e]=r:Ha(t,e,r)},Ba=a,Ja=b,Ka=Ma,Qa=Va,Za=$a,tu=ae("iterator"),eu=!1;[].keys&&("next"in(Ra=[].keys())?(Ca=Qa(Qa(Ra)))!==Object.prototype&&(La=Ca):eu=!0);var ru=null==La||Ba((function(){var t={};return La[tu].call(t)!==t}));Ja((La=ru?{}:Ka(La))[tu])||Za(La,tu,(function(){return this}));var nu={IteratorPrototype:La,BUGGY_SAFARI_ITERATORS:eu},iu=zn,ou=In?{}.toString:function(){return"[object "+iu(this)+"]"},au=In,uu=Ve.f,su=hr,cu=Ut,fu=ou,lu=ae("toStringTag"),hu=function(t,e,r,n){if(t){var i=r?t:t.prototype;cu(i,lu)||uu(i,lu,{configurable:!0,value:e}),n&&!au&&su(i,"toString",fu)}},pu={},vu=nu.IteratorPrototype,du=Ma,yu=I,gu=hu,mu=pu,bu=function(){return this},_u=o,wu=b,Ou=_u.String,Eu=_u.TypeError,Tu=m,xu=Qe,ku=function(t){if("object"==typeof t||wu(t))return t;throw Eu("Can't set "+Ou(t)+" as a prototype")},Su=Object.setPrototypeOf||("__proto__"in{}?function(){var t,e=!1,r={};try{(t=Tu(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(r,[]),e=r instanceof Array}catch(t){}return function(r,n){return xu(r),ku(n),e?t(r,n):r.__proto__=n,r}}():void 0),Au=Tr,ju=T,Pu=function(t,e,r,n){var i=e+" Iterator";return t.prototype=du(vu,{next:yu(+!n,r)}),gu(t,i,!1,!0),mu[i]=bu,t},Iu=Va,Du=hu,Lu=$a,Cu=pu,Ru=Ho.PROPER,Mu=nu.BUGGY_SAFARI_ITERATORS,Fu=ae("iterator"),Nu="keys",zu="values",qu="entries",Yu=function(){return this},Gu=function(t,e,r,n,i,o,a){Pu(r,e,n);var u,s,c,f=function(t){if(t===i&&d)return d;if(!Mu&&t in p)return p[t];switch(t){case Nu:case zu:case qu:return function(){return new r(this,t)}}return function(){return new r(this)}},l=e+" Iterator",h=!1,p=t.prototype,v=p[Fu]||p["@@iterator"]||i&&p[i],d=!Mu&&v||f(i),y="Array"==e&&p.entries||v;if(y&&(u=Iu(y.call(new t)))!==Object.prototype&&u.next&&(Du(u,l,!0,!0),Cu[l]=Yu),Ru&&i==zu&&v&&v.name!==zu&&(h=!0,d=function(){return ju(v,this)}),i)if(s={values:f(zu),keys:o?d:f(Nu),entries:f(qu)},a)for(c in s)(Mu||h||!(c in p))&&Lu(p,c,s[c]);else Au({target:e,proto:!0,forced:Mu||h},s);return a&&p[Fu]!==d&&Lu(p,Fu,d,{name:i}),Cu[e]=d,s},Xu=po.charAt,Uu=io,Wu=Yo,Vu=Gu,Hu="String Iterator",$u=Wu.set,Bu=Wu.getterFor(Hu);Vu(String,"String",(function(t){$u(this,{type:Hu,string:Uu(t),index:0})}),(function(){var t,e=Bu(this),r=e.string,n=e.index;return n>=r.length?{value:void 0,done:!0}:(t=Xu(r,n),e.index+=t.length,{value:t,done:!1})}));var Ju=T,Ku=Qe,Qu=St,Zu=function(t,e,r){var n,i;Ku(t);try{if(!(n=Qu(t,"return"))){if("throw"===e)throw r;return r}n=Ju(n,t)}catch(t){i=!0,n=t}if("throw"===e)throw r;if(i)throw n;return Ku(n),r},ts=Qe,es=Zu,rs=pu,ns=ae("iterator"),is=Array.prototype,os=function(t){return void 0!==t&&(rs.Array===t||is[ns]===t)},as=ge,us=Ve,ss=I,cs=function(t,e,r){var n=as(e);n in t?us.f(t,n,ss(0,r)):t[n]=r},fs=zn,ls=St,hs=pu,ps=ae("iterator"),vs=function(t){if(null!=t)return ls(t,ps)||ls(t,"@@iterator")||hs[fs(t)]},ds=T,ys=xt,gs=Qe,ms=wt,bs=vs,_s=o.TypeError,ws=function(t,e){var r=arguments.length<2?bs(t):e;if(ys(r))return gs(ds(r,t));throw _s(ms(t)+" is not iterable")},Os=We,Es=T,Ts=Yt,xs=function(t,e,r,n){try{return n?e(ts(r)[0],r[1]):e(r)}catch(e){es(t,"throw",e)}},ks=os,Ss=ni,As=cn,js=cs,Ps=ws,Is=vs,Ds=o.Array,Ls=ae("iterator"),Cs=!1;try{var Rs=0,Ms={next:function(){return{done:!!Rs++}},return:function(){Cs=!0}};Ms[Ls]=function(){return this},Array.from(Ms,(function(){throw 2}))}catch(t){}var Fs=function(t){var e=Ts(t),r=Ss(this),n=arguments.length,i=n>1?arguments[1]:void 0,o=void 0!==i;o&&(i=Os(i,n>2?arguments[2]:void 0));var a,u,s,c,f,l,h=Is(e),p=0;if(!h||this==Ds&&ks(h))for(a=As(e),u=r?new this(a):Ds(a);a>p;p++)l=o?i(e[p],p):e[p],js(u,p,l);else for(f=(c=Ps(e,h)).next,u=r?new this:[];!(s=Es(f,c)).done;p++)l=o?xs(c,i,[s.value,p],!0):s.value,js(u,p,l);return u.length=p,u},Ns=function(t,e){if(!e&&!Cs)return!1;var r=!1;try{var n={};n[Ls]=function(){return{next:function(){return{done:r=!0}}}},t(n)}catch(t){}return r};Tr({target:"Array",stat:!0,forced:!Ns((function(t){Array.from(t)}))},{from:Fs});var zs=B.Array.from,qs=zs,Ys=V,Gs=pu,Xs=Yo;Ve.f;var Us=Gu,Ws="Array Iterator",Vs=Xs.set,Hs=Xs.getterFor(Ws);Us(Array,"Array",(function(t,e){Vs(this,{type:Ws,target:Ys(t),index:0,kind:e})}),(function(){var t=Hs(this),e=t.target,r=t.kind,n=t.index++;return!e||n>=e.length?(t.target=void 0,{value:void 0,done:!0}):"keys"==r?{value:n,done:!1}:"values"==r?{value:e[n],done:!1}:{value:[n,e[n]],done:!1}}),"values"),Gs.Arguments=Gs.Array;var $s=vs,Bs={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0},Js=o,Ks=zn,Qs=hr,Zs=pu,tc=ae("toStringTag");for(var ec in Bs){var rc=Js[ec],nc=rc&&rc.prototype;nc&&Ks(nc)!==tc&&Qs(nc,tc,ec),Zs[ec]=Zs.Array}var ic=$s,oc={},ac=ca,uc=fa.concat("length","prototype");oc.f=Object.getOwnPropertyNames||function(t){return ac(t,uc)};var sc={},cc=Qo,fc=cn,lc=cs,hc=o.Array,pc=Math.max,vc=function(t,e,r){for(var n=fc(t),i=cc(e,n),o=cc(void 0===r?n:r,n),a=hc(pc(o-i,0)),u=0;i<o;i++,u++)lc(a,u,t[i]);return a.length=u,a},dc=R,yc=V,gc=oc.f,mc=vc,bc="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];sc.f=function(t){return bc&&"Window"==dc(t)?function(t){try{return gc(t)}catch(t){return mc(bc)}}(t):gc(yc(t))};var _c={};_c.f=Object.getOwnPropertySymbols;var wc={},Oc=ae;wc.f=Oc;var Ec=B,Tc=Ut,xc=wc,kc=Ve.f,Sc=function(t){var e=Ec.Symbol||(Ec.Symbol={});Tc(e,t)||kc(e,t,{value:xc.f(t)})},Ac=Tr,jc=o,Pc=tt,Ic=h,Dc=T,Lc=m,Cc=w,Rc=ht,Mc=a,Fc=Ut,Nc=jn,zc=b,qc=$,Yc=et,Gc=bt,Xc=Qe,Uc=Yt,Wc=V,Vc=ge,Hc=io,$c=I,Bc=Ma,Jc=pa,Kc=oc,Qc=sc,Zc=_c,tf=_,ef=Ve,rf=$o,nf=x,of=Rr,af=$a,uf=Dt.exports,sf=Eo,cf=Bt,ff=ae,lf=wc,hf=Sc,pf=hu,vf=Yo,df=bi.forEach,yf=Oo("hidden"),gf="Symbol",mf=ff("toPrimitive"),bf=vf.set,_f=vf.getterFor(gf),wf=Object.prototype,Of=jc.Symbol,Ef=Of&&Of.prototype,Tf=jc.TypeError,xf=jc.QObject,kf=Pc("JSON","stringify"),Sf=tf.f,Af=ef.f,jf=Qc.f,Pf=nf.f,If=Lc([].push),Df=uf("symbols"),Lf=uf("op-symbols"),Cf=uf("string-to-symbol-registry"),Rf=uf("symbol-to-string-registry"),Mf=uf("wks"),Ff=!xf||!xf.prototype||!xf.prototype.findChild,Nf=Cc&&Mc((function(){return 7!=Bc(Af({},"a",{get:function(){return Af(this,"a",{value:7}).a}})).a}))?function(t,e,r){var n=Sf(wf,e);n&&delete wf[e],Af(t,e,r),n&&t!==wf&&Af(wf,e,n)}:Af,zf=function(t,e){var r=Df[t]=Bc(Ef);return bf(r,{type:gf,tag:t,description:e}),Cc||(r.description=e),r},qf=function(t,e,r){t===wf&&qf(Lf,e,r),Xc(t);var n=Vc(e);return Xc(r),Fc(Df,n)?(r.enumerable?(Fc(t,yf)&&t[yf][n]&&(t[yf][n]=!1),r=Bc(r,{enumerable:$c(0,!1)})):(Fc(t,yf)||Af(t,yf,$c(1,{})),t[yf][n]=!0),Nf(t,n,r)):Af(t,n,r)},Yf=function(t,e){Xc(t);var r=Wc(e),n=Jc(r).concat(Wf(r));return df(n,(function(e){Cc&&!Dc(Gf,r,e)||qf(t,e,r[e])})),t},Gf=function(t){var e=Vc(t),r=Dc(Pf,this,e);return!(this===wf&&Fc(Df,e)&&!Fc(Lf,e))&&(!(r||!Fc(this,e)||!Fc(Df,e)||Fc(this,yf)&&this[yf][e])||r)},Xf=function(t,e){var r=Wc(t),n=Vc(e);if(r!==wf||!Fc(Df,n)||Fc(Lf,n)){var i=Sf(r,n);return!i||!Fc(Df,n)||Fc(r,yf)&&r[yf][n]||(i.enumerable=!0),i}},Uf=function(t){var e=jf(Wc(t)),r=[];return df(e,(function(t){Fc(Df,t)||Fc(sf,t)||If(r,t)})),r},Wf=function(t){var e=t===wf,r=jf(e?Lf:Wc(t)),n=[];return df(r,(function(t){!Fc(Df,t)||e&&!Fc(wf,t)||If(n,Df[t])})),n};if(Rc||(Of=function(){if(Yc(Ef,this))throw Tf("Symbol is not a constructor");var t=arguments.length&&void 0!==arguments[0]?Hc(arguments[0]):void 0,e=cf(t),r=function(t){this===wf&&Dc(r,Lf,t),Fc(this,yf)&&Fc(this[yf],e)&&(this[yf][e]=!1),Nf(this,e,$c(1,t))};return Cc&&Ff&&Nf(wf,e,{configurable:!0,set:r}),zf(e,t)},af(Ef=Of.prototype,"toString",(function(){return _f(this).tag})),af(Of,"withoutSetter",(function(t){return zf(cf(t),t)})),nf.f=Gf,ef.f=qf,rf.f=Yf,tf.f=Xf,Kc.f=Qc.f=Uf,Zc.f=Wf,lf.f=function(t){return zf(ff(t),t)},Cc&&Af(Ef,"description",{configurable:!0,get:function(){return _f(this).description}})),Ac({global:!0,wrap:!0,forced:!Rc,sham:!Rc},{Symbol:Of}),df(Jc(Mf),(function(t){hf(t)})),Ac({target:gf,stat:!0,forced:!Rc},{for:function(t){var e=Hc(t);if(Fc(Cf,e))return Cf[e];var r=Of(e);return Cf[e]=r,Rf[r]=e,r},keyFor:function(t){if(!Gc(t))throw Tf(t+" is not a symbol");if(Fc(Rf,t))return Rf[t]},useSetter:function(){Ff=!0},useSimple:function(){Ff=!1}}),Ac({target:"Object",stat:!0,forced:!Rc,sham:!Cc},{create:function(t,e){return void 0===e?Bc(t):Yf(Bc(t),e)},defineProperty:qf,defineProperties:Yf,getOwnPropertyDescriptor:Xf}),Ac({target:"Object",stat:!0,forced:!Rc},{getOwnPropertyNames:Uf,getOwnPropertySymbols:Wf}),Ac({target:"Object",stat:!0,forced:Mc((function(){Zc.f(1)}))},{getOwnPropertySymbols:function(t){return Zc.f(Uc(t))}}),kf){var Vf=!Rc||Mc((function(){var t=Of();return"[null]"!=kf([t])||"{}"!=kf({a:t})||"{}"!=kf(Object(t))}));Ac({target:"JSON",stat:!0,forced:Vf},{stringify:function(t,e,r){var n=of(arguments),i=e;if((qc(e)||void 0!==t)&&!Gc(t))return Nc(e)||(e=function(t,e){if(zc(i)&&(e=Dc(i,this,t,e)),!Gc(e))return e}),n[1]=e,Ic(kf,null,n)}})}if(!Ef[mf]){var Hf=Ef.valueOf;af(Ef,mf,(function(t){return Dc(Hf,this)}))}pf(Of,gf),sf[yf]=!0;var $f=B.Object.getOwnPropertySymbols,Bf={exports:{}},Jf=Tr,Kf=a,Qf=V,Zf=_.f,tl=w,el=Kf((function(){Zf(1)}));Jf({target:"Object",stat:!0,forced:!tl||el,sham:!tl},{getOwnPropertyDescriptor:function(t,e){return Zf(Qf(t),e)}});var rl=B.Object,nl=Bf.exports=function(t,e){return rl.getOwnPropertyDescriptor(t,e)};rl.getOwnPropertyDescriptor.sham&&(nl.sham=!0);var il=Bf.exports,ol=tt,al=oc,ul=_c,sl=Qe,cl=m([].concat),fl=ol("Reflect","ownKeys")||function(t){var e=al.f(sl(t)),r=ul.f;return r?cl(e,r(t)):e},ll=fl,hl=V,pl=_,vl=cs;Tr({target:"Object",stat:!0,sham:!w},{getOwnPropertyDescriptors:function(t){for(var e,r,n=hl(t),i=pl.f,o=ll(n),a={},u=0;o.length>u;)void 0!==(r=i(n,e=o[u++]))&&vl(a,e,r);return a}});var dl=B.Object.getOwnPropertyDescriptors,yl={exports:{}},gl=Tr,ml=w,bl=$o.f;gl({target:"Object",stat:!0,forced:Object.defineProperties!==bl,sham:!ml},{defineProperties:bl});var _l=B.Object,wl=yl.exports=function(t,e){return _l.defineProperties(t,e)};_l.defineProperties.sham&&(wl.sham=!0);var Ol=yl.exports,El=Pr;Tr({target:"Array",stat:!0},{isArray:jn});var Tl=B.Array.isArray,xl=Tl;var kl=Tr,Sl=o,Al=a,jl=jn,Pl=$,Il=Yt,Dl=cn,Ll=cs,Cl=li,Rl=Ei,Ml=ct,Fl=ae("isConcatSpreadable"),Nl=9007199254740991,zl="Maximum allowed index exceeded",ql=Sl.TypeError,Yl=Ml>=51||!Al((function(){var t=[];return t[Fl]=!1,t.concat()[0]!==t})),Gl=Rl("concat"),Xl=function(t){if(!Pl(t))return!1;var e=t[Fl];return void 0!==e?!!e:jl(t)};kl({target:"Array",proto:!0,forced:!Yl||!Gl},{concat:function(t){var e,r,n,i,o,a=Il(this),u=Cl(a,0),s=0;for(e=-1,n=arguments.length;e<n;e++)if(Xl(o=-1===e?a:arguments[e])){if(s+(i=Dl(o))>Nl)throw ql(zl);for(r=0;r<i;r++,s++)r in o&&Ll(u,s,o[r])}else{if(s>=Nl)throw ql(zl);Ll(u,s++,o)}return u.length=s,u}}),Sc("asyncIterator"),Sc("hasInstance"),Sc("isConcatSpreadable"),Sc("iterator"),Sc("match"),Sc("matchAll"),Sc("replace"),Sc("search"),Sc("species"),Sc("split"),Sc("toPrimitive"),Sc("toStringTag"),Sc("unscopables"),hu(o.JSON,"JSON",!0);var Ul=B.Symbol,Wl=Ul;Sc("asyncDispose"),Sc("dispose"),Sc("matcher"),Sc("metadata"),Sc("observable"),Sc("patternMatch"),Sc("replaceAll");var Vl=Wl;var Hl=Tr,$l=o,Bl=jn,Jl=ni,Kl=$,Ql=Qo,Zl=cn,th=V,eh=cs,rh=ae,nh=Rr,ih=Ei("slice"),oh=rh("species"),ah=$l.Array,uh=Math.max;Hl({target:"Array",proto:!0,forced:!ih},{slice:function(t,e){var r,n,i,o=th(this),a=Zl(o),u=Ql(t,a),s=Ql(void 0===e?a:e,a);if(Bl(o)&&(r=o.constructor,(Jl(r)&&(r===ah||Bl(r.prototype))||Kl(r)&&null===(r=r[oh]))&&(r=void 0),r===ah||void 0===r))return nh(o,u,s);for(n=new(void 0===r?ah:r)(uh(s-u,0)),i=0;u<s;u++,i++)u in o&&eh(n,i,o[u]);return n.length=i,n}});var sh=Jr("Array").slice,ch=et,fh=sh,lh=Array.prototype,hh=function(t){var e=t.slice;return t===lh||ch(lh,t)&&e===lh.slice?fh:e},ph=hh,vh=zs;function dh(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function yh(t,e){var r;if(t){if("string"==typeof t)return dh(t,e);var n=ph(r=Object.prototype.toString.call(t)).call(r,8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?vh(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?dh(t,e):void 0}}function gh(t,e){return function(t){if(xl(t))return t}(t)||function(t,e){var r=null==t?null:void 0!==Vl&&ic(t)||t["@@iterator"];if(null!=r){var n,i,o=[],a=!0,u=!1;try{for(r=r.call(t);!(a=(n=r.next()).done)&&(o.push(n.value),!e||o.length!==e);a=!0);}catch(t){u=!0,i=t}finally{try{a||null==r.return||r.return()}finally{if(u)throw i}}return o}}(t,e)||yh(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var mh=wc.f("iterator"),bh=mh;function _h(t){return _h="function"==typeof Vl&&"symbol"==typeof bh?function(t){return typeof t}:function(t){return t&&"function"==typeof Vl&&t.constructor===Vl&&t!==Vl.prototype?"symbol":typeof t},_h(t)}function wh(t){return function(t){if(xl(t))return dh(t)}(t)||function(t){if(void 0!==Vl&&null!=ic(t)||null!=t["@@iterator"])return vh(t)}(t)||yh(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var Oh=Ul,Eh=Jr("Array").concat,Th=et,xh=Eh,kh=Array.prototype,Sh=function(t){var e=t.concat;return t===kh||Th(kh,t)&&e===kh.concat?xh:e},Ah=hh;Tr({target:"Reflect",stat:!0},{ownKeys:fl});var jh=B.Reflect.ownKeys,Ph=Tl,Ih=Yt,Dh=pa;Tr({target:"Object",stat:!0,forced:a((function(){Dh(1)}))},{keys:function(t){return Dh(Ih(t))}});var Lh=B.Object.keys,Ch=Tr,Rh=m,Mh=o.Date,Fh=Rh(Mh.prototype.getTime);Ch({target:"Date",stat:!0},{now:function(){return Fh(new Mh)}}),B.Date.now;var Nh=bi.forEach,zh=mn("forEach")?[].forEach:function(t){return Nh(this,t,arguments.length>1?arguments[1]:void 0)};Tr({target:"Array",proto:!0,forced:[].forEach!=zh},{forEach:zh});var qh=Jr("Array").forEach,Yh=zn,Gh=Ut,Xh=et,Uh=qh,Wh=Array.prototype,Vh={DOMTokenList:!0,NodeList:!0},Hh=function(t){var e=t.forEach;return t===Wh||Xh(Wh,t)&&e===Wh.forEach||Gh(Vh,Yh(t))?Uh:e},$h=Tr,Bh=jn,Jh=m([].reverse),Kh=[1,2];$h({target:"Array",proto:!0,forced:String(Kh)===String(Kh.reverse())},{reverse:function(){return Bh(this)&&(this.length=this.length),Jh(this)}});var Qh=Jr("Array").reverse,Zh=et,tp=Qh,ep=Array.prototype,rp=function(t){var e=t.reverse;return t===ep||Zh(ep,t)&&e===ep.reverse?tp:e},np=Tr,ip=o,op=Qo,ap=on,up=cn,sp=Yt,cp=li,fp=cs,lp=Ei("splice"),hp=ip.TypeError,pp=Math.max,vp=Math.min,dp=9007199254740991,yp="Maximum allowed length exceeded";np({target:"Array",proto:!0,forced:!lp},{splice:function(t,e){var r,n,i,o,a,u,s=sp(this),c=up(s),f=op(t,c),l=arguments.length;if(0===l?r=n=0:1===l?(r=0,n=c-f):(r=l-2,n=vp(pp(ap(e),0),c-f)),c+r-n>dp)throw hp(yp);for(i=cp(s,n),o=0;o<n;o++)(a=f+o)in s&&fp(i,o,s[a]);if(i.length=n,r<n){for(o=f;o<c-n;o++)u=o+r,(a=o+n)in s?s[u]=s[a]:delete s[u];for(o=c;o>c-n+r;o--)delete s[o-1]}else if(r>n)for(o=c-n;o>f;o--)u=o+r-1,(a=o+n-1)in s?s[u]=s[a]:delete s[u];for(o=0;o<r;o++)s[o+f]=arguments[o+2];return s.length=c-n+r,i}});var gp=Jr("Array").splice,mp=et,bp=gp,_p=Array.prototype,wp=function(t){var e=t.splice;return t===_p||mp(_p,t)&&e===_p.splice?bp:e},Op=w,Ep=m,Tp=T,xp=a,kp=pa,Sp=_c,Ap=x,jp=Yt,Pp=Y,Ip=Object.assign,Dp=Object.defineProperty,Lp=Ep([].concat),Cp=!Ip||xp((function(){if(Op&&1!==Ip({b:1},Ip(Dp({},"a",{enumerable:!0,get:function(){Dp(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var t={},e={},r=Symbol(),n="abcdefghijklmnopqrst";return t[r]=7,n.split("").forEach((function(t){e[t]=t})),7!=Ip({},t)[r]||kp(Ip({},e)).join("")!=n}))?function(t,e){for(var r=jp(t),n=arguments.length,i=1,o=Sp.f,a=Ap.f;n>i;)for(var u,s=Pp(arguments[i++]),c=o?Lp(kp(s),o(s)):kp(s),f=c.length,l=0;f>l;)u=c[l++],Op&&!Tp(a,s,u)||(r[u]=s[u]);return r}:Ip,Rp=Cp;Tr({target:"Object",stat:!0,forced:Object.assign!==Rp},{assign:Rp});var Mp=B.Object.assign,Fp=na.includes;Tr({target:"Array",proto:!0},{includes:function(t){return Fp(this,t,arguments.length>1?arguments[1]:void 0)}}),Jr("Array").includes;var Np=$,zp=R,qp=ae("match"),Yp=function(t){var e;return Np(t)&&(void 0!==(e=t[qp])?!!e:"RegExp"==zp(t))},Gp=o.TypeError,Xp=ae("match"),Up=Tr,Wp=function(t){if(Yp(t))throw Gp("The method doesn't accept regular expressions");return t},Vp=X,Hp=io,$p=function(t){var e=/./;try{"/./"[t](e)}catch(r){try{return e[Xp]=!1,"/./"[t](e)}catch(t){}}return!1},Bp=m("".indexOf);Up({target:"String",proto:!0,forced:!$p("includes")},{includes:function(t){return!!~Bp(Hp(Vp(this)),Hp(Wp(t)),arguments.length>1?arguments[1]:void 0)}}),Jr("String").includes;var Jp=Yt,Kp=Va,Qp=Fa;Tr({target:"Object",stat:!0,forced:a((function(){Kp(1)})),sham:!Qp},{getPrototypeOf:function(t){return Kp(Jp(t))}});var Zp=B.Object.getPrototypeOf,tv=w,ev=m,rv=pa,nv=V,iv=ev(x.f),ov=ev([].push),av=function(t){return function(e){for(var r,n=nv(e),i=rv(n),o=i.length,a=0,u=[];o>a;)r=i[a++],tv&&!iv(n,r)||ov(u,t?[r,n[r]]:n[r]);return u}},uv={entries:av(!0),values:av(!1)}.values;Tr({target:"Object",stat:!0},{values:function(t){return uv(t)}}),B.Object.values;var sv="\t\n\v\f\r                　\u2028\u2029\ufeff",cv=X,fv=io,lv=m("".replace),hv="[\t\n\v\f\r                　\u2028\u2029\ufeff]",pv=RegExp("^"+hv+hv+"*"),vv=RegExp(hv+hv+"*$"),dv=function(t){return function(e){var r=fv(cv(e));return 1&t&&(r=lv(r,pv,"")),2&t&&(r=lv(r,vv,"")),r}},yv={start:dv(1),end:dv(2),trim:dv(3)},gv=o,mv=a,bv=m,_v=io,wv=yv.trim,Ov=sv,Ev=gv.parseInt,Tv=gv.Symbol,xv=Tv&&Tv.iterator,kv=/^[+-]?0x/i,Sv=bv(kv.exec),Av=8!==Ev(Ov+"08")||22!==Ev(Ov+"0x16")||xv&&!mv((function(){Ev(Object(xv))}))?function(t,e){var r=wv(_v(t));return Ev(r,e>>>0||(Sv(kv,r)?16:10))}:Ev;Tr({global:!0,forced:parseInt!=Av},{parseInt:Av});var jv=Tr,Pv=na.indexOf,Iv=mn,Dv=m([].indexOf),Lv=!!Dv&&1/Dv([1],1,-0)<0,Cv=Iv("indexOf");jv({target:"Array",proto:!0,forced:Lv||!Cv},{indexOf:function(t){var e=arguments.length>1?arguments[1]:void 0;return Lv?Dv(this,t,e)||0:Pv(this,t,e)}}),Jr("Array").indexOf;var Rv=Ho.PROPER,Mv=a,Fv=sv,Nv=yv.trim;Tr({target:"String",proto:!0,forced:function(t){return Mv((function(){return!!Fv[t]()||"​᠎"!=="​᠎"[t]()||Rv&&Fv[t].name!==t}))}("trim")},{trim:function(){return Nv(this)}}),Jr("String").trim,Tr({target:"Object",stat:!0,sham:!w},{create:Ma});var zv=B.Object,qv=function(t,e){return zv.create(t,e)},Yv=qv,Gv=Tr,Xv=tt,Uv=h,Wv=m,Vv=a,Hv=o.Array,$v=Xv("JSON","stringify"),Bv=Wv(/./.exec),Jv=Wv("".charAt),Kv=Wv("".charCodeAt),Qv=Wv("".replace),Zv=Wv(1..toString),td=/[\uD800-\uDFFF]/g,ed=/^[\uD800-\uDBFF]$/,rd=/^[\uDC00-\uDFFF]$/,nd=function(t,e,r){var n=Jv(r,e-1),i=Jv(r,e+1);return Bv(ed,t)&&!Bv(rd,i)||Bv(rd,t)&&!Bv(ed,n)?"\\u"+Zv(Kv(t,0),16):t},id=Vv((function(){return'"\\udf06\\ud834"'!==$v("\udf06\ud834")||'"\\udead"'!==$v("\udead")}));$v&&Gv({target:"JSON",stat:!0,forced:id},{stringify:function(t,e,r){for(var n=0,i=arguments.length,o=Hv(i);n<i;n++)o[n]=arguments[n];var a=Uv($v,null,o);return"string"==typeof a?Qv(a,td,nd):a}});var od=B,ad=h;od.JSON||(od.JSON={stringify:JSON.stringify});var ud=function(t,e,r){return ad(od.JSON.stringify,null,arguments)},sd=ud,cd=o.TypeError,fd=Tr,ld=o,hd=h,pd=b,vd=Rr,dd=function(t,e){if(t<e)throw cd("Not enough arguments");return t},yd=/MSIE .\./.test(rt),gd=ld.Function,md=function(t){return function(e,r){var n=dd(arguments.length,1)>2,i=pd(e)?e:gd(e),o=n?vd(arguments,2):void 0;return t(n?function(){hd(i,this,o)}:i,r)}};fd({global:!0,bind:!0,forced:yd},{setTimeout:md(ld.setTimeout),setInterval:md(ld.setInterval)});var bd=B.setTimeout,_d=Yt,wd=Qo,Od=cn,Ed=function(t){for(var e=_d(this),r=Od(e),n=arguments.length,i=wd(n>1?arguments[1]:void 0,r),o=n>2?arguments[2]:void 0,a=void 0===o?r:wd(o,r);a>i;)e[i++]=t;return e};Tr({target:"Array",proto:!0},{fill:Ed}),Jr("Array").fill;var Td={exports:{}};!function(t){function e(t){if(t)return function(t){for(var r in e.prototype)t[r]=e.prototype[r];return t}(t)}t.exports=e,e.prototype.on=e.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},e.prototype.once=function(t,e){function r(){this.off(t,r),e.apply(this,arguments)}return r.fn=e,this.on(t,r),this},e.prototype.off=e.prototype.removeListener=e.prototype.removeAllListeners=e.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var r,n=this._callbacks["$"+t];if(!n)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var i=0;i<n.length;i++)if((r=n[i])===e||r.fn===e){n.splice(i,1);break}return 0===n.length&&delete this._callbacks["$"+t],this},e.prototype.emit=function(t){this._callbacks=this._callbacks||{};for(var e=new Array(arguments.length-1),r=this._callbacks["$"+t],n=1;n<arguments.length;n++)e[n-1]=arguments[n];if(r){n=0;for(var i=(r=r.slice(0)).length;n<i;++n)r[n].apply(this,e)}return this},e.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},e.prototype.hasListeners=function(t){return!!this.listeners(t).length}}(Td);var xd,kd=Td.exports;
/*! Hammer.JS - v2.0.17-rc - 2019-12-16
   * http://naver.github.io/egjs
   *
   * Forked By Naver egjs
   * Copyright (c) hammerjs
   * Licensed under the MIT license */function Sd(){return Sd=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(t[n]=r[n])}return t},Sd.apply(this,arguments)}function Ad(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t.__proto__=e}function jd(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}xd="function"!=typeof Object.assign?function(t){if(null==t)throw new TypeError("Cannot convert undefined or null to object");for(var e=Object(t),r=1;r<arguments.length;r++){var n=arguments[r];if(null!=n)for(var i in n)n.hasOwnProperty(i)&&(e[i]=n[i])}return e}:Object.assign;var Pd,Id=xd,Dd=["","webkit","Moz","MS","ms","o"],Ld="undefined"==typeof document?{style:{}}:document.createElement("div"),Cd=Math.round,Rd=Math.abs,Md=Date.now;function Fd(t,e){for(var r,n,i=e[0].toUpperCase()+e.slice(1),o=0;o<Dd.length;){if((n=(r=Dd[o])?r+i:e)in t)return n;o++}}Pd="undefined"==typeof window?{}:window;var Nd=Fd(Ld.style,"touchAction"),zd=void 0!==Nd;var qd="compute",Yd="auto",Gd="manipulation",Xd="none",Ud="pan-x",Wd="pan-y",Vd=function(){if(!zd)return!1;var t={},e=Pd.CSS&&Pd.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach((function(r){return t[r]=!e||Pd.CSS.supports("touch-action",r)})),t}(),Hd="ontouchstart"in Pd,$d=void 0!==Fd(Pd,"PointerEvent"),Bd=Hd&&/mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent),Jd="touch",Kd="mouse",Qd=16,Zd=24,ty=["x","y"],ey=["clientX","clientY"];function ry(t,e,r){var n;if(t)if(t.forEach)t.forEach(e,r);else if(void 0!==t.length)for(n=0;n<t.length;)e.call(r,t[n],n,t),n++;else for(n in t)t.hasOwnProperty(n)&&e.call(r,t[n],n,t)}function ny(t,e){return"function"==typeof t?t.apply(e&&e[0]||void 0,e):t}function iy(t,e){return t.indexOf(e)>-1}var oy=function(){function t(t,e){this.manager=t,this.set(e)}var e=t.prototype;return e.set=function(t){t===qd&&(t=this.compute()),zd&&this.manager.element.style&&Vd[t]&&(this.manager.element.style[Nd]=t),this.actions=t.toLowerCase().trim()},e.update=function(){this.set(this.manager.options.touchAction)},e.compute=function(){var t=[];return ry(this.manager.recognizers,(function(e){ny(e.options.enable,[e])&&(t=t.concat(e.getTouchAction()))})),function(t){if(iy(t,Xd))return Xd;var e=iy(t,Ud),r=iy(t,Wd);return e&&r?Xd:e||r?e?Ud:Wd:iy(t,Gd)?Gd:Yd}(t.join(" "))},e.preventDefaults=function(t){var e=t.srcEvent,r=t.offsetDirection;if(this.manager.session.prevented)e.preventDefault();else{var n=this.actions,i=iy(n,Xd)&&!Vd.none,o=iy(n,Wd)&&!Vd["pan-y"],a=iy(n,Ud)&&!Vd["pan-x"];if(i){var u=1===t.pointers.length,s=t.distance<2,c=t.deltaTime<250;if(u&&s&&c)return}if(!a||!o)return i||o&&6&r||a&&r&Zd?this.preventSrc(e):void 0}},e.preventSrc=function(t){this.manager.session.prevented=!0,t.preventDefault()},t}();function ay(t,e){for(;t;){if(t===e)return!0;t=t.parentNode}return!1}function uy(t){var e=t.length;if(1===e)return{x:Cd(t[0].clientX),y:Cd(t[0].clientY)};for(var r=0,n=0,i=0;i<e;)r+=t[i].clientX,n+=t[i].clientY,i++;return{x:Cd(r/e),y:Cd(n/e)}}function sy(t){for(var e=[],r=0;r<t.pointers.length;)e[r]={clientX:Cd(t.pointers[r].clientX),clientY:Cd(t.pointers[r].clientY)},r++;return{timeStamp:Md(),pointers:e,center:uy(e),deltaX:t.deltaX,deltaY:t.deltaY}}function cy(t,e,r){r||(r=ty);var n=e[r[0]]-t[r[0]],i=e[r[1]]-t[r[1]];return Math.sqrt(n*n+i*i)}function fy(t,e,r){r||(r=ty);var n=e[r[0]]-t[r[0]],i=e[r[1]]-t[r[1]];return 180*Math.atan2(i,n)/Math.PI}function ly(t,e){return t===e?1:Rd(t)>=Rd(e)?t<0?2:4:e<0?8:Qd}function hy(t,e,r){return{x:e/t||0,y:r/t||0}}function py(t,e){var r=t.session,n=e.pointers,i=n.length;r.firstInput||(r.firstInput=sy(e)),i>1&&!r.firstMultiple?r.firstMultiple=sy(e):1===i&&(r.firstMultiple=!1);var o=r.firstInput,a=r.firstMultiple,u=a?a.center:o.center,s=e.center=uy(n);e.timeStamp=Md(),e.deltaTime=e.timeStamp-o.timeStamp,e.angle=fy(u,s),e.distance=cy(u,s),function(t,e){var r=e.center,n=t.offsetDelta||{},i=t.prevDelta||{},o=t.prevInput||{};1!==e.eventType&&4!==o.eventType||(i=t.prevDelta={x:o.deltaX||0,y:o.deltaY||0},n=t.offsetDelta={x:r.x,y:r.y}),e.deltaX=i.x+(r.x-n.x),e.deltaY=i.y+(r.y-n.y)}(r,e),e.offsetDirection=ly(e.deltaX,e.deltaY);var c,f,l=hy(e.deltaTime,e.deltaX,e.deltaY);e.overallVelocityX=l.x,e.overallVelocityY=l.y,e.overallVelocity=Rd(l.x)>Rd(l.y)?l.x:l.y,e.scale=a?(c=a.pointers,cy((f=n)[0],f[1],ey)/cy(c[0],c[1],ey)):1,e.rotation=a?function(t,e){return fy(e[1],e[0],ey)+fy(t[1],t[0],ey)}(a.pointers,n):0,e.maxPointers=r.prevInput?e.pointers.length>r.prevInput.maxPointers?e.pointers.length:r.prevInput.maxPointers:e.pointers.length,function(t,e){var r,n,i,o,a=t.lastInterval||e,u=e.timeStamp-a.timeStamp;if(8!==e.eventType&&(u>25||void 0===a.velocity)){var s=e.deltaX-a.deltaX,c=e.deltaY-a.deltaY,f=hy(u,s,c);n=f.x,i=f.y,r=Rd(f.x)>Rd(f.y)?f.x:f.y,o=ly(s,c),t.lastInterval=e}else r=a.velocity,n=a.velocityX,i=a.velocityY,o=a.direction;e.velocity=r,e.velocityX=n,e.velocityY=i,e.direction=o}(r,e);var h,p=t.element,v=e.srcEvent;ay(h=v.composedPath?v.composedPath()[0]:v.path?v.path[0]:v.target,p)&&(p=h),e.target=p}function vy(t,e,r){var n=r.pointers.length,i=r.changedPointers.length,o=1&e&&n-i==0,a=12&e&&n-i==0;r.isFirst=!!o,r.isFinal=!!a,o&&(t.session={}),r.eventType=e,py(t,r),t.emit("hammer.input",r),t.recognize(r),t.session.prevInput=r}function dy(t){return t.trim().split(/\s+/g)}function yy(t,e,r){ry(dy(e),(function(e){t.addEventListener(e,r,!1)}))}function gy(t,e,r){ry(dy(e),(function(e){t.removeEventListener(e,r,!1)}))}function my(t){var e=t.ownerDocument||t;return e.defaultView||e.parentWindow||window}var by=function(){function t(t,e){var r=this;this.manager=t,this.callback=e,this.element=t.element,this.target=t.options.inputTarget,this.domHandler=function(e){ny(t.options.enable,[t])&&r.handler(e)},this.init()}var e=t.prototype;return e.handler=function(){},e.init=function(){this.evEl&&yy(this.element,this.evEl,this.domHandler),this.evTarget&&yy(this.target,this.evTarget,this.domHandler),this.evWin&&yy(my(this.element),this.evWin,this.domHandler)},e.destroy=function(){this.evEl&&gy(this.element,this.evEl,this.domHandler),this.evTarget&&gy(this.target,this.evTarget,this.domHandler),this.evWin&&gy(my(this.element),this.evWin,this.domHandler)},t}();function _y(t,e,r){if(t.indexOf&&!r)return t.indexOf(e);for(var n=0;n<t.length;){if(r&&t[n][r]==e||!r&&t[n]===e)return n;n++}return-1}var wy={pointerdown:1,pointermove:2,pointerup:4,pointercancel:8,pointerout:8},Oy={2:Jd,3:"pen",4:Kd,5:"kinect"},Ey="pointerdown",Ty="pointermove pointerup pointercancel";Pd.MSPointerEvent&&!Pd.PointerEvent&&(Ey="MSPointerDown",Ty="MSPointerMove MSPointerUp MSPointerCancel");var xy=function(t){function e(){var r,n=e.prototype;return n.evEl=Ey,n.evWin=Ty,(r=t.apply(this,arguments)||this).store=r.manager.session.pointerEvents=[],r}return Ad(e,t),e.prototype.handler=function(t){var e=this.store,r=!1,n=t.type.toLowerCase().replace("ms",""),i=wy[n],o=Oy[t.pointerType]||t.pointerType,a=o===Jd,u=_y(e,t.pointerId,"pointerId");1&i&&(0===t.button||a)?u<0&&(e.push(t),u=e.length-1):12&i&&(r=!0),u<0||(e[u]=t,this.callback(this.manager,i,{pointers:e,changedPointers:[t],pointerType:o,srcEvent:t}),r&&e.splice(u,1))},e}(by);function ky(t){return Array.prototype.slice.call(t,0)}function Sy(t,e,r){for(var n=[],i=[],o=0;o<t.length;){var a=e?t[o][e]:t[o];_y(i,a)<0&&n.push(t[o]),i[o]=a,o++}return r&&(n=e?n.sort((function(t,r){return t[e]>r[e]})):n.sort()),n}var Ay={touchstart:1,touchmove:2,touchend:4,touchcancel:8},jy="touchstart touchmove touchend touchcancel",Py=function(t){function e(){var r;return e.prototype.evTarget=jy,(r=t.apply(this,arguments)||this).targetIds={},r}return Ad(e,t),e.prototype.handler=function(t){var e=Ay[t.type],r=Iy.call(this,t,e);r&&this.callback(this.manager,e,{pointers:r[0],changedPointers:r[1],pointerType:Jd,srcEvent:t})},e}(by);function Iy(t,e){var r,n,i=ky(t.touches),o=this.targetIds;if(3&e&&1===i.length)return o[i[0].identifier]=!0,[i,i];var a=ky(t.changedTouches),u=[],s=this.target;if(n=i.filter((function(t){return ay(t.target,s)})),1===e)for(r=0;r<n.length;)o[n[r].identifier]=!0,r++;for(r=0;r<a.length;)o[a[r].identifier]&&u.push(a[r]),12&e&&delete o[a[r].identifier],r++;return u.length?[Sy(n.concat(u),"identifier",!0),u]:void 0}var Dy={mousedown:1,mousemove:2,mouseup:4},Ly="mousedown",Cy="mousemove mouseup",Ry=function(t){function e(){var r,n=e.prototype;return n.evEl=Ly,n.evWin=Cy,(r=t.apply(this,arguments)||this).pressed=!1,r}return Ad(e,t),e.prototype.handler=function(t){var e=Dy[t.type];1&e&&0===t.button&&(this.pressed=!0),2&e&&1!==t.which&&(e=4),this.pressed&&(4&e&&(this.pressed=!1),this.callback(this.manager,e,{pointers:[t],changedPointers:[t],pointerType:Kd,srcEvent:t}))},e}(by);function My(t){var e=t.changedPointers[0];if(e.identifier===this.primaryTouch){var r={x:e.clientX,y:e.clientY},n=this.lastTouches;this.lastTouches.push(r);setTimeout((function(){var t=n.indexOf(r);t>-1&&n.splice(t,1)}),2500)}}function Fy(t,e){1&t?(this.primaryTouch=e.changedPointers[0].identifier,My.call(this,e)):12&t&&My.call(this,e)}function Ny(t){for(var e=t.srcEvent.clientX,r=t.srcEvent.clientY,n=0;n<this.lastTouches.length;n++){var i=this.lastTouches[n],o=Math.abs(e-i.x),a=Math.abs(r-i.y);if(o<=25&&a<=25)return!0}return!1}var zy=function(){return function(t){function e(e,r){var n;return(n=t.call(this,e,r)||this).handler=function(t,e,r){var i=r.pointerType===Jd,o=r.pointerType===Kd;if(!(o&&r.sourceCapabilities&&r.sourceCapabilities.firesTouchEvents)){if(i)Fy.call(jd(jd(n)),e,r);else if(o&&Ny.call(jd(jd(n)),r))return;n.callback(t,e,r)}},n.touch=new Py(n.manager,n.handler),n.mouse=new Ry(n.manager,n.handler),n.primaryTouch=null,n.lastTouches=[],n}return Ad(e,t),e.prototype.destroy=function(){this.touch.destroy(),this.mouse.destroy()},e}(by)}();function qy(t,e,r){return!!Array.isArray(t)&&(ry(t,r[e],r),!0)}var Yy=32,Gy=1;function Xy(t,e){var r=e.manager;return r?r.get(t):t}function Uy(t){return 16&t?"cancel":8&t?"end":4&t?"move":2&t?"start":""}var Wy=function(){function t(t){void 0===t&&(t={}),this.options=Sd({enable:!0},t),this.id=Gy++,this.manager=null,this.state=1,this.simultaneous={},this.requireFail=[]}var e=t.prototype;return e.set=function(t){return Id(this.options,t),this.manager&&this.manager.touchAction.update(),this},e.recognizeWith=function(t){if(qy(t,"recognizeWith",this))return this;var e=this.simultaneous;return e[(t=Xy(t,this)).id]||(e[t.id]=t,t.recognizeWith(this)),this},e.dropRecognizeWith=function(t){return qy(t,"dropRecognizeWith",this)||(t=Xy(t,this),delete this.simultaneous[t.id]),this},e.requireFailure=function(t){if(qy(t,"requireFailure",this))return this;var e=this.requireFail;return-1===_y(e,t=Xy(t,this))&&(e.push(t),t.requireFailure(this)),this},e.dropRequireFailure=function(t){if(qy(t,"dropRequireFailure",this))return this;t=Xy(t,this);var e=_y(this.requireFail,t);return e>-1&&this.requireFail.splice(e,1),this},e.hasRequireFailures=function(){return this.requireFail.length>0},e.canRecognizeWith=function(t){return!!this.simultaneous[t.id]},e.emit=function(t){var e=this,r=this.state;function n(r){e.manager.emit(r,t)}r<8&&n(e.options.event+Uy(r)),n(e.options.event),t.additionalEvent&&n(t.additionalEvent),r>=8&&n(e.options.event+Uy(r))},e.tryEmit=function(t){if(this.canEmit())return this.emit(t);this.state=Yy},e.canEmit=function(){for(var t=0;t<this.requireFail.length;){if(!(33&this.requireFail[t].state))return!1;t++}return!0},e.recognize=function(t){var e=Id({},t);if(!ny(this.options.enable,[this,e]))return this.reset(),void(this.state=Yy);56&this.state&&(this.state=1),this.state=this.process(e),30&this.state&&this.tryEmit(e)},e.process=function(t){},e.getTouchAction=function(){},e.reset=function(){},t}(),Vy=function(t){function e(e){var r;return void 0===e&&(e={}),(r=t.call(this,Sd({event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},e))||this).pTime=!1,r.pCenter=!1,r._timer=null,r._input=null,r.count=0,r}Ad(e,t);var r=e.prototype;return r.getTouchAction=function(){return[Gd]},r.process=function(t){var e=this,r=this.options,n=t.pointers.length===r.pointers,i=t.distance<r.threshold,o=t.deltaTime<r.time;if(this.reset(),1&t.eventType&&0===this.count)return this.failTimeout();if(i&&o&&n){if(4!==t.eventType)return this.failTimeout();var a=!this.pTime||t.timeStamp-this.pTime<r.interval,u=!this.pCenter||cy(this.pCenter,t.center)<r.posThreshold;if(this.pTime=t.timeStamp,this.pCenter=t.center,u&&a?this.count+=1:this.count=1,this._input=t,0===this.count%r.taps)return this.hasRequireFailures()?(this._timer=setTimeout((function(){e.state=8,e.tryEmit()}),r.interval),2):8}return Yy},r.failTimeout=function(){var t=this;return this._timer=setTimeout((function(){t.state=Yy}),this.options.interval),Yy},r.reset=function(){clearTimeout(this._timer)},r.emit=function(){8===this.state&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))},e}(Wy),Hy=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Sd({pointers:1},e))||this}Ad(e,t);var r=e.prototype;return r.attrTest=function(t){var e=this.options.pointers;return 0===e||t.pointers.length===e},r.process=function(t){var e=this.state,r=t.eventType,n=6&e,i=this.attrTest(t);return n&&(8&r||!i)?16|e:n||i?4&r?8|e:2&e?4|e:2:Yy},e}(Wy);function $y(t){return t===Qd?"down":8===t?"up":2===t?"left":4===t?"right":""}var By=function(t){function e(e){var r;return void 0===e&&(e={}),(r=t.call(this,Sd({event:"pan",threshold:10,pointers:1,direction:30},e))||this).pX=null,r.pY=null,r}Ad(e,t);var r=e.prototype;return r.getTouchAction=function(){var t=this.options.direction,e=[];return 6&t&&e.push(Wd),t&Zd&&e.push(Ud),e},r.directionTest=function(t){var e=this.options,r=!0,n=t.distance,i=t.direction,o=t.deltaX,a=t.deltaY;return i&e.direction||(6&e.direction?(i=0===o?1:o<0?2:4,r=o!==this.pX,n=Math.abs(t.deltaX)):(i=0===a?1:a<0?8:Qd,r=a!==this.pY,n=Math.abs(t.deltaY))),t.direction=i,r&&n>e.threshold&&i&e.direction},r.attrTest=function(t){return Hy.prototype.attrTest.call(this,t)&&(2&this.state||!(2&this.state)&&this.directionTest(t))},r.emit=function(e){this.pX=e.deltaX,this.pY=e.deltaY;var r=$y(e.direction);r&&(e.additionalEvent=this.options.event+r),t.prototype.emit.call(this,e)},e}(Hy),Jy=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Sd({event:"swipe",threshold:10,velocity:.3,direction:30,pointers:1},e))||this}Ad(e,t);var r=e.prototype;return r.getTouchAction=function(){return By.prototype.getTouchAction.call(this)},r.attrTest=function(e){var r,n=this.options.direction;return 30&n?r=e.overallVelocity:6&n?r=e.overallVelocityX:n&Zd&&(r=e.overallVelocityY),t.prototype.attrTest.call(this,e)&&n&e.offsetDirection&&e.distance>this.options.threshold&&e.maxPointers===this.options.pointers&&Rd(r)>this.options.velocity&&4&e.eventType},r.emit=function(t){var e=$y(t.offsetDirection);e&&this.manager.emit(this.options.event+e,t),this.manager.emit(this.options.event,t)},e}(Hy),Ky=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Sd({event:"pinch",threshold:0,pointers:2},e))||this}Ad(e,t);var r=e.prototype;return r.getTouchAction=function(){return[Xd]},r.attrTest=function(e){return t.prototype.attrTest.call(this,e)&&(Math.abs(e.scale-1)>this.options.threshold||2&this.state)},r.emit=function(e){if(1!==e.scale){var r=e.scale<1?"in":"out";e.additionalEvent=this.options.event+r}t.prototype.emit.call(this,e)},e}(Hy),Qy=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Sd({event:"rotate",threshold:0,pointers:2},e))||this}Ad(e,t);var r=e.prototype;return r.getTouchAction=function(){return[Xd]},r.attrTest=function(e){return t.prototype.attrTest.call(this,e)&&(Math.abs(e.rotation)>this.options.threshold||2&this.state)},e}(Hy),Zy=function(t){function e(e){var r;return void 0===e&&(e={}),(r=t.call(this,Sd({event:"press",pointers:1,time:251,threshold:9},e))||this)._timer=null,r._input=null,r}Ad(e,t);var r=e.prototype;return r.getTouchAction=function(){return[Yd]},r.process=function(t){var e=this,r=this.options,n=t.pointers.length===r.pointers,i=t.distance<r.threshold,o=t.deltaTime>r.time;if(this._input=t,!i||!n||12&t.eventType&&!o)this.reset();else if(1&t.eventType)this.reset(),this._timer=setTimeout((function(){e.state=8,e.tryEmit()}),r.time);else if(4&t.eventType)return 8;return Yy},r.reset=function(){clearTimeout(this._timer)},r.emit=function(t){8===this.state&&(t&&4&t.eventType?this.manager.emit(this.options.event+"up",t):(this._input.timeStamp=Md(),this.manager.emit(this.options.event,this._input)))},e}(Wy),tg={domEvents:!1,touchAction:qd,enable:!0,inputTarget:null,inputClass:null,cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}},eg=[[Qy,{enable:!1}],[Ky,{enable:!1},["rotate"]],[Jy,{direction:6}],[By,{direction:6},["swipe"]],[Vy],[Vy,{event:"doubletap",taps:2},["tap"]],[Zy]];function rg(t,e){var r,n=t.element;n.style&&(ry(t.options.cssProps,(function(i,o){r=Fd(n.style,o),e?(t.oldCssProps[r]=n.style[r],n.style[r]=i):n.style[r]=t.oldCssProps[r]||""})),e||(t.oldCssProps={}))}var ng=function(){function t(t,e){var r,n=this;this.options=Id({},tg,e||{}),this.options.inputTarget=this.options.inputTarget||t,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=t,this.input=new((r=this).options.inputClass||($d?xy:Bd?Py:Hd?zy:Ry))(r,vy),this.touchAction=new oy(this,this.options.touchAction),rg(this,!0),ry(this.options.recognizers,(function(t){var e=n.add(new t[0](t[1]));t[2]&&e.recognizeWith(t[2]),t[3]&&e.requireFailure(t[3])}),this)}var e=t.prototype;return e.set=function(t){return Id(this.options,t),t.touchAction&&this.touchAction.update(),t.inputTarget&&(this.input.destroy(),this.input.target=t.inputTarget,this.input.init()),this},e.stop=function(t){this.session.stopped=t?2:1},e.recognize=function(t){var e=this.session;if(!e.stopped){var r;this.touchAction.preventDefaults(t);var n=this.recognizers,i=e.curRecognizer;(!i||i&&8&i.state)&&(e.curRecognizer=null,i=null);for(var o=0;o<n.length;)r=n[o],2===e.stopped||i&&r!==i&&!r.canRecognizeWith(i)?r.reset():r.recognize(t),!i&&14&r.state&&(e.curRecognizer=r,i=r),o++}},e.get=function(t){if(t instanceof Wy)return t;for(var e=this.recognizers,r=0;r<e.length;r++)if(e[r].options.event===t)return e[r];return null},e.add=function(t){if(qy(t,"add",this))return this;var e=this.get(t.options.event);return e&&this.remove(e),this.recognizers.push(t),t.manager=this,this.touchAction.update(),t},e.remove=function(t){if(qy(t,"remove",this))return this;var e=this.get(t);if(t){var r=this.recognizers,n=_y(r,e);-1!==n&&(r.splice(n,1),this.touchAction.update())}return this},e.on=function(t,e){if(void 0===t||void 0===e)return this;var r=this.handlers;return ry(dy(t),(function(t){r[t]=r[t]||[],r[t].push(e)})),this},e.off=function(t,e){if(void 0===t)return this;var r=this.handlers;return ry(dy(t),(function(t){e?r[t]&&r[t].splice(_y(r[t],e),1):delete r[t]})),this},e.emit=function(t,e){this.options.domEvents&&function(t,e){var r=document.createEvent("Event");r.initEvent(t,!0,!0),r.gesture=e,e.target.dispatchEvent(r)}(t,e);var r=this.handlers[t]&&this.handlers[t].slice();if(r&&r.length){e.type=t,e.preventDefault=function(){e.srcEvent.preventDefault()};for(var n=0;n<r.length;)r[n](e),n++}},e.destroy=function(){this.element&&rg(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null},t}(),ig={touchstart:1,touchmove:2,touchend:4,touchcancel:8},og="touchstart",ag="touchstart touchmove touchend touchcancel",ug=function(t){function e(){var r,n=e.prototype;return n.evTarget=og,n.evWin=ag,(r=t.apply(this,arguments)||this).started=!1,r}return Ad(e,t),e.prototype.handler=function(t){var e=ig[t.type];if(1===e&&(this.started=!0),this.started){var r=sg.call(this,t,e);12&e&&r[0].length-r[1].length==0&&(this.started=!1),this.callback(this.manager,e,{pointers:r[0],changedPointers:r[1],pointerType:Jd,srcEvent:t})}},e}(by);function sg(t,e){var r=ky(t.touches),n=ky(t.changedTouches);return 12&e&&(r=Sy(r.concat(n),"identifier",!0)),[r,n]}function cg(t,e,r){var n="DEPRECATED METHOD: "+e+"\n"+r+" AT \n";return function(){var e=new Error("get-stack-trace"),r=e&&e.stack?e.stack.replace(/^[^\(]+?[\n$]/gm,"").replace(/^\s+at\s+/gm,"").replace(/^Object.<anonymous>\s*\(/gm,"{anonymous}()@"):"Unknown Stack Trace",i=window.console&&(window.console.warn||window.console.log);return i&&i.call(window.console,n,r),t.apply(this,arguments)}}var fg=cg((function(t,e,r){for(var n=Object.keys(e),i=0;i<n.length;)(!r||r&&void 0===t[n[i]])&&(t[n[i]]=e[n[i]]),i++;return t}),"extend","Use `assign`."),lg=cg((function(t,e){return fg(t,e,!0)}),"merge","Use `assign`.");function hg(t,e,r){var n,i=e.prototype;(n=t.prototype=Object.create(i)).constructor=t,n._super=i,r&&Id(n,r)}function pg(t,e){return function(){return t.apply(e,arguments)}}var vg=function(){var t=function(t,e){return void 0===e&&(e={}),new ng(t,Sd({recognizers:eg.concat()},e))};return t.VERSION="2.0.17-rc",t.DIRECTION_ALL=30,t.DIRECTION_DOWN=Qd,t.DIRECTION_LEFT=2,t.DIRECTION_RIGHT=4,t.DIRECTION_UP=8,t.DIRECTION_HORIZONTAL=6,t.DIRECTION_VERTICAL=Zd,t.DIRECTION_NONE=1,t.DIRECTION_DOWN=Qd,t.INPUT_START=1,t.INPUT_MOVE=2,t.INPUT_END=4,t.INPUT_CANCEL=8,t.STATE_POSSIBLE=1,t.STATE_BEGAN=2,t.STATE_CHANGED=4,t.STATE_ENDED=8,t.STATE_RECOGNIZED=8,t.STATE_CANCELLED=16,t.STATE_FAILED=Yy,t.Manager=ng,t.Input=by,t.TouchAction=oy,t.TouchInput=Py,t.MouseInput=Ry,t.PointerEventInput=xy,t.TouchMouseInput=zy,t.SingleTouchInput=ug,t.Recognizer=Wy,t.AttrRecognizer=Hy,t.Tap=Vy,t.Pan=By,t.Swipe=Jy,t.Pinch=Ky,t.Rotate=Qy,t.Press=Zy,t.on=yy,t.off=gy,t.each=ry,t.merge=lg,t.extend=fg,t.bindFn=pg,t.assign=Id,t.inherit=hg,t.bindFn=pg,t.prefixed=Fd,t.toArray=ky,t.inArray=_y,t.uniqueArray=Sy,t.splitStr=dy,t.boolOrFn=ny,t.hasParent=ay,t.addEventListeners=yy,t.removeEventListeners=gy,t.defaults=Id({},tg,{preset:eg}),t}();function dg(t,e){var r=void 0!==Oh&&ic(t)||t["@@iterator"];if(!r){if(Ph(t)||(r=function(t,e){var r;if(!t)return;if("string"==typeof t)return yg(t,e);var n=Ah(r=Object.prototype.toString.call(t)).call(r,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return qs(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return yg(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,i=function(){};return{s:i,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){r=r.call(t)},n:function(){var t=r.next();return a=t.done,t},e:function(t){u=!0,o=t},f:function(){try{a||null==r.return||r.return()}finally{if(u)throw o}}}}function yg(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var gg=Oh("DELETE");function mg(){var t=bg.apply(void 0,arguments);return wg(t),t}function bg(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];if(e.length<2)return e[0];var n;if(e.length>2)return bg.apply(void 0,Sh(n=[mg(e[0],e[1])]).call(n,wh(Ah(e).call(e,2))));var i,o=e[0],a=e[1],u=dg(jh(a));try{for(u.s();!(i=u.n()).done;){var s=i.value;Object.prototype.propertyIsEnumerable.call(a,s)&&(a[s]===gg?delete o[s]:null===o[s]||null===a[s]||"object"!==_h(o[s])||"object"!==_h(a[s])||Ph(o[s])||Ph(a[s])?o[s]=_g(a[s]):o[s]=bg(o[s],a[s]))}}catch(t){u.e(t)}finally{u.f()}return o}function _g(t){return Ph(t)?Ri(t).call(t,(function(t){return _g(t)})):"object"===_h(t)&&null!==t?bg({},t):t}function wg(t){for(var e=0,r=Lh(t);e<r.length;e++){var n=r[e];t[n]===gg?delete t[n]:"object"===_h(t[n])&&null!==t[n]&&wg(t[n])}}var Og="undefined"!=typeof window?window.Hammer||vg:function(){return function(){var t=function(){};return{on:t,off:t,destroy:t,emit:t,get:function(){return{set:t}}}}()};function Eg(t){var e,r=this;this._cleanupQueue=[],this.active=!1,this._dom={container:t,overlay:document.createElement("div")},this._dom.overlay.classList.add("vis-overlay"),this._dom.container.appendChild(this._dom.overlay),this._cleanupQueue.push((function(){r._dom.overlay.parentNode.removeChild(r._dom.overlay)}));var n=Og(this._dom.overlay);n.on("tap",en(e=this._onTapOverlay).call(e,this)),this._cleanupQueue.push((function(){n.destroy()}));var i=["tap","doubletap","press","pinch","pan","panstart","panmove","panend"];Hh(i).call(i,(function(t){n.on(t,(function(t){t.srcEvent.stopPropagation()}))})),document&&document.body&&(this._onClick=function(e){(function(t,e){for(;t;){if(t===e)return!0;t=t.parentNode}return!1})(e.target,t)||r.deactivate()},document.body.addEventListener("click",this._onClick),this._cleanupQueue.push((function(){document.body.removeEventListener("click",r._onClick)}))),this._escListener=function(t){("key"in t?"Escape"===t.key:27===t.keyCode)&&r.deactivate()}}kd(Eg.prototype),Eg.current=null,Eg.prototype.destroy=function(){var t,e;this.deactivate();var r,n=dg(rp(t=wp(e=this._cleanupQueue).call(e,0)).call(t));try{for(n.s();!(r=n.n()).done;){(0,r.value)()}}catch(t){n.e(t)}finally{n.f()}},Eg.prototype.activate=function(){Eg.current&&Eg.current.deactivate(),Eg.current=this,this.active=!0,this._dom.overlay.style.display="none",this._dom.container.classList.add("vis-active"),this.emit("change"),this.emit("activate"),document.body.addEventListener("keydown",this._escListener)},Eg.prototype.deactivate=function(){this.active=!1,this._dom.overlay.style.display="block",this._dom.container.classList.remove("vis-active"),document.body.removeEventListener("keydown",this._escListener),this.emit("change"),this.emit("deactivate")},Eg.prototype._onTapOverlay=function(t){this.activate(),t.srcEvent.stopPropagation()};var Tg=ni,xg=wt,kg=o.TypeError,Sg=Tr,Ag=h,jg=Hr,Pg=function(t){if(Tg(t))return t;throw kg(xg(t)+" is not a constructor")},Ig=Qe,Dg=$,Lg=Ma,Cg=a,Rg=tt("Reflect","construct"),Mg=Object.prototype,Fg=[].push,Ng=Cg((function(){function t(){}return!(Rg((function(){}),[],t)instanceof t)})),zg=!Cg((function(){Rg((function(){}))})),qg=Ng||zg;Sg({target:"Reflect",stat:!0,forced:qg,sham:qg},{construct:function(t,e){Pg(t),Ig(e);var r=arguments.length<3?t:Pg(arguments[2]);if(zg&&!Ng)return Rg(t,e,r);if(t==r){switch(e.length){case 0:return new t;case 1:return new t(e[0]);case 2:return new t(e[0],e[1]);case 3:return new t(e[0],e[1],e[2]);case 4:return new t(e[0],e[1],e[2],e[3])}var n=[null];return Ag(Fg,n,e),new(Ag(jg,t,n))}var i=r.prototype,o=Lg(Dg(i)?i:Mg),a=Ag(t,o,e);return Dg(a)?a:o}});var Yg=B.Reflect.construct;function Gg(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}var Xg=qv;Tr({target:"Object",stat:!0},{setPrototypeOf:Su});var Ug=B.Object.setPrototypeOf;function Wg(t,e){return Wg=Ug||function(t,e){return t.__proto__=e,t},Wg(t,e)}function Vg(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Xg(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Ir(t,"prototype",{writable:!1}),e&&Wg(t,e)}function Hg(t,e){if(e&&("object"===_h(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return Gg(t)}var $g=Zp;function Bg(t){return Bg=Ug?$g:function(t){return t.__proto__||$g(t)},Bg(t)}var Jg={exports:{}};!function(t){var e=function(t){var e,r=Object.prototype,n=r.hasOwnProperty,i="function"==typeof Symbol?Symbol:{},o=i.iterator||"@@iterator",a=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function s(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{s({},"")}catch(t){s=function(t,e,r){return t[e]=r}}function c(t,e,r,n){var i=e&&e.prototype instanceof y?e:y,o=Object.create(i.prototype),a=new A(n||[]);return o._invoke=function(t,e,r){var n=l;return function(i,o){if(n===p)throw new Error("Generator is already running");if(n===v){if("throw"===i)throw o;return P()}for(r.method=i,r.arg=o;;){var a=r.delegate;if(a){var u=x(a,r);if(u){if(u===d)continue;return u}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===l)throw n=v,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=p;var s=f(t,e,r);if("normal"===s.type){if(n=r.done?v:h,s.arg===d)continue;return{value:s.arg,done:r.done}}"throw"===s.type&&(n=v,r.method="throw",r.arg=s.arg)}}}(t,r,a),o}function f(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}t.wrap=c;var l="suspendedStart",h="suspendedYield",p="executing",v="completed",d={};function y(){}function g(){}function m(){}var b={};s(b,o,(function(){return this}));var _=Object.getPrototypeOf,w=_&&_(_(j([])));w&&w!==r&&n.call(w,o)&&(b=w);var O=m.prototype=y.prototype=Object.create(b);function E(t){["next","throw","return"].forEach((function(e){s(t,e,(function(t){return this._invoke(e,t)}))}))}function T(t,e){function r(i,o,a,u){var s=f(t[i],t,o);if("throw"!==s.type){var c=s.arg,l=c.value;return l&&"object"==typeof l&&n.call(l,"__await")?e.resolve(l.__await).then((function(t){r("next",t,a,u)}),(function(t){r("throw",t,a,u)})):e.resolve(l).then((function(t){c.value=t,a(c)}),(function(t){return r("throw",t,a,u)}))}u(s.arg)}var i;this._invoke=function(t,n){function o(){return new e((function(e,i){r(t,n,e,i)}))}return i=i?i.then(o,o):o()}}function x(t,r){var n=t.iterator[r.method];if(n===e){if(r.delegate=null,"throw"===r.method){if(t.iterator.return&&(r.method="return",r.arg=e,x(t,r),"throw"===r.method))return d;r.method="throw",r.arg=new TypeError("The iterator does not provide a 'throw' method")}return d}var i=f(n,t.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,d;var o=i.arg;return o?o.done?(r[t.resultName]=o.value,r.next=t.nextLoc,"return"!==r.method&&(r.method="next",r.arg=e),r.delegate=null,d):o:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,d)}function k(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function S(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function A(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(k,this),this.reset(!0)}function j(t){if(t){var r=t[o];if(r)return r.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var i=-1,a=function r(){for(;++i<t.length;)if(n.call(t,i))return r.value=t[i],r.done=!1,r;return r.value=e,r.done=!0,r};return a.next=a}}return{next:P}}function P(){return{value:e,done:!0}}return g.prototype=m,s(O,"constructor",m),s(m,"constructor",g),g.displayName=s(m,u,"GeneratorFunction"),t.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===g||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,m):(t.__proto__=m,s(t,u,"GeneratorFunction")),t.prototype=Object.create(O),t},t.awrap=function(t){return{__await:t}},E(T.prototype),s(T.prototype,a,(function(){return this})),t.AsyncIterator=T,t.async=function(e,r,n,i,o){void 0===o&&(o=Promise);var a=new T(c(e,r,n,i),o);return t.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},E(O),s(O,u,"Generator"),s(O,o,(function(){return this})),s(O,"toString",(function(){return"[object Generator]"})),t.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},t.values=j,A.prototype={constructor:A,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(S),!t)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=e)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var r=this;function i(n,i){return u.type="throw",u.arg=t,r.next=n,i&&(r.method="next",r.arg=e),!!i}for(var o=this.tryEntries.length-1;o>=0;--o){var a=this.tryEntries[o],u=a.completion;if("root"===a.tryLoc)return i("end");if(a.tryLoc<=this.prev){var s=n.call(a,"catchLoc"),c=n.call(a,"finallyLoc");if(s&&c){if(this.prev<a.catchLoc)return i(a.catchLoc,!0);if(this.prev<a.finallyLoc)return i(a.finallyLoc)}else if(s){if(this.prev<a.catchLoc)return i(a.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return i(a.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r];if(i.tryLoc<=this.prev&&n.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var o=i;break}}o&&("break"===t||"continue"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var a=o?o.completion:{};return a.type=t,a.arg=e,o?(this.method="next",this.next=o.finallyLoc,d):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),d},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),S(r),d}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var i=n.arg;S(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,r,n){return this.delegate={iterator:j(t),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=e),d}},t}(t.exports);try{regeneratorRuntime=e}catch(t){"object"==typeof globalThis?globalThis.regeneratorRuntime=e:Function("r","regeneratorRuntime = r")(e)}}(Jg);var Kg=Jg.exports,Qg={exports:{}},Zg=a((function(){if("function"==typeof ArrayBuffer){var t=new ArrayBuffer(8);Object.isExtensible(t)&&Object.defineProperty(t,"a",{value:8})}})),tm=a,em=$,rm=R,nm=Zg,im=Object.isExtensible,om=tm((function(){im(1)}))||nm?function(t){return!!em(t)&&((!nm||"ArrayBuffer"!=rm(t))&&(!im||im(t)))}:im,am=!a((function(){return Object.isExtensible(Object.preventExtensions({}))})),um=Tr,sm=m,cm=Eo,fm=$,lm=Ut,hm=Ve.f,pm=oc,vm=sc,dm=om,ym=am,gm=!1,mm=Bt("meta"),bm=0,_m=function(t){hm(t,mm,{value:{objectID:"O"+bm++,weakData:{}}})},wm=Qg.exports={enable:function(){wm.enable=function(){},gm=!0;var t=pm.f,e=sm([].splice),r={};r[mm]=1,t(r).length&&(pm.f=function(r){for(var n=t(r),i=0,o=n.length;i<o;i++)if(n[i]===mm){e(n,i,1);break}return n},um({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:vm.f}))},fastKey:function(t,e){if(!fm(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!lm(t,mm)){if(!dm(t))return"F";if(!e)return"E";_m(t)}return t[mm].objectID},getWeakData:function(t,e){if(!lm(t,mm)){if(!dm(t))return!0;if(!e)return!1;_m(t)}return t[mm].weakData},onFreeze:function(t){return ym&&gm&&dm(t)&&!lm(t,mm)&&_m(t),t}};cm[mm]=!0;var Om=We,Em=T,Tm=Qe,xm=wt,km=os,Sm=cn,Am=et,jm=ws,Pm=vs,Im=Zu,Dm=o.TypeError,Lm=function(t,e){this.stopped=t,this.result=e},Cm=Lm.prototype,Rm=function(t,e,r){var n,i,o,a,u,s,c,f=r&&r.that,l=!(!r||!r.AS_ENTRIES),h=!(!r||!r.IS_ITERATOR),p=!(!r||!r.INTERRUPTED),v=Om(e,f),d=function(t){return n&&Im(n,"normal",t),new Lm(!0,t)},y=function(t){return l?(Tm(t),p?v(t[0],t[1],d):v(t[0],t[1])):p?v(t,d):v(t)};if(h)n=t;else{if(!(i=Pm(t)))throw Dm(xm(t)+" is not iterable");if(km(i)){for(o=0,a=Sm(t);a>o;o++)if((u=y(t[o]))&&Am(Cm,u))return u;return new Lm(!1)}n=jm(t,i)}for(s=n.next;!(c=Em(s,n)).done;){try{u=y(c.value)}catch(t){Im(n,"throw",t)}if("object"==typeof u&&u&&Am(Cm,u))return u}return new Lm(!1)},Mm=et,Fm=o.TypeError,Nm=function(t,e){if(Mm(e,t))return t;throw Fm("Incorrect invocation")},zm=Tr,qm=o,Ym=Qg.exports,Gm=a,Xm=hr,Um=Rm,Wm=Nm,Vm=b,Hm=$,$m=hu,Bm=Ve.f,Jm=bi.forEach,Km=w,Qm=Yo.set,Zm=Yo.getterFor,tb=function(t,e,r){var n,i=-1!==t.indexOf("Map"),o=-1!==t.indexOf("Weak"),a=i?"set":"add",u=qm[t],s=u&&u.prototype,c={};if(Km&&Vm(u)&&(o||s.forEach&&!Gm((function(){(new u).entries().next()})))){var f=(n=e((function(e,r){Qm(Wm(e,f),{type:t,collection:new u}),null!=r&&Um(r,e[a],{that:e,AS_ENTRIES:i})}))).prototype,l=Zm(t);Jm(["add","clear","delete","forEach","get","has","set","keys","values","entries"],(function(t){var e="add"==t||"set"==t;!(t in s)||o&&"clear"==t||Xm(f,t,(function(r,n){var i=l(this).collection;if(!e&&o&&!Hm(r))return"get"==t&&void 0;var a=i[t](0===r?0:r,n);return e?this:a}))})),o||Bm(f,"size",{configurable:!0,get:function(){return l(this).collection.size}})}else n=r.getConstructor(e,t,i,a),Ym.enable();return $m(n,t,!1,!0),c[t]=n,zm({global:!0,forced:!0},c),o||r.setStrong(n,t,i),n},eb=$a,rb=tt,nb=Ve,ib=w,ob=ae("species"),ab=Ve.f,ub=Ma,sb=function(t,e,r){for(var n in e)r&&r.unsafe&&t[n]?t[n]=e[n]:eb(t,n,e[n],r);return t},cb=We,fb=Nm,lb=Rm,hb=Gu,pb=function(t){var e=rb(t),r=nb.f;ib&&e&&!e[ob]&&r(e,ob,{configurable:!0,get:function(){return this}})},vb=w,db=Qg.exports.fastKey,yb=Yo.set,gb=Yo.getterFor,mb={getConstructor:function(t,e,r,n){var i=t((function(t,i){fb(t,o),yb(t,{type:e,index:ub(null),first:void 0,last:void 0,size:0}),vb||(t.size=0),null!=i&&lb(i,t[n],{that:t,AS_ENTRIES:r})})),o=i.prototype,a=gb(e),u=function(t,e,r){var n,i,o=a(t),u=s(t,e);return u?u.value=r:(o.last=u={index:i=db(e,!0),key:e,value:r,previous:n=o.last,next:void 0,removed:!1},o.first||(o.first=u),n&&(n.next=u),vb?o.size++:t.size++,"F"!==i&&(o.index[i]=u)),t},s=function(t,e){var r,n=a(t),i=db(e);if("F"!==i)return n.index[i];for(r=n.first;r;r=r.next)if(r.key==e)return r};return sb(o,{clear:function(){for(var t=a(this),e=t.index,r=t.first;r;)r.removed=!0,r.previous&&(r.previous=r.previous.next=void 0),delete e[r.index],r=r.next;t.first=t.last=void 0,vb?t.size=0:this.size=0},delete:function(t){var e=this,r=a(e),n=s(e,t);if(n){var i=n.next,o=n.previous;delete r.index[n.index],n.removed=!0,o&&(o.next=i),i&&(i.previous=o),r.first==n&&(r.first=i),r.last==n&&(r.last=o),vb?r.size--:e.size--}return!!n},forEach:function(t){for(var e,r=a(this),n=cb(t,arguments.length>1?arguments[1]:void 0);e=e?e.next:r.first;)for(n(e.value,e.key,this);e&&e.removed;)e=e.previous},has:function(t){return!!s(this,t)}}),sb(o,r?{get:function(t){var e=s(this,t);return e&&e.value},set:function(t,e){return u(this,0===t?0:t,e)}}:{add:function(t){return u(this,t=0===t?0:t,t)}}),vb&&ab(o,"size",{get:function(){return a(this).size}}),i},setStrong:function(t,e,r){var n=e+" Iterator",i=gb(e),o=gb(n);hb(t,e,(function(t,e){yb(this,{type:n,target:t,state:i(t),kind:e,last:void 0})}),(function(){for(var t=o(this),e=t.kind,r=t.last;r&&r.removed;)r=r.previous;return t.target&&(t.last=r=r?r.next:t.state.first)?"keys"==e?{value:r.key,done:!1}:"values"==e?{value:r.value,done:!1}:{value:[r.key,r.value],done:!1}:(t.target=void 0,{value:void 0,done:!0})}),r?"entries":"values",!r,!0),pb(e)}};tb("Map",(function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}}),mb);var bb=B.Map,_b=bi.some;Tr({target:"Array",proto:!0,forced:!mn("some")},{some:function(t){return _b(this,t,arguments.length>1?arguments[1]:void 0)}});var wb=Jr("Array").some,Ob=et,Eb=wb,Tb=Array.prototype,xb=function(t){var e=t.some;return t===Tb||Ob(Tb,t)&&e===Tb.some?Eb:e},kb=Jr("Array").keys,Sb=zn,Ab=Ut,jb=et,Pb=kb,Ib=Array.prototype,Db={DOMTokenList:!0,NodeList:!0},Lb=function(t){var e=t.keys;return t===Ib||jb(Ib,t)&&e===Ib.keys||Ab(Db,Sb(t))?Pb:e},Cb=vc,Rb=Math.floor,Mb=function(t,e){var r=t.length,n=Rb(r/2);return r<8?Fb(t,e):Nb(t,Mb(Cb(t,0,n),e),Mb(Cb(t,n),e),e)},Fb=function(t,e){for(var r,n,i=t.length,o=1;o<i;){for(n=o,r=t[o];n&&e(t[n-1],r)>0;)t[n]=t[--n];n!==o++&&(t[n]=r)}return t},Nb=function(t,e,r,n){for(var i=e.length,o=r.length,a=0,u=0;a<i||u<o;)t[a+u]=a<i&&u<o?n(e[a],r[u])<=0?e[a++]:r[u++]:a<i?e[a++]:r[u++];return t},zb=Mb,qb=rt.match(/firefox\/(\d+)/i),Yb=!!qb&&+qb[1],Gb=/MSIE|Trident/.test(rt),Xb=rt.match(/AppleWebKit\/(\d+)\./),Ub=!!Xb&&+Xb[1],Wb=Tr,Vb=m,Hb=xt,$b=Yt,Bb=cn,Jb=io,Kb=a,Qb=zb,Zb=mn,t_=Yb,e_=Gb,r_=ct,n_=Ub,i_=[],o_=Vb(i_.sort),a_=Vb(i_.push),u_=Kb((function(){i_.sort(void 0)})),s_=Kb((function(){i_.sort(null)})),c_=Zb("sort"),f_=!Kb((function(){if(r_)return r_<70;if(!(t_&&t_>3)){if(e_)return!0;if(n_)return n_<603;var t,e,r,n,i="";for(t=65;t<76;t++){switch(e=String.fromCharCode(t),t){case 66:case 69:case 70:case 72:r=3;break;case 68:case 71:r=4;break;default:r=2}for(n=0;n<47;n++)i_.push({k:e+n,v:r})}for(i_.sort((function(t,e){return e.v-t.v})),n=0;n<i_.length;n++)e=i_[n].k.charAt(0),i.charAt(i.length-1)!==e&&(i+=e);return"DGBEFHACIJK"!==i}}));Wb({target:"Array",proto:!0,forced:u_||!s_||!c_||!f_},{sort:function(t){void 0!==t&&Hb(t);var e=$b(this);if(f_)return void 0===t?o_(e):o_(e,t);var r,n,i=[],o=Bb(e);for(n=0;n<o;n++)n in e&&a_(i,e[n]);for(Qb(i,function(t){return function(e,r){return void 0===r?-1:void 0===e?1:void 0!==t?+t(e,r)||0:Jb(e)>Jb(r)?1:-1}}(t)),r=i.length,n=0;n<r;)e[n]=i[n++];for(;n<o;)delete e[n++];return e}});var l_,h_=Jr("Array").sort,p_=et,v_=h_,d_=Array.prototype,y_=function(t){var e=t.sort;return t===d_||p_(d_,t)&&e===d_.sort?v_:e},g_=Jr("Array").values,m_=zn,b_=Ut,__=et,w_=g_,O_=Array.prototype,E_={DOMTokenList:!0,NodeList:!0},T_=function(t){var e=t.values;return t===O_||__(O_,t)&&e===O_.values||b_(E_,m_(t))?w_:e},x_=mh,k_=Jr("Array").entries,S_=zn,A_=Ut,j_=et,P_=k_,I_=Array.prototype,D_={DOMTokenList:!0,NodeList:!0},L_=function(t){var e=t.entries;return t===I_||j_(I_,t)&&e===I_.entries||A_(D_,S_(t))?P_:e},C_=new Uint8Array(16);function R_(){if(!l_&&!(l_="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return l_(C_)}var M_=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function F_(t){return"string"==typeof t&&M_.test(t)}for(var N_=[],z_=0;z_<256;++z_)N_.push((z_+256).toString(16).substr(1));function q_(t,e,r){var n=(t=t||{}).random||(t.rng||R_)();if(n[6]=15&n[6]|64,n[8]=63&n[8]|128,e){r=r||0;for(var i=0;i<16;++i)e[r+i]=n[i];return e}return function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=(N_[t[e+0]]+N_[t[e+1]]+N_[t[e+2]]+N_[t[e+3]]+"-"+N_[t[e+4]]+N_[t[e+5]]+"-"+N_[t[e+6]]+N_[t[e+7]]+"-"+N_[t[e+8]]+N_[t[e+9]]+"-"+N_[t[e+10]]+N_[t[e+11]]+N_[t[e+12]]+N_[t[e+13]]+N_[t[e+14]]+N_[t[e+15]]).toLowerCase();if(!F_(r))throw TypeError("Stringified UUID is invalid");return r}(n)}function Y_(t){return"string"==typeof t||"number"==typeof t}var G_=function(){function t(r){e(this,t),Cr(this,"delay",void 0),Cr(this,"max",void 0),Cr(this,"_queue",[]),Cr(this,"_timeout",null),Cr(this,"_extended",null),this.delay=null,this.max=1/0,this.setOptions(r)}return Lr(t,[{key:"setOptions",value:function(t){t&&void 0!==t.delay&&(this.delay=t.delay),t&&void 0!==t.max&&(this.max=t.max),this._flushIfNeeded()}},{key:"destroy",value:function(){if(this.flush(),this._extended){for(var t=this._extended.object,e=this._extended.methods,r=0;r<e.length;r++){var n=e[r];n.original?t[n.name]=n.original:delete t[n.name]}this._extended=null}}},{key:"replace",value:function(t,e){var r=this,n=t[e];if(!n)throw new Error("Method "+e+" undefined");t[e]=function(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];r.queue({args:e,fn:n,context:this})}}},{key:"queue",value:function(t){"function"==typeof t?this._queue.push({fn:t}):this._queue.push(t),this._flushIfNeeded()}},{key:"_flushIfNeeded",value:function(){var t=this;this._queue.length>this.max&&this.flush(),null!=this._timeout&&(clearTimeout(this._timeout),this._timeout=null),this.queue.length>0&&"number"==typeof this.delay&&(this._timeout=bd((function(){t.flush()}),this.delay))}},{key:"flush",value:function(){var t,e;Hh(t=wp(e=this._queue).call(e,0)).call(t,(function(t){t.fn.apply(t.context||t.fn,t.args||[])}))}}],[{key:"extend",value:function(e,r){var n=new t(r);if(void 0!==e.flush)throw new Error("Target object already has a property flush");e.flush=function(){n.flush()};var i=[{name:"flush",original:void 0}];if(r&&r.replace)for(var o=0;o<r.replace.length;o++){var a=r.replace[o];i.push({name:a,original:e[a]}),n.replace(e,a)}return n._extended={object:e,methods:i},n}}]),t}(),X_=function(){function t(){e(this,t),Cr(this,"_subscribers",{"*":[],add:[],remove:[],update:[]}),Cr(this,"subscribe",t.prototype.on),Cr(this,"unsubscribe",t.prototype.off)}return Lr(t,[{key:"_trigger",value:function(t,e,r){var n,i;if("*"===t)throw new Error("Cannot trigger event *");Hh(n=Sh(i=[]).call(i,wh(this._subscribers[t]),wh(this._subscribers["*"]))).call(n,(function(n){n(t,e,null!=r?r:null)}))}},{key:"on",value:function(t,e){"function"==typeof e&&this._subscribers[t].push(e)}},{key:"off",value:function(t,e){var r;this._subscribers[t]=ji(r=this._subscribers[t]).call(r,(function(t){return t!==e}))}}]),t}();tb("Set",(function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}}),mb);var U_,W_=B.Set,V_=ws;function H_(t,e){var r=void 0!==Oh&&ic(t)||t["@@iterator"];if(!r){if(Ph(t)||(r=function(t,e){var r;if(!t)return;if("string"==typeof t)return $_(t,e);var n=Ah(r=Object.prototype.toString.call(t)).call(r,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return qs(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return $_(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,i=function(){};return{s:i,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){r=r.call(t)},n:function(){var t=r.next();return a=t.done,t},e:function(t){u=!0,o=t},f:function(){try{a||null==r.return||r.return()}finally{if(u)throw o}}}}function $_(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}U_=x_;var B_=function(){function t(r){e(this,t),Cr(this,"_pairs",void 0),this._pairs=r}return Lr(t,[{key:U_,value:Kg.mark((function t(){var e,r,n,i,o;return Kg.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:e=H_(this._pairs),t.prev=1,e.s();case 3:if((r=e.n()).done){t.next=9;break}return n=gh(r.value,2),i=n[0],o=n[1],t.next=7,[i,o];case 7:t.next=3;break;case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),e.e(t.t0);case 14:return t.prev=14,e.f(),t.finish(14);case 17:case"end":return t.stop()}}),t,this,[[1,11,14,17]])}))},{key:"entries",value:Kg.mark((function t(){var e,r,n,i,o;return Kg.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:e=H_(this._pairs),t.prev=1,e.s();case 3:if((r=e.n()).done){t.next=9;break}return n=gh(r.value,2),i=n[0],o=n[1],t.next=7,[i,o];case 7:t.next=3;break;case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),e.e(t.t0);case 14:return t.prev=14,e.f(),t.finish(14);case 17:case"end":return t.stop()}}),t,this,[[1,11,14,17]])}))},{key:"keys",value:Kg.mark((function t(){var e,r,n,i;return Kg.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:e=H_(this._pairs),t.prev=1,e.s();case 3:if((r=e.n()).done){t.next=9;break}return n=gh(r.value,1),i=n[0],t.next=7,i;case 7:t.next=3;break;case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),e.e(t.t0);case 14:return t.prev=14,e.f(),t.finish(14);case 17:case"end":return t.stop()}}),t,this,[[1,11,14,17]])}))},{key:"values",value:Kg.mark((function t(){var e,r,n,i;return Kg.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:e=H_(this._pairs),t.prev=1,e.s();case 3:if((r=e.n()).done){t.next=9;break}return n=gh(r.value,2),i=n[1],t.next=7,i;case 7:t.next=3;break;case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),e.e(t.t0);case 14:return t.prev=14,e.f(),t.finish(14);case 17:case"end":return t.stop()}}),t,this,[[1,11,14,17]])}))},{key:"toIdArray",value:function(){var t;return Ri(t=wh(this._pairs)).call(t,(function(t){return t[0]}))}},{key:"toItemArray",value:function(){var t;return Ri(t=wh(this._pairs)).call(t,(function(t){return t[1]}))}},{key:"toEntryArray",value:function(){return wh(this._pairs)}},{key:"toObjectMap",value:function(){var t,e=Yv(null),r=H_(this._pairs);try{for(r.s();!(t=r.n()).done;){var n=gh(t.value,2),i=n[0],o=n[1];e[i]=o}}catch(t){r.e(t)}finally{r.f()}return e}},{key:"toMap",value:function(){return new bb(this._pairs)}},{key:"toIdSet",value:function(){return new W_(this.toIdArray())}},{key:"toItemSet",value:function(){return new W_(this.toItemArray())}},{key:"cache",value:function(){return new t(wh(this._pairs))}},{key:"distinct",value:function(t){var e,r=new W_,n=H_(this._pairs);try{for(n.s();!(e=n.n()).done;){var i=gh(e.value,2),o=i[0],a=i[1];r.add(t(a,o))}}catch(t){n.e(t)}finally{n.f()}return r}},{key:"filter",value:function(e){var r=this._pairs;return new t(Cr({},x_,Kg.mark((function t(){var n,i,o,a,u;return Kg.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:n=H_(r),t.prev=1,n.s();case 3:if((i=n.n()).done){t.next=10;break}if(o=gh(i.value,2),a=o[0],u=o[1],!e(u,a)){t.next=8;break}return t.next=8,[a,u];case 8:t.next=3;break;case 10:t.next=15;break;case 12:t.prev=12,t.t0=t.catch(1),n.e(t.t0);case 15:return t.prev=15,n.f(),t.finish(15);case 18:case"end":return t.stop()}}),t,null,[[1,12,15,18]])}))))}},{key:"forEach",value:function(t){var e,r=H_(this._pairs);try{for(r.s();!(e=r.n()).done;){var n=gh(e.value,2),i=n[0];t(n[1],i)}}catch(t){r.e(t)}finally{r.f()}}},{key:"map",value:function(e){var r=this._pairs;return new t(Cr({},x_,Kg.mark((function t(){var n,i,o,a,u;return Kg.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:n=H_(r),t.prev=1,n.s();case 3:if((i=n.n()).done){t.next=9;break}return o=gh(i.value,2),a=o[0],u=o[1],t.next=7,[a,e(u,a)];case 7:t.next=3;break;case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),n.e(t.t0);case 14:return t.prev=14,n.f(),t.finish(14);case 17:case"end":return t.stop()}}),t,null,[[1,11,14,17]])}))))}},{key:"max",value:function(t){var e=V_(this._pairs),r=e.next();if(r.done)return null;for(var n=r.value[1],i=t(r.value[1],r.value[0]);!(r=e.next()).done;){var o=gh(r.value,2),a=o[0],u=o[1],s=t(u,a);s>i&&(i=s,n=u)}return n}},{key:"min",value:function(t){var e=V_(this._pairs),r=e.next();if(r.done)return null;for(var n=r.value[1],i=t(r.value[1],r.value[0]);!(r=e.next()).done;){var o=gh(r.value,2),a=o[0],u=o[1],s=t(u,a);s<i&&(i=s,n=u)}return n}},{key:"reduce",value:function(t,e){var r,n=H_(this._pairs);try{for(n.s();!(r=n.n()).done;){var i=gh(r.value,2),o=i[0];e=t(e,i[1],o)}}catch(t){n.e(t)}finally{n.f()}return e}},{key:"sort",value:function(e){var r=this;return new t(Cr({},x_,(function(){var t;return V_(y_(t=wh(r._pairs)).call(t,(function(t,r){var n=gh(t,2),i=n[0],o=n[1],a=gh(r,2),u=a[0],s=a[1];return e(o,s,i,u)})))})))}}]),t}();function J_(t,e){var r=Lh(t);if($f){var n=$f(t);e&&(n=ji(n).call(n,(function(e){return il(t,e).enumerable}))),r.push.apply(r,n)}return r}function K_(t){for(var e=1;e<arguments.length;e++){var r,n,i=null!=arguments[e]?arguments[e]:{};e%2?Hh(r=J_(Object(i),!0)).call(r,(function(e){Cr(t,e,i[e])})):dl?Ol(t,dl(i)):Hh(n=J_(Object(i))).call(n,(function(e){El(t,e,il(i,e))}))}return t}function Q_(t,e){var r=void 0!==Oh&&ic(t)||t["@@iterator"];if(!r){if(Ph(t)||(r=function(t,e){var r;if(!t)return;if("string"==typeof t)return Z_(t,e);var n=Ah(r=Object.prototype.toString.call(t)).call(r,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return qs(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return Z_(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,i=function(){};return{s:i,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){r=r.call(t)},n:function(){var t=r.next();return a=t.done,t},e:function(t){u=!0,o=t},f:function(){try{a||null==r.return||r.return()}finally{if(u)throw o}}}}function Z_(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function tw(t){var e=function(){if("undefined"==typeof Reflect||!Yg)return!1;if(Yg.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Yg(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=Bg(t);if(e){var i=Bg(this).constructor;r=Yg(n,arguments,i)}else r=n.apply(this,arguments);return Hg(this,r)}}var ew=function(t){Vg(n,t);var r=tw(n);function n(t,i){var o;return e(this,n),Cr(Gg(o=r.call(this)),"flush",void 0),Cr(Gg(o),"length",void 0),Cr(Gg(o),"_options",void 0),Cr(Gg(o),"_data",void 0),Cr(Gg(o),"_idProp",void 0),Cr(Gg(o),"_queue",null),t&&!Ph(t)&&(i=t,t=[]),o._options=i||{},o._data=new bb,o.length=0,o._idProp=o._options.fieldId||"id",t&&t.length&&o.add(t),o.setOptions(i),o}return Lr(n,[{key:"idProp",get:function(){return this._idProp}},{key:"setOptions",value:function(t){t&&void 0!==t.queue&&(!1===t.queue?this._queue&&(this._queue.destroy(),this._queue=null):(this._queue||(this._queue=G_.extend(this,{replace:["add","update","remove"]})),t.queue&&"object"===_h(t.queue)&&this._queue.setOptions(t.queue)))}},{key:"add",value:function(t,e){var r,n=this,i=[];if(Ph(t)){var o=Ri(t).call(t,(function(t){return t[n._idProp]}));if(xb(o).call(o,(function(t){return n._data.has(t)})))throw new Error("A duplicate id was found in the parameter array.");for(var a=0,u=t.length;a<u;a++)r=this._addItem(t[a]),i.push(r)}else{if(!t||"object"!==_h(t))throw new Error("Unknown dataType");r=this._addItem(t),i.push(r)}return i.length&&this._trigger("add",{items:i},e),i}},{key:"update",value:function(t,e){var r=this,n=[],i=[],o=[],a=[],u=this._idProp,s=function(t){var e=t[u];if(null!=e&&r._data.has(e)){var s=t,c=Mp({},r._data.get(e)),f=r._updateItem(s);i.push(f),a.push(s),o.push(c)}else{var l=r._addItem(t);n.push(l)}};if(Ph(t))for(var c=0,f=t.length;c<f;c++)t[c]&&"object"===_h(t[c])?s(t[c]):console.warn("Ignoring input item, which is not an object at index "+c);else{if(!t||"object"!==_h(t))throw new Error("Unknown dataType");s(t)}if(n.length&&this._trigger("add",{items:n},e),i.length){var l={items:i,oldData:o,data:a};this._trigger("update",l,e)}return Sh(n).call(n,i)}},{key:"updateOnly",value:function(t,e){var r,n=this;Ph(t)||(t=[t]);var i=Ri(r=Ri(t).call(t,(function(t){var e=n._data.get(t[n._idProp]);if(null==e)throw new Error("Updating non-existent items is not allowed.");return{oldData:e,update:t}}))).call(r,(function(t){var e=t.oldData,r=t.update,i=e[n._idProp],o=function(t){for(var e,r=arguments.length,n=new Array(r>1?r-1:0),i=1;i<r;i++)n[i-1]=arguments[i];return mg.apply(void 0,Sh(e=[{},t]).call(e,n))}(e,r);return n._data.set(i,o),{id:i,oldData:e,updatedData:o}}));if(i.length){var o={items:Ri(i).call(i,(function(t){return t.id})),oldData:Ri(i).call(i,(function(t){return t.oldData})),data:Ri(i).call(i,(function(t){return t.updatedData}))};return this._trigger("update",o,e),o.items}return[]}},{key:"get",value:function(t,e){var r=void 0,n=void 0,i=void 0;Y_(t)?(r=t,i=e):Ph(t)?(n=t,i=e):i=t;var o,a=i&&"Object"===i.returnType?"Object":"Array",u=i&&ji(i),s=[],c=void 0,f=void 0,l=void 0;if(null!=r)(c=this._data.get(r))&&u&&!u(c)&&(c=void 0);else if(null!=n)for(var h=0,p=n.length;h<p;h++)null==(c=this._data.get(n[h]))||u&&!u(c)||s.push(c);else for(var v,d=0,y=(f=wh(Lb(v=this._data).call(v))).length;d<y;d++)l=f[d],null==(c=this._data.get(l))||u&&!u(c)||s.push(c);if(i&&i.order&&null==r&&this._sort(s,i.order),i&&i.fields){var g=i.fields;if(null!=r&&null!=c)c=this._filterFields(c,g);else for(var m=0,b=s.length;m<b;m++)s[m]=this._filterFields(s[m],g)}if("Object"==a){for(var _={},w=0,O=s.length;w<O;w++){var E=s[w];_[E[this._idProp]]=E}return _}return null!=r?null!==(o=c)&&void 0!==o?o:null:s}},{key:"getIds",value:function(t){var e=this._data,r=t&&ji(t),n=t&&t.order,i=wh(Lb(e).call(e)),o=[];if(r)if(n){for(var a=[],u=0,s=i.length;u<s;u++){var c=i[u],f=this._data.get(c);null!=f&&r(f)&&a.push(f)}this._sort(a,n);for(var l=0,h=a.length;l<h;l++)o.push(a[l][this._idProp])}else for(var p=0,v=i.length;p<v;p++){var d=i[p],y=this._data.get(d);null!=y&&r(y)&&o.push(y[this._idProp])}else if(n){for(var g=[],m=0,b=i.length;m<b;m++){var _=i[m];g.push(e.get(_))}this._sort(g,n);for(var w=0,O=g.length;w<O;w++)o.push(g[w][this._idProp])}else for(var E=0,T=i.length;E<T;E++){var x=i[E],k=e.get(x);null!=k&&o.push(k[this._idProp])}return o}},{key:"getDataSet",value:function(){return this}},{key:"forEach",value:function(t,e){var r=e&&ji(e),n=this._data,i=wh(Lb(n).call(n));if(e&&e.order)for(var o=this.get(e),a=0,u=o.length;a<u;a++){var s=o[a];t(s,s[this._idProp])}else for(var c=0,f=i.length;c<f;c++){var l=i[c],h=this._data.get(l);null==h||r&&!r(h)||t(h,l)}}},{key:"map",value:function(t,e){for(var r=e&&ji(e),n=[],i=this._data,o=wh(Lb(i).call(i)),a=0,u=o.length;a<u;a++){var s=o[a],c=this._data.get(s);null==c||r&&!r(c)||n.push(t(c,s))}return e&&e.order&&this._sort(n,e.order),n}},{key:"_filterFields",value:function(t,e){var r;return t?Sn(r=Ph(e)?e:Lh(e)).call(r,(function(e,r){return e[r]=t[r],e}),{}):t}},{key:"_sort",value:function(t,e){if("string"==typeof e){var r=e;y_(t).call(t,(function(t,e){var n=t[r],i=e[r];return n>i?1:n<i?-1:0}))}else{if("function"!=typeof e)throw new TypeError("Order must be a function or a string");y_(t).call(t,e)}}},{key:"remove",value:function(t,e){for(var r=[],n=[],i=Ph(t)?t:[t],o=0,a=i.length;o<a;o++){var u=this._remove(i[o]);if(u){var s=u[this._idProp];null!=s&&(r.push(s),n.push(u))}}return r.length&&this._trigger("remove",{items:r,oldData:n},e),r}},{key:"_remove",value:function(t){var e;if(Y_(t)?e=t:t&&"object"===_h(t)&&(e=t[this._idProp]),null!=e&&this._data.has(e)){var r=this._data.get(e)||null;return this._data.delete(e),--this.length,r}return null}},{key:"clear",value:function(t){for(var e,r=wh(Lb(e=this._data).call(e)),n=[],i=0,o=r.length;i<o;i++)n.push(this._data.get(r[i]));return this._data.clear(),this.length=0,this._trigger("remove",{items:r,oldData:n},t),r}},{key:"max",value:function(t){var e,r,n=null,i=null,o=Q_(T_(e=this._data).call(e));try{for(o.s();!(r=o.n()).done;){var a=r.value,u=a[t];"number"==typeof u&&(null==i||u>i)&&(n=a,i=u)}}catch(t){o.e(t)}finally{o.f()}return n||null}},{key:"min",value:function(t){var e,r,n=null,i=null,o=Q_(T_(e=this._data).call(e));try{for(o.s();!(r=o.n()).done;){var a=r.value,u=a[t];"number"==typeof u&&(null==i||u<i)&&(n=a,i=u)}}catch(t){o.e(t)}finally{o.f()}return n||null}},{key:"distinct",value:function(t){for(var e=this._data,r=wh(Lb(e).call(e)),n=[],i=0,o=0,a=r.length;o<a;o++){for(var u=r[o],s=e.get(u)[t],c=!1,f=0;f<i;f++)if(n[f]==s){c=!0;break}c||void 0===s||(n[i]=s,i++)}return n}},{key:"_addItem",value:function(t){var e=function(t,e){return null==t[e]&&(t[e]=q_()),t}(t,this._idProp),r=e[this._idProp];if(this._data.has(r))throw new Error("Cannot add item: item with id "+r+" already exists");return this._data.set(r,e),++this.length,r}},{key:"_updateItem",value:function(t){var e=t[this._idProp];if(null==e)throw new Error("Cannot update item: item has no id (item: "+sd(t)+")");var r=this._data.get(e);if(!r)throw new Error("Cannot update item: no item with id "+e+" found");return this._data.set(e,K_(K_({},r),t)),e}},{key:"stream",value:function(t){if(t){var e=this._data;return new B_(Cr({},x_,Kg.mark((function r(){var n,i,o,a;return Kg.wrap((function(r){for(;;)switch(r.prev=r.next){case 0:n=Q_(t),r.prev=1,n.s();case 3:if((i=n.n()).done){r.next=11;break}if(o=i.value,null==(a=e.get(o))){r.next=9;break}return r.next=9,[o,a];case 9:r.next=3;break;case 11:r.next=16;break;case 13:r.prev=13,r.t0=r.catch(1),n.e(r.t0);case 16:return r.prev=16,n.f(),r.finish(16);case 19:case"end":return r.stop()}}),r,null,[[1,13,16,19]])}))))}var r;return new B_(Cr({},x_,en(r=L_(this._data)).call(r,this._data)))}}]),n}(X_);function rw(t,e){var r=void 0!==Oh&&ic(t)||t["@@iterator"];if(!r){if(Ph(t)||(r=function(t,e){var r;if(!t)return;if("string"==typeof t)return nw(t,e);var n=Ah(r=Object.prototype.toString.call(t)).call(r,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return qs(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return nw(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,i=function(){};return{s:i,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){r=r.call(t)},n:function(){var t=r.next();return a=t.done,t},e:function(t){u=!0,o=t},f:function(){try{a||null==r.return||r.return()}finally{if(u)throw o}}}}function nw(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function iw(t){var e=function(){if("undefined"==typeof Reflect||!Yg)return!1;if(Yg.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Yg(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=Bg(t);if(e){var i=Bg(this).constructor;r=Yg(n,arguments,i)}else r=n.apply(this,arguments);return Hg(this,r)}}var ow=function(t){Vg(n,t);var r=iw(n);function n(t,i){var o,a;return e(this,n),Cr(Gg(a=r.call(this)),"length",0),Cr(Gg(a),"_listener",void 0),Cr(Gg(a),"_data",void 0),Cr(Gg(a),"_ids",new W_),Cr(Gg(a),"_options",void 0),a._options=i||{},a._listener=en(o=a._onEvent).call(o,Gg(a)),a.setData(t),a}return Lr(n,[{key:"idProp",get:function(){return this.getDataSet().idProp}},{key:"setData",value:function(t){if(this._data){this._data.off&&this._data.off("*",this._listener);var e=this._data.getIds({filter:ji(this._options)}),r=this._data.get(e);this._ids.clear(),this.length=0,this._trigger("remove",{items:e,oldData:r})}if(null!=t){this._data=t;for(var n=this._data.getIds({filter:ji(this._options)}),i=0,o=n.length;i<o;i++){var a=n[i];this._ids.add(a)}this.length=n.length,this._trigger("add",{items:n})}else this._data=new ew;this._data.on&&this._data.on("*",this._listener)}},{key:"refresh",value:function(){for(var t=this._data.getIds({filter:ji(this._options)}),e=wh(this._ids),r={},n=[],i=[],o=[],a=0,u=t.length;a<u;a++){var s=t[a];r[s]=!0,this._ids.has(s)||(n.push(s),this._ids.add(s))}for(var c=0,f=e.length;c<f;c++){var l=e[c],h=this._data.get(l);null==h?console.error("If you see this, report it please."):r[l]||(i.push(l),o.push(h),this._ids.delete(l))}this.length+=n.length-i.length,n.length&&this._trigger("add",{items:n}),i.length&&this._trigger("remove",{items:i,oldData:o})}},{key:"get",value:function(t,e){if(null==this._data)return null;var r,n=null;Y_(t)||Ph(t)?(n=t,r=e):r=t;var i=Mp({},this._options,r),o=ji(this._options),a=r&&ji(r);return o&&a&&(i.filter=function(t){return o(t)&&a(t)}),null==n?this._data.get(i):this._data.get(n,i)}},{key:"getIds",value:function(t){if(this._data.length){var e,r=ji(this._options),n=null!=t?ji(t):null;return e=n?r?function(t){return r(t)&&n(t)}:n:r,this._data.getIds({filter:e,order:t&&t.order})}return[]}},{key:"forEach",value:function(t,e){if(this._data){var r,n,i=ji(this._options),o=e&&ji(e);n=o?i?function(t){return i(t)&&o(t)}:o:i,Hh(r=this._data).call(r,t,{filter:n,order:e&&e.order})}}},{key:"map",value:function(t,e){if(this._data){var r,n,i=ji(this._options),o=e&&ji(e);return n=o?i?function(t){return i(t)&&o(t)}:o:i,Ri(r=this._data).call(r,t,{filter:n,order:e&&e.order})}return[]}},{key:"getDataSet",value:function(){return this._data.getDataSet()}},{key:"stream",value:function(t){var e;return this._data.stream(t||Cr({},x_,en(e=Lb(this._ids)).call(e,this._ids)))}},{key:"dispose",value:function(){var t;null!==(t=this._data)&&void 0!==t&&t.off&&this._data.off("*",this._listener);var e,r="This data view has already been disposed of.",i={get:function(){throw new Error(r)},set:function(){throw new Error(r)},configurable:!1},o=rw(jh(n.prototype));try{for(o.s();!(e=o.n()).done;){var a=e.value;El(this,a,i)}}catch(t){o.e(t)}finally{o.f()}}},{key:"_onEvent",value:function(t,e,r){if(e&&e.items&&this._data){var n=e.items,i=[],o=[],a=[],u=[],s=[],c=[];switch(t){case"add":for(var f=0,l=n.length;f<l;f++){var h=n[f];this.get(h)&&(this._ids.add(h),i.push(h))}break;case"update":for(var p=0,v=n.length;p<v;p++){var d=n[p];this.get(d)?this._ids.has(d)?(o.push(d),s.push(e.data[p]),u.push(e.oldData[p])):(this._ids.add(d),i.push(d)):this._ids.has(d)&&(this._ids.delete(d),a.push(d),c.push(e.oldData[p]))}break;case"remove":for(var y=0,g=n.length;y<g;y++){var m=n[y];this._ids.has(m)&&(this._ids.delete(m),a.push(m),c.push(e.oldData[y]))}}this.length+=i.length-a.length,i.length&&this._trigger("add",{items:i},r),o.length&&this._trigger("update",{items:o,oldData:u,data:s},r),a.length&&this._trigger("remove",{items:a,oldData:c},r)}}}]),n}(X_);function aw(t,e){return"object"===_h(e)&&null!==e&&t===e.idProp&&"function"==typeof e.add&&"function"==typeof e.clear&&"function"==typeof e.distinct&&"function"==typeof Hh(e)&&"function"==typeof e.get&&"function"==typeof e.getDataSet&&"function"==typeof e.getIds&&"number"==typeof e.length&&"function"==typeof Ri(e)&&"function"==typeof e.max&&"function"==typeof e.min&&"function"==typeof e.off&&"function"==typeof e.on&&"function"==typeof e.remove&&"function"==typeof e.setOptions&&"function"==typeof e.stream&&"function"==typeof e.update&&"function"==typeof e.updateOnly}t.DELETE=gg,t.DataSet=ew,t.DataStream=B_,t.DataView=ow,t.Queue=G_,t.createNewDataPipeFrom=function(t){return new eo(t)},t.isDataSetLike=aw,t.isDataViewLike=function(t,e){return"object"===_h(e)&&null!==e&&t===e.idProp&&"function"==typeof Hh(e)&&"function"==typeof e.get&&"function"==typeof e.getDataSet&&"function"==typeof e.getIds&&"number"==typeof e.length&&"function"==typeof Ri(e)&&"function"==typeof e.off&&"function"==typeof e.on&&"function"==typeof e.stream&&aw(t,e.getDataSet())},Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=vis-data.min.js.map


/***/ }),

/***/ "./node_modules/vis-network/peer/umd/vis-network.min.js":
/*!**************************************************************!*\
  !*** ./node_modules/vis-network/peer/umd/vis-network.min.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/**
 * vis-network
 * https://visjs.github.io/vis-network/
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 9.0.4
 * @date    2021-03-16T05:41:40.818Z
 *
 * @copyright (c) 2011-2017 Almende B.V, http://almende.com
 * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs
 *
 * @license
 * vis.js is dual licensed under both
 *
 *   1. The Apache 2.0 License
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   and
 *
 *   2. The MIT License
 *      http://opensource.org/licenses/MIT
 *
 * vis.js may be distributed under either license.
 */
!function(t,e){ true?e(exports,__webpack_require__(/*! vis-data/peer/umd/vis-data.js */ "./node_modules/vis-data/peer/umd/vis-data.js")):0}(this,(function(t,e){var i="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self?self:{};function o(t){var e={exports:{}};return t(e,e.exports),e.exports}var n=function(t){return t&&t.Math==Math&&t},r=n("object"==typeof globalThis&&globalThis)||n("object"==typeof window&&window)||n("object"==typeof self&&self)||n("object"==typeof i&&i)||function(){return this}()||Function("return this")(),s=function(t){try{return!!t()}catch(t){return!0}},a=!s((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),h={}.propertyIsEnumerable,d=Object.getOwnPropertyDescriptor,l={f:d&&!h.call({1:2},1)?function(t){var e=d(this,t);return!!e&&e.enumerable}:h},c=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}},u={}.toString,f=function(t){return u.call(t).slice(8,-1)},p="".split,v=s((function(){return!Object("z").propertyIsEnumerable(0)}))?function(t){return"String"==f(t)?p.call(t,""):Object(t)}:Object,g=function(t){if(null==t)throw TypeError("Can't call method on "+t);return t},y=function(t){return v(g(t))},m=function(t){return"object"==typeof t?null!==t:"function"==typeof t},b=function(t,e){if(!m(t))return t;var i,o;if(e&&"function"==typeof(i=t.toString)&&!m(o=i.call(t)))return o;if("function"==typeof(i=t.valueOf)&&!m(o=i.call(t)))return o;if(!e&&"function"==typeof(i=t.toString)&&!m(o=i.call(t)))return o;throw TypeError("Can't convert object to primitive value")},w={}.hasOwnProperty,k=function(t,e){return w.call(t,e)},_=r.document,x=m(_)&&m(_.createElement),E=function(t){return x?_.createElement(t):{}},O=!a&&!s((function(){return 7!=Object.defineProperty(E("div"),"a",{get:function(){return 7}}).a})),C=Object.getOwnPropertyDescriptor,S={f:a?C:function(t,e){if(t=y(t),e=b(e,!0),O)try{return C(t,e)}catch(t){}if(k(t,e))return c(!l.f.call(t,e),t[e])}},T=/#|\.prototype\./,M=function(t,e){var i=D[P(t)];return i==I||i!=B&&("function"==typeof e?s(e):!!e)},P=M.normalize=function(t){return String(t).replace(T,".").toLowerCase()},D=M.data={},B=M.NATIVE="N",I=M.POLYFILL="P",z=M,F={},N=function(t){if("function"!=typeof t)throw TypeError(String(t)+" is not a function");return t},A=function(t,e,i){if(N(t),void 0===e)return t;switch(i){case 0:return function(){return t.call(e)};case 1:return function(i){return t.call(e,i)};case 2:return function(i,o){return t.call(e,i,o)};case 3:return function(i,o,n){return t.call(e,i,o,n)}}return function(){return t.apply(e,arguments)}},R=function(t){if(!m(t))throw TypeError(String(t)+" is not an object");return t},j=Object.defineProperty,L={f:a?j:function(t,e,i){if(R(t),e=b(e,!0),R(i),O)try{return j(t,e,i)}catch(t){}if("get"in i||"set"in i)throw TypeError("Accessors not supported");return"value"in i&&(t[e]=i.value),t}},H=a?function(t,e,i){return L.f(t,e,c(1,i))}:function(t,e,i){return t[e]=i,t},W=S.f,V=function(t){var e=function(e,i,o){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(e);case 2:return new t(e,i)}return new t(e,i,o)}return t.apply(this,arguments)};return e.prototype=t.prototype,e},q=function(t,e){var i,o,n,s,a,h,d,l,c=t.target,u=t.global,f=t.stat,p=t.proto,v=u?r:f?r[c]:(r[c]||{}).prototype,g=u?F:F[c]||(F[c]={}),y=g.prototype;for(n in e)i=!z(u?n:c+(f?".":"#")+n,t.forced)&&v&&k(v,n),a=g[n],i&&(h=t.noTargetGet?(l=W(v,n))&&l.value:v[n]),s=i&&h?h:e[n],i&&typeof a==typeof s||(d=t.bind&&i?A(s,r):t.wrap&&i?V(s):p&&"function"==typeof s?A(Function.call,s):s,(t.sham||s&&s.sham||a&&a.sham)&&H(d,"sham",!0),g[n]=d,p&&(k(F,o=c+"Prototype")||H(F,o,{}),F[o][n]=s,t.real&&y&&!y[n]&&H(y,n,s)))},U=Math.ceil,Y=Math.floor,X=function(t){return isNaN(t=+t)?0:(t>0?Y:U)(t)},G=Math.min,K=function(t){return t>0?G(X(t),9007199254740991):0},$=Math.max,Q=Math.min,Z=function(t,e){var i=X(t);return i<0?$(i+e,0):Q(i,e)},J=function(t){return function(e,i,o){var n,r=y(e),s=K(r.length),a=Z(o,s);if(t&&i!=i){for(;s>a;)if((n=r[a++])!=n)return!0}else for(;s>a;a++)if((t||a in r)&&r[a]===i)return t||a||0;return!t&&-1}},tt={includes:J(!0),indexOf:J(!1)},et={},it=tt.indexOf,ot=function(t,e){var i,o=y(t),n=0,r=[];for(i in o)!k(et,i)&&k(o,i)&&r.push(i);for(;e.length>n;)k(o,i=e[n++])&&(~it(r,i)||r.push(i));return r},nt=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],rt=Object.keys||function(t){return ot(t,nt)},st={f:Object.getOwnPropertySymbols},at=function(t){return Object(g(t))},ht=Object.assign,dt=Object.defineProperty,lt=!ht||s((function(){if(a&&1!==ht({b:1},ht(dt({},"a",{enumerable:!0,get:function(){dt(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var t={},e={},i=Symbol(),o="abcdefghijklmnopqrst";return t[i]=7,o.split("").forEach((function(t){e[t]=t})),7!=ht({},t)[i]||rt(ht({},e)).join("")!=o}))?function(t,e){for(var i=at(t),o=arguments.length,n=1,r=st.f,s=l.f;o>n;)for(var h,d=v(arguments[n++]),c=r?rt(d).concat(r(d)):rt(d),u=c.length,f=0;u>f;)h=c[f++],a&&!s.call(d,h)||(i[h]=d[h]);return i}:ht;q({target:"Object",stat:!0,forced:Object.assign!==lt},{assign:lt});var ct=F.Object.assign,ut=[].slice,ft={},pt=function(t,e,i){if(!(e in ft)){for(var o=[],n=0;n<e;n++)o[n]="a["+n+"]";ft[e]=Function("C,a","return new C("+o.join(",")+")")}return ft[e](t,i)},vt=Function.bind||function(t){var e=N(this),i=ut.call(arguments,1),o=function(){var n=i.concat(ut.call(arguments));return this instanceof o?pt(e,n.length,n):e.apply(t,n)};return m(e.prototype)&&(o.prototype=e.prototype),o};q({target:"Function",proto:!0},{bind:vt});var gt=function(t){return F[t+"Prototype"]},yt=gt("Function").bind,mt=Function.prototype,bt=function(t){var e=t.bind;return t===mt||t instanceof Function&&e===mt.bind?yt:e};function wt(t,e,i,o){t.beginPath(),t.arc(e,i,o,0,2*Math.PI,!1),t.closePath()}function kt(t,e,i,o,n,r){var s=Math.PI/180;o-2*r<0&&(r=o/2),n-2*r<0&&(r=n/2),t.beginPath(),t.moveTo(e+r,i),t.lineTo(e+o-r,i),t.arc(e+o-r,i+r,r,270*s,360*s,!1),t.lineTo(e+o,i+n-r),t.arc(e+o-r,i+n-r,r,0,90*s,!1),t.lineTo(e+r,i+n),t.arc(e+r,i+n-r,r,90*s,180*s,!1),t.lineTo(e,i+r),t.arc(e+r,i+r,r,180*s,270*s,!1),t.closePath()}function _t(t,e,i,o,n){var r=.5522848,s=o/2*r,a=n/2*r,h=e+o,d=i+n,l=e+o/2,c=i+n/2;t.beginPath(),t.moveTo(e,c),t.bezierCurveTo(e,c-a,l-s,i,l,i),t.bezierCurveTo(l+s,i,h,c-a,h,c),t.bezierCurveTo(h,c+a,l+s,d,l,d),t.bezierCurveTo(l-s,d,e,c+a,e,c),t.closePath()}function xt(t,e,i,o,n){var r=n*(1/3),s=.5522848,a=o/2*s,h=r/2*s,d=e+o,l=i+r,c=e+o/2,u=i+r/2,f=i+(n-r/2),p=i+n;t.beginPath(),t.moveTo(d,u),t.bezierCurveTo(d,u+h,c+a,l,c,l),t.bezierCurveTo(c-a,l,e,u+h,e,u),t.bezierCurveTo(e,u-h,c-a,i,c,i),t.bezierCurveTo(c+a,i,d,u-h,d,u),t.lineTo(d,f),t.bezierCurveTo(d,f+h,c+a,p,c,p),t.bezierCurveTo(c-a,p,e,f+h,e,f),t.lineTo(e,u)}function Et(t,e,i,o,n,r){t.beginPath(),t.moveTo(e,i);for(var s=r.length,a=o-e,h=n-i,d=h/a,l=Math.sqrt(a*a+h*h),c=0,u=!0,f=0,p=+r[0];l>=.1;)(p=+r[c++%s])>l&&(p=l),f=Math.sqrt(p*p/(1+d*d)),e+=f=a<0?-f:f,i+=d*f,!0===u?t.lineTo(e,i):t.moveTo(e,i),l-=p,u=!u}var Ot={circle:wt,dashedLine:Et,database:xt,diamond:function(t,e,i,o){t.beginPath(),t.lineTo(e,i+o),t.lineTo(e+o,i),t.lineTo(e,i-o),t.lineTo(e-o,i),t.closePath()},ellipse:_t,ellipse_vis:_t,hexagon:function(t,e,i,o){t.beginPath();var n=2*Math.PI/6;t.moveTo(e+o,i);for(var r=1;r<6;r++)t.lineTo(e+o*Math.cos(n*r),i+o*Math.sin(n*r));t.closePath()},roundRect:kt,square:function(t,e,i,o){t.beginPath(),t.rect(e-o,i-o,2*o,2*o),t.closePath()},star:function(t,e,i,o){t.beginPath(),i+=.1*(o*=.82);for(var n=0;n<10;n++){var r=n%2==0?1.3*o:.5*o;t.lineTo(e+r*Math.sin(2*n*Math.PI/10),i-r*Math.cos(2*n*Math.PI/10))}t.closePath()},triangle:function(t,e,i,o){t.beginPath(),i+=.275*(o*=1.15);var n=2*o,r=n/2,s=Math.sqrt(3)/6*n,a=Math.sqrt(n*n-r*r);t.moveTo(e,i-(a-s)),t.lineTo(e+r,i+s),t.lineTo(e-r,i+s),t.lineTo(e,i-(a-s)),t.closePath()},triangleDown:function(t,e,i,o){t.beginPath(),i-=.275*(o*=1.15);var n=2*o,r=n/2,s=Math.sqrt(3)/6*n,a=Math.sqrt(n*n-r*r);t.moveTo(e,i+(a-s)),t.lineTo(e+r,i-s),t.lineTo(e-r,i-s),t.lineTo(e,i+(a-s)),t.closePath()}};var Ct=o((function(t){function e(t){if(t)return function(t){for(var i in e.prototype)t[i]=e.prototype[i];return t}(t)}t.exports=e,e.prototype.on=e.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},e.prototype.once=function(t,e){function i(){this.off(t,i),e.apply(this,arguments)}return i.fn=e,this.on(t,i),this},e.prototype.off=e.prototype.removeListener=e.prototype.removeAllListeners=e.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var i,o=this._callbacks["$"+t];if(!o)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var n=0;n<o.length;n++)if((i=o[n])===e||i.fn===e){o.splice(n,1);break}return 0===o.length&&delete this._callbacks["$"+t],this},e.prototype.emit=function(t){this._callbacks=this._callbacks||{};for(var e=new Array(arguments.length-1),i=this._callbacks["$"+t],o=1;o<arguments.length;o++)e[o-1]=arguments[o];if(i){o=0;for(var n=(i=i.slice(0)).length;o<n;++o)i[o].apply(this,e)}return this},e.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},e.prototype.hasListeners=function(t){return!!this.listeners(t).length}})),St=function(t){return function(e,i){var o,n,r=String(g(e)),s=X(i),a=r.length;return s<0||s>=a?t?"":void 0:(o=r.charCodeAt(s))<55296||o>56319||s+1===a||(n=r.charCodeAt(s+1))<56320||n>57343?t?r.charAt(s):o:t?r.slice(s,s+2):n-56320+(o-55296<<10)+65536}},Tt={codeAt:St(!1),charAt:St(!0)},Mt="__core-js_shared__",Pt=r[Mt]||function(t,e){try{H(r,t,e)}catch(i){r[t]=e}return e}(Mt,{}),Dt=Function.toString;"function"!=typeof Pt.inspectSource&&(Pt.inspectSource=function(t){return Dt.call(t)});var Bt,It,zt,Ft=Pt.inspectSource,Nt=r.WeakMap,At="function"==typeof Nt&&/native code/.test(Ft(Nt)),Rt=o((function(t){(t.exports=function(t,e){return Pt[t]||(Pt[t]=void 0!==e?e:{})})("versions",[]).push({version:"3.9.1",mode:"pure",copyright:"© 2021 Denis Pushkarev (zloirock.ru)"})})),jt=0,Lt=Math.random(),Ht=function(t){return"Symbol("+String(void 0===t?"":t)+")_"+(++jt+Lt).toString(36)},Wt=Rt("keys"),Vt=function(t){return Wt[t]||(Wt[t]=Ht(t))},qt=r.WeakMap;if(At){var Ut=Pt.state||(Pt.state=new qt),Yt=Ut.get,Xt=Ut.has,Gt=Ut.set;Bt=function(t,e){return e.facade=t,Gt.call(Ut,t,e),e},It=function(t){return Yt.call(Ut,t)||{}},zt=function(t){return Xt.call(Ut,t)}}else{var Kt=Vt("state");et[Kt]=!0,Bt=function(t,e){return e.facade=t,H(t,Kt,e),e},It=function(t){return k(t,Kt)?t[Kt]:{}},zt=function(t){return k(t,Kt)}}var $t,Qt,Zt={set:Bt,get:It,has:zt,enforce:function(t){return zt(t)?It(t):Bt(t,{})},getterFor:function(t){return function(e){var i;if(!m(e)||(i=It(e)).type!==t)throw TypeError("Incompatible receiver, "+t+" required");return i}}},Jt=!s((function(){function t(){}return t.prototype.constructor=null,Object.getPrototypeOf(new t)!==t.prototype})),te=Vt("IE_PROTO"),ee=Object.prototype,ie=Jt?Object.getPrototypeOf:function(t){return t=at(t),k(t,te)?t[te]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?ee:null},oe="process"==f(r.process),ne=function(t){return"function"==typeof t?t:void 0},re=function(t,e){return arguments.length<2?ne(F[t])||ne(r[t]):F[t]&&F[t][e]||r[t]&&r[t][e]},se=re("navigator","userAgent")||"",ae=r.process,he=ae&&ae.versions,de=he&&he.v8;de?Qt=($t=de.split("."))[0]+$t[1]:se&&(!($t=se.match(/Edge\/(\d+)/))||$t[1]>=74)&&($t=se.match(/Chrome\/(\d+)/))&&(Qt=$t[1]);var le,ce,ue,fe=Qt&&+Qt,pe=!!Object.getOwnPropertySymbols&&!s((function(){return!Symbol.sham&&(oe?38===fe:fe>37&&fe<41)})),ve=pe&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,ge=Rt("wks"),ye=r.Symbol,me=ve?ye:ye&&ye.withoutSetter||Ht,be=function(t){return k(ge,t)&&(pe||"string"==typeof ge[t])||(pe&&k(ye,t)?ge[t]=ye[t]:ge[t]=me("Symbol."+t)),ge[t]},we=be("iterator"),ke=!1;[].keys&&("next"in(ue=[].keys())?(ce=ie(ie(ue)))!==Object.prototype&&(le=ce):ke=!0);var _e=null==le||s((function(){var t={};return le[we].call(t)!==t}));_e&&(le={}),_e&&!k(le,we)&&H(le,we,(function(){return this}));var xe,Ee={IteratorPrototype:le,BUGGY_SAFARI_ITERATORS:ke},Oe=a?Object.defineProperties:function(t,e){R(t);for(var i,o=rt(e),n=o.length,r=0;n>r;)L.f(t,i=o[r++],e[i]);return t},Ce=re("document","documentElement"),Se=Vt("IE_PROTO"),Te=function(){},Me=function(t){return"<script>"+t+"</"+"script>"},Pe=function(){try{xe=document.domain&&new ActiveXObject("htmlfile")}catch(t){}var t,e;Pe=xe?function(t){t.write(Me("")),t.close();var e=t.parentWindow.Object;return t=null,e}(xe):((e=E("iframe")).style.display="none",Ce.appendChild(e),e.src=String("javascript:"),(t=e.contentWindow.document).open(),t.write(Me("document.F=Object")),t.close(),t.F);for(var i=nt.length;i--;)delete Pe.prototype[nt[i]];return Pe()};et[Se]=!0;var De=Object.create||function(t,e){var i;return null!==t?(Te.prototype=R(t),i=new Te,Te.prototype=null,i[Se]=t):i=Pe(),void 0===e?i:Oe(i,e)},Be={};Be[be("toStringTag")]="z";var Ie="[object z]"===String(Be),ze=be("toStringTag"),Fe="Arguments"==f(function(){return arguments}()),Ne=Ie?f:function(t){var e,i,o;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(i=function(t,e){try{return t[e]}catch(t){}}(e=Object(t),ze))?i:Fe?f(e):"Object"==(o=f(e))&&"function"==typeof e.callee?"Arguments":o},Ae=Ie?{}.toString:function(){return"[object "+Ne(this)+"]"},Re=L.f,je=be("toStringTag"),Le=function(t,e,i,o){if(t){var n=i?t:t.prototype;k(n,je)||Re(n,je,{configurable:!0,value:e}),o&&!Ie&&H(n,"toString",Ae)}},He={},We=Ee.IteratorPrototype,Ve=function(){return this},qe=Object.setPrototypeOf||("__proto__"in{}?function(){var t,e=!1,i={};try{(t=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set).call(i,[]),e=i instanceof Array}catch(t){}return function(i,o){return R(i),function(t){if(!m(t)&&null!==t)throw TypeError("Can't set "+String(t)+" as a prototype")}(o),e?t.call(i,o):i.__proto__=o,i}}():void 0),Ue=function(t,e,i,o){o&&o.enumerable?t[e]=i:H(t,e,i)},Ye=Ee.IteratorPrototype,Xe=Ee.BUGGY_SAFARI_ITERATORS,Ge=be("iterator"),Ke="keys",$e="values",Qe="entries",Ze=function(){return this},Je=function(t,e,i,o,n,r,s){!function(t,e,i){var o=e+" Iterator";t.prototype=De(We,{next:c(1,i)}),Le(t,o,!1,!0),He[o]=Ve}(i,e,o);var a,h,d,l=function(t){if(t===n&&g)return g;if(!Xe&&t in p)return p[t];switch(t){case Ke:case $e:case Qe:return function(){return new i(this,t)}}return function(){return new i(this)}},u=e+" Iterator",f=!1,p=t.prototype,v=p[Ge]||p["@@iterator"]||n&&p[n],g=!Xe&&v||l(n),y="Array"==e&&p.entries||v;if(y&&(a=ie(y.call(new t)),Ye!==Object.prototype&&a.next&&(Le(a,u,!0,!0),He[u]=Ze)),n==$e&&v&&v.name!==$e&&(f=!0,g=function(){return v.call(this)}),s&&p[Ge]!==g&&H(p,Ge,g),He[e]=g,n)if(h={values:l($e),keys:r?g:l(Ke),entries:l(Qe)},s)for(d in h)(Xe||f||!(d in p))&&Ue(p,d,h[d]);else q({target:e,proto:!0,forced:Xe||f},h);return h},ti=Tt.charAt,ei="String Iterator",ii=Zt.set,oi=Zt.getterFor(ei);Je(String,"String",(function(t){ii(this,{type:ei,string:String(t),index:0})}),(function(){var t,e=oi(this),i=e.string,o=e.index;return o>=i.length?{value:void 0,done:!0}:(t=ti(i,o),e.index+=t.length,{value:t,done:!1})}));var ni=function(t){var e=t.return;if(void 0!==e)return R(e.call(t)).value},ri=function(t,e,i,o){try{return o?e(R(i)[0],i[1]):e(i)}catch(e){throw ni(t),e}},si=be("iterator"),ai=Array.prototype,hi=function(t){return void 0!==t&&(He.Array===t||ai[si]===t)},di=function(t,e,i){var o=b(e);o in t?L.f(t,o,c(0,i)):t[o]=i},li=be("iterator"),ci=function(t){if(null!=t)return t[li]||t["@@iterator"]||He[Ne(t)]},ui=be("iterator"),fi=!1;try{var pi=0,vi={next:function(){return{done:!!pi++}},return:function(){fi=!0}};vi[ui]=function(){return this},Array.from(vi,(function(){throw 2}))}catch(t){}var gi=!function(t,e){if(!e&&!fi)return!1;var i=!1;try{var o={};o[ui]=function(){return{next:function(){return{done:i=!0}}}},t(o)}catch(t){}return i}((function(t){Array.from(t)}));q({target:"Array",stat:!0,forced:gi},{from:function(t){var e,i,o,n,r,s,a=at(t),h="function"==typeof this?this:Array,d=arguments.length,l=d>1?arguments[1]:void 0,c=void 0!==l,u=ci(a),f=0;if(c&&(l=A(l,d>2?arguments[2]:void 0,2)),null==u||h==Array&&hi(u))for(i=new h(e=K(a.length));e>f;f++)s=c?l(a[f],f):a[f],di(i,f,s);else for(r=(n=u.call(a)).next,i=new h;!(o=r.call(n)).done;f++)s=c?ri(n,l,[o.value,f],!0):o.value,di(i,f,s);return i.length=f,i}});var yi=F.Array.from,mi=yi,bi="Array Iterator",wi=Zt.set,ki=Zt.getterFor(bi);Je(Array,"Array",(function(t,e){wi(this,{type:bi,target:y(t),index:0,kind:e})}),(function(){var t=ki(this),e=t.target,i=t.kind,o=t.index++;return!e||o>=e.length?(t.target=void 0,{value:void 0,done:!0}):"keys"==i?{value:o,done:!1}:"values"==i?{value:e[o],done:!1}:{value:[o,e[o]],done:!1}}),"values"),He.Arguments=He.Array;var _i=be("toStringTag");for(var xi in{CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}){var Ei=r[xi],Oi=Ei&&Ei.prototype;Oi&&Ne(Oi)!==_i&&H(Oi,_i,xi),He[xi]=He.Array}var Ci=ci,Si=function(t){var e=ci(t);if("function"!=typeof e)throw TypeError(String(t)+" is not iterable");return R(e.call(t))},Ti=Array.isArray||function(t){return"Array"==f(t)},Mi=nt.concat("length","prototype"),Pi={f:Object.getOwnPropertyNames||function(t){return ot(t,Mi)}},Di=Pi.f,Bi={}.toString,Ii="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],zi={f:function(t){return Ii&&"[object Window]"==Bi.call(t)?function(t){try{return Di(t)}catch(t){return Ii.slice()}}(t):Di(y(t))}},Fi={f:be},Ni=L.f,Ai=function(t){var e=F.Symbol||(F.Symbol={});k(e,t)||Ni(e,t,{value:Fi.f(t)})},Ri=be("species"),ji=function(t,e){var i;return Ti(t)&&("function"!=typeof(i=t.constructor)||i!==Array&&!Ti(i.prototype)?m(i)&&null===(i=i[Ri])&&(i=void 0):i=void 0),new(void 0===i?Array:i)(0===e?0:e)},Li=[].push,Hi=function(t){var e=1==t,i=2==t,o=3==t,n=4==t,r=6==t,s=7==t,a=5==t||r;return function(h,d,l,c){for(var u,f,p=at(h),g=v(p),y=A(d,l,3),m=K(g.length),b=0,w=c||ji,k=e?w(h,m):i||s?w(h,0):void 0;m>b;b++)if((a||b in g)&&(f=y(u=g[b],b,p),t))if(e)k[b]=f;else if(f)switch(t){case 3:return!0;case 5:return u;case 6:return b;case 2:Li.call(k,u)}else switch(t){case 4:return!1;case 7:Li.call(k,u)}return r?-1:o||n?n:k}},Wi={forEach:Hi(0),map:Hi(1),filter:Hi(2),some:Hi(3),every:Hi(4),find:Hi(5),findIndex:Hi(6),filterOut:Hi(7)},Vi=Wi.forEach,qi=Vt("hidden"),Ui="Symbol",Yi=be("toPrimitive"),Xi=Zt.set,Gi=Zt.getterFor(Ui),Ki=Object.prototype,$i=r.Symbol,Qi=re("JSON","stringify"),Zi=S.f,Ji=L.f,to=zi.f,eo=l.f,io=Rt("symbols"),oo=Rt("op-symbols"),no=Rt("string-to-symbol-registry"),ro=Rt("symbol-to-string-registry"),so=Rt("wks"),ao=r.QObject,ho=!ao||!ao.prototype||!ao.prototype.findChild,lo=a&&s((function(){return 7!=De(Ji({},"a",{get:function(){return Ji(this,"a",{value:7}).a}})).a}))?function(t,e,i){var o=Zi(Ki,e);o&&delete Ki[e],Ji(t,e,i),o&&t!==Ki&&Ji(Ki,e,o)}:Ji,co=function(t,e){var i=io[t]=De($i.prototype);return Xi(i,{type:Ui,tag:t,description:e}),a||(i.description=e),i},uo=ve?function(t){return"symbol"==typeof t}:function(t){return Object(t)instanceof $i},fo=function(t,e,i){t===Ki&&fo(oo,e,i),R(t);var o=b(e,!0);return R(i),k(io,o)?(i.enumerable?(k(t,qi)&&t[qi][o]&&(t[qi][o]=!1),i=De(i,{enumerable:c(0,!1)})):(k(t,qi)||Ji(t,qi,c(1,{})),t[qi][o]=!0),lo(t,o,i)):Ji(t,o,i)},po=function(t,e){R(t);var i=y(e),o=rt(i).concat(mo(i));return Vi(o,(function(e){a&&!vo.call(i,e)||fo(t,e,i[e])})),t},vo=function(t){var e=b(t,!0),i=eo.call(this,e);return!(this===Ki&&k(io,e)&&!k(oo,e))&&(!(i||!k(this,e)||!k(io,e)||k(this,qi)&&this[qi][e])||i)},go=function(t,e){var i=y(t),o=b(e,!0);if(i!==Ki||!k(io,o)||k(oo,o)){var n=Zi(i,o);return!n||!k(io,o)||k(i,qi)&&i[qi][o]||(n.enumerable=!0),n}},yo=function(t){var e=to(y(t)),i=[];return Vi(e,(function(t){k(io,t)||k(et,t)||i.push(t)})),i},mo=function(t){var e=t===Ki,i=to(e?oo:y(t)),o=[];return Vi(i,(function(t){!k(io,t)||e&&!k(Ki,t)||o.push(io[t])})),o};if(pe||(Ue(($i=function(){if(this instanceof $i)throw TypeError("Symbol is not a constructor");var t=arguments.length&&void 0!==arguments[0]?String(arguments[0]):void 0,e=Ht(t),i=function(t){this===Ki&&i.call(oo,t),k(this,qi)&&k(this[qi],e)&&(this[qi][e]=!1),lo(this,e,c(1,t))};return a&&ho&&lo(Ki,e,{configurable:!0,set:i}),co(e,t)}).prototype,"toString",(function(){return Gi(this).tag})),Ue($i,"withoutSetter",(function(t){return co(Ht(t),t)})),l.f=vo,L.f=fo,S.f=go,Pi.f=zi.f=yo,st.f=mo,Fi.f=function(t){return co(be(t),t)},a&&Ji($i.prototype,"description",{configurable:!0,get:function(){return Gi(this).description}})),q({global:!0,wrap:!0,forced:!pe,sham:!pe},{Symbol:$i}),Vi(rt(so),(function(t){Ai(t)})),q({target:Ui,stat:!0,forced:!pe},{for:function(t){var e=String(t);if(k(no,e))return no[e];var i=$i(e);return no[e]=i,ro[i]=e,i},keyFor:function(t){if(!uo(t))throw TypeError(t+" is not a symbol");if(k(ro,t))return ro[t]},useSetter:function(){ho=!0},useSimple:function(){ho=!1}}),q({target:"Object",stat:!0,forced:!pe,sham:!a},{create:function(t,e){return void 0===e?De(t):po(De(t),e)},defineProperty:fo,defineProperties:po,getOwnPropertyDescriptor:go}),q({target:"Object",stat:!0,forced:!pe},{getOwnPropertyNames:yo,getOwnPropertySymbols:mo}),q({target:"Object",stat:!0,forced:s((function(){st.f(1)}))},{getOwnPropertySymbols:function(t){return st.f(at(t))}}),Qi){var bo=!pe||s((function(){var t=$i();return"[null]"!=Qi([t])||"{}"!=Qi({a:t})||"{}"!=Qi(Object(t))}));q({target:"JSON",stat:!0,forced:bo},{stringify:function(t,e,i){for(var o,n=[t],r=1;arguments.length>r;)n.push(arguments[r++]);if(o=e,(m(e)||void 0!==t)&&!uo(t))return Ti(e)||(e=function(t,e){if("function"==typeof o&&(e=o.call(this,t,e)),!uo(e))return e}),n[1]=e,Qi.apply(null,n)}})}$i.prototype[Yi]||H($i.prototype,Yi,$i.prototype.valueOf),Le($i,Ui),et[qi]=!0;var wo=F.Object.getOwnPropertySymbols,ko=S.f,_o=s((function(){ko(1)}));q({target:"Object",stat:!0,forced:!a||_o,sham:!a},{getOwnPropertyDescriptor:function(t,e){return ko(y(t),e)}});var xo=o((function(t){var e=F.Object,i=t.exports=function(t,i){return e.getOwnPropertyDescriptor(t,i)};e.getOwnPropertyDescriptor.sham&&(i.sham=!0)})),Eo=xo,Oo=re("Reflect","ownKeys")||function(t){var e=Pi.f(R(t)),i=st.f;return i?e.concat(i(t)):e};q({target:"Object",stat:!0,sham:!a},{getOwnPropertyDescriptors:function(t){for(var e,i,o=y(t),n=S.f,r=Oo(o),s={},a=0;r.length>a;)void 0!==(i=n(o,e=r[a++]))&&di(s,e,i);return s}});var Co=F.Object.getOwnPropertyDescriptors;q({target:"Object",stat:!0,forced:!a,sham:!a},{defineProperties:Oe});var So=o((function(t){var e=F.Object,i=t.exports=function(t,i){return e.defineProperties(t,i)};e.defineProperties.sham&&(i.sham=!0)}));q({target:"Object",stat:!0,forced:!a,sham:!a},{defineProperty:L.f});var To=o((function(t){var e=F.Object,i=t.exports=function(t,i,o){return e.defineProperty(t,i,o)};e.defineProperty.sham&&(i.sham=!0)})),Mo=To;function Po(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var Do=To;function Bo(t,e){for(var i=0;i<e.length;i++){var o=e[i];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Do(t,o.key,o)}}function Io(t,e,i){return e&&Bo(t.prototype,e),i&&Bo(t,i),t}function zo(t,e,i){return e in t?Do(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}q({target:"Array",stat:!0},{isArray:Ti});var Fo=F.Array.isArray,No=Fo;var Ao=be("species"),Ro=function(t){return fe>=51||!s((function(){var e=[];return(e.constructor={})[Ao]=function(){return{foo:1}},1!==e[t](Boolean).foo}))},jo=be("isConcatSpreadable"),Lo=9007199254740991,Ho="Maximum allowed index exceeded",Wo=fe>=51||!s((function(){var t=[];return t[jo]=!1,t.concat()[0]!==t})),Vo=Ro("concat"),qo=function(t){if(!m(t))return!1;var e=t[jo];return void 0!==e?!!e:Ti(t)};q({target:"Array",proto:!0,forced:!Wo||!Vo},{concat:function(t){var e,i,o,n,r,s=at(this),a=ji(s,0),h=0;for(e=-1,o=arguments.length;e<o;e++)if(qo(r=-1===e?s:arguments[e])){if(h+(n=K(r.length))>Lo)throw TypeError(Ho);for(i=0;i<n;i++,h++)i in r&&di(a,h,r[i])}else{if(h>=Lo)throw TypeError(Ho);di(a,h++,r)}return a.length=h,a}}),Ai("asyncIterator"),Ai("hasInstance"),Ai("isConcatSpreadable"),Ai("iterator"),Ai("match"),Ai("matchAll"),Ai("replace"),Ai("search"),Ai("species"),Ai("split"),Ai("toPrimitive"),Ai("toStringTag"),Ai("unscopables"),Le(r.JSON,"JSON",!0);var Uo=F.Symbol;Ai("asyncDispose"),Ai("dispose"),Ai("observable"),Ai("patternMatch"),Ai("replaceAll");var Yo=Uo,Xo=be("iterator"),Go=function(t){var e=Object(t);return void 0!==e[Xo]||"@@iterator"in e||He.hasOwnProperty(Ne(e))};var Ko=Ro("slice"),$o=be("species"),Qo=[].slice,Zo=Math.max;q({target:"Array",proto:!0,forced:!Ko},{slice:function(t,e){var i,o,n,r=y(this),s=K(r.length),a=Z(t,s),h=Z(void 0===e?s:e,s);if(Ti(r)&&("function"!=typeof(i=r.constructor)||i!==Array&&!Ti(i.prototype)?m(i)&&null===(i=i[$o])&&(i=void 0):i=void 0,i===Array||void 0===i))return Qo.call(r,a,h);for(o=new(void 0===i?Array:i)(Zo(h-a,0)),n=0;a<h;a++,n++)a in r&&di(o,n,r[a]);return o.length=n,o}});var Jo=gt("Array").slice,tn=Array.prototype,en=function(t){var e=t.slice;return t===tn||t instanceof Array&&e===tn.slice?Jo:e},on=en,nn=yi;function rn(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}function sn(t,e){var i;if(t){if("string"==typeof t)return rn(t,e);var o=on(i=Object.prototype.toString.call(t)).call(i,8,-1);return"Object"===o&&t.constructor&&(o=t.constructor.name),"Map"===o||"Set"===o?nn(t):"Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)?rn(t,e):void 0}}function an(t,e){return function(t){if(No(t))return t}(t)||function(t,e){if(void 0!==Yo&&Go(Object(t))){var i=[],o=!0,n=!1,r=void 0;try{for(var s,a=Si(t);!(o=(s=a.next()).done)&&(i.push(s.value),!e||i.length!==e);o=!0);}catch(t){n=!0,r=t}finally{try{o||null==a.return||a.return()}finally{if(n)throw r}}return i}}(t,e)||sn(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var hn=Fi.f("iterator");function dn(t){return(dn="function"==typeof Yo&&"symbol"==typeof hn?function(t){return typeof t}:function(t){return t&&"function"==typeof Yo&&t.constructor===Yo&&t!==Yo.prototype?"symbol":typeof t})(t)}function ln(t){return function(t){if(No(t))return rn(t)}(t)||function(t){if(void 0!==Yo&&Go(Object(t)))return nn(t)}(t)||sn(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var cn=Uo,un=gt("Array").concat,fn=Array.prototype,pn=function(t){var e=t.concat;return t===fn||t instanceof Array&&e===fn.concat?un:e},vn=en;q({target:"Reflect",stat:!0},{ownKeys:Oo}),F.Reflect.ownKeys;var gn=Fo,yn=Wi.map,mn=Ro("map");q({target:"Array",proto:!0,forced:!mn},{map:function(t){return yn(this,t,arguments.length>1?arguments[1]:void 0)}});var bn=gt("Array").map,wn=Array.prototype,kn=function(t){var e=t.map;return t===wn||t instanceof Array&&e===wn.map?bn:e},_n=s((function(){rt(1)}));q({target:"Object",stat:!0,forced:_n},{keys:function(t){return rt(at(t))}});var xn=F.Object.keys;q({target:"Date",stat:!0},{now:function(){return(new Date).getTime()}});var En=F.Date.now,On=function(t,e){var i=[][t];return!!i&&s((function(){i.call(null,e||function(){throw 1},1)}))},Cn=Wi.forEach,Sn=On("forEach")?[].forEach:function(t){return Cn(this,t,arguments.length>1?arguments[1]:void 0)};q({target:"Array",proto:!0,forced:[].forEach!=Sn},{forEach:Sn});var Tn=gt("Array").forEach,Mn=Array.prototype,Pn={DOMTokenList:!0,NodeList:!0},Dn=function(t){var e=t.forEach;return t===Mn||t instanceof Array&&e===Mn.forEach||Pn.hasOwnProperty(Ne(t))?Tn:e},Bn=[].reverse,In=[1,2];q({target:"Array",proto:!0,forced:String(In)===String(In.reverse())},{reverse:function(){return Ti(this)&&(this.length=this.length),Bn.call(this)}});var zn=gt("Array").reverse,Fn=Array.prototype,Nn=function(t){var e=t.reverse;return t===Fn||t instanceof Array&&e===Fn.reverse?zn:e},An=Ro("splice"),Rn=Math.max,jn=Math.min,Ln=9007199254740991,Hn="Maximum allowed length exceeded";q({target:"Array",proto:!0,forced:!An},{splice:function(t,e){var i,o,n,r,s,a,h=at(this),d=K(h.length),l=Z(t,d),c=arguments.length;if(0===c?i=o=0:1===c?(i=0,o=d-l):(i=c-2,o=jn(Rn(X(e),0),d-l)),d+i-o>Ln)throw TypeError(Hn);for(n=ji(h,o),r=0;r<o;r++)(s=l+r)in h&&di(n,r,h[s]);if(n.length=o,i<o){for(r=l;r<d-o;r++)a=r+i,(s=r+o)in h?h[a]=h[s]:delete h[a];for(r=d;r>d-o+i;r--)delete h[r-1]}else if(i>o)for(r=d-o;r>l;r--)a=r+i-1,(s=r+o-1)in h?h[a]=h[s]:delete h[a];for(r=0;r<i;r++)h[r+l]=arguments[r+2];return h.length=d-o+i,n}});var Wn=gt("Array").splice,Vn=Array.prototype,qn=function(t){var e=t.splice;return t===Vn||t instanceof Array&&e===Vn.splice?Wn:e},Un=tt.includes;q({target:"Array",proto:!0},{includes:function(t){return Un(this,t,arguments.length>1?arguments[1]:void 0)}});var Yn=gt("Array").includes,Xn=be("match"),Gn=function(t){if(function(t){var e;return m(t)&&(void 0!==(e=t[Xn])?!!e:"RegExp"==f(t))}(t))throw TypeError("The method doesn't accept regular expressions");return t},Kn=be("match");q({target:"String",proto:!0,forced:!function(t){var e=/./;try{"/./"[t](e)}catch(i){try{return e[Kn]=!1,"/./"[t](e)}catch(t){}}return!1}("includes")},{includes:function(t){return!!~String(g(this)).indexOf(Gn(t),arguments.length>1?arguments[1]:void 0)}});var $n=gt("String").includes,Qn=Array.prototype,Zn=String.prototype,Jn=function(t){var e=t.includes;return t===Qn||t instanceof Array&&e===Qn.includes?Yn:"string"==typeof t||t===Zn||t instanceof String&&e===Zn.includes?$n:e},tr=s((function(){ie(1)}));q({target:"Object",stat:!0,forced:tr,sham:!Jt},{getPrototypeOf:function(t){return ie(at(t))}});var er=F.Object.getPrototypeOf,ir=er,or=Wi.filter,nr=Ro("filter");q({target:"Array",proto:!0,forced:!nr},{filter:function(t){return or(this,t,arguments.length>1?arguments[1]:void 0)}});var rr=gt("Array").filter,sr=Array.prototype,ar=function(t){var e=t.filter;return t===sr||t instanceof Array&&e===sr.filter?rr:e},hr=l.f,dr=function(t){return function(e){for(var i,o=y(e),n=rt(o),r=n.length,s=0,h=[];r>s;)i=n[s++],a&&!hr.call(o,i)||h.push(t?[i,o[i]]:o[i]);return h}},lr={entries:dr(!0),values:dr(!1)}.values;q({target:"Object",stat:!0},{values:function(t){return lr(t)}}),F.Object.values;var cr="\t\n\v\f\r                　\u2028\u2029\ufeff",ur="["+cr+"]",fr=RegExp("^"+ur+ur+"*"),pr=RegExp(ur+ur+"*$"),vr=function(t){return function(e){var i=String(g(e));return 1&t&&(i=i.replace(fr,"")),2&t&&(i=i.replace(pr,"")),i}},gr={start:vr(1),end:vr(2),trim:vr(3)},yr=gr.trim,mr=r.parseInt,br=/^[+-]?0[Xx]/,wr=8!==mr(cr+"08")||22!==mr(cr+"0x16")?function(t,e){var i=yr(String(t));return mr(i,e>>>0||(br.test(i)?16:10))}:mr;q({global:!0,forced:parseInt!=wr},{parseInt:wr});var kr=F.parseInt,_r=tt.indexOf,xr=[].indexOf,Er=!!xr&&1/[1].indexOf(1,-0)<0,Or=On("indexOf");q({target:"Array",proto:!0,forced:Er||!Or},{indexOf:function(t){return Er?xr.apply(this,arguments)||0:_r(this,t,arguments.length>1?arguments[1]:void 0)}});var Cr,Sr=gt("Array").indexOf,Tr=Array.prototype,Mr=function(t){var e=t.indexOf;return t===Tr||t instanceof Array&&e===Tr.indexOf?Sr:e},Pr=gr.trim;q({target:"String",proto:!0,forced:(Cr="trim",s((function(){return!!cr[Cr]()||"​᠎"!="​᠎"[Cr]()||cr[Cr].name!==Cr})))},{trim:function(){return Pr(this)}}),gt("String").trim,q({target:"Object",stat:!0,sham:!a},{create:De});var Dr=F.Object,Br=function(t,e){return Dr.create(t,e)},Ir=Br,zr=re("JSON","stringify"),Fr=/[\uD800-\uDFFF]/g,Nr=/^[\uD800-\uDBFF]$/,Ar=/^[\uDC00-\uDFFF]$/,Rr=function(t,e,i){var o=i.charAt(e-1),n=i.charAt(e+1);return Nr.test(t)&&!Ar.test(n)||Ar.test(t)&&!Nr.test(o)?"\\u"+t.charCodeAt(0).toString(16):t},jr=s((function(){return'"\\udf06\\ud834"'!==zr("\udf06\ud834")||'"\\udead"'!==zr("\udead")}));zr&&q({target:"JSON",stat:!0,forced:jr},{stringify:function(t,e,i){var o=zr.apply(null,arguments);return"string"==typeof o?o.replace(Fr,Rr):o}}),F.JSON||(F.JSON={stringify:JSON.stringify});var Lr=function(t,e,i){return F.JSON.stringify.apply(null,arguments)},Hr=[].slice,Wr=/MSIE .\./.test(se),Vr=function(t){return function(e,i){var o=arguments.length>2,n=o?Hr.call(arguments,2):void 0;return t(o?function(){("function"==typeof e?e:Function(e)).apply(this,n)}:e,i)}};q({global:!0,bind:!0,forced:Wr},{setTimeout:Vr(r.setTimeout),setInterval:Vr(r.setInterval)});var qr=F.setTimeout;q({target:"Array",proto:!0},{fill:function(t){for(var e=at(this),i=K(e.length),o=arguments.length,n=Z(o>1?arguments[1]:void 0,i),r=o>2?arguments[2]:void 0,s=void 0===r?i:Z(r,i);s>n;)e[n++]=t;return e}});var Ur=gt("Array").fill,Yr=Array.prototype,Xr=function(t){var e=t.fill;return t===Yr||t instanceof Array&&e===Yr.fill?Ur:e};
/*! Hammer.JS - v2.0.17-rc - 2019-12-16
	 * http://naver.github.io/egjs
	 *
	 * Forked By Naver egjs
	 * Copyright (c) hammerjs
	 * Licensed under the MIT license */
function Gr(){return(Gr=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var o in i)Object.prototype.hasOwnProperty.call(i,o)&&(t[o]=i[o])}return t}).apply(this,arguments)}function Kr(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t.__proto__=e}function $r(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}var Qr,Zr="function"!=typeof Object.assign?function(t){if(null==t)throw new TypeError("Cannot convert undefined or null to object");for(var e=Object(t),i=1;i<arguments.length;i++){var o=arguments[i];if(null!=o)for(var n in o)o.hasOwnProperty(n)&&(e[n]=o[n])}return e}:Object.assign,Jr=["","webkit","Moz","MS","ms","o"],ts="undefined"==typeof document?{style:{}}:document.createElement("div"),es=Math.round,is=Math.abs,os=Date.now;function ns(t,e){for(var i,o,n=e[0].toUpperCase()+e.slice(1),r=0;r<Jr.length;){if((o=(i=Jr[r])?i+n:e)in t)return o;r++}}Qr="undefined"==typeof window?{}:window;var rs=ns(ts.style,"touchAction"),ss=void 0!==rs;var as="compute",hs="auto",ds="manipulation",ls="none",cs="pan-x",us="pan-y",fs=function(){if(!ss)return!1;var t={},e=Qr.CSS&&Qr.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach((function(i){return t[i]=!e||Qr.CSS.supports("touch-action",i)})),t}(),ps="ontouchstart"in Qr,vs=void 0!==ns(Qr,"PointerEvent"),gs=ps&&/mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent),ys="touch",ms="mouse",bs=16,ws=24,ks=["x","y"],_s=["clientX","clientY"];function xs(t,e,i){var o;if(t)if(t.forEach)t.forEach(e,i);else if(void 0!==t.length)for(o=0;o<t.length;)e.call(i,t[o],o,t),o++;else for(o in t)t.hasOwnProperty(o)&&e.call(i,t[o],o,t)}function Es(t,e){return"function"==typeof t?t.apply(e&&e[0]||void 0,e):t}function Os(t,e){return t.indexOf(e)>-1}var Cs=function(){function t(t,e){this.manager=t,this.set(e)}var e=t.prototype;return e.set=function(t){t===as&&(t=this.compute()),ss&&this.manager.element.style&&fs[t]&&(this.manager.element.style[rs]=t),this.actions=t.toLowerCase().trim()},e.update=function(){this.set(this.manager.options.touchAction)},e.compute=function(){var t=[];return xs(this.manager.recognizers,(function(e){Es(e.options.enable,[e])&&(t=t.concat(e.getTouchAction()))})),function(t){if(Os(t,ls))return ls;var e=Os(t,cs),i=Os(t,us);return e&&i?ls:e||i?e?cs:us:Os(t,ds)?ds:hs}(t.join(" "))},e.preventDefaults=function(t){var e=t.srcEvent,i=t.offsetDirection;if(this.manager.session.prevented)e.preventDefault();else{var o=this.actions,n=Os(o,ls)&&!fs.none,r=Os(o,us)&&!fs["pan-y"],s=Os(o,cs)&&!fs["pan-x"];if(n){var a=1===t.pointers.length,h=t.distance<2,d=t.deltaTime<250;if(a&&h&&d)return}if(!s||!r)return n||r&&6&i||s&&i&ws?this.preventSrc(e):void 0}},e.preventSrc=function(t){this.manager.session.prevented=!0,t.preventDefault()},t}();function Ss(t,e){for(;t;){if(t===e)return!0;t=t.parentNode}return!1}function Ts(t){var e=t.length;if(1===e)return{x:es(t[0].clientX),y:es(t[0].clientY)};for(var i=0,o=0,n=0;n<e;)i+=t[n].clientX,o+=t[n].clientY,n++;return{x:es(i/e),y:es(o/e)}}function Ms(t){for(var e=[],i=0;i<t.pointers.length;)e[i]={clientX:es(t.pointers[i].clientX),clientY:es(t.pointers[i].clientY)},i++;return{timeStamp:os(),pointers:e,center:Ts(e),deltaX:t.deltaX,deltaY:t.deltaY}}function Ps(t,e,i){i||(i=ks);var o=e[i[0]]-t[i[0]],n=e[i[1]]-t[i[1]];return Math.sqrt(o*o+n*n)}function Ds(t,e,i){i||(i=ks);var o=e[i[0]]-t[i[0]],n=e[i[1]]-t[i[1]];return 180*Math.atan2(n,o)/Math.PI}function Bs(t,e){return t===e?1:is(t)>=is(e)?t<0?2:4:e<0?8:bs}function Is(t,e,i){return{x:e/t||0,y:i/t||0}}function zs(t,e){var i=t.session,o=e.pointers,n=o.length;i.firstInput||(i.firstInput=Ms(e)),n>1&&!i.firstMultiple?i.firstMultiple=Ms(e):1===n&&(i.firstMultiple=!1);var r=i.firstInput,s=i.firstMultiple,a=s?s.center:r.center,h=e.center=Ts(o);e.timeStamp=os(),e.deltaTime=e.timeStamp-r.timeStamp,e.angle=Ds(a,h),e.distance=Ps(a,h),function(t,e){var i=e.center,o=t.offsetDelta||{},n=t.prevDelta||{},r=t.prevInput||{};1!==e.eventType&&4!==r.eventType||(n=t.prevDelta={x:r.deltaX||0,y:r.deltaY||0},o=t.offsetDelta={x:i.x,y:i.y}),e.deltaX=n.x+(i.x-o.x),e.deltaY=n.y+(i.y-o.y)}(i,e),e.offsetDirection=Bs(e.deltaX,e.deltaY);var d,l,c=Is(e.deltaTime,e.deltaX,e.deltaY);e.overallVelocityX=c.x,e.overallVelocityY=c.y,e.overallVelocity=is(c.x)>is(c.y)?c.x:c.y,e.scale=s?(d=s.pointers,Ps((l=o)[0],l[1],_s)/Ps(d[0],d[1],_s)):1,e.rotation=s?function(t,e){return Ds(e[1],e[0],_s)+Ds(t[1],t[0],_s)}(s.pointers,o):0,e.maxPointers=i.prevInput?e.pointers.length>i.prevInput.maxPointers?e.pointers.length:i.prevInput.maxPointers:e.pointers.length,function(t,e){var i,o,n,r,s=t.lastInterval||e,a=e.timeStamp-s.timeStamp;if(8!==e.eventType&&(a>25||void 0===s.velocity)){var h=e.deltaX-s.deltaX,d=e.deltaY-s.deltaY,l=Is(a,h,d);o=l.x,n=l.y,i=is(l.x)>is(l.y)?l.x:l.y,r=Bs(h,d),t.lastInterval=e}else i=s.velocity,o=s.velocityX,n=s.velocityY,r=s.direction;e.velocity=i,e.velocityX=o,e.velocityY=n,e.direction=r}(i,e);var u,f=t.element,p=e.srcEvent;Ss(u=p.composedPath?p.composedPath()[0]:p.path?p.path[0]:p.target,f)&&(f=u),e.target=f}function Fs(t,e,i){var o=i.pointers.length,n=i.changedPointers.length,r=1&e&&o-n==0,s=12&e&&o-n==0;i.isFirst=!!r,i.isFinal=!!s,r&&(t.session={}),i.eventType=e,zs(t,i),t.emit("hammer.input",i),t.recognize(i),t.session.prevInput=i}function Ns(t){return t.trim().split(/\s+/g)}function As(t,e,i){xs(Ns(e),(function(e){t.addEventListener(e,i,!1)}))}function Rs(t,e,i){xs(Ns(e),(function(e){t.removeEventListener(e,i,!1)}))}function js(t){var e=t.ownerDocument||t;return e.defaultView||e.parentWindow||window}var Ls=function(){function t(t,e){var i=this;this.manager=t,this.callback=e,this.element=t.element,this.target=t.options.inputTarget,this.domHandler=function(e){Es(t.options.enable,[t])&&i.handler(e)},this.init()}var e=t.prototype;return e.handler=function(){},e.init=function(){this.evEl&&As(this.element,this.evEl,this.domHandler),this.evTarget&&As(this.target,this.evTarget,this.domHandler),this.evWin&&As(js(this.element),this.evWin,this.domHandler)},e.destroy=function(){this.evEl&&Rs(this.element,this.evEl,this.domHandler),this.evTarget&&Rs(this.target,this.evTarget,this.domHandler),this.evWin&&Rs(js(this.element),this.evWin,this.domHandler)},t}();function Hs(t,e,i){if(t.indexOf&&!i)return t.indexOf(e);for(var o=0;o<t.length;){if(i&&t[o][i]==e||!i&&t[o]===e)return o;o++}return-1}var Ws={pointerdown:1,pointermove:2,pointerup:4,pointercancel:8,pointerout:8},Vs={2:ys,3:"pen",4:ms,5:"kinect"},qs="pointerdown",Us="pointermove pointerup pointercancel";Qr.MSPointerEvent&&!Qr.PointerEvent&&(qs="MSPointerDown",Us="MSPointerMove MSPointerUp MSPointerCancel");var Ys=function(t){function e(){var i,o=e.prototype;return o.evEl=qs,o.evWin=Us,(i=t.apply(this,arguments)||this).store=i.manager.session.pointerEvents=[],i}return Kr(e,t),e.prototype.handler=function(t){var e=this.store,i=!1,o=t.type.toLowerCase().replace("ms",""),n=Ws[o],r=Vs[t.pointerType]||t.pointerType,s=r===ys,a=Hs(e,t.pointerId,"pointerId");1&n&&(0===t.button||s)?a<0&&(e.push(t),a=e.length-1):12&n&&(i=!0),a<0||(e[a]=t,this.callback(this.manager,n,{pointers:e,changedPointers:[t],pointerType:r,srcEvent:t}),i&&e.splice(a,1))},e}(Ls);function Xs(t){return Array.prototype.slice.call(t,0)}function Gs(t,e,i){for(var o=[],n=[],r=0;r<t.length;){var s=e?t[r][e]:t[r];Hs(n,s)<0&&o.push(t[r]),n[r]=s,r++}return i&&(o=e?o.sort((function(t,i){return t[e]>i[e]})):o.sort()),o}var Ks={touchstart:1,touchmove:2,touchend:4,touchcancel:8},$s="touchstart touchmove touchend touchcancel",Qs=function(t){function e(){var i;return e.prototype.evTarget=$s,(i=t.apply(this,arguments)||this).targetIds={},i}return Kr(e,t),e.prototype.handler=function(t){var e=Ks[t.type],i=Zs.call(this,t,e);i&&this.callback(this.manager,e,{pointers:i[0],changedPointers:i[1],pointerType:ys,srcEvent:t})},e}(Ls);function Zs(t,e){var i,o,n=Xs(t.touches),r=this.targetIds;if(3&e&&1===n.length)return r[n[0].identifier]=!0,[n,n];var s=Xs(t.changedTouches),a=[],h=this.target;if(o=n.filter((function(t){return Ss(t.target,h)})),1===e)for(i=0;i<o.length;)r[o[i].identifier]=!0,i++;for(i=0;i<s.length;)r[s[i].identifier]&&a.push(s[i]),12&e&&delete r[s[i].identifier],i++;return a.length?[Gs(o.concat(a),"identifier",!0),a]:void 0}var Js={mousedown:1,mousemove:2,mouseup:4},ta="mousedown",ea="mousemove mouseup",ia=function(t){function e(){var i,o=e.prototype;return o.evEl=ta,o.evWin=ea,(i=t.apply(this,arguments)||this).pressed=!1,i}return Kr(e,t),e.prototype.handler=function(t){var e=Js[t.type];1&e&&0===t.button&&(this.pressed=!0),2&e&&1!==t.which&&(e=4),this.pressed&&(4&e&&(this.pressed=!1),this.callback(this.manager,e,{pointers:[t],changedPointers:[t],pointerType:ms,srcEvent:t}))},e}(Ls);function oa(t){var e=t.changedPointers[0];if(e.identifier===this.primaryTouch){var i={x:e.clientX,y:e.clientY},o=this.lastTouches;this.lastTouches.push(i);setTimeout((function(){var t=o.indexOf(i);t>-1&&o.splice(t,1)}),2500)}}function na(t,e){1&t?(this.primaryTouch=e.changedPointers[0].identifier,oa.call(this,e)):12&t&&oa.call(this,e)}function ra(t){for(var e=t.srcEvent.clientX,i=t.srcEvent.clientY,o=0;o<this.lastTouches.length;o++){var n=this.lastTouches[o],r=Math.abs(e-n.x),s=Math.abs(i-n.y);if(r<=25&&s<=25)return!0}return!1}var sa=function(){return function(t){function e(e,i){var o;return(o=t.call(this,e,i)||this).handler=function(t,e,i){var n=i.pointerType===ys,r=i.pointerType===ms;if(!(r&&i.sourceCapabilities&&i.sourceCapabilities.firesTouchEvents)){if(n)na.call($r($r(o)),e,i);else if(r&&ra.call($r($r(o)),i))return;o.callback(t,e,i)}},o.touch=new Qs(o.manager,o.handler),o.mouse=new ia(o.manager,o.handler),o.primaryTouch=null,o.lastTouches=[],o}return Kr(e,t),e.prototype.destroy=function(){this.touch.destroy(),this.mouse.destroy()},e}(Ls)}();function aa(t,e,i){return!!Array.isArray(t)&&(xs(t,i[e],i),!0)}var ha=32,da=1;function la(t,e){var i=e.manager;return i?i.get(t):t}function ca(t){return 16&t?"cancel":8&t?"end":4&t?"move":2&t?"start":""}var ua=function(){function t(t){void 0===t&&(t={}),this.options=Gr({enable:!0},t),this.id=da++,this.manager=null,this.state=1,this.simultaneous={},this.requireFail=[]}var e=t.prototype;return e.set=function(t){return Zr(this.options,t),this.manager&&this.manager.touchAction.update(),this},e.recognizeWith=function(t){if(aa(t,"recognizeWith",this))return this;var e=this.simultaneous;return e[(t=la(t,this)).id]||(e[t.id]=t,t.recognizeWith(this)),this},e.dropRecognizeWith=function(t){return aa(t,"dropRecognizeWith",this)||(t=la(t,this),delete this.simultaneous[t.id]),this},e.requireFailure=function(t){if(aa(t,"requireFailure",this))return this;var e=this.requireFail;return-1===Hs(e,t=la(t,this))&&(e.push(t),t.requireFailure(this)),this},e.dropRequireFailure=function(t){if(aa(t,"dropRequireFailure",this))return this;t=la(t,this);var e=Hs(this.requireFail,t);return e>-1&&this.requireFail.splice(e,1),this},e.hasRequireFailures=function(){return this.requireFail.length>0},e.canRecognizeWith=function(t){return!!this.simultaneous[t.id]},e.emit=function(t){var e=this,i=this.state;function o(i){e.manager.emit(i,t)}i<8&&o(e.options.event+ca(i)),o(e.options.event),t.additionalEvent&&o(t.additionalEvent),i>=8&&o(e.options.event+ca(i))},e.tryEmit=function(t){if(this.canEmit())return this.emit(t);this.state=ha},e.canEmit=function(){for(var t=0;t<this.requireFail.length;){if(!(33&this.requireFail[t].state))return!1;t++}return!0},e.recognize=function(t){var e=Zr({},t);if(!Es(this.options.enable,[this,e]))return this.reset(),void(this.state=ha);56&this.state&&(this.state=1),this.state=this.process(e),30&this.state&&this.tryEmit(e)},e.process=function(t){},e.getTouchAction=function(){},e.reset=function(){},t}(),fa=function(t){function e(e){var i;return void 0===e&&(e={}),(i=t.call(this,Gr({event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},e))||this).pTime=!1,i.pCenter=!1,i._timer=null,i._input=null,i.count=0,i}Kr(e,t);var i=e.prototype;return i.getTouchAction=function(){return[ds]},i.process=function(t){var e=this,i=this.options,o=t.pointers.length===i.pointers,n=t.distance<i.threshold,r=t.deltaTime<i.time;if(this.reset(),1&t.eventType&&0===this.count)return this.failTimeout();if(n&&r&&o){if(4!==t.eventType)return this.failTimeout();var s=!this.pTime||t.timeStamp-this.pTime<i.interval,a=!this.pCenter||Ps(this.pCenter,t.center)<i.posThreshold;if(this.pTime=t.timeStamp,this.pCenter=t.center,a&&s?this.count+=1:this.count=1,this._input=t,0===this.count%i.taps)return this.hasRequireFailures()?(this._timer=setTimeout((function(){e.state=8,e.tryEmit()}),i.interval),2):8}return ha},i.failTimeout=function(){var t=this;return this._timer=setTimeout((function(){t.state=ha}),this.options.interval),ha},i.reset=function(){clearTimeout(this._timer)},i.emit=function(){8===this.state&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))},e}(ua),pa=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Gr({pointers:1},e))||this}Kr(e,t);var i=e.prototype;return i.attrTest=function(t){var e=this.options.pointers;return 0===e||t.pointers.length===e},i.process=function(t){var e=this.state,i=t.eventType,o=6&e,n=this.attrTest(t);return o&&(8&i||!n)?16|e:o||n?4&i?8|e:2&e?4|e:2:ha},e}(ua);function va(t){return t===bs?"down":8===t?"up":2===t?"left":4===t?"right":""}var ga=function(t){function e(e){var i;return void 0===e&&(e={}),(i=t.call(this,Gr({event:"pan",threshold:10,pointers:1,direction:30},e))||this).pX=null,i.pY=null,i}Kr(e,t);var i=e.prototype;return i.getTouchAction=function(){var t=this.options.direction,e=[];return 6&t&&e.push(us),t&ws&&e.push(cs),e},i.directionTest=function(t){var e=this.options,i=!0,o=t.distance,n=t.direction,r=t.deltaX,s=t.deltaY;return n&e.direction||(6&e.direction?(n=0===r?1:r<0?2:4,i=r!==this.pX,o=Math.abs(t.deltaX)):(n=0===s?1:s<0?8:bs,i=s!==this.pY,o=Math.abs(t.deltaY))),t.direction=n,i&&o>e.threshold&&n&e.direction},i.attrTest=function(t){return pa.prototype.attrTest.call(this,t)&&(2&this.state||!(2&this.state)&&this.directionTest(t))},i.emit=function(e){this.pX=e.deltaX,this.pY=e.deltaY;var i=va(e.direction);i&&(e.additionalEvent=this.options.event+i),t.prototype.emit.call(this,e)},e}(pa),ya=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Gr({event:"swipe",threshold:10,velocity:.3,direction:30,pointers:1},e))||this}Kr(e,t);var i=e.prototype;return i.getTouchAction=function(){return ga.prototype.getTouchAction.call(this)},i.attrTest=function(e){var i,o=this.options.direction;return 30&o?i=e.overallVelocity:6&o?i=e.overallVelocityX:o&ws&&(i=e.overallVelocityY),t.prototype.attrTest.call(this,e)&&o&e.offsetDirection&&e.distance>this.options.threshold&&e.maxPointers===this.options.pointers&&is(i)>this.options.velocity&&4&e.eventType},i.emit=function(t){var e=va(t.offsetDirection);e&&this.manager.emit(this.options.event+e,t),this.manager.emit(this.options.event,t)},e}(pa),ma=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Gr({event:"pinch",threshold:0,pointers:2},e))||this}Kr(e,t);var i=e.prototype;return i.getTouchAction=function(){return[ls]},i.attrTest=function(e){return t.prototype.attrTest.call(this,e)&&(Math.abs(e.scale-1)>this.options.threshold||2&this.state)},i.emit=function(e){if(1!==e.scale){var i=e.scale<1?"in":"out";e.additionalEvent=this.options.event+i}t.prototype.emit.call(this,e)},e}(pa),ba=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Gr({event:"rotate",threshold:0,pointers:2},e))||this}Kr(e,t);var i=e.prototype;return i.getTouchAction=function(){return[ls]},i.attrTest=function(e){return t.prototype.attrTest.call(this,e)&&(Math.abs(e.rotation)>this.options.threshold||2&this.state)},e}(pa),wa=function(t){function e(e){var i;return void 0===e&&(e={}),(i=t.call(this,Gr({event:"press",pointers:1,time:251,threshold:9},e))||this)._timer=null,i._input=null,i}Kr(e,t);var i=e.prototype;return i.getTouchAction=function(){return[hs]},i.process=function(t){var e=this,i=this.options,o=t.pointers.length===i.pointers,n=t.distance<i.threshold,r=t.deltaTime>i.time;if(this._input=t,!n||!o||12&t.eventType&&!r)this.reset();else if(1&t.eventType)this.reset(),this._timer=setTimeout((function(){e.state=8,e.tryEmit()}),i.time);else if(4&t.eventType)return 8;return ha},i.reset=function(){clearTimeout(this._timer)},i.emit=function(t){8===this.state&&(t&&4&t.eventType?this.manager.emit(this.options.event+"up",t):(this._input.timeStamp=os(),this.manager.emit(this.options.event,this._input)))},e}(ua),ka={domEvents:!1,touchAction:as,enable:!0,inputTarget:null,inputClass:null,cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}},_a=[[ba,{enable:!1}],[ma,{enable:!1},["rotate"]],[ya,{direction:6}],[ga,{direction:6},["swipe"]],[fa],[fa,{event:"doubletap",taps:2},["tap"]],[wa]];function xa(t,e){var i,o=t.element;o.style&&(xs(t.options.cssProps,(function(n,r){i=ns(o.style,r),e?(t.oldCssProps[i]=o.style[i],o.style[i]=n):o.style[i]=t.oldCssProps[i]||""})),e||(t.oldCssProps={}))}var Ea=function(){function t(t,e){var i,o=this;this.options=Zr({},ka,e||{}),this.options.inputTarget=this.options.inputTarget||t,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=t,this.input=new((i=this).options.inputClass||(vs?Ys:gs?Qs:ps?sa:ia))(i,Fs),this.touchAction=new Cs(this,this.options.touchAction),xa(this,!0),xs(this.options.recognizers,(function(t){var e=o.add(new t[0](t[1]));t[2]&&e.recognizeWith(t[2]),t[3]&&e.requireFailure(t[3])}),this)}var e=t.prototype;return e.set=function(t){return Zr(this.options,t),t.touchAction&&this.touchAction.update(),t.inputTarget&&(this.input.destroy(),this.input.target=t.inputTarget,this.input.init()),this},e.stop=function(t){this.session.stopped=t?2:1},e.recognize=function(t){var e=this.session;if(!e.stopped){var i;this.touchAction.preventDefaults(t);var o=this.recognizers,n=e.curRecognizer;(!n||n&&8&n.state)&&(e.curRecognizer=null,n=null);for(var r=0;r<o.length;)i=o[r],2===e.stopped||n&&i!==n&&!i.canRecognizeWith(n)?i.reset():i.recognize(t),!n&&14&i.state&&(e.curRecognizer=i,n=i),r++}},e.get=function(t){if(t instanceof ua)return t;for(var e=this.recognizers,i=0;i<e.length;i++)if(e[i].options.event===t)return e[i];return null},e.add=function(t){if(aa(t,"add",this))return this;var e=this.get(t.options.event);return e&&this.remove(e),this.recognizers.push(t),t.manager=this,this.touchAction.update(),t},e.remove=function(t){if(aa(t,"remove",this))return this;var e=this.get(t);if(t){var i=this.recognizers,o=Hs(i,e);-1!==o&&(i.splice(o,1),this.touchAction.update())}return this},e.on=function(t,e){if(void 0===t||void 0===e)return this;var i=this.handlers;return xs(Ns(t),(function(t){i[t]=i[t]||[],i[t].push(e)})),this},e.off=function(t,e){if(void 0===t)return this;var i=this.handlers;return xs(Ns(t),(function(t){e?i[t]&&i[t].splice(Hs(i[t],e),1):delete i[t]})),this},e.emit=function(t,e){this.options.domEvents&&function(t,e){var i=document.createEvent("Event");i.initEvent(t,!0,!0),i.gesture=e,e.target.dispatchEvent(i)}(t,e);var i=this.handlers[t]&&this.handlers[t].slice();if(i&&i.length){e.type=t,e.preventDefault=function(){e.srcEvent.preventDefault()};for(var o=0;o<i.length;)i[o](e),o++}},e.destroy=function(){this.element&&xa(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null},t}(),Oa={touchstart:1,touchmove:2,touchend:4,touchcancel:8},Ca="touchstart",Sa="touchstart touchmove touchend touchcancel",Ta=function(t){function e(){var i,o=e.prototype;return o.evTarget=Ca,o.evWin=Sa,(i=t.apply(this,arguments)||this).started=!1,i}return Kr(e,t),e.prototype.handler=function(t){var e=Oa[t.type];if(1===e&&(this.started=!0),this.started){var i=Ma.call(this,t,e);12&e&&i[0].length-i[1].length==0&&(this.started=!1),this.callback(this.manager,e,{pointers:i[0],changedPointers:i[1],pointerType:ys,srcEvent:t})}},e}(Ls);function Ma(t,e){var i=Xs(t.touches),o=Xs(t.changedTouches);return 12&e&&(i=Gs(i.concat(o),"identifier",!0)),[i,o]}function Pa(t,e,i){var o="DEPRECATED METHOD: "+e+"\n"+i+" AT \n";return function(){var e=new Error("get-stack-trace"),i=e&&e.stack?e.stack.replace(/^[^\(]+?[\n$]/gm,"").replace(/^\s+at\s+/gm,"").replace(/^Object.<anonymous>\s*\(/gm,"{anonymous}()@"):"Unknown Stack Trace",n=window.console&&(window.console.warn||window.console.log);return n&&n.call(window.console,o,i),t.apply(this,arguments)}}var Da=Pa((function(t,e,i){for(var o=Object.keys(e),n=0;n<o.length;)(!i||i&&void 0===t[o[n]])&&(t[o[n]]=e[o[n]]),n++;return t}),"extend","Use `assign`."),Ba=Pa((function(t,e){return Da(t,e,!0)}),"merge","Use `assign`.");function Ia(t,e,i){var o,n=e.prototype;(o=t.prototype=Object.create(n)).constructor=t,o._super=n,i&&Zr(o,i)}function za(t,e){return function(){return t.apply(e,arguments)}}var Fa=function(){var t=function(t,e){return void 0===e&&(e={}),new Ea(t,Gr({recognizers:_a.concat()},e))};return t.VERSION="2.0.17-rc",t.DIRECTION_ALL=30,t.DIRECTION_DOWN=bs,t.DIRECTION_LEFT=2,t.DIRECTION_RIGHT=4,t.DIRECTION_UP=8,t.DIRECTION_HORIZONTAL=6,t.DIRECTION_VERTICAL=ws,t.DIRECTION_NONE=1,t.DIRECTION_DOWN=bs,t.INPUT_START=1,t.INPUT_MOVE=2,t.INPUT_END=4,t.INPUT_CANCEL=8,t.STATE_POSSIBLE=1,t.STATE_BEGAN=2,t.STATE_CHANGED=4,t.STATE_ENDED=8,t.STATE_RECOGNIZED=8,t.STATE_CANCELLED=16,t.STATE_FAILED=ha,t.Manager=Ea,t.Input=Ls,t.TouchAction=Cs,t.TouchInput=Qs,t.MouseInput=ia,t.PointerEventInput=Ys,t.TouchMouseInput=sa,t.SingleTouchInput=Ta,t.Recognizer=ua,t.AttrRecognizer=pa,t.Tap=fa,t.Pan=ga,t.Swipe=ya,t.Pinch=ma,t.Rotate=ba,t.Press=wa,t.on=As,t.off=Rs,t.each=xs,t.merge=Ba,t.extend=Da,t.bindFn=za,t.assign=Zr,t.inherit=Ia,t.bindFn=za,t.prefixed=ns,t.toArray=Xs,t.inArray=Hs,t.uniqueArray=Gs,t.splitStr=Ns,t.boolOrFn=Es,t.hasParent=Ss,t.addEventListeners=As,t.removeEventListeners=Rs,t.defaults=Zr({},ka,{preset:_a}),t}();function Na(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return Aa(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return Aa(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function Aa(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}function Ra(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];return ja(e.length?e:[En()])}function ja(t){var e=an(function(){for(var t=La(),e=t(" "),i=t(" "),o=t(" "),n=0;n<arguments.length;n++)(e-=t(n<0||arguments.length<=n?void 0:arguments[n]))<0&&(e+=1),(i-=t(n<0||arguments.length<=n?void 0:arguments[n]))<0&&(i+=1),(o-=t(n<0||arguments.length<=n?void 0:arguments[n]))<0&&(o+=1);return[e,i,o]}(t),3),i=e[0],o=e[1],n=e[2],r=1,s=function(){var t=2091639*i+2.3283064365386963e-10*r;return i=o,o=n,n=t-(r=0|t)};return s.uint32=function(){return 4294967296*s()},s.fract53=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.algorithm="Alea",s.seed=t,s.version="0.9",s}function La(){var t=4022871197;return function(e){for(var i=e.toString(),o=0;o<i.length;o++){var n=.02519603282416938*(t+=i.charCodeAt(o));n-=t=n>>>0,t=(n*=t)>>>0,t+=4294967296*(n-=t)}return 2.3283064365386963e-10*(t>>>0)}}cn("DELETE");var Ha="undefined"!=typeof window?window.Hammer||Fa:function(){return{on:t=function(){},off:t,destroy:t,emit:t,get:function(){return{set:t}}};var t};function Wa(t){var e,i=this;this._cleanupQueue=[],this.active=!1,this._dom={container:t,overlay:document.createElement("div")},this._dom.overlay.classList.add("vis-overlay"),this._dom.container.appendChild(this._dom.overlay),this._cleanupQueue.push((function(){i._dom.overlay.parentNode.removeChild(i._dom.overlay)}));var o=Ha(this._dom.overlay);o.on("tap",bt(e=this._onTapOverlay).call(e,this)),this._cleanupQueue.push((function(){o.destroy()}));var n=["tap","doubletap","press","pinch","pan","panstart","panmove","panend"];Dn(n).call(n,(function(t){o.on(t,(function(t){t.srcEvent.stopPropagation()}))})),document&&document.body&&(this._onClick=function(e){(function(t,e){for(;t;){if(t===e)return!0;t=t.parentNode}return!1})(e.target,t)||i.deactivate()},document.body.addEventListener("click",this._onClick),this._cleanupQueue.push((function(){document.body.removeEventListener("click",i._onClick)}))),this._escListener=function(t){("key"in t?"Escape"===t.key:27===t.keyCode)&&i.deactivate()}}Ct(Wa.prototype),Wa.current=null,Wa.prototype.destroy=function(){var t,e;this.deactivate();var i,o=Na(Nn(t=qn(e=this._cleanupQueue).call(e,0)).call(t));try{for(o.s();!(i=o.n()).done;){(0,i.value)()}}catch(t){o.e(t)}finally{o.f()}},Wa.prototype.activate=function(){Wa.current&&Wa.current.deactivate(),Wa.current=this,this.active=!0,this._dom.overlay.style.display="none",this._dom.container.classList.add("vis-active"),this.emit("change"),this.emit("activate"),document.body.addEventListener("keydown",this._escListener)},Wa.prototype.deactivate=function(){this.active=!1,this._dom.overlay.style.display="block",this._dom.container.classList.remove("vis-active"),document.body.removeEventListener("keydown",this._escListener),this.emit("change"),this.emit("deactivate")},Wa.prototype._onTapOverlay=function(t){this.activate(),t.srcEvent.stopPropagation()};var Va=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,qa=/^#?([a-f\d])([a-f\d])([a-f\d])$/i,Ua=/^rgb\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *\)$/i,Ya=/^rgba\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *([01]|0?\.\d+) *\)$/i;function Xa(t){if(t)for(;!0===t.hasChildNodes();){var e=t.firstChild;e&&(Xa(e),t.removeChild(e))}}function Ga(t){return t instanceof String||"string"==typeof t}function Ka(t){return"object"===dn(t)&&null!==t}function $a(t,e,i,o){var n=!1;!0===o&&(n=null===e[i]&&void 0!==t[i]),n?delete t[i]:t[i]=e[i]}function Qa(t,e){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];for(var o in t)if(void 0!==e[o])if(null===e[o]||"object"!==dn(e[o]))$a(t,e,o,i);else{var n=t[o],r=e[o];Ka(n)&&Ka(r)&&Qa(n,r,i)}}function Za(t,e,i){var o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(gn(i))throw new TypeError("Arrays are not supported by deepExtend");for(var n=0;n<t.length;n++){var r=t[n];if(Object.prototype.hasOwnProperty.call(i,r))if(i[r]&&i[r].constructor===Object)void 0===e[r]&&(e[r]={}),e[r].constructor===Object?th(e[r],i[r],!1,o):$a(e,i,r,o);else{if(gn(i[r]))throw new TypeError("Arrays are not supported by deepExtend");$a(e,i,r,o)}}return e}function Ja(t,e,i){var o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(gn(i))throw new TypeError("Arrays are not supported by deepExtend");for(var n in i)if(Object.prototype.hasOwnProperty.call(i,n)&&!Jn(t).call(t,n))if(i[n]&&i[n].constructor===Object)void 0===e[n]&&(e[n]={}),e[n].constructor===Object?th(e[n],i[n]):$a(e,i,n,o);else if(gn(i[n])){e[n]=[];for(var r=0;r<i[n].length;r++)e[n].push(i[n][r])}else $a(e,i,n,o);return e}function th(t,e){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];for(var n in e)if(Object.prototype.hasOwnProperty.call(e,n)||!0===i)if("object"===dn(e[n])&&null!==e[n]&&ir(e[n])===Object.prototype)void 0===t[n]?t[n]=th({},e[n],i):"object"===dn(t[n])&&null!==t[n]&&ir(t[n])===Object.prototype?th(t[n],e[n],i):$a(t,e,n,o);else if(gn(e[n])){var r;t[n]=vn(r=e[n]).call(r)}else $a(t,e,n,o);return t}function eh(t,e){var i;return pn(i=[]).call(i,ln(t),[e])}function ih(t){return vn(t).call(t)}function oh(t){return t.getBoundingClientRect().top}function nh(t,e){if(gn(t))for(var i=t.length,o=0;o<i;o++)e(t[o],o,t);else for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&e(t[n],n,t)}function rh(t){var e;switch(t.length){case 3:case 4:return(e=qa.exec(t))?{r:kr(e[1]+e[1],16),g:kr(e[2]+e[2],16),b:kr(e[3]+e[3],16)}:null;case 6:case 7:return(e=Va.exec(t))?{r:kr(e[1],16),g:kr(e[2],16),b:kr(e[3],16)}:null;default:return null}}function sh(t,e){if(Jn(t).call(t,"rgba"))return t;if(Jn(t).call(t,"rgb")){var i=t.substr(Mr(t).call(t,"(")+1).replace(")","").split(",");return"rgba("+i[0]+","+i[1]+","+i[2]+","+e+")"}var o=rh(t);return null==o?t:"rgba("+o.r+","+o.g+","+o.b+","+e+")"}function ah(t,e,i){var o;return"#"+vn(o=((1<<24)+(t<<16)+(e<<8)+i).toString(16)).call(o,1)}function hh(t,e){if(Ga(t)){var i=t;if(fh(i)){var o,n=kn(o=i.substr(4).substr(0,i.length-5).split(",")).call(o,(function(t){return kr(t)}));i=ah(n[0],n[1],n[2])}if(!0===uh(i)){var r=function(t){var e=rh(t);if(!e)throw new TypeError("'".concat(t,"' is not a valid color."));return dh(e.r,e.g,e.b)}(i),s={h:r.h,s:.8*r.s,v:Math.min(1,1.02*r.v)},a={h:r.h,s:Math.min(1,1.25*r.s),v:.8*r.v},h=ch(a.h,a.s,a.v),d=ch(s.h,s.s,s.v);return{background:i,border:h,highlight:{background:d,border:h},hover:{background:d,border:h}}}return{background:i,border:i,highlight:{background:i,border:i},hover:{background:i,border:i}}}return e?{background:t.background||e.background,border:t.border||e.border,highlight:Ga(t.highlight)?{border:t.highlight,background:t.highlight}:{background:t.highlight&&t.highlight.background||e.highlight.background,border:t.highlight&&t.highlight.border||e.highlight.border},hover:Ga(t.hover)?{border:t.hover,background:t.hover}:{border:t.hover&&t.hover.border||e.hover.border,background:t.hover&&t.hover.background||e.hover.background}}:{background:t.background||void 0,border:t.border||void 0,highlight:Ga(t.highlight)?{border:t.highlight,background:t.highlight}:{background:t.highlight&&t.highlight.background||void 0,border:t.highlight&&t.highlight.border||void 0},hover:Ga(t.hover)?{border:t.hover,background:t.hover}:{border:t.hover&&t.hover.border||void 0,background:t.hover&&t.hover.background||void 0}}}function dh(t,e,i){t/=255,e/=255,i/=255;var o=Math.min(t,Math.min(e,i)),n=Math.max(t,Math.max(e,i));return o===n?{h:0,s:0,v:o}:{h:60*((t===o?3:i===o?1:5)-(t===o?e-i:i===o?t-e:i-t)/(n-o))/360,s:(n-o)/n,v:n}}function lh(t,e,i){var o,n,r,s=Math.floor(6*t),a=6*t-s,h=i*(1-e),d=i*(1-a*e),l=i*(1-(1-a)*e);switch(s%6){case 0:o=i,n=l,r=h;break;case 1:o=d,n=i,r=h;break;case 2:o=h,n=i,r=l;break;case 3:o=h,n=d,r=i;break;case 4:o=l,n=h,r=i;break;case 5:o=i,n=h,r=d}return{r:Math.floor(255*o),g:Math.floor(255*n),b:Math.floor(255*r)}}function ch(t,e,i){var o=lh(t,e,i);return ah(o.r,o.g,o.b)}function uh(t){return/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t)}function fh(t){return Ua.test(t)}function ph(t){return Ya.test(t)}function vh(t){if(null===t||"object"!==dn(t))return null;if(t instanceof Element)return t;var e=Ir(t);for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&"object"==dn(t[i])&&(e[i]=vh(t[i]));return e}function gh(t,e,i){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},n=function(t){return null!=t},r=function(t){return null!==t&&"object"===dn(t)},s=function(t){for(var e in t)if(Object.prototype.hasOwnProperty.call(t,e))return!1;return!0};if(!r(t))throw new Error("Parameter mergeTarget must be an object");if(!r(e))throw new Error("Parameter options must be an object");if(!n(i))throw new Error("Parameter option must have a value");if(!r(o))throw new Error("Parameter globalOptions must be an object");var a=function(t,e,i){r(t[i])||(t[i]={});var o=e[i],n=t[i];for(var s in o)Object.prototype.hasOwnProperty.call(o,s)&&(n[s]=o[s])},h=e[i],d=r(o)&&!s(o),l=d?o[i]:void 0,c=l?l.enabled:void 0;if(void 0!==h){if("boolean"==typeof h)return r(t[i])||(t[i]={}),void(t[i].enabled=h);if(null===h&&!r(t[i])){if(!n(l))return;t[i]=Ir(l)}if(r(h)){var u=!0;void 0!==h.enabled?u=h.enabled:void 0!==c&&(u=l.enabled),a(t,e,i),t[i].enabled=u}}}var yh={linear:function(t){return t},easeInQuad:function(t){return t*t},easeOutQuad:function(t){return t*(2-t)},easeInOutQuad:function(t){return t<.5?2*t*t:(4-2*t)*t-1},easeInCubic:function(t){return t*t*t},easeOutCubic:function(t){return--t*t*t+1},easeInOutCubic:function(t){return t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1},easeInQuart:function(t){return t*t*t*t},easeOutQuart:function(t){return 1- --t*t*t*t},easeInOutQuart:function(t){return t<.5?8*t*t*t*t:1-8*--t*t*t*t},easeInQuint:function(t){return t*t*t*t*t},easeOutQuint:function(t){return 1+--t*t*t*t*t},easeInOutQuint:function(t){return t<.5?16*t*t*t*t*t:1+16*--t*t*t*t*t}};function mh(t,e){var i;gn(e)||(e=[e]);var o,n=Na(t);try{for(n.s();!(o=n.n()).done;){var r=o.value;if(r){i=r[e[0]];for(var s=1;s<e.length;s++)i&&(i=i[e[s]]);if(void 0!==i)break}}}catch(t){n.e(t)}finally{n.f()}return i}var bh={black:"#000000",navy:"#000080",darkblue:"#00008B",mediumblue:"#0000CD",blue:"#0000FF",darkgreen:"#006400",green:"#008000",teal:"#008080",darkcyan:"#008B8B",deepskyblue:"#00BFFF",darkturquoise:"#00CED1",mediumspringgreen:"#00FA9A",lime:"#00FF00",springgreen:"#00FF7F",aqua:"#00FFFF",cyan:"#00FFFF",midnightblue:"#191970",dodgerblue:"#1E90FF",lightseagreen:"#20B2AA",forestgreen:"#228B22",seagreen:"#2E8B57",darkslategray:"#2F4F4F",limegreen:"#32CD32",mediumseagreen:"#3CB371",turquoise:"#40E0D0",royalblue:"#4169E1",steelblue:"#4682B4",darkslateblue:"#483D8B",mediumturquoise:"#48D1CC",indigo:"#4B0082",darkolivegreen:"#556B2F",cadetblue:"#5F9EA0",cornflowerblue:"#6495ED",mediumaquamarine:"#66CDAA",dimgray:"#696969",slateblue:"#6A5ACD",olivedrab:"#6B8E23",slategray:"#708090",lightslategray:"#778899",mediumslateblue:"#7B68EE",lawngreen:"#7CFC00",chartreuse:"#7FFF00",aquamarine:"#7FFFD4",maroon:"#800000",purple:"#800080",olive:"#808000",gray:"#808080",skyblue:"#87CEEB",lightskyblue:"#87CEFA",blueviolet:"#8A2BE2",darkred:"#8B0000",darkmagenta:"#8B008B",saddlebrown:"#8B4513",darkseagreen:"#8FBC8F",lightgreen:"#90EE90",mediumpurple:"#9370D8",darkviolet:"#9400D3",palegreen:"#98FB98",darkorchid:"#9932CC",yellowgreen:"#9ACD32",sienna:"#A0522D",brown:"#A52A2A",darkgray:"#A9A9A9",lightblue:"#ADD8E6",greenyellow:"#ADFF2F",paleturquoise:"#AFEEEE",lightsteelblue:"#B0C4DE",powderblue:"#B0E0E6",firebrick:"#B22222",darkgoldenrod:"#B8860B",mediumorchid:"#BA55D3",rosybrown:"#BC8F8F",darkkhaki:"#BDB76B",silver:"#C0C0C0",mediumvioletred:"#C71585",indianred:"#CD5C5C",peru:"#CD853F",chocolate:"#D2691E",tan:"#D2B48C",lightgrey:"#D3D3D3",palevioletred:"#D87093",thistle:"#D8BFD8",orchid:"#DA70D6",goldenrod:"#DAA520",crimson:"#DC143C",gainsboro:"#DCDCDC",plum:"#DDA0DD",burlywood:"#DEB887",lightcyan:"#E0FFFF",lavender:"#E6E6FA",darksalmon:"#E9967A",violet:"#EE82EE",palegoldenrod:"#EEE8AA",lightcoral:"#F08080",khaki:"#F0E68C",aliceblue:"#F0F8FF",honeydew:"#F0FFF0",azure:"#F0FFFF",sandybrown:"#F4A460",wheat:"#F5DEB3",beige:"#F5F5DC",whitesmoke:"#F5F5F5",mintcream:"#F5FFFA",ghostwhite:"#F8F8FF",salmon:"#FA8072",antiquewhite:"#FAEBD7",linen:"#FAF0E6",lightgoldenrodyellow:"#FAFAD2",oldlace:"#FDF5E6",red:"#FF0000",fuchsia:"#FF00FF",magenta:"#FF00FF",deeppink:"#FF1493",orangered:"#FF4500",tomato:"#FF6347",hotpink:"#FF69B4",coral:"#FF7F50",darkorange:"#FF8C00",lightsalmon:"#FFA07A",orange:"#FFA500",lightpink:"#FFB6C1",pink:"#FFC0CB",gold:"#FFD700",peachpuff:"#FFDAB9",navajowhite:"#FFDEAD",moccasin:"#FFE4B5",bisque:"#FFE4C4",mistyrose:"#FFE4E1",blanchedalmond:"#FFEBCD",papayawhip:"#FFEFD5",lavenderblush:"#FFF0F5",seashell:"#FFF5EE",cornsilk:"#FFF8DC",lemonchiffon:"#FFFACD",floralwhite:"#FFFAF0",snow:"#FFFAFA",yellow:"#FFFF00",lightyellow:"#FFFFE0",ivory:"#FFFFF0",white:"#FFFFFF"},wh=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;Po(this,t),this.pixelRatio=e,this.generated=!1,this.centerCoordinates={x:144.5,y:144.5},this.r=289*.49,this.color={r:255,g:255,b:255,a:1},this.hueCircle=void 0,this.initialColor={r:255,g:255,b:255,a:1},this.previousColor=void 0,this.applied=!1,this.updateCallback=function(){},this.closeCallback=function(){},this._create()}return Io(t,[{key:"insertTo",value:function(t){void 0!==this.hammer&&(this.hammer.destroy(),this.hammer=void 0),this.container=t,this.container.appendChild(this.frame),this._bindHammer(),this._setSize()}},{key:"setUpdateCallback",value:function(t){if("function"!=typeof t)throw new Error("Function attempted to set as colorPicker update callback is not a function.");this.updateCallback=t}},{key:"setCloseCallback",value:function(t){if("function"!=typeof t)throw new Error("Function attempted to set as colorPicker closing callback is not a function.");this.closeCallback=t}},{key:"_isColorString",value:function(t){if("string"==typeof t)return bh[t]}},{key:"setColor",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if("none"!==t){var i,o=this._isColorString(t);if(void 0!==o&&(t=o),!0===Ga(t)){if(!0===fh(t)){var n=t.substr(4).substr(0,t.length-5).split(",");i={r:n[0],g:n[1],b:n[2],a:1}}else if(!0===ph(t)){var r=t.substr(5).substr(0,t.length-6).split(",");i={r:r[0],g:r[1],b:r[2],a:r[3]}}else if(!0===uh(t)){var s=rh(t);i={r:s.r,g:s.g,b:s.b,a:1}}}else if(t instanceof Object&&void 0!==t.r&&void 0!==t.g&&void 0!==t.b){var a=void 0!==t.a?t.a:"1.0";i={r:t.r,g:t.g,b:t.b,a:a}}if(void 0===i)throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: "+Lr(t));this._setColor(i,e)}}},{key:"show",value:function(){void 0!==this.closeCallback&&(this.closeCallback(),this.closeCallback=void 0),this.applied=!1,this.frame.style.display="block",this._generateHueCircle()}},{key:"_hide",value:function(){var t=this,e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];!0===e&&(this.previousColor=ct({},this.color)),!0===this.applied&&this.updateCallback(this.initialColor),this.frame.style.display="none",qr((function(){void 0!==t.closeCallback&&(t.closeCallback(),t.closeCallback=void 0)}),0)}},{key:"_save",value:function(){this.updateCallback(this.color),this.applied=!1,this._hide()}},{key:"_apply",value:function(){this.applied=!0,this.updateCallback(this.color),this._updatePicker(this.color)}},{key:"_loadLast",value:function(){void 0!==this.previousColor?this.setColor(this.previousColor,!1):alert("There is no last color to load...")}},{key:"_setColor",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];!0===e&&(this.initialColor=ct({},t)),this.color=t;var i=dh(t.r,t.g,t.b),o=2*Math.PI,n=this.r*i.s,r=this.centerCoordinates.x+n*Math.sin(o*i.h),s=this.centerCoordinates.y+n*Math.cos(o*i.h);this.colorPickerSelector.style.left=r-.5*this.colorPickerSelector.clientWidth+"px",this.colorPickerSelector.style.top=s-.5*this.colorPickerSelector.clientHeight+"px",this._updatePicker(t)}},{key:"_setOpacity",value:function(t){this.color.a=t/100,this._updatePicker(this.color)}},{key:"_setBrightness",value:function(t){var e=dh(this.color.r,this.color.g,this.color.b);e.v=t/100;var i=lh(e.h,e.s,e.v);i.a=this.color.a,this.color=i,this._updatePicker()}},{key:"_updatePicker",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.color,e=dh(t.r,t.g,t.b),i=this.colorPickerCanvas.getContext("2d");void 0===this.pixelRation&&(this.pixelRatio=(window.devicePixelRatio||1)/(i.webkitBackingStorePixelRatio||i.mozBackingStorePixelRatio||i.msBackingStorePixelRatio||i.oBackingStorePixelRatio||i.backingStorePixelRatio||1)),i.setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0);var o=this.colorPickerCanvas.clientWidth,n=this.colorPickerCanvas.clientHeight;i.clearRect(0,0,o,n),i.putImageData(this.hueCircle,0,0),i.fillStyle="rgba(0,0,0,"+(1-e.v)+")",i.circle(this.centerCoordinates.x,this.centerCoordinates.y,this.r),Xr(i).call(i),this.brightnessRange.value=100*e.v,this.opacityRange.value=100*t.a,this.initialColorDiv.style.backgroundColor="rgba("+this.initialColor.r+","+this.initialColor.g+","+this.initialColor.b+","+this.initialColor.a+")",this.newColorDiv.style.backgroundColor="rgba("+this.color.r+","+this.color.g+","+this.color.b+","+this.color.a+")"}},{key:"_setSize",value:function(){this.colorPickerCanvas.style.width="100%",this.colorPickerCanvas.style.height="100%",this.colorPickerCanvas.width=289*this.pixelRatio,this.colorPickerCanvas.height=289*this.pixelRatio}},{key:"_create",value:function(){var t,e,i,o;if(this.frame=document.createElement("div"),this.frame.className="vis-color-picker",this.colorPickerDiv=document.createElement("div"),this.colorPickerSelector=document.createElement("div"),this.colorPickerSelector.className="vis-selector",this.colorPickerDiv.appendChild(this.colorPickerSelector),this.colorPickerCanvas=document.createElement("canvas"),this.colorPickerDiv.appendChild(this.colorPickerCanvas),this.colorPickerCanvas.getContext){var n=this.colorPickerCanvas.getContext("2d");this.pixelRatio=(window.devicePixelRatio||1)/(n.webkitBackingStorePixelRatio||n.mozBackingStorePixelRatio||n.msBackingStorePixelRatio||n.oBackingStorePixelRatio||n.backingStorePixelRatio||1),this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0)}else{var r=document.createElement("DIV");r.style.color="red",r.style.fontWeight="bold",r.style.padding="10px",r.innerText="Error: your browser does not support HTML canvas",this.colorPickerCanvas.appendChild(r)}this.colorPickerDiv.className="vis-color",this.opacityDiv=document.createElement("div"),this.opacityDiv.className="vis-opacity",this.brightnessDiv=document.createElement("div"),this.brightnessDiv.className="vis-brightness",this.arrowDiv=document.createElement("div"),this.arrowDiv.className="vis-arrow",this.opacityRange=document.createElement("input");try{this.opacityRange.type="range",this.opacityRange.min="0",this.opacityRange.max="100"}catch(t){}this.opacityRange.value="100",this.opacityRange.className="vis-range",this.brightnessRange=document.createElement("input");try{this.brightnessRange.type="range",this.brightnessRange.min="0",this.brightnessRange.max="100"}catch(t){}this.brightnessRange.value="100",this.brightnessRange.className="vis-range",this.opacityDiv.appendChild(this.opacityRange),this.brightnessDiv.appendChild(this.brightnessRange);var s=this;this.opacityRange.onchange=function(){s._setOpacity(this.value)},this.opacityRange.oninput=function(){s._setOpacity(this.value)},this.brightnessRange.onchange=function(){s._setBrightness(this.value)},this.brightnessRange.oninput=function(){s._setBrightness(this.value)},this.brightnessLabel=document.createElement("div"),this.brightnessLabel.className="vis-label vis-brightness",this.brightnessLabel.innerText="brightness:",this.opacityLabel=document.createElement("div"),this.opacityLabel.className="vis-label vis-opacity",this.opacityLabel.innerText="opacity:",this.newColorDiv=document.createElement("div"),this.newColorDiv.className="vis-new-color",this.newColorDiv.innerText="new",this.initialColorDiv=document.createElement("div"),this.initialColorDiv.className="vis-initial-color",this.initialColorDiv.innerText="initial",this.cancelButton=document.createElement("div"),this.cancelButton.className="vis-button vis-cancel",this.cancelButton.innerText="cancel",this.cancelButton.onclick=bt(t=this._hide).call(t,this,!1),this.applyButton=document.createElement("div"),this.applyButton.className="vis-button vis-apply",this.applyButton.innerText="apply",this.applyButton.onclick=bt(e=this._apply).call(e,this),this.saveButton=document.createElement("div"),this.saveButton.className="vis-button vis-save",this.saveButton.innerText="save",this.saveButton.onclick=bt(i=this._save).call(i,this),this.loadButton=document.createElement("div"),this.loadButton.className="vis-button vis-load",this.loadButton.innerText="load last",this.loadButton.onclick=bt(o=this._loadLast).call(o,this),this.frame.appendChild(this.colorPickerDiv),this.frame.appendChild(this.arrowDiv),this.frame.appendChild(this.brightnessLabel),this.frame.appendChild(this.brightnessDiv),this.frame.appendChild(this.opacityLabel),this.frame.appendChild(this.opacityDiv),this.frame.appendChild(this.newColorDiv),this.frame.appendChild(this.initialColorDiv),this.frame.appendChild(this.cancelButton),this.frame.appendChild(this.applyButton),this.frame.appendChild(this.saveButton),this.frame.appendChild(this.loadButton)}},{key:"_bindHammer",value:function(){var t=this;this.drag={},this.pinch={},this.hammer=new Ha(this.colorPickerCanvas),this.hammer.get("pinch").set({enable:!0}),this.hammer.on("hammer.input",(function(e){e.isFirst&&t._moveSelector(e)})),this.hammer.on("tap",(function(e){t._moveSelector(e)})),this.hammer.on("panstart",(function(e){t._moveSelector(e)})),this.hammer.on("panmove",(function(e){t._moveSelector(e)})),this.hammer.on("panend",(function(e){t._moveSelector(e)}))}},{key:"_generateHueCircle",value:function(){if(!1===this.generated){var t=this.colorPickerCanvas.getContext("2d");void 0===this.pixelRation&&(this.pixelRatio=(window.devicePixelRatio||1)/(t.webkitBackingStorePixelRatio||t.mozBackingStorePixelRatio||t.msBackingStorePixelRatio||t.oBackingStorePixelRatio||t.backingStorePixelRatio||1)),t.setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0);var e,i,o,n,r=this.colorPickerCanvas.clientWidth,s=this.colorPickerCanvas.clientHeight;t.clearRect(0,0,r,s),this.centerCoordinates={x:.5*r,y:.5*s},this.r=.49*r;var a,h=2*Math.PI/360,d=1/this.r;for(o=0;o<360;o++)for(n=0;n<this.r;n++)e=this.centerCoordinates.x+n*Math.sin(h*o),i=this.centerCoordinates.y+n*Math.cos(h*o),a=lh(.002777777777777778*o,n*d,1),t.fillStyle="rgb("+a.r+","+a.g+","+a.b+")",t.fillRect(e-.5,i-.5,2,2);t.strokeStyle="rgba(0,0,0,1)",t.circle(this.centerCoordinates.x,this.centerCoordinates.y,this.r),t.stroke(),this.hueCircle=t.getImageData(0,0,r,s)}this.generated=!0}},{key:"_moveSelector",value:function(t){var e=this.colorPickerDiv.getBoundingClientRect(),i=t.center.x-e.left,o=t.center.y-e.top,n=.5*this.colorPickerDiv.clientHeight,r=.5*this.colorPickerDiv.clientWidth,s=i-r,a=o-n,h=Math.atan2(s,a),d=.98*Math.min(Math.sqrt(s*s+a*a),r),l=Math.cos(h)*d+n,c=Math.sin(h)*d+r;this.colorPickerSelector.style.top=l-.5*this.colorPickerSelector.clientHeight+"px",this.colorPickerSelector.style.left=c-.5*this.colorPickerSelector.clientWidth+"px";var u=h/(2*Math.PI);u=u<0?u+1:u;var f=d/this.r,p=dh(this.color.r,this.color.g,this.color.b);p.h=u,p.s=f;var v=lh(p.h,p.s,p.v);v.a=this.color.a,this.color=v,this.initialColorDiv.style.backgroundColor="rgba("+this.initialColor.r+","+this.initialColor.g+","+this.initialColor.b+","+this.initialColor.a+")",this.newColorDiv.style.backgroundColor="rgba("+this.color.r+","+this.color.g+","+this.color.b+","+this.color.a+")"}}]),t}();function kh(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];if(e.length<1)throw new TypeError("Invalid arguments.");if(1===e.length)return document.createTextNode(e[0]);var o=document.createElement(e[0]);return o.appendChild(kh.apply(void 0,ln(vn(e).call(e,1)))),o}var _h,xh=!1,Eh="background: #FFeeee; color: #dd0000",Oh=Wa,Ch=function(){function t(e,i,o){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:function(){return!1};Po(this,t),this.parent=e,this.changedOptions=[],this.container=i,this.allowCreation=!1,this.hideOption=r,this.options={},this.initialized=!1,this.popupCounter=0,this.defaultOptions={enabled:!1,filter:!0,container:void 0,showButton:!0},ct(this.options,this.defaultOptions),this.configureOptions=o,this.moduleOptions={},this.domElements=[],this.popupDiv={},this.popupLimit=5,this.popupHistory={},this.colorPicker=new wh(n),this.wrapper=void 0}return Io(t,[{key:"setOptions",value:function(t){if(void 0!==t){this.popupHistory={},this._removePopup();var e=!0;if("string"==typeof t)this.options.filter=t;else if(gn(t))this.options.filter=t.join();else if("object"===dn(t)){if(null==t)throw new TypeError("options cannot be null");void 0!==t.container&&(this.options.container=t.container),void 0!==ar(t)&&(this.options.filter=ar(t)),void 0!==t.showButton&&(this.options.showButton=t.showButton),void 0!==t.enabled&&(e=t.enabled)}else"boolean"==typeof t?(this.options.filter=!0,e=t):"function"==typeof t&&(this.options.filter=t,e=!0);!1===ar(this.options)&&(e=!1),this.options.enabled=e}this._clean()}},{key:"setModuleOptions",value:function(t){this.moduleOptions=t,!0===this.options.enabled&&(this._clean(),void 0!==this.options.container&&(this.container=this.options.container),this._create())}},{key:"_create",value:function(){this._clean(),this.changedOptions=[];var t=ar(this.options),e=0,i=!1;for(var o in this.configureOptions)Object.prototype.hasOwnProperty.call(this.configureOptions,o)&&(this.allowCreation=!1,i=!1,"function"==typeof t?i=(i=t(o,[]))||this._handleObject(this.configureOptions[o],[o],!0):!0!==t&&-1===Mr(t).call(t,o)||(i=!0),!1!==i&&(this.allowCreation=!0,e>0&&this._makeItem([]),this._makeHeader(o),this._handleObject(this.configureOptions[o],[o])),e++);this._makeButton(),this._push()}},{key:"_push",value:function(){this.wrapper=document.createElement("div"),this.wrapper.className="vis-configuration-wrapper",this.container.appendChild(this.wrapper);for(var t=0;t<this.domElements.length;t++)this.wrapper.appendChild(this.domElements[t]);this._showPopupIfNeeded()}},{key:"_clean",value:function(){for(var t=0;t<this.domElements.length;t++)this.wrapper.removeChild(this.domElements[t]);void 0!==this.wrapper&&(this.container.removeChild(this.wrapper),this.wrapper=void 0),this.domElements=[],this._removePopup()}},{key:"_getValue",value:function(t){for(var e=this.moduleOptions,i=0;i<t.length;i++){if(void 0===e[t[i]]){e=void 0;break}e=e[t[i]]}return e}},{key:"_makeItem",value:function(t){if(!0===this.allowCreation){var e=document.createElement("div");e.className="vis-configuration vis-config-item vis-config-s"+t.length;for(var i=arguments.length,o=new Array(i>1?i-1:0),n=1;n<i;n++)o[n-1]=arguments[n];return Dn(o).call(o,(function(t){e.appendChild(t)})),this.domElements.push(e),this.domElements.length}return 0}},{key:"_makeHeader",value:function(t){var e=document.createElement("div");e.className="vis-configuration vis-config-header",e.innerText=t,this._makeItem([],e)}},{key:"_makeLabel",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=document.createElement("div");if(o.className="vis-configuration vis-config-label vis-config-s"+e.length,!0===i){for(;o.firstChild;)o.removeChild(o.firstChild);o.appendChild(kh("i","b",t))}else o.innerText=t+":";return o}},{key:"_makeDropdown",value:function(t,e,i){var o=document.createElement("select");o.className="vis-configuration vis-config-select";var n=0;void 0!==e&&-1!==Mr(t).call(t,e)&&(n=Mr(t).call(t,e));for(var r=0;r<t.length;r++){var s=document.createElement("option");s.value=t[r],r===n&&(s.selected="selected"),s.innerText=t[r],o.appendChild(s)}var a=this;o.onchange=function(){a._update(this.value,i)};var h=this._makeLabel(i[i.length-1],i);this._makeItem(i,h,o)}},{key:"_makeRange",value:function(t,e,i){var o=t[0],n=t[1],r=t[2],s=t[3],a=document.createElement("input");a.className="vis-configuration vis-config-range";try{a.type="range",a.min=n,a.max=r}catch(t){}a.step=s;var h="",d=0;if(void 0!==e){var l=1.2;e<0&&e*l<n?(a.min=Math.ceil(e*l),d=a.min,h="range increased"):e/l<n&&(a.min=Math.ceil(e/l),d=a.min,h="range increased"),e*l>r&&1!==r&&(a.max=Math.ceil(e*l),d=a.max,h="range increased"),a.value=e}else a.value=o;var c=document.createElement("input");c.className="vis-configuration vis-config-rangeinput",c.value=a.value;var u=this;a.onchange=function(){c.value=this.value,u._update(Number(this.value),i)},a.oninput=function(){c.value=this.value};var f=this._makeLabel(i[i.length-1],i),p=this._makeItem(i,f,a,c);""!==h&&this.popupHistory[p]!==d&&(this.popupHistory[p]=d,this._setupPopup(h,p))}},{key:"_makeButton",value:function(){var t=this;if(!0===this.options.showButton){var e=document.createElement("div");e.className="vis-configuration vis-config-button",e.innerText="generate options",e.onclick=function(){t._printOptions()},e.onmouseover=function(){e.className="vis-configuration vis-config-button hover"},e.onmouseout=function(){e.className="vis-configuration vis-config-button"},this.optionsContainer=document.createElement("div"),this.optionsContainer.className="vis-configuration vis-config-option-container",this.domElements.push(this.optionsContainer),this.domElements.push(e)}}},{key:"_setupPopup",value:function(t,e){var i=this;if(!0===this.initialized&&!0===this.allowCreation&&this.popupCounter<this.popupLimit){var o=document.createElement("div");o.id="vis-configuration-popup",o.className="vis-configuration-popup",o.innerText=t,o.onclick=function(){i._removePopup()},this.popupCounter+=1,this.popupDiv={html:o,index:e}}}},{key:"_removePopup",value:function(){void 0!==this.popupDiv.html&&(this.popupDiv.html.parentNode.removeChild(this.popupDiv.html),clearTimeout(this.popupDiv.hideTimeout),clearTimeout(this.popupDiv.deleteTimeout),this.popupDiv={})}},{key:"_showPopupIfNeeded",value:function(){var t=this;if(void 0!==this.popupDiv.html){var e=this.domElements[this.popupDiv.index].getBoundingClientRect();this.popupDiv.html.style.left=e.left+"px",this.popupDiv.html.style.top=e.top-30+"px",document.body.appendChild(this.popupDiv.html),this.popupDiv.hideTimeout=qr((function(){t.popupDiv.html.style.opacity=0}),1500),this.popupDiv.deleteTimeout=qr((function(){t._removePopup()}),1800)}}},{key:"_makeCheckbox",value:function(t,e,i){var o=document.createElement("input");o.type="checkbox",o.className="vis-configuration vis-config-checkbox",o.checked=t,void 0!==e&&(o.checked=e,e!==t&&("object"===dn(t)?e!==t.enabled&&this.changedOptions.push({path:i,value:e}):this.changedOptions.push({path:i,value:e})));var n=this;o.onchange=function(){n._update(this.checked,i)};var r=this._makeLabel(i[i.length-1],i);this._makeItem(i,r,o)}},{key:"_makeTextInput",value:function(t,e,i){var o=document.createElement("input");o.type="text",o.className="vis-configuration vis-config-text",o.value=e,e!==t&&this.changedOptions.push({path:i,value:e});var n=this;o.onchange=function(){n._update(this.value,i)};var r=this._makeLabel(i[i.length-1],i);this._makeItem(i,r,o)}},{key:"_makeColorField",value:function(t,e,i){var o=this,n=t[1],r=document.createElement("div");"none"!==(e=void 0===e?n:e)?(r.className="vis-configuration vis-config-colorBlock",r.style.backgroundColor=e):r.className="vis-configuration vis-config-colorBlock none",e=void 0===e?n:e,r.onclick=function(){o._showColorPicker(e,r,i)};var s=this._makeLabel(i[i.length-1],i);this._makeItem(i,s,r)}},{key:"_showColorPicker",value:function(t,e,i){var o=this;e.onclick=function(){},this.colorPicker.insertTo(e),this.colorPicker.show(),this.colorPicker.setColor(t),this.colorPicker.setUpdateCallback((function(t){var n="rgba("+t.r+","+t.g+","+t.b+","+t.a+")";e.style.backgroundColor=n,o._update(n,i)})),this.colorPicker.setCloseCallback((function(){e.onclick=function(){o._showColorPicker(t,e,i)}}))}},{key:"_handleObject",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=!1,n=ar(this.options),r=!1;for(var s in t)if(Object.prototype.hasOwnProperty.call(t,s)){o=!0;var a=t[s],h=eh(e,s);if("function"==typeof n&&!1===(o=n(s,e))&&!gn(a)&&"string"!=typeof a&&"boolean"!=typeof a&&a instanceof Object&&(this.allowCreation=!1,o=this._handleObject(a,h,!0),this.allowCreation=!1===i),!1!==o){r=!0;var d=this._getValue(h);if(gn(a))this._handleArray(a,d,h);else if("string"==typeof a)this._makeTextInput(a,d,h);else if("boolean"==typeof a)this._makeCheckbox(a,d,h);else if(a instanceof Object){if(!this.hideOption(e,s,this.moduleOptions))if(void 0!==a.enabled){var l=eh(h,"enabled"),c=this._getValue(l);if(!0===c){var u=this._makeLabel(s,h,!0);this._makeItem(h,u),r=this._handleObject(a,h)||r}else this._makeCheckbox(a,c,h)}else{var f=this._makeLabel(s,h,!0);this._makeItem(h,f),r=this._handleObject(a,h)||r}}else console.error("dont know how to handle",a,s,h)}}return r}},{key:"_handleArray",value:function(t,e,i){"string"==typeof t[0]&&"color"===t[0]?(this._makeColorField(t,e,i),t[1]!==e&&this.changedOptions.push({path:i,value:e})):"string"==typeof t[0]?(this._makeDropdown(t,e,i),t[0]!==e&&this.changedOptions.push({path:i,value:e})):"number"==typeof t[0]&&(this._makeRange(t,e,i),t[0]!==e&&this.changedOptions.push({path:i,value:Number(e)}))}},{key:"_update",value:function(t,e){var i=this._constructOptions(t,e);this.parent.body&&this.parent.body.emitter&&this.parent.body.emitter.emit&&this.parent.body.emitter.emit("configChange",i),this.initialized=!0,this.parent.setOptions(i)}},{key:"_constructOptions",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=i;t="false"!==(t="true"===t||t)&&t;for(var n=0;n<e.length;n++)"global"!==e[n]&&(void 0===o[e[n]]&&(o[e[n]]={}),n!==e.length-1?o=o[e[n]]:o[e[n]]=t);return i}},{key:"_printOptions",value:function(){for(var t=this.getOptions();this.optionsContainer.firstChild;)this.optionsContainer.removeChild(this.optionsContainer.firstChild);this.optionsContainer.appendChild(kh("pre","const options = "+Lr(t,null,2)))}},{key:"getOptions",value:function(){for(var t={},e=0;e<this.changedOptions.length;e++)this._constructOptions(this.changedOptions[e].value,this.changedOptions[e].path,t);return t}}]),t}(),Sh=Ha,Th=function(){function t(e,i){Po(this,t),this.container=e,this.overflowMethod=i||"cap",this.x=0,this.y=0,this.padding=5,this.hidden=!1,this.frame=document.createElement("div"),this.frame.className="vis-tooltip",this.container.appendChild(this.frame)}return Io(t,[{key:"setPosition",value:function(t,e){this.x=kr(t),this.y=kr(e)}},{key:"setText",value:function(t){if(t instanceof Element){for(;this.frame.firstChild;)this.frame.removeChild(this.frame.firstChild);this.frame.appendChild(t)}else this.frame.innerText=t}},{key:"show",value:function(t){if(void 0===t&&(t=!0),!0===t){var e=this.frame.clientHeight,i=this.frame.clientWidth,o=this.frame.parentNode.clientHeight,n=this.frame.parentNode.clientWidth,r=0,s=0;if("flip"==this.overflowMethod){var a=!1,h=!0;this.y-e<this.padding&&(h=!1),this.x+i>n-this.padding&&(a=!0),r=a?this.x-i:this.x,s=h?this.y-e:this.y}else(s=this.y-e)+e+this.padding>o&&(s=o-e-this.padding),s<this.padding&&(s=this.padding),(r=this.x)+i+this.padding>n&&(r=n-i-this.padding),r<this.padding&&(r=this.padding);this.frame.style.left=r+"px",this.frame.style.top=s+"px",this.frame.style.visibility="visible",this.hidden=!1}else this.hide()}},{key:"hide",value:function(){this.hidden=!0,this.frame.style.left="0",this.frame.style.top="0",this.frame.style.visibility="hidden"}},{key:"destroy",value:function(){this.frame.parentNode.removeChild(this.frame)}}]),t}(),Mh=Eh,Ph=function(){function t(){Po(this,t)}return Io(t,null,[{key:"validate",value:function(e,i,o){xh=!1,_h=i;var n=i;return void 0!==o&&(n=i[o]),t.parse(e,n,[]),xh}},{key:"parse",value:function(e,i,o){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.check(n,e,i,o)}},{key:"check",value:function(e,i,o,n){if(void 0!==o[e]||void 0!==o.__any__){var r=e,s=!0;void 0===o[e]&&void 0!==o.__any__&&(r="__any__",s="object"===t.getType(i[e]));var a=o[r];s&&void 0!==a.__type__&&(a=a.__type__),t.checkFields(e,i,o,r,a,n)}else t.getSuggestion(e,o,n)}},{key:"checkFields",value:function(e,i,o,n,r,s){var a=function(i){console.error("%c"+i+t.printLocation(s,e),Eh)},h=t.getType(i[e]),d=r[h];void 0!==d?"array"===t.getType(d)&&-1===Mr(d).call(d,i[e])?(a('Invalid option detected in "'+e+'". Allowed values are:'+t.print(d)+' not "'+i[e]+'". '),xh=!0):"object"===h&&"__any__"!==n&&(s=eh(s,e),t.parse(i[e],o[n],s)):void 0===r.any&&(a('Invalid type received for "'+e+'". Expected: '+t.print(xn(r))+". Received ["+h+'] "'+i[e]+'"'),xh=!0)}},{key:"getType",value:function(t){var e=dn(t);return"object"===e?null===t?"null":t instanceof Boolean?"boolean":t instanceof Number?"number":t instanceof String?"string":gn(t)?"array":t instanceof Date?"date":void 0!==t.nodeType?"dom":!0===t._isAMomentObject?"moment":"object":"number"===e?"number":"boolean"===e?"boolean":"string"===e?"string":void 0===e?"undefined":e}},{key:"getSuggestion",value:function(e,i,o){var n,r=t.findInOptions(e,i,o,!1),s=t.findInOptions(e,_h,[],!0);n=void 0!==r.indexMatch?" in "+t.printLocation(r.path,e,"")+'Perhaps it was incomplete? Did you mean: "'+r.indexMatch+'"?\n\n':s.distance<=4&&r.distance>s.distance?" in "+t.printLocation(r.path,e,"")+"Perhaps it was misplaced? Matching option found at: "+t.printLocation(s.path,s.closestMatch,""):r.distance<=8?'. Did you mean "'+r.closestMatch+'"?'+t.printLocation(r.path,e):". Did you mean one of these: "+t.print(xn(i))+t.printLocation(o,e),console.error('%cUnknown option detected: "'+e+'"'+n,Eh),xh=!0}},{key:"findInOptions",value:function(e,i,o){var n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=1e9,s="",a=[],h=e.toLowerCase(),d=void 0;for(var l in i){var c=void 0;if(void 0!==i[l].__type__&&!0===n){var u=t.findInOptions(e,i[l],eh(o,l));r>u.distance&&(s=u.closestMatch,a=u.path,r=u.distance,d=u.indexMatch)}else{var f;-1!==Mr(f=l.toLowerCase()).call(f,h)&&(d=l),r>(c=t.levenshteinDistance(e,l))&&(s=l,a=ih(o),r=c)}}return{closestMatch:s,path:a,distance:r,indexMatch:d}}},{key:"printLocation",value:function(t,e){for(var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Problem value found at: \n",o="\n\n"+i+"options = {\n",n=0;n<t.length;n++){for(var r=0;r<n+1;r++)o+="  ";o+=t[n]+": {\n"}for(var s=0;s<t.length+1;s++)o+="  ";o+=e+"\n";for(var a=0;a<t.length+1;a++){for(var h=0;h<t.length-a;h++)o+="  ";o+="}\n"}return o+"\n\n"}},{key:"print",value:function(t){return Lr(t).replace(/(")|(\[)|(\])|(,"__type__")/g,"").replace(/(,)/g,", ")}},{key:"levenshteinDistance",value:function(t,e){if(0===t.length)return e.length;if(0===e.length)return t.length;var i,o,n=[];for(i=0;i<=e.length;i++)n[i]=[i];for(o=0;o<=t.length;o++)n[0][o]=o;for(i=1;i<=e.length;i++)for(o=1;o<=t.length;o++)e.charAt(i-1)==t.charAt(o-1)?n[i][o]=n[i-1][o-1]:n[i][o]=Math.min(n[i-1][o-1]+1,Math.min(n[i][o-1]+1,n[i-1][o]+1));return n[e.length][t.length]}}]),t}();function Dh(t){return jh=t,function(){var t={};Lh=0,void(Hh=jh.charAt(0)),Zh(),"strict"===Wh&&(t.strict=!0,Zh());"graph"!==Wh&&"digraph"!==Wh||(t.type=Wh,Zh());Vh===Nh&&(t.id=Wh,Zh());if("{"!=Wh)throw nd("Angle bracket { expected");if(Zh(),Jh(t),"}"!=Wh)throw nd("Angle bracket } expected");if(Zh(),""!==Wh)throw nd("End of file expected");return Zh(),delete t.node,delete t.edge,delete t.graph,t}()}var Bh={fontsize:"font.size",fontcolor:"font.color",labelfontcolor:"font.color",fontname:"font.face",color:["color.border","color.background"],fillcolor:"color.background",tooltip:"title",labeltooltip:"title"},Ih=Ir(Bh);Ih.color="color.color",Ih.style="dashes";var zh=0,Fh=1,Nh=2,Ah=3,Rh={"{":!0,"}":!0,"[":!0,"]":!0,";":!0,"=":!0,",":!0,"->":!0,"--":!0},jh="",Lh=0,Hh="",Wh="",Vh=zh;function qh(){Lh++,Hh=jh.charAt(Lh)}function Uh(){return jh.charAt(Lh+1)}function Yh(t){var e=t.charCodeAt(0);return e<47?35===e||46===e:e<59?e>47:e<91?e>64:e<96?95===e:e<123&&e>96}function Xh(t,e){if(t||(t={}),e)for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);return t}function Gh(t,e,i){for(var o=e.split("."),n=t;o.length;){var r=o.shift();o.length?(n[r]||(n[r]={}),n=n[r]):n[r]=i}}function Kh(t,e){for(var i,o,n=null,r=[t],s=t;s.parent;)r.push(s.parent),s=s.parent;if(s.nodes)for(i=0,o=s.nodes.length;i<o;i++)if(e.id===s.nodes[i].id){n=s.nodes[i];break}for(n||(n={id:e.id},t.node&&(n.attr=Xh(n.attr,t.node))),i=r.length-1;i>=0;i--){var a,h=r[i];h.nodes||(h.nodes=[]),-1===Mr(a=h.nodes).call(a,n)&&h.nodes.push(n)}e.attr&&(n.attr=Xh(n.attr,e.attr))}function $h(t,e){if(t.edges||(t.edges=[]),t.edges.push(e),t.edge){var i=Xh({},t.edge);e.attr=Xh(i,e.attr)}}function Qh(t,e,i,o,n){var r={from:e,to:i,type:o};return t.edge&&(r.attr=Xh({},t.edge)),r.attr=Xh(r.attr||{},n),null!=n&&n.hasOwnProperty("arrows")&&null!=n.arrows&&(r.arrows={to:{enabled:!0,type:n.arrows.type}},n.arrows=null),r}function Zh(){for(Vh=zh,Wh="";" "===Hh||"\t"===Hh||"\n"===Hh||"\r"===Hh;)qh();do{var t=!1;if("#"===Hh){for(var e=Lh-1;" "===jh.charAt(e)||"\t"===jh.charAt(e);)e--;if("\n"===jh.charAt(e)||""===jh.charAt(e)){for(;""!=Hh&&"\n"!=Hh;)qh();t=!0}}if("/"===Hh&&"/"===Uh()){for(;""!=Hh&&"\n"!=Hh;)qh();t=!0}if("/"===Hh&&"*"===Uh()){for(;""!=Hh;){if("*"===Hh&&"/"===Uh()){qh(),qh();break}qh()}t=!0}for(;" "===Hh||"\t"===Hh||"\n"===Hh||"\r"===Hh;)qh()}while(t);if(""!==Hh){var i=Hh+Uh();if(Rh[i])return Vh=Fh,Wh=i,qh(),void qh();if(Rh[Hh])return Vh=Fh,Wh=Hh,void qh();if(Yh(Hh)||"-"===Hh){for(Wh+=Hh,qh();Yh(Hh);)Wh+=Hh,qh();return"false"===Wh?Wh=!1:"true"===Wh?Wh=!0:isNaN(Number(Wh))||(Wh=Number(Wh)),void(Vh=Nh)}if('"'===Hh){for(qh();""!=Hh&&('"'!=Hh||'"'===Hh&&'"'===Uh());)'"'===Hh?(Wh+=Hh,qh()):"\\"===Hh&&"n"===Uh()?(Wh+="\n",qh()):Wh+=Hh,qh();if('"'!=Hh)throw nd('End of string " expected');return qh(),void(Vh=Nh)}for(Vh=Ah;""!=Hh;)Wh+=Hh,qh();throw new SyntaxError('Syntax error in part "'+rd(Wh,30)+'"')}Vh=Fh}function Jh(t){for(;""!==Wh&&"}"!=Wh;)td(t),";"===Wh&&Zh()}function td(t){var e=ed(t);if(e)id(t,e);else if(!function(t){if("node"===Wh)return Zh(),t.node=od(),"node";if("edge"===Wh)return Zh(),t.edge=od(),"edge";if("graph"===Wh)return Zh(),t.graph=od(),"graph";return null}(t)){if(Vh!=Nh)throw nd("Identifier expected");var i=Wh;if(Zh(),"="===Wh){if(Zh(),Vh!=Nh)throw nd("Identifier expected");t[i]=Wh,Zh()}else!function(t,e){var i={id:e},o=od();o&&(i.attr=o);Kh(t,i),id(t,e)}(t,i)}}function ed(t){var e=null;if("subgraph"===Wh&&((e={}).type="subgraph",Zh(),Vh===Nh&&(e.id=Wh,Zh())),"{"===Wh){if(Zh(),e||(e={}),e.parent=t,e.node=t.node,e.edge=t.edge,e.graph=t.graph,Jh(e),"}"!=Wh)throw nd("Angle bracket } expected");Zh(),delete e.node,delete e.edge,delete e.graph,delete e.parent,t.subgraphs||(t.subgraphs=[]),t.subgraphs.push(e)}return e}function id(t,e){for(;"->"===Wh||"--"===Wh;){var i,o=Wh;Zh();var n=ed(t);if(n)i=n;else{if(Vh!=Nh)throw nd("Identifier or subgraph expected");Kh(t,{id:i=Wh}),Zh()}$h(t,Qh(t,e,i,o,od())),e=i}}function od(){for(var t,e,i=null,o={dashed:!0,solid:!1,dotted:[1,5]},n={dot:"circle",box:"box",crow:"crow",curve:"curve",icurve:"inv_curve",normal:"triangle",inv:"inv_triangle",diamond:"diamond",tee:"bar",vee:"vee"},r=new Array,s=new Array;"["===Wh;){for(Zh(),i={};""!==Wh&&"]"!=Wh;){if(Vh!=Nh)throw nd("Attribute name expected");var a=Wh;if(Zh(),"="!=Wh)throw nd("Equal sign = expected");if(Zh(),Vh!=Nh)throw nd("Attribute value expected");var h=Wh;"style"===a&&(h=o[h]),"arrowhead"===a&&(a="arrows",h={to:{enabled:!0,type:n[h]}}),"arrowtail"===a&&(a="arrows",h={from:{enabled:!0,type:n[h]}}),r.push({attr:i,name:a,value:h}),s.push(a),Zh(),","==Wh&&Zh()}if("]"!=Wh)throw nd("Bracket ] expected");Zh()}if(Jn(s).call(s,"dir")){var d={arrows:{}};for(t=0;t<r.length;t++)if("arrows"===r[t].name)if(null!=r[t].value.to)d.arrows.to=t;else{if(null==r[t].value.from)throw nd("Invalid value of arrows");d.arrows.from=t}else"dir"===r[t].name&&(d.dir=t);var l,c,u=r[d.dir].value;if(!Jn(s).call(s,"arrows"))if("both"===u)r.push({attr:r[d.dir].attr,name:"arrows",value:{to:{enabled:!0}}}),d.arrows.to=r.length-1,r.push({attr:r[d.dir].attr,name:"arrows",value:{from:{enabled:!0}}}),d.arrows.from=r.length-1;else if("forward"===u)r.push({attr:r[d.dir].attr,name:"arrows",value:{to:{enabled:!0}}}),d.arrows.to=r.length-1;else if("back"===u)r.push({attr:r[d.dir].attr,name:"arrows",value:{from:{enabled:!0}}}),d.arrows.from=r.length-1;else{if("none"!==u)throw nd('Invalid dir type "'+u+'"');r.push({attr:r[d.dir].attr,name:"arrows",value:""}),d.arrows.to=r.length-1}if("both"===u)d.arrows.to&&d.arrows.from?(c=r[d.arrows.to].value.to.type,l=r[d.arrows.from].value.from.type,r[d.arrows.to]={attr:r[d.arrows.to].attr,name:r[d.arrows.to].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}},qn(r).call(r,d.arrows.from,1)):d.arrows.to?(c=r[d.arrows.to].value.to.type,l="arrow",r[d.arrows.to]={attr:r[d.arrows.to].attr,name:r[d.arrows.to].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}}):d.arrows.from&&(c="arrow",l=r[d.arrows.from].value.from.type,r[d.arrows.from]={attr:r[d.arrows.from].attr,name:r[d.arrows.from].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}});else if("back"===u)d.arrows.to&&d.arrows.from?(c="",l=r[d.arrows.from].value.from.type,r[d.arrows.from]={attr:r[d.arrows.from].attr,name:r[d.arrows.from].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}}):d.arrows.to?(c="",l="arrow",d.arrows.from=d.arrows.to,r[d.arrows.from]={attr:r[d.arrows.from].attr,name:r[d.arrows.from].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}}):d.arrows.from&&(c="",l=r[d.arrows.from].value.from.type,r[d.arrows.to]={attr:r[d.arrows.from].attr,name:r[d.arrows.from].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}}),r[d.arrows.from]={attr:r[d.arrows.from].attr,name:r[d.arrows.from].name,value:{from:{enabled:!0,type:r[d.arrows.from].value.from.type}}};else if("none"===u){var f;r[f=d.arrows.to?d.arrows.to:d.arrows.from]={attr:r[f].attr,name:r[f].name,value:""}}else{if("forward"!==u)throw nd('Invalid dir type "'+u+'"');d.arrows.to&&d.arrows.from||d.arrows.to?(c=r[d.arrows.to].value.to.type,l="",r[d.arrows.to]={attr:r[d.arrows.to].attr,name:r[d.arrows.to].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}}):d.arrows.from&&(c="arrow",l="",d.arrows.to=d.arrows.from,r[d.arrows.to]={attr:r[d.arrows.to].attr,name:r[d.arrows.to].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}}),r[d.arrows.to]={attr:r[d.arrows.to].attr,name:r[d.arrows.to].name,value:{to:{enabled:!0,type:r[d.arrows.to].value.to.type}}}}qn(r).call(r,d.dir,1)}if(Jn(s).call(s,"penwidth")){var p=[];for(e=r.length,t=0;t<e;t++)"width"!==r[t].name&&("penwidth"===r[t].name&&(r[t].name="width"),p.push(r[t]));r=p}for(e=r.length,t=0;t<e;t++)Gh(r[t].attr,r[t].name,r[t].value);return i}function nd(t){return new SyntaxError(t+', got "'+rd(Wh,30)+'" (char '+Lh+")")}function rd(t,e){return t.length<=e?t:t.substr(0,27)+"..."}function sd(t,e,i){for(var o=e.split("."),n=o.pop(),r=t,s=0;s<o.length;s++){var a=o[s];a in r||(r[a]={}),r=r[a]}return r[n]=i,t}function ad(t,e){var i={};for(var o in t)if(t.hasOwnProperty(o)){var n=e[o];gn(n)?Dn(n).call(n,(function(e){sd(i,e,t[o])})):sd(i,"string"==typeof n?n:o,t[o])}return i}function hd(t){var e,i=Dh(t),o={nodes:[],edges:[],options:{}};i.nodes&&Dn(e=i.nodes).call(e,(function(t){var e={id:t.id,label:String(t.label||t.id)};Xh(e,ad(t.attr,Bh)),e.image&&(e.shape="image"),o.nodes.push(e)}));if(i.edges){var n,r=function(t){var e={from:t.from,to:t.to};return Xh(e,ad(t.attr,Ih)),null==e.arrows&&"->"===t.type&&(e.arrows="to"),e};Dn(n=i.edges).call(n,(function(t){var e,i,n,s,a,h,d;(e=t.from instanceof Object?t.from.nodes:{id:t.from},i=t.to instanceof Object?t.to.nodes:{id:t.to},t.from instanceof Object&&t.from.edges)&&Dn(n=t.from.edges).call(n,(function(t){var e=r(t);o.edges.push(e)}));(a=i,h=function(e,i){var n=Qh(o,e.id,i.id,t.type,t.attr),s=r(n);o.edges.push(s)},gn(s=e)?Dn(s).call(s,(function(t){gn(a)?Dn(a).call(a,(function(e){h(t,e)})):h(t,a)})):gn(a)?Dn(a).call(a,(function(t){h(s,t)})):h(s,a),t.to instanceof Object&&t.to.edges)&&Dn(d=t.to.edges).call(d,(function(t){var e=r(t);o.edges.push(e)}))}))}return i.attr&&(o.options=i.attr),o}var dd=Object.freeze({__proto__:null,parseDOT:Dh,DOTToGraph:hd});function ld(t,e){var i,o={edges:{inheritColor:!1},nodes:{fixed:!1,parseColor:!1}};null!=e&&(null!=e.fixed&&(o.nodes.fixed=e.fixed),null!=e.parseColor&&(o.nodes.parseColor=e.parseColor),null!=e.inheritColor&&(o.edges.inheritColor=e.inheritColor));var n=t.edges,r=kn(n).call(n,(function(t){var e={from:t.source,id:t.id,to:t.target};return null!=t.attributes&&(e.attributes=t.attributes),null!=t.label&&(e.label=t.label),null!=t.attributes&&null!=t.attributes.title&&(e.title=t.attributes.title),"Directed"===t.type&&(e.arrows="to"),t.color&&!1===o.edges.inheritColor&&(e.color=t.color),e}));return{nodes:kn(i=t.nodes).call(i,(function(t){var e={id:t.id,fixed:o.nodes.fixed&&null!=t.x&&null!=t.y};return null!=t.attributes&&(e.attributes=t.attributes),null!=t.label&&(e.label=t.label),null!=t.size&&(e.size=t.size),null!=t.attributes&&null!=t.attributes.title&&(e.title=t.attributes.title),null!=t.title&&(e.title=t.title),null!=t.x&&(e.x=t.x),null!=t.y&&(e.y=t.y),null!=t.color&&(!0===o.nodes.parseColor?e.color=t.color:e.color={background:t.color,border:t.color,highlight:{background:t.color,border:t.color},hover:{background:t.color,border:t.color}}),e})),edges:r}}var cd=Object.freeze({__proto__:null,parseGephi:ld}),ud=Object.freeze({__proto__:null,en:{addDescription:"Click in an empty space to place a new node.",addEdge:"Add Edge",addNode:"Add Node",back:"Back",close:"Close",createEdgeError:"Cannot link edges to a cluster.",del:"Delete selected",deleteClusterError:"Clusters cannot be deleted.",edgeDescription:"Click on a node and drag the edge to another node to connect them.",edit:"Edit",editClusterError:"Clusters cannot be edited.",editEdge:"Edit Edge",editEdgeDescription:"Click on the control points and drag them to a node to connect to it.",editNode:"Edit Node"},de:{addDescription:"Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.",addEdge:"Kante hinzufügen",addNode:"Knoten hinzufügen",back:"Zurück",close:"Schließen",createEdgeError:"Es ist nicht möglich, Kanten mit Clustern zu verbinden.",del:"Lösche Auswahl",deleteClusterError:"Cluster können nicht gelöscht werden.",edgeDescription:"Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.",edit:"Editieren",editClusterError:"Cluster können nicht editiert werden.",editEdge:"Kante editieren",editEdgeDescription:"Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.",editNode:"Knoten editieren"},es:{addDescription:"Haga clic en un lugar vacío para colocar un nuevo nodo.",addEdge:"Añadir arista",addNode:"Añadir nodo",back:"Atrás",close:"Cerrar",createEdgeError:"No se puede conectar una arista a un grupo.",del:"Eliminar selección",deleteClusterError:"No es posible eliminar grupos.",edgeDescription:"Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.",edit:"Editar",editClusterError:"No es posible editar grupos.",editEdge:"Editar arista",editEdgeDescription:"Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.",editNode:"Editar nodo"},it:{addDescription:"Clicca per aggiungere un nuovo nodo",addEdge:"Aggiungi un vertice",addNode:"Aggiungi un nodo",back:"Indietro",close:"Chiudere",createEdgeError:"Non si possono collegare vertici ad un cluster",del:"Cancella la selezione",deleteClusterError:"I cluster non possono essere cancellati",edgeDescription:"Clicca su un nodo e trascinalo ad un altro nodo per connetterli.",edit:"Modifica",editClusterError:"I clusters non possono essere modificati.",editEdge:"Modifica il vertice",editEdgeDescription:"Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.",editNode:"Modifica il nodo"},nl:{addDescription:"Klik op een leeg gebied om een nieuwe node te maken.",addEdge:"Link toevoegen",addNode:"Node toevoegen",back:"Terug",close:"Sluiten",createEdgeError:"Kan geen link maken naar een cluster.",del:"Selectie verwijderen",deleteClusterError:"Clusters kunnen niet worden verwijderd.",edgeDescription:"Klik op een node en sleep de link naar een andere node om ze te verbinden.",edit:"Wijzigen",editClusterError:"Clusters kunnen niet worden aangepast.",editEdge:"Link wijzigen",editEdgeDescription:"Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.",editNode:"Node wijzigen"},pt:{addDescription:"Clique em um espaço em branco para adicionar um novo nó",addEdge:"Adicionar aresta",addNode:"Adicionar nó",back:"Voltar",close:"Fechar",createEdgeError:"Não foi possível linkar arestas a um cluster.",del:"Remover selecionado",deleteClusterError:"Clusters não puderam ser removidos.",edgeDescription:"Clique em um nó e arraste a aresta até outro nó para conectá-los",edit:"Editar",editClusterError:"Clusters não puderam ser editados.",editEdge:"Editar aresta",editEdgeDescription:"Clique nos pontos de controle e os arraste para um nó para conectá-los",editNode:"Editar nó"},ru:{addDescription:"Кликните в свободное место, чтобы добавить новый узел.",addEdge:"Добавить ребро",addNode:"Добавить узел",back:"Назад",close:"Закрывать",createEdgeError:"Невозможно соединить ребра в кластер.",del:"Удалить выбранное",deleteClusterError:"Кластеры не могут быть удалены",edgeDescription:"Кликните на узел и протяните ребро к другому узлу, чтобы соединить их.",edit:"Редактировать",editClusterError:"Кластеры недоступны для редактирования.",editEdge:"Редактировать ребро",editEdgeDescription:"Кликните на контрольные точки и перетащите их в узел, чтобы подключиться к нему.",editNode:"Редактировать узел"},cn:{addDescription:"单击空白处放置新节点。",addEdge:"添加连接线",addNode:"添加节点",back:"返回",close:"關閉",createEdgeError:"无法将连接线连接到群集。",del:"删除选定",deleteClusterError:"无法删除群集。",edgeDescription:"单击某个节点并将该连接线拖动到另一个节点以连接它们。",edit:"编辑",editClusterError:"无法编辑群集。",editEdge:"编辑连接线",editEdgeDescription:"单击控制节点并将它们拖到节点上连接。",editNode:"编辑节点"},uk:{addDescription:"Kлікніть на вільне місце, щоб додати новий вузол.",addEdge:"Додати край",addNode:"Додати вузол",back:"Назад",close:"Закрити",createEdgeError:"Не можливо об'єднати краї в групу.",del:"Видалити обране",deleteClusterError:"Групи не можуть бути видалені.",edgeDescription:"Клікніть на вузол і перетягніть край до іншого вузла, щоб їх з'єднати.",edit:"Редагувати",editClusterError:"Групи недоступні для редагування.",editEdge:"Редагувати край",editEdgeDescription:"Клікніть на контрольні точки і перетягніть їх у вузол, щоб підключитися до нього.",editNode:"Редагувати вузол"},fr:{addDescription:"Cliquez dans un endroit vide pour placer un nœud.",addEdge:"Ajouter un lien",addNode:"Ajouter un nœud",back:"Retour",close:"Fermer",createEdgeError:"Impossible de créer un lien vers un cluster.",del:"Effacer la sélection",deleteClusterError:"Les clusters ne peuvent pas être effacés.",edgeDescription:"Cliquez sur un nœud et glissez le lien vers un autre nœud pour les connecter.",edit:"Éditer",editClusterError:"Les clusters ne peuvent pas être édités.",editEdge:"Éditer le lien",editEdgeDescription:"Cliquez sur les points de contrôle et glissez-les pour connecter un nœud.",editNode:"Éditer le nœud"},cs:{addDescription:"Kluknutím do prázdného prostoru můžete přidat nový vrchol.",addEdge:"Přidat hranu",addNode:"Přidat vrchol",back:"Zpět",close:"Zavřít",createEdgeError:"Nelze připojit hranu ke shluku.",del:"Smazat výběr",deleteClusterError:"Nelze mazat shluky.",edgeDescription:"Přetažením z jednoho vrcholu do druhého můžete spojit tyto vrcholy novou hranou.",edit:"Upravit",editClusterError:"Nelze upravovat shluky.",editEdge:"Upravit hranu",editEdgeDescription:"Přetažením kontrolního vrcholu hrany ji můžete připojit k jinému vrcholu.",editNode:"Upravit vrchol"}});var fd=function(){function t(){Po(this,t),this.NUM_ITERATIONS=4,this.image=new Image,this.canvas=document.createElement("canvas")}return Io(t,[{key:"init",value:function(){if(!this.initialized()){this.src=this.image.src;var t=this.image.width,e=this.image.height;this.width=t,this.height=e;var i=Math.floor(e/2),o=Math.floor(e/4),n=Math.floor(e/8),r=Math.floor(e/16),s=Math.floor(t/2),a=Math.floor(t/4),h=Math.floor(t/8),d=Math.floor(t/16);this.canvas.width=3*a,this.canvas.height=i,this.coordinates=[[0,0,s,i],[s,0,a,o],[s,o,h,n],[5*h,o,d,r]],this._fillMipMap()}}},{key:"initialized",value:function(){return void 0!==this.coordinates}},{key:"_fillMipMap",value:function(){var t=this.canvas.getContext("2d"),e=this.coordinates[0];t.drawImage(this.image,e[0],e[1],e[2],e[3]);for(var i=1;i<this.NUM_ITERATIONS;i++){var o=this.coordinates[i-1],n=this.coordinates[i];t.drawImage(this.canvas,o[0],o[1],o[2],o[3],n[0],n[1],n[2],n[3])}}},{key:"drawImageAtPosition",value:function(t,e,i,o,n,r){if(this.initialized())if(e>2){e*=.5;for(var s=0;e>2&&s<this.NUM_ITERATIONS;)e*=.5,s+=1;s>=this.NUM_ITERATIONS&&(s=this.NUM_ITERATIONS-1);var a=this.coordinates[s];t.drawImage(this.canvas,a[0],a[1],a[2],a[3],i,o,n,r)}else t.drawImage(this.image,i,o,n,r)}}]),t}(),pd=function(){function t(e){Po(this,t),this.images={},this.imageBroken={},this.callback=e}return Io(t,[{key:"_tryloadBrokenUrl",value:function(t,e,i){void 0!==t&&void 0!==i&&(void 0!==e?(i.image.onerror=function(){console.error("Could not load brokenImage:",e)},i.image.src=e):console.warn("No broken url image defined"))}},{key:"_redrawWithImage",value:function(t){this.callback&&this.callback(t)}},{key:"load",value:function(t,e){var i=this,o=this.images[t];if(o)return o;var n=new fd;return this.images[t]=n,n.image.onload=function(){i._fixImageCoordinates(n.image),n.init(),i._redrawWithImage(n)},n.image.onerror=function(){console.error("Could not load image:",t),i._tryloadBrokenUrl(t,e,n)},n.image.src=t,n}},{key:"_fixImageCoordinates",value:function(t){0===t.width&&(document.body.appendChild(t),t.width=t.offsetWidth,t.height=t.offsetHeight,document.body.removeChild(t))}}]),t}(),vd=!s((function(){return Object.isExtensible(Object.preventExtensions({}))})),gd=o((function(t){var e=L.f,i=Ht("meta"),o=0,n=Object.isExtensible||function(){return!0},r=function(t){e(t,i,{value:{objectID:"O"+ ++o,weakData:{}}})},s=t.exports={REQUIRED:!1,fastKey:function(t,e){if(!m(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!k(t,i)){if(!n(t))return"F";if(!e)return"E";r(t)}return t[i].objectID},getWeakData:function(t,e){if(!k(t,i)){if(!n(t))return!0;if(!e)return!1;r(t)}return t[i].weakData},onFreeze:function(t){return vd&&s.REQUIRED&&n(t)&&!k(t,i)&&r(t),t}};et[i]=!0})),yd=function(t,e){this.stopped=t,this.result=e},md=function(t,e,i){var o,n,r,s,a,h,d,l=i&&i.that,c=!(!i||!i.AS_ENTRIES),u=!(!i||!i.IS_ITERATOR),f=!(!i||!i.INTERRUPTED),p=A(e,l,1+c+f),v=function(t){return o&&ni(o),new yd(!0,t)},g=function(t){return c?(R(t),f?p(t[0],t[1],v):p(t[0],t[1])):f?p(t,v):p(t)};if(u)o=t;else{if("function"!=typeof(n=ci(t)))throw TypeError("Target is not iterable");if(hi(n)){for(r=0,s=K(t.length);s>r;r++)if((a=g(t[r]))&&a instanceof yd)return a;return new yd(!1)}o=n.call(t)}for(h=o.next;!(d=h.call(o)).done;){try{a=g(d.value)}catch(t){throw ni(o),t}if("object"==typeof a&&a&&a instanceof yd)return a}return new yd(!1)},bd=function(t,e,i){if(!(t instanceof e))throw TypeError("Incorrect "+(i?i+" ":"")+"invocation");return t},wd=L.f,kd=Wi.forEach,_d=Zt.set,xd=Zt.getterFor,Ed=function(t,e,i){var o,n=-1!==t.indexOf("Map"),h=-1!==t.indexOf("Weak"),d=n?"set":"add",l=r[t],c=l&&l.prototype,u={};if(a&&"function"==typeof l&&(h||c.forEach&&!s((function(){(new l).entries().next()})))){o=e((function(e,i){_d(bd(e,o,t),{type:t,collection:new l}),null!=i&&md(i,e[d],{that:e,AS_ENTRIES:n})}));var f=xd(t);kd(["add","clear","delete","forEach","get","has","set","keys","values","entries"],(function(t){var e="add"==t||"set"==t;!(t in c)||h&&"clear"==t||H(o.prototype,t,(function(i,o){var n=f(this).collection;if(!e&&h&&!m(i))return"get"==t&&void 0;var r=n[t](0===i?0:i,o);return e?this:r}))})),h||wd(o.prototype,"size",{configurable:!0,get:function(){return f(this).collection.size}})}else o=i.getConstructor(e,t,n,d),gd.REQUIRED=!0;return Le(o,t,!1,!0),u[t]=o,q({global:!0,forced:!0},u),h||i.setStrong(o,t,n),o},Od=function(t,e,i){for(var o in e)i&&i.unsafe&&t[o]?t[o]=e[o]:Ue(t,o,e[o],i);return t},Cd=be("species"),Sd=L.f,Td=gd.fastKey,Md=Zt.set,Pd=Zt.getterFor,Dd={getConstructor:function(t,e,i,o){var n=t((function(t,r){bd(t,n,e),Md(t,{type:e,index:De(null),first:void 0,last:void 0,size:0}),a||(t.size=0),null!=r&&md(r,t[o],{that:t,AS_ENTRIES:i})})),r=Pd(e),s=function(t,e,i){var o,n,s=r(t),d=h(t,e);return d?d.value=i:(s.last=d={index:n=Td(e,!0),key:e,value:i,previous:o=s.last,next:void 0,removed:!1},s.first||(s.first=d),o&&(o.next=d),a?s.size++:t.size++,"F"!==n&&(s.index[n]=d)),t},h=function(t,e){var i,o=r(t),n=Td(e);if("F"!==n)return o.index[n];for(i=o.first;i;i=i.next)if(i.key==e)return i};return Od(n.prototype,{clear:function(){for(var t=r(this),e=t.index,i=t.first;i;)i.removed=!0,i.previous&&(i.previous=i.previous.next=void 0),delete e[i.index],i=i.next;t.first=t.last=void 0,a?t.size=0:this.size=0},delete:function(t){var e=this,i=r(e),o=h(e,t);if(o){var n=o.next,s=o.previous;delete i.index[o.index],o.removed=!0,s&&(s.next=n),n&&(n.previous=s),i.first==o&&(i.first=n),i.last==o&&(i.last=s),a?i.size--:e.size--}return!!o},forEach:function(t){for(var e,i=r(this),o=A(t,arguments.length>1?arguments[1]:void 0,3);e=e?e.next:i.first;)for(o(e.value,e.key,this);e&&e.removed;)e=e.previous},has:function(t){return!!h(this,t)}}),Od(n.prototype,i?{get:function(t){var e=h(this,t);return e&&e.value},set:function(t,e){return s(this,0===t?0:t,e)}}:{add:function(t){return s(this,t=0===t?0:t,t)}}),a&&Sd(n.prototype,"size",{get:function(){return r(this).size}}),n},setStrong:function(t,e,i){var o=e+" Iterator",n=Pd(e),r=Pd(o);Je(t,e,(function(t,e){Md(this,{type:o,target:t,state:n(t),kind:e,last:void 0})}),(function(){for(var t=r(this),e=t.kind,i=t.last;i&&i.removed;)i=i.previous;return t.target&&(t.last=i=i?i.next:t.state.first)?"keys"==e?{value:i.key,done:!1}:"values"==e?{value:i.value,done:!1}:{value:[i.key,i.value],done:!1}:(t.target=void 0,{value:void 0,done:!0})}),i?"entries":"values",!i,!0),function(t){var e=re(t),i=L.f;a&&e&&!e[Cd]&&i(e,Cd,{configurable:!0,get:function(){return this}})}(e)}};Ed("Map",(function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}}),Dd);var Bd=F.Map,Id=function(){function t(){Po(this,t),this.clear(),this._defaultIndex=0,this._groupIndex=0,this._defaultGroups=[{border:"#2B7CE9",background:"#97C2FC",highlight:{border:"#2B7CE9",background:"#D2E5FF"},hover:{border:"#2B7CE9",background:"#D2E5FF"}},{border:"#FFA500",background:"#FFFF00",highlight:{border:"#FFA500",background:"#FFFFA3"},hover:{border:"#FFA500",background:"#FFFFA3"}},{border:"#FA0A10",background:"#FB7E81",highlight:{border:"#FA0A10",background:"#FFAFB1"},hover:{border:"#FA0A10",background:"#FFAFB1"}},{border:"#41A906",background:"#7BE141",highlight:{border:"#41A906",background:"#A1EC76"},hover:{border:"#41A906",background:"#A1EC76"}},{border:"#E129F0",background:"#EB7DF4",highlight:{border:"#E129F0",background:"#F0B3F5"},hover:{border:"#E129F0",background:"#F0B3F5"}},{border:"#7C29F0",background:"#AD85E4",highlight:{border:"#7C29F0",background:"#D3BDF0"},hover:{border:"#7C29F0",background:"#D3BDF0"}},{border:"#C37F00",background:"#FFA807",highlight:{border:"#C37F00",background:"#FFCA66"},hover:{border:"#C37F00",background:"#FFCA66"}},{border:"#4220FB",background:"#6E6EFD",highlight:{border:"#4220FB",background:"#9B9BFD"},hover:{border:"#4220FB",background:"#9B9BFD"}},{border:"#FD5A77",background:"#FFC0CB",highlight:{border:"#FD5A77",background:"#FFD1D9"},hover:{border:"#FD5A77",background:"#FFD1D9"}},{border:"#4AD63A",background:"#C2FABC",highlight:{border:"#4AD63A",background:"#E6FFE3"},hover:{border:"#4AD63A",background:"#E6FFE3"}},{border:"#990000",background:"#EE0000",highlight:{border:"#BB0000",background:"#FF3333"},hover:{border:"#BB0000",background:"#FF3333"}},{border:"#FF6000",background:"#FF6000",highlight:{border:"#FF6000",background:"#FF6000"},hover:{border:"#FF6000",background:"#FF6000"}},{border:"#97C2FC",background:"#2B7CE9",highlight:{border:"#D2E5FF",background:"#2B7CE9"},hover:{border:"#D2E5FF",background:"#2B7CE9"}},{border:"#399605",background:"#255C03",highlight:{border:"#399605",background:"#255C03"},hover:{border:"#399605",background:"#255C03"}},{border:"#B70054",background:"#FF007E",highlight:{border:"#B70054",background:"#FF007E"},hover:{border:"#B70054",background:"#FF007E"}},{border:"#AD85E4",background:"#7C29F0",highlight:{border:"#D3BDF0",background:"#7C29F0"},hover:{border:"#D3BDF0",background:"#7C29F0"}},{border:"#4557FA",background:"#000EA1",highlight:{border:"#6E6EFD",background:"#000EA1"},hover:{border:"#6E6EFD",background:"#000EA1"}},{border:"#FFC0CB",background:"#FD5A77",highlight:{border:"#FFD1D9",background:"#FD5A77"},hover:{border:"#FFD1D9",background:"#FD5A77"}},{border:"#C2FABC",background:"#74D66A",highlight:{border:"#E6FFE3",background:"#74D66A"},hover:{border:"#E6FFE3",background:"#74D66A"}},{border:"#EE0000",background:"#990000",highlight:{border:"#FF3333",background:"#BB0000"},hover:{border:"#FF3333",background:"#BB0000"}}],this.options={},this.defaultOptions={useDefaultGroups:!0},ct(this.options,this.defaultOptions)}return Io(t,[{key:"setOptions",value:function(t){var e=["useDefaultGroups"];if(void 0!==t)for(var i in t)if(Object.prototype.hasOwnProperty.call(t,i)&&-1===Mr(e).call(e,i)){var o=t[i];this.add(i,o)}}},{key:"clear",value:function(){this._groups=new Bd,this._groupNames=[]}},{key:"get",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this._groups.get(t);if(void 0===i&&e)if(!1===this.options.useDefaultGroups&&this._groupNames.length>0){var o=this._groupIndex%this._groupNames.length;++this._groupIndex,(i={}).color=this._groups.get(this._groupNames[o]),this._groups.set(t,i)}else{var n=this._defaultIndex%this._defaultGroups.length;this._defaultIndex++,(i={}).color=this._defaultGroups[n],this._groups.set(t,i)}return i}},{key:"add",value:function(t,e){return this._groups.has(t)||this._groupNames.push(t),this._groups.set(t,e),e}}]),t}();q({target:"Number",stat:!0},{isNaN:function(t){return t!=t}});var zd=F.Number.isNaN,Fd=r.isFinite,Nd=Number.isFinite||function(t){return"number"==typeof t&&Fd(t)};q({target:"Number",stat:!0},{isFinite:Nd});var Ad=F.Number.isFinite,Rd=Wi.some,jd=On("some");q({target:"Array",proto:!0,forced:!jd},{some:function(t){return Rd(this,t,arguments.length>1?arguments[1]:void 0)}});var Ld=gt("Array").some,Hd=Array.prototype,Wd=function(t){var e=t.some;return t===Hd||t instanceof Array&&e===Hd.some?Ld:e},Vd=gr.trim,qd=r.parseFloat,Ud=1/qd(cr+"-0")!=-1/0?function(t){var e=Vd(String(t)),i=qd(e);return 0===i&&"-"==e.charAt(0)?-0:i}:qd;q({global:!0,forced:parseFloat!=Ud},{parseFloat:Ud});var Yd=F.parseFloat,Xd=zi.f,Gd=s((function(){return!Object.getOwnPropertyNames(1)}));q({target:"Object",stat:!0,forced:Gd},{getOwnPropertyNames:Xd});var Kd=F.Object,$d=function(t){return Kd.getOwnPropertyNames(t)};function Qd(t,e){var i=["node","edge","label"],o=!0,n=mh(e,"chosen");if("boolean"==typeof n)o=n;else if("object"===dn(n)){if(-1===Mr(i).call(i,t))throw new Error("choosify: subOption '"+t+"' should be one of '"+i.join("', '")+"'");var r=mh(e,["chosen",t]);"boolean"!=typeof r&&"function"!=typeof r||(o=r)}return o}function Zd(t,e,i){if(t.width<=0||t.height<=0)return!1;if(void 0!==i){var o={x:e.x-i.x,y:e.y-i.y};if(0!==i.angle){var n=-i.angle;e={x:Math.cos(n)*o.x-Math.sin(n)*o.y,y:Math.sin(n)*o.x+Math.cos(n)*o.y}}else e=o}var r=t.x+t.width,s=t.y+t.width;return t.left<e.x&&r>e.x&&t.top<e.y&&s>e.y}function Jd(t){return"string"==typeof t&&""!==t}function tl(t,e,i,o){var n=o.x,r=o.y;if("function"==typeof o.distanceToBorder){var s=o.distanceToBorder(t,e),a=Math.sin(e)*s,h=Math.cos(e)*s;h===s?(n+=s,r=o.y):a===s?(n=o.x,r-=s):(n+=h,r-=a)}else o.shape.width>o.shape.height?(n=o.x+.5*o.shape.width,r=o.y-i):(n=o.x+i,r=o.y-.5*o.shape.height);return{x:n,y:r}}var el=gt("Array").values,il=Array.prototype,ol={DOMTokenList:!0,NodeList:!0},nl=function(t){var e=t.values;return t===il||t instanceof Array&&e===il.values||ol.hasOwnProperty(Ne(t))?el:e},rl=function(){function t(e){Po(this,t),this.measureText=e,this.current=0,this.width=0,this.height=0,this.lines=[]}return Io(t,[{key:"_add",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"normal";void 0===this.lines[t]&&(this.lines[t]={width:0,height:0,blocks:[]});var o=e;void 0!==e&&""!==e||(o=" ");var n=this.measureText(o,i),r=ct({},nl(n));r.text=e,r.width=n.width,r.mod=i,void 0!==e&&""!==e||(r.width=0),this.lines[t].blocks.push(r),this.lines[t].width+=r.width}},{key:"curWidth",value:function(){var t=this.lines[this.current];return void 0===t?0:t.width}},{key:"append",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"normal";this._add(this.current,t,e)}},{key:"newLine",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"normal";this._add(this.current,t,e),this.current++}},{key:"determineLineHeights",value:function(){for(var t=0;t<this.lines.length;t++){var e=this.lines[t],i=0;if(void 0!==e.blocks)for(var o=0;o<e.blocks.length;o++){var n=e.blocks[o];i<n.height&&(i=n.height)}e.height=i}}},{key:"determineLabelSize",value:function(){for(var t=0,e=0,i=0;i<this.lines.length;i++){var o=this.lines[i];o.width>t&&(t=o.width),e+=o.height}this.width=t,this.height=e}},{key:"removeEmptyBlocks",value:function(){for(var t=[],e=0;e<this.lines.length;e++){var i=this.lines[e];if(0!==i.blocks.length&&(e!==this.lines.length-1||0!==i.width)){var o={};ct(o,i),o.blocks=[];for(var n=void 0,r=[],s=0;s<i.blocks.length;s++){var a=i.blocks[s];0!==a.width?r.push(a):void 0===n&&(n=a)}0===r.length&&void 0!==n&&r.push(n),o.blocks=r,t.push(o)}}return t}},{key:"finalize",value:function(){this.determineLineHeights(),this.determineLabelSize();var t=this.removeEmptyBlocks();return{width:this.width,height:this.height,lines:t}}}]),t}(),sl={"<b>":/<b>/,"<i>":/<i>/,"<code>":/<code>/,"</b>":/<\/b>/,"</i>":/<\/i>/,"</code>":/<\/code>/,"*":/\*/,_:/_/,"`":/`/,afterBold:/[^*]/,afterItal:/[^_]/,afterMono:/[^`]/},al=function(){function t(e){Po(this,t),this.text=e,this.bold=!1,this.ital=!1,this.mono=!1,this.spacing=!1,this.position=0,this.buffer="",this.modStack=[],this.blocks=[]}return Io(t,[{key:"mod",value:function(){return 0===this.modStack.length?"normal":this.modStack[0]}},{key:"modName",value:function(){return 0===this.modStack.length?"normal":"mono"===this.modStack[0]?"mono":this.bold&&this.ital?"boldital":this.bold?"bold":this.ital?"ital":void 0}},{key:"emitBlock",value:function(){this.spacing&&(this.add(" "),this.spacing=!1),this.buffer.length>0&&(this.blocks.push({text:this.buffer,mod:this.modName()}),this.buffer="")}},{key:"add",value:function(t){" "===t&&(this.spacing=!0),this.spacing&&(this.buffer+=" ",this.spacing=!1)," "!=t&&(this.buffer+=t)}},{key:"parseWS",value:function(t){return!!/[ \t]/.test(t)&&(this.mono?this.add(t):this.spacing=!0,!0)}},{key:"setTag",value:function(t){this.emitBlock(),this[t]=!0,this.modStack.unshift(t)}},{key:"unsetTag",value:function(t){this.emitBlock(),this[t]=!1,this.modStack.shift()}},{key:"parseStartTag",value:function(t,e){return!(this.mono||this[t]||!this.match(e))&&(this.setTag(t),!0)}},{key:"match",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this.prepareRegExp(t),o=an(i,2),n=o[0],r=o[1],s=n.test(this.text.substr(this.position,r));return s&&e&&(this.position+=r-1),s}},{key:"parseEndTag",value:function(t,e,i){var o=this.mod()===t;return!(!(o="mono"===t?o&&this.mono:o&&!this.mono)||!this.match(e))&&(void 0!==i?(this.position===this.text.length-1||this.match(i,!1))&&this.unsetTag(t):this.unsetTag(t),!0)}},{key:"replace",value:function(t,e){return!!this.match(t)&&(this.add(e),this.position+=length-1,!0)}},{key:"prepareRegExp",value:function(t){var e,i;if(t instanceof RegExp)i=t,e=1;else{var o=sl[t];i=void 0!==o?o:new RegExp(t),e=t.length}return[i,e]}}]),t}(),hl=function(){function t(e,i,o,n){var r=this;Po(this,t),this.ctx=e,this.parent=i,this.selected=o,this.hover=n;this.lines=new rl((function(t,i){if(void 0===t)return 0;var s=r.parent.getFormattingValues(e,o,n,i),a=0;""!==t&&(a=r.ctx.measureText(t).width);return{width:a,values:s}}))}return Io(t,[{key:"process",value:function(t){if(!Jd(t))return this.lines.finalize();var e=this.parent.fontOptions;t=(t=t.replace(/\r\n/g,"\n")).replace(/\r/g,"\n");var i=String(t).split("\n"),o=i.length;if(e.multi)for(var n=0;n<o;n++){var r=this.splitBlocks(i[n],e.multi);if(void 0!==r)if(0!==r.length){if(e.maxWdt>0)for(var s=0;s<r.length;s++){var a=r[s].mod,h=r[s].text;this.splitStringIntoLines(h,a,!0)}else for(var d=0;d<r.length;d++){var l=r[d].mod,c=r[d].text;this.lines.append(c,l)}this.lines.newLine()}else this.lines.newLine("")}else if(e.maxWdt>0)for(var u=0;u<o;u++)this.splitStringIntoLines(i[u]);else for(var f=0;f<o;f++)this.lines.newLine(i[f]);return this.lines.finalize()}},{key:"decodeMarkupSystem",value:function(t){var e="none";return"markdown"===t||"md"===t?e="markdown":!0!==t&&"html"!==t||(e="html"),e}},{key:"splitHtmlBlocks",value:function(t){for(var e=new al(t),i=function(t){return!!/&/.test(t)&&(e.replace(e.text,"&lt;","<")||e.replace(e.text,"&amp;","&")||e.add("&"),!0)};e.position<e.text.length;){var o=e.text.charAt(e.position);e.parseWS(o)||/</.test(o)&&(e.parseStartTag("bold","<b>")||e.parseStartTag("ital","<i>")||e.parseStartTag("mono","<code>")||e.parseEndTag("bold","</b>")||e.parseEndTag("ital","</i>")||e.parseEndTag("mono","</code>"))||i(o)||e.add(o),e.position++}return e.emitBlock(),e.blocks}},{key:"splitMarkdownBlocks",value:function(t){for(var e=this,i=new al(t),o=!0,n=function(t){return!!/\\/.test(t)&&(i.position<e.text.length+1&&(i.position++,t=e.text.charAt(i.position),/ \t/.test(t)?i.spacing=!0:(i.add(t),o=!1)),!0)};i.position<i.text.length;){var r=i.text.charAt(i.position);i.parseWS(r)||n(r)||(o||i.spacing)&&(i.parseStartTag("bold","*")||i.parseStartTag("ital","_")||i.parseStartTag("mono","`"))||i.parseEndTag("bold","*","afterBold")||i.parseEndTag("ital","_","afterItal")||i.parseEndTag("mono","`","afterMono")||(i.add(r),o=!1),i.position++}return i.emitBlock(),i.blocks}},{key:"splitBlocks",value:function(t,e){var i=this.decodeMarkupSystem(e);return"none"===i?[{text:t,mod:"normal"}]:"markdown"===i?this.splitMarkdownBlocks(t):"html"===i?this.splitHtmlBlocks(t):void 0}},{key:"overMaxWidth",value:function(t){var e=this.ctx.measureText(t).width;return this.lines.curWidth()+e>this.parent.fontOptions.maxWdt}},{key:"getLongestFit",value:function(t){for(var e="",i=0;i<t.length;){var o=e+(""===e?"":" ")+t[i];if(this.overMaxWidth(o))break;e=o,i++}return i}},{key:"getLongestFitWord",value:function(t){for(var e=0;e<t.length&&!this.overMaxWidth(vn(t).call(t,0,e));)e++;return e}},{key:"splitStringIntoLines",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"normal",i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.parent.getFormattingValues(this.ctx,this.selected,this.hover,e);for(var o=(t=(t=t.replace(/^( +)/g,"$1\r")).replace(/([^\r][^ ]*)( +)/g,"$1\r$2\r")).split("\r");o.length>0;){var n=this.getLongestFit(o);if(0===n){var r=o[0],s=this.getLongestFitWord(r);this.lines.newLine(vn(r).call(r,0,s),e),o[0]=vn(r).call(r,s)}else{var a=n;" "===o[n-1]?n--:" "===o[a]&&a++;var h=vn(o).call(o,0,n).join("");n==o.length&&i?this.lines.append(h,e):this.lines.newLine(h,e),o=vn(o).call(o,a)}}}}]),t}(),dl=["bold","ital","boldital","mono"],ll=function(){function t(e,i){var o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];Po(this,t),this.body=e,this.pointToSelf=!1,this.baseSize=void 0,this.fontOptions={},this.setOptions(i),this.size={top:0,left:0,width:0,height:0,yLine:0},this.isEdgeLabel=o}return Io(t,[{key:"setOptions",value:function(t){if(this.elementOptions=t,this.initFontOptions(t.font),Jd(t.label)?this.labelDirty=!0:t.label=void 0,void 0!==t.font&&null!==t.font)if("string"==typeof t.font)this.baseSize=this.fontOptions.size;else if("object"===dn(t.font)){var e=t.font.size;void 0!==e&&(this.baseSize=e)}}},{key:"initFontOptions",value:function(e){var i=this;nh(dl,(function(t){i.fontOptions[t]={}})),t.parseFontString(this.fontOptions,e)?this.fontOptions.vadjust=0:nh(e,(function(t,e){null!=t&&"object"!==dn(t)&&(i.fontOptions[e]=t)}))}},{key:"constrain",value:function(t){var e={constrainWidth:!1,maxWdt:-1,minWdt:-1,constrainHeight:!1,minHgt:-1,valign:"middle"},i=mh(t,"widthConstraint");if("number"==typeof i)e.maxWdt=Number(i),e.minWdt=Number(i);else if("object"===dn(i)){var o=mh(t,["widthConstraint","maximum"]);"number"==typeof o&&(e.maxWdt=Number(o));var n=mh(t,["widthConstraint","minimum"]);"number"==typeof n&&(e.minWdt=Number(n))}var r=mh(t,"heightConstraint");if("number"==typeof r)e.minHgt=Number(r);else if("object"===dn(r)){var s=mh(t,["heightConstraint","minimum"]);"number"==typeof s&&(e.minHgt=Number(s));var a=mh(t,["heightConstraint","valign"]);"string"==typeof a&&("top"!==a&&"bottom"!==a||(e.valign=a))}return e}},{key:"update",value:function(t,e){this.setOptions(t,!0),this.propagateFonts(e),th(this.fontOptions,this.constrain(e)),this.fontOptions.chooser=Qd("label",e)}},{key:"adjustSizes",value:function(t){var e=t?t.right+t.left:0;this.fontOptions.constrainWidth&&(this.fontOptions.maxWdt-=e,this.fontOptions.minWdt-=e);var i=t?t.top+t.bottom:0;this.fontOptions.constrainHeight&&(this.fontOptions.minHgt-=i)}},{key:"addFontOptionsToPile",value:function(t,e){for(var i=0;i<e.length;++i)this.addFontToPile(t,e[i])}},{key:"addFontToPile",value:function(t,e){if(void 0!==e&&void 0!==e.font&&null!==e.font){var i=e.font;t.push(i)}}},{key:"getBasicOptions",value:function(e){for(var i={},o=0;o<e.length;++o){var n=e[o],r={};t.parseFontString(r,n)&&(n=r),nh(n,(function(t,e){void 0!==t&&(Object.prototype.hasOwnProperty.call(i,e)||(-1!==Mr(dl).call(dl,e)?i[e]={}:i[e]=t))}))}return i}},{key:"getFontOption",value:function(e,i,o){for(var n,r=0;r<e.length;++r){var s=e[r];if(Object.prototype.hasOwnProperty.call(s,i)){if(null==(n=s[i]))continue;var a={};if(t.parseFontString(a,n)&&(n=a),Object.prototype.hasOwnProperty.call(n,o))return n[o]}}if(Object.prototype.hasOwnProperty.call(this.fontOptions,o))return this.fontOptions[o];throw new Error("Did not find value for multi-font for property: '"+o+"'")}},{key:"getFontOptions",value:function(t,e){for(var i={},o=["color","size","face","mod","vadjust"],n=0;n<o.length;++n){var r=o[n];i[r]=this.getFontOption(t,e,r)}return i}},{key:"propagateFonts",value:function(t){var e=this,i=[];this.addFontOptionsToPile(i,t),this.fontOptions=this.getBasicOptions(i);for(var o=function(t){var o=dl[t],n=e.fontOptions[o];nh(e.getFontOptions(i,o),(function(t,e){n[e]=t})),n.size=Number(n.size),n.vadjust=Number(n.vadjust)},n=0;n<dl.length;++n)o(n)}},{key:"draw",value:function(t,e,i,o,n){var r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"middle";if(void 0!==this.elementOptions.label){var s=this.fontOptions.size*this.body.view.scale;this.elementOptions.label&&s<this.elementOptions.scaling.label.drawThreshold-1||(s>=this.elementOptions.scaling.label.maxVisible&&(s=Number(this.elementOptions.scaling.label.maxVisible)/this.body.view.scale),this.calculateLabelSize(t,o,n,e,i,r),this._drawBackground(t),this._drawText(t,e,this.size.yLine,r,s))}}},{key:"_drawBackground",value:function(t){if(void 0!==this.fontOptions.background&&"none"!==this.fontOptions.background){t.fillStyle=this.fontOptions.background;var e=this.getSize();t.fillRect(e.left,e.top,e.width,e.height)}}},{key:"_drawText",value:function(t,e,i){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"middle",n=arguments.length>4?arguments[4]:void 0,r=this._setAlignment(t,e,i,o),s=an(r,2);e=s[0],i=s[1],t.textAlign="left",e-=this.size.width/2,this.fontOptions.valign&&this.size.height>this.size.labelHeight&&("top"===this.fontOptions.valign&&(i-=(this.size.height-this.size.labelHeight)/2),"bottom"===this.fontOptions.valign&&(i+=(this.size.height-this.size.labelHeight)/2));for(var a=0;a<this.lineCount;a++){var h=this.lines[a];if(h&&h.blocks){var d=0;this.isEdgeLabel||"center"===this.fontOptions.align?d+=(this.size.width-h.width)/2:"right"===this.fontOptions.align&&(d+=this.size.width-h.width);for(var l=0;l<h.blocks.length;l++){var c=h.blocks[l];t.font=c.font;var u=this._getColor(c.color,n,c.strokeColor),f=an(u,2),p=f[0],v=f[1];c.strokeWidth>0&&(t.lineWidth=c.strokeWidth,t.strokeStyle=v,t.lineJoin="round"),t.fillStyle=p,c.strokeWidth>0&&t.strokeText(c.text,e+d,i+c.vadjust),t.fillText(c.text,e+d,i+c.vadjust),d+=c.width}i+=h.height}}}},{key:"_setAlignment",value:function(t,e,i,o){if(this.isEdgeLabel&&"horizontal"!==this.fontOptions.align&&!1===this.pointToSelf){e=0,i=0;"top"===this.fontOptions.align?(t.textBaseline="alphabetic",i-=4):"bottom"===this.fontOptions.align?(t.textBaseline="hanging",i+=4):t.textBaseline="middle"}else t.textBaseline=o;return[e,i]}},{key:"_getColor",value:function(t,e,i){var o=t||"#000000",n=i||"#ffffff";if(e<=this.elementOptions.scaling.label.drawThreshold){var r=Math.max(0,Math.min(1,1-(this.elementOptions.scaling.label.drawThreshold-e)));o=sh(o,r),n=sh(n,r)}return[o,n]}},{key:"getTextSize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return this._processLabel(t,e,i),{width:this.size.width,height:this.size.height,lineCount:this.lineCount}}},{key:"getSize",value:function(){var t=this.size.left,e=this.size.top-1;if(this.isEdgeLabel){var i=.5*-this.size.width;switch(this.fontOptions.align){case"middle":t=i,e=.5*-this.size.height;break;case"top":t=i,e=-(this.size.height+2);break;case"bottom":t=i,e=2}}return{left:t,top:e,width:this.size.width,height:this.size.height}}},{key:"calculateLabelSize",value:function(t,e,i){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"middle";this._processLabel(t,e,i),this.size.left=o-.5*this.size.width,this.size.top=n-.5*this.size.height,this.size.yLine=n+.5*(1-this.lineCount)*this.fontOptions.size,"hanging"===r&&(this.size.top+=.5*this.fontOptions.size,this.size.top+=4,this.size.yLine+=4)}},{key:"getFormattingValues",value:function(t,e,i,o){var n=function(t,e,i){return"normal"===e?"mod"===i?"":t[i]:void 0!==t[e][i]?t[e][i]:t[i]},r={color:n(this.fontOptions,o,"color"),size:n(this.fontOptions,o,"size"),face:n(this.fontOptions,o,"face"),mod:n(this.fontOptions,o,"mod"),vadjust:n(this.fontOptions,o,"vadjust"),strokeWidth:this.fontOptions.strokeWidth,strokeColor:this.fontOptions.strokeColor};(e||i)&&("normal"===o&&!0===this.fontOptions.chooser&&this.elementOptions.labelHighlightBold?r.mod="bold":"function"==typeof this.fontOptions.chooser&&this.fontOptions.chooser(r,this.elementOptions.id,e,i));var s="";return void 0!==r.mod&&""!==r.mod&&(s+=r.mod+" "),s+=r.size+"px "+r.face,t.font=s.replace(/"/g,""),r.font=t.font,r.height=r.size,r}},{key:"differentState",value:function(t,e){return t!==this.selectedState||e!==this.hoverState}},{key:"_processLabelText",value:function(t,e,i,o){return new hl(t,this,e,i).process(o)}},{key:"_processLabel",value:function(t,e,i){if(!1!==this.labelDirty||this.differentState(e,i)){var o=this._processLabelText(t,e,i,this.elementOptions.label);this.fontOptions.minWdt>0&&o.width<this.fontOptions.minWdt&&(o.width=this.fontOptions.minWdt),this.size.labelHeight=o.height,this.fontOptions.minHgt>0&&o.height<this.fontOptions.minHgt&&(o.height=this.fontOptions.minHgt),this.lines=o.lines,this.lineCount=o.lines.length,this.size.width=o.width,this.size.height=o.height,this.selectedState=e,this.hoverState=i,this.labelDirty=!1}}},{key:"visible",value:function(){return 0!==this.size.width&&0!==this.size.height&&void 0!==this.elementOptions.label&&!(this.fontOptions.size*this.body.view.scale<this.elementOptions.scaling.label.drawThreshold-1)}}],[{key:"parseFontString",value:function(t,e){if(!e||"string"!=typeof e)return!1;var i=e.split(" ");return t.size=+i[0].replace("px",""),t.face=i[1],t.color=i[2],!0}}]),t}(),cl=re("Reflect","construct"),ul=s((function(){function t(){}return!(cl((function(){}),[],t)instanceof t)})),fl=!s((function(){cl((function(){}))})),pl=ul||fl;q({target:"Reflect",stat:!0,forced:pl,sham:pl},{construct:function(t,e){N(t),R(e);var i=arguments.length<3?t:N(arguments[2]);if(fl&&!ul)return cl(t,e,i);if(t==i){switch(e.length){case 0:return new t;case 1:return new t(e[0]);case 2:return new t(e[0],e[1]);case 3:return new t(e[0],e[1],e[2]);case 4:return new t(e[0],e[1],e[2],e[3])}var o=[null];return o.push.apply(o,e),new(vt.apply(t,o))}var n=i.prototype,r=De(m(n)?n:Object.prototype),s=Function.apply.call(t,r,e);return m(s)?s:r}});var vl=F.Reflect.construct,gl=Br;q({target:"Object",stat:!0},{setPrototypeOf:qe});var yl=F.Object.setPrototypeOf;function ml(t,e){return(ml=yl||function(t,e){return t.__proto__=e,t})(t,e)}function bl(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=gl(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&ml(t,e)}function wl(t,e){return!e||"object"!==dn(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}var kl=er;function _l(t){return(_l=yl?kl:function(t){return t.__proto__||kl(t)})(t)}var xl=function(){function t(e,i,o){Po(this,t),this.body=i,this.labelModule=o,this.setOptions(e),this.top=void 0,this.left=void 0,this.height=void 0,this.width=void 0,this.radius=void 0,this.margin=void 0,this.refreshNeeded=!0,this.boundingBox={top:0,left:0,right:0,bottom:0}}return Io(t,[{key:"setOptions",value:function(t){this.options=t}},{key:"_setMargins",value:function(t){this.margin={},this.options.margin&&("object"==dn(this.options.margin)?(this.margin.top=this.options.margin.top,this.margin.right=this.options.margin.right,this.margin.bottom=this.options.margin.bottom,this.margin.left=this.options.margin.left):(this.margin.top=this.options.margin,this.margin.right=this.options.margin,this.margin.bottom=this.options.margin,this.margin.left=this.options.margin)),t.adjustSizes(this.margin)}},{key:"_distanceToBorder",value:function(t,e){var i=this.options.borderWidth;return t&&this.resize(t),Math.min(Math.abs(this.width/2/Math.cos(e)),Math.abs(this.height/2/Math.sin(e)))+i}},{key:"enableShadow",value:function(t,e){e.shadow&&(t.shadowColor=e.shadowColor,t.shadowBlur=e.shadowSize,t.shadowOffsetX=e.shadowX,t.shadowOffsetY=e.shadowY)}},{key:"disableShadow",value:function(t,e){e.shadow&&(t.shadowColor="rgba(0,0,0,0)",t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0)}},{key:"enableBorderDashes",value:function(t,e){if(!1!==e.borderDashes)if(void 0!==t.setLineDash){var i=e.borderDashes;!0===i&&(i=[5,15]),t.setLineDash(i)}else console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used."),this.options.shapeProperties.borderDashes=!1,e.borderDashes=!1}},{key:"disableBorderDashes",value:function(t,e){!1!==e.borderDashes&&(void 0!==t.setLineDash?t.setLineDash([0]):(console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used."),this.options.shapeProperties.borderDashes=!1,e.borderDashes=!1))}},{key:"needsRefresh",value:function(t,e){return!0===this.refreshNeeded?(this.refreshNeeded=!1,!0):void 0===this.width||this.labelModule.differentState(t,e)}},{key:"initContextForDraw",value:function(t,e){var i=e.borderWidth/this.body.view.scale;t.lineWidth=Math.min(this.width,i),t.strokeStyle=e.borderColor,t.fillStyle=e.color}},{key:"performStroke",value:function(t,e){var i=e.borderWidth/this.body.view.scale;t.save(),i>0&&(this.enableBorderDashes(t,e),t.stroke(),this.disableBorderDashes(t,e)),t.restore()}},{key:"performFill",value:function(t,e){t.save(),t.fillStyle=e.color,this.enableShadow(t,e),Xr(t).call(t),this.disableShadow(t,e),t.restore(),this.performStroke(t,e)}},{key:"_addBoundingBoxMargin",value:function(t){this.boundingBox.left-=t,this.boundingBox.top-=t,this.boundingBox.bottom+=t,this.boundingBox.right+=t}},{key:"_updateBoundingBox",value:function(t,e,i,o,n){void 0!==i&&this.resize(i,o,n),this.left=t-this.width/2,this.top=e-this.height/2,this.boundingBox.left=this.left,this.boundingBox.top=this.top,this.boundingBox.bottom=this.top+this.height,this.boundingBox.right=this.left+this.width}},{key:"updateBoundingBox",value:function(t,e,i,o,n){this._updateBoundingBox(t,e,i,o,n)}},{key:"getDimensionsFromLabel",value:function(t,e,i){this.textSize=this.labelModule.getTextSize(t,e,i);var o=this.textSize.width,n=this.textSize.height;return 0===o&&(o=14,n=14),{width:o,height:n}}}]),t}();function El(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Ol=function(t){bl(i,t);var e=El(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n))._setMargins(n),r}return Io(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover;if(this.needsRefresh(e,i)){var o=this.getDimensionsFromLabel(t,e,i);this.width=o.width+this.margin.right+this.margin.left,this.height=o.height+this.margin.top+this.margin.bottom,this.radius=this.width/2}}},{key:"draw",value:function(t,e,i,o,n,r){this.resize(t,o,n),this.left=e-this.width/2,this.top=i-this.height/2,this.initContextForDraw(t,r),kt(t,this.left,this.top,this.width,this.height,r.borderRadius),this.performFill(t,r),this.updateBoundingBox(e,i,t,o,n),this.labelModule.draw(t,this.left+this.textSize.width/2+this.margin.left,this.top+this.textSize.height/2+this.margin.top,o,n)}},{key:"updateBoundingBox",value:function(t,e,i,o,n){this._updateBoundingBox(t,e,i,o,n);var r=this.options.shapeProperties.borderRadius;this._addBoundingBoxMargin(r)}},{key:"distanceToBorder",value:function(t,e){t&&this.resize(t);var i=this.options.borderWidth;return Math.min(Math.abs(this.width/2/Math.cos(e)),Math.abs(this.height/2/Math.sin(e)))+i}}]),i}(xl);function Cl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Sl=function(t){bl(i,t);var e=Cl(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n)).labelOffset=0,r.selected=!1,r}return Io(i,[{key:"setOptions",value:function(t,e,i){this.options=t,void 0===e&&void 0===i||this.setImages(e,i)}},{key:"setImages",value:function(t,e){e&&this.selected?(this.imageObj=e,this.imageObjAlt=t):(this.imageObj=t,this.imageObjAlt=e)}},{key:"switchImages",value:function(t){var e=t&&!this.selected||!t&&this.selected;if(this.selected=t,void 0!==this.imageObjAlt&&e){var i=this.imageObj;this.imageObj=this.imageObjAlt,this.imageObjAlt=i}}},{key:"_getImagePadding",value:function(){var t={top:0,right:0,bottom:0,left:0};if(this.options.imagePadding){var e=this.options.imagePadding;"object"==dn(e)?(t.top=e.top,t.right=e.right,t.bottom=e.bottom,t.left=e.left):(t.top=e,t.right=e,t.bottom=e,t.left=e)}return t}},{key:"_resizeImage",value:function(){var t,e;if(!1===this.options.shapeProperties.useImageSize){var i=1,o=1;this.imageObj.width&&this.imageObj.height&&(this.imageObj.width>this.imageObj.height?i=this.imageObj.width/this.imageObj.height:o=this.imageObj.height/this.imageObj.width),t=2*this.options.size*i,e=2*this.options.size*o}else{var n=this._getImagePadding();t=this.imageObj.width+n.left+n.right,e=this.imageObj.height+n.top+n.bottom}this.width=t,this.height=e,this.radius=.5*this.width}},{key:"_drawRawCircle",value:function(t,e,i,o){this.initContextForDraw(t,o),wt(t,e,i,o.size),this.performFill(t,o)}},{key:"_drawImageAtPosition",value:function(t,e){if(0!=this.imageObj.width){t.globalAlpha=void 0!==e.opacity?e.opacity:1,this.enableShadow(t,e);var i=1;!0===this.options.shapeProperties.interpolation&&(i=this.imageObj.width/this.width/this.body.view.scale);var o=this._getImagePadding(),n=this.left+o.left,r=this.top+o.top,s=this.width-o.left-o.right,a=this.height-o.top-o.bottom;this.imageObj.drawImageAtPosition(t,i,n,r,s,a),this.disableShadow(t,e)}}},{key:"_drawImageLabel",value:function(t,e,i,o,n){var r=0;if(void 0!==this.height){r=.5*this.height;var s=this.labelModule.getTextSize(t,o,n);s.lineCount>=1&&(r+=s.height/2)}var a=i+r;this.options.label&&(this.labelOffset=r),this.labelModule.draw(t,e,a,o,n,"hanging")}}]),i}(xl);function Tl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Ml=function(t){bl(i,t);var e=Tl(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n))._setMargins(n),r}return Io(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover;if(this.needsRefresh(e,i)){var o=this.getDimensionsFromLabel(t,e,i),n=Math.max(o.width+this.margin.right+this.margin.left,o.height+this.margin.top+this.margin.bottom);this.options.size=n/2,this.width=n,this.height=n,this.radius=this.width/2}}},{key:"draw",value:function(t,e,i,o,n,r){this.resize(t,o,n),this.left=e-this.width/2,this.top=i-this.height/2,this._drawRawCircle(t,e,i,r),this.updateBoundingBox(e,i),this.labelModule.draw(t,this.left+this.textSize.width/2+this.margin.left,i,o,n)}},{key:"updateBoundingBox",value:function(t,e){this.boundingBox.top=e-this.options.size,this.boundingBox.left=t-this.options.size,this.boundingBox.right=t+this.options.size,this.boundingBox.bottom=e+this.options.size}},{key:"distanceToBorder",value:function(t){return t&&this.resize(t),.5*this.width}}]),i}(Sl);function Pl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Dl=function(t){bl(i,t);var e=Pl(i);function i(t,o,n,r,s){var a;return Po(this,i),(a=e.call(this,t,o,n)).setImages(r,s),a}return Io(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover,o=void 0===this.imageObj.src||void 0===this.imageObj.width||void 0===this.imageObj.height;if(o){var n=2*this.options.size;return this.width=n,this.height=n,void(this.radius=.5*this.width)}this.needsRefresh(e,i)&&this._resizeImage()}},{key:"draw",value:function(t,e,i,o,n,r){this.switchImages(o),this.resize();var s=e,a=i;"top-left"===this.options.shapeProperties.coordinateOrigin?(this.left=e,this.top=i,s+=this.width/2,a+=this.height/2):(this.left=e-this.width/2,this.top=i-this.height/2),this._drawRawCircle(t,s,a,r),t.save(),t.clip(),this._drawImageAtPosition(t,r),t.restore(),this._drawImageLabel(t,s,a,o,n),this.updateBoundingBox(e,i)}},{key:"updateBoundingBox",value:function(t,e){"top-left"===this.options.shapeProperties.coordinateOrigin?(this.boundingBox.top=e,this.boundingBox.left=t,this.boundingBox.right=t+2*this.options.size,this.boundingBox.bottom=e+2*this.options.size):(this.boundingBox.top=e-this.options.size,this.boundingBox.left=t-this.options.size,this.boundingBox.right=t+this.options.size,this.boundingBox.bottom=e+this.options.size),this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left),this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width),this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelOffset)}},{key:"distanceToBorder",value:function(t){return t&&this.resize(t),.5*this.width}}]),i}(Sl);function Bl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Il=function(t){bl(i,t);var e=Bl(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{size:this.options.size};if(this.needsRefresh(e,i)){var n,r;this.labelModule.getTextSize(t,e,i);var s=2*o.size;this.width=null!==(n=this.customSizeWidth)&&void 0!==n?n:s,this.height=null!==(r=this.customSizeHeight)&&void 0!==r?r:s,this.radius=.5*this.width}}},{key:"_drawShape",value:function(t,e,i,o,n,r,s,a){var h,d=this;return this.resize(t,r,s,a),this.left=o-this.width/2,this.top=n-this.height/2,this.initContextForDraw(t,a),(h=e,Object.prototype.hasOwnProperty.call(Ot,h)?Ot[h]:function(t){for(var e=arguments.length,i=new Array(e>1?e-1:0),o=1;o<e;o++)i[o-1]=arguments[o];CanvasRenderingContext2D.prototype[h].call(t,i)})(t,o,n,a.size),this.performFill(t,a),void 0!==this.options.icon&&void 0!==this.options.icon.code&&(t.font=(r?"bold ":"")+this.height/2+"px "+(this.options.icon.face||"FontAwesome"),t.fillStyle=this.options.icon.color||"black",t.textAlign="center",t.textBaseline="middle",t.fillText(this.options.icon.code,o,n)),{drawExternalLabel:function(){if(void 0!==d.options.label){d.labelModule.calculateLabelSize(t,r,s,o,n,"hanging");var e=n+.5*d.height+.5*d.labelModule.size.height;d.labelModule.draw(t,o,e,r,s,"hanging")}d.updateBoundingBox(o,n)}}}},{key:"updateBoundingBox",value:function(t,e){this.boundingBox.top=e-this.options.size,this.boundingBox.left=t-this.options.size,this.boundingBox.right=t+this.options.size,this.boundingBox.bottom=e+this.options.size,void 0!==this.options.label&&this.labelModule.size.width>0&&(this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left),this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width),this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelModule.size.height))}}]),i}(xl);function zl(t,e){var i=xn(t);if(wo){var o=wo(t);e&&(o=ar(o).call(o,(function(e){return Eo(t,e).enumerable}))),i.push.apply(i,o)}return i}function Fl(t){for(var e=1;e<arguments.length;e++){var i,o=null!=arguments[e]?arguments[e]:{};if(e%2)Dn(i=zl(Object(o),!0)).call(i,(function(e){zo(t,e,o[e])}));else if(Co)So(t,Co(o));else{var n;Dn(n=zl(Object(o))).call(n,(function(e){Mo(t,e,Eo(o,e))}))}}return t}function Nl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Al=function(t){bl(i,t);var e=Nl(i);function i(t,o,n,r){var s;return Po(this,i),(s=e.call(this,t,o,n,r)).ctxRenderer=r,s}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){this.resize(t,o,n,r),this.left=e-this.width/2,this.top=i-this.height/2,t.save();var s=this.ctxRenderer({ctx:t,id:this.options.id,x:e,y:i,state:{selected:o,hover:n},style:Fl({},r),label:this.options.label});if(null!=s.drawNode&&s.drawNode(),t.restore(),s.drawExternalLabel){var a=s.drawExternalLabel;s.drawExternalLabel=function(){t.save(),a(),t.restore()}}return s.nodeDimensions&&(this.customSizeWidth=s.nodeDimensions.width,this.customSizeHeight=s.nodeDimensions.height),s}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Il);function Rl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var jl=function(t){bl(i,t);var e=Rl(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n))._setMargins(n),r}return Io(i,[{key:"resize",value:function(t,e,i){if(this.needsRefresh(e,i)){var o=this.getDimensionsFromLabel(t,e,i).width+this.margin.right+this.margin.left;this.width=o,this.height=o,this.radius=this.width/2}}},{key:"draw",value:function(t,e,i,o,n,r){this.resize(t,o,n),this.left=e-this.width/2,this.top=i-this.height/2,this.initContextForDraw(t,r),xt(t,e-this.width/2,i-this.height/2,this.width,this.height),this.performFill(t,r),this.updateBoundingBox(e,i,t,o,n),this.labelModule.draw(t,this.left+this.textSize.width/2+this.margin.left,this.top+this.textSize.height/2+this.margin.top,o,n)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(xl);function Ll(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Hl=function(t){bl(i,t);var e=Ll(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){return this._drawShape(t,"diamond",4,e,i,o,n,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Il);function Wl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Vl=function(t){bl(i,t);var e=Wl(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){return this._drawShape(t,"circle",2,e,i,o,n,r)}},{key:"distanceToBorder",value:function(t){return t&&this.resize(t),this.options.size}}]),i}(Il);function ql(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Ul=function(t){bl(i,t);var e=ql(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover;if(this.needsRefresh(e,i)){var o=this.getDimensionsFromLabel(t,e,i);this.height=2*o.height,this.width=o.width+o.height,this.radius=.5*this.width}}},{key:"draw",value:function(t,e,i,o,n,r){this.resize(t,o,n),this.left=e-.5*this.width,this.top=i-.5*this.height,this.initContextForDraw(t,r),_t(t,this.left,this.top,this.width,this.height),this.performFill(t,r),this.updateBoundingBox(e,i,t,o,n),this.labelModule.draw(t,e,i,o,n)}},{key:"distanceToBorder",value:function(t,e){t&&this.resize(t);var i=.5*this.width,o=.5*this.height,n=Math.sin(e)*i,r=Math.cos(e)*o;return i*o/Math.sqrt(n*n+r*r)}}]),i}(xl);function Yl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Xl=function(t){bl(i,t);var e=Yl(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n))._setMargins(n),r}return Io(i,[{key:"resize",value:function(t,e,i){this.needsRefresh(e,i)&&(this.iconSize={width:Number(this.options.icon.size),height:Number(this.options.icon.size)},this.width=this.iconSize.width+this.margin.right+this.margin.left,this.height=this.iconSize.height+this.margin.top+this.margin.bottom,this.radius=.5*this.width)}},{key:"draw",value:function(t,e,i,o,n,r){var s=this;return this.resize(t,o,n),this.options.icon.size=this.options.icon.size||50,this.left=e-this.width/2,this.top=i-this.height/2,this._icon(t,e,i,o,n,r),{drawExternalLabel:function(){if(void 0!==s.options.label){s.labelModule.draw(t,s.left+s.iconSize.width/2+s.margin.left,i+s.height/2+5,o)}s.updateBoundingBox(e,i)}}}},{key:"updateBoundingBox",value:function(t,e){if(this.boundingBox.top=e-.5*this.options.icon.size,this.boundingBox.left=t-.5*this.options.icon.size,this.boundingBox.right=t+.5*this.options.icon.size,this.boundingBox.bottom=e+.5*this.options.icon.size,void 0!==this.options.label&&this.labelModule.size.width>0){this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left),this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width),this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelModule.size.height+5)}}},{key:"_icon",value:function(t,e,i,o,n,r){var s=Number(this.options.icon.size);void 0!==this.options.icon.code?(t.font=[null!=this.options.icon.weight?this.options.icon.weight:o?"bold":"",(null!=this.options.icon.weight&&o?5:0)+s+"px",this.options.icon.face].join(" "),t.fillStyle=this.options.icon.color||"black",t.textAlign="center",t.textBaseline="middle",this.enableShadow(t,r),t.fillText(this.options.icon.code,e,i),this.disableShadow(t,r)):console.error("When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.")}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(xl);function Gl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Kl=function(t){bl(i,t);var e=Gl(i);function i(t,o,n,r,s){var a;return Po(this,i),(a=e.call(this,t,o,n)).setImages(r,s),a}return Io(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover,o=void 0===this.imageObj.src||void 0===this.imageObj.width||void 0===this.imageObj.height;if(o){var n=2*this.options.size;return this.width=n,void(this.height=n)}this.needsRefresh(e,i)&&this._resizeImage()}},{key:"draw",value:function(t,e,i,o,n,r){t.save(),this.switchImages(o),this.resize();var s=e,a=i;if("top-left"===this.options.shapeProperties.coordinateOrigin?(this.left=e,this.top=i,s+=this.width/2,a+=this.height/2):(this.left=e-this.width/2,this.top=i-this.height/2),!0===this.options.shapeProperties.useBorderWithImage){var h=this.options.borderWidth,d=this.options.borderWidthSelected||2*this.options.borderWidth,l=(o?d:h)/this.body.view.scale;t.lineWidth=Math.min(this.width,l),t.beginPath();var c=o?this.options.color.highlight.border:n?this.options.color.hover.border:this.options.color.border,u=o?this.options.color.highlight.background:n?this.options.color.hover.background:this.options.color.background;void 0!==r.opacity&&(c=sh(c,r.opacity),u=sh(u,r.opacity)),t.strokeStyle=c,t.fillStyle=u,t.rect(this.left-.5*t.lineWidth,this.top-.5*t.lineWidth,this.width+t.lineWidth,this.height+t.lineWidth),Xr(t).call(t),this.performStroke(t,r),t.closePath()}this._drawImageAtPosition(t,r),this._drawImageLabel(t,s,a,o,n),this.updateBoundingBox(e,i),t.restore()}},{key:"updateBoundingBox",value:function(t,e){this.resize(),"top-left"===this.options.shapeProperties.coordinateOrigin?(this.left=t,this.top=e):(this.left=t-this.width/2,this.top=e-this.height/2),this.boundingBox.left=this.left,this.boundingBox.top=this.top,this.boundingBox.bottom=this.top+this.height,this.boundingBox.right=this.left+this.width,void 0!==this.options.label&&this.labelModule.size.width>0&&(this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left),this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width),this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelOffset))}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Sl);function $l(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Ql=function(t){bl(i,t);var e=$l(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){return this._drawShape(t,"square",2,e,i,o,n,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Il);function Zl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Jl=function(t){bl(i,t);var e=Zl(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){return this._drawShape(t,"hexagon",4,e,i,o,n,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Il);function tc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var ec=function(t){bl(i,t);var e=tc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){return this._drawShape(t,"star",4,e,i,o,n,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Il);function ic(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var oc=function(t){bl(i,t);var e=ic(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n))._setMargins(n),r}return Io(i,[{key:"resize",value:function(t,e,i){this.needsRefresh(e,i)&&(this.textSize=this.labelModule.getTextSize(t,e,i),this.width=this.textSize.width+this.margin.right+this.margin.left,this.height=this.textSize.height+this.margin.top+this.margin.bottom,this.radius=.5*this.width)}},{key:"draw",value:function(t,e,i,o,n,r){this.resize(t,o,n),this.left=e-this.width/2,this.top=i-this.height/2,this.enableShadow(t,r),this.labelModule.draw(t,this.left+this.textSize.width/2+this.margin.left,this.top+this.textSize.height/2+this.margin.top,o,n),this.disableShadow(t,r),this.updateBoundingBox(e,i,t,o,n)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(xl);function nc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var rc=function(t){bl(i,t);var e=nc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){return this._drawShape(t,"triangle",3,e,i,o,n,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Il);function sc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var ac=function(t){bl(i,t);var e=sc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){return this._drawShape(t,"triangleDown",3,e,i,o,n,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Il);function hc(t,e){var i=xn(t);if(wo){var o=wo(t);e&&(o=ar(o).call(o,(function(e){return Eo(t,e).enumerable}))),i.push.apply(i,o)}return i}function dc(t){for(var e=1;e<arguments.length;e++){var i,o=null!=arguments[e]?arguments[e]:{};if(e%2)Dn(i=hc(Object(o),!0)).call(i,(function(e){zo(t,e,o[e])}));else if(Co)So(t,Co(o));else{var n;Dn(n=hc(Object(o))).call(n,(function(e){Mo(t,e,Eo(o,e))}))}}return t}var lc=function(){function t(e,i,o,n,r,s){Po(this,t),this.options=vh(r),this.globalOptions=r,this.defaultOptions=s,this.body=i,this.edges=[],this.id=void 0,this.imagelist=o,this.grouplist=n,this.x=void 0,this.y=void 0,this.baseSize=this.options.size,this.baseFontSize=this.options.font.size,this.predefinedPosition=!1,this.selected=!1,this.hover=!1,this.labelModule=new ll(this.body,this.options,!1),this.setOptions(e)}return Io(t,[{key:"attachEdge",value:function(t){var e;-1===Mr(e=this.edges).call(e,t)&&this.edges.push(t)}},{key:"detachEdge",value:function(t){var e,i,o=Mr(e=this.edges).call(e,t);-1!=o&&qn(i=this.edges).call(i,o,1)}},{key:"setOptions",value:function(e){var i=this.options.shape;if(e){if(void 0!==e.color&&(this._localColor=e.color),void 0!==e.id&&(this.id=e.id),void 0===this.id)throw new Error("Node must have an id");t.checkMass(e,this.id),void 0!==e.x&&(null===e.x?(this.x=void 0,this.predefinedPosition=!1):(this.x=kr(e.x),this.predefinedPosition=!0)),void 0!==e.y&&(null===e.y?(this.y=void 0,this.predefinedPosition=!1):(this.y=kr(e.y),this.predefinedPosition=!0)),void 0!==e.size&&(this.baseSize=e.size),void 0!==e.value&&(e.value=Yd(e.value)),t.parseOptions(this.options,e,!0,this.globalOptions,this.grouplist);var o=[e,this.options,this.defaultOptions];return this.chooser=Qd("node",o),this._load_images(),this.updateLabelModule(e),void 0!==e.opacity&&t.checkOpacity(e.opacity)&&(this.options.opacity=e.opacity),this.updateShape(i),void 0!==e.hidden||void 0!==e.physics}}},{key:"_load_images",value:function(){if(("circularImage"===this.options.shape||"image"===this.options.shape)&&void 0===this.options.image)throw new Error("Option image must be defined for node type '"+this.options.shape+"'");if(void 0!==this.options.image){if(void 0===this.imagelist)throw new Error("Internal Error: No images provided");if("string"==typeof this.options.image)this.imageObj=this.imagelist.load(this.options.image,this.options.brokenImage,this.id);else{if(void 0===this.options.image.unselected)throw new Error("No unselected image provided");this.imageObj=this.imagelist.load(this.options.image.unselected,this.options.brokenImage,this.id),void 0!==this.options.image.selected?this.imageObjAlt=this.imagelist.load(this.options.image.selected,this.options.brokenImage,this.id):this.imageObjAlt=void 0}}}},{key:"getFormattingValues",value:function(){var t={color:this.options.color.background,opacity:this.options.opacity,borderWidth:this.options.borderWidth,borderColor:this.options.color.border,size:this.options.size,borderDashes:this.options.shapeProperties.borderDashes,borderRadius:this.options.shapeProperties.borderRadius,shadow:this.options.shadow.enabled,shadowColor:this.options.shadow.color,shadowSize:this.options.shadow.size,shadowX:this.options.shadow.x,shadowY:this.options.shadow.y};if(this.selected||this.hover?!0===this.chooser?this.selected?(null!=this.options.borderWidthSelected?t.borderWidth=this.options.borderWidthSelected:t.borderWidth*=2,t.color=this.options.color.highlight.background,t.borderColor=this.options.color.highlight.border,t.shadow=this.options.shadow.enabled):this.hover&&(t.color=this.options.color.hover.background,t.borderColor=this.options.color.hover.border,t.shadow=this.options.shadow.enabled):"function"==typeof this.chooser&&(this.chooser(t,this.options.id,this.selected,this.hover),!1===t.shadow&&(t.shadowColor===this.options.shadow.color&&t.shadowSize===this.options.shadow.size&&t.shadowX===this.options.shadow.x&&t.shadowY===this.options.shadow.y||(t.shadow=!0))):t.shadow=this.options.shadow.enabled,void 0!==this.options.opacity){var e=this.options.opacity;t.borderColor=sh(t.borderColor,e),t.color=sh(t.color,e),t.shadowColor=sh(t.shadowColor,e)}return t}},{key:"updateLabelModule",value:function(e){void 0!==this.options.label&&null!==this.options.label||(this.options.label=""),t.updateGroupOptions(this.options,dc(dc({},e),{},{color:e&&e.color||this._localColor||void 0}),this.grouplist);var i=this.grouplist.get(this.options.group,!1),o=[e,this.options,i,this.globalOptions,this.defaultOptions];this.labelModule.update(this.options,o),void 0!==this.labelModule.baseSize&&(this.baseFontSize=this.labelModule.baseSize)}},{key:"updateShape",value:function(t){if(t===this.options.shape&&this.shape)this.shape.setOptions(this.options,this.imageObj,this.imageObjAlt);else switch(this.options.shape){case"box":this.shape=new Ol(this.options,this.body,this.labelModule);break;case"circle":this.shape=new Ml(this.options,this.body,this.labelModule);break;case"circularImage":this.shape=new Dl(this.options,this.body,this.labelModule,this.imageObj,this.imageObjAlt);break;case"custom":this.shape=new Al(this.options,this.body,this.labelModule,this.options.ctxRenderer);break;case"database":this.shape=new jl(this.options,this.body,this.labelModule);break;case"diamond":this.shape=new Hl(this.options,this.body,this.labelModule);break;case"dot":this.shape=new Vl(this.options,this.body,this.labelModule);break;case"ellipse":this.shape=new Ul(this.options,this.body,this.labelModule);break;case"icon":this.shape=new Xl(this.options,this.body,this.labelModule);break;case"image":this.shape=new Kl(this.options,this.body,this.labelModule,this.imageObj,this.imageObjAlt);break;case"square":this.shape=new Ql(this.options,this.body,this.labelModule);break;case"hexagon":this.shape=new Jl(this.options,this.body,this.labelModule);break;case"star":this.shape=new ec(this.options,this.body,this.labelModule);break;case"text":this.shape=new oc(this.options,this.body,this.labelModule);break;case"triangle":this.shape=new rc(this.options,this.body,this.labelModule);break;case"triangleDown":this.shape=new ac(this.options,this.body,this.labelModule);break;default:this.shape=new Ul(this.options,this.body,this.labelModule)}this.needsRefresh()}},{key:"select",value:function(){this.selected=!0,this.needsRefresh()}},{key:"unselect",value:function(){this.selected=!1,this.needsRefresh()}},{key:"needsRefresh",value:function(){this.shape.refreshNeeded=!0}},{key:"getTitle",value:function(){return this.options.title}},{key:"distanceToBorder",value:function(t,e){return this.shape.distanceToBorder(t,e)}},{key:"isFixed",value:function(){return this.options.fixed.x&&this.options.fixed.y}},{key:"isSelected",value:function(){return this.selected}},{key:"getValue",value:function(){return this.options.value}},{key:"getLabelSize",value:function(){return this.labelModule.size()}},{key:"setValueRange",value:function(t,e,i){if(void 0!==this.options.value){var o=this.options.scaling.customScalingFunction(t,e,i,this.options.value),n=this.options.scaling.max-this.options.scaling.min;if(!0===this.options.scaling.label.enabled){var r=this.options.scaling.label.max-this.options.scaling.label.min;this.options.font.size=this.options.scaling.label.min+o*r}this.options.size=this.options.scaling.min+o*n}else this.options.size=this.baseSize,this.options.font.size=this.baseFontSize;this.updateLabelModule()}},{key:"draw",value:function(t){var e=this.getFormattingValues();return this.shape.draw(t,this.x,this.y,this.selected,this.hover,e)||{}}},{key:"updateBoundingBox",value:function(t){this.shape.updateBoundingBox(this.x,this.y,t)}},{key:"resize",value:function(t){var e=this.getFormattingValues();this.shape.resize(t,this.selected,this.hover,e)}},{key:"getItemsOnPoint",value:function(t){var e=[];return this.labelModule.visible()&&Zd(this.labelModule.getSize(),t)&&e.push({nodeId:this.id,labelId:0}),Zd(this.shape.boundingBox,t)&&e.push({nodeId:this.id}),e}},{key:"isOverlappingWith",value:function(t){return this.shape.left<t.right&&this.shape.left+this.shape.width>t.left&&this.shape.top<t.bottom&&this.shape.top+this.shape.height>t.top}},{key:"isBoundingBoxOverlappingWith",value:function(t){return this.shape.boundingBox.left<t.right&&this.shape.boundingBox.right>t.left&&this.shape.boundingBox.top<t.bottom&&this.shape.boundingBox.bottom>t.top}}],[{key:"checkOpacity",value:function(t){return 0<=t&&t<=1}},{key:"checkCoordinateOrigin",value:function(t){return void 0===t||"center"===t||"top-left"===t}},{key:"updateGroupOptions",value:function(e,i,o){var n;if(void 0!==o){var r=e.group;if(void 0!==i&&void 0!==i.group&&r!==i.group)throw new Error("updateGroupOptions: group values in options don't match.");if("number"==typeof r||"string"==typeof r&&""!=r){var s=o.get(r);void 0!==s.opacity&&void 0===i.opacity&&(t.checkOpacity(s.opacity)||(console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+s.opacity),s.opacity=void 0));var a=ar(n=$d(i)).call(n,(function(t){return null!=i[t]}));a.push("font"),Ja(a,e,s),e.color=hh(e.color)}}}},{key:"parseOptions",value:function(e,i){var o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=arguments.length>4?arguments[4]:void 0,s=["color","fixed","shadow"];if(Ja(s,e,i,o),t.checkMass(i),void 0!==e.opacity&&(t.checkOpacity(e.opacity)||(console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+e.opacity),e.opacity=void 0)),void 0!==i.opacity&&(t.checkOpacity(i.opacity)||(console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+i.opacity),i.opacity=void 0)),i.shapeProperties&&!t.checkCoordinateOrigin(i.shapeProperties.coordinateOrigin)&&console.error("Invalid option for node coordinateOrigin, found: "+i.shapeProperties.coordinateOrigin),gh(e,i,"shadow",n),void 0!==i.color&&null!==i.color){var a=hh(i.color);Qa(e.color,a)}else!0===o&&null===i.color&&(e.color=vh(n.color));void 0!==i.fixed&&null!==i.fixed&&("boolean"==typeof i.fixed?(e.fixed.x=i.fixed,e.fixed.y=i.fixed):(void 0!==i.fixed.x&&"boolean"==typeof i.fixed.x&&(e.fixed.x=i.fixed.x),void 0!==i.fixed.y&&"boolean"==typeof i.fixed.y&&(e.fixed.y=i.fixed.y))),!0===o&&null===i.font&&(e.font=vh(n.font)),t.updateGroupOptions(e,i,r),void 0!==i.scaling&&gh(e.scaling,i.scaling,"label",n.scaling)}},{key:"checkMass",value:function(t,e){if(void 0!==t.mass&&t.mass<=0){var i="";void 0!==e&&(i=" in node id: "+e),console.error("%cNegative or zero mass disallowed"+i+", setting mass to 1.",Mh),t.mass=1}}}]),t}();function cc(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return uc(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return uc(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function uc(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}var fc=function(){function t(e,i,o,n){var r,s=this;if(Po(this,t),this.body=e,this.images=i,this.groups=o,this.layoutEngine=n,this.body.functions.createNode=bt(r=this.create).call(r,this),this.nodesListeners={add:function(t,e){s.add(e.items)},update:function(t,e){s.update(e.items,e.data,e.oldData)},remove:function(t,e){s.remove(e.items)}},this.defaultOptions={borderWidth:1,borderWidthSelected:void 0,brokenImage:void 0,color:{border:"#2B7CE9",background:"#97C2FC",highlight:{border:"#2B7CE9",background:"#D2E5FF"},hover:{border:"#2B7CE9",background:"#D2E5FF"}},opacity:void 0,fixed:{x:!1,y:!1},font:{color:"#343434",size:14,face:"arial",background:"none",strokeWidth:0,strokeColor:"#ffffff",align:"center",vadjust:0,multi:!1,bold:{mod:"bold"},boldital:{mod:"bold italic"},ital:{mod:"italic"},mono:{mod:"",size:15,face:"monospace",vadjust:2}},group:void 0,hidden:!1,icon:{face:"FontAwesome",code:void 0,size:50,color:"#2B7CE9"},image:void 0,imagePadding:{top:0,right:0,bottom:0,left:0},label:void 0,labelHighlightBold:!0,level:void 0,margin:{top:5,right:5,bottom:5,left:5},mass:1,physics:!0,scaling:{min:10,max:30,label:{enabled:!1,min:14,max:30,maxVisible:30,drawThreshold:5},customScalingFunction:function(t,e,i,o){if(e===t)return.5;var n=1/(e-t);return Math.max(0,(o-t)*n)}},shadow:{enabled:!1,color:"rgba(0,0,0,0.5)",size:10,x:5,y:5},shape:"ellipse",shapeProperties:{borderDashes:!1,borderRadius:6,interpolation:!0,useImageSize:!1,useBorderWithImage:!1,coordinateOrigin:"center"},size:25,title:void 0,value:void 0,x:void 0,y:void 0},this.defaultOptions.mass<=0)throw"Internal error: mass in defaultOptions of NodesHandler may not be zero or negative";this.options=vh(this.defaultOptions),this.bindEventListeners()}return Io(t,[{key:"bindEventListeners",value:function(){var t,e,i=this;this.body.emitter.on("refreshNodes",bt(t=this.refresh).call(t,this)),this.body.emitter.on("refresh",bt(e=this.refresh).call(e,this)),this.body.emitter.on("destroy",(function(){nh(i.nodesListeners,(function(t,e){i.body.data.nodes&&i.body.data.nodes.off(e,t)})),delete i.body.functions.createNode,delete i.nodesListeners.add,delete i.nodesListeners.update,delete i.nodesListeners.remove,delete i.nodesListeners}))}},{key:"setOptions",value:function(t){if(void 0!==t){if(lc.parseOptions(this.options,t),void 0!==t.opacity&&(zd(t.opacity)||!Ad(t.opacity)||t.opacity<0||t.opacity>1?console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+t.opacity):this.options.opacity=t.opacity),void 0!==t.shape)for(var e in this.body.nodes)Object.prototype.hasOwnProperty.call(this.body.nodes,e)&&this.body.nodes[e].updateShape();if(void 0!==t.font||void 0!==t.widthConstraint||void 0!==t.heightConstraint)for(var i=0,o=xn(this.body.nodes);i<o.length;i++){var n=o[i];this.body.nodes[n].updateLabelModule(),this.body.nodes[n].needsRefresh()}if(void 0!==t.size)for(var r in this.body.nodes)Object.prototype.hasOwnProperty.call(this.body.nodes,r)&&this.body.nodes[r].needsRefresh();void 0===t.hidden&&void 0===t.physics||this.body.emitter.emit("_dataChanged")}}},{key:"setData",value:function(t){var i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=this.body.data.nodes;if(e.isDataViewLike("id",t))this.body.data.nodes=t;else if(gn(t))this.body.data.nodes=new e.DataSet,this.body.data.nodes.add(t);else{if(t)throw new TypeError("Array or DataSet expected");this.body.data.nodes=new e.DataSet}if(o&&nh(this.nodesListeners,(function(t,e){o.off(e,t)})),this.body.nodes={},this.body.data.nodes){var n=this;nh(this.nodesListeners,(function(t,e){n.body.data.nodes.on(e,t)}));var r=this.body.data.nodes.getIds();this.add(r,!0)}!1===i&&this.body.emitter.emit("_dataChanged")}},{key:"add",value:function(t){for(var e,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=[],n=0;n<t.length;n++){e=t[n];var r=this.body.data.nodes.get(e),s=this.create(r);o.push(s),this.body.nodes[e]=s}this.layoutEngine.positionInitially(o),!1===i&&this.body.emitter.emit("_dataChanged")}},{key:"update",value:function(t,e,i){for(var o=this.body.nodes,n=!1,r=0;r<t.length;r++){var s=t[r],a=o[s],h=e[r];void 0!==a?a.setOptions(h)&&(n=!0):(n=!0,a=this.create(h),o[s]=a)}n||void 0===i||(n=Wd(e).call(e,(function(t,e){var o=i[e];return o&&o.level!==t.level}))),!0===n?this.body.emitter.emit("_dataChanged"):this.body.emitter.emit("_dataUpdated")}},{key:"remove",value:function(t){for(var e=this.body.nodes,i=0;i<t.length;i++){delete e[t[i]]}this.body.emitter.emit("_dataChanged")}},{key:"create",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:lc;return new e(t,this.body,this.images,this.groups,this.options,this.defaultOptions)}},{key:"refresh",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];nh(this.body.nodes,(function(i,o){var n=t.body.data.nodes.get(o);void 0!==n&&(!0===e&&i.setOptions({x:null,y:null}),i.setOptions({fixed:!1}),i.setOptions(n))}))}},{key:"getPositions",value:function(t){var e={};if(void 0!==t){if(!0===gn(t)){for(var i=0;i<t.length;i++)if(void 0!==this.body.nodes[t[i]]){var o=this.body.nodes[t[i]];e[t[i]]={x:Math.round(o.x),y:Math.round(o.y)}}}else if(void 0!==this.body.nodes[t]){var n=this.body.nodes[t];e[t]={x:Math.round(n.x),y:Math.round(n.y)}}}else for(var r=0;r<this.body.nodeIndices.length;r++){var s=this.body.nodes[this.body.nodeIndices[r]];e[this.body.nodeIndices[r]]={x:Math.round(s.x),y:Math.round(s.y)}}return e}},{key:"getPosition",value:function(t){if(null==t)throw new TypeError("No id was specified for getPosition method.");if(null==this.body.nodes[t])throw new ReferenceError("NodeId provided for getPosition does not exist. Provided: ".concat(t));return{x:Math.round(this.body.nodes[t].x),y:Math.round(this.body.nodes[t].y)}}},{key:"storePositions",value:function(){var t,e=[],i=this.body.data.nodes.getDataSet(),o=cc(i.get());try{for(o.s();!(t=o.n()).done;){var n=t.value,r=n.id,s=this.body.nodes[r],a=Math.round(s.x),h=Math.round(s.y);n.x===a&&n.y===h||e.push({id:r,x:a,y:h})}}catch(t){o.e(t)}finally{o.f()}i.update(e)}},{key:"getBoundingBox",value:function(t){if(void 0!==this.body.nodes[t])return this.body.nodes[t].shape.boundingBox}},{key:"getConnectedNodes",value:function(t,e){var i=[];if(void 0!==this.body.nodes[t])for(var o=this.body.nodes[t],n={},r=0;r<o.edges.length;r++){var s=o.edges[r];"to"!==e&&s.toId==o.id?void 0===n[s.fromId]&&(i.push(s.fromId),n[s.fromId]=!0):"from"!==e&&s.fromId==o.id&&void 0===n[s.toId]&&(i.push(s.toId),n[s.toId]=!0)}return i}},{key:"getConnectedEdges",value:function(t){var e=[];if(void 0!==this.body.nodes[t])for(var i=this.body.nodes[t],o=0;o<i.edges.length;o++)e.push(i.edges[o].id);else console.error("NodeId provided for getConnectedEdges does not exist. Provided: ",t);return e}},{key:"moveNode",value:function(t,e,i){var o=this;void 0!==this.body.nodes[t]?(this.body.nodes[t].x=Number(e),this.body.nodes[t].y=Number(i),qr((function(){o.body.emitter.emit("startSimulation")}),0)):console.error("Node id supplied to moveNode does not exist. Provided: ",t)}}]),t}();q({target:"Reflect",stat:!0},{get:function t(e,i){var o,n,r=arguments.length<3?e:arguments[2];return R(e)===r?e[i]:(o=S.f(e,i))?k(o,"value")?o.value:void 0===o.get?void 0:o.get.call(r):m(n=ie(e))?t(n,i,r):void 0}});var pc=F.Reflect.get,vc=xo;function gc(t,e,i){return(gc="undefined"!=typeof Reflect&&pc?pc:function(t,e,i){var o=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=_l(t)););return t}(t,e);if(o){var n=vc(o,e);return n.get?n.get.call(i):n.value}})(t,e,i||t)}var yc=Math.hypot,mc=Math.abs,bc=Math.sqrt,wc=!!yc&&yc(1/0,NaN)!==1/0;q({target:"Math",stat:!0,forced:wc},{hypot:function(t,e){for(var i,o,n=0,r=0,s=arguments.length,a=0;r<s;)a<(i=mc(arguments[r++]))?(n=n*(o=a/i)*o+1,a=i):n+=i>0?(o=i/a)*o:i;return a===1/0?1/0:a*bc(n)}});var kc=F.Math.hypot;function _c(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var xc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"transform",value:function(t,e){gn(t)||(t=[t]);for(var i=e.point.x,o=e.point.y,n=e.angle,r=e.length,s=0;s<t.length;++s){var a=t[s],h=a.x*Math.cos(n)-a.y*Math.sin(n),d=a.x*Math.sin(n)+a.y*Math.cos(n);a.x=i+r*h,a.y=o+r*d}}},{key:"drawPath",value:function(t,e){t.beginPath(),t.moveTo(e[0].x,e[0].y);for(var i=1;i<e.length;++i)t.lineTo(e[i].x,e[i].y);t.closePath()}}]),t}(),Ec=function(t){bl(i,t);var e=_c(i);function i(){return Po(this,i),e.apply(this,arguments)}return Io(i,null,[{key:"draw",value:function(t,e){if(e.image){t.save(),t.translate(e.point.x,e.point.y),t.rotate(Math.PI/2+e.angle);var i=null!=e.imageWidth?e.imageWidth:e.image.width,o=null!=e.imageHeight?e.imageHeight:e.image.height;e.image.drawImageAtPosition(t,1,-i/2,0,i,o),t.restore()}return!1}}]),i}(xc),Oc=function(t){bl(i,t);var e=_c(i);function i(){return Po(this,i),e.apply(this,arguments)}return Io(i,null,[{key:"draw",value:function(t,e){var i=[{x:0,y:0},{x:-1,y:.3},{x:-.9,y:0},{x:-1,y:-.3}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),i}(xc),Cc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i=[{x:-1,y:0},{x:0,y:.3},{x:-.4,y:0},{x:0,y:-.3}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),t}(),Sc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i={x:-.4,y:0};xc.transform(i,e),t.strokeStyle=t.fillStyle,t.fillStyle="rgba(0, 0, 0, 0)";var o=Math.PI,n=e.angle-o/2,r=e.angle+o/2;return t.beginPath(),t.arc(i.x,i.y,.4*e.length,n,r,!1),t.stroke(),!0}}]),t}(),Tc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i={x:-.3,y:0};xc.transform(i,e),t.strokeStyle=t.fillStyle,t.fillStyle="rgba(0, 0, 0, 0)";var o=Math.PI,n=e.angle+o/2,r=e.angle+3*o/2;return t.beginPath(),t.arc(i.x,i.y,.4*e.length,n,r,!1),t.stroke(),!0}}]),t}(),Mc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i=[{x:.02,y:0},{x:-1,y:.3},{x:-1,y:-.3}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),t}(),Pc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i=[{x:0,y:.3},{x:0,y:-.3},{x:-1,y:0}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),t}(),Dc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i={x:-.4,y:0};return xc.transform(i,e),wt(t,i.x,i.y,.4*e.length),!0}}]),t}(),Bc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i=[{x:0,y:.5},{x:0,y:-.5},{x:-.15,y:-.5},{x:-.15,y:.5}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),t}(),Ic=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i=[{x:0,y:.3},{x:0,y:-.3},{x:-.6,y:-.3},{x:-.6,y:.3}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),t}(),zc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i=[{x:0,y:0},{x:-.5,y:-.3},{x:-1,y:0},{x:-.5,y:.3}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),t}(),Fc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i=[{x:-1,y:.3},{x:-.5,y:0},{x:-1,y:-.3},{x:0,y:0}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),t}(),Nc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i;switch(e.type&&(i=e.type.toLowerCase()),i){case"image":return Ec.draw(t,e);case"circle":return Dc.draw(t,e);case"box":return Ic.draw(t,e);case"crow":return Cc.draw(t,e);case"curve":return Sc.draw(t,e);case"diamond":return zc.draw(t,e);case"inv_curve":return Tc.draw(t,e);case"triangle":return Mc.draw(t,e);case"inv_triangle":return Pc.draw(t,e);case"bar":return Bc.draw(t,e);case"vee":return Fc.draw(t,e);case"arrow":default:return Oc.draw(t,e)}}}]),t}();function Ac(t,e){var i=xn(t);if(wo){var o=wo(t);e&&(o=ar(o).call(o,(function(e){return Eo(t,e).enumerable}))),i.push.apply(i,o)}return i}function Rc(t){for(var e=1;e<arguments.length;e++){var i,o=null!=arguments[e]?arguments[e]:{};if(e%2)Dn(i=Ac(Object(o),!0)).call(i,(function(e){zo(t,e,o[e])}));else if(Co)So(t,Co(o));else{var n;Dn(n=Ac(Object(o))).call(n,(function(e){Mo(t,e,Eo(o,e))}))}}return t}var jc=function(){function t(e,i,o){Po(this,t),this._body=i,this._labelModule=o,this.color={},this.colorDirty=!0,this.hoverWidth=1.5,this.selectionWidth=2,this.setOptions(e),this.fromPoint=this.from,this.toPoint=this.to}return Io(t,[{key:"connect",value:function(){this.from=this._body.nodes[this.options.from],this.to=this._body.nodes[this.options.to]}},{key:"cleanup",value:function(){return!1}},{key:"setOptions",value:function(t){this.options=t,this.from=this._body.nodes[this.options.from],this.to=this._body.nodes[this.options.to],this.id=this.options.id}},{key:"drawLine",value:function(t,e,i,o){var n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:this.getViaNode();t.strokeStyle=this.getColor(t,e),t.lineWidth=e.width,!1!==e.dashes?this._drawDashedLine(t,e,n):this._drawLine(t,e,n)}},{key:"_drawLine",value:function(t,e,i,o,n){if(this.from!=this.to)this._line(t,e,i,o,n);else{var r=an(this._getCircleData(t),3),s=r[0],a=r[1],h=r[2];this._circle(t,e,s,a,h)}}},{key:"_drawDashedLine",value:function(t,e,i,o,n){t.lineCap="round";var r=gn(e.dashes)?e.dashes:[5,5];if(void 0!==t.setLineDash){if(t.save(),t.setLineDash(r),t.lineDashOffset=0,this.from!=this.to)this._line(t,e,i);else{var s=an(this._getCircleData(t),3),a=s[0],h=s[1],d=s[2];this._circle(t,e,a,h,d)}t.setLineDash([0]),t.lineDashOffset=0,t.restore()}else{if(this.from!=this.to)Et(t,this.from.x,this.from.y,this.to.x,this.to.y,r);else{var l=an(this._getCircleData(t),3),c=l[0],u=l[1],f=l[2];this._circle(t,e,c,u,f)}this.enableShadow(t,e),t.stroke(),this.disableShadow(t,e)}}},{key:"findBorderPosition",value:function(t,e,i){return this.from!=this.to?this._findBorderPosition(t,e,i):this._findBorderPositionCircle(t,e,i)}},{key:"findBorderPositions",value:function(t){if(this.from!=this.to)return{from:this._findBorderPosition(this.from,t),to:this._findBorderPosition(this.to,t)};var e,i=an(vn(e=this._getCircleData(t)).call(e,0,2),2),o=i[0],n=i[1];return{from:this._findBorderPositionCircle(this.from,t,{x:o,y:n,low:.25,high:.6,direction:-1}),to:this._findBorderPositionCircle(this.from,t,{x:o,y:n,low:.6,high:.8,direction:1})}}},{key:"_getCircleData",value:function(t){var e=this.options.selfReference.size;void 0!==t&&void 0===this.from.shape.width&&this.from.shape.resize(t);var i=tl(t,this.options.selfReference.angle,e,this.from);return[i.x,i.y,e]}},{key:"_pointOnCircle",value:function(t,e,i,o){var n=2*o*Math.PI;return{x:t+i*Math.cos(n),y:e-i*Math.sin(n)}}},{key:"_findBorderPositionCircle",value:function(t,e,i){var o,n=i.x,r=i.y,s=i.low,a=i.high,h=i.direction,d=this.options.selfReference.size,l=.5*(s+a),c=0;!0===this.options.arrowStrikethrough&&(-1===h?c=this.options.endPointOffset.from:1===h&&(c=this.options.endPointOffset.to));var u=0;do{l=.5*(s+a),o=this._pointOnCircle(n,r,d,l);var f=Math.atan2(t.y-o.y,t.x-o.x),p=t.distanceToBorder(e,f)+c-Math.sqrt(Math.pow(o.x-t.x,2)+Math.pow(o.y-t.y,2));if(Math.abs(p)<.05)break;p>0?h>0?s=l:a=l:h>0?a=l:s=l,++u}while(s<=a&&u<10);return Rc(Rc({},o),{},{t:l})}},{key:"getLineWidth",value:function(t,e){return!0===t?Math.max(this.selectionWidth,.3/this._body.view.scale):!0===e?Math.max(this.hoverWidth,.3/this._body.view.scale):Math.max(this.options.width,.3/this._body.view.scale)}},{key:"getColor",value:function(t,e){if(!1!==e.inheritsColor){if("both"===e.inheritsColor&&this.from.id!==this.to.id){var i=t.createLinearGradient(this.from.x,this.from.y,this.to.x,this.to.y),o=this.from.options.color.highlight.border,n=this.to.options.color.highlight.border;return!1===this.from.selected&&!1===this.to.selected?(o=sh(this.from.options.color.border,e.opacity),n=sh(this.to.options.color.border,e.opacity)):!0===this.from.selected&&!1===this.to.selected?n=this.to.options.color.border:!1===this.from.selected&&!0===this.to.selected&&(o=this.from.options.color.border),i.addColorStop(0,o),i.addColorStop(1,n),i}return"to"===e.inheritsColor?sh(this.to.options.color.border,e.opacity):sh(this.from.options.color.border,e.opacity)}return sh(e.color,e.opacity)}},{key:"_circle",value:function(t,e,i,o,n){this.enableShadow(t,e);var r=0,s=2*Math.PI;if(!this.options.selfReference.renderBehindTheNode){var a=this.options.selfReference.angle,h=this.options.selfReference.angle+Math.PI,d=this._findBorderPositionCircle(this.from,t,{x:i,y:o,low:a,high:h,direction:-1}),l=this._findBorderPositionCircle(this.from,t,{x:i,y:o,low:a,high:h,direction:1});r=Math.atan2(d.y-o,d.x-i),s=Math.atan2(l.y-o,l.x-i)}t.beginPath(),t.arc(i,o,n,r,s,!1),t.stroke(),this.disableShadow(t,e)}},{key:"getDistanceToEdge",value:function(t,e,i,o,n,r){if(this.from!=this.to)return this._getDistanceToEdge(t,e,i,o,n,r);var s=an(this._getCircleData(void 0),3),a=s[0],h=s[1],d=s[2],l=a-n,c=h-r;return Math.abs(Math.sqrt(l*l+c*c)-d)}},{key:"_getDistanceToLine",value:function(t,e,i,o,n,r){var s=i-t,a=o-e,h=((n-t)*s+(r-e)*a)/(s*s+a*a);h>1?h=1:h<0&&(h=0);var d=t+h*s-n,l=e+h*a-r;return Math.sqrt(d*d+l*l)}},{key:"getArrowData",value:function(t,e,i,o,n,r){var s,a,h,d,l,c,u,f=r.width;"from"===e?(h=this.from,d=this.to,l=r.fromArrowScale<0,c=Math.abs(r.fromArrowScale),u=r.fromArrowType):"to"===e?(h=this.to,d=this.from,l=r.toArrowScale<0,c=Math.abs(r.toArrowScale),u=r.toArrowType):(h=this.to,d=this.from,l=r.middleArrowScale<0,c=Math.abs(r.middleArrowScale),u=r.middleArrowType);var p=15*c+3*f;if(h!=d){var v=p/kc(h.x-d.x,h.y-d.y);if("middle"!==e)if(!0===this.options.smooth.enabled){var g=this._findBorderPosition(h,t,{via:i}),y=this.getPoint(g.t+v*("from"===e?1:-1),i);s=Math.atan2(g.y-y.y,g.x-y.x),a=g}else s=Math.atan2(h.y-d.y,h.x-d.x),a=this._findBorderPosition(h,t);else{var m=(l?-v:v)/2,b=this.getPoint(.5+m,i),w=this.getPoint(.5-m,i);s=Math.atan2(b.y-w.y,b.x-w.x),a=this.getPoint(.5,i)}}else{var k=an(this._getCircleData(t),3),_=k[0],x=k[1],E=k[2];if("from"===e){var O=this.options.selfReference.angle,C=this.options.selfReference.angle+Math.PI,S=this._findBorderPositionCircle(this.from,t,{x:_,y:x,low:O,high:C,direction:-1});s=-2*S.t*Math.PI+1.5*Math.PI+.1*Math.PI,a=S}else if("to"===e){var T=this.options.selfReference.angle,M=this.options.selfReference.angle+Math.PI,P=this._findBorderPositionCircle(this.from,t,{x:_,y:x,low:T,high:M,direction:1});s=-2*P.t*Math.PI+1.5*Math.PI-1.1*Math.PI,a=P}else{var D=this.options.selfReference.angle/(2*Math.PI);a=this._pointOnCircle(_,x,E,D),s=-2*D*Math.PI+1.5*Math.PI+.1*Math.PI}}return{point:a,core:{x:a.x-.9*p*Math.cos(s),y:a.y-.9*p*Math.sin(s)},angle:s,length:p,type:u}}},{key:"drawArrowHead",value:function(t,e,i,o,n){t.strokeStyle=this.getColor(t,e),t.fillStyle=t.strokeStyle,t.lineWidth=e.width,Nc.draw(t,n)&&(this.enableShadow(t,e),Xr(t).call(t),this.disableShadow(t,e))}},{key:"enableShadow",value:function(t,e){!0===e.shadow&&(t.shadowColor=e.shadowColor,t.shadowBlur=e.shadowSize,t.shadowOffsetX=e.shadowX,t.shadowOffsetY=e.shadowY)}},{key:"disableShadow",value:function(t,e){!0===e.shadow&&(t.shadowColor="rgba(0,0,0,0)",t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0)}},{key:"drawBackground",value:function(t,e){if(!1!==e.background){var i={strokeStyle:t.strokeStyle,lineWidth:t.lineWidth,dashes:t.dashes};t.strokeStyle=e.backgroundColor,t.lineWidth=e.backgroundSize,this.setStrokeDashed(t,e.backgroundDashes),t.stroke(),t.strokeStyle=i.strokeStyle,t.lineWidth=i.lineWidth,t.dashes=i.dashes,this.setStrokeDashed(t,e.dashes)}}},{key:"setStrokeDashed",value:function(t,e){if(!1!==e)if(void 0!==t.setLineDash){var i=gn(e)?e:[5,5];t.setLineDash(i)}else console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");else void 0!==t.setLineDash?t.setLineDash([]):console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.")}}]),t}();function Lc(t,e){var i=xn(t);if(wo){var o=wo(t);e&&(o=ar(o).call(o,(function(e){return Eo(t,e).enumerable}))),i.push.apply(i,o)}return i}function Hc(t){for(var e=1;e<arguments.length;e++){var i,o=null!=arguments[e]?arguments[e]:{};if(e%2)Dn(i=Lc(Object(o),!0)).call(i,(function(e){zo(t,e,o[e])}));else if(Co)So(t,Co(o));else{var n;Dn(n=Lc(Object(o))).call(n,(function(e){Mo(t,e,Eo(o,e))}))}}return t}function Wc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Vc=function(t){bl(i,t);var e=Wc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"_findBorderPositionBezier",value:function(t,e){var i,o,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this._getViaCoordinates(),r=10,s=.2,a=!1,h=1,d=0,l=this.to,c=this.options.endPointOffset?this.options.endPointOffset.to:0;t.id===this.from.id&&(l=this.from,a=!0,c=this.options.endPointOffset?this.options.endPointOffset.from:0),!1===this.options.arrowStrikethrough&&(c=0);var u=0;do{o=.5*(d+h),i=this.getPoint(o,n);var f=Math.atan2(l.y-i.y,l.x-i.x),p=l.distanceToBorder(e,f)+c,v=Math.sqrt(Math.pow(i.x-l.x,2)+Math.pow(i.y-l.y,2)),g=p-v;if(Math.abs(g)<s)break;g<0?!1===a?d=o:h=o:!1===a?h=o:d=o,++u}while(d<=h&&u<r);return Hc(Hc({},i),{},{t:o})}},{key:"_getDistanceToBezierEdge",value:function(t,e,i,o,n,r,s){var a,h,d,l,c,u=1e9,f=t,p=e;for(h=1;h<10;h++)d=.1*h,l=Math.pow(1-d,2)*t+2*d*(1-d)*s.x+Math.pow(d,2)*i,c=Math.pow(1-d,2)*e+2*d*(1-d)*s.y+Math.pow(d,2)*o,h>0&&(u=(a=this._getDistanceToLine(f,p,l,c,n,r))<u?a:u),f=l,p=c;return u}},{key:"_bezierCurve",value:function(t,e,i,o){t.beginPath(),t.moveTo(this.fromPoint.x,this.fromPoint.y),null!=i&&null!=i.x?null!=o&&null!=o.x?t.bezierCurveTo(i.x,i.y,o.x,o.y,this.toPoint.x,this.toPoint.y):t.quadraticCurveTo(i.x,i.y,this.toPoint.x,this.toPoint.y):t.lineTo(this.toPoint.x,this.toPoint.y),this.drawBackground(t,e),this.enableShadow(t,e),t.stroke(),this.disableShadow(t,e)}},{key:"getViaNode",value:function(){return this._getViaCoordinates()}}]),i}(jc);function qc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Uc=function(t){bl(i,t);var e=qc(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n)).via=r.via,r._boundFunction=function(){r.positionBezierNode()},r._body.emitter.on("_repositionBezierNodes",r._boundFunction),r}return Io(i,[{key:"setOptions",value:function(t){gc(_l(i.prototype),"setOptions",this).call(this,t);var e=!1;this.options.physics!==t.physics&&(e=!0),this.options=t,this.id=this.options.id,this.from=this._body.nodes[this.options.from],this.to=this._body.nodes[this.options.to],this.setupSupportNode(),this.connect(),!0===e&&(this.via.setOptions({physics:this.options.physics}),this.positionBezierNode())}},{key:"connect",value:function(){this.from=this._body.nodes[this.options.from],this.to=this._body.nodes[this.options.to],void 0===this.from||void 0===this.to||!1===this.options.physics||this.from.id===this.to.id?this.via.setOptions({physics:!1}):this.via.setOptions({physics:!0})}},{key:"cleanup",value:function(){return this._body.emitter.off("_repositionBezierNodes",this._boundFunction),void 0!==this.via&&(delete this._body.nodes[this.via.id],this.via=void 0,!0)}},{key:"setupSupportNode",value:function(){if(void 0===this.via){var t="edgeId:"+this.id,e=this._body.functions.createNode({id:t,shape:"circle",physics:!0,hidden:!0});this._body.nodes[t]=e,this.via=e,this.via.parentEdgeId=this.id,this.positionBezierNode()}}},{key:"positionBezierNode",value:function(){void 0!==this.via&&void 0!==this.from&&void 0!==this.to?(this.via.x=.5*(this.from.x+this.to.x),this.via.y=.5*(this.from.y+this.to.y)):void 0!==this.via&&(this.via.x=0,this.via.y=0)}},{key:"_line",value:function(t,e,i){this._bezierCurve(t,e,i)}},{key:"_getViaCoordinates",value:function(){return this.via}},{key:"getViaNode",value:function(){return this.via}},{key:"getPoint",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.via;if(this.from===this.to){var i=this._getCircleData(),o=an(i,3),n=o[0],r=o[1],s=o[2],a=2*Math.PI*(1-t);return{x:n+s*Math.sin(a),y:r+s-s*(1-Math.cos(a))}}return{x:Math.pow(1-t,2)*this.fromPoint.x+2*t*(1-t)*e.x+Math.pow(t,2)*this.toPoint.x,y:Math.pow(1-t,2)*this.fromPoint.y+2*t*(1-t)*e.y+Math.pow(t,2)*this.toPoint.y}}},{key:"_findBorderPosition",value:function(t,e){return this._findBorderPositionBezier(t,e,this.via)}},{key:"_getDistanceToEdge",value:function(t,e,i,o,n,r){return this._getDistanceToBezierEdge(t,e,i,o,n,r,this.via)}}]),i}(Vc);function Yc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Xc=function(t){bl(i,t);var e=Yc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"_line",value:function(t,e,i){this._bezierCurve(t,e,i)}},{key:"getViaNode",value:function(){return this._getViaCoordinates()}},{key:"_getViaCoordinates",value:function(){var t,e,i=this.options.smooth.roundness,o=this.options.smooth.type,n=Math.abs(this.from.x-this.to.x),r=Math.abs(this.from.y-this.to.y);if("discrete"===o||"diagonalCross"===o){var s,a;s=a=n<=r?i*r:i*n,this.from.x>this.to.x&&(s=-s),this.from.y>=this.to.y&&(a=-a);var h=this.from.x+s,d=this.from.y+a;return"discrete"===o&&(n<=r?h=n<i*r?this.from.x:h:d=r<i*n?this.from.y:d),{x:h,y:d}}if("straightCross"===o){var l=(1-i)*n,c=(1-i)*r;return n<=r?(l=0,this.from.y<this.to.y&&(c=-c)):(this.from.x<this.to.x&&(l=-l),c=0),{x:this.to.x+l,y:this.to.y+c}}if("horizontal"===o){var u=(1-i)*n;return this.from.x<this.to.x&&(u=-u),{x:this.to.x+u,y:this.from.y}}if("vertical"===o){var f=(1-i)*r;return this.from.y<this.to.y&&(f=-f),{x:this.from.x,y:this.to.y+f}}if("curvedCW"===o){n=this.to.x-this.from.x,r=this.from.y-this.to.y;var p=Math.sqrt(n*n+r*r),v=Math.PI,g=(Math.atan2(r,n)+(.5*i+.5)*v)%(2*v);return{x:this.from.x+(.5*i+.5)*p*Math.sin(g),y:this.from.y+(.5*i+.5)*p*Math.cos(g)}}if("curvedCCW"===o){n=this.to.x-this.from.x,r=this.from.y-this.to.y;var y=Math.sqrt(n*n+r*r),m=Math.PI,b=(Math.atan2(r,n)+(.5*-i+.5)*m)%(2*m);return{x:this.from.x+(.5*i+.5)*y*Math.sin(b),y:this.from.y+(.5*i+.5)*y*Math.cos(b)}}t=e=n<=r?i*r:i*n,this.from.x>this.to.x&&(t=-t),this.from.y>=this.to.y&&(e=-e);var w=this.from.x+t,k=this.from.y+e;return n<=r?w=this.from.x<=this.to.x?this.to.x<w?this.to.x:w:this.to.x>w?this.to.x:w:k=this.from.y>=this.to.y?this.to.y>k?this.to.y:k:this.to.y<k?this.to.y:k,{x:w,y:k}}},{key:"_findBorderPosition",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this._findBorderPositionBezier(t,e,i.via)}},{key:"_getDistanceToEdge",value:function(t,e,i,o,n,r){var s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:this._getViaCoordinates();return this._getDistanceToBezierEdge(t,e,i,o,n,r,s)}},{key:"getPoint",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this._getViaCoordinates(),i=t,o=Math.pow(1-i,2)*this.fromPoint.x+2*i*(1-i)*e.x+Math.pow(i,2)*this.toPoint.x,n=Math.pow(1-i,2)*this.fromPoint.y+2*i*(1-i)*e.y+Math.pow(i,2)*this.toPoint.y;return{x:o,y:n}}}]),i}(Vc);function Gc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}function Kc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var $c=function(t){bl(i,t);var e=Kc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"_line",value:function(t,e,i){var o=i[0],n=i[1];this._bezierCurve(t,e,o,n)}},{key:"_getViaCoordinates",value:function(){var t,e,i,o,n=this.from.x-this.to.x,r=this.from.y-this.to.y,s=this.options.smooth.roundness;return(Math.abs(n)>Math.abs(r)||!0===this.options.smooth.forceDirection||"horizontal"===this.options.smooth.forceDirection)&&"vertical"!==this.options.smooth.forceDirection?(e=this.from.y,o=this.to.y,t=this.from.x-s*n,i=this.to.x+s*n):(e=this.from.y-s*r,o=this.to.y+s*r,t=this.from.x,i=this.to.x),[{x:t,y:e},{x:i,y:o}]}},{key:"getViaNode",value:function(){return this._getViaCoordinates()}},{key:"_findBorderPosition",value:function(t,e){return this._findBorderPositionBezier(t,e)}},{key:"_getDistanceToEdge",value:function(t,e,i,o,n,r){var s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:this._getViaCoordinates(),a=an(s,2),h=a[0],d=a[1];return this._getDistanceToBezierEdge2(t,e,i,o,n,r,h,d)}},{key:"getPoint",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this._getViaCoordinates(),i=an(e,2),o=i[0],n=i[1],r=t,s=[Math.pow(1-r,3),3*r*Math.pow(1-r,2),3*Math.pow(r,2)*(1-r),Math.pow(r,3)],a=s[0]*this.fromPoint.x+s[1]*o.x+s[2]*n.x+s[3]*this.toPoint.x,h=s[0]*this.fromPoint.y+s[1]*o.y+s[2]*n.y+s[3]*this.toPoint.y;return{x:a,y:h}}}]),i}(function(t){bl(i,t);var e=Gc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"_getDistanceToBezierEdge2",value:function(t,e,i,o,n,r,s,a){for(var h=1e9,d=t,l=e,c=[0,0,0,0],u=1;u<10;u++){var f=.1*u;c[0]=Math.pow(1-f,3),c[1]=3*f*Math.pow(1-f,2),c[2]=3*Math.pow(f,2)*(1-f),c[3]=Math.pow(f,3);var p=c[0]*t+c[1]*s.x+c[2]*a.x+c[3]*i,v=c[0]*e+c[1]*s.y+c[2]*a.y+c[3]*o;if(u>0){var g=this._getDistanceToLine(d,l,p,v,n,r);h=g<h?g:h}d=p,l=v}return h}}]),i}(Vc));function Qc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Zc=function(t){bl(i,t);var e=Qc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"_line",value:function(t,e){t.beginPath(),t.moveTo(this.fromPoint.x,this.fromPoint.y),t.lineTo(this.toPoint.x,this.toPoint.y),this.enableShadow(t,e),t.stroke(),this.disableShadow(t,e)}},{key:"getViaNode",value:function(){}},{key:"getPoint",value:function(t){return{x:(1-t)*this.fromPoint.x+t*this.toPoint.x,y:(1-t)*this.fromPoint.y+t*this.toPoint.y}}},{key:"_findBorderPosition",value:function(t,e){var i=this.to,o=this.from;t.id===this.from.id&&(i=this.from,o=this.to);var n=Math.atan2(i.y-o.y,i.x-o.x),r=i.x-o.x,s=i.y-o.y,a=Math.sqrt(r*r+s*s),h=(a-t.distanceToBorder(e,n))/a;return{x:(1-h)*o.x+h*i.x,y:(1-h)*o.y+h*i.y,t:0}}},{key:"_getDistanceToEdge",value:function(t,e,i,o,n,r){return this._getDistanceToLine(t,e,i,o,n,r)}}]),i}(jc),Jc=function(){function t(e,i,o,n,r){if(Po(this,t),void 0===i)throw new Error("No body provided");this.options=vh(n),this.globalOptions=n,this.defaultOptions=r,this.body=i,this.imagelist=o,this.id=void 0,this.fromId=void 0,this.toId=void 0,this.selected=!1,this.hover=!1,this.labelDirty=!0,this.baseWidth=this.options.width,this.baseFontSize=this.options.font.size,this.from=void 0,this.to=void 0,this.edgeType=void 0,this.connected=!1,this.labelModule=new ll(this.body,this.options,!0),this.setOptions(e)}return Io(t,[{key:"setOptions",value:function(e){if(e){var i=void 0!==e.physics&&this.options.physics!==e.physics||void 0!==e.hidden&&(this.options.hidden||!1)!==(e.hidden||!1)||void 0!==e.from&&this.options.from!==e.from||void 0!==e.to&&this.options.to!==e.to;t.parseOptions(this.options,e,!0,this.globalOptions),void 0!==e.id&&(this.id=e.id),void 0!==e.from&&(this.fromId=e.from),void 0!==e.to&&(this.toId=e.to),void 0!==e.title&&(this.title=e.title),void 0!==e.value&&(e.value=Yd(e.value));var o=[e,this.options,this.defaultOptions];return this.chooser=Qd("edge",o),this.updateLabelModule(e),i=this.updateEdgeType()||i,this._setInteractionWidths(),this.connect(),i}}},{key:"getFormattingValues",value:function(){var t=!0===this.options.arrows.to||!0===this.options.arrows.to.enabled,e=!0===this.options.arrows.from||!0===this.options.arrows.from.enabled,i=!0===this.options.arrows.middle||!0===this.options.arrows.middle.enabled,o=this.options.color.inherit,n={toArrow:t,toArrowScale:this.options.arrows.to.scaleFactor,toArrowType:this.options.arrows.to.type,toArrowSrc:this.options.arrows.to.src,toArrowImageWidth:this.options.arrows.to.imageWidth,toArrowImageHeight:this.options.arrows.to.imageHeight,middleArrow:i,middleArrowScale:this.options.arrows.middle.scaleFactor,middleArrowType:this.options.arrows.middle.type,middleArrowSrc:this.options.arrows.middle.src,middleArrowImageWidth:this.options.arrows.middle.imageWidth,middleArrowImageHeight:this.options.arrows.middle.imageHeight,fromArrow:e,fromArrowScale:this.options.arrows.from.scaleFactor,fromArrowType:this.options.arrows.from.type,fromArrowSrc:this.options.arrows.from.src,fromArrowImageWidth:this.options.arrows.from.imageWidth,fromArrowImageHeight:this.options.arrows.from.imageHeight,arrowStrikethrough:this.options.arrowStrikethrough,color:o?void 0:this.options.color.color,inheritsColor:o,opacity:this.options.color.opacity,hidden:this.options.hidden,length:this.options.length,shadow:this.options.shadow.enabled,shadowColor:this.options.shadow.color,shadowSize:this.options.shadow.size,shadowX:this.options.shadow.x,shadowY:this.options.shadow.y,dashes:this.options.dashes,width:this.options.width,background:this.options.background.enabled,backgroundColor:this.options.background.color,backgroundSize:this.options.background.size,backgroundDashes:this.options.background.dashes};if(this.selected||this.hover)if(!0===this.chooser){if(this.selected){var r=this.options.selectionWidth;"function"==typeof r?n.width=r(n.width):"number"==typeof r&&(n.width+=r),n.width=Math.max(n.width,.3/this.body.view.scale),n.color=this.options.color.highlight,n.shadow=this.options.shadow.enabled}else if(this.hover){var s=this.options.hoverWidth;"function"==typeof s?n.width=s(n.width):"number"==typeof s&&(n.width+=s),n.width=Math.max(n.width,.3/this.body.view.scale),n.color=this.options.color.hover,n.shadow=this.options.shadow.enabled}}else"function"==typeof this.chooser&&(this.chooser(n,this.options.id,this.selected,this.hover),void 0!==n.color&&(n.inheritsColor=!1),!1===n.shadow&&(n.shadowColor===this.options.shadow.color&&n.shadowSize===this.options.shadow.size&&n.shadowX===this.options.shadow.x&&n.shadowY===this.options.shadow.y||(n.shadow=!0)));else n.shadow=this.options.shadow.enabled,n.width=Math.max(n.width,.3/this.body.view.scale);return n}},{key:"updateLabelModule",value:function(t){var e=[t,this.options,this.globalOptions,this.defaultOptions];this.labelModule.update(this.options,e),void 0!==this.labelModule.baseSize&&(this.baseFontSize=this.labelModule.baseSize)}},{key:"updateEdgeType",value:function(){var t=this.options.smooth,e=!1,i=!0;return void 0!==this.edgeType&&((this.edgeType instanceof Uc&&!0===t.enabled&&"dynamic"===t.type||this.edgeType instanceof $c&&!0===t.enabled&&"cubicBezier"===t.type||this.edgeType instanceof Xc&&!0===t.enabled&&"dynamic"!==t.type&&"cubicBezier"!==t.type||this.edgeType instanceof Zc&&!1===t.type.enabled)&&(i=!1),!0===i&&(e=this.cleanup())),!0===i?!0===t.enabled?"dynamic"===t.type?(e=!0,this.edgeType=new Uc(this.options,this.body,this.labelModule)):"cubicBezier"===t.type?this.edgeType=new $c(this.options,this.body,this.labelModule):this.edgeType=new Xc(this.options,this.body,this.labelModule):this.edgeType=new Zc(this.options,this.body,this.labelModule):this.edgeType.setOptions(this.options),e}},{key:"connect",value:function(){this.disconnect(),this.from=this.body.nodes[this.fromId]||void 0,this.to=this.body.nodes[this.toId]||void 0,this.connected=void 0!==this.from&&void 0!==this.to,!0===this.connected?(this.from.attachEdge(this),this.to.attachEdge(this)):(this.from&&this.from.detachEdge(this),this.to&&this.to.detachEdge(this)),this.edgeType.connect()}},{key:"disconnect",value:function(){this.from&&(this.from.detachEdge(this),this.from=void 0),this.to&&(this.to.detachEdge(this),this.to=void 0),this.connected=!1}},{key:"getTitle",value:function(){return this.title}},{key:"isSelected",value:function(){return this.selected}},{key:"getValue",value:function(){return this.options.value}},{key:"setValueRange",value:function(t,e,i){if(void 0!==this.options.value){var o=this.options.scaling.customScalingFunction(t,e,i,this.options.value),n=this.options.scaling.max-this.options.scaling.min;if(!0===this.options.scaling.label.enabled){var r=this.options.scaling.label.max-this.options.scaling.label.min;this.options.font.size=this.options.scaling.label.min+o*r}this.options.width=this.options.scaling.min+o*n}else this.options.width=this.baseWidth,this.options.font.size=this.baseFontSize;this._setInteractionWidths(),this.updateLabelModule()}},{key:"_setInteractionWidths",value:function(){"function"==typeof this.options.hoverWidth?this.edgeType.hoverWidth=this.options.hoverWidth(this.options.width):this.edgeType.hoverWidth=this.options.hoverWidth+this.options.width,"function"==typeof this.options.selectionWidth?this.edgeType.selectionWidth=this.options.selectionWidth(this.options.width):this.edgeType.selectionWidth=this.options.selectionWidth+this.options.width}},{key:"draw",value:function(t){var e=this.getFormattingValues();if(!e.hidden){var i=this.edgeType.getViaNode();this.edgeType.drawLine(t,e,this.selected,this.hover,i),this.drawLabel(t,i)}}},{key:"drawArrows",value:function(t){var e=this.getFormattingValues();if(!e.hidden){var i=this.edgeType.getViaNode(),o={};this.edgeType.fromPoint=this.edgeType.from,this.edgeType.toPoint=this.edgeType.to,e.fromArrow&&(o.from=this.edgeType.getArrowData(t,"from",i,this.selected,this.hover,e),!1===e.arrowStrikethrough&&(this.edgeType.fromPoint=o.from.core),e.fromArrowSrc&&(o.from.image=this.imagelist.load(e.fromArrowSrc)),e.fromArrowImageWidth&&(o.from.imageWidth=e.fromArrowImageWidth),e.fromArrowImageHeight&&(o.from.imageHeight=e.fromArrowImageHeight)),e.toArrow&&(o.to=this.edgeType.getArrowData(t,"to",i,this.selected,this.hover,e),!1===e.arrowStrikethrough&&(this.edgeType.toPoint=o.to.core),e.toArrowSrc&&(o.to.image=this.imagelist.load(e.toArrowSrc)),e.toArrowImageWidth&&(o.to.imageWidth=e.toArrowImageWidth),e.toArrowImageHeight&&(o.to.imageHeight=e.toArrowImageHeight)),e.middleArrow&&(o.middle=this.edgeType.getArrowData(t,"middle",i,this.selected,this.hover,e),e.middleArrowSrc&&(o.middle.image=this.imagelist.load(e.middleArrowSrc)),e.middleArrowImageWidth&&(o.middle.imageWidth=e.middleArrowImageWidth),e.middleArrowImageHeight&&(o.middle.imageHeight=e.middleArrowImageHeight)),e.fromArrow&&this.edgeType.drawArrowHead(t,e,this.selected,this.hover,o.from),e.middleArrow&&this.edgeType.drawArrowHead(t,e,this.selected,this.hover,o.middle),e.toArrow&&this.edgeType.drawArrowHead(t,e,this.selected,this.hover,o.to)}}},{key:"drawLabel",value:function(t,e){if(void 0!==this.options.label){var i,o=this.from,n=this.to;if(this.labelModule.differentState(this.selected,this.hover)&&this.labelModule.getTextSize(t,this.selected,this.hover),o.id!=n.id){this.labelModule.pointToSelf=!1,i=this.edgeType.getPoint(.5,e),t.save();var r=this._getRotation(t);0!=r.angle&&(t.translate(r.x,r.y),t.rotate(r.angle)),this.labelModule.draw(t,i.x,i.y,this.selected,this.hover),t.restore()}else{this.labelModule.pointToSelf=!0;var s=tl(t,this.options.selfReference.angle,this.options.selfReference.size,o);i=this._pointOnCircle(s.x,s.y,this.options.selfReference.size,this.options.selfReference.angle),this.labelModule.draw(t,i.x,i.y,this.selected,this.hover)}}}},{key:"getItemsOnPoint",value:function(t){var e=[];if(this.labelModule.visible()){var i=this._getRotation();Zd(this.labelModule.getSize(),t,i)&&e.push({edgeId:this.id,labelId:0})}var o={left:t.x,top:t.y};return this.isOverlappingWith(o)&&e.push({edgeId:this.id}),e}},{key:"isOverlappingWith",value:function(t){if(this.connected){var e=this.from.x,i=this.from.y,o=this.to.x,n=this.to.y,r=t.left,s=t.top;return this.edgeType.getDistanceToEdge(e,i,o,n,r,s)<10}return!1}},{key:"_getRotation",value:function(t){var e=this.edgeType.getViaNode(),i=this.edgeType.getPoint(.5,e);void 0!==t&&this.labelModule.calculateLabelSize(t,this.selected,this.hover,i.x,i.y);var o={x:i.x,y:this.labelModule.size.yLine,angle:0};if(!this.labelModule.visible())return o;if("horizontal"===this.options.font.align)return o;var n=this.from.y-this.to.y,r=this.from.x-this.to.x,s=Math.atan2(n,r);return(s<-1&&r<0||s>0&&r<0)&&(s+=Math.PI),o.angle=s,o}},{key:"_pointOnCircle",value:function(t,e,i,o){return{x:t+i*Math.cos(o),y:e-i*Math.sin(o)}}},{key:"select",value:function(){this.selected=!0}},{key:"unselect",value:function(){this.selected=!1}},{key:"cleanup",value:function(){return this.edgeType.cleanup()}},{key:"remove",value:function(){this.cleanup(),this.disconnect(),delete this.body.edges[this.id]}},{key:"endPointsValid",value:function(){return void 0!==this.body.nodes[this.fromId]&&void 0!==this.body.nodes[this.toId]}}],[{key:"parseOptions",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},n=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=["endPointOffset","arrowStrikethrough","id","from","hidden","hoverWidth","labelHighlightBold","length","line","opacity","physics","scaling","selectionWidth","selfReferenceSize","selfReference","to","title","value","width","font","chosen","widthConstraint"];if(Za(r,t,e,i),void 0!==e.endPointOffset&&void 0!==e.endPointOffset.from&&(Ad(e.endPointOffset.from)?t.endPointOffset.from=e.endPointOffset.from:(t.endPointOffset.from=void 0!==o.endPointOffset.from?o.endPointOffset.from:0,console.error("endPointOffset.from is not a valid number"))),void 0!==e.endPointOffset&&void 0!==e.endPointOffset.to&&(Ad(e.endPointOffset.to)?t.endPointOffset.to=e.endPointOffset.to:(t.endPointOffset.to=void 0!==o.endPointOffset.to?o.endPointOffset.to:0,console.error("endPointOffset.to is not a valid number"))),Jd(e.label)?t.label=e.label:Jd(t.label)||(t.label=void 0),gh(t,e,"smooth",o),gh(t,e,"shadow",o),gh(t,e,"background",o),void 0!==e.dashes&&null!==e.dashes?t.dashes=e.dashes:!0===i&&null===e.dashes&&(t.dashes=Ir(o.dashes)),void 0!==e.scaling&&null!==e.scaling?(void 0!==e.scaling.min&&(t.scaling.min=e.scaling.min),void 0!==e.scaling.max&&(t.scaling.max=e.scaling.max),gh(t.scaling,e.scaling,"label",o.scaling)):!0===i&&null===e.scaling&&(t.scaling=Ir(o.scaling)),void 0!==e.arrows&&null!==e.arrows)if("string"==typeof e.arrows){var s=e.arrows.toLowerCase();t.arrows.to.enabled=-1!=Mr(s).call(s,"to"),t.arrows.middle.enabled=-1!=Mr(s).call(s,"middle"),t.arrows.from.enabled=-1!=Mr(s).call(s,"from")}else{if("object"!==dn(e.arrows))throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:"+Lr(e.arrows));gh(t.arrows,e.arrows,"to",o.arrows),gh(t.arrows,e.arrows,"middle",o.arrows),gh(t.arrows,e.arrows,"from",o.arrows)}else!0===i&&null===e.arrows&&(t.arrows=Ir(o.arrows));if(void 0!==e.color&&null!==e.color){var a=Ga(e.color)?{color:e.color,highlight:e.color,hover:e.color,inherit:!1,opacity:1}:e.color,h=t.color;if(n)th(h,o.color,!1,i);else for(var d in h)Object.prototype.hasOwnProperty.call(h,d)&&delete h[d];if(Ga(h))h.color=h,h.highlight=h,h.hover=h,h.inherit=!1,void 0===a.opacity&&(h.opacity=1);else{var l=!1;void 0!==a.color&&(h.color=a.color,l=!0),void 0!==a.highlight&&(h.highlight=a.highlight,l=!0),void 0!==a.hover&&(h.hover=a.hover,l=!0),void 0!==a.inherit&&(h.inherit=a.inherit),void 0!==a.opacity&&(h.opacity=Math.min(1,Math.max(0,a.opacity))),!0===l?h.inherit=!1:void 0===h.inherit&&(h.inherit="from")}}else!0===i&&null===e.color&&(t.color=vh(o.color));!0===i&&null===e.font&&(t.font=vh(o.font)),Object.prototype.hasOwnProperty.call(e,"selfReferenceSize")&&(console.warn("The selfReferenceSize property has been deprecated. Please use selfReference property instead. The selfReference can be set like thise selfReference:{size:30, angle:Math.PI / 4}"),t.selfReference.size=e.selfReferenceSize)}}]),t}(),tu=function(){function t(e,i,o){var n,r=this;Po(this,t),this.body=e,this.images=i,this.groups=o,this.body.functions.createEdge=bt(n=this.create).call(n,this),this.edgesListeners={add:function(t,e){r.add(e.items)},update:function(t,e){r.update(e.items)},remove:function(t,e){r.remove(e.items)}},this.options={},this.defaultOptions={arrows:{to:{enabled:!1,scaleFactor:1,type:"arrow"},middle:{enabled:!1,scaleFactor:1,type:"arrow"},from:{enabled:!1,scaleFactor:1,type:"arrow"}},endPointOffset:{from:0,to:0},arrowStrikethrough:!0,color:{color:"#848484",highlight:"#848484",hover:"#848484",inherit:"from",opacity:1},dashes:!1,font:{color:"#343434",size:14,face:"arial",background:"none",strokeWidth:2,strokeColor:"#ffffff",align:"horizontal",multi:!1,vadjust:0,bold:{mod:"bold"},boldital:{mod:"bold italic"},ital:{mod:"italic"},mono:{mod:"",size:15,face:"courier new",vadjust:2}},hidden:!1,hoverWidth:1.5,label:void 0,labelHighlightBold:!0,length:void 0,physics:!0,scaling:{min:1,max:15,label:{enabled:!0,min:14,max:30,maxVisible:30,drawThreshold:5},customScalingFunction:function(t,e,i,o){if(e===t)return.5;var n=1/(e-t);return Math.max(0,(o-t)*n)}},selectionWidth:1.5,selfReference:{size:20,angle:Math.PI/4,renderBehindTheNode:!0},shadow:{enabled:!1,color:"rgba(0,0,0,0.5)",size:10,x:5,y:5},background:{enabled:!1,color:"rgba(111,111,111,1)",size:10,dashes:!1},smooth:{enabled:!0,type:"dynamic",forceDirection:"none",roundness:.5},title:void 0,width:1,value:void 0},th(this.options,this.defaultOptions),this.bindEventListeners()}return Io(t,[{key:"bindEventListeners",value:function(){var t,e,i=this;this.body.emitter.on("_forceDisableDynamicCurves",(function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];"dynamic"===t&&(t="continuous");var o=!1;for(var n in i.body.edges)if(Object.prototype.hasOwnProperty.call(i.body.edges,n)){var r=i.body.edges[n],s=i.body.data.edges.get(n);if(null!=s){var a=s.smooth;void 0!==a&&!0===a.enabled&&"dynamic"===a.type&&(void 0===t?r.setOptions({smooth:!1}):r.setOptions({smooth:{type:t}}),o=!0)}}!0===e&&!0===o&&i.body.emitter.emit("_dataChanged")})),this.body.emitter.on("_dataUpdated",(function(){i.reconnectEdges()})),this.body.emitter.on("refreshEdges",bt(t=this.refresh).call(t,this)),this.body.emitter.on("refresh",bt(e=this.refresh).call(e,this)),this.body.emitter.on("destroy",(function(){nh(i.edgesListeners,(function(t,e){i.body.data.edges&&i.body.data.edges.off(e,t)})),delete i.body.functions.createEdge,delete i.edgesListeners.add,delete i.edgesListeners.update,delete i.edgesListeners.remove,delete i.edgesListeners}))}},{key:"setOptions",value:function(t){if(void 0!==t){Jc.parseOptions(this.options,t,!0,this.defaultOptions,!0);var e=!1;if(void 0!==t.smooth)for(var i in this.body.edges)Object.prototype.hasOwnProperty.call(this.body.edges,i)&&(e=this.body.edges[i].updateEdgeType()||e);if(void 0!==t.font)for(var o in this.body.edges)Object.prototype.hasOwnProperty.call(this.body.edges,o)&&this.body.edges[o].updateLabelModule();void 0===t.hidden&&void 0===t.physics&&!0!==e||this.body.emitter.emit("_dataChanged")}}},{key:"setData",value:function(t){var i=this,o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=this.body.data.edges;if(e.isDataViewLike("id",t))this.body.data.edges=t;else if(gn(t))this.body.data.edges=new e.DataSet,this.body.data.edges.add(t);else{if(t)throw new TypeError("Array or DataSet expected");this.body.data.edges=new e.DataSet}if(n&&nh(this.edgesListeners,(function(t,e){n.off(e,t)})),this.body.edges={},this.body.data.edges){nh(this.edgesListeners,(function(t,e){i.body.data.edges.on(e,t)}));var r=this.body.data.edges.getIds();this.add(r,!0)}this.body.emitter.emit("_adjustEdgesForHierarchicalLayout"),!1===o&&this.body.emitter.emit("_dataChanged")}},{key:"add",value:function(t){for(var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=this.body.edges,o=this.body.data.edges,n=0;n<t.length;n++){var r=t[n],s=i[r];s&&s.disconnect();var a=o.get(r,{showInternalIds:!0});i[r]=this.create(a)}this.body.emitter.emit("_adjustEdgesForHierarchicalLayout"),!1===e&&this.body.emitter.emit("_dataChanged")}},{key:"update",value:function(t){for(var e=this.body.edges,i=this.body.data.edges,o=!1,n=0;n<t.length;n++){var r=t[n],s=i.get(r),a=e[r];void 0!==a?(a.disconnect(),o=a.setOptions(s)||o,a.connect()):(this.body.edges[r]=this.create(s),o=!0)}!0===o?(this.body.emitter.emit("_adjustEdgesForHierarchicalLayout"),this.body.emitter.emit("_dataChanged")):this.body.emitter.emit("_dataUpdated")}},{key:"remove",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(0!==t.length){var i=this.body.edges;nh(t,(function(t){var e=i[t];void 0!==e&&e.remove()})),e&&this.body.emitter.emit("_dataChanged")}}},{key:"refresh",value:function(){var t=this;nh(this.body.edges,(function(e,i){var o=t.body.data.edges.get(i);void 0!==o&&e.setOptions(o)}))}},{key:"create",value:function(t){return new Jc(t,this.body,this.images,this.options,this.defaultOptions)}},{key:"reconnectEdges",value:function(){var t,e=this.body.nodes,i=this.body.edges;for(t in e)Object.prototype.hasOwnProperty.call(e,t)&&(e[t].edges=[]);for(t in i)if(Object.prototype.hasOwnProperty.call(i,t)){var o=i[t];o.from=null,o.to=null,o.connect()}}},{key:"getConnectedNodes",value:function(t){var e=[];if(void 0!==this.body.edges[t]){var i=this.body.edges[t];void 0!==i.fromId&&e.push(i.fromId),void 0!==i.toId&&e.push(i.toId)}return e}},{key:"_updateState",value:function(){this._addMissingEdges(),this._removeInvalidEdges()}},{key:"_removeInvalidEdges",value:function(){var t=this,e=[];nh(this.body.edges,(function(i,o){var n=t.body.nodes[i.toId],r=t.body.nodes[i.fromId];void 0!==n&&!0===n.isCluster||void 0!==r&&!0===r.isCluster||void 0!==n&&void 0!==r||e.push(o)})),this.remove(e,!1)}},{key:"_addMissingEdges",value:function(){var t=this.body.data.edges;if(null!=t){var e=this.body.edges,i=[];Dn(t).call(t,(function(t,o){void 0===e[o]&&i.push(o)})),this.add(i,!0)}}}]),t}(),eu=function(){function t(e,i,o){Po(this,t),this.body=e,this.physicsBody=i,this.barnesHutTree,this.setOptions(o),this._rng=Ra("BARNES HUT SOLVER")}return Io(t,[{key:"setOptions",value:function(t){this.options=t,this.thetaInversed=1/this.options.theta,this.overlapAvoidanceFactor=1-Math.max(0,Math.min(1,this.options.avoidOverlap))}},{key:"solve",value:function(){if(0!==this.options.gravitationalConstant&&this.physicsBody.physicsNodeIndices.length>0){var t,e=this.body.nodes,i=this.physicsBody.physicsNodeIndices,o=i.length,n=this._formBarnesHutTree(e,i);this.barnesHutTree=n;for(var r=0;r<o;r++)(t=e[i[r]]).options.mass>0&&this._getForceContributions(n.root,t)}}},{key:"_getForceContributions",value:function(t,e){this._getForceContribution(t.children.NW,e),this._getForceContribution(t.children.NE,e),this._getForceContribution(t.children.SW,e),this._getForceContribution(t.children.SE,e)}},{key:"_getForceContribution",value:function(t,e){if(t.childrenCount>0){var i=t.centerOfMass.x-e.x,o=t.centerOfMass.y-e.y,n=Math.sqrt(i*i+o*o);n*t.calcSize>this.thetaInversed?this._calculateForces(n,i,o,e,t):4===t.childrenCount?this._getForceContributions(t,e):t.children.data.id!=e.id&&this._calculateForces(n,i,o,e,t)}}},{key:"_calculateForces",value:function(t,e,i,o,n){0===t&&(e=t=.1),this.overlapAvoidanceFactor<1&&o.shape.radius&&(t=Math.max(.1+this.overlapAvoidanceFactor*o.shape.radius,t-o.shape.radius));var r=this.options.gravitationalConstant*n.mass*o.options.mass/Math.pow(t,3),s=e*r,a=i*r;this.physicsBody.forces[o.id].x+=s,this.physicsBody.forces[o.id].y+=a}},{key:"_formBarnesHutTree",value:function(t,e){for(var i,o=e.length,n=t[e[0]].x,r=t[e[0]].y,s=t[e[0]].x,a=t[e[0]].y,h=1;h<o;h++){var d=t[e[h]],l=d.x,c=d.y;d.options.mass>0&&(l<n&&(n=l),l>s&&(s=l),c<r&&(r=c),c>a&&(a=c))}var u=Math.abs(s-n)-Math.abs(a-r);u>0?(r-=.5*u,a+=.5*u):(n+=.5*u,s-=.5*u);var f=Math.max(1e-5,Math.abs(s-n)),p=.5*f,v=.5*(n+s),g=.5*(r+a),y={root:{centerOfMass:{x:0,y:0},mass:0,range:{minX:v-p,maxX:v+p,minY:g-p,maxY:g+p},size:f,calcSize:1/f,children:{data:null},maxWidth:0,level:0,childrenCount:4}};this._splitBranch(y.root);for(var m=0;m<o;m++)(i=t[e[m]]).options.mass>0&&this._placeInTree(y.root,i);return y}},{key:"_updateBranchMass",value:function(t,e){var i=t.centerOfMass,o=t.mass+e.options.mass,n=1/o;i.x=i.x*t.mass+e.x*e.options.mass,i.x*=n,i.y=i.y*t.mass+e.y*e.options.mass,i.y*=n,t.mass=o;var r=Math.max(Math.max(e.height,e.radius),e.width);t.maxWidth=t.maxWidth<r?r:t.maxWidth}},{key:"_placeInTree",value:function(t,e,i){1==i&&void 0!==i||this._updateBranchMass(t,e);var o,n=t.children.NW.range;o=n.maxX>e.x?n.maxY>e.y?"NW":"SW":n.maxY>e.y?"NE":"SE",this._placeInRegion(t,e,o)}},{key:"_placeInRegion",value:function(t,e,i){var o=t.children[i];switch(o.childrenCount){case 0:o.children.data=e,o.childrenCount=1,this._updateBranchMass(o,e);break;case 1:o.children.data.x===e.x&&o.children.data.y===e.y?(e.x+=this._rng(),e.y+=this._rng()):(this._splitBranch(o),this._placeInTree(o,e));break;case 4:this._placeInTree(o,e)}}},{key:"_splitBranch",value:function(t){var e=null;1===t.childrenCount&&(e=t.children.data,t.mass=0,t.centerOfMass.x=0,t.centerOfMass.y=0),t.childrenCount=4,t.children.data=null,this._insertRegion(t,"NW"),this._insertRegion(t,"NE"),this._insertRegion(t,"SW"),this._insertRegion(t,"SE"),null!=e&&this._placeInTree(t,e)}},{key:"_insertRegion",value:function(t,e){var i,o,n,r,s=.5*t.size;switch(e){case"NW":i=t.range.minX,o=t.range.minX+s,n=t.range.minY,r=t.range.minY+s;break;case"NE":i=t.range.minX+s,o=t.range.maxX,n=t.range.minY,r=t.range.minY+s;break;case"SW":i=t.range.minX,o=t.range.minX+s,n=t.range.minY+s,r=t.range.maxY;break;case"SE":i=t.range.minX+s,o=t.range.maxX,n=t.range.minY+s,r=t.range.maxY}t.children[e]={centerOfMass:{x:0,y:0},mass:0,range:{minX:i,maxX:o,minY:n,maxY:r},size:.5*t.size,calcSize:2*t.calcSize,children:{data:null},maxWidth:0,level:t.level+1,childrenCount:0}}},{key:"_debug",value:function(t,e){void 0!==this.barnesHutTree&&(t.lineWidth=1,this._drawBranch(this.barnesHutTree.root,t,e))}},{key:"_drawBranch",value:function(t,e,i){void 0===i&&(i="#FF0000"),4===t.childrenCount&&(this._drawBranch(t.children.NW,e),this._drawBranch(t.children.NE,e),this._drawBranch(t.children.SE,e),this._drawBranch(t.children.SW,e)),e.strokeStyle=i,e.beginPath(),e.moveTo(t.range.minX,t.range.minY),e.lineTo(t.range.maxX,t.range.minY),e.stroke(),e.beginPath(),e.moveTo(t.range.maxX,t.range.minY),e.lineTo(t.range.maxX,t.range.maxY),e.stroke(),e.beginPath(),e.moveTo(t.range.maxX,t.range.maxY),e.lineTo(t.range.minX,t.range.maxY),e.stroke(),e.beginPath(),e.moveTo(t.range.minX,t.range.maxY),e.lineTo(t.range.minX,t.range.minY),e.stroke()}}]),t}(),iu=function(){function t(e,i,o){Po(this,t),this._rng=Ra("REPULSION SOLVER"),this.body=e,this.physicsBody=i,this.setOptions(o)}return Io(t,[{key:"setOptions",value:function(t){this.options=t}},{key:"solve",value:function(){for(var t,e,i,o,n,r,s,a,h=this.body.nodes,d=this.physicsBody.physicsNodeIndices,l=this.physicsBody.forces,c=this.options.nodeDistance,u=-2/3/c,f=0;f<d.length-1;f++){s=h[d[f]];for(var p=f+1;p<d.length;p++)t=(a=h[d[p]]).x-s.x,e=a.y-s.y,0===(i=Math.sqrt(t*t+e*e))&&(t=i=.1*this._rng()),i<2*c&&(r=i<.5*c?1:u*i+1.3333333333333333,o=t*(r/=i),n=e*r,l[s.id].x-=o,l[s.id].y-=n,l[a.id].x+=o,l[a.id].y+=n)}}}]),t}(),ou=function(){function t(e,i,o){Po(this,t),this.body=e,this.physicsBody=i,this.setOptions(o)}return Io(t,[{key:"setOptions",value:function(t){this.options=t,this.overlapAvoidanceFactor=Math.max(0,Math.min(1,this.options.avoidOverlap||0))}},{key:"solve",value:function(){for(var t=this.body.nodes,e=this.physicsBody.physicsNodeIndices,i=this.physicsBody.forces,o=this.options.nodeDistance,n=0;n<e.length-1;n++)for(var r=t[e[n]],s=n+1;s<e.length;s++){var a=t[e[s]];if(r.level===a.level){var h=o+this.overlapAvoidanceFactor*((r.shape.radius||0)/2+(a.shape.radius||0)/2),d=a.x-r.x,l=a.y-r.y,c=Math.sqrt(d*d+l*l),u=void 0;u=c<h?-Math.pow(.05*c,2)+Math.pow(.05*h,2):0,0!==c&&(u/=c);var f=d*u,p=l*u;i[r.id].x-=f,i[r.id].y-=p,i[a.id].x+=f,i[a.id].y+=p}}}}]),t}(),nu=function(){function t(e,i,o){Po(this,t),this.body=e,this.physicsBody=i,this.setOptions(o)}return Io(t,[{key:"setOptions",value:function(t){this.options=t}},{key:"solve",value:function(){for(var t,e,i,o,n,r=this.physicsBody.physicsEdgeIndices,s=this.body.edges,a=0;a<r.length;a++)!0===(e=s[r[a]]).connected&&e.toId!==e.fromId&&void 0!==this.body.nodes[e.toId]&&void 0!==this.body.nodes[e.fromId]&&(void 0!==e.edgeType.via?(t=void 0===e.options.length?this.options.springLength:e.options.length,i=e.to,o=e.edgeType.via,n=e.from,this._calculateSpringForce(i,o,.5*t),this._calculateSpringForce(o,n,.5*t)):(t=void 0===e.options.length?1.5*this.options.springLength:e.options.length,this._calculateSpringForce(e.from,e.to,t)))}},{key:"_calculateSpringForce",value:function(t,e,i){var o=t.x-e.x,n=t.y-e.y,r=Math.max(Math.sqrt(o*o+n*n),.01),s=this.options.springConstant*(i-r)/r,a=o*s,h=n*s;void 0!==this.physicsBody.forces[t.id]&&(this.physicsBody.forces[t.id].x+=a,this.physicsBody.forces[t.id].y+=h),void 0!==this.physicsBody.forces[e.id]&&(this.physicsBody.forces[e.id].x-=a,this.physicsBody.forces[e.id].y-=h)}}]),t}(),ru=function(){function t(e,i,o){Po(this,t),this.body=e,this.physicsBody=i,this.setOptions(o)}return Io(t,[{key:"setOptions",value:function(t){this.options=t}},{key:"solve",value:function(){for(var t,e,i,o,n,r,s,a,h,d,l=this.body.edges,c=.5,u=this.physicsBody.physicsEdgeIndices,f=this.physicsBody.physicsNodeIndices,p=this.physicsBody.forces,v=0;v<f.length;v++){var g=f[v];p[g].springFx=0,p[g].springFy=0}for(var y=0;y<u.length;y++)!0===(e=l[u[y]]).connected&&(t=void 0===e.options.length?this.options.springLength:e.options.length,i=e.from.x-e.to.x,o=e.from.y-e.to.y,a=0===(a=Math.sqrt(i*i+o*o))?.01:a,n=i*(s=this.options.springConstant*(t-a)/a),r=o*s,e.to.level!=e.from.level?(void 0!==p[e.toId]&&(p[e.toId].springFx-=n,p[e.toId].springFy-=r),void 0!==p[e.fromId]&&(p[e.fromId].springFx+=n,p[e.fromId].springFy+=r)):(void 0!==p[e.toId]&&(p[e.toId].x-=c*n,p[e.toId].y-=c*r),void 0!==p[e.fromId]&&(p[e.fromId].x+=c*n,p[e.fromId].y+=c*r)));s=1;for(var m=0;m<f.length;m++){var b=f[m];h=Math.min(s,Math.max(-s,p[b].springFx)),d=Math.min(s,Math.max(-s,p[b].springFy)),p[b].x+=h,p[b].y+=d}for(var w=0,k=0,_=0;_<f.length;_++){var x=f[_];w+=p[x].x,k+=p[x].y}for(var E=w/f.length,O=k/f.length,C=0;C<f.length;C++){var S=f[C];p[S].x-=E,p[S].y-=O}}}]),t}(),su=function(){function t(e,i,o){Po(this,t),this.body=e,this.physicsBody=i,this.setOptions(o)}return Io(t,[{key:"setOptions",value:function(t){this.options=t}},{key:"solve",value:function(){for(var t,e,i,o,n=this.body.nodes,r=this.physicsBody.physicsNodeIndices,s=this.physicsBody.forces,a=0;a<r.length;a++){t=-(o=n[r[a]]).x,e=-o.y,i=Math.sqrt(t*t+e*e),this._calculateForces(i,t,e,s,o)}}},{key:"_calculateForces",value:function(t,e,i,o,n){var r=0===t?0:this.options.centralGravity/t;o[n.id].x=e*r,o[n.id].y=i*r}}]),t}();function au(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var hu=function(t){bl(i,t);var e=au(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n))._rng=Ra("FORCE ATLAS 2 BASED REPULSION SOLVER"),r}return Io(i,[{key:"_calculateForces",value:function(t,e,i,o,n){0===t&&(e=t=.1*this._rng()),this.overlapAvoidanceFactor<1&&o.shape.radius&&(t=Math.max(.1+this.overlapAvoidanceFactor*o.shape.radius,t-o.shape.radius));var r=o.edges.length+1,s=this.options.gravitationalConstant*n.mass*o.options.mass*r/Math.pow(t,2),a=e*s,h=i*s;this.physicsBody.forces[o.id].x+=a,this.physicsBody.forces[o.id].y+=h}}]),i}(eu);function du(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var lu,cu=function(t){bl(i,t);var e=du(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"_calculateForces",value:function(t,e,i,o,n){if(t>0){var r=n.edges.length+1,s=this.options.centralGravity*r*n.options.mass;o[n.id].x=e*s,o[n.id].y=i*s}}}]),i}(su),uu=function(){function t(e){Po(this,t),this.body=e,this.physicsBody={physicsNodeIndices:[],physicsEdgeIndices:[],forces:{},velocities:{}},this.physicsEnabled=!0,this.simulationInterval=1e3/60,this.requiresTimeout=!0,this.previousStates={},this.referenceState={},this.freezeCache={},this.renderTimer=void 0,this.adaptiveTimestep=!1,this.adaptiveTimestepEnabled=!1,this.adaptiveCounter=0,this.adaptiveInterval=3,this.stabilized=!1,this.startedStabilization=!1,this.stabilizationIterations=0,this.ready=!1,this.options={},this.defaultOptions={enabled:!0,barnesHut:{theta:.5,gravitationalConstant:-2e3,centralGravity:.3,springLength:95,springConstant:.04,damping:.09,avoidOverlap:0},forceAtlas2Based:{theta:.5,gravitationalConstant:-50,centralGravity:.01,springConstant:.08,springLength:100,damping:.4,avoidOverlap:0},repulsion:{centralGravity:.2,springLength:200,springConstant:.05,nodeDistance:100,damping:.09,avoidOverlap:0},hierarchicalRepulsion:{centralGravity:0,springLength:100,springConstant:.01,nodeDistance:120,damping:.09},maxVelocity:50,minVelocity:.75,solver:"barnesHut",stabilization:{enabled:!0,iterations:1e3,updateInterval:50,onlyDynamicEdges:!1,fit:!0},timestep:.5,adaptiveTimestep:!0,wind:{x:0,y:0}},ct(this.options,this.defaultOptions),this.timestep=.5,this.layoutFailed=!1,this.bindEventListeners()}return Io(t,[{key:"bindEventListeners",value:function(){var t=this;this.body.emitter.on("initPhysics",(function(){t.initPhysics()})),this.body.emitter.on("_layoutFailed",(function(){t.layoutFailed=!0})),this.body.emitter.on("resetPhysics",(function(){t.stopSimulation(),t.ready=!1})),this.body.emitter.on("disablePhysics",(function(){t.physicsEnabled=!1,t.stopSimulation()})),this.body.emitter.on("restorePhysics",(function(){t.setOptions(t.options),!0===t.ready&&t.startSimulation()})),this.body.emitter.on("startSimulation",(function(){!0===t.ready&&t.startSimulation()})),this.body.emitter.on("stopSimulation",(function(){t.stopSimulation()})),this.body.emitter.on("destroy",(function(){t.stopSimulation(!1),t.body.emitter.off()})),this.body.emitter.on("_dataChanged",(function(){t.updatePhysicsData()}))}},{key:"setOptions",value:function(t){if(void 0!==t)if(!1===t)this.options.enabled=!1,this.physicsEnabled=!1,this.stopSimulation();else if(!0===t)this.options.enabled=!0,this.physicsEnabled=!0,this.startSimulation();else{this.physicsEnabled=!0,Ja(["stabilization"],this.options,t),gh(this.options,t,"stabilization"),void 0===t.enabled&&(this.options.enabled=!0),!1===this.options.enabled&&(this.physicsEnabled=!1,this.stopSimulation());var e=this.options.wind;e&&(("number"!=typeof e.x||zd(e.x))&&(e.x=0),("number"!=typeof e.y||zd(e.y))&&(e.y=0)),this.timestep=this.options.timestep}this.init()}},{key:"init",value:function(){var t;"forceAtlas2Based"===this.options.solver?(t=this.options.forceAtlas2Based,this.nodesSolver=new hu(this.body,this.physicsBody,t),this.edgesSolver=new nu(this.body,this.physicsBody,t),this.gravitySolver=new cu(this.body,this.physicsBody,t)):"repulsion"===this.options.solver?(t=this.options.repulsion,this.nodesSolver=new iu(this.body,this.physicsBody,t),this.edgesSolver=new nu(this.body,this.physicsBody,t),this.gravitySolver=new su(this.body,this.physicsBody,t)):"hierarchicalRepulsion"===this.options.solver?(t=this.options.hierarchicalRepulsion,this.nodesSolver=new ou(this.body,this.physicsBody,t),this.edgesSolver=new ru(this.body,this.physicsBody,t),this.gravitySolver=new su(this.body,this.physicsBody,t)):(t=this.options.barnesHut,this.nodesSolver=new eu(this.body,this.physicsBody,t),this.edgesSolver=new nu(this.body,this.physicsBody,t),this.gravitySolver=new su(this.body,this.physicsBody,t)),this.modelOptions=t}},{key:"initPhysics",value:function(){!0===this.physicsEnabled&&!0===this.options.enabled?!0===this.options.stabilization.enabled?this.stabilize():(this.stabilized=!1,this.ready=!0,this.body.emitter.emit("fit",{},this.layoutFailed),this.startSimulation()):(this.ready=!0,this.body.emitter.emit("fit"))}},{key:"startSimulation",value:function(){var t;!0===this.physicsEnabled&&!0===this.options.enabled?(this.stabilized=!1,this.adaptiveTimestep=!1,this.body.emitter.emit("_resizeNodes"),void 0===this.viewFunction&&(this.viewFunction=bt(t=this.simulationStep).call(t,this),this.body.emitter.on("initRedraw",this.viewFunction),this.body.emitter.emit("_startRendering"))):this.body.emitter.emit("_redraw")}},{key:"stopSimulation",value:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.stabilized=!0,!0===t&&this._emitStabilized(),void 0!==this.viewFunction&&(this.body.emitter.off("initRedraw",this.viewFunction),this.viewFunction=void 0,!0===t&&this.body.emitter.emit("_stopRendering"))}},{key:"simulationStep",value:function(){var t=En();this.physicsTick(),(En()-t<.4*this.simulationInterval||!0===this.runDoubleSpeed)&&!1===this.stabilized&&(this.physicsTick(),this.runDoubleSpeed=!0),!0===this.stabilized&&this.stopSimulation()}},{key:"_emitStabilized",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.stabilizationIterations;(this.stabilizationIterations>1||!0===this.startedStabilization)&&qr((function(){t.body.emitter.emit("stabilized",{iterations:e}),t.startedStabilization=!1,t.stabilizationIterations=0}),0)}},{key:"physicsStep",value:function(){this.gravitySolver.solve(),this.nodesSolver.solve(),this.edgesSolver.solve(),this.moveNodes()}},{key:"adjustTimeStep",value:function(){!0===this._evaluateStepQuality()?this.timestep=1.2*this.timestep:this.timestep/1.2<this.options.timestep?this.timestep=this.options.timestep:(this.adaptiveCounter=-1,this.timestep=Math.max(this.options.timestep,this.timestep/1.2))}},{key:"physicsTick",value:function(){if(this._startStabilizing(),!0!==this.stabilized){if(!0===this.adaptiveTimestep&&!0===this.adaptiveTimestepEnabled)this.adaptiveCounter%this.adaptiveInterval==0?(this.timestep=2*this.timestep,this.physicsStep(),this.revert(),this.timestep=.5*this.timestep,this.physicsStep(),this.physicsStep(),this.adjustTimeStep()):this.physicsStep(),this.adaptiveCounter+=1;else this.timestep=this.options.timestep,this.physicsStep();!0===this.stabilized&&this.revert(),this.stabilizationIterations++}}},{key:"updatePhysicsData",value:function(){this.physicsBody.forces={},this.physicsBody.physicsNodeIndices=[],this.physicsBody.physicsEdgeIndices=[];var t=this.body.nodes,e=this.body.edges;for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&!0===t[i].options.physics&&this.physicsBody.physicsNodeIndices.push(t[i].id);for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&!0===e[o].options.physics&&this.physicsBody.physicsEdgeIndices.push(e[o].id);for(var n=0;n<this.physicsBody.physicsNodeIndices.length;n++){var r=this.physicsBody.physicsNodeIndices[n];this.physicsBody.forces[r]={x:0,y:0},void 0===this.physicsBody.velocities[r]&&(this.physicsBody.velocities[r]={x:0,y:0})}for(var s in this.physicsBody.velocities)void 0===t[s]&&delete this.physicsBody.velocities[s]}},{key:"revert",value:function(){var t=xn(this.previousStates),e=this.body.nodes,i=this.physicsBody.velocities;this.referenceState={};for(var o=0;o<t.length;o++){var n=t[o];void 0!==e[n]?!0===e[n].options.physics&&(this.referenceState[n]={positions:{x:e[n].x,y:e[n].y}},i[n].x=this.previousStates[n].vx,i[n].y=this.previousStates[n].vy,e[n].x=this.previousStates[n].x,e[n].y=this.previousStates[n].y):delete this.previousStates[n]}}},{key:"_evaluateStepQuality",value:function(){var t,e,i=this.body.nodes,o=this.referenceState;for(var n in this.referenceState)if(Object.prototype.hasOwnProperty.call(this.referenceState,n)&&void 0!==i[n]&&(t=i[n].x-o[n].positions.x,e=i[n].y-o[n].positions.y,Math.sqrt(Math.pow(t,2)+Math.pow(e,2))>.3))return!1;return!0}},{key:"moveNodes",value:function(){for(var t=this.physicsBody.physicsNodeIndices,e=0,i=0,o=0;o<t.length;o++){var n=t[o],r=this._performStep(n);e=Math.max(e,r),i+=r}this.adaptiveTimestepEnabled=i/t.length<5,this.stabilized=e<this.options.minVelocity}},{key:"calculateComponentVelocity",value:function(t,e,i){t+=(e-this.modelOptions.damping*t)/i*this.timestep;var o=this.options.maxVelocity||1e9;return Math.abs(t)>o&&(t=t>0?o:-o),t}},{key:"_performStep",value:function(t){var e=this.body.nodes[t],i=this.physicsBody.forces[t];this.options.wind&&(i.x+=this.options.wind.x,i.y+=this.options.wind.y);var o=this.physicsBody.velocities[t];return this.previousStates[t]={x:e.x,y:e.y,vx:o.x,vy:o.y},!1===e.options.fixed.x?(o.x=this.calculateComponentVelocity(o.x,i.x,e.options.mass),e.x+=o.x*this.timestep):(i.x=0,o.x=0),!1===e.options.fixed.y?(o.y=this.calculateComponentVelocity(o.y,i.y,e.options.mass),e.y+=o.y*this.timestep):(i.y=0,o.y=0),Math.sqrt(Math.pow(o.x,2)+Math.pow(o.y,2))}},{key:"_freezeNodes",value:function(){var t=this.body.nodes;for(var e in t)if(Object.prototype.hasOwnProperty.call(t,e)&&t[e].x&&t[e].y){var i=t[e].options.fixed;this.freezeCache[e]={x:i.x,y:i.y},i.x=!0,i.y=!0}}},{key:"_restoreFrozenNodes",value:function(){var t=this.body.nodes;for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&void 0!==this.freezeCache[e]&&(t[e].options.fixed.x=this.freezeCache[e].x,t[e].options.fixed.y=this.freezeCache[e].y);this.freezeCache={}}},{key:"stabilize",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.stabilization.iterations;"number"!=typeof e&&(e=this.options.stabilization.iterations,console.error("The stabilize method needs a numeric amount of iterations. Switching to default: ",e)),0!==this.physicsBody.physicsNodeIndices.length?(this.adaptiveTimestep=this.options.adaptiveTimestep,this.body.emitter.emit("_resizeNodes"),this.stopSimulation(),this.stabilized=!1,this.body.emitter.emit("_blockRedraw"),this.targetIterations=e,!0===this.options.stabilization.onlyDynamicEdges&&this._freezeNodes(),this.stabilizationIterations=0,qr((function(){return t._stabilizationBatch()}),0)):this.ready=!0}},{key:"_startStabilizing",value:function(){return!0!==this.startedStabilization&&(this.body.emitter.emit("startStabilizing"),this.startedStabilization=!0,!0)}},{key:"_stabilizationBatch",value:function(){var t=this,e=function(){return!1===t.stabilized&&t.stabilizationIterations<t.targetIterations},i=function(){t.body.emitter.emit("stabilizationProgress",{iterations:t.stabilizationIterations,total:t.targetIterations})};this._startStabilizing()&&i();for(var o,n=0;e()&&n<this.options.stabilization.updateInterval;)this.physicsTick(),n++;(i(),e())?qr(bt(o=this._stabilizationBatch).call(o,this),0):this._finalizeStabilization()}},{key:"_finalizeStabilization",value:function(){this.body.emitter.emit("_allowRedraw"),!0===this.options.stabilization.fit&&this.body.emitter.emit("fit"),!0===this.options.stabilization.onlyDynamicEdges&&this._restoreFrozenNodes(),this.body.emitter.emit("stabilizationIterationsDone"),this.body.emitter.emit("_requestRedraw"),!0===this.stabilized?this._emitStabilized():this.startSimulation(),this.ready=!0}},{key:"_drawForces",value:function(t){for(var e=0;e<this.physicsBody.physicsNodeIndices.length;e++){var i=this.physicsBody.physicsNodeIndices[e],o=this.body.nodes[i],n=this.physicsBody.forces[i],r=Math.sqrt(Math.pow(n.x,2)+Math.pow(n.x,2)),s=Math.min(Math.max(5,r),15),a=3*s,h=ch((180-180*Math.min(1,Math.max(0,.03*r)))/360,1,1),d={x:o.x+20*n.x,y:o.y+20*n.y};t.lineWidth=s,t.strokeStyle=h,t.beginPath(),t.moveTo(o.x,o.y),t.lineTo(d.x,d.y),t.stroke();var l=Math.atan2(n.y,n.x);t.fillStyle=h,Nc.draw(t,{type:"arrow",point:d,angle:l,length:a}),Xr(t).call(t)}}}]),t}(),fu=new Uint8Array(16);function pu(){if(!lu&&!(lu="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return lu(fu)}var vu=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function gu(t){return"string"==typeof t&&vu.test(t)}for(var yu=[],mu=0;mu<256;++mu)yu.push((mu+256).toString(16).substr(1));function bu(t,e,i){var o=(t=t||{}).random||(t.rng||pu)();if(o[6]=15&o[6]|64,o[8]=63&o[8]|128,e){i=i||0;for(var n=0;n<16;++n)e[i+n]=o[n];return e}return function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=(yu[t[e+0]]+yu[t[e+1]]+yu[t[e+2]]+yu[t[e+3]]+"-"+yu[t[e+4]]+yu[t[e+5]]+"-"+yu[t[e+6]]+yu[t[e+7]]+"-"+yu[t[e+8]]+yu[t[e+9]]+"-"+yu[t[e+10]]+yu[t[e+11]]+yu[t[e+12]]+yu[t[e+13]]+yu[t[e+14]]+yu[t[e+15]]).toLowerCase();if(!gu(i))throw TypeError("Stringified UUID is invalid");return i}(o)}var wu=function(){function t(){Po(this,t)}return Io(t,null,[{key:"getRange",value:function(t){var e,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],o=1e9,n=-1e9,r=1e9,s=-1e9;if(i.length>0)for(var a=0;a<i.length;a++)r>(e=t[i[a]]).shape.boundingBox.left&&(r=e.shape.boundingBox.left),s<e.shape.boundingBox.right&&(s=e.shape.boundingBox.right),o>e.shape.boundingBox.top&&(o=e.shape.boundingBox.top),n<e.shape.boundingBox.bottom&&(n=e.shape.boundingBox.bottom);return 1e9===r&&-1e9===s&&1e9===o&&-1e9===n&&(o=0,n=0,r=0,s=0),{minX:r,maxX:s,minY:o,maxY:n}}},{key:"getRangeCore",value:function(t){var e,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],o=1e9,n=-1e9,r=1e9,s=-1e9;if(i.length>0)for(var a=0;a<i.length;a++)r>(e=t[i[a]]).x&&(r=e.x),s<e.x&&(s=e.x),o>e.y&&(o=e.y),n<e.y&&(n=e.y);return 1e9===r&&-1e9===s&&1e9===o&&-1e9===n&&(o=0,n=0,r=0,s=0),{minX:r,maxX:s,minY:o,maxY:n}}},{key:"findCenter",value:function(t){return{x:.5*(t.maxX+t.minX),y:.5*(t.maxY+t.minY)}}},{key:"cloneOptions",value:function(t,e){var i={};return void 0===e||"node"===e?(th(i,t.options,!0),i.x=t.x,i.y=t.y,i.amountOfConnections=t.edges.length):th(i,t.options,!0),i}}]),t}();function ku(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var _u=function(t){bl(i,t);var e=ku(i);function i(t,o,n,r,s,a){var h;return Po(this,i),(h=e.call(this,t,o,n,r,s,a)).isCluster=!0,h.containedNodes={},h.containedEdges={},h}return Io(i,[{key:"_openChildCluster",value:function(t){var e=this,i=this.body.nodes[t];if(void 0===this.containedNodes[t])throw new Error("node with id: "+t+" not in current cluster");if(!i.isCluster)throw new Error("node with id: "+t+" is not a cluster");delete this.containedNodes[t],nh(i.edges,(function(t){delete e.containedEdges[t.id]})),nh(i.containedNodes,(function(t,i){e.containedNodes[i]=t})),i.containedNodes={},nh(i.containedEdges,(function(t,i){e.containedEdges[i]=t})),i.containedEdges={},nh(i.edges,(function(t){nh(e.edges,(function(i){var o,n,r=Mr(o=i.clusteringEdgeReplacingIds).call(o,t.id);-1!==r&&(nh(t.clusteringEdgeReplacingIds,(function(t){i.clusteringEdgeReplacingIds.push(t),e.body.edges[t].edgeReplacedById=i.id})),qn(n=i.clusteringEdgeReplacingIds).call(n,r,1))}))})),i.edges=[]}}]),i}(lc),xu=function(){function t(e){var i=this;Po(this,t),this.body=e,this.clusteredNodes={},this.clusteredEdges={},this.options={},this.defaultOptions={},ct(this.options,this.defaultOptions),this.body.emitter.on("_resetData",(function(){i.clusteredNodes={},i.clusteredEdges={}}))}return Io(t,[{key:"clusterByHubsize",value:function(t,e){void 0===t?t=this._getHubSize():"object"===dn(t)&&(e=this._checkOptions(t),t=this._getHubSize());for(var i=[],o=0;o<this.body.nodeIndices.length;o++){var n=this.body.nodes[this.body.nodeIndices[o]];n.edges.length>=t&&i.push(n.id)}for(var r=0;r<i.length;r++)this.clusterByConnection(i[r],e,!0);this.body.emitter.emit("_dataChanged")}},{key:"cluster",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(void 0===e.joinCondition)throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");e=this._checkOptions(e);var o={},n={};nh(this.body.nodes,(function(i,r){i.options&&!0===e.joinCondition(i.options)&&(o[r]=i,nh(i.edges,(function(e){void 0===t.clusteredEdges[e.id]&&(n[e.id]=e)})))})),this._cluster(o,n,e,i)}},{key:"clusterByEdgeCount",value:function(t,e){var i=this,o=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];e=this._checkOptions(e);for(var n,r,s,a=[],h={},d=function(o){var d={},l={},c=i.body.nodeIndices[o],u=i.body.nodes[c];if(void 0===h[c]){s=0,r=[];for(var f=0;f<u.edges.length;f++)n=u.edges[f],void 0===i.clusteredEdges[n.id]&&(n.toId!==n.fromId&&s++,r.push(n));if(s===t){for(var p=function(t){if(void 0===e.joinCondition||null===e.joinCondition)return!0;var i=wu.cloneOptions(t);return e.joinCondition(i)},v=!0,g=0;g<r.length;g++){n=r[g];var y=i._getConnectedId(n,c);if(!p(u)){v=!1;break}l[n.id]=n,d[c]=u,d[y]=i.body.nodes[y],h[c]=!0}if(xn(d).length>0&&xn(l).length>0&&!0===v){var m=function(){for(var t=0;t<a.length;++t)for(var e in d)if(void 0!==a[t].nodes[e])return a[t]}();if(void 0!==m){for(var b in d)void 0===m.nodes[b]&&(m.nodes[b]=d[b]);for(var w in l)void 0===m.edges[w]&&(m.edges[w]=l[w])}else a.push({nodes:d,edges:l})}}}},l=0;l<this.body.nodeIndices.length;l++)d(l);for(var c=0;c<a.length;c++)this._cluster(a[c].nodes,a[c].edges,e,!1);!0===o&&this.body.emitter.emit("_dataChanged")}},{key:"clusterOutliers",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this.clusterByEdgeCount(1,t,e)}},{key:"clusterBridges",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this.clusterByEdgeCount(2,t,e)}},{key:"clusterByConnection",value:function(t,e){var i,o=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(void 0===t)throw new Error("No nodeId supplied to clusterByConnection!");if(void 0===this.body.nodes[t])throw new Error("The nodeId given to clusterByConnection does not exist!");var n=this.body.nodes[t];void 0===(e=this._checkOptions(e,n)).clusterNodeProperties.x&&(e.clusterNodeProperties.x=n.x),void 0===e.clusterNodeProperties.y&&(e.clusterNodeProperties.y=n.y),void 0===e.clusterNodeProperties.fixed&&(e.clusterNodeProperties.fixed={},e.clusterNodeProperties.fixed.x=n.options.fixed.x,e.clusterNodeProperties.fixed.y=n.options.fixed.y);var r={},s={},a=n.id,h=wu.cloneOptions(n);r[a]=n;for(var d=0;d<n.edges.length;d++){var l=n.edges[d];if(void 0===this.clusteredEdges[l.id]){var c=this._getConnectedId(l,a);if(void 0===this.clusteredNodes[c])if(c!==a)if(void 0===e.joinCondition)s[l.id]=l,r[c]=this.body.nodes[c];else{var u=wu.cloneOptions(this.body.nodes[c]);!0===e.joinCondition(h,u)&&(s[l.id]=l,r[c]=this.body.nodes[c])}else s[l.id]=l}}var f=kn(i=xn(r)).call(i,(function(t){return r[t].id}));for(var p in r)if(Object.prototype.hasOwnProperty.call(r,p))for(var v=r[p],g=0;g<v.edges.length;g++){var y=v.edges[g];Mr(f).call(f,this._getConnectedId(y,v.id))>-1&&(s[y.id]=y)}this._cluster(r,s,e,o)}},{key:"_createClusterEdges",value:function(t,e,i,o){for(var n,r,s,a,h,d,l=xn(t),c=[],u=0;u<l.length;u++){s=t[r=l[u]];for(var f=0;f<s.edges.length;f++)n=s.edges[f],void 0===this.clusteredEdges[n.id]&&(n.toId==n.fromId?e[n.id]=n:n.toId==r?(a=i.id,d=h=n.fromId):(a=n.toId,h=i.id,d=a),void 0===t[d]&&c.push({edge:n,fromId:h,toId:a}))}for(var p=[],v=function(t){for(var e=0;e<p.length;e++){var i=p[e],o=t.fromId===i.fromId&&t.toId===i.toId,n=t.fromId===i.toId&&t.toId===i.fromId;if(o||n)return i}return null},g=0;g<c.length;g++){var y=c[g],m=y.edge,b=v(y);null===b?(b=this._createClusteredEdge(y.fromId,y.toId,m,o),p.push(b)):b.clusteringEdgeReplacingIds.push(m.id),this.body.edges[m.id].edgeReplacedById=b.id,this._backupEdgeOptions(m),m.setOptions({physics:!1})}}},{key:"_checkOptions",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return void 0===t.clusterEdgeProperties&&(t.clusterEdgeProperties={}),void 0===t.clusterNodeProperties&&(t.clusterNodeProperties={}),t}},{key:"_cluster",value:function(t,e,i){var o=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],n=[];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&void 0!==this.clusteredNodes[r]&&n.push(r);for(var s=0;s<n.length;++s)delete t[n[s]];if(0!=xn(t).length&&(1!=xn(t).length||1==i.clusterNodeProperties.allowSingleNodeCluster)){var a=th({},i.clusterNodeProperties);if(void 0!==i.processProperties){var h=[];for(var d in t)if(Object.prototype.hasOwnProperty.call(t,d)){var l=wu.cloneOptions(t[d]);h.push(l)}var c=[];for(var u in e)if(Object.prototype.hasOwnProperty.call(e,u)&&"clusterEdge:"!==u.substr(0,12)){var f=wu.cloneOptions(e[u],"edge");c.push(f)}if(!(a=i.processProperties(a,h,c)))throw new Error("The processProperties function does not return properties!")}void 0===a.id&&(a.id="cluster:"+bu());var p=a.id;void 0===a.label&&(a.label="cluster");var v=void 0;void 0===a.x&&(v=this._getClusterPosition(t),a.x=v.x),void 0===a.y&&(void 0===v&&(v=this._getClusterPosition(t)),a.y=v.y),a.id=p;var g=this.body.functions.createNode(a,_u);g.containedNodes=t,g.containedEdges=e,g.clusterEdgeProperties=i.clusterEdgeProperties,this.body.nodes[a.id]=g,this._clusterEdges(t,e,a,i.clusterEdgeProperties),a.id=void 0,!0===o&&this.body.emitter.emit("_dataChanged")}}},{key:"_backupEdgeOptions",value:function(t){void 0===this.clusteredEdges[t.id]&&(this.clusteredEdges[t.id]={physics:t.options.physics})}},{key:"_restoreEdge",value:function(t){var e=this.clusteredEdges[t.id];void 0!==e&&(t.setOptions({physics:e.physics}),delete this.clusteredEdges[t.id])}},{key:"isCluster",value:function(t){return void 0!==this.body.nodes[t]?!0===this.body.nodes[t].isCluster:(console.error("Node does not exist."),!1)}},{key:"_getClusterPosition",value:function(t){for(var e,i=xn(t),o=t[i[0]].x,n=t[i[0]].x,r=t[i[0]].y,s=t[i[0]].y,a=1;a<i.length;a++)o=(e=t[i[a]]).x<o?e.x:o,n=e.x>n?e.x:n,r=e.y<r?e.y:r,s=e.y>s?e.y:s;return{x:.5*(o+n),y:.5*(r+s)}}},{key:"openCluster",value:function(t,e){var i=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(void 0===t)throw new Error("No clusterNodeId supplied to openCluster.");var o=this.body.nodes[t];if(void 0===o)throw new Error("The clusterNodeId supplied to openCluster does not exist.");if(!0!==o.isCluster||void 0===o.containedNodes||void 0===o.containedEdges)throw new Error("The node:"+t+" is not a valid cluster.");var n=this.findNode(t),r=Mr(n).call(n,t)-1;if(r>=0){var s=n[r],a=this.body.nodes[s];return a._openChildCluster(t),delete this.body.nodes[t],void(!0===i&&this.body.emitter.emit("_dataChanged"))}var h=o.containedNodes,d=o.containedEdges;if(void 0!==e&&void 0!==e.releaseFunction&&"function"==typeof e.releaseFunction){var l={},c={x:o.x,y:o.y};for(var u in h)if(Object.prototype.hasOwnProperty.call(h,u)){var f=this.body.nodes[u];l[u]={x:f.x,y:f.y}}var p=e.releaseFunction(c,l);for(var v in h)if(Object.prototype.hasOwnProperty.call(h,v)){var g=this.body.nodes[v];void 0!==p[v]&&(g.x=void 0===p[v].x?o.x:p[v].x,g.y=void 0===p[v].y?o.y:p[v].y)}}else nh(h,(function(t){!1===t.options.fixed.x&&(t.x=o.x),!1===t.options.fixed.y&&(t.y=o.y)}));for(var y in h)if(Object.prototype.hasOwnProperty.call(h,y)){var m=this.body.nodes[y];m.vx=o.vx,m.vy=o.vy,m.setOptions({physics:!0}),delete this.clusteredNodes[y]}for(var b=[],w=0;w<o.edges.length;w++)b.push(o.edges[w]);for(var k=0;k<b.length;k++){for(var _=b[k],x=this._getConnectedId(_,t),E=this.clusteredNodes[x],O=0;O<_.clusteringEdgeReplacingIds.length;O++){var C=_.clusteringEdgeReplacingIds[O],S=this.body.edges[C];if(void 0!==S)if(void 0!==E){var T=this.body.nodes[E.clusterId];T.containedEdges[S.id]=S,delete d[S.id];var M=S.fromId,P=S.toId;S.toId==x?P=E.clusterId:M=E.clusterId,this._createClusteredEdge(M,P,S,T.clusterEdgeProperties,{hidden:!1,physics:!0})}else this._restoreEdge(S)}_.remove()}for(var D in d)Object.prototype.hasOwnProperty.call(d,D)&&this._restoreEdge(d[D]);delete this.body.nodes[t],!0===i&&this.body.emitter.emit("_dataChanged")}},{key:"getNodesInCluster",value:function(t){var e=[];if(!0===this.isCluster(t)){var i=this.body.nodes[t].containedNodes;for(var o in i)Object.prototype.hasOwnProperty.call(i,o)&&e.push(this.body.nodes[o].id)}return e}},{key:"findNode",value:function(t){for(var e,i=[],o=0;void 0!==this.clusteredNodes[t]&&o<100;){if(void 0===(e=this.body.nodes[t]))return[];i.push(e.id),t=this.clusteredNodes[t].clusterId,o++}return void 0===(e=this.body.nodes[t])?[]:(i.push(e.id),Nn(i).call(i),i)}},{key:"updateClusteredNode",value:function(t,e){if(void 0===t)throw new Error("No clusteredNodeId supplied to updateClusteredNode.");if(void 0===e)throw new Error("No newOptions supplied to updateClusteredNode.");if(void 0===this.body.nodes[t])throw new Error("The clusteredNodeId supplied to updateClusteredNode does not exist.");this.body.nodes[t].setOptions(e),this.body.emitter.emit("_dataChanged")}},{key:"updateEdge",value:function(t,e){if(void 0===t)throw new Error("No startEdgeId supplied to updateEdge.");if(void 0===e)throw new Error("No newOptions supplied to updateEdge.");if(void 0===this.body.edges[t])throw new Error("The startEdgeId supplied to updateEdge does not exist.");for(var i=this.getClusteredEdges(t),o=0;o<i.length;o++){this.body.edges[i[o]].setOptions(e)}this.body.emitter.emit("_dataChanged")}},{key:"getClusteredEdges",value:function(t){for(var e=[],i=0;void 0!==t&&void 0!==this.body.edges[t]&&i<100;)e.push(this.body.edges[t].id),t=this.body.edges[t].edgeReplacedById,i++;return Nn(e).call(e),e}},{key:"getBaseEdge",value:function(t){return this.getBaseEdges(t)[0]}},{key:"getBaseEdges",value:function(t){for(var e=[t],i=[],o=[],n=0;e.length>0&&n<100;){var r=e.pop();if(void 0!==r){var s=this.body.edges[r];if(void 0!==s){n++;var a=s.clusteringEdgeReplacingIds;if(void 0===a)o.push(r);else for(var h=0;h<a.length;++h){var d=a[h];-1===Mr(e).call(e,a)&&-1===Mr(i).call(i,a)&&e.push(d)}i.push(r)}}}return o}},{key:"_getConnectedId",value:function(t,e){return t.toId!=e?t.toId:(t.fromId,t.fromId)}},{key:"_getHubSize",value:function(){for(var t=0,e=0,i=0,o=0,n=0;n<this.body.nodeIndices.length;n++){var r=this.body.nodes[this.body.nodeIndices[n]];r.edges.length>o&&(o=r.edges.length),t+=r.edges.length,e+=Math.pow(r.edges.length,2),i+=1}t/=i;var s=(e/=i)-Math.pow(t,2),a=Math.sqrt(s),h=Math.floor(t+2*a);return h>o&&(h=o),h}},{key:"_createClusteredEdge",value:function(t,e,i,o,n){var r=wu.cloneOptions(i,"edge");th(r,o),r.from=t,r.to=e,r.id="clusterEdge:"+bu(),void 0!==n&&th(r,n);var s=this.body.functions.createEdge(r);return s.clusteringEdgeReplacingIds=[i.id],s.connect(),this.body.edges[s.id]=s,s}},{key:"_clusterEdges",value:function(t,e,i,o){if(e instanceof Jc){var n=e,r={};r[n.id]=n,e=r}if(t instanceof lc){var s=t,a={};a[s.id]=s,t=a}if(null==i)throw new Error("_clusterEdges: parameter clusterNode required");for(var h in void 0===o&&(o=i.clusterEdgeProperties),this._createClusterEdges(t,e,i,o),e)if(Object.prototype.hasOwnProperty.call(e,h)&&void 0!==this.body.edges[h]){var d=this.body.edges[h];this._backupEdgeOptions(d),d.setOptions({physics:!1})}for(var l in t)Object.prototype.hasOwnProperty.call(t,l)&&(this.clusteredNodes[l]={clusterId:i.id,node:this.body.nodes[l]},this.body.nodes[l].setOptions({physics:!1}))}},{key:"_getClusterNodeForNode",value:function(t){if(void 0!==t){var e=this.clusteredNodes[t];if(void 0!==e){var i=e.clusterId;if(void 0!==i)return this.body.nodes[i]}}}},{key:"_filter",value:function(t,e){var i=[];return nh(t,(function(t){e(t)&&i.push(t)})),i}},{key:"_updateState",value:function(){var t,e=this,i=[],o={},n=function(t){nh(e.body.nodes,(function(e){!0===e.isCluster&&t(e)}))};for(t in this.clusteredNodes){if(Object.prototype.hasOwnProperty.call(this.clusteredNodes,t))void 0===this.body.nodes[t]&&i.push(t)}n((function(t){for(var e=0;e<i.length;e++)delete t.containedNodes[i[e]]}));for(var r=0;r<i.length;r++)delete this.clusteredNodes[i[r]];nh(this.clusteredEdges,(function(t){var i=e.body.edges[t];void 0!==i&&i.endPointsValid()||(o[t]=t)})),n((function(t){nh(t.containedEdges,(function(t,e){t.endPointsValid()||o[e]||(o[e]=e)}))})),nh(this.body.edges,(function(t,i){var n=!0,r=t.clusteringEdgeReplacingIds;if(void 0!==r){var s=0;nh(r,(function(t){var i=e.body.edges[t];void 0!==i&&i.endPointsValid()&&(s+=1)})),n=s>0}t.endPointsValid()&&n||(o[i]=i)})),n((function(t){nh(o,(function(i){delete t.containedEdges[i],nh(t.edges,(function(n,r){n.id!==i?n.clusteringEdgeReplacingIds=e._filter(n.clusteringEdgeReplacingIds,(function(t){return!o[t]})):t.edges[r]=null})),t.edges=e._filter(t.edges,(function(t){return null!==t}))}))})),nh(o,(function(t){delete e.clusteredEdges[t]})),nh(o,(function(t){delete e.body.edges[t]})),nh(xn(this.body.edges),(function(t){var i=e.body.edges[t],o=e._isClusteredNode(i.fromId)||e._isClusteredNode(i.toId);if(o!==e._isClusteredEdge(i.id))if(o){var n=e._getClusterNodeForNode(i.fromId);void 0!==n&&e._clusterEdges(e.body.nodes[i.fromId],i,n);var r=e._getClusterNodeForNode(i.toId);void 0!==r&&e._clusterEdges(e.body.nodes[i.toId],i,r)}else delete e._clusterEdges[t],e._restoreEdge(i)}));for(var s=!1,a=!0,h=function(){var t=[];n((function(e){var i=xn(e.containedNodes).length,o=!0===e.options.allowSingleNodeCluster;(o&&i<1||!o&&i<2)&&t.push(e.id)}));for(var i=0;i<t.length;++i)e.openCluster(t[i],{},!1);a=t.length>0,s=s||a};a;)h();s&&this._updateState()}},{key:"_isClusteredNode",value:function(t){return void 0!==this.clusteredNodes[t]}},{key:"_isClusteredEdge",value:function(t){return void 0!==this.clusteredEdges[t]}}]),t}();function Eu(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return Ou(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return Ou(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function Ou(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}var Cu=function(){function t(e,i){var o;Po(this,t),void 0!==window&&(o=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame),window.requestAnimationFrame=void 0===o?function(t){t()}:o,this.body=e,this.canvas=i,this.redrawRequested=!1,this.renderTimer=void 0,this.requiresTimeout=!0,this.renderingActive=!1,this.renderRequests=0,this.allowRedraw=!0,this.dragging=!1,this.zooming=!1,this.options={},this.defaultOptions={hideEdgesOnDrag:!1,hideEdgesOnZoom:!1,hideNodesOnDrag:!1},ct(this.options,this.defaultOptions),this._determineBrowserMethod(),this.bindEventListeners()}return Io(t,[{key:"bindEventListeners",value:function(){var t,e=this;this.body.emitter.on("dragStart",(function(){e.dragging=!0})),this.body.emitter.on("dragEnd",(function(){e.dragging=!1})),this.body.emitter.on("zoom",(function(){e.zooming=!0,window.clearTimeout(e.zoomTimeoutId),e.zoomTimeoutId=qr((function(){var t;e.zooming=!1,bt(t=e._requestRedraw).call(t,e)()}),250)})),this.body.emitter.on("_resizeNodes",(function(){e._resizeNodes()})),this.body.emitter.on("_redraw",(function(){!1===e.renderingActive&&e._redraw()})),this.body.emitter.on("_blockRedraw",(function(){e.allowRedraw=!1})),this.body.emitter.on("_allowRedraw",(function(){e.allowRedraw=!0,e.redrawRequested=!1})),this.body.emitter.on("_requestRedraw",bt(t=this._requestRedraw).call(t,this)),this.body.emitter.on("_startRendering",(function(){e.renderRequests+=1,e.renderingActive=!0,e._startRendering()})),this.body.emitter.on("_stopRendering",(function(){e.renderRequests-=1,e.renderingActive=e.renderRequests>0,e.renderTimer=void 0})),this.body.emitter.on("destroy",(function(){e.renderRequests=0,e.allowRedraw=!1,e.renderingActive=!1,!0===e.requiresTimeout?clearTimeout(e.renderTimer):window.cancelAnimationFrame(e.renderTimer),e.body.emitter.off()}))}},{key:"setOptions",value:function(t){if(void 0!==t){Za(["hideEdgesOnDrag","hideEdgesOnZoom","hideNodesOnDrag"],this.options,t)}}},{key:"_requestNextFrame",value:function(t,e){if("undefined"!=typeof window){var i,o=window;return!0===this.requiresTimeout?i=qr(t,e):o.requestAnimationFrame&&(i=o.requestAnimationFrame(t)),i}}},{key:"_startRendering",value:function(){var t;!0===this.renderingActive&&(void 0===this.renderTimer&&(this.renderTimer=this._requestNextFrame(bt(t=this._renderStep).call(t,this),this.simulationInterval)))}},{key:"_renderStep",value:function(){!0===this.renderingActive&&(this.renderTimer=void 0,!0===this.requiresTimeout&&this._startRendering(),this._redraw(),!1===this.requiresTimeout&&this._startRendering())}},{key:"redraw",value:function(){this.body.emitter.emit("setSize"),this._redraw()}},{key:"_requestRedraw",value:function(){var t=this;!0!==this.redrawRequested&&!1===this.renderingActive&&!0===this.allowRedraw&&(this.redrawRequested=!0,this._requestNextFrame((function(){t._redraw(!1)}),0))}},{key:"_redraw",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!0===this.allowRedraw){this.body.emitter.emit("initRedraw"),this.redrawRequested=!1;var e={drawExternalLabels:null};0!==this.canvas.frame.canvas.width&&0!==this.canvas.frame.canvas.height||this.canvas.setSize(),this.canvas.setTransform();var i=this.canvas.getContext(),o=this.canvas.frame.canvas.clientWidth,n=this.canvas.frame.canvas.clientHeight;if(i.clearRect(0,0,o,n),0===this.canvas.frame.clientWidth)return;if(i.save(),i.translate(this.body.view.translation.x,this.body.view.translation.y),i.scale(this.body.view.scale,this.body.view.scale),i.beginPath(),this.body.emitter.emit("beforeDrawing",i),i.closePath(),!1===t&&(!1===this.dragging||!0===this.dragging&&!1===this.options.hideEdgesOnDrag)&&(!1===this.zooming||!0===this.zooming&&!1===this.options.hideEdgesOnZoom)&&this._drawEdges(i),!1===this.dragging||!0===this.dragging&&!1===this.options.hideNodesOnDrag){var r=this._drawNodes(i,t),s=r.drawExternalLabels;e.drawExternalLabels=s}!1===t&&(!1===this.dragging||!0===this.dragging&&!1===this.options.hideEdgesOnDrag)&&(!1===this.zooming||!0===this.zooming&&!1===this.options.hideEdgesOnZoom)&&this._drawArrows(i),null!=e.drawExternalLabels&&e.drawExternalLabels(),!1===t&&this._drawSelectionBox(i),i.beginPath(),this.body.emitter.emit("afterDrawing",i),i.closePath(),i.restore(),!0===t&&i.clearRect(0,0,o,n)}}},{key:"_resizeNodes",value:function(){this.canvas.setTransform();var t=this.canvas.getContext();t.save(),t.translate(this.body.view.translation.x,this.body.view.translation.y),t.scale(this.body.view.scale,this.body.view.scale);var e,i=this.body.nodes;for(var o in i)Object.prototype.hasOwnProperty.call(i,o)&&((e=i[o]).resize(t),e.updateBoundingBox(t,e.selected));t.restore()}},{key:"_drawNodes",value:function(t){for(var e,i,o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=this.body.nodes,r=this.body.nodeIndices,s=[],a=[],h=20,d=this.canvas.DOMtoCanvas({x:-h,y:-h}),l=this.canvas.DOMtoCanvas({x:this.canvas.frame.canvas.clientWidth+h,y:this.canvas.frame.canvas.clientHeight+h}),c={top:d.y,left:d.x,bottom:l.y,right:l.x},u=[],f=0;f<r.length;f++)if((e=n[r[f]]).hover)a.push(r[f]);else if(e.isSelected())s.push(r[f]);else if(!0===o){var p=e.draw(t);null!=p.drawExternalLabel&&u.push(p.drawExternalLabel)}else if(!0===e.isBoundingBoxOverlappingWith(c)){var v=e.draw(t);null!=v.drawExternalLabel&&u.push(v.drawExternalLabel)}else e.updateBoundingBox(t,e.selected);var g=s.length,y=a.length;for(i=0;i<g;i++){var m=(e=n[s[i]]).draw(t);null!=m.drawExternalLabel&&u.push(m.drawExternalLabel)}for(i=0;i<y;i++){var b=(e=n[a[i]]).draw(t);null!=b.drawExternalLabel&&u.push(b.drawExternalLabel)}return{drawExternalLabels:function(){var t,e=Eu(u);try{for(e.s();!(t=e.n()).done;){(0,t.value)()}}catch(t){e.e(t)}finally{e.f()}}}}},{key:"_drawEdges",value:function(t){for(var e=this.body.edges,i=this.body.edgeIndices,o=0;o<i.length;o++){var n=e[i[o]];!0===n.connected&&n.draw(t)}}},{key:"_drawArrows",value:function(t){for(var e=this.body.edges,i=this.body.edgeIndices,o=0;o<i.length;o++){var n=e[i[o]];!0===n.connected&&n.drawArrows(t)}}},{key:"_determineBrowserMethod",value:function(){if("undefined"!=typeof window){var t=navigator.userAgent.toLowerCase();this.requiresTimeout=!1,(-1!=Mr(t).call(t,"msie 9.0")||-1!=Mr(t).call(t,"safari")&&Mr(t).call(t,"chrome")<=-1)&&(this.requiresTimeout=!0)}else this.requiresTimeout=!0}},{key:"_drawSelectionBox",value:function(t){if(this.body.selectionBox.show){t.beginPath();var e=this.body.selectionBox.position.end.x-this.body.selectionBox.position.start.x,i=this.body.selectionBox.position.end.y-this.body.selectionBox.position.start.y;t.rect(this.body.selectionBox.position.start.x,this.body.selectionBox.position.start.y,e,i),t.fillStyle="rgba(151, 194, 252, 0.2)",t.fillRect(this.body.selectionBox.position.start.x,this.body.selectionBox.position.start.y,e,i),t.strokeStyle="rgba(151, 194, 252, 1)",t.stroke()}else t.closePath()}}]),t}(),Su=F.setInterval;function Tu(t,e){e.inputHandler=function(t){t.isFirst&&e(t)},t.on("hammer.input",e.inputHandler)}function Mu(t,e){return e.inputHandler=function(t){t.isFinal&&e(t)},t.on("hammer.input",e.inputHandler)}var Pu=function(){function t(e){Po(this,t),this.body=e,this.pixelRatio=1,this.cameraState={},this.initialized=!1,this.canvasViewCenter={},this._cleanupCallbacks=[],this.options={},this.defaultOptions={autoResize:!0,height:"100%",width:"100%"},ct(this.options,this.defaultOptions),this.bindEventListeners()}return Io(t,[{key:"bindEventListeners",value:function(){var t,e=this;this.body.emitter.once("resize",(function(t){0!==t.width&&(e.body.view.translation.x=.5*t.width),0!==t.height&&(e.body.view.translation.y=.5*t.height)})),this.body.emitter.on("setSize",bt(t=this.setSize).call(t,this)),this.body.emitter.on("destroy",(function(){e.hammerFrame.destroy(),e.hammer.destroy(),e._cleanUp()}))}},{key:"setOptions",value:function(t){var e,i,o,n,r,s=this;if(void 0!==t){Za(["width","height","autoResize"],this.options,t)}if(this._cleanUp(),!0===this.options.autoResize){var a;if(window.ResizeObserver){var h=new ResizeObserver((function(){!0===s.setSize()&&s.body.emitter.emit("_requestRedraw")})),d=this.frame;h.observe(d),this._cleanupCallbacks.push((function(){h.unobserve(d)}))}else{var l=Su((function(){!0===s.setSize()&&s.body.emitter.emit("_requestRedraw")}),1e3);this._cleanupCallbacks.push((function(){clearInterval(l)}))}var c=bt(a=this._onResize).call(a,this);e=window,i="resize",o=c,e.addEventListener?(void 0===n&&(n=!1),"mousewheel"===i&&Jn(r=navigator.userAgent).call(r,"Firefox")&&(i="DOMMouseScroll"),e.addEventListener(i,o,n)):e.attachEvent("on"+i,o),this._cleanupCallbacks.push((function(){!function(t,e,i,o){var n;t.removeEventListener?(void 0===o&&(o=!1),"mousewheel"===e&&Jn(n=navigator.userAgent).call(n,"Firefox")&&(e="DOMMouseScroll"),t.removeEventListener(e,i,o)):t.detachEvent("on"+e,i)}(window,"resize",c)}))}}},{key:"_cleanUp",value:function(){var t,e,i;Dn(t=Nn(e=qn(i=this._cleanupCallbacks).call(i,0)).call(e)).call(t,(function(t){try{t()}catch(t){console.error(t)}}))}},{key:"_onResize",value:function(){this.setSize(),this.body.emitter.emit("_redraw")}},{key:"_getCameraState",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.pixelRatio;!0===this.initialized&&(this.cameraState.previousWidth=this.frame.canvas.width/t,this.cameraState.previousHeight=this.frame.canvas.height/t,this.cameraState.scale=this.body.view.scale,this.cameraState.position=this.DOMtoCanvas({x:.5*this.frame.canvas.width/t,y:.5*this.frame.canvas.height/t}))}},{key:"_setCameraState",value:function(){if(void 0!==this.cameraState.scale&&0!==this.frame.canvas.clientWidth&&0!==this.frame.canvas.clientHeight&&0!==this.pixelRatio&&this.cameraState.previousWidth>0&&this.cameraState.previousHeight>0){var t=this.frame.canvas.width/this.pixelRatio/this.cameraState.previousWidth,e=this.frame.canvas.height/this.pixelRatio/this.cameraState.previousHeight,i=this.cameraState.scale;1!=t&&1!=e?i=.5*this.cameraState.scale*(t+e):1!=t?i=this.cameraState.scale*t:1!=e&&(i=this.cameraState.scale*e),this.body.view.scale=i;var o=this.DOMtoCanvas({x:.5*this.frame.canvas.clientWidth,y:.5*this.frame.canvas.clientHeight}),n={x:o.x-this.cameraState.position.x,y:o.y-this.cameraState.position.y};this.body.view.translation.x+=n.x*this.body.view.scale,this.body.view.translation.y+=n.y*this.body.view.scale}}},{key:"_prepareValue",value:function(t){if("number"==typeof t)return t+"px";if("string"==typeof t){if(-1!==Mr(t).call(t,"%")||-1!==Mr(t).call(t,"px"))return t;if(-1===Mr(t).call(t,"%"))return t+"px"}throw new Error("Could not use the value supplied for width or height:"+t)}},{key:"_create",value:function(){for(;this.body.container.hasChildNodes();)this.body.container.removeChild(this.body.container.firstChild);if(this.frame=document.createElement("div"),this.frame.className="vis-network",this.frame.style.position="relative",this.frame.style.overflow="hidden",this.frame.tabIndex=0,this.frame.canvas=document.createElement("canvas"),this.frame.canvas.style.position="relative",this.frame.appendChild(this.frame.canvas),this.frame.canvas.getContext)this._setPixelRatio(),this.setTransform();else{var t=document.createElement("DIV");t.style.color="red",t.style.fontWeight="bold",t.style.padding="10px",t.innerText="Error: your browser does not support HTML canvas",this.frame.canvas.appendChild(t)}this.body.container.appendChild(this.frame),this.body.view.scale=1,this.body.view.translation={x:.5*this.frame.canvas.clientWidth,y:.5*this.frame.canvas.clientHeight},this._bindHammer()}},{key:"_bindHammer",value:function(){var t=this;void 0!==this.hammer&&this.hammer.destroy(),this.drag={},this.pinch={},this.hammer=new Sh(this.frame.canvas),this.hammer.get("pinch").set({enable:!0}),this.hammer.get("pan").set({threshold:5,direction:Sh.DIRECTION_ALL}),Tu(this.hammer,(function(e){t.body.eventListeners.onTouch(e)})),this.hammer.on("tap",(function(e){t.body.eventListeners.onTap(e)})),this.hammer.on("doubletap",(function(e){t.body.eventListeners.onDoubleTap(e)})),this.hammer.on("press",(function(e){t.body.eventListeners.onHold(e)})),this.hammer.on("panstart",(function(e){t.body.eventListeners.onDragStart(e)})),this.hammer.on("panmove",(function(e){t.body.eventListeners.onDrag(e)})),this.hammer.on("panend",(function(e){t.body.eventListeners.onDragEnd(e)})),this.hammer.on("pinch",(function(e){t.body.eventListeners.onPinch(e)})),this.frame.canvas.addEventListener("wheel",(function(e){t.body.eventListeners.onMouseWheel(e)})),this.frame.canvas.addEventListener("mousemove",(function(e){t.body.eventListeners.onMouseMove(e)})),this.frame.canvas.addEventListener("contextmenu",(function(e){t.body.eventListeners.onContext(e)})),this.hammerFrame=new Sh(this.frame),Mu(this.hammerFrame,(function(e){t.body.eventListeners.onRelease(e)}))}},{key:"setSize",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.width,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.height;t=this._prepareValue(t),e=this._prepareValue(e);var i=!1,o=this.frame.canvas.width,n=this.frame.canvas.height,r=this.pixelRatio;if(this._setPixelRatio(),t!=this.options.width||e!=this.options.height||this.frame.style.width!=t||this.frame.style.height!=e)this._getCameraState(r),this.frame.style.width=t,this.frame.style.height=e,this.frame.canvas.style.width="100%",this.frame.canvas.style.height="100%",this.frame.canvas.width=Math.round(this.frame.canvas.clientWidth*this.pixelRatio),this.frame.canvas.height=Math.round(this.frame.canvas.clientHeight*this.pixelRatio),this.options.width=t,this.options.height=e,this.canvasViewCenter={x:.5*this.frame.clientWidth,y:.5*this.frame.clientHeight},i=!0;else{var s=Math.round(this.frame.canvas.clientWidth*this.pixelRatio),a=Math.round(this.frame.canvas.clientHeight*this.pixelRatio);this.frame.canvas.width===s&&this.frame.canvas.height===a||this._getCameraState(r),this.frame.canvas.width!==s&&(this.frame.canvas.width=s,i=!0),this.frame.canvas.height!==a&&(this.frame.canvas.height=a,i=!0)}return!0===i&&(this.body.emitter.emit("resize",{width:Math.round(this.frame.canvas.width/this.pixelRatio),height:Math.round(this.frame.canvas.height/this.pixelRatio),oldWidth:Math.round(o/this.pixelRatio),oldHeight:Math.round(n/this.pixelRatio)}),this._setCameraState()),this.initialized=!0,i}},{key:"getContext",value:function(){return this.frame.canvas.getContext("2d")}},{key:"_determinePixelRatio",value:function(){var t=this.getContext();if(void 0===t)throw new Error("Could not get canvax context");var e=1;return"undefined"!=typeof window&&(e=window.devicePixelRatio||1),e/(t.webkitBackingStorePixelRatio||t.mozBackingStorePixelRatio||t.msBackingStorePixelRatio||t.oBackingStorePixelRatio||t.backingStorePixelRatio||1)}},{key:"_setPixelRatio",value:function(){this.pixelRatio=this._determinePixelRatio()}},{key:"setTransform",value:function(){var t=this.getContext();if(void 0===t)throw new Error("Could not get canvax context");t.setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0)}},{key:"_XconvertDOMtoCanvas",value:function(t){return(t-this.body.view.translation.x)/this.body.view.scale}},{key:"_XconvertCanvasToDOM",value:function(t){return t*this.body.view.scale+this.body.view.translation.x}},{key:"_YconvertDOMtoCanvas",value:function(t){return(t-this.body.view.translation.y)/this.body.view.scale}},{key:"_YconvertCanvasToDOM",value:function(t){return t*this.body.view.scale+this.body.view.translation.y}},{key:"canvasToDOM",value:function(t){return{x:this._XconvertCanvasToDOM(t.x),y:this._YconvertCanvasToDOM(t.y)}}},{key:"DOMtoCanvas",value:function(t){return{x:this._XconvertDOMtoCanvas(t.x),y:this._YconvertDOMtoCanvas(t.y)}}}]),t}();function Du(t,e){var i=ct({nodes:e,minZoomLevel:Number.MIN_VALUE,maxZoomLevel:1},null!=t?t:{});if(!gn(i.nodes))throw new TypeError("Nodes has to be an array of ids.");if(0===i.nodes.length&&(i.nodes=e),!("number"==typeof i.minZoomLevel&&i.minZoomLevel>0))throw new TypeError("Min zoom level has to be a number higher than zero.");if(!("number"==typeof i.maxZoomLevel&&i.minZoomLevel<=i.maxZoomLevel))throw new TypeError("Max zoom level has to be a number higher than min zoom level.");return i}var Bu=function(){function t(e,i){var o,n,r=this;Po(this,t),this.body=e,this.canvas=i,this.animationSpeed=1/this.renderRefreshRate,this.animationEasingFunction="easeInOutQuint",this.easingTime=0,this.sourceScale=0,this.targetScale=0,this.sourceTranslation=0,this.targetTranslation=0,this.lockedOnNodeId=void 0,this.lockedOnNodeOffset=void 0,this.touchTime=0,this.viewFunction=void 0,this.body.emitter.on("fit",bt(o=this.fit).call(o,this)),this.body.emitter.on("animationFinished",(function(){r.body.emitter.emit("_stopRendering")})),this.body.emitter.on("unlockNode",bt(n=this.releaseNode).call(n,this))}return Io(t,[{key:"setOptions",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.options=t}},{key:"fit",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t=Du(t,this.body.nodeIndices);var i,o,n=this.canvas.frame.canvas.clientWidth,r=this.canvas.frame.canvas.clientHeight;if(0===n||0===r)o=1,i=wu.getRange(this.body.nodes,t.nodes);else if(!0===e){var s=0;for(var a in this.body.nodes)if(Object.prototype.hasOwnProperty.call(this.body.nodes,a)){var h=this.body.nodes[a];!0===h.predefinedPosition&&(s+=1)}if(s>.5*this.body.nodeIndices.length)return void this.fit(t,!1);i=wu.getRange(this.body.nodes,t.nodes);var d=this.body.nodeIndices.length;o=12.662/(d+7.4147)+.0964822;var l=Math.min(n/600,r/600);o*=l}else{this.body.emitter.emit("_resizeNodes"),i=wu.getRange(this.body.nodes,t.nodes);var c=1.1*Math.abs(i.maxX-i.minX),u=1.1*Math.abs(i.maxY-i.minY),f=n/c,p=r/u;o=f<=p?f:p}o>t.maxZoomLevel?o=t.maxZoomLevel:o<t.minZoomLevel&&(o=t.minZoomLevel);var v=wu.findCenter(i),g={position:v,scale:o,animation:t.animation};this.moveTo(g)}},{key:"focus",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(void 0!==this.body.nodes[t]){var i={x:this.body.nodes[t].x,y:this.body.nodes[t].y};e.position=i,e.lockedOnNode=t,this.moveTo(e)}else console.error("Node: "+t+" cannot be found.")}},{key:"moveTo",value:function(t){if(void 0!==t){if(null!=t.offset){if(null!=t.offset.x){if(t.offset.x=+t.offset.x,!Ad(t.offset.x))throw new TypeError('The option "offset.x" has to be a finite number.')}else t.offset.x=0;if(null!=t.offset.y){if(t.offset.y=+t.offset.y,!Ad(t.offset.y))throw new TypeError('The option "offset.y" has to be a finite number.')}else t.offset.x=0}else t.offset={x:0,y:0};if(null!=t.position){if(null!=t.position.x){if(t.position.x=+t.position.x,!Ad(t.position.x))throw new TypeError('The option "position.x" has to be a finite number.')}else t.position.x=0;if(null!=t.position.y){if(t.position.y=+t.position.y,!Ad(t.position.y))throw new TypeError('The option "position.y" has to be a finite number.')}else t.position.x=0}else t.position=this.getViewPosition();if(null!=t.scale){if(t.scale=+t.scale,!(t.scale>0))throw new TypeError('The option "scale" has to be a number greater than zero.')}else t.scale=this.body.view.scale;void 0===t.animation&&(t.animation={duration:0}),!1===t.animation&&(t.animation={duration:0}),!0===t.animation&&(t.animation={}),void 0===t.animation.duration&&(t.animation.duration=1e3),void 0===t.animation.easingFunction&&(t.animation.easingFunction="easeInOutQuad"),this.animateView(t)}else t={}}},{key:"animateView",value:function(t){if(void 0!==t){this.animationEasingFunction=t.animation.easingFunction,this.releaseNode(),!0===t.locked&&(this.lockedOnNodeId=t.lockedOnNode,this.lockedOnNodeOffset=t.offset),0!=this.easingTime&&this._transitionRedraw(!0),this.sourceScale=this.body.view.scale,this.sourceTranslation=this.body.view.translation,this.targetScale=t.scale,this.body.view.scale=this.targetScale;var e,i,o=this.canvas.DOMtoCanvas({x:.5*this.canvas.frame.canvas.clientWidth,y:.5*this.canvas.frame.canvas.clientHeight}),n=o.x-t.position.x,r=o.y-t.position.y;if(this.targetTranslation={x:this.sourceTranslation.x+n*this.targetScale+t.offset.x,y:this.sourceTranslation.y+r*this.targetScale+t.offset.y},0===t.animation.duration)if(null!=this.lockedOnNodeId)this.viewFunction=bt(e=this._lockedRedraw).call(e,this),this.body.emitter.on("initRedraw",this.viewFunction);else this.body.view.scale=this.targetScale,this.body.view.translation=this.targetTranslation,this.body.emitter.emit("_requestRedraw");else this.animationSpeed=1/(60*t.animation.duration*.001)||1/60,this.animationEasingFunction=t.animation.easingFunction,this.viewFunction=bt(i=this._transitionRedraw).call(i,this),this.body.emitter.on("initRedraw",this.viewFunction),this.body.emitter.emit("_startRendering")}}},{key:"_lockedRedraw",value:function(){var t=this.body.nodes[this.lockedOnNodeId].x,e=this.body.nodes[this.lockedOnNodeId].y,i=this.canvas.DOMtoCanvas({x:.5*this.canvas.frame.canvas.clientWidth,y:.5*this.canvas.frame.canvas.clientHeight}),o=i.x-t,n=i.y-e,r=this.body.view.translation,s={x:r.x+o*this.body.view.scale+this.lockedOnNodeOffset.x,y:r.y+n*this.body.view.scale+this.lockedOnNodeOffset.y};this.body.view.translation=s}},{key:"releaseNode",value:function(){void 0!==this.lockedOnNodeId&&void 0!==this.viewFunction&&(this.body.emitter.off("initRedraw",this.viewFunction),this.lockedOnNodeId=void 0,this.lockedOnNodeOffset=void 0)}},{key:"_transitionRedraw",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.easingTime+=this.animationSpeed,this.easingTime=!0===t?1:this.easingTime;var e=yh[this.animationEasingFunction](this.easingTime);if(this.body.view.scale=this.sourceScale+(this.targetScale-this.sourceScale)*e,this.body.view.translation={x:this.sourceTranslation.x+(this.targetTranslation.x-this.sourceTranslation.x)*e,y:this.sourceTranslation.y+(this.targetTranslation.y-this.sourceTranslation.y)*e},this.easingTime>=1){var i;if(this.body.emitter.off("initRedraw",this.viewFunction),this.easingTime=0,null!=this.lockedOnNodeId)this.viewFunction=bt(i=this._lockedRedraw).call(i,this),this.body.emitter.on("initRedraw",this.viewFunction);this.body.emitter.emit("animationFinished")}}},{key:"getScale",value:function(){return this.body.view.scale}},{key:"getViewPosition",value:function(){return this.canvas.DOMtoCanvas({x:.5*this.canvas.frame.canvas.clientWidth,y:.5*this.canvas.frame.canvas.clientHeight})}}]),t}();function Iu(t){var e,i=t&&t.preventDefault||!1,o=t&&t.container||window,n={},r={keydown:{},keyup:{}},s={};for(e=97;e<=122;e++)s[String.fromCharCode(e)]={code:e-97+65,shift:!1};for(e=65;e<=90;e++)s[String.fromCharCode(e)]={code:e,shift:!0};for(e=0;e<=9;e++)s[""+e]={code:48+e,shift:!1};for(e=1;e<=12;e++)s["F"+e]={code:111+e,shift:!1};for(e=0;e<=9;e++)s["num"+e]={code:96+e,shift:!1};s["num*"]={code:106,shift:!1},s["num+"]={code:107,shift:!1},s["num-"]={code:109,shift:!1},s["num/"]={code:111,shift:!1},s["num."]={code:110,shift:!1},s.left={code:37,shift:!1},s.up={code:38,shift:!1},s.right={code:39,shift:!1},s.down={code:40,shift:!1},s.space={code:32,shift:!1},s.enter={code:13,shift:!1},s.shift={code:16,shift:void 0},s.esc={code:27,shift:!1},s.backspace={code:8,shift:!1},s.tab={code:9,shift:!1},s.ctrl={code:17,shift:!1},s.alt={code:18,shift:!1},s.delete={code:46,shift:!1},s.pageup={code:33,shift:!1},s.pagedown={code:34,shift:!1},s["="]={code:187,shift:!1},s["-"]={code:189,shift:!1},s["]"]={code:221,shift:!1},s["["]={code:219,shift:!1};var a=function(t){d(t,"keydown")},h=function(t){d(t,"keyup")},d=function(t,e){if(void 0!==r[e][t.keyCode]){for(var o=r[e][t.keyCode],n=0;n<o.length;n++)(void 0===o[n].shift||1==o[n].shift&&1==t.shiftKey||0==o[n].shift&&0==t.shiftKey)&&o[n].fn(t);1==i&&t.preventDefault()}};return n.bind=function(t,e,i){if(void 0===i&&(i="keydown"),void 0===s[t])throw new Error("unsupported key: "+t);void 0===r[i][s[t].code]&&(r[i][s[t].code]=[]),r[i][s[t].code].push({fn:e,shift:s[t].shift})},n.bindAll=function(t,e){for(var i in void 0===e&&(e="keydown"),s)s.hasOwnProperty(i)&&n.bind(i,t,e)},n.getKey=function(t){for(var e in s)if(s.hasOwnProperty(e)){if(1==t.shiftKey&&1==s[e].shift&&t.keyCode==s[e].code)return e;if(0==t.shiftKey&&0==s[e].shift&&t.keyCode==s[e].code)return e;if(t.keyCode==s[e].code&&"shift"==e)return e}return"unknown key, currently not supported"},n.unbind=function(t,e,i){if(void 0===i&&(i="keydown"),void 0===s[t])throw new Error("unsupported key: "+t);if(void 0!==e){var o=[],n=r[i][s[t].code];if(void 0!==n)for(var a=0;a<n.length;a++)n[a].fn==e&&n[a].shift==s[t].shift||o.push(r[i][s[t].code][a]);r[i][s[t].code]=o}else r[i][s[t].code]=[]},n.reset=function(){r={keydown:{},keyup:{}}},n.destroy=function(){r={keydown:{},keyup:{}},o.removeEventListener("keydown",a,!0),o.removeEventListener("keyup",h,!0)},o.addEventListener("keydown",a,!0),o.addEventListener("keyup",h,!0),n}var zu=function(){function t(e,i){var o=this;Po(this,t),this.body=e,this.canvas=i,this.iconsCreated=!1,this.navigationHammers=[],this.boundFunctions={},this.touchTime=0,this.activated=!1,this.body.emitter.on("activate",(function(){o.activated=!0,o.configureKeyboardBindings()})),this.body.emitter.on("deactivate",(function(){o.activated=!1,o.configureKeyboardBindings()})),this.body.emitter.on("destroy",(function(){void 0!==o.keycharm&&o.keycharm.destroy()})),this.options={}}return Io(t,[{key:"setOptions",value:function(t){void 0!==t&&(this.options=t,this.create())}},{key:"create",value:function(){!0===this.options.navigationButtons?!1===this.iconsCreated&&this.loadNavigationElements():!0===this.iconsCreated&&this.cleanNavigation(),this.configureKeyboardBindings()}},{key:"cleanNavigation",value:function(){if(0!=this.navigationHammers.length){for(var t=0;t<this.navigationHammers.length;t++)this.navigationHammers[t].destroy();this.navigationHammers=[]}this.navigationDOM&&this.navigationDOM.wrapper&&this.navigationDOM.wrapper.parentNode&&this.navigationDOM.wrapper.parentNode.removeChild(this.navigationDOM.wrapper),this.iconsCreated=!1}},{key:"loadNavigationElements",value:function(){var t=this;this.cleanNavigation(),this.navigationDOM={};var e=["up","down","left","right","zoomIn","zoomOut","zoomExtends"],i=["_moveUp","_moveDown","_moveLeft","_moveRight","_zoomIn","_zoomOut","_fit"];this.navigationDOM.wrapper=document.createElement("div"),this.navigationDOM.wrapper.className="vis-navigation",this.canvas.frame.appendChild(this.navigationDOM.wrapper);for(var o=0;o<e.length;o++){this.navigationDOM[e[o]]=document.createElement("div"),this.navigationDOM[e[o]].className="vis-button vis-"+e[o],this.navigationDOM.wrapper.appendChild(this.navigationDOM[e[o]]);var n,r,s=new Sh(this.navigationDOM[e[o]]);if("_fit"===i[o])Tu(s,bt(n=this._fit).call(n,this));else Tu(s,bt(r=this.bindToRedraw).call(r,this,i[o]));this.navigationHammers.push(s)}var a=new Sh(this.canvas.frame);Mu(a,(function(){t._stopMovement()})),this.navigationHammers.push(a),this.iconsCreated=!0}},{key:"bindToRedraw",value:function(t){var e;void 0===this.boundFunctions[t]&&(this.boundFunctions[t]=bt(e=this[t]).call(e,this),this.body.emitter.on("initRedraw",this.boundFunctions[t]),this.body.emitter.emit("_startRendering"))}},{key:"unbindFromRedraw",value:function(t){void 0!==this.boundFunctions[t]&&(this.body.emitter.off("initRedraw",this.boundFunctions[t]),this.body.emitter.emit("_stopRendering"),delete this.boundFunctions[t])}},{key:"_fit",value:function(){(new Date).valueOf()-this.touchTime>700&&(this.body.emitter.emit("fit",{duration:700}),this.touchTime=(new Date).valueOf())}},{key:"_stopMovement",value:function(){for(var t in this.boundFunctions)Object.prototype.hasOwnProperty.call(this.boundFunctions,t)&&(this.body.emitter.off("initRedraw",this.boundFunctions[t]),this.body.emitter.emit("_stopRendering"));this.boundFunctions={}}},{key:"_moveUp",value:function(){this.body.view.translation.y+=this.options.keyboard.speed.y}},{key:"_moveDown",value:function(){this.body.view.translation.y-=this.options.keyboard.speed.y}},{key:"_moveLeft",value:function(){this.body.view.translation.x+=this.options.keyboard.speed.x}},{key:"_moveRight",value:function(){this.body.view.translation.x-=this.options.keyboard.speed.x}},{key:"_zoomIn",value:function(){var t=this.body.view.scale,e=this.body.view.scale*(1+this.options.keyboard.speed.zoom),i=this.body.view.translation,o=e/t,n=(1-o)*this.canvas.canvasViewCenter.x+i.x*o,r=(1-o)*this.canvas.canvasViewCenter.y+i.y*o;this.body.view.scale=e,this.body.view.translation={x:n,y:r},this.body.emitter.emit("zoom",{direction:"+",scale:this.body.view.scale,pointer:null})}},{key:"_zoomOut",value:function(){var t=this.body.view.scale,e=this.body.view.scale/(1+this.options.keyboard.speed.zoom),i=this.body.view.translation,o=e/t,n=(1-o)*this.canvas.canvasViewCenter.x+i.x*o,r=(1-o)*this.canvas.canvasViewCenter.y+i.y*o;this.body.view.scale=e,this.body.view.translation={x:n,y:r},this.body.emitter.emit("zoom",{direction:"-",scale:this.body.view.scale,pointer:null})}},{key:"configureKeyboardBindings",value:function(){var t,e,i,o,n,r,s,a,h,d,l,c,u,f,p,v,g,y,m,b,w,k,_,x,E=this;(void 0!==this.keycharm&&this.keycharm.destroy(),!0===this.options.keyboard.enabled)&&(!0===this.options.keyboard.bindToWindow?this.keycharm=Iu({container:window,preventDefault:!0}):this.keycharm=Iu({container:this.canvas.frame,preventDefault:!0}),this.keycharm.reset(),!0===this.activated&&(bt(t=this.keycharm).call(t,"up",(function(){E.bindToRedraw("_moveUp")}),"keydown"),bt(e=this.keycharm).call(e,"down",(function(){E.bindToRedraw("_moveDown")}),"keydown"),bt(i=this.keycharm).call(i,"left",(function(){E.bindToRedraw("_moveLeft")}),"keydown"),bt(o=this.keycharm).call(o,"right",(function(){E.bindToRedraw("_moveRight")}),"keydown"),bt(n=this.keycharm).call(n,"=",(function(){E.bindToRedraw("_zoomIn")}),"keydown"),bt(r=this.keycharm).call(r,"num+",(function(){E.bindToRedraw("_zoomIn")}),"keydown"),bt(s=this.keycharm).call(s,"num-",(function(){E.bindToRedraw("_zoomOut")}),"keydown"),bt(a=this.keycharm).call(a,"-",(function(){E.bindToRedraw("_zoomOut")}),"keydown"),bt(h=this.keycharm).call(h,"[",(function(){E.bindToRedraw("_zoomOut")}),"keydown"),bt(d=this.keycharm).call(d,"]",(function(){E.bindToRedraw("_zoomIn")}),"keydown"),bt(l=this.keycharm).call(l,"pageup",(function(){E.bindToRedraw("_zoomIn")}),"keydown"),bt(c=this.keycharm).call(c,"pagedown",(function(){E.bindToRedraw("_zoomOut")}),"keydown"),bt(u=this.keycharm).call(u,"up",(function(){E.unbindFromRedraw("_moveUp")}),"keyup"),bt(f=this.keycharm).call(f,"down",(function(){E.unbindFromRedraw("_moveDown")}),"keyup"),bt(p=this.keycharm).call(p,"left",(function(){E.unbindFromRedraw("_moveLeft")}),"keyup"),bt(v=this.keycharm).call(v,"right",(function(){E.unbindFromRedraw("_moveRight")}),"keyup"),bt(g=this.keycharm).call(g,"=",(function(){E.unbindFromRedraw("_zoomIn")}),"keyup"),bt(y=this.keycharm).call(y,"num+",(function(){E.unbindFromRedraw("_zoomIn")}),"keyup"),bt(m=this.keycharm).call(m,"num-",(function(){E.unbindFromRedraw("_zoomOut")}),"keyup"),bt(b=this.keycharm).call(b,"-",(function(){E.unbindFromRedraw("_zoomOut")}),"keyup"),bt(w=this.keycharm).call(w,"[",(function(){E.unbindFromRedraw("_zoomOut")}),"keyup"),bt(k=this.keycharm).call(k,"]",(function(){E.unbindFromRedraw("_zoomIn")}),"keyup"),bt(_=this.keycharm).call(_,"pageup",(function(){E.unbindFromRedraw("_zoomIn")}),"keyup"),bt(x=this.keycharm).call(x,"pagedown",(function(){E.unbindFromRedraw("_zoomOut")}),"keyup")))}}]),t}();function Fu(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return Nu(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return Nu(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function Nu(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}var Au=function(){function t(e,i,o){var n,r,s,a,h,d,l,c,u,f,p,v,g;Po(this,t),this.body=e,this.canvas=i,this.selectionHandler=o,this.navigationHandler=new zu(e,i),this.body.eventListeners.onTap=bt(n=this.onTap).call(n,this),this.body.eventListeners.onTouch=bt(r=this.onTouch).call(r,this),this.body.eventListeners.onDoubleTap=bt(s=this.onDoubleTap).call(s,this),this.body.eventListeners.onHold=bt(a=this.onHold).call(a,this),this.body.eventListeners.onDragStart=bt(h=this.onDragStart).call(h,this),this.body.eventListeners.onDrag=bt(d=this.onDrag).call(d,this),this.body.eventListeners.onDragEnd=bt(l=this.onDragEnd).call(l,this),this.body.eventListeners.onMouseWheel=bt(c=this.onMouseWheel).call(c,this),this.body.eventListeners.onPinch=bt(u=this.onPinch).call(u,this),this.body.eventListeners.onMouseMove=bt(f=this.onMouseMove).call(f,this),this.body.eventListeners.onRelease=bt(p=this.onRelease).call(p,this),this.body.eventListeners.onContext=bt(v=this.onContext).call(v,this),this.touchTime=0,this.drag={},this.pinch={},this.popup=void 0,this.popupObj=void 0,this.popupTimer=void 0,this.body.functions.getPointer=bt(g=this.getPointer).call(g,this),this.options={},this.defaultOptions={dragNodes:!0,dragView:!0,hover:!1,keyboard:{enabled:!1,speed:{x:10,y:10,zoom:.02},bindToWindow:!0},navigationButtons:!1,tooltipDelay:300,zoomView:!0,zoomSpeed:1},ct(this.options,this.defaultOptions),this.bindEventListeners()}return Io(t,[{key:"bindEventListeners",value:function(){var t=this;this.body.emitter.on("destroy",(function(){clearTimeout(t.popupTimer),delete t.body.functions.getPointer}))}},{key:"setOptions",value:function(t){if(void 0!==t){Ja(["hideEdgesOnDrag","hideEdgesOnZoom","hideNodesOnDrag","keyboard","multiselect","selectable","selectConnectedEdges"],this.options,t),gh(this.options,t,"keyboard"),t.tooltip&&(ct(this.options.tooltip,t.tooltip),t.tooltip.color&&(this.options.tooltip.color=hh(t.tooltip.color)))}this.navigationHandler.setOptions(this.options)}},{key:"getPointer",value:function(t){return{x:t.x-(e=this.canvas.frame.canvas,e.getBoundingClientRect().left),y:t.y-oh(this.canvas.frame.canvas)};var e}},{key:"onTouch",value:function(t){(new Date).valueOf()-this.touchTime>50&&(this.drag.pointer=this.getPointer(t.center),this.drag.pinched=!1,this.pinch.scale=this.body.view.scale,this.touchTime=(new Date).valueOf())}},{key:"onTap",value:function(t){var e=this.getPointer(t.center),i=this.selectionHandler.options.multiselect&&(t.changedPointers[0].ctrlKey||t.changedPointers[0].metaKey);this.checkSelectionChanges(e,i),this.selectionHandler.commitAndEmit(e,t),this.selectionHandler.generateClickEvent("click",t,e)}},{key:"onDoubleTap",value:function(t){var e=this.getPointer(t.center);this.selectionHandler.generateClickEvent("doubleClick",t,e)}},{key:"onHold",value:function(t){var e=this.getPointer(t.center),i=this.selectionHandler.options.multiselect;this.checkSelectionChanges(e,i),this.selectionHandler.commitAndEmit(e,t),this.selectionHandler.generateClickEvent("click",t,e),this.selectionHandler.generateClickEvent("hold",t,e)}},{key:"onRelease",value:function(t){if((new Date).valueOf()-this.touchTime>10){var e=this.getPointer(t.center);this.selectionHandler.generateClickEvent("release",t,e),this.touchTime=(new Date).valueOf()}}},{key:"onContext",value:function(t){var e=this.getPointer({x:t.clientX,y:t.clientY});this.selectionHandler.generateClickEvent("oncontext",t,e)}},{key:"checkSelectionChanges",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];!0===e?this.selectionHandler.selectAdditionalOnPoint(t):this.selectionHandler.selectOnPoint(t)}},{key:"_determineDifference",value:function(t,e){var i=function(t,e){for(var i=[],o=0;o<t.length;o++){var n=t[o];-1===Mr(e).call(e,n)&&i.push(n)}return i};return{nodes:i(t.nodes,e.nodes),edges:i(t.edges,e.edges)}}},{key:"onDragStart",value:function(t){if(!this.drag.dragging){void 0===this.drag.pointer&&this.onTouch(t);var e=this.selectionHandler.getNodeAt(this.drag.pointer);if(this.drag.dragging=!0,this.drag.selection=[],this.drag.translation=ct({},this.body.view.translation),this.drag.nodeId=void 0,t.srcEvent.shiftKey){this.body.selectionBox.show=!0;var i=this.getPointer(t.center);this.body.selectionBox.position.start={x:this.canvas._XconvertDOMtoCanvas(i.x),y:this.canvas._YconvertDOMtoCanvas(i.y)},this.body.selectionBox.position.end={x:this.canvas._XconvertDOMtoCanvas(i.x),y:this.canvas._YconvertDOMtoCanvas(i.y)}}if(void 0!==e&&!0===this.options.dragNodes){this.drag.nodeId=e.id,!1===e.isSelected()&&(this.selectionHandler.unselectAll(),this.selectionHandler.selectObject(e)),this.selectionHandler.generateClickEvent("dragStart",t,this.drag.pointer);var o,n=Fu(this.selectionHandler.getSelectedNodes());try{for(n.s();!(o=n.n()).done;){var r=o.value,s={id:r.id,node:r,x:r.x,y:r.y,xFixed:r.options.fixed.x,yFixed:r.options.fixed.y};r.options.fixed.x=!0,r.options.fixed.y=!0,this.drag.selection.push(s)}}catch(t){n.e(t)}finally{n.f()}}else this.selectionHandler.generateClickEvent("dragStart",t,this.drag.pointer,void 0,!0)}}},{key:"onDrag",value:function(t){var e=this;if(!0!==this.drag.pinched){this.body.emitter.emit("unlockNode");var i=this.getPointer(t.center),o=this.drag.selection;if(o&&o.length&&!0===this.options.dragNodes){this.selectionHandler.generateClickEvent("dragging",t,i);var n=i.x-this.drag.pointer.x,r=i.y-this.drag.pointer.y;Dn(o).call(o,(function(t){var i=t.node;!1===t.xFixed&&(i.x=e.canvas._XconvertDOMtoCanvas(e.canvas._XconvertCanvasToDOM(t.x)+n)),!1===t.yFixed&&(i.y=e.canvas._YconvertDOMtoCanvas(e.canvas._YconvertCanvasToDOM(t.y)+r))})),this.body.emitter.emit("startSimulation")}else{if(t.srcEvent.shiftKey){if(this.selectionHandler.generateClickEvent("dragging",t,i,void 0,!0),void 0===this.drag.pointer)return void this.onDragStart(t);this.body.selectionBox.position.end={x:this.canvas._XconvertDOMtoCanvas(i.x),y:this.canvas._YconvertDOMtoCanvas(i.y)},this.body.emitter.emit("_requestRedraw")}if(!0===this.options.dragView&&!t.srcEvent.shiftKey){if(this.selectionHandler.generateClickEvent("dragging",t,i,void 0,!0),void 0===this.drag.pointer)return void this.onDragStart(t);var s=i.x-this.drag.pointer.x,a=i.y-this.drag.pointer.y;this.body.view.translation={x:this.drag.translation.x+s,y:this.drag.translation.y+a},this.body.emitter.emit("_requestRedraw")}}}}},{key:"onDragEnd",value:function(t){var e=this;if(this.drag.dragging=!1,this.body.selectionBox.show){var i;this.body.selectionBox.show=!1;var o=this.body.selectionBox.position,n={minX:Math.min(o.start.x,o.end.x),minY:Math.min(o.start.y,o.end.y),maxX:Math.max(o.start.x,o.end.x),maxY:Math.max(o.start.y,o.end.y)},r=ar(i=this.body.nodeIndices).call(i,(function(t){var i=e.body.nodes[t];return i.x>=n.minX&&i.x<=n.maxX&&i.y>=n.minY&&i.y<=n.maxY}));Dn(r).call(r,(function(t){return e.selectionHandler.selectObject(e.body.nodes[t])}));var s=this.getPointer(t.center);this.selectionHandler.commitAndEmit(s,t),this.selectionHandler.generateClickEvent("dragEnd",t,this.getPointer(t.center),void 0,!0),this.body.emitter.emit("_requestRedraw")}else{var a=this.drag.selection;a&&a.length?(Dn(a).call(a,(function(t){t.node.options.fixed.x=t.xFixed,t.node.options.fixed.y=t.yFixed})),this.selectionHandler.generateClickEvent("dragEnd",t,this.getPointer(t.center)),this.body.emitter.emit("startSimulation")):(this.selectionHandler.generateClickEvent("dragEnd",t,this.getPointer(t.center),void 0,!0),this.body.emitter.emit("_requestRedraw"))}}},{key:"onPinch",value:function(t){var e=this.getPointer(t.center);this.drag.pinched=!0,void 0===this.pinch.scale&&(this.pinch.scale=1);var i=this.pinch.scale*t.scale;this.zoom(i,e)}},{key:"zoom",value:function(t,e){if(!0===this.options.zoomView){var i=this.body.view.scale;t<1e-5&&(t=1e-5),t>10&&(t=10);var o=void 0;void 0!==this.drag&&!0===this.drag.dragging&&(o=this.canvas.DOMtoCanvas(this.drag.pointer));var n=this.body.view.translation,r=t/i,s=(1-r)*e.x+n.x*r,a=(1-r)*e.y+n.y*r;if(this.body.view.scale=t,this.body.view.translation={x:s,y:a},null!=o){var h=this.canvas.canvasToDOM(o);this.drag.pointer.x=h.x,this.drag.pointer.y=h.y}this.body.emitter.emit("_requestRedraw"),i<t?this.body.emitter.emit("zoom",{direction:"+",scale:this.body.view.scale,pointer:e}):this.body.emitter.emit("zoom",{direction:"-",scale:this.body.view.scale,pointer:e})}}},{key:"onMouseWheel",value:function(t){if(!0===this.options.zoomView){if(0!==t.deltaY){var e=this.body.view.scale;e*=1+(t.deltaY<0?1:-1)*(.1*this.options.zoomSpeed);var i=this.getPointer({x:t.clientX,y:t.clientY});this.zoom(e,i)}t.preventDefault()}}},{key:"onMouseMove",value:function(t){var e=this,i=this.getPointer({x:t.clientX,y:t.clientY}),o=!1;void 0!==this.popup&&(!1===this.popup.hidden&&this._checkHidePopup(i),!1===this.popup.hidden&&(o=!0,this.popup.setPosition(i.x+3,i.y-5),this.popup.show())),!1===this.options.keyboard.bindToWindow&&!0===this.options.keyboard.enabled&&this.canvas.frame.focus(),!1===o&&(void 0!==this.popupTimer&&(clearInterval(this.popupTimer),this.popupTimer=void 0),this.drag.dragging||(this.popupTimer=qr((function(){return e._checkShowPopup(i)}),this.options.tooltipDelay))),!0===this.options.hover&&this.selectionHandler.hoverObject(t,i)}},{key:"_checkShowPopup",value:function(t){var e=this.canvas._XconvertDOMtoCanvas(t.x),i=this.canvas._YconvertDOMtoCanvas(t.y),o={left:e,top:i,right:e,bottom:i},n=void 0===this.popupObj?void 0:this.popupObj.id,r=!1,s="node";if(void 0===this.popupObj){for(var a,h=this.body.nodeIndices,d=this.body.nodes,l=[],c=0;c<h.length;c++)!0===(a=d[h[c]]).isOverlappingWith(o)&&(r=!0,void 0!==a.getTitle()&&l.push(h[c]));l.length>0&&(this.popupObj=d[l[l.length-1]],r=!0)}if(void 0===this.popupObj&&!1===r){for(var u,f=this.body.edgeIndices,p=this.body.edges,v=[],g=0;g<f.length;g++)!0===(u=p[f[g]]).isOverlappingWith(o)&&!0===u.connected&&void 0!==u.getTitle()&&v.push(f[g]);v.length>0&&(this.popupObj=p[v[v.length-1]],s="edge")}void 0!==this.popupObj?this.popupObj.id!==n&&(void 0===this.popup&&(this.popup=new Th(this.canvas.frame)),this.popup.popupTargetType=s,this.popup.popupTargetId=this.popupObj.id,this.popup.setPosition(t.x+3,t.y-5),this.popup.setText(this.popupObj.getTitle()),this.popup.show(),this.body.emitter.emit("showPopup",this.popupObj.id)):void 0!==this.popup&&(this.popup.hide(),this.body.emitter.emit("hidePopup"))}},{key:"_checkHidePopup",value:function(t){var e=this.selectionHandler._pointerToPositionObject(t),i=!1;if("node"===this.popup.popupTargetType){if(void 0!==this.body.nodes[this.popup.popupTargetId]&&!0===(i=this.body.nodes[this.popup.popupTargetId].isOverlappingWith(e))){var o=this.selectionHandler.getNodeAt(t);i=void 0!==o&&o.id===this.popup.popupTargetId}}else void 0===this.selectionHandler.getNodeAt(t)&&void 0!==this.body.edges[this.popup.popupTargetId]&&(i=this.body.edges[this.popup.popupTargetId].isOverlappingWith(e));!1===i&&(this.popupObj=void 0,this.popup.hide(),this.body.emitter.emit("hidePopup"))}}]),t}();Ed("Set",(function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}}),Dd);var Ru=F.Set,ju=gd.getWeakData,Lu=Zt.set,Hu=Zt.getterFor,Wu=Wi.find,Vu=Wi.findIndex,qu=0,Uu=function(t){return t.frozen||(t.frozen=new Yu)},Yu=function(){this.entries=[]},Xu=function(t,e){return Wu(t.entries,(function(t){return t[0]===e}))};Yu.prototype={get:function(t){var e=Xu(this,t);if(e)return e[1]},has:function(t){return!!Xu(this,t)},set:function(t,e){var i=Xu(this,t);i?i[1]=e:this.entries.push([t,e])},delete:function(t){var e=Vu(this.entries,(function(e){return e[0]===t}));return~e&&this.entries.splice(e,1),!!~e}};var Gu={getConstructor:function(t,e,i,o){var n=t((function(t,r){bd(t,n,e),Lu(t,{type:e,id:qu++,frozen:void 0}),null!=r&&md(r,t[o],{that:t,AS_ENTRIES:i})})),r=Hu(e),s=function(t,e,i){var o=r(t),n=ju(R(e),!0);return!0===n?Uu(o).set(e,i):n[o.id]=i,t};return Od(n.prototype,{delete:function(t){var e=r(this);if(!m(t))return!1;var i=ju(t);return!0===i?Uu(e).delete(t):i&&k(i,e.id)&&delete i[e.id]},has:function(t){var e=r(this);if(!m(t))return!1;var i=ju(t);return!0===i?Uu(e).has(t):i&&k(i,e.id)}}),Od(n.prototype,i?{get:function(t){var e=r(this);if(m(t)){var i=ju(t);return!0===i?Uu(e).get(t):i?i[e.id]:void 0}},set:function(t,e){return s(this,t,e)}}:{add:function(t){return s(this,t,!0)}}),n}};o((function(t){var e,i=Zt.enforce,o=!r.ActiveXObject&&"ActiveXObject"in r,n=Object.isExtensible,s=function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}},a=t.exports=Ed("WeakMap",s,Gu);if(At&&o){e=Gu.getConstructor(s,"WeakMap",!0),gd.REQUIRED=!0;var h=a.prototype,d=h.delete,l=h.has,c=h.get,u=h.set;Od(h,{delete:function(t){if(m(t)&&!n(t)){var o=i(this);return o.frozen||(o.frozen=new e),d.call(this,t)||o.frozen.delete(t)}return d.call(this,t)},has:function(t){if(m(t)&&!n(t)){var o=i(this);return o.frozen||(o.frozen=new e),l.call(this,t)||o.frozen.has(t)}return l.call(this,t)},get:function(t){if(m(t)&&!n(t)){var o=i(this);return o.frozen||(o.frozen=new e),l.call(this,t)?c.call(this,t):o.frozen.get(t)}return c.call(this,t)},set:function(t,o){if(m(t)&&!n(t)){var r=i(this);r.frozen||(r.frozen=new e),l.call(this,t)?u.call(this,t,o):r.frozen.set(t,o)}else u.call(this,t,o);return this}})}}));var Ku,$u,Qu,Zu,Ju,tf=F.WeakMap;
/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
function ef(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)}function of(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i}function nf(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return rf(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return rf(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function rf(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}function sf(t,e){var i,o=new Ru,n=nf(e);try{for(n.s();!(i=n.n()).done;){var r=i.value;t.has(r)||o.add(r)}}catch(t){n.e(t)}finally{n.f()}return o}var af=function(){function t(){Po(this,t),Ku.set(this,new Ru),$u.set(this,new Ru)}return Io(t,[{key:"size",get:function(){return ef(this,$u).size}},{key:"add",value:function(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];for(var o=0,n=e;o<n.length;o++){var r=n[o];ef(this,$u).add(r)}}},{key:"delete",value:function(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];for(var o=0,n=e;o<n.length;o++){var r=n[o];ef(this,$u).delete(r)}}},{key:"clear",value:function(){ef(this,$u).clear()}},{key:"getSelection",value:function(){return ln(ef(this,$u))}},{key:"getChanges",value:function(){return{added:ln(sf(ef(this,Ku),ef(this,$u))),deleted:ln(sf(ef(this,$u),ef(this,Ku))),previous:ln(new Ru(ef(this,Ku))),current:ln(new Ru(ef(this,$u)))}}},{key:"commit",value:function(){var t=this.getChanges();of(this,Ku,ef(this,$u)),of(this,$u,new Ru(ef(this,Ku)));var e,i=nf(t.added);try{for(i.s();!(e=i.n()).done;){e.value.select()}}catch(t){i.e(t)}finally{i.f()}var o,n=nf(t.deleted);try{for(n.s();!(o=n.n()).done;){o.value.unselect()}}catch(t){n.e(t)}finally{n.f()}return t}}]),t}();Ku=new tf,$u=new tf;var hf=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){};Po(this,t),Qu.set(this,new af),Zu.set(this,new af),Ju.set(this,void 0),of(this,Ju,e)}return Io(t,[{key:"sizeNodes",get:function(){return ef(this,Qu).size}},{key:"sizeEdges",get:function(){return ef(this,Zu).size}},{key:"getNodes",value:function(){return ef(this,Qu).getSelection()}},{key:"getEdges",value:function(){return ef(this,Zu).getSelection()}},{key:"addNodes",value:function(){var t;(t=ef(this,Qu)).add.apply(t,arguments)}},{key:"addEdges",value:function(){var t;(t=ef(this,Zu)).add.apply(t,arguments)}},{key:"deleteNodes",value:function(t){ef(this,Qu).delete(t)}},{key:"deleteEdges",value:function(t){ef(this,Zu).delete(t)}},{key:"clear",value:function(){ef(this,Qu).clear(),ef(this,Zu).clear()}},{key:"commit",value:function(){for(var t,e,i={nodes:ef(this,Qu).commit(),edges:ef(this,Zu).commit()},o=arguments.length,n=new Array(o),r=0;r<o;r++)n[r]=arguments[r];return(t=ef(this,Ju)).call.apply(t,pn(e=[this,i]).call(e,n)),i}}]),t}();function df(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return lf(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return lf(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function lf(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}Qu=new tf,Zu=new tf,Ju=new tf;var cf=function(){function t(e,i){var o=this;Po(this,t),this.body=e,this.canvas=i,this._selectionAccumulator=new hf,this.hoverObj={nodes:{},edges:{}},this.options={},this.defaultOptions={multiselect:!1,selectable:!0,selectConnectedEdges:!0,hoverConnectedEdges:!0},ct(this.options,this.defaultOptions),this.body.emitter.on("_dataChanged",(function(){o.updateSelection()}))}return Io(t,[{key:"setOptions",value:function(t){if(void 0!==t){Za(["multiselect","hoverConnectedEdges","selectable","selectConnectedEdges"],this.options,t)}}},{key:"selectOnPoint",value:function(t){var e=!1;if(!0===this.options.selectable){var i=this.getNodeAt(t)||this.getEdgeAt(t);this.unselectAll(),void 0!==i&&(e=this.selectObject(i)),this.body.emitter.emit("_requestRedraw")}return e}},{key:"selectAdditionalOnPoint",value:function(t){var e=!1;if(!0===this.options.selectable){var i=this.getNodeAt(t)||this.getEdgeAt(t);void 0!==i&&(e=!0,!0===i.isSelected()?this.deselectObject(i):this.selectObject(i),this.body.emitter.emit("_requestRedraw"))}return e}},{key:"_initBaseEvent",value:function(t,e){var i={};return i.pointer={DOM:{x:e.x,y:e.y},canvas:this.canvas.DOMtoCanvas(e)},i.event=t,i}},{key:"generateClickEvent",value:function(t,e,i,o){var n=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=this._initBaseEvent(e,i);if(!0===n)r.nodes=[],r.edges=[];else{var s=this.getSelection();r.nodes=s.nodes,r.edges=s.edges}void 0!==o&&(r.previousSelection=o),"click"==t&&(r.items=this.getClickedItems(i)),void 0!==e.controlEdge&&(r.controlEdge=e.controlEdge),this.body.emitter.emit(t,r)}},{key:"selectObject",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.selectConnectedEdges;if(void 0!==t){if(t instanceof lc){var i;if(!0===e)(i=this._selectionAccumulator).addEdges.apply(i,ln(t.edges));this._selectionAccumulator.addNodes(t)}else this._selectionAccumulator.addEdges(t);return!0}return!1}},{key:"deselectObject",value:function(t){!0===t.isSelected()&&(t.selected=!1,this._removeFromSelection(t))}},{key:"_getAllNodesOverlappingWith",value:function(t){for(var e=[],i=this.body.nodes,o=0;o<this.body.nodeIndices.length;o++){var n=this.body.nodeIndices[o];i[n].isOverlappingWith(t)&&e.push(n)}return e}},{key:"_pointerToPositionObject",value:function(t){var e=this.canvas.DOMtoCanvas(t);return{left:e.x-1,top:e.y+1,right:e.x+1,bottom:e.y-1}}},{key:"getNodeAt",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this._pointerToPositionObject(t),o=this._getAllNodesOverlappingWith(i);return o.length>0?!0===e?this.body.nodes[o[o.length-1]]:o[o.length-1]:void 0}},{key:"_getEdgesOverlappingWith",value:function(t,e){for(var i=this.body.edges,o=0;o<this.body.edgeIndices.length;o++){var n=this.body.edgeIndices[o];i[n].isOverlappingWith(t)&&e.push(n)}}},{key:"_getAllEdgesOverlappingWith",value:function(t){var e=[];return this._getEdgesOverlappingWith(t,e),e}},{key:"getEdgeAt",value:function(t){for(var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this.canvas.DOMtoCanvas(t),o=10,n=null,r=this.body.edges,s=0;s<this.body.edgeIndices.length;s++){var a=this.body.edgeIndices[s],h=r[a];if(h.connected){var d=h.from.x,l=h.from.y,c=h.to.x,u=h.to.y,f=h.edgeType.getDistanceToEdge(d,l,c,u,i.x,i.y);f<o&&(n=a,o=f)}}return null!==n?!0===e?this.body.edges[n]:n:void 0}},{key:"_addToHover",value:function(t){t instanceof lc?this.hoverObj.nodes[t.id]=t:this.hoverObj.edges[t.id]=t}},{key:"_removeFromSelection",value:function(t){var e;t instanceof lc?(this._selectionAccumulator.deleteNodes(t),(e=this._selectionAccumulator).deleteEdges.apply(e,ln(t.edges))):this._selectionAccumulator.deleteEdges(t)}},{key:"unselectAll",value:function(){this._selectionAccumulator.clear()}},{key:"getSelectedNodeCount",value:function(){return this._selectionAccumulator.sizeNodes}},{key:"getSelectedEdgeCount",value:function(){return this._selectionAccumulator.sizeEdges}},{key:"_hoverConnectedEdges",value:function(t){for(var e=0;e<t.edges.length;e++){var i=t.edges[e];i.hover=!0,this._addToHover(i)}}},{key:"emitBlurEvent",value:function(t,e,i){var o=this._initBaseEvent(t,e);!0===i.hover&&(i.hover=!1,i instanceof lc?(o.node=i.id,this.body.emitter.emit("blurNode",o)):(o.edge=i.id,this.body.emitter.emit("blurEdge",o)))}},{key:"emitHoverEvent",value:function(t,e,i){var o=this._initBaseEvent(t,e),n=!1;return!1===i.hover&&(i.hover=!0,this._addToHover(i),n=!0,i instanceof lc?(o.node=i.id,this.body.emitter.emit("hoverNode",o)):(o.edge=i.id,this.body.emitter.emit("hoverEdge",o))),n}},{key:"hoverObject",value:function(t,e){var i=this.getNodeAt(e);void 0===i&&(i=this.getEdgeAt(e));var o=!1;for(var n in this.hoverObj.nodes)Object.prototype.hasOwnProperty.call(this.hoverObj.nodes,n)&&(void 0===i||i instanceof lc&&i.id!=n||i instanceof Jc)&&(this.emitBlurEvent(t,e,this.hoverObj.nodes[n]),delete this.hoverObj.nodes[n],o=!0);for(var r in this.hoverObj.edges)Object.prototype.hasOwnProperty.call(this.hoverObj.edges,r)&&(!0===o?(this.hoverObj.edges[r].hover=!1,delete this.hoverObj.edges[r]):(void 0===i||i instanceof Jc&&i.id!=r||i instanceof lc&&!i.hover)&&(this.emitBlurEvent(t,e,this.hoverObj.edges[r]),delete this.hoverObj.edges[r],o=!0));if(void 0!==i){var s=xn(this.hoverObj.edges).length,a=xn(this.hoverObj.nodes).length;(o||i instanceof Jc&&0===s&&0===a||i instanceof lc&&0===s&&0===a)&&(o=this.emitHoverEvent(t,e,i)),i instanceof lc&&!0===this.options.hoverConnectedEdges&&this._hoverConnectedEdges(i)}!0===o&&this.body.emitter.emit("_requestRedraw")}},{key:"commitWithoutEmitting",value:function(){this._selectionAccumulator.commit()}},{key:"commitAndEmit",value:function(t,e){var i=!1,o=this._selectionAccumulator.commit(),n={nodes:o.nodes.previous,edges:o.edges.previous};o.edges.deleted.length>0&&(this.generateClickEvent("deselectEdge",e,t,n),i=!0),o.nodes.deleted.length>0&&(this.generateClickEvent("deselectNode",e,t,n),i=!0),o.nodes.added.length>0&&(this.generateClickEvent("selectNode",e,t),i=!0),o.edges.added.length>0&&(this.generateClickEvent("selectEdge",e,t),i=!0),!0===i&&this.generateClickEvent("select",e,t)}},{key:"getSelection",value:function(){return{nodes:this.getSelectedNodeIds(),edges:this.getSelectedEdgeIds()}}},{key:"getSelectedNodes",value:function(){return this._selectionAccumulator.getNodes()}},{key:"getSelectedEdges",value:function(){return this._selectionAccumulator.getEdges()}},{key:"getSelectedNodeIds",value:function(){var t;return kn(t=this._selectionAccumulator.getNodes()).call(t,(function(t){return t.id}))}},{key:"getSelectedEdgeIds",value:function(){var t;return kn(t=this._selectionAccumulator.getEdges()).call(t,(function(t){return t.id}))}},{key:"setSelection",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t||!t.nodes&&!t.edges)throw new TypeError("Selection must be an object with nodes and/or edges properties");if((e.unselectAll||void 0===e.unselectAll)&&this.unselectAll(),t.nodes){var i,o=df(t.nodes);try{for(o.s();!(i=o.n()).done;){var n=i.value,r=this.body.nodes[n];if(!r)throw new RangeError('Node with id "'+n+'" not found');this.selectObject(r,e.highlightEdges)}}catch(t){o.e(t)}finally{o.f()}}if(t.edges){var s,a=df(t.edges);try{for(a.s();!(s=a.n()).done;){var h=s.value,d=this.body.edges[h];if(!d)throw new RangeError('Edge with id "'+h+'" not found');this.selectObject(d)}}catch(t){a.e(t)}finally{a.f()}}this.body.emitter.emit("_requestRedraw"),this._selectionAccumulator.commit()}},{key:"selectNodes",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!t||void 0===t.length)throw"Selection must be an array with ids";this.setSelection({nodes:t},{highlightEdges:e})}},{key:"selectEdges",value:function(t){if(!t||void 0===t.length)throw"Selection must be an array with ids";this.setSelection({edges:t})}},{key:"updateSelection",value:function(){for(var t in this._selectionAccumulator.getNodes())Object.prototype.hasOwnProperty.call(this.body.nodes,t.id)||this._selectionAccumulator.deleteNodes(t);for(var e in this._selectionAccumulator.getEdges())Object.prototype.hasOwnProperty.call(this.body.edges,e.id)||this._selectionAccumulator.deleteEdges(e)}},{key:"getClickedItems",value:function(t){for(var e=this.canvas.DOMtoCanvas(t),i=[],o=this.body.nodeIndices,n=this.body.nodes,r=o.length-1;r>=0;r--){var s=n[o[r]].getItemsOnPoint(e);i.push.apply(i,s)}for(var a=this.body.edgeIndices,h=this.body.edges,d=a.length-1;d>=0;d--){var l=h[a[d]].getItemsOnPoint(e);i.push.apply(i,l)}return i}}]),t}(),uf=[],ff=uf.sort,pf=s((function(){uf.sort(void 0)})),vf=s((function(){uf.sort(null)})),gf=On("sort");q({target:"Array",proto:!0,forced:pf||!vf||!gf},{sort:function(t){return void 0===t?ff.call(at(this)):ff.call(at(this),N(t))}});var yf=gt("Array").sort,mf=Array.prototype,bf=function(t){var e=t.sort;return t===mf||t instanceof Array&&e===mf.sort?yf:e},wf=function(t){return function(e,i,o,n){N(i);var r=at(e),s=v(r),a=K(r.length),h=t?a-1:0,d=t?-1:1;if(o<2)for(;;){if(h in s){n=s[h],h+=d;break}if(h+=d,t?h<0:a<=h)throw TypeError("Reduce of empty array with no initial value")}for(;t?h>=0:a>h;h+=d)h in s&&(n=i(n,s[h],h,r));return n}},kf={left:wf(!1),right:wf(!0)}.left,_f=On("reduce");q({target:"Array",proto:!0,forced:!_f||!oe&&fe>79&&fe<83},{reduce:function(t){return kf(this,t,arguments.length,arguments.length>1?arguments[1]:void 0)}});var xf=gt("Array").reduce,Ef=Array.prototype,Of=function(t){var e=t.reduce;return t===Ef||t instanceof Array&&e===Ef.reduce?xf:e},Cf=o((function(t,e){!function(t){function e(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0,t.sort=v;var i=32,o=7,n=256,r=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9];function s(t){return t<1e5?t<100?t<10?0:1:t<1e4?t<1e3?2:3:4:t<1e7?t<1e6?5:6:t<1e9?t<1e8?7:8:9}function a(t,e){if(t===e)return 0;if(~~t===t&&~~e===e){if(0===t||0===e)return t<e?-1:1;if(t<0||e<0){if(e>=0)return-1;if(t>=0)return 1;t=-t,e=-e}var i=s(t),o=s(e),n=0;return i<o?(t*=r[o-i-1],e/=10,n=-1):i>o&&(e*=r[i-o-1],t/=10,n=1),t===e?n:t<e?-1:1}var a=String(t),h=String(e);return a===h?0:a<h?-1:1}function h(t){for(var e=0;t>=i;)e|=1&t,t>>=1;return t+e}function d(t,e,i,o){var n=e+1;if(n===i)return 1;if(o(t[n++],t[e])<0){for(;n<i&&o(t[n],t[n-1])<0;)n++;l(t,e,n)}else for(;n<i&&o(t[n],t[n-1])>=0;)n++;return n-e}function l(t,e,i){for(i--;e<i;){var o=t[e];t[e++]=t[i],t[i--]=o}}function c(t,e,i,o,n){for(o===e&&o++;o<i;o++){for(var r=t[o],s=e,a=o;s<a;){var h=s+a>>>1;n(r,t[h])<0?a=h:s=h+1}var d=o-s;switch(d){case 3:t[s+3]=t[s+2];case 2:t[s+2]=t[s+1];case 1:t[s+1]=t[s];break;default:for(;d>0;)t[s+d]=t[s+d-1],d--}t[s]=r}}function u(t,e,i,o,n,r){var s=0,a=0,h=1;if(r(t,e[i+n])>0){for(a=o-n;h<a&&r(t,e[i+n+h])>0;)s=h,(h=1+(h<<1))<=0&&(h=a);h>a&&(h=a),s+=n,h+=n}else{for(a=n+1;h<a&&r(t,e[i+n-h])<=0;)s=h,(h=1+(h<<1))<=0&&(h=a);h>a&&(h=a);var d=s;s=n-h,h=n-d}for(s++;s<h;){var l=s+(h-s>>>1);r(t,e[i+l])>0?s=l+1:h=l}return h}function f(t,e,i,o,n,r){var s=0,a=0,h=1;if(r(t,e[i+n])<0){for(a=n+1;h<a&&r(t,e[i+n-h])<0;)s=h,(h=1+(h<<1))<=0&&(h=a);h>a&&(h=a);var d=s;s=n-h,h=n-d}else{for(a=o-n;h<a&&r(t,e[i+n+h])>=0;)s=h,(h=1+(h<<1))<=0&&(h=a);h>a&&(h=a),s+=n,h+=n}for(s++;s<h;){var l=s+(h-s>>>1);r(t,e[i+l])<0?h=l:s=l+1}return h}var p=function(){function t(i,r){e(this,t),this.array=null,this.compare=null,this.minGallop=o,this.length=0,this.tmpStorageLength=n,this.stackLength=0,this.runStart=null,this.runLength=null,this.stackSize=0,this.array=i,this.compare=r,this.length=i.length,this.length<2*n&&(this.tmpStorageLength=this.length>>>1),this.tmp=new Array(this.tmpStorageLength),this.stackLength=this.length<120?5:this.length<1542?10:this.length<119151?19:40,this.runStart=new Array(this.stackLength),this.runLength=new Array(this.stackLength)}return t.prototype.pushRun=function(t,e){this.runStart[this.stackSize]=t,this.runLength[this.stackSize]=e,this.stackSize+=1},t.prototype.mergeRuns=function(){for(;this.stackSize>1;){var t=this.stackSize-2;if(t>=1&&this.runLength[t-1]<=this.runLength[t]+this.runLength[t+1]||t>=2&&this.runLength[t-2]<=this.runLength[t]+this.runLength[t-1])this.runLength[t-1]<this.runLength[t+1]&&t--;else if(this.runLength[t]>this.runLength[t+1])break;this.mergeAt(t)}},t.prototype.forceMergeRuns=function(){for(;this.stackSize>1;){var t=this.stackSize-2;t>0&&this.runLength[t-1]<this.runLength[t+1]&&t--,this.mergeAt(t)}},t.prototype.mergeAt=function(t){var e=this.compare,i=this.array,o=this.runStart[t],n=this.runLength[t],r=this.runStart[t+1],s=this.runLength[t+1];this.runLength[t]=n+s,t===this.stackSize-3&&(this.runStart[t+1]=this.runStart[t+2],this.runLength[t+1]=this.runLength[t+2]),this.stackSize--;var a=f(i[r],i,o,n,0,e);o+=a,0!=(n-=a)&&0!==(s=u(i[o+n-1],i,r,s,s-1,e))&&(n<=s?this.mergeLow(o,n,r,s):this.mergeHigh(o,n,r,s))},t.prototype.mergeLow=function(t,e,i,n){var r=this.compare,s=this.array,a=this.tmp,h=0;for(h=0;h<e;h++)a[h]=s[t+h];var d=0,l=i,c=t;if(s[c++]=s[l++],0!=--n)if(1!==e){for(var p=this.minGallop;;){var v=0,g=0,y=!1;do{if(r(s[l],a[d])<0){if(s[c++]=s[l++],g++,v=0,0==--n){y=!0;break}}else if(s[c++]=a[d++],v++,g=0,1==--e){y=!0;break}}while((v|g)<p);if(y)break;do{if(0!==(v=f(s[l],a,d,e,0,r))){for(h=0;h<v;h++)s[c+h]=a[d+h];if(c+=v,d+=v,(e-=v)<=1){y=!0;break}}if(s[c++]=s[l++],0==--n){y=!0;break}if(0!==(g=u(a[d],s,l,n,0,r))){for(h=0;h<g;h++)s[c+h]=s[l+h];if(c+=g,l+=g,0==(n-=g)){y=!0;break}}if(s[c++]=a[d++],1==--e){y=!0;break}p--}while(v>=o||g>=o);if(y)break;p<0&&(p=0),p+=2}if(this.minGallop=p,p<1&&(this.minGallop=1),1===e){for(h=0;h<n;h++)s[c+h]=s[l+h];s[c+n]=a[d]}else{if(0===e)throw new Error("mergeLow preconditions were not respected");for(h=0;h<e;h++)s[c+h]=a[d+h]}}else{for(h=0;h<n;h++)s[c+h]=s[l+h];s[c+n]=a[d]}else for(h=0;h<e;h++)s[c+h]=a[d+h]},t.prototype.mergeHigh=function(t,e,i,n){var r=this.compare,s=this.array,a=this.tmp,h=0;for(h=0;h<n;h++)a[h]=s[i+h];var d=t+e-1,l=n-1,c=i+n-1,p=0,v=0;if(s[c--]=s[d--],0!=--e)if(1!==n){for(var g=this.minGallop;;){var y=0,m=0,b=!1;do{if(r(a[l],s[d])<0){if(s[c--]=s[d--],y++,m=0,0==--e){b=!0;break}}else if(s[c--]=a[l--],m++,y=0,1==--n){b=!0;break}}while((y|m)<g);if(b)break;do{if(0!=(y=e-f(a[l],s,t,e,e-1,r))){for(e-=y,v=1+(c-=y),p=1+(d-=y),h=y-1;h>=0;h--)s[v+h]=s[p+h];if(0===e){b=!0;break}}if(s[c--]=a[l--],1==--n){b=!0;break}if(0!=(m=n-u(s[d],a,0,n,n-1,r))){for(n-=m,v=1+(c-=m),p=1+(l-=m),h=0;h<m;h++)s[v+h]=a[p+h];if(n<=1){b=!0;break}}if(s[c--]=s[d--],0==--e){b=!0;break}g--}while(y>=o||m>=o);if(b)break;g<0&&(g=0),g+=2}if(this.minGallop=g,g<1&&(this.minGallop=1),1===n){for(v=1+(c-=e),p=1+(d-=e),h=e-1;h>=0;h--)s[v+h]=s[p+h];s[c]=a[l]}else{if(0===n)throw new Error("mergeHigh preconditions were not respected");for(p=c-(n-1),h=0;h<n;h++)s[p+h]=a[h]}}else{for(v=1+(c-=e),p=1+(d-=e),h=e-1;h>=0;h--)s[v+h]=s[p+h];s[c]=a[l]}else for(p=c-(n-1),h=0;h<n;h++)s[p+h]=a[h]},t}();function v(t,e,o,n){if(!Array.isArray(t))throw new TypeError("Can only sort arrays");e?"function"!=typeof e&&(n=o,o=e,e=a):e=a,o||(o=0),n||(n=t.length);var r=n-o;if(!(r<2)){var s=0;if(r<i)c(t,o,n,o+(s=d(t,o,n,e)),e);else{var l=new p(t,e),u=h(r);do{if((s=d(t,o,n,e))<u){var f=r;f>u&&(f=u),c(t,o,o+f,o+s,e),s=f}l.pushRun(o,s),l.mergeRuns(),r-=s,o+=s}while(0!==r);l.forceMergeRuns()}}}}(e)}));function Sf(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Tf=function(){function t(){Po(this,t)}return Io(t,[{key:"abstract",value:function(){throw new Error("Can't instantiate abstract class!")}},{key:"fake_use",value:function(){}},{key:"curveType",value:function(){return this.abstract()}},{key:"getPosition",value:function(t){return this.fake_use(t),this.abstract()}},{key:"setPosition",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;this.fake_use(t,e,i),this.abstract()}},{key:"getTreeSize",value:function(t){return this.fake_use(t),this.abstract()}},{key:"sort",value:function(t){this.fake_use(t),this.abstract()}},{key:"fix",value:function(t,e){this.fake_use(t,e),this.abstract()}},{key:"shift",value:function(t,e){this.fake_use(t,e),this.abstract()}}]),t}(),Mf=function(t){bl(i,t);var e=Sf(i);function i(t){var o;return Po(this,i),(o=e.call(this)).layout=t,o}return Io(i,[{key:"curveType",value:function(){return"horizontal"}},{key:"getPosition",value:function(t){return t.x}},{key:"setPosition",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;void 0!==i&&this.layout.hierarchical.addToOrdering(t,i),t.x=e}},{key:"getTreeSize",value:function(t){var e=this.layout.hierarchical.getTreeSize(this.layout.body.nodes,t);return{min:e.min_x,max:e.max_x}}},{key:"sort",value:function(t){Cf.sort(t,(function(t,e){return t.x-e.x}))}},{key:"fix",value:function(t,e){t.y=this.layout.options.hierarchical.levelSeparation*e,t.options.fixed.y=!0}},{key:"shift",value:function(t,e){this.layout.body.nodes[t].x+=e}}]),i}(Tf),Pf=function(t){bl(i,t);var e=Sf(i);function i(t){var o;return Po(this,i),(o=e.call(this)).layout=t,o}return Io(i,[{key:"curveType",value:function(){return"vertical"}},{key:"getPosition",value:function(t){return t.y}},{key:"setPosition",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;void 0!==i&&this.layout.hierarchical.addToOrdering(t,i),t.y=e}},{key:"getTreeSize",value:function(t){var e=this.layout.hierarchical.getTreeSize(this.layout.body.nodes,t);return{min:e.min_y,max:e.max_y}}},{key:"sort",value:function(t){Cf.sort(t,(function(t,e){return t.y-e.y}))}},{key:"fix",value:function(t,e){t.x=this.layout.options.hierarchical.levelSeparation*e,t.options.fixed.x=!0}},{key:"shift",value:function(t,e){this.layout.body.nodes[t].y+=e}}]),i}(Tf),Df=Wi.every,Bf=On("every");q({target:"Array",proto:!0,forced:!Bf},{every:function(t){return Df(this,t,arguments.length>1?arguments[1]:void 0)}});var If=gt("Array").every,zf=Array.prototype,Ff=function(t){var e=t.every;return t===zf||t instanceof Array&&e===zf.every?If:e};function Nf(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return Af(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return Af(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function Af(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}function Rf(t,e){var i=new Ru;return Dn(t).call(t,(function(t){var e;Dn(e=t.edges).call(e,(function(t){t.connected&&i.add(t)}))})),Dn(i).call(i,(function(t){var i=t.from.id,o=t.to.id;null==e[i]&&(e[i]=0),(null==e[o]||e[i]>=e[o])&&(e[o]=e[i]+1)})),e}function jf(t,e,i,o){var n,r,s=Ir(null),a=Of(n=ln(nl(o).call(o))).call(n,(function(t,e){return t+1+e.edges.length}),0),h=i+"Id",d="to"===i?1:-1,l=Nf(o);try{var c=function(){var n=an(r.value,2),l=n[0],c=n[1];if(!o.has(l)||!t(c))return"continue";s[l]=0;for(var u=[c],f=0,p=void 0,v=function(){var t,n;if(!o.has(l))return"continue";var r=s[p.id]+d;if(Dn(t=ar(n=p.edges).call(n,(function(t){return t.connected&&t.to!==t.from&&t[i]!==p&&o.has(t.toId)&&o.has(t.fromId)}))).call(t,(function(t){var o=t[h],n=s[o];(null==n||e(r,n))&&(s[o]=r,u.push(t[i]))})),f>a)return{v:{v:Rf(o,s)}};++f};p=u.pop();){var g=v();if("continue"!==g&&"object"===dn(g))return g.v}};for(l.s();!(r=l.n()).done;){var u=c();if("continue"!==u&&"object"===dn(u))return u.v}}catch(t){l.e(t)}finally{l.f()}return s}var Lf=function(){function t(){Po(this,t),this.childrenReference={},this.parentReference={},this.trees={},this.distributionOrdering={},this.levels={},this.distributionIndex={},this.isTree=!1,this.treeIndex=-1}return Io(t,[{key:"addRelation",value:function(t,e){void 0===this.childrenReference[t]&&(this.childrenReference[t]=[]),this.childrenReference[t].push(e),void 0===this.parentReference[e]&&(this.parentReference[e]=[]),this.parentReference[e].push(t)}},{key:"checkIfTree",value:function(){for(var t in this.parentReference)if(this.parentReference[t].length>1)return void(this.isTree=!1);this.isTree=!0}},{key:"numTrees",value:function(){return this.treeIndex+1}},{key:"setTreeIndex",value:function(t,e){void 0!==e&&void 0===this.trees[t.id]&&(this.trees[t.id]=e,this.treeIndex=Math.max(e,this.treeIndex))}},{key:"ensureLevel",value:function(t){void 0===this.levels[t]&&(this.levels[t]=0)}},{key:"getMaxLevel",value:function(t){var e=this,i={};return function t(o){if(void 0!==i[o])return i[o];var n=e.levels[o];if(e.childrenReference[o]){var r=e.childrenReference[o];if(r.length>0)for(var s=0;s<r.length;s++)n=Math.max(n,t(r[s]))}return i[o]=n,n}(t)}},{key:"levelDownstream",value:function(t,e){void 0===this.levels[e.id]&&(void 0===this.levels[t.id]&&(this.levels[t.id]=0),this.levels[e.id]=this.levels[t.id]+1)}},{key:"setMinLevelToZero",value:function(t){var e=1e9;for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&void 0!==this.levels[i]&&(e=Math.min(this.levels[i],e));for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&void 0!==this.levels[o]&&(this.levels[o]-=e)}},{key:"getTreeSize",value:function(t,e){var i=1e9,o=-1e9,n=1e9,r=-1e9;for(var s in this.trees)if(Object.prototype.hasOwnProperty.call(this.trees,s)&&this.trees[s]===e){var a=t[s];i=Math.min(a.x,i),o=Math.max(a.x,o),n=Math.min(a.y,n),r=Math.max(a.y,r)}return{min_x:i,max_x:o,min_y:n,max_y:r}}},{key:"hasSameParent",value:function(t,e){var i=this.parentReference[t.id],o=this.parentReference[e.id];if(void 0===i||void 0===o)return!1;for(var n=0;n<i.length;n++)for(var r=0;r<o.length;r++)if(i[n]==o[r])return!0;return!1}},{key:"inSameSubNetwork",value:function(t,e){return this.trees[t.id]===this.trees[e.id]}},{key:"getLevels",value:function(){return xn(this.distributionOrdering)}},{key:"addToOrdering",value:function(t,e){void 0===this.distributionOrdering[e]&&(this.distributionOrdering[e]=[]);var i=!1,o=this.distributionOrdering[e];for(var n in o)if(o[n]===t){i=!0;break}i||(this.distributionOrdering[e].push(t),this.distributionIndex[t.id]=this.distributionOrdering[e].length-1)}}]),t}(),Hf=function(){function t(e){Po(this,t),this.body=e,this._resetRNG(Math.random()+":"+En()),this.setPhysics=!1,this.options={},this.optionsBackup={physics:{}},this.defaultOptions={randomSeed:void 0,improvedLayout:!0,clusterThreshold:150,hierarchical:{enabled:!1,levelSeparation:150,nodeSpacing:100,treeSpacing:200,blockShifting:!0,edgeMinimization:!0,parentCentralization:!0,direction:"UD",sortMethod:"hubsize"}},ct(this.options,this.defaultOptions),this.bindEventListeners()}return Io(t,[{key:"bindEventListeners",value:function(){var t=this;this.body.emitter.on("_dataChanged",(function(){t.setupHierarchicalLayout()})),this.body.emitter.on("_dataLoaded",(function(){t.layoutNetwork()})),this.body.emitter.on("_resetHierarchicalLayout",(function(){t.setupHierarchicalLayout()})),this.body.emitter.on("_adjustEdgesForHierarchicalLayout",(function(){if(!0===t.options.hierarchical.enabled){var e=t.direction.curveType();t.body.emitter.emit("_forceDisableDynamicCurves",e,!1)}}))}},{key:"setOptions",value:function(t,e){if(void 0!==t){var i=this.options.hierarchical,o=i.enabled;if(Za(["randomSeed","improvedLayout","clusterThreshold"],this.options,t),gh(this.options,t,"hierarchical"),void 0!==t.randomSeed&&this._resetRNG(t.randomSeed),!0===i.enabled)return!0===o&&this.body.emitter.emit("refresh",!0),"RL"===i.direction||"DU"===i.direction?i.levelSeparation>0&&(i.levelSeparation*=-1):i.levelSeparation<0&&(i.levelSeparation*=-1),this.setDirectionStrategy(),this.body.emitter.emit("_resetHierarchicalLayout"),this.adaptAllOptionsForHierarchicalLayout(e);if(!0===o)return this.body.emitter.emit("refresh"),th(e,this.optionsBackup)}return e}},{key:"_resetRNG",value:function(t){this.initialRandomSeed=t,this._rng=Ra(this.initialRandomSeed)}},{key:"adaptAllOptionsForHierarchicalLayout",value:function(t){if(!0===this.options.hierarchical.enabled){var e=this.optionsBackup.physics;void 0===t.physics||!0===t.physics?(t.physics={enabled:void 0===e.enabled||e.enabled,solver:"hierarchicalRepulsion"},e.enabled=void 0===e.enabled||e.enabled,e.solver=e.solver||"barnesHut"):"object"===dn(t.physics)?(e.enabled=void 0===t.physics.enabled||t.physics.enabled,e.solver=t.physics.solver||"barnesHut",t.physics.solver="hierarchicalRepulsion"):!1!==t.physics&&(e.solver="barnesHut",t.physics={solver:"hierarchicalRepulsion"});var i=this.direction.curveType();if(void 0===t.edges)this.optionsBackup.edges={smooth:{enabled:!0,type:"dynamic"}},t.edges={smooth:!1};else if(void 0===t.edges.smooth)this.optionsBackup.edges={smooth:{enabled:!0,type:"dynamic"}},t.edges.smooth=!1;else if("boolean"==typeof t.edges.smooth)this.optionsBackup.edges={smooth:t.edges.smooth},t.edges.smooth={enabled:t.edges.smooth,type:i};else{var o=t.edges.smooth;void 0!==o.type&&"dynamic"!==o.type&&(i=o.type),this.optionsBackup.edges={smooth:{enabled:void 0===o.enabled||o.enabled,type:void 0===o.type?"dynamic":o.type,roundness:void 0===o.roundness?.5:o.roundness,forceDirection:void 0!==o.forceDirection&&o.forceDirection}},t.edges.smooth={enabled:void 0===o.enabled||o.enabled,type:i,roundness:void 0===o.roundness?.5:o.roundness,forceDirection:void 0!==o.forceDirection&&o.forceDirection}}this.body.emitter.emit("_forceDisableDynamicCurves",i)}return t}},{key:"positionInitially",value:function(t){if(!0!==this.options.hierarchical.enabled){this._resetRNG(this.initialRandomSeed);for(var e=t.length+50,i=0;i<t.length;i++){var o=t[i],n=2*Math.PI*this._rng();void 0===o.x&&(o.x=e*Math.cos(n)),void 0===o.y&&(o.y=e*Math.sin(n))}}}},{key:"layoutNetwork",value:function(){if(!0!==this.options.hierarchical.enabled&&!0===this.options.improvedLayout){for(var t=this.body.nodeIndices,e=0,i=0;i<t.length;i++){!0===this.body.nodes[t[i]].predefinedPosition&&(e+=1)}if(e<.5*t.length){var o=0,n=this.options.clusterThreshold,r={clusterNodeProperties:{shape:"ellipse",label:"",group:"",font:{multi:!1}},clusterEdgeProperties:{label:"",font:{multi:!1},smooth:{enabled:!1}}};if(t.length>n){for(var s=t.length;t.length>n&&o<=10;){o+=1;var a=t.length;if(o%3==0?this.body.modules.clustering.clusterBridges(r):this.body.modules.clustering.clusterOutliers(r),a==t.length&&o%3!=0)return this._declusterAll(),this.body.emitter.emit("_layoutFailed"),void console.info("This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.")}this.body.modules.kamadaKawai.setOptions({springLength:Math.max(150,2*s)})}o>10&&console.info("The clustering didn't succeed within the amount of interations allowed, progressing with partial result."),this.body.modules.kamadaKawai.solve(t,this.body.edgeIndices,!0),this._shiftToCenter();for(var h=0;h<t.length;h++){var d=this.body.nodes[t[h]];!1===d.predefinedPosition&&(d.x+=70*(.5-this._rng()),d.y+=70*(.5-this._rng()))}this._declusterAll(),this.body.emitter.emit("_repositionBezierNodes")}}}},{key:"_shiftToCenter",value:function(){for(var t=wu.getRangeCore(this.body.nodes,this.body.nodeIndices),e=wu.findCenter(t),i=0;i<this.body.nodeIndices.length;i++){var o=this.body.nodes[this.body.nodeIndices[i]];o.x-=e.x,o.y-=e.y}}},{key:"_declusterAll",value:function(){for(var t=!0;!0===t;){t=!1;for(var e=0;e<this.body.nodeIndices.length;e++)!0===this.body.nodes[this.body.nodeIndices[e]].isCluster&&(t=!0,this.body.modules.clustering.openCluster(this.body.nodeIndices[e],{},!1));!0===t&&this.body.emitter.emit("_dataChanged")}}},{key:"getSeed",value:function(){return this.initialRandomSeed}},{key:"setupHierarchicalLayout",value:function(){if(!0===this.options.hierarchical.enabled&&this.body.nodeIndices.length>0){var t,e,i=!1,o=!1;for(e in this.lastNodeOnLevel={},this.hierarchical=new Lf,this.body.nodes)Object.prototype.hasOwnProperty.call(this.body.nodes,e)&&(void 0!==(t=this.body.nodes[e]).options.level?(i=!0,this.hierarchical.levels[e]=t.options.level):o=!0);if(!0===o&&!0===i)throw new Error("To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.");if(!0===o){var n=this.options.hierarchical.sortMethod;"hubsize"===n?this._determineLevelsByHubsize():"directed"===n?this._determineLevelsDirected():"custom"===n&&this._determineLevelsCustomCallback()}for(var r in this.body.nodes)Object.prototype.hasOwnProperty.call(this.body.nodes,r)&&this.hierarchical.ensureLevel(r);var s=this._getDistribution();this._generateMap(),this._placeNodesByHierarchy(s),this._condenseHierarchy(),this._shiftToCenter()}}},{key:"_condenseHierarchy",value:function(){var t=this,e=!1,i={},o=function(e,i){var o=t.hierarchical.trees;for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&o[n]===e&&t.direction.shift(n,i)},n=function(){for(var e=[],i=0;i<t.hierarchical.numTrees();i++)e.push(t.direction.getTreeSize(i));return e},r=function e(i,o){if(!o[i.id]&&(o[i.id]=!0,t.hierarchical.childrenReference[i.id])){var n=t.hierarchical.childrenReference[i.id];if(n.length>0)for(var r=0;r<n.length;r++)e(t.body.nodes[n[r]],o)}},s=function(e){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e9,o=1e9,n=1e9,r=1e9,s=-1e9;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var h=t.body.nodes[a],d=t.hierarchical.levels[h.id],l=t.direction.getPosition(h),c=t._getSpaceAroundNode(h,e),u=an(c,2),f=u[0],p=u[1];o=Math.min(f,o),n=Math.min(p,n),d<=i&&(r=Math.min(l,r),s=Math.max(l,s))}return[r,s,o,n]},a=function(e,i){var o=t.hierarchical.getMaxLevel(e.id),n=t.hierarchical.getMaxLevel(i.id);return Math.min(o,n)},h=function(e,i,o){for(var n=t.hierarchical,r=0;r<i.length;r++){var s=i[r],a=n.distributionOrdering[s];if(a.length>1)for(var h=0;h<a.length-1;h++){var d=a[h],l=a[h+1];n.hasSameParent(d,l)&&n.inSameSubNetwork(d,l)&&e(d,l,o)}}},d=function(i,o){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],h=t.direction.getPosition(i),d=t.direction.getPosition(o),l=Math.abs(d-h),c=t.options.hierarchical.nodeSpacing;if(l>c){var u={},f={};r(i,u),r(o,f);var p=a(i,o),v=s(u,p),g=s(f,p),y=v[1],m=g[0],b=g[2],w=Math.abs(y-m);if(w>c){var k=y-m+c;k<-b+c&&(k=-b+c),k<0&&(t._shiftBlock(o.id,k),e=!0,!0===n&&t._centerParent(o))}}},l=function(o,n){for(var a=n.id,h=n.edges,d=t.hierarchical.levels[n.id],l=t.options.hierarchical.levelSeparation*t.options.hierarchical.levelSeparation,c={},u=[],f=0;f<h.length;f++){var p=h[f];if(p.toId!=p.fromId){var v=p.toId==a?p.from:p.to;c[h[f].id]=v,t.hierarchical.levels[v.id]<d&&u.push(p)}}var g=function(e,i){for(var o=0,n=0;n<i.length;n++)if(void 0!==c[i[n].id]){var r=t.direction.getPosition(c[i[n].id])-e;o+=r/Math.sqrt(r*r+l)}return o},y=function(e,i){for(var o=0,n=0;n<i.length;n++)if(void 0!==c[i[n].id]){var r=t.direction.getPosition(c[i[n].id])-e;o-=l*Math.pow(r*r+l,-1.5)}return o},m=function(e,i){for(var o=t.direction.getPosition(n),r={},s=0;s<e;s++){var a=g(o,i),h=y(o,i);if(void 0!==r[o-=Math.max(-40,Math.min(40,Math.round(a/h)))])break;r[o]=s}return o},b=m(o,u);!function(o){var a=t.direction.getPosition(n);if(void 0===i[n.id]){var h={};r(n,h),i[n.id]=h}var d=s(i[n.id]),l=d[2],c=d[3],u=o-a,f=0;u>0?f=Math.min(u,c-t.options.hierarchical.nodeSpacing):u<0&&(f=-Math.min(-u,l-t.options.hierarchical.nodeSpacing)),0!=f&&(t._shiftBlock(n.id,f),e=!0)}(b),function(i){var o=t.direction.getPosition(n),r=an(t._getSpaceAroundNode(n),2),s=r[0],a=r[1],h=i-o,d=o;h>0?d=Math.min(o+(a-t.options.hierarchical.nodeSpacing),i):h<0&&(d=Math.max(o-(s-t.options.hierarchical.nodeSpacing),i)),d!==o&&(t.direction.setPosition(n,d),e=!0)}(b=m(o,h))};!0===this.options.hierarchical.blockShifting&&(function(i){var o=t.hierarchical.getLevels();o=Nn(o).call(o);for(var n=0;n<i&&(e=!1,h(d,o,!0),!0===e);n++);}(5),function(){for(var e in t.body.nodes)Object.prototype.hasOwnProperty.call(t.body.nodes,e)&&t._centerParent(t.body.nodes[e])}()),!0===this.options.hierarchical.edgeMinimization&&function(i){var o=t.hierarchical.getLevels();o=Nn(o).call(o);for(var n=0;n<i;n++){e=!1;for(var r=0;r<o.length;r++)for(var s=o[r],a=t.hierarchical.distributionOrdering[s],h=0;h<a.length;h++)l(1e3,a[h]);if(!0!==e)break}}(20),!0===this.options.hierarchical.parentCentralization&&function(){var e=t.hierarchical.getLevels();e=Nn(e).call(e);for(var i=0;i<e.length;i++)for(var o=e[i],n=t.hierarchical.distributionOrdering[o],r=0;r<n.length;r++)t._centerParent(n[r])}(),function(){for(var e=n(),i=0,r=0;r<e.length-1;r++){i+=e[r].max-e[r+1].min+t.options.hierarchical.treeSpacing,o(r+1,i)}}()}},{key:"_getSpaceAroundNode",value:function(t,e){var i=!0;void 0===e&&(i=!1);var o=this.hierarchical.levels[t.id];if(void 0!==o){var n=this.hierarchical.distributionIndex[t.id],r=this.direction.getPosition(t),s=this.hierarchical.distributionOrdering[o],a=1e9,h=1e9;if(0!==n){var d=s[n-1];if(!0===i&&void 0===e[d.id]||!1===i)a=r-this.direction.getPosition(d)}if(n!=s.length-1){var l=s[n+1];if(!0===i&&void 0===e[l.id]||!1===i){var c=this.direction.getPosition(l);h=Math.min(h,c-r)}}return[a,h]}return[0,0]}},{key:"_centerParent",value:function(t){if(this.hierarchical.parentReference[t.id])for(var e=this.hierarchical.parentReference[t.id],i=0;i<e.length;i++){var o=e[i],n=this.body.nodes[o],r=this.hierarchical.childrenReference[o];if(void 0!==r){var s=this._getCenterPosition(r),a=this.direction.getPosition(n),h=an(this._getSpaceAroundNode(n),2),d=h[0],l=h[1],c=a-s;(c<0&&Math.abs(c)<l-this.options.hierarchical.nodeSpacing||c>0&&Math.abs(c)<d-this.options.hierarchical.nodeSpacing)&&this.direction.setPosition(n,s)}}}},{key:"_placeNodesByHierarchy",value:function(t){for(var e in this.positionedNodes={},t)if(Object.prototype.hasOwnProperty.call(t,e)){var i,o=xn(t[e]);o=this._indexArrayToNodes(o),bf(i=this.direction).call(i,o);for(var n=0,r=0;r<o.length;r++){var s=o[r];if(void 0===this.positionedNodes[s.id]){var a=this.options.hierarchical.nodeSpacing,h=a*n;n>0&&(h=this.direction.getPosition(o[r-1])+a),this.direction.setPosition(s,h,e),this._validatePositionAndContinue(s,e,h),n++}}}}},{key:"_placeBranchNodes",value:function(t,e){var i,o=this.hierarchical.childrenReference[t];if(void 0!==o){for(var n=[],r=0;r<o.length;r++)n.push(this.body.nodes[o[r]]);bf(i=this.direction).call(i,n);for(var s=0;s<n.length;s++){var a=n[s],h=this.hierarchical.levels[a.id];if(!(h>e&&void 0===this.positionedNodes[a.id]))return;var d=this.options.hierarchical.nodeSpacing,l=void 0;l=0===s?this.direction.getPosition(this.body.nodes[t]):this.direction.getPosition(n[s-1])+d,this.direction.setPosition(a,l,h),this._validatePositionAndContinue(a,h,l)}var c=this._getCenterPosition(n);this.direction.setPosition(this.body.nodes[t],c,e)}}},{key:"_validatePositionAndContinue",value:function(t,e,i){if(this.hierarchical.isTree){if(void 0!==this.lastNodeOnLevel[e]){var o=this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[e]]);if(i-o<this.options.hierarchical.nodeSpacing){var n=o+this.options.hierarchical.nodeSpacing-i,r=this._findCommonParent(this.lastNodeOnLevel[e],t.id);this._shiftBlock(r.withChild,n)}}this.lastNodeOnLevel[e]=t.id,this.positionedNodes[t.id]=!0,this._placeBranchNodes(t.id,e)}}},{key:"_indexArrayToNodes",value:function(t){for(var e=[],i=0;i<t.length;i++)e.push(this.body.nodes[t[i]]);return e}},{key:"_getDistribution",value:function(){var t,e,i={};for(t in this.body.nodes)if(Object.prototype.hasOwnProperty.call(this.body.nodes,t)){e=this.body.nodes[t];var o=void 0===this.hierarchical.levels[t]?0:this.hierarchical.levels[t];this.direction.fix(e,o),void 0===i[o]&&(i[o]={}),i[o][t]=e}return i}},{key:"_getActiveEdges",value:function(t){var e=this,i=[];return nh(t.edges,(function(t){var o;-1!==Mr(o=e.body.edgeIndices).call(o,t.id)&&i.push(t)})),i}},{key:"_getHubSizes",value:function(){var t=this,e={};nh(this.body.nodeIndices,(function(i){var o=t.body.nodes[i],n=t._getActiveEdges(o).length;e[n]=!0}));var i=[];return nh(e,(function(t){i.push(Number(t))})),bf(Cf).call(Cf,i,(function(t,e){return e-t})),i}},{key:"_determineLevelsByHubsize",value:function(){for(var t=this,e=function(e,i){t.hierarchical.levelDownstream(e,i)},i=this._getHubSizes(),o=function(o){var n=i[o];if(0===n)return"break";nh(t.body.nodeIndices,(function(i){var o=t.body.nodes[i];n===t._getActiveEdges(o).length&&t._crawlNetwork(e,i)}))},n=0;n<i.length;++n){if("break"===o(n))break}}},{key:"_determineLevelsCustomCallback",value:function(){var t=this;this._crawlNetwork((function(e,i,o){var n=t.hierarchical.levels[e.id];void 0===n&&(n=t.hierarchical.levels[e.id]=1e5);var r=(wu.cloneOptions(e,"node"),wu.cloneOptions(i,"node"),void wu.cloneOptions(o,"edge"));t.hierarchical.levels[i.id]=n+r})),this.hierarchical.setMinLevelToZero(this.body.nodes)}},{key:"_determineLevelsDirected",value:function(){var t,e=this,i=Of(t=this.body.nodeIndices).call(t,(function(t,i){return t.set(i,e.body.nodes[i]),t}),new Bd);"roots"===this.options.hierarchical.shakeTowards?this.hierarchical.levels=function(t){return jf((function(e){var i,o;return Ff(i=ar(o=e.edges).call(o,(function(e){return t.has(e.toId)}))).call(i,(function(t){return t.from===e}))}),(function(t,e){return e<t}),"to",t)}(i):this.hierarchical.levels=function(t){return jf((function(e){var i,o;return Ff(i=ar(o=e.edges).call(o,(function(e){return t.has(e.toId)}))).call(i,(function(t){return t.to===e}))}),(function(t,e){return e>t}),"from",t)}(i),this.hierarchical.setMinLevelToZero(this.body.nodes)}},{key:"_generateMap",value:function(){var t=this;this._crawlNetwork((function(e,i){t.hierarchical.levels[i.id]>t.hierarchical.levels[e.id]&&t.hierarchical.addRelation(e.id,i.id)})),this.hierarchical.checkIfTree()}},{key:"_crawlNetwork",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){},i=arguments.length>1?arguments[1]:void 0,o={},n=function i(n,r){if(void 0===o[n.id]){var s;t.hierarchical.setTreeIndex(n,r),o[n.id]=!0;for(var a=t._getActiveEdges(n),h=0;h<a.length;h++){var d=a[h];!0===d.connected&&(s=d.toId==n.id?d.from:d.to,n.id!=s.id&&(e(n,s,d),i(s,r)))}}};if(void 0===i)for(var r=0,s=0;s<this.body.nodeIndices.length;s++){var a=this.body.nodeIndices[s];if(void 0===o[a]){var h=this.body.nodes[a];n(h,r),r+=1}}else{var d=this.body.nodes[i];if(void 0===d)return void console.error("Node not found:",i);n(d)}}},{key:"_shiftBlock",value:function(t,e){var i=this,o={};!function t(n){if(!o[n]){o[n]=!0,i.direction.shift(n,e);var r=i.hierarchical.childrenReference[n];if(void 0!==r)for(var s=0;s<r.length;s++)t(r[s])}}(t)}},{key:"_findCommonParent",value:function(t,e){var i=this,o={};return function t(e,o){var n=i.hierarchical.parentReference[o];if(void 0!==n)for(var r=0;r<n.length;r++){var s=n[r];e[s]=!0,t(e,s)}}(o,t),function t(e,o){var n=i.hierarchical.parentReference[o];if(void 0!==n)for(var r=0;r<n.length;r++){var s=n[r];if(void 0!==e[s])return{foundParent:s,withChild:o};var a=t(e,s);if(null!==a.foundParent)return a}return{foundParent:null,withChild:o}}(o,e)}},{key:"setDirectionStrategy",value:function(){var t="UD"===this.options.hierarchical.direction||"DU"===this.options.hierarchical.direction;this.direction=t?new Mf(this):new Pf(this)}},{key:"_getCenterPosition",value:function(t){for(var e=1e9,i=-1e9,o=0;o<t.length;o++){var n=void 0;if(void 0!==t[o].id)n=t[o];else{var r=t[o];n=this.body.nodes[r]}var s=this.direction.getPosition(n);e=Math.min(e,s),i=Math.max(i,s)}return.5*(e+i)}}]),t}();function Wf(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return Vf(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return Vf(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function Vf(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}var qf=function(){function t(e,i,o,n){var r,s,a=this;Po(this,t),this.body=e,this.canvas=i,this.selectionHandler=o,this.interactionHandler=n,this.editMode=!1,this.manipulationDiv=void 0,this.editModeDiv=void 0,this.closeDiv=void 0,this._domEventListenerCleanupQueue=[],this.temporaryUIFunctions={},this.temporaryEventFunctions=[],this.touchTime=0,this.temporaryIds={nodes:[],edges:[]},this.guiEnabled=!1,this.inMode=!1,this.selectedControlNode=void 0,this.options={},this.defaultOptions={enabled:!1,initiallyActive:!1,addNode:!0,addEdge:!0,editNode:void 0,editEdge:!0,deleteNode:!0,deleteEdge:!0,controlNodeStyle:{shape:"dot",size:6,color:{background:"#ff0000",border:"#3c3c3c",highlight:{background:"#07f968",border:"#3c3c3c"}},borderWidth:2,borderWidthSelected:2}},ct(this.options,this.defaultOptions),this.body.emitter.on("destroy",(function(){a._clean()})),this.body.emitter.on("_dataChanged",bt(r=this._restore).call(r,this)),this.body.emitter.on("_resetData",bt(s=this._restore).call(s,this))}return Io(t,[{key:"_restore",value:function(){!1!==this.inMode&&(!0===this.options.initiallyActive?this.enableEditMode():this.disableEditMode())}},{key:"setOptions",value:function(t,e,i){void 0!==e&&(void 0!==e.locale?this.options.locale=e.locale:this.options.locale=i.locale,void 0!==e.locales?this.options.locales=e.locales:this.options.locales=i.locales),void 0!==t&&("boolean"==typeof t?this.options.enabled=t:(this.options.enabled=!0,th(this.options,t)),!0===this.options.initiallyActive&&(this.editMode=!0),this._setup())}},{key:"toggleEditMode",value:function(){!0===this.editMode?this.disableEditMode():this.enableEditMode()}},{key:"enableEditMode",value:function(){this.editMode=!0,this._clean(),!0===this.guiEnabled&&(this.manipulationDiv.style.display="block",this.closeDiv.style.display="block",this.editModeDiv.style.display="none",this.showManipulatorToolbar())}},{key:"disableEditMode",value:function(){this.editMode=!1,this._clean(),!0===this.guiEnabled&&(this.manipulationDiv.style.display="none",this.closeDiv.style.display="none",this.editModeDiv.style.display="block",this._createEditButton())}},{key:"showManipulatorToolbar",value:function(){if(this._clean(),this.manipulationDOM={},!0===this.guiEnabled){var t,e;this.editMode=!0,this.manipulationDiv.style.display="block",this.closeDiv.style.display="block";var i=this.selectionHandler.getSelectedNodeCount(),o=this.selectionHandler.getSelectedEdgeCount(),n=i+o,r=this.options.locales[this.options.locale],s=!1;!1!==this.options.addNode&&(this._createAddNodeButton(r),s=!0),!1!==this.options.addEdge&&(!0===s?this._createSeperator(1):s=!0,this._createAddEdgeButton(r)),1===i&&"function"==typeof this.options.editNode?(!0===s?this._createSeperator(2):s=!0,this._createEditNodeButton(r)):1===o&&0===i&&!1!==this.options.editEdge&&(!0===s?this._createSeperator(3):s=!0,this._createEditEdgeButton(r)),0!==n&&(i>0&&!1!==this.options.deleteNode||0===i&&!1!==this.options.deleteEdge)&&(!0===s&&this._createSeperator(4),this._createDeleteButton(r)),this._bindElementEvents(this.closeDiv,bt(t=this.toggleEditMode).call(t,this)),this._temporaryBindEvent("select",bt(e=this.showManipulatorToolbar).call(e,this))}this.body.emitter.emit("_redraw")}},{key:"addNodeMode",value:function(){var t;if(!0!==this.editMode&&this.enableEditMode(),this._clean(),this.inMode="addNode",!0===this.guiEnabled){var e,i=this.options.locales[this.options.locale];this.manipulationDOM={},this._createBackButton(i),this._createSeperator(),this._createDescription(i.addDescription||this.options.locales.en.addDescription),this._bindElementEvents(this.closeDiv,bt(e=this.toggleEditMode).call(e,this))}this._temporaryBindEvent("click",bt(t=this._performAddNode).call(t,this))}},{key:"editNode",value:function(){var t=this;!0!==this.editMode&&this.enableEditMode(),this._clean();var e=this.selectionHandler.getSelectedNodes()[0];if(void 0!==e){if(this.inMode="editNode","function"!=typeof this.options.editNode)throw new Error("No function has been configured to handle the editing of nodes.");if(!0!==e.isCluster){var i=th({},e.options,!1);if(i.x=e.x,i.y=e.y,2!==this.options.editNode.length)throw new Error("The function for edit does not support two arguments (data, callback)");this.options.editNode(i,(function(e){null!=e&&"editNode"===t.inMode&&t.body.data.nodes.getDataSet().update(e),t.showManipulatorToolbar()}))}else alert(this.options.locales[this.options.locale].editClusterError||this.options.locales.en.editClusterError)}else this.showManipulatorToolbar()}},{key:"addEdgeMode",value:function(){var t,e,i,o,n;if(!0!==this.editMode&&this.enableEditMode(),this._clean(),this.inMode="addEdge",!0===this.guiEnabled){var r,s=this.options.locales[this.options.locale];this.manipulationDOM={},this._createBackButton(s),this._createSeperator(),this._createDescription(s.edgeDescription||this.options.locales.en.edgeDescription),this._bindElementEvents(this.closeDiv,bt(r=this.toggleEditMode).call(r,this))}this._temporaryBindUI("onTouch",bt(t=this._handleConnect).call(t,this)),this._temporaryBindUI("onDragEnd",bt(e=this._finishConnect).call(e,this)),this._temporaryBindUI("onDrag",bt(i=this._dragControlNode).call(i,this)),this._temporaryBindUI("onRelease",bt(o=this._finishConnect).call(o,this)),this._temporaryBindUI("onDragStart",bt(n=this._dragStartEdge).call(n,this)),this._temporaryBindUI("onHold",(function(){}))}},{key:"editEdgeMode",value:function(){if(!0!==this.editMode&&this.enableEditMode(),this._clean(),this.inMode="editEdge","object"!==dn(this.options.editEdge)||"function"!=typeof this.options.editEdge.editWithoutDrag||(this.edgeBeingEditedId=this.selectionHandler.getSelectedEdgeIds()[0],void 0===this.edgeBeingEditedId)){if(!0===this.guiEnabled){var t,e=this.options.locales[this.options.locale];this.manipulationDOM={},this._createBackButton(e),this._createSeperator(),this._createDescription(e.editEdgeDescription||this.options.locales.en.editEdgeDescription),this._bindElementEvents(this.closeDiv,bt(t=this.toggleEditMode).call(t,this))}if(this.edgeBeingEditedId=this.selectionHandler.getSelectedEdgeIds()[0],void 0!==this.edgeBeingEditedId){var i,o,n,r,s=this.body.edges[this.edgeBeingEditedId],a=this._getNewTargetNode(s.from.x,s.from.y),h=this._getNewTargetNode(s.to.x,s.to.y);this.temporaryIds.nodes.push(a.id),this.temporaryIds.nodes.push(h.id),this.body.nodes[a.id]=a,this.body.nodeIndices.push(a.id),this.body.nodes[h.id]=h,this.body.nodeIndices.push(h.id),this._temporaryBindUI("onTouch",bt(i=this._controlNodeTouch).call(i,this)),this._temporaryBindUI("onTap",(function(){})),this._temporaryBindUI("onHold",(function(){})),this._temporaryBindUI("onDragStart",bt(o=this._controlNodeDragStart).call(o,this)),this._temporaryBindUI("onDrag",bt(n=this._controlNodeDrag).call(n,this)),this._temporaryBindUI("onDragEnd",bt(r=this._controlNodeDragEnd).call(r,this)),this._temporaryBindUI("onMouseMove",(function(){})),this._temporaryBindEvent("beforeDrawing",(function(t){var e=s.edgeType.findBorderPositions(t);!1===a.selected&&(a.x=e.from.x,a.y=e.from.y),!1===h.selected&&(h.x=e.to.x,h.y=e.to.y)})),this.body.emitter.emit("_redraw")}else this.showManipulatorToolbar()}else{var d=this.body.edges[this.edgeBeingEditedId];this._performEditEdge(d.from.id,d.to.id)}}},{key:"deleteSelected",value:function(){var t=this;!0!==this.editMode&&this.enableEditMode(),this._clean(),this.inMode="delete";var e=this.selectionHandler.getSelectedNodeIds(),i=this.selectionHandler.getSelectedEdgeIds(),o=void 0;if(e.length>0){for(var n=0;n<e.length;n++)if(!0===this.body.nodes[e[n]].isCluster)return void alert(this.options.locales[this.options.locale].deleteClusterError||this.options.locales.en.deleteClusterError);"function"==typeof this.options.deleteNode&&(o=this.options.deleteNode)}else i.length>0&&"function"==typeof this.options.deleteEdge&&(o=this.options.deleteEdge);if("function"==typeof o){var r={nodes:e,edges:i};if(2!==o.length)throw new Error("The function for delete does not support two arguments (data, callback)");o(r,(function(e){null!=e&&"delete"===t.inMode?(t.body.data.edges.getDataSet().remove(e.edges),t.body.data.nodes.getDataSet().remove(e.nodes),t.body.emitter.emit("startSimulation"),t.showManipulatorToolbar()):(t.body.emitter.emit("startSimulation"),t.showManipulatorToolbar())}))}else this.body.data.edges.getDataSet().remove(i),this.body.data.nodes.getDataSet().remove(e),this.body.emitter.emit("startSimulation"),this.showManipulatorToolbar()}},{key:"_setup",value:function(){!0===this.options.enabled?(this.guiEnabled=!0,this._createWrappers(),!1===this.editMode?this._createEditButton():this.showManipulatorToolbar()):(this._removeManipulationDOM(),this.guiEnabled=!1)}},{key:"_createWrappers",value:function(){var t,e;(void 0===this.manipulationDiv&&(this.manipulationDiv=document.createElement("div"),this.manipulationDiv.className="vis-manipulation",!0===this.editMode?this.manipulationDiv.style.display="block":this.manipulationDiv.style.display="none",this.canvas.frame.appendChild(this.manipulationDiv)),void 0===this.editModeDiv&&(this.editModeDiv=document.createElement("div"),this.editModeDiv.className="vis-edit-mode",!0===this.editMode?this.editModeDiv.style.display="none":this.editModeDiv.style.display="block",this.canvas.frame.appendChild(this.editModeDiv)),void 0===this.closeDiv)&&(this.closeDiv=document.createElement("button"),this.closeDiv.className="vis-close",this.closeDiv.setAttribute("aria-label",null!==(t=null===(e=this.options.locales[this.options.locale])||void 0===e?void 0:e.close)&&void 0!==t?t:this.options.locales.en.close),this.closeDiv.style.display=this.manipulationDiv.style.display,this.canvas.frame.appendChild(this.closeDiv))}},{key:"_getNewTargetNode",value:function(t,e){var i=th({},this.options.controlNodeStyle);i.id="targetNode"+bu(),i.hidden=!1,i.physics=!1,i.x=t,i.y=e;var o=this.body.functions.createNode(i);return o.shape.boundingBox={left:t,right:t,top:e,bottom:e},o}},{key:"_createEditButton",value:function(){var t;this._clean(),this.manipulationDOM={},Xa(this.editModeDiv);var e=this.options.locales[this.options.locale],i=this._createButton("editMode","vis-edit vis-edit-mode",e.edit||this.options.locales.en.edit);this.editModeDiv.appendChild(i),this._bindElementEvents(i,bt(t=this.toggleEditMode).call(t,this))}},{key:"_clean",value:function(){this.inMode=!1,!0===this.guiEnabled&&(Xa(this.editModeDiv),Xa(this.manipulationDiv),this._cleanupDOMEventListeners()),this._cleanupTemporaryNodesAndEdges(),this._unbindTemporaryUIs(),this._unbindTemporaryEvents(),this.body.emitter.emit("restorePhysics")}},{key:"_cleanupDOMEventListeners",value:function(){var t,e,i=Wf(qn(t=this._domEventListenerCleanupQueue).call(t,0));try{for(i.s();!(e=i.n()).done;){(0,e.value)()}}catch(t){i.e(t)}finally{i.f()}}},{key:"_removeManipulationDOM",value:function(){this._clean(),Xa(this.manipulationDiv),Xa(this.editModeDiv),Xa(this.closeDiv),this.manipulationDiv&&this.canvas.frame.removeChild(this.manipulationDiv),this.editModeDiv&&this.canvas.frame.removeChild(this.editModeDiv),this.closeDiv&&this.canvas.frame.removeChild(this.closeDiv),this.manipulationDiv=void 0,this.editModeDiv=void 0,this.closeDiv=void 0}},{key:"_createSeperator",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;this.manipulationDOM["seperatorLineDiv"+t]=document.createElement("div"),this.manipulationDOM["seperatorLineDiv"+t].className="vis-separator-line",this.manipulationDiv.appendChild(this.manipulationDOM["seperatorLineDiv"+t])}},{key:"_createAddNodeButton",value:function(t){var e,i=this._createButton("addNode","vis-add",t.addNode||this.options.locales.en.addNode);this.manipulationDiv.appendChild(i),this._bindElementEvents(i,bt(e=this.addNodeMode).call(e,this))}},{key:"_createAddEdgeButton",value:function(t){var e,i=this._createButton("addEdge","vis-connect",t.addEdge||this.options.locales.en.addEdge);this.manipulationDiv.appendChild(i),this._bindElementEvents(i,bt(e=this.addEdgeMode).call(e,this))}},{key:"_createEditNodeButton",value:function(t){var e,i=this._createButton("editNode","vis-edit",t.editNode||this.options.locales.en.editNode);this.manipulationDiv.appendChild(i),this._bindElementEvents(i,bt(e=this.editNode).call(e,this))}},{key:"_createEditEdgeButton",value:function(t){var e,i=this._createButton("editEdge","vis-edit",t.editEdge||this.options.locales.en.editEdge);this.manipulationDiv.appendChild(i),this._bindElementEvents(i,bt(e=this.editEdgeMode).call(e,this))}},{key:"_createDeleteButton",value:function(t){var e,i;i=this.options.rtl?"vis-delete-rtl":"vis-delete";var o=this._createButton("delete",i,t.del||this.options.locales.en.del);this.manipulationDiv.appendChild(o),this._bindElementEvents(o,bt(e=this.deleteSelected).call(e,this))}},{key:"_createBackButton",value:function(t){var e,i=this._createButton("back","vis-back",t.back||this.options.locales.en.back);this.manipulationDiv.appendChild(i),this._bindElementEvents(i,bt(e=this.showManipulatorToolbar).call(e,this))}},{key:"_createButton",value:function(t,e,i){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"vis-label";return this.manipulationDOM[t+"Div"]=document.createElement("button"),this.manipulationDOM[t+"Div"].className="vis-button "+e,this.manipulationDOM[t+"Label"]=document.createElement("div"),this.manipulationDOM[t+"Label"].className=o,this.manipulationDOM[t+"Label"].innerText=i,this.manipulationDOM[t+"Div"].appendChild(this.manipulationDOM[t+"Label"]),this.manipulationDOM[t+"Div"]}},{key:"_createDescription",value:function(t){this.manipulationDOM.descriptionLabel=document.createElement("div"),this.manipulationDOM.descriptionLabel.className="vis-none",this.manipulationDOM.descriptionLabel.innerText=t,this.manipulationDiv.appendChild(this.manipulationDOM.descriptionLabel)}},{key:"_temporaryBindEvent",value:function(t,e){this.temporaryEventFunctions.push({event:t,boundFunction:e}),this.body.emitter.on(t,e)}},{key:"_temporaryBindUI",value:function(t,e){if(void 0===this.body.eventListeners[t])throw new Error("This UI function does not exist. Typo? You tried: "+t+" possible are: "+Lr(xn(this.body.eventListeners)));this.temporaryUIFunctions[t]=this.body.eventListeners[t],this.body.eventListeners[t]=e}},{key:"_unbindTemporaryUIs",value:function(){for(var t in this.temporaryUIFunctions)Object.prototype.hasOwnProperty.call(this.temporaryUIFunctions,t)&&(this.body.eventListeners[t]=this.temporaryUIFunctions[t],delete this.temporaryUIFunctions[t]);this.temporaryUIFunctions={}}},{key:"_unbindTemporaryEvents",value:function(){for(var t=0;t<this.temporaryEventFunctions.length;t++){var e=this.temporaryEventFunctions[t].event,i=this.temporaryEventFunctions[t].boundFunction;this.body.emitter.off(e,i)}this.temporaryEventFunctions=[]}},{key:"_bindElementEvents",value:function(t,e){var i=new Sh(t,{});Tu(i,e),this._domEventListenerCleanupQueue.push((function(){i.destroy()}));var o=function(t){var i=t.keyCode,o=t.key;"Enter"!==o&&" "!==o&&13!==i&&32!==i||e()};t.addEventListener("keyup",o,!1),this._domEventListenerCleanupQueue.push((function(){t.removeEventListener("keyup",o,!1)}))}},{key:"_cleanupTemporaryNodesAndEdges",value:function(){for(var t=0;t<this.temporaryIds.edges.length;t++){var e;this.body.edges[this.temporaryIds.edges[t]].disconnect(),delete this.body.edges[this.temporaryIds.edges[t]];var i,o=Mr(e=this.body.edgeIndices).call(e,this.temporaryIds.edges[t]);if(-1!==o)qn(i=this.body.edgeIndices).call(i,o,1)}for(var n=0;n<this.temporaryIds.nodes.length;n++){var r;delete this.body.nodes[this.temporaryIds.nodes[n]];var s,a=Mr(r=this.body.nodeIndices).call(r,this.temporaryIds.nodes[n]);if(-1!==a)qn(s=this.body.nodeIndices).call(s,a,1)}this.temporaryIds={nodes:[],edges:[]}}},{key:"_controlNodeTouch",value:function(t){this.selectionHandler.unselectAll(),this.lastTouch=this.body.functions.getPointer(t.center),this.lastTouch.translation=ct({},this.body.view.translation)}},{key:"_controlNodeDragStart",value:function(){var t=this.lastTouch,e=this.selectionHandler._pointerToPositionObject(t),i=this.body.nodes[this.temporaryIds.nodes[0]],o=this.body.nodes[this.temporaryIds.nodes[1]],n=this.body.edges[this.edgeBeingEditedId];this.selectedControlNode=void 0;var r=i.isOverlappingWith(e),s=o.isOverlappingWith(e);!0===r?(this.selectedControlNode=i,n.edgeType.from=i):!0===s&&(this.selectedControlNode=o,n.edgeType.to=o),void 0!==this.selectedControlNode&&this.selectionHandler.selectObject(this.selectedControlNode),this.body.emitter.emit("_redraw")}},{key:"_controlNodeDrag",value:function(t){this.body.emitter.emit("disablePhysics");var e=this.body.functions.getPointer(t.center),i=this.canvas.DOMtoCanvas(e);void 0!==this.selectedControlNode?(this.selectedControlNode.x=i.x,this.selectedControlNode.y=i.y):this.interactionHandler.onDrag(t),this.body.emitter.emit("_redraw")}},{key:"_controlNodeDragEnd",value:function(t){var e=this.body.functions.getPointer(t.center),i=this.selectionHandler._pointerToPositionObject(e),o=this.body.edges[this.edgeBeingEditedId];if(void 0!==this.selectedControlNode){this.selectionHandler.unselectAll();for(var n=this.selectionHandler._getAllNodesOverlappingWith(i),r=void 0,s=n.length-1;s>=0;s--)if(n[s]!==this.selectedControlNode.id){r=this.body.nodes[n[s]];break}if(void 0!==r&&void 0!==this.selectedControlNode)if(!0===r.isCluster)alert(this.options.locales[this.options.locale].createEdgeError||this.options.locales.en.createEdgeError);else{var a=this.body.nodes[this.temporaryIds.nodes[0]];this.selectedControlNode.id===a.id?this._performEditEdge(r.id,o.to.id):this._performEditEdge(o.from.id,r.id)}else o.updateEdgeType(),this.body.emitter.emit("restorePhysics");this.body.emitter.emit("_redraw")}}},{key:"_handleConnect",value:function(t){if((new Date).valueOf()-this.touchTime>100){this.lastTouch=this.body.functions.getPointer(t.center),this.lastTouch.translation=ct({},this.body.view.translation),this.interactionHandler.drag.pointer=this.lastTouch,this.interactionHandler.drag.translation=this.lastTouch.translation;var e=this.lastTouch,i=this.selectionHandler.getNodeAt(e);if(void 0!==i)if(!0===i.isCluster)alert(this.options.locales[this.options.locale].createEdgeError||this.options.locales.en.createEdgeError);else{var o=this._getNewTargetNode(i.x,i.y);this.body.nodes[o.id]=o,this.body.nodeIndices.push(o.id);var n=this.body.functions.createEdge({id:"connectionEdge"+bu(),from:i.id,to:o.id,physics:!1,smooth:{enabled:!0,type:"continuous",roundness:.5}});this.body.edges[n.id]=n,this.body.edgeIndices.push(n.id),this.temporaryIds.nodes.push(o.id),this.temporaryIds.edges.push(n.id)}this.touchTime=(new Date).valueOf()}}},{key:"_dragControlNode",value:function(t){var e=this.body.functions.getPointer(t.center),i=this.selectionHandler._pointerToPositionObject(e),o=void 0;void 0!==this.temporaryIds.edges[0]&&(o=this.body.edges[this.temporaryIds.edges[0]].fromId);for(var n=this.selectionHandler._getAllNodesOverlappingWith(i),r=void 0,s=n.length-1;s>=0;s--){var a;if(-1===Mr(a=this.temporaryIds.nodes).call(a,n[s])){r=this.body.nodes[n[s]];break}}if(t.controlEdge={from:o,to:r?r.id:void 0},this.selectionHandler.generateClickEvent("controlNodeDragging",t,e),void 0!==this.temporaryIds.nodes[0]){var h=this.body.nodes[this.temporaryIds.nodes[0]];h.x=this.canvas._XconvertDOMtoCanvas(e.x),h.y=this.canvas._YconvertDOMtoCanvas(e.y),this.body.emitter.emit("_redraw")}else this.interactionHandler.onDrag(t)}},{key:"_finishConnect",value:function(t){var e=this.body.functions.getPointer(t.center),i=this.selectionHandler._pointerToPositionObject(e),o=void 0;void 0!==this.temporaryIds.edges[0]&&(o=this.body.edges[this.temporaryIds.edges[0]].fromId);for(var n=this.selectionHandler._getAllNodesOverlappingWith(i),r=void 0,s=n.length-1;s>=0;s--){var a;if(-1===Mr(a=this.temporaryIds.nodes).call(a,n[s])){r=this.body.nodes[n[s]];break}}this._cleanupTemporaryNodesAndEdges(),void 0!==r&&(!0===r.isCluster?alert(this.options.locales[this.options.locale].createEdgeError||this.options.locales.en.createEdgeError):void 0!==this.body.nodes[o]&&void 0!==this.body.nodes[r.id]&&this._performAddEdge(o,r.id)),t.controlEdge={from:o,to:r?r.id:void 0},this.selectionHandler.generateClickEvent("controlNodeDragEnd",t,e),this.body.emitter.emit("_redraw")}},{key:"_dragStartEdge",value:function(t){var e=this.lastTouch;this.selectionHandler.generateClickEvent("dragStart",t,e,void 0,!0)}},{key:"_performAddNode",value:function(t){var e=this,i={id:bu(),x:t.pointer.canvas.x,y:t.pointer.canvas.y,label:"new"};if("function"==typeof this.options.addNode){if(2!==this.options.addNode.length)throw this.showManipulatorToolbar(),new Error("The function for add does not support two arguments (data,callback)");this.options.addNode(i,(function(t){null!=t&&"addNode"===e.inMode&&e.body.data.nodes.getDataSet().add(t),e.showManipulatorToolbar()}))}else this.body.data.nodes.getDataSet().add(i),this.showManipulatorToolbar()}},{key:"_performAddEdge",value:function(t,e){var i=this,o={from:t,to:e};if("function"==typeof this.options.addEdge){if(2!==this.options.addEdge.length)throw new Error("The function for connect does not support two arguments (data,callback)");this.options.addEdge(o,(function(t){null!=t&&"addEdge"===i.inMode&&(i.body.data.edges.getDataSet().add(t),i.selectionHandler.unselectAll(),i.showManipulatorToolbar())}))}else this.body.data.edges.getDataSet().add(o),this.selectionHandler.unselectAll(),this.showManipulatorToolbar()}},{key:"_performEditEdge",value:function(t,e){var i=this,o={id:this.edgeBeingEditedId,from:t,to:e,label:this.body.data.edges.get(this.edgeBeingEditedId).label},n=this.options.editEdge;if("object"===dn(n)&&(n=n.editWithoutDrag),"function"==typeof n){if(2!==n.length)throw new Error("The function for edit does not support two arguments (data, callback)");n(o,(function(t){null==t||"editEdge"!==i.inMode?(i.body.edges[o.id].updateEdgeType(),i.body.emitter.emit("_redraw"),i.showManipulatorToolbar()):(i.body.data.edges.getDataSet().update(t),i.selectionHandler.unselectAll(),i.showManipulatorToolbar())}))}else this.body.data.edges.getDataSet().update(o),this.selectionHandler.unselectAll(),this.showManipulatorToolbar()}}]),t}(),Uf="string",Yf="boolean",Xf="number",Gf="array",Kf="object",$f=["arrow","bar","box","circle","crow","curve","diamond","image","inv_curve","inv_triangle","triangle","vee"],Qf={borderWidth:{number:Xf},borderWidthSelected:{number:Xf,undefined:"undefined"},brokenImage:{string:Uf,undefined:"undefined"},chosen:{label:{boolean:Yf,function:"function"},node:{boolean:Yf,function:"function"},__type__:{object:Kf,boolean:Yf}},color:{border:{string:Uf},background:{string:Uf},highlight:{border:{string:Uf},background:{string:Uf},__type__:{object:Kf,string:Uf}},hover:{border:{string:Uf},background:{string:Uf},__type__:{object:Kf,string:Uf}},__type__:{object:Kf,string:Uf}},opacity:{number:Xf,undefined:"undefined"},fixed:{x:{boolean:Yf},y:{boolean:Yf},__type__:{object:Kf,boolean:Yf}},font:{align:{string:Uf},color:{string:Uf},size:{number:Xf},face:{string:Uf},background:{string:Uf},strokeWidth:{number:Xf},strokeColor:{string:Uf},vadjust:{number:Xf},multi:{boolean:Yf,string:Uf},bold:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},boldital:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},ital:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},mono:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},__type__:{object:Kf,string:Uf}},group:{string:Uf,number:Xf,undefined:"undefined"},heightConstraint:{minimum:{number:Xf},valign:{string:Uf},__type__:{object:Kf,boolean:Yf,number:Xf}},hidden:{boolean:Yf},icon:{face:{string:Uf},code:{string:Uf},size:{number:Xf},color:{string:Uf},weight:{string:Uf,number:Xf},__type__:{object:Kf}},id:{string:Uf,number:Xf},image:{selected:{string:Uf,undefined:"undefined"},unselected:{string:Uf,undefined:"undefined"},__type__:{object:Kf,string:Uf}},imagePadding:{top:{number:Xf},right:{number:Xf},bottom:{number:Xf},left:{number:Xf},__type__:{object:Kf,number:Xf}},label:{string:Uf,undefined:"undefined"},labelHighlightBold:{boolean:Yf},level:{number:Xf,undefined:"undefined"},margin:{top:{number:Xf},right:{number:Xf},bottom:{number:Xf},left:{number:Xf},__type__:{object:Kf,number:Xf}},mass:{number:Xf},physics:{boolean:Yf},scaling:{min:{number:Xf},max:{number:Xf},label:{enabled:{boolean:Yf},min:{number:Xf},max:{number:Xf},maxVisible:{number:Xf},drawThreshold:{number:Xf},__type__:{object:Kf,boolean:Yf}},customScalingFunction:{function:"function"},__type__:{object:Kf}},shadow:{enabled:{boolean:Yf},color:{string:Uf},size:{number:Xf},x:{number:Xf},y:{number:Xf},__type__:{object:Kf,boolean:Yf}},shape:{string:["custom","ellipse","circle","database","box","text","image","circularImage","diamond","dot","star","triangle","triangleDown","square","icon","hexagon"]},ctxRenderer:{function:"function"},shapeProperties:{borderDashes:{boolean:Yf,array:Gf},borderRadius:{number:Xf},interpolation:{boolean:Yf},useImageSize:{boolean:Yf},useBorderWithImage:{boolean:Yf},coordinateOrigin:{string:["center","top-left"]},__type__:{object:Kf}},size:{number:Xf},title:{string:Uf,dom:"dom",undefined:"undefined"},value:{number:Xf,undefined:"undefined"},widthConstraint:{minimum:{number:Xf},maximum:{number:Xf},__type__:{object:Kf,boolean:Yf,number:Xf}},x:{number:Xf},y:{number:Xf},__type__:{object:Kf}},Zf={configure:{enabled:{boolean:Yf},filter:{boolean:Yf,string:Uf,array:Gf,function:"function"},container:{dom:"dom"},showButton:{boolean:Yf},__type__:{object:Kf,boolean:Yf,string:Uf,array:Gf,function:"function"}},edges:{arrows:{to:{enabled:{boolean:Yf},scaleFactor:{number:Xf},type:{string:$f},imageHeight:{number:Xf},imageWidth:{number:Xf},src:{string:Uf},__type__:{object:Kf,boolean:Yf}},middle:{enabled:{boolean:Yf},scaleFactor:{number:Xf},type:{string:$f},imageWidth:{number:Xf},imageHeight:{number:Xf},src:{string:Uf},__type__:{object:Kf,boolean:Yf}},from:{enabled:{boolean:Yf},scaleFactor:{number:Xf},type:{string:$f},imageWidth:{number:Xf},imageHeight:{number:Xf},src:{string:Uf},__type__:{object:Kf,boolean:Yf}},__type__:{string:["from","to","middle"],object:Kf}},endPointOffset:{from:{number:Xf},to:{number:Xf},__type__:{object:Kf,number:Xf}},arrowStrikethrough:{boolean:Yf},background:{enabled:{boolean:Yf},color:{string:Uf},size:{number:Xf},dashes:{boolean:Yf,array:Gf},__type__:{object:Kf,boolean:Yf}},chosen:{label:{boolean:Yf,function:"function"},edge:{boolean:Yf,function:"function"},__type__:{object:Kf,boolean:Yf}},color:{color:{string:Uf},highlight:{string:Uf},hover:{string:Uf},inherit:{string:["from","to","both"],boolean:Yf},opacity:{number:Xf},__type__:{object:Kf,string:Uf}},dashes:{boolean:Yf,array:Gf},font:{color:{string:Uf},size:{number:Xf},face:{string:Uf},background:{string:Uf},strokeWidth:{number:Xf},strokeColor:{string:Uf},align:{string:["horizontal","top","middle","bottom"]},vadjust:{number:Xf},multi:{boolean:Yf,string:Uf},bold:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},boldital:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},ital:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},mono:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},__type__:{object:Kf,string:Uf}},hidden:{boolean:Yf},hoverWidth:{function:"function",number:Xf},label:{string:Uf,undefined:"undefined"},labelHighlightBold:{boolean:Yf},length:{number:Xf,undefined:"undefined"},physics:{boolean:Yf},scaling:{min:{number:Xf},max:{number:Xf},label:{enabled:{boolean:Yf},min:{number:Xf},max:{number:Xf},maxVisible:{number:Xf},drawThreshold:{number:Xf},__type__:{object:Kf,boolean:Yf}},customScalingFunction:{function:"function"},__type__:{object:Kf}},selectionWidth:{function:"function",number:Xf},selfReferenceSize:{number:Xf},selfReference:{size:{number:Xf},angle:{number:Xf},renderBehindTheNode:{boolean:Yf},__type__:{object:Kf}},shadow:{enabled:{boolean:Yf},color:{string:Uf},size:{number:Xf},x:{number:Xf},y:{number:Xf},__type__:{object:Kf,boolean:Yf}},smooth:{enabled:{boolean:Yf},type:{string:["dynamic","continuous","discrete","diagonalCross","straightCross","horizontal","vertical","curvedCW","curvedCCW","cubicBezier"]},roundness:{number:Xf},forceDirection:{string:["horizontal","vertical","none"],boolean:Yf},__type__:{object:Kf,boolean:Yf}},title:{string:Uf,undefined:"undefined"},width:{number:Xf},widthConstraint:{maximum:{number:Xf},__type__:{object:Kf,boolean:Yf,number:Xf}},value:{number:Xf,undefined:"undefined"},__type__:{object:Kf}},groups:{useDefaultGroups:{boolean:Yf},__any__:Qf,__type__:{object:Kf}},interaction:{dragNodes:{boolean:Yf},dragView:{boolean:Yf},hideEdgesOnDrag:{boolean:Yf},hideEdgesOnZoom:{boolean:Yf},hideNodesOnDrag:{boolean:Yf},hover:{boolean:Yf},keyboard:{enabled:{boolean:Yf},speed:{x:{number:Xf},y:{number:Xf},zoom:{number:Xf},__type__:{object:Kf}},bindToWindow:{boolean:Yf},__type__:{object:Kf,boolean:Yf}},multiselect:{boolean:Yf},navigationButtons:{boolean:Yf},selectable:{boolean:Yf},selectConnectedEdges:{boolean:Yf},hoverConnectedEdges:{boolean:Yf},tooltipDelay:{number:Xf},zoomView:{boolean:Yf},zoomSpeed:{number:Xf},__type__:{object:Kf}},layout:{randomSeed:{undefined:"undefined",number:Xf,string:Uf},improvedLayout:{boolean:Yf},clusterThreshold:{number:Xf},hierarchical:{enabled:{boolean:Yf},levelSeparation:{number:Xf},nodeSpacing:{number:Xf},treeSpacing:{number:Xf},blockShifting:{boolean:Yf},edgeMinimization:{boolean:Yf},parentCentralization:{boolean:Yf},direction:{string:["UD","DU","LR","RL"]},sortMethod:{string:["hubsize","directed"]},shakeTowards:{string:["leaves","roots"]},__type__:{object:Kf,boolean:Yf}},__type__:{object:Kf}},manipulation:{enabled:{boolean:Yf},initiallyActive:{boolean:Yf},addNode:{boolean:Yf,function:"function"},addEdge:{boolean:Yf,function:"function"},editNode:{function:"function"},editEdge:{editWithoutDrag:{function:"function"},__type__:{object:Kf,boolean:Yf,function:"function"}},deleteNode:{boolean:Yf,function:"function"},deleteEdge:{boolean:Yf,function:"function"},controlNodeStyle:Qf,__type__:{object:Kf,boolean:Yf}},nodes:Qf,physics:{enabled:{boolean:Yf},barnesHut:{theta:{number:Xf},gravitationalConstant:{number:Xf},centralGravity:{number:Xf},springLength:{number:Xf},springConstant:{number:Xf},damping:{number:Xf},avoidOverlap:{number:Xf},__type__:{object:Kf}},forceAtlas2Based:{theta:{number:Xf},gravitationalConstant:{number:Xf},centralGravity:{number:Xf},springLength:{number:Xf},springConstant:{number:Xf},damping:{number:Xf},avoidOverlap:{number:Xf},__type__:{object:Kf}},repulsion:{centralGravity:{number:Xf},springLength:{number:Xf},springConstant:{number:Xf},nodeDistance:{number:Xf},damping:{number:Xf},__type__:{object:Kf}},hierarchicalRepulsion:{centralGravity:{number:Xf},springLength:{number:Xf},springConstant:{number:Xf},nodeDistance:{number:Xf},damping:{number:Xf},avoidOverlap:{number:Xf},__type__:{object:Kf}},maxVelocity:{number:Xf},minVelocity:{number:Xf},solver:{string:["barnesHut","repulsion","hierarchicalRepulsion","forceAtlas2Based"]},stabilization:{enabled:{boolean:Yf},iterations:{number:Xf},updateInterval:{number:Xf},onlyDynamicEdges:{boolean:Yf},fit:{boolean:Yf},__type__:{object:Kf,boolean:Yf}},timestep:{number:Xf},adaptiveTimestep:{boolean:Yf},wind:{x:{number:Xf},y:{number:Xf},__type__:{object:Kf}},__type__:{object:Kf,boolean:Yf}},autoResize:{boolean:Yf},clickToUse:{boolean:Yf},locale:{string:Uf},locales:{__any__:{any:"any"},__type__:{object:Kf}},height:{string:Uf},width:{string:Uf},__type__:{object:Kf}},Jf={nodes:{borderWidth:[1,0,10,1],borderWidthSelected:[2,0,10,1],color:{border:["color","#2B7CE9"],background:["color","#97C2FC"],highlight:{border:["color","#2B7CE9"],background:["color","#D2E5FF"]},hover:{border:["color","#2B7CE9"],background:["color","#D2E5FF"]}},opacity:[0,0,1,.1],fixed:{x:!1,y:!1},font:{color:["color","#343434"],size:[14,0,100,1],face:["arial","verdana","tahoma"],background:["color","none"],strokeWidth:[0,0,50,1],strokeColor:["color","#ffffff"]},hidden:!1,labelHighlightBold:!0,physics:!0,scaling:{min:[10,0,200,1],max:[30,0,200,1],label:{enabled:!1,min:[14,0,200,1],max:[30,0,200,1],maxVisible:[30,0,200,1],drawThreshold:[5,0,20,1]}},shadow:{enabled:!1,color:"rgba(0,0,0,0.5)",size:[10,0,20,1],x:[5,-30,30,1],y:[5,-30,30,1]},shape:["ellipse","box","circle","database","diamond","dot","square","star","text","triangle","triangleDown","hexagon"],shapeProperties:{borderDashes:!1,borderRadius:[6,0,20,1],interpolation:!0,useImageSize:!1},size:[25,0,200,1]},edges:{arrows:{to:{enabled:!1,scaleFactor:[1,0,3,.05],type:"arrow"},middle:{enabled:!1,scaleFactor:[1,0,3,.05],type:"arrow"},from:{enabled:!1,scaleFactor:[1,0,3,.05],type:"arrow"}},endPointOffset:{from:[0,-10,10,1],to:[0,-10,10,1]},arrowStrikethrough:!0,color:{color:["color","#848484"],highlight:["color","#848484"],hover:["color","#848484"],inherit:["from","to","both",!0,!1],opacity:[1,0,1,.05]},dashes:!1,font:{color:["color","#343434"],size:[14,0,100,1],face:["arial","verdana","tahoma"],background:["color","none"],strokeWidth:[2,0,50,1],strokeColor:["color","#ffffff"],align:["horizontal","top","middle","bottom"]},hidden:!1,hoverWidth:[1.5,0,5,.1],labelHighlightBold:!0,physics:!0,scaling:{min:[1,0,100,1],max:[15,0,100,1],label:{enabled:!0,min:[14,0,200,1],max:[30,0,200,1],maxVisible:[30,0,200,1],drawThreshold:[5,0,20,1]}},selectionWidth:[1.5,0,5,.1],selfReferenceSize:[20,0,200,1],selfReference:{size:[20,0,200,1],angle:[Math.PI/2,-6*Math.PI,6*Math.PI,Math.PI/8],renderBehindTheNode:!0},shadow:{enabled:!1,color:"rgba(0,0,0,0.5)",size:[10,0,20,1],x:[5,-30,30,1],y:[5,-30,30,1]},smooth:{enabled:!0,type:["dynamic","continuous","discrete","diagonalCross","straightCross","horizontal","vertical","curvedCW","curvedCCW","cubicBezier"],forceDirection:["horizontal","vertical","none"],roundness:[.5,0,1,.05]},width:[1,0,30,1]},layout:{hierarchical:{enabled:!1,levelSeparation:[150,20,500,5],nodeSpacing:[100,20,500,5],treeSpacing:[200,20,500,5],blockShifting:!0,edgeMinimization:!0,parentCentralization:!0,direction:["UD","DU","LR","RL"],sortMethod:["hubsize","directed"],shakeTowards:["leaves","roots"]}},interaction:{dragNodes:!0,dragView:!0,hideEdgesOnDrag:!1,hideEdgesOnZoom:!1,hideNodesOnDrag:!1,hover:!1,keyboard:{enabled:!1,speed:{x:[10,0,40,1],y:[10,0,40,1],zoom:[.02,0,.1,.005]},bindToWindow:!0},multiselect:!1,navigationButtons:!1,selectable:!0,selectConnectedEdges:!0,hoverConnectedEdges:!0,tooltipDelay:[300,0,1e3,25],zoomView:!0,zoomSpeed:[1,.1,2,.1]},manipulation:{enabled:!1,initiallyActive:!1},physics:{enabled:!0,barnesHut:{theta:[.5,.1,1,.05],gravitationalConstant:[-2e3,-3e4,0,50],centralGravity:[.3,0,10,.05],springLength:[95,0,500,5],springConstant:[.04,0,1.2,.005],damping:[.09,0,1,.01],avoidOverlap:[0,0,1,.01]},forceAtlas2Based:{theta:[.5,.1,1,.05],gravitationalConstant:[-50,-500,0,1],centralGravity:[.01,0,1,.005],springLength:[95,0,500,5],springConstant:[.08,0,1.2,.005],damping:[.4,0,1,.01],avoidOverlap:[0,0,1,.01]},repulsion:{centralGravity:[.2,0,10,.05],springLength:[200,0,500,5],springConstant:[.05,0,1.2,.005],nodeDistance:[100,0,500,5],damping:[.09,0,1,.01]},hierarchicalRepulsion:{centralGravity:[.2,0,10,.05],springLength:[100,0,500,5],springConstant:[.01,0,1.2,.005],nodeDistance:[120,0,500,5],damping:[.09,0,1,.01],avoidOverlap:[0,0,1,.01]},maxVelocity:[50,0,150,1],minVelocity:[.1,.01,.5,.01],solver:["barnesHut","forceAtlas2Based","repulsion","hierarchicalRepulsion"],timestep:[.5,.01,1,.01],wind:{x:[0,-10,10,.1],y:[0,-10,10,.1]}}},tp=function(t,e,i){var o;return!(!Jn(t).call(t,"physics")||!Jn(o=Jf.physics.solver).call(o,e)||i.physics.solver===e||"wind"===e)},ep=Object.freeze({__proto__:null,configuratorHideOption:tp,allOptions:Zf,configureOptions:Jf}),ip=function(){function t(){Po(this,t)}return Io(t,[{key:"getDistances",value:function(t,e,i){for(var o={},n=t.edges,r=0;r<e.length;r++){var s={};o[e[r]]=s;for(var a=0;a<e.length;a++)s[e[a]]=r==a?0:1e9}for(var h=0;h<i.length;h++){var d=n[i[h]];!0===d.connected&&void 0!==o[d.fromId]&&void 0!==o[d.toId]&&(o[d.fromId][d.toId]=1,o[d.toId][d.fromId]=1)}for(var l=e.length,c=0;c<l;c++)for(var u=e[c],f=o[u],p=0;p<l-1;p++)for(var v=e[p],g=o[v],y=p+1;y<l;y++){var m=e[y],b=o[m],w=Math.min(g[m],g[u]+f[m]);g[m]=w,b[v]=w}return o}}]),t}(),op=function(){function t(e,i,o){Po(this,t),this.body=e,this.springLength=i,this.springConstant=o,this.distanceSolver=new ip}return Io(t,[{key:"setOptions",value:function(t){t&&(t.springLength&&(this.springLength=t.springLength),t.springConstant&&(this.springConstant=t.springConstant))}},{key:"solve",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=this.distanceSolver.getDistances(this.body,t,e);this._createL_matrix(o),this._createK_matrix(o),this._createE_matrix();for(var n=.01,r=1,s=0,a=Math.max(1e3,Math.min(10*this.body.nodeIndices.length,6e3)),h=5,d=1e9,l=0,c=0,u=0,f=0,p=0;d>n&&s<a;){s+=1;var v=this._getHighestEnergyNode(i),g=an(v,4);for(l=g[0],d=g[1],c=g[2],u=g[3],f=d,p=0;f>r&&p<h;){p+=1,this._moveNode(l,c,u);var y=this._getEnergy(l),m=an(y,3);f=m[0],c=m[1],u=m[2]}}}},{key:"_getHighestEnergyNode",value:function(t){for(var e=this.body.nodeIndices,i=this.body.nodes,o=0,n=e[0],r=0,s=0,a=0;a<e.length;a++){var h=e[a];if(!0!==i[h].predefinedPosition||!0===i[h].isCluster&&!0===t||!0!==i[h].options.fixed.x||!0!==i[h].options.fixed.y){var d=an(this._getEnergy(h),3),l=d[0],c=d[1],u=d[2];o<l&&(o=l,n=h,r=c,s=u)}}return[n,o,r,s]}},{key:"_getEnergy",value:function(t){var e=an(this.E_sums[t],2),i=e[0],o=e[1];return[Math.sqrt(Math.pow(i,2)+Math.pow(o,2)),i,o]}},{key:"_moveNode",value:function(t,e,i){for(var o=this.body.nodeIndices,n=this.body.nodes,r=0,s=0,a=0,h=n[t].x,d=n[t].y,l=this.K_matrix[t],c=this.L_matrix[t],u=0;u<o.length;u++){var f=o[u];if(f!==t){var p=n[f].x,v=n[f].y,g=l[f],y=c[f],m=1/Math.pow(Math.pow(h-p,2)+Math.pow(d-v,2),1.5);r+=g*(1-y*Math.pow(d-v,2)*m),s+=g*(y*(h-p)*(d-v)*m),a+=g*(1-y*Math.pow(h-p,2)*m)}}var b=(e/r+i/s)/(s/r-a/s),w=-(s*b+e)/r;n[t].x+=w,n[t].y+=b,this._updateE_matrix(t)}},{key:"_createL_matrix",value:function(t){var e=this.body.nodeIndices,i=this.springLength;this.L_matrix=[];for(var o=0;o<e.length;o++){this.L_matrix[e[o]]={};for(var n=0;n<e.length;n++)this.L_matrix[e[o]][e[n]]=i*t[e[o]][e[n]]}}},{key:"_createK_matrix",value:function(t){var e=this.body.nodeIndices,i=this.springConstant;this.K_matrix=[];for(var o=0;o<e.length;o++){this.K_matrix[e[o]]={};for(var n=0;n<e.length;n++)this.K_matrix[e[o]][e[n]]=i*Math.pow(t[e[o]][e[n]],-2)}}},{key:"_createE_matrix",value:function(){var t=this.body.nodeIndices,e=this.body.nodes;this.E_matrix={},this.E_sums={};for(var i=0;i<t.length;i++)this.E_matrix[t[i]]=[];for(var o=0;o<t.length;o++){for(var n=t[o],r=e[n].x,s=e[n].y,a=0,h=0,d=o;d<t.length;d++){var l=t[d];if(l!==n){var c=e[l].x,u=e[l].y,f=1/Math.sqrt(Math.pow(r-c,2)+Math.pow(s-u,2));this.E_matrix[n][d]=[this.K_matrix[n][l]*(r-c-this.L_matrix[n][l]*(r-c)*f),this.K_matrix[n][l]*(s-u-this.L_matrix[n][l]*(s-u)*f)],this.E_matrix[l][o]=this.E_matrix[n][d],a+=this.E_matrix[n][d][0],h+=this.E_matrix[n][d][1]}}this.E_sums[n]=[a,h]}}},{key:"_updateE_matrix",value:function(t){for(var e=this.body.nodeIndices,i=this.body.nodes,o=this.E_matrix[t],n=this.K_matrix[t],r=this.L_matrix[t],s=i[t].x,a=i[t].y,h=0,d=0,l=0;l<e.length;l++){var c=e[l];if(c!==t){var u=o[l],f=u[0],p=u[1],v=i[c].x,g=i[c].y,y=1/Math.sqrt(Math.pow(s-v,2)+Math.pow(a-g,2)),m=n[c]*(s-v-r[c]*(s-v)*y),b=n[c]*(a-g-r[c]*(a-g)*y);o[l]=[m,b],h+=m,d+=b;var w=this.E_sums[c];w[0]+=m-f,w[1]+=b-p}}this.E_sums[t]=[h,d]}}]),t}();function np(t,e,i){var o,n,r,s,a=this;if(!(this instanceof np))throw new SyntaxError("Constructor must be called with the new operator");this.options={},this.defaultOptions={locale:"en",locales:ud,clickToUse:!1},ct(this.options,this.defaultOptions),this.body={container:t,nodes:{},nodeIndices:[],edges:{},edgeIndices:[],emitter:{on:bt(o=this.on).call(o,this),off:bt(n=this.off).call(n,this),emit:bt(r=this.emit).call(r,this),once:bt(s=this.once).call(s,this)},eventListeners:{onTap:function(){},onTouch:function(){},onDoubleTap:function(){},onHold:function(){},onDragStart:function(){},onDrag:function(){},onDragEnd:function(){},onMouseWheel:function(){},onPinch:function(){},onMouseMove:function(){},onRelease:function(){},onContext:function(){}},data:{nodes:null,edges:null},functions:{createNode:function(){},createEdge:function(){},getPointer:function(){}},modules:{},view:{scale:1,translation:{x:0,y:0}},selectionBox:{show:!1,position:{start:{x:0,y:0},end:{x:0,y:0}}}},this.bindEventListeners(),this.images=new pd((function(){return a.body.emitter.emit("_requestRedraw")})),this.groups=new Id,this.canvas=new Pu(this.body),this.selectionHandler=new cf(this.body,this.canvas),this.interactionHandler=new Au(this.body,this.canvas,this.selectionHandler),this.view=new Bu(this.body,this.canvas),this.renderer=new Cu(this.body,this.canvas),this.physics=new uu(this.body),this.layoutEngine=new Hf(this.body),this.clustering=new xu(this.body),this.manipulation=new qf(this.body,this.canvas,this.selectionHandler,this.interactionHandler),this.nodesHandler=new fc(this.body,this.images,this.groups,this.layoutEngine),this.edgesHandler=new tu(this.body,this.images,this.groups),this.body.modules.kamadaKawai=new op(this.body,150,.05),this.body.modules.clustering=this.clustering,this.canvas._create(),this.setOptions(i),this.setData(e)}Ct(np.prototype),np.prototype.setOptions=function(t){var e=this;if(null===t&&(t=void 0),void 0!==t){!0===Ph.validate(t,Zf)&&console.error("%cErrors have been found in the supplied options object.",Mh);if(Za(["locale","locales","clickToUse"],this.options,t),void 0!==t.locale&&(t.locale=function(t,e){try{var i=an(e.split(/[-_ /]/,2),2),o=i[0],n=i[1],r=null!=o?o.toLowerCase():null,s=null!=n?n.toUpperCase():null;if(r&&s){var a,h=r+"-"+s;if(Object.prototype.hasOwnProperty.call(t,h))return h;console.warn(pn(a="Unknown variant ".concat(s," of language ")).call(a,r,"."))}if(r){var d=r;if(Object.prototype.hasOwnProperty.call(t,d))return d;console.warn("Unknown language ".concat(r))}return console.warn("Unknown locale ".concat(e,", falling back to English.")),"en"}catch(t){return console.error(t),console.warn("Unexpected error while normalizing locale ".concat(e,", falling back to English.")),"en"}}(t.locales||this.options.locales,t.locale)),t=this.layoutEngine.setOptions(t.layout,t),this.canvas.setOptions(t),this.groups.setOptions(t.groups),this.nodesHandler.setOptions(t.nodes),this.edgesHandler.setOptions(t.edges),this.physics.setOptions(t.physics),this.manipulation.setOptions(t.manipulation,t,this.options),this.interactionHandler.setOptions(t.interaction),this.renderer.setOptions(t.interaction),this.selectionHandler.setOptions(t.interaction),void 0!==t.groups&&this.body.emitter.emit("refreshNodes"),"configure"in t&&(this.configurator||(this.configurator=new Ch(this,this.body.container,Jf,this.canvas.pixelRatio,tp)),this.configurator.setOptions(t.configure)),this.configurator&&!0===this.configurator.options.enabled){var i={nodes:{},edges:{},layout:{},interaction:{},manipulation:{},physics:{},global:{}};th(i.nodes,this.nodesHandler.options),th(i.edges,this.edgesHandler.options),th(i.layout,this.layoutEngine.options),th(i.interaction,this.selectionHandler.options),th(i.interaction,this.renderer.options),th(i.interaction,this.interactionHandler.options),th(i.manipulation,this.manipulation.options),th(i.physics,this.physics.options),th(i.global,this.canvas.options),th(i.global,this.options),this.configurator.setModuleOptions(i)}void 0!==t.clickToUse?!0===t.clickToUse?void 0===this.activator&&(this.activator=new Oh(this.canvas.frame),this.activator.on("change",(function(){e.body.emitter.emit("activate")}))):(void 0!==this.activator&&(this.activator.destroy(),delete this.activator),this.body.emitter.emit("activate")):this.body.emitter.emit("activate"),this.canvas.setSize(),this.body.emitter.emit("startSimulation")}},np.prototype._updateVisibleIndices=function(){var t=this.body.nodes,e=this.body.edges;for(var i in this.body.nodeIndices=[],this.body.edgeIndices=[],t)Object.prototype.hasOwnProperty.call(t,i)&&(this.clustering._isClusteredNode(i)||!1!==t[i].options.hidden||this.body.nodeIndices.push(t[i].id));for(var o in e)if(Object.prototype.hasOwnProperty.call(e,o)){var n=e[o],r=t[n.fromId],s=t[n.toId],a=void 0!==r&&void 0!==s;!this.clustering._isClusteredEdge(o)&&!1===n.options.hidden&&a&&!1===r.options.hidden&&!1===s.options.hidden&&this.body.edgeIndices.push(n.id)}},np.prototype.bindEventListeners=function(){var t=this;this.body.emitter.on("_dataChanged",(function(){t.edgesHandler._updateState(),t.body.emitter.emit("_dataUpdated")})),this.body.emitter.on("_dataUpdated",(function(){t.clustering._updateState(),t._updateVisibleIndices(),t._updateValueRange(t.body.nodes),t._updateValueRange(t.body.edges),t.body.emitter.emit("startSimulation"),t.body.emitter.emit("_requestRedraw")}))},np.prototype.setData=function(t){if(this.body.emitter.emit("resetPhysics"),this.body.emitter.emit("_resetData"),this.selectionHandler.unselectAll(),t&&t.dot&&(t.nodes||t.edges))throw new SyntaxError('Data must contain either parameter "dot" or  parameter pair "nodes" and "edges", but not both.');if(this.setOptions(t&&t.options),t&&t.dot){console.warn("The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);");var e=hd(t.dot);this.setData(e)}else if(t&&t.gephi){console.warn("The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);");var i=ld(t.gephi);this.setData(i)}else this.nodesHandler.setData(t&&t.nodes,!0),this.edgesHandler.setData(t&&t.edges,!0),this.body.emitter.emit("_dataChanged"),this.body.emitter.emit("_dataLoaded"),this.body.emitter.emit("initPhysics")},np.prototype.destroy=function(){for(var t in this.body.emitter.emit("destroy"),this.body.emitter.off(),this.off(),delete this.groups,delete this.canvas,delete this.selectionHandler,delete this.interactionHandler,delete this.view,delete this.renderer,delete this.physics,delete this.layoutEngine,delete this.clustering,delete this.manipulation,delete this.nodesHandler,delete this.edgesHandler,delete this.configurator,delete this.images,this.body.nodes)Object.prototype.hasOwnProperty.call(this.body.nodes,t)&&delete this.body.nodes[t];for(var e in this.body.edges)Object.prototype.hasOwnProperty.call(this.body.edges,e)&&delete this.body.edges[e];Xa(this.body.container)},np.prototype._updateValueRange=function(t){var e,i=void 0,o=void 0,n=0;for(e in t)if(Object.prototype.hasOwnProperty.call(t,e)){var r=t[e].getValue();void 0!==r&&(i=void 0===i?r:Math.min(r,i),o=void 0===o?r:Math.max(r,o),n+=r)}if(void 0!==i&&void 0!==o)for(e in t)Object.prototype.hasOwnProperty.call(t,e)&&t[e].setValueRange(i,o,n)},np.prototype.isActive=function(){return!this.activator||this.activator.active},np.prototype.setSize=function(){return this.canvas.setSize.apply(this.canvas,arguments)},np.prototype.canvasToDOM=function(){return this.canvas.canvasToDOM.apply(this.canvas,arguments)},np.prototype.DOMtoCanvas=function(){return this.canvas.DOMtoCanvas.apply(this.canvas,arguments)},np.prototype.findNode=function(){return this.clustering.findNode.apply(this.clustering,arguments)},np.prototype.isCluster=function(){return this.clustering.isCluster.apply(this.clustering,arguments)},np.prototype.openCluster=function(){return this.clustering.openCluster.apply(this.clustering,arguments)},np.prototype.cluster=function(){return this.clustering.cluster.apply(this.clustering,arguments)},np.prototype.getNodesInCluster=function(){return this.clustering.getNodesInCluster.apply(this.clustering,arguments)},np.prototype.clusterByConnection=function(){return this.clustering.clusterByConnection.apply(this.clustering,arguments)},np.prototype.clusterByHubsize=function(){return this.clustering.clusterByHubsize.apply(this.clustering,arguments)},np.prototype.updateClusteredNode=function(){return this.clustering.updateClusteredNode.apply(this.clustering,arguments)},np.prototype.getClusteredEdges=function(){return this.clustering.getClusteredEdges.apply(this.clustering,arguments)},np.prototype.getBaseEdge=function(){return this.clustering.getBaseEdge.apply(this.clustering,arguments)},np.prototype.getBaseEdges=function(){return this.clustering.getBaseEdges.apply(this.clustering,arguments)},np.prototype.updateEdge=function(){return this.clustering.updateEdge.apply(this.clustering,arguments)},np.prototype.clusterOutliers=function(){return this.clustering.clusterOutliers.apply(this.clustering,arguments)},np.prototype.getSeed=function(){return this.layoutEngine.getSeed.apply(this.layoutEngine,arguments)},np.prototype.enableEditMode=function(){return this.manipulation.enableEditMode.apply(this.manipulation,arguments)},np.prototype.disableEditMode=function(){return this.manipulation.disableEditMode.apply(this.manipulation,arguments)},np.prototype.addNodeMode=function(){return this.manipulation.addNodeMode.apply(this.manipulation,arguments)},np.prototype.editNode=function(){return this.manipulation.editNode.apply(this.manipulation,arguments)},np.prototype.editNodeMode=function(){return console.warn("Deprecated: Please use editNode instead of editNodeMode."),this.manipulation.editNode.apply(this.manipulation,arguments)},np.prototype.addEdgeMode=function(){return this.manipulation.addEdgeMode.apply(this.manipulation,arguments)},np.prototype.editEdgeMode=function(){return this.manipulation.editEdgeMode.apply(this.manipulation,arguments)},np.prototype.deleteSelected=function(){return this.manipulation.deleteSelected.apply(this.manipulation,arguments)},np.prototype.getPositions=function(){return this.nodesHandler.getPositions.apply(this.nodesHandler,arguments)},np.prototype.getPosition=function(){return this.nodesHandler.getPosition.apply(this.nodesHandler,arguments)},np.prototype.storePositions=function(){return this.nodesHandler.storePositions.apply(this.nodesHandler,arguments)},np.prototype.moveNode=function(){return this.nodesHandler.moveNode.apply(this.nodesHandler,arguments)},np.prototype.getBoundingBox=function(){return this.nodesHandler.getBoundingBox.apply(this.nodesHandler,arguments)},np.prototype.getConnectedNodes=function(t){return void 0!==this.body.nodes[t]?this.nodesHandler.getConnectedNodes.apply(this.nodesHandler,arguments):this.edgesHandler.getConnectedNodes.apply(this.edgesHandler,arguments)},np.prototype.getConnectedEdges=function(){return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler,arguments)},np.prototype.startSimulation=function(){return this.physics.startSimulation.apply(this.physics,arguments)},np.prototype.stopSimulation=function(){return this.physics.stopSimulation.apply(this.physics,arguments)},np.prototype.stabilize=function(){return this.physics.stabilize.apply(this.physics,arguments)},np.prototype.getSelection=function(){return this.selectionHandler.getSelection.apply(this.selectionHandler,arguments)},np.prototype.setSelection=function(){return this.selectionHandler.setSelection.apply(this.selectionHandler,arguments)},np.prototype.getSelectedNodes=function(){return this.selectionHandler.getSelectedNodeIds.apply(this.selectionHandler,arguments)},np.prototype.getSelectedEdges=function(){return this.selectionHandler.getSelectedEdgeIds.apply(this.selectionHandler,arguments)},np.prototype.getNodeAt=function(){var t=this.selectionHandler.getNodeAt.apply(this.selectionHandler,arguments);return void 0!==t&&void 0!==t.id?t.id:t},np.prototype.getEdgeAt=function(){var t=this.selectionHandler.getEdgeAt.apply(this.selectionHandler,arguments);return void 0!==t&&void 0!==t.id?t.id:t},np.prototype.selectNodes=function(){return this.selectionHandler.selectNodes.apply(this.selectionHandler,arguments)},np.prototype.selectEdges=function(){return this.selectionHandler.selectEdges.apply(this.selectionHandler,arguments)},np.prototype.unselectAll=function(){this.selectionHandler.unselectAll.apply(this.selectionHandler,arguments),this.selectionHandler.commitWithoutEmitting.apply(this.selectionHandler),this.redraw()},np.prototype.redraw=function(){return this.renderer.redraw.apply(this.renderer,arguments)},np.prototype.getScale=function(){return this.view.getScale.apply(this.view,arguments)},np.prototype.getViewPosition=function(){return this.view.getViewPosition.apply(this.view,arguments)},np.prototype.fit=function(){return this.view.fit.apply(this.view,arguments)},np.prototype.moveTo=function(){return this.view.moveTo.apply(this.view,arguments)},np.prototype.focus=function(){return this.view.focus.apply(this.view,arguments)},np.prototype.releaseNode=function(){return this.view.releaseNode.apply(this.view,arguments)},np.prototype.getOptionsFromConfigurator=function(){var t={};return this.configurator&&(t=this.configurator.getOptions.apply(this.configurator)),t};var rp=hd;t.Network=np,t.NetworkImages=pd,t.networkDOTParser=dd,t.networkGephiParser=cd,t.networkOptions=ep,t.parseDOTNetwork=rp,t.parseGephiNetwork=ld,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=vis-network.min.js.map


/***/ }),

/***/ "./src/blitzboard.js":
/*!***************************!*\
  !*** ./src/blitzboard.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! leaflet/dist/leaflet.css */ "./node_modules/leaflet/dist/leaflet.css");
__webpack_require__(/*! @iconify/iconify */ "./node_modules/@iconify/iconify/dist/iconify.min.js");
__webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js");
__webpack_require__(/*! ./pg_parser_browserified.js */ "./src/pg_parser_browserified.js");

let visData = __webpack_require__(/*! vis-data */ "./node_modules/vis-data/peer/umd/vis-data.min.js");
let visNetwork = __webpack_require__(/*! vis-network */ "./node_modules/vis-network/peer/umd/vis-network.min.js");

const defaultWidth = 2;

module.exports = class Blitzboard {
  static fontLoaded = false;
  static defaultConfig = {
    doubleClickWait: 200,
    node: {
      caption: ['id'],
      defaultIcon: true,
      thumbnail: 'thumbnail',
      saturation: '100%',
      brightness: '37%',
      limit: 500
    },
    edge: {
      caption: ['label'],
      saturation: '0%',
      brightness: '62%',
      limit: 10000,
      width: defaultWidth
    },
    zoom: { 
      max: 3.0,
      min: 0.25,
    },
    layoutSettings: {
      time_from: 'from',
      time_to: 'to',
      lng: 'lng',
      lat: 'lat'
    },
    style: "border: solid 1px silver; background: radial-gradient(white, silver);",
    extraOptions: {
    }
  };
  static tooltipMaxWidth = 600;
  static iconPrefixes = ['fa-solid:', 'ion:', 'bx:bx-', 'gridicons:', 'akar-icons:'];
  static iconSizeCoef = 1.5;
  static minScaleOnMap = 0.3;
  static maxScaleOnMap = 1.0;
  static mapContainerId = 'map';
  static edgeDelimiter = '-';
  static nodeTemplate = {
    id: null,
    labels: [],
    properties: {}
  }
  static edgeTemplate = {
    from: null,
    to: null,
    direction: '->',
    labels: [],
    properties: {}
  }

  static loadedIcons = {};
  
  static renderedColors = {};
  
  constructor(container) {
    this.container = container;
    this.nodeColorMap = {};
    this.expandedNodes = [];
    this.nodeMap = {};
    this.config = { node: {}, edge: {}};
    this.nodeLineMap = {};
    this.edgeMap = {};
    this.edgeLineMap = {};
    this.prevZoomPosition = null;
    this.warnings = [];
    this.elementWithTooltip = null;
    
    this.container.style.position = 'absolute';
    
    this.networkContainer = document.createElement('div');
    this.networkContainer.style = this.networkContainerOriginalStyle = `
      height: 100%;
      width: 100%;
      top: 0;
      left: 0;
      position: absolute;
      z-index: 2;
    `;
    
    this.mapContainer = document.createElement('div');
    this.mapContainer.style = `
      height: 100%;
      width: 100%;
      top: 0;
      left: 0;
      position: absolute;
      z-index: 1;
    `;
    this.map = null;
    this.tooltipDummy = document.createElement('div');
    this.tooltipDummy.style.position = 'absolute';
    this.tooltipDummy.classList.add('blitzboard-tooltip');
    this.tooltipDummy.style['background-color'] = 'rgba(0, 0, 0, 0)';
    this.tooltipDummy.style['z-index'] = '998';

    this.tooltip = document.createElement('span');
    this.tooltip.style.display = 'none';
    this.tooltip.classList.add('blitzboard-tooltiptext');
    this.tooltip.classList.add('blitzboard-tooltiptext-top');
    this.tooltip.style['z-index'] = '999';


    this.minTime = new Date(8640000000000000);
    this.maxTime = new Date(-8640000000000000);
    
    this.prevMouseEvent= null;
    this.timeScale = 1000;
    this.dragging = false;
    this.currentLatLng = null;
    this.redrawTimer = null;
    this.onNodeAdded = [];
    this.onEdgeAdded = [];
    this.onNodeFocused = [];
    this.onEdgeFocused = [];
    this.onUpdated = [];
    this.beforeParse = [];
    this.onParseError = [];
    this.maxLine = 0;
    this.scrollAnimationTimerId = null;
    this.screen = document.createElement('div');
    this.screenText = document.createElement('div');
    this.screenText.style = `
      font-size: 2rem;
      background-color: rgba(255, 255, 255, 0.5);
      padding: 10px;
    `;
    this.screen.appendChild(this.screenText);
    this.screenText.innerText = "Now loading...";
    this.screen.style = `
      background-color: rgba(0, 0, 0, 0.3);
      z-index: 3;
      position: absolute;
      height: 100%;
      width: 100%;
      display: none;
      justify-content: center;
      align-items: center;
      font-size: 2rem;
    `;
    this.doubleClickTimer = null;
    
    let blitzboard = this;

    container.appendChild(this.screen);
    container.appendChild(this.networkContainer);
    container.appendChild(this.mapContainer);
    document.body.appendChild(this.tooltipDummy);
    this.tooltipDummy.appendChild(this.tooltip);
    this.tooltip.addEventListener('mouseleave', (e) => {
      if(e.relatedTarget !== blitzboard.network.canvas.getContext().canvas)
        blitzboard.hideTooltip();
    });

    this.container.addEventListener('wheel', (e) => {
      if(blitzboard.config.layout === 'map')
      {
        if((e.deltaY < 0 && blitzboard.map._zoom < blitzboard.map.getMaxZoom()) ||
          (e.deltaY > 0 && blitzboard.map._zoom > blitzboard.map.getMinZoom()) ) {
          if(!blitzboard.currentLatLng) {
            blitzboard.currentLatLng = blitzboard.map.mouseEventToLatLng(e);
          }
          blitzboard.map.setZoomAround(blitzboard.currentLatLng, blitzboard.map._zoom - e.deltaY * 0.03, {animate: false});
        }
        let newScale = blitzboard.map._zoom / 12 + 0.4;
        newScale = Math.min(Blitzboard.maxScaleOnMap, Math.max(newScale, Blitzboard.minScaleOnMap));
        setTimeout( () => {
          blitzboard.network.moveTo({scale: newScale});
          blitzboard.updateNodeLocationOnMap();
        }, 10);
        blitzboard.map.invalidateSize();
        e.preventDefault();
        e.stopPropagation(); // Inhibit zoom on vis-network
      }
    }, true);
    
    this.container.addEventListener('mouseout', (e) => {
      blitzboard.dragging = false;
    }, true);

    this.container.addEventListener('mouseup', (e) => {
      blitzboard.dragging = false;
    }, true);
    
    this.container.addEventListener('mousemove', (e) => {
      if(blitzboard.dragging && blitzboard.config.layout === 'map' && blitzboard.prevMouseEvent) {
        blitzboard.map.panBy([blitzboard.prevMouseEvent.x - e.x, blitzboard.prevMouseEvent.y - e.y], {animate: false});
      }
      if(blitzboard.elementWithTooltip?.edge) {
        this.updateTooltipLocation();
      }
      blitzboard.prevMouseEvent = e;
      blitzboard.currentLatLng = null;
    }, true);

    this.container.addEventListener('dblclick', (e) => {
      if(blitzboard.config.layout === 'map') {
        blitzboard.map.panTo(blitzboard.map.mouseEventToLatLng(e));
      }
    }, true);

    this.container.addEventListener('mousedown', (e) => {
      blitzboard.dragging = true;
      blitzboard.prevMouseEvent = e;
    }, true);
    
    this.applyDynamicStyle(`
      .blitzboard-tooltip {
        position: absolute;
        display: inline-block;
        border-bottom: 1px dotted black;
      }
      
      .blitzboard-tooltip .blitzboard-tooltiptext {
        max-width: ${Blitzboard.tooltipMaxWidth}px;
        min-width: 200px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        text-align: center;
        border-radius: 6px;
        padding: 5px;
        position: absolute;
        z-index: 1;
        opacity: 1;
        transition: opacity 0.3s;
      }
      
      .blitzboard-tooltip .blitzboard-tooltiptext-top {
        bottom: 125%;
        left: 50%;
        margin-left: -6px;
      }
      
      .blitzboard-tooltip .blitzboard-tooltiptext-bottom {
        bottom: 100%;
        left: 50%;
        margin-left: -6px;
      }
      
      
      .blitzboard-tooltip .blitzboard-tooltiptext-left {
        top: 50%;
        left: 0%;
      }
      
      .blitzboard-tooltip .blitzboard-tooltiptext-right {
        top: -50%;
        left: 100%;
      }
      
      
      .blitzboard-tooltip .blitzboard-tooltiptext::after {
        content: "";
        position: absolute;
        border-width: 6px;
        border-style: solid;
      }
      
      .blitzboard-tooltip .blitzboard-tooltiptext-bottom::after {
        top: -12px;
        left: 50%;
        border-color: transparent transparent #555 transparent;
      }
      
      .blitzboard-tooltip .blitzboard-tooltiptext-left::after {
        top: 50%;
        left: 100%;
        border-color: transparent transparent transparent #555;
      }
      
      .blitzboard-tooltip .blitzboard-tooltiptext-top::after {
        top: 100%;
        left: 50%;
        border-color: #555 transparent transparent transparent;
      }

      .blitzboard-tooltip .blitzboard-tooltiptext-right::after {
        top: 50%;
        left: -12px;
        border-color: transparent #555 transparent transparent;
      }
      
      .blitzboard-tooltiptext th, .blitzboard-tooltiptext td {
        text-align: left;
        padding-left: 10px;
      }
      
      .blitzboard-tooltip a {
        color: #88BBFF;
      }
    `);
  }

  static blitzProxy = {
    get: function(target, prop, receiver) {
      if (prop === 'label') {
        return target.labels[0];
      }
      if (!(prop in target) && prop in target.properties) {
        return target.properties[prop][0]; 
      }
      return Reflect.get(target, prop, receiver);
    }
  }

  applyDynamicStyle(css) {
    var styleTag = document.createElement('style');
    var dynamicStyleCss = document.createTextNode(css);
    styleTag.appendChild(dynamicStyleCss);
    var header = document.getElementsByTagName('head')[0];
    header.appendChild(styleTag);
  };

  getHexColors(colorStr) {
    let computed = Blitzboard.renderedColors[colorStr];
    if(computed) {
      return computed;
    }
    let a = document.createElement('div');
    a.style.color = colorStr;
    let colors = window.getComputedStyle( document.body.appendChild(a) ).color.match(/\d+/g).map(function(a){ return parseInt(a,10); });
    document.body.removeChild(a);
    Blitzboard.renderedColors[colorStr] = colors;
    return colors;
  }
  
  hasNode(node_id) {
    return !!this.nodeMap[node_id];
  }
  
  hasEdge(from, to, label = null) {
    for(let edge of this.graph.edges) {
      if(edge.from === from && edge.to === to && (!label || edge.labels.includes(label)))
        return true;
    }
    return false;
  }
  
  getAllNodes(label = null) {
    if(label)
      return this.graph.nodes.filter(node => node.labels.includes(label)).map(node => this.getNode(node.id));
    else
      return this.graph.nodes.map(node => this.getNode(node.id));
  }

  getNode(node_id) {
    return new Proxy(this.nodeMap[node_id], Blitzboard.blitzProxy);
  }
  
  getEdge(edge_id) {
    return new Proxy(this.edgeMap[edge_id], Blitzboard.blitzProxy);
  }
  
  calcNodePosition(pgNode) {
    let x, y, fixed, width;
    if(this.config.layout === 'timeline' && this.timeInterval > 0) {
      x = null;
      fixed = false;
      let fromProp = this.config.layoutSettings.time_from;
      let toProp = this.config.layoutSettings.time_to;
      let from = this.maxTime;
      let to = this.minTime;

      for (let prop of Object.keys(pgNode.properties)) {
        if (prop === fromProp || prop === toProp) {
          from = new Date(Math.min(from, new Date(pgNode.properties[prop][0])));
          to = new Date(Math.max(to, new Date(pgNode.properties[prop][0])));
        }
      }
    
      if(from <= to) {
        fixed = true;
        let fromPosition = this.timeScale * (from.getTime() - this.minTime.getTime()) * 1.0 / this.timeInterval - this.timeScale * 0.5;
        let toPosition = this.timeScale * (to.getTime() - this.minTime.getTime()) * 1.0 / this.timeInterval - this.timeScale * 0.5;
        x = (fromPosition + toPosition) / 2;
        if(from === to) {
          width = fromPosition - toPosition;
        } else {
          width = 25;
        }
      } else {
        x = 0;
      }
    }
    else {
      if(this.config.layout == 'custom') {
        if (pgNode.properties[this.config.layoutSettings.x] || pgNode.properties[this.config.layoutSettings.y]) {
          x = parseInt(pgNode.properties[this.config.layoutSettings.x][0]);
          y = parseInt(pgNode.properties[this.config.layoutSettings.y][0]);
          fixed = true;
        }
      } else {
        x = null;
        y = null;
        fixed = this.config.layout === 'hierarchical';
        width = null;
      }
    }
    
    return {x, y, fixed, width};
  }

  retrieveThumbnailUrl(node) {
    if(this.config.node.thumbnail) {
      return node.properties[this.config.node.thumbnail]?.[0];
    }
    return null;
  }
  
  tooltipPosition() {
    if(window.innerWidth < window.innerHeight) {
      return this.prevMouseEvent.clientY < window.innerHeight / 2 ? 'bottom' : 'top';
    }
    return this.prevMouseEvent.clientX < window.innerWidth / 2 ? 'right' : 'left';
  }
  
  updateTooltipLocation() {
    if(!this.elementWithTooltip)
      return;
    let position, offset = 10;
    if(this.elementWithTooltip.node) {
      position = this.network.canvasToDOM(this.network.getPosition(this.elementWithTooltip.node.id));
      let clientRect = this.container.getClientRects()[0];
      position.x += clientRect.x;
      position.y += clientRect.y;
      offset += this.elementWithTooltip.node.size * this.network.getScale();
    }
    else {
      position = {
        x: this.prevMouseEvent.clientX,
        y: this.prevMouseEvent.clientY
      };
    }
    position.x += window.scrollX;
    position.y += window.scrollY;
    
    switch(this.tooltipPosition()) {
      case 'left':
        this.tooltip.classList.add('blitzboard-tooltiptext-left');
        this.tooltip.classList.remove('blitzboard-tooltiptext-top');
        this.tooltip.classList.remove('blitzboard-tooltiptext-right');
        this.tooltip.classList.remove('blitzboard-tooltiptext-bottom');
        position.x -= offset;
        position.x -= this.tooltip.clientWidth;
        position.y -= this.tooltip.clientHeight / 2;
        break;
      case 'top':
        this.tooltip.classList.remove('blitzboard-tooltiptext-left');
        this.tooltip.classList.add('blitzboard-tooltiptext-top');
        this.tooltip.classList.remove('blitzboard-tooltiptext-right');
        this.tooltip.classList.remove('blitzboard-tooltiptext-bottom');
        position.x -= this.tooltip.clientWidth / 2;
        position.y -= offset;
        break;
      case 'right':
        this.tooltip.classList.remove('blitzboard-tooltiptext-left');
        this.tooltip.classList.remove('blitzboard-tooltiptext-top');
        this.tooltip.classList.add('blitzboard-tooltiptext-right');
        this.tooltip.classList.remove('blitzboard-tooltiptext-bottom');
        position.x += offset;
        position.y -= this.tooltip.clientHeight / 2;
        break;
      case 'bottom':
        this.tooltip.classList.remove('blitzboard-tooltiptext-left');
        this.tooltip.classList.remove('blitzboard-tooltiptext-top');
        this.tooltip.classList.remove('blitzboard-tooltiptext-right');
        this.tooltip.classList.add('blitzboard-tooltiptext-bottom');
        position.x -= this.tooltip.clientWidth / 2;
        position.y += this.tooltip.clientHeight;
        position.y += offset;
        break;
    }

    this.tooltipDummy.style.left = `${position.x}px`;
    this.tooltipDummy.style.top = `${position.y}px`;
  }
  
  showTooltip() {
    this.updateTooltipLocation();
    let title = this.elementWithTooltip.node ? this.elementWithTooltip.node._title : this.elementWithTooltip.edge._title;
    if(!title)
      return;
    
    this.tooltip.innerHTML = title;
    this.tooltip.style.display = 'block';
  }
  
  hideTooltip() {
    if(this.elementWithTooltip) {
      this.tooltip.style.display = 'none';
      this.elementWithTooltip = null;
    }
  }

  toVisNode(pgNode, props, extraOptions = null) {
    const group = [...pgNode.labels].sort().join('_');
    if(!this.nodeColorMap[group]) {
      this.nodeColorMap[group] = getRandomColor(group, this.config.node.saturation, this.config.node.brightness);
    }
    
    let x, y, fixed, width;
    ({x, y, fixed, width} = this.calcNodePosition(pgNode));

    let url = retrieveHttpUrl(pgNode);
    let thumbnailUrl = this.retrieveThumbnailUrl(pgNode);
    let expanded = this.expandedNodes.includes(pgNode.id);

    let degree =  pgNode.properties['degree'];
    let blitzboard = this;
    if(degree !== undefined) {
      degree = degree[0];
    } else {
      degree = 2; // assume degree to be two (default)
    }

    let color = this.retrieveConfigProp(pgNode, 'node', 'color');
    let opacity = parseFloat(this.retrieveConfigProp(pgNode, 'node', 'opacity'));
    let size  = parseFloat(this.retrieveConfigProp(pgNode, 'node', 'size'));
    let tooltip  = this.retrieveConfigProp(pgNode, 'node', 'title');

    color = color || this.nodeColorMap[group];
    
    if(opacity < 1) {
      let rgb = this.getHexColors(color);
      color = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${opacity})`;
    }

    let attrs = {
      id: pgNode.id,
      color: color,
      label: createLabelText(pgNode, props),
      shape: 'dot',
      size: size || 25,
      degree: degree,
      _title: tooltip || this.createTitle(pgNode),
      fixed: {
        x: fixed,
        y: this.config.layout === 'timeline' ? false : fixed
      },
      borderWidth: url ? 3 : 1,
      url: url,
      x: x,
      y: y,
      chosen: this.retrieveConfigProp(pgNode, 'node', 'chosen'),
      font: {
        color: url ? 'blue' : 'black',
        strokeWidth: 2,
      },
      fixedByTime: fixed
    };
    
    let otherProps = this.retrieveConfigPropAll(pgNode,
      'node', ['color', 'size', 'opacity', 'title']);
    
    for(let key of Object.keys(otherProps)) {
      attrs[key] = otherProps[key] || attrs[key];
    }
    
    function iconRegisterer(name) {
      return (icons) => {
        if (icons.length > 0) {
          let icon = null;
          if(icons.length > 1) {
            // Find icon with the highest priority 
            for (let prefix of Blitzboard.iconPrefixes) {
              for (let i of icons) {
                if (`${i.prefix}:${i.name}`.startsWith(prefix)) {
                  icon = i; 
                  break;
                }
              }
              if (icon) {
                break;
              }
            }
          }
          icon = icon || icons[0];
          let size = attrs.size * Blitzboard.iconSizeCoef;
          let svg = Iconify.renderSVG(`${icon.prefix}:${icon.name}`, {
            width: size,
            height: size
          });
          let img = new Image();
          svg.querySelectorAll("path,circle,ellipse,rect").forEach((path) => {
            path.style.fill = "white";
            path.style.stroke = "white";
          });
          img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg.outerHTML);
          Blitzboard.loadedIcons[name] = img;
          if(blitzboard) {
            if (blitzboard.redrawTimer) {
              clearTimeout(blitzboard.redrawTimer);
            }
            blitzboard.redrawTimer = setTimeout(() => {  // Add delay to avoid redraw too ofen
              blitzboard.network.redraw();
            }, 1000);
          }
        }
      };
    }

    for(let label of pgNode.labels) {
      let icon;
      if (icon = this.config.node.icon?.[label]) {
        if(icon.includes(':')) { // For icons in iconify
          Iconify.loadIcons([icon], iconRegisterer(icon));
          attrs['customIcon'] = {
            name: icon
          };
        } else { // For icon codes in Ionicons (to be backward compatible)
          let code = String.fromCharCode(parseInt(icon, 16));
          attrs['customIcon'] = {
            face: 'Ionicons',
            size: attrs.size * 1.5,
            code: code,
            color: 'white'
          };
          break;
        }
      }
    }


    if(!attrs['customIcon'] && this.config.node.defaultIcon) {
      for(let label of pgNode.labels) {
        let lowerLabel = label.toLowerCase();
        if (!Blitzboard.loadedIcons[lowerLabel]) {
          Blitzboard.loadedIcons[lowerLabel] = 'retrieving...'; // Just a placeholder to avoid duplicate fetching
          Iconify.loadIcons(
            Blitzboard.iconPrefixes.map((prefix) => prefix + lowerLabel),
            iconRegisterer(lowerLabel)
          );
        }
      }
    }
    
    if(thumbnailUrl) {
      attrs['shape'] = 'image';
      attrs['image'] = thumbnailUrl;
    }
    attrs = Object.assign(attrs, extraOptions);
    return attrs;
  }
  
  retrieveProp(pgElem, config, loadFunction = true) {
    if((typeof config) === 'function' && loadFunction) {
      return config(new Proxy(pgElem, Blitzboard.blitzProxy));
    } else if((typeof config) === 'string' && config.startsWith('@')) {
      return pgElem.properties[config.substr(1)]?.[0];
    }
    return config; // return as constant
  }
  
  retrieveConfigProp(pgElem, type, propName, loadFunction = true) {
    const labels = pgElem.labels.join('_');
    let propConfig = this.config?.[type][propName];
    if ((typeof propConfig) === 'object') {
      return this.retrieveProp(pgElem, propConfig[labels], loadFunction)
    }
    return this.retrieveProp(pgElem, propConfig, loadFunction);
  }

  retrieveConfigPropAll(pgElem, type, except) {
    let keys = Object.keys(this.config?.[type]);
    let props = {};
    for(let key of keys) {
      if(except.includes(key))
        continue;
      // TODO: How can we allow functions for arbitrary config?
      props[key] = this.retrieveConfigProp(pgElem, type, key, false);
    }
    return props;
  }
  
  toVisEdge(pgEdge, props = this.config.edge.caption, id) {
    const edgeLabel = pgEdge.labels.join('_');
    if (!this.edgeColorMap[edgeLabel]) {
      this.edgeColorMap[edgeLabel] = getRandomColor(edgeLabel, this.config.edge.saturation || '0%', this.config.edge.brightness || '30%');
    }
    let color = this.retrieveConfigProp(pgEdge, 'edge', 'color');
    let opacity = parseFloat(this.retrieveConfigProp(pgEdge, 'edge', 'opacity')) || 1;
    let width = parseFloat(this.retrieveConfigProp(pgEdge, 'edge','width'));
    let tooltip  = this.retrieveConfigProp(pgEdge, 'edge', 'title');

    color = color || this.edgeColorMap[edgeLabel];

    if(opacity < 1) {
      let rgb = this.getHexColors(color);
      color = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${opacity})`;
    }
    
    let attrs = {
      id: id,
      from: pgEdge.from,
      to: pgEdge.to,
      color: color,
      label: createLabelText(pgEdge, props),
      _title: tooltip || this.createTitle(pgEdge),
      remoteId: id,
      width: width || defaultWidth,
      hoverWidth: 0.5,
      smooth: this.map ? false : { roundness: 1 },
      chosen: this.retrieveConfigProp(pgEdge, 'edge', 'chosen'),
      arrows: {
        to: {
          enabled: pgEdge.direction == '->' || pgEdge.undirected === 'false'
        },
      }
    };

    let otherProps = this.retrieveConfigPropAll(pgEdge,
      'edge', ['color', 'opacity', 'width', 'title']);

    for(let key of Object.keys(otherProps)) {
      attrs[key] = otherProps[key] || attrs[key];
    }
    
    return attrs;
  }
  
  includesNode(node) {
    return this.graph.nodes.filter(e => e.id === node.id).length > 0;
  }
  
  addNode(node, update = true) {
    this.addNodes([node], update);
  }
  
  addNodes(nodes, update = true) {
    let newNodes;
    if (typeof nodes === 'string' || nodes instanceof String) {
      let pg = this.tryPgParse(nodes);
      newNodes = pg.nodes;
    } else {
      newNodes = nodes;
    }
    newNodes = newNodes.filter(node => !this.includesNode(node)).map((node) => {
      let mapped = deepMerge(Blitzboard.nodeTemplate, node);
      ++this.maxLine;
      mapped.location = {
        start: {
          line: this.maxLine,
          column: 0,
        },
        end: {
          line: this.maxLine + 1,
          column: 0,
        }
      }
      return mapped;
    });
    this.graph.nodes = this.graph.nodes.concat(newNodes);
    for(let callback of this.onNodeAdded) {
      // TODO: The argument should be proxy instead of plain objects
      callback(newNodes);
    }
    if(update)
      this.update();
  }
  
  addEdge(edge, update = true) {
    this.addEdges([edge], update);
  }
  
  highlightNodePath(nodes) {
    let nodeIds = nodes;
    if(nodes.length > 0 && typeof nodes[0] !== 'string') {
      nodeIds = nodes.map((n) => n.id);
    }
    let edgeIds = [];
    for(let i = 0; i < nodeIds.length - 1; ++i) {
      edgeIds.push(`${nodeIds[i]}${Blitzboard.edgeDelimiter}${nodeIds[i + 1]}`);
    }
    this.network.selectEdges(edgeIds);
  }

  addEdges(edges, update = true) {
    let newEdges;
    if (typeof edges === 'string' || edges instanceof String) {
      let pg = this.tryPgParse(edges);
      newEdges = pg.edges
    } else {
      newEdges = edges
    }
    newEdges = newEdges.map((edge) => {
      let mapped = deepMerge(Blitzboard.edgeTemplate, edge);
      ++this.maxLine;
      mapped.location = {
        start: {
          line: this.maxLine,
          column: 0, 
        },
        end: {
          line: this.maxLine + 1,
          column: 0,
        }
      }
      return mapped;
    });
    this.graph.edges = this.graph.edges.concat(newEdges);
    for(let callback of this.onEdgeAdded) {
      // TODO: The argument should be proxy instead of plain objects
      callback(newEdges);
    }
    if(update)
      this.update();
  }


  tryPgParse(pg) {
    for(let callback of this.beforeParse) {
      callback();
    }
    try {
      return pgParser.parse(pg);
    } catch(e) {
      for(let callback of this.onParseError) {
        callback(e);
      }
      console.log(e);
      return null;
    }
  }

  createTitle(elem) {
    let flattend_props = Object.entries(elem.properties).reduce((acc, prop) =>
      acc.concat(`<tr valign="top"><td>${prop[0]}</td><td> ${convertToHyperLinkIfURL(prop[1])}</td></tr>`), []);
    if (!elem.from) // for nodes
    {
      let idText = `<tr><td><b>${elem.id}</b></td><td> <b>${wrapText(elem.labels.map((l) => ':' + l).join(' '), true)}</b></td></tr>`;
      flattend_props.splice(0, 0, idText);
    } else if(elem.labels.length > 0) {
      let idText = `<tr><td><b>${wrapText(elem.labels.map((l) => ':' + l).join(' '), true)} </b></td><td></td></tr>`;
      flattend_props.splice(0, 0, idText);
    }
    if (flattend_props.length === 0) {
      return null;
    }
    return `<table style='fixed'>${flattend_props.join('')}</table>`;
  }



  setGraph(input, update = true) {
    this.nodeColorMap = {};
    this.edgeColorMap = {};
    this.prevMouseEvent = null;
    this.dragging = false;
    let newPg;
    if (!input) {
      newPg = this.tryPgParse(''); // Set empty pg
    }
    else if (typeof input === 'string' || input instanceof String) {
      try {
        newPg = JSON.parse(input);
      } catch (err) {
        if (err instanceof SyntaxError)
          newPg = this.tryPgParse(input);
        else
          throw err;
      }
    } else {
      newPg = input;
    }
    if (newPg === null || newPg === undefined)
      return;
    this.graph = newPg;

    if(update)
      this.update();
  }



  setConfig(config, update = true) {
    this.config = deepMerge(Blitzboard.defaultConfig, config);
    if(config.layout === 'hierarchical') {
      // Remove redundant settings when layout is hierarchical
      this.config.layoutSettings = config.layoutSettings;
    }
    if(update)
      this.update(false);
  }
  
  validateGraph() {
    // If duplication of nodes exist, raise error 
    function nonuniqueNodes(nodes) {
      let nonunique = new Set();
      let nodeMap = {} // id -> node
      for(let node of nodes) {
        if(nodeMap[node.id]) {
          nonunique.add(nodeMap[node.id]);
          nonunique.add(node);
        }
        nodeMap[node.id] = node;
      }
      return [...nonunique];
    }

    let nonunique = nonuniqueNodes(this.graph.nodes);
    if(nonunique.length > 0) {
      throw new DuplicateNodeError(nonunique);
    }
    
    if(this.graph.nodes.length >= this.config.node.limit) {
      throw new Error(`The number of nodes exceeds the current limit: ${this.config.node.limit}. ` +
        `You can change it via node.limit in your config.`);
    }

    if(this.graph.edges.length >= this.config.edge.limit) {
      throw new Error(`The number of edges exceeds the current limit: ${this.config.edge.limit}. ` +
        `You can change it via edge.limit in your config.`);
    }

    // If edge refers to undefined nodes, create warnings
    for(let edge of this.graph.edges) {
      if(!this.nodeMap[edge.from]) {
        this.warnings.push({
          location: edge.location,
          message: `Source node is undefined: ${edge.from}`
        });
      }
      if(!this.nodeMap[edge.to]) {
        this.warnings.push({
          location: edge.location,
          message: `Target node is undefined: ${edge.to}`
        });
      }
    }
  }
  
  update(applyDiff = true) {
    let blitzboard = this;
    this.warnings = [];
    applyDiff = applyDiff && this.nodeDataSet && this.edgeDataSet;
    
    if(this.config.style && this.config.layout !== 'map') {
      this.networkContainer.style = this.networkContainerOriginalStyle + ' ' + this.config.style;
    }

    if(applyDiff) {
      let nodesToDelete = new Set(Object.keys(this.nodeMap));
      let newEdgeMap = {};

      this.nodeLineMap = {};
      this.edgeLineMap = {};
      this.maxLine = 0;
      this.graph.nodes.forEach(node => {
        let existingNode = this.nodeMap[node.id];
        if(existingNode) {
          if(!nodeEquals(node, existingNode)) {
            this.nodeDataSet.remove(existingNode);
            let visNode = this.toVisNode(node, this.config.node.caption);
            this.nodeDataSet.update(visNode);
          }
        } else {
          let visNode = this.toVisNode(node, this.config.node.caption);
          this.nodeDataSet.add(visNode);
        }
        this.nodeMap[node.id] = node;
        nodesToDelete.delete(node.id);
        if(node.location) {
          for (let i = node.location.start.line; i <= node.location.end.line; i++) {
            if (i < node.location.end.line || node.location.end.column > 1)
              this.nodeLineMap[i] = node;
          }
          this.maxLine = Math.max(this.maxLine, node.location.end.line);
        }
      });

      this.graph.edges.forEach(edge => {
        let id = this.toNodePairString(edge);
        while(newEdgeMap[id]) {
          id += '_';
        }
        edge.id = id;
        newEdgeMap[id] = edge;
        let visEdge = this.toVisEdge(edge, this.config.edge.caption, id);
        this.edgeDataSet.update(visEdge);
        if(edge.location) {
          for (let i = edge.location.start.line; i <= edge.location.end.line; i++) {
            if (i < edge.location.end.line || edge.location.end.column > 1)
              this.edgeLineMap[i] = visEdge;
          }
          this.maxLine = Math.max(this.maxLine, edge.location.end.line);
        }
      });

      nodesToDelete.forEach((nodeId) => {
        delete this.nodeMap[nodeId];
      });
      this.nodeDataSet.remove([...nodesToDelete]);

      let edgesToDelete = [];
      for(let edgeId of Object.keys(this.edgeMap)) {
        if(!newEdgeMap[edgeId]) {
          edgesToDelete.push(edgeId);
        }
      }
      this.edgeDataSet.remove(edgesToDelete);
      this.edgeMap = newEdgeMap;
      if(this.map) {
        blitzboard.updateNodeLocationOnMap();
      }
      if(this.config.layout === 'timeline') {
        blitzboard.updateNodeLocationOnTimeLine();
      }
    }
    
    this.prevZoomPosition = null;
    
    this.minTime = new Date(8640000000000000);
    this.maxTime = new Date(-8640000000000000);
    
    if(this.config.layout === 'timeline') {
      let fromProp = this.config.layoutSettings.time_from;
      let toProp = this.config.layoutSettings.time_to;
      
      this.graph.nodes.forEach(node => {
        for (let prop of Object.keys(node.properties)) {
          if (prop === fromProp || prop === toProp) {
            this.minTime = new Date(Math.min(this.minTime, new Date(node.properties[prop][0])));
            this.maxTime = new Date(Math.max(this.maxTime, new Date(node.properties[prop][0])));
          }
        }
      });
      this.timeInterval = this.maxTime - this.minTime;
    }


    if(applyDiff) {
      this.validateGraph();

      for(let callback of this.onUpdated) {
        callback();
      }
      return;
    }

    this.nodeProps = new Set(['id', 'label']);
    this.edgeProps = new Set(['label']);
    this.graph.nodes.forEach((node) => {
      this.nodeMap[node.id] = node;
      if(node.location) {
        for (let i = node.location.start.line; i <= node.location.end.line; i++)
          if (i < node.location.end.line || node.location.end.column > 1)
            this.nodeLineMap[i] = node;
      }
      Object.keys(node.properties).filter((prop) => prop != 'degree').forEach(this.nodeProps.add, this.nodeProps);
    });
    this.graph.edges.forEach((edge) => {
      Object.keys(edge.properties).forEach(this.edgeProps.add, this.edgeProps);
    });

    this.validateGraph();


    let defaultNodeProps = this.config.node.caption;
    let defaultEdgeProps = this.config.edge.caption;

    this.nodeDataSet = new visData.DataSet();
    this.nodeDataSet.add(this.graph.nodes.map((node) => {
      return this.toVisNode(node, defaultNodeProps);
    }));
    
    this.edgeMap = {};
    this.edgeDataSet = new visData.DataSet(this.graph.edges.map((edge) => {
      let id = this.toNodePairString(edge);
      while(this.edgeMap[id]) {
        id += '_';
      }
      let visEdge = this.toVisEdge(edge, defaultEdgeProps, id);
      this.edgeMap[visEdge.id] = edge;
      if(edge.location) {
        for (let i = edge.location.start.line; i <= edge.location.end.line; i++)
          if (i < edge.location.end.line || edge.location.end.column > 1)
            this.edgeLineMap[i] = visEdge;
      }

      return visEdge;
    }));



    // create a network
    let data = {
      nodes: this.nodeDataSet,
      edges: this.edgeDataSet
    };

    let layout = {
      randomSeed: 1
    };

    if(this.config.layout === 'hierarchical') {
      layout.hierarchical = this.config.layoutSettings;
    } else {
      layout.hierarchical = false;
    }

    this.options = {
      layout:
        layout,
      interaction: {
        dragNodes: this.config.layout !== 'map',
        dragView: this.config.layout !== 'map',
        zoomView: this.config.layout !== 'map',
        hover: true,
      },
      physics: {
        enabled: this.config.layout !== 'map' && this.config.layout !== 'hierarchical',
        barnesHut: {
          springConstant:  this.config.layout === 'timeline' ? 0.004 : 0.016
        },
        stabilization: {
          enabled: false,
          iterations: 200,
          updateInterval: 25
        }
      },
      manipulation: false,

      edges: {
        arrows: {
          to: {
            enabled: true,
            scaleFactor: 0.3,
            type: "arrow"
          },
        },
      },
    };

    this.options = Object.assign(this.options, this.config.extraOptions);
    this.network = new visNetwork.Network(this.networkContainer, data, this.options);

    if(this.config.layout === 'map') {
      this.mapContainer.style.display = 'block';
      this.networkContainer.style.background = 'transparent';
      let statistics = statisticsOfMap();
      let center = this.config?.layoutSettings?.center || statistics.center;
      if(this.map) {
        this.map.panTo(center);
      } else {
        this.map = L.map(this.mapContainer, {
          center: center,
          zoom: statistics.scale,
          minZoom: 3,
          zoomSnap: 0.01,
          zoomControl: false,
        });
        var tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '© <a href="http://osm.org/copyright">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>',
        });
        tileLayer.addTo(this.map);

        this.map.on('move', () => blitzboard.updateNodeLocationOnMap());
        this.map.on('zoom', () => blitzboard.updateNodeLocationOnMap());
      }
      blitzboard.network.moveTo({scale: 1.0});
    } else {
      this.mapContainer.style.display = 'none';
      if(this.map) {
        this.map.remove();
      }
      this.map = null;
    }

    this.network.on('zoom', (e) => {
      blitzboard.updateTooltipLocation();
    });

    this.network.on('resize', (e) => {
      if(blitzboard.config.layout === 'map') {
        // Fix scale to 1.0 (delay is needed to override scale set by vis-network)  
        let newScale = Math.min(Blitzboard.maxScaleOnMap, Math.max(blitzboard.network.getScale(), Blitzboard.minScaleOnMap));
        setTimeout( () => {
          blitzboard.network.moveTo({scale: newScale});
          blitzboard.updateNodeLocationOnMap();
        }, 10); 
        blitzboard.map.invalidateSize();
      }
    });
    

    this.network.on('dragStart', (e) => {
      const node = this.nodeDataSet.get(e.nodes[0]);
      if(e.nodes.length > 0) {
        this.nodeDataSet.update({
          id: e.nodes[0],
          fixed: node.fixedByTime ? {x: true, y: true } : false
        });
      }
    });
    

    function statisticsOfMap() {
      let lngKey =  blitzboard.config.layoutSettings.lng;
      let latKey =  blitzboard.config.layoutSettings.lat;
      let lngSum = 0, latSum = 0, count = 0,
        lngMax = Number.MIN_VALUE, lngMin = Number.MAX_VALUE,
        latMax = Number.MIN_VALUE, latMin = Number.MAX_VALUE;
      blitzboard.graph.nodes.forEach(node => {
        if(node.properties[latKey] && node.properties[lngKey]) {
          let lng = parseFloat(node.properties[lngKey][0]);
          let lat = parseFloat(node.properties[latKey][0]);
          lngSum += lng;
          latSum += lat;
          lngMax = Math.max(lng, lngMax);
          lngMin = Math.min(lng, lngMin);
          latMax = Math.max(lat, latMax);
          latMin = Math.min(lat, latMin);
          ++count;
        }
      });
      if(count === 0)
        return [0, 0];
      return {
        center: [latSum / count, lngSum / count],
        scale: Math.max( -Math.log2(Math.max(Math.abs(lngMax - lngMin), Math.abs(latMax - latMin)) / 1000), 0)
      };
    }

    
    this.network.on("zoom", function(){
      let pos = blitzboard.network.getViewPosition();
      if(blitzboard.config.zoom?.min && blitzboard.network.getScale() < blitzboard.config.zoom.min)
      {
        blitzboard.network.moveTo({
          position: blitzboard.prevZoomPosition,
          scale: blitzboard.config.zoom?.min
        });
      }
      else if(blitzboard.config.zoom?.max && blitzboard.network.getScale() > blitzboard.config.zoom.max){
        blitzboard.network.moveTo({
          position: blitzboard.prevZoomPosition,
          scale: blitzboard.config.zoom.max,
        });
      } else {
        blitzboard.prevZoomPosition = pos;
      }
    });
    
    if(this.map) {
      this.updateNodeLocationOnMap();
    }
    
    this.network.on("hoverNode", (e) => {
      this.network.canvas.body.container.style.cursor = 'default';
      const node = this.nodeDataSet.get(e.node);
      if(node) {
        if (node.url) {
          this.network.canvas.body.container.style.cursor = 'pointer';
          this.nodeDataSet.update({
            id: e.node,
            color: '#8888ff',
          });
        }
        if (this.config.node.onHover) {
          this.config.node.onHover(this.getNode(e.node));
        }
        
        this.elementWithTooltip = {
          node: node
        };
        this.showTooltip();
      } else if(node && node.degree > 1 && !this.expandedNodes.includes(e.node)) {
        this.network.canvas.body.container.style.cursor = 'pointer';
      }
    });

    this.network.on("hoverEdge", (e) => {
      const edge = this.edgeDataSet.get(e.edge);
      if (edge) {
        this.elementWithTooltip = {
          edge: edge,
          position: {
            x: e.event.offsetX,
            y: e.event.offsetY,
          }
        };
        this.showTooltip();
      }
    });

    this.network.on("selectNode", (e) => {
      // TODO: Should we show fixed tooltip on selection?
      // if(!this.network.getSelectedNodes().length && !this.network.getSelectedEdges().length) {
      //   const node = this.nodeDataSet.get(e.nodes[0]);
      //   if (node) {
      //     this.elementWithTooltip = {
      //       node: node
      //     };
      //     this.showTooltip();
      //   }
      // }
    });

    this.network.on("selectEdge", (e) => {
      // TODO: Should we show fixed tooltip on selection?
      // if(!this.network.getSelectedNodes().length && !this.network.getSelectedEdges().length) {
      //   const edge = this.edgeDataSet.get(e.edges[0]);
      //   if (edge) {
      //     this.elementWithTooltip = {
      //       edge: edge,
      //       position: {
      //         x: e.x,
      //         y: e.y,
      //       }
      //     };
      //     this.showTooltip();
      //   }
      // }
    });
    

    function plotTimes(startTime, interval, intervalUnit, timeForOnePixel, offsetX, offsetY, rightMostX, context, scale) {
      let currentTime = new Date(startTime);
      switch(intervalUnit) {
        case 'year':
          currentTime = new Date(currentTime.getFullYear()  - currentTime.getFullYear() % interval, 0, 1);
          break;
        case 'month':
          currentTime = new Date(currentTime.getFullYear(), currentTime.getMonth() - currentTime.getMonth() % interval, 1);
          break;
        case 'day':
          currentTime = new Date(currentTime.getFullYear(), currentTime.getMonth(), currentTime.getDate());
          break;
        default:
          return;
      }
      let i = 0;
      while(++i < 100) {
        const nextPosition = -offsetX + (currentTime - startTime) / timeForOnePixel;
        if(nextPosition > rightMostX) break;
        if(intervalUnit === 'year')
          context.fillText(currentTime.getFullYear(), nextPosition, -offsetY);
        else
          context.fillText(currentTime.toLocaleDateString(), nextPosition, -offsetY);
        context.moveTo(nextPosition, -offsetY);
        context.lineTo(nextPosition, -offsetY + 25 / scale);
        context.stroke();
        switch(intervalUnit) {
          case 'year':
            currentTime.setFullYear(currentTime.getFullYear() + interval);
            break;
          case 'month':
            currentTime.setMonth(currentTime.getMonth() + interval);
            break;
          case 'day':
            currentTime.setDate(currentTime.getDate() + interval);
            break;
          default:
            return;
        }
      }
    }
    
    this.network.on("afterDrawing", (ctx) => {
      this.updateTooltipLocation();
      for(let node of this.graph.nodes) {
        node = this.nodeDataSet.get(node.id);
        if(node && node.shape !== 'image' && (node.customIcon || this.config.node.defaultIcon)) {
          let position = this.network.getPosition(node.id);
          let pgNode = this.nodeMap[node.id];
          if(node.customIcon) {
            if(node.customIcon.name && Blitzboard.loadedIcons[node.customIcon.name]) { // Iconiy
              ctx.drawImage(Blitzboard.loadedIcons[node.customIcon.name],
                position.x - node.size * Blitzboard.iconSizeCoef / 2, position.y - node.size * Blitzboard.iconSizeCoef / 2,
                node.size * Blitzboard.iconSizeCoef, 
                node.size * Blitzboard.iconSizeCoef);
            } else { // Ionicons
              ctx.font = `${node.customIcon.size}px Ionicons`;
              ctx.fillStyle = "white";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(node.customIcon.code, position.x, position.y);
            }
          } else {
            if(!pgNode) {
              continue;
            }
            for (let label of pgNode.labels) {
              let lowerLabel = label.toLowerCase();
              if (Blitzboard.loadedIcons[lowerLabel]) {
                if(Blitzboard.loadedIcons[lowerLabel] != 'retrieving...')
                  ctx.drawImage(Blitzboard.loadedIcons[lowerLabel], position.x - node.size * Blitzboard.iconSizeCoef / 2,
                    position.y - node.size * Blitzboard.iconSizeCoef / 2,
                    node.size * Blitzboard.iconSizeCoef,
                    node.size * Blitzboard.iconSizeCoef);
                break;
              }
            }
          }
        }
      }

     if(this.config.layout === 'timeline'){
        const context = this.network.canvas.getContext("2d");
        const view = this.network.canvas.body.view;
        const offsetY = (view.translation.y - 20) / view.scale;
        const offsetX = view.translation.x / view.scale;
        const timeForOnePixel = (this.maxTime - this.minTime) / this.timeScale;
        const timeOnLeftEdge = new Date(((this.maxTime.getTime() + this.minTime.getTime()) / 2) - timeForOnePixel * offsetX);
        const clientWidth = this.network.canvas.body.container.clientWidth;
        const rightMost = -offsetX + clientWidth / view.scale;
        const oneMonth = 31 * 24 * 60 * 60 * 1000;
        const oneDay = 24 * 60 * 60 * 1000;
        const twoMonth = oneMonth * 2;
        const fourMonth = twoMonth * 2;
        const oneYear = 365 * oneDay;
        const minDistance = 200;
        context.font = (20 / view.scale).toString() + "px Arial";
        context.fillStyle = "blue";
        const minimumInterval = timeForOnePixel * minDistance / view.scale;
        if(minimumInterval > oneYear ) {
          plotTimes(timeOnLeftEdge, minimumInterval / oneYear, 'year', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        }
        else if(minimumInterval > fourMonth ) {
          plotTimes(timeOnLeftEdge, 4, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        }
        else if(minimumInterval > twoMonth) {
          plotTimes(timeOnLeftEdge, 2, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        }
        else if(minimumInterval > oneMonth) {
          plotTimes(timeOnLeftEdge, 1, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        } else if(minimumInterval > oneDay * 16) {
          plotTimes(timeOnLeftEdge, 16, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        } else if(minimumInterval > oneDay * 8) {
          plotTimes(timeOnLeftEdge, 8, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        } else if(minimumInterval > oneDay * 4) {
          plotTimes(timeOnLeftEdge, 4, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        } else if(minimumInterval > oneDay * 2) {
          plotTimes(timeOnLeftEdge, 2, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        } else {
          plotTimes(timeOnLeftEdge, 1, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        }
      }
    });
    this.network.on("blurNode", (params) => {
      this.network.canvas.body.container.style.cursor = 'default';
      let node = this.nodeDataSet.get(params.node);
      if(node && node.url) {
        this.nodeDataSet.update({
          id: params.node,
          color: null,
        });
      }
      this.hideTooltip();
    });

    this.network.on("blurEdge", (params) => {
      this.hideTooltip();
    });

    if (!Blitzboard.fontLoaded && document.fonts) {
      Blitzboard.fontLoaded = true;
      let blitzboard = this;
      // Decent browsers: Make sure the fonts are loaded.
      document.fonts.load('normal normal 400 24px/1 "FontAwesome"')
        .catch(
          console.error.bind(console, "Failed to load Font Awesome 4.")
        ).then(function () {
        blitzboard.network.redraw();
      })
        .catch(
          console.error.bind(
            console,
            "Failed to render the network with Font Awesome 4."
          )
        );
    }

    function clickHandler(e) {
      blitzboard.doubleClickTimer = null;
      if (e.nodes.length > 0) {
        if (blitzboard.config.node.onClick) {
          blitzboard.config.node.onClick(blitzboard.getNode(e.nodes[0]));
        }
      } else if (e.edges.length > 0) {
        if (blitzboard.config.edge.onClick) {
          blitzboard.config.edge.onClick(blitzboard.getEdge(e.edges[0]));
        }
      }
    }

    this.network.on("click", (e) => {
      if(!this.doubleClickTimer) {
        if (this.config.doubleClickWait <= 0) {
          clickHandler(e);
        } else {
          this.doubleClickTimer = setTimeout(() => clickHandler(e), this.config.doubleClickWait);
        }
      }
    });

    
    this.network.on("doubleClick", (e) => {
      clearTimeout(this.doubleClickTimer);
      this.doubleClickTimer = null;
      if(e.nodes.length > 0) {
        if(this.config.node.onDoubleClick) {
          this.config.node.onDoubleClick(this.getNode(e.nodes[0]));
        }
      } else if(e.edges.length > 0) {
        if(this.config.edge.onDoubleClick) {
          this.config.edge.onDoubleClick(this.getEdge(e.edges[0]));
        }
      }
    });

    for(let callback of this.onUpdated) {
      callback();
    }
  }


  scrollNodeIntoView(node, select = true) {
    if(typeof(node) === 'string')
      node = this.nodeMap[node];
    if(!node)
      return;

    if(this.config.layout === 'map') {
      this.scrollMapToNode(this.nodeMap[node.id]);
    } else {
      this.scrollNetworkToPosition(this.network.getPosition(node.id));
    }
    if(select)
      this.network.selectNodes([node.id]);

    for(let callback of this.onNodeFocused) {
      // TODO: The argument should be proxy instead of plain objects
      callback(node);
    }
  }
  
  scrollNetworkToPosition(position) {
    clearTimeout(this.scrollAnimationTimerId);
    this.scrollAnimationTimerId = setTimeout(() => {
      const animationOption = {
        scale: 1.0,
        animation:
          {
            duration: 500,
            easingFuntcion: "easeInOutQuad"
          }
      };
      this.network.moveTo({ ...{position: position}, ...animationOption });
    }, 200); // Set delay to avoid calling moveTo() too much (seem to cause some bug on animation)
  }
  
  updateNodeLocationOnMap() {
    let nodePositions = [];
    let lngKey =  this.config.layoutSettings.lng;
    let latKey =  this.config.layoutSettings.lat;
    this.graph.nodes.forEach(node => {
      if(node.properties[latKey] && node.properties[lngKey]) {
        let point = this.map.latLngToContainerPoint([node.properties[latKey][0], node.properties[lngKey][0]]);
        point = this.network.DOMtoCanvas(point);
        nodePositions.push({
          id: node.id,
          x: point.x, y: point.y, fixed: true
        });
      }
    });
    this.nodeDataSet.update(nodePositions);
  }


  updateNodeLocationOnTimeLine() {
    let nodePositions = [];
    this.graph.nodes.forEach(node => {
      let x, y, fixed, width;
      ({x, y, fixed, width} = this.calcNodePosition(node));
      nodePositions.push({
        id: node.id,
        x, y
      });
    });
    this.nodeDataSet.update(nodePositions);
  }
  
  scrollMapToNode(node) {
    let lngKey = this.config.layoutSettings.lng;
    let latKey = this.config.layoutSettings.lat;
    this.map.panTo([node.properties[latKey][0] ,node.properties[lngKey][0]]);
  }
  
  scrollEdgeIntoView(edge, select = true) {
    if(typeof(edge) === 'string') {
      edge = this.edgeMap[edge];
    }

    if(this.config.layout === 'map') {
      this.scrollMapToNode(this.nodeMap[edge.from]);
    } else {
      const from = this.network.getPosition(edge.from);
      const to = this.network.getPosition(edge.to);
      this.scrollNetworkToPosition({ x: (from.x + to.x) / 2, y: (from.y + to.y) /2 });
    }
    if(select) {
      this.network.selectEdges([edge.id]);
    }

    for(let callback of this.onEdgeFocused) {
      // TODO: The argument should be proxy instead of plain objects
      callback(edge);
    }
  }
  
  showLoader(text = "Now loading...") {
    this.screen.style.display = 'flex';
    this.screenText.innerText = text;
    this.screenText.style.display = text ? 'block' : 'none';
  }
  
  hideLoader() {
    this.screen.style.display = 'none';
  }

  toNodePairString(pgEdge) {
    return `${pgEdge.from}${Blitzboard.edgeDelimiter}${pgEdge.to}`;
  }
}



function arrayEquals(a, b) {
  return Array.isArray(a) &&
    Array.isArray(b) &&
    a.length === b.length &&
    a.every((val, index) => val === b[index]);
}

function nodeEquals(node1, node2) {
  if(node1.id != node2.id || !arrayEquals(node1.labels, node2.labels)) {
    return false;
  }
  let node1Keys = Object.keys(node1.properties);
  let node2Keys = Object.keys(node2.properties);
  if(node1Keys.length != node2Keys.length) {
    return false;
  }
  for(let key of node1Keys) {
    if(!arrayEquals(node1.properties[key], node2.properties[key]))
      return false;
  }
  return true;
}


class DuplicateNodeError extends Error {
  constructor(nodes) {
    super(`Duplicate node: ${nodes.map(n => n.id).join(', ')}`);
    this.name = "NodeDuplicationError";
    this.nodes = nodes;
  }
}

module.exports.DuplicateNodeError = DuplicateNodeError;


function deepMerge(target, source) {
  const isObject = obj => obj && typeof obj === 'object' && !Array.isArray(obj);
  let result = Object.assign({}, target);
  if (isObject(target) && isObject(source)) {
    for (const [sourceKey, sourceValue] of Object.entries(source)) {
      const targetValue = target[sourceKey];
      if (isObject(sourceValue) && target.hasOwnProperty(sourceKey)) {
        result[sourceKey] = deepMerge(targetValue, sourceValue);
      }
      else {
        Object.assign(result, {[sourceKey]: sourceValue});
      }
    }
  }
  return result;
}

function retrieveHttpUrl(node) {
  let candidates = [];
  for(let entry of Object.entries(node.properties)) {
    for(let prop of entry[1]) {
      if(typeof(prop) === 'string' && (prop.startsWith("https://") || prop.startsWith("http://"))) {
        if(entry[0].toLowerCase() == 'url')
          return prop;
        candidates.push([entry[0], prop]);
      }
    }
  }
  return candidates[0];
}




function wrapText(str, asHtml) {
  if(!str)
    return str;
  if(Array.isArray(str))
    str = str[0];
  const maxWidth = 40;
  let newLineStr = asHtml ? "<br>" : "\n", res = '';
  while (str.length > maxWidth) {
    res += str.slice(0, maxWidth) + newLineStr;
    str = str.slice(maxWidth);
  }
  return res + str;
}

function createLabelText(elem, props = null) {
  if (props != null) {
    // Use whitespace instead of empty string if no props are specified because Vis.js cannot update label with empty string)
    return props.length ? props.map((prop) => prop === 'id' ? elem.id : (prop === 'label' ? elem.labels : wrapText(elem.properties[prop]))).filter((val) => val).join('\n') : ' ';
  }
}

function convertToHyperLinkIfURL(text) {
  if(!text)
    return text;
  if(Array.isArray(text))
    text = text[0];
  if(text.startsWith('http://') || text.startsWith('https://') ) {
    return `<a target="_blank" href="${text}">${wrapText(text)}</a>`;
  }
  return wrapText(text);
}

// Create random colors, with str as seed, and with fixed saturation and lightness
function getRandomColor(str, saturation, brightness) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
    hash = hash & hash;
  }
  let hue = hash % 360;
  return 'hsl(' + hue + `, ${saturation}, ${brightness})`;
}

function isDateString(str) {
  return isNaN(str) && !isNaN(Date.parse(str))
}

function htmlTitle(html) {
  const container = document.createElement("div");
  container.innerHTML = html;
  return container;
}


/***/ }),

/***/ "./src/pg_parser_browserified.js":
/*!***************************************!*\
  !*** ./src/pg_parser_browserified.js ***!
  \***************************************/
/***/ (() => {

(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */

"use strict";

function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { PG: peg$parsePG },
      peg$startRuleFunction  = peg$parsePG,

      peg$c0 = function(lines) {
        return {
          nodes: lines.map(l => l.node).filter(v => v),
          edges: lines.map(l => l.edge).filter(v => v),
          nodeCount: nodeCount,
          edgeCount: edgeCount,
          nodeLabels: nodeLabelHash,
          edgeLabels: edgeLabelHash,
          nodeProperties: nodePropHash,
          edgeProperties: edgePropHash
        }
      },
      peg$c1 = function(n) {
        return {
          node: n
        }
      },
      peg$c2 = function(e) {
        return {
          edge: e
        }
      },
      peg$c3 = function(id, l, p) {
        let propObj = {};
        p.forEach(prop => {
          if (propObj[prop.key]) {
            propObj[prop.key].push(prop.value);
          } else {
            propObj[prop.key] = [prop.value];
          }
          // nodePropHash[prop.key] = true;
          if (nodePropHash[prop.key]) {
            nodePropHash[prop.key]++;
          } else {
            nodePropHash[prop.key] = 1;
          }
        });

        nodeCount++;

        l.forEach(label => {
          if (nodeLabelHash[label]) {
            nodeLabelHash[label]++;
          } else {
            nodeLabelHash[label] = 1;
          }
        });

        return {
          id: id,
          location: location(),
          labels: l,
          properties: propObj
        }
      },
      peg$c4 = function(f, d, t, l, p) {
        let propObj = {};
        p.forEach(prop => {
          if (propObj[prop.key]) {
            propObj[prop.key].push(prop.value);
          } else {
            propObj[prop.key] = [prop.value];
          }
          // edgePropHash[prop.key] = true;
          if (edgePropHash[prop.key]) {
            edgePropHash[prop.key]++;
          } else {
            edgePropHash[prop.key] = 1;
          }
        });

        edgeCount++;

        l.forEach(label => {
          if (edgeLabelHash[label]) {
            edgeLabelHash[label]++;
          } else {
            edgeLabelHash[label] = 1;
          }
        });

        return {
          from: f,
          to: t,
          location: location(),
          direction: d,
          labels: l,
          properties: propObj
        }
      },
      peg$c5 = ":",
      peg$c6 = peg$literalExpectation(":", false),
      peg$c7 = function(l) {
        return l
      },
      peg$c8 = function(k, v) {
        return {
          key: k,
          value: v
        }
      },
      peg$c9 = "--",
      peg$c10 = peg$literalExpectation("--", false),
      peg$c11 = "->",
      peg$c12 = peg$literalExpectation("->", false),
      peg$c13 = "-",
      peg$c14 = peg$literalExpectation("-", false),
      peg$c15 = ".",
      peg$c16 = peg$literalExpectation(".", false),
      peg$c17 = /^[0-9]/,
      peg$c18 = peg$classExpectation([["0", "9"]], false, false),
      peg$c19 = "0",
      peg$c20 = peg$literalExpectation("0", false),
      peg$c21 = /^[1-9]/,
      peg$c22 = peg$classExpectation([["1", "9"]], false, false),
      peg$c23 = /^[eE]/,
      peg$c24 = peg$classExpectation(["e", "E"], false, false),
      peg$c25 = "+",
      peg$c26 = peg$literalExpectation("+", false),
      peg$c27 = "'",
      peg$c28 = peg$literalExpectation("'", false),
      peg$c29 = "\"",
      peg$c30 = peg$literalExpectation("\"", false),
      peg$c31 = "\\",
      peg$c32 = peg$literalExpectation("\\", false),
      peg$c33 = "b",
      peg$c34 = peg$literalExpectation("b", false),
      peg$c35 = function() {
        return "\b";
      },
      peg$c36 = "f",
      peg$c37 = peg$literalExpectation("f", false),
      peg$c38 = function() {
        return "\f";
      },
      peg$c39 = "n",
      peg$c40 = peg$literalExpectation("n", false),
      peg$c41 = function() {
        return "\n";
      },
      peg$c42 = "r",
      peg$c43 = peg$literalExpectation("r", false),
      peg$c44 = function() {
        return "\r";
      },
      peg$c45 = "t",
      peg$c46 = peg$literalExpectation("t", false),
      peg$c47 = function() {
        return "\t";
      },
      peg$c48 = "v",
      peg$c49 = peg$literalExpectation("v", false),
      peg$c50 = function() {
        return "\x0B";
      },
      peg$c51 = peg$anyExpectation(),
      peg$c52 = function(char) {
        return char;
      },
      peg$c53 = function(esc) {
        return esc;
      },
      peg$c54 = function() {
        return text();
      },
      peg$c55 = function(chars) {
        return chars.join('');
      },
      peg$c56 = function(chars) { 
        return chars.join('');
      },
      peg$c57 = /^[ \t]/,
      peg$c58 = peg$classExpectation([" ", "\t"], false, false),
      peg$c59 = /^[: \t\r\n]/,
      peg$c60 = peg$classExpectation([":", " ", "\t", "\r", "\n"], false, false),
      peg$c61 = /^[^: \t\r\n]/,
      peg$c62 = peg$classExpectation([":", " ", "\t", "\r", "\n"], true, false),
      peg$c63 = /^[\r\n]/,
      peg$c64 = peg$classExpectation(["\r", "\n"], false, false),
      peg$c65 = /^[^\r\n]/,
      peg$c66 = peg$classExpectation(["\r", "\n"], true, false),

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parsePG() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseNodeOrEdge();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseNodeOrEdge();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseEOF();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c0(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseNodeOrEdge() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseNode();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c1(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseEdge();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$parseEmptyLine();
      }
    }

    return s0;
  }

  function peg$parseNode() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseKey();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseLabel();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseLabel();
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseProperty();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseProperty();
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseWS();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseWS();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseEndOfLine();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c3(s1, s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEdge() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    s0 = peg$currPos;
    s1 = peg$parseKey();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseWS();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseWS();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseDirection();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseWS();
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseWS();
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseKey();
            if (s5 !== peg$FAILED) {
              s6 = [];
              s7 = peg$parseLabel();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parseLabel();
              }
              if (s6 !== peg$FAILED) {
                s7 = [];
                s8 = peg$parseProperty();
                while (s8 !== peg$FAILED) {
                  s7.push(s8);
                  s8 = peg$parseProperty();
                }
                if (s7 !== peg$FAILED) {
                  s8 = [];
                  s9 = peg$parseWS();
                  while (s9 !== peg$FAILED) {
                    s8.push(s9);
                    s9 = peg$parseWS();
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseEndOfLine();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c4(s1, s3, s5, s6, s7);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseLabel() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseDelimiter();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseDelimiter();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 58) {
        s2 = peg$c5;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c6); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseWS();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseWS();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseKey();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c7(s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseProperty() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseDelimiter();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseDelimiter();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseKey();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseWS();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseWS();
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c5;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c6); }
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseWS();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseWS();
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseValue();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c8(s2, s6);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDirection() {
    var s0;

    if (input.substr(peg$currPos, 2) === peg$c9) {
      s0 = peg$c9;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c10); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c11) {
        s0 = peg$c11;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c12); }
      }
    }

    return s0;
  }

  function peg$parseNumber() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s1 = peg$c13;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c14); }
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseInteger();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s4 = peg$c15;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c16); }
        }
        if (s4 !== peg$FAILED) {
          s5 = [];
          if (peg$c17.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
          if (s6 !== peg$FAILED) {
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              if (peg$c17.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c18); }
              }
            }
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseExp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s1 = [s1, s2, s3, s4];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseInteger() {
    var s0, s1, s2, s3;

    if (input.charCodeAt(peg$currPos) === 48) {
      s0 = peg$c19;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c20); }
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (peg$c21.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c22); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c17.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c18); }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c17.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseExp() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    if (peg$c23.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c24); }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c13;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c14); }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 43) {
          s2 = peg$c25;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c26); }
        }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        if (peg$c17.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c18); }
        }
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (peg$c17.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c18); }
            }
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEscapedChar() {
    var s0, s1;

    if (input.charCodeAt(peg$currPos) === 39) {
      s0 = peg$c27;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c28); }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 34) {
        s0 = peg$c29;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c30); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 92) {
          s0 = peg$c31;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c32); }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 98) {
            s1 = peg$c33;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c35();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 102) {
              s1 = peg$c36;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c37); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c38();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 110) {
                s1 = peg$c39;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c40); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c41();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 114) {
                  s1 = peg$c42;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c43); }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c44();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 116) {
                    s1 = peg$c45;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c46); }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c47();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 118) {
                      s1 = peg$c48;
                      peg$currPos++;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c49); }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c50();
                    }
                    s0 = s1;
                  }
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseDoubleQuotedChar() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    if (input.charCodeAt(peg$currPos) === 34) {
      s2 = peg$c29;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c30); }
    }
    if (s2 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 92) {
        s2 = peg$c31;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
    }
    peg$silentFails--;
    if (s2 === peg$FAILED) {
      s1 = void 0;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c52(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s1 = peg$c31;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseEscapedChar();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c53(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseSingleQuotedChar() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    if (input.charCodeAt(peg$currPos) === 39) {
      s2 = peg$c27;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c28); }
    }
    if (s2 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 92) {
        s2 = peg$c31;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
    }
    peg$silentFails--;
    if (s2 === peg$FAILED) {
      s1 = void 0;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c52(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s1 = peg$c31;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseEscapedChar();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c53(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseKey() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseNumber();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseSPECIAL_CHAR();
      peg$silentFails--;
      if (s3 !== peg$FAILED) {
        peg$currPos = s2;
        s2 = void 0;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c54();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c29;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c30); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseDoubleQuotedChar();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseDoubleQuotedChar();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c29;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c30); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c55(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c27;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseSingleQuotedChar();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseSingleQuotedChar();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c27;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c28); }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c56(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseNON_SPECIAL_CHAR();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseNON_SPECIAL_CHAR();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c55(s1);
          }
          s0 = s1;
        }
      }
    }

    return s0;
  }

  function peg$parseValue() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c29;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c30); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseDoubleQuotedChar();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseDoubleQuotedChar();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s3 = peg$c29;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c30); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c55(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        s1 = peg$c27;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseSingleQuotedChar();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseSingleQuotedChar();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c27;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c28); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c56(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseNON_SPECIAL_CHAR();
        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c5;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c6); }
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseNON_SPECIAL_CHAR();
            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s2 = peg$c5;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c6); }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c55(s1);
        }
        s0 = s1;
      }
    }

    return s0;
  }

  function peg$parseWS() {
    var s0;

    if (peg$c57.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c58); }
    }

    return s0;
  }

  function peg$parseSPECIAL_CHAR() {
    var s0;

    if (peg$c59.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c60); }
    }

    return s0;
  }

  function peg$parseNON_SPECIAL_CHAR() {
    var s0;

    if (peg$c61.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c62); }
    }

    return s0;
  }

  function peg$parseNEWLINE() {
    var s0;

    if (peg$c63.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c64); }
    }

    return s0;
  }

  function peg$parseNON_NEWLINE() {
    var s0;

    if (peg$c65.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c66); }
    }

    return s0;
  }

  function peg$parseEOF() {
    var s0, s1;

    s0 = peg$currPos;
    peg$silentFails++;
    if (input.length > peg$currPos) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c51); }
    }
    peg$silentFails--;
    if (s1 === peg$FAILED) {
      s0 = void 0;
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEndOfLine() {
    var s0;

    s0 = peg$parseEOF();
    if (s0 === peg$FAILED) {
      s0 = peg$parseNEWLINE();
    }

    return s0;
  }

  function peg$parseDelimiter() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseWS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseWS();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseNEWLINE();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseWS();
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseWS();
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = [];
      s1 = peg$parseWS();
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parseWS();
        }
      } else {
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseEmptyLine() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseWS();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseWS();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseEOF();
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseWS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseWS();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNEWLINE();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }


    let nodeCount = 0;
    let edgeCount = 0;
    let nodeLabelHash = {};
    let edgeLabelHash = {};
    let nodePropHash = {};
    let edgePropHash = {};


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};

},{}],2:[function(require,module,exports){
pgParser = require('./pg_parser.js');

let coreParse = pgParser.parse;
function removeComment(text) {
  return text.replace(/^((("[^"\\]*(\\.[^"\\]*)*")|[^#"])*)(#.*)$/gm, '$1');
}
pgParser.parse = (text) => coreParse(removeComment(text));

},{"./pg_parser.js":1}]},{},[2]);


/***/ }),

/***/ "./node_modules/leaflet/dist/images/layers-2x.png":
/*!********************************************************!*\
  !*** ./node_modules/leaflet/dist/images/layers-2x.png ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "8f2c4d11474275fbc161.png";

/***/ }),

/***/ "./node_modules/leaflet/dist/images/layers.png":
/*!*****************************************************!*\
  !*** ./node_modules/leaflet/dist/images/layers.png ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "416d91365b44e4b4f477.png";

/***/ }),

/***/ "./node_modules/leaflet/dist/images/marker-icon.png":
/*!**********************************************************!*\
  !*** ./node_modules/leaflet/dist/images/marker-icon.png ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "2b3e1faf89f94a483539.png";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/blitzboard.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxVQUFVLFVBQVUsWUFBWSxhQUFhLFdBQVcsS0FBSyxZQUFZLE1BQU0sWUFBWSxPQUFPLHVCQUF1Qix1QkFBdUIsdUJBQXVCLHVCQUF1Qix1QkFBdUIsdUJBQXVCLHdCQUF3Qix1QkFBdUIsd0JBQXdCLE1BQU0sVUFBVSxVQUFVLEtBQUssS0FBSyxZQUFZLGFBQWEsYUFBYSxRQUFRLGFBQWEsTUFBTSxZQUFZLFdBQVcsd0JBQXdCLGFBQWEsTUFBTSxNQUFNLFlBQVksV0FBVyxZQUFZLE1BQU0sS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksUUFBUSxhQUFhLE1BQU0sWUFBWSxNQUFNLEtBQUssVUFBVSxZQUFZLGFBQWEsYUFBYSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssWUFBWSxhQUFhLGFBQWEsTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLE1BQU0sTUFBTSxZQUFZLGFBQWEsYUFBYSxPQUFPLEtBQUssWUFBWSxRQUFRLFdBQVcsS0FBSyxVQUFVLEtBQUssS0FBSyxZQUFZLGFBQWEsYUFBYSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sVUFBVSxLQUFLLE9BQU8sVUFBVSxZQUFZLGFBQWEsYUFBYSxPQUFPLFlBQVksVUFBVSxZQUFZLE9BQU8sUUFBUSx3QkFBd0IsYUFBYSxPQUFPLGFBQWEsTUFBTSxZQUFZLFdBQVcsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksYUFBYSxRQUFRLFlBQVksTUFBTSxZQUFZLFFBQVEsYUFBYSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sWUFBWSxhQUFhLFdBQVcsVUFBVSxZQUFZLFdBQVcsWUFBWSxhQUFhLFdBQVcsS0FBSyxNQUFNLFlBQVksYUFBYSxXQUFXLEtBQUssS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLGFBQWEsTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLE1BQU0sS0FBSyxVQUFVLFlBQVksV0FBVyxNQUFNLEtBQUssVUFBVSxVQUFVLFlBQVksTUFBTSxLQUFLLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxhQUFhLE9BQU8sYUFBYSxPQUFPLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxPQUFPLGFBQWEsTUFBTSxZQUFZLGFBQWEsYUFBYSxNQUFNLEtBQUssWUFBWSxXQUFXLFVBQVUsS0FBSyxLQUFLLFlBQVksYUFBYSxNQUFNLEtBQUssVUFBVSxVQUFVLEtBQUssTUFBTSxVQUFVLEtBQUssS0FBSyxVQUFVLFlBQVksTUFBTSxLQUFLLFlBQVksV0FBVyxZQUFZLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxNQUFNLEtBQUssVUFBVSxZQUFZLFdBQVcsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFVBQVUsWUFBWSxhQUFhLE9BQU8sWUFBWSxNQUFNLFlBQVksUUFBUSxhQUFhLE1BQU0sWUFBWSxhQUFhLFdBQVcsS0FBSyxNQUFNLFVBQVUsVUFBVSxLQUFLLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLE1BQU0sVUFBVSxLQUFLLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxhQUFhLGFBQWEsYUFBYSxXQUFXLFlBQVksYUFBYSxhQUFhLGNBQWMsYUFBYSxhQUFhLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxNQUFNLEtBQUssWUFBWSxPQUFPLE9BQU8sWUFBWSxNQUFNLE1BQU0sWUFBWSxhQUFhLFFBQVEsV0FBVyxLQUFLLFlBQVksYUFBYSxhQUFhLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxhQUFhLE1BQU0sS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsWUFBWSxXQUFXLFlBQVksYUFBYSxhQUFhLE1BQU0sS0FBSyxVQUFVLFVBQVUsV0FBVyxhQUFhLGFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUJBQXlCLE9BQU8sc0NBQXNDO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5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QUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUNBQXVDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdUNBQXVDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2RkFBNkYsZ0JBQWdCO0FBQzdHO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnR0FBZ0csZ0JBQWdCO0FBQ2hIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw2QkFBNkI7QUFDaEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsWUFBWTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCO0FBQ3BELDBCQUEwQixxREFBcUQ7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQywyQ0FBMkMsYUFBYTtBQUN4RCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLGlFQUFpRSxZQUFZO0FBQzdFO0FBQ0EsTUFBTSxjQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUIsc0JBQXNCLElBQUk7QUFDdkUsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLGtHQUFrRztBQUNsRywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsd0JBQXdCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkNBQTZDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixlQUFlOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJDQUEyQztBQUN2RSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsMkNBQTJDO0FBQ3ZFLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDs7QUFFeEQ7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDs7QUFFQSxpREFBaUQsVUFBVTtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0Isc0JBQXNCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUIsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGLDhCQUE4Qjs7QUFFOUIsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7O0FBRWxELCtDQUErQyxTQUFTOztBQUV4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0EsZUFBZTs7QUFFZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsc0JBQXNCLGVBQWU7QUFDckMsdUJBQXVCLGVBQWU7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsOEJBQThCO0FB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QUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFFBQVEsV0FBVztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7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Q0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsK0VBQStFOztBQUUvRTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsZ0JBQWdCOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsZ0JBQWdCOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQyx5Q0FBeUMsdUJBQXVCO0FBQ2hFLG9DQUFvQyx1QkFBdUI7QUFDM0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGtEQUFrRDs7QUFFbEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0EsNkNBQTZDOztBQUU3Qzs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLG9CQUFvQjs7QUFFcEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLHFGQUFxRjs7QUFFckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLElBQUk7QUFDSjtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0RBQStELDBCQUEwQjtBQUN6Rjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzl2YkEsTUFBcUY7QUFDckYsTUFBMkU7QUFDM0UsTUFBa0Y7QUFDbEYsTUFBcUc7QUFDckcsTUFBOEY7QUFDOUYsTUFBOEY7QUFDOUYsTUFBMkY7QUFDM0Y7QUFD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Q3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG1CQUFtQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUzs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7O0FBRTdFOztBQUVBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsU0FBUzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7OztBQUdBOztBQUVBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCLFlBQVk7QUFDN0I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUIsWUFBWTtBQUM3Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCLFlBQVk7QUFDN0I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUIsWUFBWTtBQUM3Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FB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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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O0FBRUE7QUFDQTs7QUFFQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7QUFHQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFD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VztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRzs7QUFFaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZEQUE2RCxxRkFBcUYsV0FBVyxzSEFBc0gsZ0JBQWdCLFdBQVcseUJBQXlCLFNBQVMsd0JBQXdCLDRCQUE0QixjQUFjLFNBQVMsK0JBQStCLHNCQUFzQixXQUFXLFlBQVksZ0tBQWdLLGtEQUFrRCxTQUFTLGtCQUFrQixrQkFBa0Isb0JBQW9CLHNCQUFzQiw4QkFBOEIsY0FBYyx1QkFBdUIsZUFBZSxZQUFZLG9CQUFvQixNQUFNLDJEQUEyRCxVQUFVOztBQUU3OEIsc0RBQXNELGdCQUFnQixnQkFBZ0Isa0VBQWtFLHVGQUF1Riw2REFBNkQsa0RBQWtEOztBQUU5ViwyQ0FBMkMsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sb0JBQW9COztBQUU3Szs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FB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QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4Ryx3QkFBd0I7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSx1QkFBdUI7QUFDL0Y7QUFDQTs7QUFFQTtBQUNBLHdFQUF3RSx1QkFBdUI7QUFDL0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVU7QUFDMUQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsNkJBQTZCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDZCQUE2QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw2QkFBNkI7QUFDNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7OztBQUlMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsOENBQThDLEVBQUUseUJBQXlCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUNuRjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0JBQWdCO0FBQ3JEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxtQkFBbUI7QUFDeEQsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSxtQkFBbUIsRUFBRSxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1VDN3hEM0I7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOzs7OztXQ3pCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7Ozs7V0NmQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7O1dBRUE7O1dBRUE7O1dBRUE7O1dBRUE7O1dBRUE7O1dBRUE7Ozs7O1dDckJBOzs7OztVRUFBO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQmxpdHpib2FyZC93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC8uL25vZGVfbW9kdWxlcy9AaWNvbmlmeS9pY29uaWZ5L2Rpc3QvaWNvbmlmeS5taW4uanMiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC8uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC5jc3MiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9nZXRVcmwuanMiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzIiwid2VicGFjazovL0JsaXR6Ym9hcmQvLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmpzIiwid2VicGFjazovL0JsaXR6Ym9hcmQvLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzP2I5YTMiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9CbGl0emJvYXJkLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly9CbGl0emJvYXJkLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzIiwid2VicGFjazovL0JsaXR6Ym9hcmQvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzIiwid2VicGFjazovL0JsaXR6Ym9hcmQvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9CbGl0emJvYXJkLy4vbm9kZV9tb2R1bGVzL3Zpcy1kYXRhL3BlZXIvdW1kL3Zpcy1kYXRhLmpzIiwid2VicGFjazovL0JsaXR6Ym9hcmQvLi9ub2RlX21vZHVsZXMvdmlzLWRhdGEvcGVlci91bWQvdmlzLWRhdGEubWluLmpzIiwid2VicGFjazovL0JsaXR6Ym9hcmQvLi9ub2RlX21vZHVsZXMvdmlzLW5ldHdvcmsvcGVlci91bWQvdmlzLW5ldHdvcmsubWluLmpzIiwid2VicGFjazovL0JsaXR6Ym9hcmQvLi9zcmMvYmxpdHpib2FyZC5qcyIsIndlYnBhY2s6Ly9CbGl0emJvYXJkLy4vc3JjL3BnX3BhcnNlcl9icm93c2VyaWZpZWQuanMiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9CbGl0emJvYXJkL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL0JsaXR6Ym9hcmQvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL0JsaXR6Ym9hcmQvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9CbGl0emJvYXJkL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL0JsaXR6Ym9hcmQvd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC93ZWJwYWNrL3J1bnRpbWUvanNvbnAgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly9CbGl0emJvYXJkL3dlYnBhY2svcnVudGltZS9ub25jZSIsIndlYnBhY2s6Ly9CbGl0emJvYXJkL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiQmxpdHpib2FyZFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJCbGl0emJvYXJkXCJdID0gZmFjdG9yeSgpO1xufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuICIsIi8qKlxuKiAoYykgSWNvbmlmeVxuKlxuKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgbGljZW5zZS50eHQgb3IgbGljZW5zZS5ncGwudHh0XG4qIGZpbGVzIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9pY29uaWZ5L2ljb25pZnlcbipcbiogTGljZW5zZWQgdW5kZXIgQXBhY2hlIDIuMCBvciBHUEwgMi4wIGF0IHlvdXIgb3B0aW9uLlxuKiBJZiBkZXJpdmF0aXZlIHByb2R1Y3QgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBvbmUgb2YgbGljZW5zZXMsIHlvdSBjYW4gcGljayBvbmUgb2YgbGljZW5zZXMuXG4qXG4qIEBsaWNlbnNlIEFwYWNoZSAyLjBcbiogQGxpY2Vuc2UgR1BMIDIuMFxuKi9cbnZhciBJY29uaWZ5PWZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZShlLG4sdCl7cmV0dXJuIGUodD17cGF0aDpuLGV4cG9ydHM6e30scmVxdWlyZTpmdW5jdGlvbihlLG4pe3JldHVybiBmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIkR5bmFtaWMgcmVxdWlyZXMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IEByb2xsdXAvcGx1Z2luLWNvbW1vbmpzXCIpfShudWxsPT1uJiZ0LnBhdGgpfX0sdC5leHBvcnRzKSx0LmV4cG9ydHN9dmFyIG49ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmZ1bGxJY29uPW4uaWNvbkRlZmF1bHRzPW4ubWluaWZ5UHJvcHM9bi5tYXRjaE5hbWU9dm9pZCAwLG4ubWF0Y2hOYW1lPS9eW2EtejAtOV0rKC1bYS16MC05XSspKiQvLG4ubWluaWZ5UHJvcHM9W1wid2lkdGhcIixcImhlaWdodFwiLFwidG9wXCIsXCJsZWZ0XCJdLG4uaWNvbkRlZmF1bHRzPU9iamVjdC5mcmVlemUoe2xlZnQ6MCx0b3A6MCx3aWR0aDoxNixoZWlnaHQ6MTYscm90YXRlOjAsdkZsaXA6ITEsaEZsaXA6ITF9KSxuLmZ1bGxJY29uPWZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuYXNzaWduKHt9LG4uaWNvbkRlZmF1bHRzLGUpfX0pKSx0PWUoKGZ1bmN0aW9uKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5tZXJnZUljb25EYXRhPXZvaWQgMCx0Lm1lcmdlSWNvbkRhdGE9ZnVuY3Rpb24oZSx0KXt2YXIgcj1PYmplY3QuYXNzaWduKHt9LGUpO2Zvcih2YXIgbyBpbiBuLmljb25EZWZhdWx0cyl7dmFyIGk9bztpZih2b2lkIDAhPT10W2ldKXt2YXIgYT10W2ldO2lmKHZvaWQgMD09PXJbaV0pe3JbaV09YTtjb250aW51ZX1zd2l0Y2goaSl7Y2FzZVwicm90YXRlXCI6cltpXT0ocltpXSthKSU0O2JyZWFrO2Nhc2VcImhGbGlwXCI6Y2FzZVwidkZsaXBcIjpyW2ldPWEhPT1yW2ldO2JyZWFrO2RlZmF1bHQ6cltpXT1hfX19cmV0dXJuIHJ9fSkpLHI9ZSgoZnVuY3Rpb24oZSxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLnBhcnNlSWNvblNldD12b2lkIDA7dmFyIG89T2JqZWN0LmtleXMobi5pY29uRGVmYXVsdHMpO2Z1bmN0aW9uIGkoZSxuLHIsbyl7dm9pZCAwPT09byYmKG89MCk7dmFyIGE9ZS5wYXJlbnQ7aWYodm9pZCAwIT09blthXSlyZXR1cm4gdC5tZXJnZUljb25EYXRhKG5bYV0sZSk7aWYodm9pZCAwIT09clthXSl7aWYobz4yKXJldHVybiBudWxsO3ZhciBjPWkoclthXSxuLHIsbysxKTtpZihjKXJldHVybiB0Lm1lcmdlSWNvbkRhdGEoYyxlKX1yZXR1cm4gbnVsbH1yLnBhcnNlSWNvblNldD1mdW5jdGlvbihlLHQscil7dm9pZCAwPT09ciYmKHI9XCJub25lXCIpO3ZhciBhPVtdO2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlKXJldHVyblwibm9uZVwiIT09ciYmYTtpZihlLm5vdF9mb3VuZCBpbnN0YW5jZW9mIEFycmF5JiZlLm5vdF9mb3VuZC5mb3JFYWNoKChmdW5jdGlvbihlKXt0KGUsbnVsbCksXCJhbGxcIj09PXImJmEucHVzaChlKX0pKSxcIm9iamVjdFwiIT10eXBlb2YgZS5pY29ucylyZXR1cm5cIm5vbmVcIiE9PXImJmE7dmFyIGM9T2JqZWN0LmNyZWF0ZShudWxsKTtvLmZvckVhY2goKGZ1bmN0aW9uKG4pe3ZvaWQgMCE9PWVbbl0mJlwib2JqZWN0XCIhPXR5cGVvZiBlW25dJiYoY1tuXT1lW25dKX0pKTt2YXIgdT1lLmljb25zO2lmKE9iamVjdC5rZXlzKHUpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciByPXVbZV07XCJzdHJpbmdcIj09dHlwZW9mIHIuYm9keSYmKHQoZSxPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oe30sbi5pY29uRGVmYXVsdHMsYyxyKSkpLGEucHVzaChlKSl9KSksXCJvYmplY3RcIj09dHlwZW9mIGUuYWxpYXNlcyl7dmFyIGY9ZS5hbGlhc2VzO09iamVjdC5rZXlzKGYpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciByPWkoZltlXSx1LGYsMSk7ciYmKHQoZSxPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oe30sbi5pY29uRGVmYXVsdHMsYyxyKSkpLGEucHVzaChlKSl9KSl9cmV0dXJuXCJub25lXCI9PT1yP2EubGVuZ3RoPjA6YX19KSksbz1lKChmdW5jdGlvbihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQudmFsaWRhdGVJY29uPXQuc3RyaW5nVG9JY29uPXZvaWQgMDt0LnN0cmluZ1RvSWNvbj1mdW5jdGlvbihlLG4scixvKXt2b2lkIDA9PT1vJiYobz1cIlwiKTt2YXIgaT1lLnNwbGl0KFwiOlwiKTtpZihcIkBcIj09PWUuc2xpY2UoMCwxKSl7aWYoaS5sZW5ndGg8Mnx8aS5sZW5ndGg+MylyZXR1cm4gbnVsbDtvPWkuc2hpZnQoKS5zbGljZSgxKX1pZihpLmxlbmd0aD4zfHwhaS5sZW5ndGgpcmV0dXJuIG51bGw7aWYoaS5sZW5ndGg+MSl7dmFyIGE9aS5wb3AoKSxjPWkucG9wKCksdT17cHJvdmlkZXI6aS5sZW5ndGg+MD9pWzBdOm8scHJlZml4OmMsbmFtZTphfTtyZXR1cm4gbiYmIXQudmFsaWRhdGVJY29uKHUpP251bGw6dX12YXIgZj1pWzBdLGw9Zi5zcGxpdChcIi1cIik7aWYobC5sZW5ndGg+MSl7dmFyIHM9e3Byb3ZpZGVyOm8scHJlZml4Omwuc2hpZnQoKSxuYW1lOmwuam9pbihcIi1cIil9O3JldHVybiBuJiYhdC52YWxpZGF0ZUljb24ocyk/bnVsbDpzfWlmKHImJlwiXCI9PT1vKXt2YXIgZD17cHJvdmlkZXI6byxwcmVmaXg6XCJcIixuYW1lOmZ9O3JldHVybiBuJiYhdC52YWxpZGF0ZUljb24oZCxyKT9udWxsOmR9cmV0dXJuIG51bGx9O3QudmFsaWRhdGVJY29uPWZ1bmN0aW9uKGUsdCl7cmV0dXJuISFlJiYhKFwiXCIhPT1lLnByb3ZpZGVyJiYhZS5wcm92aWRlci5tYXRjaChuLm1hdGNoTmFtZSl8fCEodCYmXCJcIj09PWUucHJlZml4fHxlLnByZWZpeC5tYXRjaChuLm1hdGNoTmFtZSkpfHwhZS5uYW1lLm1hdGNoKG4ubWF0Y2hOYW1lKSl9fSkpLGk9ZSgoZnVuY3Rpb24oZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lmxpc3RJY29ucz10LmdldEljb249dC5pY29uRXhpc3RzPXQuYWRkSWNvbj10LmFkZEljb25TZXQ9dC5nZXRTdG9yYWdlPXQubmV3U3RvcmFnZT12b2lkIDA7dmFyIG89T2JqZWN0LmNyZWF0ZShudWxsKTtmdW5jdGlvbiBpKGUsbil7cmV0dXJue3Byb3ZpZGVyOmUscHJlZml4Om4saWNvbnM6T2JqZWN0LmNyZWF0ZShudWxsKSxtaXNzaW5nOk9iamVjdC5jcmVhdGUobnVsbCl9fWZ1bmN0aW9uIGEoZSxuKXt2b2lkIDA9PT1vW2VdJiYob1tlXT1PYmplY3QuY3JlYXRlKG51bGwpKTt2YXIgdD1vW2VdO3JldHVybiB2b2lkIDA9PT10W25dJiYodFtuXT1pKGUsbikpLHRbbl19dC5uZXdTdG9yYWdlPWksdC5nZXRTdG9yYWdlPWEsdC5hZGRJY29uU2V0PWZ1bmN0aW9uKGUsbix0KXt2b2lkIDA9PT10JiYodD1cIm5vbmVcIik7dmFyIG89RGF0ZS5ub3coKTtyZXR1cm4gci5wYXJzZUljb25TZXQobiwoZnVuY3Rpb24obix0KXtudWxsPT09dD9lLm1pc3Npbmdbbl09bzplLmljb25zW25dPXR9KSx0KX0sdC5hZGRJY29uPWZ1bmN0aW9uKGUsdCxyKXt0cnl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHIuYm9keSlyZXR1cm4gZS5pY29uc1t0XT1PYmplY3QuZnJlZXplKG4uZnVsbEljb24ocikpLCEwfWNhdGNoKGUpe31yZXR1cm4hMX0sdC5pY29uRXhpc3RzPWZ1bmN0aW9uKGUsbil7cmV0dXJuIHZvaWQgMCE9PWUuaWNvbnNbbl19LHQuZ2V0SWNvbj1mdW5jdGlvbihlLG4pe3ZhciB0PWUuaWNvbnNbbl07cmV0dXJuIHZvaWQgMD09PXQ/bnVsbDp0fSx0Lmxpc3RJY29ucz1mdW5jdGlvbihlLG4pe3ZhciB0PVtdO3JldHVybihcInN0cmluZ1wiPT10eXBlb2YgZT9bZV06T2JqZWN0LmtleXMobykpLmZvckVhY2goKGZ1bmN0aW9uKGUpeyhcInN0cmluZ1wiPT10eXBlb2YgZSYmXCJzdHJpbmdcIj09dHlwZW9mIG4/W25dOnZvaWQgMD09PW9bZV0/W106T2JqZWN0LmtleXMob1tlXSkpLmZvckVhY2goKGZ1bmN0aW9uKG4pe3ZhciByPWEoZSxuKSxvPU9iamVjdC5rZXlzKHIuaWNvbnMpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuKFwiXCIhPT1lP1wiQFwiK2UrXCI6XCI6XCJcIikrbitcIjpcIit0fSkpO3Q9dC5jb25jYXQobyl9KSl9KSksdH19KSksYT1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uc3RvcmFnZUZ1bmN0aW9ucz1uLmFkZENvbGxlY3Rpb249bi5hZGRJY29uPW4uZ2V0SWNvbkRhdGE9bi5hbGxvd1NpbXBsZU5hbWVzPXZvaWQgMDt2YXIgdD0hMTtmdW5jdGlvbiBhKGUpe3ZhciBuPVwic3RyaW5nXCI9PXR5cGVvZiBlP28uc3RyaW5nVG9JY29uKGUsITAsdCk6ZTtyZXR1cm4gbj9pLmdldEljb24oaS5nZXRTdG9yYWdlKG4ucHJvdmlkZXIsbi5wcmVmaXgpLG4ubmFtZSk6bnVsbH1mdW5jdGlvbiBjKGUsbil7dmFyIHI9by5zdHJpbmdUb0ljb24oZSwhMCx0KTtpZighcilyZXR1cm4hMTt2YXIgYT1pLmdldFN0b3JhZ2Uoci5wcm92aWRlcixyLnByZWZpeCk7cmV0dXJuIGkuYWRkSWNvbihhLHIubmFtZSxuKX1mdW5jdGlvbiB1KGUsbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUpcmV0dXJuITE7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIG4mJihuPVwic3RyaW5nXCI9PXR5cGVvZiBlLnByb3ZpZGVyP2UucHJvdmlkZXI6XCJcIiksdCYmXCJcIj09PW4mJihcInN0cmluZ1wiIT10eXBlb2YgZS5wcmVmaXh8fFwiXCI9PT1lLnByZWZpeCkpe3ZhciBhPSExO3JldHVybiByLnBhcnNlSWNvblNldChlLChmdW5jdGlvbihlLG4pe251bGwhPT1uJiZjKGUsbikmJihhPSEwKX0pKSxhfWlmKFwic3RyaW5nXCIhPXR5cGVvZiBlLnByZWZpeHx8IW8udmFsaWRhdGVJY29uKHtwcm92aWRlcjpuLHByZWZpeDplLnByZWZpeCxuYW1lOlwiYVwifSkpcmV0dXJuITE7dmFyIHU9aS5nZXRTdG9yYWdlKG4sZS5wcmVmaXgpO3JldHVybiEhaS5hZGRJY29uU2V0KHUsZSl9bi5hbGxvd1NpbXBsZU5hbWVzPWZ1bmN0aW9uKGUpe3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgZSYmKHQ9ZSksdH0sbi5nZXRJY29uRGF0YT1hLG4uYWRkSWNvbj1jLG4uYWRkQ29sbGVjdGlvbj11LG4uc3RvcmFnZUZ1bmN0aW9ucz17aWNvbkV4aXN0czpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWEoZSl9LGdldEljb246ZnVuY3Rpb24oZSl7dmFyIG49YShlKTtyZXR1cm4gbj9PYmplY3QuYXNzaWduKHt9LG4pOm51bGx9LGxpc3RJY29uczppLmxpc3RJY29ucyxhZGRJY29uOmMsYWRkQ29sbGVjdGlvbjp1fX0pKSxjPWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5yZXBsYWNlSURzPXZvaWQgMDt2YXIgdD0vXFxzaWQ9XCIoXFxTKylcIi9nLHI9XCIoW15BLVphLXowLTlfLV0pXCI7dmFyIG89XCJJY29uaWZ5SWQtXCIrRGF0ZS5ub3coKS50b1N0cmluZygxNikrXCItXCIrKDE2Nzc3MjE2Kk1hdGgucmFuZG9tKCl8MCkudG9TdHJpbmcoMTYpK1wiLVwiLGk9MDtuLnJlcGxhY2VJRHM9ZnVuY3Rpb24oZSxuKXt2b2lkIDA9PT1uJiYobj1vKTtmb3IodmFyIGEsYz1bXTthPXQuZXhlYyhlKTspYy5wdXNoKGFbMV0pO3JldHVybiBjLmxlbmd0aD8oYy5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgbz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP24oKTpuK2krKztlPWUucmVwbGFjZShuZXcgUmVnRXhwKHIrXCIoXCIrKHQucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csXCJcXFxcJCZcIikrXCIpXCIpK3IsXCJnXCIpLFwiJDFcIitvK1wiJDNcIil9KSksZSk6ZX19KSksdT1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uY2FsY3VsYXRlU2l6ZT12b2lkIDA7dmFyIHQ9LygtP1swLTkuXSpbMC05XStbMC05Ll0qKS9nLHI9L14tP1swLTkuXSpbMC05XStbMC05Ll0qJC9nO24uY2FsY3VsYXRlU2l6ZT1mdW5jdGlvbihlLG4sbyl7aWYoMT09PW4pcmV0dXJuIGU7aWYobz12b2lkIDA9PT1vPzEwMDpvLFwibnVtYmVyXCI9PXR5cGVvZiBlKXJldHVybiBNYXRoLmNlaWwoZSpuKm8pL287aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUpcmV0dXJuIGU7dmFyIGk9ZS5zcGxpdCh0KTtpZihudWxsPT09aXx8IWkubGVuZ3RoKXJldHVybiBlO2Zvcih2YXIgYT1bXSxjPWkuc2hpZnQoKSx1PXIudGVzdChjKTs7KXtpZih1KXt2YXIgZj1wYXJzZUZsb2F0KGMpO2lzTmFOKGYpP2EucHVzaChjKTphLnB1c2goTWF0aC5jZWlsKGYqbipvKS9vKX1lbHNlIGEucHVzaChjKTtpZih2b2lkIDA9PT0oYz1pLnNoaWZ0KCkpKXJldHVybiBhLmpvaW4oXCJcIik7dT0hdX19fSkpLGY9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLm1lcmdlQ3VzdG9taXNhdGlvbnM9bi5kZWZhdWx0cz12b2lkIDAsbi5kZWZhdWx0cz1PYmplY3QuZnJlZXplKHtpbmxpbmU6ITEsd2lkdGg6bnVsbCxoZWlnaHQ6bnVsbCxoQWxpZ246XCJjZW50ZXJcIix2QWxpZ246XCJtaWRkbGVcIixzbGljZTohMSxoRmxpcDohMSx2RmxpcDohMSxyb3RhdGU6MH0pLG4ubWVyZ2VDdXN0b21pc2F0aW9ucz1mdW5jdGlvbihlLG4pe3ZhciB0PXt9O2Zvcih2YXIgciBpbiBlKXt2YXIgbz1yO2lmKHRbb109ZVtvXSx2b2lkIDAhPT1uW29dKXt2YXIgaT1uW29dO3N3aXRjaChvKXtjYXNlXCJpbmxpbmVcIjpjYXNlXCJzbGljZVwiOlwiYm9vbGVhblwiPT10eXBlb2YgaSYmKHRbb109aSk7YnJlYWs7Y2FzZVwiaEZsaXBcIjpjYXNlXCJ2RmxpcFwiOiEwPT09aSYmKHRbb109IXRbb10pO2JyZWFrO2Nhc2VcImhBbGlnblwiOmNhc2VcInZBbGlnblwiOlwic3RyaW5nXCI9PXR5cGVvZiBpJiZcIlwiIT09aSYmKHRbb109aSk7YnJlYWs7Y2FzZVwid2lkdGhcIjpjYXNlXCJoZWlnaHRcIjooXCJzdHJpbmdcIj09dHlwZW9mIGkmJlwiXCIhPT1pfHxcIm51bWJlclwiPT10eXBlb2YgaSYmaXx8bnVsbD09PWkpJiYodFtvXT1pKTticmVhaztjYXNlXCJyb3RhdGVcIjpcIm51bWJlclwiPT10eXBlb2YgaSYmKHRbb10rPWkpfX19cmV0dXJuIHR9fSkpLGw9ZSgoZnVuY3Rpb24oZSxuKXtmdW5jdGlvbiB0KGUpe3ZhciBuPVwiXCI7c3dpdGNoKGUuaEFsaWduKXtjYXNlXCJsZWZ0XCI6bis9XCJ4TWluXCI7YnJlYWs7Y2FzZVwicmlnaHRcIjpuKz1cInhNYXhcIjticmVhaztkZWZhdWx0Om4rPVwieE1pZFwifXN3aXRjaChlLnZBbGlnbil7Y2FzZVwidG9wXCI6bis9XCJZTWluXCI7YnJlYWs7Y2FzZVwiYm90dG9tXCI6bis9XCJZTWF4XCI7YnJlYWs7ZGVmYXVsdDpuKz1cIllNaWRcIn1yZXR1cm4gbis9ZS5zbGljZT9cIiBzbGljZVwiOlwiIG1lZXRcIn1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmljb25Ub1NWRz12b2lkIDAsbi5pY29uVG9TVkc9ZnVuY3Rpb24oZSxuKXt2YXIgcixvLGk9e2xlZnQ6ZS5sZWZ0LHRvcDplLnRvcCx3aWR0aDplLndpZHRoLGhlaWdodDplLmhlaWdodH0sYT1lLmJvZHk7W2Usbl0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG4sdD1bXSxyPWUuaEZsaXAsbz1lLnZGbGlwLGM9ZS5yb3RhdGU7c3dpdGNoKHI/bz9jKz0yOih0LnB1c2goXCJ0cmFuc2xhdGUoXCIrKGkud2lkdGgraS5sZWZ0KStcIiBcIisoMC1pLnRvcCkrXCIpXCIpLHQucHVzaChcInNjYWxlKC0xIDEpXCIpLGkudG9wPWkubGVmdD0wKTpvJiYodC5wdXNoKFwidHJhbnNsYXRlKFwiKygwLWkubGVmdCkrXCIgXCIrKGkuaGVpZ2h0K2kudG9wKStcIilcIiksdC5wdXNoKFwic2NhbGUoMSAtMSlcIiksaS50b3A9aS5sZWZ0PTApLGM8MCYmKGMtPTQqTWF0aC5mbG9vcihjLzQpKSxjJT00KXtjYXNlIDE6bj1pLmhlaWdodC8yK2kudG9wLHQudW5zaGlmdChcInJvdGF0ZSg5MCBcIituK1wiIFwiK24rXCIpXCIpO2JyZWFrO2Nhc2UgMjp0LnVuc2hpZnQoXCJyb3RhdGUoMTgwIFwiKyhpLndpZHRoLzIraS5sZWZ0KStcIiBcIisoaS5oZWlnaHQvMitpLnRvcCkrXCIpXCIpO2JyZWFrO2Nhc2UgMzpuPWkud2lkdGgvMitpLmxlZnQsdC51bnNoaWZ0KFwicm90YXRlKC05MCBcIituK1wiIFwiK24rXCIpXCIpfWMlMj09MSYmKDA9PT1pLmxlZnQmJjA9PT1pLnRvcHx8KG49aS5sZWZ0LGkubGVmdD1pLnRvcCxpLnRvcD1uKSxpLndpZHRoIT09aS5oZWlnaHQmJihuPWkud2lkdGgsaS53aWR0aD1pLmhlaWdodCxpLmhlaWdodD1uKSksdC5sZW5ndGgmJihhPSc8ZyB0cmFuc2Zvcm09XCInK3Quam9pbihcIiBcIikrJ1wiPicrYStcIjwvZz5cIil9KSksbnVsbD09PW4ud2lkdGgmJm51bGw9PT1uLmhlaWdodD8obz1cIjFlbVwiLHI9dS5jYWxjdWxhdGVTaXplKG8saS53aWR0aC9pLmhlaWdodCkpOm51bGwhPT1uLndpZHRoJiZudWxsIT09bi5oZWlnaHQ/KHI9bi53aWR0aCxvPW4uaGVpZ2h0KTpudWxsIT09bi5oZWlnaHQ/KG89bi5oZWlnaHQscj11LmNhbGN1bGF0ZVNpemUobyxpLndpZHRoL2kuaGVpZ2h0KSk6KHI9bi53aWR0aCxvPXUuY2FsY3VsYXRlU2l6ZShyLGkuaGVpZ2h0L2kud2lkdGgpKSxcImF1dG9cIj09PXImJihyPWkud2lkdGgpLFwiYXV0b1wiPT09byYmKG89aS5oZWlnaHQpO3ZhciBjPXthdHRyaWJ1dGVzOnt3aWR0aDpyPVwic3RyaW5nXCI9PXR5cGVvZiByP3I6citcIlwiLGhlaWdodDpvPVwic3RyaW5nXCI9PXR5cGVvZiBvP286bytcIlwiLHByZXNlcnZlQXNwZWN0UmF0aW86dChuKSx2aWV3Qm94OmkubGVmdCtcIiBcIitpLnRvcCtcIiBcIitpLndpZHRoK1wiIFwiK2kuaGVpZ2h0fSxib2R5OmF9O3JldHVybiBuLmlubGluZSYmKGMuaW5saW5lPSEwKSxjfX0pKSxzPWUoKGZ1bmN0aW9uKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5idWlsZGVyRnVuY3Rpb25zPXZvaWQgMCx0LmJ1aWxkZXJGdW5jdGlvbnM9e3JlcGxhY2VJRHM6Yy5yZXBsYWNlSURzLGNhbGN1bGF0ZVNpemU6dS5jYWxjdWxhdGVTaXplLGJ1aWxkSWNvbjpmdW5jdGlvbihlLHQpe3JldHVybiBsLmljb25Ub1NWRyhuLmZ1bGxJY29uKGUpLGYubWVyZ2VDdXN0b21pc2F0aW9ucyhmLmRlZmF1bHRzLHQpKX19fSkpLGQ9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmNvcmVNb2R1bGVzPXZvaWQgMCxuLmNvcmVNb2R1bGVzPXt9fSkpLHY9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnN0b3JlQ2FjaGU9bi5sb2FkQ2FjaGU9bi5tb2NrPW4uZW1wdHlMaXN0PW4uY291bnQ9bi5jb25maWc9dm9pZCAwO3ZhciB0PVwiaWNvbmlmeTJcIixyPVwiaWNvbmlmeVwiLG89XCJpY29uaWZ5LWNvdW50XCIsYT1cImljb25pZnktdmVyc2lvblwiLGM9MzZlNTtuLmNvbmZpZz17bG9jYWw6ITAsc2Vzc2lvbjohMH07dmFyIHU9ITE7bi5jb3VudD17bG9jYWw6MCxzZXNzaW9uOjB9LG4uZW1wdHlMaXN0PXtsb2NhbDpbXSxzZXNzaW9uOltdfTt2YXIgZj1cInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93P3t9OndpbmRvdztmdW5jdGlvbiBsKGUpe3ZhciB0PWUrXCJTdG9yYWdlXCI7dHJ5e2lmKGYmJmZbdF0mJlwibnVtYmVyXCI9PXR5cGVvZiBmW3RdLmxlbmd0aClyZXR1cm4gZlt0XX1jYXRjaChlKXt9cmV0dXJuIG4uY29uZmlnW2VdPSExLG51bGx9ZnVuY3Rpb24gcyhlLHQscil7dHJ5e3JldHVybiBlLnNldEl0ZW0obyxyK1wiXCIpLG4uY291bnRbdF09ciwhMH1jYXRjaChlKXtyZXR1cm4hMX19ZnVuY3Rpb24gZChlKXt2YXIgbj1lLmdldEl0ZW0obyk7aWYobil7dmFyIHQ9cGFyc2VJbnQobik7cmV0dXJuIHR8fDB9cmV0dXJuIDB9bi5tb2NrPWZ1bmN0aW9uKGUpe3U9ITEsZj1lfTtuLmxvYWRDYWNoZT1mdW5jdGlvbigpe2lmKCF1KXt1PSEwO3ZhciBlPU1hdGguZmxvb3IoRGF0ZS5ub3coKS9jKS0xNjg7Zm9yKHZhciBvIGluIG4uY29uZmlnKWYobyl9ZnVuY3Rpb24gZihvKXt2YXIgYz1sKG8pO2lmKGMpe3ZhciB1PWZ1bmN0aW9uKG4pe3ZhciB0PXIrbixvPWMuZ2V0SXRlbSh0KTtpZihcInN0cmluZ1wiIT10eXBlb2YgbylyZXR1cm4hMTt2YXIgYT0hMDt0cnl7dmFyIHU9SlNPTi5wYXJzZShvKTtpZihcIm9iamVjdFwiIT10eXBlb2YgdXx8XCJudW1iZXJcIiE9dHlwZW9mIHUuY2FjaGVkfHx1LmNhY2hlZDxlfHxcInN0cmluZ1wiIT10eXBlb2YgdS5wcm92aWRlcnx8XCJvYmplY3RcIiE9dHlwZW9mIHUuZGF0YXx8XCJzdHJpbmdcIiE9dHlwZW9mIHUuZGF0YS5wcmVmaXgpYT0hMTtlbHNle3ZhciBmPXUucHJvdmlkZXIsbD11LmRhdGEucHJlZml4LHM9aS5nZXRTdG9yYWdlKGYsbCk7YT1pLmFkZEljb25TZXQocyx1LmRhdGEpfX1jYXRjaChlKXthPSExfXJldHVybiBhfHxjLnJlbW92ZUl0ZW0odCksYX07dHJ5e3ZhciBmPWMuZ2V0SXRlbShhKTtpZihmIT09dClyZXR1cm4gZiYmZnVuY3Rpb24oZSl7dHJ5e2Zvcih2YXIgbj1kKGUpLHQ9MDt0PG47dCsrKWUucmVtb3ZlSXRlbShyK3QpfWNhdGNoKGUpe319KGMpLHZvaWQgZnVuY3Rpb24oZSxuKXt0cnl7ZS5zZXRJdGVtKGEsdCl9Y2F0Y2goZSl7fXMoZSxuLDApfShjLG8pO2Zvcih2YXIgdj1kKGMpLHA9di0xO3A+PTA7cC0tKXUocCl8fChwPT09di0xP3YtLTpuLmVtcHR5TGlzdFtvXS5wdXNoKHApKTtzKGMsbyx2KX1jYXRjaChlKXt9fX19O24uc3RvcmVDYWNoZT1mdW5jdGlvbihlLHQpe2Z1bmN0aW9uIG8obyl7aWYoIW4uY29uZmlnW29dKXJldHVybiExO3ZhciBpPWwobyk7aWYoIWkpcmV0dXJuITE7dmFyIGE9bi5lbXB0eUxpc3Rbb10uc2hpZnQoKTtpZih2b2lkIDA9PT1hJiYhcyhpLG8sKGE9bi5jb3VudFtvXSkrMSkpcmV0dXJuITE7dHJ5e3ZhciB1PXtjYWNoZWQ6TWF0aC5mbG9vcihEYXRlLm5vdygpL2MpLHByb3ZpZGVyOmUsZGF0YTp0fTtpLnNldEl0ZW0ocithLEpTT04uc3RyaW5naWZ5KHUpKX1jYXRjaChlKXtyZXR1cm4hMX1yZXR1cm4hMH11fHxuLmxvYWRDYWNoZSgpLG8oXCJsb2NhbFwiKXx8byhcInNlc3Npb25cIil9fSkpLHA9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnRvZ2dsZUJyb3dzZXJDYWNoZT12b2lkIDAsbi50b2dnbGVCcm93c2VyQ2FjaGU9ZnVuY3Rpb24oZSxuKXtzd2l0Y2goZSl7Y2FzZVwibG9jYWxcIjpjYXNlXCJzZXNzaW9uXCI6di5jb25maWdbZV09bjticmVhaztjYXNlXCJhbGxcIjpmb3IodmFyIHQgaW4gdi5jb25maWcpdi5jb25maWdbdF09bn19fSkpLGg9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmRlZmF1bHRDb25maWc9dm9pZCAwLG4uZGVmYXVsdENvbmZpZz17cmVzb3VyY2VzOltdLGluZGV4OjAsdGltZW91dDoyZTMscm90YXRlOjc1MCxyYW5kb206ITEsZGF0YUFmdGVyVGltZW91dDohMX19KSksZz1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uc2VuZFF1ZXJ5PXZvaWQgMCxuLnNlbmRRdWVyeT1mdW5jdGlvbihlLG4sdCxyLG8pe3ZhciBpLGE9ZS5yZXNvdXJjZXMubGVuZ3RoLGM9ZS5yYW5kb20/TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKmEpOmUuaW5kZXg7aWYoZS5yYW5kb20pe3ZhciB1PWUucmVzb3VyY2VzLnNsaWNlKDApO2ZvcihpPVtdO3UubGVuZ3RoPjE7KXt2YXIgZj1NYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqdS5sZW5ndGgpO2kucHVzaCh1W2ZdKSx1PXUuc2xpY2UoMCxmKS5jb25jYXQodS5zbGljZShmKzEpKX1pPWkuY29uY2F0KHUpfWVsc2UgaT1lLnJlc291cmNlcy5zbGljZShjKS5jb25jYXQoZS5yZXNvdXJjZXMuc2xpY2UoMCxjKSk7dmFyIGw9RGF0ZS5ub3coKSxzPVwicGVuZGluZ1wiLGQ9MCx2PXZvaWQgMCxwPW51bGwsaD1bXSxnPVtdO2Z1bmN0aW9uIG0oKXtwJiYoY2xlYXJUaW1lb3V0KHApLHA9bnVsbCl9ZnVuY3Rpb24gYigpe1wicGVuZGluZ1wiPT09cyYmKHM9XCJhYm9ydGVkXCIpLG0oKSxoLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UuYWJvcnQmJmUuYWJvcnQoKSxcInBlbmRpbmdcIj09PWUuc3RhdHVzJiYoZS5zdGF0dXM9XCJhYm9ydGVkXCIpfSkpLGg9W119ZnVuY3Rpb24geShlLG4pe24mJihnPVtdKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZnLnB1c2goZSl9ZnVuY3Rpb24gSSgpe3JldHVybntzdGFydFRpbWU6bCxwYXlsb2FkOm4sc3RhdHVzOnMscXVlcmllc1NlbnQ6ZCxxdWVyaWVzUGVuZGluZzpoLmxlbmd0aCxzdWJzY3JpYmU6eSxhYm9ydDpifX1mdW5jdGlvbiBqKCl7cz1cImZhaWxlZFwiLGcuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZSh2b2lkIDAsdil9KSl9ZnVuY3Rpb24geCgpe2g9aC5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVyblwicGVuZGluZ1wiPT09ZS5zdGF0dXMmJihlLnN0YXR1cz1cImFib3J0ZWRcIiksZS5hYm9ydCYmZS5hYm9ydCgpLCExfSkpfWZ1bmN0aW9uIE8oKXtpZihcInBlbmRpbmdcIj09PXMpe20oKTt2YXIgcj1pLnNoaWZ0KCk7aWYodm9pZCAwIT09cil7dmFyIGE9e2dldFF1ZXJ5U3RhdHVzOkksc3RhdHVzOlwicGVuZGluZ1wiLHJlc291cmNlOnIsZG9uZTpmdW5jdGlvbihuLHQpeyFmdW5jdGlvbihuLHQscil7dmFyIGE9dm9pZCAwPT09dDtzd2l0Y2goaD1oLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUhPT1ufSkpLHMpe2Nhc2VcInBlbmRpbmdcIjpicmVhaztjYXNlXCJmYWlsZWRcIjppZihhfHwhZS5kYXRhQWZ0ZXJUaW1lb3V0KXJldHVybjticmVhaztkZWZhdWx0OnJldHVybn1pZihhKXJldHVybiB2b2lkIDAhPT1yJiYodj1yKSx2b2lkKGgubGVuZ3RofHwoaS5sZW5ndGg/TygpOmooKSkpO2lmKG0oKSx4KCksbyYmIWUucmFuZG9tKXt2YXIgYz1lLnJlc291cmNlcy5pbmRleE9mKG4ucmVzb3VyY2UpOy0xIT09YyYmYyE9PWUuaW5kZXgmJm8oYyl9cz1cImNvbXBsZXRlZFwiLGcuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZSh0KX0pKX0oYSxuLHQpfX07aC5wdXNoKGEpLGQrKzt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnJvdGF0ZT9lLnJvdGF0ZShkLGwpOmUucm90YXRlO3A9c2V0VGltZW91dChPLGMpLHQocixuLGEpfWVsc2V7aWYoaC5sZW5ndGgpe3ZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIGUudGltZW91dD9lLnRpbWVvdXQobCk6ZS50aW1lb3V0O2lmKHUpcmV0dXJuIHZvaWQocD1zZXRUaW1lb3V0KChmdW5jdGlvbigpe20oKSxcInBlbmRpbmdcIj09PXMmJih4KCksaigpKX0pLHUpKX1qKCl9fX1yZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiByJiZnLnB1c2gociksc2V0VGltZW91dChPKSxJfX0pKSxtPWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5pbml0UmVkdW5kYW5jeT12b2lkIDAsbi5pbml0UmVkdW5kYW5jeT1mdW5jdGlvbihlKXt2YXIgbj1mdW5jdGlvbihlKXtpZighKFwib2JqZWN0XCI9PXR5cGVvZiBlJiZcIm9iamVjdFwiPT10eXBlb2YgZS5yZXNvdXJjZXMmJmUucmVzb3VyY2VzIGluc3RhbmNlb2YgQXJyYXkmJmUucmVzb3VyY2VzLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSZWR1bmNhbmN5IGNvbmZpZ3VyYXRpb25cIik7dmFyIG4sdD1PYmplY3QuY3JlYXRlKG51bGwpO2ZvcihuIGluIGguZGVmYXVsdENvbmZpZyl2b2lkIDAhPT1lW25dP3Rbbl09ZVtuXTp0W25dPWguZGVmYXVsdENvbmZpZ1tuXTtyZXR1cm4gdH0oZSksdD1bXTtmdW5jdGlvbiByKCl7dD10LmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuXCJwZW5kaW5nXCI9PT1lKCkuc3RhdHVzfSkpfXJldHVybntxdWVyeTpmdW5jdGlvbihlLG8saSl7dmFyIGE9Zy5zZW5kUXVlcnkobixlLG8sKGZ1bmN0aW9uKGUsbil7cigpLGkmJmkoZSxuKX0pLChmdW5jdGlvbihlKXtuLmluZGV4PWV9KSk7cmV0dXJuIHQucHVzaChhKSxhfSxmaW5kOmZ1bmN0aW9uKGUpe3ZhciBuPXQuZmluZCgoZnVuY3Rpb24obil7cmV0dXJuIGUobil9KSk7cmV0dXJuIHZvaWQgMCE9PW4/bjpudWxsfSxzZXRJbmRleDpmdW5jdGlvbihlKXtuLmluZGV4PWV9LGdldEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIG4uaW5kZXh9LGNsZWFudXA6cn19fSkpLGI9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnNvcnRJY29ucz12b2lkIDAsbi5zb3J0SWNvbnM9ZnVuY3Rpb24oZSl7dmFyIG49e2xvYWRlZDpbXSxtaXNzaW5nOltdLHBlbmRpbmc6W119LHQ9T2JqZWN0LmNyZWF0ZShudWxsKTtlLnNvcnQoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGUucHJvdmlkZXIhPT1uLnByb3ZpZGVyP2UucHJvdmlkZXIubG9jYWxlQ29tcGFyZShuLnByb3ZpZGVyKTplLnByZWZpeCE9PW4ucHJlZml4P2UucHJlZml4LmxvY2FsZUNvbXBhcmUobi5wcmVmaXgpOmUubmFtZS5sb2NhbGVDb21wYXJlKG4ubmFtZSl9KSk7dmFyIHI9e3Byb3ZpZGVyOlwiXCIscHJlZml4OlwiXCIsbmFtZTpcIlwifTtyZXR1cm4gZS5mb3JFYWNoKChmdW5jdGlvbihlKXtpZihyLm5hbWUhPT1lLm5hbWV8fHIucHJlZml4IT09ZS5wcmVmaXh8fHIucHJvdmlkZXIhPT1lLnByb3ZpZGVyKXtyPWU7dmFyIG89ZS5wcm92aWRlcixhPWUucHJlZml4LGM9ZS5uYW1lO3ZvaWQgMD09PXRbb10mJih0W29dPU9iamVjdC5jcmVhdGUobnVsbCkpO3ZhciB1PXRbb107dm9pZCAwPT09dVthXSYmKHVbYV09aS5nZXRTdG9yYWdlKG8sYSkpO3ZhciBmPXVbYV0sbD17cHJvdmlkZXI6byxwcmVmaXg6YSxuYW1lOmN9Oyh2b2lkIDAhPT1mLmljb25zW2NdP24ubG9hZGVkOlwiXCI9PT1hfHx2b2lkIDAhPT1mLm1pc3NpbmdbY10/bi5taXNzaW5nOm4ucGVuZGluZykucHVzaChsKX19KSksbn19KSkseT1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uc3RvcmVDYWxsYmFjaz1uLnVwZGF0ZUNhbGxiYWNrcz1uLmNhbGxiYWNrcz12b2lkIDAsbi5jYWxsYmFja3M9T2JqZWN0LmNyZWF0ZShudWxsKTt2YXIgdD1PYmplY3QuY3JlYXRlKG51bGwpO2Z1bmN0aW9uIHIoZSx0KXtlLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciByPWUucHJvdmlkZXI7aWYodm9pZCAwIT09bi5jYWxsYmFja3Nbcl0pe3ZhciBvPW4uY2FsbGJhY2tzW3JdLGk9ZS5wcmVmaXgsYT1vW2ldO2EmJihvW2ldPWEuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZCE9PXR9KSkpfX0pKX1uLnVwZGF0ZUNhbGxiYWNrcz1mdW5jdGlvbihlLG8pe3ZvaWQgMD09PXRbZV0mJih0W2VdPU9iamVjdC5jcmVhdGUobnVsbCkpO3ZhciBhPXRbZV07YVtvXXx8KGFbb109ITAsc2V0VGltZW91dCgoZnVuY3Rpb24oKXtpZihhW29dPSExLHZvaWQgMCE9PW4uY2FsbGJhY2tzW2VdJiZ2b2lkIDAhPT1uLmNhbGxiYWNrc1tlXVtvXSl7dmFyIHQ9bi5jYWxsYmFja3NbZV1bb10uc2xpY2UoMCk7aWYodC5sZW5ndGgpe3ZhciBjPWkuZ2V0U3RvcmFnZShlLG8pLHU9ITE7dC5mb3JFYWNoKChmdW5jdGlvbihuKXt2YXIgdD1uLmljb25zLGk9dC5wZW5kaW5nLmxlbmd0aDt0LnBlbmRpbmc9dC5wZW5kaW5nLmZpbHRlcigoZnVuY3Rpb24obil7aWYobi5wcmVmaXghPT1vKXJldHVybiEwO3ZhciByPW4ubmFtZTtpZih2b2lkIDAhPT1jLmljb25zW3JdKXQubG9hZGVkLnB1c2goe3Byb3ZpZGVyOmUscHJlZml4Om8sbmFtZTpyfSk7ZWxzZXtpZih2b2lkIDA9PT1jLm1pc3Npbmdbcl0pcmV0dXJuIHU9ITAsITA7dC5taXNzaW5nLnB1c2goe3Byb3ZpZGVyOmUscHJlZml4Om8sbmFtZTpyfSl9cmV0dXJuITF9KSksdC5wZW5kaW5nLmxlbmd0aCE9PWkmJih1fHxyKFt7cHJvdmlkZXI6ZSxwcmVmaXg6b31dLG4uaWQpLG4uY2FsbGJhY2sodC5sb2FkZWQuc2xpY2UoMCksdC5taXNzaW5nLnNsaWNlKDApLHQucGVuZGluZy5zbGljZSgwKSxuLmFib3J0KSl9KSl9fX0pKSl9O3ZhciBvPTA7bi5zdG9yZUNhbGxiYWNrPWZ1bmN0aW9uKGUsdCxpKXt2YXIgYT1vKyssYz1yLmJpbmQobnVsbCxpLGEpO2lmKCF0LnBlbmRpbmcubGVuZ3RoKXJldHVybiBjO3ZhciB1PXtpZDphLGljb25zOnQsY2FsbGJhY2s6ZSxhYm9ydDpjfTtyZXR1cm4gaS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdD1lLnByb3ZpZGVyLHI9ZS5wcmVmaXg7dm9pZCAwPT09bi5jYWxsYmFja3NbdF0mJihuLmNhbGxiYWNrc1t0XT1PYmplY3QuY3JlYXRlKG51bGwpKTt2YXIgbz1uLmNhbGxiYWNrc1t0XTt2b2lkIDA9PT1vW3JdJiYob1tyXT1bXSksb1tyXS5wdXNoKHUpfSkpLGN9fSkpLEk9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmdldEFQSU1vZHVsZT1uLnNldEFQSU1vZHVsZT12b2lkIDA7dmFyIHQ9T2JqZWN0LmNyZWF0ZShudWxsKTtuLnNldEFQSU1vZHVsZT1mdW5jdGlvbihlLG4pe3RbZV09bn0sbi5nZXRBUElNb2R1bGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PXRbZV0/dFtcIlwiXTp0W2VdfX0pKSxqPWUoKGZ1bmN0aW9uKGUsbil7ZnVuY3Rpb24gdChlKXt2YXIgbjtpZihcInN0cmluZ1wiPT10eXBlb2YgZS5yZXNvdXJjZXMpbj1bZS5yZXNvdXJjZXNdO2Vsc2UgaWYoISgobj1lLnJlc291cmNlcylpbnN0YW5jZW9mIEFycmF5JiZuLmxlbmd0aCkpcmV0dXJuIG51bGw7cmV0dXJue3Jlc291cmNlczpuLHBhdGg6dm9pZCAwPT09ZS5wYXRoP1wiL1wiOmUucGF0aCxtYXhVUkw6ZS5tYXhVUkw/ZS5tYXhVUkw6NTAwLHJvdGF0ZTplLnJvdGF0ZT9lLnJvdGF0ZTo3NTAsdGltZW91dDplLnRpbWVvdXQ/ZS50aW1lb3V0OjVlMyxyYW5kb206ITA9PT1lLnJhbmRvbSxpbmRleDplLmluZGV4P2UuaW5kZXg6MCxkYXRhQWZ0ZXJUaW1lb3V0OiExIT09ZS5kYXRhQWZ0ZXJUaW1lb3V0fX1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmdldEFQSUNvbmZpZz1uLnNldEFQSUNvbmZpZz12b2lkIDA7Zm9yKHZhciByPU9iamVjdC5jcmVhdGUobnVsbCksbz1bXCJodHRwczovL2FwaS5zaW1wbGVzdmcuY29tXCIsXCJodHRwczovL2FwaS51bmlzdmcuY29tXCJdLGk9W107by5sZW5ndGg+MDspMT09PW8ubGVuZ3RofHxNYXRoLnJhbmRvbSgpPi41P2kucHVzaChvLnNoaWZ0KCkpOmkucHVzaChvLnBvcCgpKTtyW1wiXCJdPXQoe3Jlc291cmNlczpbXCJodHRwczovL2FwaS5pY29uaWZ5LmRlc2lnblwiXS5jb25jYXQoaSl9KSxuLnNldEFQSUNvbmZpZz1mdW5jdGlvbihlLG4pe3ZhciBvPXQobik7cmV0dXJuIG51bGwhPT1vJiYocltlXT1vLCEwKX07bi5nZXRBUElDb25maWc9ZnVuY3Rpb24oZSl7cmV0dXJuIHJbZV19fSkpLHg9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmdldFByb3ZpZGVycz1uLmxpc3RUb0ljb25zPXZvaWQgMCxuLmxpc3RUb0ljb25zPWZ1bmN0aW9uKGUsbix0KXt2b2lkIDA9PT1uJiYobj0hMCksdm9pZCAwPT09dCYmKHQ9ITEpO3ZhciByPVtdO3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBpPVwic3RyaW5nXCI9PXR5cGVvZiBlP28uc3RyaW5nVG9JY29uKGUsITEsdCk6ZTtuJiYhby52YWxpZGF0ZUljb24oaSx0KXx8ci5wdXNoKHtwcm92aWRlcjppLnByb3ZpZGVyLHByZWZpeDppLnByZWZpeCxuYW1lOmkubmFtZX0pfSkpLHJ9LG4uZ2V0UHJvdmlkZXJzPWZ1bmN0aW9uKGUpe3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCk7cmV0dXJuIGUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7bltlLnByb3ZpZGVyXT0hMH0pKSxPYmplY3Qua2V5cyhuKX19KSksTz1lKChmdW5jdGlvbihlLG4pe2Z1bmN0aW9uIHQoKXt9T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5BUEk9bi5nZXRSZWR1bmRhbmN5Q2FjaGU9dm9pZCAwO3ZhciByPU9iamVjdC5jcmVhdGUobnVsbCksbz1PYmplY3QuY3JlYXRlKG51bGwpLGM9T2JqZWN0LmNyZWF0ZShudWxsKSx1PU9iamVjdC5jcmVhdGUobnVsbCksZj1PYmplY3QuY3JlYXRlKG51bGwpO2Z1bmN0aW9uIGwoZSl7aWYodm9pZCAwPT09ZltlXSl7dmFyIG49ai5nZXRBUElDb25maWcoZSk7aWYoIW4pcmV0dXJuO3ZhciB0PXtjb25maWc6bixyZWR1bmRhbmN5Om0uaW5pdFJlZHVuZGFuY3kobil9O2ZbZV09dH1yZXR1cm4gZltlXX1uLmdldFJlZHVuZGFuY3lDYWNoZT1sO3ZhciBzPU9iamVjdC5jcmVhdGUobnVsbCk7ZnVuY3Rpb24gdihlLG4sdCl7ZnVuY3Rpb24gYSgpe3ZhciB0PShcIlwiPT09ZT9cIlwiOlwiQFwiK2UrXCI6XCIpK24scj1NYXRoLmZsb29yKERhdGUubm93KCkvNmU0KTtzW3RdPHImJihzW3RdPXIsY29uc29sZS5lcnJvcignVW5hYmxlIHRvIHJldHJpZXZlIGljb25zIGZvciBcIicrdCsnXCIgYmVjYXVzZSBBUEkgaXMgbm90IGNvbmZpZ3VyZWQgcHJvcGVybHkuJykpfXZvaWQgMD09PW9bZV0mJihvW2VdPU9iamVjdC5jcmVhdGUobnVsbCkpO3ZhciBmPW9bZV07dm9pZCAwPT09dVtlXSYmKHVbZV09T2JqZWN0LmNyZWF0ZShudWxsKSk7dmFyIHY9dVtlXTt2b2lkIDA9PT1yW2VdJiYocltlXT1PYmplY3QuY3JlYXRlKG51bGwpKTt2YXIgcCxoPXJbZV07dm9pZCAwPT09ZltuXT9mW25dPXQ6ZltuXT1mW25dLmNvbmNhdCh0KS5zb3J0KCksdltuXXx8KHZbbl09ITAsc2V0VGltZW91dCgoZnVuY3Rpb24oKXt2W25dPSExO3ZhciB0PWZbbl07ZGVsZXRlIGZbbl07dmFyIHI9SS5nZXRBUElNb2R1bGUoZSk7aWYocil7aWYodm9pZCAwPT09cCl7dmFyIG89bChlKTtpZih2b2lkIDA9PT1vKXJldHVybiB2b2lkIGEoKTtwPW99ci5wcmVwYXJlKGUsbix0KS5mb3JFYWNoKChmdW5jdGlvbih0KXtwLnJlZHVuZGFuY3kucXVlcnkodCxyLnNlbmQsKGZ1bmN0aW9uKHIsbyl7dmFyIGE9aS5nZXRTdG9yYWdlKGUsbik7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHIpe2lmKDQwNCE9PW8pcmV0dXJuO3ZhciB1PURhdGUubm93KCk7dC5pY29ucy5mb3JFYWNoKChmdW5jdGlvbihlKXthLm1pc3NpbmdbZV09dX0pKX1lbHNlIHRyeXt2YXIgZj1pLmFkZEljb25TZXQoYSxyLFwiYWxsXCIpO2lmKFwiYm9vbGVhblwiPT10eXBlb2YgZilyZXR1cm47dmFyIGw9aFtuXTtmLmZvckVhY2goKGZ1bmN0aW9uKGUpe2RlbGV0ZSBsW2VdfSkpLGQuY29yZU1vZHVsZXMuY2FjaGUmJmQuY29yZU1vZHVsZXMuY2FjaGUoZSxyKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKGUpfSFmdW5jdGlvbihlLG4pe3ZvaWQgMD09PWNbZV0mJihjW2VdPU9iamVjdC5jcmVhdGUobnVsbCkpO3ZhciB0PWNbZV07dFtuXXx8KHRbbl09ITAsc2V0VGltZW91dCgoZnVuY3Rpb24oKXt0W25dPSExLHkudXBkYXRlQ2FsbGJhY2tzKGUsbil9KSkpfShlLG4pfSkpfSkpfWVsc2UgYSgpfSkpKX1uLkFQST17aXNQZW5kaW5nOmZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT1yW2UucHJvdmlkZXJdJiZ2b2lkIDAhPT1yW2UucHJvdmlkZXJdW2UucHJlZml4XSYmdm9pZCAwIT09cltlLnByb3ZpZGVyXVtlLnByZWZpeF1bZS5uYW1lXX0sbG9hZEljb25zOmZ1bmN0aW9uKGUsbil7dmFyIG89eC5saXN0VG9JY29ucyhlLCEwLGEuYWxsb3dTaW1wbGVOYW1lcygpKSxpPWIuc29ydEljb25zKG8pO2lmKCFpLnBlbmRpbmcubGVuZ3RoKXt2YXIgYz0hMDtyZXR1cm4gbiYmc2V0VGltZW91dCgoZnVuY3Rpb24oKXtjJiZuKGkubG9hZGVkLGkubWlzc2luZyxpLnBlbmRpbmcsdCl9KSksZnVuY3Rpb24oKXtjPSExfX12YXIgdSxmLGw9T2JqZWN0LmNyZWF0ZShudWxsKSxzPVtdO2kucGVuZGluZy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj1lLnByb3ZpZGVyLHQ9ZS5wcmVmaXg7aWYodCE9PWZ8fG4hPT11KXt1PW4sZj10LHMucHVzaCh7cHJvdmlkZXI6bixwcmVmaXg6dH0pLHZvaWQgMD09PXJbbl0mJihyW25dPU9iamVjdC5jcmVhdGUobnVsbCkpO3ZhciBvPXJbbl07dm9pZCAwPT09b1t0XSYmKG9bdF09T2JqZWN0LmNyZWF0ZShudWxsKSksdm9pZCAwPT09bFtuXSYmKGxbbl09T2JqZWN0LmNyZWF0ZShudWxsKSk7dmFyIGk9bFtuXTt2b2lkIDA9PT1pW3RdJiYoaVt0XT1bXSl9fSkpO3ZhciBkPURhdGUubm93KCk7cmV0dXJuIGkucGVuZGluZy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj1lLnByb3ZpZGVyLHQ9ZS5wcmVmaXgsbz1lLm5hbWUsaT1yW25dW3RdO3ZvaWQgMD09PWlbb10mJihpW29dPWQsbFtuXVt0XS5wdXNoKG8pKX0pKSxzLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPWUucHJvdmlkZXIsdD1lLnByZWZpeDtsW25dW3RdLmxlbmd0aCYmdihuLHQsbFtuXVt0XSl9KSksbj95LnN0b3JlQ2FsbGJhY2sobixpLHMpOnR9fX0pKSxQPWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5BUElJbnRlcm5hbEZ1bmN0aW9ucz1uLkFQSUZ1bmN0aW9ucz12b2lkIDAsbi5BUElGdW5jdGlvbnM9e2xvYWRJY29uczpPLkFQSS5sb2FkSWNvbnMsYWRkQVBJUHJvdmlkZXI6ai5zZXRBUElDb25maWd9LG4uQVBJSW50ZXJuYWxGdW5jdGlvbnM9e2dldEFQSTpPLmdldFJlZHVuZGFuY3lDYWNoZSxnZXRBUElDb25maWc6ai5nZXRBUElDb25maWcsc2V0QVBJTW9kdWxlOkkuc2V0QVBJTW9kdWxlfX0pKSx3PWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5nZXRBUElNb2R1bGU9dm9pZCAwO3ZhciB0PW51bGwscj1cIntwcmVmaXh9LmpzP2ljb25zPXtpY29uc30mY2FsbGJhY2s9e2NhbGxiYWNrfVwiLG89T2JqZWN0LmNyZWF0ZShudWxsKSxpPU9iamVjdC5jcmVhdGUobnVsbCk7ZnVuY3Rpb24gYSgpe2lmKG51bGw9PT10KXt2YXIgZT1zZWxmLG49XCJJY29uaWZ5XCIsbz1cIi5jYlwiO2lmKHZvaWQgMD09PWVbbl0pbz1cIlwiLHZvaWQgMD09PWVbbj1cIkljb25pZnlKU09OUFwiXSYmKGVbbl09T2JqZWN0LmNyZWF0ZShudWxsKSksdD1lW25dO2Vsc2V7dmFyIGk9ZVtuXTt2b2lkIDA9PT1pLmNiJiYoaS5jYj1PYmplY3QuY3JlYXRlKG51bGwpKSx0PWkuY2J9cj1yLnJlcGxhY2UoXCJ7Y2FsbGJhY2t9XCIsbitvK1wiLntjYn1cIil9cmV0dXJuIHR9bi5nZXRBUElNb2R1bGU9ZnVuY3Rpb24oZSl7cmV0dXJue3ByZXBhcmU6ZnVuY3Rpb24obix0LGMpe3ZhciB1PVtdLGY9b1tuK1wiOlwiK3RdO3ZvaWQgMD09PWYmJihmPWZ1bmN0aW9uKG4sdCl7dmFyIGMsdT1lKG4pO2lmKCF1KXJldHVybiAwO2lmKHUubWF4VVJMKXt2YXIgZj0wO3UucmVzb3VyY2VzLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPWU7Zj1NYXRoLm1heChmLG4ubGVuZ3RoKX0pKSxhKCksYz11Lm1heFVSTC1mLXUucGF0aC5sZW5ndGgtci5yZXBsYWNlKFwie3Byb3ZpZGVyfVwiLG4pLnJlcGxhY2UoXCJ7cHJlZml4fVwiLHQpLnJlcGxhY2UoXCJ7aWNvbnN9XCIsXCJcIikubGVuZ3RoLTN9ZWxzZSBjPTA7dmFyIGw9bitcIjpcIit0O3JldHVybiBpW2xdPXUucGF0aCxvW2xdPWMsY30obix0KSk7dmFyIGw9e3Byb3ZpZGVyOm4scHJlZml4OnQsaWNvbnM6W119LHM9MDtyZXR1cm4gYy5mb3JFYWNoKChmdW5jdGlvbihlLHIpeyhzKz1lLmxlbmd0aCsxKT49ZiYmcj4wJiYodS5wdXNoKGwpLGw9e3Byb3ZpZGVyOm4scHJlZml4OnQsaWNvbnM6W119LHM9ZS5sZW5ndGgpLGwuaWNvbnMucHVzaChlKX0pKSx1LnB1c2gobCksdX0sc2VuZDpmdW5jdGlvbihlLG4sdCl7Zm9yKHZhciBvPW4ucHJvdmlkZXIsYz1uLnByZWZpeCx1PW4uaWNvbnMuam9pbihcIixcIiksZj1vK1wiOlwiK2MsbD1jLnNwbGl0KFwiLVwiKS5zaGlmdCgpLnNsaWNlKDAsMykscz1hKCksZD1mdW5jdGlvbihlKXt2YXIgbix0PTA7Zm9yKG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0Kz1lLmNoYXJDb2RlQXQobik7cmV0dXJuIHQlOTk5fShvK1wiOlwiK2UrXCI6XCIrYytcIjpcIit1KTt2b2lkIDAhPT1zW2wrZF07KWQrKzt2YXIgdj1sK2QscD1pW2ZdK3IucmVwbGFjZShcIntwcm92aWRlcn1cIixvKS5yZXBsYWNlKFwie3ByZWZpeH1cIixjKS5yZXBsYWNlKFwie2ljb25zfVwiLHUpLnJlcGxhY2UoXCJ7Y2J9XCIsdik7c1t2XT1mdW5jdGlvbihlKXtkZWxldGUgc1t2XSx0LmRvbmUoZSl9O3ZhciBoPWUrcCxnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7Zy50eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIsZy5hc3luYz0hMCxnLnNyYz1oLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZyl9fX19KSksTT1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uZ2V0QVBJTW9kdWxlPW4uc2V0RmV0Y2g9dm9pZCAwO3ZhciB0PVwie3ByZWZpeH0uanNvbj9pY29ucz17aWNvbnN9XCIscj1PYmplY3QuY3JlYXRlKG51bGwpLG89T2JqZWN0LmNyZWF0ZShudWxsKSxpPW51bGw7dHJ5e2k9ZmV0Y2h9Y2F0Y2goZSl7fW4uc2V0RmV0Y2g9ZnVuY3Rpb24oZSl7aT1lfTtuLmdldEFQSU1vZHVsZT1mdW5jdGlvbihlKXtyZXR1cm57cHJlcGFyZTpmdW5jdGlvbihuLGksYSl7dmFyIGM9W10sdT1yW2ldO3ZvaWQgMD09PXUmJih1PWZ1bmN0aW9uKG4saSl7dmFyIGEsYz1lKG4pO2lmKCFjKXJldHVybiAwO2lmKGMubWF4VVJMKXt2YXIgdT0wO2MucmVzb3VyY2VzLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPWU7dT1NYXRoLm1heCh1LG4ubGVuZ3RoKX0pKSxhPWMubWF4VVJMLXUtYy5wYXRoLmxlbmd0aC10LnJlcGxhY2UoXCJ7cHJvdmlkZXJ9XCIsbikucmVwbGFjZShcIntwcmVmaXh9XCIsaSkucmVwbGFjZShcIntpY29uc31cIixcIlwiKS5sZW5ndGh9ZWxzZSBhPTA7dmFyIGY9bitcIjpcIitpO3JldHVybiBvW2ZdPWMucGF0aCxyW2ZdPWEsYX0obixpKSk7dmFyIGY9e3Byb3ZpZGVyOm4scHJlZml4OmksaWNvbnM6W119LGw9MDtyZXR1cm4gYS5mb3JFYWNoKChmdW5jdGlvbihlLHQpeyhsKz1lLmxlbmd0aCsxKT49dSYmdD4wJiYoYy5wdXNoKGYpLGY9e3Byb3ZpZGVyOm4scHJlZml4OmksaWNvbnM6W119LGw9ZS5sZW5ndGgpLGYuaWNvbnMucHVzaChlKX0pKSxjLnB1c2goZiksY30sc2VuZDpmdW5jdGlvbihlLG4scil7dmFyIGE9bi5wcm92aWRlcixjPW4ucHJlZml4LHU9bi5pY29ucy5qb2luKFwiLFwiKSxmPW9bYStcIjpcIitjXSt0LnJlcGxhY2UoXCJ7cHJvdmlkZXJ9XCIsYSkucmVwbGFjZShcIntwcmVmaXh9XCIsYykucmVwbGFjZShcIntpY29uc31cIix1KTtpP2koZStmKS50aGVuKChmdW5jdGlvbihlKXtpZigyMDA9PT1lLnN0YXR1cylyZXR1cm4gZS5qc29uKCk7ci5kb25lKHZvaWQgMCxlLnN0YXR1cyl9KSkudGhlbigoZnVuY3Rpb24oZSl7XCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lJiZyLmRvbmUoZSl9KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe3IuZG9uZSh2b2lkIDAsZS5lcnJubyl9KSk6ci5kb25lKHZvaWQgMCw0MjQpfX19fSkpLEE9XCJpY29uaWZ5RmluZGVyXCIrRGF0ZS5ub3coKSxTPVwiaWNvbmlmeURhdGFcIitEYXRlLm5vdygpO2Z1bmN0aW9uIF8oZSxuLHQscil7dmFyIG87dHJ5e289ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIil9Y2F0Y2goZSl7cmV0dXJuIHI/XCJcIjpudWxsfXZhciBpPWwuaWNvblRvU1ZHKHQsZi5tZXJnZUN1c3RvbWlzYXRpb25zKGYuZGVmYXVsdHMsbikpLGE9ZS5lbGVtZW50LHU9ZS5maW5kZXIscz1lLm5hbWUsZD1hP2EuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik6XCJcIix2PXU/dS5jbGFzc0ZpbHRlcihkP2Quc3BsaXQoL1xccysvKTpbXSk6W10scD0nPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgcm9sZT1cImltZ1wiIGNsYXNzPVwiJysoXCJpY29uaWZ5IGljb25pZnktLVwiK3MucHJlZml4KyhcIlwiPT09cy5wcm92aWRlcj9cIlwiOlwiIGljb25pZnktLVwiK3MucHJvdmlkZXIpKyh2Lmxlbmd0aD9cIiBcIit2LmpvaW4oXCIgXCIpOlwiXCIpKSsnXCI+JytjLnJlcGxhY2VJRHMoaS5ib2R5KStcIjwvc3ZnPlwiO28uaW5uZXJIVE1MPXA7dmFyIGg9by5jaGlsZE5vZGVzWzBdLGc9aC5zdHlsZSxtPWkuYXR0cmlidXRlcztpZihPYmplY3Qua2V5cyhtKS5mb3JFYWNoKChmdW5jdGlvbihlKXtoLnNldEF0dHJpYnV0ZShlLG1bZV0pfSkpLGkuaW5saW5lJiYoZy52ZXJ0aWNhbEFsaWduPVwiLTAuMTI1ZW1cIiksYSl7Zm9yKHZhciBiPWEuYXR0cmlidXRlcyx5PTA7eTxiLmxlbmd0aDt5Kyspe3ZhciBJPWIuaXRlbSh5KTtpZihJKXt2YXIgaj1JLm5hbWU7aWYoXCJjbGFzc1wiIT09aiYmXCJzdHlsZVwiIT09aiYmdm9pZCAwPT09bVtqXSl0cnl7aC5zZXRBdHRyaWJ1dGUoaixJLnZhbHVlKX1jYXRjaChlKXt9fX1mb3IodmFyIHg9YS5zdHlsZSxPPTA7Tzx4Lmxlbmd0aDtPKyspe3ZhciBQPXhbT107Z1tQXT14W1BdfX1pZih1KXt2YXIgdz17bmFtZTpzLHN0YXR1czpcImxvYWRlZFwiLGN1c3RvbWlzYXRpb25zOm59O2hbU109dyxoW0FdPXV9dmFyIE09cj9vLmlubmVySFRNTDpoO3JldHVybiBhJiZhLnBhcmVudE5vZGU/YS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChoLGEpOm8ucmVtb3ZlQ2hpbGQoaCksTX12YXIgRT1bXTtmdW5jdGlvbiBrKGUpe2Zvcih2YXIgbj0wO248RS5sZW5ndGg7bisrKXt2YXIgdD1FW25dO2lmKChcImZ1bmN0aW9uXCI9PXR5cGVvZiB0Lm5vZGU/dC5ub2RlKCk6dC5ub2RlKT09PWUpcmV0dXJuIHR9fWZ1bmN0aW9uIEMoZSxuKXt2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHQ9ayhlKTtyZXR1cm4gdD8odC50ZW1wb3JhcnkmJih0LnRlbXBvcmFyeT1uKSx0KToodD17bm9kZTplLHRlbXBvcmFyeTpufSxFLnB1c2godCksdCl9ZnVuY3Rpb24gRigpe3JldHVybiBFfXZhciBUPW51bGwsRD17Y2hpbGRMaXN0OiEwLHN1YnRyZWU6ITAsYXR0cmlidXRlczohMH07ZnVuY3Rpb24gTihlKXtpZihlLm9ic2VydmVyKXt2YXIgbj1lLm9ic2VydmVyO24ucGVuZGluZ1NjYW58fChuLnBlbmRpbmdTY2FuPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZGVsZXRlIG4ucGVuZGluZ1NjYW4sVCYmVChlKX0pKSl9fWZ1bmN0aW9uIEwoZSxuKXtpZihlLm9ic2VydmVyKXt2YXIgdD1lLm9ic2VydmVyO2lmKCF0LnBlbmRpbmdTY2FuKWZvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgbz1uW3JdO2lmKG8uYWRkZWROb2RlcyYmby5hZGRlZE5vZGVzLmxlbmd0aD4wfHxcImF0dHJpYnV0ZXNcIj09PW8udHlwZSYmdm9pZCAwIT09by50YXJnZXRbQV0pcmV0dXJuIHZvaWQodC5wYXVzZWR8fE4oZSkpfX19ZnVuY3Rpb24geihlLG4pe2Uub2JzZXJ2ZXIuaW5zdGFuY2Uub2JzZXJ2ZShuLEQpfWZ1bmN0aW9uIFIoZSl7dmFyIG49ZS5vYnNlcnZlcjtpZighbnx8IW4uaW5zdGFuY2Upe3ZhciB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIGUubm9kZT9lLm5vZGUoKTplLm5vZGU7dCYmKG58fChuPXtwYXVzZWQ6MH0sZS5vYnNlcnZlcj1uKSxuLmluc3RhbmNlPW5ldyBNdXRhdGlvbk9ic2VydmVyKEwuYmluZChudWxsLGUpKSx6KGUsdCksbi5wYXVzZWR8fE4oZSkpfX1mdW5jdGlvbiBxKCl7RigpLmZvckVhY2goUil9ZnVuY3Rpb24gVShlKXtpZihlLm9ic2VydmVyKXt2YXIgbj1lLm9ic2VydmVyO24ucGVuZGluZ1NjYW4mJihjbGVhclRpbWVvdXQobi5wZW5kaW5nU2NhbiksZGVsZXRlIG4ucGVuZGluZ1NjYW4pLG4uaW5zdGFuY2UmJihuLmluc3RhbmNlLmRpc2Nvbm5lY3QoKSxkZWxldGUgbi5pbnN0YW5jZSl9fWZ1bmN0aW9uIFYoZSl7dmFyIG49bnVsbCE9PVQ7VCE9PWUmJihUPWUsbiYmRigpLmZvckVhY2goVSkpLG4/cSgpOmZ1bmN0aW9uKGUpe3ZhciBuPWRvY3VtZW50O1wiY29tcGxldGVcIj09PW4ucmVhZHlTdGF0ZXx8XCJsb2FkaW5nXCIhPT1uLnJlYWR5U3RhdGUmJiFuLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbD9lKCk6KG4uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixlKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixlKSl9KHEpfWZ1bmN0aW9uIEcoZSl7KGU/W2VdOkYoKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7aWYoZS5vYnNlcnZlcil7dmFyIG49ZS5vYnNlcnZlcjtpZihuLnBhdXNlZCsrLCEobi5wYXVzZWQ+MSkmJm4uaW5zdGFuY2Upbi5pbnN0YW5jZS5kaXNjb25uZWN0KCl9ZWxzZSBlLm9ic2VydmVyPXtwYXVzZWQ6MX19KSl9ZnVuY3Rpb24gJChlKXsoZT9bZV06RigpKS5mb3JFYWNoKChmdW5jdGlvbihlKXtpZihlLm9ic2VydmVyKXt2YXIgbj1lLm9ic2VydmVyO2lmKG4ucGF1c2VkJiYobi5wYXVzZWQtLSwhbi5wYXVzZWQpKXt2YXIgdD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLm5vZGU/ZS5ub2RlKCk6ZS5ub2RlO2lmKCF0KXJldHVybjtuLmluc3RhbmNlP3ooZSx0KTpSKGUpfX1lbHNlIFIoZSl9KSl9ZnVuY3Rpb24gQihlLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgdD1DKGUsbik7cmV0dXJuIFIodCksdH1mdW5jdGlvbiBRKGUpe3ZhciBuPWsoZSk7biYmKFUobiksZnVuY3Rpb24oZSl7RT1FLmZpbHRlcigoZnVuY3Rpb24obil7dmFyIHQ9XCJmdW5jdGlvblwiPT10eXBlb2Ygbi5ub2RlP24ubm9kZSgpOm4ubm9kZTtyZXR1cm4gZSE9PXR9KSl9KGUpKX12YXIgSD1bXTtmdW5jdGlvbiBKKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1vLnN0cmluZ1RvSWNvbihlKSksbnVsbCE9PWUmJm8udmFsaWRhdGVJY29uKGUpP2U6bnVsbH1mdW5jdGlvbiBZKGUpe3ZhciBuPVtdO0guZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIHI9dC5maW5kKGUpO0FycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwociwoZnVuY3Rpb24oZSl7dmFyIHI9ZTtpZih2b2lkIDA9PT1yW0FdfHxyW0FdPT09dCl7dmFyIG89Sih0Lm5hbWUocikpO2lmKG51bGwhPT1vKXtyW0FdPXQ7dmFyIGk9e2VsZW1lbnQ6cixmaW5kZXI6dCxuYW1lOm99O24ucHVzaChpKX19fSkpfSkpO3ZhciB0PWUucXVlcnlTZWxlY3RvckFsbChcInN2Zy5pY29uaWZ5XCIpO3JldHVybiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHQsKGZ1bmN0aW9uKGUpe3ZhciB0PWUscj10W0FdLG89dFtTXTtpZihyJiZvKXt2YXIgaT1KKHIubmFtZSh0KSk7aWYobnVsbCE9PWkpe3ZhciBhLGM9ITE7aWYoaS5wcmVmaXghPT1vLm5hbWUucHJlZml4fHxpLm5hbWUhPT1vLm5hbWUubmFtZT9jPSEwOihhPXIuY3VzdG9taXNhdGlvbnModCksZnVuY3Rpb24oZSxuKXt2YXIgdD1PYmplY3Qua2V5cyhlKSxyPU9iamVjdC5rZXlzKG4pO2lmKHQubGVuZ3RoIT09ci5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBvPTA7bzx0Lmxlbmd0aDtvKyspe3ZhciBpPXRbb107aWYobltpXSE9PWVbaV0pcmV0dXJuITF9cmV0dXJuITB9KG8uY3VzdG9taXNhdGlvbnMsYSl8fChjPSEwKSksYyl7dmFyIHU9e2VsZW1lbnQ6dCxmaW5kZXI6cixuYW1lOmksY3VzdG9taXNhdGlvbnM6YX07bi5wdXNoKHUpfX19fSkpLG59dmFyIFo9ITE7ZnVuY3Rpb24gSygpe1p8fChaPSEwLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7WiYmKFo9ITEsVygpKX0pKSl9ZnVuY3Rpb24gVyhlLG4pe3ZvaWQgMD09PW4mJihuPSExKSxaPSExO3ZhciB0PU9iamVjdC5jcmVhdGUobnVsbCk7aWYoKGU/W2VdOkYoKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIHI9XCJmdW5jdGlvblwiPT10eXBlb2YgZS5ub2RlP2Uubm9kZSgpOmUubm9kZTtpZihyJiZyLnF1ZXJ5U2VsZWN0b3JBbGwpe3ZhciBvPSExLGE9ITE7WShyKS5mb3JFYWNoKChmdW5jdGlvbihuKXt2YXIgcixjLHU9bi5lbGVtZW50LGY9bi5uYW1lLGw9Zi5wcm92aWRlcixzPWYucHJlZml4LHY9Zi5uYW1lLHA9dVtTXTtpZih2b2lkIDAhPT1wJiYocj1wLm5hbWUsYz1mLG51bGwhPT1yJiZudWxsIT09YyYmci5uYW1lPT09Yy5uYW1lJiZyLnByZWZpeD09PWMucHJlZml4KSlzd2l0Y2gocC5zdGF0dXMpe2Nhc2VcIm1pc3NpbmdcIjpyZXR1cm47Y2FzZVwibG9hZGluZ1wiOmlmKGQuY29yZU1vZHVsZXMuYXBpJiZkLmNvcmVNb2R1bGVzLmFwaS5pc1BlbmRpbmcoe3Byb3ZpZGVyOmwscHJlZml4OnMsbmFtZTp2fSkpcmV0dXJuIHZvaWQobz0hMCl9dmFyIGg9aS5nZXRTdG9yYWdlKGwscyk7aWYodm9pZCAwPT09aC5pY29uc1t2XSl7aWYoaC5taXNzaW5nW3ZdKXJldHVybiBwPXtuYW1lOmYsc3RhdHVzOlwibWlzc2luZ1wiLGN1c3RvbWlzYXRpb25zOnt9fSx2b2lkKHVbU109cCk7aWYoZC5jb3JlTW9kdWxlcy5hcGkmJiFkLmNvcmVNb2R1bGVzLmFwaS5pc1BlbmRpbmcoe3Byb3ZpZGVyOmwscHJlZml4OnMsbmFtZTp2fSkpe3ZvaWQgMD09PXRbbF0mJih0W2xdPU9iamVjdC5jcmVhdGUobnVsbCkpO3ZhciBnPXRbbF07dm9pZCAwPT09Z1tzXSYmKGdbc109T2JqZWN0LmNyZWF0ZShudWxsKSksZ1tzXVt2XT0hMH1wPXtuYW1lOmYsc3RhdHVzOlwibG9hZGluZ1wiLGN1c3RvbWlzYXRpb25zOnt9fSx1W1NdPXAsbz0hMH1lbHNleyFhJiZlLm9ic2VydmVyJiYoRyhlKSxhPSEwKTt2YXIgbT12b2lkIDAhPT1uLmN1c3RvbWlzYXRpb25zP24uY3VzdG9taXNhdGlvbnM6bi5maW5kZXIuY3VzdG9taXNhdGlvbnModSk7XyhuLG0saS5nZXRJY29uKGgsdikpfX0pKSxlLnRlbXBvcmFyeSYmIW8/UShyKTpuJiZvP0IociwhMCk6YSYmZS5vYnNlcnZlciYmJChlKX19KSksZC5jb3JlTW9kdWxlcy5hcGkpe3ZhciByPWQuY29yZU1vZHVsZXMuYXBpO09iamVjdC5rZXlzKHQpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPXRbZV07T2JqZWN0LmtleXMobikuZm9yRWFjaCgoZnVuY3Rpb24odCl7ci5sb2FkSWNvbnMoT2JqZWN0LmtleXMoblt0XSkubWFwKChmdW5jdGlvbihuKXtyZXR1cm57cHJvdmlkZXI6ZSxwcmVmaXg6dCxuYW1lOm59fSkpLEspfSkpfSkpfX12YXIgWD1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4ucm90YXRlRnJvbVN0cmluZz12b2lkIDAsbi5yb3RhdGVGcm9tU3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciBuPWUucmVwbGFjZSgvXi0/WzAtOS5dKi8sXCJcIik7ZnVuY3Rpb24gdChlKXtmb3IoO2U8MDspZSs9NDtyZXR1cm4gZSU0fWlmKFwiXCI9PT1uKXt2YXIgcj1wYXJzZUludChlKTtyZXR1cm4gaXNOYU4ocik/MDp0KHIpfWlmKG4hPT1lKXt2YXIgbz0wO3N3aXRjaChuKXtjYXNlXCIlXCI6bz0yNTticmVhaztjYXNlXCJkZWdcIjpvPTkwfWlmKG8pe3ZhciBpPXBhcnNlRmxvYXQoZS5zbGljZSgwLGUubGVuZ3RoLW4ubGVuZ3RoKSk7cmV0dXJuIGlzTmFOKGkpPzA6KGkvPW8pJTE9PTA/dChpKTowfX1yZXR1cm4gMH19KSksZWU9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmFsaWdubWVudEZyb21TdHJpbmc9bi5mbGlwRnJvbVN0cmluZz12b2lkIDA7dmFyIHQ9L1tcXHMsXSsvO24uZmxpcEZyb21TdHJpbmc9ZnVuY3Rpb24oZSxuKXtuLnNwbGl0KHQpLmZvckVhY2goKGZ1bmN0aW9uKG4pe3N3aXRjaChuLnRyaW0oKSl7Y2FzZVwiaG9yaXpvbnRhbFwiOmUuaEZsaXA9ITA7YnJlYWs7Y2FzZVwidmVydGljYWxcIjplLnZGbGlwPSEwfX0pKX0sbi5hbGlnbm1lbnRGcm9tU3RyaW5nPWZ1bmN0aW9uKGUsbil7bi5zcGxpdCh0KS5mb3JFYWNoKChmdW5jdGlvbihuKXt2YXIgdD1uLnRyaW0oKTtzd2l0Y2godCl7Y2FzZVwibGVmdFwiOmNhc2VcImNlbnRlclwiOmNhc2VcInJpZ2h0XCI6ZS5oQWxpZ249dDticmVhaztjYXNlXCJ0b3BcIjpjYXNlXCJtaWRkbGVcIjpjYXNlXCJib3R0b21cIjplLnZBbGlnbj10O2JyZWFrO2Nhc2VcInNsaWNlXCI6Y2FzZVwiY3JvcFwiOmUuc2xpY2U9ITA7YnJlYWs7Y2FzZVwibWVldFwiOmUuc2xpY2U9ITF9fSkpfX0pKTtmdW5jdGlvbiBuZShlLG4pe3JldHVybiBlLmhhc0F0dHJpYnV0ZShuKX1mdW5jdGlvbiB0ZShlLG4pe3JldHVybiBlLmdldEF0dHJpYnV0ZShuKX12YXIgcmU9W1wiaW5saW5lXCIsXCJoRmxpcFwiLFwidkZsaXBcIl0sb2U9W1wid2lkdGhcIixcImhlaWdodFwiXSxpZT1cImljb25pZnktaW5saW5lXCIsYWU9e2ZpbmQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUucXVlcnlTZWxlY3RvckFsbChcImkuaWNvbmlmeSwgc3Bhbi5pY29uaWZ5LCBpLmljb25pZnktaW5saW5lLCBzcGFuLmljb25pZnktaW5saW5lXCIpfSxuYW1lOmZ1bmN0aW9uKGUpe3JldHVybiBuZShlLFwiZGF0YS1pY29uXCIpP3RlKGUsXCJkYXRhLWljb25cIik6bnVsbH0sY3VzdG9taXNhdGlvbnM6ZnVuY3Rpb24oZSxuKXt2b2lkIDA9PT1uJiYobj17aW5saW5lOiExfSk7dmFyIHQ9bixyPWUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7aWYoLTEhPT0ocj9yLnNwbGl0KC9cXHMrLyk6W10pLmluZGV4T2YoaWUpJiYodC5pbmxpbmU9ITApLG5lKGUsXCJkYXRhLXJvdGF0ZVwiKSl7dmFyIG89WC5yb3RhdGVGcm9tU3RyaW5nKHRlKGUsXCJkYXRhLXJvdGF0ZVwiKSk7byYmKHQucm90YXRlPW8pfXJldHVybiBuZShlLFwiZGF0YS1mbGlwXCIpJiZlZS5mbGlwRnJvbVN0cmluZyh0LHRlKGUsXCJkYXRhLWZsaXBcIikpLG5lKGUsXCJkYXRhLWFsaWduXCIpJiZlZS5hbGlnbm1lbnRGcm9tU3RyaW5nKHQsdGUoZSxcImRhdGEtYWxpZ25cIikpLHJlLmZvckVhY2goKGZ1bmN0aW9uKG4pe2lmKG5lKGUsXCJkYXRhLVwiK24pKXt2YXIgcj1mdW5jdGlvbihlLG4pe3ZhciB0PWUuZ2V0QXR0cmlidXRlKG4pO3JldHVybiB0PT09bnx8XCJ0cnVlXCI9PT10fHxcIlwiIT09dCYmXCJmYWxzZVwiIT09dCYmbnVsbH0oZSxcImRhdGEtXCIrbik7XCJib29sZWFuXCI9PXR5cGVvZiByJiYodFtuXT1yKX19KSksb2UuZm9yRWFjaCgoZnVuY3Rpb24obil7aWYobmUoZSxcImRhdGEtXCIrbikpe3ZhciByPXRlKGUsXCJkYXRhLVwiK24pO1wiXCIhPT1yJiYodFtuXT1yKX19KSksdH0sY2xhc3NGaWx0ZXI6ZnVuY3Rpb24oZSl7dmFyIG49W107cmV0dXJuIGUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7XCJpY29uaWZ5XCIhPT1lJiZcIlwiIT09ZSYmXCJpY29uaWZ5LS1cIiE9PWUuc2xpY2UoMCw5KSYmbi5wdXNoKGUpfSkpLG59fTtmdW5jdGlvbiBjZShlLG4sdCl7dmFyIHI9YS5nZXRJY29uRGF0YShlKTtyZXR1cm4gcj9fKHtuYW1lOm8uc3RyaW5nVG9JY29uKGUpfSxmLm1lcmdlQ3VzdG9taXNhdGlvbnMoZi5kZWZhdWx0cyxcIm9iamVjdFwiPT10eXBlb2Ygbj9uOnt9KSxyLHQpOm51bGx9dmFyIHVlPXtnZXRWZXJzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuXCIyLjAuNFwifSxyZW5kZXJTVkc6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gY2UoZSxuLCExKX0scmVuZGVySFRNTDpmdW5jdGlvbihlLG4pe3JldHVybiBjZShlLG4sITApfSxyZW5kZXJJY29uOmZ1bmN0aW9uKGUsbil7dmFyIHQ9YS5nZXRJY29uRGF0YShlKTtpZighdClyZXR1cm4gbnVsbDt2YXIgcj1mLm1lcmdlQ3VzdG9taXNhdGlvbnMoZi5kZWZhdWx0cyxcIm9iamVjdFwiPT10eXBlb2Ygbj9uOnt9KTtyZXR1cm4gbC5pY29uVG9TVkcodCxyKX0sc2NhbjpmdW5jdGlvbihlKXtlP2Z1bmN0aW9uKGUpe3ZhciBuPWsoZSk7bj9XKG4pOlcoe25vZGU6ZSx0ZW1wb3Jhcnk6ITB9LCEwKX0oZSk6VygpfSxvYnNlcnZlOmZ1bmN0aW9uKGUpe0IoZSl9LHN0b3BPYnNlcnZpbmc6ZnVuY3Rpb24oZSl7UShlKX0scGF1c2VPYnNlcnZlcjpmdW5jdGlvbihlKXtpZihlKXt2YXIgbj1rKGUpO24mJkcobil9ZWxzZSBHKCl9LHJlc3VtZU9ic2VydmVyOmZ1bmN0aW9uKGUpe2lmKGUpe3ZhciBuPWsoZSk7biYmJChuKX1lbHNlICQoKX19O2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyl7IWZ1bmN0aW9uKCl7aWYoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KXJldHVybiBDKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7RS5wdXNoKHtub2RlOmZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudH19KX0oKSxmdW5jdGlvbihlKXstMT09PUguaW5kZXhPZihlKSYmSC5wdXNoKGUpfShhZSk7dmFyIGZlPXdpbmRvdztpZih2b2lkIDAhPT1mZS5JY29uaWZ5UHJlbG9hZCl7dmFyIGxlPWZlLkljb25pZnlQcmVsb2FkLHNlPVwiSW52YWxpZCBJY29uaWZ5UHJlbG9hZCBzeW50YXguXCI7XCJvYmplY3RcIj09dHlwZW9mIGxlJiZudWxsIT09bGUmJihsZSBpbnN0YW5jZW9mIEFycmF5P2xlOltsZV0pLmZvckVhY2goKGZ1bmN0aW9uKGUpe3RyeXsoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lfHxlIGluc3RhbmNlb2YgQXJyYXl8fFwib2JqZWN0XCIhPXR5cGVvZiBlLmljb25zfHxcInN0cmluZ1wiIT10eXBlb2YgZS5wcmVmaXh8fCFhLnN0b3JhZ2VGdW5jdGlvbnMuYWRkQ29sbGVjdGlvbihlKSkmJmNvbnNvbGUuZXJyb3Ioc2UpfWNhdGNoKGUpe2NvbnNvbGUuZXJyb3Ioc2UpfX0pKX1zZXRUaW1lb3V0KChmdW5jdGlvbigpe1YoVyksVygpfSkpfXZhciBkZT17ZW5hYmxlQ2FjaGU6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gcC50b2dnbGVCcm93c2VyQ2FjaGUoZSwhMSE9PW4pfSxkaXNhYmxlQ2FjaGU6ZnVuY3Rpb24oZSl7cmV0dXJuIHAudG9nZ2xlQnJvd3NlckNhY2hlKGUsITApfX0sdmU9e19hcGk6UC5BUElJbnRlcm5hbEZ1bmN0aW9uc307W2Euc3RvcmFnZUZ1bmN0aW9ucyxzLmJ1aWxkZXJGdW5jdGlvbnMsdWUsZGUsUC5BUElGdW5jdGlvbnNdLmZvckVhY2goKGZ1bmN0aW9uKGUpe2Zvcih2YXIgbiBpbiBlKXZlW25dPWVbbl19KSksZC5jb3JlTW9kdWxlcy5hcGk9Ty5BUEk7dmFyIHBlPU0uZ2V0QVBJTW9kdWxlO3RyeXtcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJihwZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBmZXRjaCYmXCJmdW5jdGlvblwiPT10eXBlb2YgUHJvbWlzZT9NLmdldEFQSU1vZHVsZTp3LmdldEFQSU1vZHVsZSl9Y2F0Y2goc2Upe31pZihJLnNldEFQSU1vZHVsZShcIlwiLHBlKGouZ2V0QVBJQ29uZmlnKSksdmUuX2FwaS5zZXRGZXRjaD1mdW5jdGlvbihlKXtNLnNldEZldGNoKGUpLHBlIT09TS5nZXRBUElNb2R1bGUmJihwZT1NLmdldEFQSU1vZHVsZSxJLnNldEFQSU1vZHVsZShcIlwiLHBlKGouZ2V0QVBJQ29uZmlnKSkpfSxcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cpe2QuY29yZU1vZHVsZXMuY2FjaGU9di5zdG9yZUNhY2hlLHYubG9hZENhY2hlKCk7dmFyIGhlPXdpbmRvdztpZih2b2lkIDAhPT1oZS5JY29uaWZ5UHJvdmlkZXJzKXt2YXIgZ2U9aGUuSWNvbmlmeVByb3ZpZGVycztpZihcIm9iamVjdFwiPT10eXBlb2YgZ2UmJm51bGwhPT1nZSlmb3IodmFyIG1lIGluIGdlKXt2YXIgYmU9XCJJY29uaWZ5UHJvdmlkZXJzW1wiK21lK1wiXSBpcyBpbnZhbGlkLlwiO3RyeXt2YXIgeWU9Z2VbbWVdO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB5ZXx8IXllfHx2b2lkIDA9PT15ZS5yZXNvdXJjZXMpY29udGludWU7ai5zZXRBUElDb25maWcobWUseWUpfHxjb25zb2xlLmVycm9yKGJlKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKGJlKX19fX1yZXR1cm4gdmV9KCk7dHJ5e3ZvaWQgMD09PXNlbGYuSWNvbmlmeSYmKHNlbGYuSWNvbmlmeT1JY29uaWZ5KX1jYXRjaChlKXt9aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMpdHJ5e2V4cG9ydHMuX19lc01vZHVsZT0hMCxleHBvcnRzLmRlZmF1bHQ9SWNvbmlmeX1jYXRjaChlKXt9XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18gPSBuZXcgVVJMKFwiaW1hZ2VzL2xheWVycy5wbmdcIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyA9IG5ldyBVUkwoXCJpbWFnZXMvbGF5ZXJzLTJ4LnBuZ1wiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8yX19fID0gbmV3IFVSTChcImltYWdlcy9tYXJrZXItaWNvbi5wbmdcIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8wX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMF9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMV9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzFfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzJfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8yX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi8qIHJlcXVpcmVkIHN0eWxlcyAqL1xcclxcblxcclxcbi5sZWFmbGV0LXBhbmUsXFxyXFxuLmxlYWZsZXQtdGlsZSxcXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93LFxcclxcbi5sZWFmbGV0LXRpbGUtY29udGFpbmVyLFxcclxcbi5sZWFmbGV0LXBhbmUgPiBzdmcsXFxyXFxuLmxlYWZsZXQtcGFuZSA+IGNhbnZhcyxcXHJcXG4ubGVhZmxldC16b29tLWJveCxcXHJcXG4ubGVhZmxldC1pbWFnZS1sYXllcixcXHJcXG4ubGVhZmxldC1sYXllciB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdGxlZnQ6IDA7XFxyXFxuXFx0dG9wOiAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIge1xcclxcblxcdG92ZXJmbG93OiBoaWRkZW47XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRpbGUsXFxyXFxuLmxlYWZsZXQtbWFya2VyLWljb24sXFxyXFxuLmxlYWZsZXQtbWFya2VyLXNoYWRvdyB7XFxyXFxuXFx0LXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdCAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0ICAtd2Via2l0LXVzZXItZHJhZzogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLyogUHJldmVudHMgSUUxMSBmcm9tIGhpZ2hsaWdodGluZyB0aWxlcyBpbiBibHVlICovXFxyXFxuLmxlYWZsZXQtdGlsZTo6c2VsZWN0aW9uIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG59XFxyXFxuLyogU2FmYXJpIHJlbmRlcnMgbm9uLXJldGluYSB0aWxlIG9uIHJldGluYSBiZXR0ZXIgd2l0aCB0aGlzLCBidXQgQ2hyb21lIGlzIHdvcnNlICovXFxyXFxuLmxlYWZsZXQtc2FmYXJpIC5sZWFmbGV0LXRpbGUge1xcclxcblxcdGltYWdlLXJlbmRlcmluZzogLXdlYmtpdC1vcHRpbWl6ZS1jb250cmFzdDtcXHJcXG5cXHR9XFxyXFxuLyogaGFjayB0aGF0IHByZXZlbnRzIGh3IGxheWVycyBcXFwic3RyZXRjaGluZ1xcXCIgd2hlbiBsb2FkaW5nIG5ldyB0aWxlcyAqL1xcclxcbi5sZWFmbGV0LXNhZmFyaSAubGVhZmxldC10aWxlLWNvbnRhaW5lciB7XFxyXFxuXFx0d2lkdGg6IDE2MDBweDtcXHJcXG5cXHRoZWlnaHQ6IDE2MDBweDtcXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtbWFya2VyLWljb24sXFxyXFxuLmxlYWZsZXQtbWFya2VyLXNoYWRvdyB7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0fVxcclxcbi8qIC5sZWFmbGV0LWNvbnRhaW5lciBzdmc6IHJlc2V0IHN2ZyBtYXgtd2lkdGggZGVjbGVyYXRpb24gc2hpcHBlZCBpbiBKb29tbGEhIChqb29tbGEub3JnKSAzLnggKi9cXHJcXG4vKiAubGVhZmxldC1jb250YWluZXIgaW1nOiBtYXAgaXMgYnJva2VuIGluIEZGIGlmIHlvdSBoYXZlIG1heC13aWR0aDogMTAwJSBvbiB0aWxlcyAqL1xcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1vdmVybGF5LXBhbmUgc3ZnLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1tYXJrZXItcGFuZSBpbWcsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LXNoYWRvdy1wYW5lIGltZyxcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtdGlsZS1wYW5lIGltZyxcXHJcXG4ubGVhZmxldC1jb250YWluZXIgaW1nLmxlYWZsZXQtaW1hZ2UtbGF5ZXIsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LXRpbGUge1xcclxcblxcdG1heC13aWR0aDogbm9uZSAhaW1wb3J0YW50O1xcclxcblxcdG1heC1oZWlnaHQ6IG5vbmUgIWltcG9ydGFudDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyLmxlYWZsZXQtdG91Y2gtem9vbSB7XFxyXFxuXFx0LW1zLXRvdWNoLWFjdGlvbjogcGFuLXggcGFuLXk7XFxyXFxuXFx0dG91Y2gtYWN0aW9uOiBwYW4teCBwYW4teTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyLmxlYWZsZXQtdG91Y2gtZHJhZyB7XFxyXFxuXFx0LW1zLXRvdWNoLWFjdGlvbjogcGluY2gtem9vbTtcXHJcXG5cXHQvKiBGYWxsYmFjayBmb3IgRkYgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHBpbmNoLXpvb20gKi9cXHJcXG5cXHR0b3VjaC1hY3Rpb246IG5vbmU7XFxyXFxuXFx0dG91Y2gtYWN0aW9uOiBwaW5jaC16b29tO1xcclxcbn1cXHJcXG4ubGVhZmxldC1jb250YWluZXIubGVhZmxldC10b3VjaC1kcmFnLmxlYWZsZXQtdG91Y2gtem9vbSB7XFxyXFxuXFx0LW1zLXRvdWNoLWFjdGlvbjogbm9uZTtcXHJcXG5cXHR0b3VjaC1hY3Rpb246IG5vbmU7XFxyXFxufVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciB7XFxyXFxuXFx0LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEge1xcclxcblxcdC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSg1MSwgMTgxLCAyMjksIDAuNCk7XFxyXFxufVxcclxcbi5sZWFmbGV0LXRpbGUge1xcclxcblxcdGZpbHRlcjogaW5oZXJpdDtcXHJcXG5cXHR2aXNpYmlsaXR5OiBoaWRkZW47XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRpbGUtbG9hZGVkIHtcXHJcXG5cXHR2aXNpYmlsaXR5OiBpbmhlcml0O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWJveCB7XFxyXFxuXFx0d2lkdGg6IDA7XFxyXFxuXFx0aGVpZ2h0OiAwO1xcclxcblxcdC1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG5cXHQgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuXFx0ei1pbmRleDogODAwO1xcclxcblxcdH1cXHJcXG4vKiB3b3JrYXJvdW5kIGZvciBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODgzMTkgKi9cXHJcXG4ubGVhZmxldC1vdmVybGF5LXBhbmUgc3ZnIHtcXHJcXG5cXHQtbW96LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC1wYW5lICAgICAgICAgeyB6LWluZGV4OiA0MDA7IH1cXHJcXG5cXHJcXG4ubGVhZmxldC10aWxlLXBhbmUgICAgeyB6LWluZGV4OiAyMDA7IH1cXHJcXG4ubGVhZmxldC1vdmVybGF5LXBhbmUgeyB6LWluZGV4OiA0MDA7IH1cXHJcXG4ubGVhZmxldC1zaGFkb3ctcGFuZSAgeyB6LWluZGV4OiA1MDA7IH1cXHJcXG4ubGVhZmxldC1tYXJrZXItcGFuZSAgeyB6LWluZGV4OiA2MDA7IH1cXHJcXG4ubGVhZmxldC10b29sdGlwLXBhbmUgICB7IHotaW5kZXg6IDY1MDsgfVxcclxcbi5sZWFmbGV0LXBvcHVwLXBhbmUgICB7IHotaW5kZXg6IDcwMDsgfVxcclxcblxcclxcbi5sZWFmbGV0LW1hcC1wYW5lIGNhbnZhcyB7IHotaW5kZXg6IDEwMDsgfVxcclxcbi5sZWFmbGV0LW1hcC1wYW5lIHN2ZyAgICB7IHotaW5kZXg6IDIwMDsgfVxcclxcblxcclxcbi5sZWFmbGV0LXZtbC1zaGFwZSB7XFxyXFxuXFx0d2lkdGg6IDFweDtcXHJcXG5cXHRoZWlnaHQ6IDFweDtcXHJcXG5cXHR9XFxyXFxuLmx2bWwge1xcclxcblxcdGJlaGF2aW9yOiB1cmwoI2RlZmF1bHQjVk1MKTtcXHJcXG5cXHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBjb250cm9sIHBvc2l0aW9uaW5nICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcclxcblxcdHotaW5kZXg6IDgwMDtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogdmlzaWJsZVBhaW50ZWQ7IC8qIElFIDktMTAgZG9lc24ndCBoYXZlIGF1dG8gKi9cXHJcXG5cXHRwb2ludGVyLWV2ZW50czogYXV0bztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9wLFxcclxcbi5sZWFmbGV0LWJvdHRvbSB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHotaW5kZXg6IDEwMDA7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvcCB7XFxyXFxuXFx0dG9wOiAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1yaWdodCB7XFxyXFxuXFx0cmlnaHQ6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJvdHRvbSB7XFxyXFxuXFx0Ym90dG9tOiAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1sZWZ0IHtcXHJcXG5cXHRsZWZ0OiAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRmbG9hdDogbGVmdDtcXHJcXG5cXHRjbGVhcjogYm90aDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmlnaHQgLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0ZmxvYXQ6IHJpZ2h0O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3AgLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0bWFyZ2luLXRvcDogMTBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYm90dG9tIC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdG1hcmdpbi1ib3R0b206IDEwcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWxlZnQgLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IDEwcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJpZ2h0IC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdG1hcmdpbi1yaWdodDogMTBweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogem9vbSBhbmQgZmFkZSBhbmltYXRpb25zICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtZmFkZS1hbmltIC5sZWFmbGV0LXRpbGUge1xcclxcblxcdHdpbGwtY2hhbmdlOiBvcGFjaXR5O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtcG9wdXAge1xcclxcblxcdG9wYWNpdHk6IDA7XFxyXFxuXFx0LXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgbGluZWFyO1xcclxcblxcdCAgIC1tb3otdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGxpbmVhcjtcXHJcXG5cXHQgICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBsaW5lYXI7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWZhZGUtYW5pbSAubGVhZmxldC1tYXAtcGFuZSAubGVhZmxldC1wb3B1cCB7XFxyXFxuXFx0b3BhY2l0eTogMTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1hbmltYXRlZCB7XFxyXFxuXFx0LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiAwIDA7XFxyXFxuXFx0ICAgIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiAwIDA7XFxyXFxuXFx0ICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiAwIDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYW5pbSAubGVhZmxldC16b29tLWFuaW1hdGVkIHtcXHJcXG5cXHR3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWFuaW0gLmxlYWZsZXQtem9vbS1hbmltYXRlZCB7XFxyXFxuXFx0LXdlYmtpdC10cmFuc2l0aW9uOiAtd2Via2l0LXRyYW5zZm9ybSAwLjI1cyBjdWJpYy1iZXppZXIoMCwwLDAuMjUsMSk7XFxyXFxuXFx0ICAgLW1vei10cmFuc2l0aW9uOiAgICAtbW96LXRyYW5zZm9ybSAwLjI1cyBjdWJpYy1iZXppZXIoMCwwLDAuMjUsMSk7XFxyXFxuXFx0ICAgICAgICB0cmFuc2l0aW9uOiAgICAgICAgIHRyYW5zZm9ybSAwLjI1cyBjdWJpYy1iZXppZXIoMCwwLDAuMjUsMSk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYW5pbSAubGVhZmxldC10aWxlLFxcclxcbi5sZWFmbGV0LXBhbi1hbmltIC5sZWFmbGV0LXRpbGUge1xcclxcblxcdC13ZWJraXQtdHJhbnNpdGlvbjogbm9uZTtcXHJcXG5cXHQgICAtbW96LXRyYW5zaXRpb246IG5vbmU7XFxyXFxuXFx0ICAgICAgICB0cmFuc2l0aW9uOiBub25lO1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC16b29tLWFuaW0gLmxlYWZsZXQtem9vbS1oaWRlIHtcXHJcXG5cXHR2aXNpYmlsaXR5OiBoaWRkZW47XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGN1cnNvcnMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1pbnRlcmFjdGl2ZSB7XFxyXFxuXFx0Y3Vyc29yOiBwb2ludGVyO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1ncmFiIHtcXHJcXG5cXHRjdXJzb3I6IC13ZWJraXQtZ3JhYjtcXHJcXG5cXHRjdXJzb3I6ICAgIC1tb3otZ3JhYjtcXHJcXG5cXHRjdXJzb3I6ICAgICAgICAgZ3JhYjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY3Jvc3NoYWlyLFxcclxcbi5sZWFmbGV0LWNyb3NzaGFpciAubGVhZmxldC1pbnRlcmFjdGl2ZSB7XFxyXFxuXFx0Y3Vyc29yOiBjcm9zc2hhaXI7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLXBhbmUsXFxyXFxuLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0Y3Vyc29yOiBhdXRvO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1ncmFiLFxcclxcbi5sZWFmbGV0LWRyYWdnaW5nIC5sZWFmbGV0LWdyYWIgLmxlYWZsZXQtaW50ZXJhY3RpdmUsXFxyXFxuLmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtbWFya2VyLWRyYWdnYWJsZSB7XFxyXFxuXFx0Y3Vyc29yOiBtb3ZlO1xcclxcblxcdGN1cnNvcjogLXdlYmtpdC1ncmFiYmluZztcXHJcXG5cXHRjdXJzb3I6ICAgIC1tb3otZ3JhYmJpbmc7XFxyXFxuXFx0Y3Vyc29yOiAgICAgICAgIGdyYWJiaW5nO1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiBtYXJrZXIgJiBvdmVybGF5cyBpbnRlcmFjdGl2aXR5ICovXFxyXFxuLmxlYWZsZXQtbWFya2VyLWljb24sXFxyXFxuLmxlYWZsZXQtbWFya2VyLXNoYWRvdyxcXHJcXG4ubGVhZmxldC1pbWFnZS1sYXllcixcXHJcXG4ubGVhZmxldC1wYW5lID4gc3ZnIHBhdGgsXFxyXFxuLmxlYWZsZXQtdGlsZS1jb250YWluZXIge1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbi5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbi5sZWFmbGV0LWltYWdlLWxheWVyLmxlYWZsZXQtaW50ZXJhY3RpdmUsXFxyXFxuLmxlYWZsZXQtcGFuZSA+IHN2ZyBwYXRoLmxlYWZsZXQtaW50ZXJhY3RpdmUsXFxyXFxuc3ZnLmxlYWZsZXQtaW1hZ2UtbGF5ZXIubGVhZmxldC1pbnRlcmFjdGl2ZSBwYXRoIHtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogdmlzaWJsZVBhaW50ZWQ7IC8qIElFIDktMTAgZG9lc24ndCBoYXZlIGF1dG8gKi9cXHJcXG5cXHRwb2ludGVyLWV2ZW50czogYXV0bztcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogdmlzdWFsIHR3ZWFrcyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciB7XFxyXFxuXFx0YmFja2dyb3VuZDogI2RkZDtcXHJcXG5cXHRvdXRsaW5lOiAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYSB7XFxyXFxuXFx0Y29sb3I6ICMwMDc4QTg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtYWN0aXZlIHtcXHJcXG5cXHRvdXRsaW5lOiAycHggc29saWQgb3JhbmdlO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWJveCB7XFxyXFxuXFx0Ym9yZGVyOiAycHggZG90dGVkICMzOGY7XFxyXFxuXFx0YmFja2dyb3VuZDogcmdiYSgyNTUsMjU1LDI1NSwwLjUpO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBnZW5lcmFsIHR5cG9ncmFwaHkgKi9cXHJcXG4ubGVhZmxldC1jb250YWluZXIge1xcclxcblxcdGZvbnQ6IDEycHgvMS41IFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsIEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGdlbmVyYWwgdG9vbGJhciBzdHlsZXMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1iYXIge1xcclxcblxcdGJveC1zaGFkb3c6IDAgMXB4IDVweCByZ2JhKDAsMCwwLDAuNjUpO1xcclxcblxcdGJvcmRlci1yYWRpdXM6IDRweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYmFyIGEsXFxyXFxuLmxlYWZsZXQtYmFyIGE6aG92ZXIge1xcclxcblxcdGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNjY2M7XFxyXFxuXFx0d2lkdGg6IDI2cHg7XFxyXFxuXFx0aGVpZ2h0OiAyNnB4O1xcclxcblxcdGxpbmUtaGVpZ2h0OiAyNnB4O1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG5cXHR0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuXFx0Y29sb3I6IGJsYWNrO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYSxcXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGUge1xcclxcblxcdGJhY2tncm91bmQtcG9zaXRpb246IDUwJSA1MCU7XFxyXFxuXFx0YmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYmFyIGE6aG92ZXIge1xcclxcblxcdGJhY2tncm91bmQtY29sb3I6ICNmNGY0ZjQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhOmZpcnN0LWNoaWxkIHtcXHJcXG5cXHRib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA0cHg7XFxyXFxuXFx0Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDRweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYmFyIGE6bGFzdC1jaGlsZCB7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogNHB4O1xcclxcblxcdGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA0cHg7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYmFyIGEubGVhZmxldC1kaXNhYmxlZCB7XFxyXFxuXFx0Y3Vyc29yOiBkZWZhdWx0O1xcclxcblxcdGJhY2tncm91bmQtY29sb3I6ICNmNGY0ZjQ7XFxyXFxuXFx0Y29sb3I6ICNiYmI7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciBhIHtcXHJcXG5cXHR3aWR0aDogMzBweDtcXHJcXG5cXHRoZWlnaHQ6IDMwcHg7XFxyXFxuXFx0bGluZS1oZWlnaHQ6IDMwcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciBhOmZpcnN0LWNoaWxkIHtcXHJcXG5cXHRib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAycHg7XFxyXFxuXFx0Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDJweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIGE6bGFzdC1jaGlsZCB7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMnB4O1xcclxcblxcdGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAycHg7XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIHpvb20gY29udHJvbCAqL1xcclxcblxcclxcbi5sZWFmbGV0LWNvbnRyb2wtem9vbS1pbixcXHJcXG4ubGVhZmxldC1jb250cm9sLXpvb20tb3V0IHtcXHJcXG5cXHRmb250OiBib2xkIDE4cHggJ0x1Y2lkYSBDb25zb2xlJywgTW9uYWNvLCBtb25vc3BhY2U7XFxyXFxuXFx0dGV4dC1pbmRlbnQ6IDFweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC16b29tLWluLCAubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLXpvb20tb3V0ICB7XFxyXFxuXFx0Zm9udC1zaXplOiAyMnB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBsYXllcnMgY29udHJvbCAqL1xcclxcblxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzIHtcXHJcXG5cXHRib3gtc2hhZG93OiAwIDFweCA1cHggcmdiYSgwLDAsMCwwLjQpO1xcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogNXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGUge1xcclxcblxcdGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gKyBcIik7XFxyXFxuXFx0d2lkdGg6IDM2cHg7XFxyXFxuXFx0aGVpZ2h0OiAzNnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1yZXRpbmEgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xX19fICsgXCIpO1xcclxcblxcdGJhY2tncm91bmQtc2l6ZTogMjZweCAyNnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGUge1xcclxcblxcdHdpZHRoOiA0NHB4O1xcclxcblxcdGhlaWdodDogNDRweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtbGlzdCxcXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCAubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGUge1xcclxcblxcdGRpc3BsYXk6IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWxpc3Qge1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQge1xcclxcblxcdHBhZGRpbmc6IDZweCAxMHB4IDZweCA2cHg7XFxyXFxuXFx0Y29sb3I6ICMzMzM7XFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyIHtcXHJcXG5cXHRvdmVyZmxvdy15OiBzY3JvbGw7XFxyXFxuXFx0b3ZlcmZsb3cteDogaGlkZGVuO1xcclxcblxcdHBhZGRpbmctcmlnaHQ6IDVweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3Ige1xcclxcblxcdG1hcmdpbi10b3A6IDJweDtcXHJcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuXFx0dG9wOiAxcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzIGxhYmVsIHtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtc2VwYXJhdG9yIHtcXHJcXG5cXHRoZWlnaHQ6IDA7XFxyXFxuXFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkICNkZGQ7XFxyXFxuXFx0bWFyZ2luOiA1cHggLTEwcHggNXB4IC02cHg7XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIERlZmF1bHQgaWNvbiBVUkxzICovXFxyXFxuLmxlYWZsZXQtZGVmYXVsdC1pY29uLXBhdGgge1xcclxcblxcdGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzJfX18gKyBcIik7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGF0dHJpYnV0aW9uIGFuZCBzY2FsZSBjb250cm9scyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KTtcXHJcXG5cXHRtYXJnaW46IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sXFxyXFxuLmxlYWZsZXQtY29udHJvbC1zY2FsZS1saW5lIHtcXHJcXG5cXHRwYWRkaW5nOiAwIDVweDtcXHJcXG5cXHRjb2xvcjogIzMzMztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiBhIHtcXHJcXG5cXHR0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24gYTpob3ZlciB7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1jb250cm9sLXNjYWxlIHtcXHJcXG5cXHRmb250LXNpemU6IDExcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWxlZnQgLmxlYWZsZXQtY29udHJvbC1zY2FsZSB7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IDVweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYm90dG9tIC5sZWFmbGV0LWNvbnRyb2wtc2NhbGUge1xcclxcblxcdG1hcmdpbi1ib3R0b206IDVweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1zY2FsZS1saW5lIHtcXHJcXG5cXHRib3JkZXI6IDJweCBzb2xpZCAjNzc3O1xcclxcblxcdGJvcmRlci10b3A6IG5vbmU7XFxyXFxuXFx0bGluZS1oZWlnaHQ6IDEuMTtcXHJcXG5cXHRwYWRkaW5nOiAycHggNXB4IDFweDtcXHJcXG5cXHRmb250LXNpemU6IDExcHg7XFxyXFxuXFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcXHJcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcclxcblxcdC1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG5cXHQgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuXFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHRiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZTpub3QoOmZpcnN0LWNoaWxkKSB7XFxyXFxuXFx0Ym9yZGVyLXRvcDogMnB4IHNvbGlkICM3Nzc7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogbm9uZTtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtMnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmU6bm90KDpmaXJzdC1jaGlsZCk6bm90KDpsYXN0LWNoaWxkKSB7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogMnB4IHNvbGlkICM3Nzc7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMsXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIHtcXHJcXG5cXHRib3gtc2hhZG93OiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLWxheWVycyxcXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIge1xcclxcblxcdGJvcmRlcjogMnB4IHNvbGlkIHJnYmEoMCwwLDAsMC4yKTtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNsaXA6IHBhZGRpbmctYm94O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBwb3B1cCAqL1xcclxcblxcclxcbi5sZWFmbGV0LXBvcHVwIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcclxcblxcdG1hcmdpbi1ib3R0b206IDIwcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlciB7XFxyXFxuXFx0cGFkZGluZzogMXB4O1xcclxcblxcdHRleHQtYWxpZ246IGxlZnQ7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogMTJweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtY29udGVudCB7XFxyXFxuXFx0bWFyZ2luOiAxM3B4IDE5cHg7XFxyXFxuXFx0bGluZS1oZWlnaHQ6IDEuNDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtY29udGVudCBwIHtcXHJcXG5cXHRtYXJnaW46IDE4cHggMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtdGlwLWNvbnRhaW5lciB7XFxyXFxuXFx0d2lkdGg6IDQwcHg7XFxyXFxuXFx0aGVpZ2h0OiAyMHB4O1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHRsZWZ0OiA1MCU7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC0yMHB4O1xcclxcblxcdG92ZXJmbG93OiBoaWRkZW47XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLXRpcCB7XFxyXFxuXFx0d2lkdGg6IDE3cHg7XFxyXFxuXFx0aGVpZ2h0OiAxN3B4O1xcclxcblxcdHBhZGRpbmc6IDFweDtcXHJcXG5cXHJcXG5cXHRtYXJnaW46IC0xMHB4IGF1dG8gMDtcXHJcXG5cXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXHJcXG5cXHQgICAtbW96LXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXHJcXG5cXHQgICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXHJcXG5cXHQgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyLFxcclxcbi5sZWFmbGV0LXBvcHVwLXRpcCB7XFxyXFxuXFx0YmFja2dyb3VuZDogd2hpdGU7XFxyXFxuXFx0Y29sb3I6ICMzMzM7XFxyXFxuXFx0Ym94LXNoYWRvdzogMCAzcHggMTRweCByZ2JhKDAsMCwwLDAuNCk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9uIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0dG9wOiAwO1xcclxcblxcdHJpZ2h0OiAwO1xcclxcblxcdHBhZGRpbmc6IDRweCA0cHggMCAwO1xcclxcblxcdGJvcmRlcjogbm9uZTtcXHJcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuXFx0d2lkdGg6IDE4cHg7XFxyXFxuXFx0aGVpZ2h0OiAxNHB4O1xcclxcblxcdGZvbnQ6IDE2cHgvMTRweCBUYWhvbWEsIFZlcmRhbmEsIHNhbnMtc2VyaWY7XFxyXFxuXFx0Y29sb3I6ICNjM2MzYzM7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcblxcdGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcblxcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LXBvcHVwLWNsb3NlLWJ1dHRvbjpob3ZlciB7XFxyXFxuXFx0Y29sb3I6ICM5OTk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLXNjcm9sbGVkIHtcXHJcXG5cXHRvdmVyZmxvdzogYXV0bztcXHJcXG5cXHRib3JkZXItYm90dG9tOiAxcHggc29saWQgI2RkZDtcXHJcXG5cXHRib3JkZXItdG9wOiAxcHggc29saWQgI2RkZDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyIHtcXHJcXG5cXHR6b29tOiAxO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC10aXAge1xcclxcblxcdHdpZHRoOiAyNHB4O1xcclxcblxcdG1hcmdpbjogMCBhdXRvO1xcclxcblxcclxcblxcdC1tcy1maWx0ZXI6IFxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0wLjcwNzEwNjc4LCBNMTI9MC43MDcxMDY3OCwgTTIxPS0wLjcwNzEwNjc4LCBNMjI9MC43MDcxMDY3OClcXFwiO1xcclxcblxcdGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9MC43MDcxMDY3OCwgTTEyPTAuNzA3MTA2NzgsIE0yMT0tMC43MDcxMDY3OCwgTTIyPTAuNzA3MTA2NzgpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC10aXAtY29udGFpbmVyIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtMXB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1jb250cm9sLXpvb20sXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtY29udHJvbC1sYXllcnMsXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyLFxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLXRpcCB7XFxyXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgIzk5OTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogZGl2IGljb24gKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1kaXYtaWNvbiB7XFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHRib3JkZXI6IDFweCBzb2xpZCAjNjY2O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBUb29sdGlwICovXFxyXFxuLyogQmFzZSBzdHlsZXMgZm9yIHRoZSBlbGVtZW50IHRoYXQgaGFzIGEgdG9vbHRpcCAqL1xcclxcbi5sZWFmbGV0LXRvb2x0aXAge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHRwYWRkaW5nOiA2cHg7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXHJcXG5cXHRib3JkZXI6IDFweCBzb2xpZCAjZmZmO1xcclxcblxcdGJvcmRlci1yYWRpdXM6IDNweDtcXHJcXG5cXHRjb2xvcjogIzIyMjtcXHJcXG5cXHR3aGl0ZS1zcGFjZTogbm93cmFwO1xcclxcblxcdC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0LW1vei11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0dXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0Ym94LXNoYWRvdzogMCAxcHggM3B4IHJnYmEoMCwwLDAsMC40KTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC5sZWFmbGV0LWNsaWNrYWJsZSB7XFxyXFxuXFx0Y3Vyc29yOiBwb2ludGVyO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLXRvcDpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1ib3R0b206YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtbGVmdDpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmUge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHRib3JkZXI6IDZweCBzb2xpZCB0cmFuc3BhcmVudDtcXHJcXG5cXHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG5cXHRjb250ZW50OiBcXFwiXFxcIjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogRGlyZWN0aW9ucyAqL1xcclxcblxcclxcbi5sZWFmbGV0LXRvb2x0aXAtYm90dG9tIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiA2cHg7XFxyXFxufVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtdG9wIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtNnB4O1xcclxcbn1cXHJcXG4ubGVhZmxldC10b29sdGlwLWJvdHRvbTpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3JlIHtcXHJcXG5cXHRsZWZ0OiA1MCU7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC02cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtdG9wOmJlZm9yZSB7XFxyXFxuXFx0Ym90dG9tOiAwO1xcclxcblxcdG1hcmdpbi1ib3R0b206IC0xMnB4O1xcclxcblxcdGJvcmRlci10b3AtY29sb3I6ICNmZmY7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtYm90dG9tOmJlZm9yZSB7XFxyXFxuXFx0dG9wOiAwO1xcclxcblxcdG1hcmdpbi10b3A6IC0xMnB4O1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtNnB4O1xcclxcblxcdGJvcmRlci1ib3R0b20tY29sb3I6ICNmZmY7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtbGVmdCB7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC02cHg7XFxyXFxufVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcmlnaHQge1xcclxcblxcdG1hcmdpbi1sZWZ0OiA2cHg7XFxyXFxufVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtbGVmdDpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmUge1xcclxcblxcdHRvcDogNTAlO1xcclxcblxcdG1hcmdpbi10b3A6IC02cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtbGVmdDpiZWZvcmUge1xcclxcblxcdHJpZ2h0OiAwO1xcclxcblxcdG1hcmdpbi1yaWdodDogLTEycHg7XFxyXFxuXFx0Ym9yZGVyLWxlZnQtY29sb3I6ICNmZmY7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcmlnaHQ6YmVmb3JlIHtcXHJcXG5cXHRsZWZ0OiAwO1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtMTJweDtcXHJcXG5cXHRib3JkZXItcmlnaHQtY29sb3I6ICNmZmY7XFxyXFxuXFx0fVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsb0JBQW9COztBQUVwQjs7Ozs7Ozs7OztDQVVDLGtCQUFrQjtDQUNsQixPQUFPO0NBQ1AsTUFBTTtDQUNOO0FBQ0Q7Q0FDQyxnQkFBZ0I7Q0FDaEI7QUFDRDs7O0NBR0MseUJBQXlCO0lBQ3RCLHNCQUFzQjtTQUNqQixpQkFBaUI7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O0NBQ3JDO0FBQ0Q7Q0FDQyxlQUFlO0NBQ2Ysb0JBQW9CO0NBQ3BCO0FBQ0Q7Ozs7Q0FJQyxrQkFBa0I7Q0FDbEIsb0JBQW9CO0NBQ3BCLDZCQUE2QjtDQUM3Qix1QkFBdUI7Q0FDdkIsV0FBVztDQUNYOztBQUVELGVBQWU7O0FBRWY7Q0FDQyxlQUFlO0FBQ2hCO0FBQ0E7Q0FDQyxnQkFBZ0I7QUFDakI7QUFDQTs7Q0FFQyxTQUFTO0NBQ1QsaUJBQWlCO0NBQ2pCO0FBQ0Q7Q0FDQyxTQUFTO0NBQ1Qsb0JBQW9CO0NBQ3BCLHNCQUFzQjtDQUN0QjtBQUNEO0NBQ0MsTUFBTTtDQUNOLGlCQUFpQjtDQUNqQixpQkFBaUI7Q0FDakIseUJBQXlCO0NBQ3pCO0FBQ0Q7Q0FDQyxpQkFBaUI7QUFDbEI7QUFDQTtDQUNDLGdCQUFnQjtBQUNqQjtBQUNBOztDQUVDLFFBQVE7Q0FDUixnQkFBZ0I7Q0FDaEI7QUFDRDtDQUNDLFFBQVE7Q0FDUixtQkFBbUI7Q0FDbkIsdUJBQXVCO0NBQ3ZCO0FBQ0Q7Q0FDQyxPQUFPO0NBQ1Asa0JBQWtCO0NBQ2xCLHdCQUF3QjtDQUN4QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKiByZXF1aXJlZCBzdHlsZXMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1wYW5lLFxcclxcbi5sZWFmbGV0LXRpbGUsXFxyXFxuLmxlYWZsZXQtbWFya2VyLWljb24sXFxyXFxuLmxlYWZsZXQtbWFya2VyLXNoYWRvdyxcXHJcXG4ubGVhZmxldC10aWxlLWNvbnRhaW5lcixcXHJcXG4ubGVhZmxldC1wYW5lID4gc3ZnLFxcclxcbi5sZWFmbGV0LXBhbmUgPiBjYW52YXMsXFxyXFxuLmxlYWZsZXQtem9vbS1ib3gsXFxyXFxuLmxlYWZsZXQtaW1hZ2UtbGF5ZXIsXFxyXFxuLmxlYWZsZXQtbGF5ZXIge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHRsZWZ0OiAwO1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10aWxlLFxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3cge1xcclxcblxcdC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0ICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdCAgLXdlYmtpdC11c2VyLWRyYWc6IG5vbmU7XFxyXFxuXFx0fVxcclxcbi8qIFByZXZlbnRzIElFMTEgZnJvbSBoaWdobGlnaHRpbmcgdGlsZXMgaW4gYmx1ZSAqL1xcclxcbi5sZWFmbGV0LXRpbGU6OnNlbGVjdGlvbiB7XFxyXFxuXFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcbi8qIFNhZmFyaSByZW5kZXJzIG5vbi1yZXRpbmEgdGlsZSBvbiByZXRpbmEgYmV0dGVyIHdpdGggdGhpcywgYnV0IENocm9tZSBpcyB3b3JzZSAqL1xcclxcbi5sZWFmbGV0LXNhZmFyaSAubGVhZmxldC10aWxlIHtcXHJcXG5cXHRpbWFnZS1yZW5kZXJpbmc6IC13ZWJraXQtb3B0aW1pemUtY29udHJhc3Q7XFxyXFxuXFx0fVxcclxcbi8qIGhhY2sgdGhhdCBwcmV2ZW50cyBodyBsYXllcnMgXFxcInN0cmV0Y2hpbmdcXFwiIHdoZW4gbG9hZGluZyBuZXcgdGlsZXMgKi9cXHJcXG4ubGVhZmxldC1zYWZhcmkgLmxlYWZsZXQtdGlsZS1jb250YWluZXIge1xcclxcblxcdHdpZHRoOiAxNjAwcHg7XFxyXFxuXFx0aGVpZ2h0OiAxNjAwcHg7XFxyXFxuXFx0LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiAwIDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3cge1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdH1cXHJcXG4vKiAubGVhZmxldC1jb250YWluZXIgc3ZnOiByZXNldCBzdmcgbWF4LXdpZHRoIGRlY2xlcmF0aW9uIHNoaXBwZWQgaW4gSm9vbWxhISAoam9vbWxhLm9yZykgMy54ICovXFxyXFxuLyogLmxlYWZsZXQtY29udGFpbmVyIGltZzogbWFwIGlzIGJyb2tlbiBpbiBGRiBpZiB5b3UgaGF2ZSBtYXgtd2lkdGg6IDEwMCUgb24gdGlsZXMgKi9cXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2ZyxcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtbWFya2VyLXBhbmUgaW1nLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1zaGFkb3ctcGFuZSBpbWcsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LXRpbGUtcGFuZSBpbWcsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGltZy5sZWFmbGV0LWltYWdlLWxheWVyLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC10aWxlIHtcXHJcXG5cXHRtYXgtd2lkdGg6IG5vbmUgIWltcG9ydGFudDtcXHJcXG5cXHRtYXgtaGVpZ2h0OiBub25lICFpbXBvcnRhbnQ7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLXpvb20ge1xcclxcblxcdC1tcy10b3VjaC1hY3Rpb246IHBhbi14IHBhbi15O1xcclxcblxcdHRvdWNoLWFjdGlvbjogcGFuLXggcGFuLXk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLWRyYWcge1xcclxcblxcdC1tcy10b3VjaC1hY3Rpb246IHBpbmNoLXpvb207XFxyXFxuXFx0LyogRmFsbGJhY2sgZm9yIEZGIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwaW5jaC16b29tICovXFxyXFxuXFx0dG91Y2gtYWN0aW9uOiBub25lO1xcclxcblxcdHRvdWNoLWFjdGlvbjogcGluY2gtem9vbTtcXHJcXG59XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyLmxlYWZsZXQtdG91Y2gtZHJhZy5sZWFmbGV0LXRvdWNoLXpvb20ge1xcclxcblxcdC1tcy10b3VjaC1hY3Rpb246IG5vbmU7XFxyXFxuXFx0dG91Y2gtYWN0aW9uOiBub25lO1xcclxcbn1cXHJcXG4ubGVhZmxldC1jb250YWluZXIge1xcclxcblxcdC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhIHtcXHJcXG5cXHQtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoNTEsIDE4MSwgMjI5LCAwLjQpO1xcclxcbn1cXHJcXG4ubGVhZmxldC10aWxlIHtcXHJcXG5cXHRmaWx0ZXI6IGluaGVyaXQ7XFxyXFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10aWxlLWxvYWRlZCB7XFxyXFxuXFx0dmlzaWJpbGl0eTogaW5oZXJpdDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1ib3gge1xcclxcblxcdHdpZHRoOiAwO1xcclxcblxcdGhlaWdodDogMDtcXHJcXG5cXHQtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuXFx0ICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcdHotaW5kZXg6IDgwMDtcXHJcXG5cXHR9XFxyXFxuLyogd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg4MzE5ICovXFxyXFxuLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2ZyB7XFxyXFxuXFx0LW1vei11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtcGFuZSAgICAgICAgIHsgei1pbmRleDogNDAwOyB9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdGlsZS1wYW5lICAgIHsgei1pbmRleDogMjAwOyB9XFxyXFxuLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHsgei1pbmRleDogNDAwOyB9XFxyXFxuLmxlYWZsZXQtc2hhZG93LXBhbmUgIHsgei1pbmRleDogNTAwOyB9XFxyXFxuLmxlYWZsZXQtbWFya2VyLXBhbmUgIHsgei1pbmRleDogNjAwOyB9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1wYW5lICAgeyB6LWluZGV4OiA2NTA7IH1cXHJcXG4ubGVhZmxldC1wb3B1cC1wYW5lICAgeyB6LWluZGV4OiA3MDA7IH1cXHJcXG5cXHJcXG4ubGVhZmxldC1tYXAtcGFuZSBjYW52YXMgeyB6LWluZGV4OiAxMDA7IH1cXHJcXG4ubGVhZmxldC1tYXAtcGFuZSBzdmcgICAgeyB6LWluZGV4OiAyMDA7IH1cXHJcXG5cXHJcXG4ubGVhZmxldC12bWwtc2hhcGUge1xcclxcblxcdHdpZHRoOiAxcHg7XFxyXFxuXFx0aGVpZ2h0OiAxcHg7XFxyXFxuXFx0fVxcclxcbi5sdm1sIHtcXHJcXG5cXHRiZWhhdmlvcjogdXJsKCNkZWZhdWx0I1ZNTCk7XFxyXFxuXFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogY29udHJvbCBwb3NpdGlvbmluZyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG5cXHR6LWluZGV4OiA4MDA7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IHZpc2libGVQYWludGVkOyAvKiBJRSA5LTEwIGRvZXNuJ3QgaGF2ZSBhdXRvICovXFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvcCxcXHJcXG4ubGVhZmxldC1ib3R0b20ge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR6LWluZGV4OiAxMDAwO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3Age1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmlnaHQge1xcclxcblxcdHJpZ2h0OiAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1ib3R0b20ge1xcclxcblxcdGJvdHRvbTogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtbGVmdCB7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0ZmxvYXQ6IGxlZnQ7XFxyXFxuXFx0Y2xlYXI6IGJvdGg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJpZ2h0IC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGZsb2F0OiByaWdodDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9wIC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdG1hcmdpbi10b3A6IDEwcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJvdHRvbSAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1sZWZ0IC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdG1hcmdpbi1sZWZ0OiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1yaWdodCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tcmlnaHQ6IDEwcHg7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIHpvb20gYW5kIGZhZGUgYW5pbWF0aW9ucyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWZhZGUtYW5pbSAubGVhZmxldC10aWxlIHtcXHJcXG5cXHR3aWxsLWNoYW5nZTogb3BhY2l0eTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZmFkZS1hbmltIC5sZWFmbGV0LXBvcHVwIHtcXHJcXG5cXHRvcGFjaXR5OiAwO1xcclxcblxcdC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGxpbmVhcjtcXHJcXG5cXHQgICAtbW96LXRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBsaW5lYXI7XFxyXFxuXFx0ICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgbGluZWFyO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtbWFwLXBhbmUgLmxlYWZsZXQtcG9wdXAge1xcclxcblxcdG9wYWNpdHk6IDE7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYW5pbWF0ZWQge1xcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdCAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdCAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWFuaW0gLmxlYWZsZXQtem9vbS1hbmltYXRlZCB7XFxyXFxuXFx0d2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20tYW5pbWF0ZWQge1xcclxcblxcdC13ZWJraXQtdHJhbnNpdGlvbjogLXdlYmtpdC10cmFuc2Zvcm0gMC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwwLjI1LDEpO1xcclxcblxcdCAgIC1tb3otdHJhbnNpdGlvbjogICAgLW1vei10cmFuc2Zvcm0gMC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwwLjI1LDEpO1xcclxcblxcdCAgICAgICAgdHJhbnNpdGlvbjogICAgICAgICB0cmFuc2Zvcm0gMC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwwLjI1LDEpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWFuaW0gLmxlYWZsZXQtdGlsZSxcXHJcXG4ubGVhZmxldC1wYW4tYW5pbSAubGVhZmxldC10aWxlIHtcXHJcXG5cXHQtd2Via2l0LXRyYW5zaXRpb246IG5vbmU7XFxyXFxuXFx0ICAgLW1vei10cmFuc2l0aW9uOiBub25lO1xcclxcblxcdCAgICAgICAgdHJhbnNpdGlvbjogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20taGlkZSB7XFxyXFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBjdXJzb3JzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtaW50ZXJhY3RpdmUge1xcclxcblxcdGN1cnNvcjogcG9pbnRlcjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZ3JhYiB7XFxyXFxuXFx0Y3Vyc29yOiAtd2Via2l0LWdyYWI7XFxyXFxuXFx0Y3Vyc29yOiAgICAtbW96LWdyYWI7XFxyXFxuXFx0Y3Vyc29yOiAgICAgICAgIGdyYWI7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNyb3NzaGFpcixcXHJcXG4ubGVhZmxldC1jcm9zc2hhaXIgLmxlYWZsZXQtaW50ZXJhY3RpdmUge1xcclxcblxcdGN1cnNvcjogY3Jvc3NoYWlyO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1wYW5lLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGN1cnNvcjogYXV0bztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtZ3JhYixcXHJcXG4ubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1ncmFiIC5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbi5sZWFmbGV0LWRyYWdnaW5nIC5sZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUge1xcclxcblxcdGN1cnNvcjogbW92ZTtcXHJcXG5cXHRjdXJzb3I6IC13ZWJraXQtZ3JhYmJpbmc7XFxyXFxuXFx0Y3Vyc29yOiAgICAtbW96LWdyYWJiaW5nO1xcclxcblxcdGN1cnNvcjogICAgICAgICBncmFiYmluZztcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogbWFya2VyICYgb3ZlcmxheXMgaW50ZXJhY3Rpdml0eSAqL1xcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3csXFxyXFxuLmxlYWZsZXQtaW1hZ2UtbGF5ZXIsXFxyXFxuLmxlYWZsZXQtcGFuZSA+IHN2ZyBwYXRoLFxcclxcbi5sZWFmbGV0LXRpbGUtY29udGFpbmVyIHtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtbWFya2VyLWljb24ubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG4ubGVhZmxldC1pbWFnZS1sYXllci5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbi5sZWFmbGV0LXBhbmUgPiBzdmcgcGF0aC5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbnN2Zy5sZWFmbGV0LWltYWdlLWxheWVyLmxlYWZsZXQtaW50ZXJhY3RpdmUgcGF0aCB7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IHZpc2libGVQYWludGVkOyAvKiBJRSA5LTEwIGRvZXNuJ3QgaGF2ZSBhdXRvICovXFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIHZpc3VhbCB0d2Vha3MgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250YWluZXIge1xcclxcblxcdGJhY2tncm91bmQ6ICNkZGQ7XFxyXFxuXFx0b3V0bGluZTogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEge1xcclxcblxcdGNvbG9yOiAjMDA3OEE4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LWFjdGl2ZSB7XFxyXFxuXFx0b3V0bGluZTogMnB4IHNvbGlkIG9yYW5nZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1ib3gge1xcclxcblxcdGJvcmRlcjogMnB4IGRvdHRlZCAjMzhmO1xcclxcblxcdGJhY2tncm91bmQ6IHJnYmEoMjU1LDI1NSwyNTUsMC41KTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogZ2VuZXJhbCB0eXBvZ3JhcGh5ICovXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHRmb250OiAxMnB4LzEuNSBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBnZW5lcmFsIHRvb2xiYXIgc3R5bGVzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtYmFyIHtcXHJcXG5cXHRib3gtc2hhZG93OiAwIDFweCA1cHggcmdiYSgwLDAsMCwwLjY1KTtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiA0cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhLFxcclxcbi5sZWFmbGV0LWJhciBhOmhvdmVyIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcclxcblxcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjO1xcclxcblxcdHdpZHRoOiAyNnB4O1xcclxcblxcdGhlaWdodDogMjZweDtcXHJcXG5cXHRsaW5lLWhlaWdodDogMjZweDtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcblxcdGNvbG9yOiBibGFjaztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYmFyIGEsXFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiA1MCUgNTAlO1xcclxcblxcdGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhOmhvdmVyIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYTpmaXJzdC1jaGlsZCB7XFxyXFxuXFx0Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNHB4O1xcclxcblxcdGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhOmxhc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDRweDtcXHJcXG5cXHRib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNHB4O1xcclxcblxcdGJvcmRlci1ib3R0b206IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhLmxlYWZsZXQtZGlzYWJsZWQge1xcclxcblxcdGN1cnNvcjogZGVmYXVsdDtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xcclxcblxcdGNvbG9yOiAjYmJiO1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYSB7XFxyXFxuXFx0d2lkdGg6IDMwcHg7XFxyXFxuXFx0aGVpZ2h0OiAzMHB4O1xcclxcblxcdGxpbmUtaGVpZ2h0OiAzMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYTpmaXJzdC1jaGlsZCB7XFxyXFxuXFx0Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMnB4O1xcclxcblxcdGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAycHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciBhOmxhc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDJweDtcXHJcXG5cXHRib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMnB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiB6b29tIGNvbnRyb2wgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250cm9sLXpvb20taW4sXFxyXFxuLmxlYWZsZXQtY29udHJvbC16b29tLW91dCB7XFxyXFxuXFx0Zm9udDogYm9sZCAxOHB4ICdMdWNpZGEgQ29uc29sZScsIE1vbmFjbywgbW9ub3NwYWNlO1xcclxcblxcdHRleHQtaW5kZW50OiAxcHg7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtem9vbS1pbiwgLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC16b29tLW91dCAge1xcclxcblxcdGZvbnQtc2l6ZTogMjJweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogbGF5ZXJzIGNvbnRyb2wgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycyB7XFxyXFxuXFx0Ym94LXNoYWRvdzogMCAxcHggNXB4IHJnYmEoMCwwLDAsMC40KTtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdGJvcmRlci1yYWRpdXM6IDVweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoaW1hZ2VzL2xheWVycy5wbmcpO1xcclxcblxcdHdpZHRoOiAzNnB4O1xcclxcblxcdGhlaWdodDogMzZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmV0aW5hIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKGltYWdlcy9sYXllcnMtMngucG5nKTtcXHJcXG5cXHRiYWNrZ3JvdW5kLXNpemU6IDI2cHggMjZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHR3aWR0aDogNDRweDtcXHJcXG5cXHRoZWlnaHQ6IDQ0cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWxpc3QsXFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRkaXNwbGF5OiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCAubGVhZmxldC1jb250cm9sLWxheWVycy1saXN0IHtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkIHtcXHJcXG5cXHRwYWRkaW5nOiA2cHggMTBweCA2cHggNnB4O1xcclxcblxcdGNvbG9yOiAjMzMzO1xcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhciB7XFxyXFxuXFx0b3ZlcmZsb3cteTogc2Nyb2xsO1xcclxcblxcdG92ZXJmbG93LXg6IGhpZGRlbjtcXHJcXG5cXHRwYWRkaW5nLXJpZ2h0OiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiAycHg7XFxyXFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcclxcblxcdHRvcDogMXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycyBsYWJlbCB7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlcGFyYXRvciB7XFxyXFxuXFx0aGVpZ2h0OiAwO1xcclxcblxcdGJvcmRlci10b3A6IDFweCBzb2xpZCAjZGRkO1xcclxcblxcdG1hcmdpbjogNXB4IC0xMHB4IDVweCAtNnB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiBEZWZhdWx0IGljb24gVVJMcyAqL1xcclxcbi5sZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoaW1hZ2VzL21hcmtlci1pY29uLnBuZyk7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGF0dHJpYnV0aW9uIGFuZCBzY2FsZSBjb250cm9scyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KTtcXHJcXG5cXHRtYXJnaW46IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sXFxyXFxuLmxlYWZsZXQtY29udHJvbC1zY2FsZS1saW5lIHtcXHJcXG5cXHRwYWRkaW5nOiAwIDVweDtcXHJcXG5cXHRjb2xvcjogIzMzMztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiBhIHtcXHJcXG5cXHR0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24gYTpob3ZlciB7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1jb250cm9sLXNjYWxlIHtcXHJcXG5cXHRmb250LXNpemU6IDExcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWxlZnQgLmxlYWZsZXQtY29udHJvbC1zY2FsZSB7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IDVweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYm90dG9tIC5sZWFmbGV0LWNvbnRyb2wtc2NhbGUge1xcclxcblxcdG1hcmdpbi1ib3R0b206IDVweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1zY2FsZS1saW5lIHtcXHJcXG5cXHRib3JkZXI6IDJweCBzb2xpZCAjNzc3O1xcclxcblxcdGJvcmRlci10b3A6IG5vbmU7XFxyXFxuXFx0bGluZS1oZWlnaHQ6IDEuMTtcXHJcXG5cXHRwYWRkaW5nOiAycHggNXB4IDFweDtcXHJcXG5cXHRmb250LXNpemU6IDExcHg7XFxyXFxuXFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcXHJcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcclxcblxcdC1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG5cXHQgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuXFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHRiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZTpub3QoOmZpcnN0LWNoaWxkKSB7XFxyXFxuXFx0Ym9yZGVyLXRvcDogMnB4IHNvbGlkICM3Nzc7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogbm9uZTtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtMnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmU6bm90KDpmaXJzdC1jaGlsZCk6bm90KDpsYXN0LWNoaWxkKSB7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogMnB4IHNvbGlkICM3Nzc7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMsXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIHtcXHJcXG5cXHRib3gtc2hhZG93OiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLWxheWVycyxcXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIge1xcclxcblxcdGJvcmRlcjogMnB4IHNvbGlkIHJnYmEoMCwwLDAsMC4yKTtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNsaXA6IHBhZGRpbmctYm94O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBwb3B1cCAqL1xcclxcblxcclxcbi5sZWFmbGV0LXBvcHVwIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcclxcblxcdG1hcmdpbi1ib3R0b206IDIwcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlciB7XFxyXFxuXFx0cGFkZGluZzogMXB4O1xcclxcblxcdHRleHQtYWxpZ246IGxlZnQ7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogMTJweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtY29udGVudCB7XFxyXFxuXFx0bWFyZ2luOiAxM3B4IDE5cHg7XFxyXFxuXFx0bGluZS1oZWlnaHQ6IDEuNDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtY29udGVudCBwIHtcXHJcXG5cXHRtYXJnaW46IDE4cHggMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtdGlwLWNvbnRhaW5lciB7XFxyXFxuXFx0d2lkdGg6IDQwcHg7XFxyXFxuXFx0aGVpZ2h0OiAyMHB4O1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHRsZWZ0OiA1MCU7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC0yMHB4O1xcclxcblxcdG92ZXJmbG93OiBoaWRkZW47XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLXRpcCB7XFxyXFxuXFx0d2lkdGg6IDE3cHg7XFxyXFxuXFx0aGVpZ2h0OiAxN3B4O1xcclxcblxcdHBhZGRpbmc6IDFweDtcXHJcXG5cXHJcXG5cXHRtYXJnaW46IC0xMHB4IGF1dG8gMDtcXHJcXG5cXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXHJcXG5cXHQgICAtbW96LXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXHJcXG5cXHQgICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXHJcXG5cXHQgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyLFxcclxcbi5sZWFmbGV0LXBvcHVwLXRpcCB7XFxyXFxuXFx0YmFja2dyb3VuZDogd2hpdGU7XFxyXFxuXFx0Y29sb3I6ICMzMzM7XFxyXFxuXFx0Ym94LXNoYWRvdzogMCAzcHggMTRweCByZ2JhKDAsMCwwLDAuNCk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9uIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0dG9wOiAwO1xcclxcblxcdHJpZ2h0OiAwO1xcclxcblxcdHBhZGRpbmc6IDRweCA0cHggMCAwO1xcclxcblxcdGJvcmRlcjogbm9uZTtcXHJcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuXFx0d2lkdGg6IDE4cHg7XFxyXFxuXFx0aGVpZ2h0OiAxNHB4O1xcclxcblxcdGZvbnQ6IDE2cHgvMTRweCBUYWhvbWEsIFZlcmRhbmEsIHNhbnMtc2VyaWY7XFxyXFxuXFx0Y29sb3I6ICNjM2MzYzM7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcblxcdGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcblxcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LXBvcHVwLWNsb3NlLWJ1dHRvbjpob3ZlciB7XFxyXFxuXFx0Y29sb3I6ICM5OTk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLXNjcm9sbGVkIHtcXHJcXG5cXHRvdmVyZmxvdzogYXV0bztcXHJcXG5cXHRib3JkZXItYm90dG9tOiAxcHggc29saWQgI2RkZDtcXHJcXG5cXHRib3JkZXItdG9wOiAxcHggc29saWQgI2RkZDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyIHtcXHJcXG5cXHR6b29tOiAxO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC10aXAge1xcclxcblxcdHdpZHRoOiAyNHB4O1xcclxcblxcdG1hcmdpbjogMCBhdXRvO1xcclxcblxcclxcblxcdC1tcy1maWx0ZXI6IFxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0wLjcwNzEwNjc4LCBNMTI9MC43MDcxMDY3OCwgTTIxPS0wLjcwNzEwNjc4LCBNMjI9MC43MDcxMDY3OClcXFwiO1xcclxcblxcdGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9MC43MDcxMDY3OCwgTTEyPTAuNzA3MTA2NzgsIE0yMT0tMC43MDcxMDY3OCwgTTIyPTAuNzA3MTA2NzgpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC10aXAtY29udGFpbmVyIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtMXB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1jb250cm9sLXpvb20sXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtY29udHJvbC1sYXllcnMsXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyLFxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLXRpcCB7XFxyXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgIzk5OTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogZGl2IGljb24gKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1kaXYtaWNvbiB7XFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHRib3JkZXI6IDFweCBzb2xpZCAjNjY2O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBUb29sdGlwICovXFxyXFxuLyogQmFzZSBzdHlsZXMgZm9yIHRoZSBlbGVtZW50IHRoYXQgaGFzIGEgdG9vbHRpcCAqL1xcclxcbi5sZWFmbGV0LXRvb2x0aXAge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHRwYWRkaW5nOiA2cHg7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXHJcXG5cXHRib3JkZXI6IDFweCBzb2xpZCAjZmZmO1xcclxcblxcdGJvcmRlci1yYWRpdXM6IDNweDtcXHJcXG5cXHRjb2xvcjogIzIyMjtcXHJcXG5cXHR3aGl0ZS1zcGFjZTogbm93cmFwO1xcclxcblxcdC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0LW1vei11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0dXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0Ym94LXNoYWRvdzogMCAxcHggM3B4IHJnYmEoMCwwLDAsMC40KTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC5sZWFmbGV0LWNsaWNrYWJsZSB7XFxyXFxuXFx0Y3Vyc29yOiBwb2ludGVyO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLXRvcDpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1ib3R0b206YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtbGVmdDpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmUge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHRib3JkZXI6IDZweCBzb2xpZCB0cmFuc3BhcmVudDtcXHJcXG5cXHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG5cXHRjb250ZW50OiBcXFwiXFxcIjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogRGlyZWN0aW9ucyAqL1xcclxcblxcclxcbi5sZWFmbGV0LXRvb2x0aXAtYm90dG9tIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiA2cHg7XFxyXFxufVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtdG9wIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtNnB4O1xcclxcbn1cXHJcXG4ubGVhZmxldC10b29sdGlwLWJvdHRvbTpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3JlIHtcXHJcXG5cXHRsZWZ0OiA1MCU7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC02cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtdG9wOmJlZm9yZSB7XFxyXFxuXFx0Ym90dG9tOiAwO1xcclxcblxcdG1hcmdpbi1ib3R0b206IC0xMnB4O1xcclxcblxcdGJvcmRlci10b3AtY29sb3I6ICNmZmY7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtYm90dG9tOmJlZm9yZSB7XFxyXFxuXFx0dG9wOiAwO1xcclxcblxcdG1hcmdpbi10b3A6IC0xMnB4O1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtNnB4O1xcclxcblxcdGJvcmRlci1ib3R0b20tY29sb3I6ICNmZmY7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtbGVmdCB7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC02cHg7XFxyXFxufVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcmlnaHQge1xcclxcblxcdG1hcmdpbi1sZWZ0OiA2cHg7XFxyXFxufVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtbGVmdDpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmUge1xcclxcblxcdHRvcDogNTAlO1xcclxcblxcdG1hcmdpbi10b3A6IC02cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtbGVmdDpiZWZvcmUge1xcclxcblxcdHJpZ2h0OiAwO1xcclxcblxcdG1hcmdpbi1yaWdodDogLTEycHg7XFxyXFxuXFx0Ym9yZGVyLWxlZnQtY29sb3I6ICNmZmY7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcmlnaHQ6YmVmb3JlIHtcXHJcXG5cXHRsZWZ0OiAwO1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtMTJweDtcXHJcXG5cXHRib3JkZXItcmlnaHQtY29sb3I6ICNmZmY7XFxyXFxuXFx0fVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2YgaXRlbVs1XSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuXG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiBpKG1vZHVsZXMsIG1lZGlhLCBkZWR1cGUsIHN1cHBvcnRzLCBsYXllcikge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgdW5kZWZpbmVkXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBsYXllciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW1bNV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAoIXVybCkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB1cmwgPSBTdHJpbmcodXJsLl9fZXNNb2R1bGUgPyB1cmwuZGVmYXVsdCA6IHVybCk7IC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxuXG4gIGlmICgvXlsnXCJdLipbJ1wiXSQvLnRlc3QodXJsKSkge1xuICAgIHVybCA9IHVybC5zbGljZSgxLCAtMSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5oYXNoKSB7XG4gICAgdXJsICs9IG9wdGlvbnMuaGFzaDtcbiAgfSAvLyBTaG91bGQgdXJsIGJlIHdyYXBwZWQ/XG4gIC8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG5cblxuICBpZiAoL1tcIicoKSBcXHRcXG5dfCglMjApLy50ZXN0KHVybCkgfHwgb3B0aW9ucy5uZWVkUXVvdGVzKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdCh1cmwucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLCBcIlxcXCJcIik7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV07XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8IFwiXCIpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyIsIi8qIEBwcmVzZXJ2ZVxuICogTGVhZmxldCAxLjYuMCwgYSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzLiBodHRwOi8vbGVhZmxldGpzLmNvbVxuICogKGMpIDIwMTAtMjAxOSBWbGFkaW1pciBBZ2Fmb25raW4sIChjKSAyMDEwLTIwMTEgQ2xvdWRNYWRlXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLkwgPSB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIHZlcnNpb24gPSBcIjEuNi4wXCI7XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICovXHJcblxyXG52YXIgZnJlZXplID0gT2JqZWN0LmZyZWV6ZTtcclxuT2JqZWN0LmZyZWV6ZSA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iajsgfTtcclxuXHJcbi8vIEBmdW5jdGlvbiBleHRlbmQoZGVzdDogT2JqZWN0LCBzcmM/OiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgc3JjYCBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGludG8gYGRlc3RgIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgbGF0dGVyLiBIYXMgYW4gYEwuZXh0ZW5kYCBzaG9ydGN1dC5cclxuZnVuY3Rpb24gZXh0ZW5kKGRlc3QpIHtcclxuXHR2YXIgaSwgaiwgbGVuLCBzcmM7XHJcblxyXG5cdGZvciAoaiA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xyXG5cdFx0c3JjID0gYXJndW1lbnRzW2pdO1xyXG5cdFx0Zm9yIChpIGluIHNyYykge1xyXG5cdFx0XHRkZXN0W2ldID0gc3JjW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZGVzdDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNyZWF0ZShwcm90bzogT2JqZWN0LCBwcm9wZXJ0aWVzPzogT2JqZWN0KTogT2JqZWN0XHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtPYmplY3QuY3JlYXRlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlKVxyXG52YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xyXG5cdGZ1bmN0aW9uIEYoKSB7fVxyXG5cdHJldHVybiBmdW5jdGlvbiAocHJvdG8pIHtcclxuXHRcdEYucHJvdG90eXBlID0gcHJvdG87XHJcblx0XHRyZXR1cm4gbmV3IEYoKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGJpbmQoZm46IEZ1bmN0aW9uLCDigKYpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBhcmd1bWVudHMgcGFzc2VkLCBsaWtlIFtGdW5jdGlvbi5wcm90b3R5cGUuYmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCkuXHJcbi8vIEhhcyBhIGBMLmJpbmQoKWAgc2hvcnRjdXQuXHJcbmZ1bmN0aW9uIGJpbmQoZm4sIG9iaikge1xyXG5cdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcblx0aWYgKGZuLmJpbmQpIHtcclxuXHRcdHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG5cdH1cclxuXHJcblx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xyXG5cdH07XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBsYXN0SWQ6IE51bWJlclxyXG4vLyBMYXN0IHVuaXF1ZSBJRCB1c2VkIGJ5IFtgc3RhbXAoKWBdKCN1dGlsLXN0YW1wKVxyXG52YXIgbGFzdElkID0gMDtcclxuXHJcbi8vIEBmdW5jdGlvbiBzdGFtcChvYmo6IE9iamVjdCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSB1bmlxdWUgSUQgb2YgYW4gb2JqZWN0LCBhc3NpZ25pbmcgaXQgb25lIGlmIGl0IGRvZXNuJ3QgaGF2ZSBpdC5cclxuZnVuY3Rpb24gc3RhbXAob2JqKSB7XHJcblx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdG9iai5fbGVhZmxldF9pZCA9IG9iai5fbGVhZmxldF9pZCB8fCArK2xhc3RJZDtcclxuXHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xyXG5cdC8qIGVzbGludC1lbmFibGUgKi9cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRocm90dGxlKGZuOiBGdW5jdGlvbiwgdGltZTogTnVtYmVyLCBjb250ZXh0OiBPYmplY3QpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZXhlY3V0ZXMgZnVuY3Rpb24gYGZuYCB3aXRoIHRoZSBnaXZlbiBzY29wZSBgY29udGV4dGBcclxuLy8gKHNvIHRoYXQgdGhlIGB0aGlzYCBrZXl3b3JkIHJlZmVycyB0byBgY29udGV4dGAgaW5zaWRlIGBmbmAncyBjb2RlKS4gVGhlIGZ1bmN0aW9uXHJcbi8vIGBmbmAgd2lsbCBiZSBjYWxsZWQgbm8gbW9yZSB0aGFuIG9uZSB0aW1lIHBlciBnaXZlbiBhbW91bnQgb2YgYHRpbWVgLiBUaGUgYXJndW1lbnRzXHJcbi8vIHJlY2VpdmVkIGJ5IHRoZSBib3VuZCBmdW5jdGlvbiB3aWxsIGJlIGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gYmluZGluZyB0aGVcclxuLy8gZnVuY3Rpb24sIGZvbGxvd2VkIGJ5IGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gaW52b2tpbmcgdGhlIGJvdW5kIGZ1bmN0aW9uLlxyXG4vLyBIYXMgYW4gYEwudGhyb3R0bGVgIHNob3J0Y3V0LlxyXG5mdW5jdGlvbiB0aHJvdHRsZShmbiwgdGltZSwgY29udGV4dCkge1xyXG5cdHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xyXG5cclxuXHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXHJcblx0XHRsb2NrID0gZmFsc2U7XHJcblx0XHRpZiAoYXJncykge1xyXG5cdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHRcdGFyZ3MgPSBmYWxzZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHR3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAobG9jaykge1xyXG5cdFx0XHQvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuXHRcdFx0YXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXHJcblx0XHRcdGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG5cdFx0XHRsb2NrID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gd3JhcHBlckZuO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgbW9kdWxvIGByYW5nZWAgaW4gc3VjaCBhIHdheSBzbyBpdCBsaWVzIHdpdGhpblxyXG4vLyBgcmFuZ2VbMF1gIGFuZCBgcmFuZ2VbMV1gLiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBhbHdheXMgc21hbGxlciB0aGFuXHJcbi8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG5mdW5jdGlvbiB3cmFwTnVtKHgsIHJhbmdlLCBpbmNsdWRlTWF4KSB7XHJcblx0dmFyIG1heCA9IHJhbmdlWzFdLFxyXG5cdCAgICBtaW4gPSByYW5nZVswXSxcclxuXHQgICAgZCA9IG1heCAtIG1pbjtcclxuXHRyZXR1cm4geCA9PT0gbWF4ICYmIGluY2x1ZGVNYXggPyB4IDogKCh4IC0gbWluKSAlIGQgKyBkKSAlIGQgKyBtaW47XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBmYWxzZUZuKCk6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgLlxyXG5mdW5jdGlvbiBmYWxzZUZuKCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbi8vIEBmdW5jdGlvbiBmb3JtYXROdW0obnVtOiBOdW1iZXIsIGRpZ2l0cz86IE51bWJlcik6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgcm91bmRlZCB0byBgZGlnaXRzYCBkZWNpbWFscywgb3IgdG8gNiBkZWNpbWFscyBieSBkZWZhdWx0LlxyXG5mdW5jdGlvbiBmb3JtYXROdW0obnVtLCBkaWdpdHMpIHtcclxuXHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIChkaWdpdHMgPT09IHVuZGVmaW5lZCA/IDYgOiBkaWdpdHMpKTtcclxuXHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdHJpbShzdHI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbU3RyaW5nLnByb3RvdHlwZS50cmltXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbSlcclxuZnVuY3Rpb24gdHJpbShzdHIpIHtcclxuXHRyZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyOiBTdHJpbmcpOiBTdHJpbmdbXVxyXG4vLyBUcmltcyBhbmQgc3BsaXRzIHRoZSBzdHJpbmcgb24gd2hpdGVzcGFjZSBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgcGFydHMuXHJcbmZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyKSB7XHJcblx0cmV0dXJuIHRyaW0oc3RyKS5zcGxpdCgvXFxzKy8pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmo6IE9iamVjdCwgb3B0aW9uczogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE1lcmdlcyB0aGUgZ2l2ZW4gcHJvcGVydGllcyB0byB0aGUgYG9wdGlvbnNgIG9mIHRoZSBgb2JqYCBvYmplY3QsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIG9wdGlvbnMuIFNlZSBgQ2xhc3Mgb3B0aW9uc2AuIEhhcyBhbiBgTC5zZXRPcHRpb25zYCBzaG9ydGN1dC5cclxuZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmosIG9wdGlvbnMpIHtcclxuXHRpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eSgnb3B0aW9ucycpKSB7XHJcblx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gY3JlYXRlKG9iai5vcHRpb25zKSA6IHt9O1xyXG5cdH1cclxuXHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuXHR9XHJcblx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqOiBPYmplY3QsIGV4aXN0aW5nVXJsPzogU3RyaW5nLCB1cHBlcmNhc2U/OiBCb29sZWFuKTogU3RyaW5nXHJcbi8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuLy8gdHJhbnNsYXRlcyB0byBgJz9hPWZvbyZiPWJhcidgLiBJZiBgZXhpc3RpbmdVcmxgIGlzIHNldCwgdGhlIHBhcmFtZXRlcnMgd2lsbFxyXG4vLyBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kLiBJZiBgdXBwZXJjYXNlYCBpcyBgdHJ1ZWAsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbFxyXG4vLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcbmZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iaiwgZXhpc3RpbmdVcmwsIHVwcGVyY2FzZSkge1xyXG5cdHZhciBwYXJhbXMgPSBbXTtcclxuXHRmb3IgKHZhciBpIGluIG9iaikge1xyXG5cdFx0cGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHVwcGVyY2FzZSA/IGkudG9VcHBlckNhc2UoKSA6IGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSkpO1xyXG5cdH1cclxuXHRyZXR1cm4gKCghZXhpc3RpbmdVcmwgfHwgZXhpc3RpbmdVcmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICsgcGFyYW1zLmpvaW4oJyYnKTtcclxufVxyXG5cclxudmFyIHRlbXBsYXRlUmUgPSAvXFx7ICooW1xcd18tXSspICpcXH0vZztcclxuXHJcbi8vIEBmdW5jdGlvbiB0ZW1wbGF0ZShzdHI6IFN0cmluZywgZGF0YTogT2JqZWN0KTogU3RyaW5nXHJcbi8vIFNpbXBsZSB0ZW1wbGF0aW5nIGZhY2lsaXR5LCBhY2NlcHRzIGEgdGVtcGxhdGUgc3RyaW5nIG9mIHRoZSBmb3JtIGAnSGVsbG8ge2F9LCB7Yn0nYFxyXG4vLyBhbmQgYSBkYXRhIG9iamVjdCBsaWtlIGB7YTogJ2ZvbycsIGI6ICdiYXInfWAsIHJldHVybnMgZXZhbHVhdGVkIHN0cmluZ1xyXG4vLyBgKCdIZWxsbyBmb28sIGJhcicpYC4gWW91IGNhbiBhbHNvIHNwZWNpZnkgZnVuY3Rpb25zIGluc3RlYWQgb2Ygc3RyaW5ncyBmb3JcclxuLy8gZGF0YSB2YWx1ZXMg4oCUIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgcGFzc2luZyBgZGF0YWAgYXMgYW4gYXJndW1lbnQuXHJcbmZ1bmN0aW9uIHRlbXBsYXRlKHN0ciwgZGF0YSkge1xyXG5cdHJldHVybiBzdHIucmVwbGFjZSh0ZW1wbGF0ZVJlLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcclxuXHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIHByb3ZpZGVkIGZvciB2YXJpYWJsZSAnICsgc3RyKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gaXNBcnJheShvYmopOiBCb29sZWFuXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5pc0FycmF5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5KVxyXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xyXG5cdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGluZGV4T2YoYXJyYXk6IEFycmF5LCBlbDogT2JqZWN0KTogTnVtYmVyXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5wcm90b3R5cGUuaW5kZXhPZl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZilcclxuZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgZWwpIHtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAoYXJyYXlbaV0gPT09IGVsKSB7IHJldHVybiBpOyB9XHJcblx0fVxyXG5cdHJldHVybiAtMTtcclxufVxyXG5cclxuLy8gQHByb3BlcnR5IGVtcHR5SW1hZ2VVcmw6IFN0cmluZ1xyXG4vLyBEYXRhIFVSSSBzdHJpbmcgY29udGFpbmluZyBhIGJhc2U2NC1lbmNvZGVkIGVtcHR5IEdJRiBpbWFnZS5cclxuLy8gVXNlZCBhcyBhIGhhY2sgdG8gZnJlZSBtZW1vcnkgZnJvbSB1bnVzZWQgaW1hZ2VzIG9uIFdlYktpdC1wb3dlcmVkXHJcbi8vIG1vYmlsZSBkZXZpY2VzIChieSBzZXR0aW5nIGltYWdlIGBzcmNgIHRvIHRoaXMgc3RyaW5nKS5cclxudmFyIGVtcHR5SW1hZ2VVcmwgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPSc7XHJcblxyXG4vLyBpbnNwaXJlZCBieSBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG5cclxuZnVuY3Rpb24gZ2V0UHJlZml4ZWQobmFtZSkge1xyXG5cdHJldHVybiB3aW5kb3dbJ3dlYmtpdCcgKyBuYW1lXSB8fCB3aW5kb3dbJ21veicgKyBuYW1lXSB8fCB3aW5kb3dbJ21zJyArIG5hbWVdO1xyXG59XHJcblxyXG52YXIgbGFzdFRpbWUgPSAwO1xyXG5cclxuLy8gZmFsbGJhY2sgZm9yIElFIDctOFxyXG5mdW5jdGlvbiB0aW1lb3V0RGVmZXIoZm4pIHtcclxuXHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxyXG5cdCAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAodGltZSAtIGxhc3RUaW1lKSk7XHJcblxyXG5cdGxhc3RUaW1lID0gdGltZSArIHRpbWVUb0NhbGw7XHJcblx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lVG9DYWxsKTtcclxufVxyXG5cclxudmFyIHJlcXVlc3RGbiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ1JlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IHRpbWVvdXREZWZlcjtcclxudmFyIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8XHJcblx0XHRnZXRQcmVmaXhlZCgnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgZnVuY3Rpb24gKGlkKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpOyB9O1xyXG5cclxuLy8gQGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0LCBpbW1lZGlhdGU/OiBCb29sZWFuKTogTnVtYmVyXHJcbi8vIFNjaGVkdWxlcyBgZm5gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGJyb3dzZXIgcmVwYWludHMuIGBmbmAgaXMgYm91bmQgdG9cclxuLy8gYGNvbnRleHRgIGlmIGdpdmVuLiBXaGVuIGBpbW1lZGlhdGVgIGlzIHNldCwgYGZuYCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgaWZcclxuLy8gdGhlIGJyb3dzZXIgZG9lc24ndCBoYXZlIG5hdGl2ZSBzdXBwb3J0IGZvclxyXG4vLyBbYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZSksXHJcbi8vIG90aGVyd2lzZSBpdCdzIGRlbGF5ZWQuIFJldHVybnMgYSByZXF1ZXN0IElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxyXG5mdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuLCBjb250ZXh0LCBpbW1lZGlhdGUpIHtcclxuXHRpZiAoaW1tZWRpYXRlICYmIHJlcXVlc3RGbiA9PT0gdGltZW91dERlZmVyKSB7XHJcblx0XHRmbi5jYWxsKGNvbnRleHQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gcmVxdWVzdEZuLmNhbGwod2luZG93LCBiaW5kKGZuLCBjb250ZXh0KSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkOiBOdW1iZXIpOiB1bmRlZmluZWRcclxuLy8gQ2FuY2VscyBhIHByZXZpb3VzIGByZXF1ZXN0QW5pbUZyYW1lYC4gU2VlIGFsc28gW3dpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZSkuXHJcbmZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZCkge1xyXG5cdGlmIChpZCkge1xyXG5cdFx0Y2FuY2VsRm4uY2FsbCh3aW5kb3csIGlkKTtcclxuXHR9XHJcbn1cclxuXG5cbnZhciBVdGlsID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdGZyZWV6ZTogZnJlZXplLFxuXHRleHRlbmQ6IGV4dGVuZCxcblx0Y3JlYXRlOiBjcmVhdGUsXG5cdGJpbmQ6IGJpbmQsXG5cdGxhc3RJZDogbGFzdElkLFxuXHRzdGFtcDogc3RhbXAsXG5cdHRocm90dGxlOiB0aHJvdHRsZSxcblx0d3JhcE51bTogd3JhcE51bSxcblx0ZmFsc2VGbjogZmFsc2VGbixcblx0Zm9ybWF0TnVtOiBmb3JtYXROdW0sXG5cdHRyaW06IHRyaW0sXG5cdHNwbGl0V29yZHM6IHNwbGl0V29yZHMsXG5cdHNldE9wdGlvbnM6IHNldE9wdGlvbnMsXG5cdGdldFBhcmFtU3RyaW5nOiBnZXRQYXJhbVN0cmluZyxcblx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuXHRpc0FycmF5OiBpc0FycmF5LFxuXHRpbmRleE9mOiBpbmRleE9mLFxuXHRlbXB0eUltYWdlVXJsOiBlbXB0eUltYWdlVXJsLFxuXHRyZXF1ZXN0Rm46IHJlcXVlc3RGbixcblx0Y2FuY2VsRm46IGNhbmNlbEZuLFxuXHRyZXF1ZXN0QW5pbUZyYW1lOiByZXF1ZXN0QW5pbUZyYW1lLFxuXHRjYW5jZWxBbmltRnJhbWU6IGNhbmNlbEFuaW1GcmFtZVxufSk7XG5cbi8vIEBjbGFzcyBDbGFzc1xyXG4vLyBAYWthIEwuQ2xhc3NcclxuXHJcbi8vIEBzZWN0aW9uXHJcbi8vIEB1bmluaGVyaXRhYmxlXHJcblxyXG4vLyBUaGFua3MgdG8gSm9obiBSZXNpZyBhbmQgRGVhbiBFZHdhcmRzIGZvciBpbnNwaXJhdGlvbiFcclxuXHJcbmZ1bmN0aW9uIENsYXNzKCkge31cclxuXHJcbkNsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gZXh0ZW5kKHByb3BzOiBPYmplY3QpOiBGdW5jdGlvblxyXG5cdC8vIFtFeHRlbmRzIHRoZSBjdXJyZW50IGNsYXNzXSgjY2xhc3MtaW5oZXJpdGFuY2UpIGdpdmVuIHRoZSBwcm9wZXJ0aWVzIHRvIGJlIGluY2x1ZGVkLlxyXG5cdC8vIFJldHVybnMgYSBKYXZhc2NyaXB0IGZ1bmN0aW9uIHRoYXQgaXMgYSBjbGFzcyBjb25zdHJ1Y3RvciAodG8gYmUgY2FsbGVkIHdpdGggYG5ld2ApLlxyXG5cdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG5cdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG5cdFx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblx0fTtcclxuXHJcblx0dmFyIHBhcmVudFByb3RvID0gTmV3Q2xhc3MuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG5cdHZhciBwcm90byA9IGNyZWF0ZShwYXJlbnRQcm90byk7XHJcblx0cHJvdG8uY29uc3RydWN0b3IgPSBOZXdDbGFzcztcclxuXHJcblx0TmV3Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XHJcblxyXG5cdC8vIGluaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG5cdGZvciAodmFyIGkgaW4gdGhpcykge1xyXG5cdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScgJiYgaSAhPT0gJ19fc3VwZXJfXycpIHtcclxuXHRcdFx0TmV3Q2xhc3NbaV0gPSB0aGlzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gbWl4IHN0YXRpYyBwcm9wZXJ0aWVzIGludG8gdGhlIGNsYXNzXHJcblx0aWYgKHByb3BzLnN0YXRpY3MpIHtcclxuXHRcdGV4dGVuZChOZXdDbGFzcywgcHJvcHMuc3RhdGljcyk7XHJcblx0XHRkZWxldGUgcHJvcHMuc3RhdGljcztcclxuXHR9XHJcblxyXG5cdC8vIG1peCBpbmNsdWRlcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuXHRpZiAocHJvcHMuaW5jbHVkZXMpIHtcclxuXHRcdGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKHByb3BzLmluY2x1ZGVzKTtcclxuXHRcdGV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLmluY2x1ZGVzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWVyZ2Ugb3B0aW9uc1xyXG5cdGlmIChwcm90by5vcHRpb25zKSB7XHJcblx0XHRwcm9wcy5vcHRpb25zID0gZXh0ZW5kKGNyZWF0ZShwcm90by5vcHRpb25zKSwgcHJvcHMub3B0aW9ucyk7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggZ2l2ZW4gcHJvcGVydGllcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuXHRleHRlbmQocHJvdG8sIHByb3BzKTtcclxuXHJcblx0cHJvdG8uX2luaXRIb29rcyA9IFtdO1xyXG5cclxuXHQvLyBhZGQgbWV0aG9kIGZvciBjYWxsaW5nIGFsbCBob29rc1xyXG5cdHByb3RvLmNhbGxJbml0SG9va3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRIb29rc0NhbGxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAocGFyZW50UHJvdG8uY2FsbEluaXRIb29rcykge1xyXG5cdFx0XHRwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEhvb2tzQ2FsbGVkID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvdG8uX2luaXRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRwcm90by5faW5pdEhvb2tzW2ldLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIE5ld0NsYXNzO1xyXG59O1xyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBpbmNsdWRlKHByb3BlcnRpZXM6IE9iamVjdCk6IHRoaXNcclxuLy8gW0luY2x1ZGVzIGEgbWl4aW5dKCNjbGFzcy1pbmNsdWRlcykgaW50byB0aGUgY3VycmVudCBjbGFzcy5cclxuQ2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cdGV4dGVuZCh0aGlzLnByb3RvdHlwZSwgcHJvcHMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtNZXJnZXMgYG9wdGlvbnNgXSgjY2xhc3Mtb3B0aW9ucykgaW50byB0aGUgZGVmYXVsdHMgb2YgdGhlIGNsYXNzLlxyXG5DbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdGV4dGVuZCh0aGlzLnByb3RvdHlwZS5vcHRpb25zLCBvcHRpb25zKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRJbml0SG9vayhmbjogRnVuY3Rpb24pOiB0aGlzXHJcbi8vIEFkZHMgYSBbY29uc3RydWN0b3IgaG9va10oI2NsYXNzLWNvbnN0cnVjdG9yLWhvb2tzKSB0byB0aGUgY2xhc3MuXHJcbkNsYXNzLmFkZEluaXRIb29rID0gZnVuY3Rpb24gKGZuKSB7IC8vIChGdW5jdGlvbikgfHwgKFN0cmluZywgYXJncy4uLilcclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG5cdHZhciBpbml0ID0gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nID8gZm4gOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzW2ZuXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHR9O1xyXG5cclxuXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzID0gdGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyB8fCBbXTtcclxuXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzLnB1c2goaW5pdCk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhpbmNsdWRlcykge1xyXG5cdGlmICh0eXBlb2YgTCA9PT0gJ3VuZGVmaW5lZCcgfHwgIUwgfHwgIUwuTWl4aW4pIHsgcmV0dXJuOyB9XHJcblxyXG5cdGluY2x1ZGVzID0gaXNBcnJheShpbmNsdWRlcykgPyBpbmNsdWRlcyA6IFtpbmNsdWRlc107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgaW5jbHVkZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChpbmNsdWRlc1tpXSA9PT0gTC5NaXhpbi5FdmVudHMpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIGluY2x1ZGUgb2YgTC5NaXhpbi5FdmVudHM6ICcgK1xyXG5cdFx0XHRcdCd0aGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMsICcgK1xyXG5cdFx0XHRcdCdwbGVhc2UgaW5oZXJpdCBmcm9tIEwuRXZlbnRlZCBpbnN0ZWFkLicsIG5ldyBFcnJvcigpLnN0YWNrKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cblxuLypcclxuICogQGNsYXNzIEV2ZW50ZWRcclxuICogQGFrYSBMLkV2ZW50ZWRcclxuICogQGluaGVyaXRzIENsYXNzXHJcbiAqXHJcbiAqIEEgc2V0IG9mIG1ldGhvZHMgc2hhcmVkIGJldHdlZW4gZXZlbnQtcG93ZXJlZCBjbGFzc2VzIChsaWtlIGBNYXBgIGFuZCBgTWFya2VyYCkuIEdlbmVyYWxseSwgZXZlbnRzIGFsbG93IHlvdSB0byBleGVjdXRlIHNvbWUgZnVuY3Rpb24gd2hlbiBzb21ldGhpbmcgaGFwcGVucyB3aXRoIGFuIG9iamVjdCAoZS5nLiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG1hcCwgY2F1c2luZyB0aGUgbWFwIHRvIGZpcmUgYCdjbGljaydgIGV2ZW50KS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogbWFwLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICogXHRhbGVydChlLmxhdGxuZyk7XHJcbiAqIH0gKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIExlYWZsZXQgZGVhbHMgd2l0aCBldmVudCBsaXN0ZW5lcnMgYnkgcmVmZXJlbmNlLCBzbyBpZiB5b3Ugd2FudCB0byBhZGQgYSBsaXN0ZW5lciBhbmQgdGhlbiByZW1vdmUgaXQsIGRlZmluZSBpdCBhcyBhIGZ1bmN0aW9uOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBmdW5jdGlvbiBvbkNsaWNrKGUpIHsgLi4uIH1cclxuICpcclxuICogbWFwLm9uKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gKiBtYXAub2ZmKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgRXZlbnRzID0ge1xyXG5cdC8qIEBtZXRob2Qgb24odHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBvZiB0aGUgb2JqZWN0LiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXIgKG9iamVjdCB0aGUgdGhpcyBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvbihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHQgKi9cclxuXHRvbjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG5cdFx0XHR0eXBlcyA9IHNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8qIEBtZXRob2Qgb2ZmKHR5cGU6IFN0cmluZywgZm4/OiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi4gSWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBvZiB0aGF0IHBhcnRpY3VsYXIgZXZlbnQgZnJvbSB0aGUgb2JqZWN0LiBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIGBvbmAsIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWUgY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmYoZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZjogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyB0byBhbGwgZXZlbnRzIG9uIHRoZSBvYmplY3QuIFRoaXMgaW5jbHVkZXMgaW1wbGljaXRseSBhdHRhY2hlZCBldmVudHMuXHJcblx0ICovXHJcblx0b2ZmOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKCF0eXBlcykge1xyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGlmIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50c1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0eXBlcyA9IHNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBhdHRhY2ggbGlzdGVuZXIgKHdpdGhvdXQgc3ludGFjdGljIHN1Z2FyIG5vdylcclxuXHRfb246IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xyXG5cclxuXHRcdC8qIGdldC9pbml0IGxpc3RlbmVycyBmb3IgdHlwZSAqL1xyXG5cdFx0dmFyIHR5cGVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAoIXR5cGVMaXN0ZW5lcnMpIHtcclxuXHRcdFx0dHlwZUxpc3RlbmVycyA9IFtdO1xyXG5cdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSB0eXBlTGlzdGVuZXJzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcblx0XHRcdC8vIExlc3MgbWVtb3J5IGZvb3RwcmludC5cclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHRcdHZhciBuZXdMaXN0ZW5lciA9IHtmbjogZm4sIGN0eDogY29udGV4dH0sXHJcblx0XHQgICAgbGlzdGVuZXJzID0gdHlwZUxpc3RlbmVycztcclxuXHJcblx0XHQvLyBjaGVjayBpZiBmbiBhbHJlYWR5IHRoZXJlXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuICYmIGxpc3RlbmVyc1tpXS5jdHggPT09IGNvbnRleHQpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsaXN0ZW5lcnMucHVzaChuZXdMaXN0ZW5lcik7XHJcblx0fSxcclxuXHJcblx0X29mZjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzLFxyXG5cdFx0ICAgIGksXHJcblx0XHQgICAgbGVuO1xyXG5cclxuXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcblx0XHRpZiAoIWxpc3RlbmVycykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFmbikge1xyXG5cdFx0XHQvLyBTZXQgYWxsIHJlbW92ZWQgbGlzdGVuZXJzIHRvIG5vb3Agc28gdGhleSBhcmUgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGxpc3RlbmVyc1tpXS5mbiA9IGZhbHNlRm47XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblxyXG5cdFx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0aWYgKGwuY3R4ICE9PSBjb250ZXh0KSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdFx0aWYgKGwuZm4gPT09IGZuKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRcdFx0bC5mbiA9IGZhbHNlRm47XHJcblxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2ZpcmluZ0NvdW50KSB7XHJcblx0XHRcdFx0XHRcdC8qIGNvcHkgYXJyYXkgaW4gY2FzZSBldmVudHMgYXJlIGJlaW5nIGZpcmVkICovXHJcblx0XHRcdFx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXJlKHR5cGU6IFN0cmluZywgZGF0YT86IE9iamVjdCwgcHJvcGFnYXRlPzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBGaXJlcyBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGFuIGRhdGFcclxuXHQvLyBvYmplY3Qg4oCUIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gd2lsbCBjb250YWluIGl0c1xyXG5cdC8vIHByb3BlcnRpZXMuIFRoZSBldmVudCBjYW4gb3B0aW9uYWxseSBiZSBwcm9wYWdhdGVkIHRvIGV2ZW50IHBhcmVudHMuXHJcblx0ZmlyZTogZnVuY3Rpb24gKHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSkge1xyXG5cdFx0aWYgKCF0aGlzLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBldmVudCA9IGV4dGVuZCh7fSwgZGF0YSwge1xyXG5cdFx0XHR0eXBlOiB0eXBlLFxyXG5cdFx0XHR0YXJnZXQ6IHRoaXMsXHJcblx0XHRcdHNvdXJjZVRhcmdldDogZGF0YSAmJiBkYXRhLnNvdXJjZVRhcmdldCB8fCB0aGlzXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fZXZlbnRzKSB7XHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG5cdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQgPSAodGhpcy5fZmlyaW5nQ291bnQgKyAxKSB8fCAxO1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xyXG5cdFx0XHRcdFx0bC5mbi5jYWxsKGwuY3R4IHx8IHRoaXMsIGV2ZW50KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50LS07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAocHJvcGFnYXRlKSB7XHJcblx0XHRcdC8vIHByb3BhZ2F0ZSB0aGUgZXZlbnQgdG8gcGFyZW50cyAoc2V0IHdpdGggYWRkRXZlbnRQYXJlbnQpXHJcblx0XHRcdHRoaXMuX3Byb3BhZ2F0ZUV2ZW50KGV2ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxpc3RlbnModHlwZTogU3RyaW5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGEgcGFydGljdWxhciBldmVudCB0eXBlIGhhcyBhbnkgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIGl0LlxyXG5cdGxpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBwcm9wYWdhdGUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMubGVuZ3RoKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBhbHNvIGNoZWNrIHBhcmVudHMgZm9yIGxpc3RlbmVycyBpZiBldmVudCBwcm9wYWdhdGVzXHJcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHNbaWRdLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvbmNlKOKApik6IHRoaXNcclxuXHQvLyBCZWhhdmVzIGFzIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKSwgZXhjZXB0IHRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgZ2V0IGZpcmVkIG9uY2UgYW5kIHRoZW4gcmVtb3ZlZC5cclxuXHRvbmNlOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMub25jZSh0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gYmluZChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5vZmYodHlwZXMsIGZuLCBjb250ZXh0KVxyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHQvLyBhZGQgYSBsaXN0ZW5lciB0aGF0J3MgZXhlY3V0ZWQgb25jZSBhbmQgcmVtb3ZlZCBhZnRlciB0aGF0XHJcblx0XHRyZXR1cm4gdGhpc1xyXG5cdFx0ICAgIC5vbih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHQgICAgLm9uKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGV2ZW50IHBhcmVudCAtIGFuIGBFdmVudGVkYCB0aGF0IHdpbGwgcmVjZWl2ZSBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdGFkZEV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHMgPSB0aGlzLl9ldmVudFBhcmVudHMgfHwge307XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHNbc3RhbXAob2JqKV0gPSBvYmo7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFuIGV2ZW50IHBhcmVudCwgc28gaXQgd2lsbCBzdG9wIHJlY2VpdmluZyBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdHJlbW92ZUV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudFBhcmVudHNbc3RhbXAob2JqKV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcHJvcGFnYXRlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0dGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5maXJlKGUudHlwZSwgZXh0ZW5kKHtcclxuXHRcdFx0XHRsYXllcjogZS50YXJnZXQsXHJcblx0XHRcdFx0cHJvcGFnYXRlZEZyb206IGUudGFyZ2V0XHJcblx0XHRcdH0sIGUpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vLyBhbGlhc2VzOyB3ZSBzaG91bGQgZGl0Y2ggdGhvc2UgZXZlbnR1YWxseVxyXG5cclxuLy8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pXHJcbkV2ZW50cy5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uO1xyXG5cclxuLy8gQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYo4oCmKWBdKCNldmVudGVkLW9mZilcclxuXHJcbi8vIEBtZXRob2QgY2xlYXJBbGxFdmVudExpc3RlbmVycyjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKClgXSgjZXZlbnRlZC1vZmYpXHJcbkV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyID0gRXZlbnRzLmNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMub2ZmO1xyXG5cclxuLy8gQG1ldGhvZCBhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb25jZSjigKYpYF0oI2V2ZW50ZWQtb25jZSlcclxuRXZlbnRzLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uY2U7XHJcblxyXG4vLyBAbWV0aG9kIGZpcmVFdmVudCjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgZmlyZSjigKYpYF0oI2V2ZW50ZWQtZmlyZSlcclxuRXZlbnRzLmZpcmVFdmVudCA9IEV2ZW50cy5maXJlO1xyXG5cclxuLy8gQG1ldGhvZCBoYXNFdmVudExpc3RlbmVycyjigKYpOiBCb29sZWFuXHJcbi8vIEFsaWFzIHRvIFtgbGlzdGVucyjigKYpYF0oI2V2ZW50ZWQtbGlzdGVucylcclxuRXZlbnRzLmhhc0V2ZW50TGlzdGVuZXJzID0gRXZlbnRzLmxpc3RlbnM7XHJcblxyXG52YXIgRXZlbnRlZCA9IENsYXNzLmV4dGVuZChFdmVudHMpO1xuXG4vKlxyXG4gKiBAY2xhc3MgUG9pbnRcclxuICogQGFrYSBMLlBvaW50XHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBwb2ludCB3aXRoIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGluIHBpeGVscy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvaW50ID0gTC5wb2ludCgyMDAsIDMwMCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIGFuZCBvcHRpb25zIHRoYXQgYWNjZXB0IGBQb2ludGAgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBganNcclxuICogbWFwLnBhbkJ5KFsyMDAsIDMwMF0pO1xyXG4gKiBtYXAucGFuQnkoTC5wb2ludCgyMDAsIDMwMCkpO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBQb2ludGAgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuXHQvLyBAcHJvcGVydHkgeDogTnVtYmVyOyBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG5cdC8vIEBwcm9wZXJ0eSB5OiBOdW1iZXI7IFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuXHR0aGlzLnkgPSAocm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XHJcbn1cclxuXHJcbnZhciB0cnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcclxuXHRyZXR1cm4gdiA+IDAgPyBNYXRoLmZsb29yKHYpIDogTWF0aC5jZWlsKHYpO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGNsb25lKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkKG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYWRkaXRpb24gb2YgdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0YWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIG5vbi1kZXN0cnVjdGl2ZSwgcmV0dXJucyBhIG5ldyBwb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHRvUG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIGRlc3RydWN0aXZlLCB1c2VkIGRpcmVjdGx5IGZvciBwZXJmb3JtYW5jZSBpbiBzaXR1YXRpb25zIHdoZXJlIGl0J3Mgc2FmZSB0byBtb2RpZnkgZXhpc3RpbmcgcG9pbnRcclxuXHRcdHRoaXMueCArPSBwb2ludC54O1xyXG5cdFx0dGhpcy55ICs9IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN1YnRyYWN0KG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3Rpb24gb2YgdGhlIGdpdmVuIHBvaW50IGZyb20gdGhlIGN1cnJlbnQuXHJcblx0c3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QodG9Qb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9zdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR0aGlzLnggLT0gcG9pbnQueDtcclxuXHRcdHRoaXMueSAtPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXZpZGVCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0ZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2RpdmlkZUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X2RpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggLz0gbnVtO1xyXG5cdFx0dGhpcy55IC89IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbXVsdGlwbHlCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0bXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdGlwbHlCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9tdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggKj0gbnVtO1xyXG5cdFx0dGhpcy55ICo9IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIE11bHRpcGx5IGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieSBlYWNoIGNvb3JkaW5hdGUgb2ZcclxuXHQvLyBgc2NhbGVgLiBJbiBsaW5lYXIgYWxnZWJyYSB0ZXJtcywgbXVsdGlwbHkgdGhlIHBvaW50IGJ5IHRoZVxyXG5cdC8vIFtzY2FsaW5nIG1hdHJpeF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NhbGluZ18lMjhnZW9tZXRyeSUyOSNNYXRyaXhfcmVwcmVzZW50YXRpb24pXHJcblx0Ly8gZGVmaW5lZCBieSBgc2NhbGVgLlxyXG5cdHNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEludmVyc2Ugb2YgYHNjYWxlQnlgLiBEaXZpZGUgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5XHJcblx0Ly8gZWFjaCBjb29yZGluYXRlIG9mIGBzY2FsZWAuXHJcblx0dW5zY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByb3VuZCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggcm91bmRlZCBjb29yZGluYXRlcy5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmxvb3IoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGZsb29yZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgZG93bikuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XHJcblx0fSxcclxuXHJcblx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNlaWwoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGNlaWxlZCBjb29yZGluYXRlcyAocm91bmRlZCB1cCkuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0cnVuYygpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggdHJ1bmNhdGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHRvd2FyZHMgemVybykuXHJcblx0dHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3RydW5jKCk7XHJcblx0fSxcclxuXHJcblx0X3RydW5jOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSB0cnVuYyh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gdHJ1bmModGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlclBvaW50OiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGNhcnRlc2lhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLngsXHJcblx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaGFzIHRoZSBzYW1lIGNvb3JkaW5hdGVzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludC54ID09PSB0aGlzLnggJiZcclxuXHRcdCAgICAgICBwb2ludC55ID09PSB0aGlzLnk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGNvb3JkaW5hdGVzIG9mIHRoZSBnaXZlbiBwb2ludCBhcmUgbGVzcyB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGN1cnJlbnQgcG9pbnQgY29vcmRpbmF0ZXMgKGluIGFic29sdXRlIHZhbHVlcykuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMocG9pbnQueCkgPD0gTWF0aC5hYnModGhpcy54KSAmJlxyXG5cdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gJ1BvaW50KCcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy55KSArICcpJztcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KHg6IE51bWJlciwgeTogTnVtYmVyLCByb3VuZD86IEJvb2xlYW4pXHJcbi8vIENyZWF0ZXMgYSBQb2ludCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMuIElmIG9wdGlvbmFsIGByb3VuZGAgaXMgc2V0IHRvIHRydWUsIHJvdW5kcyB0aGUgYHhgIGFuZCBgeWAgdmFsdWVzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBOdW1iZXJbXSlcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW3gsIHldYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBPYmplY3QpXHJcbi8vIEV4cGVjdHMgYSBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHt4OiBOdW1iZXIsIHk6IE51bWJlcn1gIGluc3RlYWQuXHJcbmZ1bmN0aW9uIHRvUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuXHRpZiAoeCBpbnN0YW5jZW9mIFBvaW50KSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKGlzQXJyYXkoeCkpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoeFswXSwgeFsxXSk7XHJcblx0fVxyXG5cdGlmICh4ID09PSB1bmRlZmluZWQgfHwgeCA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIHggJiYgJ3knIGluIHgpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoeC54LCB4LnkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxufVxuXG4vKlxyXG4gKiBAY2xhc3MgQm91bmRzXHJcbiAqIEBha2EgTC5Cb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgaW4gcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwMSA9IEwucG9pbnQoMTAsIDEwKSxcclxuICogcDIgPSBMLnBvaW50KDQwLCA2MCksXHJcbiAqIGJvdW5kcyA9IEwuYm91bmRzKHAxLCBwMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IGBCb3VuZHNgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBvdGhlckJvdW5kcy5pbnRlcnNlY3RzKFtbMTAsIDEwXSwgWzQwLCA2MF1dKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5mdW5jdGlvbiBCb3VuZHMoYSwgYikge1xyXG5cdGlmICghYSkgeyByZXR1cm47IH1cclxuXHJcblx0dmFyIHBvaW50cyA9IGIgPyBbYSwgYl0gOiBhO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChwb2ludHNbaV0pO1xyXG5cdH1cclxufVxyXG5cclxuQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChwb2ludDogUG9pbnQpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kcyB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50LlxyXG5cdGV4dGVuZDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1pbjogUG9pbnRcclxuXHRcdC8vIFRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtYXg6IFBvaW50XHJcblx0XHQvLyBUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0aWYgKCF0aGlzLm1pbiAmJiAhdGhpcy5tYXgpIHtcclxuXHRcdFx0dGhpcy5taW4gPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0XHR0aGlzLm1heCA9IHBvaW50LmNsb25lKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm1pbi54ID0gTWF0aC5taW4ocG9pbnQueCwgdGhpcy5taW4ueCk7XHJcblx0XHRcdHRoaXMubWF4LnggPSBNYXRoLm1heChwb2ludC54LCB0aGlzLm1heC54KTtcclxuXHRcdFx0dGhpcy5taW4ueSA9IE1hdGgubWluKHBvaW50LnksIHRoaXMubWluLnkpO1xyXG5cdFx0XHR0aGlzLm1heC55ID0gTWF0aC5tYXgocG9pbnQueSwgdGhpcy5tYXgueSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcihyb3VuZD86IEJvb2xlYW4pOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKHJvdW5kKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueCArIHRoaXMubWF4LngpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnkgKyB0aGlzLm1heC55KSAvIDIsIHJvdW5kKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdHRvbUxlZnQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldEJvdHRvbUxlZnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5taW4ueCwgdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BSaWdodCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHRvcC1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFRvcFJpZ2h0OiBmdW5jdGlvbiAoKSB7IC8vIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMubWF4LngsIHRoaXMubWluLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0VG9wTGVmdCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHRvcC1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMgKGkuZS4gW2B0aGlzLm1pbmBdKCNib3VuZHMtbWluKSkuXHJcblx0Z2V0VG9wTGVmdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWluOyAvLyBsZWZ0LCB0b3BcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdHRvbVJpZ2h0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMgKGkuZS4gW2B0aGlzLm1heGBdKCNib3VuZHMtbWF4KSkuXHJcblx0Z2V0Qm90dG9tUmlnaHQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1heDsgLy8gcmlnaHQsIGJvdHRvbVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1heC5zdWJ0cmFjdCh0aGlzLm1pbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKHBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuXHRjb250YWluczogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIG1pbiwgbWF4O1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBQb2ludCkge1xyXG5cdFx0XHRvYmogPSB0b1BvaW50KG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBCb3VuZHMpIHtcclxuXHRcdFx0bWluID0gb2JqLm1pbjtcclxuXHRcdFx0bWF4ID0gb2JqLm1heDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1pbiA9IG1heCA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKG1pbi54ID49IHRoaXMubWluLngpICYmXHJcblx0XHQgICAgICAgKG1heC54IDw9IHRoaXMubWF4LngpICYmXHJcblx0XHQgICAgICAgKG1pbi55ID49IHRoaXMubWluLnkpICYmXHJcblx0XHQgICAgICAgKG1heC55IDw9IHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeEludGVyc2VjdHMgPSAobWF4Mi54ID49IG1pbi54KSAmJiAobWluMi54IDw9IG1heC54KSxcclxuXHRcdCAgICB5SW50ZXJzZWN0cyA9IChtYXgyLnkgPj0gbWluLnkpICYmIChtaW4yLnkgPD0gbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4SW50ZXJzZWN0cyAmJiB5SW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4T3ZlcmxhcHMgPSAobWF4Mi54ID4gbWluLngpICYmIChtaW4yLnggPCBtYXgueCksXHJcblx0XHQgICAgeU92ZXJsYXBzID0gKG1heDIueSA+IG1pbi55KSAmJiAobWluMi55IDwgbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4T3ZlcmxhcHMgJiYgeU92ZXJsYXBzO1xyXG5cdH0sXHJcblxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLm1pbiAmJiB0aGlzLm1heCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKGNvcm5lcjE6IFBvaW50LCBjb3JuZXIyOiBQb2ludClcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0d28gY29ybmVycyBjb29yZGluYXRlIHBhaXJzLlxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5ib3VuZHMocG9pbnRzOiBQb2ludFtdKVxyXG4vLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhcnJheSBvZiBwb2ludHMuXHJcbmZ1bmN0aW9uIHRvQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgQm91bmRzKGEsIGIpO1xyXG59XG5cbi8qXHJcbiAqIEBjbGFzcyBMYXRMbmdCb3VuZHNcclxuICogQGFrYSBMLkxhdExuZ0JvdW5kc1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgZ2VvZ3JhcGhpY2FsIGFyZWEgb24gYSBtYXAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBjb3JuZXIxID0gTC5sYXRMbmcoNDAuNzEyLCAtNzQuMjI3KSxcclxuICogY29ybmVyMiA9IEwubGF0TG5nKDQwLjc3NCwgLTc0LjEyNSksXHJcbiAqIGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmdCb3VuZHMgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5maXRCb3VuZHMoW1xyXG4gKiBcdFs0MC43MTIsIC03NC4yMjddLFxyXG4gKiBcdFs0MC43NzQsIC03NC4xMjVdXHJcbiAqIF0pO1xyXG4gKiBgYGBcclxuICpcclxuICogQ2F1dGlvbjogaWYgdGhlIGFyZWEgY3Jvc3NlcyB0aGUgYW50aW1lcmlkaWFuIChvZnRlbiBjb25mdXNlZCB3aXRoIHRoZSBJbnRlcm5hdGlvbmFsIERhdGUgTGluZSksIHlvdSBtdXN0IHNwZWNpZnkgY29ybmVycyBfb3V0c2lkZV8gdGhlIFstMTgwLCAxODBdIGRlZ3JlZXMgbG9uZ2l0dWRlIHJhbmdlLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYExhdExuZ0JvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gTGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcblx0aWYgKCFjb3JuZXIxKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgbGF0bG5ncyA9IGNvcm5lcjIgPyBbY29ybmVyMSwgY29ybmVyMl0gOiBjb3JuZXIxO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5MYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGV4dGVuZChsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuXHRcdFx0c3cyID0gb2JqO1xyXG5cdFx0XHRuZTIgPSBvYmo7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLl9zb3V0aFdlc3Q7XHJcblx0XHRcdG5lMiA9IG9iai5fbm9ydGhFYXN0O1xyXG5cclxuXHRcdFx0aWYgKCFzdzIgfHwgIW5lMikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBvYmogPyB0aGlzLmV4dGVuZCh0b0xhdExuZyhvYmopIHx8IHRvTGF0TG5nQm91bmRzKG9iaikpIDogdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXN3ICYmICFuZSkge1xyXG5cdFx0XHR0aGlzLl9zb3V0aFdlc3QgPSBuZXcgTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xyXG5cdFx0XHR0aGlzLl9ub3J0aEVhc3QgPSBuZXcgTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcclxuXHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcclxuXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuXHRcdFx0bmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcblx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcoc3cubGF0IC0gaGVpZ2h0QnVmZmVyLCBzdy5sbmcgLSB3aWR0aEJ1ZmZlciksXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubGF0ICsgdGhpcy5fbm9ydGhFYXN0LmxhdCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxuZyArIHRoaXMuX25vcnRoRWFzdC5sbmcpIC8gMik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB3ZXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0V2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0U291dGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWFzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBlYXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMgKGxhdGxuZzogTGF0TG5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMYXRMbmcgfHwgJ2xhdCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0xhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcblx0XHQgICAgbG5nSW50ZXJzZWN0cyA9IChuZTIubG5nID49IHN3LmxuZykgJiYgKHN3Mi5sbmcgPD0gbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0SW50ZXJzZWN0cyAmJiBsbmdJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ092ZXJsYXBzID0gKG5lMi5sbmcgPiBzdy5sbmcpICYmIChzdzIubG5nIDwgbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0T3ZlcmxhcHMgJiYgbG5nT3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JCb3hTdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyB3aXRoIGJvdW5kaW5nIGJveCBjb29yZGluYXRlcyBpbiBhICdzb3V0aHdlc3RfbG5nLHNvdXRod2VzdF9sYXQsbm9ydGhlYXN0X2xuZyxub3J0aGVhc3RfbGF0JyBmb3JtYXQuIFVzZWZ1bCBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byB3ZWIgc2VydmljZXMgdGhhdCByZXR1cm4gZ2VvIGRhdGEuXHJcblx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpcyBlcXVpdmFsZW50ICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpIHRvIHRoZSBnaXZlbiBib3VuZHMuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMsIG1heE1hcmdpbikge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCksIG1heE1hcmdpbikgJiZcclxuXHRcdCAgICAgICB0aGlzLl9ub3J0aEVhc3QuZXF1YWxzKGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgbWF4TWFyZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzVmFsaWQoKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLl9zb3V0aFdlc3QgJiYgdGhpcy5fbm9ydGhFYXN0KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBUT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMoY29ybmVyMTogTGF0TG5nLCBjb3JuZXIyOiBMYXRMbmcpXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgYnkgZGVmaW5pbmcgdHdvIGRpYWdvbmFsbHkgb3Bwb3NpdGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGxhdGxuZ3M6IExhdExuZ1tdKVxyXG4vLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGRlZmluZWQgYnkgdGhlIGdlb2dyYXBoaWNhbCBwb2ludHMgaXQgY29udGFpbnMuIFZlcnkgdXNlZnVsIGZvciB6b29taW5nIHRoZSBtYXAgdG8gZml0IGEgcGFydGljdWxhciBzZXQgb2YgbG9jYXRpb25zIHdpdGggW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbmZ1bmN0aW9uIHRvTGF0TG5nQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKGEsIGIpO1xyXG59XG5cbi8qIEBjbGFzcyBMYXRMbmdcclxuICogQGFrYSBMLkxhdExuZ1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggYSBjZXJ0YWluIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiB2YXIgbGF0bG5nID0gTC5sYXRMbmcoNTAuNSwgMzAuNSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSBhbmQgc2ltcGxlIG9iamVjdCBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBtYXAucGFuVG8oWzUwLCAzMF0pO1xyXG4gKiBtYXAucGFuVG8oe2xvbjogMzAsIGxhdDogNTB9KTtcclxuICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAqIG1hcC5wYW5UbyhMLmxhdExuZyg1MCwgMzApKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgTGF0TG5nYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gTGF0TG5nKGxhdCwgbG5nLCBhbHQpIHtcclxuXHRpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcclxuXHR9XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsYXQ6IE51bWJlclxyXG5cdC8vIExhdGl0dWRlIGluIGRlZ3JlZXNcclxuXHR0aGlzLmxhdCA9ICtsYXQ7XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsbmc6IE51bWJlclxyXG5cdC8vIExvbmdpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sbmcgPSArbG5nO1xyXG5cclxuXHQvLyBAcHJvcGVydHkgYWx0OiBOdW1iZXJcclxuXHQvLyBBbHRpdHVkZSBpbiBtZXRlcnMgKG9wdGlvbmFsKVxyXG5cdGlmIChhbHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhpcy5hbHQgPSArYWx0O1xyXG5cdH1cclxufVxyXG5cclxuTGF0TG5nLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckxhdExuZzogTGF0TG5nLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGBMYXRMbmdgIHBvaW50IGlzIGF0IHRoZSBzYW1lIHBvc2l0aW9uICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAob2JqLCBtYXhNYXJnaW4pIHtcclxuXHRcdGlmICghb2JqKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblxyXG5cdFx0dmFyIG1hcmdpbiA9IE1hdGgubWF4KFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxhdCAtIG9iai5sYXQpLFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxuZyAtIG9iai5sbmcpKTtcclxuXHJcblx0XHRyZXR1cm4gbWFyZ2luIDw9IChtYXhNYXJnaW4gPT09IHVuZGVmaW5lZCA/IDEuMEUtOSA6IG1heE1hcmdpbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlcykuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHJldHVybiAnTGF0TG5nKCcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMubG5nLCBwcmVjaXNpb24pICsgJyknO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlckxhdExuZzogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgKGluIG1ldGVycykgdG8gdGhlIGdpdmVuIGBMYXRMbmdgIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIFtTcGhlcmljYWwgTGF3IG9mIENvc2luZXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwaGVyaWNhbF9sYXdfb2ZfY29zaW5lcykuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKG90aGVyKSB7XHJcblx0XHRyZXR1cm4gRWFydGguZGlzdGFuY2UodGhpcywgdG9MYXRMbmcob3RoZXIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXAoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nYCBvYmplY3Qgd2l0aCB0aGUgbG9uZ2l0dWRlIHdyYXBwZWQgc28gaXQncyBhbHdheXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcblx0d3JhcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIEVhcnRoLndyYXBMYXRMbmcodGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JvdW5kcyhzaXplSW5NZXRlcnM6IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGluIHdoaWNoIGVhY2ggYm91bmRhcnkgaXMgYHNpemVJbk1ldGVycy8yYCBtZXRlcnMgYXBhcnQgZnJvbSB0aGUgYExhdExuZ2AuXHJcblx0dG9Cb3VuZHM6IGZ1bmN0aW9uIChzaXplSW5NZXRlcnMpIHtcclxuXHRcdHZhciBsYXRBY2N1cmFjeSA9IDE4MCAqIHNpemVJbk1ldGVycyAvIDQwMDc1MDE3LFxyXG5cdFx0ICAgIGxuZ0FjY3VyYWN5ID0gbGF0QWNjdXJhY3kgLyBNYXRoLmNvcygoTWF0aC5QSSAvIDE4MCkgKiB0aGlzLmxhdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRvTGF0TG5nQm91bmRzKFxyXG5cdFx0ICAgICAgICBbdGhpcy5sYXQgLSBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgLSBsbmdBY2N1cmFjeV0sXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCArIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyArIGxuZ0FjY3VyYWN5XSk7XHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMubGF0LCB0aGlzLmxuZywgdGhpcy5hbHQpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcobGF0aXR1ZGU6IE51bWJlciwgbG9uZ2l0dWRlOiBOdW1iZXIsIGFsdGl0dWRlPzogTnVtYmVyKTogTGF0TG5nXHJcbi8vIENyZWF0ZXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIHRoZSBnaXZlbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIChhbmQgb3B0aW9uYWxseSBhbHRpdHVkZSkuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbTnVtYmVyLCBOdW1iZXJdYCBvciBgW051bWJlciwgTnVtYmVyLCBOdW1iZXJdYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogT2JqZWN0KTogTGF0TG5nXHJcbi8vIEV4cGVjdHMgYW4gcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyfWAgb3IgYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXIsIGFsdDogTnVtYmVyfWAgaW5zdGVhZC5cclxuXHJcbmZ1bmN0aW9uIHRvTGF0TG5nKGEsIGIsIGMpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmIChpc0FycmF5KGEpICYmIHR5cGVvZiBhWzBdICE9PSAnb2JqZWN0Jykge1xyXG5cdFx0aWYgKGEubGVuZ3RoID09PSAzKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTGF0TG5nKGFbMF0sIGFbMV0sIGFbMl0pO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGEubGVuZ3RoID09PSAyKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTGF0TG5nKGFbMF0sIGFbMV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdGlmIChhID09PSB1bmRlZmluZWQgfHwgYSA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ2xhdCcgaW4gYSkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoYS5sYXQsICdsbmcnIGluIGEgPyBhLmxuZyA6IGEubG9uLCBhLmFsdCk7XHJcblx0fVxyXG5cdGlmIChiID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IExhdExuZyhhLCBiLCBjKTtcclxufVxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkJhc2VcclxuICogT2JqZWN0IHRoYXQgZGVmaW5lcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGZvciBwcm9qZWN0aW5nXHJcbiAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAqIFtzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29vcmRpbmF0ZV9yZWZlcmVuY2Vfc3lzdGVtKS5cclxuICpcclxuICogTGVhZmxldCBkZWZpbmVzIHRoZSBtb3N0IHVzdWFsIENSU3MgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG8gdXNlIGFcclxuICogQ1JTIG5vdCBkZWZpbmVkIGJ5IGRlZmF1bHQsIHRha2UgYSBsb29rIGF0IHRoZVxyXG4gKiBbUHJvajRMZWFmbGV0XShodHRwczovL2dpdGh1Yi5jb20va2FydGVuYS9Qcm9qNExlYWZsZXQpIHBsdWdpbi5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSBDUlMgaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxyXG4gKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG52YXIgQ1JTID0ge1xyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Qb2ludChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBnaXZlbiB6b29tLlxyXG5cdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuXHQvLyB6b29tIGludG8gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cdHBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICB1bnRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGNvb3JkaW5hdGVzIGluIHVuaXRzIGFjY2VwdGVkIGZvclxyXG5cdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcHJvamVjdGVkIGNvb3JkaW5hdGUgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBMYXRMbmcuXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChwb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZSh6b29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSB1c2VkIHdoZW4gdHJhbnNmb3JtaW5nIHByb2plY3RlZCBjb29yZGluYXRlcyBpbnRvXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG5cdC8vIGAyNTYgKiAyXnpvb21gIGZvciBNZXJjYXRvci1iYXNlZCBDUlMuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tKHNjYWxlOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5nIHRvIGEgc2NhbGVcclxuXHQvLyBmYWN0b3Igb2YgYHNjYWxlYC5cclxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFByb2plY3RlZEJvdW5kcyh6b29tOiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcblx0Z2V0UHJvamVjdGVkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0aWYgKHRoaXMuaW5maW5pdGUpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcblx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcblx0XHQgICAgcyA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgbWluID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5taW4sIHMpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhtaW4sIG1heCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHJcblx0Ly8gQHByb3BlcnR5IGNvZGU6IFN0cmluZ1xyXG5cdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxyXG5cdC8vXHJcblx0Ly8gQHByb3BlcnR5IHdyYXBMbmc6IE51bWJlcltdXHJcblx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXHJcblx0Ly8gYXhpcyB3cmFwcyBhcm91bmQgYSBnaXZlbiByYW5nZSBhbmQgaG93LiBEZWZhdWx0cyB0byBgWy0xODAsIDE4MF1gIGluIG1vc3RcclxuXHQvLyBnZW9ncmFwaGljYWwgQ1JTcy4gSWYgYHVuZGVmaW5lZGAsIHRoZSBsb25naXR1ZGUgYXhpcyBkb2VzIG5vdCB3cmFwIGFyb3VuZC5cclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTGF0OiBOdW1iZXJbXVxyXG5cdC8vIExpa2UgYHdyYXBMbmdgLCBidXQgZm9yIHRoZSBsYXRpdHVkZSAodmVydGljYWwpIGF4aXMuXHJcblxyXG5cdC8vIHdyYXBMbmc6IFttaW4sIG1heF0sXHJcblx0Ly8gd3JhcExhdDogW21pbiwgbWF4XSxcclxuXHJcblx0Ly8gQHByb3BlcnR5IGluZmluaXRlOiBCb29sZWFuXHJcblx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuXHRpbmZpbml0ZTogZmFsc2UsXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IHdyYXBOdW0obGF0bG5nLmxuZywgdGhpcy53cmFwTG5nLCB0cnVlKSA6IGxhdGxuZy5sbmcsXHJcblx0XHQgICAgbGF0ID0gdGhpcy53cmFwTGF0ID8gd3JhcE51bShsYXRsbmcubGF0LCB0aGlzLndyYXBMYXQsIHRydWUpIDogbGF0bG5nLmxhdCxcclxuXHRcdCAgICBhbHQgPSBsYXRsbmcuYWx0O1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKGxhdCwgbG5nLCBhbHQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZ0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmdcclxuXHQvLyB0aGF0IGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXHJcblx0Ly8gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5MYXRMbmdCb3VuZHNgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR2YXIgY2VudGVyID0gYm91bmRzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMud3JhcExhdExuZyhjZW50ZXIpLFxyXG5cdFx0ICAgIGxhdFNoaWZ0ID0gY2VudGVyLmxhdCAtIG5ld0NlbnRlci5sYXQsXHJcblx0XHQgICAgbG5nU2hpZnQgPSBjZW50ZXIubG5nIC0gbmV3Q2VudGVyLmxuZztcclxuXHJcblx0XHRpZiAobGF0U2hpZnQgPT09IDAgJiYgbG5nU2hpZnQgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIGJvdW5kcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3cgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblx0XHQgICAgbmV3U3cgPSBuZXcgTGF0TG5nKHN3LmxhdCAtIGxhdFNoaWZ0LCBzdy5sbmcgLSBsbmdTaGlmdCksXHJcblx0XHQgICAgbmV3TmUgPSBuZXcgTGF0TG5nKG5lLmxhdCAtIGxhdFNoaWZ0LCBuZS5sbmcgLSBsbmdTaGlmdCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMobmV3U3csIG5ld05lKTtcclxuXHR9XHJcbn07XG5cbi8qXG4gKiBAbmFtZXNwYWNlIENSU1xuICogQGNycyBMLkNSUy5FYXJ0aFxuICpcbiAqIFNlcnZlcyBhcyB0aGUgYmFzZSBmb3IgQ1JTIHRoYXQgYXJlIGdsb2JhbCBzdWNoIHRoYXQgdGhleSBjb3ZlciB0aGUgZWFydGguXG4gKiBDYW4gb25seSBiZSB1c2VkIGFzIHRoZSBiYXNlIGZvciBvdGhlciBDUlMgYW5kIGNhbm5vdCBiZSB1c2VkIGRpcmVjdGx5LFxuICogc2luY2UgaXQgZG9lcyBub3QgaGF2ZSBhIGBjb2RlYCwgYHByb2plY3Rpb25gIG9yIGB0cmFuc2Zvcm1hdGlvbmAuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBtZXRlcnMuXG4gKi9cblxudmFyIEVhcnRoID0gZXh0ZW5kKHt9LCBDUlMsIHtcblx0d3JhcExuZzogWy0xODAsIDE4MF0sXG5cblx0Ly8gTWVhbiBFYXJ0aCBSYWRpdXMsIGFzIHJlY29tbWVuZGVkIGZvciB1c2UgYnlcblx0Ly8gdGhlIEludGVybmF0aW9uYWwgVW5pb24gb2YgR2VvZGVzeSBhbmQgR2VvcGh5c2ljcyxcblx0Ly8gc2VlIGh0dHA6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuXHRSOiA2MzcxMDAwLFxuXG5cdC8vIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBwb2ludHMgdXNpbmcgc3BoZXJpY2FsIGxhdyBvZiBjb3NpbmVzIGFwcHJveGltYXRpb25cblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG5cdFx0dmFyIHJhZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0ICAgIGxhdDEgPSBsYXRsbmcxLmxhdCAqIHJhZCxcblx0XHQgICAgbGF0MiA9IGxhdGxuZzIubGF0ICogcmFkLFxuXHRcdCAgICBzaW5ETGF0ID0gTWF0aC5zaW4oKGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQpICogcmFkIC8gMiksXG5cdFx0ICAgIHNpbkRMb24gPSBNYXRoLnNpbigobGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZykgKiByYWQgLyAyKSxcblx0XHQgICAgYSA9IHNpbkRMYXQgKiBzaW5ETGF0ICsgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIHNpbkRMb24gKiBzaW5ETG9uLFxuXHRcdCAgICBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcblx0XHRyZXR1cm4gdGhpcy5SICogYztcblx0fVxufSk7XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3JcclxuICpcclxuICogU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IGNvbW1vbiBwcm9qZWN0aW9uIGZvciBvbmxpbmUgbWFwcyxcclxuICogdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWwgdGlsZSBwcm92aWRlcnMuIEFzc3VtZXMgdGhhdCBFYXJ0aCBpc1xyXG4gKiBhIHNwaGVyZS4gVXNlZCBieSB0aGUgYEVQU0c6Mzg1N2AgQ1JTLlxyXG4gKi9cclxuXHJcbnZhciBlYXJ0aFJhZGl1cyA9IDYzNzgxMzc7XHJcblxyXG52YXIgU3BoZXJpY2FsTWVyY2F0b3IgPSB7XHJcblxyXG5cdFI6IGVhcnRoUmFkaXVzLFxyXG5cdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG5cdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG5cdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHRcdHRoaXMuUiAqIGxhdGxuZy5sbmcgKiBkLFxyXG5cdFx0XHR0aGlzLlIgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gMik7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuXHRcdFx0KDIgKiBNYXRoLmF0YW4oTWF0aC5leHAocG9pbnQueSAvIHRoaXMuUikpIC0gKE1hdGguUEkgLyAyKSkgKiBkLFxyXG5cdFx0XHRwb2ludC54ICogZCAvIHRoaXMuUik7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGQgPSBlYXJ0aFJhZGl1cyAqIE1hdGguUEk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhbLWQsIC1kXSwgW2QsIGRdKTtcclxuXHR9KSgpXHJcbn07XG5cbi8qXHJcbiAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblxyXG4gKiBAYWthIEwuVHJhbnNmb3JtYXRpb25cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb246IGEgc2V0IG9mIGNvZWZmaWNpZW50cyBgYWAsIGBiYCwgYGNgLCBgZGBcclxuICogZm9yIHRyYW5zZm9ybWluZyBhIHBvaW50IG9mIGEgZm9ybSBgKHgsIHkpYCBpbnRvIGAoYSp4ICsgYiwgYyp5ICsgZClgIGFuZCBkb2luZ1xyXG4gKiB0aGUgcmV2ZXJzZS4gVXNlZCBieSBMZWFmbGV0IGluIGl0cyBwcm9qZWN0aW9ucyBjb2RlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdHJhbnNmb3JtYXRpb24gPSBMLnRyYW5zZm9ybWF0aW9uKDIsIDUsIC0xLCAxMCksXHJcbiAqIFx0cCA9IEwucG9pbnQoMSwgMiksXHJcbiAqIFx0cDIgPSB0cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0ocCksIC8vICBMLnBvaW50KDcsIDgpXHJcbiAqIFx0cDMgPSB0cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwMik7IC8vICBMLnBvaW50KDEsIDIpXHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG4vLyBmYWN0b3J5IG5ldyBMLlRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuLy8gQ3JlYXRlcyBhIGBUcmFuc2Zvcm1hdGlvbmAgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG5cdGlmIChpc0FycmF5KGEpKSB7XHJcblx0XHQvLyB1c2UgYXJyYXkgcHJvcGVydGllc1xyXG5cdFx0dGhpcy5fYSA9IGFbMF07XHJcblx0XHR0aGlzLl9iID0gYVsxXTtcclxuXHRcdHRoaXMuX2MgPSBhWzJdO1xyXG5cdFx0dGhpcy5fZCA9IGFbM107XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cdHRoaXMuX2EgPSBhO1xyXG5cdHRoaXMuX2IgPSBiO1xyXG5cdHRoaXMuX2MgPSBjO1xyXG5cdHRoaXMuX2QgPSBkO1xyXG59XHJcblxyXG5UcmFuc2Zvcm1hdGlvbi5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCB0cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIHRyYW5zZm9ybWVkIHBvaW50LCBvcHRpb25hbGx5IG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIHNjYWxlLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHsgLy8gKFBvaW50LCBOdW1iZXIpIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHBvaW50LmNsb25lKCksIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXN0cnVjdGl2ZSB0cmFuc2Zvcm0gKGZhc3RlcilcclxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRwb2ludC54ID0gc2NhbGUgKiAodGhpcy5fYSAqIHBvaW50LnggKyB0aGlzLl9iKTtcclxuXHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW50cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmV2ZXJzZSB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQsIG9wdGlvbmFsbHkgZGl2aWRlZFxyXG5cdC8vIGJ5IHRoZSBnaXZlbiBzY2FsZS4gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHVudHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0ICAgICAgICAocG9pbnQueCAvIHNjYWxlIC0gdGhpcy5fYikgLyB0aGlzLl9hLFxyXG5cdFx0ICAgICAgICAocG9pbnQueSAvIHNjYWxlIC0gdGhpcy5fZCkgLyB0aGlzLl9jKTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG5cclxuLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIEluc3RhbnRpYXRlcyBhIFRyYW5zZm9ybWF0aW9uIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihjb2VmZmljaWVudHM6IEFycmF5KTogVHJhbnNmb3JtYXRpb25cclxuLy8gRXhwZWN0cyBhbiBjb2VmZmljaWVudHMgYXJyYXkgb2YgdGhlIGZvcm1cclxuLy8gYFthOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXJdYC5cclxuXHJcbmZ1bmN0aW9uIHRvVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG5cdHJldHVybiBuZXcgVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCk7XHJcbn1cblxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHMzg1N1xyXG4gKlxyXG4gKiBUaGUgbW9zdCBjb21tb24gQ1JTIGZvciBvbmxpbmUgbWFwcywgdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWxcclxuICogdGlsZSBwcm92aWRlcnMuIFVzZXMgU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uIFNldCBpbiBieSBkZWZhdWx0IGluXHJcbiAqIE1hcCdzIGBjcnNgIG9wdGlvbi5cclxuICovXHJcblxyXG52YXIgRVBTRzM4NTcgPSBleHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6Mzg1NycsXHJcblx0cHJvamVjdGlvbjogU3BoZXJpY2FsTWVyY2F0b3IsXHJcblxyXG5cdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBTcGhlcmljYWxNZXJjYXRvci5SKTtcclxuXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG5cclxudmFyIEVQU0c5MDA5MTMgPSBleHRlbmQoe30sIEVQU0czODU3LCB7XHJcblx0Y29kZTogJ0VQU0c6OTAwOTEzJ1xyXG59KTtcblxuLy8gQG5hbWVzcGFjZSBTVkc7IEBzZWN0aW9uXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuU1ZHOlxuXG4vLyBAZnVuY3Rpb24gY3JlYXRlKG5hbWU6IFN0cmluZyk6IFNWR0VsZW1lbnRcbi8vIFJldHVybnMgYSBpbnN0YW5jZSBvZiBbU1ZHRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpLFxuLy8gY29ycmVzcG9uZGluZyB0byB0aGUgY2xhc3MgbmFtZSBwYXNzZWQuIEZvciBleGFtcGxlLCB1c2luZyAnbGluZScgd2lsbCByZXR1cm5cbi8vIGFuIGluc3RhbmNlIG9mIFtTVkdMaW5lRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0xpbmVFbGVtZW50KS5cbmZ1bmN0aW9uIHN2Z0NyZWF0ZShuYW1lKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5cbi8vIEBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3M6IFBvaW50W10sIGNsb3NlZDogQm9vbGVhbik6IFN0cmluZ1xuLy8gR2VuZXJhdGVzIGEgU1ZHIHBhdGggc3RyaW5nIGZvciBtdWx0aXBsZSByaW5ncywgd2l0aCBlYWNoIHJpbmcgdHVybmluZ1xuLy8gaW50byBcIk0uLkwuLkwuLlwiIGluc3RydWN0aW9uc1xuZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzLCBjbG9zZWQpIHtcblx0dmFyIHN0ciA9ICcnLFxuXHRpLCBqLCBsZW4sIGxlbjIsIHBvaW50cywgcDtcblxuXHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHBvaW50cyA9IHJpbmdzW2ldO1xuXG5cdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdHAgPSBwb2ludHNbal07XG5cdFx0XHRzdHIgKz0gKGogPyAnTCcgOiAnTScpICsgcC54ICsgJyAnICsgcC55O1xuXHRcdH1cblxuXHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcblx0XHRzdHIgKz0gY2xvc2VkID8gKHN2ZyA/ICd6JyA6ICd4JykgOiAnJztcblx0fVxuXG5cdC8vIFNWRyBjb21wbGFpbnMgYWJvdXQgZW1wdHkgcGF0aCBzdHJpbmdzXG5cdHJldHVybiBzdHIgfHwgJ00wIDAnO1xufVxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIEJyb3dzZXJcclxuICogQGFrYSBMLkJyb3dzZXJcclxuICpcclxuICogQSBuYW1lc3BhY2Ugd2l0aCBzdGF0aWMgcHJvcGVydGllcyBmb3IgYnJvd3Nlci9mZWF0dXJlIGRldGVjdGlvbiB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogaWYgKEwuQnJvd3Nlci5pZWx0OSkge1xyXG4gKiAgIGFsZXJ0KCdVcGdyYWRlIHlvdXIgYnJvd3NlciwgZHVkZSEnKTtcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgc3R5bGUkMSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBpZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgKG5vdCBFZGdlKS5cclxudmFyIGllID0gJ0FjdGl2ZVhPYmplY3QnIGluIHdpbmRvdztcclxuXHJcbi8vIEBwcm9wZXJ0eSBpZWx0OTogQm9vbGVhbjsgYHRydWVgIGZvciBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBsZXNzIHRoYW4gOS5cclxudmFyIGllbHQ5ID0gaWUgJiYgIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI7XHJcblxyXG4vLyBAcHJvcGVydHkgZWRnZTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgRWRnZSB3ZWIgYnJvd3Nlci5cclxudmFyIGVkZ2UgPSAnbXNMYXVuY2hVcmknIGluIG5hdmlnYXRvciAmJiAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3ZWJraXQ6IEJvb2xlYW47XHJcbi8vIGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIGxpa2UgQ2hyb21lIGFuZCBTYWZhcmkgKGluY2x1ZGluZyBtb2JpbGUgdmVyc2lvbnMpLlxyXG52YXIgd2Via2l0ID0gdXNlckFnZW50Q29udGFpbnMoJ3dlYmtpdCcpO1xyXG5cclxuLy8gQHByb3BlcnR5IGFuZHJvaWQ6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbnkgYnJvd3NlciBydW5uaW5nIG9uIGFuIEFuZHJvaWQgcGxhdGZvcm0uXHJcbnZhciBhbmRyb2lkID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkMjM6IEJvb2xlYW47IGB0cnVlYCBmb3IgYnJvd3NlcnMgcnVubmluZyBvbiBBbmRyb2lkIDIgb3IgQW5kcm9pZCAzLlxyXG52YXIgYW5kcm9pZDIzID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQgMicpIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDMnKTtcclxuXHJcbi8qIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTc5NjEyNjYgZm9yIGRldGFpbHMgb24gZGV0ZWN0aW5nIHN0b2NrIEFuZHJvaWQgKi9cclxudmFyIHdlYmtpdFZlciA9IHBhcnNlSW50KC9XZWJLaXRcXC8oWzAtOV0rKXwkLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpWzFdLCAxMCk7IC8vIGFsc28gbWF0Y2hlcyBBcHBsZVdlYktpdFxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZFN0b2NrOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBBbmRyb2lkIHN0b2NrIGJyb3dzZXIgKGkuZS4gbm90IENocm9tZSlcclxudmFyIGFuZHJvaWRTdG9jayA9IGFuZHJvaWQgJiYgdXNlckFnZW50Q29udGFpbnMoJ0dvb2dsZScpICYmIHdlYmtpdFZlciA8IDUzNyAmJiAhKCdBdWRpb05vZGUnIGluIHdpbmRvdyk7XHJcblxyXG4vLyBAcHJvcGVydHkgb3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXJcclxudmFyIG9wZXJhID0gISF3aW5kb3cub3BlcmE7XHJcblxyXG4vLyBAcHJvcGVydHkgY2hyb21lOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBDaHJvbWUgYnJvd3Nlci5cclxudmFyIGNocm9tZSA9IHVzZXJBZ2VudENvbnRhaW5zKCdjaHJvbWUnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBnZWNrbzogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBsaWtlIEZpcmVmb3guXHJcbnZhciBnZWNrbyA9IHVzZXJBZ2VudENvbnRhaW5zKCdnZWNrbycpICYmICF3ZWJraXQgJiYgIW9wZXJhICYmICFpZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBzYWZhcmk6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIFNhZmFyaSBicm93c2VyLlxyXG52YXIgc2FmYXJpID0gIWNocm9tZSAmJiB1c2VyQWdlbnRDb250YWlucygnc2FmYXJpJyk7XHJcblxyXG52YXIgcGhhbnRvbSA9IHVzZXJBZ2VudENvbnRhaW5zKCdwaGFudG9tJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgb3BlcmExMjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMgKHZlcnNpb24gMTIgb3IgbGF0ZXIpLlxyXG52YXIgb3BlcmExMiA9ICdPVHJhbnNpdGlvbicgaW4gc3R5bGUkMTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3aW46IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBXaW5kb3dzIHBsYXRmb3JtXHJcbnZhciB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDA7XHJcblxyXG4vLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIGllM2QgPSBpZSAmJiAoJ3RyYW5zaXRpb24nIGluIHN0eWxlJDEpO1xyXG5cclxuLy8gQHByb3BlcnR5IHdlYmtpdDNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMztcclxuXHJcbi8vIEBwcm9wZXJ0eSBnZWNrbzNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbnZhciBnZWNrbzNkID0gJ01velBlcnNwZWN0aXZlJyBpbiBzdHlsZSQxO1xyXG5cclxuLy8gQHByb3BlcnR5IGFueTNkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbnZhciBhbnkzZCA9ICF3aW5kb3cuTF9ESVNBQkxFXzNEICYmIChpZTNkIHx8IHdlYmtpdDNkIHx8IGdlY2tvM2QpICYmICFvcGVyYTEyICYmICFwaGFudG9tO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbnZhciBtb2JpbGUgPSB0eXBlb2Ygb3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdtb2JpbGUnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQ6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbnZhciBtb2JpbGVXZWJraXQgPSBtb2JpbGUgJiYgd2Via2l0O1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDNkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2Ugc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIG1vYmlsZVdlYmtpdDNkID0gbW9iaWxlICYmIHdlYmtpdDNkO1xyXG5cclxuLy8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIGltcGxlbWVudGluZyB0aGUgTWljcm9zb2Z0IHRvdWNoIGV2ZW50cyBtb2RlbCAobm90YWJseSBJRTEwKS5cclxudmFyIG1zUG9pbnRlciA9ICF3aW5kb3cuUG9pbnRlckV2ZW50ICYmIHdpbmRvdy5NU1BvaW50ZXJFdmVudDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBwb2ludGVyOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3BvaW50ZXIgZXZlbnRzXShodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RuNDMzMjQ0JTI4dj12cy44NSUyOS5hc3B4KS5cclxudmFyIHBvaW50ZXIgPSAhd2Via2l0ICYmICEhKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgbXNQb2ludGVyKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB0b3VjaDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG4vLyBUaGlzIGRvZXMgbm90IG5lY2Vzc2FyaWx5IG1lYW4gdGhhdCB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgY29tcHV0ZXIgd2l0aFxyXG4vLyBhIHRvdWNoc2NyZWVuLCBpdCBvbmx5IG1lYW5zIHRoYXQgdGhlIGJyb3dzZXIgaXMgY2FwYWJsZSBvZiB1bmRlcnN0YW5kaW5nXHJcbi8vIHRvdWNoIGV2ZW50cy5cclxudmFyIHRvdWNoID0gIXdpbmRvdy5MX05PX1RPVUNIICYmIChwb2ludGVyIHx8ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fFxyXG5cdFx0KHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVPcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbnZhciBtb2JpbGVPcGVyYSA9IG1vYmlsZSAmJiBvcGVyYTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVHZWNrbzogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG52YXIgbW9iaWxlR2Vja28gPSBtb2JpbGUgJiYgZ2Vja287XHJcblxyXG4vLyBAcHJvcGVydHkgcmV0aW5hOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgb24gYSBoaWdoLXJlc29sdXRpb24gXCJyZXRpbmFcIiBzY3JlZW4gb3Igb24gYW55IHNjcmVlbiB3aGVuIGJyb3dzZXIncyBkaXNwbGF5IHpvb20gaXMgbW9yZSB0aGFuIDEwMCUuXHJcbnZhciByZXRpbmEgPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgKHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSAvIHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkpKSA+IDE7XHJcblxyXG4vLyBAcHJvcGVydHkgcGFzc2l2ZUV2ZW50czogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBwYXNzaXZlIGV2ZW50cy5cclxudmFyIHBhc3NpdmVFdmVudHMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciBzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSBmYWxzZTtcclxuXHR0cnkge1xyXG5cdFx0dmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIGZhbHNlRm4sIG9wdHMpO1xyXG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlRXZlbnRTdXBwb3J0JywgZmFsc2VGbiwgb3B0cyk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0Ly8gRXJyb3JzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBzaW5jZSB0aGlzIGlzIG9ubHkgYSBicm93c2VyIHN1cHBvcnQgdGVzdC5cclxuXHR9XHJcblx0cmV0dXJuIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbjtcclxufSk7XHJcblxyXG4vLyBAcHJvcGVydHkgY2FudmFzOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXHJcbnZhciBjYW52YXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXHJcbnZhciBzdmcgPSAhIShkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgc3ZnQ3JlYXRlKCdzdmcnKS5jcmVhdGVTVkdSZWN0KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB2bWw6IEJvb2xlYW5cclxuLy8gYHRydWVgIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLlxyXG52YXIgdm1sID0gIXN2ZyAmJiAoZnVuY3Rpb24gKCkge1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRkaXYuaW5uZXJIVE1MID0gJzx2OnNoYXBlIGFkaj1cIjFcIi8+JztcclxuXHJcblx0XHR2YXIgc2hhcGUgPSBkaXYuZmlyc3RDaGlsZDtcclxuXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcclxuXHJcblx0XHRyZXR1cm4gc2hhcGUgJiYgKHR5cGVvZiBzaGFwZS5hZGogPT09ICdvYmplY3QnKTtcclxuXHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufSgpKTtcclxuXHJcblxyXG5mdW5jdGlvbiB1c2VyQWdlbnRDb250YWlucyhzdHIpIHtcclxuXHRyZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyKSA+PSAwO1xyXG59XHJcblxuXG52YXIgQnJvd3NlciA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRpZTogaWUsXG5cdGllbHQ5OiBpZWx0OSxcblx0ZWRnZTogZWRnZSxcblx0d2Via2l0OiB3ZWJraXQsXG5cdGFuZHJvaWQ6IGFuZHJvaWQsXG5cdGFuZHJvaWQyMzogYW5kcm9pZDIzLFxuXHRhbmRyb2lkU3RvY2s6IGFuZHJvaWRTdG9jayxcblx0b3BlcmE6IG9wZXJhLFxuXHRjaHJvbWU6IGNocm9tZSxcblx0Z2Vja286IGdlY2tvLFxuXHRzYWZhcmk6IHNhZmFyaSxcblx0cGhhbnRvbTogcGhhbnRvbSxcblx0b3BlcmExMjogb3BlcmExMixcblx0d2luOiB3aW4sXG5cdGllM2Q6IGllM2QsXG5cdHdlYmtpdDNkOiB3ZWJraXQzZCxcblx0Z2Vja28zZDogZ2Vja28zZCxcblx0YW55M2Q6IGFueTNkLFxuXHRtb2JpbGU6IG1vYmlsZSxcblx0bW9iaWxlV2Via2l0OiBtb2JpbGVXZWJraXQsXG5cdG1vYmlsZVdlYmtpdDNkOiBtb2JpbGVXZWJraXQzZCxcblx0bXNQb2ludGVyOiBtc1BvaW50ZXIsXG5cdHBvaW50ZXI6IHBvaW50ZXIsXG5cdHRvdWNoOiB0b3VjaCxcblx0bW9iaWxlT3BlcmE6IG1vYmlsZU9wZXJhLFxuXHRtb2JpbGVHZWNrbzogbW9iaWxlR2Vja28sXG5cdHJldGluYTogcmV0aW5hLFxuXHRwYXNzaXZlRXZlbnRzOiBwYXNzaXZlRXZlbnRzLFxuXHRjYW52YXM6IGNhbnZhcyxcblx0c3ZnOiBzdmcsXG5cdHZtbDogdm1sXG59KTtcblxuLypcbiAqIEV4dGVuZHMgTC5Eb21FdmVudCB0byBwcm92aWRlIHRvdWNoIHN1cHBvcnQgZm9yIEludGVybmV0IEV4cGxvcmVyIGFuZCBXaW5kb3dzLWJhc2VkIGRldmljZXMuXG4gKi9cblxuXG52YXIgUE9JTlRFUl9ET1dOID0gICBtc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgICA6ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9NT1ZFID0gICBtc1BvaW50ZXIgPyAnTVNQb2ludGVyTW92ZScgICA6ICdwb2ludGVybW92ZSc7XG52YXIgUE9JTlRFUl9VUCA9ICAgICBtc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnICAgICA6ICdwb2ludGVydXAnO1xudmFyIFBPSU5URVJfQ0FOQ0VMID0gbXNQb2ludGVyID8gJ01TUG9pbnRlckNhbmNlbCcgOiAncG9pbnRlcmNhbmNlbCc7XG52YXIgVEFHX1dISVRFX0xJU1QgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdPUFRJT04nXTtcblxudmFyIF9wb2ludGVycyA9IHt9O1xudmFyIF9wb2ludGVyRG9jTGlzdGVuZXIgPSBmYWxzZTtcblxuLy8gRG9tRXZlbnQuRG91YmxlVGFwIG5lZWRzIHRvIGtub3cgYWJvdXQgdGhpc1xudmFyIF9wb2ludGVyc0NvdW50ID0gMDtcblxuLy8gUHJvdmlkZXMgYSB0b3VjaCBldmVudHMgd3JhcHBlciBmb3IgKG1zKXBvaW50ZXIgZXZlbnRzLlxuLy8gcmVmIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvIGh0dHBzOi8vd3d3LnczLm9yZy9CdWdzL1B1YmxpYy9zaG93X2J1Zy5jZ2k/aWQ9MjI4OTBcblxuZnVuY3Rpb24gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpIHtcblx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdF9hZGRQb2ludGVyU3RhcnQob2JqLCBoYW5kbGVyLCBpZCk7XG5cblx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuXHRcdF9hZGRQb2ludGVyTW92ZShvYmosIGhhbmRsZXIsIGlkKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRfYWRkUG9pbnRlckVuZChvYmosIGhhbmRsZXIsIGlkKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiByZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCkge1xuXHR2YXIgaGFuZGxlciA9IG9ialsnX2xlYWZsZXRfJyArIHR5cGUgKyBpZF07XG5cblx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIGhhbmRsZXIsIGZhbHNlKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIGhhbmRsZXIsIGZhbHNlKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlclN0YXJ0KG9iaiwgaGFuZGxlciwgaWQpIHtcblx0dmFyIG9uRG93biA9IGJpbmQoZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJyAmJiBlLk1TUE9JTlRFUl9UWVBFX01PVVNFICYmIGUucG9pbnRlclR5cGUgIT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UpIHtcblx0XHRcdC8vIEluIElFMTEsIHNvbWUgdG91Y2ggZXZlbnRzIG5lZWRzIHRvIGZpcmUgZm9yIGZvcm0gY29udHJvbHMsIG9yXG5cdFx0XHQvLyB0aGUgY29udHJvbHMgd2lsbCBzdG9wIHdvcmtpbmcuIFdlIGtlZXAgYSB3aGl0ZWxpc3Qgb2YgdGFnIG5hbWVzIHRoYXRcblx0XHRcdC8vIG5lZWQgdGhlc2UgZXZlbnRzLiBGb3Igb3RoZXIgdGFyZ2V0IHRhZ3MsIHdlIHByZXZlbnQgZGVmYXVsdCBvbiB0aGUgZXZlbnQuXG5cdFx0XHRpZiAoVEFHX1dISVRFX0xJU1QuaW5kZXhPZihlLnRhcmdldC50YWdOYW1lKSA8IDApIHtcblx0XHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdH0pO1xuXG5cdG9ialsnX2xlYWZsZXRfdG91Y2hzdGFydCcgKyBpZF0gPSBvbkRvd247XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgb25Eb3duLCBmYWxzZSk7XG5cblx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG5cdGlmICghX3BvaW50ZXJEb2NMaXN0ZW5lcikge1xuXHRcdC8vIHdlIGxpc3RlbiBkb2N1bWVudEVsZW1lbnQgYXMgYW55IGRyYWdzIHRoYXQgZW5kIGJ5IG1vdmluZyB0aGUgdG91Y2ggb2ZmIHRoZSBzY3JlZW4gZ2V0IGZpcmVkIHRoZXJlXG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBfZ2xvYmFsUG9pbnRlckRvd24sIHRydWUpO1xuXHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgX2dsb2JhbFBvaW50ZXJNb3ZlLCB0cnVlKTtcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0NBTkNFTCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG5cblx0XHRfcG9pbnRlckRvY0xpc3RlbmVyID0gdHJ1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlckRvd24oZSkge1xuXHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0X3BvaW50ZXJzQ291bnQrKztcbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJNb3ZlKGUpIHtcblx0aWYgKF9wb2ludGVyc1tlLnBvaW50ZXJJZF0pIHtcblx0XHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0fVxufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlclVwKGUpIHtcblx0ZGVsZXRlIF9wb2ludGVyc1tlLnBvaW50ZXJJZF07XG5cdF9wb2ludGVyc0NvdW50LS07XG59XG5cbmZ1bmN0aW9uIF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpIHtcblx0ZS50b3VjaGVzID0gW107XG5cdGZvciAodmFyIGkgaW4gX3BvaW50ZXJzKSB7XG5cdFx0ZS50b3VjaGVzLnB1c2goX3BvaW50ZXJzW2ldKTtcblx0fVxuXHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG5cdGhhbmRsZXIoZSk7XG59XG5cbmZ1bmN0aW9uIF9hZGRQb2ludGVyTW92ZShvYmosIGhhbmRsZXIsIGlkKSB7XG5cdHZhciBvbk1vdmUgPSBmdW5jdGlvbiAoZSkge1xuXHRcdC8vIGRvbid0IGZpcmUgdG91Y2ggbW92ZXMgd2hlbiBtb3VzZSBpc24ndCBkb3duXG5cdFx0aWYgKChlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpICYmIGUuYnV0dG9ucyA9PT0gMCkgeyByZXR1cm47IH1cblxuXHRcdF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuXHR9O1xuXG5cdG9ialsnX2xlYWZsZXRfdG91Y2htb3ZlJyArIGlkXSA9IG9uTW92ZTtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBvbk1vdmUsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJFbmQob2JqLCBoYW5kbGVyLCBpZCkge1xuXHR2YXIgb25VcCA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdH07XG5cblx0b2JqWydfbGVhZmxldF90b3VjaGVuZCcgKyBpZF0gPSBvblVwO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBvblVwLCBmYWxzZSk7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBvblVwLCBmYWxzZSk7XG59XG5cbi8qXHJcbiAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICovXHJcblxyXG52YXIgX3RvdWNoc3RhcnQgPSBtc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgOiBwb2ludGVyID8gJ3BvaW50ZXJkb3duJyA6ICd0b3VjaHN0YXJ0JztcclxudmFyIF90b3VjaGVuZCA9IG1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgOiBwb2ludGVyID8gJ3BvaW50ZXJ1cCcgOiAndG91Y2hlbmQnO1xyXG52YXIgX3ByZSA9ICdfbGVhZmxldF8nO1xyXG5cclxuLy8gaW5zcGlyZWQgYnkgWmVwdG8gdG91Y2ggY29kZSBieSBUaG9tYXMgRnVjaHNcclxuZnVuY3Rpb24gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyLCBpZCkge1xyXG5cdHZhciBsYXN0LCB0b3VjaCQkMSxcclxuXHQgICAgZG91YmxlVGFwID0gZmFsc2UsXHJcblx0ICAgIGRlbGF5ID0gMjUwO1xyXG5cclxuXHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xyXG5cdFx0dmFyIGNvdW50O1xyXG5cclxuXHRcdGlmIChwb2ludGVyKSB7XHJcblx0XHRcdGlmICgoIWVkZ2UpIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHsgcmV0dXJuOyB9XHJcblx0XHRcdGNvdW50ID0gX3BvaW50ZXJzQ291bnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb3VudCA9IGUudG91Y2hlcy5sZW5ndGg7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvdW50ID4gMSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSxcclxuXHRcdCAgICBkZWx0YSA9IG5vdyAtIChsYXN0IHx8IG5vdyk7XHJcblxyXG5cdFx0dG91Y2gkJDEgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xyXG5cdFx0ZG91YmxlVGFwID0gKGRlbHRhID4gMCAmJiBkZWx0YSA8PSBkZWxheSk7XHJcblx0XHRsYXN0ID0gbm93O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XHJcblx0XHRpZiAoZG91YmxlVGFwICYmICF0b3VjaCQkMS5jYW5jZWxCdWJibGUpIHtcclxuXHRcdFx0aWYgKHBvaW50ZXIpIHtcclxuXHRcdFx0XHRpZiAoKCFlZGdlKSB8fCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7IHJldHVybjsgfVxyXG5cdFx0XHRcdC8vIHdvcmsgYXJvdW5kIC50eXBlIGJlaW5nIHJlYWRvbmx5IHdpdGggTVNQb2ludGVyKiBldmVudHNcclxuXHRcdFx0XHR2YXIgbmV3VG91Y2ggPSB7fSxcclxuXHRcdFx0XHQgICAgcHJvcCwgaTtcclxuXHJcblx0XHRcdFx0Zm9yIChpIGluIHRvdWNoJCQxKSB7XHJcblx0XHRcdFx0XHRwcm9wID0gdG91Y2gkJDFbaV07XHJcblx0XHRcdFx0XHRuZXdUb3VjaFtpXSA9IHByb3AgJiYgcHJvcC5iaW5kID8gcHJvcC5iaW5kKHRvdWNoJCQxKSA6IHByb3A7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRvdWNoJCQxID0gbmV3VG91Y2g7XHJcblx0XHRcdH1cclxuXHRcdFx0dG91Y2gkJDEudHlwZSA9ICdkYmxjbGljayc7XHJcblx0XHRcdHRvdWNoJCQxLmJ1dHRvbiA9IDA7XHJcblx0XHRcdGhhbmRsZXIodG91Y2gkJDEpO1xyXG5cdFx0XHRsYXN0ID0gbnVsbDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdG9ialtfcHJlICsgX3RvdWNoc3RhcnQgKyBpZF0gPSBvblRvdWNoU3RhcnQ7XHJcblx0b2JqW19wcmUgKyBfdG91Y2hlbmQgKyBpZF0gPSBvblRvdWNoRW5kO1xyXG5cdG9ialtfcHJlICsgJ2RibGNsaWNrJyArIGlkXSA9IGhhbmRsZXI7XHJcblxyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKF90b3VjaHN0YXJ0LCBvblRvdWNoU3RhcnQsIHBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKF90b3VjaGVuZCwgb25Ub3VjaEVuZCwgcGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblxyXG5cdC8vIE9uIHNvbWUgcGxhdGZvcm1zIChub3RhYmx5LCBjaHJvbWU8NTUgb24gd2luMTAgKyB0b3VjaHNjcmVlbiArIG1vdXNlKSxcclxuXHQvLyB0aGUgYnJvd3NlciBkb2Vzbid0IGZpcmUgdG91Y2hlbmQvcG9pbnRlcnVwIGV2ZW50cyBidXQgZG9lcyBmaXJlXHJcblx0Ly8gbmF0aXZlIGRibGNsaWNrcy4gU2VlICM0MTI3LlxyXG5cdC8vIEVkZ2UgMTQgYWxzbyBmaXJlcyBuYXRpdmUgZGJsY2xpY2tzLCBidXQgb25seSBmb3IgcG9pbnRlclR5cGUgbW91c2UsIHNlZSAjNTE4MC5cclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKSB7XHJcblx0dmFyIHRvdWNoc3RhcnQgPSBvYmpbX3ByZSArIF90b3VjaHN0YXJ0ICsgaWRdLFxyXG5cdCAgICB0b3VjaGVuZCA9IG9ialtfcHJlICsgX3RvdWNoZW5kICsgaWRdLFxyXG5cdCAgICBkYmxjbGljayA9IG9ialtfcHJlICsgJ2RibGNsaWNrJyArIGlkXTtcclxuXHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3RvdWNoc3RhcnQsIHRvdWNoc3RhcnQsIHBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKF90b3VjaGVuZCwgdG91Y2hlbmQsIHBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cdGlmICghZWRnZSkge1xyXG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZGJsY2xpY2ssIGZhbHNlKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tVXRpbFxyXG4gKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Eb2N1bWVudF9PYmplY3RfTW9kZWwpXHJcbiAqIHRyZWUsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBNb3N0IGZ1bmN0aW9ucyBleHBlY3Rpbmcgb3IgcmV0dXJuaW5nIGEgYEhUTUxFbGVtZW50YCBhbHNvIHdvcmsgZm9yXHJcbiAqIFNWRyBlbGVtZW50cy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGNsYXNzZXMgcmVmZXIgdG8gQ1NTIGNsYXNzZXNcclxuICogaW4gSFRNTCBhbmQgU1ZHIGNsYXNzZXMgaW4gU1ZHLlxyXG4gKi9cclxuXHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNGT1JNOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zZm9ybSBzdHlsZSBuYW1lIChlLmcuIGAnd2Via2l0VHJhbnNmb3JtJ2AgZm9yIFdlYktpdCkuXHJcbnZhciBUUkFOU0ZPUk0gPSB0ZXN0UHJvcChcclxuXHRbJ3RyYW5zZm9ybScsICd3ZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXSk7XHJcblxyXG4vLyB3ZWJraXRUcmFuc2l0aW9uIGNvbWVzIGZpcnN0IGJlY2F1c2Ugc29tZSBicm93c2VyIHZlcnNpb25zIHRoYXQgZHJvcCB2ZW5kb3IgcHJlZml4IGRvbid0IGRvXHJcbi8vIHRoZSBzYW1lIGZvciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgaW4gcGFydGljdWxhciB0aGUgQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT046IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbiBzdHlsZSBuYW1lLlxyXG52YXIgVFJBTlNJVElPTiA9IHRlc3RQcm9wKFxyXG5cdFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT05fRU5EOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZS5cclxudmFyIFRSQU5TSVRJT05fRU5EID1cclxuXHRUUkFOU0lUSU9OID09PSAnd2Via2l0VHJhbnNpdGlvbicgfHwgVFJBTlNJVElPTiA9PT0gJ09UcmFuc2l0aW9uJyA/IFRSQU5TSVRJT04gKyAnRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0KGlkOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBSZXR1cm5zIGFuIGVsZW1lbnQgZ2l2ZW4gaXRzIERPTSBpZCwgb3IgcmV0dXJucyB0aGUgZWxlbWVudCBpdHNlbGZcclxuLy8gaWYgaXQgd2FzIHBhc3NlZCBkaXJlY3RseS5cclxuZnVuY3Rpb24gZ2V0KGlkKSB7XHJcblx0cmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgc3R5bGVBdHRyaWI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgYSBjZXJ0YWluIHN0eWxlIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxyXG4vLyBpbmNsdWRpbmcgY29tcHV0ZWQgdmFsdWVzIG9yIHZhbHVlcyBzZXQgdGhyb3VnaCBDU1MuXHJcbmZ1bmN0aW9uIGdldFN0eWxlKGVsLCBzdHlsZSkge1xyXG5cdHZhciB2YWx1ZSA9IGVsLnN0eWxlW3N0eWxlXSB8fCAoZWwuY3VycmVudFN0eWxlICYmIGVsLmN1cnJlbnRTdHlsZVtzdHlsZV0pO1xyXG5cclxuXHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xyXG5cdFx0dmFyIGNzcyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xyXG5cdFx0dmFsdWUgPSBjc3MgPyBjc3Nbc3R5bGVdIDogbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZTogU3RyaW5nLCBjbGFzc05hbWU/OiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gQ3JlYXRlcyBhbiBIVE1MIGVsZW1lbnQgd2l0aCBgdGFnTmFtZWAsIHNldHMgaXRzIGNsYXNzIHRvIGBjbGFzc05hbWVgLCBhbmQgb3B0aW9uYWxseSBhcHBlbmRzIGl0IHRvIGBjb250YWluZXJgIGVsZW1lbnQuXHJcbmZ1bmN0aW9uIGNyZWF0ZSQxKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuXHRlbC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XHJcblxyXG5cdGlmIChjb250YWluZXIpIHtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcblx0fVxyXG5cdHJldHVybiBlbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIFJlbW92ZXMgYGVsYCBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudFxyXG5mdW5jdGlvbiByZW1vdmUoZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50KSB7XHJcblx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGVtcHR5KGVsOiBIVE1MRWxlbWVudClcclxuLy8gUmVtb3ZlcyBhbGwgb2YgYGVsYCdzIGNoaWxkcmVuIGVsZW1lbnRzIGZyb20gYGVsYFxyXG5mdW5jdGlvbiBlbXB0eShlbCkge1xyXG5cdHdoaWxlIChlbC5maXJzdENoaWxkKSB7XHJcblx0XHRlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0b0Zyb250KGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgYGVsYCB0aGUgbGFzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGluIGZyb250IG9mIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuZnVuY3Rpb24gdG9Gcm9udChlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQgJiYgcGFyZW50Lmxhc3RDaGlsZCAhPT0gZWwpIHtcclxuXHRcdHBhcmVudC5hcHBlbmRDaGlsZChlbCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdG9CYWNrKGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgYGVsYCB0aGUgZmlyc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBiZWhpbmQgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5mdW5jdGlvbiB0b0JhY2soZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50ICYmIHBhcmVudC5maXJzdENoaWxkICE9PSBlbCkge1xyXG5cdFx0cGFyZW50Lmluc2VydEJlZm9yZShlbCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGhhc0NsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZSBjb250YWlucyBgbmFtZWAuXHJcbmZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xyXG5cdH1cclxuXHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG5cdHJldHVybiBjbGFzc05hbWUubGVuZ3RoID4gMCAmJiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgbmFtZSArICcoXFxcXHN8JCknKS50ZXN0KGNsYXNzTmFtZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gQWRkcyBgbmFtZWAgdG8gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbmZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR2YXIgY2xhc3NlcyA9IHNwbGl0V29yZHMobmFtZSk7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsLCBuYW1lKSkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuXHRcdHNldENsYXNzKGVsLCAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgJyAnIDogJycpICsgbmFtZSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIFJlbW92ZXMgYG5hbWVgIGZyb20gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzZXRDbGFzcyhlbCwgdHJpbSgoJyAnICsgZ2V0Q2xhc3MoZWwpICsgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJykpKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gU2V0cyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5mdW5jdGlvbiBzZXRDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRlbC5jbGFzc05hbWUgPSBuYW1lO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBpbiBjYXNlIG9mIFNWRyBlbGVtZW50XHJcblx0XHRlbC5jbGFzc05hbWUuYmFzZVZhbCA9IG5hbWU7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50KTogU3RyaW5nXHJcbi8vIFJldHVybnMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuZnVuY3Rpb24gZ2V0Q2xhc3MoZWwpIHtcclxuXHQvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkdFbGVtZW50SW5zdGFuY2UgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZ0VsZW1lbnQgaW5zdGVhZFxyXG5cdC8vIChSZXF1aXJlZCBmb3IgbGlua2VkIFNWRyBlbGVtZW50cyBpbiBJRTExLilcclxuXHRpZiAoZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQpIHtcclxuXHRcdGVsID0gZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQ7XHJcblx0fVxyXG5cdHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkID8gZWwuY2xhc3NOYW1lIDogZWwuY2xhc3NOYW1lLmJhc2VWYWw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsOiBIVE1MRWxlbWVudCwgb3BhY2l0eTogTnVtYmVyKVxyXG4vLyBTZXQgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudCAoaW5jbHVkaW5nIG9sZCBJRSBzdXBwb3J0KS5cclxuLy8gYG9wYWNpdHlgIG11c3QgYmUgYSBudW1iZXIgZnJvbSBgMGAgdG8gYDFgLlxyXG5mdW5jdGlvbiBzZXRPcGFjaXR5KGVsLCB2YWx1ZSkge1xyXG5cdGlmICgnb3BhY2l0eScgaW4gZWwuc3R5bGUpIHtcclxuXHRcdGVsLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHR9IGVsc2UgaWYgKCdmaWx0ZXInIGluIGVsLnN0eWxlKSB7XHJcblx0XHRfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSkge1xyXG5cdHZhciBmaWx0ZXIgPSBmYWxzZSxcclxuXHQgICAgZmlsdGVyTmFtZSA9ICdEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYSc7XHJcblxyXG5cdC8vIGZpbHRlcnMgY29sbGVjdGlvbiB0aHJvd3MgYW4gZXJyb3IgaWYgd2UgdHJ5IHRvIHJldHJpZXZlIGEgZmlsdGVyIHRoYXQgZG9lc24ndCBleGlzdFxyXG5cdHRyeSB7XHJcblx0XHRmaWx0ZXIgPSBlbC5maWx0ZXJzLml0ZW0oZmlsdGVyTmFtZSk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0Ly8gZG9uJ3Qgc2V0IG9wYWNpdHkgdG8gMSBpZiB3ZSBoYXZlbid0IGFscmVhZHkgc2V0IGFuIG9wYWNpdHksXHJcblx0XHQvLyBpdCBpc24ndCBuZWVkZWQgYW5kIGJyZWFrcyB0cmFuc3BhcmVudCBwbmdzLlxyXG5cdFx0aWYgKHZhbHVlID09PSAxKSB7IHJldHVybjsgfVxyXG5cdH1cclxuXHJcblx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogMTAwKTtcclxuXHJcblx0aWYgKGZpbHRlcikge1xyXG5cdFx0ZmlsdGVyLkVuYWJsZWQgPSAodmFsdWUgIT09IDEwMCk7XHJcblx0XHRmaWx0ZXIuT3BhY2l0eSA9IHZhbHVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlbC5zdHlsZS5maWx0ZXIgKz0gJyBwcm9naWQ6JyArIGZpbHRlck5hbWUgKyAnKG9wYWNpdHk9JyArIHZhbHVlICsgJyknO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzOiBTdHJpbmdbXSk6IFN0cmluZ3xmYWxzZVxyXG4vLyBHb2VzIHRocm91Z2ggdGhlIGFycmF5IG9mIHN0eWxlIG5hbWVzIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBuYW1lXHJcbi8vIHRoYXQgaXMgYSB2YWxpZCBzdHlsZSBuYW1lIGZvciBhbiBlbGVtZW50LiBJZiBubyBzdWNoIG5hbWUgaXMgZm91bmQsXHJcbi8vIGl0IHJldHVybnMgZmFsc2UuIFVzZWZ1bCBmb3IgdmVuZG9yLXByZWZpeGVkIHN0eWxlcyBsaWtlIGB0cmFuc2Zvcm1gLlxyXG5mdW5jdGlvbiB0ZXN0UHJvcChwcm9wcykge1xyXG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKHByb3BzW2ldIGluIHN0eWxlKSB7XHJcblx0XHRcdHJldHVybiBwcm9wc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsOiBIVE1MRWxlbWVudCwgb2Zmc2V0OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpXHJcbi8vIFJlc2V0cyB0aGUgM0QgQ1NTIHRyYW5zZm9ybSBvZiBgZWxgIHNvIGl0IGlzIHRyYW5zbGF0ZWQgYnkgYG9mZnNldGAgcGl4ZWxzXHJcbi8vIGFuZCBvcHRpb25hbGx5IHNjYWxlZCBieSBgc2NhbGVgLiBEb2VzIG5vdCBoYXZlIGFuIGVmZmVjdCBpZiB0aGVcclxuLy8gYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgM0QgQ1NTIHRyYW5zZm9ybXMuXHJcbmZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbCwgb2Zmc2V0LCBzY2FsZSkge1xyXG5cdHZhciBwb3MgPSBvZmZzZXQgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cclxuXHRlbC5zdHlsZVtUUkFOU0ZPUk1dID1cclxuXHRcdChpZTNkID9cclxuXHRcdFx0J3RyYW5zbGF0ZSgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4KScgOlxyXG5cdFx0XHQndHJhbnNsYXRlM2QoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCwwKScpICtcclxuXHRcdChzY2FsZSA/ICcgc2NhbGUoJyArIHNjYWxlICsgJyknIDogJycpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50LCBwb3NpdGlvbjogUG9pbnQpXHJcbi8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGBlbGAgdG8gY29vcmRpbmF0ZXMgc3BlY2lmaWVkIGJ5IGBwb3NpdGlvbmAsXHJcbi8vIHVzaW5nIENTUyB0cmFuc2xhdGUgb3IgdG9wL2xlZnQgcG9zaXRpb25pbmcgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyXHJcbi8vICh1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBwb3NpdGlvbiBpdHMgbGF5ZXJzKS5cclxuZnVuY3Rpb24gc2V0UG9zaXRpb24oZWwsIHBvaW50KSB7XHJcblxyXG5cdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRlbC5fbGVhZmxldF9wb3MgPSBwb2ludDtcclxuXHQvKiBlc2xpbnQtZW5hYmxlICovXHJcblxyXG5cdGlmIChhbnkzZCkge1xyXG5cdFx0c2V0VHJhbnNmb3JtKGVsLCBwb2ludCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuXHRcdGVsLnN0eWxlLnRvcCA9IHBvaW50LnkgKyAncHgnO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIGFuIGVsZW1lbnQgcHJldmlvdXNseSBwb3NpdGlvbmVkIHdpdGggc2V0UG9zaXRpb24uXHJcbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsKSB7XHJcblx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGZvciBlbGVtZW50cyBwcmV2aW91c2x5IHBvc2l0aW9uZWQgdXNpbmcgc2V0UG9zaXRpb24sXHJcblx0Ly8gc28gaXQncyBzYWZlIHRvIGNhY2hlIHRoZSBwb3NpdGlvbiBmb3IgcGVyZm9ybWFuY2VcclxuXHJcblx0cmV0dXJuIGVsLl9sZWFmbGV0X3BvcyB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbigpXHJcbi8vIFByZXZlbnRzIHRoZSB1c2VyIGZyb20gZ2VuZXJhdGluZyBgc2VsZWN0c3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkXHJcbi8vIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIG1vdXNlIHRocm91Z2ggYSBwYWdlIHdpdGggdGV4dC4gVXNlZCBpbnRlcm5hbGx5XHJcbi8vIGJ5IExlYWZsZXQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW91ciBvZiBhbnkgY2xpY2stYW5kLWRyYWcgaW50ZXJhY3Rpb24gb25cclxuLy8gdGhlIG1hcC4gQWZmZWN0cyBkcmFnIGludGVyYWN0aW9ucyBvbiB0aGUgd2hvbGUgZG9jdW1lbnQuXHJcblxyXG4vLyBAZnVuY3Rpb24gZW5hYmxlVGV4dFNlbGVjdGlvbigpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxudmFyIGRpc2FibGVUZXh0U2VsZWN0aW9uO1xyXG52YXIgZW5hYmxlVGV4dFNlbGVjdGlvbjtcclxudmFyIF91c2VyU2VsZWN0O1xyXG5pZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB7XHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRvbih3aW5kb3csICdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG5cdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRvZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxufSBlbHNlIHtcclxuXHR2YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gdGVzdFByb3AoXHJcblx0XHRbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcclxuXHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldO1xyXG5cdFx0XHRzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSBfdXNlclNlbGVjdDtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKVxyXG4vLyBBcyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKSwgYnV0XHJcbi8vIGZvciBgZHJhZ3N0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGFuIGltYWdlLlxyXG5mdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKCkge1xyXG5cdG9uKHdpbmRvdywgJ2RyYWdzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG5mdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKSB7XHJcblx0b2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxufVxyXG5cclxudmFyIF9vdXRsaW5lRWxlbWVudDtcbnZhciBfb3V0bGluZVN0eWxlO1xyXG4vLyBAZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyB0aGUgW291dGxpbmVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9vdXRsaW5lKVxyXG4vLyBvZiB0aGUgZWxlbWVudCBgZWxgIGludmlzaWJsZS4gVXNlZCBpbnRlcm5hbGx5IGJ5IExlYWZsZXQgdG8gcHJldmVudFxyXG4vLyBmb2N1c2FibGUgZWxlbWVudHMgZnJvbSBkaXNwbGF5aW5nIGFuIG91dGxpbmUgd2hlbiB0aGUgdXNlciBwZXJmb3JtcyBhXHJcbi8vIGRyYWcgaW50ZXJhY3Rpb24gb24gdGhlbS5cclxuZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWxlbWVudCkge1xyXG5cdHdoaWxlIChlbGVtZW50LnRhYkluZGV4ID09PSAtMSkge1xyXG5cdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHR9XHJcblx0aWYgKCFlbGVtZW50LnN0eWxlKSB7IHJldHVybjsgfVxyXG5cdHJlc3RvcmVPdXRsaW5lKCk7XHJcblx0X291dGxpbmVFbGVtZW50ID0gZWxlbWVudDtcclxuXHRfb3V0bGluZVN0eWxlID0gZWxlbWVudC5zdHlsZS5vdXRsaW5lO1xyXG5cdGVsZW1lbnQuc3R5bGUub3V0bGluZSA9ICdub25lJztcclxuXHRvbih3aW5kb3csICdrZXlkb3duJywgcmVzdG9yZU91dGxpbmUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVzdG9yZU91dGxpbmUoKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwucHJldmVudE91dGxpbmVgXSgpLlxyXG5mdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpIHtcclxuXHRpZiAoIV9vdXRsaW5lRWxlbWVudCkgeyByZXR1cm47IH1cclxuXHRfb3V0bGluZUVsZW1lbnQuc3R5bGUub3V0bGluZSA9IF9vdXRsaW5lU3R5bGU7XHJcblx0X291dGxpbmVFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG5cdF9vdXRsaW5lU3R5bGUgPSB1bmRlZmluZWQ7XHJcblx0b2ZmKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWw6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gRmluZHMgdGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgd2hpY2ggc2l6ZSAod2lkdGggYW5kIGhlaWdodCkgaXMgbm90IG51bGwuXHJcbmZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbGVtZW50KSB7XHJcblx0ZG8ge1xyXG5cdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHR9IHdoaWxlICgoIWVsZW1lbnQub2Zmc2V0V2lkdGggfHwgIWVsZW1lbnQub2Zmc2V0SGVpZ2h0KSAmJiBlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KTtcclxuXHRyZXR1cm4gZWxlbWVudDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFNjYWxlKGVsOiBIVE1MRWxlbWVudCk6IE9iamVjdFxyXG4vLyBDb21wdXRlcyB0aGUgQ1NTIHNjYWxlIGN1cnJlbnRseSBhcHBsaWVkIG9uIHRoZSBlbGVtZW50LlxyXG4vLyBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGB4YCBhbmQgYHlgIG1lbWJlcnMgYXMgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc2NhbGVzIHJlc3BlY3RpdmVseSxcclxuLy8gYW5kIGBib3VuZGluZ0NsaWVudFJlY3RgIGFzIHRoZSByZXN1bHQgb2YgW2BnZXRCb3VuZGluZ0NsaWVudFJlY3QoKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEJvdW5kaW5nQ2xpZW50UmVjdCkuXHJcbmZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQpIHtcclxuXHR2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIFJlYWQtb25seSBpbiBvbGQgYnJvd3NlcnMuXHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR4OiByZWN0LndpZHRoIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxLFxyXG5cdFx0eTogcmVjdC5oZWlnaHQgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxLFxyXG5cdFx0Ym91bmRpbmdDbGllbnRSZWN0OiByZWN0XHJcblx0fTtcclxufVxyXG5cblxudmFyIERvbVV0aWwgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0VFJBTlNGT1JNOiBUUkFOU0ZPUk0sXG5cdFRSQU5TSVRJT046IFRSQU5TSVRJT04sXG5cdFRSQU5TSVRJT05fRU5EOiBUUkFOU0lUSU9OX0VORCxcblx0Z2V0OiBnZXQsXG5cdGdldFN0eWxlOiBnZXRTdHlsZSxcblx0Y3JlYXRlOiBjcmVhdGUkMSxcblx0cmVtb3ZlOiByZW1vdmUsXG5cdGVtcHR5OiBlbXB0eSxcblx0dG9Gcm9udDogdG9Gcm9udCxcblx0dG9CYWNrOiB0b0JhY2ssXG5cdGhhc0NsYXNzOiBoYXNDbGFzcyxcblx0YWRkQ2xhc3M6IGFkZENsYXNzLFxuXHRyZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG5cdHNldENsYXNzOiBzZXRDbGFzcyxcblx0Z2V0Q2xhc3M6IGdldENsYXNzLFxuXHRzZXRPcGFjaXR5OiBzZXRPcGFjaXR5LFxuXHR0ZXN0UHJvcDogdGVzdFByb3AsXG5cdHNldFRyYW5zZm9ybTogc2V0VHJhbnNmb3JtLFxuXHRzZXRQb3NpdGlvbjogc2V0UG9zaXRpb24sXG5cdGdldFBvc2l0aW9uOiBnZXRQb3NpdGlvbixcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb246IGRpc2FibGVUZXh0U2VsZWN0aW9uLFxuXHRlbmFibGVUZXh0U2VsZWN0aW9uOiBlbmFibGVUZXh0U2VsZWN0aW9uLFxuXHRkaXNhYmxlSW1hZ2VEcmFnOiBkaXNhYmxlSW1hZ2VEcmFnLFxuXHRlbmFibGVJbWFnZURyYWc6IGVuYWJsZUltYWdlRHJhZyxcblx0cHJldmVudE91dGxpbmU6IHByZXZlbnRPdXRsaW5lLFxuXHRyZXN0b3JlT3V0bGluZTogcmVzdG9yZU91dGxpbmUsXG5cdGdldFNpemVkUGFyZW50Tm9kZTogZ2V0U2l6ZWRQYXJlbnROb2RlLFxuXHRnZXRTY2FsZTogZ2V0U2NhbGVcbn0pO1xuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbUV2ZW50XHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTSBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudCksIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEluc3BpcmVkIGJ5IEpvaG4gUmVzaWcsIERlYW4gRWR3YXJkcyBhbmQgWVVJIGFkZEV2ZW50IGltcGxlbWVudGF0aW9ucy5cclxuXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgRE9NIGV2ZW50IHR5cGUgb2YgdGhlXHJcbi8vIGVsZW1lbnQgYGVsYC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyXHJcbi8vIChvYmplY3QgdGhlIGB0aGlzYCBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsXHJcbi8vIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuZnVuY3Rpb24gb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG52YXIgZXZlbnRzS2V5ID0gJ19sZWFmbGV0X2V2ZW50cyc7XHJcblxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi5cclxuLy8gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBvbiwgeW91IG11c3QgcGFzcyB0aGUgc2FtZVxyXG4vLyBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuZnVuY3Rpb24gb2ZmKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICh0eXBlcykge1xyXG5cdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yICh2YXIgaiBpbiBvYmpbZXZlbnRzS2V5XSkge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCBqLCBvYmpbZXZlbnRzS2V5XVtqXSk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgb2JqW2V2ZW50c0tleV07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHR2YXIgaWQgPSB0eXBlICsgc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBzdGFtcChjb250ZXh0KSA6ICcnKTtcclxuXHJcblx0aWYgKG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gZm4uY2FsbChjb250ZXh0IHx8IG9iaiwgZSB8fCB3aW5kb3cuZXZlbnQpO1xyXG5cdH07XHJcblxyXG5cdHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuXHRpZiAocG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdC8vIE5lZWRzIERvbUV2ZW50LlBvaW50ZXIuanNcclxuXHRcdGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmICh0b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgYWRkRG91YmxlVGFwTGlzdGVuZXIgJiZcclxuXHQgICAgICAgICAgICEocG9pbnRlciAmJiBjaHJvbWUpKSB7XHJcblx0XHQvLyBDaHJvbWUgPjU1IGRvZXMgbm90IG5lZWQgdGhlIHN5bnRoZXRpYyBkYmxjbGlja3MgZnJvbSBhZGREb3VibGVUYXBMaXN0ZW5lclxyXG5cdFx0Ly8gU2VlICM1MTgwXHJcblx0XHRhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgcGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICgodHlwZSA9PT0gJ21vdXNlZW50ZXInKSB8fCAodHlwZSA9PT0gJ21vdXNlbGVhdmUnKSkge1xyXG5cdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcblx0XHRcdFx0aWYgKGlzRXh0ZXJuYWxUYXJnZXQob2JqLCBlKSkge1xyXG5cdFx0XHRcdFx0b3JpZ2luYWxIYW5kbGVyKGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSA9PT0gJ21vdXNlZW50ZXInID8gJ21vdXNlb3ZlcicgOiAnbW91c2VvdXQnLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycgJiYgYW5kcm9pZCkge1xyXG5cdFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0ZmlsdGVyQ2xpY2soZSwgb3JpZ2luYWxIYW5kbGVyKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIGlmICgnYXR0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHR9XHJcblxyXG5cdG9ialtldmVudHNLZXldID0gb2JqW2V2ZW50c0tleV0gfHwge307XHJcblx0b2JqW2V2ZW50c0tleV1baWRdID0gaGFuZGxlcjtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0dmFyIGlkID0gdHlwZSArIHN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgc3RhbXAoY29udGV4dCkgOiAnJyksXHJcblx0ICAgIGhhbmRsZXIgPSBvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF07XHJcblxyXG5cdGlmICghaGFuZGxlcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRpZiAocG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmICh0b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIgJiZcclxuXHQgICAgICAgICAgICEocG9pbnRlciAmJiBjaHJvbWUpKSB7XHJcblx0XHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgcGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXHJcblx0XHRcdFx0dHlwZSA9PT0gJ21vdXNlZW50ZXInID8gJ21vdXNlb3ZlcicgOlxyXG5cdFx0XHRcdHR5cGUgPT09ICdtb3VzZWxlYXZlJyA/ICdtb3VzZW91dCcgOiB0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2RldGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdG9iai5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBudWxsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gU3RvcCB0aGUgZ2l2ZW4gZXZlbnQgZnJvbSBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuIFVzZWQgaW5zaWRlIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnM6XHJcbi8vIGBgYGpzXHJcbi8vIEwuRG9tRXZlbnQub24oZGl2LCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuLy8gXHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldik7XHJcbi8vIH0pO1xyXG4vLyBgYGBcclxuZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGUpIHtcclxuXHJcblx0aWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XHJcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50KSB7ICAvLyBJbiBjYXNlIG9mIExlYWZsZXQgZXZlbnQuXHJcblx0XHRlLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgPSB0cnVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcblx0fVxyXG5cdHNraXBwZWQoZSk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnbW91c2V3aGVlbCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsKSB7XHJcblx0YWRkT25lKGVsLCAnbW91c2V3aGVlbCcsIHN0b3BQcm9wYWdhdGlvbik7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbi8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ2NsaWNrJ2AsIGAnZG91YmxlY2xpY2snYCxcclxuLy8gYCdtb3VzZWRvd24nYCBhbmQgYCd0b3VjaHN0YXJ0J2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5mdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbCkge1xyXG5cdG9uKGVsLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQgZGJsY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdGFkZE9uZShlbCwgJ2NsaWNrJywgZmFrZVN0b3ApO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIERPTSBFdmVudCBgZXZgIGZyb20gaGFwcGVuaW5nIChzdWNoIGFzXHJcbi8vIGZvbGxvd2luZyBhIGxpbmsgaW4gdGhlIGhyZWYgb2YgdGhlIGEgZWxlbWVudCwgb3IgZG9pbmcgYSBQT1NUIHJlcXVlc3RcclxuLy8gd2l0aCBwYWdlIHJlbG9hZCB3aGVuIGEgYDxmb3JtPmAgaXMgc3VibWl0dGVkKS5cclxuLy8gVXNlIGl0IGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcclxuXHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcChldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIERvZXMgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgYXQgdGhlIHNhbWUgdGltZS5cclxuZnVuY3Rpb24gc3RvcChlKSB7XHJcblx0cHJldmVudERlZmF1bHQoZSk7XHJcblx0c3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihldjogRE9NRXZlbnQsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogUG9pbnRcclxuLy8gR2V0cyBub3JtYWxpemVkIG1vdXNlIHBvc2l0aW9uIGZyb20gYSBET00gZXZlbnQgcmVsYXRpdmUgdG8gdGhlXHJcbi8vIGBjb250YWluZXJgIChib3JkZXIgZXhjbHVkZWQpIG9yIHRvIHRoZSB3aG9sZSBwYWdlIGlmIG5vdCBzcGVjaWZpZWQuXHJcbmZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSwgY29udGFpbmVyKSB7XHJcblx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xyXG5cdH1cclxuXHJcblx0dmFyIHNjYWxlID0gZ2V0U2NhbGUoY29udGFpbmVyKSxcclxuXHQgICAgb2Zmc2V0ID0gc2NhbGUuYm91bmRpbmdDbGllbnRSZWN0OyAvLyBsZWZ0IGFuZCB0b3AgIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSB0aGUgZXZlbnQgY2xpZW50WC9ZKVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0Ly8gb2Zmc2V0LmxlZnQvdG9wIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSBjbGllbnRYL1kpLFxyXG5cdFx0Ly8gd2hlcmVhcyBjbGllbnRMZWZ0L1RvcCAoYm9yZGVyIHdpZHRoKSB2YWx1ZXMgYXJlIHRoZSBvcmlnaW5hbCB2YWx1ZXMgKGJlZm9yZSBDU1Mgc2NhbGUgYXBwbGllcykuXHJcblx0XHQoZS5jbGllbnRYIC0gb2Zmc2V0LmxlZnQpIC8gc2NhbGUueCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG5cdFx0KGUuY2xpZW50WSAtIG9mZnNldC50b3ApIC8gc2NhbGUueSAtIGNvbnRhaW5lci5jbGllbnRUb3BcclxuXHQpO1xyXG59XHJcblxyXG4vLyBDaHJvbWUgb24gV2luIHNjcm9sbHMgZG91YmxlIHRoZSBwaXhlbHMgYXMgaW4gb3RoZXIgcGxhdGZvcm1zIChzZWUgIzQ1MzgpLFxyXG4vLyBhbmQgRmlyZWZveCBzY3JvbGxzIGRldmljZSBwaXhlbHMsIG5vdCBDU1MgcGl4ZWxzXHJcbnZhciB3aGVlbFB4RmFjdG9yID1cclxuXHQod2luICYmIGNocm9tZSkgPyAyICogd2luZG93LmRldmljZVBpeGVsUmF0aW8gOlxyXG5cdGdlY2tvID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZXY6IERPTUV2ZW50KTogTnVtYmVyXHJcbi8vIEdldHMgbm9ybWFsaXplZCB3aGVlbCBkZWx0YSBmcm9tIGEgbW91c2V3aGVlbCBET00gZXZlbnQsIGluIHZlcnRpY2FsXHJcbi8vIHBpeGVscyBzY3JvbGxlZCAobmVnYXRpdmUgaWYgc2Nyb2xsaW5nIGRvd24pLlxyXG4vLyBFdmVudHMgZnJvbSBwb2ludGluZyBkZXZpY2VzIHdpdGhvdXQgcHJlY2lzZSBzY3JvbGxpbmcgYXJlIG1hcHBlZCB0b1xyXG4vLyBhIGJlc3QgZ3Vlc3Mgb2YgNjAgcGl4ZWxzLlxyXG5mdW5jdGlvbiBnZXRXaGVlbERlbHRhKGUpIHtcclxuXHRyZXR1cm4gKGVkZ2UpID8gZS53aGVlbERlbHRhWSAvIDIgOiAvLyBEb24ndCB0cnVzdCB3aW5kb3ctZ2VvbWV0cnktYmFzZWQgZGVsdGFcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAwKSA/IC1lLmRlbHRhWSAvIHdoZWVsUHhGYWN0b3IgOiAvLyBQaXhlbHNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAxKSA/IC1lLmRlbHRhWSAqIDIwIDogLy8gTGluZXNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAyKSA/IC1lLmRlbHRhWSAqIDYwIDogLy8gUGFnZXNcclxuXHQgICAgICAgKGUuZGVsdGFYIHx8IGUuZGVsdGFaKSA/IDAgOlx0Ly8gU2tpcCBob3Jpem9udGFsL2RlcHRoIHdoZWVsIGV2ZW50c1xyXG5cdCAgICAgICBlLndoZWVsRGVsdGEgPyAoZS53aGVlbERlbHRhWSB8fCBlLndoZWVsRGVsdGEpIC8gMiA6IC8vIExlZ2FjeSBJRSBwaXhlbHNcclxuXHQgICAgICAgKGUuZGV0YWlsICYmIE1hdGguYWJzKGUuZGV0YWlsKSA8IDMyNzY1KSA/IC1lLmRldGFpbCAqIDIwIDogLy8gTGVnYWN5IE1veiBsaW5lc1xyXG5cdCAgICAgICBlLmRldGFpbCA/IGUuZGV0YWlsIC8gLTMyNzY1ICogNjAgOiAvLyBMZWdhY3kgTW96IHBhZ2VzXHJcblx0ICAgICAgIDA7XHJcbn1cclxuXHJcbnZhciBza2lwRXZlbnRzID0ge307XHJcblxyXG5mdW5jdGlvbiBmYWtlU3RvcChlKSB7XHJcblx0Ly8gZmFrZXMgc3RvcFByb3BhZ2F0aW9uIGJ5IHNldHRpbmcgYSBzcGVjaWFsIGV2ZW50IGZsYWcsIGNoZWNrZWQvcmVzZXQgd2l0aCBza2lwcGVkKGUpXHJcblx0c2tpcEV2ZW50c1tlLnR5cGVdID0gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2tpcHBlZChlKSB7XHJcblx0dmFyIGV2ZW50cyA9IHNraXBFdmVudHNbZS50eXBlXTtcclxuXHQvLyByZXNldCB3aGVuIGNoZWNraW5nLCBhcyBpdCdzIG9ubHkgdXNlZCBpbiBtYXAgY29udGFpbmVyIGFuZCBwcm9wYWdhdGVzIG91dHNpZGUgb2YgdGhlIG1hcFxyXG5cdHNraXBFdmVudHNbZS50eXBlXSA9IGZhbHNlO1xyXG5cdHJldHVybiBldmVudHM7XHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIGVsZW1lbnQgcmVhbGx5IGxlZnQvZW50ZXJlZCB0aGUgZXZlbnQgdGFyZ2V0IChmb3IgbW91c2VlbnRlci9tb3VzZWxlYXZlKVxyXG5mdW5jdGlvbiBpc0V4dGVybmFsVGFyZ2V0KGVsLCBlKSB7XHJcblxyXG5cdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuXHRpZiAoIXJlbGF0ZWQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0dHJ5IHtcclxuXHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuXHRcdFx0cmVsYXRlZCA9IHJlbGF0ZWQucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcbn1cclxuXHJcbnZhciBsYXN0Q2xpY2s7XHJcblxyXG4vLyB0aGlzIGlzIGEgaG9ycmlibGUgd29ya2Fyb3VuZCBmb3IgYSBidWcgaW4gQW5kcm9pZCB3aGVyZSBhIHNpbmdsZSB0b3VjaCB0cmlnZ2VycyB0d28gY2xpY2sgZXZlbnRzXHJcbmZ1bmN0aW9uIGZpbHRlckNsaWNrKGUsIGhhbmRsZXIpIHtcclxuXHR2YXIgdGltZVN0YW1wID0gKGUudGltZVN0YW1wIHx8IChlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LnRpbWVTdGFtcCkpLFxyXG5cdCAgICBlbGFwc2VkID0gbGFzdENsaWNrICYmICh0aW1lU3RhbXAgLSBsYXN0Q2xpY2spO1xyXG5cclxuXHQvLyBhcmUgdGhleSBjbG9zZXIgdG9nZXRoZXIgdGhhbiA1MDBtcyB5ZXQgbW9yZSB0aGFuIDEwMG1zP1xyXG5cdC8vIEFuZHJvaWQgdHlwaWNhbGx5IHRyaWdnZXJzIHRoZW0gfjMwMG1zIGFwYXJ0IHdoaWxlIG11bHRpcGxlIGxpc3RlbmVyc1xyXG5cdC8vIG9uIHRoZSBzYW1lIGV2ZW50IHNob3VsZCBiZSB0cmlnZ2VyZWQgZmFyIGZhc3RlcjtcclxuXHQvLyBvciBjaGVjayBpZiBjbGljayBpcyBzaW11bGF0ZWQgb24gdGhlIGVsZW1lbnQsIGFuZCBpZiBpdCBpcywgcmVqZWN0IGFueSBub24tc2ltdWxhdGVkIGV2ZW50c1xyXG5cclxuXHRpZiAoKGVsYXBzZWQgJiYgZWxhcHNlZCA+IDEwMCAmJiBlbGFwc2VkIDwgNTAwKSB8fCAoZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrICYmICFlLl9zaW11bGF0ZWQpKSB7XHJcblx0XHRzdG9wKGUpO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHRsYXN0Q2xpY2sgPSB0aW1lU3RhbXA7XHJcblxyXG5cdGhhbmRsZXIoZSk7XHJcbn1cclxuXHJcblxyXG5cblxudmFyIERvbUV2ZW50ID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdG9uOiBvbixcblx0b2ZmOiBvZmYsXG5cdHN0b3BQcm9wYWdhdGlvbjogc3RvcFByb3BhZ2F0aW9uLFxuXHRkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb246IGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbixcblx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb246IGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uLFxuXHRwcmV2ZW50RGVmYXVsdDogcHJldmVudERlZmF1bHQsXG5cdHN0b3A6IHN0b3AsXG5cdGdldE1vdXNlUG9zaXRpb246IGdldE1vdXNlUG9zaXRpb24sXG5cdGdldFdoZWVsRGVsdGE6IGdldFdoZWVsRGVsdGEsXG5cdGZha2VTdG9wOiBmYWtlU3RvcCxcblx0c2tpcHBlZDogc2tpcHBlZCxcblx0aXNFeHRlcm5hbFRhcmdldDogaXNFeHRlcm5hbFRhcmdldCxcblx0YWRkTGlzdGVuZXI6IG9uLFxuXHRyZW1vdmVMaXN0ZW5lcjogb2ZmXG59KTtcblxuLypcbiAqIEBjbGFzcyBQb3NBbmltYXRpb25cbiAqIEBha2EgTC5Qb3NBbmltYXRpb25cbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIHBhbm5pbmcgYW5pbWF0aW9ucywgdXRpbGl6aW5nIENTUzMgVHJhbnNpdGlvbnMgZm9yIG1vZGVybiBicm93c2VycyBhbmQgYSB0aW1lciBmYWxsYmFjayBmb3IgSUU2LTkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgZnggPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcbiAqIGZ4LnJ1bihlbCwgWzMwMCwgNTAwXSwgMC41KTtcbiAqIGBgYFxuICpcbiAqIEBjb25zdHJ1Y3RvciBMLlBvc0FuaW1hdGlvbigpXG4gKiBDcmVhdGVzIGEgYFBvc0FuaW1hdGlvbmAgb2JqZWN0LlxuICpcbiAqL1xuXG52YXIgUG9zQW5pbWF0aW9uID0gRXZlbnRlZC5leHRlbmQoe1xuXG5cdC8vIEBtZXRob2QgcnVuKGVsOiBIVE1MRWxlbWVudCwgbmV3UG9zOiBQb2ludCwgZHVyYXRpb24/OiBOdW1iZXIsIGVhc2VMaW5lYXJpdHk/OiBOdW1iZXIpXG5cdC8vIFJ1biBhbiBhbmltYXRpb24gb2YgYSBnaXZlbiBlbGVtZW50IHRvIGEgbmV3IHBvc2l0aW9uLCBvcHRpb25hbGx5IHNldHRpbmdcblx0Ly8gZHVyYXRpb24gaW4gc2Vjb25kcyAoYDAuMjVgIGJ5IGRlZmF1bHQpIGFuZCBlYXNpbmcgbGluZWFyaXR5IGZhY3RvciAoM3JkXG5cdC8vIGFyZ3VtZW50IG9mIHRoZSBbY3ViaWMgYmV6aWVyIGN1cnZlXShodHRwOi8vY3ViaWMtYmV6aWVyLmNvbS8jMCwwLC41LDEpLFxuXHQvLyBgMC41YCBieSBkZWZhdWx0KS5cblx0cnVuOiBmdW5jdGlvbiAoZWwsIG5ld1BvcywgZHVyYXRpb24sIGVhc2VMaW5lYXJpdHkpIHtcblx0XHR0aGlzLnN0b3AoKTtcblxuXHRcdHRoaXMuX2VsID0gZWw7XG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IHRydWU7XG5cdFx0dGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAwLjI1O1xuXHRcdHRoaXMuX2Vhc2VPdXRQb3dlciA9IDEgLyBNYXRoLm1heChlYXNlTGluZWFyaXR5IHx8IDAuNSwgMC4yKTtcblxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gZ2V0UG9zaXRpb24oZWwpO1xuXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cblx0XHQvLyBAZXZlbnQgc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuXHRcdHRoaXMuX2FuaW1hdGUoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHN0b3AoKVxuXHQvLyBTdG9wcyB0aGUgYW5pbWF0aW9uIChpZiBjdXJyZW50bHkgcnVubmluZykuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9zdGVwKHRydWUpO1xuXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhbmltYXRpb24gbG9vcFxuXHRcdHRoaXMuX2FuaW1JZCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYW5pbWF0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fc3RlcCgpO1xuXHR9LFxuXG5cdF9zdGVwOiBmdW5jdGlvbiAocm91bmQpIHtcblx0XHR2YXIgZWxhcHNlZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG5cdFx0aWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlbGFwc2VkIC8gZHVyYXRpb24pLCByb3VuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKDEpO1xuXHRcdFx0dGhpcy5fY29tcGxldGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3J1bkZyYW1lOiBmdW5jdGlvbiAocHJvZ3Jlc3MsIHJvdW5kKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0cG9zLl9yb3VuZCgpO1xuXHRcdH1cblx0XHRzZXRQb3NpdGlvbih0aGlzLl9lbCwgcG9zKTtcblxuXHRcdC8vIEBldmVudCBzdGVwOiBFdmVudFxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cblx0XHR0aGlzLmZpcmUoJ3N0ZXAnKTtcblx0fSxcblxuXHRfY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbUlkKTtcblxuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHRoaXMuZmlyZSgnZW5kJyk7XG5cdH0sXG5cblx0X2Vhc2VPdXQ6IGZ1bmN0aW9uICh0KSB7XG5cdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgdGhpcy5fZWFzZU91dFBvd2VyKTtcblx0fVxufSk7XG5cbi8qXHJcbiAqIEBjbGFzcyBNYXBcclxuICogQGFrYSBMLk1hcFxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBUaGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1hcCBvbiBhIHBhZ2UgYW5kIG1hbmlwdWxhdGUgaXQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcclxuICogXHRjZW50ZXI6IFs1MS41MDUsIC0wLjA5XSxcclxuICogXHR6b29tOiAxM1xyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5cclxudmFyIE1hcCA9IEV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIFN0YXRlIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBMLkNSUy5FUFNHMzg1N1xyXG5cdFx0Ly8gVGhlIFtDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW1dKCNjcnMpIHRvIHVzZS4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdFxyXG5cdFx0Ly8gc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG5cdFx0Y3JzOiBFUFNHMzg1NyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNlbnRlcjogTGF0TG5nID0gdW5kZWZpbmVkXHJcblx0XHQvLyBJbml0aWFsIGdlb2dyYXBoaWMgY2VudGVyIG9mIHRoZSBtYXBcclxuXHRcdGNlbnRlcjogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcblx0XHQvLyBJbml0aWFsIG1hcCB6b29tIGxldmVsXHJcblx0XHR6b29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAqXHJcblx0XHQvLyBNaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxyXG5cdFx0Ly8gdGhlIGxvd2VzdCBvZiB0aGVpciBgbWluWm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuXHRcdG1pblpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9ICpcclxuXHRcdC8vIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcblx0XHQvLyB0aGUgaGlnaGVzdCBvZiB0aGVpciBgbWF4Wm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuXHRcdG1heFpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogTGF5ZXJbXSA9IFtdXHJcblx0XHQvLyBBcnJheSBvZiBsYXllcnMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAgaW5pdGlhbGx5XHJcblx0XHRsYXllcnM6IFtdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Qm91bmRzOiBMYXRMbmdCb3VuZHMgPSBudWxsXHJcblx0XHQvLyBXaGVuIHRoaXMgb3B0aW9uIGlzIHNldCwgdGhlIG1hcCByZXN0cmljdHMgdGhlIHZpZXcgdG8gdGhlIGdpdmVuXHJcblx0XHQvLyBnZW9ncmFwaGljYWwgYm91bmRzLCBib3VuY2luZyB0aGUgdXNlciBiYWNrIGlmIHRoZSB1c2VyIHRyaWVzIHRvIHBhblxyXG5cdFx0Ly8gb3V0c2lkZSB0aGUgdmlldy4gVG8gc2V0IHRoZSByZXN0cmljdGlvbiBkeW5hbWljYWxseSwgdXNlXHJcblx0XHQvLyBbYHNldE1heEJvdW5kc2BdKCNtYXAtc2V0bWF4Ym91bmRzKSBtZXRob2QuXHJcblx0XHRtYXhCb3VuZHM6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlciA9ICpcclxuXHRcdC8vIFRoZSBkZWZhdWx0IG1ldGhvZCBmb3IgZHJhd2luZyB2ZWN0b3IgbGF5ZXJzIG9uIHRoZSBtYXAuIGBMLlNWR2BcclxuXHRcdC8vIG9yIGBMLkNhbnZhc2AgYnkgZGVmYXVsdCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0LlxyXG5cdFx0cmVuZGVyZXI6IHVuZGVmaW5lZCxcclxuXHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gQW5pbWF0aW9uIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCB6b29tIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxyXG5cdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IE51bWJlciA9IDRcclxuXHRcdC8vIFdvbid0IGFuaW1hdGUgem9vbSBpZiB0aGUgem9vbSBkaWZmZXJlbmNlIGV4Y2VlZHMgdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IDQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBmYWRlQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdGlsZSBmYWRlIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxyXG5cdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0ZmFkZUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1hcmtlclpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIG1hcmtlcnMgYW5pbWF0ZSB0aGVpciB6b29tIHdpdGggdGhlIHpvb20gYW5pbWF0aW9uLCBpZiBkaXNhYmxlZFxyXG5cdFx0Ly8gdGhleSB3aWxsIGRpc2FwcGVhciBmb3IgdGhlIGxlbmd0aCBvZiB0aGUgYW5pbWF0aW9uLiBCeSBkZWZhdWx0IGl0J3NcclxuXHRcdC8vIGVuYWJsZWQgaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0bWFya2VyWm9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYW5zZm9ybTNETGltaXQ6IE51bWJlciA9IDJeMjNcclxuXHRcdC8vIERlZmluZXMgdGhlIG1heGltdW0gc2l6ZSBvZiBhIENTUyB0cmFuc2xhdGlvbiB0cmFuc2Zvcm0uIFRoZSBkZWZhdWx0XHJcblx0XHQvLyB2YWx1ZSBzaG91bGQgbm90IGJlIGNoYW5nZWQgdW5sZXNzIGEgd2ViIGJyb3dzZXIgcG9zaXRpb25zIGxheWVycyBpblxyXG5cdFx0Ly8gdGhlIHdyb25nIHBsYWNlIGFmdGVyIGRvaW5nIGEgbGFyZ2UgYHBhbkJ5YC5cclxuXHRcdHRyYW5zZm9ybTNETGltaXQ6IDgzODg2MDgsIC8vIFByZWNpc2lvbiBsaW1pdCBvZiBhIDMyLWJpdCBmbG9hdFxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gem9vbVNuYXA6IE51bWJlciA9IDFcclxuXHRcdC8vIEZvcmNlcyB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB0byBhbHdheXMgYmUgYSBtdWx0aXBsZSBvZiB0aGlzLCBwYXJ0aWN1bGFybHlcclxuXHRcdC8vIHJpZ2h0IGFmdGVyIGEgW2BmaXRCb3VuZHMoKWBdKCNtYXAtZml0Ym91bmRzKSBvciBhIHBpbmNoLXpvb20uXHJcblx0XHQvLyBCeSBkZWZhdWx0LCB0aGUgem9vbSBsZXZlbCBzbmFwcyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyOyBsb3dlciB2YWx1ZXNcclxuXHRcdC8vIChlLmcuIGAwLjVgIG9yIGAwLjFgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS4gQSB2YWx1ZSBvZiBgMGBcclxuXHRcdC8vIG1lYW5zIHRoZSB6b29tIGxldmVsIHdpbGwgbm90IGJlIHNuYXBwZWQgYWZ0ZXIgYGZpdEJvdW5kc2Agb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0em9vbVNuYXA6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tRGVsdGE6IE51bWJlciA9IDFcclxuXHRcdC8vIENvbnRyb2xzIGhvdyBtdWNoIHRoZSBtYXAncyB6b29tIGxldmVsIHdpbGwgY2hhbmdlIGFmdGVyIGFcclxuXHRcdC8vIFtgem9vbUluKClgXSgjbWFwLXpvb21pbiksIFtgem9vbU91dCgpYF0oI21hcC16b29tb3V0KSwgcHJlc3NpbmcgYCtgXHJcblx0XHQvLyBvciBgLWAgb24gdGhlIGtleWJvYXJkLCBvciB1c2luZyB0aGUgW3pvb20gY29udHJvbHNdKCNjb250cm9sLXpvb20pLlxyXG5cdFx0Ly8gVmFsdWVzIHNtYWxsZXIgdGhhbiBgMWAgKGUuZy4gYDAuNWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LlxyXG5cdFx0em9vbURlbHRhOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhY2tSZXNpemU6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgYXV0b21hdGljYWxseSBoYW5kbGVzIGJyb3dzZXIgd2luZG93IHJlc2l6ZSB0byB1cGRhdGUgaXRzZWxmLlxyXG5cdFx0dHJhY2tSZXNpemU6IHRydWVcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxyXG5cdFx0b3B0aW9ucyA9IHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Ly8gTWFrZSBzdXJlIHRvIGFzc2lnbiBpbnRlcm5hbCBmbGFncyBhdCB0aGUgYmVnaW5uaW5nLFxyXG5cdFx0Ly8gdG8gYXZvaWQgaW5jb25zaXN0ZW50IHN0YXRlIGluIHNvbWUgZWRnZSBjYXNlcy5cclxuXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX2luaXRDb250YWluZXIoaWQpO1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuXHRcdC8vIGhhY2sgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzE5ODBcclxuXHRcdHRoaXMuX29uUmVzaXplID0gYmluZCh0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cygpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm1heEJvdW5kcykge1xyXG5cdFx0XHR0aGlzLnNldE1heEJvdW5kcyhvcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB0aGlzLl9saW1pdFpvb20ob3B0aW9ucy56b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5jZW50ZXIgJiYgb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KHRvTGF0TG5nKG9wdGlvbnMuY2VudGVyKSwgb3B0aW9ucy56b29tLCB7cmVzZXQ6IHRydWV9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIG9uIGJyb3dzZXJzIHdpdGhvdXQgaGFyZHdhcmUtYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnMgb3Igb2xkIEFuZHJvaWQvT3BlcmFcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IFRSQU5TSVRJT04gJiYgYW55M2QgJiYgIW1vYmlsZU9wZXJhICYmXHJcblx0XHRcdFx0dGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XHJcblxyXG5cdFx0Ly8gem9vbSB0cmFuc2l0aW9ucyBydW4gd2l0aCB0aGUgc2FtZSBkdXJhdGlvbiBmb3IgYWxsIGxheWVycywgc28gaWYgb25lIG9mIHRyYW5zaXRpb25lbmQgZXZlbnRzXHJcblx0XHQvLyBoYXBwZW5zIGFmdGVyIHN0YXJ0aW5nIHpvb20gYW5pbWF0aW9uIChwcm9wYWdhdGluZyB0byB0aGUgbWFwIHBhbmUpLCB3ZSBrbm93IHRoYXQgaXQgZW5kZWQgZ2xvYmFsbHlcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0dGhpcy5fY3JlYXRlQW5pbVByb3h5KCk7XHJcblx0XHRcdG9uKHRoaXMuX3Byb3h5LCBUUkFOU0lUSU9OX0VORCwgdGhpcy5fY2F0Y2hUcmFuc2l0aW9uRW5kLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hZGRMYXllcnModGhpcy5vcHRpb25zLmxheWVycyk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRWaWV3KGNlbnRlcjogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgd2l0aCB0aGUgZ2l2ZW5cclxuXHQvLyBhbmltYXRpb24gb3B0aW9ucy5cclxuXHRzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblx0XHRjZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcih0b0xhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbSA9IGV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlfSwgb3B0aW9ucy56b29tKTtcclxuXHRcdFx0XHRvcHRpb25zLnBhbiA9IGV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLCBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbn0sIG9wdGlvbnMucGFuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxyXG5cdFx0XHR2YXIgbW92ZWQgPSAodGhpcy5fem9vbSAhPT0gem9vbSkgP1xyXG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkWm9vbSAmJiB0aGlzLl90cnlBbmltYXRlZFpvb20oY2VudGVyLCB6b29tLCBvcHRpb25zLnpvb20pIDpcclxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMucGFuKTtcclxuXHJcblx0XHRcdGlmIChtb3ZlZCkge1xyXG5cdFx0XHRcdC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XHJcblx0XHR0aGlzLl9yZXNldFZpZXcoY2VudGVyLCB6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb20oem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB6b29tIG9mIHRoZSBtYXAuXHJcblx0c2V0Wm9vbTogZnVuY3Rpb24gKHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21JbihkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBJbmNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tSW46IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tT3V0KGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIERlY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG5cdHpvb21PdXQ6IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gLSBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgZ2VvZ3JhcGhpY2FsIHBvaW50IG9uIHRoZSBtYXBcclxuXHQvLyBzdGF0aW9uYXJ5IChlLmcuIHVzZWQgaW50ZXJuYWxseSBmb3Igc2Nyb2xsIHpvb20gYW5kIGRvdWJsZS1jbGljayB6b29tKS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQob2Zmc2V0OiBQb2ludCwgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIHBpeGVsIG9uIHRoZSBtYXAgKHJlbGF0aXZlIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIpIHN0YXRpb25hcnkuXHJcblx0c2V0Wm9vbUFyb3VuZDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgb3B0aW9ucykge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICBjb250YWluZXJQb2ludCA9IGxhdGxuZyBpbnN0YW5jZW9mIFBvaW50ID8gbGF0bG5nIDogdGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZyksXHJcblxyXG5cdFx0ICAgIGNlbnRlck9mZnNldCA9IGNvbnRhaW5lclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKS5tdWx0aXBseUJ5KDEgLSAxIC8gc2NhbGUpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xhdExuZyh2aWV3SGFsZi5hZGQoY2VudGVyT2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhuZXdDZW50ZXIsIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0X2dldEJvdW5kc0NlbnRlclpvb206IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdGJvdW5kcyA9IGJvdW5kcy5nZXRCb3VuZHMgPyBib3VuZHMuZ2V0Qm91bmRzKCkgOiB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBwYWRkaW5nVEwgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHJcblx0XHQgICAgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMsIGZhbHNlLCBwYWRkaW5nVEwuYWRkKHBhZGRpbmdCUikpO1xyXG5cclxuXHRcdHpvb20gPSAodHlwZW9mIG9wdGlvbnMubWF4Wm9vbSA9PT0gJ251bWJlcicpID8gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCB6b29tKSA6IHpvb207XHJcblxyXG5cdFx0aWYgKHpvb20gPT09IEluZmluaXR5KSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0Y2VudGVyOiBib3VuZHMuZ2V0Q2VudGVyKCksXHJcblx0XHRcdFx0em9vbTogem9vbVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwYWRkaW5nT2Zmc2V0ID0gcGFkZGluZ0JSLnN1YnRyYWN0KHBhZGRpbmdUTCkuZGl2aWRlQnkoMiksXHJcblxyXG5cdFx0ICAgIHN3UG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKSxcclxuXHRcdCAgICBuZVBvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgY2VudGVyID0gdGhpcy51bnByb2plY3Qoc3dQb2ludC5hZGQobmVQb2ludCkuZGl2aWRlQnkoMikuYWRkKHBhZGRpbmdPZmZzZXQpLCB6b29tKTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0em9vbTogem9vbVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IGNvbnRhaW5zIHRoZSBnaXZlbiBnZW9ncmFwaGljYWwgYm91bmRzIHdpdGggdGhlXHJcblx0Ly8gbWF4aW11bSB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignQm91bmRzIGFyZSBub3QgdmFsaWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZml0V29ybGQob3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IG1vc3RseSBjb250YWlucyB0aGUgd2hvbGUgd29ybGQgd2l0aCB0aGUgbWF4aW11bVxyXG5cdC8vIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcblx0Zml0V29ybGQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5maXRCb3VuZHMoW1stOTAsIC0xODBdLCBbOTAsIDE4MF1dLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhblRvKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRvIGEgZ2l2ZW4gY2VudGVyLlxyXG5cdHBhblRvOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7IC8vIChMYXRMbmcpXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KGNlbnRlciwgdGhpcy5fem9vbSwge3Bhbjogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuQnkob2Zmc2V0OiBQb2ludCwgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCBieSBhIGdpdmVuIG51bWJlciBvZiBwaXhlbHMgKGFuaW1hdGVkKS5cclxuXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCwgb3B0aW9ucykge1xyXG5cdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLnJvdW5kKCk7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHR9XHJcblx0XHQvLyBJZiB3ZSBwYW4gdG9vIGZhciwgQ2hyb21lIGdldHMgaXNzdWVzIHdpdGggdGlsZXNcclxuXHRcdC8vIGFuZCBtYWtlcyB0aGVtIGRpc2FwcGVhciBvciBhcHBlYXIgaW4gdGhlIHdyb25nIHBsYWNlIChzbGlnaHRseSBvZmZzZXQpICMyNjAyXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLnVucHJvamVjdCh0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSkuYWRkKG9mZnNldCkpLCB0aGlzLmdldFpvb20oKSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fcGFuQW5pbSkge1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltID0gbmV3IFBvc0FuaW1hdGlvbigpO1xyXG5cclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5vbih7XHJcblx0XHRcdFx0J3N0ZXAnOiB0aGlzLl9vblBhblRyYW5zaXRpb25TdGVwLFxyXG5cdFx0XHRcdCdlbmQnOiB0aGlzLl9vblBhblRyYW5zaXRpb25FbmRcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZG9uJ3QgZmlyZSBtb3Zlc3RhcnQgaWYgYW5pbWF0aW5nIGluZXJ0aWFcclxuXHRcdGlmICghb3B0aW9ucy5ub01vdmVTdGFydCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFuaW1hdGUgcGFuIHVubGVzcyBhbmltYXRlOiBmYWxzZSBzcGVjaWZpZWRcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlKSB7XHJcblx0XHRcdGFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblxyXG5cdFx0XHR2YXIgbmV3UG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5ydW4odGhpcy5fbWFwUGFuZSwgbmV3UG9zLCBvcHRpb25zLmR1cmF0aW9uIHx8IDAuMjUsIG9wdGlvbnMuZWFzZUxpbmVhcml0eSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKS5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUbyhsYXRsbmc6IExhdExuZywgem9vbT86IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSBwZXJmb3JtaW5nIGEgc21vb3RoXHJcblx0Ly8gcGFuLXpvb20gYW5pbWF0aW9uLlxyXG5cdGZseVRvOiBmdW5jdGlvbiAodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCAhYW55M2QpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHR2YXIgZnJvbSA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcclxuXHRcdCAgICB0byA9IHRoaXMucHJvamVjdCh0YXJnZXRDZW50ZXIpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBzdGFydFpvb20gPSB0aGlzLl96b29tO1xyXG5cclxuXHRcdHRhcmdldENlbnRlciA9IHRvTGF0TG5nKHRhcmdldENlbnRlcik7XHJcblx0XHR0YXJnZXRab29tID0gdGFyZ2V0Wm9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogdGFyZ2V0Wm9vbTtcclxuXHJcblx0XHR2YXIgdzAgPSBNYXRoLm1heChzaXplLngsIHNpemUueSksXHJcblx0XHQgICAgdzEgPSB3MCAqIHRoaXMuZ2V0Wm9vbVNjYWxlKHN0YXJ0Wm9vbSwgdGFyZ2V0Wm9vbSksXHJcblx0XHQgICAgdTEgPSAodG8uZGlzdGFuY2VUbyhmcm9tKSkgfHwgMSxcclxuXHRcdCAgICByaG8gPSAxLjQyLFxyXG5cdFx0ICAgIHJobzIgPSByaG8gKiByaG87XHJcblxyXG5cdFx0ZnVuY3Rpb24gcihpKSB7XHJcblx0XHRcdHZhciBzMSA9IGkgPyAtMSA6IDEsXHJcblx0XHRcdCAgICBzMiA9IGkgPyB3MSA6IHcwLFxyXG5cdFx0XHQgICAgdDEgPSB3MSAqIHcxIC0gdzAgKiB3MCArIHMxICogcmhvMiAqIHJobzIgKiB1MSAqIHUxLFxyXG5cdFx0XHQgICAgYjEgPSAyICogczIgKiByaG8yICogdTEsXHJcblx0XHRcdCAgICBiID0gdDEgLyBiMSxcclxuXHRcdFx0ICAgIHNxID0gTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiO1xyXG5cclxuXHRcdFx0ICAgIC8vIHdvcmthcm91bmQgZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBidWcgd2hlbiBzcSA9IDAsIGxvZyA9IC1JbmZpbml0ZSxcclxuXHRcdFx0ICAgIC8vIHRodXMgdHJpZ2dlcmluZyBhbiBpbmZpbml0ZSBsb29wIGluIGZseVRvXHJcblx0XHRcdCAgICB2YXIgbG9nID0gc3EgPCAwLjAwMDAwMDAwMSA/IC0xOCA6IE1hdGgubG9nKHNxKTtcclxuXHJcblx0XHRcdHJldHVybiBsb2c7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2luaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gdGFuaChuKSB7IHJldHVybiBzaW5oKG4pIC8gY29zaChuKTsgfVxyXG5cclxuXHRcdHZhciByMCA9IHIoMCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gdyhzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7IH1cclxuXHRcdGZ1bmN0aW9uIHUocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yOyB9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZWFzZU91dCh0KSB7IHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIDEuNSk7IH1cclxuXHJcblx0XHR2YXIgc3RhcnQgPSBEYXRlLm5vdygpLFxyXG5cdFx0ICAgIFMgPSAocigxKSAtIHIwKSAvIHJobyxcclxuXHRcdCAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPyAxMDAwICogb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDAgKiBTICogMC44O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGZyYW1lKCkge1xyXG5cdFx0XHR2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24sXHJcblx0XHRcdCAgICBzID0gZWFzZU91dCh0KSAqIFM7XHJcblxyXG5cdFx0XHRpZiAodCA8PSAxKSB7XHJcblx0XHRcdFx0dGhpcy5fZmx5VG9GcmFtZSA9IHJlcXVlc3RBbmltRnJhbWUoZnJhbWUsIHRoaXMpO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9tb3ZlKFxyXG5cdFx0XHRcdFx0dGhpcy51bnByb2plY3QoZnJvbS5hZGQodG8uc3VidHJhY3QoZnJvbSkubXVsdGlwbHlCeSh1KHMpIC8gdTEpKSwgc3RhcnRab29tKSxcclxuXHRcdFx0XHRcdHRoaXMuZ2V0U2NhbGVab29tKHcwIC8gdyhzKSwgc3RhcnRab29tKSxcclxuXHRcdFx0XHRcdHtmbHlUbzogdHJ1ZX0pO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzXHJcblx0XHRcdFx0XHQuX21vdmUodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tKVxyXG5cdFx0XHRcdFx0Ll9tb3ZlRW5kKHRydWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbW92ZVN0YXJ0KHRydWUsIG9wdGlvbnMubm9Nb3ZlU3RhcnQpO1xyXG5cclxuXHRcdGZyYW1lLmNhbGwodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZseVRvQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIHdpdGggYSBzbW9vdGggYW5pbWF0aW9uIGxpa2UgW2BmbHlUb2BdKCNtYXAtZmx5dG8pLFxyXG5cdC8vIGJ1dCB0YWtlcyBhIGJvdW5kcyBwYXJhbWV0ZXIgbGlrZSBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuXHRmbHlUb0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcclxuXHRcdHJldHVybiB0aGlzLmZseVRvKHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heEJvdW5kcyhib3VuZHM6IEJvdW5kcyk6IHRoaXNcclxuXHQvLyBSZXN0cmljdHMgdGhlIG1hcCB2aWV3IHRvIHRoZSBnaXZlbiBib3VuZHMgKHNlZSB0aGUgW21heEJvdW5kc10oI21hcC1tYXhib3VuZHMpIG9wdGlvbikuXHJcblx0c2V0TWF4Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gbnVsbDtcclxuXHRcdFx0cmV0dXJuIHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLm1heEJvdW5kcykge1xyXG5cdFx0XHR0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IGJvdW5kcztcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm9uKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1pblpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGxvd2VyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttaW5ab29tXSgjbWFwLW1pbnpvb20pIG9wdGlvbikuXHJcblx0c2V0TWluWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1pblpvb207XHJcblx0XHR0aGlzLm9wdGlvbnMubWluWm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB1cHBlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWF4Wm9vbV0oI21hcC1tYXh6b29tKSBvcHRpb24pLlxyXG5cdHNldE1heFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG5cdFx0dGhpcy5vcHRpb25zLm1heFpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmdldFpvb20oKSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuSW5zaWRlQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRvIHRoZSBjbG9zZXN0IHZpZXcgdGhhdCB3b3VsZCBsaWUgaW5zaWRlIHRoZSBnaXZlbiBib3VuZHMgKGlmIGl0J3Mgbm90IGFscmVhZHkpLCBjb250cm9sbGluZyB0aGUgYW5pbWF0aW9uIHVzaW5nIHRoZSBvcHRpb25zIHNwZWNpZmljLCBpZiBhbnkuXHJcblx0cGFuSW5zaWRlQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG5cdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoY2VudGVyLCB0aGlzLl96b29tLCB0b0xhdExuZ0JvdW5kcyhib3VuZHMpKTtcclxuXHJcblx0XHRpZiAoIWNlbnRlci5lcXVhbHMobmV3Q2VudGVyKSkge1xyXG5cdFx0XHR0aGlzLnBhblRvKG5ld0NlbnRlciwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkluc2lkZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRoZSBtaW5pbXVtIGFtb3VudCB0byBtYWtlIHRoZSBgbGF0bG5nYCB2aXNpYmxlLiBVc2VcclxuXHQvLyBgcGFkZGluZ2AsIGBwYWRkaW5nVG9wTGVmdGAgYW5kIGBwYWRkaW5nVG9wUmlnaHRgIG9wdGlvbnMgdG8gZml0XHJcblx0Ly8gdGhlIGRpc3BsYXkgdG8gbW9yZSByZXN0cmljdGVkIGJvdW5kcywgbGlrZSBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuXHQvLyBJZiBgbGF0bG5nYCBpcyBhbHJlYWR5IHdpdGhpbiB0aGUgKG9wdGlvbmFsbHkgcGFkZGVkKSBkaXNwbGF5IGJvdW5kcyxcclxuXHQvLyB0aGUgbWFwIHdpbGwgbm90IGJlIHBhbm5lZC5cclxuXHRwYW5JbnNpZGU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdHZhciBwYWRkaW5nVEwgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIHBpeGVsQ2VudGVyID0gdGhpcy5wcm9qZWN0KGNlbnRlciksXHJcblx0XHQgICAgcGl4ZWxQb2ludCA9IHRoaXMucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHBpeGVsQm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIGhhbGZQaXhlbEJvdW5kcyA9IHBpeGVsQm91bmRzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICBwYWRkZWRCb3VuZHMgPSB0b0JvdW5kcyhbcGl4ZWxCb3VuZHMubWluLmFkZChwYWRkaW5nVEwpLCBwaXhlbEJvdW5kcy5tYXguc3VidHJhY3QocGFkZGluZ0JSKV0pO1xyXG5cclxuXHRcdGlmICghcGFkZGVkQm91bmRzLmNvbnRhaW5zKHBpeGVsUG9pbnQpKSB7XHJcblx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHRcdHZhciBkaWZmID0gcGl4ZWxDZW50ZXIuc3VidHJhY3QocGl4ZWxQb2ludCksXHJcblx0XHRcdCAgICBuZXdDZW50ZXIgPSB0b1BvaW50KHBpeGVsUG9pbnQueCArIGRpZmYueCwgcGl4ZWxQb2ludC55ICsgZGlmZi55KTtcclxuXHJcblx0XHRcdGlmIChwaXhlbFBvaW50LnggPCBwYWRkZWRCb3VuZHMubWluLnggfHwgcGl4ZWxQb2ludC54ID4gcGFkZGVkQm91bmRzLm1heC54KSB7XHJcblx0XHRcdFx0bmV3Q2VudGVyLnggPSBwaXhlbENlbnRlci54IC0gZGlmZi54O1xyXG5cdFx0XHRcdGlmIChkaWZmLnggPiAwKSB7XHJcblx0XHRcdFx0XHRuZXdDZW50ZXIueCArPSBoYWxmUGl4ZWxCb3VuZHMueCAtIHBhZGRpbmdUTC54O1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRuZXdDZW50ZXIueCAtPSBoYWxmUGl4ZWxCb3VuZHMueCAtIHBhZGRpbmdCUi54O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAocGl4ZWxQb2ludC55IDwgcGFkZGVkQm91bmRzLm1pbi55IHx8IHBpeGVsUG9pbnQueSA+IHBhZGRlZEJvdW5kcy5tYXgueSkge1xyXG5cdFx0XHRcdG5ld0NlbnRlci55ID0gcGl4ZWxDZW50ZXIueSAtIGRpZmYueTtcclxuXHRcdFx0XHRpZiAoZGlmZi55ID4gMCkge1xyXG5cdFx0XHRcdFx0bmV3Q2VudGVyLnkgKz0gaGFsZlBpeGVsQm91bmRzLnkgLSBwYWRkaW5nVEwueTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bmV3Q2VudGVyLnkgLT0gaGFsZlBpeGVsQm91bmRzLnkgLSBwYWRkaW5nQlIueTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5wYW5Ubyh0aGlzLnVucHJvamVjdChuZXdDZW50ZXIpLCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKG9wdGlvbnM6IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LiBJZiBgb3B0aW9ucy5wYW5gIGlzIGBmYWxzZWAsIHBhbm5pbmcgd2lsbCBub3Qgb2NjdXIuXHJcblx0Ly8gSWYgYG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kYCBpcyBgdHJ1ZWAsIGl0IHdpbGwgZGVsYXkgYG1vdmVlbmRgIGV2ZW50IHNvXHJcblx0Ly8gdGhhdCBpdCBkb2Vzbid0IGhhcHBlbiBvZnRlbiBldmVuIGlmIHRoZSBtZXRob2QgaXMgY2FsbGVkIG1hbnlcclxuXHQvLyB0aW1lcyBpbiBhIHJvdy5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShhbmltYXRlOiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuXHQvLyBwYW4gYnkgZGVmYXVsdC5cclxuXHRpbnZhbGlkYXRlU2l6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IGV4dGVuZCh7XHJcblx0XHRcdGFuaW1hdGU6IGZhbHNlLFxyXG5cdFx0XHRwYW46IHRydWVcclxuXHRcdH0sIG9wdGlvbnMgPT09IHRydWUgPyB7YW5pbWF0ZTogdHJ1ZX0gOiBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgb2xkU2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5fbGFzdENlbnRlciA9IG51bGw7XHJcblxyXG5cdFx0dmFyIG5ld1NpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBvbGRDZW50ZXIgPSBvbGRTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gbmV3U2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG9sZENlbnRlci5zdWJ0cmFjdChuZXdDZW50ZXIpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAmJiBvcHRpb25zLnBhbikge1xyXG5cdFx0XHR0aGlzLnBhbkJ5KG9mZnNldCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5kZWJvdW5jZU1vdmVlbmQpIHtcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHR0aGlzLl9zaXplVGltZXIgPSBzZXRUaW1lb3V0KGJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdC8vIEBldmVudCByZXNpemU6IFJlc2l6ZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGBwYW5Ub2Agb3IgYGZseVRvYCBhbmltYXRpb24sIGlmIGFueS5cclxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnNldFpvb20odGhpcy5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEdlb2xvY2F0aW9uIG1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGxvY2F0ZShvcHRpb25zPzogTG9jYXRlIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gVHJpZXMgdG8gbG9jYXRlIHRoZSB1c2VyIHVzaW5nIHRoZSBHZW9sb2NhdGlvbiBBUEksIGZpcmluZyBhIFtgbG9jYXRpb25mb3VuZGBdKCNtYXAtbG9jYXRpb25mb3VuZClcclxuXHQvLyBldmVudCB3aXRoIGxvY2F0aW9uIGRhdGEgb24gc3VjY2VzcyBvciBhIFtgbG9jYXRpb25lcnJvcmBdKCNtYXAtbG9jYXRpb25lcnJvcikgZXZlbnQgb24gZmFpbHVyZSxcclxuXHQvLyBhbmQgb3B0aW9uYWxseSBzZXRzIHRoZSBtYXAgdmlldyB0byB0aGUgdXNlcidzIGxvY2F0aW9uIHdpdGggcmVzcGVjdCB0b1xyXG5cdC8vIGRldGVjdGlvbiBhY2N1cmFjeSAob3IgdG8gdGhlIHdvcmxkIHZpZXcgaWYgZ2VvbG9jYXRpb24gZmFpbGVkKS5cclxuXHQvLyBOb3RlIHRoYXQsIGlmIHlvdXIgcGFnZSBkb2Vzbid0IHVzZSBIVFRQUywgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIGluXHJcblx0Ly8gbW9kZXJuIGJyb3dzZXJzIChbQ2hyb21lIDUwIGFuZCBuZXdlcl0oaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2Rldi9Ib21lL2Nocm9taXVtLXNlY3VyaXR5L2RlcHJlY2F0aW5nLXBvd2VyZnVsLWZlYXR1cmVzLW9uLWluc2VjdXJlLW9yaWdpbnMpKVxyXG5cdC8vIFNlZSBgTG9jYXRlIG9wdGlvbnNgIGZvciBtb3JlIGRldGFpbHMuXHJcblx0bG9jYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zID0gZXh0ZW5kKHtcclxuXHRcdFx0dGltZW91dDogMTAwMDAsXHJcblx0XHRcdHdhdGNoOiBmYWxzZVxyXG5cdFx0XHQvLyBzZXRWaWV3OiBmYWxzZVxyXG5cdFx0XHQvLyBtYXhab29tOiA8TnVtYmVyPlxyXG5cdFx0XHQvLyBtYXhpbXVtQWdlOiAwXHJcblx0XHRcdC8vIGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2VcclxuXHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdGlmICghKCdnZW9sb2NhdGlvbicgaW4gbmF2aWdhdG9yKSkge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtcclxuXHRcdFx0XHRjb2RlOiAwLFxyXG5cdFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkLidcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvblJlc3BvbnNlID0gYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlLCB0aGlzKSxcclxuXHRcdCAgICBvbkVycm9yID0gYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG5cdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3RvcExvY2F0ZSgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcblx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcblx0Ly8gYHtzZXRWaWV3OiB0cnVlfWAuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZXJyb3I6IEVycm9yRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMYXRMbmcobGF0LCBsbmcpLFxyXG5cdFx0ICAgIGJvdW5kcyA9IGxhdGxuZy50b0JvdW5kcyhwb3MuY29vcmRzLmFjY3VyYWN5ICogMiksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG5cdFx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpO1xyXG5cdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCBvcHRpb25zLm1heFpvb20gPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heFpvb20pIDogem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuXHRcdFx0dGltZXN0YW1wOiBwb3MudGltZXN0YW1wXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG5cdFx0XHRpZiAodHlwZW9mIHBvcy5jb29yZHNbaV0gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdFx0ZGF0YVtpXSA9IHBvcy5jb29yZHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25mb3VuZDogTG9jYXRpb25FdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZClcclxuXHRcdC8vIHdlbnQgc3VjY2Vzc2Z1bGx5LlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmZvdW5kJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETyBBcHByb3ByaWF0ZSBkb2NzIHNlY3Rpb24/XHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgYWRkSGFuZGxlcihuYW1lOiBTdHJpbmcsIEhhbmRsZXJDbGFzczogRnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gQWRkcyBhIG5ldyBgSGFuZGxlcmAgdG8gdGhlIG1hcCwgZ2l2ZW4gaXRzIG5hbWUgYW5kIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG5cdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIChuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcclxuXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuXHRcdFx0aGFuZGxlci5lbmFibGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZSgpOiB0aGlzXHJcblx0Ly8gRGVzdHJveXMgdGhlIG1hcCBhbmQgY2xlYXJzIGFsbCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jb250YWluZXJJZCAhPT0gdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBiZWluZyByZXVzZWQgYnkgYW5vdGhlciBpbnN0YW5jZScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIHRocm93cyBlcnJvciBpbiBJRTYtOFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkO1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVySWQ7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkID0gdW5kZWZpbmVkO1xyXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlICovXHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lcklkID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9sb2NhdGlvbldhdGNoSWQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnN0b3BMb2NhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0cmVtb3ZlKHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jbGVhckNvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5fY2xlYXJDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fcmVzaXplUmVxdWVzdCkge1xyXG5cdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCB1bmxvYWQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ucmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fcGFuZXMpIHtcclxuXHRcdFx0cmVtb3ZlKHRoaXMuX3BhbmVzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX3BhbmVzID0gW107XHJcblx0XHRkZWxldGUgdGhpcy5fbWFwUGFuZTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9yZW5kZXJlcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVQYW5lKG5hbWU6IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENyZWF0ZXMgYSBuZXcgW21hcCBwYW5lXSgjbWFwLXBhbmUpIHdpdGggdGhlIGdpdmVuIG5hbWUgaWYgaXQgZG9lc24ndCBleGlzdCBhbHJlYWR5LFxyXG5cdC8vIHRoZW4gcmV0dXJucyBpdC4gVGhlIHBhbmUgaXMgY3JlYXRlZCBhcyBhIGNoaWxkIG9mIGBjb250YWluZXJgLCBvclxyXG5cdC8vIGFzIGEgY2hpbGQgb2YgdGhlIG1haW4gbWFwIHBhbmUgaWYgbm90IHNldC5cclxuXHRjcmVhdGVQYW5lOiBmdW5jdGlvbiAobmFtZSwgY29udGFpbmVyKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtcGFuZScgKyAobmFtZSA/ICcgbGVhZmxldC0nICsgbmFtZS5yZXBsYWNlKCdQYW5lJywgJycpICsgJy1wYW5lJyA6ICcnKSxcclxuXHRcdCAgICBwYW5lID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyIHx8IHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmIChuYW1lKSB7XHJcblx0XHRcdHRoaXMuX3BhbmVzW25hbWVdID0gcGFuZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIEdldHRpbmcgTWFwIFN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBjZW50ZXIgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RDZW50ZXIgJiYgIXRoaXMuX21vdmVkKCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2xhc3RDZW50ZXI7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXAgdmlld1xyXG5cdGdldFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl96b29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgdmlzaWJsZSBpbiB0aGUgY3VycmVudCBtYXAgdmlld1xyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBzdyA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRCb3R0b21MZWZ0KCkpLFxyXG5cdFx0ICAgIG5lID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldFRvcFJpZ2h0KCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKHN3LCBuZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNaW5ab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtaW5ab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKSwgb3IgYDBgIGJ5IGRlZmF1bHQuXHJcblx0Z2V0TWluWm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9sYXllcnNNaW5ab29tIHx8IDAgOiB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1heFpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1heFpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLlxyXG5cdGdldE1heFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID9cclxuXHRcdFx0KHRoaXMuX2xheWVyc01heFpvb20gPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogdGhpcy5fbGF5ZXJzTWF4Wm9vbSkgOlxyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kc1pvb20oYm91bmRzOiBMYXRMbmdCb3VuZHMsIGluc2lkZT86IEJvb2xlYW4sIHBhZGRpbmc/OiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgZ2l2ZW4gYm91bmRzIGZpdCB0byB0aGUgbWFwXHJcblx0Ly8gdmlldyBpbiBpdHMgZW50aXJldHkuIElmIGBpbnNpZGVgIChvcHRpb25hbCkgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG1ldGhvZFxyXG5cdC8vIGluc3RlYWQgcmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBtYXAgdmlldyBmaXRzIGludG9cclxuXHQvLyB0aGUgZ2l2ZW4gYm91bmRzIGluIGl0cyBlbnRpcmV0eS5cclxuXHRnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHsgLy8gKExhdExuZ0JvdW5kc1ssIEJvb2xlYW4sIFBvaW50XSkgLT4gTnVtYmVyXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cdFx0cGFkZGluZyA9IHRvUG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuXHRcdHZhciB6b29tID0gdGhpcy5nZXRab29tKCkgfHwgMCxcclxuXHRcdCAgICBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdCAgICBzZSA9IGJvdW5kcy5nZXRTb3V0aEVhc3QoKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCkuc3VidHJhY3QocGFkZGluZyksXHJcblx0XHQgICAgYm91bmRzU2l6ZSA9IHRvQm91bmRzKHRoaXMucHJvamVjdChzZSwgem9vbSksIHRoaXMucHJvamVjdChudywgem9vbSkpLmdldFNpemUoKSxcclxuXHRcdCAgICBzbmFwID0gYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxLFxyXG5cdFx0ICAgIHNjYWxleCA9IHNpemUueCAvIGJvdW5kc1NpemUueCxcclxuXHRcdCAgICBzY2FsZXkgPSBzaXplLnkgLyBib3VuZHNTaXplLnksXHJcblx0XHQgICAgc2NhbGUgPSBpbnNpZGUgPyBNYXRoLm1heChzY2FsZXgsIHNjYWxleSkgOiBNYXRoLm1pbihzY2FsZXgsIHNjYWxleSk7XHJcblxyXG5cdFx0em9vbSA9IHRoaXMuZ2V0U2NhbGVab29tKHNjYWxlLCB6b29tKTtcclxuXHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gKHNuYXAgLyAxMDApKSAqIChzbmFwIC8gMTAwKTsgLy8gZG9uJ3QganVtcCBpZiB3aXRoaW4gMSUgb2YgYSBzbmFwIGxldmVsXHJcblx0XHRcdHpvb20gPSBpbnNpZGUgPyBNYXRoLmNlaWwoem9vbSAvIHNuYXApICogc25hcCA6IE1hdGguZmxvb3Ioem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIG1hcCBjb250YWluZXIgKGluIHBpeGVscykuXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9zaXplIHx8IHRoaXMuX3NpemVDaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuX3NpemUgPSBuZXcgUG9pbnQoXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIHx8IDAsXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCAwKTtcclxuXHJcblx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS5jbG9uZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxCb3VuZHMoKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IG1hcCB2aWV3IGluIHByb2plY3RlZCBwaXhlbFxyXG5cdC8vIGNvb3JkaW5hdGVzIChzb21ldGltZXMgdXNlZnVsIGluIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB0b3BMZWZ0UG9pbnQgPSB0aGlzLl9nZXRUb3BMZWZ0UG9pbnQoY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiBuZXcgQm91bmRzKHRvcExlZnRQb2ludCwgdG9wTGVmdFBvaW50LmFkZCh0aGlzLmdldFNpemUoKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE86IENoZWNrIHNlbWFudGljcyAtIGlzbid0IHRoZSBwaXhlbCBvcmlnaW4gdGhlIDAsMCBjb29yZCByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBtYXAgcGFuZT8gXCJsZWZ0IHBvaW50IG9mIHRoZSBtYXAgbGF5ZXJcIiBjYW4gYmUgY29uZnVzaW5nLCBzcGVjaWFsbHlcclxuXHQvLyBzaW5jZSB0aGVyZSBjYW4gYmUgbmVnYXRpdmUgb2Zmc2V0cy5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsT3JpZ2luKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGVkIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBwb2ludCBvZlxyXG5cdC8vIHRoZSBtYXAgbGF5ZXIgKHVzZWZ1bCBpbiBjdXN0b20gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbE9yaWdpbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsT3JpZ2luO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxXb3JsZEJvdW5kcyh6b29tPzogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgd29ybGQncyBib3VuZHMgaW4gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIHpvb20gbGV2ZWwgYHpvb21gLlxyXG5cdC8vIElmIGB6b29tYCBpcyBvbWl0dGVkLCB0aGUgbWFwJ3MgY3VycmVudCB6b29tIGxldmVsIGlzIHVzZWQuXHJcblx0Z2V0UGl4ZWxXb3JsZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmdldFByb2plY3RlZEJvdW5kcyh6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lKHBhbmU6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyBhIFttYXAgcGFuZV0oI21hcC1wYW5lKSwgZ2l2ZW4gaXRzIG5hbWUgb3IgaXRzIEhUTUwgZWxlbWVudCAoaXRzIGlkZW50aXR5KS5cclxuXHRnZXRQYW5lOiBmdW5jdGlvbiAocGFuZSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBwYW5lID09PSAnc3RyaW5nJyA/IHRoaXMuX3BhbmVzW3BhbmVdIDogcGFuZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmVzKCk6IE9iamVjdFxyXG5cdC8vIFJldHVybnMgYSBwbGFpbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIFtwYW5lc10oI21hcC1wYW5lKSBhcyBrZXlzIGFuZFxyXG5cdC8vIHRoZSBwYW5lcyBhcyB2YWx1ZXMuXHJcblx0Z2V0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wYW5lcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgbWFwLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gQ29udmVyc2lvbiBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbVNjYWxlKHRvWm9vbTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgZmFjdG9yIHRvIGJlIGFwcGxpZWQgdG8gYSBtYXAgdHJhbnNpdGlvbiBmcm9tIHpvb20gbGV2ZWxcclxuXHQvLyBgZnJvbVpvb21gIHRvIGB0b1pvb21gLiBVc2VkIGludGVybmFsbHkgdG8gaGVscCB3aXRoIHpvb20gYW5pbWF0aW9ucy5cclxuXHRnZXRab29tU2NhbGU6IGZ1bmN0aW9uICh0b1pvb20sIGZyb21ab29tKSB7XHJcblx0XHQvLyBUT0RPIHJlcGxhY2Ugd2l0aCB1bml2ZXJzYWwgaW1wbGVtZW50YXRpb24gYWZ0ZXIgcmVmYWN0b3JpbmcgcHJvamVjdGlvbnNcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0cmV0dXJuIGNycy5zY2FsZSh0b1pvb20pIC8gY3JzLnNjYWxlKGZyb21ab29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNjYWxlWm9vbShzY2FsZTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgem9vbSBsZXZlbCB0aGF0IHRoZSBtYXAgd291bGQgZW5kIHVwIGF0LCBpZiBpdCBpcyBhdCBgZnJvbVpvb21gXHJcblx0Ly8gbGV2ZWwgYW5kIGV2ZXJ5dGhpbmcgaXMgc2NhbGVkIGJ5IGEgZmFjdG9yIG9mIGBzY2FsZWAuIEludmVyc2Ugb2ZcclxuXHQvLyBbYGdldFpvb21TY2FsZWBdKCNtYXAtZ2V0Wm9vbVNjYWxlKS5cclxuXHRnZXRTY2FsZVpvb206IGZ1bmN0aW9uIChzY2FsZSwgZnJvbVpvb20pIHtcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0dmFyIHpvb20gPSBjcnMuem9vbShzY2FsZSAqIGNycy5zY2FsZShmcm9tWm9vbSkpO1xyXG5cdFx0cmV0dXJuIGlzTmFOKHpvb20pID8gSW5maW5pdHkgOiB6b29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIGBMYXRMbmdgIGFjY29yZGluZyB0byB0aGUgcHJvamVjdGlvblxyXG5cdC8vIG9mIHRoZSBtYXAncyBDUlMsIHRoZW4gc2NhbGVzIGl0IGFjY29yZGluZyB0byBgem9vbWAgYW5kIHRoZSBDUlMnc1xyXG5cdC8vIGBUcmFuc2Zvcm1hdGlvbmAuIFRoZSByZXN1bHQgaXMgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBDUlMgb3JpZ2luLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmxhdExuZ1RvUG9pbnQodG9MYXRMbmcobGF0bG5nKSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBJbnZlcnNlIG9mIFtgcHJvamVjdGBdKCNtYXAtcHJvamVjdCkuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLnBvaW50VG9MYXRMbmcodG9Qb2ludChwb2ludCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGxheWVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChwcm9qZWN0ZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRsYXRMbmdUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdCh0b0xhdExuZyhsYXRsbmcpKS5fcm91bmQoKTtcclxuXHRcdHJldHVybiBwcm9qZWN0ZWRQb2ludC5fc3VidHJhY3QodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgYGxhdGAgYW5kIGBsbmdgIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG5cdC8vIG1hcCdzIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlXHJcblx0Ly8gQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG5cdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmcodG9MYXRMbmcobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZyB0aGF0XHJcblx0Ly8gaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgdGhlIGNlbnRlciBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG5cdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLCBhbmQgdGhlIG1ham9yaXR5IG9mIHRoZSBib3VuZHNcclxuXHQvLyBvdmVybGFwcyB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmdCb3VuZHModG9MYXRMbmdCb3VuZHMobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG9cclxuXHQvLyB0aGUgbWFwJ3MgQ1JTLiBCeSBkZWZhdWx0IHRoaXMgbWVhc3VyZXMgZGlzdGFuY2UgaW4gbWV0ZXJzLlxyXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZGlzdGFuY2UodG9MYXRMbmcobGF0bG5nMSksIHRvTGF0TG5nKGxhdGxuZzIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJuc1xyXG5cdC8vIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodG9Qb2ludChwb2ludCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF0TG5nVG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQodG9MYXRMbmcobGF0bG5nKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlXHJcblx0Ly8gbWFwIGNvbnRhaW5lciB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBnZXRNb3VzZVBvc2l0aW9uKGUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXllclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xhdExuZyhldjogTW91c2VFdmVudCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgd2hlcmUgdGhlXHJcblx0Ly8gZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXRMbmc6IGZ1bmN0aW9uIChlKSB7IC8vIChNb3VzZUV2ZW50KVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIG1hcCBpbml0aWFsaXphdGlvbiBtZXRob2RzXHJcblxyXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBnZXQoaWQpO1xyXG5cclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBub3QgZm91bmQuJyk7XHJcblx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHRvbihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgdGhpcyk7XHJcblx0XHR0aGlzLl9jb250YWluZXJJZCA9IHN0YW1wKGNvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcblxyXG5cdFx0dGhpcy5fZmFkZUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gJiYgYW55M2Q7XHJcblxyXG5cdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250YWluZXInICtcclxuXHRcdFx0KHRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcblx0XHRcdChyZXRpbmEgPyAnIGxlYWZsZXQtcmV0aW5hJyA6ICcnKSArXHJcblx0XHRcdChpZWx0OSA/ICcgbGVhZmxldC1vbGRpZScgOiAnJykgK1xyXG5cdFx0XHQoc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgK1xyXG5cdFx0XHQodGhpcy5fZmFkZUFuaW1hdGVkID8gJyBsZWFmbGV0LWZhZGUtYW5pbScgOiAnJykpO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IGdldFN0eWxlKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJyk7XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XHJcblx0XHRcdGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdFBhbmVzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2luaXRDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBhbmVzID0gdGhpcy5fcGFuZXMgPSB7fTtcclxuXHRcdHRoaXMuX3BhbmVSZW5kZXJlcnMgPSB7fTtcclxuXHJcblx0XHQvLyBAc2VjdGlvblxyXG5cdFx0Ly9cclxuXHRcdC8vIFBhbmVzIGFyZSBET00gZWxlbWVudHMgdXNlZCB0byBjb250cm9sIHRoZSBvcmRlcmluZyBvZiBsYXllcnMgb24gdGhlIG1hcC4gWW91XHJcblx0XHQvLyBjYW4gYWNjZXNzIHBhbmVzIHdpdGggW2BtYXAuZ2V0UGFuZWBdKCNtYXAtZ2V0cGFuZSkgb3JcclxuXHRcdC8vIFtgbWFwLmdldFBhbmVzYF0oI21hcC1nZXRwYW5lcykgbWV0aG9kcy4gTmV3IHBhbmVzIGNhbiBiZSBjcmVhdGVkIHdpdGggdGhlXHJcblx0XHQvLyBbYG1hcC5jcmVhdGVQYW5lYF0oI21hcC1jcmVhdGVwYW5lKSBtZXRob2QuXHJcblx0XHQvL1xyXG5cdFx0Ly8gRXZlcnkgbWFwIGhhcyB0aGUgZm9sbG93aW5nIGRlZmF1bHQgcGFuZXMgdGhhdCBkaWZmZXIgb25seSBpbiB6SW5kZXguXHJcblx0XHQvL1xyXG5cdFx0Ly8gQHBhbmUgbWFwUGFuZTogSFRNTEVsZW1lbnQgPSAnYXV0bydcclxuXHRcdC8vIFBhbmUgdGhhdCBjb250YWlucyBhbGwgb3RoZXIgbWFwIHBhbmVzXHJcblxyXG5cdFx0dGhpcy5fbWFwUGFuZSA9IHRoaXMuY3JlYXRlUGFuZSgnbWFwUGFuZScsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHRzZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdC8vIEBwYW5lIHRpbGVQYW5lOiBIVE1MRWxlbWVudCA9IDIwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEdyaWRMYXllcmBzIGFuZCBgVGlsZUxheWVyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndGlsZVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG92ZXJsYXlQYW5lOiBIVE1MRWxlbWVudCA9IDQwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgdmVjdG9ycyAoYFBhdGhgcywgbGlrZSBgUG9seWxpbmVgcyBhbmQgYFBvbHlnb25gcyksIGBJbWFnZU92ZXJsYXlgcyBhbmQgYFZpZGVvT3ZlcmxheWBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3NoYWRvd1BhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHNoYWRvd1BhbmU6IEhUTUxFbGVtZW50ID0gNTAwXHJcblx0XHQvLyBQYW5lIGZvciBvdmVybGF5IHNoYWRvd3MgKGUuZy4gYE1hcmtlcmAgc2hhZG93cylcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnb3ZlcmxheVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG1hcmtlclBhbmU6IEhUTUxFbGVtZW50ID0gNjAwXHJcblx0XHQvLyBQYW5lIGZvciBgSWNvbmBzIG9mIGBNYXJrZXJgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdtYXJrZXJQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSB0b29sdGlwUGFuZTogSFRNTEVsZW1lbnQgPSA2NTBcclxuXHRcdC8vIFBhbmUgZm9yIGBUb29sdGlwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3Rvb2x0aXBQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBwb3B1cFBhbmU6IEhUTUxFbGVtZW50ID0gNzAwXHJcblx0XHQvLyBQYW5lIGZvciBgUG9wdXBgcy5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgncG9wdXBQYW5lJyk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRhZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0YWRkQ2xhc3MocGFuZXMuc2hhZG93UGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyB0aGF0IG1vZGlmeSBtYXAgc3RhdGVcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHRzZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdHZhciBsb2FkaW5nID0gIXRoaXMuX2xvYWRlZDtcclxuXHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XHJcblx0XHR6b29tID0gdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgndmlld3ByZXJlc2V0Jyk7XHJcblxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuXHRcdHRoaXNcclxuXHRcdFx0Ll9tb3ZlU3RhcnQoem9vbUNoYW5nZWQsIGZhbHNlKVxyXG5cdFx0XHQuX21vdmUoY2VudGVyLCB6b29tKVxyXG5cdFx0XHQuX21vdmVFbmQoem9vbUNoYW5nZWQpO1xyXG5cclxuXHRcdC8vIEBldmVudCB2aWV3cmVzZXQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgbmVlZHMgdG8gcmVkcmF3IGl0cyBjb250ZW50ICh0aGlzIHVzdWFsbHkgaGFwcGVuc1xyXG5cdFx0Ly8gb24gbWFwIHpvb20gb3IgbG9hZCkuIFZlcnkgdXNlZnVsIGZvciBjcmVhdGluZyBjdXN0b20gb3ZlcmxheXMuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGluaXRpYWxpemVkICh3aGVuIGl0cyBjZW50ZXIgYW5kIHpvb20gYXJlIHNldFxyXG5cdFx0Ly8gZm9yIHRoZSBmaXJzdCB0aW1lKS5cclxuXHRcdGlmIChsb2FkaW5nKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9tb3ZlU3RhcnQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCwgbm9Nb3ZlU3RhcnQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgem9vbSBpcyBhYm91dCB0byBjaGFuZ2UgKGUuZy4gYmVmb3JlIHpvb20gYW5pbWF0aW9uKS5cclxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWV3IG9mIHRoZSBtYXAgc3RhcnRzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXApLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbXN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0XHRpZiAoIW5vTW92ZVN0YXJ0KSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfbW92ZTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgZGF0YSkge1xyXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuXHRcdH1cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblxyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gY2VudGVyO1xyXG5cdFx0dGhpcy5fcGl4ZWxPcmlnaW4gPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCB6b29tOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IGNoYW5nZSBpbiB6b29tIGxldmVsLCBpbmNsdWRpbmcgem9vbVxyXG5cdFx0Ly8gYW5kIGZseSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkIHx8IChkYXRhICYmIGRhdGEucGluY2gpKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBtb3ZlbWVudCBvZiB0aGUgbWFwLCBpbmNsdWRpbmcgcGFuIGFuZFxyXG5cdFx0Ly8gZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0X21vdmVFbmQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21lbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaGFzIGNoYW5nZWQsIGFmdGVyIGFueSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY2VudGVyIG9mIHRoZSBtYXAgc3RvcHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdG9wcGVkXHJcblx0XHQvLyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfc3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZseVRvRnJhbWUpO1xyXG5cdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5zdG9wKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmF3UGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdHNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbVNwYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldE1heFpvb20oKSAtIHRoaXMuZ2V0TWluWm9vbSgpO1xyXG5cdH0sXHJcblxyXG5cdF9wYW5JbnNpZGVNYXhCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5mb3JjaW5nQm91bmRzKSB7XHJcblx0XHRcdHRoaXMucGFuSW5zaWRlQm91bmRzKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jaGVja0lmTG9hZGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NldCBtYXAgY2VudGVyIGFuZCB6b29tIGZpcnN0LicpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIERPTSBldmVudCBoYW5kbGluZ1xyXG5cclxuXHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBldmVudHNcclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKHJlbW92ZSQkMSkge1xyXG5cdFx0dGhpcy5fdGFyZ2V0cyA9IHt9O1xyXG5cdFx0dGhpcy5fdGFyZ2V0c1tzdGFtcCh0aGlzLl9jb250YWluZXIpXSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlJCQxID8gb2ZmIDogb247XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAob3IgdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBkYmxjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIChvciBkb3VibGUtdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZWRvd246IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZXVwOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW92ZXI6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3V0OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW1vdmU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoaWxlIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgY29udGV4dG1lbnU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSByaWdodCBtb3VzZSBidXR0b24gb24gdGhlIG1hcCwgcHJldmVudHNcclxuXHRcdC8vIGRlZmF1bHQgYnJvd3NlciBjb250ZXh0IG1lbnUgZnJvbSBzaG93aW5nIGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMgb25cclxuXHRcdC8vIHRoaXMgZXZlbnQuIEFsc28gZmlyZWQgb24gbW9iaWxlIHdoZW4gdGhlIHVzZXIgaG9sZHMgYSBzaW5nbGUgdG91Y2hcclxuXHRcdC8vIGZvciBhIHNlY29uZCAoYWxzbyBjYWxsZWQgbG9uZyBwcmVzcykuXHJcblx0XHQvLyBAZXZlbnQga2V5cHJlc3M6IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB0aGF0IHByb2R1Y2VzIGEgY2hhcmFjdGVyIHZhbHVlIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuXHRcdC8vIEBldmVudCBrZXlkb3duOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLiBVbmxpa2UgdGhlIGBrZXlwcmVzc2AgZXZlbnQsXHJcblx0XHQvLyB0aGUgYGtleWRvd25gIGV2ZW50IGlzIGZpcmVkIGZvciBrZXlzIHRoYXQgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZSBhbmQgZm9yIGtleXNcclxuXHRcdC8vIHRoYXQgZG8gbm90IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUuXHJcblx0XHQvLyBAZXZlbnQga2V5dXA6IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG5cdFx0b25PZmYodGhpcy5fY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgJyArXHJcblx0XHRcdCdtb3VzZW92ZXIgbW91c2VvdXQgbW91c2Vtb3ZlIGNvbnRleHRtZW51IGtleXByZXNzIGtleWRvd24ga2V5dXAnLCB0aGlzLl9oYW5kbGVET01FdmVudCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSkge1xyXG5cdFx0XHRvbk9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGFueTNkICYmIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdChyZW1vdmUkJDEgPyB0aGlzLm9mZiA6IHRoaXMub24pLmNhbGwodGhpcywgJ21vdmVlbmQnLCB0aGlzLl9vbk1vdmVFbmQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUoXHJcblx0XHQgICAgICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5pbnZhbGlkYXRlU2l6ZSh7ZGVib3VuY2VNb3ZlZW5kOiB0cnVlfSk7IH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vblNjcm9sbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbFRvcCAgPSAwO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbExlZnQgPSAwO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyMDM4NzMgYnV0IFdlYmtpdCBhbHNvIGhhdmVcclxuXHRcdFx0Ly8gYSBwaXhlbCBvZmZzZXQgb24gdmVyeSBoaWdoIHZhbHVlcywgc2VlOiBodHRwOi8vanNmaWRkbGUubmV0L2RnNnI1aGhiL1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9maW5kRXZlbnRUYXJnZXRzOiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG5cdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuXHRcdCAgICB0YXJnZXQsXHJcblx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXHJcblx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG5cdFx0ICAgIGRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0d2hpbGUgKHNyYykge1xyXG5cdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW3N0YW1wKHNyYyldO1xyXG5cdFx0XHRpZiAodGFyZ2V0ICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdwcmVjbGljaycpICYmICFlLl9zaW11bGF0ZWQgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG5cdFx0XHRcdC8vIFByZXZlbnQgZmlyaW5nIGNsaWNrIGFmdGVyIHlvdSBqdXN0IGRyYWdnZWQgYW4gb2JqZWN0LlxyXG5cdFx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGFyZ2V0ICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIWlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG5cdFx0XHRcdHRhcmdldHMucHVzaCh0YXJnZXQpO1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHNyYyA9PT0gdGhpcy5fY29udGFpbmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdHNyYyA9IHNyYy5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiAhZHJhZ2dpbmcgJiYgIWlzSG92ZXIgJiYgaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7XHJcblx0XHRcdHRhcmdldHMgPSBbdGhpc107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBza2lwcGVkKGUpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciB0eXBlID0gZS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2Vkb3duJyB8fCB0eXBlID09PSAna2V5cHJlc3MnIHx8IHR5cGUgPT09ICdrZXl1cCcgfHwgdHlwZSA9PT0gJ2tleWRvd24nKSB7XHJcblx0XHRcdC8vIHByZXZlbnRzIG91dGxpbmUgd2hlbiBjbGlja2luZyBvbiBrZXlib2FyZC1mb2N1c2FibGUgZWxlbWVudFxyXG5cdFx0XHRwcmV2ZW50T3V0bGluZShlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcclxuXHR9LFxyXG5cclxuXHRfbW91c2VFdmVudHM6IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J10sXHJcblxyXG5cdF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlLCB0YXJnZXRzKSB7XHJcblxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHQvLyBGaXJlIGEgc3ludGhldGljICdwcmVjbGljaycgZXZlbnQgd2hpY2ggcHJvcGFnYXRlcyB1cCAobWFpbmx5IGZvciBjbG9zaW5nIHBvcHVwcykuXHJcblx0XHRcdC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCBiZWZvcmUgbW91c2UgY2xpY2sgb24gdGhlIG1hcCAoc29tZXRpbWVzIHVzZWZ1bCB3aGVuIHlvdVxyXG5cdFx0XHQvLyB3YW50IHNvbWV0aGluZyB0byBoYXBwZW4gb24gY2xpY2sgYmVmb3JlIGFueSBleGlzdGluZyBjbGlja1xyXG5cdFx0XHQvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cclxuXHRcdFx0dmFyIHN5bnRoID0gZXh0ZW5kKHt9LCBlKTtcclxuXHRcdFx0c3ludGgudHlwZSA9ICdwcmVjbGljayc7XHJcblx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChzeW50aCwgc3ludGgudHlwZSwgdGFyZ2V0cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGUuX3N0b3BwZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gRmluZCB0aGUgbGF5ZXIgdGhlIGV2ZW50IGlzIHByb3BhZ2F0aW5nIGZyb20gYW5kIGl0cyBwYXJlbnRzLlxyXG5cdFx0dGFyZ2V0cyA9ICh0YXJnZXRzIHx8IFtdKS5jb25jYXQodGhpcy5fZmluZEV2ZW50VGFyZ2V0cyhlLCB0eXBlKSk7XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcclxuXHRcdGlmICh0eXBlID09PSAnY29udGV4dG1lbnUnICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdHByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChlLnR5cGUgIT09ICdrZXlwcmVzcycgJiYgZS50eXBlICE9PSAna2V5ZG93bicgJiYgZS50eXBlICE9PSAna2V5dXAnKSB7XHJcblx0XHRcdHZhciBpc01hcmtlciA9IHRhcmdldC5nZXRMYXRMbmcgJiYgKCF0YXJnZXQuX3JhZGl1cyB8fCB0YXJnZXQuX3JhZGl1cyA8PSAxMCk7XHJcblx0XHRcdGRhdGEuY29udGFpbmVyUG9pbnQgPSBpc01hcmtlciA/XHJcblx0XHRcdFx0dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRhcmdldC5nZXRMYXRMbmcoKSkgOiB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xyXG5cdFx0XHRkYXRhLmxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGRhdGEuY29udGFpbmVyUG9pbnQpO1xyXG5cdFx0XHRkYXRhLmxhdGxuZyA9IGlzTWFya2VyID8gdGFyZ2V0LmdldExhdExuZygpIDogdGhpcy5sYXllclBvaW50VG9MYXRMbmcoZGF0YS5sYXllclBvaW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGFyZ2V0c1tpXS5maXJlKHR5cGUsIGRhdGEsIHRydWUpO1xyXG5cdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkIHx8XHJcblx0XHRcdFx0KHRhcmdldHNbaV0ub3B0aW9ucy5idWJibGluZ01vdXNlRXZlbnRzID09PSBmYWxzZSAmJiBpbmRleE9mKHRoaXMuX21vdXNlRXZlbnRzLCB0eXBlKSAhPT0gLTEpKSB7IHJldHVybjsgfVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9kcmFnZ2FibGVNb3ZlZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0b2JqID0gb2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5lbmFibGVkKCkgPyBvYmogOiB0aGlzO1xyXG5cdFx0cmV0dXJuIChvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLm1vdmVkKCkpIHx8ICh0aGlzLmJveFpvb20gJiYgdGhpcy5ib3hab29tLm1vdmVkKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlcnNbaV0uZGlzYWJsZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCB3aGVuUmVhZHkoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGBmbmAgd2hlbiB0aGUgbWFwIGdldHMgaW5pdGlhbGl6ZWQgd2l0aFxyXG5cdC8vIGEgdmlldyAoY2VudGVyIGFuZCB6b29tKSBhbmQgYXQgbGVhc3Qgb25lIGxheWVyLCBvciBpbW1lZGlhdGVseVxyXG5cdC8vIGlmIGl0J3MgYWxyZWFkeSBpbml0aWFsaXplZCwgb3B0aW9uYWxseSBwYXNzaW5nIGEgZnVuY3Rpb24gY29udGV4dC5cclxuXHR3aGVuUmVhZHk6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQgfHwgdGhpcywge3RhcmdldDogdGhpc30pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5vbignbG9hZCcsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgZm9yIGdldHRpbmcgbWFwIHN0YXRlXHJcblxyXG5cdF9nZXRNYXBQYW5lUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZ2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSkgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdHJldHVybiBwb3MgJiYgIXBvcy5lcXVhbHMoWzAsIDBdKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9wTGVmdFBvaW50OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgcGl4ZWxPcmlnaW4gPSBjZW50ZXIgJiYgem9vbSAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0dGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSA6XHJcblx0XHRcdHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKTtcclxuXHRcdHJldHVybiBwaXhlbE9yaWdpbi5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXROZXdQaXhlbE9yaWdpbjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLl9zdWJ0cmFjdCh2aWV3SGFsZikuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChsYXRsbmcsIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgem9vbSwgY2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gdG9Cb3VuZHMoW1xyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdClcclxuXHRcdF0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdF9nZXRDZW50ZXJMYXllclBvaW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIG9mZnNldCBvZiB0aGUgc3BlY2lmaWVkIHBsYWNlIHRvIHRoZSBjdXJyZW50IGNlbnRlciBpbiBwaXhlbHNcclxuXHRfZ2V0Q2VudGVyT2Zmc2V0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBjZW50ZXIgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRDZW50ZXI6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGJvdW5kcykge1xyXG5cclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBjZW50ZXI7IH1cclxuXHJcblx0XHR2YXIgY2VudGVyUG9pbnQgPSB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIHZpZXdCb3VuZHMgPSBuZXcgQm91bmRzKGNlbnRlclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKSwgY2VudGVyUG9pbnQuYWRkKHZpZXdIYWxmKSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KHZpZXdCb3VuZHMsIGJvdW5kcywgem9vbSk7XHJcblxyXG5cdFx0Ly8gSWYgb2Zmc2V0IGlzIGxlc3MgdGhhbiBhIHBpeGVsLCBpZ25vcmUuXHJcblx0XHQvLyBUaGlzIHByZXZlbnRzIHVuc3RhYmxlIHByb2plY3Rpb25zIGZyb20gZ2V0dGluZyBpbnRvXHJcblx0XHQvLyBhbiBpbmZpbml0ZSBsb29wIG9mIHRpbnkgb2Zmc2V0cy5cclxuXHRcdGlmIChvZmZzZXQucm91bmQoKS5lcXVhbHMoWzAsIDBdKSkge1xyXG5cdFx0XHRyZXR1cm4gY2VudGVyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChjZW50ZXJQb2ludC5hZGQob2Zmc2V0KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IG9mZnNldCBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCwgYm91bmRzKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gb2Zmc2V0OyB9XHJcblxyXG5cdFx0dmFyIHZpZXdCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiBvZmZzZXQuYWRkKHRoaXMuX2dldEJvdW5kc09mZnNldChuZXdCb3VuZHMsIGJvdW5kcykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgb2Zmc2V0IG5lZWRlZCBmb3IgcHhCb3VuZHMgdG8gZ2V0IGluc2lkZSBtYXhCb3VuZHMgYXQgYSBzcGVjaWZpZWQgem9vbVxyXG5cdF9nZXRCb3VuZHNPZmZzZXQ6IGZ1bmN0aW9uIChweEJvdW5kcywgbWF4Qm91bmRzLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkTWF4Qm91bmRzID0gdG9Cb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKVxyXG5cdFx0ICAgICksXHJcblx0XHQgICAgbWluT2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1pbi5zdWJ0cmFjdChweEJvdW5kcy5taW4pLFxyXG5cdFx0ICAgIG1heE9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5tYXguc3VidHJhY3QocHhCb3VuZHMubWF4KSxcclxuXHJcblx0XHQgICAgZHggPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC54LCAtbWF4T2Zmc2V0LngpLFxyXG5cdFx0ICAgIGR5ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueSwgLW1heE9mZnNldC55KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGR4LCBkeSk7XHJcblx0fSxcclxuXHJcblx0X3JlYm91bmQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG5cdFx0cmV0dXJuIGxlZnQgKyByaWdodCA+IDAgP1xyXG5cdFx0XHRNYXRoLnJvdW5kKGxlZnQgLSByaWdodCkgLyAyIDpcclxuXHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5jZWlsKGxlZnQpKSAtIE1hdGgubWF4KDAsIE1hdGguZmxvb3IocmlnaHQpKTtcclxuXHR9LFxyXG5cclxuXHRfbGltaXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIHNuYXAgPSBhbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0X29uUGFuVHJhbnNpdGlvblN0ZXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cdH0sXHJcblxyXG5cdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRQYW46IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHtcclxuXHRcdC8vIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbmV3IGFuZCBjdXJyZW50IGNlbnRlcnMgaW4gcGl4ZWxzXHJcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX3RydW5jKCk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSB0b28gZmFyIHVubGVzcyBhbmltYXRlOiB0cnVlIHNwZWNpZmllZCBpbiBvcHRpb25zXHJcblx0XHRpZiAoKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRlKSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHR0aGlzLnBhbkJ5KG9mZnNldCwgb3B0aW9ucyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBwcm94eSA9IHRoaXMuX3Byb3h5ID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LXByb3h5IGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cdFx0dGhpcy5fcGFuZXMubWFwUGFuZS5hcHBlbmRDaGlsZChwcm94eSk7XHJcblxyXG5cdFx0dGhpcy5vbignem9vbWFuaW0nLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHR2YXIgcHJvcCA9IFRSQU5TRk9STSxcclxuXHRcdFx0ICAgIHRyYW5zZm9ybSA9IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdO1xyXG5cclxuXHRcdFx0c2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoZS5jZW50ZXIsIGUuem9vbSksIHRoaXMuZ2V0Wm9vbVNjYWxlKGUuem9vbSwgMSkpO1xyXG5cclxuXHRcdFx0Ly8gd29ya2Fyb3VuZCBmb3IgY2FzZSB3aGVuIHRyYW5zZm9ybSBpcyB0aGUgc2FtZSBhbmQgc28gdHJhbnNpdGlvbmVuZCBldmVudCBpcyBub3QgZmlyZWRcclxuXHRcdFx0aWYgKHRyYW5zZm9ybSA9PT0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF0gJiYgdGhpcy5fYW5pbWF0aW5nWm9vbSkge1xyXG5cdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5vbignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX29uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95QW5pbVByb3h5LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfZGVzdHJveUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmVtb3ZlKHRoaXMuX3Byb3h5KTtcclxuXHRcdHRoaXMub2ZmKCdsb2FkIG1vdmVlbmQnLCB0aGlzLl9hbmltTW92ZUVuZCwgdGhpcyk7XHJcblx0XHRkZWxldGUgdGhpcy5fcHJveHk7XHJcblx0fSxcclxuXHJcblx0X2FuaW1Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYyA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgeiA9IHRoaXMuZ2V0Wm9vbSgpO1xyXG5cdFx0c2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoYywgeiksIHRoaXMuZ2V0Wm9vbVNjYWxlKHosIDEpKTtcclxuXHR9LFxyXG5cclxuXHRfY2F0Y2hUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20gJiYgZS5wcm9wZXJ0eU5hbWUuaW5kZXhPZigndHJhbnNmb3JtJykgPj0gMCkge1xyXG5cdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpLmxlbmd0aDtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2VcclxuXHRcdGlmICghdGhpcy5fem9vbUFuaW1hdGVkIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5fbm90aGluZ1RvQW5pbWF0ZSgpIHx8XHJcblx0XHQgICAgICAgIE1hdGguYWJzKHpvb20gLSB0aGlzLl96b29tKSA+IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl9kaXZpZGVCeSgxIC0gMSAvIHNjYWxlKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRyZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpXHJcblx0XHRcdCAgICAuX2FuaW1hdGVab29tKGNlbnRlciwgem9vbSwgdHJ1ZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHN0YXJ0QW5pbSwgbm9VcGRhdGUpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwUGFuZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoc3RhcnRBbmltKSB7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSB0cnVlO1xyXG5cclxuXHRcdFx0Ly8gcmVtZW1iZXIgd2hhdCBjZW50ZXIvem9vbSB0byBzZXQgYWZ0ZXIgYW5pbWF0aW9uXHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb0NlbnRlciA9IGNlbnRlcjtcclxuXHRcdFx0dGhpcy5fYW5pbWF0ZVRvWm9vbSA9IHpvb207XHJcblxyXG5cdFx0XHRhZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBPdGhlciBFdmVudHNcclxuXHRcdC8vIEBldmVudCB6b29tYW5pbTogWm9vbUFuaW1FdmVudFxyXG5cdFx0Ly8gRmlyZWQgYXQgbGVhc3Qgb25jZSBwZXIgem9vbSBhbmltYXRpb24uIEZvciBjb250aW51b3VzIHpvb20sIGxpa2UgcGluY2ggem9vbWluZywgZmlyZWQgb25jZSBwZXIgZnJhbWUgZHVyaW5nIHpvb20uXHJcblx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0em9vbTogem9vbSxcclxuXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBXb3JrIGFyb3VuZCB3ZWJraXQgbm90IGZpcmluZyAndHJhbnNpdGlvbmVuZCcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5LCAyNjkzXHJcblx0XHRzZXRUaW1lb3V0KGJpbmQodGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCwgdGhpcyksIDI1MCk7XHJcblx0fSxcclxuXHJcblx0X29uWm9vbVRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAodGhpcy5fbWFwUGFuZSkge1xyXG5cdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20pO1xyXG5cclxuXHRcdC8vIFRoaXMgYW5pbSBmcmFtZSBzaG91bGQgcHJldmVudCBhbiBvYnNjdXJlIGlPUyB3ZWJraXQgdGlsZSBsb2FkaW5nIHJhY2UgY29uZGl0aW9uLlxyXG5cdFx0cmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuX21vdmVFbmQodHJ1ZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuXHJcbi8vIEBmYWN0b3J5IEwubWFwKGlkOiBTdHJpbmcsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiB0aGUgRE9NIElEIG9mIGEgYDxkaXY+YCBlbGVtZW50XHJcbi8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuLy9cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubWFwKGVsOiBIVE1MRWxlbWVudCwgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIGFuIGluc3RhbmNlIG9mIGEgYDxkaXY+YCBIVE1MIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG5mdW5jdGlvbiBjcmVhdGVNYXAoaWQsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcChpZCwgb3B0aW9ucyk7XHJcbn1cblxuLypcclxuICogQGNsYXNzIENvbnRyb2xcclxuICogQGFrYSBMLkNvbnRyb2xcclxuICogQGluaGVyaXRzIENsYXNzXHJcbiAqXHJcbiAqIEwuQ29udHJvbCBpcyBhIGJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGluZyBtYXAgY29udHJvbHMuIEhhbmRsZXMgcG9zaXRpb25pbmcuXHJcbiAqIEFsbCBvdGhlciBjb250cm9scyBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gKi9cclxuXHJcbnZhciBDb250cm9sID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbCBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBwb3NpdGlvbjogU3RyaW5nID0gJ3RvcHJpZ2h0J1xyXG5cdFx0Ly8gVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIChvbmUgb2YgdGhlIG1hcCBjb3JuZXJzKS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RvcGxlZnQnYCxcclxuXHRcdC8vIGAndG9wcmlnaHQnYCwgYCdib3R0b21sZWZ0J2Agb3IgYCdib3R0b21yaWdodCdgXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgTC5Db250cm9sIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGdldFBvc2l0aW9uOiBzdHJpbmdcclxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHQgKi9cclxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5yZW1vdmVDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLmFkZENvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRUbyhtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBjb250cm9sIHRvIHRoZSBnaXZlbiBtYXAuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMucmVtb3ZlKCk7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKSxcclxuXHRcdCAgICBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKCksXHJcblx0XHQgICAgY29ybmVyID0gbWFwLl9jb250cm9sQ29ybmVyc1twb3NdO1xyXG5cclxuXHRcdGFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbCcpO1xyXG5cclxuXHRcdGlmIChwb3MuaW5kZXhPZignYm90dG9tJykgIT09IC0xKSB7XHJcblx0XHRcdGNvcm5lci5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjb3JuZXIuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb3JuZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAub24oJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGNvbnRyb2wgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG5cdFx0XHR0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9mZigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmVmb2N1c09uTWFwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gaWYgbWFwIGV4aXN0cyBhbmQgZXZlbnQgaXMgbm90IGEga2V5Ym9hcmQgZXZlbnRcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgZSAmJiBlLnNjcmVlblggPiAwICYmIGUuc2NyZWVuWSA+IDApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbnZhciBjb250cm9sID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IENvbnRyb2wob3B0aW9ucyk7XHJcbn07XHJcblxyXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG4gKiBAdW5pbmhlcml0YWJsZVxyXG4gKlxyXG4gKiBFdmVyeSBjb250cm9sIHNob3VsZCBleHRlbmQgZnJvbSBgTC5Db250cm9sYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogSFRNTEVsZW1lbnRcclxuICogU2hvdWxkIHJldHVybiB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50IGZvciB0aGUgY29udHJvbCBhbmQgYWRkIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2Bjb250cm9sLmFkZFRvKG1hcClgXSgjY29udHJvbC1hZGRUbykuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApXHJcbiAqIE9wdGlvbmFsIG1ldGhvZC4gU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2NvbnRyb2wtb25hZGQpLiBDYWxsZWQgb24gW2Bjb250cm9sLnJlbW92ZSgpYF0oI2NvbnRyb2wtcmVtb3ZlKS5cclxuICovXHJcblxyXG4vKiBAbmFtZXNwYWNlIE1hcFxyXG4gKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbiAqL1xyXG5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBhZGRDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gY29udHJvbCB0byB0aGUgbWFwXHJcblx0YWRkQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wuYWRkVG8odGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUNvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBjb250cm9sIGZyb20gdGhlIG1hcFxyXG5cdHJlbW92ZUNvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLnJlbW92ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29ybmVycyA9IHRoaXMuX2NvbnRyb2xDb3JuZXJzID0ge30sXHJcblx0XHQgICAgbCA9ICdsZWFmbGV0LScsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9XHJcblx0XHQgICAgICAgICAgICBjcmVhdGUkMSgnZGl2JywgbCArICdjb250cm9sLWNvbnRhaW5lcicsIHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQ29ybmVyKHZTaWRlLCBoU2lkZSkge1xyXG5cdFx0XHR2YXIgY2xhc3NOYW1lID0gbCArIHZTaWRlICsgJyAnICsgbCArIGhTaWRlO1xyXG5cclxuXHRcdFx0Y29ybmVyc1t2U2lkZSArIGhTaWRlXSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAncmlnaHQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ3JpZ2h0Jyk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFyQ29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9jb250cm9sQ29ybmVycykge1xyXG5cdFx0XHRyZW1vdmUodGhpcy5fY29udHJvbENvcm5lcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmVtb3ZlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb3JuZXJzO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb250YWluZXI7XHJcblx0fVxyXG59KTtcblxuLypcclxuICogQGNsYXNzIENvbnRyb2wuTGF5ZXJzXHJcbiAqIEBha2EgTC5Db250cm9sLkxheWVyc1xyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXJzIGNvbnRyb2wgZ2l2ZXMgdXNlcnMgdGhlIGFiaWxpdHkgdG8gc3dpdGNoIGJldHdlZW4gZGlmZmVyZW50IGJhc2UgbGF5ZXJzIGFuZCBzd2l0Y2ggb3ZlcmxheXMgb24vb2ZmIChjaGVjayBvdXQgdGhlIFtkZXRhaWxlZCBleGFtcGxlXShodHRwOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9sYXllcnMtY29udHJvbC8pKS4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBiYXNlTGF5ZXJzID0ge1xyXG4gKiBcdFwiTWFwYm94XCI6IG1hcGJveCxcclxuICogXHRcIk9wZW5TdHJlZXRNYXBcIjogb3NtXHJcbiAqIH07XHJcbiAqXHJcbiAqIHZhciBvdmVybGF5cyA9IHtcclxuICogXHRcIk1hcmtlclwiOiBtYXJrZXIsXHJcbiAqIFx0XCJSb2Fkc1wiOiByb2Fkc0xheWVyXHJcbiAqIH07XHJcbiAqXHJcbiAqIEwuY29udHJvbC5sYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMpLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgYGJhc2VMYXllcnNgIGFuZCBgb3ZlcmxheXNgIHBhcmFtZXRlcnMgYXJlIG9iamVjdCBsaXRlcmFscyB3aXRoIGxheWVyIG5hbWVzIGFzIGtleXMgYW5kIGBMYXllcmAgb2JqZWN0cyBhcyB2YWx1ZXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcclxuICogICAgIFwiPHNvbWVOYW1lMT5cIjogbGF5ZXIxLFxyXG4gKiAgICAgXCI8c29tZU5hbWUyPlwiOiBsYXllcjJcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGxheWVyIG5hbWVzIGNhbiBjb250YWluIEhUTUwsIHdoaWNoIGFsbG93cyB5b3UgdG8gYWRkIGFkZGl0aW9uYWwgc3R5bGluZyB0byB0aGUgaXRlbXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcIjxpbWcgc3JjPSdteS1sYXllci1pY29uJyAvPiA8c3BhbiBjbGFzcz0nbXktbGF5ZXItaXRlbSc+TXkgTGF5ZXI8L3NwYW4+XCI6IG15TGF5ZXJ9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBMYXllcnMgPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuTGF5ZXJzIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNvbGxhcHNlZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBiZSBjb2xsYXBzZWQgaW50byBhbiBpY29uIGFuZCBleHBhbmRlZCBvbiBtb3VzZSBob3ZlciBvciB0b3VjaC5cclxuXHRcdGNvbGxhcHNlZDogdHJ1ZSxcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1pJbmRleDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBhc3NpZ24gekluZGV4ZXMgaW4gaW5jcmVhc2luZyBvcmRlciB0byBhbGwgb2YgaXRzIGxheWVycyBzbyB0aGF0IHRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQgd2hlbiBzd2l0Y2hpbmcgdGhlbSBvbi9vZmYuXHJcblx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaGlkZVNpbmdsZUJhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgYmFzZSBsYXllcnMgaW4gdGhlIGNvbnRyb2wgd2lsbCBiZSBoaWRkZW4gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZS5cclxuXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRMYXllcnM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0byBzb3J0IHRoZSBsYXllcnMuIFdoZW4gYGZhbHNlYCwgbGF5ZXJzIHdpbGwga2VlcCB0aGUgb3JkZXJcclxuXHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cclxuXHRcdHNvcnRMYXllcnM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc29ydEZ1bmN0aW9uOiBGdW5jdGlvbiA9ICpcclxuXHRcdC8vIEEgW2NvbXBhcmUgZnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpXHJcblx0XHQvLyB0aGF0IHdpbGwgYmUgdXNlZCBmb3Igc29ydGluZyB0aGUgbGF5ZXJzLCB3aGVuIGBzb3J0TGF5ZXJzYCBpcyBgdHJ1ZWAuXHJcblx0XHQvLyBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYm90aCB0aGUgYEwuTGF5ZXJgIGluc3RhbmNlcyBhbmQgdGhlaXIgbmFtZXMsIGFzIGluXHJcblx0XHQvLyBgc29ydEZ1bmN0aW9uKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpYC5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIGl0IHNvcnRzIGxheWVycyBhbHBoYWJldGljYWxseSBieSB0aGVpciBuYW1lLlxyXG5cdFx0c29ydEZ1bmN0aW9uOiBmdW5jdGlvbiAobGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQikge1xyXG5cdFx0XHRyZXR1cm4gbmFtZUEgPCBuYW1lQiA/IC0xIDogKG5hbWVCIDwgbmFtZUEgPyAxIDogMCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXN0WkluZGV4ID0gMDtcclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIoYmFzZUxheWVyc1tpXSwgaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKG92ZXJsYXlzW2ldLCBpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0Q29udHJvbC5wcm90b3R5cGUuYWRkVG8uY2FsbCh0aGlzLCBtYXApO1xyXG5cdFx0Ly8gVHJpZ2dlciBleHBhbmQgYWZ0ZXIgTGF5ZXJzIENvbnRyb2wgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byBET00gc28gdGhhdCBpcyBub3cgaGFzIGFuIGFjdHVhbCBoZWlnaHQuXHJcblx0XHRyZXR1cm4gdGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9mZignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEJhc2VMYXllcihsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGEgYmFzZSBsYXllciAocmFkaW8gYnV0dG9uIGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRPdmVybGF5KGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gb3ZlcmxheSAoY2hlY2tib3ggZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSwgdHJ1ZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBjb250cm9sLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihzdGFtcChsYXllcikpO1xyXG5cdFx0aWYgKG9iaikge1xyXG5cdFx0XHR0aGlzLl9sYXllcnMuc3BsaWNlKHRoaXMuX2xheWVycy5pbmRleE9mKG9iaiksIDEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXhwYW5kKCk6IHRoaXNcclxuXHQvLyBFeHBhbmQgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGNvbGxhcHNlZC5cclxuXHRleHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gbnVsbDtcclxuXHRcdHZhciBhY2NlcHRhYmxlSGVpZ2h0ID0gdGhpcy5fbWFwLmdldFNpemUoKS55IC0gKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRUb3AgKyA1MCk7XHJcblx0XHRpZiAoYWNjZXB0YWJsZUhlaWdodCA8IHRoaXMuX3NlY3Rpb24uY2xpZW50SGVpZ2h0KSB7XHJcblx0XHRcdGFkZENsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0XHR0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodCA9IGFjY2VwdGFibGVIZWlnaHQgKyAncHgnO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbGxhcHNlKCk6IHRoaXNcclxuXHQvLyBDb2xsYXBzZSB0aGUgY29udHJvbCBjb250YWluZXIgaWYgZXhwYW5kZWQuXHJcblx0Y29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUpLFxyXG5cdFx0ICAgIGNvbGxhcHNlZCA9IHRoaXMub3B0aW9ucy5jb2xsYXBzZWQ7XHJcblxyXG5cdFx0Ly8gbWFrZXMgdGhpcyB3b3JrIG9uIElFIHRvdWNoIGRldmljZXMgYnkgc3RvcHBpbmcgaXQgZnJvbSBmaXJpbmcgYSBtb3VzZW91dCBldmVudCB3aGVuIHRoZSB0b3VjaCBpcyByZWxlYXNlZFxyXG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsIHRydWUpO1xyXG5cclxuXHRcdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHRkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHJcblx0XHR2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb24gPSBjcmVhdGUkMSgnc2VjdGlvbicsIGNsYXNzTmFtZSArICctbGlzdCcpO1xyXG5cclxuXHRcdGlmIChjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuY29sbGFwc2UsIHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKCFhbmRyb2lkKSB7XHJcblx0XHRcdFx0b24oY29udGFpbmVyLCB7XHJcblx0XHRcdFx0XHRtb3VzZWVudGVyOiB0aGlzLmV4cGFuZCxcclxuXHRcdFx0XHRcdG1vdXNlbGVhdmU6IHRoaXMuY29sbGFwc2VcclxuXHRcdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IGNyZWF0ZSQxKCdhJywgY2xhc3NOYW1lICsgJy10b2dnbGUnLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xyXG5cclxuXHRcdGlmICh0b3VjaCkge1xyXG5cdFx0XHRvbihsaW5rLCAnY2xpY2snLCBzdG9wKTtcclxuXHRcdFx0b24obGluaywgJ2NsaWNrJywgdGhpcy5leHBhbmQsIHRoaXMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b24obGluaywgJ2ZvY3VzJywgdGhpcy5leHBhbmQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYmFzZUxheWVyc0xpc3QgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lICsgJy1iYXNlJywgc2VjdGlvbik7XHJcblx0XHR0aGlzLl9zZXBhcmF0b3IgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lICsgJy1zZXBhcmF0b3InLCBzZWN0aW9uKTtcclxuXHRcdHRoaXMuX292ZXJsYXlzTGlzdCA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUgKyAnLW92ZXJsYXlzJywgc2VjdGlvbik7XHJcblxyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHNlY3Rpb24pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuX2xheWVyc1tpXSAmJiBzdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSwgb3ZlcmxheSkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHRsYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycy5wdXNoKHtcclxuXHRcdFx0bGF5ZXI6IGxheWVyLFxyXG5cdFx0XHRuYW1lOiBuYW1lLFxyXG5cdFx0XHRvdmVybGF5OiBvdmVybGF5XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnNvcnRMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNvcnQoYmluZChmdW5jdGlvbiAoYSwgYikge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKGEubGF5ZXIsIGIubGF5ZXIsIGEubmFtZSwgYi5uYW1lKTtcclxuXHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1pJbmRleCAmJiBsYXllci5zZXRaSW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fbGFzdFpJbmRleCsrO1xyXG5cdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGVtcHR5KHRoaXMuX2Jhc2VMYXllcnNMaXN0KTtcclxuXHRcdGVtcHR5KHRoaXMuX292ZXJsYXlzTGlzdCk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0b2JqID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcblx0XHRcdG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCB8fCAhb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIaWRlIGJhc2UgbGF5ZXJzIHNlY3Rpb24gaWYgdGhlcmUncyBvbmx5IG9uZSBsYXllci5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCAmJiBiYXNlTGF5ZXJzQ291bnQgPiAxO1xyXG5cdFx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdC5zdHlsZS5kaXNwbGF5ID0gYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9oYW5kbGluZ0NsaWNrKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihzdGFtcChlLnRhcmdldCkpO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBMYXllciBldmVudHNcclxuXHRcdC8vIEBldmVudCBiYXNlbGF5ZXJjaGFuZ2U6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllciBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlhZGQ6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIHNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllciBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlyZW1vdmU6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIGRlc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAbmFtZXNwYWNlIENvbnRyb2wuTGF5ZXJzXHJcblx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xyXG5cclxuXHRcdGlmICh0eXBlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIG9iaik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwOi8vYml0Lmx5L1BxWUxCZSlcclxuXHRfY3JlYXRlUmFkaW9FbGVtZW50OiBmdW5jdGlvbiAobmFtZSwgY2hlY2tlZCkge1xyXG5cclxuXHRcdHZhciByYWRpb0h0bWwgPSAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiIG5hbWU9XCInICtcclxuXHRcdFx0XHRuYW1lICsgJ1wiJyArIChjaGVja2VkID8gJyBjaGVja2VkPVwiY2hlY2tlZFwiJyA6ICcnKSArICcvPic7XHJcblxyXG5cdFx0dmFyIHJhZGlvRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdHJhZGlvRnJhZ21lbnQuaW5uZXJIVE1MID0gcmFkaW9IdG1sO1xyXG5cclxuXHRcdHJldHVybiByYWRpb0ZyYWdtZW50LmZpcnN0Q2hpbGQ7XHJcblx0fSxcclxuXHJcblx0X2FkZEl0ZW06IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyksXHJcblx0XHQgICAgY2hlY2tlZCA9IHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpLFxyXG5cdFx0ICAgIGlucHV0O1xyXG5cclxuXHRcdGlmIChvYmoub3ZlcmxheSkge1xyXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcblx0XHRcdGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xyXG5cdFx0XHRpbnB1dC5jbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3Rvcic7XHJcblx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlucHV0ID0gdGhpcy5fY3JlYXRlUmFkaW9FbGVtZW50KCdsZWFmbGV0LWJhc2UtbGF5ZXJzXycgKyBzdGFtcCh0aGlzKSwgY2hlY2tlZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLnB1c2goaW5wdXQpO1xyXG5cdFx0aW5wdXQubGF5ZXJJZCA9IHN0YW1wKG9iai5sYXllcik7XHJcblxyXG5cdFx0b24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblx0XHRuYW1lLmlubmVySFRNTCA9ICcgJyArIG9iai5uYW1lO1xyXG5cclxuXHRcdC8vIEhlbHBzIGZyb20gcHJldmVudGluZyBsYXllciBjb250cm9sIGZsaWNrZXIgd2hlbiBjaGVja2JveGVzIGFyZSBkaXNhYmxlZFxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjc3MVxyXG5cdFx0dmFyIGhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuXHRcdGxhYmVsLmFwcGVuZENoaWxkKGhvbGRlcik7XHJcblx0XHRob2xkZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKG5hbWUpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSBvYmoub3ZlcmxheSA/IHRoaXMuX292ZXJsYXlzTGlzdCA6IHRoaXMuX2Jhc2VMYXllcnNMaXN0O1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gbGFiZWw7XHJcblx0fSxcclxuXHJcblx0X29uSW5wdXRDbGljazogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCwgbGF5ZXI7XHJcblx0XHR2YXIgYWRkZWRMYXllcnMgPSBbXSxcclxuXHRcdCAgICByZW1vdmVkTGF5ZXJzID0gW107XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHJcblx0XHRcdGlmIChpbnB1dC5jaGVja2VkKSB7XHJcblx0XHRcdFx0YWRkZWRMYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQpIHtcclxuXHRcdFx0XHRyZW1vdmVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVnZml4IGlzc3VlIDIzMTg6IFNob3VsZCByZW1vdmUgYWxsIG9sZCBsYXllcnMgYmVmb3JlIHJlYWRkaW5nIG5ldyBvbmVzXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHJlbW92ZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHJlbW92ZWRMYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgYWRkZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9tYXAuaGFzTGF5ZXIoYWRkZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGFkZGVkTGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9yZWZvY3VzT25NYXAoKTtcclxuXHR9LFxyXG5cclxuXHRfY2hlY2tEaXNhYmxlZExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCxcclxuXHRcdCAgICBsYXllcixcclxuXHRcdCAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cdFx0XHRpbnB1dC5kaXNhYmxlZCA9IChsYXllci5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tIDwgbGF5ZXIub3B0aW9ucy5taW5ab29tKSB8fFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgIChsYXllci5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tID4gbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZElmTm90Q29sbGFwc2VkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxyXG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2NvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxyXG5cdFx0cmV0dXJuIHRoaXMuY29sbGFwc2UoKTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wubGF5ZXJzKGJhc2VsYXllcnM/OiBPYmplY3QsIG92ZXJsYXlzPzogT2JqZWN0LCBvcHRpb25zPzogQ29udHJvbC5MYXllcnMgb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIGxheWVycyBjb250cm9sIHdpdGggdGhlIGdpdmVuIGxheWVycy4gQmFzZSBsYXllcnMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIHJhZGlvIGJ1dHRvbnMsIHdoaWxlIG92ZXJsYXlzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCBjaGVja2JveGVzLiBOb3RlIHRoYXQgYWxsIGJhc2UgbGF5ZXJzIHNob3VsZCBiZSBwYXNzZWQgaW4gdGhlIGJhc2UgbGF5ZXJzIG9iamVjdCwgYnV0IG9ubHkgb25lIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgbWFwIGR1cmluZyBtYXAgaW5zdGFudGlhdGlvbi5cclxudmFyIGxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKTtcclxufTtcblxuLypcclxuICogQGNsYXNzIENvbnRyb2wuWm9vbVxyXG4gKiBAYWthIEwuQ29udHJvbC5ab29tXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIEEgYmFzaWMgem9vbSBjb250cm9sIHdpdGggdHdvIGJ1dHRvbnMgKHpvb20gaW4gYW5kIHpvb20gb3V0KS4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB0byBgZmFsc2VgLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICovXHJcblxyXG52YXIgWm9vbSA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5ab29tIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ3RvcGxlZnQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGV4dDogU3RyaW5nID0gJysnXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UZXh0OiAnKycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UaXRsZTogU3RyaW5nID0gJ1pvb20gaW4nXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGl0bGU6ICdab29tIGluJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PdXRUZXh0OiBTdHJpbmcgPSAnJiN4MjIxMjsnXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRleHQ6ICcmI3gyMjEyOycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGl0bGU6IFN0cmluZyA9ICdab29tIG91dCdcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRpdGxlOiAnWm9vbSBvdXQnXHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHZhciB6b29tTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtem9vbScsXHJcblx0XHQgICAgY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIHpvb21OYW1lICsgJyBsZWFmbGV0LWJhcicpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0dGhpcy5fem9vbUluQnV0dG9uICA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21JblRleHQsIG9wdGlvbnMuem9vbUluVGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1pbicsICBjb250YWluZXIsIHRoaXMuX3pvb21Jbik7XHJcblx0XHR0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbU91dFRleHQsIG9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctb3V0JywgY29udGFpbmVyLCB0aGlzLl96b29tT3V0KTtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3pvb21JbjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tIDwgdGhpcy5fbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tID4gdGhpcy5fbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbU91dCh0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4pIHtcclxuXHRcdHZhciBsaW5rID0gY3JlYXRlJDEoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmlubmVySFRNTCA9IGh0bWw7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG5cdFx0LypcclxuXHRcdCAqIFdpbGwgZm9yY2Ugc2NyZWVuIHJlYWRlcnMgbGlrZSBWb2ljZU92ZXIgdG8gcmVhZCB0aGlzIGFzIFwiWm9vbSBpbiAtIGJ1dHRvblwiXHJcblx0XHQgKi9cclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cdFx0bGluay5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XHJcblxyXG5cdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24obGluayk7XHJcblx0XHRvbihsaW5rLCAnY2xpY2snLCBzdG9wKTtcclxuXHRcdG9uKGxpbmssICdjbGljaycsIGZuLCB0aGlzKTtcclxuXHRcdG9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbms7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWRpc2FibGVkJztcclxuXHJcblx0XHRyZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHRyZW1vdmVDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0YWRkQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0YWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFt6b29tIGNvbnRyb2xdKCNjb250cm9sLXpvb20pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0em9vbUNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuXHRcdC8vIEBzZWN0aW9uIENvbnRyb2xzXHJcblx0XHQvLyBAcHJvcGVydHkgem9vbUNvbnRyb2w6IENvbnRyb2wuWm9vbVxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgem9vbSBjb250cm9sIChvbmx5IGF2YWlsYWJsZSBpZiB0aGVcclxuXHRcdC8vIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgd2FzIGB0cnVlYCB3aGVuIGNyZWF0aW5nIHRoZSBtYXApLlxyXG5cdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBab29tKCk7XHJcblx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC56b29tKG9wdGlvbnM6IENvbnRyb2wuWm9vbSBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgem9vbSBjb250cm9sXHJcbnZhciB6b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFpvb20ob3B0aW9ucyk7XHJcbn07XG5cbi8qXG4gKiBAY2xhc3MgQ29udHJvbC5TY2FsZVxuICogQGFrYSBMLkNvbnRyb2wuU2NhbGVcbiAqIEBpbmhlcml0cyBDb250cm9sXG4gKlxuICogQSBzaW1wbGUgc2NhbGUgY29udHJvbCB0aGF0IHNob3dzIHRoZSBzY2FsZSBvZiB0aGUgY3VycmVudCBjZW50ZXIgb2Ygc2NyZWVuIGluIG1ldHJpYyAobS9rbSkgYW5kIGltcGVyaWFsIChtaS9mdCkgc3lzdGVtcy4gRXh0ZW5kcyBgQ29udHJvbGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jb250cm9sLnNjYWxlKCkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbnZhciBTY2FsZSA9IENvbnRyb2wuZXh0ZW5kKHtcblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDb250cm9sLlNjYWxlIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdHBvc2l0aW9uOiAnYm90dG9tbGVmdCcsXG5cblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAxMDBcblx0XHQvLyBNYXhpbXVtIHdpZHRoIG9mIHRoZSBjb250cm9sIGluIHBpeGVscy4gVGhlIHdpZHRoIGlzIHNldCBkeW5hbWljYWxseSB0byBzaG93IHJvdW5kIHZhbHVlcyAoZS5nLiAxMDAsIDIwMCwgNTAwKS5cblx0XHRtYXhXaWR0aDogMTAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtZXRyaWM6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBtZXRyaWMgc2NhbGUgbGluZSAobS9rbSkuXG5cdFx0bWV0cmljOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBpbXBlcmlhbDogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIGltcGVyaWFsIHNjYWxlIGxpbmUgKG1pL2Z0KS5cblx0XHRpbXBlcmlhbDogdHJ1ZVxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCBpcyB1cGRhdGVkIG9uIFtgbW92ZWVuZGBdKCNtYXAtbW92ZWVuZCksIG90aGVyd2lzZSBpdCdzIGFsd2F5cyB1cC10by1kYXRlICh1cGRhdGVkIG9uIFtgbW92ZWBdKCNtYXAtbW92ZSkpLlxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtc2NhbGUnLFxuXHRcdCAgICBjb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHRoaXMuX2FkZFNjYWxlcyhvcHRpb25zLCBjbGFzc05hbWUgKyAnLWxpbmUnLCBjb250YWluZXIpO1xuXG5cdFx0bWFwLm9uKG9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdFx0bWFwLndoZW5SZWFkeSh0aGlzLl91cGRhdGUsIHRoaXMpO1xuXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5vZmYodGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHR9LFxuXG5cdF9hZGRTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuXHRcdGlmIChvcHRpb25zLm1ldHJpYykge1xuXHRcdFx0dGhpcy5fbVNjYWxlID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuaW1wZXJpYWwpIHtcblx0XHRcdHRoaXMuX2lTY2FsZSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB5ID0gbWFwLmdldFNpemUoKS55IC8gMjtcblxuXHRcdHZhciBtYXhNZXRlcnMgPSBtYXAuZGlzdGFuY2UoXG5cdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbMCwgeV0pLFxuXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoW3RoaXMub3B0aW9ucy5tYXhXaWR0aCwgeV0pKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlcyhtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVTY2FsZXM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHRpZiAodGhpcy5vcHRpb25zLm1ldHJpYyAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU1ldHJpYyhtYXhNZXRlcnMpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmltcGVyaWFsICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlSW1wZXJpYWwobWF4TWV0ZXJzKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU1ldHJpYzogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdHZhciBtZXRlcnMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNZXRlcnMpLFxuXHRcdCAgICBsYWJlbCA9IG1ldGVycyA8IDEwMDAgPyBtZXRlcnMgKyAnIG0nIDogKG1ldGVycyAvIDEwMDApICsgJyBrbSc7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9tU2NhbGUsIGxhYmVsLCBtZXRlcnMgLyBtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVJbXBlcmlhbDogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdHZhciBtYXhGZWV0ID0gbWF4TWV0ZXJzICogMy4yODA4Mzk5LFxuXHRcdCAgICBtYXhNaWxlcywgbWlsZXMsIGZlZXQ7XG5cblx0XHRpZiAobWF4RmVldCA+IDUyODApIHtcblx0XHRcdG1heE1pbGVzID0gbWF4RmVldCAvIDUyODA7XG5cdFx0XHRtaWxlcyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1pbGVzKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgbWlsZXMgKyAnIG1pJywgbWlsZXMgLyBtYXhNaWxlcyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZmVldCA9IHRoaXMuX2dldFJvdW5kTnVtKG1heEZlZXQpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBmZWV0ICsgJyBmdCcsIGZlZXQgLyBtYXhGZWV0KTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlOiBmdW5jdGlvbiAoc2NhbGUsIHRleHQsIHJhdGlvKSB7XG5cdFx0c2NhbGUuc3R5bGUud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5tYXhXaWR0aCAqIHJhdGlvKSArICdweCc7XG5cdFx0c2NhbGUuaW5uZXJIVE1MID0gdGV4dDtcblx0fSxcblxuXHRfZ2V0Um91bmROdW06IGZ1bmN0aW9uIChudW0pIHtcblx0XHR2YXIgcG93MTAgPSBNYXRoLnBvdygxMCwgKE1hdGguZmxvb3IobnVtKSArICcnKS5sZW5ndGggLSAxKSxcblx0XHQgICAgZCA9IG51bSAvIHBvdzEwO1xuXG5cdFx0ZCA9IGQgPj0gMTAgPyAxMCA6XG5cdFx0ICAgIGQgPj0gNSA/IDUgOlxuXHRcdCAgICBkID49IDMgPyAzIDpcblx0XHQgICAgZCA+PSAyID8gMiA6IDE7XG5cblx0XHRyZXR1cm4gcG93MTAgKiBkO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuc2NhbGUob3B0aW9ucz86IENvbnRyb2wuU2NhbGUgb3B0aW9ucylcbi8vIENyZWF0ZXMgYW4gc2NhbGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxudmFyIHNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTY2FsZShvcHRpb25zKTtcbn07XG5cbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBha2EgTC5Db250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBhdHRyaWJ1dGlvbiBjb250cm9sIGFsbG93cyB5b3UgdG8gZGlzcGxheSBhdHRyaWJ1dGlvbiBkYXRhIGluIGEgc21hbGwgdGV4dCBib3ggb24gYSBtYXAuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgYXR0cmlidXRpb25Db250cm9sYCBvcHRpb25dKCNtYXAtYXR0cmlidXRpb25jb250cm9sKSB0byBgZmFsc2VgLCBhbmQgaXQgZmV0Y2hlcyBhdHRyaWJ1dGlvbiB0ZXh0cyBmcm9tIGxheWVycyB3aXRoIHRoZSBbYGdldEF0dHJpYnV0aW9uYCBtZXRob2RdKCNsYXllci1nZXRhdHRyaWJ1dGlvbikgYXV0b21hdGljYWxseS4gRXh0ZW5kcyBDb250cm9sLlxyXG4gKi9cclxuXHJcbnZhciBBdHRyaWJ1dGlvbiA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICdib3R0b21yaWdodCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwcmVmaXg6IFN0cmluZyA9ICdMZWFmbGV0J1xyXG5cdFx0Ly8gVGhlIEhUTUwgdGV4dCBzaG93biBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUuXHJcblx0XHRwcmVmaXg6ICc8YSBocmVmPVwiaHR0cHM6Ly9sZWFmbGV0anMuY29tXCIgdGl0bGU9XCJBIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj5MZWFmbGV0PC9hPidcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbCA9IHRoaXM7XHJcblx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG5cdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHQvLyBUT0RPIHVnbHksIHJlZmFjdG9yXHJcblx0XHRmb3IgKHZhciBpIGluIG1hcC5fbGF5ZXJzKSB7XHJcblx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UHJlZml4KHByZWZpeDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHRleHQgYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuXHJcblx0c2V0UHJlZml4OiBmdW5jdGlvbiAocHJlZml4KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMucHJlZml4ID0gcHJlZml4O1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGF0dHJpYnV0aW9uIHRleHQgKGUuZy4gYCdWZWN0b3IgZGF0YSAmY29weTsgTWFwYm94J2ApLlxyXG5cdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gYXR0cmlidXRpb24gdGV4dC5cclxuXHRyZW1vdmVBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5wcmVmaXgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0dHJpYnMubGVuZ3RoKSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyB8ICcpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiBhdHRyaWJ1dGlvbkNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbYXR0cmlidXRpb24gY29udHJvbF0oI2NvbnRyb2wtYXR0cmlidXRpb24pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0YXR0cmlidXRpb25Db250cm9sOiB0cnVlXHJcbn0pO1xyXG5cclxuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG5cdFx0bmV3IEF0dHJpYnV0aW9uKCkuYWRkVG8odGhpcyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuYXR0cmlidXRpb24ob3B0aW9uczogQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wuXHJcbnZhciBhdHRyaWJ1dGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBBdHRyaWJ1dGlvbihvcHRpb25zKTtcclxufTtcblxuQ29udHJvbC5MYXllcnMgPSBMYXllcnM7XG5Db250cm9sLlpvb20gPSBab29tO1xuQ29udHJvbC5TY2FsZSA9IFNjYWxlO1xuQ29udHJvbC5BdHRyaWJ1dGlvbiA9IEF0dHJpYnV0aW9uO1xuXG5jb250cm9sLmxheWVycyA9IGxheWVycztcbmNvbnRyb2wuem9vbSA9IHpvb207XG5jb250cm9sLnNjYWxlID0gc2NhbGU7XG5jb250cm9sLmF0dHJpYnV0aW9uID0gYXR0cmlidXRpb247XG5cbi8qXG5cdEwuSGFuZGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGhhbmRsZXIgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHkgdG8gaW5qZWN0XG5cdGludGVyYWN0aW9uIGZlYXR1cmVzIGxpa2UgZHJhZ2dpbmcgdG8gY2xhc3NlcyBsaWtlIE1hcCBhbmQgTWFya2VyLlxuKi9cblxuLy8gQGNsYXNzIEhhbmRsZXJcbi8vIEBha2EgTC5IYW5kbGVyXG4vLyBBYnN0cmFjdCBjbGFzcyBmb3IgbWFwIGludGVyYWN0aW9uIGhhbmRsZXJzXG5cbnZhciBIYW5kbGVyID0gQ2xhc3MuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpOiB0aGlzXG5cdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuYWRkSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuXHQvLyBEaXNhYmxlcyB0aGUgaGFuZGxlclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlZCgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcblx0ZW5hYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG5cdH1cblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQsIHNob3VsZCBhZGQgZXZlbnQgaG9va3MuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbn0pO1xuXG4vLyBAc2VjdGlvbiBUaGVyZSBpcyBzdGF0aWMgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5IYW5kbGVyOlxuLy8gQGZ1bmN0aW9uIGFkZFRvKG1hcDogTWFwLCBuYW1lOiBTdHJpbmcpOiB0aGlzXG4vLyBBZGRzIGEgbmV3IEhhbmRsZXIgdG8gdGhlIGdpdmVuIG1hcCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuSGFuZGxlci5hZGRUbyA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcblx0bWFwLmFkZEhhbmRsZXIobmFtZSwgdGhpcyk7XG5cdHJldHVybiB0aGlzO1xufTtcblxudmFyIE1peGluID0ge0V2ZW50czogRXZlbnRzfTtcblxuLypcclxuICogQGNsYXNzIERyYWdnYWJsZVxyXG4gKiBAYWthIEwuRHJhZ2dhYmxlXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIEEgY2xhc3MgZm9yIG1ha2luZyBET00gZWxlbWVudHMgZHJhZ2dhYmxlIChpbmNsdWRpbmcgdG91Y2ggc3VwcG9ydCkuXHJcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgbWFwIGFuZCBtYXJrZXIgZHJhZ2dpbmcuIE9ubHkgd29ya3MgZm9yIGVsZW1lbnRzXHJcbiAqIHRoYXQgd2VyZSBwb3NpdGlvbmVkIHdpdGggW2BMLkRvbVV0aWwuc2V0UG9zaXRpb25gXSgjZG9tdXRpbC1zZXRwb3NpdGlvbikuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBkcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoZWxlbWVudFRvRHJhZyk7XHJcbiAqIGRyYWdnYWJsZS5lbmFibGUoKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIFNUQVJUID0gdG91Y2ggPyAndG91Y2hzdGFydCBtb3VzZWRvd24nIDogJ21vdXNlZG93bic7XHJcbnZhciBFTkQgPSB7XHJcblx0bW91c2Vkb3duOiAnbW91c2V1cCcsXHJcblx0dG91Y2hzdGFydDogJ3RvdWNoZW5kJyxcclxuXHRwb2ludGVyZG93bjogJ3RvdWNoZW5kJyxcclxuXHRNU1BvaW50ZXJEb3duOiAndG91Y2hlbmQnXHJcbn07XHJcbnZhciBNT1ZFID0ge1xyXG5cdG1vdXNlZG93bjogJ21vdXNlbW92ZScsXHJcblx0dG91Y2hzdGFydDogJ3RvdWNobW92ZScsXHJcblx0cG9pbnRlcmRvd246ICd0b3VjaG1vdmUnLFxyXG5cdE1TUG9pbnRlckRvd246ICd0b3VjaG1vdmUnXHJcbn07XHJcblxyXG5cclxudmFyIERyYWdnYWJsZSA9IEV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vIEBha2EgRHJhZ2dhYmxlIG9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gY2xpY2tUb2xlcmFuY2U6IE51bWJlciA9IDNcclxuXHRcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGNsaWNrXHJcblx0XHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIGNsaWNrIChhcyBvcHBvc2VkIHRvIGEgbW91c2UgZHJhZykuXHJcblx0XHRjbGlja1RvbGVyYW5jZTogM1xyXG5cdH0sXHJcblxyXG5cdC8vIEBjb25zdHJ1Y3RvciBMLkRyYWdnYWJsZShlbDogSFRNTEVsZW1lbnQsIGRyYWdIYW5kbGU/OiBIVE1MRWxlbWVudCwgcHJldmVudE91dGxpbmU/OiBCb29sZWFuLCBvcHRpb25zPzogRHJhZ2dhYmxlIG9wdGlvbnMpXHJcblx0Ly8gQ3JlYXRlcyBhIGBEcmFnZ2FibGVgIG9iamVjdCBmb3IgbW92aW5nIGBlbGAgd2hlbiB5b3Ugc3RhcnQgZHJhZ2dpbmcgdGhlIGBkcmFnSGFuZGxlYCBlbGVtZW50IChlcXVhbHMgYGVsYCBpdHNlbGYgYnkgZGVmYXVsdCkuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGRyYWdTdGFydFRhcmdldCwgcHJldmVudE91dGxpbmUkJDEsIG9wdGlvbnMpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9kcmFnU3RhcnRUYXJnZXQgPSBkcmFnU3RhcnRUYXJnZXQgfHwgZWxlbWVudDtcclxuXHRcdHRoaXMuX3ByZXZlbnRPdXRsaW5lID0gcHJldmVudE91dGxpbmUkJDE7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlbmFibGUoKVxyXG5cdC8vIEVuYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdG9uKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXNhYmxlKClcclxuXHQvLyBEaXNhYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBJZiB3ZSdyZSBjdXJyZW50bHkgZHJhZ2dpbmcgdGhpcyBkcmFnZ2FibGUsXHJcblx0XHQvLyBkaXNhYmxpbmcgaXQgY291bnRzIGFzIGZpcnN0IGVuZGluZyB0aGUgZHJhZy5cclxuXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcblx0XHRcdHRoaXMuZmluaXNoRHJhZygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG9mZih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoaGFzQ2xhc3ModGhpcy5fZWxlbWVudCwgJ2xlYWZsZXQtem9vbS1hbmltJykpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgfHwgZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkgJiYgIWUudG91Y2hlcykpIHsgcmV0dXJuOyB9XHJcblx0XHREcmFnZ2FibGUuX2RyYWdnaW5nID0gdGhpczsgIC8vIFByZXZlbnQgZHJhZ2dpbmcgbXVsdGlwbGUgb2JqZWN0cyBhdCBvbmNlLlxyXG5cclxuXHRcdGlmICh0aGlzLl9wcmV2ZW50T3V0bGluZSkge1xyXG5cdFx0XHRwcmV2ZW50T3V0bGluZSh0aGlzLl9lbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRkaXNhYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHRkaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZpbmcpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRvd246IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBpcyBhYm91dCB0byBzdGFydC5cclxuXHRcdHRoaXMuZmlyZSgnZG93bicpO1xyXG5cclxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXHJcblx0XHQgICAgc2l6ZWRQYXJlbnQgPSBnZXRTaXplZFBhcmVudE5vZGUodGhpcy5fZWxlbWVudCk7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuXHJcblx0XHQvLyBDYWNoZSB0aGUgc2NhbGUsIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVvdXNseSBjb21wZW5zYXRlIGZvciBpdCBkdXJpbmcgZHJhZyAoX29uTW92ZSkuXHJcblx0XHR0aGlzLl9wYXJlbnRTY2FsZSA9IGdldFNjYWxlKHNpemVkUGFyZW50KTtcclxuXHJcblx0XHRvbihkb2N1bWVudCwgTU9WRVtlLnR5cGVdLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xyXG5cdFx0b24oZG9jdW1lbnQsIEVORFtlLnR5cGVdLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKS5fc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCk7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcblx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0LngpICsgTWF0aC5hYnMob2Zmc2V0LnkpIDwgdGhpcy5vcHRpb25zLmNsaWNrVG9sZXJhbmNlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IHRoZSBwYXJlbnQgY29udGFpbmVyJ3MgcG9zaXRpb24sIGJvcmRlciBhbmQgc2NhbGUgZG8gbm90IGNoYW5nZSBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBkcmFnLlxyXG5cdFx0Ly8gVGhlcmVmb3JlIHRoZXJlIGlzIG5vIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIHBvc2l0aW9uIGFuZCBib3JkZXIgKHRoZXkgYXJlIGVsaW1pbmF0ZWQgYnkgdGhlIHN1YnRyYWN0aW9uKVxyXG5cdFx0Ly8gYW5kIHdlIGNhbiB1c2UgdGhlIGNhY2hlZCB2YWx1ZSBmb3IgdGhlIHNjYWxlLlxyXG5cdFx0b2Zmc2V0LnggLz0gdGhpcy5fcGFyZW50U2NhbGUueDtcclxuXHRcdG9mZnNldC55IC89IHRoaXMuX3BhcmVudFNjYWxlLnk7XHJcblxyXG5cdFx0cHJldmVudERlZmF1bHQoZSk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBzdGFydHNcclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnc3RhcnQnKTtcclxuXHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5fc3RhcnRQb3MgPSBnZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KS5zdWJ0cmFjdChvZmZzZXQpO1xyXG5cclxuXHRcdFx0YWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XHJcblx0XHRcdC8vIElFIGFuZCBFZGdlIGRvIG5vdCBnaXZlIHRoZSA8dXNlPiBlbGVtZW50LCBzbyBmZXRjaCBpdFxyXG5cdFx0XHQvLyBpZiBuZWNlc3NhcnlcclxuXHRcdFx0aWYgKCh3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlKSAmJiAodGhpcy5fbGFzdFRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnRJbnN0YW5jZSkpIHtcclxuXHRcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gdGhpcy5fbGFzdFRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcclxuXHRcdFx0fVxyXG5cdFx0XHRhZGRDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX25ld1BvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xyXG5cdFx0dGhpcy5fbW92aW5nID0gdHJ1ZTtcclxuXHJcblx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fbGFzdEV2ZW50ID0gZTtcclxuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVQb3NpdGlvbiwgdGhpcywgdHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZSA9IHtvcmlnaW5hbEV2ZW50OiB0aGlzLl9sYXN0RXZlbnR9O1xyXG5cclxuXHRcdC8vIEBldmVudCBwcmVkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZyAqYmVmb3JlKiBlYWNoIGNvcnJlc3BvbmRpbmdcclxuXHRcdC8vIHVwZGF0ZSBvZiB0aGUgZWxlbWVudCdzIHBvc2l0aW9uLlxyXG5cdFx0dGhpcy5maXJlKCdwcmVkcmFnJywgZSk7XHJcblx0XHRzZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50LCB0aGlzLl9uZXdQb3MpO1xyXG5cclxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZy5cclxuXHRcdHRoaXMuZmlyZSgnZHJhZycsIGUpO1xyXG5cdH0sXHJcblxyXG5cdF9vblVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHRcdHRoaXMuZmluaXNoRHJhZygpO1xyXG5cdH0sXHJcblxyXG5cdGZpbmlzaERyYWc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBNT1ZFKSB7XHJcblx0XHRcdG9mZihkb2N1bWVudCwgTU9WRVtpXSwgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdFx0b2ZmKGRvY3VtZW50LCBFTkRbaV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGVuYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0ZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZlZCAmJiB0aGlzLl9tb3ZpbmcpIHtcclxuXHRcdFx0Ly8gZW5zdXJlIGRyYWcgaXMgbm90IGZpcmVkIGFmdGVyIGRyYWdlbmRcclxuXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHJcblx0XHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZHJhZyBlbmRzLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdlbmQnLCB7XHJcblx0XHRcdFx0ZGlzdGFuY2U6IHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZpbmcgPSBmYWxzZTtcclxuXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHR9XHJcblxyXG59KTtcblxuLypcclxuICogQG5hbWVzcGFjZSBMaW5lVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5bGluZSBwb2ludHMgcHJvY2Vzc2luZywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gbWFrZSBwb2x5bGluZXMgbGlnaHRuaW5nLWZhc3QuXHJcbiAqL1xyXG5cclxuLy8gU2ltcGxpZnkgcG9seWxpbmUgd2l0aCB2ZXJ0ZXggcmVkdWN0aW9uIGFuZCBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24uXHJcbi8vIEltcHJvdmVzIHJlbmRlcmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnkgbGVzc2VuaW5nIHRoZSBudW1iZXIgb2YgcG9pbnRzIHRvIGRyYXcuXHJcblxyXG4vLyBAZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzOiBQb2ludFtdLCB0b2xlcmFuY2U6IE51bWJlcik6IFBvaW50W11cclxuLy8gRHJhbWF0aWNhbGx5IHJlZHVjZXMgdGhlIG51bWJlciBvZiBwb2ludHMgaW4gYSBwb2x5bGluZSB3aGlsZSByZXRhaW5pbmdcclxuLy8gaXRzIHNoYXBlIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNpbXBsaWZpZWQgcG9pbnRzLCB1c2luZyB0aGVcclxuLy8gW0RvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobSkuXHJcbi8vIFVzZWQgZm9yIGEgaHVnZSBwZXJmb3JtYW5jZSBib29zdCB3aGVuIHByb2Nlc3NpbmcvZGlzcGxheWluZyBMZWFmbGV0IHBvbHlsaW5lcyBmb3JcclxuLy8gZWFjaCB6b29tIGxldmVsIGFuZCBhbHNvIHJlZHVjaW5nIHZpc3VhbCBub2lzZS4gdG9sZXJhbmNlIGFmZmVjdHMgdGhlIGFtb3VudCBvZlxyXG4vLyBzaW1wbGlmaWNhdGlvbiAobGVzc2VyIHZhbHVlIG1lYW5zIGhpZ2hlciBxdWFsaXR5IGJ1dCBzbG93ZXIgYW5kIHdpdGggbW9yZSBwb2ludHMpLlxyXG4vLyBBbHNvIHJlbGVhc2VkIGFzIGEgc2VwYXJhdGVkIG1pY3JvLWxpYnJhcnkgW1NpbXBsaWZ5LmpzXShodHRwOi8vbW91cm5lci5naXRodWIuY29tL3NpbXBsaWZ5LWpzLykuXHJcbmZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgdG9sZXJhbmNlKSB7XHJcblx0aWYgKCF0b2xlcmFuY2UgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuXHRcdHJldHVybiBwb2ludHMuc2xpY2UoKTtcclxuXHR9XHJcblxyXG5cdHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcclxuXHJcblx0ICAgIC8vIHN0YWdlIDE6IHZlcnRleCByZWR1Y3Rpb25cclxuXHQgICAgcG9pbnRzID0gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0ICAgIC8vIHN0YWdlIDI6IERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvblxyXG5cdCAgICBwb2ludHMgPSBfc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnQgYHBgIGFuZCBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwMSwgcDIpIHtcclxuXHRyZXR1cm4gTWF0aC5zcXJ0KF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHRydWUpKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgY2xvc2VzdCBwb2ludCBmcm9tIGEgcG9pbnQgYHBgIG9uIGEgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbmZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpIHtcclxuXHRyZXR1cm4gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcbn1cclxuXHJcbi8vIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobVxyXG5mdW5jdGlvbiBfc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblxyXG5cdHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxyXG5cdCAgICBBcnJheUNvbnN0cnVjdG9yID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IHVuZGVmaW5lZCArICcnID8gVWludDhBcnJheSA6IEFycmF5LFxyXG5cdCAgICBtYXJrZXJzID0gbmV3IEFycmF5Q29uc3RydWN0b3IobGVuKTtcclxuXHJcblx0ICAgIG1hcmtlcnNbMF0gPSBtYXJrZXJzW2xlbiAtIDFdID0gMTtcclxuXHJcblx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIDAsIGxlbiAtIDEpO1xyXG5cclxuXHR2YXIgaSxcclxuXHQgICAgbmV3UG9pbnRzID0gW107XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0aWYgKG1hcmtlcnNbaV0pIHtcclxuXHRcdFx0bmV3UG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXdQb2ludHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgbGFzdCkge1xyXG5cclxuXHR2YXIgbWF4U3FEaXN0ID0gMCxcclxuXHRpbmRleCwgaSwgc3FEaXN0O1xyXG5cclxuXHRmb3IgKGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdCAtIDE7IGkrKykge1xyXG5cdFx0c3FEaXN0ID0gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XHJcblx0XHRcdGluZGV4ID0gaTtcclxuXHRcdFx0bWF4U3FEaXN0ID0gc3FEaXN0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRtYXJrZXJzW2luZGV4XSA9IDE7XHJcblxyXG5cdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBpbmRleCk7XHJcblx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgaW5kZXgsIGxhc3QpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gcmVkdWNlIHBvaW50cyB0aGF0IGFyZSB0b28gY2xvc2UgdG8gZWFjaCBvdGhlciB0byBhIHNpbmdsZSBwb2ludFxyXG5mdW5jdGlvbiBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHR2YXIgcmVkdWNlZFBvaW50cyA9IFtwb2ludHNbMF1dO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMSwgcHJldiA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0aWYgKF9zcURpc3QocG9pbnRzW2ldLCBwb2ludHNbcHJldl0pID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHRcdHByZXYgPSBpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAocHJldiA8IGxlbiAtIDEpIHtcclxuXHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbbGVuIC0gMV0pO1xyXG5cdH1cclxuXHRyZXR1cm4gcmVkdWNlZFBvaW50cztcclxufVxyXG5cclxudmFyIF9sYXN0Q29kZTtcclxuXHJcbi8vIEBmdW5jdGlvbiBjbGlwU2VnbWVudChhOiBQb2ludCwgYjogUG9pbnQsIGJvdW5kczogQm91bmRzLCB1c2VMYXN0Q29kZT86IEJvb2xlYW4sIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W118Qm9vbGVhblxyXG4vLyBDbGlwcyB0aGUgc2VnbWVudCBhIHRvIGIgYnkgcmVjdGFuZ3VsYXIgYm91bmRzIHdpdGggdGhlXHJcbi8vIFtDb2hlbi1TdXRoZXJsYW5kIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29oZW4lRTIlODAlOTNTdXRoZXJsYW5kX2FsZ29yaXRobSlcclxuLy8gKG1vZGlmeWluZyB0aGUgc2VnbWVudCBwb2ludHMgZGlyZWN0bHkhKS4gVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5bGluZVxyXG4vLyBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nIHBlcmZvcm1hbmNlLlxyXG5mdW5jdGlvbiBjbGlwU2VnbWVudChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlLCByb3VuZCkge1xyXG5cdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gX2xhc3RDb2RlIDogX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuXHQgICAgY29kZUIgPSBfZ2V0Qml0Q29kZShiLCBib3VuZHMpLFxyXG5cclxuXHQgICAgY29kZU91dCwgcCwgbmV3Q29kZTtcclxuXHJcblx0ICAgIC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG5cdCAgICBfbGFzdENvZGUgPSBjb2RlQjtcclxuXHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuXHRcdGlmICghKGNvZGVBIHwgY29kZUIpKSB7XHJcblx0XHRcdHJldHVybiBbYSwgYl07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgYSxiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIHJlamVjdClcclxuXHRcdGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlciBjYXNlc1xyXG5cdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG5cdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0bmV3Q29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcblx0XHRcdGEgPSBwO1xyXG5cdFx0XHRjb2RlQSA9IG5ld0NvZGU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRiID0gcDtcclxuXHRcdFx0Y29kZUIgPSBuZXdDb2RlO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZSwgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBkeCA9IGIueCAtIGEueCxcclxuXHQgICAgZHkgPSBiLnkgLSBhLnksXHJcblx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcblx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0ICAgIHgsIHk7XHJcblxyXG5cdGlmIChjb2RlICYgOCkgeyAvLyB0b3BcclxuXHRcdHggPSBhLnggKyBkeCAqIChtYXgueSAtIGEueSkgLyBkeTtcclxuXHRcdHkgPSBtYXgueTtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgNCkgeyAvLyBib3R0b21cclxuXHRcdHggPSBhLnggKyBkeCAqIChtaW4ueSAtIGEueSkgLyBkeTtcclxuXHRcdHkgPSBtaW4ueTtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMikgeyAvLyByaWdodFxyXG5cdFx0eCA9IG1heC54O1xyXG5cdFx0eSA9IGEueSArIGR5ICogKG1heC54IC0gYS54KSAvIGR4O1xyXG5cclxuXHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7IC8vIGxlZnRcclxuXHRcdHggPSBtaW4ueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtaW4ueCAtIGEueCkgLyBkeDtcclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfZ2V0Qml0Q29kZShwLCBib3VuZHMpIHtcclxuXHR2YXIgY29kZSA9IDA7XHJcblxyXG5cdGlmIChwLnggPCBib3VuZHMubWluLngpIHsgLy8gbGVmdFxyXG5cdFx0Y29kZSB8PSAxO1xyXG5cdH0gZWxzZSBpZiAocC54ID4gYm91bmRzLm1heC54KSB7IC8vIHJpZ2h0XHJcblx0XHRjb2RlIHw9IDI7XHJcblx0fVxyXG5cclxuXHRpZiAocC55IDwgYm91bmRzLm1pbi55KSB7IC8vIGJvdHRvbVxyXG5cdFx0Y29kZSB8PSA0O1xyXG5cdH0gZWxzZSBpZiAocC55ID4gYm91bmRzLm1heC55KSB7IC8vIHRvcFxyXG5cdFx0Y29kZSB8PSA4O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNvZGU7XHJcbn1cclxuXHJcbi8vIHNxdWFyZSBkaXN0YW5jZSAodG8gYXZvaWQgdW5uZWNlc3NhcnkgTWF0aC5zcXJ0IGNhbGxzKVxyXG5mdW5jdGlvbiBfc3FEaXN0KHAxLCBwMikge1xyXG5cdHZhciBkeCA9IHAyLnggLSBwMS54LFxyXG5cdCAgICBkeSA9IHAyLnkgLSBwMS55O1xyXG5cdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxufVxyXG5cclxuLy8gcmV0dXJuIGNsb3Nlc3QgcG9pbnQgb24gc2VnbWVudCBvciBkaXN0YW5jZSB0byB0aGF0IHBvaW50XHJcbmZ1bmN0aW9uIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG5cdHZhciB4ID0gcDEueCxcclxuXHQgICAgeSA9IHAxLnksXHJcblx0ICAgIGR4ID0gcDIueCAtIHgsXHJcblx0ICAgIGR5ID0gcDIueSAtIHksXHJcblx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG5cdCAgICB0O1xyXG5cclxuXHRpZiAoZG90ID4gMCkge1xyXG5cdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcblx0XHRpZiAodCA+IDEpIHtcclxuXHRcdFx0eCA9IHAyLng7XHJcblx0XHRcdHkgPSBwMi55O1xyXG5cdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG5cdFx0XHR4ICs9IGR4ICogdDtcclxuXHRcdFx0eSArPSBkeSAqIHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRkeCA9IHAueCAtIHg7XHJcblx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuXHRyZXR1cm4gc3FEaXN0ID8gZHggKiBkeCArIGR5ICogZHkgOiBuZXcgUG9pbnQoeCwgeSk7XHJcbn1cclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3M6IExhdExuZ1tdKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIHRydWUgaWYgYGxhdGxuZ3NgIGlzIGEgZmxhdCBhcnJheSwgZmFsc2UgaXMgbmVzdGVkLlxyXG5mdW5jdGlvbiBpc0ZsYXQobGF0bG5ncykge1xyXG5cdHJldHVybiAhaXNBcnJheShsYXRsbmdzWzBdKSB8fCAodHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9mbGF0KGxhdGxuZ3MpIHtcclxuXHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgdXNlIG9mIF9mbGF0LCBwbGVhc2UgdXNlIEwuTGluZVV0aWwuaXNGbGF0IGluc3RlYWQuJyk7XHJcblx0cmV0dXJuIGlzRmxhdChsYXRsbmdzKTtcclxufVxyXG5cblxudmFyIExpbmVVdGlsID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdHNpbXBsaWZ5OiBzaW1wbGlmeSxcblx0cG9pbnRUb1NlZ21lbnREaXN0YW5jZTogcG9pbnRUb1NlZ21lbnREaXN0YW5jZSxcblx0Y2xvc2VzdFBvaW50T25TZWdtZW50OiBjbG9zZXN0UG9pbnRPblNlZ21lbnQsXG5cdGNsaXBTZWdtZW50OiBjbGlwU2VnbWVudCxcblx0X2dldEVkZ2VJbnRlcnNlY3Rpb246IF9nZXRFZGdlSW50ZXJzZWN0aW9uLFxuXHRfZ2V0Qml0Q29kZTogX2dldEJpdENvZGUsXG5cdF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudDogX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50LFxuXHRpc0ZsYXQ6IGlzRmxhdCxcblx0X2ZsYXQ6IF9mbGF0XG59KTtcblxuLypcclxuICogQG5hbWVzcGFjZSBQb2x5VXRpbFxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5Z29uIGdlb21ldHJpZXMuXHJcbiAqL1xyXG5cclxuLyogQGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50czogUG9pbnRbXSwgYm91bmRzOiBCb3VuZHMsIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W11cclxuICogQ2xpcHMgdGhlIHBvbHlnb24gZ2VvbWV0cnkgZGVmaW5lZCBieSB0aGUgZ2l2ZW4gYHBvaW50c2AgYnkgdGhlIGdpdmVuIGJvdW5kcyAodXNpbmcgdGhlIFtTdXRoZXJsYW5kLUhvZGdtYW4gYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdXRoZXJsYW5kJUUyJTgwJTkzSG9kZ21hbl9hbGdvcml0aG0pKS5cclxuICogVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5Z29uIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmdcclxuICogcGVyZm9ybWFuY2UuIE5vdGUgdGhhdCBwb2x5Z29uIHBvaW50cyBuZWVkcyBkaWZmZXJlbnQgYWxnb3JpdGhtIGZvciBjbGlwcGluZ1xyXG4gKiB0aGFuIHBvbHlsaW5lLCBzbyB0aGVyZSdzIGEgc2VwYXJhdGUgbWV0aG9kIGZvciBpdC5cclxuICovXHJcbmZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50cywgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBjbGlwcGVkUG9pbnRzLFxyXG5cdCAgICBlZGdlcyA9IFsxLCA0LCAyLCA4XSxcclxuXHQgICAgaSwgaiwgayxcclxuXHQgICAgYSwgYixcclxuXHQgICAgbGVuLCBlZGdlLCBwO1xyXG5cclxuXHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHBvaW50c1tpXS5fY29kZSA9IF9nZXRCaXRDb2RlKHBvaW50c1tpXSwgYm91bmRzKTtcclxuXHR9XHJcblxyXG5cdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcclxuXHRmb3IgKGsgPSAwOyBrIDwgNDsgaysrKSB7XHJcblx0XHRlZGdlID0gZWRnZXNba107XHJcblx0XHRjbGlwcGVkUG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuXHRcdFx0YSA9IHBvaW50c1tpXTtcclxuXHRcdFx0YiA9IHBvaW50c1tqXTtcclxuXHJcblx0XHRcdC8vIGlmIGEgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvd1xyXG5cdFx0XHRpZiAoIShhLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHQvLyBpZiBiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGdvZXMgb3V0IG9mIHNjcmVlbilcclxuXHRcdFx0XHRpZiAoYi5fY29kZSAmIGVkZ2UpIHtcclxuXHRcdFx0XHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRcdHAuX2NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRwLl9jb2RlID0gX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59XHJcblxuXG52YXIgUG9seVV0aWwgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0Y2xpcFBvbHlnb246IGNsaXBQb2x5Z29uXG59KTtcblxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBzZWN0aW9uXHJcbiAqIExlYWZsZXQgY29tZXMgd2l0aCBhIHNldCBvZiBhbHJlYWR5IGRlZmluZWQgUHJvamVjdGlvbnMgb3V0IG9mIHRoZSBib3g6XHJcbiAqXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5Mb25MYXRcclxuICpcclxuICogRXF1aXJlY3Rhbmd1bGFyLCBvciBQbGF0ZSBDYXJyZWUgcHJvamVjdGlvbiDigJQgdGhlIG1vc3Qgc2ltcGxlIHByb2plY3Rpb24sXHJcbiAqIG1vc3RseSB1c2VkIGJ5IEdJUyBlbnRodXNpYXN0cy4gRGlyZWN0bHkgbWFwcyBgeGAgYXMgbG9uZ2l0dWRlLCBhbmQgYHlgIGFzXHJcbiAqIGxhdGl0dWRlLiBBbHNvIHN1aXRhYmxlIGZvciBmbGF0IHdvcmxkcywgZS5nLiBnYW1lIG1hcHMuIFVzZWQgYnkgdGhlXHJcbiAqIGBFUFNHOjQzMjZgIGFuZCBgU2ltcGxlYCBDUlMuXHJcbiAqL1xyXG5cclxudmFyIExvbkxhdCA9IHtcclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGxhdGxuZy5sbmcsIGxhdGxuZy5sYXQpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhwb2ludC55LCBwb2ludC54KTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IG5ldyBCb3VuZHMoWy0xODAsIC05MF0sIFsxODAsIDkwXSlcclxufTtcblxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5NZXJjYXRvclxyXG4gKlxyXG4gKiBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIG1vcmUgY29tcGxleCB0aGFuIFNwaGVyaWNhbCBNZXJjYXRvci4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzIGFuIGVsbGlwc29pZC4gVXNlZCBieSB0aGUgRVBTRzozMzk1IENSUy5cclxuICovXHJcblxyXG52YXIgTWVyY2F0b3IgPSB7XHJcblx0UjogNjM3ODEzNyxcclxuXHRSX01JTk9SOiA2MzU2NzUyLjMxNDI0NTE3OSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMjAwMzc1MDguMzQyNzksIC0xNTQ5NjU3MC43Mzk3Ml0sIFsyMDAzNzUwOC4zNDI3OSwgMTg3NjQ2NTYuMjMxMzhdKSxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgeSA9IGxhdGxuZy5sYXQgKiBkLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICBjb24gPSBlICogTWF0aC5zaW4oeSk7XHJcblxyXG5cdFx0dmFyIHRzID0gTWF0aC50YW4oTWF0aC5QSSAvIDQgLSB5IC8gMikgLyBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdHkgPSAtciAqIE1hdGgubG9nKE1hdGgubWF4KHRzLCAxRS0xMCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZyAqIGQgKiByLCB5KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIHRzID0gTWF0aC5leHAoLXBvaW50LnkgLyByKSxcclxuXHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBkcGhpID0gMC4xLCBjb247IGkgPCAxNSAmJiBNYXRoLmFicyhkcGhpKSA+IDFlLTc7IGkrKykge1xyXG5cdFx0XHRjb24gPSBlICogTWF0aC5zaW4ocGhpKTtcclxuXHRcdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHRcdGRwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMgKiBjb24pIC0gcGhpO1xyXG5cdFx0XHRwaGkgKz0gZHBoaTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhwaGkgKiBkLCBwb2ludC54ICogZCAvIHIpO1xyXG5cdH1cclxufTtcblxuLypcbiAqIEBjbGFzcyBQcm9qZWN0aW9uXG5cbiAqIEFuIG9iamVjdCB3aXRoIG1ldGhvZHMgZm9yIHByb2plY3RpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBvbnRvXG4gKiBhIGZsYXQgc3VyZmFjZSAoYW5kIGJhY2spLiBTZWUgW01hcCBwcm9qZWN0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcF9wcm9qZWN0aW9uKS5cblxuICogQHByb3BlcnR5IGJvdW5kczogQm91bmRzXG4gKiBUaGUgYm91bmRzIChzcGVjaWZpZWQgaW4gQ1JTIHVuaXRzKSB3aGVyZSB0aGUgcHJvamVjdGlvbiBpcyB2YWxpZFxuXG4gKiBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxuICogUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gYSAyRCBwb2ludC5cbiAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAqIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xuICogVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLiBQcm9qZWN0cyBhIDJEIHBvaW50IGludG8gYSBnZW9ncmFwaGljYWwgbG9jYXRpb24uXG4gKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAqIE5vdGUgdGhhdCB0aGUgcHJvamVjdGlvbiBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmZXQncyBgQ2xhc3NgIG9iamVjdCxcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxuICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXG5cbiAqL1xuXG5cblxuXG52YXIgaW5kZXggPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0TG9uTGF0OiBMb25MYXQsXG5cdE1lcmNhdG9yOiBNZXJjYXRvcixcblx0U3BoZXJpY2FsTWVyY2F0b3I6IFNwaGVyaWNhbE1lcmNhdG9yXG59KTtcblxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHMzM5NVxyXG4gKlxyXG4gKiBSYXJlbHkgdXNlZCBieSBzb21lIGNvbW1lcmNpYWwgdGlsZSBwcm92aWRlcnMuIFVzZXMgRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLlxyXG4gKi9cclxudmFyIEVQU0czMzk1ID0gZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjMzOTUnLFxyXG5cdHByb2plY3Rpb246IE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcblxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHNDMyNlxyXG4gKlxyXG4gKiBBIGNvbW1vbiBDUlMgYW1vbmcgR0lTIGVudGh1c2lhc3RzLiBVc2VzIHNpbXBsZSBFcXVpcmVjdGFuZ3VsYXIgcHJvamVjdGlvbi5cclxuICpcclxuICogTGVhZmxldCAxLjAueCBjb21wbGllcyB3aXRoIHRoZSBbVE1TIGNvb3JkaW5hdGUgc2NoZW1lIGZvciBFUFNHOjQzMjZdKGh0dHBzOi8vd2lraS5vc2dlby5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlX1NwZWNpZmljYXRpb24jZ2xvYmFsLWdlb2RldGljKSxcclxuICogd2hpY2ggaXMgYSBicmVha2luZyBjaGFuZ2UgZnJvbSAwLjcueCBiZWhhdmlvdXIuICBJZiB5b3UgYXJlIHVzaW5nIGEgYFRpbGVMYXllcmBcclxuICogd2l0aCB0aGlzIENSUywgZW5zdXJlIHRoYXQgdGhlcmUgYXJlIHR3byAyNTZ4MjU2IHBpeGVsIHRpbGVzIGNvdmVyaW5nIHRoZVxyXG4gKiB3aG9sZSBlYXJ0aCBhdCB6b29tIGxldmVsIHplcm8sIGFuZCB0aGF0IHRoZSB0aWxlIGNvb3JkaW5hdGUgb3JpZ2luIGlzICgtMTgwLCs5MCksXHJcbiAqIG9yICgtMTgwLC05MCkgZm9yIGBUaWxlTGF5ZXJgcyB3aXRoIFt0aGUgYHRtc2Agb3B0aW9uXSgjdGlsZWxheWVyLXRtcykgc2V0LlxyXG4gKi9cclxuXHJcbnZhciBFUFNHNDMyNiA9IGV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzo0MzI2JyxcclxuXHRwcm9qZWN0aW9uOiBMb25MYXQsXHJcblx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSAvIDE4MCwgMSwgLTEgLyAxODAsIDAuNSlcclxufSk7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIENSU1xuICogQGNycyBMLkNSUy5TaW1wbGVcbiAqXG4gKiBBIHNpbXBsZSBDUlMgdGhhdCBtYXBzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgaW50byBgeGAgYW5kIGB5YCBkaXJlY3RseS5cbiAqIE1heSBiZSB1c2VkIGZvciBtYXBzIG9mIGZsYXQgc3VyZmFjZXMgKGUuZy4gZ2FtZSBtYXBzKS4gTm90ZSB0aGF0IHRoZSBgeWBcbiAqIGF4aXMgc2hvdWxkIHN0aWxsIGJlIGludmVydGVkIChnb2luZyBmcm9tIGJvdHRvbSB0byB0b3ApLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogc2ltcGxlIGV1Y2xpZGVhbiBkaXN0YW5jZS5cbiAqL1xuXG52YXIgU2ltcGxlID0gZXh0ZW5kKHt9LCBDUlMsIHtcblx0cHJvamVjdGlvbjogTG9uTGF0LFxuXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxLCAwLCAtMSwgMCksXG5cblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0cmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xuXHR9LFxuXG5cdHpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSkgLyBNYXRoLkxOMjtcblx0fSxcblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgZHggPSBsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nLFxuXHRcdCAgICBkeSA9IGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQ7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0fSxcblxuXHRpbmZpbml0ZTogdHJ1ZVxufSk7XG5cbkNSUy5FYXJ0aCA9IEVhcnRoO1xuQ1JTLkVQU0czMzk1ID0gRVBTRzMzOTU7XG5DUlMuRVBTRzM4NTcgPSBFUFNHMzg1NztcbkNSUy5FUFNHOTAwOTEzID0gRVBTRzkwMDkxMztcbkNSUy5FUFNHNDMyNiA9IEVQU0c0MzI2O1xuQ1JTLlNpbXBsZSA9IFNpbXBsZTtcblxuLypcbiAqIEBjbGFzcyBMYXllclxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIEBha2EgTC5MYXllclxuICogQGFrYSBJTGF5ZXJcbiAqXG4gKiBBIHNldCBvZiBtZXRob2RzIGZyb20gdGhlIExheWVyIGJhc2UgY2xhc3MgdGhhdCBhbGwgTGVhZmxldCBsYXllcnMgdXNlLlxuICogSW5oZXJpdHMgYWxsIG1ldGhvZHMsIG9wdGlvbnMgYW5kIGV2ZW50cyBmcm9tIGBMLkV2ZW50ZWRgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwubWFya2VyKGxhdGxuZykuYWRkVG8obWFwKTtcbiAqIGxheWVyLmFkZFRvKG1hcCk7XG4gKiBsYXllci5yZW1vdmUoKTtcbiAqIGBgYFxuICpcbiAqIEBldmVudCBhZGQ6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gYSBtYXBcbiAqXG4gKiBAZXZlbnQgcmVtb3ZlOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIG1hcFxuICovXG5cblxudmFyIExheWVyID0gRXZlbnRlZC5leHRlbmQoe1xuXG5cdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnb3ZlcmxheVBhbmUnXG5cdFx0Ly8gQnkgZGVmYXVsdCB0aGUgbGF5ZXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwJ3MgW292ZXJsYXkgcGFuZV0oI21hcC1vdmVybGF5cGFuZSkuIE92ZXJyaWRpbmcgdGhpcyBvcHRpb24gd2lsbCBjYXVzZSB0aGUgbGF5ZXIgdG8gYmUgcGxhY2VkIG9uIGFub3RoZXIgcGFuZSBieSBkZWZhdWx0LlxuXHRcdHBhbmU6ICdvdmVybGF5UGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIGF0dHJpYnV0aW9uOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gU3RyaW5nIHRvIGJlIHNob3duIGluIHRoZSBhdHRyaWJ1dGlvbiBjb250cm9sLCBlLmcuIFwiwqkgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnNcIi4gSXQgZGVzY3JpYmVzIHRoZSBsYXllciBkYXRhIGFuZCBpcyBvZnRlbiBhIGxlZ2FsIG9ibGlnYXRpb24gdG93YXJkcyBjb3B5cmlnaHQgaG9sZGVycyBhbmQgdGlsZSBwcm92aWRlcnMuXG5cdFx0YXR0cmlidXRpb246IG51bGwsXG5cblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiB0cnVlXG5cdH0sXG5cblx0LyogQHNlY3Rpb25cblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG5cdCAqXG5cdCAqIEBtZXRob2QgYWRkVG8obWFwOiBNYXB8TGF5ZXJHcm91cCk6IHRoaXNcblx0ICogQWRkcyB0aGUgbGF5ZXIgdG8gdGhlIGdpdmVuIG1hcCBvciBsYXllciBncm91cC5cblx0ICovXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVGcm9tKHRoaXMuX21hcCB8fCB0aGlzLl9tYXBUb0FkZCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKG1hcDogTWFwKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBnaXZlbiBtYXBcblx0cmVtb3ZlRnJvbTogZnVuY3Rpb24gKG9iaikge1xuXHRcdGlmIChvYmopIHtcblx0XHRcdG9iai5yZW1vdmVMYXllcih0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRQYW5lKG5hbWU/IDogU3RyaW5nKTogSFRNTEVsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCByZXByZXNlbnRpbmcgdGhlIG5hbWVkIHBhbmUgb24gdGhlIG1hcC4gSWYgYG5hbWVgIGlzIG9taXR0ZWQsIHJldHVybnMgdGhlIHBhbmUgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldFBhbmU6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hcC5nZXRQYW5lKG5hbWUgPyAodGhpcy5vcHRpb25zW25hbWVdIHx8IG5hbWUpIDogdGhpcy5vcHRpb25zLnBhbmUpO1xuXHR9LFxuXG5cdGFkZEludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHR0aGlzLl9tYXAuX3RhcmdldHNbc3RhbXAodGFyZ2V0RWwpXSA9IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdGRlbGV0ZSB0aGlzLl9tYXAuX3RhcmdldHNbc3RhbXAodGFyZ2V0RWwpXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEF0dHJpYnV0aW9uOiBTdHJpbmdcblx0Ly8gVXNlZCBieSB0aGUgYGF0dHJpYnV0aW9uIGNvbnRyb2xgLCByZXR1cm5zIHRoZSBbYXR0cmlidXRpb24gb3B0aW9uXSgjZ3JpZGxheWVyLWF0dHJpYnV0aW9uKS5cblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuXHR9LFxuXG5cdF9sYXllckFkZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gZS50YXJnZXQ7XG5cblx0XHQvLyBjaGVjayBpbiBjYXNlIGxheWVyIGdldHMgYWRkZWQgYW5kIHRoZW4gcmVtb3ZlZCBiZWZvcmUgdGhlIG1hcCBpcyByZWFkeVxuXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xuXG5cdFx0aWYgKHRoaXMuZ2V0RXZlbnRzKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5nZXRFdmVudHMoKTtcblx0XHRcdG1hcC5vbihldmVudHMsIHRoaXMpO1xuXHRcdFx0dGhpcy5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdG1hcC5vZmYoZXZlbnRzLCB0aGlzKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMub25BZGQobWFwKTtcblxuXHRcdGlmICh0aGlzLmdldEF0dHJpYnV0aW9uICYmIG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcblx0XHRcdG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuYWRkQXR0cmlidXRpb24odGhpcy5nZXRBdHRyaWJ1dGlvbigpKTtcblx0XHR9XG5cblx0XHR0aGlzLmZpcmUoJ2FkZCcpO1xuXHRcdG1hcC5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogdGhpc30pO1xuXHR9XG59KTtcblxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAqIEB1bmluaGVyaXRhYmxlXG4gKlxuICogRXZlcnkgbGF5ZXIgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkxheWVyYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxuICpcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBjb2RlIHRoYXQgY3JlYXRlcyBET00gZWxlbWVudHMgZm9yIHRoZSBsYXllciwgYWRkcyB0aGVtIHRvIGBtYXAgcGFuZXNgIHdoZXJlIHRoZXkgc2hvdWxkIGJlbG9uZyBhbmQgcHV0cyBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLlxuICpcbiAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxheWVyJ3MgZWxlbWVudHMgZnJvbSB0aGUgRE9NIGFuZCByZW1vdmVzIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjbGF5ZXItb25hZGQpLiBDYWxsZWQgb24gW2BtYXAucmVtb3ZlTGF5ZXIobGF5ZXIpYF0oI21hcC1yZW1vdmVsYXllcikuXG4gKlxuICogQG1ldGhvZCBnZXRFdmVudHMoKTogT2JqZWN0XG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBsaWtlIGB7IHZpZXdyZXNldDogdGhpcy5fcmVzZXQgfWAgZm9yIFtgYWRkRXZlbnRMaXN0ZW5lcmBdKCNldmVudGVkLWFkZGV2ZW50bGlzdGVuZXIpLiBUaGUgZXZlbnQgaGFuZGxlcnMgaW4gdGhpcyBvYmplY3Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIG1hcCB3aXRoIHlvdXIgbGF5ZXIuXG4gKlxuICogQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbigpOiBTdHJpbmdcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgY29udGFpbmluZyBIVE1MIHRvIGJlIHNob3duIG9uIHRoZSBgQXR0cmlidXRpb24gY29udHJvbGAgd2hlbmV2ZXIgdGhlIGxheWVyIGlzIHZpc2libGUuXG4gKlxuICogQG1ldGhvZCBiZWZvcmVBZGQobWFwOiBNYXApOiB0aGlzXG4gKiBPcHRpb25hbCBtZXRob2QuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKSwgYmVmb3JlIHRoZSBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLCBiZWZvcmUgZXZlbnRzIGFyZSBpbml0aWFsaXplZCwgd2l0aG91dCB3YWl0aW5nIHVudGlsIHRoZSBtYXAgaXMgaW4gYSB1c2FibGUgc3RhdGUuIFVzZSBmb3IgZWFybHkgaW5pdGlhbGl6YXRpb24gb25seS5cbiAqL1xuXG5cbi8qIEBuYW1lc3BhY2UgTWFwXG4gKiBAc2VjdGlvbiBMYXllciBldmVudHNcbiAqXG4gKiBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gYSBuZXcgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAqXG4gKiBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gc29tZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcFxuICpcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAqL1xuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIG1hcFxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCFsYXllci5fbGF5ZXJBZGQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIG9iamVjdCBpcyBub3QgYSBMYXllci4nKTtcblx0XHR9XG5cblx0XHR2YXIgaWQgPSBzdGFtcChsYXllcik7XG5cdFx0aWYgKHRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XG5cblx0XHRsYXllci5fbWFwVG9BZGQgPSB0aGlzO1xuXG5cdFx0aWYgKGxheWVyLmJlZm9yZUFkZCkge1xuXHRcdFx0bGF5ZXIuYmVmb3JlQWRkKHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMud2hlblJlYWR5KGxheWVyLl9sYXllckFkZCwgbGF5ZXIpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIG1hcC5cblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IHN0YW1wKGxheWVyKTtcblxuXHRcdGlmICghdGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLmdldEF0dHJpYnV0aW9uICYmIHRoaXMuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHR0aGlzLmF0dHJpYnV0aW9uQ29udHJvbC5yZW1vdmVBdHRyaWJ1dGlvbihsYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcblx0XHR9XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XG5cdFx0XHRsYXllci5maXJlKCdyZW1vdmUnKTtcblx0XHR9XG5cblx0XHRsYXllci5fbWFwID0gbGF5ZXIuX21hcFRvQWRkID0gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBtYXBcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHJldHVybiAhIWxheWVyICYmIChzdGFtcChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcblx0fSxcblxuXHQvKiBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXG5cdCAqIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgbWFwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXG5cdCAqIGBgYFxuXHQgKiBtYXAuZWFjaExheWVyKGZ1bmN0aW9uKGxheWVyKXtcblx0ICogICAgIGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcblx0ICogfSk7XG5cdCAqIGBgYFxuXHQgKi9cblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9hZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcblx0XHRsYXllcnMgPSBsYXllcnMgPyAoaXNBcnJheShsYXllcnMpID8gbGF5ZXJzIDogW2xheWVyc10pIDogW107XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChpc05hTihsYXllci5vcHRpb25zLm1heFpvb20pIHx8ICFpc05hTihsYXllci5vcHRpb25zLm1pblpvb20pKSB7XG5cdFx0XHR0aGlzLl96b29tQm91bmRMYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBzdGFtcChsYXllcik7XG5cblx0XHRpZiAodGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF07XG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVab29tTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1pblpvb20gPSBJbmZpbml0eSxcblx0XHQgICAgbWF4Wm9vbSA9IC1JbmZpbml0eSxcblx0XHQgICAgb2xkWm9vbVNwYW4gPSB0aGlzLl9nZXRab29tU3BhbigpO1xuXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2ldLm9wdGlvbnM7XG5cblx0XHRcdG1pblpvb20gPSBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IG1pblpvb20gOiBNYXRoLm1pbihtaW5ab29tLCBvcHRpb25zLm1pblpvb20pO1xuXHRcdFx0bWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gbWF4Wm9vbSA6IE1hdGgubWF4KG1heFpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGF5ZXJzTWF4Wm9vbSA9IG1heFpvb20gPT09IC1JbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1heFpvb207XG5cdFx0dGhpcy5fbGF5ZXJzTWluWm9vbSA9IG1pblpvb20gPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbWluWm9vbTtcblxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHpvb21sZXZlbHNjaGFuZ2U6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHpvb21sZXZlbHMgb24gdGhlIG1hcCBpcyBjaGFuZ2VkIGR1ZVxuXHRcdC8vIHRvIGFkZGluZyBvciByZW1vdmluZyBhIGxheWVyLlxuXHRcdGlmIChvbGRab29tU3BhbiAhPT0gdGhpcy5fZ2V0Wm9vbVNwYW4oKSkge1xuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWF4Wm9vbSAmJiB0aGlzLmdldFpvb20oKSA+IHRoaXMuX2xheWVyc01heFpvb20pIHtcblx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNYXhab29tKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWluWm9vbSAmJiB0aGlzLmdldFpvb20oKSA8IHRoaXMuX2xheWVyc01pblpvb20pIHtcblx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNaW5ab29tKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vKlxyXG4gKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gKiBAYWthIEwuTGF5ZXJHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICpcclxuICogVXNlZCB0byBncm91cCBzZXZlcmFsIGxheWVycyBhbmQgaGFuZGxlIHRoZW0gYXMgb25lLiBJZiB5b3UgYWRkIGl0IHRvIHRoZSBtYXAsXHJcbiAqIGFueSBsYXllcnMgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgb24gdGhlIG1hcCBhc1xyXG4gKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubGF5ZXJHcm91cChbbWFya2VyMSwgbWFya2VyMl0pXHJcbiAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgTGF5ZXJHcm91cCA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0dmFyIGksIGxlbjtcclxuXHJcblx0XHRpZiAobGF5ZXJzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBncm91cC5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihpZDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElEIGZyb20gdGhlIGdyb3VwLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIoaWQ6IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gISFsYXllciAmJiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzIHx8IHRoaXMuZ2V0TGF5ZXJJZChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsZWFyTGF5ZXJzKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFsbCB0aGUgbGF5ZXJzIGZyb20gdGhlIGdyb3VwLlxyXG5cdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZW1vdmVMYXllciwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZva2UobWV0aG9kTmFtZTogU3RyaW5nLCDigKYpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYG1ldGhvZE5hbWVgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIGFueVxyXG5cdC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVycy4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgbGF5ZXJzIGNvbnRhaW5lZCBkbyBub3RcclxuXHQvLyBpbXBsZW1lbnQgYG1ldGhvZE5hbWVgLlxyXG5cdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuXHRcdCAgICBpLCBsYXllcjtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcblx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5hZGRMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobWFwLnJlbW92ZUxheWVyLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIGdyb3VwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXHJcblx0Ly8gYGBganNcclxuXHQvLyBncm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0Ly8gXHRsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XHJcblx0Ly8gfSk7XHJcblx0Ly8gYGBgXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcihpZDogTnVtYmVyKTogTGF5ZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRC5cclxuXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVycygpOiBMYXllcltdXHJcblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGxheWVycyBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLmVhY2hMYXllcihsYXllcnMucHVzaCwgbGF5ZXJzKTtcclxuXHRcdHJldHVybiBsYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYHNldFpJbmRleGAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgdGhlIHotaW5kZXguXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcklkKGxheWVyOiBMYXllcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGludGVybmFsIElEIGZvciBhIGxheWVyXHJcblx0Z2V0TGF5ZXJJZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gc3RhbXAobGF5ZXIpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXllckdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbi8vIENyZWF0ZSBhIGxheWVyIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycyBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxudmFyIGxheWVyR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllckdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbn07XG5cbi8qXHJcbiAqIEBjbGFzcyBGZWF0dXJlR3JvdXBcclxuICogQGFrYSBMLkZlYXR1cmVHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJHcm91cFxyXG4gKlxyXG4gKiBFeHRlbmRlZCBgTGF5ZXJHcm91cGAgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gZG8gdGhlIHNhbWUgdGhpbmcgdG8gYWxsIGl0cyBtZW1iZXIgbGF5ZXJzOlxyXG4gKiAgKiBbYGJpbmRQb3B1cGBdKCNsYXllci1iaW5kcG9wdXApIGJpbmRzIGEgcG9wdXAgdG8gYWxsIG9mIHRoZSBsYXllcnMgYXQgb25jZSAobGlrZXdpc2Ugd2l0aCBbYGJpbmRUb29sdGlwYF0oI2xheWVyLWJpbmR0b29sdGlwKSlcclxuICogICogRXZlbnRzIGFyZSBwcm9wYWdhdGVkIHRvIHRoZSBgRmVhdHVyZUdyb3VwYCwgc28gaWYgdGhlIGdyb3VwIGhhcyBhbiBldmVudFxyXG4gKiBoYW5kbGVyLCBpdCB3aWxsIGhhbmRsZSBldmVudHMgZnJvbSBhbnkgb2YgdGhlIGxheWVycy4gVGhpcyBpbmNsdWRlcyBtb3VzZSBldmVudHNcclxuICogYW5kIGN1c3RvbSBldmVudHMuXHJcbiAqICAqIEhhcyBgbGF5ZXJhZGRgIGFuZCBgbGF5ZXJyZW1vdmVgIGV2ZW50c1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmZlYXR1cmVHcm91cChbbWFya2VyMSwgbWFya2VyMiwgcG9seWxpbmVdKVxyXG4gKiBcdC5iaW5kUG9wdXAoJ0hlbGxvIHdvcmxkIScpXHJcbiAqIFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBhbGVydCgnQ2xpY2tlZCBvbiBhIG1lbWJlciBvZiB0aGUgZ3JvdXAhJyk7IH0pXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBGZWF0dXJlR3JvdXAgPSBMYXllckdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMYXllckdyb3VwLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyBhZGRlZCB0byB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxheWVyIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcl07XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnaXZlbiBwYXRoIG9wdGlvbnMgdG8gZWFjaCBsYXllciBvZiB0aGUgZ3JvdXAgdGhhdCBoYXMgYSBgc2V0U3R5bGVgIG1ldGhvZC5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFN0eWxlJywgc3R5bGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvRnJvbnQnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSBiYWNrIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvQmFjaycpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGUgRmVhdHVyZSBHcm91cCAoY3JlYXRlZCBmcm9tIGJvdW5kcyBhbmQgY29vcmRpbmF0ZXMgb2YgaXRzIGNoaWxkcmVuKS5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XHJcblx0XHRcdGJvdW5kcy5leHRlbmQobGF5ZXIuZ2V0Qm91bmRzID8gbGF5ZXIuZ2V0Qm91bmRzKCkgOiBsYXllci5nZXRMYXRMbmcoKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmZlYXR1cmVHcm91cChsYXllcnM6IExheWVyW10pXHJcbi8vIENyZWF0ZSBhIGZlYXR1cmUgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzLlxyXG52YXIgZmVhdHVyZUdyb3VwID0gZnVuY3Rpb24gKGxheWVycykge1xyXG5cdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcbn07XG5cbi8qXHJcbiAqIEBjbGFzcyBJY29uXHJcbiAqIEBha2EgTC5JY29uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gaWNvbiB0byBwcm92aWRlIHdoZW4gY3JlYXRpbmcgYSBtYXJrZXIuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBteUljb24gPSBMLmljb24oe1xyXG4gKiAgICAgaWNvblVybDogJ215LWljb24ucG5nJyxcclxuICogICAgIGljb25SZXRpbmFVcmw6ICdteS1pY29uQDJ4LnBuZycsXHJcbiAqICAgICBpY29uU2l6ZTogWzM4LCA5NV0sXHJcbiAqICAgICBpY29uQW5jaG9yOiBbMjIsIDk0XSxcclxuICogICAgIHBvcHVwQW5jaG9yOiBbLTMsIC03Nl0sXHJcbiAqICAgICBzaGFkb3dVcmw6ICdteS1pY29uLXNoYWRvdy5wbmcnLFxyXG4gKiAgICAgc2hhZG93UmV0aW5hVXJsOiAnbXktaWNvbi1zaGFkb3dAMngucG5nJyxcclxuICogICAgIHNoYWRvd1NpemU6IFs2OCwgOTVdLFxyXG4gKiAgICAgc2hhZG93QW5jaG9yOiBbMjIsIDk0XVxyXG4gKiB9KTtcclxuICpcclxuICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIGBMLkljb24uRGVmYXVsdGAgZXh0ZW5kcyBgTC5JY29uYCBhbmQgaXMgdGhlIGJsdWUgaWNvbiBMZWFmbGV0IHVzZXMgZm9yIG1hcmtlcnMgYnkgZGVmYXVsdC5cclxuICpcclxuICovXHJcblxyXG52YXIgSWNvbiA9IENsYXNzLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBJY29uIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqICoqKHJlcXVpcmVkKSoqIFRoZSBVUkwgdG8gdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXIgc2NyaXB0IHBhdGgpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uUmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byBhIHJldGluYSBzaXplZCB2ZXJzaW9uIG9mIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyXHJcblx0ICogc2NyaXB0IHBhdGgpLiBVc2VkIGZvciBSZXRpbmEgc2NyZWVuIGRldmljZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25TaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBpY29uIGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvbkFuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBpY29uIChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKS4gVGhlIGljb25cclxuXHQgKiB3aWxsIGJlIGFsaWduZWQgc28gdGhhdCB0aGlzIHBvaW50IGlzIGF0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24uIENlbnRlcmVkXHJcblx0ICogYnkgZGVmYXVsdCBpZiBzaXplIGlzIHNwZWNpZmllZCwgYWxzbyBjYW4gYmUgc2V0IGluIENTUyB3aXRoIG5lZ2F0aXZlIG1hcmdpbnMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvcHVwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCBwb3B1cHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiB0b29sdGlwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCB0b29sdGlwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1VybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gdGhlIGljb24gc2hhZG93IGltYWdlLiBJZiBub3Qgc3BlY2lmaWVkLCBubyBzaGFkb3cgaW1hZ2Ugd2lsbCBiZSBjcmVhdGVkLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dSZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93U2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgc2hhZG93IGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93QW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIHNoYWRvdyAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikgKHRoZSBzYW1lXHJcblx0ICogYXMgaWNvbkFuY2hvciBpZiBub3Qgc3BlY2lmaWVkKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdCAqIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIGJvdGggaWNvbiBhbmQgc2hhZG93IGltYWdlcy4gRW1wdHkgYnkgZGVmYXVsdC5cclxuXHQgKi9cclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9wdXBBbmNob3I6IFswLCAwXSxcclxuXHRcdHRvb2x0aXBBbmNob3I6IFswLCAwXVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlSWNvbihvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gdGhlIGljb24gaGFzIHRvIGJlIHNob3duLCByZXR1cm5zIGEgYDxpbWc+YCBIVE1MIGVsZW1lbnRcclxuXHQvLyBzdHlsZWQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zLlxyXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignaWNvbicsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlU2hhZG93KG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQXMgYGNyZWF0ZUljb25gLCBidXQgZm9yIHRoZSBzaGFkb3cgYmVuZWF0aCBpdC5cclxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignc2hhZG93Jywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUljb246IGZ1bmN0aW9uIChuYW1lLCBvbGRJY29uKSB7XHJcblx0XHR2YXIgc3JjID0gdGhpcy5fZ2V0SWNvblVybChuYW1lKTtcclxuXHJcblx0XHRpZiAoIXNyYykge1xyXG5cdFx0XHRpZiAobmFtZSA9PT0gJ2ljb24nKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpY29uVXJsIG5vdCBzZXQgaW4gSWNvbiBvcHRpb25zIChzZWUgdGhlIGRvY3MpLicpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbWcgPSB0aGlzLl9jcmVhdGVJbWcoc3JjLCBvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0lNRycgPyBvbGRJY29uIDogbnVsbCk7XHJcblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGltZywgbmFtZSk7XHJcblxyXG5cdFx0cmV0dXJuIGltZztcclxuXHR9LFxyXG5cclxuXHRfc2V0SWNvblN0eWxlczogZnVuY3Rpb24gKGltZywgbmFtZSkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0XHR2YXIgc2l6ZU9wdGlvbiA9IG9wdGlvbnNbbmFtZSArICdTaXplJ107XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBzaXplT3B0aW9uID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRzaXplT3B0aW9uID0gW3NpemVPcHRpb24sIHNpemVPcHRpb25dO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzaXplID0gdG9Qb2ludChzaXplT3B0aW9uKSxcclxuXHRcdCAgICBhbmNob3IgPSB0b1BvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG5cdFx0ICAgICAgICAgICAgc2l6ZSAmJiBzaXplLmRpdmlkZUJ5KDIsIHRydWUpKTtcclxuXHJcblx0XHRpbWcuY2xhc3NOYW1lID0gJ2xlYWZsZXQtbWFya2VyLScgKyBuYW1lICsgJyAnICsgKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKTtcclxuXHJcblx0XHRpZiAoYW5jaG9yKSB7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1hbmNob3IueCkgKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luVG9wICA9ICgtYW5jaG9yLnkpICsgJ3B4JztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2l6ZSkge1xyXG5cdFx0XHRpbWcuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuXHRcdGVsID0gZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblx0XHRlbC5zcmMgPSBzcmM7XHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRyZXR1cm4gcmV0aW5hICYmIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddIHx8IHRoaXMub3B0aW9uc1tuYW1lICsgJ1VybCddO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5pY29uKG9wdGlvbnM6IEljb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBpY29uIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXHJcbmZ1bmN0aW9uIGljb24ob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgSWNvbihvcHRpb25zKTtcclxufVxuXG4vKlxuICogQG1pbmljbGFzcyBJY29uLkRlZmF1bHQgKEljb24pXG4gKiBAYWthIEwuSWNvbi5EZWZhdWx0XG4gKiBAc2VjdGlvblxuICpcbiAqIEEgdHJpdmlhbCBzdWJjbGFzcyBvZiBgSWNvbmAsIHJlcHJlc2VudHMgdGhlIGljb24gdG8gdXNlIGluIGBNYXJrZXJgcyB3aGVuXG4gKiBubyBpY29uIGlzIHNwZWNpZmllZC4gUG9pbnRzIHRvIHRoZSBibHVlIG1hcmtlciBpbWFnZSBkaXN0cmlidXRlZCB3aXRoIExlYWZsZXRcbiAqIHJlbGVhc2VzLlxuICpcbiAqIEluIG9yZGVyIHRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBpY29uLCBqdXN0IGNoYW5nZSB0aGUgcHJvcGVydGllcyBvZiBgTC5JY29uLkRlZmF1bHQucHJvdG90eXBlLm9wdGlvbnNgXG4gKiAod2hpY2ggaXMgYSBzZXQgb2YgYEljb24gb3B0aW9uc2ApLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIF9jb21wbGV0ZWx5XyByZXBsYWNlIHRoZSBkZWZhdWx0IGljb24sIG92ZXJyaWRlIHRoZVxuICogYEwuTWFya2VyLnByb3RvdHlwZS5vcHRpb25zLmljb25gIHdpdGggeW91ciBvd24gaWNvbiBpbnN0ZWFkLlxuICovXG5cbnZhciBJY29uRGVmYXVsdCA9IEljb24uZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0aWNvblVybDogICAgICAgJ21hcmtlci1pY29uLnBuZycsXG5cdFx0aWNvblJldGluYVVybDogJ21hcmtlci1pY29uLTJ4LnBuZycsXG5cdFx0c2hhZG93VXJsOiAgICAgJ21hcmtlci1zaGFkb3cucG5nJyxcblx0XHRpY29uU2l6ZTogICAgWzI1LCA0MV0sXG5cdFx0aWNvbkFuY2hvcjogIFsxMiwgNDFdLFxuXHRcdHBvcHVwQW5jaG9yOiBbMSwgLTM0XSxcblx0XHR0b29sdGlwQW5jaG9yOiBbMTYsIC0yOF0sXG5cdFx0c2hhZG93U2l6ZTogIFs0MSwgNDFdXG5cdH0sXG5cblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKCFJY29uRGVmYXVsdC5pbWFnZVBhdGgpIHtcdC8vIERlcHJlY2F0ZWQsIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IG9ubHlcblx0XHRcdEljb25EZWZhdWx0LmltYWdlUGF0aCA9IHRoaXMuX2RldGVjdEljb25QYXRoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gQG9wdGlvbiBpbWFnZVBhdGg6IFN0cmluZ1xuXHRcdC8vIGBJY29uLkRlZmF1bHRgIHdpbGwgdHJ5IHRvIGF1dG8tZGV0ZWN0IHRoZSBsb2NhdGlvbiBvZiB0aGVcblx0XHQvLyBibHVlIGljb24gaW1hZ2VzLiBJZiB5b3UgYXJlIHBsYWNpbmcgdGhlc2UgaW1hZ2VzIGluIGEgbm9uLXN0YW5kYXJkXG5cdFx0Ly8gd2F5LCBzZXQgdGhpcyBvcHRpb24gdG8gcG9pbnQgdG8gdGhlIHJpZ2h0IHBhdGguXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuaW1hZ2VQYXRoIHx8IEljb25EZWZhdWx0LmltYWdlUGF0aCkgKyBJY29uLnByb3RvdHlwZS5fZ2V0SWNvblVybC5jYWxsKHRoaXMsIG5hbWUpO1xuXHR9LFxuXG5cdF9kZXRlY3RJY29uUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlbCA9IGNyZWF0ZSQxKCdkaXYnLCAgJ2xlYWZsZXQtZGVmYXVsdC1pY29uLXBhdGgnLCBkb2N1bWVudC5ib2R5KTtcblx0XHR2YXIgcGF0aCA9IGdldFN0eWxlKGVsLCAnYmFja2dyb3VuZC1pbWFnZScpIHx8XG5cdFx0ICAgICAgICAgICBnZXRTdHlsZShlbCwgJ2JhY2tncm91bmRJbWFnZScpO1x0Ly8gSUU4XG5cblx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcblxuXHRcdGlmIChwYXRoID09PSBudWxsIHx8IHBhdGguaW5kZXhPZigndXJsJykgIT09IDApIHtcblx0XHRcdHBhdGggPSAnJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aCA9IHBhdGgucmVwbGFjZSgvXnVybFxcKFtcIiddPy8sICcnKS5yZXBsYWNlKC9tYXJrZXItaWNvblxcLnBuZ1tcIiddP1xcKSQvLCAnJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhdGg7XG5cdH1cbn0pO1xuXG4vKlxuICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXJrZXJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gKlxuICogSW50ZXJhY3Rpb24gaGFuZGxlcnMgYXJlIHByb3BlcnRpZXMgb2YgYSBtYXJrZXIgaW5zdGFuY2UgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbCBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoIGFzIGRyYWdnaW5nIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICogYGBgXG4gKlxuICogQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLiBPbmx5IHZhbGlkIHdoZW4gdGhlIG1hcmtlciBpcyBvbiB0aGUgbWFwIChPdGhlcndpc2Ugc2V0IFtgbWFya2VyLm9wdGlvbnMuZHJhZ2dhYmxlYF0oI21hcmtlci1kcmFnZ2FibGUpKS5cbiAqL1xuXG52YXIgTWFya2VyRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdHRoaXMuX21hcmtlciA9IG1hcmtlcjtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpY29uID0gdGhpcy5fbWFya2VyLl9pY29uO1xuXG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoaWNvbiwgaWNvbiwgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRwcmVkcmFnOiB0aGlzLl9vblByZURyYWcsXG5cdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHR9LCB0aGlzKS5lbmFibGUoKTtcblxuXHRcdGFkZENsYXNzKGljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5vZmYoe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXIuX2ljb24pIHtcblx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcmtlci5faWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHRcdH1cblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIG1hcCA9IG1hcmtlci5fbWFwLFxuXHRcdCAgICBzcGVlZCA9IHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5TcGVlZCxcblx0XHQgICAgcGFkZGluZyA9IHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5QYWRkaW5nLFxuXHRcdCAgICBpY29uUG9zID0gZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcblx0XHQgICAgYm91bmRzID0gbWFwLmdldFBpeGVsQm91bmRzKCksXG5cdFx0ICAgIG9yaWdpbiA9IG1hcC5nZXRQaXhlbE9yaWdpbigpO1xuXG5cdFx0dmFyIHBhbkJvdW5kcyA9IHRvQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi5fc3VidHJhY3Qob3JpZ2luKS5hZGQocGFkZGluZyksXG5cdFx0XHRib3VuZHMubWF4Ll9zdWJ0cmFjdChvcmlnaW4pLnN1YnRyYWN0KHBhZGRpbmcpXG5cdFx0KTtcblxuXHRcdGlmICghcGFuQm91bmRzLmNvbnRhaW5zKGljb25Qb3MpKSB7XG5cdFx0XHQvLyBDb21wdXRlIGluY3JlbWVudGFsIG1vdmVtZW50XG5cdFx0XHR2YXIgbW92ZW1lbnQgPSB0b1BvaW50KFxuXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1heC54KSAvIChib3VuZHMubWF4LnggLSBwYW5Cb3VuZHMubWF4LngpIC1cblx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5taW4ueCkgLyAoYm91bmRzLm1pbi54IC0gcGFuQm91bmRzLm1pbi54KSxcblxuXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC55LCBpY29uUG9zLnkpIC0gcGFuQm91bmRzLm1heC55KSAvIChib3VuZHMubWF4LnkgLSBwYW5Cb3VuZHMubWF4LnkpIC1cblx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5taW4ueSkgLyAoYm91bmRzLm1pbi55IC0gcGFuQm91bmRzLm1pbi55KVxuXHRcdFx0KS5tdWx0aXBseUJ5KHNwZWVkKTtcblxuXHRcdFx0bWFwLnBhbkJ5KG1vdmVtZW50LCB7YW5pbWF0ZTogZmFsc2V9KTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuX2FkZChtb3ZlbWVudCk7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLl9hZGQobW92ZW1lbnQpO1xuXG5cdFx0XHRzZXRQb3NpdGlvbihtYXJrZXIuX2ljb24sIHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zKTtcblx0XHRcdHRoaXMuX29uRHJhZyhlKTtcblxuXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBAc2VjdGlvbiBEcmFnZ2luZyBldmVudHNcblx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdGFydHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblxuXHRcdHRoaXMuX29sZExhdExuZyA9IHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKTtcblx0XHR0aGlzLl9tYXJrZXJcblx0XHQgICAgLmNsb3NlUG9wdXAoKVxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXHR9LFxuXG5cdF9vblByZURyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW4pIHtcblx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuXHRcdCAgICBzaGFkb3cgPSBtYXJrZXIuX3NoYWRvdyxcblx0XHQgICAgaWNvblBvcyA9IGdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGxhdGxuZyA9IG1hcmtlci5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhpY29uUG9zKTtcblxuXHRcdC8vIHVwZGF0ZSBzaGFkb3cgcG9zaXRpb25cblx0XHRpZiAoc2hhZG93KSB7XG5cdFx0XHRzZXRQb3NpdGlvbihzaGFkb3csIGljb25Qb3MpO1xuXHRcdH1cblxuXHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuXHRcdGUubGF0bG5nID0gbGF0bG5nO1xuXHRcdGUub2xkTGF0TG5nID0gdGhpcy5fb2xkTGF0TG5nO1xuXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgbWFya2VyLlxuXHRcdG1hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0IGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdG9wcyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXHRcdGRlbGV0ZSB0aGlzLl9vbGRMYXRMbmc7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlZW5kJylcblx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblx0fVxufSk7XG5cbi8qXHJcbiAqIEBjbGFzcyBNYXJrZXJcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqIEBha2EgTC5NYXJrZXJcclxuICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBNYXJrZXIgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgTWFya2VyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGljb246IEljb24gPSAqXHJcblx0XHQvLyBJY29uIGluc3RhbmNlIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBtYXJrZXIuXHJcblx0XHQvLyBTZWUgW0ljb24gZG9jdW1lbnRhdGlvbl0oI0wuSWNvbikgZm9yIGRldGFpbHMgb24gaG93IHRvIGN1c3RvbWl6ZSB0aGUgbWFya2VyIGljb24uXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkLCBhIGNvbW1vbiBpbnN0YW5jZSBvZiBgTC5JY29uLkRlZmF1bHRgIGlzIHVzZWQuXHJcblx0XHRpY29uOiBuZXcgSWNvbkRlZmF1bHQoKSxcclxuXHJcblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXHJcblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGNhbiBiZSB0YWJiZWQgdG8gd2l0aCBhIGtleWJvYXJkIGFuZCBjbGlja2VkIGJ5IHByZXNzaW5nIGVudGVyLlxyXG5cdFx0a2V5Ym9hcmQ6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0aXRsZTogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBicm93c2VyIHRvb2x0aXAgdGhhdCBhcHBlYXIgb24gbWFya2VyIGhvdmVyIChubyB0b29sdGlwIGJ5IGRlZmF1bHQpLlxyXG5cdFx0dGl0bGU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaWNvbiBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXhPZmZzZXQ6IE51bWJlciA9IDBcclxuXHRcdC8vIEJ5IGRlZmF1bHQsIG1hcmtlciBpbWFnZXMgekluZGV4IGlzIHNldCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIGl0cyBsYXRpdHVkZS4gVXNlIHRoaXMgb3B0aW9uIGlmIHlvdSB3YW50IHRvIHB1dCB0aGUgbWFya2VyIG9uIHRvcCBvZiBhbGwgb3RoZXJzIChvciBiZWxvdyksIHNwZWNpZnlpbmcgYSBoaWdoIHZhbHVlIGxpa2UgYDEwMDBgIChvciBoaWdoIG5lZ2F0aXZlIHZhbHVlLCByZXNwZWN0aXZlbHkpLlxyXG5cdFx0ekluZGV4T2Zmc2V0OiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG5cdFx0b3BhY2l0eTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPbkhvdmVyOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIG1hcmtlciB3aWxsIGdldCBvbiB0b3Agb2Ygb3RoZXJzIHdoZW4geW91IGhvdmVyIHRoZSBtb3VzZSBvdmVyIGl0LlxyXG5cdFx0cmlzZU9uSG92ZXI6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmlzZU9mZnNldDogTnVtYmVyID0gMjUwXHJcblx0XHQvLyBUaGUgei1pbmRleCBvZmZzZXQgdXNlZCBmb3IgdGhlIGByaXNlT25Ib3ZlcmAgZmVhdHVyZS5cclxuXHRcdHJpc2VPZmZzZXQ6IDI1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdtYXJrZXJQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBpY29uIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAnbWFya2VyUGFuZScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnc2hhZG93UGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgc2hhZG93IHdpbGwgYmUgYWRkZWQuXHJcblx0XHRzaGFkb3dQYW5lOiAnc2hhZG93UGFuZScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgbWFya2VyIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXHJcblx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cclxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIERyYWdnYWJsZSBtYXJrZXIgb3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBkcmFnZ2FibGU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cclxuXHRcdGRyYWdnYWJsZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdG8gcGFuIHRoZSBtYXAgd2hlbiBkcmFnZ2luZyB0aGlzIG1hcmtlciBuZWFyIGl0cyBlZGdlIG9yIG5vdC5cclxuXHRcdGF1dG9QYW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNTAsIDUwKVxyXG5cdFx0Ly8gRGlzdGFuY2UgKGluIHBpeGVscyB0byB0aGUgbGVmdC9yaWdodCBhbmQgdG8gdGhlIHRvcC9ib3R0b20pIG9mIHRoZVxyXG5cdFx0Ly8gbWFwIGVkZ2UgdG8gc3RhcnQgcGFubmluZyB0aGUgbWFwLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1MCwgNTBdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblNwZWVkOiBOdW1iZXIgPSAxMFxyXG5cdFx0Ly8gTnVtYmVyIG9mIHBpeGVscyB0aGUgbWFwIHNob3VsZCBwYW4gYnkuXHJcblx0XHRhdXRvUGFuU3BlZWQ6IDEwXHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKlxyXG5cdCAqIEluIGFkZGl0aW9uIHRvIFtzaGFyZWQgbGF5ZXIgbWV0aG9kc10oI0xheWVyKSBsaWtlIGBhZGRUbygpYCBhbmQgYHJlbW92ZSgpYCBhbmQgW3BvcHVwIG1ldGhvZHNdKCNQb3B1cCkgbGlrZSBiaW5kUG9wdXAoKSB5b3UgY2FuIGFsc28gdXNlIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IHRoaXMuX3pvb21BbmltYXRlZCAmJiBtYXAub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5kcmFnZ2luZy5lbmFibGVkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLmRyYWdnYWJsZSA9IHRydWU7XHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSB0aGlzLmRyYWdnaW5nO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR6b29tOiB0aGlzLnVwZGF0ZSxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLnVwZGF0ZVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBwb2ludC5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjbWFya2VyLXNldGxhdGxuZykgb3IgYnkgW2RyYWdnaW5nXSgjbWFya2VyLWRyYWdnaW5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4T2Zmc2V0KG9mZnNldDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXggb2Zmc2V0XSgjbWFya2VyLXppbmRleG9mZnNldCkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRaSW5kZXhPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQgPSBvZmZzZXQ7XHJcblx0XHRyZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEljb246IEljb25cclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGljb24gdXNlZCBieSB0aGUgbWFya2VyXHJcblx0Z2V0SWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0SWNvbihpY29uOiBJY29uKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBpY29uLlxyXG5cdHNldEljb246IGZ1bmN0aW9uIChpY29uKSB7XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLmljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5iaW5kUG9wdXAodGhpcy5fcG9wdXAsIHRoaXMuX3BvcHVwLm9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pY29uO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uICYmIHRoaXMuX21hcCkge1xyXG5cdFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgY2xhc3NUb0FkZCA9ICdsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcclxuXHJcblx0XHR2YXIgaWNvbiA9IG9wdGlvbnMuaWNvbi5jcmVhdGVJY29uKHRoaXMuX2ljb24pLFxyXG5cdFx0ICAgIGFkZEljb24gPSBmYWxzZTtcclxuXHJcblx0XHQvLyBpZiB3ZSdyZSBub3QgcmV1c2luZyB0aGUgaWNvbiwgcmVtb3ZlIHRoZSBvbGQgb25lIGFuZCBpbml0IG5ldyBvbmVcclxuXHRcdGlmIChpY29uICE9PSB0aGlzLl9pY29uKSB7XHJcblx0XHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGFkZEljb24gPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMudGl0bGUpIHtcclxuXHRcdFx0XHRpY29uLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGljb24udGFnTmFtZSA9PT0gJ0lNRycpIHtcclxuXHRcdFx0XHRpY29uLmFsdCA9IG9wdGlvbnMuYWx0IHx8ICcnO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0YWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcclxuXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5ld1NoYWRvdyA9IG9wdGlvbnMuaWNvbi5jcmVhdGVTaGFkb3codGhpcy5fc2hhZG93KSxcclxuXHRcdCAgICBhZGRTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdykge1xyXG5cdFx0XHRhZGRDbGFzcyhuZXdTaGFkb3csIGNsYXNzVG9BZGQpO1xyXG5cdFx0XHRuZXdTaGFkb3cuYWx0ID0gJyc7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBuZXdTaGFkb3c7XHJcblxyXG5cclxuXHRcdGlmIChvcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKGFkZEljb24pIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faWNvbik7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuXHRcdGlmIChuZXdTaGFkb3cgJiYgYWRkU2hhZG93KSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZShvcHRpb25zLnNoYWRvd1BhbmUpLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vZmYoe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZW1vdmUodGhpcy5faWNvbik7XHJcblx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0cmVtb3ZlKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRQb3M6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9pY29uLCBwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0c2V0UG9zaXRpb24odGhpcy5fc2hhZG93LCBwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3pJbmRleCA9IHBvcy55ICsgdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldDtcclxuXHJcblx0XHR0aGlzLl9yZXNldFpJbmRleCgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdHRoaXMuX2ljb24uc3R5bGUuekluZGV4ID0gdGhpcy5fekluZGV4ICsgb2Zmc2V0O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKG9wdCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgb3B0Lnpvb20sIG9wdC5jZW50ZXIpLnJvdW5kKCk7XHJcblxyXG5cdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0fSxcclxuXHJcblx0X2luaXRJbnRlcmFjdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGFkZENsYXNzKHRoaXMuX2ljb24sICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblxyXG5cdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHRpZiAoTWFya2VyRHJhZykge1xyXG5cdFx0XHR2YXIgZHJhZ2dhYmxlID0gdGhpcy5vcHRpb25zLmRyYWdnYWJsZTtcclxuXHRcdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuXHRcdFx0XHRkcmFnZ2FibGUgPSB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKTtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmRpc2FibGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5kcmFnZ2luZyA9IG5ldyBNYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKGRyYWdnYWJsZSkge1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9pY29uLCBvcGFjaXR5KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHNldE9wYWNpdHkodGhpcy5fc2hhZG93LCBvcGFjaXR5KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgodGhpcy5vcHRpb25zLnJpc2VPZmZzZXQpO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldFpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KDApO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRQb3B1cEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMucG9wdXBBbmNob3I7XHJcblx0fSxcclxuXHJcblx0X2dldFRvb2x0aXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnRvb2x0aXBBbmNob3I7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIE1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcbmZ1bmN0aW9uIG1hcmtlcihsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG59XG5cbi8qXG4gKiBAY2xhc3MgUGF0aFxuICogQGFrYSBMLlBhdGhcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxuICpcbiAqIEFuIGFic3RyYWN0IGNsYXNzIHRoYXQgY29udGFpbnMgb3B0aW9ucyBhbmQgY29uc3RhbnRzIHNoYXJlZCBiZXR3ZWVuIHZlY3RvclxuICogb3ZlcmxheXMgKFBvbHlnb24sIFBvbHlsaW5lLCBDaXJjbGUpLiBEbyBub3QgdXNlIGl0IGRpcmVjdGx5LiBFeHRlbmRzIGBMYXllcmAuXG4gKi9cblxudmFyIFBhdGggPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUGF0aCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHN0cm9rZTogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGV0aGVyIHRvIGRyYXcgc3Ryb2tlIGFsb25nIHRoZSBwYXRoLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRzdHJva2U6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGNvbG9yOiBTdHJpbmcgPSAnIzMzODhmZidcblx0XHQvLyBTdHJva2UgY29sb3Jcblx0XHRjb2xvcjogJyMzMzg4ZmYnLFxuXG5cdFx0Ly8gQG9wdGlvbiB3ZWlnaHQ6IE51bWJlciA9IDNcblx0XHQvLyBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG5cdFx0d2VpZ2h0OiAzLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBTdHJva2Ugb3BhY2l0eVxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVDYXA6IFN0cmluZz0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVDYXA6ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVKb2luOiBTdHJpbmcgPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBjb3JuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lam9pbikgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lSm9pbjogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gZGFzaEFycmF5OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hBcnJheTogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZGFzaE9mZnNldDogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgW2Rpc3RhbmNlIGludG8gdGhlIGRhc2ggcGF0dGVybiB0byBzdGFydCB0aGUgZGFzaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaG9mZnNldCkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoT2Zmc2V0OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsOiBCb29sZWFuID0gZGVwZW5kc1xuXHRcdC8vIFdoZXRoZXIgdG8gZmlsbCB0aGUgcGF0aCB3aXRoIGNvbG9yLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGZpbGxpbmcgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRmaWxsOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gZmlsbENvbG9yOiBTdHJpbmcgPSAqXG5cdFx0Ly8gRmlsbCBjb2xvci4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBbYGNvbG9yYF0oI3BhdGgtY29sb3IpIG9wdGlvblxuXHRcdGZpbGxDb2xvcjogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbE9wYWNpdHk6IE51bWJlciA9IDAuMlxuXHRcdC8vIEZpbGwgb3BhY2l0eS5cblx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsUnVsZTogU3RyaW5nID0gJ2V2ZW5vZGQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cblx0XHRmaWxsUnVsZTogJ2V2ZW5vZGQnLFxuXG5cdFx0Ly8gY2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3Ncblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIHBhdGggd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcblx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiB0cnVlXG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0Ly8gUmVuZGVyZXIgaXMgc2V0IGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIGNhbGwgcmVuZGVyZXIuZ2V0RXZlbnRzXG5cdFx0Ly8gYmVmb3JlIHRoaXMuZ2V0RXZlbnRzLlxuXHRcdHRoaXMuX3JlbmRlcmVyID0gbWFwLmdldFJlbmRlcmVyKHRoaXMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2luaXRQYXRoKHRoaXMpO1xuXHRcdHRoaXMuX3Jlc2V0KCk7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2FkZFBhdGgodGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdygpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIGxheWVyLiBTb21ldGltZXMgdXNlZnVsIGFmdGVyIHlvdSBjaGFuZ2VkIHRoZSBjb29yZGluYXRlcyB0aGF0IHRoZSBwYXRoIHVzZXMuXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIGFwcGVhcmFuY2Ugb2YgYSBQYXRoIGJhc2VkIG9uIHRoZSBvcHRpb25zIGluIHRoZSBgUGF0aCBvcHRpb25zYCBvYmplY3QuXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcblx0XHRzZXRPcHRpb25zKHRoaXMsIHN0eWxlKTtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKTtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlICYmIHN0eWxlLmhhc093blByb3BlcnR5KCd3ZWlnaHQnKSkge1xuXHRcdFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHBhdGggbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvRnJvbnQodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHBhdGggbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9CYWNrKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gZGVmaW5lZCBpbiBjaGlsZCBjbGFzc2VzXG5cdFx0dGhpcy5fcHJvamVjdCgpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9jbGlja1RvbGVyYW5jZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHVzZWQgd2hlbiBkb2luZyBoaXQgZGV0ZWN0aW9uIGZvciBDYW52YXMgbGF5ZXJzXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuc3Ryb2tlID8gdGhpcy5vcHRpb25zLndlaWdodCAvIDIgOiAwKSArIHRoaXMuX3JlbmRlcmVyLm9wdGlvbnMudG9sZXJhbmNlO1xuXHR9XG59KTtcblxuLypcbiAqIEBjbGFzcyBDaXJjbGVNYXJrZXJcbiAqIEBha2EgTC5DaXJjbGVNYXJrZXJcbiAqIEBpbmhlcml0cyBQYXRoXG4gKlxuICogQSBjaXJjbGUgb2YgYSBmaXhlZCBzaXplIHdpdGggcmFkaXVzIHNwZWNpZmllZCBpbiBwaXhlbHMuIEV4dGVuZHMgYFBhdGhgLlxuICovXG5cbnZhciBDaXJjbGVNYXJrZXIgPSBQYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDaXJjbGVNYXJrZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXIgPSAxMFxuXHRcdC8vIFJhZGl1cyBvZiB0aGUgY2lyY2xlIG1hcmtlciwgaW4gcGl4ZWxzXG5cdFx0cmFkaXVzOiAxMFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRMbmc6IExhdExuZyk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYSBjaXJjbGUgbWFya2VyIHRvIGEgbmV3IGxvY2F0aW9uLlxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0dGhpcy5yZWRyYXcoKTtcblxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjY2lyY2xlbWFya2VyLXNldGxhdGxuZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmcoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZSBtYXJrZXIuIFVuaXRzIGFyZSBpbiBwaXhlbHMuXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuXHRcdHRoaXMub3B0aW9ucy5yYWRpdXMgPSB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIHRoZSBjaXJjbGVcblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cztcblx0fSxcblxuXHRzZXRTdHlsZSA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0dmFyIHJhZGl1cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yYWRpdXMgfHwgdGhpcy5fcmFkaXVzO1xuXHRcdFBhdGgucHJvdG90eXBlLnNldFN0eWxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5zZXRSYWRpdXMocmFkaXVzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9LFxuXG5cdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgciA9IHRoaXMuX3JhZGl1cyxcblx0XHQgICAgcjIgPSB0aGlzLl9yYWRpdXNZIHx8IHIsXG5cdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdCAgICBwID0gW3IgKyB3LCByMiArIHddO1xuXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludC5zdWJ0cmFjdChwKSwgdGhpcy5fcG9pbnQuYWRkKHApKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVDaXJjbGUodGhpcyk7XG5cdH0sXG5cblx0X2VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cyAmJiAhdGhpcy5fcmVuZGVyZXIuX2JvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX3B4Qm91bmRzKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xuXHRcdHJldHVybiBwLmRpc3RhbmNlVG8odGhpcy5fcG9pbnQpIDw9IHRoaXMuX3JhZGl1cyArIHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY2lyY2xlTWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlTWFya2VyIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgbWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuZnVuY3Rpb24gY2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IENpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xufVxuXG4vKlxuICogQGNsYXNzIENpcmNsZVxuICogQGFrYSBMLkNpcmNsZVxuICogQGluaGVyaXRzIENpcmNsZU1hcmtlclxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgY2lyY2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBDaXJjbGVNYXJrZXJgLlxuICpcbiAqIEl0J3MgYW4gYXBwcm94aW1hdGlvbiBhbmQgc3RhcnRzIHRvIGRpdmVyZ2UgZnJvbSBhIHJlYWwgY2lyY2xlIGNsb3NlciB0byBwb2xlcyAoZHVlIHRvIHByb2plY3Rpb24gZGlzdG9ydGlvbikuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jaXJjbGUoWzUwLjUsIDMwLjVdLCB7cmFkaXVzOiAyMDB9KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxudmFyIENpcmNsZSA9IENpcmNsZU1hcmtlci5leHRlbmQoe1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGZhY3RvcnkgKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zPylcblx0XHRcdG9wdGlvbnMgPSBleHRlbmQoe30sIGxlZ2FjeU9wdGlvbnMsIHtyYWRpdXM6IG9wdGlvbnN9KTtcblx0XHR9XG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXG5cdFx0aWYgKGlzTmFOKHRoaXMub3B0aW9ucy5yYWRpdXMpKSB7IHRocm93IG5ldyBFcnJvcignQ2lyY2xlIHJhZGl1cyBjYW5ub3QgYmUgTmFOJyk7IH1cblxuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBDaXJjbGUgb3B0aW9uc1xuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXI7IFJhZGl1cyBvZiB0aGUgY2lyY2xlLCBpbiBtZXRlcnMuXG5cdFx0dGhpcy5fbVJhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGhhbGYgPSBbdGhpcy5fcmFkaXVzLCB0aGlzLl9yYWRpdXNZIHx8IHRoaXMuX3JhZGl1c107XG5cblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuc3VidHJhY3QoaGFsZikpLFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5hZGQoaGFsZikpKTtcblx0fSxcblxuXHRzZXRTdHlsZTogUGF0aC5wcm90b3R5cGUuc2V0U3R5bGUsXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBsbmcgPSB0aGlzLl9sYXRsbmcubG5nLFxuXHRcdCAgICBsYXQgPSB0aGlzLl9sYXRsbmcubGF0LFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuXHRcdGlmIChjcnMuZGlzdGFuY2UgPT09IEVhcnRoLmRpc3RhbmNlKSB7XG5cdFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHQgICAgbGF0UiA9ICh0aGlzLl9tUmFkaXVzIC8gRWFydGguUikgLyBkLFxuXHRcdFx0ICAgIHRvcCA9IG1hcC5wcm9qZWN0KFtsYXQgKyBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBib3R0b20gPSBtYXAucHJvamVjdChbbGF0IC0gbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgcCA9IHRvcC5hZGQoYm90dG9tKS5kaXZpZGVCeSgyKSxcblx0XHRcdCAgICBsYXQyID0gbWFwLnVucHJvamVjdChwKS5sYXQsXG5cdFx0XHQgICAgbG5nUiA9IE1hdGguYWNvcygoTWF0aC5jb3MobGF0UiAqIGQpIC0gTWF0aC5zaW4obGF0ICogZCkgKiBNYXRoLnNpbihsYXQyICogZCkpIC9cblx0XHRcdCAgICAgICAgICAgIChNYXRoLmNvcyhsYXQgKiBkKSAqIE1hdGguY29zKGxhdDIgKiBkKSkpIC8gZDtcblxuXHRcdFx0aWYgKGlzTmFOKGxuZ1IpIHx8IGxuZ1IgPT09IDApIHtcblx0XHRcdFx0bG5nUiA9IGxhdFIgLyBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogbGF0KTsgLy8gRmFsbGJhY2sgZm9yIGVkZ2UgY2FzZSwgIzI0MjVcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBwLnN1YnRyYWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IGlzTmFOKGxuZ1IpID8gMCA6IHAueCAtIG1hcC5wcm9qZWN0KFtsYXQyLCBsbmcgLSBsbmdSXSkueDtcblx0XHRcdHRoaXMuX3JhZGl1c1kgPSBwLnkgLSB0b3AueTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGF0bG5nMiA9IGNycy51bnByb2plY3QoY3JzLnByb2plY3QodGhpcy5fbGF0bG5nKS5zdWJ0cmFjdChbdGhpcy5fbVJhZGl1cywgMF0pKTtcblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLl9wb2ludC54IC0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcyKS54O1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25zIG9iamVjdFxuLy8gd2hpY2ggY29udGFpbnMgdGhlIGNpcmNsZSByYWRpdXMuXG4vLyBAYWx0ZXJuYXRpdmVcbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCByYWRpdXM6IE51bWJlciwgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gT2Jzb2xldGUgd2F5IG9mIGluc3RhbnRpYXRpbmcgYSBjaXJjbGUsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggY29kZS5cbi8vIERvIG5vdCB1c2UgaW4gbmV3IGFwcGxpY2F0aW9ucyBvciBwbHVnaW5zLlxuZnVuY3Rpb24gY2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IENpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpO1xufVxuXG4vKlxuICogQGNsYXNzIFBvbHlsaW5lXG4gKiBAYWthIEwuUG9seWxpbmVcbiAqIEBpbmhlcml0cyBQYXRoXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5bGluZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUGF0aGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFs0NS41MSwgLTEyMi42OF0sXG4gKiBcdFszNy43NywgLTEyMi40M10sXG4gKiBcdFszNC4wNCwgLTExOC4yXVxuICogXTtcbiAqXG4gKiB2YXIgcG9seWxpbmUgPSBMLnBvbHlsaW5lKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWxpbmVcbiAqIG1hcC5maXRCb3VuZHMocG9seWxpbmUuZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBgTXVsdGlQb2x5bGluZWAgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIGFycmF5cyBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0W1s0NS41MSwgLTEyMi42OF0sXG4gKiBcdCBbMzcuNzcsIC0xMjIuNDNdLFxuICogXHQgWzM0LjA0LCAtMTE4LjJdXSxcbiAqIFx0W1s0MC43OCwgLTczLjkxXSxcbiAqIFx0IFs0MS44MywgLTg3LjYyXSxcbiAqIFx0IFszMi43NiwgLTk2LjcyXV1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG5cbnZhciBQb2x5bGluZSA9IFBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBvbHlsaW5lIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gc21vb3RoRmFjdG9yOiBOdW1iZXIgPSAxLjBcblx0XHQvLyBIb3cgbXVjaCB0byBzaW1wbGlmeSB0aGUgcG9seWxpbmUgb24gZWFjaCB6b29tIGxldmVsLiBNb3JlIG1lYW5zXG5cdFx0Ly8gYmV0dGVyIHBlcmZvcm1hbmNlIGFuZCBzbW9vdGhlciBsb29rLCBhbmQgbGVzcyBtZWFucyBtb3JlIGFjY3VyYXRlIHJlcHJlc2VudGF0aW9uLlxuXHRcdHNtb290aEZhY3RvcjogMS4wLFxuXG5cdFx0Ly8gQG9wdGlvbiBub0NsaXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIERpc2FibGUgcG9seWxpbmUgY2xpcHBpbmcuXG5cdFx0bm9DbGlwOiBmYWxzZVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5ncygpOiBMYXRMbmdbXVxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBwb2ludHMgaW4gdGhlIHBhdGgsIG9yIG5lc3RlZCBhcnJheXMgb2YgcG9pbnRzIGluIGNhc2Ugb2YgbXVsdGktcG9seWxpbmUuXG5cdGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldExhdExuZ3MobGF0bG5nczogTGF0TG5nW10pOiB0aGlzXG5cdC8vIFJlcGxhY2VzIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBwb2x5bGluZSB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzLlxuXHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0VtcHR5KCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFBvbHlsaW5lIGhhcyBubyBMYXRMbmdzLlxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3Nlc3RMYXllclBvaW50KHA6IFBvaW50KTogUG9pbnRcblx0Ly8gUmV0dXJucyB0aGUgcG9pbnQgY2xvc2VzdCB0byBgcGAgb24gdGhlIFBvbHlsaW5lLlxuXHRjbG9zZXN0TGF5ZXJQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eSxcblx0XHQgICAgbWluUG9pbnQgPSBudWxsLFxuXHRcdCAgICBjbG9zZXN0ID0gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50LFxuXHRcdCAgICBwMSwgcDI7XG5cblx0XHRmb3IgKHZhciBqID0gMCwgakxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuXHRcdFx0dmFyIHBvaW50cyA9IHRoaXMuX3BhcnRzW2pdO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHAxID0gcG9pbnRzW2kgLSAxXTtcblx0XHRcdFx0cDIgPSBwb2ludHNbaV07XG5cblx0XHRcdFx0dmFyIHNxRGlzdCA9IGNsb3Nlc3QocCwgcDEsIHAyLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoc3FEaXN0IDwgbWluRGlzdGFuY2UpIHtcblx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IHNxRGlzdDtcblx0XHRcdFx0XHRtaW5Qb2ludCA9IGNsb3Nlc3QocCwgcDEsIHAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobWluUG9pbnQpIHtcblx0XHRcdG1pblBvaW50LmRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1pblBvaW50O1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwb2x5bGluZS5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblxuXHRcdHZhciBpLCBoYWxmRGlzdCwgc2VnRGlzdCwgZGlzdCwgcDEsIHAyLCByYXRpbyxcblx0XHQgICAgcG9pbnRzID0gdGhpcy5fcmluZ3NbMF0sXG5cdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm4gbnVsbDsgfVxuXG5cdFx0Ly8gcG9seWxpbmUgY2VudHJvaWQgYWxnb3JpdGhtOyBvbmx5IHVzZXMgdGhlIGZpcnN0IHJpbmcgaWYgdGhlcmUgYXJlIG11bHRpcGxlXG5cblx0XHRmb3IgKGkgPSAwLCBoYWxmRGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcblx0XHRcdGhhbGZEaXN0ICs9IHBvaW50c1tpXS5kaXN0YW5jZVRvKHBvaW50c1tpICsgMV0pIC8gMjtcblx0XHR9XG5cblx0XHQvLyBUaGUgbGluZSBpcyBzbyBzbWFsbCBpbiB0aGUgY3VycmVudCB2aWV3IHRoYXQgYWxsIHBvaW50cyBhcmUgb24gdGhlIHNhbWUgcGl4ZWwuXG5cdFx0aWYgKGhhbGZEaXN0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhwb2ludHNbMF0pO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG5cdFx0XHRwMSA9IHBvaW50c1tpXTtcblx0XHRcdHAyID0gcG9pbnRzW2kgKyAxXTtcblx0XHRcdHNlZ0Rpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcblx0XHRcdGRpc3QgKz0gc2VnRGlzdDtcblxuXHRcdFx0aWYgKGRpc3QgPiBoYWxmRGlzdCkge1xuXHRcdFx0XHRyYXRpbyA9IChkaXN0IC0gaGFsZkRpc3QpIC8gc2VnRGlzdDtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoW1xuXHRcdFx0XHRcdHAyLnggLSByYXRpbyAqIChwMi54IC0gcDEueCksXG5cdFx0XHRcdFx0cDIueSAtIHJhdGlvICogKHAyLnkgLSBwMS55KVxuXHRcdFx0XHRdKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYWRkTGF0TG5nKGxhdGxuZzogTGF0TG5nLCBsYXRsbmdzPyBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gQWRkcyBhIGdpdmVuIHBvaW50IHRvIHRoZSBwb2x5bGluZS4gQnkgZGVmYXVsdCwgYWRkcyB0byB0aGUgZmlyc3QgcmluZyBvZlxuXHQvLyB0aGUgcG9seWxpbmUgaW4gY2FzZSBvZiBhIG11bHRpLXBvbHlsaW5lLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZ1xuXHQvLyBhIHNwZWNpZmljIHJpbmcgYXMgYSBMYXRMbmcgYXJyYXkgKHRoYXQgeW91IGNhbiBlYXJsaWVyIGFjY2VzcyB3aXRoIFtgZ2V0TGF0TG5nc2BdKCNwb2x5bGluZS1nZXRsYXRsbmdzKSkuXG5cdGFkZExhdExuZzogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuXHRcdGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2RlZmF1bHRTaGFwZSgpO1xuXHRcdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XG5cdFx0dGhpcy5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcblx0XHR0aGlzLl9sYXRsbmdzID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBpc0ZsYXQodGhpcy5fbGF0bG5ncykgPyB0aGlzLl9sYXRsbmdzIDogdGhpcy5fbGF0bG5nc1swXTtcblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSBjb252ZXJ0IGxhdGxuZ3MgaW5wdXQgaW50byBhY3R1YWwgTGF0TG5nIGluc3RhbmNlczsgY2FsY3VsYXRlIGJvdW5kcyBhbG9uZyB0aGUgd2F5XG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0ICAgIGZsYXQgPSBpc0ZsYXQobGF0bG5ncyk7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGZsYXQpIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQocmVzdWx0W2ldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3NbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5cdFx0dGhpcy5fcmluZ3MgPSBbXTtcblx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyh0aGlzLl9sYXRsbmdzLCB0aGlzLl9yaW5ncywgcHhCb3VuZHMpO1xuXG5cdFx0aWYgKHRoaXMuX2JvdW5kcy5pc1ZhbGlkKCkgJiYgcHhCb3VuZHMuaXNWYWxpZCgpKSB7XG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcyA9IHB4Qm91bmRzO1xuXHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKFtcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1pbi5zdWJ0cmFjdChwKSxcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1heC5hZGQocClcblx0XHRdKTtcblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSB0dXJucyBsYXRsbmdzIGludG8gYSBzZXQgb2YgcmluZ3Mgd2l0aCBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0X3Byb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAobGF0bG5ncywgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpIHtcblx0XHR2YXIgZmxhdCA9IGxhdGxuZ3NbMF0gaW5zdGFuY2VvZiBMYXRMbmcsXG5cdFx0ICAgIGxlbiA9IGxhdGxuZ3MubGVuZ3RoLFxuXHRcdCAgICBpLCByaW5nO1xuXG5cdFx0aWYgKGZsYXQpIHtcblx0XHRcdHJpbmcgPSBbXTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyaW5nW2ldID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdzW2ldKTtcblx0XHRcdFx0cHJvamVjdGVkQm91bmRzLmV4dGVuZChyaW5nW2ldKTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdC5wdXNoKHJpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3MobGF0bG5nc1tpXSwgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBjbGlwIHBvbHlsaW5lIGJ5IHJlbmRlcmVyIGJvdW5kcyBzbyB0aGF0IHdlIGhhdmUgbGVzcyB0byByZW5kZXIgZm9yIHBlcmZvcm1hbmNlXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHM7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICBpLCBqLCBrLCBsZW4sIGxlbjIsIHNlZ21lbnQsIHBvaW50cztcblxuXHRcdGZvciAoaSA9IDAsIGsgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cG9pbnRzID0gdGhpcy5fcmluZ3NbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMiAtIDE7IGorKykge1xuXHRcdFx0XHRzZWdtZW50ID0gY2xpcFNlZ21lbnQocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdLCBib3VuZHMsIGosIHRydWUpO1xuXG5cdFx0XHRcdGlmICghc2VnbWVudCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHBhcnRzW2tdID0gcGFydHNba10gfHwgW107XG5cdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFswXSk7XG5cblx0XHRcdFx0Ly8gaWYgc2VnbWVudCBnb2VzIG91dCBvZiBzY3JlZW4sIG9yIGl0J3MgdGhlIGxhc3Qgb25lLCBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmUgcGFydFxuXHRcdFx0XHRpZiAoKHNlZ21lbnRbMV0gIT09IHBvaW50c1tqICsgMV0pIHx8IChqID09PSBsZW4yIC0gMikpIHtcblx0XHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMV0pO1xuXHRcdFx0XHRcdGsrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmUgZm9yIHBlcmZvcm1hbmNlXG5cdF9zaW1wbGlmeVBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICB0b2xlcmFuY2UgPSB0aGlzLm9wdGlvbnMuc21vb3RoRmFjdG9yO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0c1tpXSA9IHNpbXBsaWZ5KHBhcnRzW2ldLCB0b2xlcmFuY2UpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jbGlwUG9pbnRzKCk7XG5cdFx0dGhpcy5fc2ltcGxpZnlQb2ludHMoKTtcblx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCwgY2xvc2VkKSB7XG5cdFx0dmFyIGksIGosIGssIGxlbiwgbGVuMiwgcGFydCxcblx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIGhpdCBkZXRlY3Rpb24gZm9yIHBvbHlsaW5lc1xuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0XHRpZiAoIWNsb3NlZCAmJiAoaiA9PT0gMCkpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRpZiAocG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwYXJ0W2tdLCBwYXJ0W2pdKSA8PSB3KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5wb2x5bGluZShsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBwb2x5bGluZSBvYmplY3QgZ2l2ZW4gYW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cyBhbmRcbi8vIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuIFlvdSBjYW4gY3JlYXRlIGEgYFBvbHlsaW5lYCBvYmplY3Qgd2l0aFxuLy8gbXVsdGlwbGUgc2VwYXJhdGUgbGluZXMgKGBNdWx0aVBvbHlsaW5lYCkgYnkgcGFzc2luZyBhbiBhcnJheSBvZiBhcnJheXNcbi8vIG9mIGdlb2dyYXBoaWMgcG9pbnRzLlxuZnVuY3Rpb24gcG9seWxpbmUobGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xufVxuXG4vLyBSZXRyb2NvbXBhdC4gQWxsb3cgcGx1Z2lucyB0byBzdXBwb3J0IExlYWZsZXQgdmVyc2lvbnMgYmVmb3JlIGFuZCBhZnRlciAxLjEuXG5Qb2x5bGluZS5fZmxhdCA9IF9mbGF0O1xuXG4vKlxuICogQGNsYXNzIFBvbHlnb25cbiAqIEBha2EgTC5Qb2x5Z29uXG4gKiBAaW5oZXJpdHMgUG9seWxpbmVcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlnb24gb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlsaW5lYC5cbiAqXG4gKiBOb3RlIHRoYXQgcG9pbnRzIHlvdSBwYXNzIHdoZW4gY3JlYXRpbmcgYSBwb2x5Z29uIHNob3VsZG4ndCBoYXZlIGFuIGFkZGl0aW9uYWwgbGFzdCBwb2ludCBlcXVhbCB0byB0aGUgZmlyc3Qgb25lIOKAlCBpdCdzIGJldHRlciB0byBmaWx0ZXIgb3V0IHN1Y2ggcG9pbnRzLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWdvbiBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dO1xuICpcbiAqIHZhciBwb2x5Z29uID0gTC5wb2x5Z29uKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWdvblxuICogbWFwLmZpdEJvdW5kcyhwb2x5Z29uLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB3aXRoIHRoZSBmaXJzdCBhcnJheSByZXByZXNlbnRpbmcgdGhlIG91dGVyIHNoYXBlIGFuZCB0aGUgb3RoZXIgYXJyYXlzIHJlcHJlc2VudGluZyBob2xlcyBpbiB0aGUgb3V0ZXIgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAqICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAqIF07XG4gKiBgYGBcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIE11bHRpUG9seWdvbiBzaGFwZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFsgLy8gZmlyc3QgcG9seWdvblxuICogICAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICogICAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gKiAgIF0sXG4gKiAgIFsgLy8gc2Vjb25kIHBvbHlnb25cbiAqICAgICBbWzQxLCAtMTExLjAzXSxbNDUsIC0xMTEuMDRdLFs0NSwgLTEwNC4wNV0sWzQxLCAtMTA0LjA1XV1cbiAqICAgXVxuICogXTtcbiAqIGBgYFxuICovXG5cbnZhciBQb2x5Z29uID0gUG9seWxpbmUuZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZVxuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoIHx8ICF0aGlzLl9sYXRsbmdzWzBdLmxlbmd0aDtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGksIGosIHAxLCBwMiwgZiwgYXJlYSwgeCwgeSwgY2VudGVyLFxuXHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcblx0XHQgICAgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cblx0XHQvLyBwb2x5Z29uIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0YXJlYSA9IHggPSB5ID0gMDtcblxuXHRcdGZvciAoaSA9IDAsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XG5cdFx0XHRwMSA9IHBvaW50c1tpXTtcblx0XHRcdHAyID0gcG9pbnRzW2pdO1xuXG5cdFx0XHRmID0gcDEueSAqIHAyLnggLSBwMi55ICogcDEueDtcblx0XHRcdHggKz0gKHAxLnggKyBwMi54KSAqIGY7XG5cdFx0XHR5ICs9IChwMS55ICsgcDIueSkgKiBmO1xuXHRcdFx0YXJlYSArPSBmICogMztcblx0XHR9XG5cblx0XHRpZiAoYXJlYSA9PT0gMCkge1xuXHRcdFx0Ly8gUG9seWdvbiBpcyBzbyBzbWFsbCB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHNhbWUgcGl4ZWwuXG5cdFx0XHRjZW50ZXIgPSBwb2ludHNbMF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNlbnRlciA9IFt4IC8gYXJlYSwgeSAvIGFyZWFdO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhjZW50ZXIpO1xuXHR9LFxuXG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gUG9seWxpbmUucHJvdG90eXBlLl9jb252ZXJ0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpLFxuXHRcdCAgICBsZW4gPSByZXN1bHQubGVuZ3RoO1xuXG5cdFx0Ly8gcmVtb3ZlIGxhc3QgcG9pbnQgaWYgaXQgZXF1YWxzIGZpcnN0IG9uZVxuXHRcdGlmIChsZW4gPj0gMiAmJiByZXN1bHRbMF0gaW5zdGFuY2VvZiBMYXRMbmcgJiYgcmVzdWx0WzBdLmVxdWFscyhyZXN1bHRbbGVuIC0gMV0pKSB7XG5cdFx0XHRyZXN1bHQucG9wKCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0UG9seWxpbmUucHJvdG90eXBlLl9zZXRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyk7XG5cdFx0aWYgKGlzRmxhdCh0aGlzLl9sYXRsbmdzKSkge1xuXHRcdFx0dGhpcy5fbGF0bG5ncyA9IFt0aGlzLl9sYXRsbmdzXTtcblx0XHR9XG5cdH0sXG5cblx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBpc0ZsYXQodGhpcy5fbGF0bG5nc1swXSkgPyB0aGlzLl9sYXRsbmdzWzBdIDogdGhpcy5fbGF0bG5nc1swXVswXTtcblx0fSxcblxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBvbHlnb25zIG5lZWQgYSBkaWZmZXJlbnQgY2xpcHBpbmcgYWxnb3JpdGhtIHNvIHdlIHJlZGVmaW5lIHRoYXRcblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzLFxuXHRcdCAgICB3ID0gdGhpcy5vcHRpb25zLndlaWdodCxcblx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblxuXHRcdC8vIGluY3JlYXNlIGNsaXAgcGFkZGluZyBieSBzdHJva2Ugd2lkdGggdG8gYXZvaWQgc3Ryb2tlIG9uIGNsaXAgZWRnZXNcblx0XHRib3VuZHMgPSBuZXcgQm91bmRzKGJvdW5kcy5taW4uc3VidHJhY3QocCksIGJvdW5kcy5tYXguYWRkKHApKTtcblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcblx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aCwgY2xpcHBlZDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRjbGlwcGVkID0gY2xpcFBvbHlnb24odGhpcy5fcmluZ3NbaV0sIGJvdW5kcywgdHJ1ZSk7XG5cdFx0XHRpZiAoY2xpcHBlZC5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5fcGFydHMucHVzaChjbGlwcGVkKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzLCB0cnVlKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xuXHRcdHZhciBpbnNpZGUgPSBmYWxzZSxcblx0XHQgICAgcGFydCwgcDEsIHAyLCBpLCBqLCBrLCBsZW4sIGxlbjI7XG5cblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIHJheSBjYXN0aW5nIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGlmIHBvaW50IGlzIGluIHBvbHlnb25cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdFx0cDEgPSBwYXJ0W2pdO1xuXHRcdFx0XHRwMiA9IHBhcnRba107XG5cblx0XHRcdFx0aWYgKCgocDEueSA+IHAueSkgIT09IChwMi55ID4gcC55KSkgJiYgKHAueCA8IChwMi54IC0gcDEueCkgKiAocC55IC0gcDEueSkgLyAocDIueSAtIHAxLnkpICsgcDEueCkpIHtcblx0XHRcdFx0XHRpbnNpZGUgPSAhaW5zaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYWxzbyBjaGVjayBpZiBpdCdzIG9uIHBvbHlnb24gc3Ryb2tlXG5cdFx0cmV0dXJuIGluc2lkZSB8fCBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQuY2FsbCh0aGlzLCBwLCB0cnVlKTtcblx0fVxuXG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnBvbHlnb24obGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuZnVuY3Rpb24gcG9seWdvbihsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcbn1cblxuLypcclxuICogQGNsYXNzIEdlb0pTT05cclxuICogQGFrYSBMLkdlb0pTT05cclxuICogQGluaGVyaXRzIEZlYXR1cmVHcm91cFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgR2VvSlNPTiBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgR2VvSlNPTiBvYmplY3RzLiBBbGxvd3MgeW91IHRvIHBhcnNlXHJcbiAqIEdlb0pTT04gZGF0YSBhbmQgZGlzcGxheSBpdCBvbiB0aGUgbWFwLiBFeHRlbmRzIGBGZWF0dXJlR3JvdXBgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmdlb0pTT04oZGF0YSwge1xyXG4gKiBcdHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gKiBcdFx0cmV0dXJuIHtjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzLmNvbG9yfTtcclxuICogXHR9XHJcbiAqIH0pLmJpbmRQb3B1cChmdW5jdGlvbiAobGF5ZXIpIHtcclxuICogXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xyXG4gKiB9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgR2VvSlNPTiA9IEZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgR2VvSlNPTiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvaW50VG9MYXllcjogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIGhvdyBHZW9KU09OIHBvaW50cyBzcGF3biBMZWFmbGV0IGxheWVycy4gSXQgaXMgaW50ZXJuYWxseVxyXG5cdCAqIGNhbGxlZCB3aGVuIGRhdGEgaXMgYWRkZWQsIHBhc3NpbmcgdGhlIEdlb0pTT04gcG9pbnQgZmVhdHVyZSBhbmQgaXRzIGBMYXRMbmdgLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIHNwYXduIGEgZGVmYXVsdCBgTWFya2VyYDpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uKGdlb0pzb25Qb2ludCwgbGF0bG5nKSB7XHJcblx0ICogXHRyZXR1cm4gTC5tYXJrZXIobGF0bG5nKTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHN0eWxlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgdGhlIGBQYXRoIG9wdGlvbnNgIGZvciBzdHlsaW5nIEdlb0pTT04gbGluZXMgYW5kIHBvbHlnb25zLFxyXG5cdCAqIGNhbGxlZCBpbnRlcm5hbGx5IHdoZW4gZGF0YSBpcyBhZGRlZC5cclxuXHQgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0byBub3Qgb3ZlcnJpZGUgYW55IGRlZmF1bHRzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4ge31cclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIG9uRWFjaEZlYXR1cmU6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgZm9yIGVhY2ggY3JlYXRlZCBgRmVhdHVyZWAsIGFmdGVyIGl0IGhhc1xyXG5cdCAqIGJlZW4gY3JlYXRlZCBhbmQgc3R5bGVkLiBVc2VmdWwgZm9yIGF0dGFjaGluZyBldmVudHMgYW5kIHBvcHVwcyB0byBmZWF0dXJlcy5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBkbyBub3RoaW5nIHdpdGggdGhlIG5ld2x5IGNyZWF0ZWQgbGF5ZXJzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGZlYXR1cmUsIGxheWVyKSB7fVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBmaWx0ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCB0byBkZWNpZGUgd2hldGhlciB0byBpbmNsdWRlIGEgZmVhdHVyZSBvciBub3QuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gaW5jbHVkZSBhbGwgZmVhdHVyZXM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuXHQgKiBcdHJldHVybiB0cnVlO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKiBOb3RlOiBkeW5hbWljYWxseSBjaGFuZ2luZyB0aGUgYGZpbHRlcmAgb3B0aW9uIHdpbGwgaGF2ZSBlZmZlY3Qgb25seSBvbiBuZXdseVxyXG5cdCAqIGFkZGVkIGRhdGEuIEl0IHdpbGwgX25vdF8gcmUtZXZhbHVhdGUgYWxyZWFkeSBpbmNsdWRlZCBmZWF0dXJlcy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gY29vcmRzVG9MYXRMbmc6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgY29udmVydGluZyBHZW9KU09OIGNvb3JkaW5hdGVzIHRvIGBMYXRMbmdgcy5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0aGUgYGNvb3Jkc1RvTGF0TG5nYCBzdGF0aWMgbWV0aG9kLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBtYXJrZXJzSW5oZXJpdE9wdGlvbnM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdCAqIFdoZXRoZXIgZGVmYXVsdCBNYXJrZXJzIGZvciBcIlBvaW50XCIgdHlwZSBGZWF0dXJlcyBpbmhlcml0IGZyb20gZ3JvdXAgb3B0aW9ucy5cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0aWYgKGdlb2pzb24pIHtcclxuXHRcdFx0dGhpcy5hZGREYXRhKGdlb2pzb24pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRGF0YSggPEdlb0pTT04+IGRhdGEgKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBHZW9KU09OIG9iamVjdCB0byB0aGUgbGF5ZXIuXHJcblx0YWRkRGF0YTogZnVuY3Rpb24gKGdlb2pzb24pIHtcclxuXHRcdHZhciBmZWF0dXJlcyA9IGlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuXHRcdCAgICBpLCBsZW4sIGZlYXR1cmU7XHJcblxyXG5cdFx0aWYgKGZlYXR1cmVzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Ly8gb25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXHJcblx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG5cdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkRGF0YShmZWF0dXJlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKTtcclxuXHRcdGlmICghbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRsYXllci5mZWF0dXJlID0gYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuXHRcdGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG5cdFx0XHRvcHRpb25zLm9uRWFjaEZlYXR1cmUoZ2VvanNvbiwgbGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlc2V0U3R5bGUoIDxQYXRoPiBsYXllcj8gKTogdGhpc1xyXG5cdC8vIFJlc2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIGxheWVyJ3Mgc3R5bGUgdG8gdGhlIG9yaWdpbmFsIEdlb0pTT04gc3R5bGUsIHVzZWZ1bCBmb3IgcmVzZXR0aW5nIHN0eWxlIGFmdGVyIGhvdmVyIGV2ZW50cy5cclxuXHQvLyBJZiBgbGF5ZXJgIGlzIG9taXR0ZWQsIHRoZSBzdHlsZSBvZiBhbGwgZmVhdHVyZXMgaW4gdGhlIGN1cnJlbnQgbGF5ZXIgaXMgcmVzZXQuXHJcblx0cmVzZXRTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZXNldFN0eWxlLCB0aGlzKTtcclxuXHRcdH1cclxuXHRcdC8vIHJlc2V0IGFueSBjdXN0b20gc3R5bGVzXHJcblx0XHRsYXllci5vcHRpb25zID0gZXh0ZW5kKHt9LCBsYXllci5kZWZhdWx0T3B0aW9ucyk7XHJcblx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCB0aGlzLm9wdGlvbnMuc3R5bGUpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRTdHlsZSggPEZ1bmN0aW9uPiBzdHlsZSApOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyBzdHlsZXMgb2YgR2VvSlNPTiB2ZWN0b3IgbGF5ZXJzIHdpdGggdGhlIGdpdmVuIHN0eWxlIGZ1bmN0aW9uLlxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgc3R5bGUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X3NldExheWVyU3R5bGU6IGZ1bmN0aW9uIChsYXllciwgc3R5bGUpIHtcclxuXHRcdGlmIChsYXllci5zZXRTdHlsZSkge1xyXG5cdFx0XHRpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0c3R5bGUgPSBzdHlsZShsYXllci5mZWF0dXJlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsYXllci5zZXRTdHlsZShzdHlsZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBzZWN0aW9uXHJcbi8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5HZW9KU09OOlxyXG5cclxuLy8gQGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihmZWF0dXJlRGF0YTogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKTogTGF5ZXJcclxuLy8gQ3JlYXRlcyBhIGBMYXllcmAgZnJvbSBhIGdpdmVuIEdlb0pTT04gZmVhdHVyZS4gQ2FuIHVzZSBhIGN1c3RvbVxyXG4vLyBbYHBvaW50VG9MYXllcmBdKCNnZW9qc29uLXBvaW50dG9sYXllcikgYW5kL29yIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuLy8gZnVuY3Rpb25zIGlmIHByb3ZpZGVkIGFzIG9wdGlvbnMuXHJcbmZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb24sXHJcblx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBudWxsLFxyXG5cdCAgICBsYXllcnMgPSBbXSxcclxuXHQgICAgcG9pbnRUb0xheWVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnBvaW50VG9MYXllcixcclxuXHQgICAgX2Nvb3Jkc1RvTGF0TG5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nLFxyXG5cdCAgICBsYXRsbmcsIGxhdGxuZ3MsIGksIGxlbjtcclxuXHJcblx0aWYgKCFjb29yZHMgJiYgIWdlb21ldHJ5KSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xyXG5cdGNhc2UgJ1BvaW50JzpcclxuXHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG5cdFx0cmV0dXJuIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdNdWx0aVBvaW50JzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdFx0bGF5ZXJzLnB1c2goX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0Y2FzZSAnTGluZVN0cmluZyc6XHJcblx0Y2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcclxuXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgPyAwIDogMSwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ1BvbHlnb24nOlxyXG5cdGNhc2UgJ011bHRpUG9seWdvbic6XHJcblx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nID8gMSA6IDIsIF9jb29yZHNUb0xhdExuZyk7XHJcblx0XHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcih7XHJcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcblx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRcdHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllc1xyXG5cdFx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRcdGlmIChsYXllcikge1xyXG5cdFx0XHRcdGxheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0ZGVmYXVsdDpcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyRm4sIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBwb2ludFRvTGF5ZXJGbiA/XHJcblx0XHRwb2ludFRvTGF5ZXJGbihnZW9qc29uLCBsYXRsbmcpIDpcclxuXHRcdG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zICYmIG9wdGlvbnMubWFya2Vyc0luaGVyaXRPcHRpb25zICYmIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGEgYExhdExuZ2Agb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgMiBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlKVxyXG4vLyBvciAzIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlKSB1c2VkIGluIEdlb0pTT04gZm9yIHBvaW50cy5cclxuZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzKSB7XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY29vcmRzVG9MYXRMbmc/OiBGdW5jdGlvbik6IEFycmF5XHJcbi8vIENyZWF0ZXMgYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IG9mIGBMYXRMbmdgcyBmcm9tIGEgR2VvSlNPTiBjb29yZGluYXRlcyBhcnJheS5cclxuLy8gYGxldmVsc0RlZXBgIHNwZWNpZmllcyB0aGUgbmVzdGluZyBsZXZlbCAoMCBpcyBmb3IgYW4gYXJyYXkgb2YgcG9pbnRzLCAxIGZvciBhbiBhcnJheSBvZiBhcnJheXMgb2YgcG9pbnRzLCBldGMuLCAwIGJ5IGRlZmF1bHQpLlxyXG4vLyBDYW4gdXNlIGEgY3VzdG9tIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZykgZnVuY3Rpb24uXHJcbmZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGxldmVsc0RlZXAsIF9jb29yZHNUb0xhdExuZykge1xyXG5cdHZhciBsYXRsbmdzID0gW107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoLCBsYXRsbmc7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0bGF0bG5nID0gbGV2ZWxzRGVlcCA/XHJcblx0XHRcdGNvb3Jkc1RvTGF0TG5ncyhjb29yZHNbaV0sIGxldmVsc0RlZXAgLSAxLCBfY29vcmRzVG9MYXRMbmcpIDpcclxuXHRcdFx0KF9jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZykoY29vcmRzW2ldKTtcclxuXHJcblx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBsYXRsbmdzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nOiBMYXRMbmcsIHByZWNpc2lvbj86IE51bWJlcik6IEFycmF5XHJcbi8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG5mdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmcsIHByZWNpc2lvbikge1xyXG5cdHByZWNpc2lvbiA9IHR5cGVvZiBwcmVjaXNpb24gPT09ICdudW1iZXInID8gcHJlY2lzaW9uIDogNjtcclxuXHRyZXR1cm4gbGF0bG5nLmFsdCAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFtmb3JtYXROdW0obGF0bG5nLmxuZywgcHJlY2lzaW9uKSwgZm9ybWF0TnVtKGxhdGxuZy5sYXQsIHByZWNpc2lvbiksIGZvcm1hdE51bShsYXRsbmcuYWx0LCBwcmVjaXNpb24pXSA6XHJcblx0XHRbZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIGZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pXTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY2xvc2VkPzogQm9vbGVhbik6IEFycmF5XHJcbi8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcbi8vIGBjbG9zZWRgIGRldGVybWluZXMgd2hldGhlciB0aGUgZmlyc3QgcG9pbnQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IHRvIGNsb3NlIHRoZSBmZWF0dXJlLCBvbmx5IHVzZWQgd2hlbiBgbGV2ZWxzRGVlcGAgaXMgMC4gRmFsc2UgYnkgZGVmYXVsdC5cclxuZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3MsIGxldmVsc0RlZXAsIGNsb3NlZCwgcHJlY2lzaW9uKSB7XHJcblx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0Y29vcmRzLnB1c2gobGV2ZWxzRGVlcCA/XHJcblx0XHRcdGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzW2ldLCBsZXZlbHNEZWVwIC0gMSwgY2xvc2VkLCBwcmVjaXNpb24pIDpcclxuXHRcdFx0bGF0TG5nVG9Db29yZHMobGF0bG5nc1tpXSwgcHJlY2lzaW9uKSk7XHJcblx0fVxyXG5cclxuXHRpZiAoIWxldmVsc0RlZXAgJiYgY2xvc2VkKSB7XHJcblx0XHRjb29yZHMucHVzaChjb29yZHNbMF0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNvb3JkcztcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RmVhdHVyZShsYXllciwgbmV3R2VvbWV0cnkpIHtcclxuXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/XHJcblx0XHRleHRlbmQoe30sIGxheWVyLmZlYXR1cmUsIHtnZW9tZXRyeTogbmV3R2VvbWV0cnl9KSA6XHJcblx0XHRhc0ZlYXR1cmUobmV3R2VvbWV0cnkpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb246IE9iamVjdCk6IE9iamVjdFxyXG4vLyBOb3JtYWxpemUgR2VvSlNPTiBnZW9tZXRyaWVzL2ZlYXR1cmVzIGludG8gR2VvSlNPTiBmZWF0dXJlcy5cclxuZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb24pIHtcclxuXHRpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgfHwgZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcblx0XHRyZXR1cm4gZ2VvanNvbjtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRwcm9wZXJ0aWVzOiB7fSxcclxuXHRcdGdlb21ldHJ5OiBnZW9qc29uXHJcblx0fTtcclxufVxyXG5cclxudmFyIFBvaW50VG9HZW9KU09OID0ge1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogbGF0TG5nVG9Db29yZHModGhpcy5nZXRMYXRMbmcoKSwgcHJlY2lzaW9uKVxyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXJrZXJcclxuLy8gQHNlY3Rpb24gT3RoZXIgbWV0aG9kc1xyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXIpOiBPYmplY3RcclxuLy8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcbi8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDaXJjbGVNYXJrZXJcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcbi8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG4vLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2IHBsYWNlcy5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG5DaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbkNpcmNsZU1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlsaW5lXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4vLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5bGluZSAoYXMgYSBHZW9KU09OIGBMaW5lU3RyaW5nYCBvciBgTXVsdGlMaW5lU3RyaW5nYCBGZWF0dXJlKS5cclxuUG9seWxpbmUuaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgbXVsdGkgPSAhaXNGbGF0KHRoaXMuX2xhdGxuZ3MpO1xyXG5cclxuXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAxIDogMCwgZmFsc2UsIHByZWNpc2lvbik7XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ0xpbmVTdHJpbmcnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5Z29uXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4vLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5Z29uIChhcyBhIEdlb0pTT04gYFBvbHlnb25gIG9yIGBNdWx0aVBvbHlnb25gIEZlYXR1cmUpLlxyXG5Qb2x5Z29uLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIGhvbGVzID0gIWlzRmxhdCh0aGlzLl9sYXRsbmdzKSxcclxuXHRcdCAgICBtdWx0aSA9IGhvbGVzICYmICFpc0ZsYXQodGhpcy5fbGF0bG5nc1swXSk7XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDIgOiBob2xlcyA/IDEgOiAwLCB0cnVlLCBwcmVjaXNpb24pO1xyXG5cclxuXHRcdGlmICghaG9sZXMpIHtcclxuXHRcdFx0Y29vcmRzID0gW2Nvb3Jkc107XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ1BvbHlnb24nLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTGF5ZXJHcm91cFxyXG5MYXllckdyb3VwLmluY2x1ZGUoe1xyXG5cdHRvTXVsdGlQb2ludDogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRjb29yZHMucHVzaChsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdNdWx0aVBvaW50JyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcblx0Ly8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcblx0Ly8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcblx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyIGdyb3VwIChhcyBhIEdlb0pTT04gYEZlYXR1cmVDb2xsZWN0aW9uYCwgYEdlb21ldHJ5Q29sbGVjdGlvbmAsIG9yIGBNdWx0aVBvaW50YCkuXHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblxyXG5cdFx0dmFyIHR5cGUgPSB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5ICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KHByZWNpc2lvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicsXHJcblx0XHQgICAganNvbnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0aWYgKGxheWVyLnRvR2VvSlNPTikge1xyXG5cdFx0XHRcdHZhciBqc29uID0gbGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbik7XHJcblx0XHRcdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdFx0XHRqc29ucy5wdXNoKGpzb24uZ2VvbWV0cnkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgZmVhdHVyZSA9IGFzRmVhdHVyZShqc29uKTtcclxuXHRcdFx0XHRcdC8vIFNxdWFzaCBuZXN0ZWQgZmVhdHVyZSBjb2xsZWN0aW9uc1xyXG5cdFx0XHRcdFx0aWYgKGZlYXR1cmUudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRqc29ucy5wdXNoLmFwcGx5KGpzb25zLCBmZWF0dXJlLmZlYXR1cmVzKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGpzb25zLnB1c2goZmVhdHVyZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHRcdGdlb21ldHJpZXM6IGpzb25zLFxyXG5cdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcblx0XHRcdGZlYXR1cmVzOiBqc29uc1xyXG5cdFx0fTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBHZW9KU09OXHJcbi8vIEBmYWN0b3J5IEwuZ2VvSlNPTihnZW9qc29uPzogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgR2VvSlNPTiBsYXllci4gT3B0aW9uYWxseSBhY2NlcHRzIGFuIG9iamVjdCBpblxyXG4vLyBbR2VvSlNPTiBmb3JtYXRdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3OTQ2KSB0byBkaXNwbGF5IG9uIHRoZSBtYXBcclxuLy8gKHlvdSBjYW4gYWx0ZXJuYXRpdmVseSBhZGQgaXQgbGF0ZXIgd2l0aCBgYWRkRGF0YWAgbWV0aG9kKSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuZnVuY3Rpb24gZ2VvSlNPTihnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBHZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxyXG52YXIgZ2VvSnNvbiA9IGdlb0pTT047XG5cbi8qXHJcbiAqIEBjbGFzcyBJbWFnZU92ZXJsYXlcclxuICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGltYWdlVXJsID0gJ2h0dHA6Ly93d3cubGliLnV0ZXhhcy5lZHUvbWFwcy9oaXN0b3JpY2FsL25ld2Fya19ual8xOTIyLmpwZycsXHJcbiAqIFx0aW1hZ2VCb3VuZHMgPSBbWzQwLjcxMjIxNiwgLTc0LjIyNjU1XSwgWzQwLjc3Mzk0MSwgLTc0LjEyNTQ0XV07XHJcbiAqIEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsLCBpbWFnZUJvdW5kcykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIEltYWdlT3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbWFnZS5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCB0aGUgaW1hZ2Ugd2lsbCBoYXZlIGl0cyBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBpbWFnZSBwaXhlbCBkYXRhLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yT3ZlcmxheVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgb3ZlcmxheSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSBvdmVybGF5IHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvck92ZXJsYXlVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXHJcblx0XHQvLyBUaGUgZXhwbGljaXQgW3pJbmRleF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL0NTU19Qb3NpdGlvbmluZy9VbmRlcnN0YW5kaW5nX3pfaW5kZXgpIG9mIHRoZSBvdmVybGF5IGxheWVyLlxyXG5cdFx0ekluZGV4OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIGltYWdlLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBMYXRMbmdCb3VuZHMsIE9iamVjdClcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl9pbml0SW1hZ2UoKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdGFkZENsYXNzKHRoaXMuX2ltYWdlLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcblx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZW1vdmUodGhpcy5faW1hZ2UpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIG92ZXJsYXkuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuXHRcdGlmIChzdHlsZU9wdHMub3BhY2l0eSkge1xyXG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoc3R5bGVPcHRzLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRvRnJvbnQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBvdmVybGF5cy5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0b0JhY2sodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgVVJMIG9mIHRoZSBpbWFnZS5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwpIHtcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gdXJsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gVXBkYXRlIHRoZSBib3VuZHMgdGhhdCB0aGlzIEltYWdlT3ZlcmxheSBjb3ZlcnNcclxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldCxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgodmFsdWU6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjaW1hZ2VvdmVybGF5LXppbmRleCkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB2YWx1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gR2V0IHRoZSBib3VuZHMgdGhhdCB0aGlzIEltYWdlT3ZlcmxheSBjb3ZlcnNcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MSW1hZ2VFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQpXHJcblx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB3YXNFbGVtZW50U3VwcGxpZWQgPSB0aGlzLl91cmwudGFnTmFtZSA9PT0gJ0lNRyc7XHJcblx0XHR2YXIgaW1nID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBjcmVhdGUkMSgnaW1nJyk7XHJcblxyXG5cdFx0YWRkQ2xhc3MoaW1nLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBhZGRDbGFzcyhpbWcsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgYWRkQ2xhc3MoaW1nLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxyXG5cclxuXHRcdGltZy5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcclxuXHRcdGltZy5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgaGFzIGxvYWRlZCBpdHMgaW1hZ2VcclxuXHRcdGltZy5vbmxvYWQgPSBiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHRcdGltZy5vbmVycm9yID0gYmluZCh0aGlzLl9vdmVybGF5T25FcnJvciwgdGhpcywgJ2Vycm9yJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuekluZGV4KSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gaW1nLnNyYztcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcblx0XHRpbWcuYWx0ID0gdGhpcy5vcHRpb25zLmFsdDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKGUuem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fbWFwLl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzKHRoaXMuX2JvdW5kcywgZS56b29tLCBlLmNlbnRlcikubWluO1xyXG5cclxuXHRcdHNldFRyYW5zZm9ybSh0aGlzLl9pbWFnZSwgb2Zmc2V0LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcclxuXHRcdCAgICBib3VuZHMgPSBuZXcgQm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoRWFzdCgpKSksXHJcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XHJcblxyXG5cdFx0c2V0UG9zaXRpb24oaW1hZ2UsIGJvdW5kcy5taW4pO1xyXG5cclxuXHRcdGltYWdlLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRpbWFnZS5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRzZXRPcGFjaXR5KHRoaXMuX2ltYWdlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ltYWdlICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X292ZXJsYXlPbkVycm9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBAZXZlbnQgZXJyb3I6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgZmFpbHMgdG8gbG9hZCBpdHMgaW1hZ2VcclxuXHRcdHRoaXMuZmlyZSgnZXJyb3InKTtcclxuXHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRoaXMuX3VybCAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gZXJyb3JVcmw7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmltYWdlT3ZlcmxheShpbWFnZVVybDogU3RyaW5nLCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IEltYWdlT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgaW1hZ2UgYW5kIHRoZVxyXG4vLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcbnZhciBpbWFnZU92ZXJsYXkgPSBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEltYWdlT3ZlcmxheSh1cmwsIGJvdW5kcywgb3B0aW9ucyk7XHJcbn07XG5cbi8qXHJcbiAqIEBjbGFzcyBWaWRlb092ZXJsYXlcclxuICogQGFrYSBMLlZpZGVvT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XHJcbiAqXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHZpZGVvIHBsYXllciBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxyXG4gKlxyXG4gKiBBIHZpZGVvIG92ZXJsYXkgdXNlcyB0aGUgW2A8dmlkZW8+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3ZpZGVvKVxyXG4gKiBIVE1MNSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdmlkZW9VcmwgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9iaXRlcy8wMDE4OC9wYXRyaWNpYV9uYXNhLndlYm0nLFxyXG4gKiBcdHZpZGVvQm91bmRzID0gW1sgMzIsIC0xMzBdLCBbIDEzLCAtMTAwXV07XHJcbiAqIEwudmlkZW9PdmVybGF5KHZpZGVvVXJsLCB2aWRlb0JvdW5kcyApLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBWaWRlb092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFZpZGVvT3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvcGxheTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHN0YXJ0cyBwbGF5aW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBsb2FkZWQuXHJcblx0XHRhdXRvcGxheTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxvb3A6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIGxvb3AgYmFjayB0byB0aGUgYmVnaW5uaW5nIHdoZW4gcGxheWVkLlxyXG5cdFx0bG9vcDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtlZXBBc3BlY3RSYXRpbzogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgc2F2ZSBhc3BlY3QgcmF0aW8gYWZ0ZXIgdGhlIHByb2plY3Rpb24uXHJcblx0XHQvLyBSZWxldmFudCBmb3Igc3VwcG9ydGVkIGJyb3dzZXJzLiBCcm93c2VyIGNvbXBhdGliaWxpdHktIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9vYmplY3QtZml0XHJcblx0XHRrZWVwQXNwZWN0UmF0aW86IHRydWVcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdWSURFTyc7XHJcblx0XHR2YXIgdmlkID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBjcmVhdGUkMSgndmlkZW8nKTtcclxuXHJcblx0XHRhZGRDbGFzcyh2aWQsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IGFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBhZGRDbGFzcyh2aWQsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG5cdFx0dmlkLm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xyXG5cdFx0dmlkLm9ubW91c2Vtb3ZlID0gZmFsc2VGbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHZpZGVvIGhhcyBmaW5pc2hlZCBsb2FkaW5nIHRoZSBmaXJzdCBmcmFtZVxyXG5cdFx0dmlkLm9ubG9hZGVkZGF0YSA9IGJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dmFyIHNvdXJjZUVsZW1lbnRzID0gdmlkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzb3VyY2UnKTtcclxuXHRcdFx0dmFyIHNvdXJjZXMgPSBbXTtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2VFbGVtZW50c1tqXS5zcmMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl91cmwgPSAoc291cmNlRWxlbWVudHMubGVuZ3RoID4gMCkgPyBzb3VyY2VzIDogW3ZpZC5zcmNdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFpc0FycmF5KHRoaXMuX3VybCkpIHsgdGhpcy5fdXJsID0gW3RoaXMuX3VybF07IH1cclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5rZWVwQXNwZWN0UmF0aW8gJiYgdmlkLnN0eWxlLmhhc093blByb3BlcnR5KCdvYmplY3RGaXQnKSkgeyB2aWQuc3R5bGVbJ29iamVjdEZpdCddID0gJ2ZpbGwnOyB9XHJcblx0XHR2aWQuYXV0b3BsYXkgPSAhIXRoaXMub3B0aW9ucy5hdXRvcGxheTtcclxuXHRcdHZpZC5sb29wID0gISF0aGlzLm9wdGlvbnMubG9vcDtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdXJsLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBzb3VyY2UgPSBjcmVhdGUkMSgnc291cmNlJyk7XHJcblx0XHRcdHNvdXJjZS5zcmMgPSB0aGlzLl91cmxbaV07XHJcblx0XHRcdHZpZC5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxWaWRlb0VsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxWaWRlb0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTFZpZGVvRWxlbWVudClcclxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC52aWRlb092ZXJsYXkodmlkZW86IFN0cmluZ3xBcnJheXxIVE1MVmlkZW9FbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFZpZGVvT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgdmlkZW8gKG9yIGFycmF5IG9mIFVSTHMsIG9yIGV2ZW4gYSB2aWRlbyBlbGVtZW50KSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuXHJcbmZ1bmN0aW9uIHZpZGVvT3ZlcmxheSh2aWRlbywgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBWaWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucyk7XHJcbn1cblxuLypcbiAqIEBjbGFzcyBTVkdPdmVybGF5XG4gKiBAYWthIEwuU1ZHT3ZlcmxheVxuICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxuICpcbiAqIFVzZWQgdG8gbG9hZCwgZGlzcGxheSBhbmQgcHJvdmlkZSBET00gYWNjZXNzIHRvIGFuIFNWRyBmaWxlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXG4gKlxuICogQW4gU1ZHIG92ZXJsYXkgdXNlcyB0aGUgW2A8c3ZnPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9FbGVtZW50L3N2ZykgZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKTtcbiAqIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgXCIwIDAgMjAwIDIwMFwiKTtcbiAqIHN2Z0VsZW1lbnQuaW5uZXJIVE1MID0gJzxyZWN0IHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjAwXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDpyZWRcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjEyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDojMDAxM2ZmXCIvPic7XG4gKiB2YXIgc3ZnRWxlbWVudEJvdW5kcyA9IFsgWyAzMiwgLTEzMCBdLCBbIDEzLCAtMTAwIF0gXTtcbiAqIEwuc3ZnT3ZlcmxheShzdmdFbGVtZW50LCBzdmdFbGVtZW50Qm91bmRzKS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxudmFyIFNWR092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlbCA9IHRoaXMuX2ltYWdlID0gdGhpcy5fdXJsO1xuXG5cdFx0YWRkQ2xhc3MoZWwsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBhZGRDbGFzcyhlbCwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgYWRkQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XG5cblx0XHRlbC5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcblx0XHRlbC5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XG5cdH1cblxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogU1ZHRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYFNWR0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudClcblx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnN2Z092ZXJsYXkoc3ZnOiBTdHJpbmd8U1ZHRWxlbWVudCwgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBTVkdPdmVybGF5IG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gYW4gU1ZHIGVsZW1lbnQgYW5kIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXG4vLyBBIHZpZXdCb3ggYXR0cmlidXRlIGlzIHJlcXVpcmVkIG9uIHRoZSBTVkcgZWxlbWVudCB0byB6b29tIGluIGFuZCBvdXQgcHJvcGVybHkuXG5cbmZ1bmN0aW9uIHN2Z092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFNWR092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucyk7XG59XG5cbi8qXHJcbiAqIEBjbGFzcyBEaXZPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBMYXllclxyXG4gKiBAYWthIEwuRGl2T3ZlcmxheVxyXG4gKiBCYXNlIG1vZGVsIGZvciBMLlBvcHVwIGFuZCBMLlRvb2x0aXAuIEluaGVyaXQgZnJvbSBpdCBmb3IgY3VzdG9tIHBvcHVwIGxpa2UgcGx1Z2lucy5cclxuICovXHJcblxyXG4vLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxudmFyIERpdk92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgRGl2T3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgNylcclxuXHRcdC8vIFRoZSBvZmZzZXQgb2YgdGhlIHBvcHVwIHBvc2l0aW9uLiBVc2VmdWwgdG8gY29udHJvbCB0aGUgYW5jaG9yXHJcblx0XHQvLyBvZiB0aGUgcG9wdXAgd2hlbiBvcGVuaW5nIGl0IG9uIHNvbWUgb3ZlcmxheXMuXHJcblx0XHRvZmZzZXQ6IFswLCA3XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3BvcHVwUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAncG9wdXBQYW5lJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlVGltZW91dCk7XHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYnJpbmdUb0Zyb250KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQocmVtb3ZlLCB1bmRlZmluZWQsIHRoaXMuX2NvbnRhaW5lciksIDIwMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCBvZiBwb3B1cC5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBwb3B1cCB3aWxsIG9wZW4uXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cdFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAuXHJcblx0Z2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRDb250ZW50KGh0bWxDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBwb3B1cC4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YCB0byBiZSB1c2VkIGluIHRoZSBwb3B1cC5cclxuXHRzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0dGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBBbGlhcyBmb3IgW2dldENvbnRlbnQoKV0oI3BvcHVwLWdldGNvbnRlbnQpXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG5cdC8vIFVwZGF0ZXMgdGhlIHBvcHVwIGNvbnRlbnQsIGxheW91dCBhbmQgcG9zaXRpb24uIFVzZWZ1bCBmb3IgdXBkYXRpbmcgdGhlIHBvcHVwIGFmdGVyIHNvbWV0aGluZyBpbnNpZGUgY2hhbmdlZCwgZS5nLiBpbWFnZSBsb2FkZWQuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZUNvbnRlbnQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZUxheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cclxuXHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fdXBkYXRlUG9zaXRpb24sXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fdXBkYXRlUG9zaXRpb25cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc09wZW46IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSBwb3B1cCBpcyB2aXNpYmxlIG9uIHRoZSBtYXAuXHJcblx0aXNPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgaW4gZnJvbnQgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBwb3B1cCB0byB0aGUgYmFjayBvZiBvdGhlciBwb3B1cHMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0b0JhY2sodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9wcmVwYXJlT3BlbjogZnVuY3Rpb24gKHBhcmVudCwgbGF5ZXIsIGxhdGxuZykge1xyXG5cdFx0aWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBMYXllcikpIHtcclxuXHRcdFx0bGF0bG5nID0gbGF5ZXI7XHJcblx0XHRcdGxheWVyID0gcGFyZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkge1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiBwYXJlbnQuX2xheWVycykge1xyXG5cdFx0XHRcdGxheWVyID0gcGFyZW50Ll9sYXllcnNbaWRdO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFsYXRsbmcpIHtcclxuXHRcdFx0aWYgKGxheWVyLmdldENlbnRlcikge1xyXG5cdFx0XHRcdGxhdGxuZyA9IGxheWVyLmdldENlbnRlcigpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGxheWVyLmdldExhdExuZykge1xyXG5cdFx0XHRcdGxhdGxuZyA9IGxheWVyLmdldExhdExuZygpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBzb3VyY2UgbGF5ZXIgTGF0TG5nLicpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2V0IG92ZXJsYXkgc291cmNlIHRvIHRoaXMgbGF5ZXJcclxuXHRcdHRoaXMuX3NvdXJjZSA9IGxheWVyO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSB0aGUgb3ZlcmxheSAoY29udGVudCwgbGF5b3V0LCBlY3QuLi4pXHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiBsYXRsbmc7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm9kZSA9IHRoaXMuX2NvbnRlbnROb2RlO1xyXG5cdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBjb250ZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcblx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmZpcmUoJ2NvbnRlbnR1cGRhdGUnKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9mZnNldCA9IG9mZnNldC5hZGQocG9zKS5hZGQoYW5jaG9yKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYm90dG9tID0gdGhpcy5fY29udGFpbmVyQm90dG9tID0gLW9mZnNldC55LFxyXG5cdFx0ICAgIGxlZnQgPSB0aGlzLl9jb250YWluZXJMZWZ0ID0gLU1hdGgucm91bmQodGhpcy5fY29udGFpbmVyV2lkdGggLyAyKSArIG9mZnNldC54O1xyXG5cclxuXHRcdC8vIGJvdHRvbSBwb3NpdGlvbiB0aGUgcG9wdXAgaW4gY2FzZSB0aGUgaGVpZ2h0IG9mIHRoZSBwb3B1cCBjaGFuZ2VzIChpbWFnZXMgbG9hZGluZyBldGMpXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuYm90dG9tID0gYm90dG9tICsgJ3B4JztcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XHJcblx0fSxcclxuXHJcblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIFswLCAwXTtcclxuXHR9XHJcblxyXG59KTtcblxuLypcclxuICogQGNsYXNzIFBvcHVwXHJcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XHJcbiAqIEBha2EgTC5Qb3B1cFxyXG4gKiBVc2VkIHRvIG9wZW4gcG9wdXBzIGluIGNlcnRhaW4gcGxhY2VzIG9mIHRoZSBtYXAuIFVzZSBbTWFwLm9wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIHRvXHJcbiAqIG9wZW4gcG9wdXBzIHdoaWxlIG1ha2luZyBzdXJlIHRoYXQgb25seSBvbmUgcG9wdXAgaXMgb3BlbiBhdCBvbmUgdGltZVxyXG4gKiAocmVjb21tZW5kZWQgZm9yIHVzYWJpbGl0eSksIG9yIHVzZSBbTWFwLmFkZExheWVyXSgjbWFwLWFkZGxheWVyKSB0byBvcGVuIGFzIG1hbnkgYXMgeW91IHdhbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHBvcHVwIHRvIG1hcmtlciBjbGljayBhbmQgdGhlbiBvcGVuIGl0LCBpdCdzIHJlYWxseSBlYXN5OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXJrZXIuYmluZFBvcHVwKHBvcHVwQ29udGVudCkub3BlblBvcHVwKCk7XHJcbiAqIGBgYFxyXG4gKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kUG9wdXBgIG1ldGhvZC5cclxuICogSGVyZSdzIGEgbW9yZSBjb21wbGljYXRlZCB3YXkgdG8gb3BlbiBhIHBvcHVwIG9uIGEgbWFwOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9wdXAgPSBMLnBvcHVwKClcclxuICogXHQuc2V0TGF0TG5nKGxhdGxuZylcclxuICogXHQuc2V0Q29udGVudCgnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAqIFx0Lm9wZW5PbihtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG52YXIgUG9wdXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBQb3B1cCBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMzAwXHJcblx0XHQvLyBNYXggd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtYXhXaWR0aDogMzAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluV2lkdGg6IE51bWJlciA9IDUwXHJcblx0XHQvLyBNaW4gd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtaW5XaWR0aDogNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhIZWlnaHQ6IE51bWJlciA9IG51bGxcclxuXHRcdC8vIElmIHNldCwgY3JlYXRlcyBhIHNjcm9sbGFibGUgY29udGFpbmVyIG9mIHRoZSBnaXZlbiBoZWlnaHRcclxuXHRcdC8vIGluc2lkZSBhIHBvcHVwIGlmIGl0cyBjb250ZW50IGV4Y2VlZHMgaXQuXHJcblx0XHRtYXhIZWlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byBkbyBwYW5uaW5nIGFuaW1hdGlvblxyXG5cdFx0Ly8gdG8gZml0IHRoZSBvcGVuZWQgcG9wdXAuXHJcblx0XHRhdXRvUGFuOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNSwgNSlcclxuXHRcdC8vIEVxdWl2YWxlbnQgb2Ygc2V0dGluZyBib3RoIHRvcCBsZWZ0IGFuZCBib3R0b20gcmlnaHQgYXV0b3BhbiBwYWRkaW5nIHRvIHRoZSBzYW1lIHZhbHVlLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1LCA1XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtlZXBJblZpZXc6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0byBwcmV2ZW50IHVzZXJzIGZyb20gcGFubmluZyB0aGUgcG9wdXBcclxuXHRcdC8vIG9mZiBvZiB0aGUgc2NyZWVuIHdoaWxlIGl0IGlzIG9wZW4uXHJcblx0XHRrZWVwSW5WaWV3OiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlQnV0dG9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gQ29udHJvbHMgdGhlIHByZXNlbmNlIG9mIGEgY2xvc2UgYnV0dG9uIGluIHRoZSBwb3B1cC5cclxuXHRcdGNsb3NlQnV0dG9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b0Nsb3NlOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuXHRcdC8vIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcblx0XHRhdXRvQ2xvc2U6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZU9uRXNjYXBlS2V5OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuXHRcdC8vIHRoZSBFU0Mga2V5IGZvciBjbG9zaW5nIG9mIHRoZSBwb3B1cC5cclxuXHRcdGNsb3NlT25Fc2NhcGVLZXk6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZU9uQ2xpY2s6IEJvb2xlYW4gPSAqXHJcblx0XHQvLyBTZXQgaXQgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiB1c2VyIGNsaWNrc1xyXG5cdFx0Ly8gb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdGhlIG1hcCdzIFtgY2xvc2VQb3B1cE9uQ2xpY2tgXSgjbWFwLWNsb3NlcG9wdXBvbmNsaWNrKSBvcHRpb24uXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBwb3B1cCB0byB0aGUgbWFwIGFuZCBjbG9zZXMgdGhlIHByZXZpb3VzIG9uZS4gVGhlIHNhbWUgYXMgYG1hcC5vcGVuUG9wdXAocG9wdXApYC5cclxuXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vcGVuUG9wdXAodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpcyBvcGVuZWQgaW4gdGhlIG1hcFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG5cdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWRcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHQvLyBGb3Igbm9uLXBhdGggbGF5ZXJzLCB3ZSB0b2dnbGUgdGhlIHBvcHVwIHdoZW4gY2xpY2tpbmdcclxuXHRcdFx0Ly8gYWdhaW4gdGhlIGxheWVyLCBzbyBwcmV2ZW50IHRoZSBtYXAgdG8gcmVvcGVuIGl0LlxyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vbigncHJlY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGluIHRoZSBtYXAgaXMgY2xvc2VkXHJcblx0XHRtYXAuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG5cdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcblx0XHRcdFx0dGhpcy5fc291cmNlLm9mZigncHJlY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgIT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgOiB0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykge1xyXG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLl9jbG9zZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcclxuXHRcdFx0ZXZlbnRzLm1vdmVlbmQgPSB0aGlzLl9hZGp1c3RQYW47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHRfY2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmNsb3NlUG9wdXAodGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC1wb3B1cCcsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsXHJcblx0XHRcdHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArXHJcblx0XHRcdCcgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblxyXG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyID0gY3JlYXRlJDEoJ2RpdicsIHByZWZpeCArICctY29udGVudC13cmFwcGVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gY3JlYXRlJDEoJ2RpdicsIHByZWZpeCArICctY29udGVudCcsIHdyYXBwZXIpO1xyXG5cclxuXHRcdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHdyYXBwZXIpO1xyXG5cdFx0ZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKHRoaXMuX2NvbnRlbnROb2RlKTtcclxuXHRcdG9uKHdyYXBwZXIsICdjb250ZXh0bWVudScsIHN0b3BQcm9wYWdhdGlvbik7XHJcblxyXG5cdFx0dGhpcy5fdGlwQ29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIHByZWZpeCArICctdGlwLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl90aXAgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcclxuXHRcdFx0dmFyIGNsb3NlQnV0dG9uID0gdGhpcy5fY2xvc2VCdXR0b24gPSBjcmVhdGUkMSgnYScsIHByZWZpeCArICctY2xvc2UtYnV0dG9uJywgY29udGFpbmVyKTtcclxuXHRcdFx0Y2xvc2VCdXR0b24uaHJlZiA9ICcjY2xvc2UnO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnJiMyMTU7JztcclxuXHJcblx0XHRcdG9uKGNsb3NlQnV0dG9uLCAnY2xpY2snLCB0aGlzLl9vbkNsb3NlQnV0dG9uQ2xpY2ssIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250ZW50Tm9kZSxcclxuXHRcdCAgICBzdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICcnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHRcdHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMub3B0aW9ucy5tYXhXaWR0aCk7XHJcblx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gKHdpZHRoICsgMSkgKyAncHgnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICcnO1xyXG5cclxuXHRcdHN0eWxlLmhlaWdodCA9ICcnO1xyXG5cclxuXHRcdHZhciBoZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG5cdFx0ICAgIG1heEhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQsXHJcblx0XHQgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJztcclxuXHJcblx0XHRpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xyXG5cdFx0XHRzdHlsZS5oZWlnaHQgPSBtYXhIZWlnaHQgKyAncHgnO1xyXG5cdFx0XHRhZGRDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHRcdHNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5hdXRvUGFuKSB7IHJldHVybjsgfVxyXG5cdFx0aWYgKHRoaXMuX21hcC5fcGFuQW5pbSkgeyB0aGlzLl9tYXAuX3BhbkFuaW0uc3RvcCgpOyB9XHJcblxyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBtYXJnaW5Cb3R0b20gPSBwYXJzZUludChnZXRTdHlsZSh0aGlzLl9jb250YWluZXIsICdtYXJnaW5Cb3R0b20nKSwgMTApIHx8IDAsXHJcblx0XHQgICAgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCArIG1hcmdpbkJvdHRvbSxcclxuXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG5cdFx0ICAgIGxheWVyUG9zID0gbmV3IFBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xyXG5cclxuXHRcdGxheWVyUG9zLl9hZGQoZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcblx0XHQgICAgcGFkZGluZyA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nVEwgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBzaXplID0gbWFwLmdldFNpemUoKSxcclxuXHRcdCAgICBkeCA9IDAsXHJcblx0XHQgICAgZHkgPSAwO1xyXG5cclxuXHRcdGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0IC0gc2l6ZS55ICsgcGFkZGluZ0JSLnk7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBhdXRvcGFuc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgc3RhcnRzIGF1dG9wYW5uaW5nIHdoZW4gb3BlbmluZyBhIHBvcHVwLlxyXG5cdFx0aWYgKGR4IHx8IGR5KSB7XHJcblx0XHRcdG1hcFxyXG5cdFx0XHQgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXHJcblx0XHRcdCAgICAucGFuQnkoW2R4LCBkeV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbkNsb3NlQnV0dG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9jbG9zZSgpO1xyXG5cdFx0c3RvcChlKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSBwb3B1cCBvbiB0aGUgc291cmNlIGxheWVyP1xyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXHJcbnZhciBwb3B1cCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRyZXR1cm4gbmV3IFBvcHVwKG9wdGlvbnMsIHNvdXJjZSk7XHJcbn07XHJcblxyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG4gKiBAb3B0aW9uIGNsb3NlUG9wdXBPbkNsaWNrOiBCb29sZWFuID0gdHJ1ZVxyXG4gKiBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCBwb3B1cHMgdG8gY2xvc2Ugd2hlbiB1c2VyIGNsaWNrcyB0aGUgbWFwLlxyXG4gKi9cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0Y2xvc2VQb3B1cE9uQ2xpY2s6IHRydWVcclxufSk7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAocG9wdXA6IFBvcHVwKTogdGhpc1xyXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgcG9wdXAgd2hpbGUgY2xvc2luZyB0aGUgcHJldmlvdXNseSBvcGVuZWQgKHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBpcyBvcGVuZWQgYXQgb25lIHRpbWUgZm9yIHVzYWJpbGl0eSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ3JlYXRlcyBhIHBvcHVwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVucyBpdCBpbiB0aGUgZ2l2ZW4gcG9pbnQgb24gYSBtYXAuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAocG9wdXAsIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0aWYgKCEocG9wdXAgaW5zdGFuY2VvZiBQb3B1cCkpIHtcclxuXHRcdFx0cG9wdXAgPSBuZXcgUG9wdXAob3B0aW9ucykuc2V0Q29udGVudChwb3B1cCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhdGxuZykge1xyXG5cdFx0XHRwb3B1cC5zZXRMYXRMbmcobGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihwb3B1cCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX3BvcHVwLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XHJcblx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3BvcHVwID0gcG9wdXA7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihwb3B1cCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKHBvcHVwPzogUG9wdXApOiB0aGlzXHJcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBwcmV2aW91c2x5IG9wZW5lZCB3aXRoIFtvcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSAob3IgdGhlIGdpdmVuIG9uZSkuXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKHBvcHVwKSB7XHJcblx0XHRpZiAoIXBvcHVwIHx8IHBvcHVwID09PSB0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRwb3B1cCA9IHRoaXMuX3BvcHVwO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRpZiAocG9wdXApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVMYXllcihwb3B1cCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBMYXllclxyXG4gKiBAc2VjdGlvbiBQb3B1cCBtZXRob2RzIGV4YW1wbGVcclxuICpcclxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgcG9wdXBzIHRvIGl0LlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFBvcHVwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xyXG4gKiBsYXllci5vcGVuUG9wdXAoKTtcclxuICogbGF5ZXIuY2xvc2VQb3B1cCgpO1xyXG4gKiBgYGBcclxuICpcclxuICogUG9wdXBzIHdpbGwgYWxzbyBiZSBhdXRvbWF0aWNhbGx5IG9wZW5lZCB3aGVuIHRoZSBsYXllciBpcyBjbGlja2VkIG9uIGFuZCBjbG9zZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgb3IgYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcbiAqL1xyXG5cclxuLy8gQHNlY3Rpb24gUG9wdXAgbWV0aG9kc1xyXG5MYXllci5pbmNsdWRlKHtcclxuXHJcblx0Ly8gQG1ldGhvZCBiaW5kUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFBvcHVwLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBCaW5kcyBhIHBvcHVwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxyXG5cdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXHJcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXHJcblx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG5cclxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgUG9wdXApIHtcclxuXHRcdFx0c2V0T3B0aW9ucyhjb250ZW50LCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBjb250ZW50O1xyXG5cdFx0XHRjb250ZW50Ll9zb3VyY2UgPSB0aGlzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCBvcHRpb25zKSB7XHJcblx0XHRcdFx0dGhpcy5fcG9wdXAgPSBuZXcgUG9wdXAob3B0aW9ucywgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuYmluZFBvcHVwKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBwb3B1cCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRQb3B1cGAuXHJcblx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHBvcHVwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgcG9wdXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fbWFwKSB7XHJcblx0XHRcdGxhdGxuZyA9IHRoaXMuX3BvcHVwLl9wcmVwYXJlT3Blbih0aGlzLCBsYXllciwgbGF0bG5nKTtcclxuXHJcblx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Qb3B1cCh0aGlzLl9wb3B1cCwgbGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAoKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5fY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9nZ2xlUG9wdXAoKTogdGhpc1xyXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcblx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRpZiAodGhpcy5fcG9wdXAuX21hcCkge1xyXG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMub3BlblBvcHVwKHRhcmdldCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNQb3B1cE9wZW4oKTogYm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxyXG5cdGlzUG9wdXBPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gKHRoaXMuX3BvcHVwID8gdGhpcy5fcG9wdXAuaXNPcGVuKCkgOiBmYWxzZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQb3B1cENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFBvcHVwKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcblx0c2V0UG9wdXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBvcHVwKCk6IFBvcHVwXHJcblx0Ly8gUmV0dXJucyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BvcHVwO1xyXG5cdH0sXHJcblxyXG5cdF9vcGVuUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xyXG5cclxuXHRcdGlmICghdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xyXG5cdFx0c3RvcChlKTtcclxuXHJcblx0XHQvLyBpZiB0aGlzIGluaGVyaXRzIGZyb20gUGF0aCBpdHMgYSB2ZWN0b3IgYW5kIHdlIGNhbiBqdXN0XHJcblx0XHQvLyBvcGVuIHRoZSBwb3B1cCBhdCB0aGUgbmV3IGxvY2F0aW9uXHJcblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBQYXRoKSB7XHJcblx0XHRcdHRoaXMub3BlblBvcHVwKGUubGF5ZXIgfHwgZS50YXJnZXQsIGUubGF0bG5nKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG90aGVyd2lzZSB0cmVhdCBpdCBsaWtlIGEgbWFya2VyIGFuZCBmaWd1cmUgb3V0XHJcblx0XHQvLyBpZiB3ZSBzaG91bGQgdG9nZ2xlIGl0IG9wZW4vY2xvc2VkXHJcblx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHRoaXMuX3BvcHVwKSAmJiB0aGlzLl9wb3B1cC5fc291cmNlID09PSBsYXllcikge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub3BlblBvcHVwKGxheWVyLCBlLmxhdGxuZyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X21vdmVQb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhlLmxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0X29uS2V5UHJlc3M6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDEzKSB7XHJcblx0XHRcdHRoaXMuX29wZW5Qb3B1cChlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xuXG4vKlxuICogQGNsYXNzIFRvb2x0aXBcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XG4gKiBAYWthIEwuVG9vbHRpcFxuICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIG1hcmtlci5iaW5kVG9vbHRpcChcIm15IHRvb2x0aXAgdGV4dFwiKS5vcGVuVG9vbHRpcCgpO1xuICogYGBgXG4gKiBOb3RlIGFib3V0IHRvb2x0aXAgb2Zmc2V0LiBMZWFmbGV0IHRha2VzIHR3byBvcHRpb25zIGluIGNvbnNpZGVyYXRpb25cbiAqIGZvciBjb21wdXRpbmcgdG9vbHRpcCBvZmZzZXR0aW5nOlxuICogLSB0aGUgYG9mZnNldGAgVG9vbHRpcCBvcHRpb246IGl0IGRlZmF1bHRzIHRvIFswLCAwXSwgYW5kIGl0J3Mgc3BlY2lmaWMgdG8gb25lIHRvb2x0aXAuXG4gKiAgIEFkZCBhIHBvc2l0aXZlIHggb2Zmc2V0IHRvIG1vdmUgdGhlIHRvb2x0aXAgdG8gdGhlIHJpZ2h0LCBhbmQgYSBwb3NpdGl2ZSB5IG9mZnNldCB0b1xuICogICBtb3ZlIGl0IHRvIHRoZSBib3R0b20uIE5lZ2F0aXZlcyB3aWxsIG1vdmUgdG8gdGhlIGxlZnQgYW5kIHRvcC5cbiAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAqICAgc2hvdWxkIGFkYXB0IHRoaXMgdmFsdWUgaWYgeW91IHVzZSBhIGN1c3RvbSBpY29uLlxuICovXG5cblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG52YXIgVG9vbHRpcCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFRvb2x0aXAgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndG9vbHRpcFBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0b29sdGlwUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxuXHRcdC8vIE9wdGlvbmFsIG9mZnNldCBvZiB0aGUgdG9vbHRpcCBwb3NpdGlvbi5cblx0XHRvZmZzZXQ6IFswLCAwXSxcblxuXHRcdC8vIEBvcHRpb24gZGlyZWN0aW9uOiBTdHJpbmcgPSAnYXV0bydcblx0XHQvLyBEaXJlY3Rpb24gd2hlcmUgdG8gb3BlbiB0aGUgdG9vbHRpcC4gUG9zc2libGUgdmFsdWVzIGFyZTogYHJpZ2h0YCwgYGxlZnRgLFxuXHRcdC8vIGB0b3BgLCBgYm90dG9tYCwgYGNlbnRlcmAsIGBhdXRvYC5cblx0XHQvLyBgYXV0b2Agd2lsbCBkeW5hbWljYWxseSBzd2l0Y2ggYmV0d2VlbiBgcmlnaHRgIGFuZCBgbGVmdGAgYWNjb3JkaW5nIHRvIHRoZSB0b29sdGlwXG5cdFx0Ly8gcG9zaXRpb24gb24gdGhlIG1hcC5cblx0XHRkaXJlY3Rpb246ICdhdXRvJyxcblxuXHRcdC8vIEBvcHRpb24gcGVybWFuZW50OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRvIG9wZW4gdGhlIHRvb2x0aXAgcGVybWFuZW50bHkgb3Igb25seSBvbiBtb3VzZW92ZXIuXG5cdFx0cGVybWFuZW50OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gc3RpY2t5OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGZvbGxvdyB0aGUgbW91c2UgaW5zdGVhZCBvZiBiZWluZyBmaXhlZCBhdCB0aGUgZmVhdHVyZSBjZW50ZXIuXG5cdFx0c3RpY2t5OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgbGlzdGVuIHRvIHRoZSBmZWF0dXJlIGV2ZW50cy5cblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDAuOVxuXHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG9wYWNpdHkuXG5cdFx0b3BhY2l0eTogMC45XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG5cdFx0dGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGlzIG9wZW5lZCBpbiB0aGUgbWFwLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaW4gdGhlIG1hcCBpcyBjbG9zZWQuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cblx0XHRpZiAodG91Y2ggJiYgIXRoaXMub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuX2Nsb3NlO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fbWFwLmNsb3NlVG9vbHRpcCh0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtdG9vbHRpcCcsXG5cdFx0ICAgIGNsYXNzTmFtZSA9IHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArICcgbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XG5cblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUpO1xuXHR9LFxuXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9zZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgY2VudGVyUG9pbnQgPSBtYXAubGF0TG5nVG9Db250YWluZXJQb2ludChtYXAuZ2V0Q2VudGVyKCkpLFxuXHRcdCAgICB0b29sdGlwUG9pbnQgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9zKSxcblx0XHQgICAgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbixcblx0XHQgICAgdG9vbHRpcFdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoLFxuXHRcdCAgICB0b29sdGlwSGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XG5cblx0XHRpZiAoZGlyZWN0aW9uID09PSAndG9wJykge1xuXHRcdFx0cG9zID0gcG9zLmFkZCh0b1BvaW50KC10b29sdGlwV2lkdGggLyAyICsgb2Zmc2V0LngsIC10b29sdGlwSGVpZ2h0ICsgb2Zmc2V0LnkgKyBhbmNob3IueSwgdHJ1ZSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJykge1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQodG9vbHRpcFdpZHRoIC8gMiAtIG9mZnNldC54LCAtb2Zmc2V0LnksIHRydWUpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHRvb2x0aXBXaWR0aCAvIDIgKyBvZmZzZXQueCwgdG9vbHRpcEhlaWdodCAvIDIgLSBhbmNob3IueSArIG9mZnNldC55LCB0cnVlKSk7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcgfHwgZGlyZWN0aW9uID09PSAnYXV0bycgJiYgdG9vbHRpcFBvaW50LnggPCBjZW50ZXJQb2ludC54KSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAncmlnaHQnO1xuXHRcdFx0cG9zID0gcG9zLmFkZCh0b1BvaW50KG9mZnNldC54ICsgYW5jaG9yLngsIGFuY2hvci55IC0gdG9vbHRpcEhlaWdodCAvIDIgKyBvZmZzZXQueSwgdHJ1ZSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAnbGVmdCc7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludCh0b29sdGlwV2lkdGggKyBhbmNob3IueCAtIG9mZnNldC54LCB0b29sdGlwSGVpZ2h0IC8gMiAtIGFuY2hvci55IC0gb2Zmc2V0LnksIHRydWUpKTtcblx0XHR9XG5cblx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtcmlnaHQnKTtcblx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtbGVmdCcpO1xuXHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC10b3AnKTtcblx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtYm90dG9tJyk7XG5cdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLScgKyBkaXJlY3Rpb24pO1xuXHRcdHNldFBvc2l0aW9uKGNvbnRhaW5lciwgcG9zKTtcblx0fSxcblxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgb3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSB0b29sdGlwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvciAmJiAhdGhpcy5vcHRpb25zLnN0aWNreSA/IHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvcigpIDogWzAsIDBdKTtcblx0fVxuXG59KTtcblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4vLyBAZmFjdG9yeSBMLnRvb2x0aXAob3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXG4vLyBJbnN0YW50aWF0ZXMgYSBUb29sdGlwIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHRvb2x0aXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxudmFyIHRvb2x0aXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG5cdHJldHVybiBuZXcgVG9vbHRpcChvcHRpb25zLCBzb3VyY2UpO1xufTtcblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbk1hcC5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cblx0Ly8gQGFsdGVybmF0aXZlXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0aWYgKCEodG9vbHRpcCBpbnN0YW5jZW9mIFRvb2x0aXApKSB7XG5cdFx0XHR0b29sdGlwID0gbmV3IFRvb2x0aXAob3B0aW9ucykuc2V0Q29udGVudCh0b29sdGlwKTtcblx0XHR9XG5cblx0XHRpZiAobGF0bG5nKSB7XG5cdFx0XHR0b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmhhc0xheWVyKHRvb2x0aXApKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcih0b29sdGlwKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCh0b29sdGlwPzogVG9vbHRpcCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGdpdmVuIGFzIHBhcmFtZXRlci5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCkge1xuXHRcdGlmICh0b29sdGlwKSB7XG5cdFx0XHR0aGlzLnJlbW92ZUxheWVyKHRvb2x0aXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG59KTtcblxuLypcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAqIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kcyBleGFtcGxlXG4gKlxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgdG9vbHRpcHMgdG8gaXQuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kVG9vbHRpcCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAqIGxheWVyLm9wZW5Ub29sdGlwKCk7XG4gKiBsYXllci5jbG9zZVRvb2x0aXAoKTtcbiAqIGBgYFxuICovXG5cbi8vIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kc1xuTGF5ZXIuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBiaW5kVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258VG9vbHRpcCwgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQmluZHMgYSB0b29sdGlwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cblx0YmluZFRvb2x0aXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIFRvb2x0aXApIHtcblx0XHRcdHNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gY29udGVudDtcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCBvcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBuZXcgVG9vbHRpcChvcHRpb25zLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKCk7XG5cblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCAmJiB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpKSB7XG5cdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB1bmJpbmRUb29sdGlwKCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgdG9vbHRpcCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRUb29sdGlwYC5cblx0dW5iaW5kVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyh0cnVlKTtcblx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOiBmdW5jdGlvbiAocmVtb3ZlJCQxKSB7XG5cdFx0aWYgKCFyZW1vdmUkJDEgJiYgdGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlJCQxID8gJ29mZicgOiAnb24nLFxuXHRcdCAgICBldmVudHMgPSB7XG5cdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VUb29sdGlwLFxuXHRcdFx0bW92ZTogdGhpcy5fbW92ZVRvb2x0aXBcblx0XHQgICAgfTtcblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5tb3VzZW92ZXIgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdGV2ZW50cy5tb3VzZW91dCA9IHRoaXMuY2xvc2VUb29sdGlwO1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kpIHtcblx0XHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSA9IHRoaXMuX21vdmVUb29sdGlwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRvdWNoKSB7XG5cdFx0XHRcdGV2ZW50cy5jbGljayA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRldmVudHMuYWRkID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0fVxuXHRcdHRoaXNbb25PZmZdKGV2ZW50cyk7XG5cdFx0dGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQgPSAhcmVtb3ZlJCQxO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgYm91bmQgdG9vbHRpcCBhdCB0aGUgc3BlY2lmaWVkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHRvb2x0aXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cblx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAgJiYgdGhpcy5fbWFwKSB7XG5cdFx0XHRsYXRsbmcgPSB0aGlzLl90b29sdGlwLl9wcmVwYXJlT3Blbih0aGlzLCBsYXllciwgbGF0bG5nKTtcblxuXHRcdFx0Ly8gb3BlbiB0aGUgdG9vbHRpcCBvbiB0aGUgbWFwXG5cdFx0XHR0aGlzLl9tYXAub3BlblRvb2x0aXAodGhpcy5fdG9vbHRpcCwgbGF0bG5nKTtcblxuXHRcdFx0Ly8gVG9vbHRpcCBjb250YWluZXIgbWF5IG5vdCBiZSBkZWZpbmVkIGlmIG5vdCBwZXJtYW5lbnQgYW5kIG5ldmVyXG5cdFx0XHQvLyBvcGVuZWQuXG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLmludGVyYWN0aXZlICYmIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcikge1xuXHRcdFx0XHRhZGRDbGFzcyh0aGlzLl90b29sdGlwLl9jb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5fY2xvc2UoKTtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB0b2dnbGVUb29sdGlwKCk6IHRoaXNcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxuXHR0b2dnbGVUb29sdGlwOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLl9tYXApIHtcblx0XHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMub3BlblRvb2x0aXAodGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc1Rvb2x0aXBPcGVuKCk6IGJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cblx0aXNUb29sdGlwT3BlbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0VG9vbHRpcENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFRvb2x0aXApOiB0aGlzXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0c2V0VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRUb29sdGlwKCk6IFRvb2x0aXBcblx0Ly8gUmV0dXJucyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRnZXRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG5cdH0sXG5cblx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XG5cblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLm9wZW5Ub29sdGlwKGxheWVyLCB0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ID8gZS5sYXRsbmcgOiB1bmRlZmluZWQpO1xuXHR9LFxuXG5cdF9tb3ZlVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF0bG5nID0gZS5sYXRsbmcsIGNvbnRhaW5lclBvaW50LCBsYXllclBvaW50O1xuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ICYmIGUub3JpZ2luYWxFdmVudCkge1xuXHRcdFx0Y29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50KTtcblx0XHRcdGxheWVyUG9pbnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpO1xuXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcblx0XHR9XG5cdFx0dGhpcy5fdG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0fVxufSk7XG5cbi8qXG4gKiBAY2xhc3MgRGl2SWNvblxuICogQGFrYSBMLkRpdkljb25cbiAqIEBpbmhlcml0cyBJY29uXG4gKlxuICogUmVwcmVzZW50cyBhIGxpZ2h0d2VpZ2h0IGljb24gZm9yIG1hcmtlcnMgdGhhdCB1c2VzIGEgc2ltcGxlIGA8ZGl2PmBcbiAqIGVsZW1lbnQgaW5zdGVhZCBvZiBhbiBpbWFnZS4gSW5oZXJpdHMgZnJvbSBgSWNvbmAgYnV0IGlnbm9yZXMgdGhlIGBpY29uVXJsYCBhbmQgc2hhZG93IG9wdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgbXlJY29uID0gTC5kaXZJY29uKHtjbGFzc05hbWU6ICdteS1kaXYtaWNvbid9KTtcbiAqIC8vIHlvdSBjYW4gc2V0IC5teS1kaXYtaWNvbiBzdHlsZXMgaW4gQ1NTXG4gKlxuICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICpcbiAqIEJ5IGRlZmF1bHQsIGl0IGhhcyBhICdsZWFmbGV0LWRpdi1pY29uJyBDU1MgY2xhc3MgYW5kIGlzIHN0eWxlZCBhcyBhIGxpdHRsZSB3aGl0ZSBzcXVhcmUgd2l0aCBhIHNoYWRvdy5cbiAqL1xuXG52YXIgRGl2SWNvbiA9IEljb24uZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBEaXZJY29uIG9wdGlvbnNcblx0XHRpY29uU2l6ZTogWzEyLCAxMl0sIC8vIGFsc28gY2FuIGJlIHNldCB0aHJvdWdoIENTU1xuXG5cdFx0Ly8gaWNvbkFuY2hvcjogKFBvaW50KSxcblx0XHQvLyBwb3B1cEFuY2hvcjogKFBvaW50KSxcblxuXHRcdC8vIEBvcHRpb24gaHRtbDogU3RyaW5nfEhUTUxFbGVtZW50ID0gJydcblx0XHQvLyBDdXN0b20gSFRNTCBjb2RlIHRvIHB1dCBpbnNpZGUgdGhlIGRpdiBlbGVtZW50LCBlbXB0eSBieSBkZWZhdWx0LiBBbHRlcm5hdGl2ZWx5LFxuXHRcdC8vIGFuIGluc3RhbmNlIG9mIGBIVE1MRWxlbWVudGAuXG5cdFx0aHRtbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGJnUG9zOiBQb2ludCA9IFswLCAwXVxuXHRcdC8vIE9wdGlvbmFsIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBiYWNrZ3JvdW5kLCBpbiBwaXhlbHNcblx0XHRiZ1BvczogbnVsbCxcblxuXHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nXG5cdH0sXG5cblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcblx0XHR2YXIgZGl2ID0gKG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnRElWJykgPyBvbGRJY29uIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0aW9ucy5odG1sIGluc3RhbmNlb2YgRWxlbWVudCkge1xuXHRcdFx0ZW1wdHkoZGl2KTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZChvcHRpb25zLmh0bWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sICE9PSBmYWxzZSA/IG9wdGlvbnMuaHRtbCA6ICcnO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmJnUG9zKSB7XG5cdFx0XHR2YXIgYmdQb3MgPSB0b1BvaW50KG9wdGlvbnMuYmdQb3MpO1xuXHRcdFx0ZGl2LnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9ICgtYmdQb3MueCkgKyAncHggJyArICgtYmdQb3MueSkgKyAncHgnO1xuXHRcdH1cblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGRpdiwgJ2ljb24nKTtcblxuXHRcdHJldHVybiBkaXY7XG5cdH0sXG5cblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmRpdkljb24ob3B0aW9uczogRGl2SWNvbiBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIGBEaXZJY29uYCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZnVuY3Rpb24gZGl2SWNvbihvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgRGl2SWNvbihvcHRpb25zKTtcbn1cblxuSWNvbi5EZWZhdWx0ID0gSWNvbkRlZmF1bHQ7XG5cbi8qXG4gKiBAY2xhc3MgR3JpZExheWVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5HcmlkTGF5ZXJcbiAqXG4gKiBHZW5lcmljIGNsYXNzIGZvciBoYW5kbGluZyBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cy4gVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIHRpbGUgbGF5ZXJzIGFuZCByZXBsYWNlcyBgVGlsZUxheWVyLkNhbnZhc2AuXG4gKiBHcmlkTGF5ZXIgY2FuIGJlIGV4dGVuZGVkIHRvIGNyZWF0ZSBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cyBsaWtlIGA8Y2FudmFzPmAsIGA8aW1nPmAgb3IgYDxkaXY+YC4gR3JpZExheWVyIHdpbGwgaGFuZGxlIGNyZWF0aW5nIGFuZCBhbmltYXRpbmcgdGhlc2UgRE9NIGVsZW1lbnRzIGZvciB5b3UuXG4gKlxuICpcbiAqIEBzZWN0aW9uIFN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBsYXllciwgZXh0ZW5kIEdyaWRMYXllciBhbmQgaW1wbGVtZW50IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGEgYFBvaW50YCBvYmplY3Qgd2l0aCB0aGUgYHhgLCBgeWAsIGFuZCBgemAgKHpvb20gbGV2ZWwpIGNvb3JkaW5hdGVzIHRvIGRyYXcgeW91ciB0aWxlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3Jkcyl7XG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGdldCBhIGNhbnZhcyBjb250ZXh0IGFuZCBkcmF3IHNvbWV0aGluZyBvbiBpdCB1c2luZyBjb29yZHMueCwgY29vcmRzLnkgYW5kIGNvb3Jkcy56XG4gKiAgICAgICAgIHZhciBjdHggPSB0aWxlLmdldENvbnRleHQoJzJkJyk7XG4gKlxuICogICAgICAgICAvLyByZXR1cm4gdGhlIHRpbGUgc28gaXQgY2FuIGJlIHJlbmRlcmVkIG9uIHNjcmVlblxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uIEFzeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUaWxlIGNyZWF0aW9uIGNhbiBhbHNvIGJlIGFzeW5jaHJvbm91cywgdGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBhIHRoaXJkLXBhcnR5IGRyYXdpbmcgbGlicmFyeS4gT25jZSB0aGUgdGlsZSBpcyBmaW5pc2hlZCBkcmF3aW5nIGl0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGBkb25lKClgIGNhbGxiYWNrLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgZG9uZSl7XG4gKiAgICAgICAgIHZhciBlcnJvcjtcbiAqXG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGRyYXcgc29tZXRoaW5nIGFzeW5jaHJvbm91c2x5IGFuZCBwYXNzIHRoZSB0aWxlIHRvIHRoZSBkb25lKCkgY2FsbGJhY2tcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGRvbmUoZXJyb3IsIHRpbGUpO1xuICogICAgICAgICB9LCAxMDAwKTtcbiAqXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb25cbiAqL1xuXG5cbnZhciBHcmlkTGF5ZXIgPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgR3JpZExheWVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gdGlsZVNpemU6IE51bWJlcnxQb2ludCA9IDI1NlxuXHRcdC8vIFdpZHRoIGFuZCBoZWlnaHQgb2YgdGlsZXMgaW4gdGhlIGdyaWQuIFVzZSBhIG51bWJlciBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBlcXVhbCwgb3IgYEwucG9pbnQod2lkdGgsIGhlaWdodClgIG90aGVyd2lzZS5cblx0XHR0aWxlU2l6ZTogMjU2LFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBPcGFjaXR5IG9mIHRoZSB0aWxlcy4gQ2FuIGJlIHVzZWQgaW4gdGhlIGBjcmVhdGVUaWxlKClgIGZ1bmN0aW9uLlxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gKGRlcGVuZHMpXG5cdFx0Ly8gTG9hZCBuZXcgdGlsZXMgb25seSB3aGVuIHBhbm5pbmcgZW5kcy5cblx0XHQvLyBgdHJ1ZWAgYnkgZGVmYXVsdCBvbiBtb2JpbGUgYnJvd3NlcnMsIGluIG9yZGVyIHRvIGF2b2lkIHRvbyBtYW55IHJlcXVlc3RzIGFuZCBrZWVwIHNtb290aCBuYXZpZ2F0aW9uLlxuXHRcdC8vIGBmYWxzZWAgb3RoZXJ3aXNlIGluIG9yZGVyIHRvIGRpc3BsYXkgbmV3IHRpbGVzIF9kdXJpbmdfIHBhbm5pbmcsIHNpbmNlIGl0IGlzIGVhc3kgdG8gcGFuIG91dHNpZGUgdGhlXG5cdFx0Ly8gW2BrZWVwQnVmZmVyYF0oI2dyaWRsYXllci1rZWVwYnVmZmVyKSBvcHRpb24gaW4gZGVza3RvcCBicm93c2Vycy5cblx0XHR1cGRhdGVXaGVuSWRsZTogbW9iaWxlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuWm9vbWluZzogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBCeSBkZWZhdWx0LCBhIHNtb290aCB6b29tIGFuaW1hdGlvbiAoZHVyaW5nIGEgW3RvdWNoIHpvb21dKCNtYXAtdG91Y2h6b29tKSBvciBhIFtgZmx5VG8oKWBdKCNtYXAtZmx5dG8pKSB3aWxsIHVwZGF0ZSBncmlkIGxheWVycyBldmVyeSBpbnRlZ2VyIHpvb20gbGV2ZWwuIFNldHRpbmcgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB3aWxsIHVwZGF0ZSB0aGUgZ3JpZCBsYXllciBvbmx5IHdoZW4gdGhlIHNtb290aCBhbmltYXRpb24gZW5kcy5cblx0XHR1cGRhdGVXaGVuWm9vbWluZzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlSW50ZXJ2YWw6IE51bWJlciA9IDIwMFxuXHRcdC8vIFRpbGVzIHdpbGwgbm90IHVwZGF0ZSBtb3JlIHRoYW4gb25jZSBldmVyeSBgdXBkYXRlSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyB3aGVuIHBhbm5pbmcuXG5cdFx0dXBkYXRlSW50ZXJ2YWw6IDIwMCxcblxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IHpJbmRleCBvZiB0aGUgdGlsZSBsYXllci5cblx0XHR6SW5kZXg6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGJvdW5kczogTGF0TG5nQm91bmRzID0gdW5kZWZpbmVkXG5cdFx0Ly8gSWYgc2V0LCB0aWxlcyB3aWxsIG9ubHkgYmUgbG9hZGVkIGluc2lkZSB0aGUgc2V0IGBMYXRMbmdCb3VuZHNgLlxuXHRcdGJvdW5kczogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuXHRcdG1pblpvb206IDAsXG5cblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cblx0XHRtYXhab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG1heE5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIE1heGltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGhpZ2hlciB0aGFuIGBtYXhOYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuXHRcdC8vIGZyb20gYG1heE5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cblx0XHRtYXhOYXRpdmVab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG1pbk5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIE1pbmltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGxvd2VyIHRoYW4gYG1pbk5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG5cdFx0Ly8gZnJvbSBgbWluTmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuXHRcdG1pbk5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbm9XcmFwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRoZSBsYXllciBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgYW50aW1lcmlkaWFuLiBJZiBgdHJ1ZWAsIHRoZVxuXHRcdC8vIEdyaWRMYXllciB3aWxsIG9ubHkgYmUgZGlzcGxheWVkIG9uY2UgYXQgbG93IHpvb20gbGV2ZWxzLiBIYXMgbm9cblx0XHQvLyBlZmZlY3Qgd2hlbiB0aGUgW21hcCBDUlNdKCNtYXAtY3JzKSBkb2Vzbid0IHdyYXAgYXJvdW5kLiBDYW4gYmUgdXNlZFxuXHRcdC8vIGluIGNvbWJpbmF0aW9uIHdpdGggW2Bib3VuZHNgXSgjZ3JpZGxheWVyLWJvdW5kcykgdG8gcHJldmVudCByZXF1ZXN0aW5nXG5cdFx0Ly8gdGlsZXMgb3V0c2lkZSB0aGUgQ1JTIGxpbWl0cy5cblx0XHRub1dyYXA6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndGlsZVBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgZ3JpZCBsYXllciB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0aWxlUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcblx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgdGlsZSBsYXllci4gRW1wdHkgYnkgZGVmYXVsdC5cblx0XHRjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gQG9wdGlvbiBrZWVwQnVmZmVyOiBOdW1iZXIgPSAyXG5cdFx0Ly8gV2hlbiBwYW5uaW5nIHRoZSBtYXAsIGtlZXAgdGhpcyBtYW55IHJvd3MgYW5kIGNvbHVtbnMgb2YgdGlsZXMgYmVmb3JlIHVubG9hZGluZyB0aGVtLlxuXHRcdGtlZXBCdWZmZXI6IDJcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XG5cblx0XHR0aGlzLl9sZXZlbHMgPSB7fTtcblx0XHR0aGlzLl90aWxlcyA9IHt9O1xuXG5cdFx0dGhpcy5fcmVzZXRWaWV3KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLl9hZGRab29tTGltaXQodGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdHJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdG1hcC5fcmVtb3ZlWm9vbUxpbWl0KHRoaXMpO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG5cdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWF4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgdGlsZSBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSB0aWxlcyBmb3IgdGhpcyBsYXllci5cblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBbb3BhY2l0eV0oI2dyaWRsYXllci1vcGFjaXR5KSBvZiB0aGUgZ3JpZCBsYXllci5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjZ3JpZGxheWVyLXppbmRleCkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xuXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB6SW5kZXg7XG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzTG9hZGluZzogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgdGlsZSBpbiB0aGUgZ3JpZCBsYXllciBoYXMgbm90IGZpbmlzaGVkIGxvYWRpbmcuXG5cdGlzTG9hZGluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sb2FkaW5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVkcmF3OiB0aGlzXG5cdC8vIENhdXNlcyB0aGUgbGF5ZXIgdG8gY2xlYXIgYWxsIHRoZSB0aWxlcyBhbmQgcmVxdWVzdCB0aGVtIGFnYWluLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cHJlcmVzZXQ6IHRoaXMuX2ludmFsaWRhdGVBbGwsXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0Vmlldyxcblx0XHRcdHpvb206IHRoaXMuX3Jlc2V0Vmlldyxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX29uTW92ZUVuZFxuXHRcdH07XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSkge1xuXHRcdFx0Ly8gdXBkYXRlIHRpbGVzIG9uIG1vdmUsIGJ1dCBub3QgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIGdpdmVuIGludGVydmFsXG5cdFx0XHRpZiAoIXRoaXMuX29uTW92ZSkge1xuXHRcdFx0XHR0aGlzLl9vbk1vdmUgPSB0aHJvdHRsZSh0aGlzLl9vbk1vdmVFbmQsIHRoaXMub3B0aW9ucy51cGRhdGVJbnRlcnZhbCwgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50cy5tb3ZlID0gdGhpcy5fb25Nb3ZlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgR3JpZExheWVyYCBzaGFsbCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBtdXN0IGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyBleHRlbmRpbmcgYEdyaWRMYXllcmAuXG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYGNvb3Jkc2AuIElmIHRoZSBgZG9uZWAgY2FsbGJhY2tcblx0Ly8gaXMgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBmaW5pc2hlZCBsb2FkaW5nIGFuZCBkcmF3aW5nLlxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVNpemU6IFBvaW50XG5cdC8vIE5vcm1hbGl6ZXMgdGhlIFt0aWxlU2l6ZSBvcHRpb25dKCNncmlkbGF5ZXItdGlsZXNpemUpIGludG8gYSBwb2ludC4gVXNlZCBieSB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLlxuXHRnZXRUaWxlU2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuXHRcdHJldHVybiBzIGluc3RhbmNlb2YgUG9pbnQgPyBzIDogbmV3IFBvaW50KHMsIHMpO1xuXHR9LFxuXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcblx0XHR9XG5cdH0sXG5cblx0X3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChjb21wYXJlKSB7XG5cdFx0Ly8gZ28gdGhyb3VnaCBhbGwgb3RoZXIgbGF5ZXJzIG9mIHRoZSBzYW1lIHBhbmUsIHNldCB6SW5kZXggdG8gbWF4ICsgMSAoZnJvbnQpIG9yIG1pbiAtIDEgKGJhY2spXG5cblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5nZXRQYW5lKCkuY2hpbGRyZW4sXG5cdFx0ICAgIGVkZ2VaSW5kZXggPSAtY29tcGFyZSgtSW5maW5pdHksIEluZmluaXR5KTsgLy8gLUluZmluaXR5IGZvciBtYXgsIEluZmluaXR5IGZvciBtaW5cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xuXG5cdFx0XHR6SW5kZXggPSBsYXllcnNbaV0uc3R5bGUuekluZGV4O1xuXG5cdFx0XHRpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jb250YWluZXIgJiYgekluZGV4KSB7XG5cdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0Zpbml0ZShlZGdlWkluZGV4KSkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IGVkZ2VaSW5kZXggKyBjb21wYXJlKC0xLCAxKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gSUUgZG9lc24ndCBpbmhlcml0IGZpbHRlciBvcGFjaXR5IHByb3Blcmx5LCBzbyB3ZSdyZSBmb3JjZWQgdG8gc2V0IGl0IG9uIHRpbGVzXG5cdFx0aWYgKGllbHQ5KSB7IHJldHVybjsgfVxuXG5cdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdHZhciBub3cgPSArbmV3IERhdGUoKSxcblx0XHQgICAgbmV4dEZyYW1lID0gZmFsc2UsXG5cdFx0ICAgIHdpbGxQcnVuZSA9IGZhbHNlO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAoIXRpbGUuY3VycmVudCB8fCAhdGlsZS5sb2FkZWQpIHsgY29udGludWU7IH1cblxuXHRcdFx0dmFyIGZhZGUgPSBNYXRoLm1pbigxLCAobm93IC0gdGlsZS5sb2FkZWQpIC8gMjAwKTtcblxuXHRcdFx0c2V0T3BhY2l0eSh0aWxlLmVsLCBmYWRlKTtcblx0XHRcdGlmIChmYWRlIDwgMSkge1xuXHRcdFx0XHRuZXh0RnJhbWUgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0d2lsbFBydW5lID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9vbk9wYXF1ZVRpbGUodGlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh3aWxsUHJ1bmUgJiYgIXRoaXMuX25vUHJ1bmUpIHsgdGhpcy5fcHJ1bmVUaWxlcygpOyB9XG5cblx0XHRpZiAobmV4dEZyYW1lKSB7XG5cdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk9wYXF1ZVRpbGU6IGZhbHNlRm4sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LWxheWVyICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X3VwZGF0ZUxldmVsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcblx0XHQgICAgbWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xuXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cblx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0aWYgKHRoaXMuX2xldmVsc1t6XS5lbC5jaGlsZHJlbi5sZW5ndGggfHwgeiA9PT0gem9vbSkge1xuXHRcdFx0XHR0aGlzLl9sZXZlbHNbel0uZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbSAtIE1hdGguYWJzKHpvb20gLSB6KTtcblx0XHRcdFx0dGhpcy5fb25VcGRhdGVMZXZlbCh6KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlc0F0Wm9vbSh6KTtcblx0XHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0sXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdGlmICghbGV2ZWwpIHtcblx0XHRcdGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dID0ge307XG5cblx0XHRcdGxldmVsLmVsID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LXRpbGUtY29udGFpbmVyIGxlYWZsZXQtem9vbS1hbmltYXRlZCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRsZXZlbC5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tO1xuXG5cdFx0XHRsZXZlbC5vcmlnaW4gPSBtYXAucHJvamVjdChtYXAudW5wcm9qZWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKSwgem9vbSkucm91bmQoKTtcblx0XHRcdGxldmVsLnpvb20gPSB6b29tO1xuXG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKGxldmVsLCBtYXAuZ2V0Q2VudGVyKCksIG1hcC5nZXRab29tKCkpO1xuXG5cdFx0XHQvLyBmb3JjZSB0aGUgYnJvd3NlciB0byBjb25zaWRlciB0aGUgbmV3bHkgYWRkZWQgZWxlbWVudCBmb3IgdHJhbnNpdGlvblxuXHRcdFx0ZmFsc2VGbihsZXZlbC5lbC5vZmZzZXRXaWR0aCk7XG5cblx0XHRcdHRoaXMuX29uQ3JlYXRlTGV2ZWwobGV2ZWwpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xldmVsID0gbGV2ZWw7XG5cblx0XHRyZXR1cm4gbGV2ZWw7XG5cdH0sXG5cblx0X29uVXBkYXRlTGV2ZWw6IGZhbHNlRm4sXG5cblx0X29uUmVtb3ZlTGV2ZWw6IGZhbHNlRm4sXG5cblx0X29uQ3JlYXRlTGV2ZWw6IGZhbHNlRm4sXG5cblx0X3BydW5lVGlsZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBrZXksIHRpbGU7XG5cblx0XHR2YXIgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cdFx0aWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fFxuXHRcdFx0em9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdHRpbGUucmV0YWluID0gdGlsZS5jdXJyZW50O1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdGlmICh0aWxlLmN1cnJlbnQgJiYgIXRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSB0aWxlLmNvb3Jkcztcblx0XHRcdFx0aWYgKCF0aGlzLl9yZXRhaW5QYXJlbnQoY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogLSA1KSkge1xuXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56ICsgMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLnJldGFpbikge1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVUaWxlc0F0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICh0aGlzLl90aWxlc1trZXldLmNvb3Jkcy56ICE9PSB6b29tKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlQWxsVGlsZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X2ludmFsaWRhdGVBbGw6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0cmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKHopO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHR9XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblxuXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdF9yZXRhaW5QYXJlbnQ6IGZ1bmN0aW9uICh4LCB5LCB6LCBtaW5ab29tKSB7XG5cdFx0dmFyIHgyID0gTWF0aC5mbG9vcih4IC8gMiksXG5cdFx0ICAgIHkyID0gTWF0aC5mbG9vcih5IC8gMiksXG5cdFx0ICAgIHoyID0geiAtIDEsXG5cdFx0ICAgIGNvb3JkczIgPSBuZXcgUG9pbnQoK3gyLCAreTIpO1xuXHRcdGNvb3JkczIueiA9ICt6MjtcblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzMiksXG5cdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKHoyID4gbWluWm9vbSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JldGFpblBhcmVudCh4MiwgeTIsIHoyLCBtaW5ab29tKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X3JldGFpbkNoaWxkcmVuOiBmdW5jdGlvbiAoeCwgeSwgeiwgbWF4Wm9vbSkge1xuXG5cdFx0Zm9yICh2YXIgaSA9IDIgKiB4OyBpIDwgMiAqIHggKyAyOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAyICogeTsgaiA8IDIgKiB5ICsgMjsgaisrKSB7XG5cblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB6ICsgMTtcblxuXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG5cdFx0XHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oaSwgaiwgeiArIDEsIG1heFpvb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XG5cdFx0dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCksIGFuaW1hdGluZywgYW5pbWF0aW5nKTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fc2V0VmlldyhlLmNlbnRlciwgZS56b29tLCB0cnVlLCBlLm5vVXBkYXRlKTtcblx0fSxcblxuXHRfY2xhbXBab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5taW5OYXRpdmVab29tICYmIHpvb20gPCBvcHRpb25zLm1pbk5hdGl2ZVpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1pbk5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5tYXhOYXRpdmVab29tICYmIG9wdGlvbnMubWF4TmF0aXZlWm9vbSA8IHpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHpvb207XG5cdH0sXG5cblx0X3NldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG5cdFx0dmFyIHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKE1hdGgucm91bmQoem9vbSkpO1xuXHRcdGlmICgodGhpcy5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB8fFxuXHRcdCAgICAodGhpcy5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0dmFyIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcblxuXHRcdGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG5cblx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cblx0XHRcdGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fYWJvcnRMb2FkaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuXHRcdFx0dGhpcy5fcmVzZXRHcmlkKCk7XG5cblx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIW5vUHJ1bmUpIHtcblx0XHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgX3VwZGF0ZU9wYWNpdHkgZnJvbSBwcnVuaW5nIHRpbGVzIGR1cmluZ1xuXHRcdFx0Ly8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXG5cdFx0XHR0aGlzLl9ub1BydW5lID0gISFub1BydW5lO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSk7XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm1zOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0odGhpcy5fbGV2ZWxzW2ldLCBjZW50ZXIsIHpvb20pO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24gKGxldmVsLCBjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuXHRcdCAgICB0cmFuc2xhdGUgPSBsZXZlbC5vcmlnaW4ubXVsdGlwbHlCeShzY2FsZSlcblx0XHQgICAgICAgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpLnJvdW5kKCk7XG5cblx0XHRpZiAoYW55M2QpIHtcblx0XHRcdHNldFRyYW5zZm9ybShsZXZlbC5lbCwgdHJhbnNsYXRlLCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNldFBvc2l0aW9uKGxldmVsLmVsLCB0cmFuc2xhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRHcmlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX3RpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICB0aWxlWm9vbSA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR0aGlzLl9nbG9iYWxUaWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fd3JhcFggPSBjcnMud3JhcExuZyAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzFdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdFx0dGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzFdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdH0sXG5cblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9nZXRUaWxlZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgbWFwWm9vbSA9IG1hcC5fYW5pbWF0aW5nWm9vbSA/IE1hdGgubWF4KG1hcC5fYW5pbWF0ZVRvWm9vbSwgbWFwLmdldFpvb20oKSkgOiBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fdGlsZVpvb20pLFxuXHRcdCAgICBwaXhlbENlbnRlciA9IG1hcC5wcm9qZWN0KGNlbnRlciwgdGhpcy5fdGlsZVpvb20pLmZsb29yKCksXG5cdFx0ICAgIGhhbGZTaXplID0gbWFwLmdldFNpemUoKS5kaXZpZGVCeShzY2FsZSAqIDIpO1xuXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMocGl4ZWxDZW50ZXIuc3VidHJhY3QoaGFsZlNpemUpLCBwaXhlbENlbnRlci5hZGQoaGFsZlNpemUpKTtcblx0fSxcblxuXHQvLyBQcml2YXRlIG1ldGhvZCB0byBsb2FkIHRpbGVzIGluIHRoZSBncmlkJ3MgYWN0aXZlIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIG1hcCBib3VuZHNcblx0X3VwZGF0ZTogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHpvb20gPSB0aGlzLl9jbGFtcFpvb20obWFwLmdldFpvb20oKSk7XG5cblx0XHRpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG5cdFx0aWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XHQvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cblx0XHR2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG5cdFx0ICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuXHRcdCAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuXHRcdCAgICBxdWV1ZSA9IFtdLFxuXHRcdCAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcblx0XHQgICAgbm9QcnVuZVJhbmdlID0gbmV3IEJvdW5kcyh0aWxlUmFuZ2UuZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFttYXJnaW4sIC1tYXJnaW5dKSxcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pKTtcblxuXHRcdC8vIFNhbml0eSBjaGVjazogcGFuaWMgaWYgdGhlIHRpbGUgcmFuZ2UgY29udGFpbnMgSW5maW5pdHkgc29tZXdoZXJlLlxuXHRcdGlmICghKGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLnkpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC54KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueSkpKSB7IHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGxvYWQgYW4gaW5maW5pdGUgbnVtYmVyIG9mIHRpbGVzJyk7IH1cblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIGMgPSB0aGlzLl90aWxlc1trZXldLmNvb3Jkcztcblx0XHRcdGlmIChjLnogIT09IHRoaXMuX3RpbGVab29tIHx8ICFub1BydW5lUmFuZ2UuY29udGFpbnMobmV3IFBvaW50KGMueCwgYy55KSkpIHtcblx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuXHRcdC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG5cdFx0aWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7IHRoaXMuX3NldFZpZXcoY2VudGVyLCB6b29tKTsgcmV0dXJuOyB9XG5cblx0XHQvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cblx0XHRmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pbi55OyBqIDw9IHRpbGVSYW5nZS5tYXgueTsgaisrKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pbi54OyBpIDw9IHRpbGVSYW5nZS5tYXgueDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHRcdFx0aWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV07XG5cdFx0XHRcdGlmICh0aWxlKSB7XG5cdFx0XHRcdFx0dGlsZS5jdXJyZW50ID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKGNvb3Jkcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzb3J0IHRpbGUgcXVldWUgdG8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcblx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0Ly8gaWYgaXQncyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuXHRcdFx0aWYgKCF0aGlzLl9sb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuXHRcdFx0XHQvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBzdGFydHMgbG9hZGluZyB0aWxlcy5cblx0XHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNyZWF0ZSBET00gZnJhZ21lbnQgdG8gYXBwZW5kIHRpbGVzIGluIG9uZSBiYXRjaFxuXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fYWRkVGlsZShxdWV1ZVtpXSwgZnJhZ21lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1ZhbGlkVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBjcnMgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoIWNycy5pbmZpbml0ZSkge1xuXHRcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kcyBhbmQgbm90IHdyYXBwZWRcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2U7XG5cdFx0XHRpZiAoKCFjcnMud3JhcExuZyAmJiAoY29vcmRzLnggPCBib3VuZHMubWluLnggfHwgY29vcmRzLnggPiBib3VuZHMubWF4LngpKSB8fFxuXHRcdFx0ICAgICghY3JzLndyYXBMYXQgJiYgKGNvb3Jkcy55IDwgYm91bmRzLm1pbi55IHx8IGNvb3Jkcy55ID4gYm91bmRzLm1heC55KSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYm91bmRzKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBpbiBvcHRpb25zXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKTtcblx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHModGhpcy5vcHRpb25zLmJvdW5kcykub3ZlcmxhcHModGlsZUJvdW5kcyk7XG5cdH0sXG5cblx0X2tleVRvQm91bmRzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyh0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KSk7XG5cdH0sXG5cblx0X3RpbGVDb29yZHNUb053U2U6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblx0XHQgICAgbndQb2ludCA9IGNvb3Jkcy5zY2FsZUJ5KHRpbGVTaXplKSxcblx0XHQgICAgc2VQb2ludCA9IG53UG9pbnQuYWRkKHRpbGVTaXplKSxcblx0XHQgICAgbncgPSBtYXAudW5wcm9qZWN0KG53UG9pbnQsIGNvb3Jkcy56KSxcblx0XHQgICAgc2UgPSBtYXAudW5wcm9qZWN0KHNlUG9pbnQsIGNvb3Jkcy56KTtcblx0XHRyZXR1cm4gW253LCBzZV07XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBpdHMgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuXHRfdGlsZUNvb3Jkc1RvQm91bmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIGJwID0gdGhpcy5fdGlsZUNvb3Jkc1RvTndTZShjb29yZHMpLFxuXHRcdCAgICBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKGJwWzBdLCBicFsxXSk7XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5ub1dyYXApIHtcblx0XHRcdGJvdW5kcyA9IHRoaXMuX21hcC53cmFwTGF0TG5nQm91bmRzKGJvdW5kcyk7XG5cdFx0fVxuXHRcdHJldHVybiBib3VuZHM7XG5cdH0sXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8ga2V5IGZvciB0aGUgdGlsZSBjYWNoZVxuXHRfdGlsZUNvb3Jkc1RvS2V5OiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0cmV0dXJuIGNvb3Jkcy54ICsgJzonICsgY29vcmRzLnkgKyAnOicgKyBjb29yZHMuejtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNhY2hlIGtleSB0byBjb29yZGluYXRlc1xuXHRfa2V5VG9UaWxlQ29vcmRzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIGsgPSBrZXkuc3BsaXQoJzonKSxcblx0XHQgICAgY29vcmRzID0gbmV3IFBvaW50KCtrWzBdLCAra1sxXSk7XG5cdFx0Y29vcmRzLnogPSAra1syXTtcblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9LFxuXG5cdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuXHRcdHJlbW92ZSh0aWxlLmVsKTtcblxuXHRcdGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0Ly8gQGV2ZW50IHRpbGV1bmxvYWQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlbW92ZWQgKGUuZy4gd2hlbiBhIHRpbGUgZ29lcyBvZmYgdGhlIHNjcmVlbikuXG5cdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge1xuXHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdGNvb3JkczogdGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSlcblx0XHR9KTtcblx0fSxcblxuXHRfaW5pdFRpbGU6IGZ1bmN0aW9uICh0aWxlKSB7XG5cdFx0YWRkQ2xhc3ModGlsZSwgJ2xlYWZsZXQtdGlsZScpO1xuXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHRpbGUuc3R5bGUud2lkdGggPSB0aWxlU2l6ZS54ICsgJ3B4Jztcblx0XHR0aWxlLnN0eWxlLmhlaWdodCA9IHRpbGVTaXplLnkgKyAncHgnO1xuXG5cdFx0dGlsZS5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcblx0XHR0aWxlLm9ubW91c2Vtb3ZlID0gZmFsc2VGbjtcblxuXHRcdC8vIHVwZGF0ZSBvcGFjaXR5IG9uIHRpbGVzIGluIElFNy04IGJlY2F1c2Ugb2YgZmlsdGVyIGluaGVyaXRhbmNlIHByb2JsZW1zXG5cdFx0aWYgKGllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0c2V0T3BhY2l0eSh0aWxlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cdFx0fVxuXG5cdFx0Ly8gd2l0aG91dCB0aGlzIGhhY2ssIHRpbGVzIGRpc2FwcGVhciBhZnRlciB6b29tIG9uIENocm9tZSBmb3IgQW5kcm9pZFxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzIwNzhcblx0XHRpZiAoYW5kcm9pZCAmJiAhYW5kcm9pZDIzKSB7XG5cdFx0XHR0aWxlLnN0eWxlLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgY29udGFpbmVyKSB7XG5cdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKGNvb3JkcyksXG5cdFx0ICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpLCBiaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzKSk7XG5cblx0XHR0aGlzLl9pbml0VGlsZSh0aWxlKTtcblxuXHRcdC8vIGlmIGNyZWF0ZVRpbGUgaXMgZGVmaW5lZCB3aXRoIGEgc2Vjb25kIGFyZ3VtZW50IChcImRvbmVcIiBjYWxsYmFjayksXG5cdFx0Ly8gd2Uga25vdyB0aGF0IHRpbGUgaXMgYXN5bmMgYW5kIHdpbGwgYmUgcmVhZHkgbGF0ZXI7IG90aGVyd2lzZVxuXHRcdGlmICh0aGlzLmNyZWF0ZVRpbGUubGVuZ3RoIDwgMikge1xuXHRcdFx0Ly8gbWFyayB0aWxlIGFzIHJlYWR5LCBidXQgZGVsYXkgb25lIGZyYW1lIGZvciBvcGFjaXR5IGFuaW1hdGlvbiB0byBoYXBwZW5cblx0XHRcdHJlcXVlc3RBbmltRnJhbWUoYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcywgbnVsbCwgdGlsZSkpO1xuXHRcdH1cblxuXHRcdHNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MpO1xuXG5cdFx0Ly8gc2F2ZSB0aWxlIGluIGNhY2hlXG5cdFx0dGhpcy5fdGlsZXNba2V5XSA9IHtcblx0XHRcdGVsOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHMsXG5cdFx0XHRjdXJyZW50OiB0cnVlXG5cdFx0fTtcblxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWxlKTtcblx0XHQvLyBAZXZlbnQgdGlsZWxvYWRzdGFydDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVxdWVzdGVkIGFuZCBzdGFydHMgbG9hZGluZy5cblx0XHR0aGlzLmZpcmUoJ3RpbGVsb2Fkc3RhcnQnLCB7XG5cdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHR9KTtcblx0fSxcblxuXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcblx0XHRpZiAoZXJyKSB7XG5cdFx0XHQvLyBAZXZlbnQgdGlsZWVycm9yOiBUaWxlRXJyb3JFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBsb2FkaW5nIGEgdGlsZS5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWVycm9yJywge1xuXHRcdFx0XHRlcnJvcjogZXJyLFxuXHRcdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG5cdFx0dGlsZS5sb2FkZWQgPSArbmV3IERhdGUoKTtcblx0XHRpZiAodGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdHNldE9wYWNpdHkodGlsZS5lbCwgMCk7XG5cdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHR9XG5cblx0XHRpZiAoIWVycikge1xuXHRcdFx0YWRkQ2xhc3ModGlsZS5lbCwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcblxuXHRcdFx0Ly8gQGV2ZW50IHRpbGVsb2FkOiBUaWxlRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGxvYWRzLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcblx0XHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ub1RpbGVzVG9Mb2FkKCkpIHtcblx0XHRcdHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcblx0XHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBsb2FkZWQgYWxsIHZpc2libGUgdGlsZXMuXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcblxuXHRcdFx0aWYgKGllbHQ5IHx8ICF0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2FpdCBhIGJpdCBtb3JlIHRoYW4gMC4yIHNlY3MgKHRoZSBkdXJhdGlvbiBvZiB0aGUgdGlsZSBmYWRlLWluKVxuXHRcdFx0XHQvLyB0byB0cmlnZ2VyIGEgcHJ1bmluZy5cblx0XHRcdFx0c2V0VGltZW91dChiaW5kKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpLCAyNTApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZ2V0VGlsZVBvczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMuc2NhbGVCeSh0aGlzLmdldFRpbGVTaXplKCkpLnN1YnRyYWN0KHRoaXMuX2xldmVsLm9yaWdpbik7XG5cdH0sXG5cblx0X3dyYXBDb29yZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgbmV3Q29vcmRzID0gbmV3IFBvaW50KFxuXHRcdFx0dGhpcy5fd3JhcFggPyB3cmFwTnVtKGNvb3Jkcy54LCB0aGlzLl93cmFwWCkgOiBjb29yZHMueCxcblx0XHRcdHRoaXMuX3dyYXBZID8gd3JhcE51bShjb29yZHMueSwgdGhpcy5fd3JhcFkpIDogY29vcmRzLnkpO1xuXHRcdG5ld0Nvb3Jkcy56ID0gY29vcmRzLno7XG5cdFx0cmV0dXJuIG5ld0Nvb3Jkcztcblx0fSxcblxuXHRfcHhCb3VuZHNUb1RpbGVSYW5nZTogZnVuY3Rpb24gKGJvdW5kcykge1xuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4udW5zY2FsZUJ5KHRpbGVTaXplKS5mbG9vcigpLFxuXHRcdFx0Ym91bmRzLm1heC51bnNjYWxlQnkodGlsZVNpemUpLmNlaWwoKS5zdWJ0cmFjdChbMSwgMV0pKTtcblx0fSxcblxuXHRfbm9UaWxlc1RvTG9hZDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLmxvYWRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmdyaWRMYXllcihvcHRpb25zPzogR3JpZExheWVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEdyaWRMYXllciB3aXRoIHRoZSBzdXBwbGllZCBvcHRpb25zLlxuZnVuY3Rpb24gZ3JpZExheWVyKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBHcmlkTGF5ZXIob3B0aW9ucyk7XG59XG5cbi8qXHJcbiAqIEBjbGFzcyBUaWxlTGF5ZXJcclxuICogQGluaGVyaXRzIEdyaWRMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBOb3RlIHRoYXQgbW9zdCB0aWxlIHNlcnZlcnMgcmVxdWlyZSBhdHRyaWJ1dGlvbiwgd2hpY2ggeW91IGNhbiBzZXQgdW5kZXIgYExheWVyYC4gRXh0ZW5kcyBgR3JpZExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC50aWxlTGF5ZXIoJ2h0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nP3tmb299Jywge2ZvbzogJ2JhcicsIGF0dHJpYnV0aW9uOiAnTWFwIGRhdGEgJmNvcHk7IDxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9cIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMsIDxhIGhyZWY9XCJodHRwczovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktc2EvMi4wL1wiPkNDLUJZLVNBPC9hPid9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogQHNlY3Rpb24gVVJMIHRlbXBsYXRlXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIEEgc3RyaW5nIG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcclxuICpcclxuICogYGBgXHJcbiAqICdodHRwOi8ve3N9LnNvbWVkb21haW4uY29tL2JsYWJsYS97en0ve3h9L3t5fXtyfS5wbmcnXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBge3N9YCBtZWFucyBvbmUgb2YgdGhlIGF2YWlsYWJsZSBzdWJkb21haW5zICh1c2VkIHNlcXVlbnRpYWxseSB0byBoZWxwIHdpdGggYnJvd3NlciBwYXJhbGxlbCByZXF1ZXN0cyBwZXIgZG9tYWluIGxpbWl0YXRpb247IHN1YmRvbWFpbiB2YWx1ZXMgYXJlIHNwZWNpZmllZCBpbiBvcHRpb25zOyBgYWAsIGBiYCBvciBgY2AgYnkgZGVmYXVsdCwgY2FuIGJlIG9taXR0ZWQpLCBge3p9YCDigJQgem9vbSBsZXZlbCwgYHt4fWAgYW5kIGB7eX1gIOKAlCB0aWxlIGNvb3JkaW5hdGVzLiBge3J9YCBjYW4gYmUgdXNlZCB0byBhZGQgXCImY29tbWF0OzJ4XCIgdG8gdGhlIFVSTCB0byBsb2FkIHJldGluYSB0aWxlcy5cclxuICpcclxuICogWW91IGNhbiB1c2UgY3VzdG9tIGtleXMgaW4gdGhlIHRlbXBsYXRlLCB3aGljaCB3aWxsIGJlIFtldmFsdWF0ZWRdKCN1dGlsLXRlbXBsYXRlKSBmcm9tIFRpbGVMYXllciBvcHRpb25zLCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBMLnRpbGVMYXllcignaHR0cDovL3tzfS5zb21lZG9tYWluLmNvbS97Zm9vfS97en0ve3h9L3t5fS5wbmcnLCB7Zm9vOiAnYmFyJ30pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxudmFyIFRpbGVMYXllciA9IEdyaWRMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcclxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWluWm9vbTogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IDE4XHJcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcblx0XHRtYXhab29tOiAxOCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN1YmRvbWFpbnM6IFN0cmluZ3xTdHJpbmdbXSA9ICdhYmMnXHJcblx0XHQvLyBTdWJkb21haW5zIG9mIHRoZSB0aWxlIHNlcnZpY2UuIENhbiBiZSBwYXNzZWQgaW4gdGhlIGZvcm0gb2Ygb25lIHN0cmluZyAod2hlcmUgZWFjaCBsZXR0ZXIgaXMgYSBzdWJkb21haW4gbmFtZSkgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuXHRcdHN1YmRvbWFpbnM6ICdhYmMnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZXJyb3JUaWxlVXJsOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVVJMIHRvIHRoZSB0aWxlIGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIHRpbGUgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuXHRcdGVycm9yVGlsZVVybDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSBvZmZzZXQgd2l0aCB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbU9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRtczogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIGludmVyc2VzIFkgYXhpcyBudW1iZXJpbmcgZm9yIHRpbGVzICh0dXJuIHRoaXMgb24gZm9yIFtUTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS5cclxuXHRcdHRtczogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tUmV2ZXJzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgcmV2ZXJzZWQgKGBtYXhab29tIC0gem9vbWAgaW5zdGVhZCBvZiBgem9vbWApXHJcblx0XHR6b29tUmV2ZXJzZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBkZXRlY3RSZXRpbmE6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgIGFuZCB1c2VyIGlzIG9uIGEgcmV0aW5hIGRpc3BsYXksIGl0IHdpbGwgcmVxdWVzdCBmb3VyIHRpbGVzIG9mIGhhbGYgdGhlIHNwZWNpZmllZCBzaXplIGFuZCBhIGJpZ2dlciB6b29tIGxldmVsIGluIHBsYWNlIG9mIG9uZSB0byB1dGlsaXplIHRoZSBoaWdoIHJlc29sdXRpb24uXHJcblx0XHRkZXRlY3RSZXRpbmE6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIGRldGVjdGluZyByZXRpbmEgZGlzcGxheXMsIGFkanVzdGluZyB0aWxlU2l6ZSBhbmQgem9vbSBsZXZlbHNcclxuXHRcdGlmIChvcHRpb25zLmRldGVjdFJldGluYSAmJiByZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cclxuXHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0Kys7XHJcblx0XHRcdFx0b3B0aW9ucy5tYXhab29tLS07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0LS07XHJcblx0XHRcdFx0b3B0aW9ucy5taW5ab29tKys7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluWm9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG9wdGlvbnMuc3ViZG9tYWlucyA9IG9wdGlvbnMuc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xyXG5cdFx0aWYgKCFhbmRyb2lkKSB7XHJcblx0XHRcdHRoaXMub24oJ3RpbGV1bmxvYWQnLCB0aGlzLl9vblRpbGVSZW1vdmUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nLCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gVXBkYXRlcyB0aGUgbGF5ZXIncyBVUkwgdGVtcGxhdGUgYW5kIHJlZHJhd3MgaXQgKHVubGVzcyBgbm9SZWRyYXdgIGlzIHNldCB0byBgdHJ1ZWApLlxyXG5cdC8vIElmIHRoZSBVUkwgZG9lcyBub3QgY2hhbmdlLCB0aGUgbGF5ZXIgd2lsbCBub3QgYmUgcmVkcmF3biB1bmxlc3NcclxuXHQvLyB0aGUgbm9SZWRyYXcgcGFyYW1ldGVyIGlzIHNldCB0byBmYWxzZS5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwsIG5vUmVkcmF3KSB7XHJcblx0XHRpZiAodGhpcy5fdXJsID09PSB1cmwgJiYgbm9SZWRyYXcgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRub1JlZHJhdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBvdmVycmlkZXMgR3JpZExheWVyJ3MgW2BjcmVhdGVUaWxlKClgXSgjZ3JpZGxheWVyLWNyZWF0ZXRpbGUpXHJcblx0Ly8gdG8gcmV0dXJuIGFuIGA8aW1nPmAgSFRNTCBlbGVtZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIGltYWdlIFVSTCBnaXZlbiBgY29vcmRzYC4gVGhlIGBkb25lYFxyXG5cdC8vIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBiZWVuIGxvYWRlZC5cclxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBkb25lKSB7XHJcblx0XHR2YXIgdGlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cclxuXHRcdG9uKHRpbGUsICdsb2FkJywgYmluZCh0aGlzLl90aWxlT25Mb2FkLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblx0XHRvbih0aWxlLCAnZXJyb3InLCBiaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdHRpbGUuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuXHRcdH1cclxuXHJcblx0XHQvKlxyXG5cdFx0IEFsdCB0YWcgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyB0byBrZWVwIHNjcmVlbiByZWFkZXJzIGZyb20gcmVhZGluZyBVUkwgYW5kIGZvciBjb21wbGlhbmNlIHJlYXNvbnNcclxuXHRcdCBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAtVEVDSFMvSDY3XHJcblx0XHQqL1xyXG5cdFx0dGlsZS5hbHQgPSAnJztcclxuXHJcblx0XHQvKlxyXG5cdFx0IFNldCByb2xlPVwicHJlc2VudGF0aW9uXCIgdG8gZm9yY2Ugc2NyZWVuIHJlYWRlcnMgdG8gaWdub3JlIHRoaXNcclxuXHRcdCBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEvcm9sZXMjdGV4dGFsdGVybmF0aXZlY29tcHV0YXRpb25cclxuXHRcdCovXHJcblx0XHR0aWxlLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcclxuXHJcblx0XHR0aWxlLnNyYyA9IHRoaXMuZ2V0VGlsZVVybChjb29yZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aWxlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcblx0Ly8gQHVuaW5oZXJpdGFibGVcclxuXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIG1pZ2h0IHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxyXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVVybChjb29yZHM6IE9iamVjdCk6IFN0cmluZ1xyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIHJldHVybnMgdGhlIFVSTCBmb3IgYSB0aWxlIGdpdmVuIGl0cyBjb29yZGluYXRlcy5cclxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBjYW4gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBwcm92aWRlIGN1c3RvbSB0aWxlIFVSTCBuYW1pbmcgc2NoZW1lcy5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0cjogcmV0aW5hID8gJ0AyeCcgOiAnJyxcclxuXHRcdFx0czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXHJcblx0XHRcdHg6IGNvb3Jkcy54LFxyXG5cdFx0XHR5OiBjb29yZHMueSxcclxuXHRcdFx0ejogdGhpcy5fZ2V0Wm9vbUZvclVybCgpXHJcblx0XHR9O1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLm9wdGlvbnMuY3JzLmluZmluaXRlKSB7XHJcblx0XHRcdHZhciBpbnZlcnRlZFkgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2UubWF4LnkgLSBjb29yZHMueTtcclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy50bXMpIHtcclxuXHRcdFx0XHRkYXRhWyd5J10gPSBpbnZlcnRlZFk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0YVsnLXknXSA9IGludmVydGVkWTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGVtcGxhdGUodGhpcy5fdXJsLCBleHRlbmQoZGF0YSwgdGhpcy5vcHRpb25zKSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkxvYWQ6IGZ1bmN0aW9uIChkb25lLCB0aWxlKSB7XHJcblx0XHQvLyBGb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzMzMlxyXG5cdFx0aWYgKGllbHQ5KSB7XHJcblx0XHRcdHNldFRpbWVvdXQoYmluZChkb25lLCB0aGlzLCBudWxsLCB0aWxlKSwgMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkb25lKG51bGwsIHRpbGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF90aWxlT25FcnJvcjogZnVuY3Rpb24gKGRvbmUsIHRpbGUsIGUpIHtcclxuXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7XHJcblx0XHRpZiAoZXJyb3JVcmwgJiYgdGlsZS5nZXRBdHRyaWJ1dGUoJ3NyYycpICE9PSBlcnJvclVybCkge1xyXG5cdFx0XHR0aWxlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdFx0ZG9uZShlLCB0aWxlKTtcclxuXHR9LFxyXG5cclxuXHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0ZS50aWxlLm9ubG9hZCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21Gb3JVcmw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXHJcblx0XHRtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb20sXHJcblx0XHR6b29tUmV2ZXJzZSA9IHRoaXMub3B0aW9ucy56b29tUmV2ZXJzZSxcclxuXHRcdHpvb21PZmZzZXQgPSB0aGlzLm9wdGlvbnMuem9vbU9mZnNldDtcclxuXHJcblx0XHRpZiAoem9vbVJldmVyc2UpIHtcclxuXHRcdFx0em9vbSA9IG1heFpvb20gLSB6b29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB6b29tICsgem9vbU9mZnNldDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0U3ViZG9tYWluOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHR2YXIgaW5kZXggPSBNYXRoLmFicyh0aWxlUG9pbnQueCArIHRpbGVQb2ludC55KSAlIHRoaXMub3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aDtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcblx0fSxcclxuXHJcblx0Ly8gc3RvcHMgbG9hZGluZyBhbGwgdGlsZXMgaW4gdGhlIGJhY2tncm91bmQgbGF5ZXJcclxuXHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSwgdGlsZTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl90aWxlcykge1xyXG5cdFx0XHRpZiAodGhpcy5fdGlsZXNbaV0uY29vcmRzLnogIT09IHRoaXMuX3RpbGVab29tKSB7XHJcblx0XHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2ldLmVsO1xyXG5cclxuXHRcdFx0XHR0aWxlLm9ubG9hZCA9IGZhbHNlRm47XHJcblx0XHRcdFx0dGlsZS5vbmVycm9yID0gZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0aWYgKCF0aWxlLmNvbXBsZXRlKSB7XHJcblx0XHRcdFx0XHR0aWxlLnNyYyA9IGVtcHR5SW1hZ2VVcmw7XHJcblx0XHRcdFx0XHRyZW1vdmUodGlsZSk7XHJcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fdGlsZXNbaV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcclxuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXHJcblx0XHQvLyB1bmxlc3Mgd2UncmUgb24gQW5kcm9pZCdzIHN0b2NrIGJyb3dzZXIsXHJcblx0XHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTM3XHJcblx0XHRpZiAoIWFuZHJvaWRTdG9jaykge1xyXG5cdFx0XHR0aWxlLmVsLnNldEF0dHJpYnV0ZSgnc3JjJywgZW1wdHlJbWFnZVVybCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEdyaWRMYXllci5wcm90b3R5cGUuX3JlbW92ZVRpbGUuY2FsbCh0aGlzLCBrZXkpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgdGlsZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgKHRpbGUgJiYgdGlsZS5nZXRBdHRyaWJ1dGUoJ3NyYycpID09PSBlbXB0eUltYWdlVXJsKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEdyaWRMYXllci5wcm90b3R5cGUuX3RpbGVSZWFkeS5jYWxsKHRoaXMsIGNvb3JkcywgZXJyLCB0aWxlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZWxheWVyKHVybFRlbXBsYXRlOiBTdHJpbmcsIG9wdGlvbnM/OiBUaWxlTGF5ZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBgVVJMIHRlbXBsYXRlYCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuXHJcbmZ1bmN0aW9uIHRpbGVMYXllcih1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFRpbGVMYXllcih1cmwsIG9wdGlvbnMpO1xyXG59XG5cbi8qXHJcbiAqIEBjbGFzcyBUaWxlTGF5ZXIuV01TXHJcbiAqIEBpbmhlcml0cyBUaWxlTGF5ZXJcclxuICogQGFrYSBMLlRpbGVMYXllci5XTVNcclxuICogVXNlZCB0byBkaXNwbGF5IFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMgYXMgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgVGlsZUxheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIG5leHJhZCA9IEwudGlsZUxheWVyLndtcyhcImh0dHA6Ly9tZXNvbmV0LmFncm9uLmlhc3RhdGUuZWR1L2NnaS1iaW4vd21zL25leHJhZC9uMHIuY2dpXCIsIHtcclxuICogXHRsYXllcnM6ICduZXhyYWQtbjByLTkwMDkxMycsXHJcbiAqIFx0Zm9ybWF0OiAnaW1hZ2UvcG5nJyxcclxuICogXHR0cmFuc3BhcmVudDogdHJ1ZSxcclxuICogXHRhdHRyaWJ1dGlvbjogXCJXZWF0aGVyIGRhdGEgwqkgMjAxMiBJRU0gTmV4cmFkXCJcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBUaWxlTGF5ZXJXTVMgPSBUaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllci5XTVMgb3B0aW9uc1xyXG5cdC8vIElmIGFueSBjdXN0b20gb3B0aW9ucyBub3QgZG9jdW1lbnRlZCBoZXJlIGFyZSB1c2VkLCB0aGV5IHdpbGwgYmUgc2VudCB0byB0aGVcclxuXHQvLyBXTVMgc2VydmVyIGFzIGV4dHJhIHBhcmFtZXRlcnMgaW4gZWFjaCByZXF1ZXN0IFVSTC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxyXG5cdC8vIFtub24tc3RhbmRhcmQgdmVuZG9yIFdNUyBwYXJhbWV0ZXJzXShodHRwOi8vZG9jcy5nZW9zZXJ2ZXIub3JnL3N0YWJsZS9lbi91c2VyL3NlcnZpY2VzL3dtcy92ZW5kb3IuaHRtbCkuXHJcblx0ZGVmYXVsdFdtc1BhcmFtczoge1xyXG5cdFx0c2VydmljZTogJ1dNUycsXHJcblx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogU3RyaW5nID0gJydcclxuXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuXHRcdGxheWVyczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdHlsZXM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG5cdFx0c3R5bGVzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZvcm1hdDogU3RyaW5nID0gJ2ltYWdlL2pwZWcnXHJcblx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuXHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNwYXJlbnQ6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG5cdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdmVyc2lvbjogU3RyaW5nID0gJzEuMS4xJ1xyXG5cdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcblx0XHR2ZXJzaW9uOiAnMS4xLjEnXHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IG51bGxcclxuXHRcdC8vIENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbSB0byB1c2UgZm9yIHRoZSBXTVMgcmVxdWVzdHMsIGRlZmF1bHRzIHRvXHJcblx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHVwcGVyY2FzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG5cdFx0dXBwZXJjYXNlOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHdtc1BhcmFtcyA9IGV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtcclxuXHJcblx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdGlmICghKGkgaW4gdGhpcy5vcHRpb25zKSkge1xyXG5cdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgcmVhbFJldGluYSA9IG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIHJldGluYSA/IDIgOiAxO1xyXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xyXG5cdFx0d21zUGFyYW1zLndpZHRoID0gdGlsZVNpemUueCAqIHJlYWxSZXRpbmE7XHJcblx0XHR3bXNQYXJhbXMuaGVpZ2h0ID0gdGlsZVNpemUueSAqIHJlYWxSZXRpbmE7XHJcblxyXG5cdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHJcblx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuXHRcdHRoaXMuX3dtc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHRoaXMud21zUGFyYW1zLnZlcnNpb24pO1xyXG5cclxuXHRcdHZhciBwcm9qZWN0aW9uS2V5ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xyXG5cdFx0dGhpcy53bXNQYXJhbXNbcHJvamVjdGlvbktleV0gPSB0aGlzLl9jcnMuY29kZTtcclxuXHJcblx0XHRUaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblxyXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXHJcblx0XHQgICAgY3JzID0gdGhpcy5fY3JzLFxyXG5cdFx0ICAgIGJvdW5kcyA9IHRvQm91bmRzKGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMF0pLCBjcnMucHJvamVjdCh0aWxlQm91bmRzWzFdKSksXHJcblx0XHQgICAgbWluID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIGJib3ggPSAodGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBFUFNHNDMyNiA/XHJcblx0XHQgICAgW21pbi55LCBtaW4ueCwgbWF4LnksIG1heC54XSA6XHJcblx0XHQgICAgW21pbi54LCBtaW4ueSwgbWF4LngsIG1heC55XSkuam9pbignLCcpLFxyXG5cdFx0ICAgIHVybCA9IFRpbGVMYXllci5wcm90b3R5cGUuZ2V0VGlsZVVybC5jYWxsKHRoaXMsIGNvb3Jkcyk7XHJcblx0XHRyZXR1cm4gdXJsICtcclxuXHRcdFx0Z2V0UGFyYW1TdHJpbmcodGhpcy53bXNQYXJhbXMsIHVybCwgdGhpcy5vcHRpb25zLnVwcGVyY2FzZSkgK1xyXG5cdFx0XHQodGhpcy5vcHRpb25zLnVwcGVyY2FzZSA/ICcmQkJPWD0nIDogJyZiYm94PScpICsgYmJveDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBhcmFtcyhwYXJhbXM6IE9iamVjdCwgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIE1lcmdlcyBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IHBhcmFtZXRlcnMgYW5kIHJlLXJlcXVlc3RzIHRpbGVzIG9uIHRoZSBjdXJyZW50IHNjcmVlbiAodW5sZXNzIGBub1JlZHJhd2Agd2FzIHNldCB0byB0cnVlKS5cclxuXHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChwYXJhbXMsIG5vUmVkcmF3KSB7XHJcblxyXG5cdFx0ZXh0ZW5kKHRoaXMud21zUGFyYW1zLCBwYXJhbXMpO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZUxheWVyLndtcyhiYXNlVXJsOiBTdHJpbmcsIG9wdGlvbnM6IFRpbGVMYXllci5XTVMgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgV01TIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYmFzZSBVUkwgb2YgdGhlIFdNUyBzZXJ2aWNlIGFuZCBhIFdNUyBwYXJhbWV0ZXJzL29wdGlvbnMgb2JqZWN0LlxyXG5mdW5jdGlvbiB0aWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKTtcclxufVxuXG5UaWxlTGF5ZXIuV01TID0gVGlsZUxheWVyV01TO1xudGlsZUxheWVyLndtcyA9IHRpbGVMYXllcldNUztcblxuLypcbiAqIEBjbGFzcyBSZW5kZXJlclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuUmVuZGVyZXJcbiAqXG4gKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICogRE9NIGNvbnRhaW5lciBvZiB0aGUgcmVuZGVyZXIsIGl0cyBib3VuZHMsIGFuZCBpdHMgem9vbSBhbmltYXRpb24uXG4gKlxuICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICogaXRzZWxmIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkIHRvIHRoZSBtYXAuIEFsbCBwYXRocyB1c2UgYSByZW5kZXJlciwgd2hpY2ggY2FuXG4gKiBiZSBpbXBsaWNpdCAodGhlIG1hcCB3aWxsIGRlY2lkZSB0aGUgdHlwZSBvZiByZW5kZXJlciBhbmQgdXNlIGl0IGF1dG9tYXRpY2FsbHkpXG4gKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAqXG4gKiBEbyBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBgU1ZHYCBhbmQgYENhbnZhc2AgaW5zdGVhZC5cbiAqXG4gKiBAZXZlbnQgdXBkYXRlOiBFdmVudFxuICogRmlyZWQgd2hlbiB0aGUgcmVuZGVyZXIgdXBkYXRlcyBpdHMgYm91bmRzLCBjZW50ZXIgYW5kIHpvb20sIGZvciBleGFtcGxlIHdoZW5cbiAqIGl0cyBtYXAgaGFzIG1vdmVkXG4gKi9cblxudmFyIFJlbmRlcmVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFJlbmRlcmVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFkZGluZzogTnVtYmVyID0gMC4xXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGlwIGFyZWEgYXJvdW5kIHRoZSBtYXAgdmlldyAocmVsYXRpdmUgdG8gaXRzIHNpemUpXG5cdFx0Ly8gZS5nLiAwLjEgd291bGQgYmUgMTAlIG9mIG1hcCB2aWV3IGluIGVhY2ggZGlyZWN0aW9uXG5cdFx0cGFkZGluZzogMC4xLFxuXG5cdFx0Ly8gQG9wdGlvbiB0b2xlcmFuY2U6IE51bWJlciA9IDBcblx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgY2xpY2sgdG9sZXJhbmNlIHJvdW5kIGEgcGF0aC9vYmplY3Qgb24gdGhlIG1hcFxuXHRcdHRvbGVyYW5jZSA6IDBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0c3RhbXAodGhpcyk7XG5cdFx0dGhpcy5fbGF5ZXJzID0gdGhpcy5fbGF5ZXJzIHx8IHt9O1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdHRoaXMuX2luaXRDb250YWluZXIoKTsgLy8gZGVmaW5lZCBieSByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnNcblxuXHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMub2ZmKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdFx0dGhpcy5fZGVzdHJveUNvbnRhaW5lcigpO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0LFxuXHRcdFx0em9vbTogdGhpcy5fb25ab29tLFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fdXBkYXRlLFxuXHRcdFx0em9vbWVuZDogdGhpcy5fb25ab29tRW5kXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9vbkFuaW1ab29tO1xuXHRcdH1cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vbkFuaW1ab29tOiBmdW5jdGlvbiAoZXYpIHtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0oZXYuY2VudGVyLCBldi56b29tKTtcblx0fSxcblxuXHRfb25ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSk7XG5cdH0sXG5cblx0X3VwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgdGhpcy5fem9vbSksXG5cdFx0ICAgIHBvc2l0aW9uID0gZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSxcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkoMC41ICsgdGhpcy5vcHRpb25zLnBhZGRpbmcpLFxuXHRcdCAgICBjdXJyZW50Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9jZW50ZXIsIHpvb20pLFxuXHRcdCAgICBkZXN0Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdChjZW50ZXIsIHpvb20pLFxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBkZXN0Q2VudGVyUG9pbnQuc3VidHJhY3QoY3VycmVudENlbnRlclBvaW50KSxcblxuXHRcdCAgICB0b3BMZWZ0T2Zmc2V0ID0gdmlld0hhbGYubXVsdGlwbHlCeSgtc2NhbGUpLmFkZChwb3NpdGlvbikuYWRkKHZpZXdIYWxmKS5zdWJ0cmFjdChjZW50ZXJPZmZzZXQpO1xuXG5cdFx0aWYgKGFueTNkKSB7XG5cdFx0XHRzZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20pO1xuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9yZXNldCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9wcm9qZWN0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fdXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBVcGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcblx0XHQvLyBTdWJjbGFzc2VzIGFyZSByZXNwb25zaWJsZSBvZiBmaXJpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuXHRcdHZhciBwID0gdGhpcy5vcHRpb25zLnBhZGRpbmcsXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMobWluLCBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpKS5yb3VuZCgpKTtcblxuXHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcblx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0fVxufSk7XG5cbi8qXG4gKiBAY2xhc3MgQ2FudmFzXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5DYW52YXNcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9Y2FudmFzKSwgQ2FudmFzIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgSUU4LCBhbmQgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcyBtaWdodFxuICogbm90IGRpc3BsYXkgcHJvcGVybHkgaW4gc29tZSBlZGdlIGNhc2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIENhbnZhcyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLmNhbnZhcygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIENhbnZhcyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLmNhbnZhcyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxudmFyIENhbnZhcyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBSZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cdFx0ZXZlbnRzLnZpZXdwcmVyZXNldCA9IHRoaXMuX29uVmlld1ByZVJlc2V0O1xuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X29uVmlld1ByZVJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gU2V0IGEgZmxhZyBzbyB0aGF0IGEgdmlld3ByZXJlc2V0K21vdmVlbmQrdmlld3Jlc2V0IG9ubHkgdXBkYXRlcyZyZWRyYXdzIG9uY2Vcblx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gdHJ1ZTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMpO1xuXG5cdFx0Ly8gUmVkcmF3IHZlY3RvcnMgc2luY2UgY2FudmFzIGlzIGNsZWFyZWQgdXBvbiByZW1vdmFsLFxuXHRcdC8vIGluIGNhc2Ugb2YgcmVtb3ZpbmcgdGhlIHJlbmRlcmVyIGl0c2VsZiBmcm9tIHRoZSBtYXAuXG5cdFx0dGhpcy5fZHJhdygpO1xuXHR9LFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG5cdFx0b24oY29udGFpbmVyLCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuXHRcdG9uKGNvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIGNvbnRleHRtZW51JywgdGhpcy5fb25DbGljaywgdGhpcyk7XG5cdFx0b24oY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9oYW5kbGVNb3VzZU91dCwgdGhpcyk7XG5cblx0XHR0aGlzLl9jdHggPSBjb250YWluZXIuZ2V0Q29udGV4dCgnMmQnKTtcblx0fSxcblxuXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZWRyYXdSZXF1ZXN0KTtcblx0XHRkZWxldGUgdGhpcy5fY3R4O1xuXHRcdHJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdG9mZih0aGlzLl9jb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbGF5ZXI7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHR9XG5cdFx0dGhpcy5fcmVkcmF3KCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHQgICAgbSA9IHJldGluYSA/IDIgOiAxO1xuXG5cdFx0c2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cblx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG5cdFx0Y29udGFpbmVyLndpZHRoID0gbSAqIHNpemUueDtcblx0XHRjb250YWluZXIuaGVpZ2h0ID0gbSAqIHNpemUueTtcblx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuXHRcdGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXG5cdFx0aWYgKHJldGluYSkge1xuXHRcdFx0dGhpcy5fY3R4LnNjYWxlKDIsIDIpO1xuXHRcdH1cblxuXHRcdC8vIHRyYW5zbGF0ZSBzbyB3ZSB1c2UgdGhlIHNhbWUgcGF0aCBjb29yZGluYXRlcyBhZnRlciBjYW52YXMgZWxlbWVudCBtb3Zlc1xuXHRcdHRoaXMuX2N0eC50cmFuc2xhdGUoLWIubWluLngsIC1iLm1pbi55KTtcblxuXHRcdC8vIFRlbGwgcGF0aHMgdG8gcmVkcmF3IHRoZW1zZWx2ZXNcblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fcmVzZXQuY2FsbCh0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7XG5cdFx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gZmFsc2U7XG5cdFx0XHR0aGlzLl91cGRhdGVQYXRocygpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblxuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlciA9IHtcblx0XHRcdGxheWVyOiBsYXllcixcblx0XHRcdHByZXY6IHRoaXMuX2RyYXdMYXN0LFxuXHRcdFx0bmV4dDogbnVsbFxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX2RyYXdMYXN0KSB7IHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjsgfVxuXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0ID0gdGhpcy5fZHJhd0ZpcnN0IHx8IHRoaXMuX2RyYXdMYXN0O1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuXHRcdH1cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcblx0XHR9XG5cblx0XHRkZWxldGUgbGF5ZXIuX29yZGVyO1xuXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIFJlZHJhdyB0aGUgdW5pb24gb2YgdGhlIGxheWVyJ3Mgb2xkIHBpeGVsXG5cdFx0Ly8gYm91bmRzIGFuZCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdC8vIFRoZSByZWRyYXcgd2lsbCBleHRlbmQgdGhlIHJlZHJhdyBib3VuZHNcblx0XHQvLyB3aXRoIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlRGFzaEFycmF5OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAodHlwZW9mIGxheWVyLm9wdGlvbnMuZGFzaEFycmF5ID09PSAnc3RyaW5nJykge1xuXHRcdFx0dmFyIHBhcnRzID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoL1ssIF0rLyksXG5cdFx0XHQgICAgZGFzaEFycmF5ID0gW10sXG5cdFx0XHQgICAgZGFzaFZhbHVlLFxuXHRcdFx0ICAgIGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGFzaFZhbHVlID0gTnVtYmVyKHBhcnRzW2ldKTtcblx0XHRcdFx0Ly8gSWdub3JlIGRhc2ggYXJyYXkgY29udGFpbmluZyBpbnZhbGlkIGxlbmd0aHNcblx0XHRcdFx0aWYgKGlzTmFOKGRhc2hWYWx1ZSkpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdGRhc2hBcnJheS5wdXNoKGRhc2hWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5O1xuXHRcdH1cblx0fSxcblxuXHRfcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSB0aGlzLl9yZWRyYXdSZXF1ZXN0IHx8IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fcmVkcmF3LCB0aGlzKTtcblx0fSxcblxuXHRfZXh0ZW5kUmVkcmF3Qm91bmRzOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAobGF5ZXIuX3B4Qm91bmRzKSB7XG5cdFx0XHR2YXIgcGFkZGluZyA9IChsYXllci5vcHRpb25zLndlaWdodCB8fCAwKSArIDE7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHMgfHwgbmV3IEJvdW5kcygpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWluLnN1YnRyYWN0KFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWF4LmFkZChbcGFkZGluZywgcGFkZGluZ10pKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSBudWxsO1xuXG5cdFx0aWYgKHRoaXMuX3JlZHJhd0JvdW5kcykge1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1pbi5fZmxvb3IoKTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5tYXguX2NlaWwoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9jbGVhcigpOyAvLyBjbGVhciBsYXllcnMgaW4gcmVkcmF3IGJvdW5kc1xuXHRcdHRoaXMuX2RyYXcoKTsgLy8gZHJhdyBsYXllcnNcblxuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdH0sXG5cblx0X2NsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY29udGFpbmVyLndpZHRoLCB0aGlzLl9jb250YWluZXIuaGVpZ2h0KTtcblx0XHR9XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbGF5ZXIsIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcblx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcblx0XHRcdHRoaXMuX2N0eC5yZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG5cdFx0XHR0aGlzLl9jdHguY2xpcCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYXdpbmcgPSB0cnVlO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAoIWJvdW5kcyB8fCAobGF5ZXIuX3B4Qm91bmRzICYmIGxheWVyLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpKSB7XG5cdFx0XHRcdGxheWVyLl91cGRhdGVQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTsgIC8vIFJlc3RvcmUgc3RhdGUgYmVmb3JlIGNsaXBwaW5nLlxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXHRcdGlmICghdGhpcy5fZHJhd2luZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBpLCBqLCBsZW4yLCBwLFxuXHRcdCAgICBwYXJ0cyA9IGxheWVyLl9wYXJ0cyxcblx0XHQgICAgbGVuID0gcGFydHMubGVuZ3RoLFxuXHRcdCAgICBjdHggPSB0aGlzLl9jdHg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm47IH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnRzW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0XHRwID0gcGFydHNbaV1bal07XG5cdFx0XHRcdGN0eFtqID8gJ2xpbmVUbycgOiAnbW92ZVRvJ10ocC54LCBwLnkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblxuXHRcdC8vIFRPRE8gb3B0aW1pemF0aW9uOiAxIGZpbGwvc3Ryb2tlIGZvciBhbGwgZmVhdHVyZXMgd2l0aCBlcXVhbCBzdHlsZSBpbnN0ZWFkIG9mIDEgZm9yIGVhY2ggZmVhdHVyZVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nIHx8IGxheWVyLl9lbXB0eSgpKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eCxcblx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuXHRcdCAgICBzID0gKE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByKSAvIHI7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zY2FsZSgxLCBzKTtcblx0XHR9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyhwLngsIHAueSAvIHMsIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXHR9LFxuXG5cdF9maWxsU3Ryb2tlOiBmdW5jdGlvbiAoY3R4LCBsYXllcikge1xuXHRcdHZhciBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5maWxsKG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy53ZWlnaHQgIT09IDApIHtcblx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxheWVyLm9wdGlvbnMgJiYgbGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5IHx8IFtdKTtcblx0XHRcdH1cblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMub3BhY2l0eTtcblx0XHRcdGN0eC5saW5lV2lkdGggPSBvcHRpb25zLndlaWdodDtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRjdHgubGluZUNhcCA9IG9wdGlvbnMubGluZUNhcDtcblx0XHRcdGN0eC5saW5lSm9pbiA9IG9wdGlvbnMubGluZUpvaW47XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENhbnZhcyBvYnZpb3VzbHkgZG9lc24ndCBoYXZlIG1vdXNlIGV2ZW50cyBmb3IgaW5kaXZpZHVhbCBkcmF3biBvYmplY3RzLFxuXHQvLyBzbyB3ZSBlbXVsYXRlIHRoYXQgYnkgY2FsY3VsYXRpbmcgd2hhdCdzIHVuZGVyIHRoZSBtb3VzZSBvbiBtb3VzZW1vdmUvY2xpY2sgbWFudWFsbHlcblxuXHRfb25DbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSwgbGF5ZXIsIGNsaWNrZWRMYXllcjtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpICYmICF0aGlzLl9tYXAuX2RyYWdnYWJsZU1vdmVkKGxheWVyKSkge1xuXHRcdFx0XHRjbGlja2VkTGF5ZXIgPSBsYXllcjtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNsaWNrZWRMYXllcikgIHtcblx0XHRcdGZha2VTdG9wKGUpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtjbGlja2VkTGF5ZXJdLCBlKTtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZpbmcoKSB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKTtcblx0XHR0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKGUsIHBvaW50KTtcblx0fSxcblxuXG5cdF9oYW5kbGVNb3VzZU91dDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9ob3ZlcmVkTGF5ZXI7XG5cdFx0aWYgKGxheWVyKSB7XG5cdFx0XHQvLyBpZiB3ZSdyZSBsZWF2aW5nIHRoZSBsYXllciwgZmlyZSBtb3VzZW91dFxuXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtsYXllcl0sIGUsICdtb3VzZW91dCcpO1xuXHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gbnVsbDtcblx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZU1vdXNlSG92ZXI6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuXHRcdGlmICh0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGxheWVyLCBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuXHRcdFx0XHRjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIgPSBsYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyICE9PSB0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZU1vdXNlT3V0KGUpO1xuXG5cdFx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyKSB7XG5cdFx0XHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTsgLy8gY2hhbmdlIGN1cnNvclxuXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NhbmRpZGF0ZUhvdmVyZWRMYXllcl0sIGUsICdtb3VzZW92ZXInKTtcblx0XHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbdGhpcy5faG92ZXJlZExheWVyXSwgZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IHRydWU7XG5cdFx0c2V0VGltZW91dChMLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuXHRcdH0sIHRoaXMpLCAzMik7XG5cdH0sXG5cblx0X2ZpcmVFdmVudDogZnVuY3Rpb24gKGxheWVycywgZSwgdHlwZSkge1xuXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgbGFzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2UgaWYgKG5leHQpIHtcblx0XHRcdC8vIFVwZGF0ZSBmaXJzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcblx0XHR9XG5cblx0XHRvcmRlci5wcmV2ID0gdGhpcy5fZHJhd0xhc3Q7XG5cdFx0dGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyO1xuXG5cdFx0b3JkZXIubmV4dCA9IG51bGw7XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG5cdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQWxyZWFkeSBmaXJzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2UgaWYgKHByZXYpIHtcblx0XHRcdC8vIFVwZGF0ZSBsYXN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuXHRcdFx0Ly8gc2luZ2xlIGVudHJ5XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IG51bGw7XG5cblx0XHRvcmRlci5uZXh0ID0gdGhpcy5fZHJhd0ZpcnN0O1xuXHRcdHRoaXMuX2RyYXdGaXJzdC5wcmV2ID0gb3JkZXI7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIENhbnZhcyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZnVuY3Rpb24gY2FudmFzJDEob3B0aW9ucykge1xuXHRyZXR1cm4gY2FudmFzID8gbmV3IENhbnZhcyhvcHRpb25zKSA6IG51bGw7XG59XG5cbi8qXG4gKiBUaGFua3MgdG8gRG1pdHJ5IEJhcmFub3Zza3kgYW5kIGhpcyBSYXBoYWVsIGxpYnJhcnkgZm9yIGluc3BpcmF0aW9uIVxuICovXG5cblxudmFyIHZtbENyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0ZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQoJ2x2bWwnLCAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdFx0fTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzwnICsgbmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdH07XG5cdH1cbn0pKCk7XG5cblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqXG4gKlxuICogVk1MIHdhcyBkZXByZWNhdGVkIGluIDIwMTIsIHdoaWNoIG1lYW5zIFZNTCBmdW5jdGlvbmFsaXR5IGV4aXN0cyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICogd2l0aCBvbGQgdmVyc2lvbnMgb2YgSW50ZXJuZXQgRXhwbG9yZXIuXG4gKi9cblxuLy8gbWl4aW4gdG8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcbnZhciB2bWxNaXhpbiA9IHtcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC12bWwtY29udGFpbmVyJyk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXIgPSB2bWxDcmVhdGUoJ3NoYXBlJyk7XG5cblx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZSAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblxuXHRcdGNvbnRhaW5lci5jb29yZHNpemUgPSAnMSAxJztcblxuXHRcdGxheWVyLl9wYXRoID0gdm1sQ3JlYXRlKCdwYXRoJyk7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0cmVtb3ZlKGNvbnRhaW5lcik7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgc3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSxcblx0XHQgICAgZmlsbCA9IGxheWVyLl9maWxsLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucyxcblx0XHQgICAgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblxuXHRcdGNvbnRhaW5lci5zdHJva2VkID0gISFvcHRpb25zLnN0cm9rZTtcblx0XHRjb250YWluZXIuZmlsbGVkID0gISFvcHRpb25zLmZpbGw7XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdGlmICghc3Ryb2tlKSB7XG5cdFx0XHRcdHN0cm9rZSA9IGxheWVyLl9zdHJva2UgPSB2bWxDcmVhdGUoJ3N0cm9rZScpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHN0cm9rZSk7XG5cdFx0XHRzdHJva2Uud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgKyAncHgnO1xuXHRcdFx0c3Ryb2tlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdHN0cm9rZS5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IGlzQXJyYXkob3B0aW9ucy5kYXNoQXJyYXkpID9cblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LmpvaW4oJyAnKSA6XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5yZXBsYWNlKC8oICosICopL2csICcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gJyc7XG5cdFx0XHR9XG5cdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xuXHRcdFx0c3Ryb2tlLmpvaW5zdHlsZSA9IG9wdGlvbnMubGluZUpvaW47XG5cblx0XHR9IGVsc2UgaWYgKHN0cm9rZSkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKHN0cm9rZSk7XG5cdFx0XHRsYXllci5fc3Ryb2tlID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRpZiAoIWZpbGwpIHtcblx0XHRcdFx0ZmlsbCA9IGxheWVyLl9maWxsID0gdm1sQ3JlYXRlKCdmaWxsJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsbCk7XG5cdFx0XHRmaWxsLmNvbG9yID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGZpbGwub3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cblx0XHR9IGVsc2UgaWYgKGZpbGwpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChmaWxsKTtcblx0XHRcdGxheWVyLl9maWxsID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQucm91bmQoKSxcblx0XHQgICAgciA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksXG5cdFx0ICAgIHIyID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSB8fCByKTtcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdCdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgciArICcsJyArIHIyICsgJyAwLCcgKyAoNjU1MzUgKiAzNjApKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGgudiA9IHBhdGg7XG5cdH0sXG5cblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dG9Gcm9udChsYXllci5fY29udGFpbmVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRvQmFjayhsYXllci5fY29udGFpbmVyKTtcblx0fVxufTtcblxudmFyIGNyZWF0ZSQyID0gdm1sID8gdm1sQ3JlYXRlIDogc3ZnQ3JlYXRlO1xuXG4vKlxuICogQGNsYXNzIFNWR1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuU1ZHXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXN2ZyksIFNWRyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IEFuZHJvaWQgMi54IGFuZCAzLnguXG4gKlxuICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnRcbiAqIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpXG4gKiAoYSBub3cgZGVwcmVjYXRlZCB0ZWNobm9sb2d5KSwgYW5kIHRoZSBTVkcgcmVuZGVyZXIgd2lsbCBmYWxsIGJhY2sgdG8gVk1MIGluXG4gKiB0aGlzIGNhc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBVc2UgU1ZHIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAqIFx0cmVuZGVyZXI6IEwuc3ZnKClcbiAqIH0pO1xuICogYGBgXG4gKlxuICogVXNlIGEgU1ZHIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gKiB2YXIgbXlSZW5kZXJlciA9IEwuc3ZnKHsgcGFkZGluZzogMC41IH0pO1xuICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiBgYGBcbiAqL1xuXG52YXIgU1ZHID0gUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXHRcdGV2ZW50cy56b29tc3RhcnQgPSB0aGlzLl9vblpvb21TdGFydDtcblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDIoJ3N2ZycpO1xuXG5cdFx0Ly8gbWFrZXMgaXQgcG9zc2libGUgdG8gY2xpY2sgdGhyb3VnaCBzdmcgcm9vdDsgd2UnbGwgcmVzZXQgaXQgYmFjayBpbiBpbmRpdmlkdWFsIHBhdGhzXG5cdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuXG5cdFx0dGhpcy5fcm9vdEdyb3VwID0gY3JlYXRlJDIoJ2cnKTtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcblx0fSxcblxuXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdG9mZih0aGlzLl9jb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG5cdFx0ZGVsZXRlIHRoaXMuX3Jvb3RHcm91cDtcblx0XHRkZWxldGUgdGhpcy5fc3ZnU2l6ZTtcblx0fSxcblxuXHRfb25ab29tU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBEcmFnLXRoZW4tcGluY2ggaW50ZXJhY3Rpb25zIG1pZ2h0IG1lc3MgdXAgdGhlIGNlbnRlciBhbmQgem9vbS5cblx0XHQvLyBJbiB0aGlzIGNhc2UsIHRoZSBlYXNpZXN0IHdheSB0byBwcmV2ZW50IHRoaXMgaXMgcmUtZG8gdGhlIHJlbmRlcmVyXG5cdFx0Ly8gICBib3VuZHMgYW5kIHBhZGRpbmcgd2hlbiB0aGUgem9vbWluZyBzdGFydHMuXG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuXHRcdC8vIHNldCBzaXplIG9mIHN2Zy1jb250YWluZXIgaWYgY2hhbmdlZFxuXHRcdGlmICghdGhpcy5fc3ZnU2l6ZSB8fCAhdGhpcy5fc3ZnU2l6ZS5lcXVhbHMoc2l6ZSkpIHtcblx0XHRcdHRoaXMuX3N2Z1NpemUgPSBzaXplO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLngpO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS55KTtcblx0XHR9XG5cblx0XHQvLyBtb3ZlbWVudDogdXBkYXRlIGNvbnRhaW5lciB2aWV3Qm94IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgY29vcmRpbmF0ZXMgb2YgaW5kaXZpZHVhbCBsYXllcnNcblx0XHRzZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgW2IubWluLngsIGIubWluLnksIHNpemUueCwgc2l6ZS55XS5qb2luKCcgJykpO1xuXG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHQvLyBtZXRob2RzIGJlbG93IGFyZSBjYWxsZWQgYnkgdmVjdG9yIGxheWVycyBpbXBsZW1lbnRhdGlvbnNcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGggPSBjcmVhdGUkMigncGF0aCcpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9IG51bGxcblx0XHQvLyBDdXN0b20gY2xhc3MgbmFtZSBzZXQgb24gYW4gZWxlbWVudC4gT25seSBmb3IgU1ZHIHJlbmRlcmVyLlxuXHRcdGlmIChsYXllci5vcHRpb25zLmNsYXNzTmFtZSkge1xuXHRcdFx0YWRkQ2xhc3MocGF0aCwgbGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHRhZGRDbGFzcyhwYXRoLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIXRoaXMuX3Jvb3RHcm91cCkgeyB0aGlzLl9pbml0Q29udGFpbmVyKCk7IH1cblx0XHR0aGlzLl9yb290R3JvdXAuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0cmVtb3ZlKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGgsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKCFwYXRoKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCBvcHRpb25zLm9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIG9wdGlvbnMud2VpZ2h0KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIG9wdGlvbnMubGluZUNhcCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgb3B0aW9ucy5saW5lSm9pbik7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIG9wdGlvbnMuZGFzaEFycmF5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hPZmZzZXQpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jywgb3B0aW9ucy5kYXNoT2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIG9wdGlvbnMuZmlsbE9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsIG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBwb2ludHNUb1BhdGgobGF5ZXIuX3BhcnRzLCBjbG9zZWQpKTtcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuXHRcdCAgICByMiA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByLFxuXHRcdCAgICBhcmMgPSAnYScgKyByICsgJywnICsgcjIgKyAnIDAgMSwwICc7XG5cblx0XHQvLyBkcmF3aW5nIGEgY2lyY2xlIHdpdGggdHdvIGhhbGYtYXJjc1xuXHRcdHZhciBkID0gbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0J00nICsgKHAueCAtIHIpICsgJywnICsgcC55ICtcblx0XHRcdGFyYyArIChyICogMikgKyAnLDAgJyArXG5cdFx0XHRhcmMgKyAoLXIgKiAyKSArICcsMCAnO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgZCk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuXHR9LFxuXG5cdC8vIFNWRyBkb2VzIG5vdCBoYXZlIHRoZSBjb25jZXB0IG9mIHpJbmRleCBzbyB3ZSByZXNvcnQgdG8gY2hhbmdpbmcgdGhlIERPTSBvcmRlciBvZiBlbGVtZW50c1xuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0b0Zyb250KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRvQmFjayhsYXllci5fcGF0aCk7XG5cdH1cbn0pO1xuXG5pZiAodm1sKSB7XG5cdFNWRy5pbmNsdWRlKHZtbE1peGluKTtcbn1cblxuLy8gQG5hbWVzcGFjZSBTVkdcbi8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIFNWRyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZnVuY3Rpb24gc3ZnJDEob3B0aW9ucykge1xuXHRyZXR1cm4gc3ZnIHx8IHZtbCA/IG5ldyBTVkcob3B0aW9ucykgOiBudWxsO1xufVxuXG5NYXAuaW5jbHVkZSh7XG5cdC8vIEBuYW1lc3BhY2UgTWFwOyBAbWV0aG9kIGdldFJlbmRlcmVyKGxheWVyOiBQYXRoKTogUmVuZGVyZXJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlbmRlciB0aGUgZ2l2ZW5cblx0Ly8gYFBhdGhgLiBJdCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBgcmVuZGVyZXJgIG9wdGlvbnMgb2YgdGhlIG1hcCBhbmQgcGF0aHNcblx0Ly8gYXJlIHJlc3BlY3RlZCwgYW5kIHRoYXQgdGhlIHJlbmRlcmVycyBkbyBleGlzdCBvbiB0aGUgbWFwLlxuXHRnZXRSZW5kZXJlcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoOyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlclxuXHRcdC8vIFVzZSB0aGlzIHNwZWNpZmljIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgZm9yIHRoaXMgcGF0aC4gVGFrZXNcblx0XHQvLyBwcmVjZWRlbmNlIG92ZXIgdGhlIG1hcCdzIFtkZWZhdWx0IHJlbmRlcmVyXSgjbWFwLXJlbmRlcmVyKS5cblx0XHR2YXIgcmVuZGVyZXIgPSBsYXllci5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX2dldFBhbmVSZW5kZXJlcihsYXllci5vcHRpb25zLnBhbmUpIHx8IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9yZW5kZXJlcjtcblxuXHRcdGlmICghcmVuZGVyZXIpIHtcblx0XHRcdHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcigpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5oYXNMYXllcihyZW5kZXJlcikpIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIocmVuZGVyZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2dldFBhbmVSZW5kZXJlcjogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gJ292ZXJsYXlQYW5lJyB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdO1xuXHRcdGlmIChyZW5kZXJlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKHtwYW5lOiBuYW1lfSk7XG5cdFx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdID0gcmVuZGVyZXI7XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fSxcblxuXHRfY3JlYXRlUmVuZGVyZXI6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBvcHRpb24gcHJlZmVyQ2FudmFzOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIGBQYXRoYHMgc2hvdWxkIGJlIHJlbmRlcmVkIG9uIGEgYENhbnZhc2AgcmVuZGVyZXIuXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYWxsIGBQYXRoYHMgYXJlIHJlbmRlcmVkIGluIGEgYFNWR2AgcmVuZGVyZXIuXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMucHJlZmVyQ2FudmFzICYmIGNhbnZhcyQxKG9wdGlvbnMpKSB8fCBzdmckMShvcHRpb25zKTtcblx0fVxufSk7XG5cbi8qXG4gKiBMLlJlY3RhbmdsZSBleHRlbmRzIFBvbHlnb24gYW5kIGNyZWF0ZXMgYSByZWN0YW5nbGUgd2hlbiBwYXNzZWQgYSBMYXRMbmdCb3VuZHMgb2JqZWN0LlxuICovXG5cbi8qXG4gKiBAY2xhc3MgUmVjdGFuZ2xlXG4gKiBAYWthIEwuUmVjdGFuZ2xlXG4gKiBAaW5oZXJpdHMgUG9seWdvblxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcmVjdGFuZ2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5Z29uYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWZpbmUgcmVjdGFuZ2xlIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAqIHZhciBib3VuZHMgPSBbWzU0LjU1OTMyMiwgLTUuNzY3ODIyXSwgWzU2LjEyMTA2MDQsIC0zLjAyMTI0MF1dO1xuICpcbiAqIC8vIGNyZWF0ZSBhbiBvcmFuZ2UgcmVjdGFuZ2xlXG4gKiBMLnJlY3RhbmdsZShib3VuZHMsIHtjb2xvcjogXCIjZmY3ODAwXCIsIHdlaWdodDogMX0pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSByZWN0YW5nbGUgYm91bmRzXG4gKiBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gKiBgYGBcbiAqXG4gKi9cblxuXG52YXIgUmVjdGFuZ2xlID0gUG9seWdvbi5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdFx0UG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgcmVjdGFuZ2xlIHdpdGggdGhlIHBhc3NlZCBib3VuZHMuXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdHJldHVybiB0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xuXHR9LFxuXG5cdF9ib3VuZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRsYXRMbmdCb3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRMbmdCb3VuZHMpO1xuXHRcdHJldHVybiBbXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KClcblx0XHRdO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnJlY3RhbmdsZShsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5mdW5jdGlvbiByZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucyk7XG59XG5cblNWRy5jcmVhdGUgPSBjcmVhdGUkMjtcblNWRy5wb2ludHNUb1BhdGggPSBwb2ludHNUb1BhdGg7XG5cbkdlb0pTT04uZ2VvbWV0cnlUb0xheWVyID0gZ2VvbWV0cnlUb0xheWVyO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZyA9IGNvb3Jkc1RvTGF0TG5nO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZ3MgPSBjb29yZHNUb0xhdExuZ3M7XG5HZW9KU09OLmxhdExuZ1RvQ29vcmRzID0gbGF0TG5nVG9Db29yZHM7XG5HZW9KU09OLmxhdExuZ3NUb0Nvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcztcbkdlb0pTT04uZ2V0RmVhdHVyZSA9IGdldEZlYXR1cmU7XG5HZW9KU09OLmFzRmVhdHVyZSA9IGFzRmVhdHVyZTtcblxuLypcbiAqIEwuSGFuZGxlci5Cb3hab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gKiAoem9vbSB0byBhIHNlbGVjdGVkIGJvdW5kaW5nIGJveCksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gYm94Wm9vbTogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgdG8gYSByZWN0YW5ndWxhciBhcmVhIHNwZWNpZmllZCBieVxuXHQvLyBkcmFnZ2luZyB0aGUgbW91c2Ugd2hpbGUgcHJlc3NpbmcgdGhlIHNoaWZ0IGtleS5cblx0Ym94Wm9vbTogdHJ1ZVxufSk7XG5cbnZhciBCb3hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5fY29udGFpbmVyO1xuXHRcdHRoaXMuX3BhbmUgPSBtYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHRtYXAub24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3ksIHRoaXMpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b24odGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b2ZmKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdHJlbW92ZSh0aGlzLl9wYW5lKTtcblx0XHRkZWxldGUgdGhpcy5fcGFuZTtcblx0fSxcblxuXHRfcmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdF9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXNldFN0YXRlVGltZW91dCAhPT0gMCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0KTtcblx0XHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gQ2xlYXIgdGhlIGRlZmVycmVkIHJlc2V0U3RhdGUgaWYgaXQgaGFzbid0IGV4ZWN1dGVkIHlldCwgb3RoZXJ3aXNlIGl0XG5cdFx0Ly8gd2lsbCBpbnRlcnJ1cHQgdGhlIGludGVyYWN0aW9uIGFuZCBvcnBoYW4gYSBib3ggZWxlbWVudCBpbiB0aGUgY29udGFpbmVyLlxuXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuXG5cdFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHRkaXNhYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHR0aGlzLl9zdGFydFBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0b24oZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBzdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JveCA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC16b29tLWJveCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludCwgdGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXG5cdFx0c2V0UG9zaXRpb24odGhpcy5fYm94LCBib3VuZHMubWluKTtcblxuXHRcdHRoaXMuX2JveC5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xuXHRcdHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXHR9LFxuXG5cdF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbW92ZWQpIHtcblx0XHRcdHJlbW92ZSh0aGlzLl9ib3gpO1xuXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblx0XHR9XG5cblx0XHRlbmFibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0ZW5hYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHRvZmYoZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBzdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZmluaXNoKCk7XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7IHJldHVybjsgfVxuXHRcdC8vIFBvc3Rwb25lIHRvIG5leHQgSlMgdGljayBzbyBpbnRlcm5hbCBjbGljayBldmVudCBoYW5kbGluZ1xuXHRcdC8vIHN0aWxsIHNlZSBpdCBhcyBcIm1vdmVkXCIuXG5cdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IHNldFRpbWVvdXQoYmluZCh0aGlzLl9yZXNldFN0YXRlLCB0aGlzKSwgMCk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQpKTtcblxuXHRcdHRoaXMuX21hcFxuXHRcdFx0LmZpdEJvdW5kcyhib3VuZHMpXG5cdFx0XHQuZmlyZSgnYm94em9vbWVuZCcsIHtib3hab29tQm91bmRzOiBib3VuZHN9KTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHR0aGlzLl9maW5pc2goKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGJveFpvb206IEhhbmRsZXJcbi8vIEJveCAoc2hpZnQtZHJhZyB3aXRoIG1vdXNlKSB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnYm94Wm9vbScsIEJveFpvb20pO1xuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZG91YmxlQ2xpY2tab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcblx0Ly8gYCdjZW50ZXInYCwgZG91YmxlLWNsaWNrIHpvb20gd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlXG5cdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG59KTtcblxudmFyIERvdWJsZUNsaWNrWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub24oJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub2ZmKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9sZFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5vcHRpb25zLnpvb21EZWx0YSxcblx0XHQgICAgem9vbSA9IGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSA/IG9sZFpvb20gLSBkZWx0YSA6IG9sZFpvb20gKyBkZWx0YTtcblxuXHRcdGlmIChtYXAub3B0aW9ucy5kb3VibGVDbGlja1pvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQoZS5jb250YWluZXJQb2ludCwgem9vbSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vXG4vLyBNYXAgcHJvcGVydGllcyBpbmNsdWRlIGludGVyYWN0aW9uIGhhbmRsZXJzIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2xcbi8vIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2hcbi8vIGFzIGRyYWdnaW5nIG9yIHRvdWNoIHpvb20gKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEZvciBleGFtcGxlOlxuLy9cbi8vIGBgYGpzXG4vLyBtYXAuZG91YmxlQ2xpY2tab29tLmRpc2FibGUoKTtcbi8vIGBgYFxuLy9cbi8vIEBwcm9wZXJ0eSBkb3VibGVDbGlja1pvb206IEhhbmRsZXJcbi8vIERvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZG91YmxlQ2xpY2tab29tJywgRG91YmxlQ2xpY2tab29tKTtcblxuLypcbiAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRyYWdnaW5nOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgYmUgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuXHRkcmFnZ2luZzogdHJ1ZSxcblxuXHQvLyBAc2VjdGlvbiBQYW5uaW5nIEluZXJ0aWEgT3B0aW9uc1xuXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG5cdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcblx0Ly8gdGhlIG1hcCBidWlsZHMgbW9tZW50dW0gd2hpbGUgZHJhZ2dpbmcgYW5kIGNvbnRpbnVlcyBtb3ZpbmcgaW5cblx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQgdW5sZXNzIHJ1bm5pbmcgb24gb2xkIEFuZHJvaWQgZGV2aWNlcy5cblx0aW5lcnRpYTogIWFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFEZWNlbGVyYXRpb246IE51bWJlciA9IDMwMDBcblx0Ly8gVGhlIHJhdGUgd2l0aCB3aGljaCB0aGUgaW5lcnRpYWwgbW92ZW1lbnQgc2xvd3MgZG93biwgaW4gcGl4ZWxzL3NlY29uZMKyLlxuXHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFNYXhTcGVlZDogTnVtYmVyID0gSW5maW5pdHlcblx0Ly8gTWF4IHNwZWVkIG9mIHRoZSBpbmVydGlhbCBtb3ZlbWVudCwgaW4gcGl4ZWxzL3NlY29uZC5cblx0aW5lcnRpYU1heFNwZWVkOiBJbmZpbml0eSwgLy8gcHgvc1xuXG5cdC8vIEBvcHRpb24gZWFzZUxpbmVhcml0eTogTnVtYmVyID0gMC4yXG5cdGVhc2VMaW5lYXJpdHk6IDAuMixcblxuXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuXHQvLyBAb3B0aW9uIHdvcmxkQ29weUp1bXA6IEJvb2xlYW4gPSBmYWxzZVxuXHQvLyBXaXRoIHRoaXMgb3B0aW9uIGVuYWJsZWQsIHRoZSBtYXAgdHJhY2tzIHdoZW4geW91IHBhbiB0byBhbm90aGVyIFwiY29weVwiXG5cdC8vIG9mIHRoZSB3b3JsZCBhbmQgc2VhbWxlc3NseSBqdW1wcyB0byB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgYWxsIG92ZXJsYXlzXG5cdC8vIGxpa2UgbWFya2VycyBhbmQgdmVjdG9yIGxheWVycyBhcmUgc3RpbGwgdmlzaWJsZS5cblx0d29ybGRDb3B5SnVtcDogZmFsc2UsXG5cblx0Ly8gQG9wdGlvbiBtYXhCb3VuZHNWaXNjb3NpdHk6IE51bWJlciA9IDAuMFxuXHQvLyBJZiBgbWF4Qm91bmRzYCBpcyBzZXQsIHRoaXMgb3B0aW9uIHdpbGwgY29udHJvbCBob3cgc29saWQgdGhlIGJvdW5kc1xuXHQvLyBhcmUgd2hlbiBkcmFnZ2luZyB0aGUgbWFwIGFyb3VuZC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgYDAuMGAgYWxsb3dzIHRoZVxuXHQvLyB1c2VyIHRvIGRyYWcgb3V0c2lkZSB0aGUgYm91bmRzIGF0IG5vcm1hbCBzcGVlZCwgaGlnaGVyIHZhbHVlcyB3aWxsXG5cdC8vIHNsb3cgZG93biBtYXAgZHJhZ2dpbmcgb3V0c2lkZSBib3VuZHMsIGFuZCBgMS4wYCBtYWtlcyB0aGUgYm91bmRzIGZ1bGx5XG5cdC8vIHNvbGlkLCBwcmV2ZW50aW5nIHRoZSB1c2VyIGZyb20gZHJhZ2dpbmcgb3V0c2lkZSB0aGUgYm91bmRzLlxuXHRtYXhCb3VuZHNWaXNjb3NpdHk6IDAuMFxufSk7XG5cbnZhciBEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ0xpbWl0LCB0aGlzKTtcblx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ1dyYXAsIHRoaXMpO1xuXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXG5cdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0YWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWIgbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmVuYWJsZSgpO1xuXHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdHRoaXMuX3RpbWVzID0gW107XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYicpO1xuXHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRtb3Zpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRtYXAuX3N0b3AoKTtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzICYmIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gdG9Cb3VuZHMoXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSlcblx0XHRcdFx0XHQuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKTtcblxuXHRcdFx0dGhpcy5fdmlzY29zaXR5ID0gTWF0aC5taW4oMS4wLCBNYXRoLm1heCgwLjAsIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0bWFwXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG5cdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zIHx8IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnModGltZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWFwXG5cdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcblx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcblx0fSxcblxuXHRfcHJ1bmVQb3NpdGlvbnM6IGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0d2hpbGUgKHRoaXMuX3Bvc2l0aW9ucy5sZW5ndGggPiAxICYmIHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcblx0XHRcdHRoaXMuX3RpbWVzLnNoaWZ0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxuXHRcdCAgICBweFdvcmxkQ2VudGVyID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbMCwgMF0pO1xuXG5cdFx0dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0ID0gcHhXb3JsZENlbnRlci5zdWJ0cmFjdChweENlbnRlcikueDtcblx0XHR0aGlzLl93b3JsZFdpZHRoID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHMoKS5nZXRTaXplKCkueDtcblx0fSxcblxuXHRfdmlzY291c0xpbWl0OiBmdW5jdGlvbiAodmFsdWUsIHRocmVzaG9sZCkge1xuXHRcdHJldHVybiB2YWx1ZSAtICh2YWx1ZSAtIHRocmVzaG9sZCkgKiB0aGlzLl92aXNjb3NpdHk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ0xpbWl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl92aXNjb3NpdHkgfHwgIXRoaXMuX29mZnNldExpbWl0KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnN1YnRyYWN0KHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MpO1xuXG5cdFx0dmFyIGxpbWl0ID0gdGhpcy5fb2Zmc2V0TGltaXQ7XG5cdFx0aWYgKG9mZnNldC54IDwgbGltaXQubWluLngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1pbi54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA8IGxpbWl0Lm1pbi55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5taW4ueSk7IH1cblx0XHRpZiAob2Zmc2V0LnggPiBsaW1pdC5tYXgueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWF4LngpOyB9XG5cdFx0aWYgKG9mZnNldC55ID4gbGltaXQubWF4LnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1heC55KTsgfVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xuXHR9LFxuXG5cdF9vblByZURyYWdXcmFwOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVE9ETyByZWZhY3RvciB0byBiZSBhYmxlIHRvIGFkanVzdCBtYXAgcGFuZSBwb3NpdGlvbiBhZnRlciB6b29tXG5cdFx0dmFyIHdvcmxkV2lkdGggPSB0aGlzLl93b3JsZFdpZHRoLFxuXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcblx0XHQgICAgZHggPSB0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQsXG5cdFx0ICAgIHggPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54LFxuXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYMiA9ICh4ICsgaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCAtIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYID0gTWF0aC5hYnMobmV3WDEgKyBkeCkgPCBNYXRoLmFicyhuZXdYMiArIGR4KSA/IG5ld1gxIDogbmV3WDI7XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCA9IG5ld1g7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvcHRpb25zID0gbWFwLm9wdGlvbnMsXG5cblx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG5cdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuXHRcdGlmIChub0luZXJ0aWEpIHtcblx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnMoK25ldyBEYXRlKCkpO1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lIC0gdGhpcy5fdGltZXNbMF0pIC8gMTAwMCxcblx0XHRcdCAgICBlYXNlID0gb3B0aW9ucy5lYXNlTGluZWFyaXR5LFxuXG5cdFx0XHQgICAgc3BlZWRWZWN0b3IgPSBkaXJlY3Rpb24ubXVsdGlwbHlCeShlYXNlIC8gZHVyYXRpb24pLFxuXHRcdFx0ICAgIHNwZWVkID0gc3BlZWRWZWN0b3IuZGlzdGFuY2VUbyhbMCwgMF0pLFxuXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkID0gTWF0aC5taW4ob3B0aW9ucy5pbmVydGlhTWF4U3BlZWQsIHNwZWVkKSxcblx0XHRcdCAgICBsaW1pdGVkU3BlZWRWZWN0b3IgPSBzcGVlZFZlY3Rvci5tdWx0aXBseUJ5KGxpbWl0ZWRTcGVlZCAvIHNwZWVkKSxcblxuXHRcdFx0ICAgIGRlY2VsZXJhdGlvbkR1cmF0aW9uID0gbGltaXRlZFNwZWVkIC8gKG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAqIGVhc2UpLFxuXHRcdFx0ICAgIG9mZnNldCA9IGxpbWl0ZWRTcGVlZFZlY3Rvci5tdWx0aXBseUJ5KC1kZWNlbGVyYXRpb25EdXJhdGlvbiAvIDIpLnJvdW5kKCk7XG5cblx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG5cdFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQob2Zmc2V0LCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHRcdHJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcblx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG5cdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZSxcblx0XHRcdFx0XHRcdGFuaW1hdGU6IHRydWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuLy8gTWFwIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIERyYWcpO1xuXG4vKlxuICogTC5NYXAuS2V5Ym9hcmQgaXMgaGFuZGxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEtleWJvYXJkIE5hdmlnYXRpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIE1ha2VzIHRoZSBtYXAgZm9jdXNhYmxlIGFuZCBhbGxvd3MgdXNlcnMgdG8gbmF2aWdhdGUgdGhlIG1hcCB3aXRoIGtleWJvYXJkXG5cdC8vIGFycm93cyBhbmQgYCtgL2AtYCBrZXlzLlxuXHRrZXlib2FyZDogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIGtleWJvYXJkUGFuRGVsdGE6IE51bWJlciA9IDgwXG5cdC8vIEFtb3VudCBvZiBwaXhlbHMgdG8gcGFuIHdoZW4gcHJlc3NpbmcgYW4gYXJyb3cga2V5LlxuXHRrZXlib2FyZFBhbkRlbHRhOiA4MFxufSk7XG5cbnZhciBLZXlib2FyZCA9IEhhbmRsZXIuZXh0ZW5kKHtcblxuXHRrZXlDb2Rlczoge1xuXHRcdGxlZnQ6ICAgIFszN10sXG5cdFx0cmlnaHQ6ICAgWzM5XSxcblx0XHRkb3duOiAgICBbNDBdLFxuXHRcdHVwOiAgICAgIFszOF0sXG5cdFx0em9vbUluOiAgWzE4NywgMTA3LCA2MSwgMTcxXSxcblx0XHR6b29tT3V0OiBbMTg5LCAxMDksIDU0LCAxNzNdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblxuXHRcdHRoaXMuX3NldFBhbkRlbHRhKG1hcC5vcHRpb25zLmtleWJvYXJkUGFuRGVsdGEpO1xuXHRcdHRoaXMuX3NldFpvb21EZWx0YShtYXAub3B0aW9ucy56b29tRGVsdGEpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xuXG5cdFx0Ly8gbWFrZSB0aGUgY29udGFpbmVyIGZvY3VzYWJsZSBieSB0YWJiaW5nXG5cdFx0aWYgKGNvbnRhaW5lci50YWJJbmRleCA8PSAwKSB7XG5cdFx0XHRjb250YWluZXIudGFiSW5kZXggPSAnMCc7XG5cdFx0fVxuXG5cdFx0b24oY29udGFpbmVyLCB7XG5cdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5vbih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVtb3ZlSG9va3MoKTtcblxuXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub2ZmKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2ZvY3VzZWQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG5cdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdCAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCBkb2NFbC5zY3JvbGxUb3AsXG5cdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuXHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cblx0XHR3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcblx0fSxcblxuXHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuXHR9LFxuXG5cdF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2JsdXInKTtcblx0fSxcblxuXHRfc2V0UGFuRGVsdGE6IGZ1bmN0aW9uIChwYW5EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fcGFuS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmxlZnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMubGVmdFtpXV0gPSBbLTEgKiBwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnJpZ2h0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnJpZ2h0W2ldXSA9IFtwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmRvd24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuZG93bltpXV0gPSBbMCwgcGFuRGVsdGFdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy51cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy51cFtpXV0gPSBbMCwgLTEgKiBwYW5EZWx0YV07XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tRGVsdGE6IGZ1bmN0aW9uICh6b29tRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3pvb21LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21JbltpXV0gPSB6b29tRGVsdGE7XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbURlbHRhO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9yZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIga2V5ID0gZS5rZXlDb2RlLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9mZnNldDtcblxuXHRcdGlmIChrZXkgaW4gdGhpcy5fcGFuS2V5cykge1xuXHRcdFx0aWYgKCFtYXAuX3BhbkFuaW0gfHwgIW1hcC5fcGFuQW5pbS5faW5Qcm9ncmVzcykge1xuXHRcdFx0XHRvZmZzZXQgPSB0aGlzLl9wYW5LZXlzW2tleV07XG5cdFx0XHRcdGlmIChlLnNoaWZ0S2V5KSB7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLm11bHRpcGx5QnkoMyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0KTtcblxuXHRcdFx0XHRpZiAobWFwLm9wdGlvbnMubWF4Qm91bmRzKSB7XG5cdFx0XHRcdFx0bWFwLnBhbkluc2lkZUJvdW5kcyhtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChrZXkgaW4gdGhpcy5fem9vbUtleXMpIHtcblx0XHRcdG1hcC5zZXRab29tKG1hcC5nZXRab29tKCkgKyAoZS5zaGlmdEtleSA/IDMgOiAxKSAqIHRoaXMuX3pvb21LZXlzW2tleV0pO1xuXG5cdFx0fSBlbHNlIGlmIChrZXkgPT09IDI3ICYmIG1hcC5fcG9wdXAgJiYgbWFwLl9wb3B1cC5vcHRpb25zLmNsb3NlT25Fc2NhcGVLZXkpIHtcblx0XHRcdG1hcC5jbG9zZVBvcHVwKCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHN0b3AoZSk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBrZXlib2FyZDogSGFuZGxlclxuLy8gS2V5Ym9hcmQgbmF2aWdhdGlvbiBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2tleWJvYXJkJywgS2V5Ym9hcmQpO1xuXG4vKlxuICogTC5IYW5kbGVyLlNjcm9sbFdoZWVsWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGVuYWJsZSBtb3VzZSBzY3JvbGwgd2hlZWwgem9vbSBvbiB0aGUgbWFwLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gTW91c2V3aGVlbCBvcHRpb25zXG5cdC8vIEBvcHRpb24gc2Nyb2xsV2hlZWxab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdXNpbmcgdGhlIG1vdXNlIHdoZWVsLiBJZiBwYXNzZWQgYCdjZW50ZXInYCxcblx0Ly8gaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuXHRzY3JvbGxXaGVlbFpvb206IHRydWUsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbERlYm91bmNlVGltZTogTnVtYmVyID0gNDBcblx0Ly8gTGltaXRzIHRoZSByYXRlIGF0IHdoaWNoIGEgd2hlZWwgY2FuIGZpcmUgKGluIG1pbGxpc2Vjb25kcykuIEJ5IGRlZmF1bHRcblx0Ly8gdXNlciBjYW4ndCB6b29tIHZpYSB3aGVlbCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgNDAgbXMuXG5cdHdoZWVsRGVib3VuY2VUaW1lOiA0MCxcblxuXHQvLyBAb3B0aW9uIHdoZWVsUHhQZXJab29tTGV2ZWw6IE51bWJlciA9IDYwXG5cdC8vIEhvdyBtYW55IHNjcm9sbCBwaXhlbHMgKGFzIHJlcG9ydGVkIGJ5IFtMLkRvbUV2ZW50LmdldFdoZWVsRGVsdGFdKCNkb21ldmVudC1nZXR3aGVlbGRlbHRhKSlcblx0Ly8gbWVhbiBhIGNoYW5nZSBvZiBvbmUgZnVsbCB6b29tIGxldmVsLiBTbWFsbGVyIHZhbHVlcyB3aWxsIG1ha2Ugd2hlZWwtem9vbWluZ1xuXHQvLyBmYXN0ZXIgKGFuZCB2aWNlIHZlcnNhKS5cblx0d2hlZWxQeFBlclpvb21MZXZlbDogNjBcbn0pO1xuXG52YXIgU2Nyb2xsV2hlZWxab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXHR9LFxuXG5cdF9vbldoZWVsU2Nyb2xsOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBkZWx0YSA9IGdldFdoZWVsRGVsdGEoZSk7XG5cblx0XHR2YXIgZGVib3VuY2UgPSB0aGlzLl9tYXAub3B0aW9ucy53aGVlbERlYm91bmNlVGltZTtcblxuXHRcdHRoaXMuX2RlbHRhICs9IGRlbHRhO1xuXHRcdHRoaXMuX2xhc3RNb3VzZVBvcyA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdGlmICghdGhpcy5fc3RhcnRUaW1lKSB7XG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblx0XHR9XG5cblx0XHR2YXIgbGVmdCA9IE1hdGgubWF4KGRlYm91bmNlIC0gKCtuZXcgRGF0ZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSwgMCk7XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuXHRcdHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChiaW5kKHRoaXMuX3BlcmZvcm1ab29tLCB0aGlzKSwgbGVmdCk7XG5cblx0XHRzdG9wKGUpO1xuXHR9LFxuXG5cdF9wZXJmb3JtWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzbmFwID0gdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXAgfHwgMDtcblxuXHRcdG1hcC5fc3RvcCgpOyAvLyBzdG9wIHBhbm5pbmcgYW5kIGZseSBhbmltYXRpb25zIGlmIGFueVxuXG5cdFx0Ly8gbWFwIHRoZSBkZWx0YSB3aXRoIGEgc2lnbW9pZCBmdW5jdGlvbiB0byAtNC4uNCByYW5nZSBsZWFuaW5nIG9uIC0xLi4xXG5cdFx0dmFyIGQyID0gdGhpcy5fZGVsdGEgLyAodGhpcy5fbWFwLm9wdGlvbnMud2hlZWxQeFBlclpvb21MZXZlbCAqIDQpLFxuXHRcdCAgICBkMyA9IDQgKiBNYXRoLmxvZygyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZDIpKSkpIC8gTWF0aC5MTjIsXG5cdFx0ICAgIGQ0ID0gc25hcCA/IE1hdGguY2VpbChkMyAvIHNuYXApICogc25hcCA6IGQzLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5fbGltaXRab29tKHpvb20gKyAodGhpcy5fZGVsdGEgPiAwID8gZDQgOiAtZDQpKSAtIHpvb207XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuXHRcdGlmICghZGVsdGEpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQodGhpcy5fbGFzdE1vdXNlUG9zLCB6b29tICsgZGVsdGEpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgc2Nyb2xsV2hlZWxab29tOiBIYW5kbGVyXG4vLyBTY3JvbGwgd2hlZWwgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3Njcm9sbFdoZWVsWm9vbScsIFNjcm9sbFdoZWVsWm9vbSk7XG5cbi8qXG4gKiBMLk1hcC5UYXAgaXMgdXNlZCB0byBlbmFibGUgbW9iaWxlIGhhY2tzIGxpa2UgcXVpY2sgdGFwcyBhbmQgbG9uZyBob2xkLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHRhcDogQm9vbGVhbiA9IHRydWVcblx0Ly8gRW5hYmxlcyBtb2JpbGUgaGFja3MgZm9yIHN1cHBvcnRpbmcgaW5zdGFudCB0YXBzIChmaXhpbmcgMjAwbXMgY2xpY2tcblx0Ly8gZGVsYXkgb24gaU9TL0FuZHJvaWQpIGFuZCB0b3VjaCBob2xkcyAoZmlyZWQgYXMgYGNvbnRleHRtZW51YCBldmVudHMpLlxuXHR0YXA6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiB0YXBUb2xlcmFuY2U6IE51bWJlciA9IDE1XG5cdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IGhpcyBmaW5nZXIgZHVyaW5nIHRvdWNoXG5cdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgdGFwLlxuXHR0YXBUb2xlcmFuY2U6IDE1XG59KTtcblxudmFyIFRhcCA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcykgeyByZXR1cm47IH1cblxuXHRcdHByZXZlbnREZWZhdWx0KGUpO1xuXG5cdFx0dGhpcy5fZmlyZUNsaWNrID0gdHJ1ZTtcblxuXHRcdC8vIGRvbid0IHNpbXVsYXRlIGNsaWNrIG9yIHRyYWNrIGxvbmdwcmVzcyBpZiBtb3JlIHRoYW4gMSB0b3VjaFxuXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXSxcblx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuXHRcdC8vIGlmIHRvdWNoaW5nIGEgbGluaywgaGlnaGxpZ2h0IGl0XG5cdFx0aWYgKGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcblx0XHRcdGFkZENsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHR9XG5cblx0XHQvLyBzaW11bGF0ZSBsb25nIGhvbGQgYnV0IHNldHRpbmcgYSB0aW1lb3V0XG5cdFx0dGhpcy5faG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9maXJlQ2xpY2sgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fb25VcCgpO1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjb250ZXh0bWVudScsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKSwgMTAwMCk7XG5cblx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdtb3VzZWRvd24nLCBmaXJzdCk7XG5cblx0XHRvbihkb2N1bWVudCwge1xuXHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG5cdFx0XHR0b3VjaGVuZDogdGhpcy5fb25VcFxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vblVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cblx0XHRvZmYoZG9jdW1lbnQsIHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHR9LCB0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9maXJlQ2xpY2sgJiYgZSAmJiBlLmNoYW5nZWRUb3VjaGVzKSB7XG5cblx0XHRcdHZhciBmaXJzdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0sXG5cdFx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHRcdGlmIChlbCAmJiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHRcdHJlbW92ZUNsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2V1cCcsIGZpcnN0KTtcblxuXHRcdFx0Ly8gc2ltdWxhdGUgY2xpY2sgaWYgdGhlIHRvdWNoIGRpZG4ndCBtb3ZlIHRvbyBtdWNoXG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NsaWNrJywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfaXNUYXBWYWxpZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcykgPD0gdGhpcy5fbWFwLm9wdGlvbnMudGFwVG9sZXJhbmNlO1xuXHR9LFxuXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xuXHRcdHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdtb3VzZW1vdmUnLCBmaXJzdCk7XG5cdH0sXG5cblx0X3NpbXVsYXRlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG5cdFx0dmFyIHNpbXVsYXRlZEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTtcblx0XHRlLnRhcmdldC5fc2ltdWxhdGVkQ2xpY2sgPSB0cnVlO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQoXG5cdFx0ICAgICAgICB0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsXG5cdFx0ICAgICAgICBlLnNjcmVlblgsIGUuc2NyZWVuWSxcblx0XHQgICAgICAgIGUuY2xpZW50WCwgZS5jbGllbnRZLFxuXHRcdCAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRhcDogSGFuZGxlclxuLy8gTW9iaWxlIHRvdWNoIGhhY2tzIChxdWljayB0YXAgYW5kIHRvdWNoIGhvbGQpIGhhbmRsZXIuXG5pZiAodG91Y2ggJiYgIXBvaW50ZXIpIHtcblx0TWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcCcsIFRhcCk7XG59XG5cbi8qXG4gKiBMLkhhbmRsZXIuVG91Y2hab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gYWRkIHBpbmNoIHpvb20gb24gc3VwcG9ydGVkIG1vYmlsZSBicm93c2Vycy5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0b3VjaFpvb206IEJvb2xlYW58U3RyaW5nID0gKlxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB0b3VjaC1kcmFnZ2luZyB3aXRoIHR3byBmaW5nZXJzLiBJZlxuXHQvLyBwYXNzZWQgYCdjZW50ZXInYCwgaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZlxuXHQvLyB3aGVyZSB0aGUgdG91Y2ggZXZlbnRzIChmaW5nZXJzKSB3ZXJlLiBFbmFibGVkIGZvciB0b3VjaC1jYXBhYmxlIHdlYlxuXHQvLyBicm93c2VycyBleGNlcHQgZm9yIG9sZCBBbmRyb2lkcy5cblx0dG91Y2hab29tOiB0b3VjaCAmJiAhYW5kcm9pZDIzLFxuXG5cdC8vIEBvcHRpb24gYm91bmNlQXRab29tTGltaXRzOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBTZXQgaXQgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byB6b29tIGJleW9uZCBtaW4vbWF4IHpvb21cblx0Ly8gYW5kIHRoZW4gYm91bmNlIGJhY2sgd2hlbiBwaW5jaC16b29taW5nLlxuXHRib3VuY2VBdFpvb21MaW1pdHM6IHRydWVcbn0pO1xuXG52YXIgVG91Y2hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdGFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0b24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgbWFwLl9hbmltYXRpbmdab29tIHx8IHRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKTtcblxuXHRcdHRoaXMuX2NlbnRlclBvaW50ID0gbWFwLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XG5cdFx0dGhpcy5fc3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSAhPT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhwMS5hZGQocDIpLl9kaXZpZGVCeSgyKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3RhcnREaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0dGhpcy5fc3RhcnRab29tID0gbWFwLmdldFpvb20oKTtcblxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5fem9vbWluZyA9IHRydWU7XG5cblx0XHRtYXAuX3N0b3AoKTtcblxuXHRcdG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuXHRcdG9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdHByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8ICF0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKSxcblx0XHQgICAgc2NhbGUgPSBwMS5kaXN0YW5jZVRvKHAyKSAvIHRoaXMuX3N0YXJ0RGlzdDtcblxuXHRcdHRoaXMuX3pvb20gPSBtYXAuZ2V0U2NhbGVab29tKHNjYWxlLCB0aGlzLl9zdGFydFpvb20pO1xuXG5cdFx0aWYgKCFtYXAub3B0aW9ucy5ib3VuY2VBdFpvb21MaW1pdHMgJiYgKFxuXHRcdFx0KHRoaXMuX3pvb20gPCBtYXAuZ2V0TWluWm9vbSgpICYmIHNjYWxlIDwgMSkgfHxcblx0XHRcdCh0aGlzLl96b29tID4gbWFwLmdldE1heFpvb20oKSAmJiBzY2FsZSA+IDEpKSkge1xuXHRcdFx0dGhpcy5fem9vbSA9IG1hcC5fbGltaXRab29tKHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9zdGFydExhdExuZztcblx0XHRcdGlmIChzY2FsZSA9PT0gMSkgeyByZXR1cm47IH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gR2V0IGRlbHRhIGZyb20gcGluY2ggdG8gY2VudGVyLCBzbyBjZW50ZXJMYXRMbmcgaXMgZGVsdGEgYXBwbGllZCB0byBpbml0aWFsIHBpbmNoTGF0TG5nXG5cdFx0XHR2YXIgZGVsdGEgPSBwMS5fYWRkKHAyKS5fZGl2aWRlQnkoMikuX3N1YnRyYWN0KHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRcdGlmIChzY2FsZSA9PT0gMSAmJiBkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApIHsgcmV0dXJuOyB9XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSBtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcsIHRoaXMuX3pvb20pLnN1YnRyYWN0KGRlbHRhKSwgdGhpcy5fem9vbSk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0bWFwLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHR2YXIgbW92ZUZuID0gYmluZChtYXAuX21vdmUsIG1hcCwgdGhpcy5fY2VudGVyLCB0aGlzLl96b29tLCB7cGluY2g6IHRydWUsIHJvdW5kOiBmYWxzZX0pO1xuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZShtb3ZlRm4sIHRoaXMsIHRydWUpO1xuXG5cdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG5cdFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG5cdFx0b2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kKTtcblxuXHRcdC8vIFBpbmNoIHVwZGF0ZXMgR3JpZExheWVycycgbGV2ZWxzIG9ubHkgd2hlbiB6b29tU25hcCBpcyBvZmYsIHNvIHpvb21TbmFwIGJlY29tZXMgbm9VcGRhdGUuXG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcblx0XHRcdHRoaXMuX21hcC5fYW5pbWF0ZVpvb20odGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSwgdHJ1ZSwgdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRvdWNoWm9vbTogSGFuZGxlclxuLy8gVG91Y2ggem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RvdWNoWm9vbScsIFRvdWNoWm9vbSk7XG5cbk1hcC5Cb3hab29tID0gQm94Wm9vbTtcbk1hcC5Eb3VibGVDbGlja1pvb20gPSBEb3VibGVDbGlja1pvb207XG5NYXAuRHJhZyA9IERyYWc7XG5NYXAuS2V5Ym9hcmQgPSBLZXlib2FyZDtcbk1hcC5TY3JvbGxXaGVlbFpvb20gPSBTY3JvbGxXaGVlbFpvb207XG5NYXAuVGFwID0gVGFwO1xuTWFwLlRvdWNoWm9vbSA9IFRvdWNoWm9vbTtcblxuT2JqZWN0LmZyZWV6ZSA9IGZyZWV6ZTtcblxuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydHMuQ29udHJvbCA9IENvbnRyb2w7XG5leHBvcnRzLmNvbnRyb2wgPSBjb250cm9sO1xuZXhwb3J0cy5Ccm93c2VyID0gQnJvd3NlcjtcbmV4cG9ydHMuRXZlbnRlZCA9IEV2ZW50ZWQ7XG5leHBvcnRzLk1peGluID0gTWl4aW47XG5leHBvcnRzLlV0aWwgPSBVdGlsO1xuZXhwb3J0cy5DbGFzcyA9IENsYXNzO1xuZXhwb3J0cy5IYW5kbGVyID0gSGFuZGxlcjtcbmV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuZXhwb3J0cy5iaW5kID0gYmluZDtcbmV4cG9ydHMuc3RhbXAgPSBzdGFtcDtcbmV4cG9ydHMuc2V0T3B0aW9ucyA9IHNldE9wdGlvbnM7XG5leHBvcnRzLkRvbUV2ZW50ID0gRG9tRXZlbnQ7XG5leHBvcnRzLkRvbVV0aWwgPSBEb21VdGlsO1xuZXhwb3J0cy5Qb3NBbmltYXRpb24gPSBQb3NBbmltYXRpb247XG5leHBvcnRzLkRyYWdnYWJsZSA9IERyYWdnYWJsZTtcbmV4cG9ydHMuTGluZVV0aWwgPSBMaW5lVXRpbDtcbmV4cG9ydHMuUG9seVV0aWwgPSBQb2x5VXRpbDtcbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbmV4cG9ydHMucG9pbnQgPSB0b1BvaW50O1xuZXhwb3J0cy5Cb3VuZHMgPSBCb3VuZHM7XG5leHBvcnRzLmJvdW5kcyA9IHRvQm91bmRzO1xuZXhwb3J0cy5UcmFuc2Zvcm1hdGlvbiA9IFRyYW5zZm9ybWF0aW9uO1xuZXhwb3J0cy50cmFuc2Zvcm1hdGlvbiA9IHRvVHJhbnNmb3JtYXRpb247XG5leHBvcnRzLlByb2plY3Rpb24gPSBpbmRleDtcbmV4cG9ydHMuTGF0TG5nID0gTGF0TG5nO1xuZXhwb3J0cy5sYXRMbmcgPSB0b0xhdExuZztcbmV4cG9ydHMuTGF0TG5nQm91bmRzID0gTGF0TG5nQm91bmRzO1xuZXhwb3J0cy5sYXRMbmdCb3VuZHMgPSB0b0xhdExuZ0JvdW5kcztcbmV4cG9ydHMuQ1JTID0gQ1JTO1xuZXhwb3J0cy5HZW9KU09OID0gR2VvSlNPTjtcbmV4cG9ydHMuZ2VvSlNPTiA9IGdlb0pTT047XG5leHBvcnRzLmdlb0pzb24gPSBnZW9Kc29uO1xuZXhwb3J0cy5MYXllciA9IExheWVyO1xuZXhwb3J0cy5MYXllckdyb3VwID0gTGF5ZXJHcm91cDtcbmV4cG9ydHMubGF5ZXJHcm91cCA9IGxheWVyR3JvdXA7XG5leHBvcnRzLkZlYXR1cmVHcm91cCA9IEZlYXR1cmVHcm91cDtcbmV4cG9ydHMuZmVhdHVyZUdyb3VwID0gZmVhdHVyZUdyb3VwO1xuZXhwb3J0cy5JbWFnZU92ZXJsYXkgPSBJbWFnZU92ZXJsYXk7XG5leHBvcnRzLmltYWdlT3ZlcmxheSA9IGltYWdlT3ZlcmxheTtcbmV4cG9ydHMuVmlkZW9PdmVybGF5ID0gVmlkZW9PdmVybGF5O1xuZXhwb3J0cy52aWRlb092ZXJsYXkgPSB2aWRlb092ZXJsYXk7XG5leHBvcnRzLlNWR092ZXJsYXkgPSBTVkdPdmVybGF5O1xuZXhwb3J0cy5zdmdPdmVybGF5ID0gc3ZnT3ZlcmxheTtcbmV4cG9ydHMuRGl2T3ZlcmxheSA9IERpdk92ZXJsYXk7XG5leHBvcnRzLlBvcHVwID0gUG9wdXA7XG5leHBvcnRzLnBvcHVwID0gcG9wdXA7XG5leHBvcnRzLlRvb2x0aXAgPSBUb29sdGlwO1xuZXhwb3J0cy50b29sdGlwID0gdG9vbHRpcDtcbmV4cG9ydHMuSWNvbiA9IEljb247XG5leHBvcnRzLmljb24gPSBpY29uO1xuZXhwb3J0cy5EaXZJY29uID0gRGl2SWNvbjtcbmV4cG9ydHMuZGl2SWNvbiA9IGRpdkljb247XG5leHBvcnRzLk1hcmtlciA9IE1hcmtlcjtcbmV4cG9ydHMubWFya2VyID0gbWFya2VyO1xuZXhwb3J0cy5UaWxlTGF5ZXIgPSBUaWxlTGF5ZXI7XG5leHBvcnRzLnRpbGVMYXllciA9IHRpbGVMYXllcjtcbmV4cG9ydHMuR3JpZExheWVyID0gR3JpZExheWVyO1xuZXhwb3J0cy5ncmlkTGF5ZXIgPSBncmlkTGF5ZXI7XG5leHBvcnRzLlNWRyA9IFNWRztcbmV4cG9ydHMuc3ZnID0gc3ZnJDE7XG5leHBvcnRzLlJlbmRlcmVyID0gUmVuZGVyZXI7XG5leHBvcnRzLkNhbnZhcyA9IENhbnZhcztcbmV4cG9ydHMuY2FudmFzID0gY2FudmFzJDE7XG5leHBvcnRzLlBhdGggPSBQYXRoO1xuZXhwb3J0cy5DaXJjbGVNYXJrZXIgPSBDaXJjbGVNYXJrZXI7XG5leHBvcnRzLmNpcmNsZU1hcmtlciA9IGNpcmNsZU1hcmtlcjtcbmV4cG9ydHMuQ2lyY2xlID0gQ2lyY2xlO1xuZXhwb3J0cy5jaXJjbGUgPSBjaXJjbGU7XG5leHBvcnRzLlBvbHlsaW5lID0gUG9seWxpbmU7XG5leHBvcnRzLnBvbHlsaW5lID0gcG9seWxpbmU7XG5leHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uO1xuZXhwb3J0cy5wb2x5Z29uID0gcG9seWdvbjtcbmV4cG9ydHMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xuZXhwb3J0cy5yZWN0YW5nbGUgPSByZWN0YW5nbGU7XG5leHBvcnRzLk1hcCA9IE1hcDtcbmV4cG9ydHMubWFwID0gY3JlYXRlTWFwO1xuXG52YXIgb2xkTCA9IHdpbmRvdy5MO1xuZXhwb3J0cy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG5cdHdpbmRvdy5MID0gb2xkTDtcblx0cmV0dXJuIHRoaXM7XG59XG5cbi8vIEFsd2F5cyBleHBvcnQgdXMgdG8gd2luZG93IGdsb2JhbCAoc2VlICMyMzY0KVxud2luZG93LkwgPSBleHBvcnRzO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVhZmxldC1zcmMuanMubWFwXG4iLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9sZWFmbGV0LmNzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xuXG4gICAgICBvcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xuICAgIFxub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9sZWFmbGV0LmNzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuXG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB1cGRhdGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZW1vID0ge307XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0KHRhcmdldCkge1xuICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBpbnNlcnRCeVNlbGVjdG9yKGluc2VydCwgc3R5bGUpIHtcbiAgdmFyIHRhcmdldCA9IGdldFRhcmdldChpbnNlcnQpO1xuXG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgfVxuXG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QnlTZWxlY3RvcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgb3B0aW9ucy5zZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFN0eWxlRWxlbWVudDsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBcIlwiO1xuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChvYmouc3VwcG9ydHMsIFwiKSB7XCIpO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpO1xuICB9XG5cbiAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBvYmoubGF5ZXIgIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIkBsYXllclwiLmNvbmNhdChvYmoubGF5ZXIubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChvYmoubGF5ZXIpIDogXCJcIiwgXCIge1wiKTtcbiAgfVxuXG4gIGNzcyArPSBvYmouY3NzO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgb3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlRWxlbWVudC5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbmZ1bmN0aW9uIGRvbUFQSShvcHRpb25zKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBvcHRpb25zLmluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvYmopIHtcbiAgICAgIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRvbUFQSTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCkge1xuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiLCIvKipcbiAqIHZpcy1kYXRhXG4gKiBodHRwOi8vdmlzanMub3JnL1xuICpcbiAqIE1hbmFnZSB1bnN0cnVjdHVyZWQgZGF0YSB1c2luZyBEYXRhU2V0LiBBZGQsIHVwZGF0ZSwgYW5kIHJlbW92ZSBkYXRhLCBhbmQgbGlzdGVuIGZvciBjaGFuZ2VzIGluIHRoZSBkYXRhLlxuICpcbiAqIEB2ZXJzaW9uIDcuMS40XG4gKiBAZGF0ZSAgICAyMDIyLTAzLTE1VDE1OjIzOjU5LjI0NVpcbiAqXG4gKiBAY29weXJpZ2h0IChjKSAyMDExLTIwMTcgQWxtZW5kZSBCLlYsIGh0dHA6Ly9hbG1lbmRlLmNvbVxuICogQGNvcHlyaWdodCAoYykgMjAxNy0yMDE5IHZpc2pzIGNvbnRyaWJ1dG9ycywgaHR0cHM6Ly9naXRodWIuY29tL3Zpc2pzXG4gKlxuICogQGxpY2Vuc2VcbiAqIHZpcy5qcyBpcyBkdWFsIGxpY2Vuc2VkIHVuZGVyIGJvdGhcbiAqXG4gKiAgIDEuIFRoZSBBcGFjaGUgMi4wIExpY2Vuc2VcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogICBhbmRcbiAqXG4gKiAgIDIuIFRoZSBNSVQgTGljZW5zZVxuICogICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogdmlzLmpzIG1heSBiZSBkaXN0cmlidXRlZCB1bmRlciBlaXRoZXIgbGljZW5zZS5cbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLnZpcyA9IGdsb2JhbC52aXMgfHwge30pKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbiAgdmFyIGRlZmluZVByb3BlcnR5JGUgPSB7ZXhwb3J0czoge319O1xuXG4gIHZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XG4gIH07IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5cblxuICB2YXIgZ2xvYmFsJE0gPSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZ2xvYmFsLXRoaXMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fCBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8IGNoZWNrKHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCkgfHwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jIC0tIGZhbGxiYWNrXG4gIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgdmFyIGZhaWxzJHIgPSBmdW5jdGlvbiAoZXhlYykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gISFleGVjKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZmFpbHMkcSA9IGZhaWxzJHI7XG4gIHZhciBmdW5jdGlvbkJpbmROYXRpdmUgPSAhZmFpbHMkcShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKiBlbXB0eSAqL1xuICAgIH0uYmluZCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcblxuXG4gICAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG4gIH0pO1xuXG4gIHZhciBOQVRJVkVfQklORCQ0ID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuICB2YXIgRnVuY3Rpb25Qcm90b3R5cGUkMyA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGFwcGx5JDYgPSBGdW5jdGlvblByb3RvdHlwZSQzLmFwcGx5O1xuICB2YXIgY2FsbCRjID0gRnVuY3Rpb25Qcm90b3R5cGUkMy5jYWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tcmVmbGVjdCAtLSBzYWZlXG5cbiAgdmFyIGZ1bmN0aW9uQXBwbHkgPSB0eXBlb2YgUmVmbGVjdCA9PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmFwcGx5IHx8IChOQVRJVkVfQklORCQ0ID8gY2FsbCRjLmJpbmQoYXBwbHkkNikgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGwkYy5hcHBseShhcHBseSQ2LCBhcmd1bWVudHMpO1xuICB9KTtcblxuICB2YXIgTkFUSVZFX0JJTkQkMyA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcbiAgdmFyIEZ1bmN0aW9uUHJvdG90eXBlJDIgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gIHZhciBiaW5kJGQgPSBGdW5jdGlvblByb3RvdHlwZSQyLmJpbmQ7XG4gIHZhciBjYWxsJGIgPSBGdW5jdGlvblByb3RvdHlwZSQyLmNhbGw7XG4gIHZhciB1bmN1cnJ5VGhpcyR0ID0gTkFUSVZFX0JJTkQkMyAmJiBiaW5kJGQuYmluZChjYWxsJGIsIGNhbGwkYik7XG4gIHZhciBmdW5jdGlvblVuY3VycnlUaGlzID0gTkFUSVZFX0JJTkQkMyA/IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBmbiAmJiB1bmN1cnJ5VGhpcyR0KGZuKTtcbiAgfSA6IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBmbiAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY2FsbCRiLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG5cbiAgdmFyIGlzQ2FsbGFibGUkaCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcbiAgfTtcblxuICB2YXIgb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0ge307XG5cbiAgdmFyIGZhaWxzJHAgPSBmYWlscyRyOyAvLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxuXG4gIHZhciBkZXNjcmlwdG9ycyA9ICFmYWlscyRwKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiA3O1xuICAgICAgfVxuICAgIH0pWzFdICE9IDc7XG4gIH0pO1xuXG4gIHZhciBOQVRJVkVfQklORCQyID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuICB2YXIgY2FsbCRhID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG4gIHZhciBmdW5jdGlvbkNhbGwgPSBOQVRJVkVfQklORCQyID8gY2FsbCRhLmJpbmQoY2FsbCRhKSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbCRhLmFwcGx5KGNhbGwkYSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUgPSB7fTtcblxuICB2YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlJDIgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuXG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IC8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xuXG4gIHZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ1ICYmICEkcHJvcGVydHlJc0VudW1lcmFibGUkMi5jYWxsKHtcbiAgICAxOiAyXG4gIH0sIDEpOyAvLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxuXG4gIG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ1KHRoaXMsIFYpO1xuICAgIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xuICB9IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlJDI7XG5cbiAgdmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1ID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgfTtcblxuICB2YXIgdW5jdXJyeVRoaXMkcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciB0b1N0cmluZyQ5ID0gdW5jdXJyeVRoaXMkcyh7fS50b1N0cmluZyk7XG4gIHZhciBzdHJpbmdTbGljZSQxID0gdW5jdXJyeVRoaXMkcygnJy5zbGljZSk7XG5cbiAgdmFyIGNsYXNzb2ZSYXckMSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBzdHJpbmdTbGljZSQxKHRvU3RyaW5nJDkoaXQpLCA4LCAtMSk7XG4gIH07XG5cbiAgdmFyIGdsb2JhbCRMID0gZ2xvYmFsJE07XG4gIHZhciB1bmN1cnJ5VGhpcyRyID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIGZhaWxzJG8gPSBmYWlscyRyO1xuICB2YXIgY2xhc3NvZiRmID0gY2xhc3NvZlJhdyQxO1xuICB2YXIgT2JqZWN0JDkgPSBnbG9iYWwkTC5PYmplY3Q7XG4gIHZhciBzcGxpdCA9IHVuY3VycnlUaGlzJHIoJycuc3BsaXQpOyAvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xuXG4gIHZhciBpbmRleGVkT2JqZWN0ID0gZmFpbHMkbyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICAgIHJldHVybiAhT2JqZWN0JDkoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbiAgfSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gY2xhc3NvZiRmKGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0KGl0LCAnJykgOiBPYmplY3QkOShpdCk7XG4gIH0gOiBPYmplY3QkOTtcblxuICB2YXIgZ2xvYmFsJEsgPSBnbG9iYWwkTTtcbiAgdmFyIFR5cGVFcnJvciRqID0gZ2xvYmFsJEsuVHlwZUVycm9yOyAvLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxuXG4gIHZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IkaihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICAgIHJldHVybiBpdDtcbiAgfTtcblxuICB2YXIgSW5kZXhlZE9iamVjdCQzID0gaW5kZXhlZE9iamVjdDtcbiAgdmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkNCA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcblxuICB2YXIgdG9JbmRleGVkT2JqZWN0JGIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gSW5kZXhlZE9iamVjdCQzKHJlcXVpcmVPYmplY3RDb2VyY2libGUkNChpdCkpO1xuICB9O1xuXG4gIHZhciBpc0NhbGxhYmxlJGcgPSBpc0NhbGxhYmxlJGg7XG5cbiAgdmFyIGlzT2JqZWN0JGYgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlJGcoaXQpO1xuICB9O1xuXG4gIHZhciBwYXRoJHEgPSB7fTtcblxuICB2YXIgcGF0aCRwID0gcGF0aCRxO1xuICB2YXIgZ2xvYmFsJEogPSBnbG9iYWwkTTtcbiAgdmFyIGlzQ2FsbGFibGUkZiA9IGlzQ2FsbGFibGUkaDtcblxuICB2YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIGlzQ2FsbGFibGUkZih2YXJpYWJsZSkgPyB2YXJpYWJsZSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICB2YXIgZ2V0QnVpbHRJbiQ5ID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKHBhdGgkcFtuYW1lc3BhY2VdKSB8fCBhRnVuY3Rpb24oZ2xvYmFsJEpbbmFtZXNwYWNlXSkgOiBwYXRoJHBbbmFtZXNwYWNlXSAmJiBwYXRoJHBbbmFtZXNwYWNlXVttZXRob2RdIHx8IGdsb2JhbCRKW25hbWVzcGFjZV0gJiYgZ2xvYmFsJEpbbmFtZXNwYWNlXVttZXRob2RdO1xuICB9O1xuXG4gIHZhciB1bmN1cnJ5VGhpcyRxID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIG9iamVjdElzUHJvdG90eXBlT2YgPSB1bmN1cnJ5VGhpcyRxKHt9LmlzUHJvdG90eXBlT2YpO1xuXG4gIHZhciBnZXRCdWlsdEluJDggPSBnZXRCdWlsdEluJDk7XG4gIHZhciBlbmdpbmVVc2VyQWdlbnQgPSBnZXRCdWlsdEluJDgoJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcblxuICB2YXIgZ2xvYmFsJEkgPSBnbG9iYWwkTTtcbiAgdmFyIHVzZXJBZ2VudCQzID0gZW5naW5lVXNlckFnZW50O1xuICB2YXIgcHJvY2VzcyA9IGdsb2JhbCRJLnByb2Nlc3M7XG4gIHZhciBEZW5vID0gZ2xvYmFsJEkuRGVubztcbiAgdmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zIHx8IERlbm8gJiYgRGVuby52ZXJzaW9uO1xuICB2YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbiAgdmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG4gIGlmICh2OCkge1xuICAgIG1hdGNoID0gdjguc3BsaXQoJy4nKTsgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAgIC8vIGJ1dCB0aGVpciBjb3JyZWN0IHZlcnNpb25zIGFyZSBub3QgaW50ZXJlc3RpbmcgZm9yIHVzXG5cbiAgICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xuICB9IC8vIEJyb3dzZXJGUyBOb2RlSlMgYHByb2Nlc3NgIHBvbHlmaWxsIGluY29ycmVjdGx5IHNldCBgLnY4YCB0byBgMC4wYFxuICAvLyBzbyBjaGVjayBgdXNlckFnZW50YCBldmVuIGlmIGAudjhgIGV4aXN0cywgYnV0IDBcblxuXG4gIGlmICghdmVyc2lvbiAmJiB1c2VyQWdlbnQkMykge1xuICAgIG1hdGNoID0gdXNlckFnZW50JDMubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcblxuICAgIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICAgIG1hdGNoID0gdXNlckFnZW50JDMubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gK21hdGNoWzFdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbmdpbmVWOFZlcnNpb24gPSB2ZXJzaW9uO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuICB2YXIgVjhfVkVSU0lPTiQyID0gZW5naW5lVjhWZXJzaW9uO1xuICB2YXIgZmFpbHMkbiA9IGZhaWxzJHI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cbiAgdmFyIG5hdGl2ZVN5bWJvbCA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMkbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpOyAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAgIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcblxuICAgIHJldHVybiAhU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHwgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiQyICYmIFY4X1ZFUlNJT04kMiA8IDQxO1xuICB9KTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbiAgdmFyIE5BVElWRV9TWU1CT0wkMiA9IG5hdGl2ZVN5bWJvbDtcbiAgdmFyIHVzZVN5bWJvbEFzVWlkID0gTkFUSVZFX1NZTUJPTCQyICYmICFTeW1ib2wuc2hhbSAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuXG4gIHZhciBnbG9iYWwkSCA9IGdsb2JhbCRNO1xuICB2YXIgZ2V0QnVpbHRJbiQ3ID0gZ2V0QnVpbHRJbiQ5O1xuICB2YXIgaXNDYWxsYWJsZSRlID0gaXNDYWxsYWJsZSRoO1xuICB2YXIgaXNQcm90b3R5cGVPZiRpID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbiAgdmFyIFVTRV9TWU1CT0xfQVNfVUlEJDEgPSB1c2VTeW1ib2xBc1VpZDtcbiAgdmFyIE9iamVjdCQ4ID0gZ2xvYmFsJEguT2JqZWN0O1xuICB2YXIgaXNTeW1ib2wkMyA9IFVTRV9TWU1CT0xfQVNfVUlEJDEgPyBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xuICB9IDogZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluJDcoJ1N5bWJvbCcpO1xuICAgIHJldHVybiBpc0NhbGxhYmxlJGUoJFN5bWJvbCkgJiYgaXNQcm90b3R5cGVPZiRpKCRTeW1ib2wucHJvdG90eXBlLCBPYmplY3QkOChpdCkpO1xuICB9O1xuXG4gIHZhciBnbG9iYWwkRyA9IGdsb2JhbCRNO1xuICB2YXIgU3RyaW5nJDQgPSBnbG9iYWwkRy5TdHJpbmc7XG5cbiAgdmFyIHRyeVRvU3RyaW5nJDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFN0cmluZyQ0KGFyZ3VtZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuICdPYmplY3QnO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2xvYmFsJEYgPSBnbG9iYWwkTTtcbiAgdmFyIGlzQ2FsbGFibGUkZCA9IGlzQ2FsbGFibGUkaDtcbiAgdmFyIHRyeVRvU3RyaW5nJDMgPSB0cnlUb1N0cmluZyQ0O1xuICB2YXIgVHlwZUVycm9yJGkgPSBnbG9iYWwkRi5UeXBlRXJyb3I7IC8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG5cbiAgdmFyIGFDYWxsYWJsZSQ3ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgaWYgKGlzQ2FsbGFibGUkZChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgICB0aHJvdyBUeXBlRXJyb3IkaSh0cnlUb1N0cmluZyQzKGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfTtcblxuICB2YXIgYUNhbGxhYmxlJDYgPSBhQ2FsbGFibGUkNzsgLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0bWV0aG9kXG5cbiAgdmFyIGdldE1ldGhvZCQzID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgICB2YXIgZnVuYyA9IFZbUF07XG4gICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFDYWxsYWJsZSQ2KGZ1bmMpO1xuICB9O1xuXG4gIHZhciBnbG9iYWwkRSA9IGdsb2JhbCRNO1xuICB2YXIgY2FsbCQ5ID0gZnVuY3Rpb25DYWxsO1xuICB2YXIgaXNDYWxsYWJsZSRjID0gaXNDYWxsYWJsZSRoO1xuICB2YXIgaXNPYmplY3QkZSA9IGlzT2JqZWN0JGY7XG4gIHZhciBUeXBlRXJyb3IkaCA9IGdsb2JhbCRFLlR5cGVFcnJvcjsgLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9yZGluYXJ5dG9wcmltaXRpdmVcblxuICB2YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSQxID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gICAgdmFyIGZuLCB2YWw7XG4gICAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkYyhmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkZSh2YWwgPSBjYWxsJDkoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gICAgaWYgKGlzQ2FsbGFibGUkYyhmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCRlKHZhbCA9IGNhbGwkOShmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgICBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSRjKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCRlKHZhbCA9IGNhbGwkOShmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgICB0aHJvdyBUeXBlRXJyb3IkaChcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbiAgfTtcblxuICB2YXIgc2hhcmVkJDQgPSB7ZXhwb3J0czoge319O1xuXG4gIHZhciBnbG9iYWwkRCA9IGdsb2JhbCRNOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcblxuICB2YXIgZGVmaW5lUHJvcGVydHkkZCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuICB2YXIgc2V0R2xvYmFsJDEgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSRkKGdsb2JhbCRELCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZ2xvYmFsJERba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB2YXIgZ2xvYmFsJEMgPSBnbG9iYWwkTTtcbiAgdmFyIHNldEdsb2JhbCA9IHNldEdsb2JhbCQxO1xuICB2YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG4gIHZhciBzdG9yZSQzID0gZ2xvYmFsJENbU0hBUkVEXSB8fCBzZXRHbG9iYWwoU0hBUkVELCB7fSk7XG4gIHZhciBzaGFyZWRTdG9yZSA9IHN0b3JlJDM7XG5cbiAgdmFyIHN0b3JlJDIgPSBzaGFyZWRTdG9yZTtcbiAgKHNoYXJlZCQ0LmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBzdG9yZSQyW2tleV0gfHwgKHN0b3JlJDJba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbiAgfSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICAgIHZlcnNpb246ICczLjIxLjEnLFxuICAgIG1vZGU6ICdwdXJlJyAsXG4gICAgY29weXJpZ2h0OiAnwqkgMjAxNC0yMDIyIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJyxcbiAgICBsaWNlbnNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4yMS4xL0xJQ0VOU0UnLFxuICAgIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xuICB9KTtcblxuICB2YXIgZ2xvYmFsJEIgPSBnbG9iYWwkTTtcbiAgdmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcbiAgdmFyIE9iamVjdCQ3ID0gZ2xvYmFsJEIuT2JqZWN0OyAvLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG5cbiAgdmFyIHRvT2JqZWN0JGUgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICByZXR1cm4gT2JqZWN0JDcocmVxdWlyZU9iamVjdENvZXJjaWJsZSQzKGFyZ3VtZW50KSk7XG4gIH07XG5cbiAgdmFyIHVuY3VycnlUaGlzJHAgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgdG9PYmplY3QkZCA9IHRvT2JqZWN0JGU7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzJHAoe30uaGFzT3duUHJvcGVydHkpOyAvLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWhhc293bnByb3BlcnR5XG5cbiAgdmFyIGhhc093blByb3BlcnR5XzEgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5KHRvT2JqZWN0JGQoaXQpLCBrZXkpO1xuICB9O1xuXG4gIHZhciB1bmN1cnJ5VGhpcyRvID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIGlkJDEgPSAwO1xuICB2YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG4gIHZhciB0b1N0cmluZyQ4ID0gdW5jdXJyeVRoaXMkbygxLjAudG9TdHJpbmcpO1xuXG4gIHZhciB1aWQkNCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nJDgoKytpZCQxICsgcG9zdGZpeCwgMzYpO1xuICB9O1xuXG4gIHZhciBnbG9iYWwkQSA9IGdsb2JhbCRNO1xuICB2YXIgc2hhcmVkJDMgPSBzaGFyZWQkNC5leHBvcnRzO1xuICB2YXIgaGFzT3duJGYgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuICB2YXIgdWlkJDMgPSB1aWQkNDtcbiAgdmFyIE5BVElWRV9TWU1CT0wkMSA9IG5hdGl2ZVN5bWJvbDtcbiAgdmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gdXNlU3ltYm9sQXNVaWQ7XG4gIHZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUkMSA9IHNoYXJlZCQzKCd3a3MnKTtcbiAgdmFyIFN5bWJvbCQyID0gZ2xvYmFsJEEuU3ltYm9sO1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sJDIgJiYgU3ltYm9sJDJbJ2ZvciddO1xuICB2YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wkMiA6IFN5bWJvbCQyICYmIFN5bWJvbCQyLndpdGhvdXRTZXR0ZXIgfHwgdWlkJDM7XG5cbiAgdmFyIHdlbGxLbm93blN5bWJvbCRqID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoIWhhc093biRmKFdlbGxLbm93blN5bWJvbHNTdG9yZSQxLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wkMSB8fCB0eXBlb2YgV2VsbEtub3duU3ltYm9sc1N0b3JlJDFbbmFtZV0gPT0gJ3N0cmluZycpKSB7XG4gICAgICB2YXIgZGVzY3JpcHRpb24gPSAnU3ltYm9sLicgKyBuYW1lO1xuXG4gICAgICBpZiAoTkFUSVZFX1NZTUJPTCQxICYmIGhhc093biRmKFN5bWJvbCQyLCBuYW1lKSkge1xuICAgICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmUkMVtuYW1lXSA9IFN5bWJvbCQyW25hbWVdO1xuICAgICAgfSBlbHNlIGlmIChVU0VfU1lNQk9MX0FTX1VJRCAmJiBzeW1ib2xGb3IpIHtcbiAgICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlJDFbbmFtZV0gPSBzeW1ib2xGb3IoZGVzY3JpcHRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlJDFbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woZGVzY3JpcHRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmUkMVtuYW1lXTtcbiAgfTtcblxuICB2YXIgZ2xvYmFsJHogPSBnbG9iYWwkTTtcbiAgdmFyIGNhbGwkOCA9IGZ1bmN0aW9uQ2FsbDtcbiAgdmFyIGlzT2JqZWN0JGQgPSBpc09iamVjdCRmO1xuICB2YXIgaXNTeW1ib2wkMiA9IGlzU3ltYm9sJDM7XG4gIHZhciBnZXRNZXRob2QkMiA9IGdldE1ldGhvZCQzO1xuICB2YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IG9yZGluYXJ5VG9QcmltaXRpdmUkMTtcbiAgdmFyIHdlbGxLbm93blN5bWJvbCRpID0gd2VsbEtub3duU3ltYm9sJGo7XG4gIHZhciBUeXBlRXJyb3IkZyA9IGdsb2JhbCR6LlR5cGVFcnJvcjtcbiAgdmFyIFRPX1BSSU1JVElWRSQxID0gd2VsbEtub3duU3ltYm9sJGkoJ3RvUHJpbWl0aXZlJyk7IC8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcblxuICB2YXIgdG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICAgIGlmICghaXNPYmplY3QkZChpbnB1dCkgfHwgaXNTeW1ib2wkMihpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kJDIoaW5wdXQsIFRPX1BSSU1JVElWRSQxKTtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgICAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdkZWZhdWx0JztcbiAgICAgIHJlc3VsdCA9IGNhbGwkOChleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICAgIGlmICghaXNPYmplY3QkZChyZXN1bHQpIHx8IGlzU3ltYm9sJDIocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHRocm93IFR5cGVFcnJvciRnKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICAgIH1cblxuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG4gIH07XG5cbiAgdmFyIHRvUHJpbWl0aXZlID0gdG9QcmltaXRpdmUkMTtcbiAgdmFyIGlzU3ltYm9sJDEgPSBpc1N5bWJvbCQzOyAvLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxuXG4gIHZhciB0b1Byb3BlcnR5S2V5JDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgICByZXR1cm4gaXNTeW1ib2wkMShrZXkpID8ga2V5IDoga2V5ICsgJyc7XG4gIH07XG5cbiAgdmFyIGdsb2JhbCR5ID0gZ2xvYmFsJE07XG4gIHZhciBpc09iamVjdCRjID0gaXNPYmplY3QkZjtcbiAgdmFyIGRvY3VtZW50JDEgPSBnbG9iYWwkeS5kb2N1bWVudDsgLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG5cbiAgdmFyIEVYSVNUUyQxID0gaXNPYmplY3QkYyhkb2N1bWVudCQxKSAmJiBpc09iamVjdCRjKGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCk7XG5cbiAgdmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIEVYSVNUUyQxID8gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xuICB9O1xuXG4gIHZhciBERVNDUklQVE9SUyRoID0gZGVzY3JpcHRvcnM7XG4gIHZhciBmYWlscyRtID0gZmFpbHMkcjtcbiAgdmFyIGNyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMTsgLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5cbiAgdmFyIGllOERvbURlZmluZSA9ICFERVNDUklQVE9SUyRoICYmICFmYWlscyRtKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDc7XG4gICAgICB9XG4gICAgfSkuYSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVTQ1JJUFRPUlMkZyA9IGRlc2NyaXB0b3JzO1xuICB2YXIgY2FsbCQ3ID0gZnVuY3Rpb25DYWxsO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMiA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICB2YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbiAgdmFyIHRvSW5kZXhlZE9iamVjdCRhID0gdG9JbmRleGVkT2JqZWN0JGI7XG4gIHZhciB0b1Byb3BlcnR5S2V5JDMgPSB0b1Byb3BlcnR5S2V5JDQ7XG4gIHZhciBoYXNPd24kZSA9IGhhc093blByb3BlcnR5XzE7XG4gIHZhciBJRThfRE9NX0RFRklORSQxID0gaWU4RG9tRGVmaW5lOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG5cbiAgdmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5cbiAgb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmYgPSBERVNDUklQVE9SUyRnID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgICBPID0gdG9JbmRleGVkT2JqZWN0JGEoTyk7XG4gICAgUCA9IHRvUHJvcGVydHlLZXkkMyhQKTtcbiAgICBpZiAoSUU4X0RPTV9ERUZJTkUkMSkgdHJ5IHtcbiAgICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIoTywgUCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8qIGVtcHR5ICovXG4gICAgfVxuICAgIGlmIChoYXNPd24kZShPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ0KCFjYWxsJDcocHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMi5mLCBPLCBQKSwgT1tQXSk7XG4gIH07XG5cbiAgdmFyIGZhaWxzJGwgPSBmYWlscyRyO1xuICB2YXIgaXNDYWxsYWJsZSRiID0gaXNDYWxsYWJsZSRoO1xuICB2YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG4gIHZhciBpc0ZvcmNlZCQxID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICAgIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2UgOiBpc0NhbGxhYmxlJGIoZGV0ZWN0aW9uKSA/IGZhaWxzJGwoZGV0ZWN0aW9uKSA6ICEhZGV0ZWN0aW9uO1xuICB9O1xuXG4gIHZhciBub3JtYWxpemUgPSBpc0ZvcmNlZCQxLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xuICB9O1xuXG4gIHZhciBkYXRhID0gaXNGb3JjZWQkMS5kYXRhID0ge307XG4gIHZhciBOQVRJVkUgPSBpc0ZvcmNlZCQxLk5BVElWRSA9ICdOJztcbiAgdmFyIFBPTFlGSUxMID0gaXNGb3JjZWQkMS5QT0xZRklMTCA9ICdQJztcbiAgdmFyIGlzRm9yY2VkXzEgPSBpc0ZvcmNlZCQxO1xuXG4gIHZhciB1bmN1cnJ5VGhpcyRuID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIGFDYWxsYWJsZSQ1ID0gYUNhbGxhYmxlJDc7XG4gIHZhciBOQVRJVkVfQklORCQxID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuICB2YXIgYmluZCRjID0gdW5jdXJyeVRoaXMkbih1bmN1cnJ5VGhpcyRuLmJpbmQpOyAvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcblxuICB2YXIgZnVuY3Rpb25CaW5kQ29udGV4dCA9IGZ1bmN0aW9uIChmbiwgdGhhdCkge1xuICAgIGFDYWxsYWJsZSQ1KGZuKTtcbiAgICByZXR1cm4gdGhhdCA9PT0gdW5kZWZpbmVkID8gZm4gOiBOQVRJVkVfQklORCQxID8gYmluZCRjKGZuLCB0aGF0KSA6IGZ1bmN0aW9uXG4gICAgICAvKiAuLi5hcmdzICovXG4gICAgKCkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgb2JqZWN0RGVmaW5lUHJvcGVydHkgPSB7fTtcblxuICB2YXIgREVTQ1JJUFRPUlMkZiA9IGRlc2NyaXB0b3JzO1xuICB2YXIgZmFpbHMkayA9IGZhaWxzJHI7IC8vIFY4IH4gQ2hyb21lIDM2LVxuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMzM0XG5cbiAgdmFyIHY4UHJvdG90eXBlRGVmaW5lQnVnID0gREVTQ1JJUFRPUlMkZiAmJiBmYWlscyRrKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7XG4gICAgICAvKiBlbXB0eSAqL1xuICAgIH0sICdwcm90b3R5cGUnLCB7XG4gICAgICB2YWx1ZTogNDIsXG4gICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9KS5wcm90b3R5cGUgIT0gNDI7XG4gIH0pO1xuXG4gIHZhciBnbG9iYWwkeCA9IGdsb2JhbCRNO1xuICB2YXIgaXNPYmplY3QkYiA9IGlzT2JqZWN0JGY7XG4gIHZhciBTdHJpbmckMyA9IGdsb2JhbCR4LlN0cmluZztcbiAgdmFyIFR5cGVFcnJvciRmID0gZ2xvYmFsJHguVHlwZUVycm9yOyAvLyBgQXNzZXJ0OiBUeXBlKGFyZ3VtZW50KSBpcyBPYmplY3RgXG5cbiAgdmFyIGFuT2JqZWN0JGIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICBpZiAoaXNPYmplY3QkYihhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgICB0aHJvdyBUeXBlRXJyb3IkZihTdHJpbmckMyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgfTtcblxuICB2YXIgZ2xvYmFsJHcgPSBnbG9iYWwkTTtcbiAgdmFyIERFU0NSSVBUT1JTJGUgPSBkZXNjcmlwdG9ycztcbiAgdmFyIElFOF9ET01fREVGSU5FID0gaWU4RG9tRGVmaW5lO1xuICB2YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSA9IHY4UHJvdG90eXBlRGVmaW5lQnVnO1xuICB2YXIgYW5PYmplY3QkYSA9IGFuT2JqZWN0JGI7XG4gIHZhciB0b1Byb3BlcnR5S2V5JDIgPSB0b1Byb3BlcnR5S2V5JDQ7XG4gIHZhciBUeXBlRXJyb3IkZSA9IGdsb2JhbCR3LlR5cGVFcnJvcjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG5cbiAgdmFyICRkZWZpbmVQcm9wZXJ0eSQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG5cbiAgdmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gIHZhciBFTlVNRVJBQkxFID0gJ2VudW1lcmFibGUnO1xuICB2YXIgQ09ORklHVVJBQkxFJDEgPSAnY29uZmlndXJhYmxlJztcbiAgdmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJzsgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5cbiAgb2JqZWN0RGVmaW5lUHJvcGVydHkuZiA9IERFU0NSSVBUT1JTJGUgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID8gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICAgIGFuT2JqZWN0JGEoTyk7XG4gICAgUCA9IHRvUHJvcGVydHlLZXkkMihQKTtcbiAgICBhbk9iamVjdCRhKEF0dHJpYnV0ZXMpO1xuXG4gICAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoTywgUCk7XG5cbiAgICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnRbV1JJVEFCTEVdKSB7XG4gICAgICAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgICBBdHRyaWJ1dGVzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogQ09ORklHVVJBQkxFJDEgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFJDFdIDogY3VycmVudFtDT05GSUdVUkFCTEUkMV0sXG4gICAgICAgICAgZW51bWVyYWJsZTogRU5VTUVSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tFTlVNRVJBQkxFXSA6IGN1cnJlbnRbRU5VTUVSQUJMRV0sXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eSQxKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IDogJGRlZmluZVByb3BlcnR5JDEgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gICAgYW5PYmplY3QkYShPKTtcbiAgICBQID0gdG9Qcm9wZXJ0eUtleSQyKFApO1xuICAgIGFuT2JqZWN0JGEoQXR0cmlidXRlcyk7XG4gICAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eSQxKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvKiBlbXB0eSAqL1xuICAgIH1cbiAgICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IkZSgnQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICByZXR1cm4gTztcbiAgfTtcblxuICB2YXIgREVTQ1JJUFRPUlMkZCA9IGRlc2NyaXB0b3JzO1xuICB2YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkNCA9IG9iamVjdERlZmluZVByb3BlcnR5O1xuICB2YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbiAgdmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2ID0gREVTQ1JJUFRPUlMkZCA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUkNC5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMygxLCB2YWx1ZSkpO1xuICB9IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcblxuICB2YXIgZ2xvYmFsJHYgPSBnbG9iYWwkTTtcbiAgdmFyIGFwcGx5JDUgPSBmdW5jdGlvbkFwcGx5O1xuICB2YXIgdW5jdXJyeVRoaXMkbSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBpc0NhbGxhYmxlJGEgPSBpc0NhbGxhYmxlJGg7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNCA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xuICB2YXIgaXNGb3JjZWQgPSBpc0ZvcmNlZF8xO1xuICB2YXIgcGF0aCRvID0gcGF0aCRxO1xuICB2YXIgYmluZCRiID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbiAgdmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDY7XG4gIHZhciBoYXNPd24kZCA9IGhhc093blByb3BlcnR5XzE7XG5cbiAgdmFyIHdyYXBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChOYXRpdmVDb25zdHJ1Y3Rvcikge1xuICAgIHZhciBXcmFwcGVyID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgV3JhcHBlcikge1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCk7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGEpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcihhLCBiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQ29uc3RydWN0b3IoYSwgYiwgYyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcHBseSQ1KE5hdGl2ZUNvbnN0cnVjdG9yLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE5hdGl2ZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gV3JhcHBlcjtcbiAgfTtcbiAgLypcbiAgICBvcHRpb25zLnRhcmdldCAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICAgIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgICBvcHRpb25zLnN0YXQgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICAgIG9wdGlvbnMucHJvdG8gICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gICAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gICAgb3B0aW9ucy5mb3JjZWQgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgICBvcHRpb25zLmJpbmQgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gICAgb3B0aW9ucy51bnNhZmUgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICAgIG9wdGlvbnMuc2hhbSAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gICAgb3B0aW9ucy5ub1RhcmdldEdldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgICBvcHRpb25zLm5hbWUgICAgICAgIC0gdGhlIC5uYW1lIG9mIHRoZSBmdW5jdGlvbiBpZiBpdCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5XG4gICovXG5cblxuICB2YXIgX2V4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gICAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICAgIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gICAgdmFyIFBST1RPID0gb3B0aW9ucy5wcm90bztcbiAgICB2YXIgbmF0aXZlU291cmNlID0gR0xPQkFMID8gZ2xvYmFsJHYgOiBTVEFUSUMgPyBnbG9iYWwkdltUQVJHRVRdIDogKGdsb2JhbCR2W1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgICB2YXIgdGFyZ2V0ID0gR0xPQkFMID8gcGF0aCRvIDogcGF0aCRvW1RBUkdFVF0gfHwgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUocGF0aCRvLCBUQVJHRVQsIHt9KVtUQVJHRVRdO1xuICAgIHZhciB0YXJnZXRQcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgIHZhciBGT1JDRUQsIFVTRV9OQVRJVkUsIFZJUlRVQUxfUFJPVE9UWVBFO1xuICAgIHZhciBrZXksIHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSwgbmF0aXZlUHJvcGVydHksIHJlc3VsdFByb3BlcnR5LCBkZXNjcmlwdG9yO1xuXG4gICAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpOyAvLyBjb250YWlucyBpbiBuYXRpdmVcblxuICAgICAgVVNFX05BVElWRSA9ICFGT1JDRUQgJiYgbmF0aXZlU291cmNlICYmIGhhc093biRkKG5hdGl2ZVNvdXJjZSwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgICBpZiAoVVNFX05BVElWRSkgaWYgKG9wdGlvbnMubm9UYXJnZXRHZXQpIHtcbiAgICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ0KG5hdGl2ZVNvdXJjZSwga2V5KTtcbiAgICAgICAgbmF0aXZlUHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICB9IGVsc2UgbmF0aXZlUHJvcGVydHkgPSBuYXRpdmVTb3VyY2Vba2V5XTsgLy8gZXhwb3J0IG5hdGl2ZSBvciBpbXBsZW1lbnRhdGlvblxuXG4gICAgICBzb3VyY2VQcm9wZXJ0eSA9IFVTRV9OQVRJVkUgJiYgbmF0aXZlUHJvcGVydHkgPyBuYXRpdmVQcm9wZXJ0eSA6IHNvdXJjZVtrZXldO1xuICAgICAgaWYgKFVTRV9OQVRJVkUgJiYgdHlwZW9mIHRhcmdldFByb3BlcnR5ID09IHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSkgY29udGludWU7IC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG5cbiAgICAgIGlmIChvcHRpb25zLmJpbmQgJiYgVVNFX05BVElWRSkgcmVzdWx0UHJvcGVydHkgPSBiaW5kJGIoc291cmNlUHJvcGVydHksIGdsb2JhbCR2KTsgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5ncyBpbiB0aGlzIHZlcnNpb25cbiAgICAgIGVsc2UgaWYgKG9wdGlvbnMud3JhcCAmJiBVU0VfTkFUSVZFKSByZXN1bHRQcm9wZXJ0eSA9IHdyYXBDb25zdHJ1Y3Rvcihzb3VyY2VQcm9wZXJ0eSk7IC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgICAgZWxzZSBpZiAoUFJPVE8gJiYgaXNDYWxsYWJsZSRhKHNvdXJjZVByb3BlcnR5KSkgcmVzdWx0UHJvcGVydHkgPSB1bmN1cnJ5VGhpcyRtKHNvdXJjZVByb3BlcnR5KTsgLy8gZGVmYXVsdCBjYXNlXG4gICAgICBlbHNlIHJlc3VsdFByb3BlcnR5ID0gc291cmNlUHJvcGVydHk7IC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcblxuICAgICAgaWYgKG9wdGlvbnMuc2hhbSB8fCBzb3VyY2VQcm9wZXJ0eSAmJiBzb3VyY2VQcm9wZXJ0eS5zaGFtIHx8IHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pIHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUocmVzdWx0UHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHRhcmdldCwga2V5LCByZXN1bHRQcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChQUk9UTykge1xuICAgICAgICBWSVJUVUFMX1BST1RPVFlQRSA9IFRBUkdFVCArICdQcm90b3R5cGUnO1xuXG4gICAgICAgIGlmICghaGFzT3duJGQocGF0aCRvLCBWSVJUVUFMX1BST1RPVFlQRSkpIHtcbiAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNShwYXRoJG8sIFZJUlRVQUxfUFJPVE9UWVBFLCB7fSk7XG4gICAgICAgIH0gLy8gZXhwb3J0IHZpcnR1YWwgcHJvdG90eXBlIG1ldGhvZHNcblxuXG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHBhdGgkb1tWSVJUVUFMX1BST1RPVFlQRV0sIGtleSwgc291cmNlUHJvcGVydHkpOyAvLyBleHBvcnQgcmVhbCBwcm90b3R5cGUgbWV0aG9kc1xuXG4gICAgICAgIGlmIChvcHRpb25zLnJlYWwgJiYgdGFyZ2V0UHJvdG90eXBlICYmICF0YXJnZXRQcm90b3R5cGVba2V5XSkge1xuICAgICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHRhcmdldFByb3RvdHlwZSwga2V5LCBzb3VyY2VQcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyICQkQyA9IF9leHBvcnQ7XG4gIHZhciBERVNDUklQVE9SUyRjID0gZGVzY3JpcHRvcnM7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSRjID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjsgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuXG4gICQkQyh7XG4gICAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgICBzdGF0OiB0cnVlLFxuICAgIGZvcmNlZDogT2JqZWN0LmRlZmluZVByb3BlcnR5ICE9PSBkZWZpbmVQcm9wZXJ0eSRjLFxuICAgIHNoYW06ICFERVNDUklQVE9SUyRjXG4gIH0sIHtcbiAgICBkZWZpbmVQcm9wZXJ0eTogZGVmaW5lUHJvcGVydHkkY1xuICB9KTtcblxuICB2YXIgcGF0aCRuID0gcGF0aCRxO1xuICB2YXIgT2JqZWN0JDYgPSBwYXRoJG4uT2JqZWN0O1xuXG4gIHZhciBkZWZpbmVQcm9wZXJ0eSRiID0gZGVmaW5lUHJvcGVydHkkZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYykge1xuICAgIHJldHVybiBPYmplY3QkNi5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbiAgfTtcblxuICBpZiAoT2JqZWN0JDYuZGVmaW5lUHJvcGVydHkuc2hhbSkgZGVmaW5lUHJvcGVydHkkYi5zaGFtID0gdHJ1ZTtcblxuICB2YXIgcGFyZW50JFYgPSBkZWZpbmVQcm9wZXJ0eSRlLmV4cG9ydHM7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSRhID0gcGFyZW50JFY7XG5cbiAgdmFyIHBhcmVudCRVID0gZGVmaW5lUHJvcGVydHkkYTtcbiAgdmFyIGRlZmluZVByb3BlcnR5JDkgPSBwYXJlbnQkVTtcblxuICB2YXIgcGFyZW50JFQgPSBkZWZpbmVQcm9wZXJ0eSQ5O1xuICB2YXIgZGVmaW5lUHJvcGVydHkkOCA9IHBhcmVudCRUO1xuXG4gIHZhciBkZWZpbmVQcm9wZXJ0eSQ3ID0gZGVmaW5lUHJvcGVydHkkODtcblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG5cbiAgICAgIGRlZmluZVByb3BlcnR5JDcodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcblxuICAgIGRlZmluZVByb3BlcnR5JDcoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSQ3KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciB1bmN1cnJ5VGhpcyRsID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIGFycmF5U2xpY2UkNSA9IHVuY3VycnlUaGlzJGwoW10uc2xpY2UpO1xuXG4gIHZhciBnbG9iYWwkdSA9IGdsb2JhbCRNO1xuICB2YXIgdW5jdXJyeVRoaXMkayA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBhQ2FsbGFibGUkNCA9IGFDYWxsYWJsZSQ3O1xuICB2YXIgaXNPYmplY3QkYSA9IGlzT2JqZWN0JGY7XG4gIHZhciBoYXNPd24kYyA9IGhhc093blByb3BlcnR5XzE7XG4gIHZhciBhcnJheVNsaWNlJDQgPSBhcnJheVNsaWNlJDU7XG4gIHZhciBOQVRJVkVfQklORCA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcbiAgdmFyIEZ1bmN0aW9uJDIgPSBnbG9iYWwkdS5GdW5jdGlvbjtcbiAgdmFyIGNvbmNhdCQ2ID0gdW5jdXJyeVRoaXMkayhbXS5jb25jYXQpO1xuICB2YXIgam9pbiA9IHVuY3VycnlUaGlzJGsoW10uam9pbik7XG4gIHZhciBmYWN0b3JpZXMgPSB7fTtcblxuICB2YXIgY29uc3RydWN0JDQgPSBmdW5jdGlvbiAoQywgYXJnc0xlbmd0aCwgYXJncykge1xuICAgIGlmICghaGFzT3duJGMoZmFjdG9yaWVzLCBhcmdzTGVuZ3RoKSkge1xuICAgICAgZm9yICh2YXIgbGlzdCA9IFtdLCBpID0gMDsgaSA8IGFyZ3NMZW5ndGg7IGkrKykgbGlzdFtpXSA9ICdhWycgKyBpICsgJ10nO1xuXG4gICAgICBmYWN0b3JpZXNbYXJnc0xlbmd0aF0gPSBGdW5jdGlvbiQyKCdDLGEnLCAncmV0dXJuIG5ldyBDKCcgKyBqb2luKGxpc3QsICcsJykgKyAnKScpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWN0b3JpZXNbYXJnc0xlbmd0aF0oQywgYXJncyk7XG4gIH07IC8vIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcblxuXG4gIHZhciBmdW5jdGlvbkJpbmQgPSBOQVRJVkVfQklORCA/IEZ1bmN0aW9uJDIuYmluZCA6IGZ1bmN0aW9uIGJpbmQodGhhdFxuICAvKiAsIC4uLmFyZ3MgKi9cbiAgKSB7XG4gICAgdmFyIEYgPSBhQ2FsbGFibGUkNCh0aGlzKTtcbiAgICB2YXIgUHJvdG90eXBlID0gRi5wcm90b3R5cGU7XG4gICAgdmFyIHBhcnRBcmdzID0gYXJyYXlTbGljZSQ0KGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGZ1bmN0aW9uXG4gICAgICAvKiBhcmdzLi4uICovXG4gICAgYm91bmQoKSB7XG4gICAgICB2YXIgYXJncyA9IGNvbmNhdCQ2KHBhcnRBcmdzLCBhcnJheVNsaWNlJDQoYXJndW1lbnRzKSk7XG4gICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kRnVuY3Rpb24gPyBjb25zdHJ1Y3QkNChGLCBhcmdzLmxlbmd0aCwgYXJncykgOiBGLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBpZiAoaXNPYmplY3QkYShQcm90b3R5cGUpKSBib3VuZEZ1bmN0aW9uLnByb3RvdHlwZSA9IFByb3RvdHlwZTtcbiAgICByZXR1cm4gYm91bmRGdW5jdGlvbjtcbiAgfTtcblxuICB2YXIgJCRCID0gX2V4cG9ydDtcbiAgdmFyIGJpbmQkYSA9IGZ1bmN0aW9uQmluZDsgLy8gYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuXG4gICQkQih7XG4gICAgdGFyZ2V0OiAnRnVuY3Rpb24nLFxuICAgIHByb3RvOiB0cnVlLFxuICAgIGZvcmNlZDogRnVuY3Rpb24uYmluZCAhPT0gYmluZCRhXG4gIH0sIHtcbiAgICBiaW5kOiBiaW5kJGFcbiAgfSk7XG5cbiAgdmFyIHBhdGgkbSA9IHBhdGgkcTtcblxuICB2YXIgZW50cnlWaXJ0dWFsJGsgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1IpIHtcbiAgICByZXR1cm4gcGF0aCRtW0NPTlNUUlVDVE9SICsgJ1Byb3RvdHlwZSddO1xuICB9O1xuXG4gIHZhciBlbnRyeVZpcnR1YWwkaiA9IGVudHJ5VmlydHVhbCRrO1xuICB2YXIgYmluZCQ5ID0gZW50cnlWaXJ0dWFsJGooJ0Z1bmN0aW9uJykuYmluZDtcblxuICB2YXIgaXNQcm90b3R5cGVPZiRoID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbiAgdmFyIG1ldGhvZCRlID0gYmluZCQ5O1xuICB2YXIgRnVuY3Rpb25Qcm90b3R5cGUkMSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICB2YXIgYmluZCQ4ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIG93biA9IGl0LmJpbmQ7XG4gICAgcmV0dXJuIGl0ID09PSBGdW5jdGlvblByb3RvdHlwZSQxIHx8IGlzUHJvdG90eXBlT2YkaChGdW5jdGlvblByb3RvdHlwZSQxLCBpdCkgJiYgb3duID09PSBGdW5jdGlvblByb3RvdHlwZSQxLmJpbmQgPyBtZXRob2QkZSA6IG93bjtcbiAgfTtcblxuICB2YXIgcGFyZW50JFMgPSBiaW5kJDg7XG4gIHZhciBiaW5kJDcgPSBwYXJlbnQkUztcblxuICB2YXIgYmluZCQ2ID0gYmluZCQ3O1xuXG4gIHZhciBjZWlsID0gTWF0aC5jZWlsO1xuICB2YXIgZmxvb3IkMSA9IE1hdGguZmxvb3I7IC8vIGBUb0ludGVnZXJPckluZmluaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG5cbiAgdmFyIHRvSW50ZWdlck9ySW5maW5pdHkkNCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgIHZhciBudW1iZXIgPSArYXJndW1lbnQ7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gc2FmZVxuXG4gICAgcmV0dXJuIG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gMCA/IDAgOiAobnVtYmVyID4gMCA/IGZsb29yJDEgOiBjZWlsKShudW1iZXIpO1xuICB9O1xuXG4gIHZhciB0b0ludGVnZXJPckluZmluaXR5JDMgPSB0b0ludGVnZXJPckluZmluaXR5JDQ7XG4gIHZhciBtaW4kMiA9IE1hdGgubWluOyAvLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG5cbiAgdmFyIHRvTGVuZ3RoJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluJDIodG9JbnRlZ2VyT3JJbmZpbml0eSQzKGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG4gIH07XG5cbiAgdmFyIHRvTGVuZ3RoID0gdG9MZW5ndGgkMTsgLy8gYExlbmd0aE9mQXJyYXlMaWtlYCBhYnN0cmFjdCBvcGVyYXRpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxuXG4gIHZhciBsZW5ndGhPZkFycmF5TGlrZSRkID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgZ2xvYmFsJHQgPSBnbG9iYWwkTTtcbiAgdmFyIGFDYWxsYWJsZSQzID0gYUNhbGxhYmxlJDc7XG4gIHZhciB0b09iamVjdCRjID0gdG9PYmplY3QkZTtcbiAgdmFyIEluZGV4ZWRPYmplY3QkMiA9IGluZGV4ZWRPYmplY3Q7XG4gIHZhciBsZW5ndGhPZkFycmF5TGlrZSRjID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbiAgdmFyIFR5cGVFcnJvciRkID0gZ2xvYmFsJHQuVHlwZUVycm9yOyAvLyBgQXJyYXkucHJvdG90eXBlLnsgcmVkdWNlLCByZWR1Y2VSaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cbiAgdmFyIGNyZWF0ZU1ldGhvZCQ1ID0gZnVuY3Rpb24gKElTX1JJR0hUKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhcmd1bWVudHNMZW5ndGgsIG1lbW8pIHtcbiAgICAgIGFDYWxsYWJsZSQzKGNhbGxiYWNrZm4pO1xuICAgICAgdmFyIE8gPSB0b09iamVjdCRjKHRoYXQpO1xuICAgICAgdmFyIHNlbGYgPSBJbmRleGVkT2JqZWN0JDIoTyk7XG4gICAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkYyhPKTtcbiAgICAgIHZhciBpbmRleCA9IElTX1JJR0hUID8gbGVuZ3RoIC0gMSA6IDA7XG4gICAgICB2YXIgaSA9IElTX1JJR0hUID8gLTEgOiAxO1xuICAgICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA8IDIpIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgICAgIGluZGV4ICs9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCArPSBpO1xuXG4gICAgICAgIGlmIChJU19SSUdIVCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvciRkKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IElTX1JJR0hUID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKSBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIHZhciBhcnJheVJlZHVjZSA9IHtcbiAgICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4gICAgbGVmdDogY3JlYXRlTWV0aG9kJDUoZmFsc2UpLFxuICAgIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHRgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG4gICAgcmlnaHQ6IGNyZWF0ZU1ldGhvZCQ1KHRydWUpXG4gIH07XG5cbiAgdmFyIGZhaWxzJGogPSBmYWlscyRyO1xuXG4gIHZhciBhcnJheU1ldGhvZElzU3RyaWN0JDUgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUsIGFyZ3VtZW50KSB7XG4gICAgdmFyIG1ldGhvZCA9IFtdW01FVEhPRF9OQU1FXTtcbiAgICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMkaihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgICBtZXRob2QuY2FsbChudWxsLCBhcmd1bWVudCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSwgMSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGNsYXNzb2YkZSA9IGNsYXNzb2ZSYXckMTtcbiAgdmFyIGdsb2JhbCRzID0gZ2xvYmFsJE07XG4gIHZhciBlbmdpbmVJc05vZGUgPSBjbGFzc29mJGUoZ2xvYmFsJHMucHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG4gIHZhciAkJEEgPSBfZXhwb3J0O1xuICB2YXIgJHJlZHVjZSA9IGFycmF5UmVkdWNlLmxlZnQ7XG4gIHZhciBhcnJheU1ldGhvZElzU3RyaWN0JDQgPSBhcnJheU1ldGhvZElzU3RyaWN0JDU7XG4gIHZhciBDSFJPTUVfVkVSU0lPTiA9IGVuZ2luZVY4VmVyc2lvbjtcbiAgdmFyIElTX05PREUgPSBlbmdpbmVJc05vZGU7XG4gIHZhciBTVFJJQ1RfTUVUSE9EJDQgPSBhcnJheU1ldGhvZElzU3RyaWN0JDQoJ3JlZHVjZScpOyAvLyBDaHJvbWUgODAtODIgaGFzIGEgY3JpdGljYWwgYnVnXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwNDk5ODJcblxuICB2YXIgQ0hST01FX0JVRyA9ICFJU19OT0RFICYmIENIUk9NRV9WRVJTSU9OID4gNzkgJiYgQ0hST01FX1ZFUlNJT04gPCA4MzsgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcblxuICAkJEEoe1xuICAgIHRhcmdldDogJ0FycmF5JyxcbiAgICBwcm90bzogdHJ1ZSxcbiAgICBmb3JjZWQ6ICFTVFJJQ1RfTUVUSE9EJDQgfHwgQ0hST01FX0JVR1xuICB9LCB7XG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmblxuICAgIC8qICwgaW5pdGlhbFZhbHVlICovXG4gICAgKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGxlbmd0aCwgbGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZW50cnlWaXJ0dWFsJGkgPSBlbnRyeVZpcnR1YWwkaztcbiAgdmFyIHJlZHVjZSQzID0gZW50cnlWaXJ0dWFsJGkoJ0FycmF5JykucmVkdWNlO1xuXG4gIHZhciBpc1Byb3RvdHlwZU9mJGcgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuICB2YXIgbWV0aG9kJGQgPSByZWR1Y2UkMztcbiAgdmFyIEFycmF5UHJvdG90eXBlJGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgdmFyIHJlZHVjZSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIG93biA9IGl0LnJlZHVjZTtcbiAgICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJGUgfHwgaXNQcm90b3R5cGVPZiRnKEFycmF5UHJvdG90eXBlJGUsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGUucmVkdWNlID8gbWV0aG9kJGQgOiBvd247XG4gIH07XG5cbiAgdmFyIHBhcmVudCRSID0gcmVkdWNlJDI7XG4gIHZhciByZWR1Y2UkMSA9IHBhcmVudCRSO1xuXG4gIHZhciByZWR1Y2UgPSByZWR1Y2UkMTtcblxuICB2YXIgY2xhc3NvZiRkID0gY2xhc3NvZlJhdyQxOyAvLyBgSXNBcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNhcnJheVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktaXNhcnJheSAtLSBzYWZlXG5cbiAgdmFyIGlzQXJyYXkkZCA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmd1bWVudCkge1xuICAgIHJldHVybiBjbGFzc29mJGQoYXJndW1lbnQpID09ICdBcnJheSc7XG4gIH07XG5cbiAgdmFyIHdlbGxLbm93blN5bWJvbCRoID0gd2VsbEtub3duU3ltYm9sJGo7XG4gIHZhciBUT19TVFJJTkdfVEFHJDMgPSB3ZWxsS25vd25TeW1ib2wkaCgndG9TdHJpbmdUYWcnKTtcbiAgdmFyIHRlc3QkMiA9IHt9O1xuICB0ZXN0JDJbVE9fU1RSSU5HX1RBRyQzXSA9ICd6JztcbiAgdmFyIHRvU3RyaW5nVGFnU3VwcG9ydCA9IFN0cmluZyh0ZXN0JDIpID09PSAnW29iamVjdCB6XSc7XG5cbiAgdmFyIGdsb2JhbCRyID0gZ2xvYmFsJE07XG4gIHZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQkMiA9IHRvU3RyaW5nVGFnU3VwcG9ydDtcbiAgdmFyIGlzQ2FsbGFibGUkOSA9IGlzQ2FsbGFibGUkaDtcbiAgdmFyIGNsYXNzb2ZSYXcgPSBjbGFzc29mUmF3JDE7XG4gIHZhciB3ZWxsS25vd25TeW1ib2wkZyA9IHdlbGxLbm93blN5bWJvbCRqO1xuICB2YXIgVE9fU1RSSU5HX1RBRyQyID0gd2VsbEtub3duU3ltYm9sJGcoJ3RvU3RyaW5nVGFnJyk7XG4gIHZhciBPYmplY3QkNSA9IGdsb2JhbCRyLk9iamVjdDsgLy8gRVMzIHdyb25nIGhlcmVcblxuICB2YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzO1xuICB9KCkpID09ICdBcmd1bWVudHMnOyAvLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxuXG4gIHZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gaXRba2V5XTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLyogZW1wdHkgKi9cbiAgICB9XG4gIH07IC8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BcblxuXG4gIHZhciBjbGFzc29mJGMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQkMiA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gICAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9IE9iamVjdCQ1KGl0KSwgVE9fU1RSSU5HX1RBRyQyKSkgPT0gJ3N0cmluZycgPyB0YWcgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTykgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUkOShPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbiAgfTtcblxuICB2YXIgdW5jdXJyeVRoaXMkaiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBpc0NhbGxhYmxlJDggPSBpc0NhbGxhYmxlJGg7XG4gIHZhciBzdG9yZSQxID0gc2hhcmVkU3RvcmU7XG4gIHZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMkaihGdW5jdGlvbi50b1N0cmluZyk7IC8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcblxuICBpZiAoIWlzQ2FsbGFibGUkOChzdG9yZSQxLmluc3BlY3RTb3VyY2UpKSB7XG4gICAgc3RvcmUkMS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZyhpdCk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpbnNwZWN0U291cmNlJDIgPSBzdG9yZSQxLmluc3BlY3RTb3VyY2U7XG5cbiAgdmFyIHVuY3VycnlUaGlzJGkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgZmFpbHMkaSA9IGZhaWxzJHI7XG4gIHZhciBpc0NhbGxhYmxlJDcgPSBpc0NhbGxhYmxlJGg7XG4gIHZhciBjbGFzc29mJGIgPSBjbGFzc29mJGM7XG4gIHZhciBnZXRCdWlsdEluJDYgPSBnZXRCdWlsdEluJDk7XG4gIHZhciBpbnNwZWN0U291cmNlJDEgPSBpbnNwZWN0U291cmNlJDI7XG5cbiAgdmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfTtcblxuICB2YXIgZW1wdHkgPSBbXTtcbiAgdmFyIGNvbnN0cnVjdCQzID0gZ2V0QnVpbHRJbiQ2KCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xuICB2YXIgY29uc3RydWN0b3JSZWdFeHAgPSAvXlxccyooPzpjbGFzc3xmdW5jdGlvbilcXGIvO1xuICB2YXIgZXhlYyQyID0gdW5jdXJyeVRoaXMkaShjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKTtcbiAgdmFyIElOQ09SUkVDVF9UT19TVFJJTkcgPSAhY29uc3RydWN0b3JSZWdFeHAuZXhlYyhub29wKTtcblxuICB2YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgICBpZiAoIWlzQ2FsbGFibGUkNyhhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdHJ1Y3QkMyhub29wLCBlbXB0eSwgYXJndW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzQ29uc3RydWN0b3JMZWdhY3kgPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gICAgaWYgKCFpc0NhbGxhYmxlJDcoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBzd2l0Y2ggKGNsYXNzb2YkYihhcmd1bWVudCkpIHtcbiAgICAgIGNhc2UgJ0FzeW5jRnVuY3Rpb24nOlxuICAgICAgY2FzZSAnR2VuZXJhdG9yRnVuY3Rpb24nOlxuICAgICAgY2FzZSAnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbic6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICAgICAgLy8gYEZ1bmN0aW9uI3RvU3RyaW5nYCB0aHJvd3Mgb24gc29tZSBidWlsdC1pdCBmdW5jdGlvbiBpbiBzb21lIGxlZ2FjeSBlbmdpbmVzXG4gICAgICAvLyAoZm9yIGV4YW1wbGUsIGBET01RdWFkYCBhbmQgc2ltaWxhciBpbiBGRjQxLSlcbiAgICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyQyKGNvbnN0cnVjdG9yUmVnRXhwLCBpbnNwZWN0U291cmNlJDEoYXJndW1lbnQpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuXG4gIGlzQ29uc3RydWN0b3JMZWdhY3kuc2hhbSA9IHRydWU7IC8vIGBJc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXG5cbiAgdmFyIGlzQ29uc3RydWN0b3IkNCA9ICFjb25zdHJ1Y3QkMyB8fCBmYWlscyRpKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FsbGVkO1xuICAgIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbCkgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KSB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgIH0pIHx8IGNhbGxlZDtcbiAgfSkgPyBpc0NvbnN0cnVjdG9yTGVnYWN5IDogaXNDb25zdHJ1Y3Rvck1vZGVybjtcblxuICB2YXIgZ2xvYmFsJHEgPSBnbG9iYWwkTTtcbiAgdmFyIGlzQXJyYXkkYyA9IGlzQXJyYXkkZDtcbiAgdmFyIGlzQ29uc3RydWN0b3IkMyA9IGlzQ29uc3RydWN0b3IkNDtcbiAgdmFyIGlzT2JqZWN0JDkgPSBpc09iamVjdCRmO1xuICB2YXIgd2VsbEtub3duU3ltYm9sJGYgPSB3ZWxsS25vd25TeW1ib2wkajtcbiAgdmFyIFNQRUNJRVMkMyA9IHdlbGxLbm93blN5bWJvbCRmKCdzcGVjaWVzJyk7XG4gIHZhciBBcnJheSQ1ID0gZ2xvYmFsJHEuQXJyYXk7IC8vIGEgcGFydCBvZiBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcblxuICB2YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5KSB7XG4gICAgdmFyIEM7XG5cbiAgICBpZiAoaXNBcnJheSRjKG9yaWdpbmFsQXJyYXkpKSB7XG4gICAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjsgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcblxuICAgICAgaWYgKGlzQ29uc3RydWN0b3IkMyhDKSAmJiAoQyA9PT0gQXJyYXkkNSB8fCBpc0FycmF5JGMoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtlbHNlIGlmIChpc09iamVjdCQ5KEMpKSB7XG4gICAgICAgIEMgPSBDW1NQRUNJRVMkM107XG4gICAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSQ1IDogQztcbiAgfTtcblxuICB2YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IgPSBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciQxOyAvLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcblxuICB2YXIgYXJyYXlTcGVjaWVzQ3JlYXRlJDQgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyAoYXJyYXlTcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWxBcnJheSkpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBiaW5kJDUgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xuICB2YXIgdW5jdXJyeVRoaXMkaCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBJbmRleGVkT2JqZWN0JDEgPSBpbmRleGVkT2JqZWN0O1xuICB2YXIgdG9PYmplY3QkYiA9IHRvT2JqZWN0JGU7XG4gIHZhciBsZW5ndGhPZkFycmF5TGlrZSRiID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbiAgdmFyIGFycmF5U3BlY2llc0NyZWF0ZSQzID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDQ7XG4gIHZhciBwdXNoJDUgPSB1bmN1cnJ5VGhpcyRoKFtdLnB1c2gpOyAvLyBgQXJyYXkucHJvdG90eXBlLnsgZm9yRWFjaCwgbWFwLCBmaWx0ZXIsIHNvbWUsIGV2ZXJ5LCBmaW5kLCBmaW5kSW5kZXgsIGZpbHRlclJlamVjdCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cbiAgdmFyIGNyZWF0ZU1ldGhvZCQ0ID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICAgIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gICAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gICAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICAgIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICAgIHZhciBJU19GSUxURVJfUkVKRUNUID0gVFlQRSA9PSA3O1xuICAgIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICAgIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQsIHNwZWNpZmljQ3JlYXRlKSB7XG4gICAgICB2YXIgTyA9IHRvT2JqZWN0JGIoJHRoaXMpO1xuICAgICAgdmFyIHNlbGYgPSBJbmRleGVkT2JqZWN0JDEoTyk7XG4gICAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQkNShjYWxsYmFja2ZuLCB0aGF0KTtcbiAgICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSRiKHNlbGYpO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBjcmVhdGUgPSBzcGVjaWZpY0NyZWF0ZSB8fCBhcnJheVNwZWNpZXNDcmVhdGUkMztcbiAgICAgIHZhciB0YXJnZXQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgfHwgSVNfRklMVEVSX1JFSkVDVCA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgdmFsdWUsIHJlc3VsdDtcblxuICAgICAgZm9yICg7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgICB2YWx1ZSA9IHNlbGZbaW5kZXhdO1xuICAgICAgICByZXN1bHQgPSBib3VuZEZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgTyk7XG5cbiAgICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgICBpZiAoSVNfTUFQKSB0YXJnZXRbaW5kZXhdID0gcmVzdWx0OyAvLyBtYXBcbiAgICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHNvbWVcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvLyBmaW5kXG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgLy8gZmluZEluZGV4XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcHVzaCQ1KHRhcmdldCwgdmFsdWUpO1xuICAgICAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgICAgfSBlbHNlIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyBldmVyeVxuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHB1c2gkNSh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgICAgIC8vIGZpbHRlclJlamVjdFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGFycmF5SXRlcmF0aW9uID0ge1xuICAgIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuICAgIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCQ0KDApLFxuICAgIC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcbiAgICBtYXA6IGNyZWF0ZU1ldGhvZCQ0KDEpLFxuICAgIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgICBmaWx0ZXI6IGNyZWF0ZU1ldGhvZCQ0KDIpLFxuICAgIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuICAgIHNvbWU6IGNyZWF0ZU1ldGhvZCQ0KDMpLFxuICAgIC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmV2ZXJ5XG4gICAgZXZlcnk6IGNyZWF0ZU1ldGhvZCQ0KDQpLFxuICAgIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuICAgIGZpbmQ6IGNyZWF0ZU1ldGhvZCQ0KDUpLFxuICAgIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcbiAgICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCQ0KDYpLFxuICAgIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyUmVqZWN0YCBtZXRob2RcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hcnJheS1maWx0ZXJpbmdcbiAgICBmaWx0ZXJSZWplY3Q6IGNyZWF0ZU1ldGhvZCQ0KDcpXG4gIH07XG5cbiAgdmFyIGZhaWxzJGggPSBmYWlscyRyO1xuICB2YXIgd2VsbEtub3duU3ltYm9sJGUgPSB3ZWxsS25vd25TeW1ib2wkajtcbiAgdmFyIFY4X1ZFUlNJT04kMSA9IGVuZ2luZVY4VmVyc2lvbjtcbiAgdmFyIFNQRUNJRVMkMiA9IHdlbGxLbm93blN5bWJvbCRlKCdzcGVjaWVzJyk7XG5cbiAgdmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNSA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICAgIC8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuICAgIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3N1xuICAgIHJldHVybiBWOF9WRVJTSU9OJDEgPj0gNTEgfHwgIWZhaWxzJGgoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICB2YXIgY29uc3RydWN0b3IgPSBhcnJheS5jb25zdHJ1Y3RvciA9IHt9O1xuXG4gICAgICBjb25zdHJ1Y3RvcltTUEVDSUVTJDJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZvbzogMVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGFycmF5W01FVEhPRF9OQU1FXShCb29sZWFuKS5mb28gIT09IDE7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyICQkeiA9IF9leHBvcnQ7XG4gIHZhciAkZmlsdGVyID0gYXJyYXlJdGVyYXRpb24uZmlsdGVyO1xuICB2YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ0ID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ1O1xuICB2YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCQzID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ0KCdmaWx0ZXInKTsgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcblxuICAkJHooe1xuICAgIHRhcmdldDogJ0FycmF5JyxcbiAgICBwcm90bzogdHJ1ZSxcbiAgICBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUJDNcbiAgfSwge1xuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm5cbiAgICAvKiAsIHRoaXNBcmcgKi9cbiAgICApIHtcbiAgICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBlbnRyeVZpcnR1YWwkaCA9IGVudHJ5VmlydHVhbCRrO1xuICB2YXIgZmlsdGVyJDMgPSBlbnRyeVZpcnR1YWwkaCgnQXJyYXknKS5maWx0ZXI7XG5cbiAgdmFyIGlzUHJvdG90eXBlT2YkZiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG4gIHZhciBtZXRob2QkYyA9IGZpbHRlciQzO1xuICB2YXIgQXJyYXlQcm90b3R5cGUkZCA9IEFycmF5LnByb3RvdHlwZTtcblxuICB2YXIgZmlsdGVyJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgb3duID0gaXQuZmlsdGVyO1xuICAgIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkZCB8fCBpc1Byb3RvdHlwZU9mJGYoQXJyYXlQcm90b3R5cGUkZCwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkZC5maWx0ZXIgPyBtZXRob2QkYyA6IG93bjtcbiAgfTtcblxuICB2YXIgcGFyZW50JFEgPSBmaWx0ZXIkMjtcbiAgdmFyIGZpbHRlciQxID0gcGFyZW50JFE7XG5cbiAgdmFyIGZpbHRlciA9IGZpbHRlciQxO1xuXG4gIHZhciAkJHkgPSBfZXhwb3J0O1xuICB2YXIgJG1hcCA9IGFycmF5SXRlcmF0aW9uLm1hcDtcbiAgdmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMyA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNTtcbiAgdmFyIEhBU19TUEVDSUVTX1NVUFBPUlQkMiA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMygnbWFwJyk7IC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4gIC8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG5cbiAgJCR5KHtcbiAgICB0YXJnZXQ6ICdBcnJheScsXG4gICAgcHJvdG86IHRydWUsXG4gICAgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCQyXG4gIH0sIHtcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuXG4gICAgLyogLCB0aGlzQXJnICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZW50cnlWaXJ0dWFsJGcgPSBlbnRyeVZpcnR1YWwkaztcbiAgdmFyIG1hcCQ2ID0gZW50cnlWaXJ0dWFsJGcoJ0FycmF5JykubWFwO1xuXG4gIHZhciBpc1Byb3RvdHlwZU9mJGUgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuICB2YXIgbWV0aG9kJGIgPSBtYXAkNjtcbiAgdmFyIEFycmF5UHJvdG90eXBlJGMgPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgdmFyIG1hcCQ1ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIG93biA9IGl0Lm1hcDtcbiAgICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJGMgfHwgaXNQcm90b3R5cGVPZiRlKEFycmF5UHJvdG90eXBlJGMsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGMubWFwID8gbWV0aG9kJGIgOiBvd247XG4gIH07XG5cbiAgdmFyIHBhcmVudCRQID0gbWFwJDU7XG4gIHZhciBtYXAkNCA9IHBhcmVudCRQO1xuXG4gIHZhciBtYXAkMyA9IG1hcCQ0O1xuXG4gIHZhciBnbG9iYWwkcCA9IGdsb2JhbCRNO1xuICB2YXIgaXNBcnJheSRiID0gaXNBcnJheSRkO1xuICB2YXIgbGVuZ3RoT2ZBcnJheUxpa2UkYSA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG4gIHZhciBiaW5kJDQgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xuICB2YXIgVHlwZUVycm9yJGMgPSBnbG9iYWwkcC5UeXBlRXJyb3I7IC8vIGBGbGF0dGVuSW50b0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtRmxhdHRlbkludG9BcnJheVxuXG4gIHZhciBmbGF0dGVuSW50b0FycmF5JDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBvcmlnaW5hbCwgc291cmNlLCBzb3VyY2VMZW4sIHN0YXJ0LCBkZXB0aCwgbWFwcGVyLCB0aGlzQXJnKSB7XG4gICAgdmFyIHRhcmdldEluZGV4ID0gc3RhcnQ7XG4gICAgdmFyIHNvdXJjZUluZGV4ID0gMDtcbiAgICB2YXIgbWFwRm4gPSBtYXBwZXIgPyBiaW5kJDQobWFwcGVyLCB0aGlzQXJnKSA6IGZhbHNlO1xuICAgIHZhciBlbGVtZW50LCBlbGVtZW50TGVuO1xuXG4gICAgd2hpbGUgKHNvdXJjZUluZGV4IDwgc291cmNlTGVuKSB7XG4gICAgICBpZiAoc291cmNlSW5kZXggaW4gc291cmNlKSB7XG4gICAgICAgIGVsZW1lbnQgPSBtYXBGbiA/IG1hcEZuKHNvdXJjZVtzb3VyY2VJbmRleF0sIHNvdXJjZUluZGV4LCBvcmlnaW5hbCkgOiBzb3VyY2Vbc291cmNlSW5kZXhdO1xuXG4gICAgICAgIGlmIChkZXB0aCA+IDAgJiYgaXNBcnJheSRiKGVsZW1lbnQpKSB7XG4gICAgICAgICAgZWxlbWVudExlbiA9IGxlbmd0aE9mQXJyYXlMaWtlJGEoZWxlbWVudCk7XG4gICAgICAgICAgdGFyZ2V0SW5kZXggPSBmbGF0dGVuSW50b0FycmF5JDEodGFyZ2V0LCBvcmlnaW5hbCwgZWxlbWVudCwgZWxlbWVudExlbiwgdGFyZ2V0SW5kZXgsIGRlcHRoIC0gMSkgLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0YXJnZXRJbmRleCA+PSAweDFGRkZGRkZGRkZGRkZGKSB0aHJvdyBUeXBlRXJyb3IkYygnRXhjZWVkIHRoZSBhY2NlcHRhYmxlIGFycmF5IGxlbmd0aCcpO1xuICAgICAgICAgIHRhcmdldFt0YXJnZXRJbmRleF0gPSBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0SW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgc291cmNlSW5kZXgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0SW5kZXg7XG4gIH07XG5cbiAgdmFyIGZsYXR0ZW5JbnRvQXJyYXlfMSA9IGZsYXR0ZW5JbnRvQXJyYXkkMTtcblxuICB2YXIgJCR4ID0gX2V4cG9ydDtcbiAgdmFyIGZsYXR0ZW5JbnRvQXJyYXkgPSBmbGF0dGVuSW50b0FycmF5XzE7XG4gIHZhciBhQ2FsbGFibGUkMiA9IGFDYWxsYWJsZSQ3O1xuICB2YXIgdG9PYmplY3QkYSA9IHRvT2JqZWN0JGU7XG4gIHZhciBsZW5ndGhPZkFycmF5TGlrZSQ5ID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbiAgdmFyIGFycmF5U3BlY2llc0NyZWF0ZSQyID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDQ7IC8vIGBBcnJheS5wcm90b3R5cGUuZmxhdE1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZsYXRtYXBcblxuICAkJHgoe1xuICAgIHRhcmdldDogJ0FycmF5JyxcbiAgICBwcm90bzogdHJ1ZVxuICB9LCB7XG4gICAgZmxhdE1hcDogZnVuY3Rpb24gZmxhdE1hcChjYWxsYmFja2ZuXG4gICAgLyogLCB0aGlzQXJnICovXG4gICAgKSB7XG4gICAgICB2YXIgTyA9IHRvT2JqZWN0JGEodGhpcyk7XG4gICAgICB2YXIgc291cmNlTGVuID0gbGVuZ3RoT2ZBcnJheUxpa2UkOShPKTtcbiAgICAgIHZhciBBO1xuICAgICAgYUNhbGxhYmxlJDIoY2FsbGJhY2tmbik7XG4gICAgICBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDIoTywgMCk7XG4gICAgICBBLmxlbmd0aCA9IGZsYXR0ZW5JbnRvQXJyYXkoQSwgTywgTywgc291cmNlTGVuLCAwLCAxLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gQTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBlbnRyeVZpcnR1YWwkZiA9IGVudHJ5VmlydHVhbCRrO1xuICB2YXIgZmxhdE1hcCQzID0gZW50cnlWaXJ0dWFsJGYoJ0FycmF5JykuZmxhdE1hcDtcblxuICB2YXIgaXNQcm90b3R5cGVPZiRkID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbiAgdmFyIG1ldGhvZCRhID0gZmxhdE1hcCQzO1xuICB2YXIgQXJyYXlQcm90b3R5cGUkYiA9IEFycmF5LnByb3RvdHlwZTtcblxuICB2YXIgZmxhdE1hcCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIG93biA9IGl0LmZsYXRNYXA7XG4gICAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRiIHx8IGlzUHJvdG90eXBlT2YkZChBcnJheVByb3RvdHlwZSRiLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRiLmZsYXRNYXAgPyBtZXRob2QkYSA6IG93bjtcbiAgfTtcblxuICB2YXIgcGFyZW50JE8gPSBmbGF0TWFwJDI7XG4gIHZhciBmbGF0TWFwJDEgPSBwYXJlbnQkTztcblxuICB2YXIgZmxhdE1hcCA9IGZsYXRNYXAkMTtcblxuICAvKipcclxuICAgKiBDcmVhdGUgbmV3IGRhdGEgcGlwZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHNvdXJjZSBkYXRhIHNldCBvciBkYXRhIHZpZXcuXHJcbiAgICogQHJlbWFya3NcclxuICAgKiBFeGFtcGxlIHVzYWdlOlxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiBpbnRlcmZhY2UgQXBwSXRlbSB7XHJcbiAgICogICB3aG9hbWk6IHN0cmluZztcclxuICAgKiAgIGFwcERhdGE6IHVua25vd247XHJcbiAgICogICB2aXNEYXRhOiBWaXNJdGVtO1xyXG4gICAqIH1cclxuICAgKiBpbnRlcmZhY2UgVmlzSXRlbSB7XHJcbiAgICogICBpZDogbnVtYmVyO1xyXG4gICAqICAgbGFiZWw6IHN0cmluZztcclxuICAgKiAgIGNvbG9yOiBzdHJpbmc7XHJcbiAgICogICB4OiBudW1iZXI7XHJcbiAgICogICB5OiBudW1iZXI7XHJcbiAgICogfVxyXG4gICAqXHJcbiAgICogY29uc3QgZHMxID0gbmV3IERhdGFTZXQ8QXBwSXRlbSwgXCJ3aG9hbWlcIj4oW10sIHsgZmllbGRJZDogXCJ3aG9hbWlcIiB9KTtcclxuICAgKiBjb25zdCBkczIgPSBuZXcgRGF0YVNldDxWaXNJdGVtLCBcImlkXCI+KCk7XHJcbiAgICpcclxuICAgKiBjb25zdCBwaXBlID0gY3JlYXRlTmV3RGF0YVBpcGVGcm9tKGRzMSlcclxuICAgKiAgIC5maWx0ZXIoKGl0ZW0pOiBib29sZWFuID0+IGl0ZW0uZW5hYmxlZCA9PT0gdHJ1ZSlcclxuICAgKiAgIC5tYXA8VmlzSXRlbSwgXCJpZFwiPigoaXRlbSk6IFZpc0l0ZW0gPT4gaXRlbS52aXNEYXRhKVxyXG4gICAqICAgLnRvKGRzMik7XHJcbiAgICpcclxuICAgKiBwaXBlLnN0YXJ0KCk7XHJcbiAgICogYGBgXHJcbiAgICogQHJldHVybnMgQSBmYWN0b3J5IHdob3NlIG1ldGhvZHMgY2FuIGJlIHVzZWQgdG8gY29uZmlndXJlIHRoZSBwaXBlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVOZXdEYXRhUGlwZUZyb20oZnJvbSkge1xuICAgIHJldHVybiBuZXcgRGF0YVBpcGVVbmRlckNvbnN0cnVjdGlvbihmcm9tKTtcbiAgfVxuICAvKipcclxuICAgKiBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgcGlwZS4gVGhpcyBzaG91bGQgYmUgYWNjZXNzaWJsZSBvbmx5IHRocm91Z2hcclxuICAgKiBgY3JlYXRlTmV3RGF0YVBpcGVGcm9tYCBmcm9tIHRoZSBvdXRzaWRlLlxyXG4gICAqXHJcbiAgICogQHR5cGVQYXJhbSBTSSAtIFNvdXJjZSBpdGVtIHR5cGUuXHJcbiAgICogQHR5cGVQYXJhbSBTUCAtIFNvdXJjZSBpdGVtIHR5cGUncyBpZCBwcm9wZXJ0eSBuYW1lLlxyXG4gICAqIEB0eXBlUGFyYW0gVEkgLSBUYXJnZXQgaXRlbSB0eXBlLlxyXG4gICAqIEB0eXBlUGFyYW0gVFAgLSBUYXJnZXQgaXRlbSB0eXBlJ3MgaWQgcHJvcGVydHkgbmFtZS5cclxuICAgKi9cblxuICB2YXIgU2ltcGxlRGF0YVBpcGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIC8qKlxyXG4gICAgICogQm91bmQgbGlzdGVuZXJzIGZvciB1c2Ugd2l0aCBgRGF0YUludGVyZmFjZVsnb24nIHwgJ29mZiddYC5cclxuICAgICAqL1xuXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgZGF0YSBwaXBlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBfc291cmNlIC0gVGhlIGRhdGEgc2V0IG9yIGRhdGEgdmlldyB0aGF0IHdpbGwgYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKiBAcGFyYW0gX3RyYW5zZm9ybWVycyAtIEFuIGFycmF5IG9mIHRyYW5zZm9ybWluZyBmdW5jdGlvbnMgdG8gYmUgdXNlZCB0b1xyXG4gICAgICogZmlsdGVyIG9yIHRyYW5zZm9ybSB0aGUgaXRlbXMgaW4gdGhlIHBpcGUuXHJcbiAgICAgKiBAcGFyYW0gX3RhcmdldCAtIFRoZSBkYXRhIHNldCBvciBkYXRhIHZpZXcgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGl0ZW1zLlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2ltcGxlRGF0YVBpcGUoX3NvdXJjZSwgX3RyYW5zZm9ybWVycywgX3RhcmdldCkge1xuICAgICAgdmFyIF9jb250ZXh0LCBfY29udGV4dDIsIF9jb250ZXh0MztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpbXBsZURhdGFQaXBlKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NvdXJjZVwiLCB2b2lkIDApO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdHJhbnNmb3JtZXJzXCIsIHZvaWQgMCk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YXJnZXRcIiwgdm9pZCAwKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2xpc3RlbmVyc1wiLCB7XG4gICAgICAgIGFkZDogYmluZCQ2KF9jb250ZXh0ID0gdGhpcy5fYWRkKS5jYWxsKF9jb250ZXh0LCB0aGlzKSxcbiAgICAgICAgcmVtb3ZlOiBiaW5kJDYoX2NvbnRleHQyID0gdGhpcy5fcmVtb3ZlKS5jYWxsKF9jb250ZXh0MiwgdGhpcyksXG4gICAgICAgIHVwZGF0ZTogYmluZCQ2KF9jb250ZXh0MyA9IHRoaXMuX3VwZGF0ZSkuY2FsbChfY29udGV4dDMsIHRoaXMpXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fc291cmNlID0gX3NvdXJjZTtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybWVycyA9IF90cmFuc2Zvcm1lcnM7XG4gICAgICB0aGlzLl90YXJnZXQgPSBfdGFyZ2V0O1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKFNpbXBsZURhdGFQaXBlLCBbe1xuICAgICAga2V5OiBcImFsbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFsbCgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnVwZGF0ZSh0aGlzLl90cmFuc2Zvcm1JdGVtcyh0aGlzLl9zb3VyY2UuZ2V0KCkpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInN0YXJ0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZS5vbihcImFkZFwiLCB0aGlzLl9saXN0ZW5lcnMuYWRkKTtcblxuICAgICAgICB0aGlzLl9zb3VyY2Uub24oXCJyZW1vdmVcIiwgdGhpcy5fbGlzdGVuZXJzLnJlbW92ZSk7XG5cbiAgICAgICAgdGhpcy5fc291cmNlLm9uKFwidXBkYXRlXCIsIHRoaXMuX2xpc3RlbmVycy51cGRhdGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RvcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZS5vZmYoXCJhZGRcIiwgdGhpcy5fbGlzdGVuZXJzLmFkZCk7XG5cbiAgICAgICAgdGhpcy5fc291cmNlLm9mZihcInJlbW92ZVwiLCB0aGlzLl9saXN0ZW5lcnMucmVtb3ZlKTtcblxuICAgICAgICB0aGlzLl9zb3VyY2Uub2ZmKFwidXBkYXRlXCIsIHRoaXMuX2xpc3RlbmVycy51cGRhdGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIEFwcGx5IHRoZSB0cmFuc2Zvcm1lcnMgdG8gdGhlIGl0ZW1zLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gaXRlbXMgLSBUaGUgaXRlbXMgdG8gYmUgdHJhbnNmb3JtZWQuXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2Zvcm1lZCBpdGVtcy5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3RyYW5zZm9ybUl0ZW1zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zZm9ybUl0ZW1zKGl0ZW1zKSB7XG4gICAgICAgIHZhciBfY29udGV4dDQ7XG5cbiAgICAgICAgcmV0dXJuIHJlZHVjZShfY29udGV4dDQgPSB0aGlzLl90cmFuc2Zvcm1lcnMpLmNhbGwoX2NvbnRleHQ0LCBmdW5jdGlvbiAoaXRlbXMsIHRyYW5zZm9ybSkge1xuICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm0oaXRlbXMpO1xuICAgICAgICB9LCBpdGVtcyk7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogSGFuZGxlIGFuIGFkZCBldmVudC5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIF9uYW1lIC0gSWdub3JlZC5cclxuICAgICAgICogQHBhcmFtIHBheWxvYWQgLSBUaGUgcGF5bG9hZCBjb250YWluaW5nIHRoZSBpZHMgb2YgdGhlIGFkZGVkIGl0ZW1zLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYWRkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZChfbmFtZSwgcGF5bG9hZCkge1xuICAgICAgICBpZiAocGF5bG9hZCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZCh0aGlzLl90cmFuc2Zvcm1JdGVtcyh0aGlzLl9zb3VyY2UuZ2V0KHBheWxvYWQuaXRlbXMpKSk7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogSGFuZGxlIGFuIHVwZGF0ZSBldmVudC5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIF9uYW1lIC0gSWdub3JlZC5cclxuICAgICAgICogQHBhcmFtIHBheWxvYWQgLSBUaGUgcGF5bG9hZCBjb250YWluaW5nIHRoZSBpZHMgb2YgdGhlIHVwZGF0ZWQgaXRlbXMuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl91cGRhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKF9uYW1lLCBwYXlsb2FkKSB7XG4gICAgICAgIGlmIChwYXlsb2FkID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90YXJnZXQudXBkYXRlKHRoaXMuX3RyYW5zZm9ybUl0ZW1zKHRoaXMuX3NvdXJjZS5nZXQocGF5bG9hZC5pdGVtcykpKTtcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBIYW5kbGUgYSByZW1vdmUgZXZlbnQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBfbmFtZSAtIElnbm9yZWQuXHJcbiAgICAgICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIHBheWxvYWQgY29udGFpbmluZyB0aGUgZGF0YSBvZiB0aGUgcmVtb3ZlZCBpdGVtcy5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmUoX25hbWUsIHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHBheWxvYWQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RhcmdldC5yZW1vdmUodGhpcy5fdHJhbnNmb3JtSXRlbXMocGF5bG9hZC5vbGREYXRhKSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNpbXBsZURhdGFQaXBlO1xuICB9KCk7XG4gIC8qKlxyXG4gICAqIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSBwaXBlIGZhY3RvcnkuIFRoaXMgc2hvdWxkIGJlIGFjY2Vzc2libGVcclxuICAgKiBvbmx5IHRocm91Z2ggYGNyZWF0ZU5ld0RhdGFQaXBlRnJvbWAgZnJvbSB0aGUgb3V0c2lkZS5cclxuICAgKlxyXG4gICAqIEB0eXBlUGFyYW0gVEkgLSBUYXJnZXQgaXRlbSB0eXBlLlxyXG4gICAqIEB0eXBlUGFyYW0gVFAgLSBUYXJnZXQgaXRlbSB0eXBlJ3MgaWQgcHJvcGVydHkgbmFtZS5cclxuICAgKi9cblxuXG4gIHZhciBEYXRhUGlwZVVuZGVyQ29uc3RydWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAvKipcclxuICAgICAqIEFycmF5IHRyYW5zZm9ybWVycyB1c2VkIHRvIHRyYW5zZm9ybSBpdGVtcyB3aXRoaW4gdGhlIHBpcGUuIFRoaXMgaXMgdHlwZWRcclxuICAgICAqIGFzIGFueSBmb3IgdGhlIHNha2Ugb2Ygc2ltcGxpY2l0eS5cclxuICAgICAqL1xuXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgZGF0YSBwaXBlIGZhY3RvcnkuIFRoaXMgaXMgYW4gaW50ZXJuYWwgY29uc3RydWN0b3IgdGhhdFxyXG4gICAgICogc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCBmcm9tIG91dHNpZGUgb2YgdGhpcyBmaWxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBfc291cmNlIC0gVGhlIHNvdXJjZSBkYXRhIHNldCBvciBkYXRhIHZpZXcgZm9yIHRoaXMgcGlwZS5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERhdGFQaXBlVW5kZXJDb25zdHJ1Y3Rpb24oX3NvdXJjZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFQaXBlVW5kZXJDb25zdHJ1Y3Rpb24pO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc291cmNlXCIsIHZvaWQgMCk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90cmFuc2Zvcm1lcnNcIiwgW10pO1xuXG4gICAgICB0aGlzLl9zb3VyY2UgPSBfc291cmNlO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEZpbHRlciB0aGUgaXRlbXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gQSBmaWx0ZXJpbmcgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgZ2l2ZW4gaXRlbVxyXG4gICAgICogc2hvdWxkIGJlIHBpcGVkIGFuZCBmYWxzZSBpZiBub3QuXHJcbiAgICAgKiBAcmV0dXJucyBUaGlzIGZhY3RvcnkgZm9yIGZ1cnRoZXIgY29uZmlndXJhdGlvbi5cclxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoRGF0YVBpcGVVbmRlckNvbnN0cnVjdGlvbiwgW3tcbiAgICAgIGtleTogXCJmaWx0ZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaWx0ZXIkMShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1lcnMucHVzaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyKGlucHV0KS5jYWxsKGlucHV0LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIE1hcCBlYWNoIHNvdXJjZSBpdGVtIHRvIGEgbmV3IHR5cGUuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEEgbWFwcGluZyBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc291cmNlIGl0ZW0gYW5kIHJldHVybnNcclxuICAgICAgICogY29ycmVzcG9uZGluZyBtYXBwZWQgaXRlbS5cclxuICAgICAgICogQHR5cGVQYXJhbSBUSSAtIFRhcmdldCBpdGVtIHR5cGUuXHJcbiAgICAgICAqIEB0eXBlUGFyYW0gVFAgLSBUYXJnZXQgaXRlbSB0eXBlJ3MgaWQgcHJvcGVydHkgbmFtZS5cclxuICAgICAgICogQHJldHVybnMgVGhpcyBmYWN0b3J5IGZvciBmdXJ0aGVyIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1hcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1lcnMucHVzaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gbWFwJDMoaW5wdXQpLmNhbGwoaW5wdXQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogTWFwIGVhY2ggc291cmNlIGl0ZW0gdG8gemVybyBvciBtb3JlIGl0ZW1zIG9mIGEgbmV3IHR5cGUuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEEgbWFwcGluZyBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc291cmNlIGl0ZW0gYW5kIHJldHVybnNcclxuICAgICAgICogYW4gYXJyYXkgb2YgY29ycmVzcG9uZGluZyBtYXBwZWQgaXRlbXMuXHJcbiAgICAgICAqIEB0eXBlUGFyYW0gVEkgLSBUYXJnZXQgaXRlbSB0eXBlLlxyXG4gICAgICAgKiBAdHlwZVBhcmFtIFRQIC0gVGFyZ2V0IGl0ZW0gdHlwZSdzIGlkIHByb3BlcnR5IG5hbWUuXHJcbiAgICAgICAqIEByZXR1cm5zIFRoaXMgZmFjdG9yeSBmb3IgZnVydGhlciBjb25maWd1cmF0aW9uLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmbGF0TWFwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmxhdE1hcCQxKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVycy5wdXNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgIHJldHVybiBmbGF0TWFwKGlucHV0KS5jYWxsKGlucHV0LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIENvbm5lY3QgdGhpcyBwaXBlIHRvIGdpdmVuIGRhdGEgc2V0LlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIGRhdGEgc2V0IHRoYXQgd2lsbCByZWNlaXZlIHRoZSBpdGVtcyBmcm9tIHRoaXMgcGlwZS5cclxuICAgICAgICogQHJldHVybnMgVGhlIHBpcGUgY29ubmVjdGVkIGJldHdlZW4gZ2l2ZW4gZGF0YSBzZXRzIGFuZCBwZXJmb3JtaW5nXHJcbiAgICAgICAqIGNvbmZpZ3VyZWQgdHJhbnNmb3JtYXRpb24gb24gdGhlIHByb2Nlc3NlZCBpdGVtcy5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidG9cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0byh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVEYXRhUGlwZSh0aGlzLl9zb3VyY2UsIHRoaXMuX3RyYW5zZm9ybWVycywgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRGF0YVBpcGVVbmRlckNvbnN0cnVjdGlvbjtcbiAgfSgpO1xuXG4gIHZhciBnbG9iYWwkbyA9IGdsb2JhbCRNO1xuICB2YXIgY2xhc3NvZiRhID0gY2xhc3NvZiRjO1xuICB2YXIgU3RyaW5nJDIgPSBnbG9iYWwkby5TdHJpbmc7XG5cbiAgdmFyIHRvU3RyaW5nJDcgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICBpZiAoY2xhc3NvZiRhKGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgICByZXR1cm4gU3RyaW5nJDIoYXJndW1lbnQpO1xuICB9O1xuXG4gIHZhciB1bmN1cnJ5VGhpcyRnID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMiA9IHRvSW50ZWdlck9ySW5maW5pdHkkNDtcbiAgdmFyIHRvU3RyaW5nJDYgPSB0b1N0cmluZyQ3O1xuICB2YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1O1xuICB2YXIgY2hhckF0JDIgPSB1bmN1cnJ5VGhpcyRnKCcnLmNoYXJBdCk7XG4gIHZhciBjaGFyQ29kZUF0JDEgPSB1bmN1cnJ5VGhpcyRnKCcnLmNoYXJDb2RlQXQpO1xuICB2YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcyRnKCcnLnNsaWNlKTtcblxuICB2YXIgY3JlYXRlTWV0aG9kJDMgPSBmdW5jdGlvbiAoQ09OVkVSVF9UT19TVFJJTkcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICAgIHZhciBTID0gdG9TdHJpbmckNihyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIoJHRoaXMpKTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRvSW50ZWdlck9ySW5maW5pdHkkMihwb3MpO1xuICAgICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSBzaXplKSByZXR1cm4gQ09OVkVSVF9UT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICAgIGZpcnN0ID0gY2hhckNvZGVBdCQxKFMsIHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemUgfHwgKHNlY29uZCA9IGNoYXJDb2RlQXQkMShTLCBwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkYgPyBDT05WRVJUX1RPX1NUUklORyA/IGNoYXJBdCQyKFMsIHBvc2l0aW9uKSA6IGZpcnN0IDogQ09OVkVSVF9UT19TVFJJTkcgPyBzdHJpbmdTbGljZShTLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAyKSA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgc3RyaW5nTXVsdGlieXRlID0ge1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcbiAgICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZCQzKGZhbHNlKSxcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5hdGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuICAgIGNoYXJBdDogY3JlYXRlTWV0aG9kJDModHJ1ZSlcbiAgfTtcblxuICB2YXIgZ2xvYmFsJG4gPSBnbG9iYWwkTTtcbiAgdmFyIGlzQ2FsbGFibGUkNiA9IGlzQ2FsbGFibGUkaDtcbiAgdmFyIGluc3BlY3RTb3VyY2UgPSBpbnNwZWN0U291cmNlJDI7XG4gIHZhciBXZWFrTWFwJDEgPSBnbG9iYWwkbi5XZWFrTWFwO1xuICB2YXIgbmF0aXZlV2Vha01hcCA9IGlzQ2FsbGFibGUkNihXZWFrTWFwJDEpICYmIC9uYXRpdmUgY29kZS8udGVzdChpbnNwZWN0U291cmNlKFdlYWtNYXAkMSkpO1xuXG4gIHZhciBzaGFyZWQkMiA9IHNoYXJlZCQ0LmV4cG9ydHM7XG4gIHZhciB1aWQkMiA9IHVpZCQ0O1xuICB2YXIga2V5cyQ3ID0gc2hhcmVkJDIoJ2tleXMnKTtcblxuICB2YXIgc2hhcmVkS2V5JDQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleXMkN1trZXldIHx8IChrZXlzJDdba2V5XSA9IHVpZCQyKGtleSkpO1xuICB9O1xuXG4gIHZhciBoaWRkZW5LZXlzJDYgPSB7fTtcblxuICB2YXIgTkFUSVZFX1dFQUtfTUFQID0gbmF0aXZlV2Vha01hcDtcbiAgdmFyIGdsb2JhbCRtID0gZ2xvYmFsJE07XG4gIHZhciB1bmN1cnJ5VGhpcyRmID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIGlzT2JqZWN0JDggPSBpc09iamVjdCRmO1xuICB2YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcbiAgdmFyIGhhc093biRiID0gaGFzT3duUHJvcGVydHlfMTtcbiAgdmFyIHNoYXJlZCQxID0gc2hhcmVkU3RvcmU7XG4gIHZhciBzaGFyZWRLZXkkMyA9IHNoYXJlZEtleSQ0O1xuICB2YXIgaGlkZGVuS2V5cyQ1ID0gaGlkZGVuS2V5cyQ2O1xuICB2YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xuICB2YXIgVHlwZUVycm9yJGIgPSBnbG9iYWwkbS5UeXBlRXJyb3I7XG4gIHZhciBXZWFrTWFwID0gZ2xvYmFsJG0uV2Vha01hcDtcbiAgdmFyIHNldCQzLCBnZXQsIGhhcztcblxuICB2YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldCQzKGl0LCB7fSk7XG4gIH07XG5cbiAgdmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgICAgdmFyIHN0YXRlO1xuXG4gICAgICBpZiAoIWlzT2JqZWN0JDgoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yJGIoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9O1xuICB9O1xuXG4gIGlmIChOQVRJVkVfV0VBS19NQVAgfHwgc2hhcmVkJDEuc3RhdGUpIHtcbiAgICB2YXIgc3RvcmUgPSBzaGFyZWQkMS5zdGF0ZSB8fCAoc2hhcmVkJDEuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgICB2YXIgd21nZXQgPSB1bmN1cnJ5VGhpcyRmKHN0b3JlLmdldCk7XG4gICAgdmFyIHdtaGFzID0gdW5jdXJyeVRoaXMkZihzdG9yZS5oYXMpO1xuICAgIHZhciB3bXNldCA9IHVuY3VycnlUaGlzJGYoc3RvcmUuc2V0KTtcblxuICAgIHNldCQzID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgICAgaWYgKHdtaGFzKHN0b3JlLCBpdCkpIHRocm93IG5ldyBUeXBlRXJyb3IkYihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICAgIHdtc2V0KHN0b3JlLCBpdCwgbWV0YWRhdGEpO1xuICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH07XG5cbiAgICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiB3bWdldChzdG9yZSwgaXQpIHx8IHt9O1xuICAgIH07XG5cbiAgICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiB3bWhhcyhzdG9yZSwgaXQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIFNUQVRFID0gc2hhcmVkS2V5JDMoJ3N0YXRlJyk7XG4gICAgaGlkZGVuS2V5cyQ1W1NUQVRFXSA9IHRydWU7XG5cbiAgICBzZXQkMyA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICAgIGlmIChoYXNPd24kYihpdCwgU1RBVEUpKSB0aHJvdyBuZXcgVHlwZUVycm9yJGIoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNChpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9O1xuXG4gICAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gaGFzT3duJGIoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICAgIH07XG5cbiAgICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiBoYXNPd24kYihpdCwgU1RBVEUpO1xuICAgIH07XG4gIH1cblxuICB2YXIgaW50ZXJuYWxTdGF0ZSA9IHtcbiAgICBzZXQ6IHNldCQzLFxuICAgIGdldDogZ2V0LFxuICAgIGhhczogaGFzLFxuICAgIGVuZm9yY2U6IGVuZm9yY2UsXG4gICAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3JcbiAgfTtcblxuICB2YXIgREVTQ1JJUFRPUlMkYiA9IGRlc2NyaXB0b3JzO1xuICB2YXIgaGFzT3duJGEgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuICB2YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcblxuICB2YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTJGIgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgdmFyIEVYSVNUUyA9IGhhc093biRhKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpOyAvLyBhZGRpdGlvbmFsIHByb3RlY3Rpb24gZnJvbSBtaW5pZmllZCAvIG1hbmdsZWQgLyBkcm9wcGVkIGZ1bmN0aW9uIG5hbWVzXG5cbiAgdmFyIFBST1BFUiA9IEVYSVNUUyAmJiBmdW5jdGlvbiBzb21ldGhpbmcoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfS5uYW1lID09PSAnc29tZXRoaW5nJztcblxuICB2YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMkYiB8fCBERVNDUklQVE9SUyRiICYmIGdldERlc2NyaXB0b3IoRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJykuY29uZmlndXJhYmxlKTtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IHtcbiAgICBFWElTVFM6IEVYSVNUUyxcbiAgICBQUk9QRVI6IFBST1BFUixcbiAgICBDT05GSUdVUkFCTEU6IENPTkZJR1VSQUJMRVxuICB9O1xuXG4gIHZhciBvYmplY3REZWZpbmVQcm9wZXJ0aWVzID0ge307XG5cbiAgdmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNDtcbiAgdmFyIG1heCQzID0gTWF0aC5tYXg7XG4gIHZhciBtaW4kMSA9IE1hdGgubWluOyAvLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcbiAgLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuICAvLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxuXG4gIHZhciB0b0Fic29sdXRlSW5kZXgkNSA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gICAgdmFyIGludGVnZXIgPSB0b0ludGVnZXJPckluZmluaXR5JDEoaW5kZXgpO1xuICAgIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heCQzKGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluJDEoaW50ZWdlciwgbGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgdG9JbmRleGVkT2JqZWN0JDkgPSB0b0luZGV4ZWRPYmplY3QkYjtcbiAgdmFyIHRvQWJzb2x1dGVJbmRleCQ0ID0gdG9BYnNvbHV0ZUluZGV4JDU7XG4gIHZhciBsZW5ndGhPZkFycmF5TGlrZSQ4ID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDsgLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblxuICB2YXIgY3JlYXRlTWV0aG9kJDIgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQ5KCR0aGlzKTtcbiAgICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ4KE8pO1xuICAgICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDQoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgICAgdmFyIHZhbHVlOyAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuXG4gICAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgICB2YWx1ZSA9IE9baW5kZXgrK107IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG5cbiAgICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTsgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgICAgfSBlbHNlIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGFycmF5SW5jbHVkZXMgPSB7XG4gICAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgICBpbmNsdWRlczogY3JlYXRlTWV0aG9kJDIodHJ1ZSksXG4gICAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gICAgaW5kZXhPZjogY3JlYXRlTWV0aG9kJDIoZmFsc2UpXG4gIH07XG5cbiAgdmFyIHVuY3VycnlUaGlzJGUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgaGFzT3duJDkgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuICB2YXIgdG9JbmRleGVkT2JqZWN0JDggPSB0b0luZGV4ZWRPYmplY3QkYjtcbiAgdmFyIGluZGV4T2YgPSBhcnJheUluY2x1ZGVzLmluZGV4T2Y7XG4gIHZhciBoaWRkZW5LZXlzJDQgPSBoaWRkZW5LZXlzJDY7XG4gIHZhciBwdXNoJDQgPSB1bmN1cnJ5VGhpcyRlKFtdLnB1c2gpO1xuXG4gIHZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0JDgob2JqZWN0KTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXk7XG5cbiAgICBmb3IgKGtleSBpbiBPKSAhaGFzT3duJDkoaGlkZGVuS2V5cyQ0LCBrZXkpICYmIGhhc093biQ5KE8sIGtleSkgJiYgcHVzaCQ0KHJlc3VsdCwga2V5KTsgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuXG5cbiAgICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093biQ5KE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcHVzaCQ0KHJlc3VsdCwga2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBlbnVtQnVnS2V5cyQzID0gWydjb25zdHJ1Y3RvcicsICdoYXNPd25Qcm9wZXJ0eScsICdpc1Byb3RvdHlwZU9mJywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ3RvTG9jYWxlU3RyaW5nJywgJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnXTtcblxuICB2YXIgaW50ZXJuYWxPYmplY3RLZXlzJDEgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG4gIHZhciBlbnVtQnVnS2V5cyQyID0gZW51bUJ1Z0tleXMkMzsgLy8gYE9iamVjdC5rZXlzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxuXG4gIHZhciBvYmplY3RLZXlzJDQgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzJDEoTywgZW51bUJ1Z0tleXMkMik7XG4gIH07XG5cbiAgdmFyIERFU0NSSVBUT1JTJGEgPSBkZXNjcmlwdG9ycztcbiAgdmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG4gIHZhciBhbk9iamVjdCQ5ID0gYW5PYmplY3QkYjtcbiAgdmFyIHRvSW5kZXhlZE9iamVjdCQ3ID0gdG9JbmRleGVkT2JqZWN0JGI7XG4gIHZhciBvYmplY3RLZXlzJDMgPSBvYmplY3RLZXlzJDQ7IC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcblxuICBvYmplY3REZWZpbmVQcm9wZXJ0aWVzLmYgPSBERVNDUklQVE9SUyRhICYmICFWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gICAgYW5PYmplY3QkOShPKTtcbiAgICB2YXIgcHJvcHMgPSB0b0luZGV4ZWRPYmplY3QkNyhQcm9wZXJ0aWVzKTtcbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXMkMyhQcm9wZXJ0aWVzKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIga2V5O1xuXG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzLmYoTywga2V5ID0ga2V5c1tpbmRleCsrXSwgcHJvcHNba2V5XSk7XG5cbiAgICByZXR1cm4gTztcbiAgfTtcblxuICB2YXIgZ2V0QnVpbHRJbiQ1ID0gZ2V0QnVpbHRJbiQ5O1xuICB2YXIgaHRtbCQxID0gZ2V0QnVpbHRJbiQ1KCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcblxuICAvKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAtLSBvbGQgSUUsIFdTSCAqL1xuICB2YXIgYW5PYmplY3QkOCA9IGFuT2JqZWN0JGI7XG4gIHZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlJDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0aWVzO1xuICB2YXIgZW51bUJ1Z0tleXMkMSA9IGVudW1CdWdLZXlzJDM7XG4gIHZhciBoaWRkZW5LZXlzJDMgPSBoaWRkZW5LZXlzJDY7XG4gIHZhciBodG1sID0gaHRtbCQxO1xuICB2YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDE7XG4gIHZhciBzaGFyZWRLZXkkMiA9IHNoYXJlZEtleSQ0O1xuICB2YXIgR1QgPSAnPic7XG4gIHZhciBMVCA9ICc8JztcbiAgdmFyIFBST1RPVFlQRSQxID0gJ3Byb3RvdHlwZSc7XG4gIHZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbiAgdmFyIElFX1BST1RPJDEgPSBzaGFyZWRLZXkkMignSUVfUFJPVE8nKTtcblxuICB2YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9O1xuXG4gIHZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XG4gIH07IC8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG5cblxuICB2YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gICAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XG4gICAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuXG4gICAgcmV0dXJuIHRlbXA7XG4gIH07IC8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcblxuXG4gIHZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gICAgdmFyIGlmcmFtZURvY3VtZW50O1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuXG4gICAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gICAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gICAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICAgIHJldHVybiBpZnJhbWVEb2N1bWVudC5GO1xuICB9OyAvLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4gIC8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4gIC8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4gIC8vIGF2b2lkIElFIEdDIGJ1Z1xuXG5cbiAgdmFyIGFjdGl2ZVhEb2N1bWVudDtcblxuICB2YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBhY3RpdmVYRG9jdW1lbnQgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLyogaWdub3JlICovXG4gICAgfVxuXG4gICAgTnVsbFByb3RvT2JqZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnID8gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudCA/IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSAvLyBvbGQgSUVcbiAgICA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpIDogTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpOyAvLyBXU0hcblxuICAgIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cyQxLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkgZGVsZXRlIE51bGxQcm90b09iamVjdFtQUk9UT1RZUEUkMV1bZW51bUJ1Z0tleXMkMVtsZW5ndGhdXTtcblxuICAgIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbiAgfTtcblxuICBoaWRkZW5LZXlzJDNbSUVfUFJPVE8kMV0gPSB0cnVlOyAvLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuXG4gIHZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChPICE9PSBudWxsKSB7XG4gICAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRSQxXSA9IGFuT2JqZWN0JDgoTyk7XG4gICAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEUkMV0gPSBudWxsOyAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG5cbiAgICAgIHJlc3VsdFtJRV9QUk9UTyQxXSA9IE87XG4gICAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuXG4gICAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXNNb2R1bGUkMS5mKHJlc3VsdCwgUHJvcGVydGllcyk7XG4gIH07XG5cbiAgdmFyIGZhaWxzJGcgPSBmYWlscyRyO1xuICB2YXIgY29ycmVjdFByb3RvdHlwZUdldHRlciA9ICFmYWlscyRnKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGKCkge1xuICAgICAgLyogZW1wdHkgKi9cbiAgICB9XG5cbiAgICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcblxuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IEYoKSkgIT09IEYucHJvdG90eXBlO1xuICB9KTtcblxuICB2YXIgZ2xvYmFsJGwgPSBnbG9iYWwkTTtcbiAgdmFyIGhhc093biQ4ID0gaGFzT3duUHJvcGVydHlfMTtcbiAgdmFyIGlzQ2FsbGFibGUkNSA9IGlzQ2FsbGFibGUkaDtcbiAgdmFyIHRvT2JqZWN0JDkgPSB0b09iamVjdCRlO1xuICB2YXIgc2hhcmVkS2V5JDEgPSBzaGFyZWRLZXkkNDtcbiAgdmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiQxID0gY29ycmVjdFByb3RvdHlwZUdldHRlcjtcbiAgdmFyIElFX1BST1RPID0gc2hhcmVkS2V5JDEoJ0lFX1BST1RPJyk7XG4gIHZhciBPYmplY3QkNCA9IGdsb2JhbCRsLk9iamVjdDtcbiAgdmFyIE9iamVjdFByb3RvdHlwZSQyID0gT2JqZWN0JDQucHJvdG90eXBlOyAvLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2ZcblxuICB2YXIgb2JqZWN0R2V0UHJvdG90eXBlT2YgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIkMSA/IE9iamVjdCQ0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcbiAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QkOShPKTtcbiAgICBpZiAoaGFzT3duJDgob2JqZWN0LCBJRV9QUk9UTykpIHJldHVybiBvYmplY3RbSUVfUFJPVE9dO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChpc0NhbGxhYmxlJDUoY29uc3RydWN0b3IpICYmIG9iamVjdCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBPYmplY3QkNCA/IE9iamVjdFByb3RvdHlwZSQyIDogbnVsbDtcbiAgfTtcblxuICB2YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcblxuICB2YXIgcmVkZWZpbmUkNCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVudW1lcmFibGUpIHRhcmdldFtrZXldID0gdmFsdWU7ZWxzZSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMyh0YXJnZXQsIGtleSwgdmFsdWUpO1xuICB9O1xuXG4gIHZhciBmYWlscyRmID0gZmFpbHMkcjtcbiAgdmFyIGlzQ2FsbGFibGUkNCA9IGlzQ2FsbGFibGUkaDtcbiAgdmFyIGNyZWF0ZSRhID0gb2JqZWN0Q3JlYXRlO1xuICB2YXIgZ2V0UHJvdG90eXBlT2YkNiA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xuICB2YXIgcmVkZWZpbmUkMyA9IHJlZGVmaW5lJDQ7XG4gIHZhciB3ZWxsS25vd25TeW1ib2wkZCA9IHdlbGxLbm93blN5bWJvbCRqO1xuICB2YXIgSVRFUkFUT1IkNSA9IHdlbGxLbm93blN5bWJvbCRkKCdpdGVyYXRvcicpO1xuICB2YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gZmFsc2U7IC8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSQxLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG4gIC8qIGVzbGludC1kaXNhYmxlIGVzL25vLWFycmF5LXByb3RvdHlwZS1rZXlzIC0tIHNhZmUgKi9cblxuICBpZiAoW10ua2V5cykge1xuICAgIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7IC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuXG4gICAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSB0cnVlO2Vsc2Uge1xuICAgICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YkNihnZXRQcm90b3R5cGVPZiQ2KGFycmF5SXRlcmF0b3IpKTtcbiAgICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlJDEgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gICAgfVxuICB9XG5cbiAgdmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSBJdGVyYXRvclByb3RvdHlwZSQxID09IHVuZGVmaW5lZCB8fCBmYWlscyRmKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGVzdCA9IHt9OyAvLyBGRjQ0LSBsZWdhY3kgaXRlcmF0b3JzIGNhc2VcblxuICAgIHJldHVybiBJdGVyYXRvclByb3RvdHlwZSQxW0lURVJBVE9SJDVdLmNhbGwodGVzdCkgIT09IHRlc3Q7XG4gIH0pO1xuICBpZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUkMSA9IHt9O2Vsc2UgSXRlcmF0b3JQcm90b3R5cGUkMSA9IGNyZWF0ZSRhKEl0ZXJhdG9yUHJvdG90eXBlJDEpOyAvLyBgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLUBAaXRlcmF0b3JcblxuICBpZiAoIWlzQ2FsbGFibGUkNChJdGVyYXRvclByb3RvdHlwZSQxW0lURVJBVE9SJDVdKSkge1xuICAgIHJlZGVmaW5lJDMoSXRlcmF0b3JQcm90b3R5cGUkMSwgSVRFUkFUT1IkNSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaXRlcmF0b3JzQ29yZSA9IHtcbiAgICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUkMSxcbiAgICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDFcbiAgfTtcblxuICB2YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUJDEgPSB0b1N0cmluZ1RhZ1N1cHBvcnQ7XG4gIHZhciBjbGFzc29mJDkgPSBjbGFzc29mJGM7IC8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5cbiAgdmFyIG9iamVjdFRvU3RyaW5nID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUJDEgPyB7fS50b1N0cmluZyA6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZiQ5KHRoaXMpICsgJ10nO1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSB0b1N0cmluZ1RhZ1N1cHBvcnQ7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSQ2ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbiAgdmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDY7XG4gIHZhciBoYXNPd24kNyA9IGhhc093blByb3BlcnR5XzE7XG4gIHZhciB0b1N0cmluZyQ1ID0gb2JqZWN0VG9TdHJpbmc7XG4gIHZhciB3ZWxsS25vd25TeW1ib2wkYyA9IHdlbGxLbm93blN5bWJvbCRqO1xuICB2YXIgVE9fU1RSSU5HX1RBRyQxID0gd2VsbEtub3duU3ltYm9sJGMoJ3RvU3RyaW5nVGFnJyk7XG5cbiAgdmFyIHNldFRvU3RyaW5nVGFnJDUgPSBmdW5jdGlvbiAoaXQsIFRBRywgU1RBVElDLCBTRVRfTUVUSE9EKSB7XG4gICAgaWYgKGl0KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gU1RBVElDID8gaXQgOiBpdC5wcm90b3R5cGU7XG5cbiAgICAgIGlmICghaGFzT3duJDcodGFyZ2V0LCBUT19TVFJJTkdfVEFHJDEpKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5JDYodGFyZ2V0LCBUT19TVFJJTkdfVEFHJDEsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IFRBR1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFNFVF9NRVRIT0QgJiYgIVRPX1NUUklOR19UQUdfU1VQUE9SVCkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMih0YXJnZXQsICd0b1N0cmluZycsIHRvU3RyaW5nJDUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgaXRlcmF0b3JzID0ge307XG5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gaXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbiAgdmFyIGNyZWF0ZSQ5ID0gb2JqZWN0Q3JlYXRlO1xuICB2YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbiAgdmFyIHNldFRvU3RyaW5nVGFnJDQgPSBzZXRUb1N0cmluZ1RhZyQ1O1xuICB2YXIgSXRlcmF0b3JzJDUgPSBpdGVyYXRvcnM7XG5cbiAgdmFyIHJldHVyblRoaXMkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIEVOVU1FUkFCTEVfTkVYVCkge1xuICAgIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICAgIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlJDkoSXRlcmF0b3JQcm90b3R5cGUsIHtcbiAgICAgIG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyKCshRU5VTUVSQUJMRV9ORVhULCBuZXh0KVxuICAgIH0pO1xuICAgIHNldFRvU3RyaW5nVGFnJDQoSXRlcmF0b3JDb25zdHJ1Y3RvciwgVE9fU1RSSU5HX1RBRywgZmFsc2UsIHRydWUpO1xuICAgIEl0ZXJhdG9ycyQ1W1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcyQxO1xuICAgIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xuICB9O1xuXG4gIHZhciBnbG9iYWwkayA9IGdsb2JhbCRNO1xuICB2YXIgaXNDYWxsYWJsZSQzID0gaXNDYWxsYWJsZSRoO1xuICB2YXIgU3RyaW5nJDEgPSBnbG9iYWwkay5TdHJpbmc7XG4gIHZhciBUeXBlRXJyb3IkYSA9IGdsb2JhbCRrLlR5cGVFcnJvcjtcblxuICB2YXIgYVBvc3NpYmxlUHJvdG90eXBlJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdvYmplY3QnIHx8IGlzQ2FsbGFibGUkMyhhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgICB0aHJvdyBUeXBlRXJyb3IkYShcIkNhbid0IHNldCBcIiArIFN0cmluZyQxKGFyZ3VtZW50KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbiAgfTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAtLSBzYWZlICovXG4gIHZhciB1bmN1cnJ5VGhpcyRkID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIGFuT2JqZWN0JDcgPSBhbk9iamVjdCRiO1xuICB2YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gYVBvc3NpYmxlUHJvdG90eXBlJDE7IC8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuICAvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXG5cbiAgdmFyIG9iamVjdFNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgICB2YXIgdGVzdCA9IHt9O1xuICAgIHZhciBzZXR0ZXI7XG5cbiAgICB0cnkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuICAgICAgc2V0dGVyID0gdW5jdXJyeVRoaXMkZChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQpO1xuICAgICAgc2V0dGVyKHRlc3QsIFtdKTtcbiAgICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvKiBlbXB0eSAqL1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgYW5PYmplY3QkNyhPKTtcbiAgICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gICAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlcihPLCBwcm90byk7ZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgcmV0dXJuIE87XG4gICAgfTtcbiAgfSgpIDogdW5kZWZpbmVkKTtcblxuICB2YXIgJCR3ID0gX2V4cG9ydDtcbiAgdmFyIGNhbGwkNiA9IGZ1bmN0aW9uQ2FsbDtcbiAgdmFyIEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZTtcbiAgdmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yJDE7XG4gIHZhciBnZXRQcm90b3R5cGVPZiQ1ID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG4gIHZhciBzZXRUb1N0cmluZ1RhZyQzID0gc2V0VG9TdHJpbmdUYWckNTtcbiAgdmFyIHJlZGVmaW5lJDIgPSByZWRlZmluZSQ0O1xuICB2YXIgd2VsbEtub3duU3ltYm9sJGIgPSB3ZWxsS25vd25TeW1ib2wkajtcbiAgdmFyIEl0ZXJhdG9ycyQ0ID0gaXRlcmF0b3JzO1xuICB2YXIgSXRlcmF0b3JzQ29yZSA9IGl0ZXJhdG9yc0NvcmU7XG4gIHZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSQxID0gRnVuY3Rpb25OYW1lLlBST1BFUjtcbiAgdmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG4gIHZhciBJVEVSQVRPUiQ0ID0gd2VsbEtub3duU3ltYm9sJGIoJ2l0ZXJhdG9yJyk7XG4gIHZhciBLRVlTID0gJ2tleXMnO1xuICB2YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG4gIHZhciBFTlRSSUVTID0gJ2VudHJpZXMnO1xuXG4gIHZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBkZWZpbmVJdGVyYXRvciQzID0gZnVuY3Rpb24gKEl0ZXJhYmxlLCBOQU1FLCBJdGVyYXRvckNvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAgIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcbiAgICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG5cbiAgICAgIHN3aXRjaCAoS0lORCkge1xuICAgICAgICBjYXNlIEtFWVM6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlIFZBTFVFUzpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgY2FzZSBFTlRSSUVTOlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpO1xuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICAgIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gICAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkNF0gfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXSB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuICAgIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gICAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xuICAgIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTsgLy8gZml4IG5hdGl2ZVxuXG4gICAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgICBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiQ1KGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcblxuICAgICAgaWYgKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuXG5cbiAgICAgICAgc2V0VG9TdHJpbmdUYWckMyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUsIHRydWUpO1xuICAgICAgICBJdGVyYXRvcnMkNFtUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gICAgICB9XG4gICAgfSAvLyBmaXggQXJyYXkucHJvdG90eXBlLnsgdmFsdWVzLCBAQGl0ZXJhdG9yIH0ubmFtZSBpbiBWOCAvIEZGXG5cblxuICAgIGlmIChQUk9QRVJfRlVOQ1RJT05fTkFNRSQxICYmIERFRkFVTFQgPT0gVkFMVUVTICYmIG5hdGl2ZUl0ZXJhdG9yICYmIG5hdGl2ZUl0ZXJhdG9yLm5hbWUgIT09IFZBTFVFUykge1xuICAgICAge1xuICAgICAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuXG4gICAgICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbCQ2KG5hdGl2ZUl0ZXJhdG9yLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcblxuXG4gICAgaWYgKERFRkFVTFQpIHtcbiAgICAgIG1ldGhvZHMgPSB7XG4gICAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gICAgICB9O1xuICAgICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgICAgICAgcmVkZWZpbmUkMihJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgJCR3KHtcbiAgICAgICAgdGFyZ2V0OiBOQU1FLFxuICAgICAgICBwcm90bzogdHJ1ZSxcbiAgICAgICAgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRVxuICAgICAgfSwgbWV0aG9kcyk7XG4gICAgfSAvLyBkZWZpbmUgaXRlcmF0b3JcblxuXG4gICAgaWYgKChGT1JDRUQpICYmIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDRdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcbiAgICAgIHJlZGVmaW5lJDIoSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SJDQsIGRlZmF1bHRJdGVyYXRvciwge1xuICAgICAgICBuYW1lOiBERUZBVUxUXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBJdGVyYXRvcnMkNFtOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjtcbiAgICByZXR1cm4gbWV0aG9kcztcbiAgfTtcblxuICB2YXIgY2hhckF0JDEgPSBzdHJpbmdNdWx0aWJ5dGUuY2hhckF0O1xuICB2YXIgdG9TdHJpbmckNCA9IHRvU3RyaW5nJDc7XG4gIHZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDQgPSBpbnRlcm5hbFN0YXRlO1xuICB2YXIgZGVmaW5lSXRlcmF0b3IkMiA9IGRlZmluZUl0ZXJhdG9yJDM7XG4gIHZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbiAgdmFyIHNldEludGVybmFsU3RhdGUkNCA9IEludGVybmFsU3RhdGVNb2R1bGUkNC5zZXQ7XG4gIHZhciBnZXRJbnRlcm5hbFN0YXRlJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDQuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7IC8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLUBAaXRlcmF0b3JcblxuICBkZWZpbmVJdGVyYXRvciQyKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICAgIHNldEludGVybmFsU3RhdGUkNCh0aGlzLCB7XG4gICAgICB0eXBlOiBTVFJJTkdfSVRFUkFUT1IsXG4gICAgICBzdHJpbmc6IHRvU3RyaW5nJDQoaXRlcmF0ZWQpLFxuICAgICAgaW5kZXg6IDBcbiAgICB9KTsgLy8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lc3RyaW5naXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbiAgfSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDIodGhpcyk7XG4gICAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleDtcbiAgICB2YXIgcG9pbnQ7XG4gICAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgZG9uZTogdHJ1ZVxuICAgIH07XG4gICAgcG9pbnQgPSBjaGFyQXQkMShzdHJpbmcsIGluZGV4KTtcbiAgICBzdGF0ZS5pbmRleCArPSBwb2ludC5sZW5ndGg7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBwb2ludCxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfSk7XG5cbiAgdmFyIGNhbGwkNSA9IGZ1bmN0aW9uQ2FsbDtcbiAgdmFyIGFuT2JqZWN0JDYgPSBhbk9iamVjdCRiO1xuICB2YXIgZ2V0TWV0aG9kJDEgPSBnZXRNZXRob2QkMztcblxuICB2YXIgaXRlcmF0b3JDbG9zZSQyID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBraW5kLCB2YWx1ZSkge1xuICAgIHZhciBpbm5lclJlc3VsdCwgaW5uZXJFcnJvcjtcbiAgICBhbk9iamVjdCQ2KGl0ZXJhdG9yKTtcblxuICAgIHRyeSB7XG4gICAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZCQxKGl0ZXJhdG9yLCAncmV0dXJuJyk7XG5cbiAgICAgIGlmICghaW5uZXJSZXN1bHQpIHtcbiAgICAgICAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlubmVyUmVzdWx0ID0gY2FsbCQ1KGlubmVyUmVzdWx0LCBpdGVyYXRvcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlubmVyRXJyb3IgPSB0cnVlO1xuICAgICAgaW5uZXJSZXN1bHQgPSBlcnJvcjtcbiAgICB9XG5cbiAgICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gICAgaWYgKGlubmVyRXJyb3IpIHRocm93IGlubmVyUmVzdWx0O1xuICAgIGFuT2JqZWN0JDYoaW5uZXJSZXN1bHQpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB2YXIgYW5PYmplY3QkNSA9IGFuT2JqZWN0JGI7XG4gIHZhciBpdGVyYXRvckNsb3NlJDEgPSBpdGVyYXRvckNsb3NlJDI7IC8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcblxuICB2YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyQxID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIEVOVFJJRVMpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEVOVFJJRVMgPyBmbihhbk9iamVjdCQ1KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlJDEoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHdlbGxLbm93blN5bWJvbCRhID0gd2VsbEtub3duU3ltYm9sJGo7XG4gIHZhciBJdGVyYXRvcnMkMyA9IGl0ZXJhdG9ycztcbiAgdmFyIElURVJBVE9SJDMgPSB3ZWxsS25vd25TeW1ib2wkYSgnaXRlcmF0b3InKTtcbiAgdmFyIEFycmF5UHJvdG90eXBlJGEgPSBBcnJheS5wcm90b3R5cGU7IC8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcblxuICB2YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzJDMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlJGFbSVRFUkFUT1IkM10gPT09IGl0KTtcbiAgfTtcblxuICB2YXIgdG9Qcm9wZXJ0eUtleSQxID0gdG9Qcm9wZXJ0eUtleSQ0O1xuICB2YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMiA9IG9iamVjdERlZmluZVByb3BlcnR5O1xuICB2YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcblxuICB2YXIgY3JlYXRlUHJvcGVydHkkNiA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5JDEoa2V5KTtcbiAgICBpZiAocHJvcGVydHlLZXkgaW4gb2JqZWN0KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEoMCwgdmFsdWUpKTtlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbiAgfTtcblxuICB2YXIgY2xhc3NvZiQ4ID0gY2xhc3NvZiRjO1xuICB2YXIgZ2V0TWV0aG9kID0gZ2V0TWV0aG9kJDM7XG4gIHZhciBJdGVyYXRvcnMkMiA9IGl0ZXJhdG9ycztcbiAgdmFyIHdlbGxLbm93blN5bWJvbCQ5ID0gd2VsbEtub3duU3ltYm9sJGo7XG4gIHZhciBJVEVSQVRPUiQyID0gd2VsbEtub3duU3ltYm9sJDkoJ2l0ZXJhdG9yJyk7XG5cbiAgdmFyIGdldEl0ZXJhdG9yTWV0aG9kJDggPSBmdW5jdGlvbiAoaXQpIHtcbiAgICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gZ2V0TWV0aG9kKGl0LCBJVEVSQVRPUiQyKSB8fCBnZXRNZXRob2QoaXQsICdAQGl0ZXJhdG9yJykgfHwgSXRlcmF0b3JzJDJbY2xhc3NvZiQ4KGl0KV07XG4gIH07XG5cbiAgdmFyIGdsb2JhbCRqID0gZ2xvYmFsJE07XG4gIHZhciBjYWxsJDQgPSBmdW5jdGlvbkNhbGw7XG4gIHZhciBhQ2FsbGFibGUkMSA9IGFDYWxsYWJsZSQ3O1xuICB2YXIgYW5PYmplY3QkNCA9IGFuT2JqZWN0JGI7XG4gIHZhciB0cnlUb1N0cmluZyQyID0gdHJ5VG9TdHJpbmckNDtcbiAgdmFyIGdldEl0ZXJhdG9yTWV0aG9kJDcgPSBnZXRJdGVyYXRvck1ldGhvZCQ4O1xuICB2YXIgVHlwZUVycm9yJDkgPSBnbG9iYWwkai5UeXBlRXJyb3I7XG5cbiAgdmFyIGdldEl0ZXJhdG9yJDcgPSBmdW5jdGlvbiAoYXJndW1lbnQsIHVzaW5nSXRlcmF0b3IpIHtcbiAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGdldEl0ZXJhdG9yTWV0aG9kJDcoYXJndW1lbnQpIDogdXNpbmdJdGVyYXRvcjtcbiAgICBpZiAoYUNhbGxhYmxlJDEoaXRlcmF0b3JNZXRob2QpKSByZXR1cm4gYW5PYmplY3QkNChjYWxsJDQoaXRlcmF0b3JNZXRob2QsIGFyZ3VtZW50KSk7XG4gICAgdGhyb3cgVHlwZUVycm9yJDkodHJ5VG9TdHJpbmckMihhcmd1bWVudCkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xuICB9O1xuXG4gIHZhciBnbG9iYWwkaSA9IGdsb2JhbCRNO1xuICB2YXIgYmluZCQzID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbiAgdmFyIGNhbGwkMyA9IGZ1bmN0aW9uQ2FsbDtcbiAgdmFyIHRvT2JqZWN0JDggPSB0b09iamVjdCRlO1xuICB2YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmckMTtcbiAgdmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCQxID0gaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDI7XG4gIHZhciBpc0NvbnN0cnVjdG9yJDIgPSBpc0NvbnN0cnVjdG9yJDQ7XG4gIHZhciBsZW5ndGhPZkFycmF5TGlrZSQ3ID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbiAgdmFyIGNyZWF0ZVByb3BlcnR5JDUgPSBjcmVhdGVQcm9wZXJ0eSQ2O1xuICB2YXIgZ2V0SXRlcmF0b3IkNiA9IGdldEl0ZXJhdG9yJDc7XG4gIHZhciBnZXRJdGVyYXRvck1ldGhvZCQ2ID0gZ2V0SXRlcmF0b3JNZXRob2QkODtcbiAgdmFyIEFycmF5JDQgPSBnbG9iYWwkaS5BcnJheTsgLy8gYEFycmF5LmZyb21gIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cblxuICB2YXIgYXJyYXlGcm9tID0gZnVuY3Rpb24gZnJvbShhcnJheUxpa2VcbiAgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqL1xuICApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0JDgoYXJyYXlMaWtlKTtcbiAgICB2YXIgSVNfQ09OU1RSVUNUT1IgPSBpc0NvbnN0cnVjdG9yJDIodGhpcyk7XG4gICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gYmluZCQzKG1hcGZuLCBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZCQ2KE8pO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvciwgbmV4dCwgdmFsdWU7IC8vIGlmIHRoZSB0YXJnZXQgaXMgbm90IGl0ZXJhYmxlIG9yIGl0J3MgYW4gYXJyYXkgd2l0aCB0aGUgZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBhIHNpbXBsZSBjYXNlXG5cbiAgICBpZiAoaXRlcmF0b3JNZXRob2QgJiYgISh0aGlzID09IEFycmF5JDQgJiYgaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDEoaXRlcmF0b3JNZXRob2QpKSkge1xuICAgICAgaXRlcmF0b3IgPSBnZXRJdGVyYXRvciQ2KE8sIGl0ZXJhdG9yTWV0aG9kKTtcbiAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgICAgcmVzdWx0ID0gSVNfQ09OU1RSVUNUT1IgPyBuZXcgdGhpcygpIDogW107XG5cbiAgICAgIGZvciAoOyAhKHN0ZXAgPSBjYWxsJDMobmV4dCwgaXRlcmF0b3IpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIHZhbHVlID0gbWFwcGluZyA/IGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWU7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5JDUocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ3KE8pO1xuICAgICAgcmVzdWx0ID0gSVNfQ09OU1RSVUNUT1IgPyBuZXcgdGhpcyhsZW5ndGgpIDogQXJyYXkkNChsZW5ndGgpO1xuXG4gICAgICBmb3IgKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgdmFsdWUgPSBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdO1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eSQ1KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgd2VsbEtub3duU3ltYm9sJDggPSB3ZWxsS25vd25TeW1ib2wkajtcbiAgdmFyIElURVJBVE9SJDEgPSB3ZWxsS25vd25TeW1ib2wkOCgnaXRlcmF0b3InKTtcbiAgdmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIGNhbGxlZCA9IDA7XG4gICAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiAhIWNhbGxlZCsrXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SJDFdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWZyb20sIG5vLXRocm93LWxpdGVyYWwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcblxuXG4gICAgQXJyYXkuZnJvbShpdGVyYXRvcldpdGhSZXR1cm4sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IDI7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxuXG4gIHZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMSA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcbiAgICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuXG4gICAgICBvYmplY3RbSVRFUkFUT1IkMV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGV4ZWMob2JqZWN0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLyogZW1wdHkgKi9cbiAgICB9XG5cbiAgICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG4gIH07XG5cbiAgdmFyICQkdiA9IF9leHBvcnQ7XG4gIHZhciBmcm9tJDYgPSBhcnJheUZyb207XG4gIHZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMTtcbiAgdmFyIElOQ09SUkVDVF9JVEVSQVRJT04gPSAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1mcm9tIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgQXJyYXkuZnJvbShpdGVyYWJsZSk7XG4gIH0pOyAvLyBgQXJyYXkuZnJvbWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxuXG4gICQkdih7XG4gICAgdGFyZ2V0OiAnQXJyYXknLFxuICAgIHN0YXQ6IHRydWUsXG4gICAgZm9yY2VkOiBJTkNPUlJFQ1RfSVRFUkFUSU9OXG4gIH0sIHtcbiAgICBmcm9tOiBmcm9tJDZcbiAgfSk7XG5cbiAgdmFyIHBhdGgkbCA9IHBhdGgkcTtcbiAgdmFyIGZyb20kNSA9IHBhdGgkbC5BcnJheS5mcm9tO1xuXG4gIHZhciBwYXJlbnQkTiA9IGZyb20kNTtcbiAgdmFyIGZyb20kNCA9IHBhcmVudCROO1xuXG4gIHZhciBmcm9tJDMgPSBmcm9tJDQ7XG5cbiAgdmFyIHRvSW5kZXhlZE9iamVjdCQ2ID0gdG9JbmRleGVkT2JqZWN0JGI7XG4gIHZhciBJdGVyYXRvcnMkMSA9IGl0ZXJhdG9ycztcbiAgdmFyIEludGVybmFsU3RhdGVNb2R1bGUkMyA9IGludGVybmFsU3RhdGU7XG4gIG9iamVjdERlZmluZVByb3BlcnR5LmY7XG4gIHZhciBkZWZpbmVJdGVyYXRvciQxID0gZGVmaW5lSXRlcmF0b3IkMztcbiAgdmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcbiAgdmFyIHNldEludGVybmFsU3RhdGUkMyA9IEludGVybmFsU3RhdGVNb2R1bGUkMy5zZXQ7XG4gIHZhciBnZXRJbnRlcm5hbFN0YXRlJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDMuZ2V0dGVyRm9yKEFSUkFZX0lURVJBVE9SKTsgLy8gYEFycmF5LnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5rZXlzXG4gIC8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUudmFsdWVzXG4gIC8vIGBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4gIC8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVhcnJheWl0ZXJhdG9yXG5cbiAgZGVmaW5lSXRlcmF0b3IkMShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSQzKHRoaXMsIHtcbiAgICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgICAgdGFyZ2V0OiB0b0luZGV4ZWRPYmplY3QkNihpdGVyYXRlZCksXG4gICAgICAvLyB0YXJnZXRcbiAgICAgIGluZGV4OiAwLFxuICAgICAgLy8gbmV4dCBpbmRleFxuICAgICAga2luZDoga2luZCAvLyBraW5kXG5cbiAgICB9KTsgLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG4gIH0sIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDEodGhpcyk7XG4gICAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcbiAgICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gICAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcblxuICAgIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4ge1xuICAgICAgdmFsdWU6IGluZGV4LFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4ge1xuICAgICAgdmFsdWU6IHRhcmdldFtpbmRleF0sXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9LCAndmFsdWVzJyk7IC8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlbWFwcGVkYXJndW1lbnRzb2JqZWN0XG5cbiAgSXRlcmF0b3JzJDEuQXJndW1lbnRzID0gSXRlcmF0b3JzJDEuQXJyYXk7IC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcblxuICB2YXIgZ2V0SXRlcmF0b3JNZXRob2QkNSA9IGdldEl0ZXJhdG9yTWV0aG9kJDg7XG4gIHZhciBnZXRJdGVyYXRvck1ldGhvZF8xID0gZ2V0SXRlcmF0b3JNZXRob2QkNTtcblxuICAvLyBmbGFnIC0gYGl0ZXJhYmxlYCBpbnRlcmZhY2UgLSAnZW50cmllcycsICdrZXlzJywgJ3ZhbHVlcycsICdmb3JFYWNoJyBtZXRob2RzXG5cbiAgdmFyIGRvbUl0ZXJhYmxlcyA9IHtcbiAgICBDU1NSdWxlTGlzdDogMCxcbiAgICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuICAgIENTU1ZhbHVlTGlzdDogMCxcbiAgICBDbGllbnRSZWN0TGlzdDogMCxcbiAgICBET01SZWN0TGlzdDogMCxcbiAgICBET01TdHJpbmdMaXN0OiAwLFxuICAgIERPTVRva2VuTGlzdDogMSxcbiAgICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcbiAgICBGaWxlTGlzdDogMCxcbiAgICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiAgICBIVE1MQ29sbGVjdGlvbjogMCxcbiAgICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gICAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gICAgTWVkaWFMaXN0OiAwLFxuICAgIE1pbWVUeXBlQXJyYXk6IDAsXG4gICAgTmFtZWROb2RlTWFwOiAwLFxuICAgIE5vZGVMaXN0OiAxLFxuICAgIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gICAgUGx1Z2luOiAwLFxuICAgIFBsdWdpbkFycmF5OiAwLFxuICAgIFNWR0xlbmd0aExpc3Q6IDAsXG4gICAgU1ZHTnVtYmVyTGlzdDogMCxcbiAgICBTVkdQYXRoU2VnTGlzdDogMCxcbiAgICBTVkdQb2ludExpc3Q6IDAsXG4gICAgU1ZHU3RyaW5nTGlzdDogMCxcbiAgICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuICAgIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gICAgU3R5bGVTaGVldExpc3Q6IDAsXG4gICAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcbiAgICBUZXh0VHJhY2tMaXN0OiAwLFxuICAgIFRvdWNoTGlzdDogMFxuICB9O1xuXG4gIHZhciBET01JdGVyYWJsZXMkNCA9IGRvbUl0ZXJhYmxlcztcbiAgdmFyIGdsb2JhbCRoID0gZ2xvYmFsJE07XG4gIHZhciBjbGFzc29mJDcgPSBjbGFzc29mJGM7XG4gIHZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xuICB2YXIgSXRlcmF0b3JzID0gaXRlcmF0b3JzO1xuICB2YXIgd2VsbEtub3duU3ltYm9sJDcgPSB3ZWxsS25vd25TeW1ib2wkajtcbiAgdmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2wkNygndG9TdHJpbmdUYWcnKTtcblxuICBmb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzJDQpIHtcbiAgICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbCRoW0NPTExFQ1RJT05fTkFNRV07XG4gICAgdmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuXG4gICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUgJiYgY2xhc3NvZiQ3KENvbGxlY3Rpb25Qcm90b3R5cGUpICE9PSBUT19TVFJJTkdfVEFHKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCBDT0xMRUNUSU9OX05BTUUpO1xuICAgIH1cblxuICAgIEl0ZXJhdG9yc1tDT0xMRUNUSU9OX05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xuICB9XG5cbiAgdmFyIHBhcmVudCRNID0gZ2V0SXRlcmF0b3JNZXRob2RfMTtcbiAgdmFyIGdldEl0ZXJhdG9yTWV0aG9kJDQgPSBwYXJlbnQkTTtcblxuICB2YXIgcGFyZW50JEwgPSBnZXRJdGVyYXRvck1ldGhvZCQ0O1xuICB2YXIgZ2V0SXRlcmF0b3JNZXRob2QkMyA9IHBhcmVudCRMO1xuXG4gIHZhciBwYXJlbnQkSyA9IGdldEl0ZXJhdG9yTWV0aG9kJDM7XG4gIHZhciBnZXRJdGVyYXRvck1ldGhvZCQyID0gcGFyZW50JEs7XG5cbiAgdmFyIGdldEl0ZXJhdG9yTWV0aG9kJDEgPSBnZXRJdGVyYXRvck1ldGhvZCQyO1xuXG4gIHZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzID0ge307XG5cbiAgdmFyIGludGVybmFsT2JqZWN0S2V5cyA9IG9iamVjdEtleXNJbnRlcm5hbDtcbiAgdmFyIGVudW1CdWdLZXlzID0gZW51bUJ1Z0tleXMkMztcbiAgdmFyIGhpZGRlbktleXMkMiA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpOyAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5cbiAgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gICAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzJDIpO1xuICB9O1xuXG4gIHZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwgPSB7fTtcblxuICB2YXIgZ2xvYmFsJGcgPSBnbG9iYWwkTTtcbiAgdmFyIHRvQWJzb2x1dGVJbmRleCQzID0gdG9BYnNvbHV0ZUluZGV4JDU7XG4gIHZhciBsZW5ndGhPZkFycmF5TGlrZSQ2ID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbiAgdmFyIGNyZWF0ZVByb3BlcnR5JDQgPSBjcmVhdGVQcm9wZXJ0eSQ2O1xuICB2YXIgQXJyYXkkMyA9IGdsb2JhbCRnLkFycmF5O1xuICB2YXIgbWF4JDIgPSBNYXRoLm1heDtcblxuICB2YXIgYXJyYXlTbGljZVNpbXBsZSA9IGZ1bmN0aW9uIChPLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDYoTyk7XG4gICAgdmFyIGsgPSB0b0Fic29sdXRlSW5kZXgkMyhzdGFydCwgbGVuZ3RoKTtcbiAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4JDMoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5JDMobWF4JDIoZmluIC0gaywgMCkpO1xuXG4gICAgZm9yICh2YXIgbiA9IDA7IGsgPCBmaW47IGsrKywgbisrKSBjcmVhdGVQcm9wZXJ0eSQ0KHJlc3VsdCwgbiwgT1trXSk7XG5cbiAgICByZXN1bHQubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmUgKi9cbiAgdmFyIGNsYXNzb2YkNiA9IGNsYXNzb2ZSYXckMTtcbiAgdmFyIHRvSW5kZXhlZE9iamVjdCQ1ID0gdG9JbmRleGVkT2JqZWN0JGI7XG4gIHZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mO1xuICB2YXIgYXJyYXlTbGljZSQzID0gYXJyYXlTbGljZVNpbXBsZTtcbiAgdmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbiAgdmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlOYW1lcyQxKGl0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGFycmF5U2xpY2UkMyh3aW5kb3dOYW1lcyk7XG4gICAgfVxuICB9OyAvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG5cblxuICBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMgJiYgY2xhc3NvZiQ2KGl0KSA9PSAnV2luZG93JyA/IGdldFdpbmRvd05hbWVzKGl0KSA6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzJDEodG9JbmRleGVkT2JqZWN0JDUoaXQpKTtcbiAgfTtcblxuICB2YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0ge307XG5cbiAgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIHZhciB3ZWxsS25vd25TeW1ib2xXcmFwcGVkID0ge307XG5cbiAgdmFyIHdlbGxLbm93blN5bWJvbCQ2ID0gd2VsbEtub3duU3ltYm9sJGo7XG4gIHdlbGxLbm93blN5bWJvbFdyYXBwZWQuZiA9IHdlbGxLbm93blN5bWJvbCQ2O1xuXG4gIHZhciBwYXRoJGsgPSBwYXRoJHE7XG4gIHZhciBoYXNPd24kNiA9IGhhc093blByb3BlcnR5XzE7XG4gIHZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlJDEgPSB3ZWxsS25vd25TeW1ib2xXcmFwcGVkO1xuICB2YXIgZGVmaW5lUHJvcGVydHkkNSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRsID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgICB2YXIgU3ltYm9sID0gcGF0aCRrLlN5bWJvbCB8fCAocGF0aCRrLlN5bWJvbCA9IHt9KTtcbiAgICBpZiAoIWhhc093biQ2KFN5bWJvbCwgTkFNRSkpIGRlZmluZVByb3BlcnR5JDUoU3ltYm9sLCBOQU1FLCB7XG4gICAgICB2YWx1ZTogd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSQxLmYoTkFNRSlcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgJCR1ID0gX2V4cG9ydDtcbiAgdmFyIGdsb2JhbCRmID0gZ2xvYmFsJE07XG4gIHZhciBnZXRCdWlsdEluJDQgPSBnZXRCdWlsdEluJDk7XG4gIHZhciBhcHBseSQ0ID0gZnVuY3Rpb25BcHBseTtcbiAgdmFyIGNhbGwkMiA9IGZ1bmN0aW9uQ2FsbDtcbiAgdmFyIHVuY3VycnlUaGlzJGMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgREVTQ1JJUFRPUlMkOSA9IGRlc2NyaXB0b3JzO1xuICB2YXIgTkFUSVZFX1NZTUJPTCA9IG5hdGl2ZVN5bWJvbDtcbiAgdmFyIGZhaWxzJGUgPSBmYWlscyRyO1xuICB2YXIgaGFzT3duJDUgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuICB2YXIgaXNBcnJheSRhID0gaXNBcnJheSRkO1xuICB2YXIgaXNDYWxsYWJsZSQyID0gaXNDYWxsYWJsZSRoO1xuICB2YXIgaXNPYmplY3QkNyA9IGlzT2JqZWN0JGY7XG4gIHZhciBpc1Byb3RvdHlwZU9mJGMgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuICB2YXIgaXNTeW1ib2wgPSBpc1N5bWJvbCQzO1xuICB2YXIgYW5PYmplY3QkMyA9IGFuT2JqZWN0JGI7XG4gIHZhciB0b09iamVjdCQ3ID0gdG9PYmplY3QkZTtcbiAgdmFyIHRvSW5kZXhlZE9iamVjdCQ0ID0gdG9JbmRleGVkT2JqZWN0JGI7XG4gIHZhciB0b1Byb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQ0O1xuICB2YXIgJHRvU3RyaW5nID0gdG9TdHJpbmckNztcbiAgdmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xuICB2YXIgbmF0aXZlT2JqZWN0Q3JlYXRlID0gb2JqZWN0Q3JlYXRlO1xuICB2YXIgb2JqZWN0S2V5cyQyID0gb2JqZWN0S2V5cyQ0O1xuICB2YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSQyID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcztcbiAgdmFyIGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbCA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbDtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQyID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcztcbiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgdmFyIGFycmF5U2xpY2UkMiA9IGFycmF5U2xpY2UkNTtcbiAgdmFyIHJlZGVmaW5lJDEgPSByZWRlZmluZSQ0O1xuICB2YXIgc2hhcmVkID0gc2hhcmVkJDQuZXhwb3J0cztcbiAgdmFyIHNoYXJlZEtleSA9IHNoYXJlZEtleSQ0O1xuICB2YXIgaGlkZGVuS2V5cyQxID0gaGlkZGVuS2V5cyQ2O1xuICB2YXIgdWlkJDEgPSB1aWQkNDtcbiAgdmFyIHdlbGxLbm93blN5bWJvbCQ1ID0gd2VsbEtub3duU3ltYm9sJGo7XG4gIHZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gd2VsbEtub3duU3ltYm9sV3JhcHBlZDtcbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRrID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7XG4gIHZhciBzZXRUb1N0cmluZ1RhZyQyID0gc2V0VG9TdHJpbmdUYWckNTtcbiAgdmFyIEludGVybmFsU3RhdGVNb2R1bGUkMiA9IGludGVybmFsU3RhdGU7XG4gIHZhciAkZm9yRWFjaCQxID0gYXJyYXlJdGVyYXRpb24uZm9yRWFjaDtcbiAgdmFyIEhJRERFTiA9IHNoYXJlZEtleSgnaGlkZGVuJyk7XG4gIHZhciBTWU1CT0wgPSAnU3ltYm9sJztcbiAgdmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuICB2YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sJDUoJ3RvUHJpbWl0aXZlJyk7XG4gIHZhciBzZXRJbnRlcm5hbFN0YXRlJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDIuc2V0O1xuICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkMi5nZXR0ZXJGb3IoU1lNQk9MKTtcbiAgdmFyIE9iamVjdFByb3RvdHlwZSQxID0gT2JqZWN0W1BST1RPVFlQRV07XG4gIHZhciAkU3ltYm9sID0gZ2xvYmFsJGYuU3ltYm9sO1xuICB2YXIgU3ltYm9sUHJvdG90eXBlID0gJFN5bWJvbCAmJiAkU3ltYm9sW1BST1RPVFlQRV07XG4gIHZhciBUeXBlRXJyb3IkOCA9IGdsb2JhbCRmLlR5cGVFcnJvcjtcbiAgdmFyIFFPYmplY3QgPSBnbG9iYWwkZi5RT2JqZWN0O1xuICB2YXIgJHN0cmluZ2lmeSQxID0gZ2V0QnVpbHRJbiQ0KCdKU09OJywgJ3N0cmluZ2lmeScpO1xuICB2YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUkMS5mO1xuICB2YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxLmY7XG4gIHZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzID0gZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmY7XG4gIHZhciBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEuZjtcbiAgdmFyIHB1c2gkMyA9IHVuY3VycnlUaGlzJGMoW10ucHVzaCk7XG4gIHZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG4gIHZhciBPYmplY3RQcm90b3R5cGVTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG4gIHZhciBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzdHJpbmctdG8tc3ltYm9sLXJlZ2lzdHJ5Jyk7XG4gIHZhciBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtdG8tc3RyaW5nLXJlZ2lzdHJ5Jyk7XG4gIHZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpOyAvLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcblxuICB2YXIgVVNFX1NFVFRFUiA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7IC8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xuXG4gIHZhciBzZXRTeW1ib2xEZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMkOSAmJiBmYWlscyRlKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmF0aXZlT2JqZWN0Q3JlYXRlKG5hdGl2ZURlZmluZVByb3BlcnR5KHt9LCAnYScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkodGhpcywgJ2EnLCB7XG4gICAgICAgICAgdmFsdWU6IDdcbiAgICAgICAgfSkuYTtcbiAgICAgIH1cbiAgICB9KSkuYSAhPSA3O1xuICB9KSA/IGZ1bmN0aW9uIChPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gICAgdmFyIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShPYmplY3RQcm90b3R5cGUkMSwgUCk7XG4gICAgaWYgKE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpIGRlbGV0ZSBPYmplY3RQcm90b3R5cGUkMVtQXTtcbiAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcblxuICAgIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yICYmIE8gIT09IE9iamVjdFByb3RvdHlwZSQxKSB7XG4gICAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPYmplY3RQcm90b3R5cGUkMSwgUCwgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcik7XG4gICAgfVxuICB9IDogbmF0aXZlRGVmaW5lUHJvcGVydHk7XG5cbiAgdmFyIHdyYXAkMSA9IGZ1bmN0aW9uICh0YWcsIGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIHN5bWJvbCA9IEFsbFN5bWJvbHNbdGFnXSA9IG5hdGl2ZU9iamVjdENyZWF0ZShTeW1ib2xQcm90b3R5cGUpO1xuICAgIHNldEludGVybmFsU3RhdGUkMihzeW1ib2wsIHtcbiAgICAgIHR5cGU6IFNZTUJPTCxcbiAgICAgIHRhZzogdGFnLFxuICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uXG4gICAgfSk7XG4gICAgaWYgKCFERVNDUklQVE9SUyQ5KSBzeW1ib2wuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICByZXR1cm4gc3ltYm9sO1xuICB9O1xuXG4gIHZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gICAgaWYgKE8gPT09IE9iamVjdFByb3RvdHlwZSQxKSAkZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCwgQXR0cmlidXRlcyk7XG4gICAgYW5PYmplY3QkMyhPKTtcbiAgICB2YXIga2V5ID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgICBhbk9iamVjdCQzKEF0dHJpYnV0ZXMpO1xuXG4gICAgaWYgKGhhc093biQ1KEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICAgIGlmICghQXR0cmlidXRlcy5lbnVtZXJhYmxlKSB7XG4gICAgICAgIGlmICghaGFzT3duJDUoTywgSElEREVOKSkgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgSElEREVOLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwge30pKTtcbiAgICAgICAgT1tISURERU5dW2tleV0gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGhhc093biQ1KE8sIEhJRERFTikgJiYgT1tISURERU5dW2tleV0pIE9bSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICAgIEF0dHJpYnV0ZXMgPSBuYXRpdmVPYmplY3RDcmVhdGUoQXR0cmlidXRlcywge1xuICAgICAgICAgIGVudW1lcmFibGU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBmYWxzZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXRTeW1ib2xEZXNjcmlwdG9yKE8sIGtleSwgQXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIGtleSwgQXR0cmlidXRlcyk7XG4gIH07XG5cbiAgdmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gICAgYW5PYmplY3QkMyhPKTtcbiAgICB2YXIgcHJvcGVydGllcyA9IHRvSW5kZXhlZE9iamVjdCQ0KFByb3BlcnRpZXMpO1xuICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyQyKHByb3BlcnRpZXMpLmNvbmNhdCgkZ2V0T3duUHJvcGVydHlTeW1ib2xzKHByb3BlcnRpZXMpKTtcbiAgICAkZm9yRWFjaCQxKGtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMkOSB8fCBjYWxsJDIoJHByb3BlcnR5SXNFbnVtZXJhYmxlJDEsIHByb3BlcnRpZXMsIGtleSkpICRkZWZpbmVQcm9wZXJ0eShPLCBrZXksIHByb3BlcnRpZXNba2V5XSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIE87XG4gIH07XG5cbiAgdmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICAgIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyBuYXRpdmVPYmplY3RDcmVhdGUoTykgOiAkZGVmaW5lUHJvcGVydGllcyhuYXRpdmVPYmplY3RDcmVhdGUoTyksIFByb3BlcnRpZXMpO1xuICB9O1xuXG4gIHZhciAkcHJvcGVydHlJc0VudW1lcmFibGUkMSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgICB2YXIgUCA9IHRvUHJvcGVydHlLZXkoVik7XG4gICAgdmFyIGVudW1lcmFibGUgPSBjYWxsJDIobmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUsIHRoaXMsIFApO1xuICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUkMSAmJiBoYXNPd24kNShBbGxTeW1ib2xzLCBQKSAmJiAhaGFzT3duJDUoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZW51bWVyYWJsZSB8fCAhaGFzT3duJDUodGhpcywgUCkgfHwgIWhhc093biQ1KEFsbFN5bWJvbHMsIFApIHx8IGhhc093biQ1KHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW1BdID8gZW51bWVyYWJsZSA6IHRydWU7XG4gIH07XG5cbiAgdmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICAgIHZhciBpdCA9IHRvSW5kZXhlZE9iamVjdCQ0KE8pO1xuICAgIHZhciBrZXkgPSB0b1Byb3BlcnR5S2V5KFApO1xuICAgIGlmIChpdCA9PT0gT2JqZWN0UHJvdG90eXBlJDEgJiYgaGFzT3duJDUoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzT3duJDUoT2JqZWN0UHJvdG90eXBlU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICAgIHZhciBkZXNjcmlwdG9yID0gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoaXQsIGtleSk7XG5cbiAgICBpZiAoZGVzY3JpcHRvciAmJiBoYXNPd24kNShBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzT3duJDUoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkge1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgfTtcblxuICB2YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgICB2YXIgbmFtZXMgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdCQ0KE8pKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgJGZvckVhY2gkMShuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCFoYXNPd24kNShBbGxTeW1ib2xzLCBrZXkpICYmICFoYXNPd24kNShoaWRkZW5LZXlzJDEsIGtleSkpIHB1c2gkMyhyZXN1bHQsIGtleSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhPKSB7XG4gICAgdmFyIElTX09CSkVDVF9QUk9UT1RZUEUgPSBPID09PSBPYmplY3RQcm90b3R5cGUkMTtcbiAgICB2YXIgbmFtZXMgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKElTX09CSkVDVF9QUk9UT1RZUEUgPyBPYmplY3RQcm90b3R5cGVTeW1ib2xzIDogdG9JbmRleGVkT2JqZWN0JDQoTykpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAkZm9yRWFjaCQxKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoaGFzT3duJDUoQWxsU3ltYm9scywga2V5KSAmJiAoIUlTX09CSkVDVF9QUk9UT1RZUEUgfHwgaGFzT3duJDUoT2JqZWN0UHJvdG90eXBlJDEsIGtleSkpKSB7XG4gICAgICAgIHB1c2gkMyhyZXN1bHQsIEFsbFN5bWJvbHNba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTsgLy8gYFN5bWJvbGAgY29uc3RydWN0b3JcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wtY29uc3RydWN0b3JcblxuXG4gIGlmICghTkFUSVZFX1NZTUJPTCkge1xuICAgICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgICBpZiAoaXNQcm90b3R5cGVPZiRjKFN5bWJvbFByb3RvdHlwZSwgdGhpcykpIHRocm93IFR5cGVFcnJvciQ4KCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgICAgIHZhciBkZXNjcmlwdGlvbiA9ICFhcmd1bWVudHMubGVuZ3RoIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogJHRvU3RyaW5nKGFyZ3VtZW50c1swXSk7XG4gICAgICB2YXIgdGFnID0gdWlkJDEoZGVzY3JpcHRpb24pO1xuXG4gICAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUkMSkgY2FsbCQyKHNldHRlciwgT2JqZWN0UHJvdG90eXBlU3ltYm9scywgdmFsdWUpO1xuICAgICAgICBpZiAoaGFzT3duJDUodGhpcywgSElEREVOKSAmJiBoYXNPd24kNSh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICAgIHNldFN5bWJvbERlc2NyaXB0b3IodGhpcywgdGFnLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChERVNDUklQVE9SUyQ5ICYmIFVTRV9TRVRURVIpIHNldFN5bWJvbERlc2NyaXB0b3IoT2JqZWN0UHJvdG90eXBlJDEsIHRhZywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHNldDogc2V0dGVyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB3cmFwJDEodGFnLCBkZXNjcmlwdGlvbik7XG4gICAgfTtcblxuICAgIFN5bWJvbFByb3RvdHlwZSA9ICRTeW1ib2xbUFJPVE9UWVBFXTtcbiAgICByZWRlZmluZSQxKFN5bWJvbFByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS50YWc7XG4gICAgfSk7XG4gICAgcmVkZWZpbmUkMSgkU3ltYm9sLCAnd2l0aG91dFNldHRlcicsIGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgcmV0dXJuIHdyYXAkMSh1aWQkMShkZXNjcmlwdGlvbiksIGRlc2NyaXB0aW9uKTtcbiAgICB9KTtcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGUkMTtcbiAgICBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gICAgZGVmaW5lUHJvcGVydGllc01vZHVsZS5mID0gJGRlZmluZVByb3BlcnRpZXM7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDEuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSQyLmYgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICAgIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQyLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gICAgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiB3cmFwJDEod2VsbEtub3duU3ltYm9sJDUobmFtZSksIG5hbWUpO1xuICAgIH07XG5cbiAgICBpZiAoREVTQ1JJUFRPUlMkOSkge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtU3ltYm9sLWRlc2NyaXB0aW9uXG4gICAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShTeW1ib2xQcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAkJHUoe1xuICAgIGdsb2JhbDogdHJ1ZSxcbiAgICB3cmFwOiB0cnVlLFxuICAgIGZvcmNlZDogIU5BVElWRV9TWU1CT0wsXG4gICAgc2hhbTogIU5BVElWRV9TWU1CT0xcbiAgfSwge1xuICAgIFN5bWJvbDogJFN5bWJvbFxuICB9KTtcbiAgJGZvckVhY2gkMShvYmplY3RLZXlzJDIoV2VsbEtub3duU3ltYm9sc1N0b3JlKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBkZWZpbmVXZWxsS25vd25TeW1ib2wkayhuYW1lKTtcbiAgfSk7XG4gICQkdSh7XG4gICAgdGFyZ2V0OiBTWU1CT0wsXG4gICAgc3RhdDogdHJ1ZSxcbiAgICBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MXG4gIH0sIHtcbiAgICAvLyBgU3ltYm9sLmZvcmAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuZm9yXG4gICAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBzdHJpbmcgPSAkdG9TdHJpbmcoa2V5KTtcbiAgICAgIGlmIChoYXNPd24kNShTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5LCBzdHJpbmcpKSByZXR1cm4gU3RyaW5nVG9TeW1ib2xSZWdpc3RyeVtzdHJpbmddO1xuICAgICAgdmFyIHN5bWJvbCA9ICRTeW1ib2woc3RyaW5nKTtcbiAgICAgIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXSA9IHN5bWJvbDtcbiAgICAgIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnlbc3ltYm9sXSA9IHN0cmluZztcbiAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgfSxcbiAgICAvLyBgU3ltYm9sLmtleUZvcmAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wua2V5Zm9yXG4gICAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvciQ4KHN5bSArICcgaXMgbm90IGEgc3ltYm9sJyk7XG4gICAgICBpZiAoaGFzT3duJDUoU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSwgc3ltKSkgcmV0dXJuIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnlbc3ltXTtcbiAgICB9LFxuICAgIHVzZVNldHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgVVNFX1NFVFRFUiA9IHRydWU7XG4gICAgfSxcbiAgICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFVTRV9TRVRURVIgPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICAkJHUoe1xuICAgIHRhcmdldDogJ09iamVjdCcsXG4gICAgc3RhdDogdHJ1ZSxcbiAgICBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLFxuICAgIHNoYW06ICFERVNDUklQVE9SUyQ5XG4gIH0sIHtcbiAgICAvLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4gICAgY3JlYXRlOiAkY3JlYXRlLFxuICAgIC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG4gICAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbiAgICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvclxuICB9KTtcbiAgJCR1KHtcbiAgICB0YXJnZXQ6ICdPYmplY3QnLFxuICAgIHN0YXQ6IHRydWUsXG4gICAgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTFxuICB9LCB7XG4gICAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4gICAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gICAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5c3ltYm9sc1xuICAgIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xuICB9KTsgLy8gQ2hyb21lIDM4IGFuZCAzOSBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgZmFpbHMgb24gcHJpbWl0aXZlc1xuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNDQzXG5cbiAgJCR1KHtcbiAgICB0YXJnZXQ6ICdPYmplY3QnLFxuICAgIHN0YXQ6IHRydWUsXG4gICAgZm9yY2VkOiBmYWlscyRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQyLmYoMSk7XG4gICAgfSlcbiAgfSwge1xuICAgIGdldE93blByb3BlcnR5U3ltYm9sczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gICAgICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDIuZih0b09iamVjdCQ3KGl0KSk7XG4gICAgfVxuICB9KTsgLy8gYEpTT04uc3RyaW5naWZ5YCBtZXRob2QgYmVoYXZpb3Igd2l0aCBzeW1ib2xzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtanNvbi5zdHJpbmdpZnlcblxuICBpZiAoJHN0cmluZ2lmeSQxKSB7XG4gICAgdmFyIEZPUkNFRF9KU09OX1NUUklOR0lGWSA9ICFOQVRJVkVfU1lNQk9MIHx8IGZhaWxzJGUoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN5bWJvbCA9ICRTeW1ib2woKTsgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cblxuICAgICAgcmV0dXJuICRzdHJpbmdpZnkkMShbc3ltYm9sXSkgIT0gJ1tudWxsXScgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gICAgICB8fCAkc3RyaW5naWZ5JDEoe1xuICAgICAgICBhOiBzeW1ib2xcbiAgICAgIH0pICE9ICd7fScgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgICAgIHx8ICRzdHJpbmdpZnkkMShPYmplY3Qoc3ltYm9sKSkgIT0gJ3t9JztcbiAgICB9KTtcbiAgICAkJHUoe1xuICAgICAgdGFyZ2V0OiAnSlNPTicsXG4gICAgICBzdGF0OiB0cnVlLFxuICAgICAgZm9yY2VkOiBGT1JDRURfSlNPTl9TVFJJTkdJRllcbiAgICB9LCB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgICAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UkMihhcmd1bWVudHMpO1xuICAgICAgICB2YXIgJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICAgIGlmICghaXNPYmplY3QkNyhyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuXG4gICAgICAgIGlmICghaXNBcnJheSRhKHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChpc0NhbGxhYmxlJDIoJHJlcGxhY2VyKSkgdmFsdWUgPSBjYWxsJDIoJHJlcGxhY2VyLCB0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgICAgIHJldHVybiBhcHBseSQ0KCRzdHJpbmdpZnkkMSwgbnVsbCwgYXJncyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3ByaW1pdGl2ZVxuXG5cbiAgaWYgKCFTeW1ib2xQcm90b3R5cGVbVE9fUFJJTUlUSVZFXSkge1xuICAgIHZhciB2YWx1ZU9mID0gU3ltYm9sUHJvdG90eXBlLnZhbHVlT2Y7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgLmxlbmd0aFxuXG4gICAgcmVkZWZpbmUkMShTeW1ib2xQcm90b3R5cGUsIFRPX1BSSU1JVElWRSwgZnVuY3Rpb24gKGhpbnQpIHtcbiAgICAgIC8vIFRPRE86IGltcHJvdmUgaGludCBsb2dpY1xuICAgICAgcmV0dXJuIGNhbGwkMih2YWx1ZU9mLCB0aGlzKTtcbiAgICB9KTtcbiAgfSAvLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXWAgcHJvcGVydHlcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9zdHJpbmd0YWdcblxuXG4gIHNldFRvU3RyaW5nVGFnJDIoJFN5bWJvbCwgU1lNQk9MKTtcbiAgaGlkZGVuS2V5cyQxW0hJRERFTl0gPSB0cnVlO1xuXG4gIHZhciBwYXRoJGogPSBwYXRoJHE7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMkMiA9IHBhdGgkai5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIHZhciBwYXJlbnQkSiA9IGdldE93blByb3BlcnR5U3ltYm9scyQyO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzJDEgPSBwYXJlbnQkSjtcblxuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzJDE7XG5cbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzID0ge2V4cG9ydHM6IHt9fTtcblxuICB2YXIgJCR0ID0gX2V4cG9ydDtcbiAgdmFyIGZhaWxzJGQgPSBmYWlscyRyO1xuICB2YXIgdG9JbmRleGVkT2JqZWN0JDMgPSB0b0luZGV4ZWRPYmplY3QkYjtcbiAgdmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xuICB2YXIgREVTQ1JJUFRPUlMkOCA9IGRlc2NyaXB0b3JzO1xuICB2YXIgRkFJTFNfT05fUFJJTUlUSVZFUyQzID0gZmFpbHMkZChmdW5jdGlvbiAoKSB7XG4gICAgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKDEpO1xuICB9KTtcbiAgdmFyIEZPUkNFRCQ1ID0gIURFU0NSSVBUT1JTJDggfHwgRkFJTFNfT05fUFJJTUlUSVZFUyQzOyAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuXG4gICQkdCh7XG4gICAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgICBzdGF0OiB0cnVlLFxuICAgIGZvcmNlZDogRk9SQ0VEJDUsXG4gICAgc2hhbTogIURFU0NSSVBUT1JTJDhcbiAgfSwge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JbmRleGVkT2JqZWN0JDMoaXQpLCBrZXkpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHBhdGgkaSA9IHBhdGgkcTtcbiAgdmFyIE9iamVjdCQzID0gcGF0aCRpLk9iamVjdDtcblxuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMy5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICByZXR1cm4gT2JqZWN0JDMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpO1xuICB9O1xuXG4gIGlmIChPYmplY3QkMy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iuc2hhbSkgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIuc2hhbSA9IHRydWU7XG5cbiAgdmFyIHBhcmVudCRJID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMuZXhwb3J0cztcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gcGFyZW50JEk7XG5cbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxO1xuXG4gIHZhciBnZXRCdWlsdEluJDMgPSBnZXRCdWlsdEluJDk7XG4gIHZhciB1bmN1cnJ5VGhpcyRiID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUkMSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXM7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbiAgdmFyIGFuT2JqZWN0JDIgPSBhbk9iamVjdCRiO1xuICB2YXIgY29uY2F0JDUgPSB1bmN1cnJ5VGhpcyRiKFtdLmNvbmNhdCk7IC8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcblxuICB2YXIgb3duS2V5cyQ2ID0gZ2V0QnVpbHRJbiQzKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlJDEuZihhbk9iamVjdCQyKGl0KSk7XG4gICAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxLmY7XG4gICAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdCQ1KGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbiAgfTtcblxuICB2YXIgJCRzID0gX2V4cG9ydDtcbiAgdmFyIERFU0NSSVBUT1JTJDcgPSBkZXNjcmlwdG9ycztcbiAgdmFyIG93bktleXMkNSA9IG93bktleXMkNjtcbiAgdmFyIHRvSW5kZXhlZE9iamVjdCQyID0gdG9JbmRleGVkT2JqZWN0JGI7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gIHZhciBjcmVhdGVQcm9wZXJ0eSQzID0gY3JlYXRlUHJvcGVydHkkNjsgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xuXG4gICQkcyh7XG4gICAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgICBzdGF0OiB0cnVlLFxuICAgIHNoYW06ICFERVNDUklQVE9SUyQ3XG4gIH0sIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuICAgICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkMihvYmplY3QpO1xuICAgICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICAgICAgdmFyIGtleXMgPSBvd25LZXlzJDUoTyk7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIGtleSwgZGVzY3JpcHRvcjtcblxuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBrZXkgPSBrZXlzW2luZGV4KytdKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCkgY3JlYXRlUHJvcGVydHkkMyhyZXN1bHQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcGF0aCRoID0gcGF0aCRxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyQyID0gcGF0aCRoLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xuXG4gIHZhciBwYXJlbnQkSCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMkMjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMkMSA9IHBhcmVudCRIO1xuXG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyQxO1xuXG4gIHZhciBkZWZpbmVQcm9wZXJ0aWVzJDQgPSB7ZXhwb3J0czoge319O1xuXG4gIHZhciAkJHIgPSBfZXhwb3J0O1xuICB2YXIgREVTQ1JJUFRPUlMkNiA9IGRlc2NyaXB0b3JzO1xuICB2YXIgZGVmaW5lUHJvcGVydGllcyQzID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcy5mOyAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG5cbiAgJCRyKHtcbiAgICB0YXJnZXQ6ICdPYmplY3QnLFxuICAgIHN0YXQ6IHRydWUsXG4gICAgZm9yY2VkOiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyAhPT0gZGVmaW5lUHJvcGVydGllcyQzLFxuICAgIHNoYW06ICFERVNDUklQVE9SUyQ2XG4gIH0sIHtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzOiBkZWZpbmVQcm9wZXJ0aWVzJDNcbiAgfSk7XG5cbiAgdmFyIHBhdGgkZyA9IHBhdGgkcTtcbiAgdmFyIE9iamVjdCQyID0gcGF0aCRnLk9iamVjdDtcblxuICB2YXIgZGVmaW5lUHJvcGVydGllcyQyID0gZGVmaW5lUHJvcGVydGllcyQ0LmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKFQsIEQpIHtcbiAgICByZXR1cm4gT2JqZWN0JDIuZGVmaW5lUHJvcGVydGllcyhULCBEKTtcbiAgfTtcblxuICBpZiAoT2JqZWN0JDIuZGVmaW5lUHJvcGVydGllcy5zaGFtKSBkZWZpbmVQcm9wZXJ0aWVzJDIuc2hhbSA9IHRydWU7XG5cbiAgdmFyIHBhcmVudCRHID0gZGVmaW5lUHJvcGVydGllcyQ0LmV4cG9ydHM7XG4gIHZhciBkZWZpbmVQcm9wZXJ0aWVzJDEgPSBwYXJlbnQkRztcblxuICB2YXIgZGVmaW5lUHJvcGVydGllcyA9IGRlZmluZVByb3BlcnRpZXMkMTtcblxuICB2YXIgZGVmaW5lUHJvcGVydHkkNCA9IGRlZmluZVByb3BlcnR5JGE7XG5cbiAgdmFyICQkcSA9IF9leHBvcnQ7XG4gIHZhciBpc0FycmF5JDkgPSBpc0FycmF5JGQ7IC8vIGBBcnJheS5pc0FycmF5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5pc2FycmF5XG5cbiAgJCRxKHtcbiAgICB0YXJnZXQ6ICdBcnJheScsXG4gICAgc3RhdDogdHJ1ZVxuICB9LCB7XG4gICAgaXNBcnJheTogaXNBcnJheSQ5XG4gIH0pO1xuXG4gIHZhciBwYXRoJGYgPSBwYXRoJHE7XG4gIHZhciBpc0FycmF5JDggPSBwYXRoJGYuQXJyYXkuaXNBcnJheTtcblxuICB2YXIgcGFyZW50JEYgPSBpc0FycmF5JDg7XG4gIHZhciBpc0FycmF5JDcgPSBwYXJlbnQkRjtcblxuICB2YXIgcGFyZW50JEUgPSBpc0FycmF5JDc7XG4gIHZhciBpc0FycmF5JDYgPSBwYXJlbnQkRTtcblxuICB2YXIgcGFyZW50JEQgPSBpc0FycmF5JDY7XG4gIHZhciBpc0FycmF5JDUgPSBwYXJlbnQkRDtcblxuICB2YXIgaXNBcnJheSQ0ID0gaXNBcnJheSQ1O1xuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgICBpZiAoaXNBcnJheSQ0KGFycikpIHJldHVybiBhcnI7XG4gIH1cblxuICB2YXIgJCRwID0gX2V4cG9ydDtcbiAgdmFyIGdsb2JhbCRlID0gZ2xvYmFsJE07XG4gIHZhciBmYWlscyRjID0gZmFpbHMkcjtcbiAgdmFyIGlzQXJyYXkkMyA9IGlzQXJyYXkkZDtcbiAgdmFyIGlzT2JqZWN0JDYgPSBpc09iamVjdCRmO1xuICB2YXIgdG9PYmplY3QkNiA9IHRvT2JqZWN0JGU7XG4gIHZhciBsZW5ndGhPZkFycmF5TGlrZSQ1ID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbiAgdmFyIGNyZWF0ZVByb3BlcnR5JDIgPSBjcmVhdGVQcm9wZXJ0eSQ2O1xuICB2YXIgYXJyYXlTcGVjaWVzQ3JlYXRlJDEgPSBhcnJheVNwZWNpZXNDcmVhdGUkNDtcbiAgdmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMiA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNTtcbiAgdmFyIHdlbGxLbm93blN5bWJvbCQ0ID0gd2VsbEtub3duU3ltYm9sJGo7XG4gIHZhciBWOF9WRVJTSU9OID0gZW5naW5lVjhWZXJzaW9uO1xuICB2YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEUgPSB3ZWxsS25vd25TeW1ib2wkNCgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG4gIHZhciBNQVhfU0FGRV9JTlRFR0VSJDEgPSAweDFGRkZGRkZGRkZGRkZGO1xuICB2YXIgTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEID0gJ01heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZCc7XG4gIHZhciBUeXBlRXJyb3IkNyA9IGdsb2JhbCRlLlR5cGVFcnJvcjsgLy8gV2UgY2FuJ3QgdXNlIHRoaXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4gIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcblxuICB2YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEVfU1VQUE9SVCA9IFY4X1ZFUlNJT04gPj0gNTEgfHwgIWZhaWxzJGMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGFycmF5W0lTX0NPTkNBVF9TUFJFQURBQkxFXSA9IGZhbHNlO1xuICAgIHJldHVybiBhcnJheS5jb25jYXQoKVswXSAhPT0gYXJyYXk7XG4gIH0pO1xuICB2YXIgU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQyKCdjb25jYXQnKTtcblxuICB2YXIgaXNDb25jYXRTcHJlYWRhYmxlID0gZnVuY3Rpb24gKE8pIHtcbiAgICBpZiAoIWlzT2JqZWN0JDYoTykpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgc3ByZWFkYWJsZSA9IE9bSVNfQ09OQ0FUX1NQUkVBREFCTEVdO1xuICAgIHJldHVybiBzcHJlYWRhYmxlICE9PSB1bmRlZmluZWQgPyAhIXNwcmVhZGFibGUgOiBpc0FycmF5JDMoTyk7XG4gIH07XG5cbiAgdmFyIEZPUkNFRCQ0ID0gIUlTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgfHwgIVNQRUNJRVNfU1VQUE9SVDsgLy8gYEFycmF5LnByb3RvdHlwZS5jb25jYXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5jb25jYXRcbiAgLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQGlzQ29uY2F0U3ByZWFkYWJsZSBhbmQgQEBzcGVjaWVzXG5cbiAgJCRwKHtcbiAgICB0YXJnZXQ6ICdBcnJheScsXG4gICAgcHJvdG86IHRydWUsXG4gICAgZm9yY2VkOiBGT1JDRUQkNFxuICB9LCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgICBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdChhcmcpIHtcbiAgICAgIHZhciBPID0gdG9PYmplY3QkNih0aGlzKTtcbiAgICAgIHZhciBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDEoTywgMCk7XG4gICAgICB2YXIgbiA9IDA7XG4gICAgICB2YXIgaSwgaywgbGVuZ3RoLCBsZW4sIEU7XG5cbiAgICAgIGZvciAoaSA9IC0xLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgRSA9IGkgPT09IC0xID8gTyA6IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICBpZiAoaXNDb25jYXRTcHJlYWRhYmxlKEUpKSB7XG4gICAgICAgICAgbGVuID0gbGVuZ3RoT2ZBcnJheUxpa2UkNShFKTtcbiAgICAgICAgICBpZiAobiArIGxlbiA+IE1BWF9TQUZFX0lOVEVHRVIkMSkgdGhyb3cgVHlwZUVycm9yJDcoTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEKTtcblxuICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBsZW47IGsrKywgbisrKSBpZiAoayBpbiBFKSBjcmVhdGVQcm9wZXJ0eSQyKEEsIG4sIEVba10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChuID49IE1BWF9TQUZFX0lOVEVHRVIkMSkgdGhyb3cgVHlwZUVycm9yJDcoTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEKTtcbiAgICAgICAgICBjcmVhdGVQcm9wZXJ0eSQyKEEsIG4rKywgRSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgQS5sZW5ndGggPSBuO1xuICAgICAgcmV0dXJuIEE7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGogPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5hc3luY0l0ZXJhdG9yYCB3ZWxsLWtub3duIHN5bWJvbFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5hc3luY2l0ZXJhdG9yXG5cbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJGooJ2FzeW5jSXRlcmF0b3InKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGkgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5oYXNJbnN0YW5jZWAgd2VsbC1rbm93biBzeW1ib2xcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuaGFzaW5zdGFuY2VcblxuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkaSgnaGFzSW5zdGFuY2UnKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGggPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGVgIHdlbGwta25vd24gc3ltYm9sXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmlzY29uY2F0c3ByZWFkYWJsZVxuXG4gIGRlZmluZVdlbGxLbm93blN5bWJvbCRoKCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGcgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5pdGVyYXRvcmAgd2VsbC1rbm93biBzeW1ib2xcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuaXRlcmF0b3JcblxuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkZygnaXRlcmF0b3InKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGYgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5tYXRjaGAgd2VsbC1rbm93biBzeW1ib2xcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wubWF0Y2hcblxuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkZignbWF0Y2gnKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGUgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5tYXRjaEFsbGAgd2VsbC1rbm93biBzeW1ib2xcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wubWF0Y2hhbGxcblxuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkZSgnbWF0Y2hBbGwnKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGQgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5yZXBsYWNlYCB3ZWxsLWtub3duIHN5bWJvbFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5yZXBsYWNlXG5cbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJGQoJ3JlcGxhY2UnKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGMgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5zZWFyY2hgIHdlbGwta25vd24gc3ltYm9sXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnNlYXJjaFxuXG4gIGRlZmluZVdlbGxLbm93blN5bWJvbCRjKCdzZWFyY2gnKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGIgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5zcGVjaWVzYCB3ZWxsLWtub3duIHN5bWJvbFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5zcGVjaWVzXG5cbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJGIoJ3NwZWNpZXMnKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGEgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5zcGxpdGAgd2VsbC1rbm93biBzeW1ib2xcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuc3BsaXRcblxuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkYSgnc3BsaXQnKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDkgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC50b1ByaW1pdGl2ZWAgd2VsbC1rbm93biBzeW1ib2xcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wudG9wcmltaXRpdmVcblxuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkOSgndG9QcmltaXRpdmUnKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDggPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC50b1N0cmluZ1RhZ2Agd2VsbC1rbm93biBzeW1ib2xcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wudG9zdHJpbmd0YWdcblxuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkOCgndG9TdHJpbmdUYWcnKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDcgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC51bnNjb3BhYmxlc2Agd2VsbC1rbm93biBzeW1ib2xcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wudW5zY29wYWJsZXNcblxuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkNygndW5zY29wYWJsZXMnKTtcblxuICB2YXIgZ2xvYmFsJGQgPSBnbG9iYWwkTTtcbiAgdmFyIHNldFRvU3RyaW5nVGFnJDEgPSBzZXRUb1N0cmluZ1RhZyQ1OyAvLyBKU09OW0BAdG9TdHJpbmdUYWddIHByb3BlcnR5XG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtanNvbi1AQHRvc3RyaW5ndGFnXG5cbiAgc2V0VG9TdHJpbmdUYWckMShnbG9iYWwkZC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG4gIHZhciBwYXRoJGUgPSBwYXRoJHE7XG4gIHZhciBzeW1ib2wkNSA9IHBhdGgkZS5TeW1ib2w7XG5cbiAgdmFyIHBhcmVudCRDID0gc3ltYm9sJDU7XG4gIHZhciBzeW1ib2wkNCA9IHBhcmVudCRDO1xuXG4gIHZhciBwYXJlbnQkQiA9IHN5bWJvbCQ0O1xuICB2YXIgc3ltYm9sJDMgPSBwYXJlbnQkQjtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDYgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5hc3luY0Rpc3Bvc2VgIHdlbGwta25vd24gc3ltYm9sXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXVzaW5nLXN0YXRlbWVudFxuXG4gIGRlZmluZVdlbGxLbm93blN5bWJvbCQ2KCdhc3luY0Rpc3Bvc2UnKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDUgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5kaXNwb3NlYCB3ZWxsLWtub3duIHN5bWJvbFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC11c2luZy1zdGF0ZW1lbnRcblxuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkNSgnZGlzcG9zZScpO1xuXG4gIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkNCA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLm1hdGNoZXJgIHdlbGwta25vd24gc3ltYm9sXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXBhdHRlcm4tbWF0Y2hpbmdcblxuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkNCgnbWF0Y2hlcicpO1xuXG4gIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkMyA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLm1ldGFkYXRhYCB3ZWxsLWtub3duIHN5bWJvbFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1kZWNvcmF0b3JzXG5cbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJDMoJ21ldGFkYXRhJyk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQyID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wub2JzZXJ2YWJsZWAgd2VsbC1rbm93biBzeW1ib2xcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZVxuXG4gIGRlZmluZVdlbGxLbm93blN5bWJvbCQyKCdvYnNlcnZhYmxlJyk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQxID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wucGF0dGVybk1hdGNoYCB3ZWxsLWtub3duIHN5bWJvbFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wYXR0ZXJuLW1hdGNoaW5nXG5cbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJDEoJ3BhdHRlcm5NYXRjaCcpO1xuXG4gIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDtcbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sKCdyZXBsYWNlQWxsJyk7XG5cbiAgdmFyIHBhcmVudCRBID0gc3ltYm9sJDM7IC8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG4gIC8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG5cbiAgdmFyIHN5bWJvbCQyID0gcGFyZW50JEE7XG5cbiAgdmFyIHN5bWJvbCQxID0gc3ltYm9sJDI7XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICAgIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBzeW1ib2wkMSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKGFycikgfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICAgIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuXG4gICAgdmFyIF9zLCBfZTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICB2YXIgJCRvID0gX2V4cG9ydDtcbiAgdmFyIGdsb2JhbCRjID0gZ2xvYmFsJE07XG4gIHZhciBpc0FycmF5JDIgPSBpc0FycmF5JGQ7XG4gIHZhciBpc0NvbnN0cnVjdG9yJDEgPSBpc0NvbnN0cnVjdG9yJDQ7XG4gIHZhciBpc09iamVjdCQ1ID0gaXNPYmplY3QkZjtcbiAgdmFyIHRvQWJzb2x1dGVJbmRleCQyID0gdG9BYnNvbHV0ZUluZGV4JDU7XG4gIHZhciBsZW5ndGhPZkFycmF5TGlrZSQ0ID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbiAgdmFyIHRvSW5kZXhlZE9iamVjdCQxID0gdG9JbmRleGVkT2JqZWN0JGI7XG4gIHZhciBjcmVhdGVQcm9wZXJ0eSQxID0gY3JlYXRlUHJvcGVydHkkNjtcbiAgdmFyIHdlbGxLbm93blN5bWJvbCQzID0gd2VsbEtub3duU3ltYm9sJGo7XG4gIHZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDEgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDU7XG4gIHZhciB1biRTbGljZSA9IGFycmF5U2xpY2UkNTtcbiAgdmFyIEhBU19TUEVDSUVTX1NVUFBPUlQkMSA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMSgnc2xpY2UnKTtcbiAgdmFyIFNQRUNJRVMkMSA9IHdlbGxLbm93blN5bWJvbCQzKCdzcGVjaWVzJyk7XG4gIHZhciBBcnJheSQyID0gZ2xvYmFsJGMuQXJyYXk7XG4gIHZhciBtYXgkMSA9IE1hdGgubWF4OyAvLyBgQXJyYXkucHJvdG90eXBlLnNsaWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xuXG4gICQkbyh7XG4gICAgdGFyZ2V0OiAnQXJyYXknLFxuICAgIHByb3RvOiB0cnVlLFxuICAgIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQkMVxuICB9LCB7XG4gICAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0JDEodGhpcyk7XG4gICAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNChPKTtcbiAgICAgIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4JDIoc3RhcnQsIGxlbmd0aCk7XG4gICAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4JDIoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7IC8vIGlubGluZSBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBmb3IgdXNhZ2UgbmF0aXZlIGBBcnJheSNzbGljZWAgd2hlcmUgaXQncyBwb3NzaWJsZVxuXG4gICAgICB2YXIgQ29uc3RydWN0b3IsIHJlc3VsdCwgbjtcblxuICAgICAgaWYgKGlzQXJyYXkkMihPKSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IE8uY29uc3RydWN0b3I7IC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG5cbiAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IkMShDb25zdHJ1Y3RvcikgJiYgKENvbnN0cnVjdG9yID09PSBBcnJheSQyIHx8IGlzQXJyYXkkMihDb25zdHJ1Y3Rvci5wcm90b3R5cGUpKSkge1xuICAgICAgICAgIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0JDUoQ29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcltTUEVDSUVTJDFdO1xuICAgICAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gbnVsbCkgQ29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQ29uc3RydWN0b3IgPT09IEFycmF5JDIgfHwgQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB1biRTbGljZShPLCBrLCBmaW4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IG5ldyAoQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCA/IEFycmF5JDIgOiBDb25zdHJ1Y3RvcikobWF4JDEoZmluIC0gaywgMCkpO1xuXG4gICAgICBmb3IgKG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgaWYgKGsgaW4gTykgY3JlYXRlUHJvcGVydHkkMShyZXN1bHQsIG4sIE9ba10pO1xuXG4gICAgICByZXN1bHQubGVuZ3RoID0gbjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZW50cnlWaXJ0dWFsJGUgPSBlbnRyeVZpcnR1YWwkaztcbiAgdmFyIHNsaWNlJDYgPSBlbnRyeVZpcnR1YWwkZSgnQXJyYXknKS5zbGljZTtcblxuICB2YXIgaXNQcm90b3R5cGVPZiRiID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbiAgdmFyIG1ldGhvZCQ5ID0gc2xpY2UkNjtcbiAgdmFyIEFycmF5UHJvdG90eXBlJDkgPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgdmFyIHNsaWNlJDUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgb3duID0gaXQuc2xpY2U7XG4gICAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQ5IHx8IGlzUHJvdG90eXBlT2YkYihBcnJheVByb3RvdHlwZSQ5LCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQ5LnNsaWNlID8gbWV0aG9kJDkgOiBvd247XG4gIH07XG5cbiAgdmFyIHBhcmVudCR6ID0gc2xpY2UkNTtcbiAgdmFyIHNsaWNlJDQgPSBwYXJlbnQkejtcblxuICB2YXIgcGFyZW50JHkgPSBzbGljZSQ0O1xuICB2YXIgc2xpY2UkMyA9IHBhcmVudCR5O1xuXG4gIHZhciBwYXJlbnQkeCA9IHNsaWNlJDM7XG4gIHZhciBzbGljZSQyID0gcGFyZW50JHg7XG5cbiAgdmFyIHNsaWNlJDEgPSBzbGljZSQyO1xuXG4gIHZhciBwYXJlbnQkdyA9IGZyb20kNDtcbiAgdmFyIGZyb20kMiA9IHBhcmVudCR3O1xuXG4gIHZhciBwYXJlbnQkdiA9IGZyb20kMjtcbiAgdmFyIGZyb20kMSA9IHBhcmVudCR2O1xuXG4gIHZhciBmcm9tID0gZnJvbSQxO1xuXG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDQoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ0KG8sIG1pbkxlbikge1xuICAgIHZhciBfY29udGV4dDtcblxuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDQobywgbWluTGVuKTtcblxuICAgIHZhciBuID0gc2xpY2UkMShfY29udGV4dCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dCwgOCwgLTEpO1xuXG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gZnJvbShvKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDQobywgbWluTGVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICAgIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNChhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbiAgfVxuXG4gIHZhciBXcmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gd2VsbEtub3duU3ltYm9sV3JhcHBlZDtcbiAgdmFyIGl0ZXJhdG9yJDUgPSBXcmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYoJ2l0ZXJhdG9yJyk7XG5cbiAgdmFyIHBhcmVudCR1ID0gaXRlcmF0b3IkNTtcbiAgdmFyIGl0ZXJhdG9yJDQgPSBwYXJlbnQkdTtcblxuICB2YXIgcGFyZW50JHQgPSBpdGVyYXRvciQ0O1xuICB2YXIgaXRlcmF0b3IkMyA9IHBhcmVudCR0O1xuXG4gIHZhciBwYXJlbnQkcyA9IGl0ZXJhdG9yJDM7XG4gIHZhciBpdGVyYXRvciQyID0gcGFyZW50JHM7XG5cbiAgdmFyIGl0ZXJhdG9yJDEgPSBpdGVyYXRvciQyO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gICAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHN5bWJvbCQxICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIGl0ZXJhdG9yJDEgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHN5bWJvbCQxICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gc3ltYm9sJDEgJiYgb2JqICE9PSBzeW1ib2wkMS5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9LCBfdHlwZW9mKG9iaik7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgaWYgKGlzQXJyYXkkNChhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNChhcnIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBzeW1ib2wkMSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKGl0ZXIpICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIGZyb20oaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNChhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xuICB9XG5cbiAgdmFyIHN5bWJvbCA9IHN5bWJvbCQ0O1xuXG4gIHZhciBlbnRyeVZpcnR1YWwkZCA9IGVudHJ5VmlydHVhbCRrO1xuICB2YXIgY29uY2F0JDQgPSBlbnRyeVZpcnR1YWwkZCgnQXJyYXknKS5jb25jYXQ7XG5cbiAgdmFyIGlzUHJvdG90eXBlT2YkYSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG4gIHZhciBtZXRob2QkOCA9IGNvbmNhdCQ0O1xuICB2YXIgQXJyYXlQcm90b3R5cGUkOCA9IEFycmF5LnByb3RvdHlwZTtcblxuICB2YXIgY29uY2F0JDMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgb3duID0gaXQuY29uY2F0O1xuICAgIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkOCB8fCBpc1Byb3RvdHlwZU9mJGEoQXJyYXlQcm90b3R5cGUkOCwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkOC5jb25jYXQgPyBtZXRob2QkOCA6IG93bjtcbiAgfTtcblxuICB2YXIgcGFyZW50JHIgPSBjb25jYXQkMztcbiAgdmFyIGNvbmNhdCQyID0gcGFyZW50JHI7XG5cbiAgdmFyIGNvbmNhdCQxID0gY29uY2F0JDI7XG5cbiAgdmFyIHNsaWNlID0gc2xpY2UkNDtcblxuICB2YXIgJCRuID0gX2V4cG9ydDtcbiAgdmFyIG93bktleXMkNCA9IG93bktleXMkNjsgLy8gYFJlZmxlY3Qub3duS2V5c2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVmbGVjdC5vd25rZXlzXG5cbiAgJCRuKHtcbiAgICB0YXJnZXQ6ICdSZWZsZWN0JyxcbiAgICBzdGF0OiB0cnVlXG4gIH0sIHtcbiAgICBvd25LZXlzOiBvd25LZXlzJDRcbiAgfSk7XG5cbiAgdmFyIHBhdGgkZCA9IHBhdGgkcTtcbiAgdmFyIG93bktleXMkMyA9IHBhdGgkZC5SZWZsZWN0Lm93bktleXM7XG5cbiAgdmFyIHBhcmVudCRxID0gb3duS2V5cyQzO1xuICB2YXIgb3duS2V5cyQyID0gcGFyZW50JHE7XG5cbiAgdmFyIG93bktleXMkMSA9IG93bktleXMkMjtcblxuICB2YXIgaXNBcnJheSQxID0gaXNBcnJheSQ3O1xuXG4gIHZhciAkJG0gPSBfZXhwb3J0O1xuICB2YXIgdG9PYmplY3QkNSA9IHRvT2JqZWN0JGU7XG4gIHZhciBuYXRpdmVLZXlzID0gb2JqZWN0S2V5cyQ0O1xuICB2YXIgZmFpbHMkYiA9IGZhaWxzJHI7XG4gIHZhciBGQUlMU19PTl9QUklNSVRJVkVTJDIgPSBmYWlscyRiKGZ1bmN0aW9uICgpIHtcbiAgICBuYXRpdmVLZXlzKDEpO1xuICB9KTsgLy8gYE9iamVjdC5rZXlzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuXG4gICQkbSh7XG4gICAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgICBzdGF0OiB0cnVlLFxuICAgIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUyQyXG4gIH0sIHtcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgICByZXR1cm4gbmF0aXZlS2V5cyh0b09iamVjdCQ1KGl0KSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcGF0aCRjID0gcGF0aCRxO1xuICB2YXIga2V5cyQ2ID0gcGF0aCRjLk9iamVjdC5rZXlzO1xuXG4gIHZhciBwYXJlbnQkcCA9IGtleXMkNjtcbiAgdmFyIGtleXMkNSA9IHBhcmVudCRwO1xuXG4gIHZhciBrZXlzJDQgPSBrZXlzJDU7XG5cbiAgdmFyICQkbCA9IF9leHBvcnQ7XG4gIHZhciBnbG9iYWwkYiA9IGdsb2JhbCRNO1xuICB2YXIgdW5jdXJyeVRoaXMkYSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBEYXRlJDEgPSBnbG9iYWwkYi5EYXRlO1xuICB2YXIgZ2V0VGltZSA9IHVuY3VycnlUaGlzJGEoRGF0ZSQxLnByb3RvdHlwZS5nZXRUaW1lKTsgLy8gYERhdGUubm93YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1kYXRlLm5vd1xuXG4gICQkbCh7XG4gICAgdGFyZ2V0OiAnRGF0ZScsXG4gICAgc3RhdDogdHJ1ZVxuICB9LCB7XG4gICAgbm93OiBmdW5jdGlvbiBub3coKSB7XG4gICAgICByZXR1cm4gZ2V0VGltZShuZXcgRGF0ZSQxKCkpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHBhdGgkYiA9IHBhdGgkcTtcbiAgcGF0aCRiLkRhdGUubm93O1xuXG4gIHZhciAkZm9yRWFjaCA9IGFycmF5SXRlcmF0aW9uLmZvckVhY2g7XG4gIHZhciBhcnJheU1ldGhvZElzU3RyaWN0JDMgPSBhcnJheU1ldGhvZElzU3RyaWN0JDU7XG4gIHZhciBTVFJJQ1RfTUVUSE9EJDMgPSBhcnJheU1ldGhvZElzU3RyaWN0JDMoJ2ZvckVhY2gnKTsgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuXG4gIHZhciBhcnJheUZvckVhY2ggPSAhU1RSSUNUX01FVEhPRCQzID8gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuXG4gIC8qICwgdGhpc0FyZyAqL1xuICApIHtcbiAgICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWZvcmVhY2ggLS0gc2FmZVxuICB9IDogW10uZm9yRWFjaDtcblxuICB2YXIgJCRrID0gX2V4cG9ydDtcbiAgdmFyIGZvckVhY2gkNSA9IGFycmF5Rm9yRWFjaDsgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWZvcmVhY2ggLS0gc2FmZVxuXG4gICQkayh7XG4gICAgdGFyZ2V0OiAnQXJyYXknLFxuICAgIHByb3RvOiB0cnVlLFxuICAgIGZvcmNlZDogW10uZm9yRWFjaCAhPSBmb3JFYWNoJDVcbiAgfSwge1xuICAgIGZvckVhY2g6IGZvckVhY2gkNVxuICB9KTtcblxuICB2YXIgZW50cnlWaXJ0dWFsJGMgPSBlbnRyeVZpcnR1YWwkaztcbiAgdmFyIGZvckVhY2gkNCA9IGVudHJ5VmlydHVhbCRjKCdBcnJheScpLmZvckVhY2g7XG5cbiAgdmFyIHBhcmVudCRvID0gZm9yRWFjaCQ0O1xuICB2YXIgZm9yRWFjaCQzID0gcGFyZW50JG87XG5cbiAgdmFyIGNsYXNzb2YkNSA9IGNsYXNzb2YkYztcbiAgdmFyIGhhc093biQ0ID0gaGFzT3duUHJvcGVydHlfMTtcbiAgdmFyIGlzUHJvdG90eXBlT2YkOSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG4gIHZhciBtZXRob2QkNyA9IGZvckVhY2gkMztcbiAgdmFyIEFycmF5UHJvdG90eXBlJDcgPSBBcnJheS5wcm90b3R5cGU7XG4gIHZhciBET01JdGVyYWJsZXMkMyA9IHtcbiAgICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gICAgTm9kZUxpc3Q6IHRydWVcbiAgfTtcblxuICB2YXIgZm9yRWFjaCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIG93biA9IGl0LmZvckVhY2g7XG4gICAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQ3IHx8IGlzUHJvdG90eXBlT2YkOShBcnJheVByb3RvdHlwZSQ3LCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQ3LmZvckVhY2ggfHwgaGFzT3duJDQoRE9NSXRlcmFibGVzJDMsIGNsYXNzb2YkNShpdCkpID8gbWV0aG9kJDcgOiBvd247XG4gIH07XG5cbiAgdmFyIGZvckVhY2gkMSA9IGZvckVhY2gkMjtcblxuICB2YXIgJCRqID0gX2V4cG9ydDtcbiAgdmFyIHVuY3VycnlUaGlzJDkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgaXNBcnJheSA9IGlzQXJyYXkkZDtcbiAgdmFyIHVuJFJldmVyc2UgPSB1bmN1cnJ5VGhpcyQ5KFtdLnJldmVyc2UpO1xuICB2YXIgdGVzdCQxID0gWzEsIDJdOyAvLyBgQXJyYXkucHJvdG90eXBlLnJldmVyc2VgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZXZlcnNlXG4gIC8vIGZpeCBmb3IgU2FmYXJpIDEyLjAgYnVnXG4gIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODg3OTRcblxuICAkJGooe1xuICAgIHRhcmdldDogJ0FycmF5JyxcbiAgICBwcm90bzogdHJ1ZSxcbiAgICBmb3JjZWQ6IFN0cmluZyh0ZXN0JDEpID09PSBTdHJpbmcodGVzdCQxLnJldmVyc2UoKSlcbiAgfSwge1xuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ24gLS0gZGlydHkgaGFja1xuICAgICAgaWYgKGlzQXJyYXkodGhpcykpIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gdW4kUmV2ZXJzZSh0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBlbnRyeVZpcnR1YWwkYiA9IGVudHJ5VmlydHVhbCRrO1xuICB2YXIgcmV2ZXJzZSQzID0gZW50cnlWaXJ0dWFsJGIoJ0FycmF5JykucmV2ZXJzZTtcblxuICB2YXIgaXNQcm90b3R5cGVPZiQ4ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbiAgdmFyIG1ldGhvZCQ2ID0gcmV2ZXJzZSQzO1xuICB2YXIgQXJyYXlQcm90b3R5cGUkNiA9IEFycmF5LnByb3RvdHlwZTtcblxuICB2YXIgcmV2ZXJzZSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIG93biA9IGl0LnJldmVyc2U7XG4gICAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQ2IHx8IGlzUHJvdG90eXBlT2YkOChBcnJheVByb3RvdHlwZSQ2LCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQ2LnJldmVyc2UgPyBtZXRob2QkNiA6IG93bjtcbiAgfTtcblxuICB2YXIgcGFyZW50JG4gPSByZXZlcnNlJDI7XG4gIHZhciByZXZlcnNlJDEgPSBwYXJlbnQkbjtcblxuICB2YXIgcmV2ZXJzZSA9IHJldmVyc2UkMTtcblxuICB2YXIgJCRpID0gX2V4cG9ydDtcbiAgdmFyIGdsb2JhbCRhID0gZ2xvYmFsJE07XG4gIHZhciB0b0Fic29sdXRlSW5kZXgkMSA9IHRvQWJzb2x1dGVJbmRleCQ1O1xuICB2YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNDtcbiAgdmFyIGxlbmd0aE9mQXJyYXlMaWtlJDMgPSBsZW5ndGhPZkFycmF5TGlrZSRkO1xuICB2YXIgdG9PYmplY3QkNCA9IHRvT2JqZWN0JGU7XG4gIHZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBhcnJheVNwZWNpZXNDcmVhdGUkNDtcbiAgdmFyIGNyZWF0ZVByb3BlcnR5ID0gY3JlYXRlUHJvcGVydHkkNjtcbiAgdmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDU7XG4gIHZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnc3BsaWNlJyk7XG4gIHZhciBUeXBlRXJyb3IkNiA9IGdsb2JhbCRhLlR5cGVFcnJvcjtcbiAgdmFyIG1heCA9IE1hdGgubWF4O1xuICB2YXIgbWluID0gTWF0aC5taW47XG4gIHZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxRkZGRkZGRkZGRkZGRjtcbiAgdmFyIE1BWElNVU1fQUxMT1dFRF9MRU5HVEhfRVhDRUVERUQgPSAnTWF4aW11bSBhbGxvd2VkIGxlbmd0aCBleGNlZWRlZCc7IC8vIGBBcnJheS5wcm90b3R5cGUuc3BsaWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc3BsaWNlXG4gIC8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG5cbiAgJCRpKHtcbiAgICB0YXJnZXQ6ICdBcnJheScsXG4gICAgcHJvdG86IHRydWUsXG4gICAgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVFxuICB9LCB7XG4gICAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50XG4gICAgLyogLCAuLi5pdGVtcyAqL1xuICAgICkge1xuICAgICAgdmFyIE8gPSB0b09iamVjdCQ0KHRoaXMpO1xuICAgICAgdmFyIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlJDMoTyk7XG4gICAgICB2YXIgYWN0dWFsU3RhcnQgPSB0b0Fic29sdXRlSW5kZXgkMShzdGFydCwgbGVuKTtcbiAgICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIGluc2VydENvdW50LCBhY3R1YWxEZWxldGVDb3VudCwgQSwgaywgZnJvbSwgdG87XG5cbiAgICAgIGlmIChhcmd1bWVudHNMZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5zZXJ0Q291bnQgPSBhY3R1YWxEZWxldGVDb3VudCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c0xlbmd0aCA9PT0gMSkge1xuICAgICAgICBpbnNlcnRDb3VudCA9IDA7XG4gICAgICAgIGFjdHVhbERlbGV0ZUNvdW50ID0gbGVuIC0gYWN0dWFsU3RhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnNlcnRDb3VudCA9IGFyZ3VtZW50c0xlbmd0aCAtIDI7XG4gICAgICAgIGFjdHVhbERlbGV0ZUNvdW50ID0gbWluKG1heCh0b0ludGVnZXJPckluZmluaXR5KGRlbGV0ZUNvdW50KSwgMCksIGxlbiAtIGFjdHVhbFN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxlbiArIGluc2VydENvdW50IC0gYWN0dWFsRGVsZXRlQ291bnQgPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvciQ2KE1BWElNVU1fQUxMT1dFRF9MRU5HVEhfRVhDRUVERUQpO1xuICAgICAgfVxuXG4gICAgICBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIGFjdHVhbERlbGV0ZUNvdW50KTtcblxuICAgICAgZm9yIChrID0gMDsgayA8IGFjdHVhbERlbGV0ZUNvdW50OyBrKyspIHtcbiAgICAgICAgZnJvbSA9IGFjdHVhbFN0YXJ0ICsgaztcbiAgICAgICAgaWYgKGZyb20gaW4gTykgY3JlYXRlUHJvcGVydHkoQSwgaywgT1tmcm9tXSk7XG4gICAgICB9XG5cbiAgICAgIEEubGVuZ3RoID0gYWN0dWFsRGVsZXRlQ291bnQ7XG5cbiAgICAgIGlmIChpbnNlcnRDb3VudCA8IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICAgIGZvciAoayA9IGFjdHVhbFN0YXJ0OyBrIDwgbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7IGsrKykge1xuICAgICAgICAgIGZyb20gPSBrICsgYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgICAgICAgdG8gPSBrICsgaW5zZXJ0Q291bnQ7XG4gICAgICAgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO2Vsc2UgZGVsZXRlIE9bdG9dO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrID0gbGVuOyBrID4gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpbnNlcnRDb3VudDsgay0tKSBkZWxldGUgT1trIC0gMV07XG4gICAgICB9IGVsc2UgaWYgKGluc2VydENvdW50ID4gYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgICAgZm9yIChrID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7IGsgPiBhY3R1YWxTdGFydDsgay0tKSB7XG4gICAgICAgICAgZnJvbSA9IGsgKyBhY3R1YWxEZWxldGVDb3VudCAtIDE7XG4gICAgICAgICAgdG8gPSBrICsgaW5zZXJ0Q291bnQgLSAxO1xuICAgICAgICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGsgPSAwOyBrIDwgaW5zZXJ0Q291bnQ7IGsrKykge1xuICAgICAgICBPW2sgKyBhY3R1YWxTdGFydF0gPSBhcmd1bWVudHNbayArIDJdO1xuICAgICAgfVxuXG4gICAgICBPLmxlbmd0aCA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaW5zZXJ0Q291bnQ7XG4gICAgICByZXR1cm4gQTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBlbnRyeVZpcnR1YWwkYSA9IGVudHJ5VmlydHVhbCRrO1xuICB2YXIgc3BsaWNlJDMgPSBlbnRyeVZpcnR1YWwkYSgnQXJyYXknKS5zcGxpY2U7XG5cbiAgdmFyIGlzUHJvdG90eXBlT2YkNyA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG4gIHZhciBtZXRob2QkNSA9IHNwbGljZSQzO1xuICB2YXIgQXJyYXlQcm90b3R5cGUkNSA9IEFycmF5LnByb3RvdHlwZTtcblxuICB2YXIgc3BsaWNlJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgb3duID0gaXQuc3BsaWNlO1xuICAgIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkNSB8fCBpc1Byb3RvdHlwZU9mJDcoQXJyYXlQcm90b3R5cGUkNSwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkNS5zcGxpY2UgPyBtZXRob2QkNSA6IG93bjtcbiAgfTtcblxuICB2YXIgcGFyZW50JG0gPSBzcGxpY2UkMjtcbiAgdmFyIHNwbGljZSQxID0gcGFyZW50JG07XG5cbiAgdmFyIHNwbGljZSA9IHNwbGljZSQxO1xuXG4gIHZhciBERVNDUklQVE9SUyQ1ID0gZGVzY3JpcHRvcnM7XG4gIHZhciB1bmN1cnJ5VGhpcyQ4ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIGNhbGwkMSA9IGZ1bmN0aW9uQ2FsbDtcbiAgdmFyIGZhaWxzJGEgPSBmYWlscyRyO1xuICB2YXIgb2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5cyQ0O1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgdmFyIHRvT2JqZWN0JDMgPSB0b09iamVjdCRlO1xuICB2YXIgSW5kZXhlZE9iamVjdCA9IGluZGV4ZWRPYmplY3Q7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtYXNzaWduIC0tIHNhZmVcblxuICB2YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcblxuICB2YXIgZGVmaW5lUHJvcGVydHkkMyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgdmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzJDgoW10uY29uY2F0KTsgLy8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cblxuICB2YXIgb2JqZWN0QXNzaWduID0gISRhc3NpZ24gfHwgZmFpbHMkYShmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2hvdWxkIGhhdmUgY29ycmVjdCBvcmRlciBvZiBvcGVyYXRpb25zIChFZGdlIGJ1ZylcbiAgICBpZiAoREVTQ1JJUFRPUlMkNSAmJiAkYXNzaWduKHtcbiAgICAgIGI6IDFcbiAgICB9LCAkYXNzaWduKGRlZmluZVByb3BlcnR5JDMoe30sICdhJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSQzKHRoaXMsICdiJywge1xuICAgICAgICAgIHZhbHVlOiAzLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLCB7XG4gICAgICBiOiAyXG4gICAgfSkpLmIgIT09IDEpIHJldHVybiB0cnVlOyAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcblxuICAgIHZhciBBID0ge307XG4gICAgdmFyIEIgPSB7fTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXN5bWJvbCAtLSBzYWZlXG5cbiAgICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gICAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgICBBW3N5bWJvbF0gPSA3O1xuICAgIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHtcbiAgICAgIEJbY2hyXSA9IGNocjtcbiAgICB9KTtcbiAgICByZXR1cm4gJGFzc2lnbih7fSwgQSlbc3ltYm9sXSAhPSA3IHx8IG9iamVjdEtleXMkMSgkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gYWxwaGFiZXQ7XG4gIH0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gICAgdmFyIFQgPSB0b09iamVjdCQzKHRhcmdldCk7XG4gICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gMTtcbiAgICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gICAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcblxuICAgIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFyIFMgPSBJbmRleGVkT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdChvYmplY3RLZXlzJDEoUyksIGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzJDEoUyk7XG4gICAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICB2YXIgaiA9IDA7XG4gICAgICB2YXIga2V5O1xuXG4gICAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICAgIGlmICghREVTQ1JJUFRPUlMkNSB8fCBjYWxsJDEocHJvcGVydHlJc0VudW1lcmFibGUsIFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gVDtcbiAgfSA6ICRhc3NpZ247XG5cbiAgdmFyICQkaCA9IF9leHBvcnQ7XG4gIHZhciBhc3NpZ24kNSA9IG9iamVjdEFzc2lnbjsgLy8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1hc3NpZ24gLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcblxuICAkJGgoe1xuICAgIHRhcmdldDogJ09iamVjdCcsXG4gICAgc3RhdDogdHJ1ZSxcbiAgICBmb3JjZWQ6IE9iamVjdC5hc3NpZ24gIT09IGFzc2lnbiQ1XG4gIH0sIHtcbiAgICBhc3NpZ246IGFzc2lnbiQ1XG4gIH0pO1xuXG4gIHZhciBwYXRoJGEgPSBwYXRoJHE7XG4gIHZhciBhc3NpZ24kNCA9IHBhdGgkYS5PYmplY3QuYXNzaWduO1xuXG4gIHZhciBwYXJlbnQkbCA9IGFzc2lnbiQ0O1xuICB2YXIgYXNzaWduJDMgPSBwYXJlbnQkbDtcblxuICB2YXIgYXNzaWduJDIgPSBhc3NpZ24kMztcblxuICB2YXIgJCRnID0gX2V4cG9ydDtcbiAgdmFyICRpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMuaW5jbHVkZXM7XG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG5cbiAgJCRnKHtcbiAgICB0YXJnZXQ6ICdBcnJheScsXG4gICAgcHJvdG86IHRydWVcbiAgfSwge1xuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbFxuICAgIC8qICwgZnJvbUluZGV4ID0gMCAqL1xuICAgICkge1xuICAgICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfSk7IC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcblxuICB2YXIgZW50cnlWaXJ0dWFsJDkgPSBlbnRyeVZpcnR1YWwkaztcbiAgZW50cnlWaXJ0dWFsJDkoJ0FycmF5JykuaW5jbHVkZXM7XG5cbiAgdmFyIGlzT2JqZWN0JDQgPSBpc09iamVjdCRmO1xuICB2YXIgY2xhc3NvZiQ0ID0gY2xhc3NvZlJhdyQxO1xuICB2YXIgd2VsbEtub3duU3ltYm9sJDIgPSB3ZWxsS25vd25TeW1ib2wkajtcbiAgdmFyIE1BVENIJDEgPSB3ZWxsS25vd25TeW1ib2wkMignbWF0Y2gnKTsgLy8gYElzUmVnRXhwYCBhYnN0cmFjdCBvcGVyYXRpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc3JlZ2V4cFxuXG4gIHZhciBpc1JlZ2V4cCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBpc1JlZ0V4cDtcbiAgICByZXR1cm4gaXNPYmplY3QkNChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIJDFdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNsYXNzb2YkNChpdCkgPT0gJ1JlZ0V4cCcpO1xuICB9O1xuXG4gIHZhciBnbG9iYWwkOSA9IGdsb2JhbCRNO1xuICB2YXIgaXNSZWdFeHAgPSBpc1JlZ2V4cDtcbiAgdmFyIFR5cGVFcnJvciQ1ID0gZ2xvYmFsJDkuVHlwZUVycm9yO1xuXG4gIHZhciBub3RBUmVnZXhwID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgaWYgKGlzUmVnRXhwKGl0KSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJDUoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0O1xuICB9O1xuXG4gIHZhciB3ZWxsS25vd25TeW1ib2wkMSA9IHdlbGxLbm93blN5bWJvbCRqO1xuICB2YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2wkMSgnbWF0Y2gnKTtcblxuICB2YXIgY29ycmVjdElzUmVnZXhwTG9naWMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgICB2YXIgcmVnZXhwID0gLy4vO1xuXG4gICAgdHJ5IHtcbiAgICAgICcvLi8nW01FVEhPRF9OQU1FXShyZWdleHApO1xuICAgIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVnZXhwW01BVENIXSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgLyogZW1wdHkgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgdmFyICQkZiA9IF9leHBvcnQ7XG4gIHZhciB1bmN1cnJ5VGhpcyQ3ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIG5vdEFSZWdFeHAgPSBub3RBUmVnZXhwO1xuICB2YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQxID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1O1xuICB2YXIgdG9TdHJpbmckMyA9IHRvU3RyaW5nJDc7XG4gIHZhciBjb3JyZWN0SXNSZWdFeHBMb2dpYyA9IGNvcnJlY3RJc1JlZ2V4cExvZ2ljO1xuICB2YXIgc3RyaW5nSW5kZXhPZiA9IHVuY3VycnlUaGlzJDcoJycuaW5kZXhPZik7IC8vIGBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzXG5cbiAgJCRmKHtcbiAgICB0YXJnZXQ6ICdTdHJpbmcnLFxuICAgIHByb3RvOiB0cnVlLFxuICAgIGZvcmNlZDogIWNvcnJlY3RJc1JlZ0V4cExvZ2ljKCdpbmNsdWRlcycpXG4gIH0sIHtcbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nXG4gICAgLyogLCBwb3NpdGlvbiA9IDAgKi9cbiAgICApIHtcbiAgICAgIHJldHVybiAhIX5zdHJpbmdJbmRleE9mKHRvU3RyaW5nJDMocmVxdWlyZU9iamVjdENvZXJjaWJsZSQxKHRoaXMpKSwgdG9TdHJpbmckMyhub3RBUmVnRXhwKHNlYXJjaFN0cmluZykpLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZW50cnlWaXJ0dWFsJDggPSBlbnRyeVZpcnR1YWwkaztcbiAgZW50cnlWaXJ0dWFsJDgoJ1N0cmluZycpLmluY2x1ZGVzO1xuXG4gIHZhciAkJGUgPSBfZXhwb3J0O1xuICB2YXIgZmFpbHMkOSA9IGZhaWxzJHI7XG4gIHZhciB0b09iamVjdCQyID0gdG9PYmplY3QkZTtcbiAgdmFyIG5hdGl2ZUdldFByb3RvdHlwZU9mID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG4gIHZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSBjb3JyZWN0UHJvdG90eXBlR2V0dGVyO1xuICB2YXIgRkFJTFNfT05fUFJJTUlUSVZFUyQxID0gZmFpbHMkOShmdW5jdGlvbiAoKSB7XG4gICAgbmF0aXZlR2V0UHJvdG90eXBlT2YoMSk7XG4gIH0pOyAvLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2ZcblxuICAkJGUoe1xuICAgIHRhcmdldDogJ09iamVjdCcsXG4gICAgc3RhdDogdHJ1ZSxcbiAgICBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMkMSxcbiAgICBzaGFtOiAhQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSXG4gIH0sIHtcbiAgICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICAgIHJldHVybiBuYXRpdmVHZXRQcm90b3R5cGVPZih0b09iamVjdCQyKGl0KSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcGF0aCQ5ID0gcGF0aCRxO1xuICB2YXIgZ2V0UHJvdG90eXBlT2YkNCA9IHBhdGgkOS5PYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbiAgdmFyIHBhcmVudCRrID0gZ2V0UHJvdG90eXBlT2YkNDtcbiAgdmFyIGdldFByb3RvdHlwZU9mJDMgPSBwYXJlbnQkaztcblxuICB2YXIgREVTQ1JJUFRPUlMkNCA9IGRlc2NyaXB0b3JzO1xuICB2YXIgdW5jdXJyeVRoaXMkNiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBvYmplY3RLZXlzID0gb2JqZWN0S2V5cyQ0O1xuICB2YXIgdG9JbmRleGVkT2JqZWN0ID0gdG9JbmRleGVkT2JqZWN0JGI7XG4gIHZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSB1bmN1cnJ5VGhpcyQ2KCRwcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG4gIHZhciBwdXNoJDIgPSB1bmN1cnJ5VGhpcyQ2KFtdLnB1c2gpOyAvLyBgT2JqZWN0LnsgZW50cmllcywgdmFsdWVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblxuICB2YXIgY3JlYXRlTWV0aG9kJDEgPSBmdW5jdGlvbiAoVE9fRU5UUklFUykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KGl0KTtcbiAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhPKTtcbiAgICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBrZXk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGggPiBpKSB7XG4gICAgICAgIGtleSA9IGtleXNbaSsrXTtcblxuICAgICAgICBpZiAoIURFU0NSSVBUT1JTJDQgfHwgcHJvcGVydHlJc0VudW1lcmFibGUoTywga2V5KSkge1xuICAgICAgICAgIHB1c2gkMihyZXN1bHQsIFRPX0VOVFJJRVMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgdmFyIG9iamVjdFRvQXJyYXkgPSB7XG4gICAgLy8gYE9iamVjdC5lbnRyaWVzYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5lbnRyaWVzXG4gICAgZW50cmllczogY3JlYXRlTWV0aG9kJDEodHJ1ZSksXG4gICAgLy8gYE9iamVjdC52YWx1ZXNgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnZhbHVlc1xuICAgIHZhbHVlczogY3JlYXRlTWV0aG9kJDEoZmFsc2UpXG4gIH07XG5cbiAgdmFyICQkZCA9IF9leHBvcnQ7XG4gIHZhciAkdmFsdWVzID0gb2JqZWN0VG9BcnJheS52YWx1ZXM7IC8vIGBPYmplY3QudmFsdWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QudmFsdWVzXG5cbiAgJCRkKHtcbiAgICB0YXJnZXQ6ICdPYmplY3QnLFxuICAgIHN0YXQ6IHRydWVcbiAgfSwge1xuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKE8pIHtcbiAgICAgIHJldHVybiAkdmFsdWVzKE8pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHBhdGgkOCA9IHBhdGgkcTtcbiAgcGF0aCQ4Lk9iamVjdC52YWx1ZXM7XG5cbiAgdmFyIHdoaXRlc3BhY2VzJDMgPSAnXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDInICsgJ1xcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxuICB2YXIgdW5jdXJyeVRoaXMkNSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1O1xuICB2YXIgdG9TdHJpbmckMiA9IHRvU3RyaW5nJDc7XG4gIHZhciB3aGl0ZXNwYWNlcyQyID0gd2hpdGVzcGFjZXMkMztcbiAgdmFyIHJlcGxhY2UkMSA9IHVuY3VycnlUaGlzJDUoJycucmVwbGFjZSk7XG4gIHZhciB3aGl0ZXNwYWNlID0gJ1snICsgd2hpdGVzcGFjZXMkMiArICddJztcbiAgdmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyonKTtcbiAgdmFyIHJ0cmltID0gUmVnRXhwKHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyokJyk7IC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbSwgdHJpbVN0YXJ0LCB0cmltRW5kLCB0cmltTGVmdCwgdHJpbVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblxuICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzKSB7XG4gICAgICB2YXIgc3RyaW5nID0gdG9TdHJpbmckMihyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHJlcGxhY2UkMShzdHJpbmcsIGx0cmltLCAnJyk7XG4gICAgICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHJlcGxhY2UkMShzdHJpbmcsIHJ0cmltLCAnJyk7XG4gICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIHN0cmluZ1RyaW0gPSB7XG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltTGVmdCwgdHJpbVN0YXJ0IH1gIG1ldGhvZHNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbXN0YXJ0XG4gICAgc3RhcnQ6IGNyZWF0ZU1ldGhvZCgxKSxcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1SaWdodCwgdHJpbUVuZCB9YCBtZXRob2RzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1lbmRcbiAgICBlbmQ6IGNyZWF0ZU1ldGhvZCgyKSxcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS50cmltYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuICAgIHRyaW06IGNyZWF0ZU1ldGhvZCgzKVxuICB9O1xuXG4gIHZhciBnbG9iYWwkOCA9IGdsb2JhbCRNO1xuICB2YXIgZmFpbHMkOCA9IGZhaWxzJHI7XG4gIHZhciB1bmN1cnJ5VGhpcyQ0ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIHRvU3RyaW5nJDEgPSB0b1N0cmluZyQ3O1xuICB2YXIgdHJpbSA9IHN0cmluZ1RyaW0udHJpbTtcbiAgdmFyIHdoaXRlc3BhY2VzJDEgPSB3aGl0ZXNwYWNlcyQzO1xuICB2YXIgJHBhcnNlSW50JDEgPSBnbG9iYWwkOC5wYXJzZUludDtcbiAgdmFyIFN5bWJvbCQxID0gZ2xvYmFsJDguU3ltYm9sO1xuICB2YXIgSVRFUkFUT1IgPSBTeW1ib2wkMSAmJiBTeW1ib2wkMS5pdGVyYXRvcjtcbiAgdmFyIGhleCA9IC9eWystXT8weC9pO1xuICB2YXIgZXhlYyQxID0gdW5jdXJyeVRoaXMkNChoZXguZXhlYyk7XG4gIHZhciBGT1JDRUQkMyA9ICRwYXJzZUludCQxKHdoaXRlc3BhY2VzJDEgKyAnMDgnKSAhPT0gOCB8fCAkcGFyc2VJbnQkMSh3aGl0ZXNwYWNlcyQxICsgJzB4MTYnKSAhPT0gMjIgLy8gTVMgRWRnZSAxOC0gYnJva2VuIHdpdGggYm94ZWQgc3ltYm9sc1xuICB8fCBJVEVSQVRPUiAmJiAhZmFpbHMkOChmdW5jdGlvbiAoKSB7XG4gICAgJHBhcnNlSW50JDEoT2JqZWN0KElURVJBVE9SKSk7XG4gIH0pOyAvLyBgcGFyc2VJbnRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXBhcnNlaW50LXN0cmluZy1yYWRpeFxuXG4gIHZhciBudW1iZXJQYXJzZUludCA9IEZPUkNFRCQzID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCkge1xuICAgIHZhciBTID0gdHJpbSh0b1N0cmluZyQxKHN0cmluZykpO1xuICAgIHJldHVybiAkcGFyc2VJbnQkMShTLCByYWRpeCA+Pj4gMCB8fCAoZXhlYyQxKGhleCwgUykgPyAxNiA6IDEwKSk7XG4gIH0gOiAkcGFyc2VJbnQkMTtcblxuICB2YXIgJCRjID0gX2V4cG9ydDtcbiAgdmFyICRwYXJzZUludCA9IG51bWJlclBhcnNlSW50OyAvLyBgcGFyc2VJbnRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXBhcnNlaW50LXN0cmluZy1yYWRpeFxuXG4gICQkYyh7XG4gICAgZ2xvYmFsOiB0cnVlLFxuICAgIGZvcmNlZDogcGFyc2VJbnQgIT0gJHBhcnNlSW50XG4gIH0sIHtcbiAgICBwYXJzZUludDogJHBhcnNlSW50XG4gIH0pO1xuXG4gIHZhciBwYXRoJDcgPSBwYXRoJHE7XG4gIHBhdGgkNy5wYXJzZUludDtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1hcnJheS1wcm90b3R5cGUtaW5kZXhvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG5cbiAgdmFyICQkYiA9IF9leHBvcnQ7XG4gIHZhciB1bmN1cnJ5VGhpcyQzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyICRJbmRleE9mID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xuICB2YXIgYXJyYXlNZXRob2RJc1N0cmljdCQyID0gYXJyYXlNZXRob2RJc1N0cmljdCQ1O1xuICB2YXIgdW4kSW5kZXhPZiA9IHVuY3VycnlUaGlzJDMoW10uaW5kZXhPZik7XG4gIHZhciBORUdBVElWRV9aRVJPID0gISF1biRJbmRleE9mICYmIDEgLyB1biRJbmRleE9mKFsxXSwgMSwgLTApIDwgMDtcbiAgdmFyIFNUUklDVF9NRVRIT0QkMiA9IGFycmF5TWV0aG9kSXNTdHJpY3QkMignaW5kZXhPZicpOyAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG5cbiAgJCRiKHtcbiAgICB0YXJnZXQ6ICdBcnJheScsXG4gICAgcHJvdG86IHRydWUsXG4gICAgZm9yY2VkOiBORUdBVElWRV9aRVJPIHx8ICFTVFJJQ1RfTUVUSE9EJDJcbiAgfSwge1xuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudFxuICAgIC8qICwgZnJvbUluZGV4ID0gMCAqL1xuICAgICkge1xuICAgICAgdmFyIGZyb21JbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIE5FR0FUSVZFX1pFUk8gLy8gY29udmVydCAtMCB0byArMFxuICAgICAgPyB1biRJbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkgfHwgMCA6ICRJbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZW50cnlWaXJ0dWFsJDcgPSBlbnRyeVZpcnR1YWwkaztcbiAgZW50cnlWaXJ0dWFsJDcoJ0FycmF5JykuaW5kZXhPZjtcblxuICB2YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUgPSBmdW5jdGlvbk5hbWUuUFJPUEVSO1xuICB2YXIgZmFpbHMkNyA9IGZhaWxzJHI7XG4gIHZhciB3aGl0ZXNwYWNlcyA9IHdoaXRlc3BhY2VzJDM7XG4gIHZhciBub24gPSAnXFx1MjAwQlxcdTAwODVcXHUxODBFJzsgLy8gY2hlY2sgdGhhdCBhIG1ldGhvZCB3b3JrcyB3aXRoIHRoZSBjb3JyZWN0IGxpc3RcbiAgLy8gb2Ygd2hpdGVzcGFjZXMgYW5kIGhhcyBhIGNvcnJlY3QgbmFtZVxuXG4gIHZhciBzdHJpbmdUcmltRm9yY2VkID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gICAgcmV0dXJuIGZhaWxzJDcoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhd2hpdGVzcGFjZXNbTUVUSE9EX05BTUVdKCkgfHwgbm9uW01FVEhPRF9OQU1FXSgpICE9PSBub24gfHwgUFJPUEVSX0ZVTkNUSU9OX05BTUUgJiYgd2hpdGVzcGFjZXNbTUVUSE9EX05BTUVdLm5hbWUgIT09IE1FVEhPRF9OQU1FO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciAkJGEgPSBfZXhwb3J0O1xuICB2YXIgJHRyaW0gPSBzdHJpbmdUcmltLnRyaW07XG4gIHZhciBmb3JjZWRTdHJpbmdUcmltTWV0aG9kID0gc3RyaW5nVHJpbUZvcmNlZDsgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltXG5cbiAgJCRhKHtcbiAgICB0YXJnZXQ6ICdTdHJpbmcnLFxuICAgIHByb3RvOiB0cnVlLFxuICAgIGZvcmNlZDogZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCgndHJpbScpXG4gIH0sIHtcbiAgICB0cmltOiBmdW5jdGlvbiB0cmltKCkge1xuICAgICAgcmV0dXJuICR0cmltKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGVudHJ5VmlydHVhbCQ2ID0gZW50cnlWaXJ0dWFsJGs7XG4gIGVudHJ5VmlydHVhbCQ2KCdTdHJpbmcnKS50cmltO1xuXG4gIHZhciAkJDkgPSBfZXhwb3J0O1xuICB2YXIgREVTQ1JJUFRPUlMkMyA9IGRlc2NyaXB0b3JzO1xuICB2YXIgY3JlYXRlJDggPSBvYmplY3RDcmVhdGU7IC8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG5cbiAgJCQ5KHtcbiAgICB0YXJnZXQ6ICdPYmplY3QnLFxuICAgIHN0YXQ6IHRydWUsXG4gICAgc2hhbTogIURFU0NSSVBUT1JTJDNcbiAgfSwge1xuICAgIGNyZWF0ZTogY3JlYXRlJDhcbiAgfSk7XG5cbiAgdmFyIHBhdGgkNiA9IHBhdGgkcTtcbiAgdmFyIE9iamVjdCQxID0gcGF0aCQ2Lk9iamVjdDtcblxuICB2YXIgY3JlYXRlJDcgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCkge1xuICAgIHJldHVybiBPYmplY3QkMS5jcmVhdGUoUCwgRCk7XG4gIH07XG5cbiAgdmFyIHBhcmVudCRqID0gY3JlYXRlJDc7XG4gIHZhciBjcmVhdGUkNiA9IHBhcmVudCRqO1xuXG4gIHZhciBjcmVhdGUkNSA9IGNyZWF0ZSQ2O1xuXG4gIHZhciAkJDggPSBfZXhwb3J0O1xuICB2YXIgZ2xvYmFsJDcgPSBnbG9iYWwkTTtcbiAgdmFyIGdldEJ1aWx0SW4kMiA9IGdldEJ1aWx0SW4kOTtcbiAgdmFyIGFwcGx5JDMgPSBmdW5jdGlvbkFwcGx5O1xuICB2YXIgdW5jdXJyeVRoaXMkMiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBmYWlscyQ2ID0gZmFpbHMkcjtcbiAgdmFyIEFycmF5JDEgPSBnbG9iYWwkNy5BcnJheTtcbiAgdmFyICRzdHJpbmdpZnkgPSBnZXRCdWlsdEluJDIoJ0pTT04nLCAnc3RyaW5naWZ5Jyk7XG4gIHZhciBleGVjID0gdW5jdXJyeVRoaXMkMigvLi8uZXhlYyk7XG4gIHZhciBjaGFyQXQgPSB1bmN1cnJ5VGhpcyQyKCcnLmNoYXJBdCk7XG4gIHZhciBjaGFyQ29kZUF0ID0gdW5jdXJyeVRoaXMkMignJy5jaGFyQ29kZUF0KTtcbiAgdmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcyQyKCcnLnJlcGxhY2UpO1xuICB2YXIgbnVtYmVyVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyQyKDEuMC50b1N0cmluZyk7XG4gIHZhciB0ZXN0ZXIgPSAvW1xcdUQ4MDAtXFx1REZGRl0vZztcbiAgdmFyIGxvdyA9IC9eW1xcdUQ4MDAtXFx1REJGRl0kLztcbiAgdmFyIGhpID0gL15bXFx1REMwMC1cXHVERkZGXSQvO1xuXG4gIHZhciBmaXggPSBmdW5jdGlvbiAobWF0Y2gsIG9mZnNldCwgc3RyaW5nKSB7XG4gICAgdmFyIHByZXYgPSBjaGFyQXQoc3RyaW5nLCBvZmZzZXQgLSAxKTtcbiAgICB2YXIgbmV4dCA9IGNoYXJBdChzdHJpbmcsIG9mZnNldCArIDEpO1xuXG4gICAgaWYgKGV4ZWMobG93LCBtYXRjaCkgJiYgIWV4ZWMoaGksIG5leHQpIHx8IGV4ZWMoaGksIG1hdGNoKSAmJiAhZXhlYyhsb3csIHByZXYpKSB7XG4gICAgICByZXR1cm4gJ1xcXFx1JyArIG51bWJlclRvU3RyaW5nKGNoYXJDb2RlQXQobWF0Y2gsIDApLCAxNik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xuXG4gIHZhciBGT1JDRUQkMiA9IGZhaWxzJDYoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAkc3RyaW5naWZ5KCdcXHVERjA2XFx1RDgzNCcpICE9PSAnXCJcXFxcdWRmMDZcXFxcdWQ4MzRcIicgfHwgJHN0cmluZ2lmeSgnXFx1REVBRCcpICE9PSAnXCJcXFxcdWRlYWRcIic7XG4gIH0pO1xuXG4gIGlmICgkc3RyaW5naWZ5KSB7XG4gICAgLy8gYEpTT04uc3RyaW5naWZ5YCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtd2VsbC1mb3JtZWQtc3RyaW5naWZ5XG4gICAgJCQ4KHtcbiAgICAgIHRhcmdldDogJ0pTT04nLFxuICAgICAgc3RhdDogdHJ1ZSxcbiAgICAgIGZvcmNlZDogRk9SQ0VEJDJcbiAgICB9LCB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheSQxKGwpOyBpIDwgbDsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBhcHBseSQzKCRzdHJpbmdpZnksIG51bGwsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PSAnc3RyaW5nJyA/IHJlcGxhY2UocmVzdWx0LCB0ZXN0ZXIsIGZpeCkgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcGF0aCQ1ID0gcGF0aCRxO1xuICB2YXIgYXBwbHkkMiA9IGZ1bmN0aW9uQXBwbHk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1qc29uIC0tIHNhZmVcblxuICBpZiAoIXBhdGgkNS5KU09OKSBwYXRoJDUuSlNPTiA9IHtcbiAgICBzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5XG4gIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG5cbiAgdmFyIHN0cmluZ2lmeSQzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0LCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICByZXR1cm4gYXBwbHkkMihwYXRoJDUuSlNPTi5zdHJpbmdpZnksIG51bGwsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIHBhcmVudCRpID0gc3RyaW5naWZ5JDM7XG4gIHZhciBzdHJpbmdpZnkkMiA9IHBhcmVudCRpO1xuXG4gIHZhciBzdHJpbmdpZnkkMSA9IHN0cmluZ2lmeSQyO1xuXG4gIHZhciBnbG9iYWwkNiA9IGdsb2JhbCRNO1xuICB2YXIgVHlwZUVycm9yJDQgPSBnbG9iYWwkNi5UeXBlRXJyb3I7XG5cbiAgdmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEgPSBmdW5jdGlvbiAocGFzc2VkLCByZXF1aXJlZCkge1xuICAgIGlmIChwYXNzZWQgPCByZXF1aXJlZCkgdGhyb3cgVHlwZUVycm9yJDQoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gICAgcmV0dXJuIHBhc3NlZDtcbiAgfTtcblxuICB2YXIgJCQ3ID0gX2V4cG9ydDtcbiAgdmFyIGdsb2JhbCQ1ID0gZ2xvYmFsJE07XG4gIHZhciBhcHBseSQxID0gZnVuY3Rpb25BcHBseTtcbiAgdmFyIGlzQ2FsbGFibGUkMSA9IGlzQ2FsbGFibGUkaDtcbiAgdmFyIHVzZXJBZ2VudCQyID0gZW5naW5lVXNlckFnZW50O1xuICB2YXIgYXJyYXlTbGljZSQxID0gYXJyYXlTbGljZSQ1O1xuICB2YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGggPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxO1xuICB2YXIgTVNJRSA9IC9NU0lFIC5cXC4vLnRlc3QodXNlckFnZW50JDIpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG5cbiAgdmFyIEZ1bmN0aW9uJDEgPSBnbG9iYWwkNS5GdW5jdGlvbjtcblxuICB2YXIgd3JhcCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGhhbmRsZXIsIHRpbWVvdXRcbiAgICAvKiAsIC4uLmFyZ3VtZW50cyAqL1xuICAgICkge1xuICAgICAgdmFyIGJvdW5kQXJncyA9IHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpID4gMjtcbiAgICAgIHZhciBmbiA9IGlzQ2FsbGFibGUkMShoYW5kbGVyKSA/IGhhbmRsZXIgOiBGdW5jdGlvbiQxKGhhbmRsZXIpO1xuICAgICAgdmFyIGFyZ3MgPSBib3VuZEFyZ3MgPyBhcnJheVNsaWNlJDEoYXJndW1lbnRzLCAyKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBzY2hlZHVsZXIoYm91bmRBcmdzID8gZnVuY3Rpb24gKCkge1xuICAgICAgICBhcHBseSQxKGZuLCB0aGlzLCBhcmdzKTtcbiAgICAgIH0gOiBmbiwgdGltZW91dCk7XG4gICAgfTtcbiAgfTsgLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS90aW1lcnMtYW5kLXVzZXItcHJvbXB0cy5odG1sI3RpbWVyc1xuXG5cbiAgJCQ3KHtcbiAgICBnbG9iYWw6IHRydWUsXG4gICAgYmluZDogdHJ1ZSxcbiAgICBmb3JjZWQ6IE1TSUVcbiAgfSwge1xuICAgIC8vIGBzZXRUaW1lb3V0YCBtZXRob2RcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS90aW1lcnMtYW5kLXVzZXItcHJvbXB0cy5odG1sI2RvbS1zZXR0aW1lb3V0XG4gICAgc2V0VGltZW91dDogd3JhcChnbG9iYWwkNS5zZXRUaW1lb3V0KSxcbiAgICAvLyBgc2V0SW50ZXJ2YWxgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3RpbWVycy1hbmQtdXNlci1wcm9tcHRzLmh0bWwjZG9tLXNldGludGVydmFsXG4gICAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsJDUuc2V0SW50ZXJ2YWwpXG4gIH0pO1xuXG4gIHZhciBwYXRoJDQgPSBwYXRoJHE7XG4gIHZhciBzZXRUaW1lb3V0JDIgPSBwYXRoJDQuc2V0VGltZW91dDtcblxuICB2YXIgc2V0VGltZW91dCQxID0gc2V0VGltZW91dCQyO1xuXG4gIHZhciB0b09iamVjdCQxID0gdG9PYmplY3QkZTtcbiAgdmFyIHRvQWJzb2x1dGVJbmRleCA9IHRvQWJzb2x1dGVJbmRleCQ1O1xuICB2YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMiA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7IC8vIGBBcnJheS5wcm90b3R5cGUuZmlsbGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbGxcblxuICB2YXIgYXJyYXlGaWxsID0gZnVuY3Rpb24gZmlsbCh2YWx1ZVxuICAvKiAsIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqL1xuICApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0JDEodGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDIoTyk7XG4gICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gICAgdmFyIGVuZCA9IGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcblxuICAgIHdoaWxlIChlbmRQb3MgPiBpbmRleCkgT1tpbmRleCsrXSA9IHZhbHVlO1xuXG4gICAgcmV0dXJuIE87XG4gIH07XG5cbiAgdmFyICQkNiA9IF9leHBvcnQ7XG4gIHZhciBmaWxsID0gYXJyYXlGaWxsO1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWxsXG5cbiAgJCQ2KHtcbiAgICB0YXJnZXQ6ICdBcnJheScsXG4gICAgcHJvdG86IHRydWVcbiAgfSwge1xuICAgIGZpbGw6IGZpbGxcbiAgfSk7IC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcblxuICB2YXIgZW50cnlWaXJ0dWFsJDUgPSBlbnRyeVZpcnR1YWwkaztcbiAgZW50cnlWaXJ0dWFsJDUoJ0FycmF5JykuZmlsbDtcblxuICB2YXIgY29tcG9uZW50RW1pdHRlciA9IHtleHBvcnRzOiB7fX07XG5cbiAgKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAvKipcclxuICAgICAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAgICAgKi9cbiAgICB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAgICAgKlxyXG4gICAgICogQGFwaSBwdWJsaWNcclxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICAgICAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICAgKiBAYXBpIHByaXZhdGVcclxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICAgICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gICAgICogQHJldHVybiB7RW1pdHRlcn1cclxuICAgICAqIEBhcGkgcHVibGljXHJcbiAgICAgKi9cblxuXG4gICAgRW1pdHRlci5wcm90b3R5cGUub24gPSBFbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgICAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKS5wdXNoKGZuKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICAgICAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gICAgICogQHJldHVybiB7RW1pdHRlcn1cclxuICAgICAqIEBhcGkgcHVibGljXHJcbiAgICAgKi9cblxuXG4gICAgRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgICB0aGlzLm9mZihldmVudCwgb24pO1xuICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBvbi5mbiA9IGZuO1xuICAgICAgdGhpcy5vbihldmVudCwgb24pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAgICAgKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAgICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gICAgICogQGFwaSBwdWJsaWNcclxuICAgICAqL1xuXG5cbiAgICBFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307IC8vIGFsbFxuXG4gICAgICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gLy8gc3BlY2lmaWMgZXZlbnRcblxuXG4gICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgICAgIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpczsgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuXG4gICAgICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcblxuXG4gICAgICB2YXIgY2I7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuXG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZW1vdmUgZXZlbnQgc3BlY2lmaWMgYXJyYXlzIGZvciBldmVudCB0eXBlcyB0aGF0IG5vXG4gICAgICAvLyBvbmUgaXMgc3Vic2NyaWJlZCBmb3IgdG8gYXZvaWQgbWVtb3J5IGxlYWsuXG5cblxuICAgICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gICAgICogQHJldHVybiB7RW1pdHRlcn1cclxuICAgICAqL1xuXG5cbiAgICBFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXG4gICAgICAgICAgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgICAqIEBhcGkgcHVibGljXHJcbiAgICAgKi9cblxuXG4gICAgRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqIEBhcGkgcHVibGljXHJcbiAgICAgKi9cblxuXG4gICAgRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gISF0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xuICAgIH07XG4gIH0pKGNvbXBvbmVudEVtaXR0ZXIpO1xuXG4gIHZhciBFbWl0dGVyID0gY29tcG9uZW50RW1pdHRlci5leHBvcnRzO1xuXG4gIC8qISBIYW1tZXIuSlMgLSB2Mi4wLjE3LXJjIC0gMjAxOS0xMi0xNlxuICAgKiBodHRwOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanNcbiAgICpcbiAgICogRm9ya2VkIEJ5IE5hdmVyIGVnanNcbiAgICogQ29weXJpZ2h0IChjKSBoYW1tZXJqc1xuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cbiAgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gICAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQkMShzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBleHRlbmQgb2JqZWN0LlxuICAgKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0gey4uLk9iamVjdH0gb2JqZWN0c190b19hc3NpZ25cbiAgICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gICAqL1xuXG5cbiAgdmFyIGFzc2lnbjtcblxuICBpZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgICBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuXG4gICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuICB9XG5cbiAgdmFyIGFzc2lnbiQxID0gYXNzaWduO1xuICB2YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ01veicsICdNUycsICdtcycsICdvJ107XG4gIHZhciBURVNUX0VMRU1FTlQgPSB0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyB7XG4gICAgc3R5bGU6IHt9XG4gIH0gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xuICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgYWJzID0gTWF0aC5hYnM7XG4gIHZhciBub3cgPSBEYXRlLm5vdztcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgICB2YXIgcHJlZml4O1xuICAgIHZhciBwcm9wO1xuICAgIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XG4gICAgICBwcmVmaXggPSBWRU5ET1JfUFJFRklYRVNbaV07XG4gICAgICBwcm9wID0gcHJlZml4ID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMsIG5vLW5lc3RlZC10ZXJuYXJ5ICovXG5cblxuICB2YXIgd2luO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gd2luZG93IGlzIHVuZGVmaW5lZCBpbiBub2RlLmpzXG4gICAgd2luID0ge307XG4gIH0gZWxzZSB7XG4gICAgd2luID0gd2luZG93O1xuICB9XG5cbiAgdmFyIFBSRUZJWEVEX1RPVUNIX0FDVElPTiA9IHByZWZpeGVkKFRFU1RfRUxFTUVOVC5zdHlsZSwgJ3RvdWNoQWN0aW9uJyk7XG4gIHZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpIHtcbiAgICBpZiAoIU5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdG91Y2hNYXAgPSB7fTtcbiAgICB2YXIgY3NzU3VwcG9ydHMgPSB3aW4uQ1NTICYmIHdpbi5DU1Muc3VwcG9ydHM7XG4gICAgWydhdXRvJywgJ21hbmlwdWxhdGlvbicsICdwYW4teScsICdwYW4teCcsICdwYW4teCBwYW4teScsICdub25lJ10uZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAvLyBJZiBjc3Muc3VwcG9ydHMgaXMgbm90IHN1cHBvcnRlZCBidXQgdGhlcmUgaXMgbmF0aXZlIHRvdWNoLWFjdGlvbiBhc3N1bWUgaXQgc3VwcG9ydHNcbiAgICAgIC8vIGFsbCB2YWx1ZXMuIFRoaXMgaXMgdGhlIGNhc2UgZm9yIElFIDEwIGFuZCAxMS5cbiAgICAgIHJldHVybiB0b3VjaE1hcFt2YWxdID0gY3NzU3VwcG9ydHMgPyB3aW4uQ1NTLnN1cHBvcnRzKCd0b3VjaC1hY3Rpb24nLCB2YWwpIDogdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG91Y2hNYXA7XG4gIH1cblxuICB2YXIgVE9VQ0hfQUNUSU9OX0NPTVBVVEUgPSAnY29tcHV0ZSc7XG4gIHZhciBUT1VDSF9BQ1RJT05fQVVUTyA9ICdhdXRvJztcbiAgdmFyIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04gPSAnbWFuaXB1bGF0aW9uJzsgLy8gbm90IGltcGxlbWVudGVkXG5cbiAgdmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xuICB2YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcbiAgdmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XG4gIHZhciBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xuICB2YXIgTU9CSUxFX1JFR0VYID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pO1xuICB2YXIgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW4pO1xuICB2YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbiwgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XG4gIHZhciBTVVBQT1JUX09OTFlfVE9VQ0ggPSBTVVBQT1JUX1RPVUNIICYmIE1PQklMRV9SRUdFWC50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB2YXIgSU5QVVRfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XG4gIHZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xuICB2YXIgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XG4gIHZhciBJTlBVVF9UWVBFX0tJTkVDVCA9ICdraW5lY3QnO1xuICB2YXIgQ09NUFVURV9JTlRFUlZBTCA9IDI1O1xuICB2YXIgSU5QVVRfU1RBUlQgPSAxO1xuICB2YXIgSU5QVVRfTU9WRSA9IDI7XG4gIHZhciBJTlBVVF9FTkQgPSA0O1xuICB2YXIgSU5QVVRfQ0FOQ0VMID0gODtcbiAgdmFyIERJUkVDVElPTl9OT05FID0gMTtcbiAgdmFyIERJUkVDVElPTl9MRUZUID0gMjtcbiAgdmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XG4gIHZhciBESVJFQ1RJT05fVVAgPSA4O1xuICB2YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcbiAgdmFyIERJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0xFRlQgfCBESVJFQ1RJT05fUklHSFQ7XG4gIHZhciBESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVVAgfCBESVJFQ1RJT05fRE9XTjtcbiAgdmFyIERJUkVDVElPTl9BTEwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTDtcbiAgdmFyIFBST1BTX1hZID0gWyd4JywgJ3knXTtcbiAgdmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiB3YWxrIG9iamVjdHMgYW5kIGFycmF5c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBpO1xuXG4gICAgaWYgKCFvYmopIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpIDwgb2JqLmxlbmd0aCkge1xuICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGxldCBhIGJvb2xlYW4gdmFsdWUgYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgbXVzdCByZXR1cm4gYSBib29sZWFuXG4gICAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnc11cbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICAgIHJldHVybiB2YWwuYXBwbHkoYXJncyA/IGFyZ3NbMF0gfHwgdW5kZWZpbmVkIDogdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcbiAgICovXG5cblxuICBmdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YoZmluZCkgPiAtMTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgICAvLyBub25lXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xuICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7IC8vIGlmIGJvdGggcGFuLXggYW5kIHBhbi15IGFyZSBzZXQgKGRpZmZlcmVudCByZWNvZ25pemVyc1xuICAgIC8vIGZvciBkaWZmZXJlbnQgZGlyZWN0aW9ucywgZS5nLiBob3Jpem9udGFsIHBhbiBidXQgdmVydGljYWwgc3dpcGU/KVxuICAgIC8vIHdlIG5lZWQgbm9uZSAoYXMgb3RoZXJ3aXNlIHdpdGggcGFuLXggcGFuLXkgY29tYmluZWQgbm9uZSBvZiB0aGVzZVxuICAgIC8vIHJlY29nbml6ZXJzIHdpbGwgd29yaywgc2luY2UgdGhlIGJyb3dzZXIgd291bGQgaGFuZGxlIGFsbCBwYW5uaW5nXG5cbiAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfSAvLyBwYW4teCBPUiBwYW4teVxuXG5cbiAgICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XG4gICAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcbiAgICB9IC8vIG1hbmlwdWxhdGlvblxuXG5cbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcbiAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OO1xuICAgIH1cblxuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogVG91Y2ggQWN0aW9uXG4gICAqIHNldHMgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IG9yIHVzZXMgdGhlIGpzIGFsdGVybmF0aXZlXG4gICAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuXG5cbiAgdmFyIFRvdWNoQWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb3VjaEFjdGlvbihtYW5hZ2VyLCB2YWx1ZSkge1xuICAgICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICAgIHRoaXMuc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IFRvdWNoQWN0aW9uLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIC8vIGZpbmQgb3V0IHRoZSB0b3VjaC1hY3Rpb24gYnkgdGhlIGV2ZW50IGhhbmRsZXJzXG4gICAgICBpZiAodmFsdWUgPT09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5jb21wdXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OICYmIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlICYmIFRPVUNIX0FDVElPTl9NQVBbdmFsdWVdKSB7XG4gICAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hY3Rpb25zID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIGp1c3QgcmUtc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZVxuICAgICAqL1xuXG5cbiAgICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IGJhc2VkIG9uIHRoZSByZWNvZ25pemVyJ3Mgc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuXG5cbiAgICBfcHJvdG8uY29tcHV0ZSA9IGZ1bmN0aW9uIGNvbXB1dGUoKSB7XG4gICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgZWFjaCh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsIGZ1bmN0aW9uIChyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChib29sT3JGbihyZWNvZ25pemVyLm9wdGlvbnMuZW5hYmxlLCBbcmVjb2duaXplcl0pKSB7XG4gICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMuam9pbignICcpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIG9uIGVhY2ggaW5wdXQgY3ljbGUgYW5kIHByb3ZpZGVzIHRoZSBwcmV2ZW50aW5nIG9mIHRoZSBicm93c2VyIGJlaGF2aW9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG5cblxuICAgIF9wcm90by5wcmV2ZW50RGVmYXVsdHMgPSBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdHMoaW5wdXQpIHtcbiAgICAgIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0Lm9mZnNldERpcmVjdGlvbjsgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXG5cbiAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1ldO1xuICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWF07XG5cbiAgICAgIGlmIChoYXNOb25lKSB7XG4gICAgICAgIC8vIGRvIG5vdCBwcmV2ZW50IGRlZmF1bHRzIGlmIHRoaXMgaXMgYSB0YXAgZ2VzdHVyZVxuICAgICAgICB2YXIgaXNUYXBQb2ludGVyID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSAxO1xuICAgICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgICAgdmFyIGlzVGFwVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgMjUwO1xuXG4gICAgICAgIGlmIChpc1RhcFBvaW50ZXIgJiYgaXNUYXBNb3ZlbWVudCAmJiBpc1RhcFRvdWNoVGltZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgIC8vIGBwYW4teCBwYW4teWAgbWVhbnMgYnJvd3NlciBoYW5kbGVzIGFsbCBzY3JvbGxpbmcvcGFubmluZywgZG8gbm90IHByZXZlbnRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzTm9uZSB8fCBoYXNQYW5ZICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMIHx8IGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRTcmMoc3JjRXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLnByZXZlbnRTcmMgPSBmdW5jdGlvbiBwcmV2ZW50U3JjKHNyY0V2ZW50KSB7XG4gICAgICB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvdWNoQWN0aW9uO1xuICB9KCk7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gICAqIEBtZXRob2QgaGFzUGFyZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSBwb2ludGVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoOyAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRYKSxcbiAgICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB5ID0gMDtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XG4gICAgICB4ICs9IHBvaW50ZXJzW2ldLmNsaWVudFg7XG4gICAgICB5ICs9IHBvaW50ZXJzW2ldLmNsaWVudFk7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJvdW5kKHggLyBwb2ludGVyc0xlbmd0aCksXG4gICAgICB5OiByb3VuZCh5IC8gcG9pbnRlcnNMZW5ndGgpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcbiAgICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICAgIGNsaWVudFg6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFgpLFxuICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgICAgfTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGltZVN0YW1wOiBub3coKSxcbiAgICAgIHBvaW50ZXJzOiBwb2ludGVycyxcbiAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxuICAgICAgZGVsdGFZOiBpbnB1dC5kZWx0YVlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuXG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV07XG4gICAgdmFyIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcDFcbiAgICogQHBhcmFtIHtPYmplY3R9IHAyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldEFuZ2xlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cblxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dO1xuICAgIHZhciB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZ2V0IHRoZSBkaXJlY3Rpb24gYmV0d2VlbiB0d28gcG9pbnRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge051bWJlcn0gZGlyZWN0aW9uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgcmV0dXJuIERJUkVDVElPTl9OT05FO1xuICAgIH1cblxuICAgIGlmIChhYnMoeCkgPj0gYWJzKHkpKSB7XG4gICAgICByZXR1cm4geCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG5cbiAgICByZXR1cm4geSA8IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlcjsgLy8gbGV0IHsgb2Zmc2V0RGVsdGE6b2Zmc2V0ID0ge30sIHByZXZEZWx0YSA9IHt9LCBwcmV2SW5wdXQgPSB7fSB9ID0gc2Vzc2lvbjtcbiAgICAvLyBqc2NzIHRocm93aW5nIGVycm9yIG9uIGRlZmFsdXQgZGVzdHJ1Y3R1cmVkIHZhbHVlcyBhbmQgd2l0aG91dCBkZWZhdWx0cyB0ZXN0cyBmYWlsXG5cbiAgICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfU1RBUlQgfHwgcHJldklucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfRU5EKSB7XG4gICAgICBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSA9IHtcbiAgICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxuICAgICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcbiAgICAgIH07XG4gICAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgICB4OiBjZW50ZXIueCxcbiAgICAgICAgeTogY2VudGVyLnlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaW5wdXQuZGVsdGFYID0gcHJldkRlbHRhLnggKyAoY2VudGVyLnggLSBvZmZzZXQueCk7XG4gICAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcbiAgICAgIHk6IHkgLyBkZWx0YVRpbWUgfHwgMFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gICAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAgICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0sIFBST1BTX0NMSUVOVF9YWSkgLyBnZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0sIFBST1BTX0NMSUVOVF9YWSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAgICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0sIFBST1BTX0NMSUVOVF9YWSkgKyBnZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0sIFBST1BTX0NMSUVOVF9YWSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xuICAgKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG5cblxuICBmdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgbGFzdCA9IHNlc3Npb24ubGFzdEludGVydmFsIHx8IGlucHV0O1xuICAgIHZhciBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcDtcbiAgICB2YXIgdmVsb2NpdHk7XG4gICAgdmFyIHZlbG9jaXR5WDtcbiAgICB2YXIgdmVsb2NpdHlZO1xuICAgIHZhciBkaXJlY3Rpb247XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9PSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgdmFyIGRlbHRhWCA9IGlucHV0LmRlbHRhWCAtIGxhc3QuZGVsdGFYO1xuICAgICAgdmFyIGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuICAgICAgdmFyIHYgPSBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICAgIHZlbG9jaXR5ID0gYWJzKHYueCkgPiBhYnModi55KSA/IHYueCA6IHYueTtcbiAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG4gICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XG4gICAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XG4gICAgfVxuXG4gICAgaW5wdXQudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICBpbnB1dC52ZWxvY2l0eVggPSB2ZWxvY2l0eVg7XG4gICAgaW5wdXQudmVsb2NpdHlZID0gdmVsb2NpdHlZO1xuICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgfVxuICAvKipcbiAgKiBAcHJpdmF0ZVxuICAgKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7IC8vIHN0b3JlIHRoZSBmaXJzdCBpbnB1dCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGFuZCBkaXJlY3Rpb25cblxuICAgIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XG4gICAgICBzZXNzaW9uLmZpcnN0SW5wdXQgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gICAgfSAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG5cblxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA+IDEgJiYgIXNlc3Npb24uZmlyc3RNdWx0aXBsZSkge1xuICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmaXJzdElucHV0ID0gc2Vzc2lvbi5maXJzdElucHV0LFxuICAgICAgICBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuICAgIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50ZXJzKTtcbiAgICBpbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICBpbnB1dC5kZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBmaXJzdElucHV0LnRpbWVTdGFtcDtcbiAgICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gICAgaW5wdXQub2Zmc2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgICB2YXIgb3ZlcmFsbFZlbG9jaXR5ID0gZ2V0VmVsb2NpdHkoaW5wdXQuZGVsdGFUaW1lLCBpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WCA9IG92ZXJhbGxWZWxvY2l0eS54O1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVkgPSBvdmVyYWxsVmVsb2NpdHkueTtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHkgPSBhYnMob3ZlcmFsbFZlbG9jaXR5LngpID4gYWJzKG92ZXJhbGxWZWxvY2l0eS55KSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gICAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcbiAgICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xuICAgIGlucHV0Lm1heFBvaW50ZXJzID0gIXNlc3Npb24ucHJldklucHV0ID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogaW5wdXQucG9pbnRlcnMubGVuZ3RoID4gc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycztcbiAgICBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpOyAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxuXG4gICAgdmFyIHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICB2YXIgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgICB2YXIgc3JjRXZlbnRUYXJnZXQ7XG5cbiAgICBpZiAoc3JjRXZlbnQuY29tcG9zZWRQYXRoKSB7XG4gICAgICBzcmNFdmVudFRhcmdldCA9IHNyY0V2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgIH0gZWxzZSBpZiAoc3JjRXZlbnQucGF0aCkge1xuICAgICAgc3JjRXZlbnRUYXJnZXQgPSBzcmNFdmVudC5wYXRoWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcmNFdmVudFRhcmdldCA9IHNyY0V2ZW50LnRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAoaGFzUGFyZW50KHNyY0V2ZW50VGFyZ2V0LCB0YXJnZXQpKSB7XG4gICAgICB0YXJnZXQgPSBzcmNFdmVudFRhcmdldDtcbiAgICB9XG5cbiAgICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGhhbmRsZSBpbnB1dCBldmVudHNcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGlzRmlyc3QgPSBldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMDtcbiAgICB2YXIgaXNGaW5hbCA9IGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwO1xuICAgIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICBtYW5hZ2VyLnNlc3Npb24gPSB7fTtcbiAgICB9IC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gICAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG5cblxuICAgIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTsgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG5cbiAgICBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KTsgLy8gZW1pdCBzZWNyZXQgZXZlbnRcblxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNwbGl0IHN0cmluZyBvbiB3aGl0ZXNwYWNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHNwbGl0U3RyKHN0cikge1xuICAgIHJldHVybiBzdHIudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcbiAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cgfHwgd2luZG93O1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICAgKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0lucHV0fVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG5cblxuICB2YXIgSW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgdGhpcy5lbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7IC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxuICAgICAgLy8gc28gd2hlbiBkaXNhYmxlZCB0aGUgaW5wdXQgZXZlbnRzIGFyZSBjb21wbGV0ZWx5IGJ5cGFzc2VkLlxuXG4gICAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKGJvb2xPckZuKG1hbmFnZXIub3B0aW9ucy5lbmFibGUsIFttYW5hZ2VyXSkpIHtcbiAgICAgICAgICBzZWxmLmhhbmRsZXIoZXYpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBzaG91bGQgaGFuZGxlIHRoZSBpbnB1dEV2ZW50IGRhdGEgYW5kIHRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IElucHV0LnByb3RvdHlwZTtcblxuICAgIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcigpIHt9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG5cblxuICAgIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgIHRoaXMuZXZUYXJnZXQgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogdW5iaW5kIHRoZSBldmVudHNcbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgdGhpcy5ldlRhcmdldCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIH07XG5cbiAgICByZXR1cm4gSW5wdXQ7XG4gIH0oKTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seUZpbGxcbiAgICogQHBhcmFtIHtBcnJheX0gc3JjXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZmluZEJ5S2V5XVxuICAgKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcbiAgICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xuICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgICBpZiAoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQgfHwgIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpIHtcbiAgICAgICAgICAvLyBkbyBub3QgdXNlID09PSBoZXJlLCB0ZXN0IGZhaWxzXG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cblxuICAgICAgICBpKys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICB2YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gICAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxuICAgIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICAgIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcbiAgICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbiAgfTsgLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cblxuICB2YXIgSUUxMF9QT0lOVEVSX1RZUEVfRU5VTSA9IHtcbiAgICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgIDM6IElOUFVUX1RZUEVfUEVOLFxuICAgIDQ6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG5cbiAgfTtcbiAgdmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xuICB2YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJzsgLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5cbiAgaWYgKHdpbi5NU1BvaW50ZXJFdmVudCAmJiAhd2luLlBvaW50ZXJFdmVudCkge1xuICAgIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XG4gICAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogUG9pbnRlciBldmVudHMgaW5wdXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIElucHV0XG4gICAqL1xuXG5cbiAgdmFyIFBvaW50ZXJFdmVudElucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSW5wdXQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShQb2ludGVyRXZlbnRJbnB1dCwgX0lucHV0KTtcblxuICAgIGZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICB2YXIgcHJvdG8gPSBQb2ludGVyRXZlbnRJbnB1dC5wcm90b3R5cGU7XG4gICAgICBwcm90by5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICAgIHByb3RvLmV2V2luID0gUE9JTlRFUl9XSU5ET1dfRVZFTlRTO1xuICAgICAgX3RoaXMgPSBfSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgX3RoaXMuc3RvcmUgPSBfdGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZTtcblxuICAgIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgIHZhciByZW1vdmVQb2ludGVyID0gZmFsc2U7XG4gICAgICB2YXIgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcbiAgICAgIHZhciBldmVudFR5cGUgPSBQT0lOVEVSX0lOUFVUX01BUFtldmVudFR5cGVOb3JtYWxpemVkXTtcbiAgICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuICAgICAgdmFyIGlzVG91Y2ggPSBwb2ludGVyVHlwZSA9PT0gSU5QVVRfVFlQRV9UT1VDSDsgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcblxuICAgICAgdmFyIHN0b3JlSW5kZXggPSBpbkFycmF5KHN0b3JlLCBldi5wb2ludGVySWQsICdwb2ludGVySWQnKTsgLy8gc3RhcnQgYW5kIG1vdXNlIG11c3QgYmUgZG93blxuXG4gICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICBzdG9yZS5wdXNoKGV2KTtcbiAgICAgICAgICBzdG9yZUluZGV4ID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcbiAgICAgIH0gLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG5cblxuICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gdXBkYXRlIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcblxuXG4gICAgICBzdG9yZVtzdG9yZUluZGV4XSA9IGV2O1xuICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICBwb2ludGVyczogc3RvcmUsXG4gICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVtb3ZlUG9pbnRlcikge1xuICAgICAgICAvLyByZW1vdmUgZnJvbSB0aGUgc3RvcmVcbiAgICAgICAgc3RvcmUuc3BsaWNlKHN0b3JlSW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gUG9pbnRlckV2ZW50SW5wdXQ7XG4gIH0oSW5wdXQpO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gcmVhbCBhcnJheXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqLCAwKTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNyYyBbe2lkOjF9LHtpZDoyfSx7aWQ6MX1dXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFt7aWQ6MX0se2lkOjJ9XVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHVuaXF1ZUFycmF5KHNyYywga2V5LCBzb3J0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsID0ga2V5ID8gc3JjW2ldW2tleV0gOiBzcmNbaV07XG5cbiAgICAgIGlmIChpbkFycmF5KHZhbHVlcywgdmFsKSA8IDApIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlc1tpXSA9IHZhbDtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoc29ydCkge1xuICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgdmFyIFRPVUNIX0lOUFVUX01BUCA9IHtcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gICAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG4gIH07XG4gIHZhciBUT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBJbnB1dFxuICAgKi9cblxuICB2YXIgVG91Y2hJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lucHV0KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoVG91Y2hJbnB1dCwgX0lucHV0KTtcblxuICAgIGZ1bmN0aW9uIFRvdWNoSW5wdXQoKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIFRvdWNoSW5wdXQucHJvdG90eXBlLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICAgIF90aGlzID0gX0lucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgIF90aGlzLnRhcmdldElkcyA9IHt9OyAvLyB0aGlzLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBUb3VjaElucHV0LnByb3RvdHlwZTtcblxuICAgIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG5cbiAgICAgIGlmICghdG91Y2hlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gVG91Y2hJbnB1dDtcbiAgfShJbnB1dCk7XG5cbiAgZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7IC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICByZXR1cm4gW2FsbFRvdWNoZXMsIGFsbFRvdWNoZXNdO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciB0YXJnZXRUb3VjaGVzO1xuICAgIHZhciBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpO1xuICAgIHZhciBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDsgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xuXG4gICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gICAgfSk7IC8vIGNvbGxlY3QgdG91Y2hlc1xuXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9IC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcblxuXG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgaWYgKHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5wdXNoKGNoYW5nZWRUb3VjaGVzW2ldKTtcbiAgICAgIH0gLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcblxuXG4gICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBbLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gICAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLCBjaGFuZ2VkVGFyZ2V0VG91Y2hlc107XG4gIH1cblxuICB2YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICAgIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gICAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIG1vdXNldXA6IElOUFVUX0VORFxuICB9O1xuICB2YXIgTU9VU0VfRUxFTUVOVF9FVkVOVFMgPSAnbW91c2Vkb3duJztcbiAgdmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogTW91c2UgZXZlbnRzIGlucHV0XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBJbnB1dFxuICAgKi9cblxuICB2YXIgTW91c2VJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lucHV0KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoTW91c2VJbnB1dCwgX0lucHV0KTtcblxuICAgIGZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIHZhciBwcm90byA9IE1vdXNlSW5wdXQucHJvdG90eXBlO1xuICAgICAgcHJvdG8uZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgICAgcHJvdG8uZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xuICAgICAgX3RoaXMgPSBfSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgX3RoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IE1vdXNlSW5wdXQucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGV2KSB7XG4gICAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdOyAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cblxuICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xuICAgICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XG4gICAgICB9IC8vIG1vdXNlIG11c3QgYmUgZG93blxuXG5cbiAgICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1vdXNlSW5wdXQ7XG4gIH0oSW5wdXQpO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XG4gICAqXG4gICAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICAgKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBJbnB1dFxuICAgKi9cblxuXG4gIHZhciBERURVUF9USU1FT1VUID0gMjUwMDtcbiAgdmFyIERFRFVQX0RJU1RBTkNFID0gMjU7XG5cbiAgZnVuY3Rpb24gc2V0TGFzdFRvdWNoKGV2ZW50RGF0YSkge1xuICAgIHZhciBfZXZlbnREYXRhJGNoYW5nZWRQb2kgPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzLFxuICAgICAgICB0b3VjaCA9IF9ldmVudERhdGEkY2hhbmdlZFBvaVswXTtcblxuICAgIGlmICh0b3VjaC5pZGVudGlmaWVyID09PSB0aGlzLnByaW1hcnlUb3VjaCkge1xuICAgICAgdmFyIGxhc3RUb3VjaCA9IHtcbiAgICAgICAgeDogdG91Y2guY2xpZW50WCxcbiAgICAgICAgeTogdG91Y2guY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHZhciBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgICAgdGhpcy5sYXN0VG91Y2hlcy5wdXNoKGxhc3RUb3VjaCk7XG5cbiAgICAgIHZhciByZW1vdmVMYXN0VG91Y2ggPSBmdW5jdGlvbiByZW1vdmVMYXN0VG91Y2goKSB7XG4gICAgICAgIHZhciBpID0gbHRzLmluZGV4T2YobGFzdFRvdWNoKTtcblxuICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgbHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2V0VGltZW91dChyZW1vdmVMYXN0VG91Y2gsIERFRFVQX1RJTUVPVVQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgIHRoaXMucHJpbWFyeVRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXS5pZGVudGlmaWVyO1xuICAgICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ludGhldGljRXZlbnQoZXZlbnREYXRhKSB7XG4gICAgdmFyIHggPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WDtcbiAgICB2YXIgeSA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRZO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHRoaXMubGFzdFRvdWNoZXNbaV07XG4gICAgICB2YXIgZHggPSBNYXRoLmFicyh4IC0gdC54KTtcbiAgICAgIHZhciBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuXG4gICAgICBpZiAoZHggPD0gREVEVVBfRElTVEFOQ0UgJiYgZHkgPD0gREVEVVBfRElTVEFOQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIFRvdWNoTW91c2VJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgdmFyIFRvdWNoTW91c2VJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lucHV0KSB7XG4gICAgICBfaW5oZXJpdHNMb29zZShUb3VjaE1vdXNlSW5wdXQsIF9JbnB1dCk7XG5cbiAgICAgIGZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dChfbWFuYWdlciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzO1xuXG4gICAgICAgIF90aGlzID0gX0lucHV0LmNhbGwodGhpcywgX21hbmFnZXIsIGNhbGxiYWNrKSB8fCB0aGlzO1xuXG4gICAgICAgIF90aGlzLmhhbmRsZXIgPSBmdW5jdGlvbiAobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKSB7XG4gICAgICAgICAgdmFyIGlzVG91Y2ggPSBpbnB1dERhdGEucG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfVE9VQ0g7XG4gICAgICAgICAgdmFyIGlzTW91c2UgPSBpbnB1dERhdGEucG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfTU9VU0U7XG5cbiAgICAgICAgICBpZiAoaXNNb3VzZSAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCByZWNvcmQgdG91Y2hlcyB0byAgZGUtZHVwZSBzeW50aGV0aWMgbW91c2UgZXZlbnRcblxuXG4gICAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgIHJlY29yZFRvdWNoZXMuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkJDEoX2Fzc2VydFRoaXNJbml0aWFsaXplZCQxKF90aGlzKSksIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc01vdXNlICYmIGlzU3ludGhldGljRXZlbnQuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkJDEoX2Fzc2VydFRoaXNJbml0aWFsaXplZCQxKF90aGlzKSksIGlucHV0RGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5jYWxsYmFjayhtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLnRvdWNoID0gbmV3IFRvdWNoSW5wdXQoX3RoaXMubWFuYWdlciwgX3RoaXMuaGFuZGxlcik7XG4gICAgICAgIF90aGlzLm1vdXNlID0gbmV3IE1vdXNlSW5wdXQoX3RoaXMubWFuYWdlciwgX3RoaXMuaGFuZGxlcik7XG4gICAgICAgIF90aGlzLnByaW1hcnlUb3VjaCA9IG51bGw7XG4gICAgICAgIF90aGlzLmxhc3RUb3VjaGVzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICAgKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0RXZlbnRcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgICAqL1xuXG5cbiAgICAgIHZhciBfcHJvdG8gPSBUb3VjaE1vdXNlSW5wdXQucHJvdG90eXBlO1xuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAqL1xuXG4gICAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudG91Y2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1vdXNlLmRlc3Ryb3koKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBUb3VjaE1vdXNlSW5wdXQ7XG4gICAgfShJbnB1dCk7XG5cbiAgICByZXR1cm4gVG91Y2hNb3VzZUlucHV0O1xuICB9KCk7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICAgKiBjYWxsZWQgYnkgdGhlIE1hbmFnZXIgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICogQHJldHVybnMge0lucHV0fVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICAgIHZhciBUeXBlOyAvLyBsZXQgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuXG4gICAgdmFyIGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcblxuICAgIGlmIChpbnB1dENsYXNzKSB7XG4gICAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xuICAgICAgVHlwZSA9IFRvdWNoSW5wdXQ7XG4gICAgfSBlbHNlIGlmICghU1VQUE9SVF9UT1VDSCkge1xuICAgICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUeXBlKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XG4gICAqIGlmIGl0IGFpbnQgYW4gYXJyYXkgd2UgZG9uJ3Qgd2FudCB0byBkbyBhIHRoaW5nLlxuICAgKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cbiAgICogQHBhcmFtIHsqfEFycmF5fSBhcmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW52b2tlQXJyYXlBcmcoYXJnLCBmbiwgY29udGV4dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgIGVhY2goYXJnLCBjb250ZXh0W2ZuXSwgY29udGV4dCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgU1RBVEVfUE9TU0lCTEUgPSAxO1xuICB2YXIgU1RBVEVfQkVHQU4gPSAyO1xuICB2YXIgU1RBVEVfQ0hBTkdFRCA9IDQ7XG4gIHZhciBTVEFURV9FTkRFRCA9IDg7XG4gIHZhciBTVEFURV9SRUNPR05JWkVEID0gU1RBVEVfRU5ERUQ7XG4gIHZhciBTVEFURV9DQU5DRUxMRUQgPSAxNjtcbiAgdmFyIFNUQVRFX0ZBSUxFRCA9IDMyO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZ2V0IGEgdW5pcXVlIGlkXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZUlkXG4gICAqL1xuXG4gIHZhciBfdW5pcXVlSWQgPSAxO1xuXG4gIGZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBfdW5pcXVlSWQrKztcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZ2V0IGEgcmVjb2duaXplciBieSBuYW1lIGlmIGl0IGlzIGJvdW5kIHRvIGEgbWFuYWdlclxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gICAgdmFyIG1hbmFnZXIgPSByZWNvZ25pemVyLm1hbmFnZXI7XG5cbiAgICBpZiAobWFuYWdlcikge1xuICAgICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG90aGVyUmVjb2duaXplcjtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gICAqIEBwYXJhbSB7Y29uc3RhbnR9IHN0YXRlXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHN0YXRlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcbiAgICAgIHJldHVybiAnY2FuY2VsJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfRU5ERUQpIHtcbiAgICAgIHJldHVybiAnZW5kJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgICAgcmV0dXJuICdtb3ZlJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcbiAgICAgIHJldHVybiAnc3RhcnQnO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogUmVjb2duaXplciBmbG93IGV4cGxhaW5lZDsgKlxuICAgKiBBbGwgcmVjb2duaXplcnMgaGF2ZSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBQT1NTSUJMRSB3aGVuIGEgaW5wdXQgc2Vzc2lvbiBzdGFydHMuXG4gICAqIFRoZSBkZWZpbml0aW9uIG9mIGEgaW5wdXQgc2Vzc2lvbiBpcyBmcm9tIHRoZSBmaXJzdCBpbnB1dCB1bnRpbCB0aGUgbGFzdCBpbnB1dCwgd2l0aCBhbGwgaXQncyBtb3ZlbWVudCBpbiBpdC4gKlxuICAgKiBFeGFtcGxlIHNlc3Npb24gZm9yIG1vdXNlLWlucHV0OiBtb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBcbiAgICpcbiAgICogT24gZWFjaCByZWNvZ25pemluZyBjeWNsZSAoc2VlIE1hbmFnZXIucmVjb2duaXplKSB0aGUgLnJlY29nbml6ZSgpIG1ldGhvZCBpcyBleGVjdXRlZFxuICAgKiB3aGljaCBkZXRlcm1pbmVzIHdpdGggc3RhdGUgaXQgc2hvdWxkIGJlLlxuICAgKlxuICAgKiBJZiB0aGUgcmVjb2duaXplciBoYXMgdGhlIHN0YXRlIEZBSUxFRCwgQ0FOQ0VMTEVEIG9yIFJFQ09HTklaRUQgKGVxdWFscyBFTkRFRCksIGl0IGlzIHJlc2V0IHRvXG4gICAqIFBPU1NJQkxFIHRvIGdpdmUgaXQgYW5vdGhlciBjaGFuZ2Ugb24gdGhlIG5leHQgY3ljbGUuXG4gICAqXG4gICAqICAgICAgICAgICAgICAgUG9zc2libGVcbiAgICogICAgICAgICAgICAgICAgICB8XG4gICAqICAgICAgICAgICAgKy0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAgICogICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiAgICAgICstLS0tLSstLS0tLSsgICAgICAgICAgICAgICB8XG4gICAqICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxcbiAgICogICBGYWlsZWQgICAgICBDYW5jZWxsZWQgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0rLS0tLS0tK1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBSZWNvZ25pemVkICAgICAgIEJlZ2FuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGFuZ2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZGVkL1JlY29nbml6ZWRcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFJlY29nbml6ZXJcbiAgICogRXZlcnkgcmVjb2duaXplciBuZWVkcyB0byBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICB2YXIgUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe1xuICAgICAgICBlbmFibGU6IHRydWVcbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgdGhpcy5pZCA9IHVuaXF1ZUlkKCk7XG4gICAgICB0aGlzLm1hbmFnZXIgPSBudWxsOyAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXG5cbiAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICAgIHRoaXMuc2ltdWx0YW5lb3VzID0ge307XG4gICAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1JlY29nbml6ZXJ9XG4gICAgICovXG5cblxuICAgIHZhciBfcHJvdG8gPSBSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICAgICAgYXNzaWduJDEodGhpcy5vcHRpb25zLCBvcHRpb25zKTsgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcblxuICAgICAgdGhpcy5tYW5hZ2VyICYmIHRoaXMubWFuYWdlci50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG5cblxuICAgIF9wcm90by5yZWNvZ25pemVXaXRoID0gZnVuY3Rpb24gcmVjb2duaXplV2l0aChvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcbiAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcblxuICAgICAgaWYgKCFzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSkge1xuICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlY29nbml6ZVdpdGgodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG5cblxuICAgIF9wcm90by5kcm9wUmVjb2duaXplV2l0aCA9IGZ1bmN0aW9uIGRyb3BSZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHJlY29nbml6ZXIgY2FuIG9ubHkgcnVuIHdoZW4gYW4gb3RoZXIgaXMgZmFpbGluZ1xuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLnJlcXVpcmVGYWlsdXJlID0gZnVuY3Rpb24gcmVxdWlyZUZhaWx1cmUob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcbiAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcblxuICAgICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XG4gICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogZHJvcCB0aGUgcmVxdWlyZUZhaWx1cmUgbGluay4gaXQgZG9lcyBub3QgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLmRyb3BSZXF1aXJlRmFpbHVyZSA9IGZ1bmN0aW9uIGRyb3BSZXF1aXJlRmFpbHVyZShvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgdmFyIGluZGV4ID0gaW5BcnJheSh0aGlzLnJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpO1xuXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBoYXMgcmVxdWlyZSBmYWlsdXJlcyBib29sZWFuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cblxuICAgIF9wcm90by5oYXNSZXF1aXJlRmFpbHVyZXMgPSBmdW5jdGlvbiBoYXNSZXF1aXJlRmFpbHVyZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuXG5cbiAgICBfcHJvdG8uY2FuUmVjb2duaXplV2l0aCA9IGZ1bmN0aW9uIGNhblJlY29nbml6ZVdpdGgob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuXG5cbiAgICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgIGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoZXZlbnQsIGlucHV0KTtcbiAgICAgIH0gLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG5cblxuICAgICAgaWYgKHN0YXRlIDwgU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgfVxuXG4gICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgICAgaWYgKGlucHV0LmFkZGl0aW9uYWxFdmVudCkge1xuICAgICAgICAvLyBhZGRpdGlvbmFsIGV2ZW50KHBhbmxlZnQsIHBhbnJpZ2h0LCBwaW5jaGluLCBwaW5jaG91dC4uLilcbiAgICAgICAgZW1pdChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpO1xuICAgICAgfSAvLyBwYW5lbmQgYW5kIHBhbmNhbmNlbFxuXG5cbiAgICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xuICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXG4gICAgICogb3RoZXJ3aXNlLCBzZXR1cCB0aGUgc3RhdGUgdG8gRkFJTEVELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuXG5cbiAgICBfcHJvdG8udHJ5RW1pdCA9IGZ1bmN0aW9uIHRyeUVtaXQoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcbiAgICAgIH0gLy8gaXQncyBmYWlsaW5nIGFueXdheVxuXG5cbiAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIGNhbiB3ZSBlbWl0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBfcHJvdG8uY2FuRW1pdCA9IGZ1bmN0aW9uIGNhbkVtaXQoKSB7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCEodGhpcy5yZXF1aXJlRmFpbFtpXS5zdGF0ZSAmIChTVEFURV9GQUlMRUQgfCBTVEFURV9QT1NTSUJMRSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuXG5cbiAgICBfcHJvdG8ucmVjb2duaXplID0gZnVuY3Rpb24gcmVjb2duaXplKGlucHV0RGF0YSkge1xuICAgICAgLy8gbWFrZSBhIG5ldyBjb3B5IG9mIHRoZSBpbnB1dERhdGFcbiAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgICB2YXIgaW5wdXREYXRhQ2xvbmUgPSBhc3NpZ24kMSh7fSwgaW5wdXREYXRhKTsgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG5cbiAgICAgIGlmICghYm9vbE9yRm4odGhpcy5vcHRpb25zLmVuYWJsZSwgW3RoaXMsIGlucHV0RGF0YUNsb25lXSkpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG5cblxuICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTsgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgICAvLyBzbyB0cmlnZ2VyIGFuIGV2ZW50XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEIHwgU1RBVEVfQ0FOQ0VMTEVEKSkge1xuICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiByZXR1cm4gdGhlIHN0YXRlIG9mIHRoZSByZWNvZ25pemVyXG4gICAgICogdGhlIGFjdHVhbCByZWNvZ25pemluZyBoYXBwZW5zIGluIHRoaXMgbWV0aG9kXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICogQHJldHVybnMge2NvbnN0YW50fSBTVEFURVxuICAgICAqL1xuXG4gICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuXG5cbiAgICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXREYXRhKSB7fTtcbiAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7fTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIGNhbGxlZCB3aGVuIHRoZSBnZXN0dXJlIGlzbid0IGFsbG93ZWQgdG8gcmVjb2duaXplXG4gICAgICogbGlrZSB3aGVuIGFub3RoZXIgaXMgYmVpbmcgcmVjb2duaXplZCBvciBpdCBpcyBkaXNhYmxlZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG5cblxuICAgIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge307XG5cbiAgICByZXR1cm4gUmVjb2duaXplcjtcbiAgfSgpO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQSB0YXAgaXMgcmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAgICogYmV0d2VlbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgYW5kIHBvc2l0aW9uLiBUaGUgZGVsYXkgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHJlY29nbml6ZSBtdWx0aS10YXBzIHdpdGhvdXQgZmlyaW5nXG4gICAqIGEgc2luZ2xlIHRhcC5cbiAgICpcbiAgICogVGhlIGV2ZW50RGF0YSBmcm9tIHRoZSBlbWl0dGVkIGV2ZW50IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBgdGFwQ291bnRgLCB3aGljaCBjb250YWlucyB0aGUgYW1vdW50IG9mXG4gICAqIG11bHRpLXRhcHMgYmVpbmcgcmVjb2duaXplZC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAgICovXG5cblxuICB2YXIgVGFwUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlY29nbml6ZXIpIHtcbiAgICBfaW5oZXJpdHNMb29zZShUYXBSZWNvZ25pemVyLCBfUmVjb2duaXplcik7XG5cbiAgICBmdW5jdGlvbiBUYXBSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIF90aGlzID0gX1JlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICAgIGV2ZW50OiAndGFwJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRhcHM6IDEsXG4gICAgICAgIGludGVydmFsOiAzMDAsXG4gICAgICAgIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXG4gICAgICAgIHRpbWU6IDI1MCxcbiAgICAgICAgLy8gbWF4IHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgZG93biAobGlrZSBmaW5nZXIgb24gdGhlIHNjcmVlbilcbiAgICAgICAgdGhyZXNob2xkOiA5LFxuICAgICAgICAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgICBwb3NUaHJlc2hvbGQ6IDEwXG4gICAgICB9LCBvcHRpb25zKSkgfHwgdGhpczsgLy8gcHJldmlvdXMgdGltZSBhbmQgY2VudGVyLFxuICAgICAgLy8gdXNlZCBmb3IgdGFwIGNvdW50aW5nXG5cbiAgICAgIF90aGlzLnBUaW1lID0gZmFsc2U7XG4gICAgICBfdGhpcy5wQ2VudGVyID0gZmFsc2U7XG4gICAgICBfdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgX3RoaXMuX2lucHV0ID0gbnVsbDtcbiAgICAgIF90aGlzLmNvdW50ID0gMDtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gVGFwUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XG4gICAgfTtcblxuICAgIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhpbnB1dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICB2YXIgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XG4gICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiB0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICB9IC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG5cblxuICAgICAgaWYgKHZhbGlkTW92ZW1lbnQgJiYgdmFsaWRUb3VjaFRpbWUgJiYgdmFsaWRQb2ludGVycykge1xuICAgICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9PSBJTlBVVF9FTkQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbGlkSW50ZXJ2YWwgPSB0aGlzLnBUaW1lID8gaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwgOiB0cnVlO1xuICAgICAgICB2YXIgdmFsaWRNdWx0aVRhcCA9ICF0aGlzLnBDZW50ZXIgfHwgZ2V0RGlzdGFuY2UodGhpcy5wQ2VudGVyLCBpbnB1dC5jZW50ZXIpIDwgb3B0aW9ucy5wb3NUaHJlc2hvbGQ7XG4gICAgICAgIHRoaXMucFRpbWUgPSBpbnB1dC50aW1lU3RhbXA7XG4gICAgICAgIHRoaXMucENlbnRlciA9IGlucHV0LmNlbnRlcjtcblxuICAgICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0OyAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAgIC8vIGVsc2UgaXQgaGFzIGJlZ2FuIHJlY29nbml6aW5nLi4uXG5cbiAgICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcblxuICAgICAgICBpZiAodGFwQ291bnQgPT09IDApIHtcbiAgICAgICAgICAvLyBubyBmYWlsaW5nIHJlcXVpcmVtZW50cywgaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgdGFwIGV2ZW50XG4gICAgICAgICAgLy8gb3Igd2FpdCBhcyBsb25nIGFzIHRoZSBtdWx0aXRhcCBpbnRlcnZhbCB0byB0cmlnZ2VyXG4gICAgICAgICAgaWYgKCF0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpKSB7XG4gICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcblxuICAgICAgICAgICAgICBfdGhpczIudHJ5RW1pdCgpO1xuICAgICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfTtcblxuICAgIF9wcm90by5mYWlsVGltZW91dCA9IGZ1bmN0aW9uIGZhaWxUaW1lb3V0KCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgfTtcblxuICAgIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdCgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBUYXBSZWNvZ25pemVyO1xuICB9KFJlY29nbml6ZXIpO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgUmVjb2duaXplclxuICAgKi9cblxuXG4gIHZhciBBdHRyUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlY29nbml6ZXIpIHtcbiAgICBfaW5oZXJpdHNMb29zZShBdHRyUmVjb2duaXplciwgX1JlY29nbml6ZXIpO1xuXG4gICAgZnVuY3Rpb24gQXR0clJlY29nbml6ZXIob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgICAgcG9pbnRlcnM6IDFcbiAgICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFVzZWQgdG8gY2hlY2sgaWYgaXQgdGhlIHJlY29nbml6ZXIgcmVjZWl2ZXMgdmFsaWQgaW5wdXQsIGxpa2UgaW5wdXQuZGlzdGFuY2UgPiAxMC5cbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmVjb2duaXplZFxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gQXR0clJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICAgIHZhciBvcHRpb25Qb2ludGVycyA9IHRoaXMub3B0aW9ucy5wb2ludGVycztcbiAgICAgIHJldHVybiBvcHRpb25Qb2ludGVycyA9PT0gMCB8fCBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvblBvaW50ZXJzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBQcm9jZXNzIHRoZSBpbnB1dCBhbmQgcmV0dXJuIHRoZSBzdGF0ZSBmb3IgdGhlIHJlY29nbml6ZXJcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Kn0gU3RhdGVcbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGlucHV0KSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcbiAgICAgIHZhciBpc1JlY29nbml6ZWQgPSBzdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQpO1xuICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTsgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxuXG4gICAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgICB9IGVsc2UgaWYgKCEoc3RhdGUgJiBTVEFURV9CRUdBTikpIHtcbiAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DSEFOR0VEO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH07XG5cbiAgICByZXR1cm4gQXR0clJlY29nbml6ZXI7XG4gIH0oUmVjb2duaXplcik7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBkaXJlY3Rpb24gY29ucyB0byBzdHJpbmdcbiAgICogQHBhcmFtIHtjb25zdGFudH0gZGlyZWN0aW9uXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZGlyZWN0aW9uU3RyKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9ET1dOKSB7XG4gICAgICByZXR1cm4gJ2Rvd24nO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fVVApIHtcbiAgICAgIHJldHVybiAndXAnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fTEVGVCkge1xuICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1JJR0hUKSB7XG4gICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFBhblxuICAgKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBhbmQgbW92ZWQgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAgICovXG5cblxuICB2YXIgUGFuUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoUGFuUmVjb2duaXplciwgX0F0dHJSZWNvZ25pemVyKTtcblxuICAgIGZ1bmN0aW9uIFBhblJlY29nbml6ZXIob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMgPSBfQXR0clJlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICAgIGV2ZW50OiAncGFuJyxcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0FMTFxuICAgICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5wWCA9IG51bGw7XG4gICAgICBfdGhpcy5wWSA9IG51bGw7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFBhblJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgIHZhciBhY3Rpb25zID0gW107XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfTtcblxuICAgIF9wcm90by5kaXJlY3Rpb25UZXN0ID0gZnVuY3Rpb24gZGlyZWN0aW9uVGVzdChpbnB1dCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xuICAgICAgdmFyIGRpc3RhbmNlID0gaW5wdXQuZGlzdGFuY2U7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQuZGlyZWN0aW9uO1xuICAgICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XG4gICAgICB2YXIgeSA9IGlucHV0LmRlbHRhWTsgLy8gbG9jayB0byBheGlzP1xuXG4gICAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICBkaXJlY3Rpb24gPSB4ID09PSAwID8gRElSRUNUSU9OX05PTkUgOiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICAgIGhhc01vdmVkID0geCAhPT0gdGhpcy5wWDtcbiAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlyZWN0aW9uID0geSA9PT0gMCA/IERJUkVDVElPTl9OT05FIDogeSA8IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgICBoYXNNb3ZlZCA9IHkgIT09IHRoaXMucFk7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgIHJldHVybiBoYXNNb3ZlZCAmJiBkaXN0YW5jZSA+IG9wdGlvbnMudGhyZXNob2xkICYmIGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uO1xuICAgIH07XG5cbiAgICBfcHJvdG8uYXR0clRlc3QgPSBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgICAgcmV0dXJuIEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiAoIC8vIHJlcGxhY2Ugd2l0aCBhIHN1cGVyIGNhbGxcbiAgICAgIHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTiB8fCAhKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSk7XG4gICAgfTtcblxuICAgIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICAgIHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICBfQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfTtcblxuICAgIHJldHVybiBQYW5SZWNvZ25pemVyO1xuICB9KEF0dHJSZWNvZ25pemVyKTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFN3aXBlXG4gICAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBtb3ZpbmcgZmFzdCAodmVsb2NpdHkpLCB3aXRoIGVub3VnaCBkaXN0YW5jZSBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICAgKi9cblxuXG4gIHZhciBTd2lwZVJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BdHRyUmVjb2duaXplcikge1xuICAgIF9pbmhlcml0c0xvb3NlKFN3aXBlUmVjb2duaXplciwgX0F0dHJSZWNvZ25pemVyKTtcblxuICAgIGZ1bmN0aW9uIFN3aXBlUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHZlbG9jaXR5OiAwLjMsXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICAgIHBvaW50ZXJzOiAxXG4gICAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gU3dpcGVSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gICAgfTtcblxuICAgIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgIHZhciB2ZWxvY2l0eTtcblxuICAgICAgaWYgKGRpcmVjdGlvbiAmIChESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHk7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WDtcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgZGlyZWN0aW9uICYgaW5wdXQub2Zmc2V0RGlyZWN0aW9uICYmIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJiBpbnB1dC5tYXhQb2ludGVycyA9PT0gdGhpcy5vcHRpb25zLnBvaW50ZXJzICYmIGFicyh2ZWxvY2l0eSkgPiB0aGlzLm9wdGlvbnMudmVsb2NpdHkgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcblxuICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCBpbnB1dCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTd2lwZVJlY29nbml6ZXI7XG4gIH0oQXR0clJlY29nbml6ZXIpO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogUGluY2hcbiAgICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXJzIGFyZSBtb3ZpbmcgdG93YXJkICh6b29tLWluKSBvciBhd2F5IGZyb20gZWFjaCBvdGhlciAoem9vbS1vdXQpLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAgICovXG5cblxuICB2YXIgUGluY2hSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXR0clJlY29nbml6ZXIpIHtcbiAgICBfaW5oZXJpdHNMb29zZShQaW5jaFJlY29nbml6ZXIsIF9BdHRyUmVjb2duaXplcik7XG5cbiAgICBmdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICAgIGV2ZW50OiAncGluY2gnLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHBvaW50ZXJzOiAyXG4gICAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gUGluY2hSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfTtcblxuICAgIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiAoTWF0aC5hYnMoaW5wdXQuc2NhbGUgLSAxKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBpbk91dDtcbiAgICAgIH1cblxuICAgICAgX0F0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGluY2hSZWNvZ25pemVyO1xuICB9KEF0dHJSZWNvZ25pemVyKTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFJvdGF0ZVxuICAgKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAgICovXG5cblxuICB2YXIgUm90YXRlUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoUm90YXRlUmVjb2duaXplciwgX0F0dHJSZWNvZ25pemVyKTtcblxuICAgIGZ1bmN0aW9uIFJvdGF0ZVJlY29nbml6ZXIob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICAgIGV2ZW50OiAncm90YXRlJyxcbiAgICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgICBwb2ludGVyczogMlxuICAgICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFJvdGF0ZVJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmIChNYXRoLmFicyhpbnB1dC5yb3RhdGlvbikgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfTtcblxuICAgIHJldHVybiBSb3RhdGVSZWNvZ25pemVyO1xuICB9KEF0dHJSZWNvZ25pemVyKTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFByZXNzXG4gICAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGZvciB4IG1zIHdpdGhvdXQgYW55IG1vdmVtZW50LlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgUmVjb2duaXplclxuICAgKi9cblxuXG4gIHZhciBQcmVzc1JlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWNvZ25pemVyKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoUHJlc3NSZWNvZ25pemVyLCBfUmVjb2duaXplcik7XG5cbiAgICBmdW5jdGlvbiBQcmVzc1JlY29nbml6ZXIob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMgPSBfUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgICAgZXZlbnQ6ICdwcmVzcycsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICB0aW1lOiAyNTEsXG4gICAgICAgIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXG4gICAgICAgIHRocmVzaG9sZDogOVxuICAgICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgX3RoaXMuX2lucHV0ID0gbnVsbDtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gUHJlc3NSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfTtcblxuICAgIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhpbnB1dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDsgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcblxuICAgICAgaWYgKCF2YWxpZE1vdmVtZW50IHx8ICF2YWxpZFBvaW50ZXJzIHx8IGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcblxuICAgICAgICAgIF90aGlzMi50cnlFbWl0KCk7XG4gICAgICAgIH0sIG9wdGlvbnMudGltZSk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlucHV0ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBcInVwXCIsIGlucHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFByZXNzUmVjb2duaXplcjtcbiAgfShSZWNvZ25pemVyKTtcblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuICAgICAqIEJ1dCB0aGlzIGlzIHNsb3dlciBhbmQgdW51c2VkIGJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbnMsIHNvIGRpc2FibGVkIGJ5IGRlZmF1bHQuXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkb21FdmVudHM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBUaGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eS9mYWxsYmFjay5cbiAgICAgKiBXaGVuIHNldCB0byBgY29tcHV0ZWAgaXQgd2lsbCBtYWdpY2FsbHkgc2V0IHRoZSBjb3JyZWN0IHZhbHVlIGJhc2VkIG9uIHRoZSBhZGRlZCByZWNvZ25pemVycy5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IGNvbXB1dGVcbiAgICAgKi9cbiAgICB0b3VjaEFjdGlvbjogVE9VQ0hfQUNUSU9OX0NPTVBVVEUsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBlbmFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEVYUEVSSU1FTlRBTCBGRUFUVVJFIC0tIGNhbiBiZSByZW1vdmVkL2NoYW5nZWRcbiAgICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cbiAgICAgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtOdWxsfEV2ZW50VGFyZ2V0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dFRhcmdldDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogZm9yY2UgYW4gaW5wdXQgY2xhc3NcbiAgICAgKiBAdHlwZSB7TnVsbHxGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRDbGFzczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogU29tZSBDU1MgcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHRoZSB3b3JraW5nIG9mIEhhbW1lci5cbiAgICAgKiBBZGQgdGhlbSB0byB0aGlzIG1ldGhvZCBhbmQgdGhleSB3aWxsIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIuXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqL1xuICAgIGNzc1Byb3BzOiB7XG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBEaXNhYmxlcyB0ZXh0IHNlbGVjdGlvbiB0byBpbXByb3ZlIHRoZSBkcmFnZ2luZyBnZXN0dXJlLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgKi9cbiAgICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBEaXNhYmxlIHRoZSBXaW5kb3dzIFBob25lIGdyaXBwZXJzIHdoZW4gcHJlc3NpbmcgYW4gZWxlbWVudC5cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAqL1xuICAgICAgdG91Y2hTZWxlY3Q6IFwibm9uZVwiLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBEaXNhYmxlcyB0aGUgZGVmYXVsdCBjYWxsb3V0IHNob3duIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0LlxuICAgICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICovXG4gICAgICB0b3VjaENhbGxvdXQ6IFwibm9uZVwiLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB6b29taW5nIGlzIGVuYWJsZWQuIFVzZWQgYnkgSUUxMD5cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAqL1xuICAgICAgY29udGVudFpvb21pbmc6IFwibm9uZVwiLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgKi9cbiAgICAgIHVzZXJEcmFnOiBcIm5vbmVcIixcblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcbiAgICAgICAqIGNsaWNrYWJsZSBlbGVtZW50IGluIGlPUy4gVGhpcyBwcm9wZXJ0eSBvYmV5cyB0aGUgYWxwaGEgdmFsdWUsIGlmIHNwZWNpZmllZC5cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcbiAgICAgICAqL1xuICAgICAgdGFwSGlnaGxpZ2h0Q29sb3I6IFwicmdiYSgwLDAsMCwwKVwiXG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gICAqIFdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlciB0aGVzZSB3aWxsIGJlIHNraXBwZWQuXG4gICAqIFRoaXMgaXMgc2VwYXJhdGVkIHdpdGggb3RoZXIgZGVmYXVsdHMgYmVjYXVzZSBvZiB0cmVlLXNoYWtpbmcuXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG5cbiAgdmFyIHByZXNldCA9IFtbUm90YXRlUmVjb2duaXplciwge1xuICAgIGVuYWJsZTogZmFsc2VcbiAgfV0sIFtQaW5jaFJlY29nbml6ZXIsIHtcbiAgICBlbmFibGU6IGZhbHNlXG4gIH0sIFsncm90YXRlJ11dLCBbU3dpcGVSZWNvZ25pemVyLCB7XG4gICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTFxuICB9XSwgW1BhblJlY29nbml6ZXIsIHtcbiAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMXG4gIH0sIFsnc3dpcGUnXV0sIFtUYXBSZWNvZ25pemVyXSwgW1RhcFJlY29nbml6ZXIsIHtcbiAgICBldmVudDogJ2RvdWJsZXRhcCcsXG4gICAgdGFwczogMlxuICB9LCBbJ3RhcCddXSwgW1ByZXNzUmVjb2duaXplcl1dO1xuICB2YXIgU1RPUCA9IDE7XG4gIHZhciBGT1JDRURfU1RPUCA9IDI7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xuICAgKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBhZGRcbiAgICovXG5cbiAgZnVuY3Rpb24gdG9nZ2xlQ3NzUHJvcHMobWFuYWdlciwgYWRkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG5cbiAgICBpZiAoIWVsZW1lbnQuc3R5bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcDtcbiAgICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgICBwcm9wID0gcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSk7XG5cbiAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSA9IGVsZW1lbnQuc3R5bGVbcHJvcF07XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdIHx8IFwiXCI7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWFkZCkge1xuICAgICAgbWFuYWdlci5vbGRDc3NQcm9wcyA9IHt9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogdHJpZ2dlciBkb20gZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGdlc3R1cmVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgZ2VzdHVyZUV2ZW50LmluaXRFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xuICAgIGRhdGEudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VzdHVyZUV2ZW50KTtcbiAgfVxuICAvKipcbiAgKiBAcHJpdmF0ZVxuICAgKiBNYW5hZ2VyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG5cblxuICB2YXIgTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFuYWdlcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24kMSh7fSwgZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG4gICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICAgIHRoaXMub2xkQ3NzUHJvcHMgPSB7fTtcbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgICAgIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIHRydWUpO1xuICAgICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciByZWNvZ25pemVyID0gX3RoaXMuYWRkKG5ldyBpdGVtWzBdKGl0ZW1bMV0pKTtcblxuICAgICAgICBpdGVtWzJdICYmIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtWzJdKTtcbiAgICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gTWFuYWdlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgICAgIGFzc2lnbiQxKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7IC8vIE9wdGlvbnMgdGhhdCBuZWVkIGEgbGl0dGxlIG1vcmUgc2V0dXBcblxuICAgICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuaW5wdXRUYXJnZXQpIHtcbiAgICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcbiAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaW5wdXQudGFyZ2V0ID0gb3B0aW9ucy5pbnB1dFRhcmdldDtcbiAgICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBzdG9wIHJlY29nbml6aW5nIGZvciB0aGlzIHNlc3Npb24uXG4gICAgICogVGhpcyBzZXNzaW9uIHdpbGwgYmUgZGlzY2FyZGVkLCB3aGVuIGEgbmV3IFtpbnB1dF1zdGFydCBldmVudCBpcyBmaXJlZC5cbiAgICAgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLnN0b3AgPSBmdW5jdGlvbiBzdG9wKGZvcmNlKSB7XG4gICAgICB0aGlzLnNlc3Npb24uc3RvcHBlZCA9IGZvcmNlID8gRk9SQ0VEX1NUT1AgOiBTVE9QO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBydW4gdGhlIHJlY29nbml6ZXJzIVxuICAgICAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcbiAgICAgKiBpdCB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgcmVjb2duaXplcnMgYW5kIHRyaWVzIHRvIGRldGVjdCB0aGUgZ2VzdHVyZSB0aGF0IGlzIGJlaW5nIG1hZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG5cblxuICAgIF9wcm90by5yZWNvZ25pemUgPSBmdW5jdGlvbiByZWNvZ25pemUoaW5wdXREYXRhKSB7XG4gICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcblxuICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHJ1biB0aGUgdG91Y2gtYWN0aW9uIHBvbHlmaWxsXG5cblxuICAgICAgdGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHMoaW5wdXREYXRhKTtcbiAgICAgIHZhciByZWNvZ25pemVyO1xuICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVyczsgLy8gdGhpcyBob2xkcyB0aGUgcmVjb2duaXplciB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXG5cbiAgICAgIHZhciBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyOyAvLyByZXNldCB3aGVuIHRoZSBsYXN0IHJlY29nbml6ZXIgaXMgcmVjb2duaXplZFxuICAgICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXG5cbiAgICAgIGlmICghY3VyUmVjb2duaXplciB8fCBjdXJSZWNvZ25pemVyICYmIGN1clJlY29nbml6ZXIuc3RhdGUgJiBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgIHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgICAgIGN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpIDwgcmVjb2duaXplcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlY29nbml6ZXIgPSByZWNvZ25pemVyc1tpXTsgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxuICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcbiAgICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXG4gICAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cbiAgICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXG5cbiAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXG4gICAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT09IGN1clJlY29nbml6ZXIgfHwgLy8gMlxuICAgICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7XG4gICAgICAgICAgLy8gM1xuICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgICB9IC8vIGlmIHRoZSByZWNvZ25pemVyIGhhcyBiZWVuIHJlY29nbml6aW5nIHRoZSBpbnB1dCBhcyBhIHZhbGlkIGdlc3R1cmUsIHdlIHdhbnQgdG8gc3RvcmUgdGhpcyBvbmUgYXMgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuXG5cbiAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgICAgc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcbiAgICAgICAgICBjdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TnVsbH1cbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChyZWNvZ25pemVyKSB7XG4gICAgICBpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFJlY29nbml6ZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlY29nbml6ZXJzW2ldLm9wdGlvbnMuZXZlbnQgPT09IHJlY29nbml6ZXIpIHtcbiAgICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZSBhZGQgYSByZWNvZ25pemVyIHRvIHRoZSBtYW5hZ2VyXG4gICAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE1hbmFnZXJ9XG4gICAgICovXG5cblxuICAgIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQocmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsIFwiYWRkXCIsIHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSAvLyByZW1vdmUgZXhpc3RpbmdcblxuXG4gICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuXG4gICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoZXhpc3RpbmcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgICByZWNvZ25pemVyLm1hbmFnZXIgPSB0aGlzO1xuICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiByZW1vdmUgYSByZWNvZ25pemVyIGJ5IG5hbWUgb3IgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG5cblxuICAgIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUocmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsIFwicmVtb3ZlXCIsIHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0UmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpOyAvLyBsZXQncyBtYWtlIHN1cmUgdGhpcyByZWNvZ25pemVyIGV4aXN0c1xuXG4gICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCB0YXJnZXRSZWNvZ25pemVyKTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBiaW5kIGV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG5cblxuICAgIF9wcm90by5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkIHx8IGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGUgdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuXG5cbiAgICBfcHJvdG8ub2ZmID0gZnVuY3Rpb24gb2ZmKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVyc1tldmVudF0gJiYgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGUgZW1pdCBldmVudCB0byB0aGUgbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBkYXRhKSB7XG4gICAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gdHJpZ2dlciBkb20gZXZlbnRzXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgICB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpO1xuICAgICAgfSAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcblxuXG4gICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuXG4gICAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnR5cGUgPSBldmVudDtcblxuICAgICAgZGF0YS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICBoYW5kbGVyc1tpXShkYXRhKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcbiAgICAgKiBpdCBkb2Vzbid0IHVuYmluZCBkb20gZXZlbnRzLCB0aGF0IGlzIHRoZSB1c2VyIG93biByZXNwb25zaWJpbGl0eVxuICAgICAqL1xuXG5cbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmVsZW1lbnQgJiYgdG9nZ2xlQ3NzUHJvcHModGhpcywgZmFsc2UpO1xuICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBNYW5hZ2VyO1xuICB9KCk7XG5cbiAgdmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxuICB9O1xuICB2YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG4gIHZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBUb3VjaCBldmVudHMgaW5wdXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIElucHV0XG4gICAqL1xuXG4gIHZhciBTaW5nbGVUb3VjaElucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSW5wdXQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShTaW5nbGVUb3VjaElucHV0LCBfSW5wdXQpO1xuXG4gICAgZnVuY3Rpb24gU2luZ2xlVG91Y2hJbnB1dCgpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgdmFyIHByb3RvID0gU2luZ2xlVG91Y2hJbnB1dC5wcm90b3R5cGU7XG4gICAgICBwcm90by5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgICAgcHJvdG8uZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICAgIF90aGlzID0gX0lucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgIF90aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gU2luZ2xlVG91Y2hJbnB1dC5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXYpIHtcbiAgICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTsgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuXG4gICAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG91Y2hlcyA9IG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7IC8vIHdoZW4gZG9uZSwgcmVzZXQgdGhlIHN0YXJ0ZWQgc3RhdGVcblxuICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiB0b3VjaGVzWzBdLmxlbmd0aCAtIHRvdWNoZXNbMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNpbmdsZVRvdWNoSW5wdXQ7XG4gIH0oSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICB2YXIgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgY2hhbmdlZCA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpO1xuXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2FsbCwgY2hhbmdlZF07XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHdyYXBwaW5nIHRoZSBzdXBwbGllZCBtZXRob2QuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZGVwcmVjYXRlKG1ldGhvZCwgbmFtZSwgbWVzc2FnZSkge1xuICAgIHZhciBkZXByZWNhdGlvbk1lc3NhZ2UgPSBcIkRFUFJFQ0FURUQgTUVUSE9EOiBcIiArIG5hbWUgKyBcIlxcblwiICsgbWVzc2FnZSArIFwiIEFUIFxcblwiO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignZ2V0LXN0YWNrLXRyYWNlJyk7XG4gICAgICB2YXIgc3RhY2sgPSBlICYmIGUuc3RhY2sgPyBlLnN0YWNrLnJlcGxhY2UoL15bXlxcKF0rP1tcXG4kXS9nbSwgJycpLnJlcGxhY2UoL15cXHMrYXRcXHMrL2dtLCAnJykucmVwbGFjZSgvXk9iamVjdC48YW5vbnltb3VzPlxccypcXCgvZ20sICd7YW5vbnltb3VzfSgpQCcpIDogJ1Vua25vd24gU3RhY2sgVHJhY2UnO1xuICAgICAgdmFyIGxvZyA9IHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS53YXJuIHx8IHdpbmRvdy5jb25zb2xlLmxvZyk7XG5cbiAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgbG9nLmNhbGwod2luZG93LmNvbnNvbGUsIGRlcHJlY2F0aW9uTWVzc2FnZSwgc3RhY2spO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZXh0ZW5kIG9iamVjdC5cbiAgICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAgICovXG5cblxuICB2YXIgZXh0ZW5kID0gZGVwcmVjYXRlKGZ1bmN0aW9uIChkZXN0LCBzcmMsIG1lcmdlKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgIGlmICghbWVyZ2UgfHwgbWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdDtcbiAgfSwgJ2V4dGVuZCcsICdVc2UgYGFzc2lnbmAuJyk7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxuICAgKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBkZXN0IHdpbGwgbm90IGJlIG92ZXJ3cml0dGVuIGJ5IHNyY1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAgICovXG5cbiAgdmFyIG1lcmdlJDEgPSBkZXByZWNhdGUoZnVuY3Rpb24gKGRlc3QsIHNyYykge1xuICAgIHJldHVybiBleHRlbmQoZGVzdCwgc3JjLCB0cnVlKTtcbiAgfSwgJ21lcmdlJywgJ1VzZSBgYXNzaWduYC4nKTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGlsZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAgICovXG5cbiAgZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xuICAgIHZhciBiYXNlUCA9IGJhc2UucHJvdG90eXBlO1xuICAgIHZhciBjaGlsZFA7XG4gICAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XG4gICAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgY2hpbGRQLl9zdXBlciA9IGJhc2VQO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIGFzc2lnbiQxKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzaW1wbGUgZnVuY3Rpb24gYmluZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBTaW1wbGUgd2F5IHRvIGNyZWF0ZSBhIG1hbmFnZXIgd2l0aCBhIGRlZmF1bHQgc2V0IG9mIHJlY29nbml6ZXJzLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuXG5cbiAgdmFyIEhhbW1lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgdmFyIEhhbW1lciA9XG4gICAgLyoqXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqIEBjb25zdCB7c3RyaW5nfVxuICAgICAgKi9cbiAgICBmdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTWFuYWdlcihlbGVtZW50LCBfZXh0ZW5kcyh7XG4gICAgICAgIHJlY29nbml6ZXJzOiBwcmVzZXQuY29uY2F0KClcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9O1xuXG4gICAgSGFtbWVyLlZFUlNJT04gPSBcIjIuMC4xNy1yY1wiO1xuICAgIEhhbW1lci5ESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0FMTDtcbiAgICBIYW1tZXIuRElSRUNUSU9OX0RPV04gPSBESVJFQ1RJT05fRE9XTjtcbiAgICBIYW1tZXIuRElSRUNUSU9OX0xFRlQgPSBESVJFQ1RJT05fTEVGVDtcbiAgICBIYW1tZXIuRElSRUNUSU9OX1JJR0hUID0gRElSRUNUSU9OX1JJR0hUO1xuICAgIEhhbW1lci5ESVJFQ1RJT05fVVAgPSBESVJFQ1RJT05fVVA7XG4gICAgSGFtbWVyLkRJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0hPUklaT05UQUw7XG4gICAgSGFtbWVyLkRJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9WRVJUSUNBTDtcbiAgICBIYW1tZXIuRElSRUNUSU9OX05PTkUgPSBESVJFQ1RJT05fTk9ORTtcbiAgICBIYW1tZXIuRElSRUNUSU9OX0RPV04gPSBESVJFQ1RJT05fRE9XTjtcbiAgICBIYW1tZXIuSU5QVVRfU1RBUlQgPSBJTlBVVF9TVEFSVDtcbiAgICBIYW1tZXIuSU5QVVRfTU9WRSA9IElOUFVUX01PVkU7XG4gICAgSGFtbWVyLklOUFVUX0VORCA9IElOUFVUX0VORDtcbiAgICBIYW1tZXIuSU5QVVRfQ0FOQ0VMID0gSU5QVVRfQ0FOQ0VMO1xuICAgIEhhbW1lci5TVEFURV9QT1NTSUJMRSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgIEhhbW1lci5TVEFURV9CRUdBTiA9IFNUQVRFX0JFR0FOO1xuICAgIEhhbW1lci5TVEFURV9DSEFOR0VEID0gU1RBVEVfQ0hBTkdFRDtcbiAgICBIYW1tZXIuU1RBVEVfRU5ERUQgPSBTVEFURV9FTkRFRDtcbiAgICBIYW1tZXIuU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgSGFtbWVyLlNUQVRFX0NBTkNFTExFRCA9IFNUQVRFX0NBTkNFTExFRDtcbiAgICBIYW1tZXIuU1RBVEVfRkFJTEVEID0gU1RBVEVfRkFJTEVEO1xuICAgIEhhbW1lci5NYW5hZ2VyID0gTWFuYWdlcjtcbiAgICBIYW1tZXIuSW5wdXQgPSBJbnB1dDtcbiAgICBIYW1tZXIuVG91Y2hBY3Rpb24gPSBUb3VjaEFjdGlvbjtcbiAgICBIYW1tZXIuVG91Y2hJbnB1dCA9IFRvdWNoSW5wdXQ7XG4gICAgSGFtbWVyLk1vdXNlSW5wdXQgPSBNb3VzZUlucHV0O1xuICAgIEhhbW1lci5Qb2ludGVyRXZlbnRJbnB1dCA9IFBvaW50ZXJFdmVudElucHV0O1xuICAgIEhhbW1lci5Ub3VjaE1vdXNlSW5wdXQgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gICAgSGFtbWVyLlNpbmdsZVRvdWNoSW5wdXQgPSBTaW5nbGVUb3VjaElucHV0O1xuICAgIEhhbW1lci5SZWNvZ25pemVyID0gUmVjb2duaXplcjtcbiAgICBIYW1tZXIuQXR0clJlY29nbml6ZXIgPSBBdHRyUmVjb2duaXplcjtcbiAgICBIYW1tZXIuVGFwID0gVGFwUmVjb2duaXplcjtcbiAgICBIYW1tZXIuUGFuID0gUGFuUmVjb2duaXplcjtcbiAgICBIYW1tZXIuU3dpcGUgPSBTd2lwZVJlY29nbml6ZXI7XG4gICAgSGFtbWVyLlBpbmNoID0gUGluY2hSZWNvZ25pemVyO1xuICAgIEhhbW1lci5Sb3RhdGUgPSBSb3RhdGVSZWNvZ25pemVyO1xuICAgIEhhbW1lci5QcmVzcyA9IFByZXNzUmVjb2duaXplcjtcbiAgICBIYW1tZXIub24gPSBhZGRFdmVudExpc3RlbmVycztcbiAgICBIYW1tZXIub2ZmID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnM7XG4gICAgSGFtbWVyLmVhY2ggPSBlYWNoO1xuICAgIEhhbW1lci5tZXJnZSA9IG1lcmdlJDE7XG4gICAgSGFtbWVyLmV4dGVuZCA9IGV4dGVuZDtcbiAgICBIYW1tZXIuYmluZEZuID0gYmluZEZuO1xuICAgIEhhbW1lci5hc3NpZ24gPSBhc3NpZ24kMTtcbiAgICBIYW1tZXIuaW5oZXJpdCA9IGluaGVyaXQ7XG4gICAgSGFtbWVyLmJpbmRGbiA9IGJpbmRGbjtcbiAgICBIYW1tZXIucHJlZml4ZWQgPSBwcmVmaXhlZDtcbiAgICBIYW1tZXIudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgSGFtbWVyLmluQXJyYXkgPSBpbkFycmF5O1xuICAgIEhhbW1lci51bmlxdWVBcnJheSA9IHVuaXF1ZUFycmF5O1xuICAgIEhhbW1lci5zcGxpdFN0ciA9IHNwbGl0U3RyO1xuICAgIEhhbW1lci5ib29sT3JGbiA9IGJvb2xPckZuO1xuICAgIEhhbW1lci5oYXNQYXJlbnQgPSBoYXNQYXJlbnQ7XG4gICAgSGFtbWVyLmFkZEV2ZW50TGlzdGVuZXJzID0gYWRkRXZlbnRMaXN0ZW5lcnM7XG4gICAgSGFtbWVyLnJlbW92ZUV2ZW50TGlzdGVuZXJzID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnM7XG4gICAgSGFtbWVyLmRlZmF1bHRzID0gYXNzaWduJDEoe30sIGRlZmF1bHRzLCB7XG4gICAgICBwcmVzZXQ6IHByZXNldFxuICAgIH0pO1xuICAgIHJldHVybiBIYW1tZXI7XG4gIH0oKTsgLy8gIHN0eWxlIGxvYWRlciBidXQgYnkgc2NyaXB0IHRhZywgbm90IGJ5IHRoZSBsb2FkZXIuXG4gIHZhciBSZWFsSGFtbWVyID0gSGFtbWVyO1xuXG4gIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIHN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChpc0FycmF5JDEobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDMobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG4gIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQzKG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQyMTsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDMobywgbWluTGVuKTsgdmFyIG4gPSBzbGljZShfY29udGV4dDIxID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0MjEsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb20kMyhvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQzKG8sIG1pbkxlbik7IH1cblxuICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQzKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuICAvKipcclxuICAgKiBVc2UgdGhpcyBzeW1ib2wgdG8gZGVsZXRlIHByb3BlcmllcyBpbiBkZWVwT2JqZWN0QXNzaWduLlxyXG4gICAqL1xuXG4gIHZhciBERUxFVEUgPSBzeW1ib2woXCJERUxFVEVcIik7XG4gIC8qKlxyXG4gICAqIFB1cmUgdmVyc2lvbiBvZiBkZWVwT2JqZWN0QXNzaWduLCBpdCBkb2Vzbid0IG1vZGlmeSBhbnkgb2YgaXQncyBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYmFzZSAtIFRoZSBiYXNlIG9iamVjdCB0aGF0IGZ1bGxmaWxzIHRoZSB3aG9sZSBpbnRlcmZhY2UgVC5cclxuICAgKiBAcGFyYW0gdXBkYXRlcyAtIFVwZGF0ZXMgdGhhdCBtYXkgY2hhbmdlIG9yIGRlbGV0ZSBwcm9wcy5cclxuICAgKiBAcmV0dXJucyBBIGJyYW5kIG5ldyBpbnN0YW5jZSB3aXRoIGFsbCB0aGUgc3VwcGxpZWQgb2JqZWN0cyBkZWVwbHkgbWVyZ2VkLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcHVyZURlZXBPYmplY3RBc3NpZ24oYmFzZSkge1xuICAgIHZhciBfY29udGV4dDtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB1cGRhdGVzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHVwZGF0ZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBkZWVwT2JqZWN0QXNzaWduLmFwcGx5KHZvaWQgMCwgY29uY2F0JDEoX2NvbnRleHQgPSBbe30sIGJhc2VdKS5jYWxsKF9jb250ZXh0LCB1cGRhdGVzKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogRGVlcCB2ZXJzaW9uIG9mIG9iamVjdCBhc3NpZ24gd2l0aCBhZGRpdGlvbmFsIGRlbGV0aW5nIGJ5IHRoZSBERUxFVEUgc3ltYm9sLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHZhbHVlcyAtIE9iamVjdHMgdG8gYmUgZGVlcGx5IG1lcmdlZC5cclxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3Qgb2JqZWN0IGZyb20gdmFsdWVzLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZGVlcE9iamVjdEFzc2lnbigpIHtcbiAgICB2YXIgbWVyZ2VkID0gZGVlcE9iamVjdEFzc2lnbk5vbmVudHJ5LmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICBzdHJpcERlbGV0ZShtZXJnZWQpO1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH1cbiAgLyoqXHJcbiAgICogRGVlcCB2ZXJzaW9uIG9mIG9iamVjdCBhc3NpZ24gd2l0aCBhZGRpdGlvbmFsIGRlbGV0aW5nIGJ5IHRoZSBERUxFVEUgc3ltYm9sLlxyXG4gICAqXHJcbiAgICogQHJlbWFya3NcclxuICAgKiBUaGlzIGRvZXNuJ3Qgc3RyaXAgdGhlIERFTEVURSBzeW1ib2xzIHNvIHRoZXkgbWF5IGVuZCB1cCBpbiB0aGUgZmluYWwgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSB2YWx1ZXMgLSBPYmplY3RzIHRvIGJlIGRlZXBseSBtZXJnZWQuXHJcbiAgICogQHJldHVybnMgVGhlIGZpcnN0IG9iamVjdCBmcm9tIHZhbHVlcy5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGRlZXBPYmplY3RBc3NpZ25Ob25lbnRyeSgpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgdmFsdWVzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gdmFsdWVzWzBdO1xuICAgIH0gZWxzZSBpZiAodmFsdWVzLmxlbmd0aCA+IDIpIHtcbiAgICAgIHZhciBfY29udGV4dDI7XG5cbiAgICAgIHJldHVybiBkZWVwT2JqZWN0QXNzaWduTm9uZW50cnkuYXBwbHkodm9pZCAwLCBjb25jYXQkMShfY29udGV4dDIgPSBbZGVlcE9iamVjdEFzc2lnbih2YWx1ZXNbMF0sIHZhbHVlc1sxXSldKS5jYWxsKF9jb250ZXh0MiwgX3RvQ29uc3VtYWJsZUFycmF5KHNsaWNlKHZhbHVlcykuY2FsbCh2YWx1ZXMsIDIpKSkpO1xuICAgIH1cblxuICAgIHZhciBhID0gdmFsdWVzWzBdO1xuICAgIHZhciBiID0gdmFsdWVzWzFdO1xuXG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMob3duS2V5cyQxKGIpKSxcbiAgICAgICAgX3N0ZXA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHByb3AgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoYiwgcHJvcCkpIDtlbHNlIGlmIChiW3Byb3BdID09PSBERUxFVEUpIHtcbiAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgfSBlbHNlIGlmIChhW3Byb3BdICE9PSBudWxsICYmIGJbcHJvcF0gIT09IG51bGwgJiYgX3R5cGVvZihhW3Byb3BdKSA9PT0gXCJvYmplY3RcIiAmJiBfdHlwZW9mKGJbcHJvcF0pID09PSBcIm9iamVjdFwiICYmICFpc0FycmF5JDEoYVtwcm9wXSkgJiYgIWlzQXJyYXkkMShiW3Byb3BdKSkge1xuICAgICAgICAgIGFbcHJvcF0gPSBkZWVwT2JqZWN0QXNzaWduTm9uZW50cnkoYVtwcm9wXSwgYltwcm9wXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYVtwcm9wXSA9IGNsb25lKGJbcHJvcF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9XG4gIC8qKlxyXG4gICAqIERlZXAgY2xvbmUgZ2l2ZW4gb2JqZWN0IG9yIGFycmF5LiBJbiBjYXNlIG9mIHByaW1pdGl2ZSBzaW1wbHkgcmV0dXJuLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGEgLSBBbnl0aGluZy5cclxuICAgKiBAcmV0dXJucyBEZWVwIGNsb25lZCBvYmplY3QvYXJyYXkgb3IgdW5jaGFuZ2VkIGEuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBjbG9uZShhKSB7XG4gICAgaWYgKGlzQXJyYXkkMShhKSkge1xuICAgICAgcmV0dXJuIG1hcCQzKGEpLmNhbGwoYSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjbG9uZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKF90eXBlb2YoYSkgPT09IFwib2JqZWN0XCIgJiYgYSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGRlZXBPYmplY3RBc3NpZ25Ob25lbnRyeSh7fSwgYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBTdHJpcCBERUxFVEUgZnJvbSBnaXZlbiBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYSAtIE9iamVjdCB3aGljaCBtYXkgY29udGFpbiBERUxFVEUgYnV0IHdvbid0IGFmdGVyIHRoaXMgaXMgZXhlY3V0ZWQuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBzdHJpcERlbGV0ZShhKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGtleXMgPSBrZXlzJDQoYSk7IF9pIDwgX09iamVjdCRrZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHByb3AgPSBfT2JqZWN0JGtleXNbX2ldO1xuXG4gICAgICBpZiAoYVtwcm9wXSA9PT0gREVMRVRFKSB7XG4gICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGFbcHJvcF0pID09PSBcIm9iamVjdFwiICYmIGFbcHJvcF0gIT09IG51bGwpIHtcbiAgICAgICAgc3RyaXBEZWxldGUoYVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXR1cCBhIG1vY2sgaGFtbWVyLmpzIG9iamVjdCwgZm9yIHVuaXQgdGVzdGluZy5cbiAgICpcbiAgICogSW5zcGlyYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS91YmVyL2RlY2suZ2wvcHVsbC82NThcbiAgICpcbiAgICogQHJldHVybnMge3tvbjogbm9vcCwgb2ZmOiBub29wLCBkZXN0cm95OiBub29wLCBlbWl0OiBub29wLCBnZXQ6IGdldH19XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaGFtbWVyTW9jaygpIHtcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICBvbjogbm9vcCxcbiAgICAgIG9mZjogbm9vcCxcbiAgICAgIGRlc3Ryb3k6IG5vb3AsXG4gICAgICBlbWl0OiBub29wLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2V0OiBub29wXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBIYW1tZXIkMSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuSGFtbWVyIHx8IFJlYWxIYW1tZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaGFtbWVyLmpzIGlzIG9ubHkgYXZhaWxhYmxlIGluIGEgYnJvd3Nlciwgbm90IGluIG5vZGUuanMuIFJlcGxhY2luZyBpdCB3aXRoIGEgbW9jayBvYmplY3QuXG4gICAgcmV0dXJuIGhhbW1lck1vY2soKTtcbiAgfTtcbiAgLyoqXG4gICAqIFR1cm4gYW4gZWxlbWVudCBpbnRvIGFuIGNsaWNrVG9Vc2UgZWxlbWVudC5cbiAgICogV2hlbiBub3QgYWN0aXZlLCB0aGUgZWxlbWVudCBoYXMgYSB0cmFuc3BhcmVudCBvdmVybGF5LiBXaGVuIHRoZSBvdmVybGF5IGlzXG4gICAqIGNsaWNrZWQsIHRoZSBtb2RlIGlzIGNoYW5nZWQgdG8gYWN0aXZlLlxuICAgKiBXaGVuIGFjdGl2ZSwgdGhlIGVsZW1lbnQgaXMgZGlzcGxheWVkIHdpdGggYSBibHVlIGJvcmRlciBhcm91bmQgaXQsIGFuZFxuICAgKiB0aGUgaW50ZXJhY3RpdmUgY29udGVudHMgb2YgdGhlIGVsZW1lbnQgY2FuIGJlIHVzZWQuIFdoZW4gY2xpY2tlZCBvdXRzaWRlXG4gICAqIHRoZSBlbGVtZW50LCB0aGUgZWxlbWVudHMgbW9kZSBpcyBjaGFuZ2VkIHRvIGluYWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lclxuICAgKiBAY2xhc3MgQWN0aXZhdG9yXG4gICAqL1xuXG4gIGZ1bmN0aW9uIEFjdGl2YXRvciQxKGNvbnRhaW5lcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIF9jb250ZXh0MztcblxuICAgIHRoaXMuX2NsZWFudXBRdWV1ZSA9IFtdO1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5fZG9tID0ge1xuICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICBvdmVybGF5OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgfTtcblxuICAgIHRoaXMuX2RvbS5vdmVybGF5LmNsYXNzTGlzdC5hZGQoXCJ2aXMtb3ZlcmxheVwiKTtcblxuICAgIHRoaXMuX2RvbS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZG9tLm92ZXJsYXkpO1xuXG4gICAgdGhpcy5fY2xlYW51cFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX2RvbS5vdmVybGF5LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoX3RoaXMuX2RvbS5vdmVybGF5KTtcbiAgICB9KTtcblxuICAgIHZhciBoYW1tZXIgPSBIYW1tZXIkMSh0aGlzLl9kb20ub3ZlcmxheSk7XG4gICAgaGFtbWVyLm9uKFwidGFwXCIsIGJpbmQkNihfY29udGV4dDMgPSB0aGlzLl9vblRhcE92ZXJsYXkpLmNhbGwoX2NvbnRleHQzLCB0aGlzKSk7XG5cbiAgICB0aGlzLl9jbGVhbnVwUXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBoYW1tZXIuZGVzdHJveSgpOyAvLyBGSVhNRTogY2xlYW5pbmcgdXAgaGFtbWVyIGluc3RhbmNlcyBkb2Vzbid0IHdvcmsgKFRpbWVsaW5lIG5vdCByZW1vdmVkXG4gICAgICAvLyBmcm9tIG1lbW9yeSlcbiAgICB9KTsgLy8gYmxvY2sgYWxsIHRvdWNoIGV2ZW50cyAoZXhjZXB0IHRhcClcblxuXG4gICAgdmFyIGV2ZW50cyA9IFtcInRhcFwiLCBcImRvdWJsZXRhcFwiLCBcInByZXNzXCIsIFwicGluY2hcIiwgXCJwYW5cIiwgXCJwYW5zdGFydFwiLCBcInBhbm1vdmVcIiwgXCJwYW5lbmRcIl07XG5cbiAgICBmb3JFYWNoJDEoZXZlbnRzKS5jYWxsKGV2ZW50cywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBoYW1tZXIub24oZXZlbnQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0pO1xuICAgIH0pOyAvLyBhdHRhY2ggYSBjbGljayBldmVudCB0byB0aGUgd2luZG93LCBpbiBvcmRlciB0byBkZWFjdGl2YXRlIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSB0aGUgdGltZWxpbmVcblxuXG4gICAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIHRoaXMuX29uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFfaGFzUGFyZW50KGV2ZW50LnRhcmdldCwgY29udGFpbmVyKSkge1xuICAgICAgICAgIF90aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fb25DbGljayk7XG5cbiAgICAgIHRoaXMuX2NsZWFudXBRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX3RoaXMuX29uQ2xpY2spO1xuICAgICAgfSk7XG4gICAgfSAvLyBwcmVwYXJlIGVzY2FwZSBrZXkgbGlzdGVuZXIgZm9yIGRlYWN0aXZhdGluZyB3aGVuIGFjdGl2ZVxuXG5cbiAgICB0aGlzLl9lc2NMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKFwia2V5XCIgaW4gZXZlbnQgPyBldmVudC5rZXkgPT09IFwiRXNjYXBlXCIgOiBldmVudC5rZXlDb2RlID09PSAyN1xuICAgICAgLyogdGhlIGtleUNvZGUgaXMgZm9yIElFMTEgKi9cbiAgICAgICkge1xuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSAvLyB0dXJuIGludG8gYW4gZXZlbnQgZW1pdHRlclxuXG5cbiAgRW1pdHRlcihBY3RpdmF0b3IkMS5wcm90b3R5cGUpOyAvLyBUaGUgY3VycmVudGx5IGFjdGl2ZSBhY3RpdmF0b3JcblxuICBBY3RpdmF0b3IkMS5jdXJyZW50ID0gbnVsbDtcbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIGFjdGl2YXRvci4gQ2xlYW5zIHVwIGFsbCBjcmVhdGVkIERPTSBhbmQgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG4gIEFjdGl2YXRvciQxLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfY29udGV4dDQsIF9jb250ZXh0NTtcblxuICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuXG4gICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKHJldmVyc2UoX2NvbnRleHQ0ID0gc3BsaWNlKF9jb250ZXh0NSA9IHRoaXMuX2NsZWFudXBRdWV1ZSkuY2FsbChfY29udGV4dDUsIDApKS5jYWxsKF9jb250ZXh0NCkpLFxuICAgICAgICBfc3RlcDI7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEFjdGl2YXRlIHRoZSBlbGVtZW50XG4gICAqIE92ZXJsYXkgaXMgaGlkZGVuLCBlbGVtZW50IGlzIGRlY29yYXRlZCB3aXRoIGEgYmx1ZSBzaGFkb3cgYm9yZGVyXG4gICAqL1xuXG5cbiAgQWN0aXZhdG9yJDEucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHdlIGFsbG93IG9ubHkgb25lIGFjdGl2ZSBhY3RpdmF0b3IgYXQgYSB0aW1lXG4gICAgaWYgKEFjdGl2YXRvciQxLmN1cnJlbnQpIHtcbiAgICAgIEFjdGl2YXRvciQxLmN1cnJlbnQuZGVhY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIEFjdGl2YXRvciQxLmN1cnJlbnQgPSB0aGlzO1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9kb20ub3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgICB0aGlzLl9kb20uY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ2aXMtYWN0aXZlXCIpO1xuXG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICAgIHRoaXMuZW1pdChcImFjdGl2YXRlXCIpOyAvLyB1Z2x5IGhhY2s6IGJpbmQgRVNDIGFmdGVyIGVtaXR0aW5nIHRoZSBldmVudHMsIGFzIHRoZSBOZXR3b3JrIHJlYmluZHMgYWxsXG4gICAgLy8ga2V5Ym9hcmQgZXZlbnRzIG9uIGEgJ2NoYW5nZScgZXZlbnRcblxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fZXNjTGlzdGVuZXIpO1xuICB9O1xuICAvKipcbiAgICogRGVhY3RpdmF0ZSB0aGUgZWxlbWVudFxuICAgKiBPdmVybGF5IGlzIGRpc3BsYXllZCBvbiB0b3Agb2YgdGhlIGVsZW1lbnRcbiAgICovXG5cblxuICBBY3RpdmF0b3IkMS5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuX2RvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cbiAgICB0aGlzLl9kb20uY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJ2aXMtYWN0aXZlXCIpO1xuXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9lc2NMaXN0ZW5lcik7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICAgIHRoaXMuZW1pdChcImRlYWN0aXZhdGVcIik7XG4gIH07XG4gIC8qKlxuICAgKiBIYW5kbGUgYSB0YXAgZXZlbnQ6IGFjdGl2YXRlIHRoZSBjb250YWluZXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQWN0aXZhdG9yJDEucHJvdG90eXBlLl9vblRhcE92ZXJsYXkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBhY3RpdmF0ZSB0aGUgY29udGFpbmVyXG4gICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgIGV2ZW50LnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9O1xuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyB0aGUgcmVxdWVzdGVkIHBhcmVudCBlbGVtZW50IHNvbWV3aGVyZSBpblxuICAgKiBpdHMgY2hhaW4gb2YgcGFyZW50IG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gdGhlIHBhcmVudCBpcyBmb3VuZCBzb21ld2hlcmUgaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICBjaGFpbiBvZiBwYXJlbnQgbm9kZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gX2hhc1BhcmVudChlbGVtZW50LCBwYXJlbnQpIHtcbiAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnQgPT09IHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gdXRpbGl0eSBmdW5jdGlvbnNcblxuICB2YXIgZ2xvYmFsJDQgPSBnbG9iYWwkTTtcbiAgdmFyIGlzQ29uc3RydWN0b3IgPSBpc0NvbnN0cnVjdG9yJDQ7XG4gIHZhciB0cnlUb1N0cmluZyQxID0gdHJ5VG9TdHJpbmckNDtcbiAgdmFyIFR5cGVFcnJvciQzID0gZ2xvYmFsJDQuVHlwZUVycm9yOyAvLyBgQXNzZXJ0OiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSBpcyB0cnVlYFxuXG4gIHZhciBhQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgIGlmIChpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICAgIHRocm93IFR5cGVFcnJvciQzKHRyeVRvU3RyaW5nJDEoYXJndW1lbnQpICsgJyBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuICB9O1xuXG4gIHZhciAkJDUgPSBfZXhwb3J0O1xuICB2YXIgZ2V0QnVpbHRJbiQxID0gZ2V0QnVpbHRJbiQ5O1xuICB2YXIgYXBwbHkgPSBmdW5jdGlvbkFwcGx5O1xuICB2YXIgYmluZCQyID0gZnVuY3Rpb25CaW5kO1xuICB2YXIgYUNvbnN0cnVjdG9yID0gYUNvbnN0cnVjdG9yJDE7XG4gIHZhciBhbk9iamVjdCQxID0gYW5PYmplY3QkYjtcbiAgdmFyIGlzT2JqZWN0JDMgPSBpc09iamVjdCRmO1xuICB2YXIgY3JlYXRlJDQgPSBvYmplY3RDcmVhdGU7XG4gIHZhciBmYWlscyQ1ID0gZmFpbHMkcjtcbiAgdmFyIG5hdGl2ZUNvbnN0cnVjdCA9IGdldEJ1aWx0SW4kMSgnUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbiAgdmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBwdXNoJDEgPSBbXS5wdXNoOyAvLyBgUmVmbGVjdC5jb25zdHJ1Y3RgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZmxlY3QuY29uc3RydWN0XG4gIC8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuICAvLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG5cbiAgdmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMkNShmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRigpIHtcbiAgICAgIC8qIGVtcHR5ICovXG4gICAgfVxuXG4gICAgcmV0dXJuICEobmF0aXZlQ29uc3RydWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qIGVtcHR5ICovXG4gICAgfSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG4gIH0pO1xuICB2YXIgQVJHU19CVUcgPSAhZmFpbHMkNShmdW5jdGlvbiAoKSB7XG4gICAgbmF0aXZlQ29uc3RydWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qIGVtcHR5ICovXG4gICAgfSk7XG4gIH0pO1xuICB2YXIgRk9SQ0VEJDEgPSBORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRztcbiAgJCQ1KHtcbiAgICB0YXJnZXQ6ICdSZWZsZWN0JyxcbiAgICBzdGF0OiB0cnVlLFxuICAgIGZvcmNlZDogRk9SQ0VEJDEsXG4gICAgc2hhbTogRk9SQ0VEJDFcbiAgfSwge1xuICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJnc1xuICAgIC8qICwgbmV3VGFyZ2V0ICovXG4gICAgKSB7XG4gICAgICBhQ29uc3RydWN0b3IoVGFyZ2V0KTtcbiAgICAgIGFuT2JqZWN0JDEoYXJncyk7XG4gICAgICB2YXIgbmV3VGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBUYXJnZXQgOiBhQ29uc3RydWN0b3IoYXJndW1lbnRzWzJdKTtcbiAgICAgIGlmIChBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpIHJldHVybiBuYXRpdmVDb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuXG4gICAgICBpZiAoVGFyZ2V0ID09IG5ld1RhcmdldCkge1xuICAgICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoKTtcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICB9IC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG5cblxuICAgICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAgIGFwcGx5KHB1c2gkMSwgJGFyZ3MsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gbmV3IChhcHBseShiaW5kJDIsIFRhcmdldCwgJGFyZ3MpKSgpO1xuICAgICAgfSAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcblxuXG4gICAgICB2YXIgcHJvdG8gPSBuZXdUYXJnZXQucHJvdG90eXBlO1xuICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlJDQoaXNPYmplY3QkMyhwcm90bykgPyBwcm90byA6IE9iamVjdFByb3RvdHlwZSk7XG4gICAgICB2YXIgcmVzdWx0ID0gYXBwbHkoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgICByZXR1cm4gaXNPYmplY3QkMyhyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcGF0aCQzID0gcGF0aCRxO1xuICB2YXIgY29uc3RydWN0JDIgPSBwYXRoJDMuUmVmbGVjdC5jb25zdHJ1Y3Q7XG5cbiAgdmFyIHBhcmVudCRoID0gY29uc3RydWN0JDI7XG4gIHZhciBjb25zdHJ1Y3QkMSA9IHBhcmVudCRoO1xuXG4gIHZhciBjb25zdHJ1Y3QgPSBjb25zdHJ1Y3QkMTtcblxuICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICB2YXIgcGFyZW50JGcgPSBjcmVhdGUkNjtcbiAgdmFyIGNyZWF0ZSQzID0gcGFyZW50JGc7XG5cbiAgdmFyIHBhcmVudCRmID0gY3JlYXRlJDM7XG4gIHZhciBjcmVhdGUkMiA9IHBhcmVudCRmO1xuXG4gIHZhciBjcmVhdGUkMSA9IGNyZWF0ZSQyO1xuXG4gIHZhciAkJDQgPSBfZXhwb3J0O1xuICB2YXIgc2V0UHJvdG90eXBlT2YkNSA9IG9iamVjdFNldFByb3RvdHlwZU9mOyAvLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2ZcblxuICAkJDQoe1xuICAgIHRhcmdldDogJ09iamVjdCcsXG4gICAgc3RhdDogdHJ1ZVxuICB9LCB7XG4gICAgc2V0UHJvdG90eXBlT2Y6IHNldFByb3RvdHlwZU9mJDVcbiAgfSk7XG5cbiAgdmFyIHBhdGgkMiA9IHBhdGgkcTtcbiAgdmFyIHNldFByb3RvdHlwZU9mJDQgPSBwYXRoJDIuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuXG4gIHZhciBwYXJlbnQkZSA9IHNldFByb3RvdHlwZU9mJDQ7XG4gIHZhciBzZXRQcm90b3R5cGVPZiQzID0gcGFyZW50JGU7XG5cbiAgdmFyIHBhcmVudCRkID0gc2V0UHJvdG90eXBlT2YkMztcbiAgdmFyIHNldFByb3RvdHlwZU9mJDIgPSBwYXJlbnQkZDtcblxuICB2YXIgcGFyZW50JGMgPSBzZXRQcm90b3R5cGVPZiQyO1xuICB2YXIgc2V0UHJvdG90eXBlT2YkMSA9IHBhcmVudCRjO1xuXG4gIHZhciBzZXRQcm90b3R5cGVPZiA9IHNldFByb3RvdHlwZU9mJDE7XG5cbiAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBzZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgcmV0dXJuIG87XG4gICAgfTtcblxuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gY3JlYXRlJDEoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkZWZpbmVQcm9wZXJ0eSQ3KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7XG4gICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9KTtcblxuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICByZXR1cm4gY2FsbDtcbiAgICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xuICB9XG5cbiAgdmFyIHBhcmVudCRiID0gZ2V0UHJvdG90eXBlT2YkMztcbiAgdmFyIGdldFByb3RvdHlwZU9mJDIgPSBwYXJlbnQkYjtcblxuICB2YXIgcGFyZW50JGEgPSBnZXRQcm90b3R5cGVPZiQyO1xuICB2YXIgZ2V0UHJvdG90eXBlT2YkMSA9IHBhcmVudCRhO1xuXG4gIHZhciBnZXRQcm90b3R5cGVPZiA9IGdldFByb3RvdHlwZU9mJDE7XG5cbiAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBzZXRQcm90b3R5cGVPZiA/IGdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBnZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH1cblxuICB2YXIgcnVudGltZSA9IHtleHBvcnRzOiB7fX07XG5cbiAgLyoqXG4gICAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKi9cblxuICAoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgIHZhciBydW50aW1lID0gZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICAgICAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgICAgIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgIHZhciB1bmRlZmluZWQkMTsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG5cbiAgICAgIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gICAgICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICAgICAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgICAgIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgICAgIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgICAgIGRlZmluZSh7fSwgXCJcIik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZGVmaW5lID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgICAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7IC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAgICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuXG4gICAgICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgICAgIH1cblxuICAgICAgZXhwb3J0cy53cmFwID0gd3JhcDsgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gICAgICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgICAgIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAgICAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAgICAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAgICAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAgICAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgICAgIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAgICAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAgICAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuXG4gICAgICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgIGFyZzogZm4uY2FsbChvYmosIGFyZylcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJ0aHJvd1wiLFxuICAgICAgICAgICAgYXJnOiBlcnJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICAgICAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gICAgICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICAgICAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjsgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAgICAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuXG4gICAgICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9OyAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgICAgIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAgICAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgICAgIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG5cbiAgICAgIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG5cbiAgICAgIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cblxuICAgICAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gICAgICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuXG5cbiAgICAgIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICAgICAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pO1xuICAgICAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICAgICAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuXG4gICAgICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAgICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAgICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgICAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICAgICAgfVxuXG4gICAgICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGRlZmluZShHcCwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgICBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pO1xuICAgICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpOyAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAgICAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cblxuICAgICAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgICAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICAgICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gY3RvciA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgOiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgICAgIHJldHVybiBnZW5GdW47XG4gICAgICB9OyAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgICAgIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gICAgICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gICAgICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuXG5cbiAgICAgIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgX19hd2FpdDogYXJnXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICAgICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgICAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICAgICAgfSAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgICAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cblxuXG4gICAgICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gICAgICB9XG5cbiAgICAgIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KTtcbiAgICAgIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7IC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgICAgIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAgICAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG5cbiAgICAgIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG4gICAgICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgICAgfSAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuXG5cbiAgICAgICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcblxuICAgICAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcbiAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IEdlblN0YXRlQ29tcGxldGVkIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkOyAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG5cbiAgICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAgICAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAgICAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gICAgICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cblxuXG4gICAgICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkJDEpIHtcbiAgICAgICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlOyAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG5cbiAgICAgICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jOyAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgfSAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgICAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuXG5cbiAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfSAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAgICAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuXG5cbiAgICAgIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG4gICAgICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTsgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgICAgIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gICAgICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAgICAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgICAgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pO1xuICAgICAgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICAgIHRyeUxvYzogbG9jc1swXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgICAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgICAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgICAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICAgICAgdGhpcy50cnlFbnRyaWVzID0gW3tcbiAgICAgICAgICB0cnlMb2M6IFwicm9vdFwiXG4gICAgICAgIH1dO1xuICAgICAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzLnJldmVyc2UoKTsgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAgICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuXG5cbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcblxuICAgICAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cblxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmV4dDogZG9uZVJlc3VsdFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICAgICAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkJDEsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IENvbnRleHQsXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoc2tpcFRlbXBSZXNldCkge1xuICAgICAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICAgICAgdGhpcy5uZXh0ID0gMDsgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuXG4gICAgICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgICAgICB9LFxuICAgICAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWJydXB0OiBmdW5jdGlvbiAodHlwZSwgYXJnKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmluYWxseUVudHJ5ICYmICh0eXBlID09PSBcImJyZWFrXCIgfHwgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fCByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmlzaDogZnVuY3Rpb24gKGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImNhdGNoXCI6IGZ1bmN0aW9uICh0cnlMb2MpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cblxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgICAgICB9LFxuICAgICAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiAoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfTsgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAgICAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gICAgICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgICAgIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG5cbiAgICAgIHJldHVybiBleHBvcnRzO1xuICAgIH0oIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gICAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gICAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgICBtb2R1bGUuZXhwb3J0cyApO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gICAgfSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgICAgIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gICAgICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgICAgIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgICAgIC8vIHdlIGNhbiBleHBsaWNpdGx5IGFjY2VzcyBnbG9iYWxUaGlzLiBJbiBvbGRlciBlbmdpbmVzIHdlIGNhbiBlc2NhcGVcbiAgICAgIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAgICAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gICAgICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAgICAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgICAgIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAgICAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKHJ1bnRpbWUpO1xuXG4gIHZhciByZWdlbmVyYXRvciA9IHJ1bnRpbWUuZXhwb3J0cztcblxuICB2YXIgaW50ZXJuYWxNZXRhZGF0YSA9IHtleHBvcnRzOiB7fX07XG5cbiAgdmFyIGZhaWxzJDQgPSBmYWlscyRyO1xuICB2YXIgYXJyYXlCdWZmZXJOb25FeHRlbnNpYmxlID0gZmFpbHMkNChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSwgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcblxuICAgICAgaWYgKE9iamVjdC5pc0V4dGVuc2libGUoYnVmZmVyKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJ1ZmZlciwgJ2EnLCB7XG4gICAgICAgIHZhbHVlOiA4XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBmYWlscyQzID0gZmFpbHMkcjtcbiAgdmFyIGlzT2JqZWN0JDIgPSBpc09iamVjdCRmO1xuICB2YXIgY2xhc3NvZiQzID0gY2xhc3NvZlJhdyQxO1xuICB2YXIgQVJSQVlfQlVGRkVSX05PTl9FWFRFTlNJQkxFID0gYXJyYXlCdWZmZXJOb25FeHRlbnNpYmxlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSAtLSBzYWZlXG5cbiAgdmFyICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuICB2YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzJDMoZnVuY3Rpb24gKCkge1xuICAgICRpc0V4dGVuc2libGUoMSk7XG4gIH0pOyAvLyBgT2JqZWN0LmlzRXh0ZW5zaWJsZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmlzZXh0ZW5zaWJsZVxuXG4gIHZhciBvYmplY3RJc0V4dGVuc2libGUgPSBGQUlMU19PTl9QUklNSVRJVkVTIHx8IEFSUkFZX0JVRkZFUl9OT05fRVhURU5TSUJMRSA/IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCkge1xuICAgIGlmICghaXNPYmplY3QkMihpdCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoQVJSQVlfQlVGRkVSX05PTl9FWFRFTlNJQkxFICYmIGNsYXNzb2YkMyhpdCkgPT0gJ0FycmF5QnVmZmVyJykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZShpdCkgOiB0cnVlO1xuICB9IDogJGlzRXh0ZW5zaWJsZTtcblxuICB2YXIgZmFpbHMkMiA9IGZhaWxzJHI7XG4gIHZhciBmcmVlemluZyA9ICFmYWlscyQyKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSwgZXMvbm8tb2JqZWN0LXByZXZlbnRleHRlbnNpb25zIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgcmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG4gIH0pO1xuXG4gIHZhciAkJDMgPSBfZXhwb3J0O1xuICB2YXIgdW5jdXJyeVRoaXMkMSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBoaWRkZW5LZXlzID0gaGlkZGVuS2V5cyQ2O1xuICB2YXIgaXNPYmplY3QkMSA9IGlzT2JqZWN0JGY7XG4gIHZhciBoYXNPd24kMyA9IGhhc093blByb3BlcnR5XzE7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSQyID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbiAgdmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICB2YXIgZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsO1xuICB2YXIgaXNFeHRlbnNpYmxlID0gb2JqZWN0SXNFeHRlbnNpYmxlO1xuICB2YXIgdWlkID0gdWlkJDQ7XG4gIHZhciBGUkVFWklORyA9IGZyZWV6aW5nO1xuICB2YXIgUkVRVUlSRUQgPSBmYWxzZTtcbiAgdmFyIE1FVEFEQVRBID0gdWlkKCdtZXRhJyk7XG4gIHZhciBpZCA9IDA7XG5cbiAgdmFyIHNldE1ldGFkYXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgZGVmaW5lUHJvcGVydHkkMihpdCwgTUVUQURBVEEsIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIG9iamVjdElEOiAnTycgKyBpZCsrLFxuICAgICAgICAvLyBvYmplY3QgSURcbiAgICAgICAgd2Vha0RhdGE6IHt9IC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG5cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZmFzdEtleSQxID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgICAvLyByZXR1cm4gYSBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgICBpZiAoIWlzT2JqZWN0JDEoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuXG4gICAgaWYgKCFoYXNPd24kMyhpdCwgTUVUQURBVEEpKSB7XG4gICAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnOyAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuXG4gICAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJzsgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcblxuICAgICAgc2V0TWV0YWRhdGEoaXQpOyAvLyByZXR1cm4gb2JqZWN0IElEXG4gICAgfVxuXG4gICAgcmV0dXJuIGl0W01FVEFEQVRBXS5vYmplY3RJRDtcbiAgfTtcblxuICB2YXIgZ2V0V2Vha0RhdGEgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAgIGlmICghaGFzT3duJDMoaXQsIE1FVEFEQVRBKSkge1xuICAgICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7IC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG5cbiAgICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7IC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG5cbiAgICAgIHNldE1ldGFkYXRhKGl0KTsgLy8gcmV0dXJuIHRoZSBzdG9yZSBvZiB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICAgIH1cblxuICAgIHJldHVybiBpdFtNRVRBREFUQV0ud2Vha0RhdGE7XG4gIH07IC8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xuXG5cbiAgdmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgaWYgKEZSRUVaSU5HICYmIFJFUVVJUkVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhc093biQzKGl0LCBNRVRBREFUQSkpIHNldE1ldGFkYXRhKGl0KTtcbiAgICByZXR1cm4gaXQ7XG4gIH07XG5cbiAgdmFyIGVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBtZXRhLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qIGVtcHR5ICovXG4gICAgfTtcblxuICAgIFJFUVVJUkVEID0gdHJ1ZTtcbiAgICB2YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZjtcbiAgICB2YXIgc3BsaWNlID0gdW5jdXJyeVRoaXMkMShbXS5zcGxpY2UpO1xuICAgIHZhciB0ZXN0ID0ge307XG4gICAgdGVzdFtNRVRBREFUQV0gPSAxOyAvLyBwcmV2ZW50IGV4cG9zaW5nIG9mIG1ldGFkYXRhIGtleVxuXG4gICAgaWYgKGdldE93blByb3BlcnR5TmFtZXModGVzdCkubGVuZ3RoKSB7XG4gICAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGdldE93blByb3BlcnR5TmFtZXMoaXQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSByZXN1bHQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocmVzdWx0W2ldID09PSBNRVRBREFUQSkge1xuICAgICAgICAgICAgc3BsaWNlKHJlc3VsdCwgaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgJCQzKHtcbiAgICAgICAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgICAgICAgc3RhdDogdHJ1ZSxcbiAgICAgICAgZm9yY2VkOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIGdldE93blByb3BlcnR5TmFtZXM6IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbE1vZHVsZS5mXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG1ldGEgPSBpbnRlcm5hbE1ldGFkYXRhLmV4cG9ydHMgPSB7XG4gICAgZW5hYmxlOiBlbmFibGUsXG4gICAgZmFzdEtleTogZmFzdEtleSQxLFxuICAgIGdldFdlYWtEYXRhOiBnZXRXZWFrRGF0YSxcbiAgICBvbkZyZWV6ZTogb25GcmVlemVcbiAgfTtcbiAgaGlkZGVuS2V5c1tNRVRBREFUQV0gPSB0cnVlO1xuXG4gIHZhciBnbG9iYWwkMyA9IGdsb2JhbCRNO1xuICB2YXIgYmluZCQxID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbiAgdmFyIGNhbGwgPSBmdW5jdGlvbkNhbGw7XG4gIHZhciBhbk9iamVjdCA9IGFuT2JqZWN0JGI7XG4gIHZhciB0cnlUb1N0cmluZyA9IHRyeVRvU3RyaW5nJDQ7XG4gIHZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSBpc0FycmF5SXRlcmF0b3JNZXRob2QkMjtcbiAgdmFyIGxlbmd0aE9mQXJyYXlMaWtlJDEgPSBsZW5ndGhPZkFycmF5TGlrZSRkO1xuICB2YXIgaXNQcm90b3R5cGVPZiQ2ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbiAgdmFyIGdldEl0ZXJhdG9yJDUgPSBnZXRJdGVyYXRvciQ3O1xuICB2YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZCQ4O1xuICB2YXIgaXRlcmF0b3JDbG9zZSA9IGl0ZXJhdG9yQ2xvc2UkMjtcbiAgdmFyIFR5cGVFcnJvciQyID0gZ2xvYmFsJDMuVHlwZUVycm9yO1xuXG4gIHZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG4gICAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgfTtcblxuICB2YXIgUmVzdWx0UHJvdG90eXBlID0gUmVzdWx0LnByb3RvdHlwZTtcblxuICB2YXIgaXRlcmF0ZSQyID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCB1bmJvdW5kRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgdGhhdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aGF0O1xuICAgIHZhciBBU19FTlRSSUVTID0gISEob3B0aW9ucyAmJiBvcHRpb25zLkFTX0VOVFJJRVMpO1xuICAgIHZhciBJU19JVEVSQVRPUiA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JU19JVEVSQVRPUik7XG4gICAgdmFyIElOVEVSUlVQVEVEID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklOVEVSUlVQVEVEKTtcbiAgICB2YXIgZm4gPSBiaW5kJDEodW5ib3VuZEZ1bmN0aW9uLCB0aGF0KTtcbiAgICB2YXIgaXRlcmF0b3IsIGl0ZXJGbiwgaW5kZXgsIGxlbmd0aCwgcmVzdWx0LCBuZXh0LCBzdGVwO1xuXG4gICAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICBpZiAoaXRlcmF0b3IpIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICdub3JtYWwnLCBjb25kaXRpb24pO1xuICAgICAgcmV0dXJuIG5ldyBSZXN1bHQodHJ1ZSwgY29uZGl0aW9uKTtcbiAgICB9O1xuXG4gICAgdmFyIGNhbGxGbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKEFTX0VOVFJJRVMpIHtcbiAgICAgICAgYW5PYmplY3QodmFsdWUpO1xuICAgICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZVswXSwgdmFsdWVbMV0sIHN0b3ApIDogZm4odmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWUsIHN0b3ApIDogZm4odmFsdWUpO1xuICAgIH07XG5cbiAgICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICAgIGl0ZXJhdG9yID0gaXRlcmFibGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgICAgIGlmICghaXRlckZuKSB0aHJvdyBUeXBlRXJyb3IkMih0cnlUb1N0cmluZyhpdGVyYWJsZSkgKyAnIGlzIG5vdCBpdGVyYWJsZScpOyAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuXG4gICAgICBpZiAoaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJGbikpIHtcbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDEoaXRlcmFibGUpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICAgIHJlc3VsdCA9IGNhbGxGbihpdGVyYWJsZVtpbmRleF0pO1xuICAgICAgICAgIGlmIChyZXN1bHQgJiYgaXNQcm90b3R5cGVPZiQ2KFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0b3IgPSBnZXRJdGVyYXRvciQ1KGl0ZXJhYmxlLCBpdGVyRm4pO1xuICAgIH1cblxuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuXG4gICAgd2hpbGUgKCEoc3RlcCA9IGNhbGwobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBjYWxsRm4oc3RlcC52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdvYmplY3QnICYmIHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mJDYoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbiAgfTtcblxuICB2YXIgZ2xvYmFsJDIgPSBnbG9iYWwkTTtcbiAgdmFyIGlzUHJvdG90eXBlT2YkNSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG4gIHZhciBUeXBlRXJyb3IkMSA9IGdsb2JhbCQyLlR5cGVFcnJvcjtcblxuICB2YXIgYW5JbnN0YW5jZSQyID0gZnVuY3Rpb24gKGl0LCBQcm90b3R5cGUpIHtcbiAgICBpZiAoaXNQcm90b3R5cGVPZiQ1KFByb3RvdHlwZSwgaXQpKSByZXR1cm4gaXQ7XG4gICAgdGhyb3cgVHlwZUVycm9yJDEoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG4gIH07XG5cbiAgdmFyICQkMiA9IF9leHBvcnQ7XG4gIHZhciBnbG9iYWwkMSA9IGdsb2JhbCRNO1xuICB2YXIgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZSA9IGludGVybmFsTWV0YWRhdGEuZXhwb3J0cztcbiAgdmFyIGZhaWxzJDEgPSBmYWlscyRyO1xuICB2YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDY7XG4gIHZhciBpdGVyYXRlJDEgPSBpdGVyYXRlJDI7XG4gIHZhciBhbkluc3RhbmNlJDEgPSBhbkluc3RhbmNlJDI7XG4gIHZhciBpc0NhbGxhYmxlID0gaXNDYWxsYWJsZSRoO1xuICB2YXIgaXNPYmplY3QgPSBpc09iamVjdCRmO1xuICB2YXIgc2V0VG9TdHJpbmdUYWcgPSBzZXRUb1N0cmluZ1RhZyQ1O1xuICB2YXIgZGVmaW5lUHJvcGVydHkkMSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG4gIHZhciBmb3JFYWNoID0gYXJyYXlJdGVyYXRpb24uZm9yRWFjaDtcbiAgdmFyIERFU0NSSVBUT1JTJDIgPSBkZXNjcmlwdG9ycztcbiAgdmFyIEludGVybmFsU3RhdGVNb2R1bGUkMSA9IGludGVybmFsU3RhdGU7XG4gIHZhciBzZXRJbnRlcm5hbFN0YXRlJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDEuc2V0O1xuICB2YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLmdldHRlckZvcjtcblxuICB2YXIgY29sbGVjdGlvbiQyID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUsIHdyYXBwZXIsIGNvbW1vbikge1xuICAgIHZhciBJU19NQVAgPSBDT05TVFJVQ1RPUl9OQU1FLmluZGV4T2YoJ01hcCcpICE9PSAtMTtcbiAgICB2YXIgSVNfV0VBSyA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignV2VhaycpICE9PSAtMTtcbiAgICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICAgIHZhciBOYXRpdmVDb25zdHJ1Y3RvciA9IGdsb2JhbCQxW0NPTlNUUlVDVE9SX05BTUVdO1xuICAgIHZhciBOYXRpdmVQcm90b3R5cGUgPSBOYXRpdmVDb25zdHJ1Y3RvciAmJiBOYXRpdmVDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgdmFyIGV4cG9ydGVkID0ge307XG4gICAgdmFyIENvbnN0cnVjdG9yO1xuXG4gICAgaWYgKCFERVNDUklQVE9SUyQyIHx8ICFpc0NhbGxhYmxlKE5hdGl2ZUNvbnN0cnVjdG9yKSB8fCAhKElTX1dFQUsgfHwgTmF0aXZlUHJvdG90eXBlLmZvckVhY2ggJiYgIWZhaWxzJDEoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCkuZW50cmllcygpLm5leHQoKTtcbiAgICB9KSkpIHtcbiAgICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgICBDb25zdHJ1Y3RvciA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICAgIEludGVybmFsTWV0YWRhdGFNb2R1bGUuZW5hYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGFyZ2V0LCBpdGVyYWJsZSkge1xuICAgICAgICBzZXRJbnRlcm5hbFN0YXRlJDEoYW5JbnN0YW5jZSQxKHRhcmdldCwgUHJvdG90eXBlKSwge1xuICAgICAgICAgIHR5cGU6IENPTlNUUlVDVE9SX05BTUUsXG4gICAgICAgICAgY29sbGVjdGlvbjogbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGl0ZXJhdGUkMShpdGVyYWJsZSwgdGFyZ2V0W0FEREVSXSwge1xuICAgICAgICAgIHRoYXQ6IHRhcmdldCxcbiAgICAgICAgICBBU19FTlRSSUVTOiBJU19NQVBcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBQcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IkMShDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICAgIGZvckVhY2goWydhZGQnLCAnY2xlYXInLCAnZGVsZXRlJywgJ2ZvckVhY2gnLCAnZ2V0JywgJ2hhcycsICdzZXQnLCAna2V5cycsICd2YWx1ZXMnLCAnZW50cmllcyddLCBmdW5jdGlvbiAoS0VZKSB7XG4gICAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PSAnYWRkJyB8fCBLRVkgPT0gJ3NldCc7XG5cbiAgICAgICAgaWYgKEtFWSBpbiBOYXRpdmVQcm90b3R5cGUgJiYgIShJU19XRUFLICYmIEtFWSA9PSAnY2xlYXInKSkge1xuICAgICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShQcm90b3R5cGUsIEtFWSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5jb2xsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdChhKSkgcmV0dXJuIEtFWSA9PSAnZ2V0JyA/IHVuZGVmaW5lZCA6IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbGxlY3Rpb25bS0VZXShhID09PSAwID8gMCA6IGEsIGIpO1xuICAgICAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBJU19XRUFLIHx8IGRlZmluZVByb3BlcnR5JDEoUHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5jb2xsZWN0aW9uLnNpemU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZXhwb3J0ZWRbQ09OU1RSVUNUT1JfTkFNRV0gPSBDb25zdHJ1Y3RvcjtcbiAgICAkJDIoe1xuICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgZm9yY2VkOiB0cnVlXG4gICAgfSwgZXhwb3J0ZWQpO1xuICAgIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG5cbiAgdmFyIHJlZGVmaW5lID0gcmVkZWZpbmUkNDtcblxuICB2YXIgcmVkZWZpbmVBbGwkMSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudW5zYWZlICYmIHRhcmdldFtrZXldKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO2Vsc2UgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHZhciBnZXRCdWlsdEluID0gZ2V0QnVpbHRJbiQ5O1xuICB2YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbiAgdmFyIHdlbGxLbm93blN5bWJvbCA9IHdlbGxLbm93blN5bWJvbCRqO1xuICB2YXIgREVTQ1JJUFRPUlMkMSA9IGRlc2NyaXB0b3JzO1xuICB2YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG4gIHZhciBzZXRTcGVjaWVzJDEgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSkge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4oQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcblxuICAgIGlmIChERVNDUklQVE9SUyQxICYmIENvbnN0cnVjdG9yICYmICFDb25zdHJ1Y3RvcltTUEVDSUVTXSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFNQRUNJRVMsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG4gIHZhciBjcmVhdGUgPSBvYmplY3RDcmVhdGU7XG4gIHZhciByZWRlZmluZUFsbCA9IHJlZGVmaW5lQWxsJDE7XG4gIHZhciBiaW5kID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbiAgdmFyIGFuSW5zdGFuY2UgPSBhbkluc3RhbmNlJDI7XG4gIHZhciBpdGVyYXRlID0gaXRlcmF0ZSQyO1xuICB2YXIgZGVmaW5lSXRlcmF0b3IgPSBkZWZpbmVJdGVyYXRvciQzO1xuICB2YXIgc2V0U3BlY2llcyA9IHNldFNwZWNpZXMkMTtcbiAgdmFyIERFU0NSSVBUT1JTID0gZGVzY3JpcHRvcnM7XG4gIHZhciBmYXN0S2V5ID0gaW50ZXJuYWxNZXRhZGF0YS5leHBvcnRzLmZhc3RLZXk7XG4gIHZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gaW50ZXJuYWxTdGF0ZTtcbiAgdmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbiAgdmFyIGludGVybmFsU3RhdGVHZXR0ZXJGb3IgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcjtcbiAgdmFyIGNvbGxlY3Rpb25TdHJvbmckMiA9IHtcbiAgICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgUHJvdG90eXBlKTtcbiAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XG4gICAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcbiAgICAgICAgICBpbmRleDogY3JlYXRlKG51bGwpLFxuICAgICAgICAgIGZpcnN0OiB1bmRlZmluZWQsXG4gICAgICAgICAgbGFzdDogdW5kZWZpbmVkLFxuICAgICAgICAgIHNpemU6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghREVTQ1JJUFRPUlMpIHRoYXQuc2l6ZSA9IDA7XG4gICAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB7XG4gICAgICAgICAgdGhhdDogdGhhdCxcbiAgICAgICAgICBBU19FTlRSSUVTOiBJU19NQVBcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBQcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgICAgIHZhciBkZWZpbmUgPSBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICB2YXIgcHJldmlvdXMsIGluZGV4OyAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcblxuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICBlbnRyeS52YWx1ZSA9IHZhbHVlOyAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUubGFzdCA9IGVudHJ5ID0ge1xuICAgICAgICAgICAgaW5kZXg6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLFxuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwcmV2aW91czogcHJldmlvdXMgPSBzdGF0ZS5sYXN0LFxuICAgICAgICAgICAgbmV4dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVtb3ZlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICghc3RhdGUuZmlyc3QpIHN0YXRlLmZpcnN0ID0gZW50cnk7XG4gICAgICAgICAgaWYgKHByZXZpb3VzKSBwcmV2aW91cy5uZXh0ID0gZW50cnk7XG4gICAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplKys7ZWxzZSB0aGF0LnNpemUrKzsgLy8gYWRkIHRvIGluZGV4XG5cbiAgICAgICAgICBpZiAoaW5kZXggIT09ICdGJykgc3RhdGUuaW5kZXhbaW5kZXhdID0gZW50cnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH07XG5cbiAgICAgIHZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTsgLy8gZmFzdCBjYXNlXG5cbiAgICAgICAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSByZXR1cm4gc3RhdGUuaW5kZXhbaW5kZXhdOyAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcblxuICAgICAgICBmb3IgKGVudHJ5ID0gc3RhdGUuZmlyc3Q7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm5leHQpIHtcbiAgICAgICAgICBpZiAoZW50cnkua2V5ID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZWRlZmluZUFsbChQcm90b3R5cGUsIHtcbiAgICAgICAgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGUuY2xlYXIoKWAgbWV0aG9kc1xuICAgICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuY2xlYXJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmNsZWFyXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgICAgICB2YXIgZGF0YSA9IHN0YXRlLmluZGV4O1xuICAgICAgICAgIHZhciBlbnRyeSA9IHN0YXRlLmZpcnN0O1xuXG4gICAgICAgICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5wcmV2aW91cykgZW50cnkucHJldmlvdXMgPSBlbnRyeS5wcmV2aW91cy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaW5kZXhdO1xuICAgICAgICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXRlLmZpcnN0ID0gc3RhdGUubGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoREVTQ1JJUFRPUlMpIHN0YXRlLnNpemUgPSAwO2Vsc2UgdGhhdC5zaXplID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGUuZGVsZXRlKGtleSlgIG1ldGhvZHNcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmRlbGV0ZVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZGVsZXRlXG4gICAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcblxuICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xuICAgICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5pbmRleFtlbnRyeS5pbmRleF07XG4gICAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICAgICAgaWYgKG5leHQpIG5leHQucHJldmlvdXMgPSBwcmV2O1xuICAgICAgICAgICAgaWYgKHN0YXRlLmZpcnN0ID09IGVudHJ5KSBzdGF0ZS5maXJzdCA9IG5leHQ7XG4gICAgICAgICAgICBpZiAoc3RhdGUubGFzdCA9PSBlbnRyeSkgc3RhdGUubGFzdCA9IHByZXY7XG4gICAgICAgICAgICBpZiAoREVTQ1JJUFRPUlMpIHN0YXRlLnNpemUtLTtlbHNlIHRoYXQuc2l6ZS0tO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAhIWVudHJ5O1xuICAgICAgICB9LFxuICAgICAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpYCBtZXRob2RzXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5mb3JlYWNoXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5mb3JlYWNoXG4gICAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmblxuICAgICAgICAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi9cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgICAgICAgIHZhciBlbnRyeTtcblxuICAgICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubmV4dCA6IHN0YXRlLmZpcnN0KSB7XG4gICAgICAgICAgICBib3VuZEZ1bmN0aW9uKGVudHJ5LnZhbHVlLCBlbnRyeS5rZXksIHRoaXMpOyAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcblxuICAgICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBgeyBNYXAsIFNldH0ucHJvdG90eXBlLmhhcyhrZXkpYCBtZXRob2RzXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5oYXNcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmhhc1xuICAgICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlZGVmaW5lQWxsKFByb3RvdHlwZSwgSVNfTUFQID8ge1xuICAgICAgICAvLyBgTWFwLnByb3RvdHlwZS5nZXQoa2V5KWAgbWV0aG9kXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5nZXRcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKWAgbWV0aG9kXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5zZXRcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBkZWZpbmUodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IDoge1xuICAgICAgICAvLyBgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpYCBtZXRob2RcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmFkZFxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBkZWZpbmUodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHkoUHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgfSxcbiAgICBzZXRTdHJvbmc6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKSB7XG4gICAgICB2YXIgSVRFUkFUT1JfTkFNRSA9IENPTlNUUlVDVE9SX05BTUUgKyAnIEl0ZXJhdG9yJztcbiAgICAgIHZhciBnZXRJbnRlcm5hbENvbGxlY3Rpb25TdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgICB2YXIgZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihJVEVSQVRPUl9OQU1FKTsgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGUueyBrZXlzLCB2YWx1ZXMsIGVudHJpZXMsIEBAaXRlcmF0b3IgfSgpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZW50cmllc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmtleXNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS52YWx1ZXNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZW50cmllc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmtleXNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS52YWx1ZXNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5cbiAgICAgIGRlZmluZUl0ZXJhdG9yKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICAgICAgdHlwZTogSVRFUkFUT1JfTkFNRSxcbiAgICAgICAgICB0YXJnZXQ6IGl0ZXJhdGVkLFxuICAgICAgICAgIHN0YXRlOiBnZXRJbnRlcm5hbENvbGxlY3Rpb25TdGF0ZShpdGVyYXRlZCksXG4gICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICBsYXN0OiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSh0aGlzKTtcbiAgICAgICAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICAgICAgICB2YXIgZW50cnkgPSBzdGF0ZS5sYXN0OyAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcblxuICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucmVtb3ZlZCkgZW50cnkgPSBlbnRyeS5wcmV2aW91czsgLy8gZ2V0IG5leHQgZW50cnlcblxuXG4gICAgICAgIGlmICghc3RhdGUudGFyZ2V0IHx8ICEoc3RhdGUubGFzdCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uZXh0IDogc3RhdGUuc3RhdGUuZmlyc3QpKSB7XG4gICAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSAvLyByZXR1cm4gc3RlcCBieSBraW5kXG5cblxuICAgICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGVudHJ5LmtleSxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogZW50cnkudmFsdWUsXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogW2VudHJ5LmtleSwgZW50cnkudmFsdWVdLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7IC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlW0BAc3BlY2llc11gIGFjY2Vzc29yc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtbWFwLUBAc3BlY2llc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtc2V0LUBAc3BlY2llc1xuXG4gICAgICBzZXRTcGVjaWVzKENPTlNUUlVDVE9SX05BTUUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY29sbGVjdGlvbiQxID0gY29sbGVjdGlvbiQyO1xuICB2YXIgY29sbGVjdGlvblN0cm9uZyQxID0gY29sbGVjdGlvblN0cm9uZyQyOyAvLyBgTWFwYCBjb25zdHJ1Y3RvclxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC1vYmplY3RzXG5cbiAgY29sbGVjdGlvbiQxKCdNYXAnLCBmdW5jdGlvbiAoaW5pdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7XG4gICAgICByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB9O1xuICB9LCBjb2xsZWN0aW9uU3Ryb25nJDEpO1xuXG4gIHZhciBwYXRoJDEgPSBwYXRoJHE7XG4gIHZhciBtYXAkMiA9IHBhdGgkMS5NYXA7XG5cbiAgdmFyIHBhcmVudCQ5ID0gbWFwJDI7XG4gIHZhciBtYXAkMSA9IHBhcmVudCQ5O1xuXG4gIHZhciBtYXAgPSBtYXAkMTtcblxuICB2YXIgJCQxID0gX2V4cG9ydDtcbiAgdmFyICRzb21lID0gYXJyYXlJdGVyYXRpb24uc29tZTtcbiAgdmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkMSA9IGFycmF5TWV0aG9kSXNTdHJpY3QkNTtcbiAgdmFyIFNUUklDVF9NRVRIT0QkMSA9IGFycmF5TWV0aG9kSXNTdHJpY3QkMSgnc29tZScpOyAvLyBgQXJyYXkucHJvdG90eXBlLnNvbWVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG5cbiAgJCQxKHtcbiAgICB0YXJnZXQ6ICdBcnJheScsXG4gICAgcHJvdG86IHRydWUsXG4gICAgZm9yY2VkOiAhU1RSSUNUX01FVEhPRCQxXG4gIH0sIHtcbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm5cbiAgICAvKiAsIHRoaXNBcmcgKi9cbiAgICApIHtcbiAgICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZW50cnlWaXJ0dWFsJDQgPSBlbnRyeVZpcnR1YWwkaztcbiAgdmFyIHNvbWUkMyA9IGVudHJ5VmlydHVhbCQ0KCdBcnJheScpLnNvbWU7XG5cbiAgdmFyIGlzUHJvdG90eXBlT2YkNCA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG4gIHZhciBtZXRob2QkNCA9IHNvbWUkMztcbiAgdmFyIEFycmF5UHJvdG90eXBlJDQgPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgdmFyIHNvbWUkMiA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBvd24gPSBpdC5zb21lO1xuICAgIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkNCB8fCBpc1Byb3RvdHlwZU9mJDQoQXJyYXlQcm90b3R5cGUkNCwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkNC5zb21lID8gbWV0aG9kJDQgOiBvd247XG4gIH07XG5cbiAgdmFyIHBhcmVudCQ4ID0gc29tZSQyO1xuICB2YXIgc29tZSQxID0gcGFyZW50JDg7XG5cbiAgdmFyIHNvbWUgPSBzb21lJDE7XG5cbiAgdmFyIGVudHJ5VmlydHVhbCQzID0gZW50cnlWaXJ0dWFsJGs7XG4gIHZhciBrZXlzJDMgPSBlbnRyeVZpcnR1YWwkMygnQXJyYXknKS5rZXlzO1xuXG4gIHZhciBwYXJlbnQkNyA9IGtleXMkMztcbiAgdmFyIGtleXMkMiA9IHBhcmVudCQ3O1xuXG4gIHZhciBjbGFzc29mJDIgPSBjbGFzc29mJGM7XG4gIHZhciBoYXNPd24kMiA9IGhhc093blByb3BlcnR5XzE7XG4gIHZhciBpc1Byb3RvdHlwZU9mJDMgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuICB2YXIgbWV0aG9kJDMgPSBrZXlzJDI7XG4gIHZhciBBcnJheVByb3RvdHlwZSQzID0gQXJyYXkucHJvdG90eXBlO1xuICB2YXIgRE9NSXRlcmFibGVzJDIgPSB7XG4gICAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICAgIE5vZGVMaXN0OiB0cnVlXG4gIH07XG5cbiAgdmFyIGtleXMkMSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBvd24gPSBpdC5rZXlzO1xuICAgIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkMyB8fCBpc1Byb3RvdHlwZU9mJDMoQXJyYXlQcm90b3R5cGUkMywgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkMy5rZXlzIHx8IGhhc093biQyKERPTUl0ZXJhYmxlcyQyLCBjbGFzc29mJDIoaXQpKSA/IG1ldGhvZCQzIDogb3duO1xuICB9O1xuXG4gIHZhciBrZXlzID0ga2V5cyQxO1xuXG4gIHZhciBhcnJheVNsaWNlID0gYXJyYXlTbGljZVNpbXBsZTtcbiAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuICB2YXIgbWVyZ2VTb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciBtaWRkbGUgPSBmbG9vcihsZW5ndGggLyAyKTtcbiAgICByZXR1cm4gbGVuZ3RoIDwgOCA/IGluc2VydGlvblNvcnQoYXJyYXksIGNvbXBhcmVmbikgOiBtZXJnZShhcnJheSwgbWVyZ2VTb3J0KGFycmF5U2xpY2UoYXJyYXksIDAsIG1pZGRsZSksIGNvbXBhcmVmbiksIG1lcmdlU29ydChhcnJheVNsaWNlKGFycmF5LCBtaWRkbGUpLCBjb21wYXJlZm4pLCBjb21wYXJlZm4pO1xuICB9O1xuXG4gIHZhciBpbnNlcnRpb25Tb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgZWxlbWVudCwgajtcblxuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICBqID0gaTtcbiAgICAgIGVsZW1lbnQgPSBhcnJheVtpXTtcblxuICAgICAgd2hpbGUgKGogJiYgY29tcGFyZWZuKGFycmF5W2ogLSAxXSwgZWxlbWVudCkgPiAwKSB7XG4gICAgICAgIGFycmF5W2pdID0gYXJyYXlbLS1qXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGogIT09IGkrKykgYXJyYXlbal0gPSBlbGVtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfTtcblxuICB2YXIgbWVyZ2UgPSBmdW5jdGlvbiAoYXJyYXksIGxlZnQsIHJpZ2h0LCBjb21wYXJlZm4pIHtcbiAgICB2YXIgbGxlbmd0aCA9IGxlZnQubGVuZ3RoO1xuICAgIHZhciBybGVuZ3RoID0gcmlnaHQubGVuZ3RoO1xuICAgIHZhciBsaW5kZXggPSAwO1xuICAgIHZhciByaW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKGxpbmRleCA8IGxsZW5ndGggfHwgcmluZGV4IDwgcmxlbmd0aCkge1xuICAgICAgYXJyYXlbbGluZGV4ICsgcmluZGV4XSA9IGxpbmRleCA8IGxsZW5ndGggJiYgcmluZGV4IDwgcmxlbmd0aCA/IGNvbXBhcmVmbihsZWZ0W2xpbmRleF0sIHJpZ2h0W3JpbmRleF0pIDw9IDAgPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXSA6IGxpbmRleCA8IGxsZW5ndGggPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH07XG5cbiAgdmFyIGFycmF5U29ydCA9IG1lcmdlU29ydDtcblxuICB2YXIgdXNlckFnZW50JDEgPSBlbmdpbmVVc2VyQWdlbnQ7XG4gIHZhciBmaXJlZm94ID0gdXNlckFnZW50JDEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvaSk7XG4gIHZhciBlbmdpbmVGZlZlcnNpb24gPSAhIWZpcmVmb3ggJiYgK2ZpcmVmb3hbMV07XG5cbiAgdmFyIFVBID0gZW5naW5lVXNlckFnZW50O1xuICB2YXIgZW5naW5lSXNJZU9yRWRnZSA9IC9NU0lFfFRyaWRlbnQvLnRlc3QoVUEpO1xuXG4gIHZhciB1c2VyQWdlbnQgPSBlbmdpbmVVc2VyQWdlbnQ7XG4gIHZhciB3ZWJraXQgPSB1c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvKFxcZCspXFwuLyk7XG4gIHZhciBlbmdpbmVXZWJraXRWZXJzaW9uID0gISF3ZWJraXQgJiYgK3dlYmtpdFsxXTtcblxuICB2YXIgJCA9IF9leHBvcnQ7XG4gIHZhciB1bmN1cnJ5VGhpcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBhQ2FsbGFibGUgPSBhQ2FsbGFibGUkNztcbiAgdmFyIHRvT2JqZWN0ID0gdG9PYmplY3QkZTtcbiAgdmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbiAgdmFyIHRvU3RyaW5nID0gdG9TdHJpbmckNztcbiAgdmFyIGZhaWxzID0gZmFpbHMkcjtcbiAgdmFyIGludGVybmFsU29ydCA9IGFycmF5U29ydDtcbiAgdmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSBhcnJheU1ldGhvZElzU3RyaWN0JDU7XG4gIHZhciBGRiA9IGVuZ2luZUZmVmVyc2lvbjtcbiAgdmFyIElFX09SX0VER0UgPSBlbmdpbmVJc0llT3JFZGdlO1xuICB2YXIgVjggPSBlbmdpbmVWOFZlcnNpb247XG4gIHZhciBXRUJLSVQgPSBlbmdpbmVXZWJraXRWZXJzaW9uO1xuICB2YXIgdGVzdCA9IFtdO1xuICB2YXIgdW4kU29ydCA9IHVuY3VycnlUaGlzKHRlc3Quc29ydCk7XG4gIHZhciBwdXNoID0gdW5jdXJyeVRoaXModGVzdC5wdXNoKTsgLy8gSUU4LVxuXG4gIHZhciBGQUlMU19PTl9VTkRFRklORUQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdGVzdC5zb3J0KHVuZGVmaW5lZCk7XG4gIH0pOyAvLyBWOCBidWdcblxuICB2YXIgRkFJTFNfT05fTlVMTCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICB0ZXN0LnNvcnQobnVsbCk7XG4gIH0pOyAvLyBPbGQgV2ViS2l0XG5cbiAgdmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdzb3J0Jyk7XG4gIHZhciBTVEFCTEVfU09SVCA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZmVhdHVyZSBkZXRlY3Rpb24gY2FuIGJlIHRvbyBzbG93LCBzbyBjaGVjayBlbmdpbmVzIHZlcnNpb25zXG4gICAgaWYgKFY4KSByZXR1cm4gVjggPCA3MDtcbiAgICBpZiAoRkYgJiYgRkYgPiAzKSByZXR1cm47XG4gICAgaWYgKElFX09SX0VER0UpIHJldHVybiB0cnVlO1xuICAgIGlmIChXRUJLSVQpIHJldHVybiBXRUJLSVQgPCA2MDM7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBjb2RlLCBjaHIsIHZhbHVlLCBpbmRleDsgLy8gZ2VuZXJhdGUgYW4gYXJyYXkgd2l0aCBtb3JlIDUxMiBlbGVtZW50cyAoQ2hha3JhIGFuZCBvbGQgVjggZmFpbHMgb25seSBpbiB0aGlzIGNhc2UpXG5cbiAgICBmb3IgKGNvZGUgPSA2NTsgY29kZSA8IDc2OyBjb2RlKyspIHtcbiAgICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG5cbiAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIDY2OlxuICAgICAgICBjYXNlIDY5OlxuICAgICAgICBjYXNlIDcwOlxuICAgICAgICBjYXNlIDcyOlxuICAgICAgICAgIHZhbHVlID0gMztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDY4OlxuICAgICAgICBjYXNlIDcxOlxuICAgICAgICAgIHZhbHVlID0gNDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhbHVlID0gMjtcbiAgICAgIH1cblxuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgNDc7IGluZGV4KyspIHtcbiAgICAgICAgdGVzdC5wdXNoKHtcbiAgICAgICAgICBrOiBjaHIgKyBpbmRleCxcbiAgICAgICAgICB2OiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0ZXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBiLnYgLSBhLnY7XG4gICAgfSk7XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0ZXN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY2hyID0gdGVzdFtpbmRleF0uay5jaGFyQXQoMCk7XG4gICAgICBpZiAocmVzdWx0LmNoYXJBdChyZXN1bHQubGVuZ3RoIC0gMSkgIT09IGNocikgcmVzdWx0ICs9IGNocjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0ICE9PSAnREdCRUZIQUNJSksnO1xuICB9KTtcbiAgdmFyIEZPUkNFRCA9IEZBSUxTX09OX1VOREVGSU5FRCB8fCAhRkFJTFNfT05fTlVMTCB8fCAhU1RSSUNUX01FVEhPRCB8fCAhU1RBQkxFX1NPUlQ7XG5cbiAgdmFyIGdldFNvcnRDb21wYXJlID0gZnVuY3Rpb24gKGNvbXBhcmVmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgcmV0dXJuIDE7XG4gICAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIHJldHVybiArY29tcGFyZWZuKHgsIHkpIHx8IDA7XG4gICAgICByZXR1cm4gdG9TdHJpbmcoeCkgPiB0b1N0cmluZyh5KSA/IDEgOiAtMTtcbiAgICB9O1xuICB9OyAvLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb3J0XG5cblxuICAkKHtcbiAgICB0YXJnZXQ6ICdBcnJheScsXG4gICAgcHJvdG86IHRydWUsXG4gICAgZm9yY2VkOiBGT1JDRURcbiAgfSwge1xuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIGFDYWxsYWJsZShjb21wYXJlZm4pO1xuICAgICAgdmFyIGFycmF5ID0gdG9PYmplY3QodGhpcyk7XG4gICAgICBpZiAoU1RBQkxFX1NPUlQpIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZCA/IHVuJFNvcnQoYXJyYXkpIDogdW4kU29ydChhcnJheSwgY29tcGFyZWZuKTtcbiAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgdmFyIGFycmF5TGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoYXJyYXkpO1xuICAgICAgdmFyIGl0ZW1zTGVuZ3RoLCBpbmRleDtcblxuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgaWYgKGluZGV4IGluIGFycmF5KSBwdXNoKGl0ZW1zLCBhcnJheVtpbmRleF0pO1xuICAgICAgfVxuXG4gICAgICBpbnRlcm5hbFNvcnQoaXRlbXMsIGdldFNvcnRDb21wYXJlKGNvbXBhcmVmbikpO1xuICAgICAgaXRlbXNMZW5ndGggPSBpdGVtcy5sZW5ndGg7XG4gICAgICBpbmRleCA9IDA7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGl0ZW1zTGVuZ3RoKSBhcnJheVtpbmRleF0gPSBpdGVtc1tpbmRleCsrXTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgYXJyYXlMZW5ndGgpIGRlbGV0ZSBhcnJheVtpbmRleCsrXTtcblxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGVudHJ5VmlydHVhbCQyID0gZW50cnlWaXJ0dWFsJGs7XG4gIHZhciBzb3J0JDMgPSBlbnRyeVZpcnR1YWwkMignQXJyYXknKS5zb3J0O1xuXG4gIHZhciBpc1Byb3RvdHlwZU9mJDIgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuICB2YXIgbWV0aG9kJDIgPSBzb3J0JDM7XG4gIHZhciBBcnJheVByb3RvdHlwZSQyID0gQXJyYXkucHJvdG90eXBlO1xuXG4gIHZhciBzb3J0JDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgb3duID0gaXQuc29ydDtcbiAgICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDIgfHwgaXNQcm90b3R5cGVPZiQyKEFycmF5UHJvdG90eXBlJDIsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDIuc29ydCA/IG1ldGhvZCQyIDogb3duO1xuICB9O1xuXG4gIHZhciBwYXJlbnQkNiA9IHNvcnQkMjtcbiAgdmFyIHNvcnQkMSA9IHBhcmVudCQ2O1xuXG4gIHZhciBzb3J0ID0gc29ydCQxO1xuXG4gIHZhciBlbnRyeVZpcnR1YWwkMSA9IGVudHJ5VmlydHVhbCRrO1xuICB2YXIgdmFsdWVzJDMgPSBlbnRyeVZpcnR1YWwkMSgnQXJyYXknKS52YWx1ZXM7XG5cbiAgdmFyIHBhcmVudCQ1ID0gdmFsdWVzJDM7XG4gIHZhciB2YWx1ZXMkMiA9IHBhcmVudCQ1O1xuXG4gIHZhciBjbGFzc29mJDEgPSBjbGFzc29mJGM7XG4gIHZhciBoYXNPd24kMSA9IGhhc093blByb3BlcnR5XzE7XG4gIHZhciBpc1Byb3RvdHlwZU9mJDEgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuICB2YXIgbWV0aG9kJDEgPSB2YWx1ZXMkMjtcbiAgdmFyIEFycmF5UHJvdG90eXBlJDEgPSBBcnJheS5wcm90b3R5cGU7XG4gIHZhciBET01JdGVyYWJsZXMkMSA9IHtcbiAgICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gICAgTm9kZUxpc3Q6IHRydWVcbiAgfTtcblxuICB2YXIgdmFsdWVzJDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgb3duID0gaXQudmFsdWVzO1xuICAgIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkMSB8fCBpc1Byb3RvdHlwZU9mJDEoQXJyYXlQcm90b3R5cGUkMSwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkMS52YWx1ZXMgfHwgaGFzT3duJDEoRE9NSXRlcmFibGVzJDEsIGNsYXNzb2YkMShpdCkpID8gbWV0aG9kJDEgOiBvd247XG4gIH07XG5cbiAgdmFyIHZhbHVlcyA9IHZhbHVlcyQxO1xuXG4gIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yJDQ7XG5cbiAgdmFyIGVudHJ5VmlydHVhbCA9IGVudHJ5VmlydHVhbCRrO1xuICB2YXIgZW50cmllcyQzID0gZW50cnlWaXJ0dWFsKCdBcnJheScpLmVudHJpZXM7XG5cbiAgdmFyIHBhcmVudCQ0ID0gZW50cmllcyQzO1xuICB2YXIgZW50cmllcyQyID0gcGFyZW50JDQ7XG5cbiAgdmFyIGNsYXNzb2YgPSBjbGFzc29mJGM7XG4gIHZhciBoYXNPd24gPSBoYXNPd25Qcm9wZXJ0eV8xO1xuICB2YXIgaXNQcm90b3R5cGVPZiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG4gIHZhciBtZXRob2QgPSBlbnRyaWVzJDI7XG4gIHZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbiAgdmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gICAgTm9kZUxpc3Q6IHRydWVcbiAgfTtcblxuICB2YXIgZW50cmllcyQxID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIG93biA9IGl0LmVudHJpZXM7XG4gICAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSB8fCBpc1Byb3RvdHlwZU9mKEFycmF5UHJvdG90eXBlLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZS5lbnRyaWVzIHx8IGhhc093bihET01JdGVyYWJsZXMsIGNsYXNzb2YoaXQpKSA/IG1ldGhvZCA6IG93bjtcbiAgfTtcblxuICB2YXIgZW50cmllcyA9IGVudHJpZXMkMTtcblxuICAvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbiAgLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4gIC8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG4gIHZhciBnZXRSYW5kb21WYWx1ZXM7XG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgZnVuY3Rpb24gcm5nKCkge1xuICAgIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uIEFsc28sXG4gICAgICAvLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxuICAgICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSB8fCB0eXBlb2YgbXNDcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pO1xuXG4gICAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gIH1cblxuICB2YXIgUkVHRVggPSAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICAgIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAgICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gICAqL1xuXG4gIHZhciBieXRlVG9IZXggPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnkoYXJyKSB7XG4gICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDsgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcblxuICAgIHZhciB1dWlkID0gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gICAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAgIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICAgIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV1aWQ7XG4gIH1cblxuICBmdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gICAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICAgIGlmIChidWYpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5KHJuZHMpO1xuICB9XG5cbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgYSB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YWx1ZSAtIElucHV0IHZhbHVlIG9mIHVua25vd24gdHlwZS5cclxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB2YWxpZCBpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBpc0lkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG4gIH1cblxuICAvKipcclxuICAgKiBBIHF1ZXVlLlxyXG4gICAqXHJcbiAgICogQHR5cGVQYXJhbSBUIC0gVGhlIHR5cGUgb2YgbWV0aG9kIG5hbWVzIHRvIGJlIHJlcGxhY2VkIGJ5IHF1ZXVlZCB2ZXJzaW9ucy5cclxuICAgKi9cbiAgdmFyIFF1ZXVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAvKiogRGVsYXkgaW4gbWlsbGlzZWNvbmRzLiBJZiBkZWZpbmVkIHRoZSBxdWV1ZSB3aWxsIGJlIHBlcmlvZGljYWxseSBmbHVzaGVkLiAqL1xuXG4gICAgLyoqIE1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHF1ZXVlIGJlZm9yZSBpdCB3aWxsIGJlIGZsdXNoZWQuICovXG5cbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBRdWV1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFF1ZXVlIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBRdWV1ZShvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUXVldWUpO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWxheVwiLCB2b2lkIDApO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhcIiwgdm9pZCAwKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3F1ZXVlXCIsIFtdKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RpbWVvdXRcIiwgbnVsbCk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9leHRlbmRlZFwiLCBudWxsKTtcblxuICAgICAgLy8gb3B0aW9uc1xuICAgICAgdGhpcy5kZWxheSA9IG51bGw7XG4gICAgICB0aGlzLm1heCA9IEluZmluaXR5O1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgcXVldWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBRdWV1ZSBjb25maWd1cmF0aW9uLlxyXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhRdWV1ZSwgW3tcbiAgICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmRlbGF5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdGhpcy5kZWxheSA9IG9wdGlvbnMuZGVsYXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aGlzLm1heCA9IG9wdGlvbnMubWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZmx1c2hJZk5lZWRlZCgpO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIEV4dGVuZCBhbiBvYmplY3Qgd2l0aCBxdWV1aW5nIGZ1bmN0aW9uYWxpdHkuXHJcbiAgICAgICAqIFRoZSBvYmplY3Qgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGEgZnVuY3Rpb24gZmx1c2gsIGFuZCB0aGUgbWV0aG9kcyBwcm92aWRlZCBpbiBvcHRpb25zLnJlcGxhY2Ugd2lsbCBiZSByZXBsYWNlZCB3aXRoIHF1ZXVlZCBvbmVzLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZC5cclxuICAgICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMuXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHF1ZXVlLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgICB2YWx1ZTpcbiAgICAgIC8qKlxyXG4gICAgICAgKiBEZXN0cm95IHRoZSBxdWV1ZS4gVGhlIHF1ZXVlIHdpbGwgZmlyc3QgZmx1c2ggYWxsIHF1ZXVlZCBhY3Rpb25zLCBhbmQgaW4gY2FzZSBpdCBoYXMgZXh0ZW5kZWQgYW4gb2JqZWN0LCB3aWxsIHJlc3RvcmUgdGhlIG9yaWdpbmFsIG9iamVjdC5cclxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2V4dGVuZGVkKSB7XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHRoaXMuX2V4dGVuZGVkLm9iamVjdDtcbiAgICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMuX2V4dGVuZGVkLm1ldGhvZHM7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBtZXRob2RzW2ldO1xuXG4gICAgICAgICAgICBpZiAobWV0aG9kLm9yaWdpbmFsKSB7XG4gICAgICAgICAgICAgIC8vIEBUT0RPOiBiZXR0ZXIgc29sdXRpb24/XG4gICAgICAgICAgICAgIG9iamVjdFttZXRob2QubmFtZV0gPSBtZXRob2Qub3JpZ2luYWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBAVE9ETzogYmV0dGVyIHNvbHV0aW9uP1xuICAgICAgICAgICAgICBkZWxldGUgb2JqZWN0W21ldGhvZC5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9leHRlbmRlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXBsYWNlIGEgbWV0aG9kIG9uIGFuIG9iamVjdCB3aXRoIGEgcXVldWVkIHZlcnNpb24uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBvYmplY3QgLSBPYmplY3QgaGF2aW5nIHRoZSBtZXRob2QuXHJcbiAgICAgICAqIEBwYXJhbSBtZXRob2QgLSBUaGUgbWV0aG9kIG5hbWUuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJlcGxhY2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKG9iamVjdCwgbWV0aG9kKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcyAtLSBGdW5jdGlvbiB0aGlzIGlzIG5lY2Vzc2FyeSBpbiB0aGUgZnVuY3Rpb24gYmVsbG93LCBzbyBjbGFzcyB0aGlzIGhhcyB0byBiZSBzYXZlZCBpbnRvIGEgdmFyaWFibGUgaGVyZS4gKi9cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIG9yaWdpbmFsID0gb2JqZWN0W21ldGhvZF07XG5cbiAgICAgICAgaWYgKCFvcmlnaW5hbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBcIiArIG1ldGhvZCArIFwiIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iamVjdFttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBhZGQgdGhpcyBjYWxsIHRvIHRoZSBxdWV1ZVxuICAgICAgICAgIG1lLnF1ZXVlKHtcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgICBmbjogb3JpZ2luYWwsXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogUXVldWUgYSBjYWxsLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gZW50cnkgLSBUaGUgZnVuY3Rpb24gb3IgZW50cnkgdG8gYmUgcXVldWVkLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJxdWV1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHF1ZXVlKGVudHJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgICAgZm46IGVudHJ5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcXVldWUucHVzaChlbnRyeSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mbHVzaElmTmVlZGVkKCk7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogQ2hlY2sgd2hldGhlciB0aGUgcXVldWUgbmVlZHMgdG8gYmUgZmx1c2hlZC5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2ZsdXNoSWZOZWVkZWRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmx1c2hJZk5lZWRlZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAvLyBmbHVzaCB3aGVuIHRoZSBtYXhpbXVtIGlzIGV4Y2VlZGVkLlxuICAgICAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gdGhpcy5tYXgpIHtcbiAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH0gLy8gZmx1c2ggYWZ0ZXIgYSBwZXJpb2Qgb2YgaW5hY3Rpdml0eSB3aGVuIGEgZGVsYXkgaXMgY29uZmlndXJlZFxuXG5cbiAgICAgICAgaWYgKHRoaXMuX3RpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHRoaXMuZGVsYXkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmZsdXNoKCk7XG4gICAgICAgICAgfSwgdGhpcy5kZWxheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBGbHVzaCBhbGwgcXVldWVkIGNhbGxzXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImZsdXNoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIHZhciBfY29udGV4dCwgX2NvbnRleHQyO1xuXG4gICAgICAgIGZvckVhY2gkMShfY29udGV4dCA9IHNwbGljZShfY29udGV4dDIgPSB0aGlzLl9xdWV1ZSkuY2FsbChfY29udGV4dDIsIDApKS5jYWxsKF9jb250ZXh0LCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICBlbnRyeS5mbi5hcHBseShlbnRyeS5jb250ZXh0IHx8IGVudHJ5LmZuLCBlbnRyeS5hcmdzIHx8IFtdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiZXh0ZW5kXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kKG9iamVjdCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcXVldWUgPSBuZXcgUXVldWUob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG9iamVjdC5mbHVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGFyZ2V0IG9iamVjdCBhbHJlYWR5IGhhcyBhIHByb3BlcnR5IGZsdXNoXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqZWN0LmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHF1ZXVlLmZsdXNoKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG1ldGhvZHMgPSBbe1xuICAgICAgICAgIG5hbWU6IFwiZmx1c2hcIixcbiAgICAgICAgICBvcmlnaW5hbDogdW5kZWZpbmVkXG4gICAgICAgIH1dO1xuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVwbGFjZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5yZXBsYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG9wdGlvbnMucmVwbGFjZVtpXTtcbiAgICAgICAgICAgIG1ldGhvZHMucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIC8vIEBUT0RPOiBiZXR0ZXIgc29sdXRpb24/XG4gICAgICAgICAgICAgIG9yaWdpbmFsOiBvYmplY3RbbmFtZV1cbiAgICAgICAgICAgIH0pOyAvLyBAVE9ETzogYmV0dGVyIHNvbHV0aW9uP1xuXG4gICAgICAgICAgICBxdWV1ZS5yZXBsYWNlKG9iamVjdCwgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcXVldWUuX2V4dGVuZGVkID0ge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIG1ldGhvZHM6IG1ldGhvZHNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHF1ZXVlO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBRdWV1ZTtcbiAgfSgpO1xuXG4gIC8qKlxyXG4gICAqIFtbRGF0YVNldF1dIGNvZGUgdGhhdCBjYW4gYmUgcmV1c2VkIGluIFtbRGF0YVZpZXddXSBvciBvdGhlciBzaW1pbGFyIGltcGxlbWVudGF0aW9ucyBvZiBbW0RhdGFJbnRlcmZhY2VdXS5cclxuICAgKlxyXG4gICAqIEB0eXBlUGFyYW0gSXRlbSAtIEl0ZW0gdHlwZSB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgYW4gaWQuXHJcbiAgICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpZC5cclxuICAgKi9cbiAgdmFyIERhdGFTZXRQYXJ0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRhU2V0UGFydCgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhU2V0UGFydCk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdWJzY3JpYmVyc1wiLCB7XG4gICAgICAgIFwiKlwiOiBbXSxcbiAgICAgICAgYWRkOiBbXSxcbiAgICAgICAgcmVtb3ZlOiBbXSxcbiAgICAgICAgdXBkYXRlOiBbXVxuICAgICAgfSk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN1YnNjcmliZVwiLCBEYXRhU2V0UGFydC5wcm90b3R5cGUub24pO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1bnN1YnNjcmliZVwiLCBEYXRhU2V0UGFydC5wcm90b3R5cGUub2ZmKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRGF0YVNldFBhcnQsIFt7XG4gICAgICBrZXk6IFwiX3RyaWdnZXJcIixcbiAgICAgIHZhbHVlOlxuICAgICAgLyoqXHJcbiAgICAgICAqIFRyaWdnZXIgYW4gZXZlbnRcclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIGV2ZW50IC0gRXZlbnQgbmFtZS5cclxuICAgICAgICogQHBhcmFtIHBheWxvYWQgLSBFdmVudCBwYXlsb2FkLlxyXG4gICAgICAgKiBAcGFyYW0gc2VuZGVySWQgLSBJZCBvZiB0aGUgc2VuZGVyLlxyXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIF90cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCBzZW5kZXJJZCkge1xuICAgICAgICB2YXIgX2NvbnRleHQsIF9jb250ZXh0MjtcblxuICAgICAgICBpZiAoZXZlbnQgPT09IFwiKlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHRyaWdnZXIgZXZlbnQgKlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvckVhY2gkMShfY29udGV4dCA9IGNvbmNhdCQxKF9jb250ZXh0MiA9IFtdKS5jYWxsKF9jb250ZXh0MiwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XSksIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9zdWJzY3JpYmVyc1tcIipcIl0pKSkuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICBzdWJzY3JpYmVyKGV2ZW50LCBwYXlsb2FkLCBzZW5kZXJJZCAhPSBudWxsID8gc2VuZGVySWQgOiBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogU3Vic2NyaWJlIHRvIGFuIGV2ZW50LCBhZGQgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZW1hcmtzIE5vbi1mdW5jdGlvbiBjYWxsYmFja3MgYXJlIGlnbm9yZWQuXHJcbiAgICAgICAqIEBwYXJhbSBldmVudCAtIEV2ZW50IG5hbWUuXHJcbiAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIG1ldGhvZC5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9IC8vIEBUT0RPOiBNYXliZSB0aHJvdyBmb3IgaW52YWxpZCBjYWxsYmFja3M/XG5cbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBVbnN1YnNjcmliZSBmcm9tIGFuIGV2ZW50LCByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZW1hcmtzIElmIHRoZSBzYW1lIGNhbGxiYWNrIHdhcyBzdWJzY3JpYmVkIG1vcmUgdGhhbiBvbmNlICoqYWxsKiogb2NjdXJlbmNlcyB3aWxsIGJlIHJlbW92ZWQuXHJcbiAgICAgICAqIEBwYXJhbSBldmVudCAtIEV2ZW50IG5hbWUuXHJcbiAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIG1ldGhvZC5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib2ZmXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2NvbnRleHQzO1xuXG4gICAgICAgIHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XSA9IGZpbHRlcihfY29udGV4dDMgPSB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0pLmNhbGwoX2NvbnRleHQzLCBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyICE9PSBjYWxsYmFjaztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIG9uIGluc3RlYWQgKFBTOiBEYXRhVmlldy5zdWJzY3JpYmUgPT09IERhdGFWaWV3Lm9uKS5cclxuICAgICAgICovXG5cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRGF0YVNldFBhcnQ7XG4gIH0oKTtcblxuICB2YXIgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb24kMjtcbiAgdmFyIGNvbGxlY3Rpb25TdHJvbmcgPSBjb2xsZWN0aW9uU3Ryb25nJDI7IC8vIGBTZXRgIGNvbnN0cnVjdG9yXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LW9iamVjdHNcblxuICBjb2xsZWN0aW9uKCdTZXQnLCBmdW5jdGlvbiAoaW5pdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7XG4gICAgICByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB9O1xuICB9LCBjb2xsZWN0aW9uU3Ryb25nKTtcblxuICB2YXIgcGF0aCA9IHBhdGgkcTtcbiAgdmFyIHNldCQyID0gcGF0aC5TZXQ7XG5cbiAgdmFyIHBhcmVudCQzID0gc2V0JDI7XG4gIHZhciBzZXQkMSA9IHBhcmVudCQzO1xuXG4gIHZhciBzZXQgPSBzZXQkMTtcblxuICB2YXIgZ2V0SXRlcmF0b3IkNCA9IGdldEl0ZXJhdG9yJDc7XG4gIHZhciBnZXRJdGVyYXRvcl8xID0gZ2V0SXRlcmF0b3IkNDtcblxuICB2YXIgcGFyZW50JDIgPSBnZXRJdGVyYXRvcl8xO1xuICB2YXIgZ2V0SXRlcmF0b3IkMyA9IHBhcmVudCQyO1xuXG4gIHZhciBwYXJlbnQkMSA9IGdldEl0ZXJhdG9yJDM7XG4gIHZhciBnZXRJdGVyYXRvciQyID0gcGFyZW50JDE7XG5cbiAgdmFyIHBhcmVudCA9IGdldEl0ZXJhdG9yJDI7XG4gIHZhciBnZXRJdGVyYXRvciQxID0gcGFyZW50O1xuXG4gIHZhciBnZXRJdGVyYXRvciA9IGdldEl0ZXJhdG9yJDE7XG5cbiAgdmFyIF9TeW1ib2wkaXRlcmF0b3I7XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2Ygc3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGdldEl0ZXJhdG9yTWV0aG9kJDEobykgfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKGlzQXJyYXkkMShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMihvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbiAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIobywgbWluTGVuKSB7IHZhciBfY29udGV4dDEwOyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMihvLCBtaW5MZW4pOyB2YXIgbiA9IHNsaWNlKF9jb250ZXh0MTAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQxMCwgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gZnJvbSQzKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDIobywgbWluTGVuKTsgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDIoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbiAgX1N5bWJvbCRpdGVyYXRvciA9IGl0ZXJhdG9yO1xuXG4gIC8qKlxyXG4gICAqIERhdGEgc3RyZWFtXHJcbiAgICpcclxuICAgKiBAcmVtYXJrc1xyXG4gICAqIFtbRGF0YVN0cmVhbV1dIG9mZmVycyBhbiBhbHdheXMgdXAgdG8gZGF0ZSBzdHJlYW0gb2YgaXRlbXMgZnJvbSBhIFtbRGF0YVNldF1dIG9yIFtbRGF0YVZpZXddXS5cclxuICAgKiBUaGF0IG1lYW5zIHRoYXQgdGhlIHN0cmVhbSBpcyBldmFsdWF0ZWQgYXQgdGhlIHRpbWUgb2YgaXRlcmF0aW9uLCBjb252ZXJzaW9uIHRvIGFub3RoZXIgZGF0YSB0eXBlIG9yIHdoZW4gW1tjYWNoZV1dIGlzIGNhbGxlZCwgbm90IHdoZW4gdGhlIFtbRGF0YVN0cmVhbV1dIHdhcyBjcmVhdGVkLlxyXG4gICAqIE11bHRpcGxlIGludm9jYXRpb25zIG9mIGZvciBleGFtcGxlIFtbdG9JdGVtQXJyYXldXSBtYXkgeWllbGQgZGlmZmVyZW50IHJlc3VsdHMgKGlmIHRoZSBkYXRhIHNvdXJjZSBsaWtlIGZvciBleGFtcGxlIFtbRGF0YVNldF1dIGdldHMgbW9kaWZpZWQpLlxyXG4gICAqIEB0eXBlUGFyYW0gSXRlbSAtIFRoZSBpdGVtIHR5cGUgdGhpcyBzdHJlYW0gaXMgZ29pbmcgdG8gd29yayB3aXRoLlxyXG4gICAqL1xuICB2YXIgRGF0YVN0cmVhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgZGF0YSBzdHJlYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhaXJzIC0gVGhlIGlkLCBpdGVtIHBhaXJzLlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGF0YVN0cmVhbShwYWlycykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFTdHJlYW0pO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcGFpcnNcIiwgdm9pZCAwKTtcblxuICAgICAgdGhpcy5fcGFpcnMgPSBwYWlycztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYW4gaXRlcmFibGUgb2Yga2V5LCB2YWx1ZSBwYWlycyBmb3IgZXZlcnkgZW50cnkgaW4gdGhlIHN0cmVhbS5cclxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoRGF0YVN0cmVhbSwgW3tcbiAgICAgIGtleTogX1N5bWJvbCRpdGVyYXRvcixcbiAgICAgIHZhbHVlOlxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvciwgX3N0ZXAsIF9zdGVwJHZhbHVlLCBpZCwgaXRlbTtcblxuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiB2YWx1ZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMih0aGlzLl9wYWlycyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IucygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAoKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSwgaWQgPSBfc3RlcCR2YWx1ZVswXSwgaXRlbSA9IF9zdGVwJHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIHJldHVybiBbaWQsIGl0ZW1dO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDExO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvci5lKF9jb250ZXh0LnQwKTtcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNDtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDE0KTtcblxuICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHZhbHVlLCB0aGlzLCBbWzEsIDExLCAxNCwgMTddXSk7XG4gICAgICB9KVxuICAgICAgLyoqXHJcbiAgICAgICAqIFJldHVybiBhbiBpdGVyYWJsZSBvZiBrZXksIHZhbHVlIHBhaXJzIGZvciBldmVyeSBlbnRyeSBpbiB0aGUgc3RyZWFtLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlbnRyaWVzXCIsXG4gICAgICB2YWx1ZTpcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIHJlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjIsIF9zdGVwMiwgX3N0ZXAyJHZhbHVlLCBpZCwgaXRlbTtcblxuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBlbnRyaWVzJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMih0aGlzLl9wYWlycyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxO1xuXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5zKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGlmICgoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksIGlkID0gX3N0ZXAyJHZhbHVlWzBdLCBpdGVtID0gX3N0ZXAyJHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICByZXR1cm4gW2lkLCBpdGVtXTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxMTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIuZShfY29udGV4dDIudDApO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxNDtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMTQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIGVudHJpZXMsIHRoaXMsIFtbMSwgMTEsIDE0LCAxN11dKTtcbiAgICAgIH0pXG4gICAgICAvKipcclxuICAgICAgICogUmV0dXJuIGFuIGl0ZXJhYmxlIG9mIGtleXMgaW4gdGhlIHN0cmVhbS5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwia2V5c1wiLFxuICAgICAgdmFsdWU6XG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICByZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IzLCBfc3RlcDMsIF9zdGVwMyR2YWx1ZSwgaWQ7XG5cbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24ga2V5cyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIodGhpcy5fcGFpcnMpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMucygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAoKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfc3RlcDMkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDMudmFsdWUsIDEpLCBpZCA9IF9zdGVwMyR2YWx1ZVswXTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDExO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDEpO1xuXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5lKF9jb250ZXh0My50MCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDE0O1xuXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmZpbmlzaCgxNCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwga2V5cywgdGhpcywgW1sxLCAxMSwgMTQsIDE3XV0pO1xuICAgICAgfSlcbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXR1cm4gYW4gaXRlcmFibGUgb2YgdmFsdWVzIGluIHRoZSBzdHJlYW0uXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInZhbHVlc1wiLFxuICAgICAgdmFsdWU6XG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICByZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjQsIF9zdGVwNCwgX3N0ZXA0JHZhbHVlLCBpdGVtO1xuXG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIHZhbHVlcyQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIodGhpcy5fcGFpcnMpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMTtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjQucygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAoKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfc3RlcDQkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDQudmFsdWUsIDIpLCBpdGVtID0gX3N0ZXA0JHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAxMTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDQudDAgPSBfY29udGV4dDRbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjQuZShfY29udGV4dDQudDApO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAxNDtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjQuZigpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5maW5pc2goMTQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHZhbHVlcywgdGhpcywgW1sxLCAxMSwgMTQsIDE3XV0pO1xuICAgICAgfSlcbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIGlkcyBpbiB0aGlzIHN0cmVhbS5cclxuICAgICAgICpcclxuICAgICAgICogQHJlbWFya3NcclxuICAgICAgICogVGhlIGFycmF5IG1heSBjb250YWluIGR1cGxpY2l0aWVzLlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgYXJyYXkgd2l0aCBhbGwgaWRzIGZyb20gdGhpcyBzdHJlYW0uXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInRvSWRBcnJheVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSWRBcnJheSgpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NTtcblxuICAgICAgICByZXR1cm4gbWFwJDMoX2NvbnRleHQ1ID0gX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX3BhaXJzKSkuY2FsbChfY29udGV4dDUsIGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgICAgcmV0dXJuIHBhaXJbMF07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgaXRlbXMgaW4gdGhpcyBzdHJlYW0uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZW1hcmtzXHJcbiAgICAgICAqIFRoZSBhcnJheSBtYXkgY29udGFpbiBkdXBsaWNpdGllcy5cclxuICAgICAgICogQHJldHVybnMgVGhlIGFycmF5IHdpdGggYWxsIGl0ZW1zIGZyb20gdGhpcyBzdHJlYW0uXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInRvSXRlbUFycmF5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9JdGVtQXJyYXkoKSB7XG4gICAgICAgIHZhciBfY29udGV4dDY7XG5cbiAgICAgICAgcmV0dXJuIG1hcCQzKF9jb250ZXh0NiA9IF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9wYWlycykpLmNhbGwoX2NvbnRleHQ2LCBmdW5jdGlvbiAocGFpcikge1xuICAgICAgICAgIHJldHVybiBwYWlyWzFdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIGVudHJpZXMgaW4gdGhpcyBzdHJlYW0uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZW1hcmtzXHJcbiAgICAgICAqIFRoZSBhcnJheSBtYXkgY29udGFpbiBkdXBsaWNpdGllcy5cclxuICAgICAgICogQHJldHVybnMgVGhlIGFycmF5IHdpdGggYWxsIGVudHJpZXMgZnJvbSB0aGlzIHN0cmVhbS5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidG9FbnRyeUFycmF5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9FbnRyeUFycmF5KCkge1xuICAgICAgICByZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX3BhaXJzKTtcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IG1hcCBjb250YWluaW5nIGFsbCB0aGUgaXRlbXMgaW4gdGhpcyBzdHJlYW0gYWNjZXNzaWJsZSBieSBpZHMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZW1hcmtzXHJcbiAgICAgICAqIEluIGNhc2Ugb2YgZHVwbGljYXRlIGlkcyAoY29lcmNlZCB0byBzdHJpbmcgc28gYDcgPT0gJzcnYCkgdGhlIGxhc3QgZW5jb3V0ZXJlZCBhcHBlYXJzIGluIHRoZSByZXR1cm5lZCBvYmplY3QuXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSBvYmplY3QgbWFwIG9mIGFsbCBpZCDihpIgaXRlbSBwYWlycyBmcm9tIHRoaXMgc3RyZWFtLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b09iamVjdE1hcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvT2JqZWN0TWFwKCkge1xuICAgICAgICB2YXIgbWFwID0gY3JlYXRlJDUobnVsbCk7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKHRoaXMuX3BhaXJzKSxcbiAgICAgICAgICAgIF9zdGVwNTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgX3N0ZXA1JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA1LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICBpZCA9IF9zdGVwNSR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICBpdGVtID0gX3N0ZXA1JHZhbHVlWzFdO1xuXG4gICAgICAgICAgICBtYXBbaWRdID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXR1cm4gYSBtYXAgY29udGFpbmluZyBhbGwgdGhlIGl0ZW1zIGluIHRoaXMgc3RyZWFtIGFjY2Vzc2libGUgYnkgaWRzLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgbWFwIG9mIGFsbCBpZCDihpIgaXRlbSBwYWlycyBmcm9tIHRoaXMgc3RyZWFtLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b01hcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvTWFwKCkge1xuICAgICAgICByZXR1cm4gbmV3IG1hcCh0aGlzLl9wYWlycyk7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogUmV0dXJuIGEgc2V0IGNvbnRhaW5pbmcgYWxsIHRoZSAodW5pcXVlKSBpZHMgaW4gdGhpcyBzdHJlYW0uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSBzZXQgb2YgYWxsIGlkcyBmcm9tIHRoaXMgc3RyZWFtLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b0lkU2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9JZFNldCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBzZXQodGhpcy50b0lkQXJyYXkoKSk7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogUmV0dXJuIGEgc2V0IGNvbnRhaW5pbmcgYWxsIHRoZSAodW5pcXVlKSBpdGVtcyBpbiB0aGlzIHN0cmVhbS5cclxuICAgICAgICpcclxuICAgICAgICogQHJldHVybnMgVGhlIHNldCBvZiBhbGwgaXRlbXMgZnJvbSB0aGlzIHN0cmVhbS5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidG9JdGVtU2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9JdGVtU2V0KCkge1xuICAgICAgICByZXR1cm4gbmV3IHNldCh0aGlzLnRvSXRlbUFycmF5KCkpO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIENhY2hlIHRoZSBpdGVtcyBmcm9tIHRoaXMgc3RyZWFtLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmVtYXJrc1xyXG4gICAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIGl0ZW1zIHRvIGJlIGZldGNoZWQgaW1tZWRpYXRlbGx5IGFuZCB1c2VkIChwb3NzaWJseSBtdWx0aXBsZSB0aW1lcykgbGF0ZXIuXHJcbiAgICAgICAqIEl0IGNhbiBhbHNvIGJlIHVzZWQgdG8gb3B0aW1pemUgcGVyZm9ybWFuY2UgYXMgW1tEYXRhU3RyZWFtXV0gd291bGQgb3RoZXJ3aXNlIHJlZXZhbHVhdGUgZXZlcnl0aGluZyB1cG9uIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAjIyBFeGFtcGxlXHJcbiAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICogY29uc3QgZHMgPSBuZXcgRGF0YVNldChb4oCmXSlcclxuICAgICAgICpcclxuICAgICAgICogY29uc3QgY2FjaGVkU3RyZWFtID0gZHMuc3RyZWFtKClcclxuICAgICAgICogICAuZmlsdGVyKOKApilcclxuICAgICAgICogICAuc29ydCjigKYpXHJcbiAgICAgICAqICAgLm1hcCjigKYpXHJcbiAgICAgICAqICAgLmNhY2hlZCjigKYpIC8vIERhdGEgYXJlIGZldGNoZWQsIHByb2Nlc3NlZCBhbmQgY2FjaGVkIGhlcmUuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIGRzLmNsZWFyKClcclxuICAgICAgICogY2hhY2hlZFN0cmVhbSAvLyBTdGlsbCBoYXMgYWxsIHRoZSBpdGVtcy5cclxuICAgICAgICogYGBgXHJcbiAgICAgICAqIEByZXR1cm5zIEEgbmV3IFtbRGF0YVN0cmVhbV1dIHdpdGggY2FjaGVkIGl0ZW1zIChkZXRhY2hlZCBmcm9tIHRoZSBvcmlnaW5hbCBbW0RhdGFTZXRdXSkuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImNhY2hlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2FjaGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbShfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fcGFpcnMpKTtcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBHZXQgdGhlIGRpc3RpbmN0IHZhbHVlcyBvZiBnaXZlbiBwcm9wZXJ0eS5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRoYXQgcGlja3MgYW5kIHBvc3NpYmx5IGNvbnZlcnRzIHRoZSBwcm9wZXJ0eS5cclxuICAgICAgICogQHR5cGVQYXJhbSBUIC0gVGhlIHR5cGUgb2YgdGhlIGRpc3RpbmN0IHZhbHVlLlxyXG4gICAgICAgKiBAcmV0dXJucyBBIHNldCBvZiBhbGwgZGlzdGluY3QgcHJvcGVydGllcy5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGlzdGluY3RcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0aW5jdChjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2V0JDEgPSBuZXcgc2V0KCk7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKHRoaXMuX3BhaXJzKSxcbiAgICAgICAgICAgIF9zdGVwNjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgX3N0ZXA2JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA2LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICBpZCA9IF9zdGVwNiR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICBpdGVtID0gX3N0ZXA2JHZhbHVlWzFdO1xuXG4gICAgICAgICAgICBzZXQkMS5hZGQoY2FsbGJhY2soaXRlbSwgaWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNldCQxO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIEZpbHRlciB0aGUgaXRlbXMgb2YgdGhlIHN0cmVhbS5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRoYXQgZGVjaWRlcyB3aGV0aGVyIGFuIGl0ZW0gd2lsbCBiZSBpbmNsdWRlZC5cclxuICAgICAgICogQHJldHVybnMgQSBuZXcgZGF0YSBzdHJlYW0gd2l0aCB0aGUgZmlsdGVyZWQgaXRlbXMuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImZpbHRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFjaykge1xuICAgICAgICB2YXIgcGFpcnMgPSB0aGlzLl9wYWlycztcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhU3RyZWFtKF9kZWZpbmVQcm9wZXJ0eSh7fSwgaXRlcmF0b3IsIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjcsIF9zdGVwNywgX3N0ZXA3JHZhbHVlLCBpZCwgaXRlbTtcblxuICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0Nykge1xuICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIocGFpcnMpO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAxO1xuXG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3I3LnMoKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgIGlmICgoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIF9zdGVwNyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNy52YWx1ZSwgMiksIGlkID0gX3N0ZXA3JHZhbHVlWzBdLCBpdGVtID0gX3N0ZXA3JHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKGl0ZW0sIGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2lkLCBpdGVtXTtcblxuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDEyO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3LnQwID0gX2NvbnRleHQ3W1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjcuZShfY29udGV4dDcudDApO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMTU7XG5cbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjcuZigpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmZpbmlzaCgxNSk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1sxLCAxMiwgMTUsIDE4XV0pO1xuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZWFjaCBpdGVtIG9mIHRoZSBzdHJlYW0uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCBmb3IgZWFjaCBpdGVtLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmb3JFYWNoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIodGhpcy5fcGFpcnMpLFxuICAgICAgICAgICAgX3N0ZXA4O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3I4LnMoKTsgIShfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBfc3RlcDgkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDgudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgIGlkID0gX3N0ZXA4JHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIGl0ZW0gPSBfc3RlcDgkdmFsdWVbMV07XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjguZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjguZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogTWFwIHRoZSBpdGVtcyBpbnRvIGEgZGlmZmVyZW50IHR5cGUuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IGRvZXMgdGhlIGNvbnZlcnNpb24uXHJcbiAgICAgICAqIEB0eXBlUGFyYW0gTWFwcGVkIC0gVGhlIHR5cGUgb2YgdGhlIGl0ZW0gYWZ0ZXIgbWFwcGluZy5cclxuICAgICAgICogQHJldHVybnMgQSBuZXcgZGF0YSBzdHJlYW0gd2l0aCB0aGUgbWFwcGVkIGl0ZW1zLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHBhaXJzID0gdGhpcy5fcGFpcnM7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbShfZGVmaW5lUHJvcGVydHkoe30sIGl0ZXJhdG9yLCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yOSwgX3N0ZXA5LCBfc3RlcDkkdmFsdWUsIGlkLCBpdGVtO1xuXG4gICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0OCkge1xuICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIocGFpcnMpO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAxO1xuXG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3I5LnMoKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgIGlmICgoX3N0ZXA5ID0gX2l0ZXJhdG9yOS5uKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX3N0ZXA5JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA5LnZhbHVlLCAyKSwgaWQgPSBfc3RlcDkkdmFsdWVbMF0sIGl0ZW0gPSBfc3RlcDkkdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2lkLCBjYWxsYmFjayhpdGVtLCBpZCldO1xuXG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAxMTtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC50MCA9IF9jb250ZXh0OFtcImNhdGNoXCJdKDEpO1xuXG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3I5LmUoX2NvbnRleHQ4LnQwKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgucHJldiA9IDE0O1xuXG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3I5LmYoKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5maW5pc2goMTQpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUyLCBudWxsLCBbWzEsIDExLCAxNCwgMTddXSk7XG4gICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogR2V0IHRoZSBpdGVtIHdpdGggdGhlIG1heGltdW0gdmFsdWUgb2YgZ2l2ZW4gcHJvcGVydHkuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IHBpY2tzIGFuZCBwb3NzaWJseSBjb252ZXJ0cyB0aGUgcHJvcGVydHkuXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSBpdGVtIHdpdGggdGhlIG1heGltdW0gaWYgZm91bmQgb3RoZXJ3aXNlIG51bGwuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1heFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1heChjYWxsYmFjaykge1xuICAgICAgICB2YXIgaXRlciA9IGdldEl0ZXJhdG9yKHRoaXMuX3BhaXJzKTtcblxuICAgICAgICB2YXIgY3VyciA9IGl0ZXIubmV4dCgpO1xuXG4gICAgICAgIGlmIChjdXJyLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXhJdGVtID0gY3Vyci52YWx1ZVsxXTtcbiAgICAgICAgdmFyIG1heFZhbHVlID0gY2FsbGJhY2soY3Vyci52YWx1ZVsxXSwgY3Vyci52YWx1ZVswXSk7XG5cbiAgICAgICAgd2hpbGUgKCEoY3VyciA9IGl0ZXIubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgdmFyIF9jdXJyJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoY3Vyci52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIGlkID0gX2N1cnIkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIGl0ZW0gPSBfY3VyciR2YWx1ZVsxXTtcblxuICAgICAgICAgIHZhciBfdmFsdWUgPSBjYWxsYmFjayhpdGVtLCBpZCk7XG5cbiAgICAgICAgICBpZiAoX3ZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgIG1heFZhbHVlID0gX3ZhbHVlO1xuICAgICAgICAgICAgbWF4SXRlbSA9IGl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heEl0ZW07XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogR2V0IHRoZSBpdGVtIHdpdGggdGhlIG1pbmltdW0gdmFsdWUgb2YgZ2l2ZW4gcHJvcGVydHkuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IHBpY2tzIGFuZCBwb3NzaWJseSBjb252ZXJ0cyB0aGUgcHJvcGVydHkuXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSBpdGVtIHdpdGggdGhlIG1pbmltdW0gaWYgZm91bmQgb3RoZXJ3aXNlIG51bGwuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1pblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1pbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgaXRlciA9IGdldEl0ZXJhdG9yKHRoaXMuX3BhaXJzKTtcblxuICAgICAgICB2YXIgY3VyciA9IGl0ZXIubmV4dCgpO1xuXG4gICAgICAgIGlmIChjdXJyLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5JdGVtID0gY3Vyci52YWx1ZVsxXTtcbiAgICAgICAgdmFyIG1pblZhbHVlID0gY2FsbGJhY2soY3Vyci52YWx1ZVsxXSwgY3Vyci52YWx1ZVswXSk7XG5cbiAgICAgICAgd2hpbGUgKCEoY3VyciA9IGl0ZXIubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgdmFyIF9jdXJyJHZhbHVlMiA9IF9zbGljZWRUb0FycmF5KGN1cnIudmFsdWUsIDIpLFxuICAgICAgICAgICAgICBpZCA9IF9jdXJyJHZhbHVlMlswXSxcbiAgICAgICAgICAgICAgaXRlbSA9IF9jdXJyJHZhbHVlMlsxXTtcblxuICAgICAgICAgIHZhciBfdmFsdWUyID0gY2FsbGJhY2soaXRlbSwgaWQpO1xuXG4gICAgICAgICAgaWYgKF92YWx1ZTIgPCBtaW5WYWx1ZSkge1xuICAgICAgICAgICAgbWluVmFsdWUgPSBfdmFsdWUyO1xuICAgICAgICAgICAgbWluSXRlbSA9IGl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1pbkl0ZW07XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogUmVkdWNlIHRoZSBpdGVtcyBpbnRvIGEgc2luZ2xlIHZhbHVlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdGhhdCBkb2VzIHRoZSByZWR1Y3Rpb24uXHJcbiAgICAgICAqIEBwYXJhbSBhY2N1bXVsYXRvciAtIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cclxuICAgICAgICogQHR5cGVQYXJhbSBUIC0gVGhlIHR5cGUgb2YgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgcmVkdWNlZCB2YWx1ZS5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVkdWNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrLCBhY2N1bXVsYXRvcikge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yMTAgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKHRoaXMuX3BhaXJzKSxcbiAgICAgICAgICAgIF9zdGVwMTA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjEwLnMoKTsgIShfc3RlcDEwID0gX2l0ZXJhdG9yMTAubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIF9zdGVwMTAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDEwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICBpZCA9IF9zdGVwMTAkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgaXRlbSA9IF9zdGVwMTAkdmFsdWVbMV07XG5cbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIGl0ZW0sIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjEwLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IxMC5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogU29ydCB0aGUgaXRlbXMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEl0ZW0gY29tcGFyYXRvci5cclxuICAgICAgICogQHJldHVybnMgQSBuZXcgc3RyZWFtIHdpdGggc29ydGVkIGl0ZW1zLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzb3J0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc29ydCQxKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhU3RyZWFtKF9kZWZpbmVQcm9wZXJ0eSh7fSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQ5O1xuXG4gICAgICAgICAgcmV0dXJuIGdldEl0ZXJhdG9yKHNvcnQoX2NvbnRleHQ5ID0gX3RvQ29uc3VtYWJsZUFycmF5KF90aGlzLl9wYWlycykpLmNhbGwoX2NvbnRleHQ5LCBmdW5jdGlvbiAoX3JlZiwgX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciBfcmVmMyA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgICAgIGlkQSA9IF9yZWYzWzBdLFxuICAgICAgICAgICAgICAgIGl0ZW1BID0gX3JlZjNbMV07XG5cbiAgICAgICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYyLCAyKSxcbiAgICAgICAgICAgICAgICBpZEIgPSBfcmVmNFswXSxcbiAgICAgICAgICAgICAgICBpdGVtQiA9IF9yZWY0WzFdO1xuXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soaXRlbUEsIGl0ZW1CLCBpZEEsIGlkQik7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERhdGFTdHJlYW07XG4gIH0oKTtcblxuICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBrZXlzJDQob2JqZWN0KTsgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IGZpbHRlcihzeW1ib2xzKS5jYWxsKHN5bWJvbHMsIGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgX2NvbnRleHQxMCwgX2NvbnRleHQxMTsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gZm9yRWFjaCQxKF9jb250ZXh0MTAgPSBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkpLmNhbGwoX2NvbnRleHQxMCwgZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBmb3JFYWNoJDEoX2NvbnRleHQxMSA9IG93bktleXMoT2JqZWN0KHNvdXJjZSkpKS5jYWxsKF9jb250ZXh0MTEsIGZ1bmN0aW9uIChrZXkpIHsgZGVmaW5lUHJvcGVydHkkNCh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuICBmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBzeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoaXNBcnJheSQxKG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQxKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0OTsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDEobywgbWluTGVuKTsgdmFyIG4gPSBzbGljZShfY29udGV4dDkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQ5LCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tJDMobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMShvLCBtaW5MZW4pOyB9XG5cbiAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuICBmdW5jdGlvbiBfY3JlYXRlU3VwZXIkMShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbiAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbiAgLyoqXHJcbiAgICogQWRkIGFuIGlkIHRvIGdpdmVuIGl0ZW0gaWYgaXQgZG9lc24ndCBoYXZlIG9uZSBhbHJlYWR5LlxyXG4gICAqXHJcbiAgICogQHJlbWFya3NcclxuICAgKiBUaGUgaXRlbSB3aWxsIGJlIG1vZGlmaWVkLlxyXG4gICAqIEBwYXJhbSBpdGVtIC0gVGhlIGl0ZW0gdGhhdCB3aWxsIGhhdmUgYW4gaWQgYWZ0ZXIgYSBjYWxsIHRvIHRoaXMgZnVuY3Rpb24uXHJcbiAgICogQHBhcmFtIGlkUHJvcCAtIFRoZSBrZXkgb2YgdGhlIGlkIHByb3BlcnR5LlxyXG4gICAqIEB0eXBlUGFyYW0gSXRlbSAtIEl0ZW0gdHlwZSB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgYW4gaWQuXHJcbiAgICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpZC5cclxuICAgKiBAcmV0dXJucyB0cnVlXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gZW5zdXJlRnVsbEl0ZW0oaXRlbSwgaWRQcm9wKSB7XG4gICAgaWYgKGl0ZW1baWRQcm9wXSA9PSBudWxsKSB7XG4gICAgICAvLyBnZW5lcmF0ZSBhbiBpZFxuICAgICAgaXRlbVtpZFByb3BdID0gdjQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuICAvKipcclxuICAgKiAjIERhdGFTZXRcclxuICAgKlxyXG4gICAqIFZpcy5qcyBjb21lcyB3aXRoIGEgZmxleGlibGUgRGF0YVNldCwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gaG9sZCBhbmRcclxuICAgKiBtYW5pcHVsYXRlIHVuc3RydWN0dXJlZCBkYXRhIGFuZCBsaXN0ZW4gZm9yIGNoYW5nZXMgaW4gdGhlIGRhdGEuIFRoZSBEYXRhU2V0XHJcbiAgICogaXMga2V5L3ZhbHVlIGJhc2VkLiBEYXRhIGl0ZW1zIGNhbiBiZSBhZGRlZCwgdXBkYXRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZVxyXG4gICAqIERhdGFTZXQsIGFuZCBvbmUgY2FuIHN1YnNjcmliZSB0byBjaGFuZ2VzIGluIHRoZSBEYXRhU2V0LiBUaGUgZGF0YSBpbiB0aGVcclxuICAgKiBEYXRhU2V0IGNhbiBiZSBmaWx0ZXJlZCBhbmQgb3JkZXJlZC4gRGF0YSBjYW4gYmUgbm9ybWFsaXplZCB3aGVuIGFwcGVuZGluZyBpdFxyXG4gICAqIHRvIHRoZSBEYXRhU2V0IGFzIHdlbGwuXHJcbiAgICpcclxuICAgKiAjIyBFeGFtcGxlXHJcbiAgICpcclxuICAgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIHVzZSBhIERhdGFTZXQuXHJcbiAgICpcclxuICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICogLy8gY3JlYXRlIGEgRGF0YVNldFxyXG4gICAqIHZhciBvcHRpb25zID0ge307XHJcbiAgICogdmFyIGRhdGEgPSBuZXcgdmlzLkRhdGFTZXQob3B0aW9ucyk7XHJcbiAgICpcclxuICAgKiAvLyBhZGQgaXRlbXNcclxuICAgKiAvLyBub3RlIHRoYXQgdGhlIGRhdGEgaXRlbXMgY2FuIGNvbnRhaW4gZGlmZmVyZW50IHByb3BlcnRpZXMgYW5kIGRhdGEgZm9ybWF0c1xyXG4gICAqIGRhdGEuYWRkKFtcclxuICAgKiAgIHtpZDogMSwgdGV4dDogJ2l0ZW0gMScsIGRhdGU6IG5ldyBEYXRlKDIwMTMsIDYsIDIwKSwgZ3JvdXA6IDEsIGZpcnN0OiB0cnVlfSxcclxuICAgKiAgIHtpZDogMiwgdGV4dDogJ2l0ZW0gMicsIGRhdGU6ICcyMDEzLTA2LTIzJywgZ3JvdXA6IDJ9LFxyXG4gICAqICAge2lkOiAzLCB0ZXh0OiAnaXRlbSAzJywgZGF0ZTogJzIwMTMtMDYtMjUnLCBncm91cDogMn0sXHJcbiAgICogICB7aWQ6IDQsIHRleHQ6ICdpdGVtIDQnfVxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gc3Vic2NyaWJlIHRvIGFueSBjaGFuZ2UgaW4gdGhlIERhdGFTZXRcclxuICAgKiBkYXRhLm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50LCBwcm9wZXJ0aWVzLCBzZW5kZXJJZCkge1xyXG4gICAqICAgY29uc29sZS5sb2coJ2V2ZW50JywgZXZlbnQsIHByb3BlcnRpZXMpO1xyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogLy8gdXBkYXRlIGFuIGV4aXN0aW5nIGl0ZW1cclxuICAgKiBkYXRhLnVwZGF0ZSh7aWQ6IDIsIGdyb3VwOiAxfSk7XHJcbiAgICpcclxuICAgKiAvLyByZW1vdmUgYW4gaXRlbVxyXG4gICAqIGRhdGEucmVtb3ZlKDQpO1xyXG4gICAqXHJcbiAgICogLy8gZ2V0IGFsbCBpZHNcclxuICAgKiB2YXIgaWRzID0gZGF0YS5nZXRJZHMoKTtcclxuICAgKiBjb25zb2xlLmxvZygnaWRzJywgaWRzKTtcclxuICAgKlxyXG4gICAqIC8vIGdldCBhIHNwZWNpZmljIGl0ZW1cclxuICAgKiB2YXIgaXRlbTEgPSBkYXRhLmdldCgxKTtcclxuICAgKiBjb25zb2xlLmxvZygnaXRlbTEnLCBpdGVtMSk7XHJcbiAgICpcclxuICAgKiAvLyByZXRyaWV2ZSBhIGZpbHRlcmVkIHN1YnNldCBvZiB0aGUgZGF0YVxyXG4gICAqIHZhciBpdGVtcyA9IGRhdGEuZ2V0KHtcclxuICAgKiAgIGZpbHRlcjogZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgKiAgICAgcmV0dXJuIGl0ZW0uZ3JvdXAgPT0gMTtcclxuICAgKiAgIH1cclxuICAgKiB9KTtcclxuICAgKiBjb25zb2xlLmxvZygnZmlsdGVyZWQgaXRlbXMnLCBpdGVtcyk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxyXG4gICAqIEB0eXBlUGFyYW0gSWRQcm9wIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGUgaWQuXHJcbiAgICovXG5cblxuICB2YXIgRGF0YVNldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0RhdGFTZXRQYXJ0KSB7XG4gICAgX2luaGVyaXRzKERhdGFTZXQsIF9EYXRhU2V0UGFydCk7XG5cbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDEoRGF0YVNldCk7XG5cbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBEYXRhU2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkYXRhIC0gSW5pdGlhbCBkYXRhIG9yIG9wdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgKHR5cGUgZXJyb3IgaWYgZGF0YSBpcyBhbHNvIG9wdGlvbnMpLlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGF0YVNldChkYXRhLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhU2V0KTtcblxuICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTsgLy8gY29ycmVjdGx5IHJlYWQgb3B0aW9uYWwgYXJndW1lbnRzXG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJmbHVzaFwiLCB2b2lkIDApO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibGVuZ3RoXCIsIHZvaWQgMCk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfb3B0aW9uc1wiLCB2b2lkIDApO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX2RhdGFcIiwgdm9pZCAwKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9pZFByb3BcIiwgdm9pZCAwKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9xdWV1ZVwiLCBudWxsKTtcblxuICAgICAgaWYgKGRhdGEgJiYgIWlzQXJyYXkkMShkYXRhKSkge1xuICAgICAgICBvcHRpb25zID0gZGF0YTtcbiAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBfdGhpcy5fZGF0YSA9IG5ldyBtYXAoKTsgLy8gbWFwIHdpdGggZGF0YSBpbmRleGVkIGJ5IGlkXG5cbiAgICAgIF90aGlzLmxlbmd0aCA9IDA7IC8vIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgRGF0YVNldFxuXG4gICAgICBfdGhpcy5faWRQcm9wID0gX3RoaXMuX29wdGlvbnMuZmllbGRJZCB8fCBcImlkXCI7IC8vIG5hbWUgb2YgdGhlIGZpZWxkIGNvbnRhaW5pbmcgaWRcbiAgICAgIC8vIGFkZCBpbml0aWFsIGRhdGEgd2hlbiBwcm92aWRlZFxuXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCkge1xuICAgICAgICBfdGhpcy5hZGQoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbmV3IG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgbmV3IG9wdGlvbnMuXHJcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKERhdGFTZXQsIFt7XG4gICAgICBrZXk6IFwiaWRQcm9wXCIsXG4gICAgICBnZXQ6XG4gICAgICAvKiogRmx1c2ggYWxsIHF1ZXVlZCBjYWxscy4gKi9cblxuICAgICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWRQcm9wO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucXVldWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLnF1ZXVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gZGVsZXRlIHF1ZXVlIGlmIGxvYWRlZFxuICAgICAgICAgICAgaWYgKHRoaXMuX3F1ZXVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3F1ZXVlLmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgICB0aGlzLl9xdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBxdWV1ZSBhbmQgdXBkYXRlIGl0cyBvcHRpb25zXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3F1ZXVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3F1ZXVlID0gUXVldWUuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlOiBbXCJhZGRcIiwgXCJ1cGRhdGVcIiwgXCJyZW1vdmVcIl1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnF1ZXVlICYmIF90eXBlb2Yob3B0aW9ucy5xdWV1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcXVldWUuc2V0T3B0aW9ucyhvcHRpb25zLnF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBBZGQgYSBkYXRhIGl0ZW0gb3IgYW4gYXJyYXkgd2l0aCBpdGVtcy5cclxuICAgICAgICpcclxuICAgICAgICogQWZ0ZXIgdGhlIGl0ZW1zIGFyZSBhZGRlZCB0byB0aGUgRGF0YVNldCwgdGhlIERhdGFTZXQgd2lsbCB0cmlnZ2VyIGFuIGV2ZW50IGBhZGRgLiBXaGVuIGEgYHNlbmRlcklkYCBpcyBwcm92aWRlZCwgdGhpcyBpZCB3aWxsIGJlIHBhc3NlZCB3aXRoIHRoZSB0cmlnZ2VyZWQgZXZlbnQgdG8gYWxsIHN1YnNjcmliZXJzLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAjIyBFeGFtcGxlXHJcbiAgICAgICAqXHJcbiAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICogLy8gY3JlYXRlIGEgRGF0YVNldFxyXG4gICAgICAgKiBjb25zdCBkYXRhID0gbmV3IHZpcy5EYXRhU2V0KClcclxuICAgICAgICpcclxuICAgICAgICogLy8gYWRkIGl0ZW1zXHJcbiAgICAgICAqIGNvbnN0IGlkcyA9IGRhdGEuYWRkKFtcclxuICAgICAgICogICB7IGlkOiAxLCB0ZXh0OiAnaXRlbSAxJyB9LFxyXG4gICAgICAgKiAgIHsgaWQ6IDIsIHRleHQ6ICdpdGVtIDInIH0sXHJcbiAgICAgICAqICAgeyB0ZXh0OiAnaXRlbSB3aXRob3V0IGFuIGlkJyB9XHJcbiAgICAgICAqIF0pXHJcbiAgICAgICAqXHJcbiAgICAgICAqIGNvbnNvbGUubG9nKGlkcykgLy8gWzEsIDIsICc8VVVJRHY0PiddXHJcbiAgICAgICAqIGBgYFxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gZGF0YSAtIEl0ZW1zIHRvIGJlIGFkZGVkIChpZHMgd2lsbCBiZSBnZW5lcmF0ZWQgaWYgbWlzc2luZykuXHJcbiAgICAgICAqIEBwYXJhbSBzZW5kZXJJZCAtIFNlbmRlciBpZC5cclxuICAgICAgICogQHJldHVybnMgYWRkZWRJZHMgLSBBcnJheSB3aXRoIHRoZSBpZHMgKGdlbmVyYXRlZCBpZiBub3QgcHJlc2VudCkgb2YgdGhlIGFkZGVkIGl0ZW1zLlxyXG4gICAgICAgKiBAdGhyb3dzIFdoZW4gYW4gaXRlbSB3aXRoIHRoZSBzYW1lIGlkIGFzIGFueSBvZiB0aGUgYWRkZWQgaXRlbXMgYWxyZWFkeSBleGlzdHMuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChkYXRhLCBzZW5kZXJJZCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgYWRkZWRJZHMgPSBbXTtcbiAgICAgICAgdmFyIGlkO1xuXG4gICAgICAgIGlmIChpc0FycmF5JDEoZGF0YSkpIHtcbiAgICAgICAgICAvLyBBcnJheVxuICAgICAgICAgIHZhciBpZHNUb0FkZCA9IG1hcCQzKGRhdGEpLmNhbGwoZGF0YSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkW190aGlzMi5faWRQcm9wXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChzb21lKGlkc1RvQWRkKS5jYWxsKGlkc1RvQWRkLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuX2RhdGEuaGFzKGlkKTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBkdXBsaWNhdGUgaWQgd2FzIGZvdW5kIGluIHRoZSBwYXJhbWV0ZXIgYXJyYXkuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZCA9IHRoaXMuX2FkZEl0ZW0oZGF0YVtpXSk7XG4gICAgICAgICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSAmJiBfdHlwZW9mKGRhdGEpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgLy8gU2luZ2xlIGl0ZW1cbiAgICAgICAgICBpZCA9IHRoaXMuX2FkZEl0ZW0oZGF0YSk7XG4gICAgICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhVHlwZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyKFwiYWRkXCIsIHtcbiAgICAgICAgICAgIGl0ZW1zOiBhZGRlZElkc1xuICAgICAgICAgIH0sIHNlbmRlcklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhZGRlZElkcztcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBVcGRhdGUgZXhpc3RpbmcgaXRlbXMuIFdoZW4gYW4gaXRlbSBkb2VzIG5vdCBleGlzdCwgaXQgd2lsbCBiZSBjcmVhdGVkLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmVtYXJrc1xyXG4gICAgICAgKiBUaGUgcHJvdmlkZWQgcHJvcGVydGllcyB3aWxsIGJlIG1lcmdlZCBpbiB0aGUgZXhpc3RpbmcgaXRlbS4gV2hlbiBhbiBpdGVtIGRvZXMgbm90IGV4aXN0LCBpdCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEFmdGVyIHRoZSBpdGVtcyBhcmUgdXBkYXRlZCwgdGhlIERhdGFTZXQgd2lsbCB0cmlnZ2VyIGFuIGV2ZW50IGBhZGRgIGZvciB0aGUgYWRkZWQgaXRlbXMsIGFuZCBhbiBldmVudCBgdXBkYXRlYC4gV2hlbiBhIGBzZW5kZXJJZGAgaXMgcHJvdmlkZWQsIHRoaXMgaWQgd2lsbCBiZSBwYXNzZWQgd2l0aCB0aGUgdHJpZ2dlcmVkIGV2ZW50IHRvIGFsbCBzdWJzY3JpYmVycy5cclxuICAgICAgICpcclxuICAgICAgICogIyMgRXhhbXBsZVxyXG4gICAgICAgKlxyXG4gICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAqIC8vIGNyZWF0ZSBhIERhdGFTZXRcclxuICAgICAgICogY29uc3QgZGF0YSA9IG5ldyB2aXMuRGF0YVNldChbXHJcbiAgICAgICAqICAgeyBpZDogMSwgdGV4dDogJ2l0ZW0gMScgfSxcclxuICAgICAgICogICB7IGlkOiAyLCB0ZXh0OiAnaXRlbSAyJyB9LFxyXG4gICAgICAgKiAgIHsgaWQ6IDMsIHRleHQ6ICdpdGVtIDMnIH1cclxuICAgICAgICogXSlcclxuICAgICAgICpcclxuICAgICAgICogLy8gdXBkYXRlIGl0ZW1zXHJcbiAgICAgICAqIGNvbnN0IGlkcyA9IGRhdGEudXBkYXRlKFtcclxuICAgICAgICogICB7IGlkOiAyLCB0ZXh0OiAnaXRlbSAyICh1cGRhdGVkKScgfSxcclxuICAgICAgICogICB7IGlkOiA0LCB0ZXh0OiAnaXRlbSA0IChuZXcpJyB9XHJcbiAgICAgICAqIF0pXHJcbiAgICAgICAqXHJcbiAgICAgICAqIGNvbnNvbGUubG9nKGlkcykgLy8gWzIsIDRdXHJcbiAgICAgICAqIGBgYFxyXG4gICAgICAgKlxyXG4gICAgICAgKiAjIyBXYXJuaW5nIGZvciBUeXBlU2NyaXB0IHVzZXJzXHJcbiAgICAgICAqIFRoaXMgbWV0aG9kIG1heSBpbnRyb2R1Y2UgcGFydGlhbCBpdGVtcyBpbnRvIHRoZSBkYXRhIHNldC4gVXNlIGFkZCBvciB1cGRhdGVPbmx5IGluc3RlYWQgZm9yIGJldHRlciB0eXBlIHNhZmV0eS5cclxuICAgICAgICogQHBhcmFtIGRhdGEgLSBJdGVtcyB0byBiZSB1cGRhdGVkIChpZiB0aGUgaWQgaXMgYWxyZWFkeSBwcmVzZW50KSBvciBhZGRlZCAoaWYgdGhlIGlkIGlzIG1pc3NpbmcpLlxyXG4gICAgICAgKiBAcGFyYW0gc2VuZGVySWQgLSBTZW5kZXIgaWQuXHJcbiAgICAgICAqIEByZXR1cm5zIHVwZGF0ZWRJZHMgLSBUaGUgaWRzIG9mIHRoZSBhZGRlZCAodGhlc2UgbWF5IGJlIG5ld2x5IGdlbmVyYXRlZCBpZiB0aGVyZSB3YXMgbm8gaWQgaW4gdGhlIGl0ZW0gZnJvbSB0aGUgZGF0YSkgb3IgdXBkYXRlZCBpdGVtcy5cclxuICAgICAgICogQHRocm93cyBXaGVuIHRoZSBzdXBwbGllZCBkYXRhIGlzIG5laXRoZXIgYW4gaXRlbSBub3IgYW4gYXJyYXkgb2YgaXRlbXMuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInVwZGF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShkYXRhLCBzZW5kZXJJZCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB2YXIgYWRkZWRJZHMgPSBbXTtcbiAgICAgICAgdmFyIHVwZGF0ZWRJZHMgPSBbXTtcbiAgICAgICAgdmFyIG9sZERhdGEgPSBbXTtcbiAgICAgICAgdmFyIHVwZGF0ZWREYXRhID0gW107XG4gICAgICAgIHZhciBpZFByb3AgPSB0aGlzLl9pZFByb3A7XG5cbiAgICAgICAgdmFyIGFkZE9yVXBkYXRlID0gZnVuY3Rpb24gYWRkT3JVcGRhdGUoaXRlbSkge1xuICAgICAgICAgIHZhciBvcmlnSWQgPSBpdGVtW2lkUHJvcF07XG5cbiAgICAgICAgICBpZiAob3JpZ0lkICE9IG51bGwgJiYgX3RoaXMzLl9kYXRhLmhhcyhvcmlnSWQpKSB7XG4gICAgICAgICAgICB2YXIgZnVsbEl0ZW0gPSBpdGVtOyAvLyBpdCBoYXMgYW4gaWQsIHRoZXJlZm9yZSBpdCBpcyBhIGZ1bGxpdGVtXG5cbiAgICAgICAgICAgIHZhciBvbGRJdGVtID0gYXNzaWduJDIoe30sIF90aGlzMy5fZGF0YS5nZXQob3JpZ0lkKSk7IC8vIHVwZGF0ZSBpdGVtXG5cblxuICAgICAgICAgICAgdmFyIGlkID0gX3RoaXMzLl91cGRhdGVJdGVtKGZ1bGxJdGVtKTtcblxuICAgICAgICAgICAgdXBkYXRlZElkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgIHVwZGF0ZWREYXRhLnB1c2goZnVsbEl0ZW0pO1xuICAgICAgICAgICAgb2xkRGF0YS5wdXNoKG9sZEl0ZW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBhZGQgbmV3IGl0ZW1cbiAgICAgICAgICAgIHZhciBfaWQgPSBfdGhpczMuX2FkZEl0ZW0oaXRlbSk7XG5cbiAgICAgICAgICAgIGFkZGVkSWRzLnB1c2goX2lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlzQXJyYXkkMShkYXRhKSkge1xuICAgICAgICAgIC8vIEFycmF5XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkYXRhW2ldICYmIF90eXBlb2YoZGF0YVtpXSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgYWRkT3JVcGRhdGUoZGF0YVtpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJJZ25vcmluZyBpbnB1dCBpdGVtLCB3aGljaCBpcyBub3QgYW4gb2JqZWN0IGF0IGluZGV4IFwiICsgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgJiYgX3R5cGVvZihkYXRhKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIC8vIFNpbmdsZSBpdGVtXG4gICAgICAgICAgYWRkT3JVcGRhdGUoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhVHlwZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyKFwiYWRkXCIsIHtcbiAgICAgICAgICAgIGl0ZW1zOiBhZGRlZElkc1xuICAgICAgICAgIH0sIHNlbmRlcklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cGRhdGVkSWRzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICAgIGl0ZW1zOiB1cGRhdGVkSWRzLFxuICAgICAgICAgICAgb2xkRGF0YTogb2xkRGF0YSxcbiAgICAgICAgICAgIGRhdGE6IHVwZGF0ZWREYXRhXG4gICAgICAgICAgfTsgLy8gVE9ETzogcmVtb3ZlIGRlcHJlY2F0ZWQgcHJvcGVydHkgJ2RhdGEnIHNvbWUgZGF5XG4gICAgICAgICAgLy9PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdkYXRhJywge1xuICAgICAgICAgIC8vICAnZ2V0JzogKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vICAgIGNvbnNvbGUud2FybignUHJvcGVydHkgZGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgRGF0YVNldC5nZXQoaWRzKSB0byByZXRyaWV2ZSB0aGUgbmV3IGRhdGEsIHVzZSB0aGUgb2xkRGF0YSBwcm9wZXJ0eSBvbiB0aGlzIG9iamVjdCB0byBnZXQgdGhlIG9sZCBkYXRhJyk7XG4gICAgICAgICAgLy8gICAgcmV0dXJuIHVwZGF0ZWREYXRhO1xuICAgICAgICAgIC8vICB9KS5iaW5kKHRoaXMpXG4gICAgICAgICAgLy99KTtcblxuICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXCJ1cGRhdGVcIiwgcHJvcHMsIHNlbmRlcklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25jYXQkMShhZGRlZElkcykuY2FsbChhZGRlZElkcywgdXBkYXRlZElkcyk7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogVXBkYXRlIGV4aXN0aW5nIGl0ZW1zLiBXaGVuIGFuIGl0ZW0gZG9lcyBub3QgZXhpc3QsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmVtYXJrc1xyXG4gICAgICAgKiBUaGUgcHJvdmlkZWQgcHJvcGVydGllcyB3aWxsIGJlIGRlZXBseSBtZXJnZWQgaW50byB0aGUgZXhpc3RpbmcgaXRlbS5cclxuICAgICAgICogV2hlbiBhbiBpdGVtIGRvZXMgbm90IGV4aXN0IChpZCBub3QgcHJlc2VudCBpbiB0aGUgZGF0YSBzZXQgb3IgYWJzZW50KSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gYW5kIG5vdGhpbmcgd2lsbCBiZSBjaGFuZ2VkLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBBZnRlciB0aGUgaXRlbXMgYXJlIHVwZGF0ZWQsIHRoZSBEYXRhU2V0IHdpbGwgdHJpZ2dlciBhbiBldmVudCBgdXBkYXRlYC5cclxuICAgICAgICogV2hlbiBhIGBzZW5kZXJJZGAgaXMgcHJvdmlkZWQsIHRoaXMgaWQgd2lsbCBiZSBwYXNzZWQgd2l0aCB0aGUgdHJpZ2dlcmVkIGV2ZW50IHRvIGFsbCBzdWJzY3JpYmVycy5cclxuICAgICAgICpcclxuICAgICAgICogIyMgRXhhbXBsZVxyXG4gICAgICAgKlxyXG4gICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAqIC8vIGNyZWF0ZSBhIERhdGFTZXRcclxuICAgICAgICogY29uc3QgZGF0YSA9IG5ldyB2aXMuRGF0YVNldChbXHJcbiAgICAgICAqICAgeyBpZDogMSwgdGV4dDogJ2l0ZW0gMScgfSxcclxuICAgICAgICogICB7IGlkOiAyLCB0ZXh0OiAnaXRlbSAyJyB9LFxyXG4gICAgICAgKiAgIHsgaWQ6IDMsIHRleHQ6ICdpdGVtIDMnIH0sXHJcbiAgICAgICAqIF0pXHJcbiAgICAgICAqXHJcbiAgICAgICAqIC8vIHVwZGF0ZSBpdGVtc1xyXG4gICAgICAgKiBjb25zdCBpZHMgPSBkYXRhLnVwZGF0ZShbXHJcbiAgICAgICAqICAgeyBpZDogMiwgdGV4dDogJ2l0ZW0gMiAodXBkYXRlZCknIH0sIC8vIHdvcmtzXHJcbiAgICAgICAqICAgLy8geyBpZDogNCwgdGV4dDogJ2l0ZW0gNCAobmV3KScgfSwgLy8gd291bGQgdGhyb3dcclxuICAgICAgICogICAvLyB7IHRleHQ6ICdpdGVtIDQgKG5ldyknIH0sIC8vIHdvdWxkIGFsc28gdGhyb3dcclxuICAgICAgICogXSlcclxuICAgICAgICpcclxuICAgICAgICogY29uc29sZS5sb2coaWRzKSAvLyBbMl1cclxuICAgICAgICogYGBgXHJcbiAgICAgICAqIEBwYXJhbSBkYXRhIC0gVXBkYXRlcyAodGhlIGlkIGFuZCBvcHRpb25hbGx5IG90aGVyIHByb3BzKSB0byB0aGUgaXRlbXMgaW4gdGhpcyBkYXRhIHNldC5cclxuICAgICAgICogQHBhcmFtIHNlbmRlcklkIC0gU2VuZGVyIGlkLlxyXG4gICAgICAgKiBAcmV0dXJucyB1cGRhdGVkSWRzIC0gVGhlIGlkcyBvZiB0aGUgdXBkYXRlZCBpdGVtcy5cclxuICAgICAgICogQHRocm93cyBXaGVuIHRoZSBzdXBwbGllZCBkYXRhIGlzIG5laXRoZXIgYW4gaXRlbSBub3IgYW4gYXJyYXkgb2YgaXRlbXMsIHdoZW4gdGhlIGlkcyBhcmUgbWlzc2luZy5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidXBkYXRlT25seVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU9ubHkoZGF0YSwgc2VuZGVySWQpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0LFxuICAgICAgICAgICAgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICBpZiAoIWlzQXJyYXkkMShkYXRhKSkge1xuICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXBkYXRlRXZlbnREYXRhID0gbWFwJDMoX2NvbnRleHQgPSBtYXAkMyhkYXRhKS5jYWxsKGRhdGEsIGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgICB2YXIgb2xkRGF0YSA9IF90aGlzNC5fZGF0YS5nZXQodXBkYXRlW190aGlzNC5faWRQcm9wXSk7XG5cbiAgICAgICAgICBpZiAob2xkRGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVcGRhdGluZyBub24tZXhpc3RlbnQgaXRlbXMgaXMgbm90IGFsbG93ZWQuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvbGREYXRhOiBvbGREYXRhLFxuICAgICAgICAgICAgdXBkYXRlOiB1cGRhdGVcbiAgICAgICAgICB9O1xuICAgICAgICB9KSkuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgb2xkRGF0YSA9IF9yZWYub2xkRGF0YSxcbiAgICAgICAgICAgICAgdXBkYXRlID0gX3JlZi51cGRhdGU7XG4gICAgICAgICAgdmFyIGlkID0gb2xkRGF0YVtfdGhpczQuX2lkUHJvcF07XG4gICAgICAgICAgdmFyIHVwZGF0ZWREYXRhID0gcHVyZURlZXBPYmplY3RBc3NpZ24ob2xkRGF0YSwgdXBkYXRlKTtcblxuICAgICAgICAgIF90aGlzNC5fZGF0YS5zZXQoaWQsIHVwZGF0ZWREYXRhKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBvbGREYXRhOiBvbGREYXRhLFxuICAgICAgICAgICAgdXBkYXRlZERhdGE6IHVwZGF0ZWREYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZUV2ZW50RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICBpdGVtczogbWFwJDModXBkYXRlRXZlbnREYXRhKS5jYWxsKHVwZGF0ZUV2ZW50RGF0YSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5pZDtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb2xkRGF0YTogbWFwJDModXBkYXRlRXZlbnREYXRhKS5jYWxsKHVwZGF0ZUV2ZW50RGF0YSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5vbGREYXRhO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkYXRhOiBtYXAkMyh1cGRhdGVFdmVudERhdGEpLmNhbGwodXBkYXRlRXZlbnREYXRhLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnVwZGF0ZWREYXRhO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9OyAvLyBUT0RPOiByZW1vdmUgZGVwcmVjYXRlZCBwcm9wZXJ0eSAnZGF0YScgc29tZSBkYXlcbiAgICAgICAgICAvL09iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2RhdGEnLCB7XG4gICAgICAgICAgLy8gICdnZXQnOiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gICAgY29uc29sZS53YXJuKCdQcm9wZXJ0eSBkYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBEYXRhU2V0LmdldChpZHMpIHRvIHJldHJpZXZlIHRoZSBuZXcgZGF0YSwgdXNlIHRoZSBvbGREYXRhIHByb3BlcnR5IG9uIHRoaXMgb2JqZWN0IHRvIGdldCB0aGUgb2xkIGRhdGEnKTtcbiAgICAgICAgICAvLyAgICByZXR1cm4gdXBkYXRlZERhdGE7XG4gICAgICAgICAgLy8gIH0pLmJpbmQodGhpcylcbiAgICAgICAgICAvL30pO1xuXG4gICAgICAgICAgdGhpcy5fdHJpZ2dlcihcInVwZGF0ZVwiLCBwcm9wcywgc2VuZGVySWQpO1xuXG4gICAgICAgICAgcmV0dXJuIHByb3BzLml0ZW1zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgLy8gQFRPRE86IFdvdWRuJ3QgaXQgYmUgYmV0dGVyIHRvIHNwbGl0IHRoaXMgaW50byBtdWx0aXBsZSBtZXRob2RzP1xuICAgICAgICAvLyBwYXJzZSB0aGUgYXJndW1lbnRzXG4gICAgICAgIHZhciBpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGlkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGlzSWQoZmlyc3QpKSB7XG4gICAgICAgICAgLy8gZ2V0KGlkIFssIG9wdGlvbnNdKVxuICAgICAgICAgIGlkID0gZmlyc3Q7XG4gICAgICAgICAgb3B0aW9ucyA9IHNlY29uZDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5JDEoZmlyc3QpKSB7XG4gICAgICAgICAgLy8gZ2V0KGlkcyBbLCBvcHRpb25zXSlcbiAgICAgICAgICBpZHMgPSBmaXJzdDtcbiAgICAgICAgICBvcHRpb25zID0gc2Vjb25kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGdldChbLCBvcHRpb25zXSlcbiAgICAgICAgICBvcHRpb25zID0gZmlyc3Q7XG4gICAgICAgIH0gLy8gZGV0ZXJtaW5lIHRoZSByZXR1cm4gdHlwZVxuXG5cbiAgICAgICAgdmFyIHJldHVyblR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMucmV0dXJuVHlwZSA9PT0gXCJPYmplY3RcIiA/IFwiT2JqZWN0XCIgOiBcIkFycmF5XCI7IC8vIEBUT0RPOiBXVEYgaXMgdGhpcz8gT3IgYW0gSSBtaXNzaW5nIHNvbWV0aGluZz9cbiAgICAgICAgLy8gdmFyIHJldHVyblR5cGVcbiAgICAgICAgLy8gaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXR1cm5UeXBlKSB7XG4gICAgICAgIC8vICAgdmFyIGFsbG93ZWRWYWx1ZXMgPSBbJ0FycmF5JywgJ09iamVjdCddXG4gICAgICAgIC8vICAgcmV0dXJuVHlwZSA9XG4gICAgICAgIC8vICAgICBhbGxvd2VkVmFsdWVzLmluZGV4T2Yob3B0aW9ucy5yZXR1cm5UeXBlKSA9PSAtMVxuICAgICAgICAvLyAgICAgICA/ICdBcnJheSdcbiAgICAgICAgLy8gICAgICAgOiBvcHRpb25zLnJldHVyblR5cGVcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICByZXR1cm5UeXBlID0gJ0FycmF5J1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGJ1aWxkIG9wdGlvbnNcblxuICAgICAgICB2YXIgZmlsdGVyJDEgPSBvcHRpb25zICYmIGZpbHRlcihvcHRpb25zKTtcblxuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgdmFyIGl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBpdGVtSWRzID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgaXRlbUlkID0gdW5kZWZpbmVkOyAvLyBjb252ZXJ0IGl0ZW1zXG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAvLyByZXR1cm4gYSBzaW5nbGUgaXRlbVxuICAgICAgICAgIGl0ZW0gPSB0aGlzLl9kYXRhLmdldChpZCk7XG5cbiAgICAgICAgICBpZiAoaXRlbSAmJiBmaWx0ZXIkMSAmJiAhZmlsdGVyJDEoaXRlbSkpIHtcbiAgICAgICAgICAgIGl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlkcyAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gcmV0dXJuIGEgc3Vic2V0IG9mIGl0ZW1zXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkc1tpXSk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtICE9IG51bGwgJiYgKCFmaWx0ZXIkMSB8fCBmaWx0ZXIkMShpdGVtKSkpIHtcbiAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0MjtcblxuICAgICAgICAgIC8vIHJldHVybiBhbGwgaXRlbXNcbiAgICAgICAgICBpdGVtSWRzID0gX3RvQ29uc3VtYWJsZUFycmF5KGtleXMoX2NvbnRleHQyID0gdGhpcy5fZGF0YSkuY2FsbChfY29udGV4dDIpKTtcblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2xlbiA9IGl0ZW1JZHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIGl0ZW1JZCA9IGl0ZW1JZHNbX2ldO1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGl0ZW1JZCk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtICE9IG51bGwgJiYgKCFmaWx0ZXIkMSB8fCBmaWx0ZXIkMShpdGVtKSkpIHtcbiAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gb3JkZXIgdGhlIHJlc3VsdHNcblxuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIgJiYgaWQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fc29ydChpdGVtcywgb3B0aW9ucy5vcmRlcik7XG4gICAgICAgIH0gLy8gZmlsdGVyIGZpZWxkcyBvZiB0aGUgaXRlbXNcblxuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICAgICAgdmFyIGZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuXG4gICAgICAgICAgaWYgKGlkICE9IHVuZGVmaW5lZCAmJiBpdGVtICE9IG51bGwpIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLl9maWx0ZXJGaWVsZHMoaXRlbSwgZmllbGRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX2xlbjIgPSBpdGVtcy5sZW5ndGg7IF9pMiA8IF9sZW4yOyBfaTIrKykge1xuICAgICAgICAgICAgICBpdGVtc1tfaTJdID0gdGhpcy5fZmlsdGVyRmllbGRzKGl0ZW1zW19pMl0sIGZpZWxkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHJldHVybiB0aGUgcmVzdWx0c1xuXG5cbiAgICAgICAgaWYgKHJldHVyblR5cGUgPT0gXCJPYmplY3RcIikge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9sZW4zID0gaXRlbXMubGVuZ3RoOyBfaTMgPCBfbGVuMzsgX2kzKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRhbnQgPSBpdGVtc1tfaTNdOyAvLyBAVE9ETzogU2hvdWRuJ3QgdGhpcyBiZSB0aGlzLl9maWVsZElkP1xuICAgICAgICAgICAgLy8gcmVzdWx0W3Jlc3VsdGFudC5pZF0gPSByZXN1bHRhbnRcblxuICAgICAgICAgICAgdmFyIF9pZDIgPSByZXN1bHRhbnRbdGhpcy5faWRQcm9wXTtcbiAgICAgICAgICAgIHJlc3VsdFtfaWQyXSA9IHJlc3VsdGFudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2l0ZW07XG5cbiAgICAgICAgICAgIC8vIGEgc2luZ2xlIGl0ZW1cbiAgICAgICAgICAgIHJldHVybiAoX2l0ZW0gPSBpdGVtKSAhPT0gbnVsbCAmJiBfaXRlbSAhPT0gdm9pZCAwID8gX2l0ZW0gOiBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBqdXN0IHJldHVybiBvdXIgYXJyYXlcbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldElkc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldElkcyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB2YXIgZmlsdGVyJDEgPSBvcHRpb25zICYmIGZpbHRlcihvcHRpb25zKTtcblxuICAgICAgICB2YXIgb3JkZXIgPSBvcHRpb25zICYmIG9wdGlvbnMub3JkZXI7XG5cbiAgICAgICAgdmFyIGl0ZW1JZHMgPSBfdG9Db25zdW1hYmxlQXJyYXkoa2V5cyhkYXRhKS5jYWxsKGRhdGEpKTtcblxuICAgICAgICB2YXIgaWRzID0gW107XG5cbiAgICAgICAgaWYgKGZpbHRlciQxKSB7XG4gICAgICAgICAgLy8gZ2V0IGZpbHRlcmVkIGl0ZW1zXG4gICAgICAgICAgaWYgKG9yZGVyKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgb3JkZXJlZCBsaXN0XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGlkID0gaXRlbUlkc1tpXTtcblxuICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkKTtcblxuICAgICAgICAgICAgICBpZiAoaXRlbSAhPSBudWxsICYmIGZpbHRlciQxKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zb3J0KGl0ZW1zLCBvcmRlcik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDAsIF9sZW40ID0gaXRlbXMubGVuZ3RoOyBfaTQgPCBfbGVuNDsgX2k0KyspIHtcbiAgICAgICAgICAgICAgaWRzLnB1c2goaXRlbXNbX2k0XVt0aGlzLl9pZFByb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY3JlYXRlIHVub3JkZXJlZCBsaXN0XG4gICAgICAgICAgICBmb3IgKHZhciBfaTUgPSAwLCBfbGVuNSA9IGl0ZW1JZHMubGVuZ3RoOyBfaTUgPCBfbGVuNTsgX2k1KyspIHtcbiAgICAgICAgICAgICAgdmFyIF9pZDMgPSBpdGVtSWRzW19pNV07XG5cbiAgICAgICAgICAgICAgdmFyIF9pdGVtMiA9IHRoaXMuX2RhdGEuZ2V0KF9pZDMpO1xuXG4gICAgICAgICAgICAgIGlmIChfaXRlbTIgIT0gbnVsbCAmJiBmaWx0ZXIkMShfaXRlbTIpKSB7XG4gICAgICAgICAgICAgICAgaWRzLnB1c2goX2l0ZW0yW3RoaXMuX2lkUHJvcF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGdldCBhbGwgaXRlbXNcbiAgICAgICAgICBpZiAob3JkZXIpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBvcmRlcmVkIGxpc3RcbiAgICAgICAgICAgIHZhciBfaXRlbXMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2k2ID0gMCwgX2xlbjYgPSBpdGVtSWRzLmxlbmd0aDsgX2k2IDwgX2xlbjY7IF9pNisrKSB7XG4gICAgICAgICAgICAgIHZhciBfaWQ0ID0gaXRlbUlkc1tfaTZdO1xuXG4gICAgICAgICAgICAgIF9pdGVtcy5wdXNoKGRhdGEuZ2V0KF9pZDQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc29ydChfaXRlbXMsIG9yZGVyKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2k3ID0gMCwgX2xlbjcgPSBfaXRlbXMubGVuZ3RoOyBfaTcgPCBfbGVuNzsgX2k3KyspIHtcbiAgICAgICAgICAgICAgaWRzLnB1c2goX2l0ZW1zW19pN11bdGhpcy5faWRQcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB1bm9yZGVyZWQgbGlzdFxuICAgICAgICAgICAgZm9yICh2YXIgX2k4ID0gMCwgX2xlbjggPSBpdGVtSWRzLmxlbmd0aDsgX2k4IDwgX2xlbjg7IF9pOCsrKSB7XG4gICAgICAgICAgICAgIHZhciBfaWQ1ID0gaXRlbUlkc1tfaThdO1xuXG4gICAgICAgICAgICAgIHZhciBfaXRlbTMgPSBkYXRhLmdldChfaWQ1KTtcblxuICAgICAgICAgICAgICBpZiAoX2l0ZW0zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZHMucHVzaChfaXRlbTNbdGhpcy5faWRQcm9wXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgfVxuICAgICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0RGF0YVNldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGFTZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGZpbHRlciQxID0gb3B0aW9ucyAmJiBmaWx0ZXIob3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHZhciBpdGVtSWRzID0gX3RvQ29uc3VtYWJsZUFycmF5KGtleXMoZGF0YSkuY2FsbChkYXRhKSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlcikge1xuICAgICAgICAgIC8vIGV4ZWN1dGUgZm9yRWFjaCBvbiBvcmRlcmVkIGxpc3RcbiAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmdldChvcHRpb25zKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIHZhciBpZCA9IGl0ZW1bdGhpcy5faWRQcm9wXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdW5vcmRlcmVkXG4gICAgICAgICAgZm9yICh2YXIgX2k5ID0gMCwgX2xlbjkgPSBpdGVtSWRzLmxlbmd0aDsgX2k5IDwgX2xlbjk7IF9pOSsrKSB7XG4gICAgICAgICAgICB2YXIgX2lkNiA9IGl0ZW1JZHNbX2k5XTtcblxuICAgICAgICAgICAgdmFyIF9pdGVtNCA9IHRoaXMuX2RhdGEuZ2V0KF9pZDYpO1xuXG4gICAgICAgICAgICBpZiAoX2l0ZW00ICE9IG51bGwgJiYgKCFmaWx0ZXIkMSB8fCBmaWx0ZXIkMShfaXRlbTQpKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhfaXRlbTQsIF9pZDYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWFwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBmaWx0ZXIkMSA9IG9wdGlvbnMgJiYgZmlsdGVyKG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBtYXBwZWRJdGVtcyA9IFtdO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdmFyIGl0ZW1JZHMgPSBfdG9Db25zdW1hYmxlQXJyYXkoa2V5cyhkYXRhKS5jYWxsKGRhdGEpKTsgLy8gY29udmVydCBhbmQgZmlsdGVyIGl0ZW1zXG5cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBpZCA9IGl0ZW1JZHNbaV07XG5cbiAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkKTtcblxuICAgICAgICAgIGlmIChpdGVtICE9IG51bGwgJiYgKCFmaWx0ZXIkMSB8fCBmaWx0ZXIkMShpdGVtKSkpIHtcbiAgICAgICAgICAgIG1hcHBlZEl0ZW1zLnB1c2goY2FsbGJhY2soaXRlbSwgaWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gb3JkZXIgaXRlbXNcblxuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIpIHtcbiAgICAgICAgICB0aGlzLl9zb3J0KG1hcHBlZEl0ZW1zLCBvcHRpb25zLm9yZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXBwZWRJdGVtcztcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBGaWx0ZXIgdGhlIGZpZWxkcyBvZiBhbiBpdGVtLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gaXRlbSAtIFRoZSBpdGVtIHdob3NlIGZpZWxkcyBzaG91bGQgYmUgZmlsdGVyZWQuXHJcbiAgICAgICAqIEBwYXJhbSBmaWVsZHMgLSBUaGUgbmFtZXMgb2YgdGhlIGZpZWxkcyB0aGF0IHdpbGwgYmUga2VwdC5cclxuICAgICAgICogQHR5cGVQYXJhbSBLIC0gRmllbGQgbmFtZSB0eXBlLlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSB3aXRob3V0IGFueSBhZGRpdGlvbmFsIGZpZWxkcy5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2ZpbHRlckZpZWxkc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maWx0ZXJGaWVsZHMoaXRlbSwgZmllbGRzKSB7XG4gICAgICAgIHZhciBfY29udGV4dDM7XG5cbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgLy8gaXRlbSBpcyBudWxsXG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVkdWNlKF9jb250ZXh0MyA9IGlzQXJyYXkkMShmaWVsZHMpID8gLy8gVXNlIHRoZSBzdXBwbGllZCBhcnJheVxuICAgICAgICBmaWVsZHMgOiAvLyBVc2UgdGhlIGtleXMgb2YgdGhlIHN1cHBsaWVkIG9iamVjdFxuICAgICAgICBrZXlzJDQoZmllbGRzKSkuY2FsbChfY29udGV4dDMsIGZ1bmN0aW9uIChmaWx0ZXJlZEl0ZW0sIGZpZWxkKSB7XG4gICAgICAgICAgZmlsdGVyZWRJdGVtW2ZpZWxkXSA9IGl0ZW1bZmllbGRdO1xuICAgICAgICAgIHJldHVybiBmaWx0ZXJlZEl0ZW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBTb3J0IHRoZSBwcm92aWRlZCBhcnJheSB3aXRoIGl0ZW1zLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gaXRlbXMgLSBJdGVtcyB0byBiZSBzb3J0ZWQgaW4gcGxhY2UuXHJcbiAgICAgICAqIEBwYXJhbSBvcmRlciAtIEEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cclxuICAgICAgICogQHR5cGVQYXJhbSBUIC0gVGhlIHR5cGUgb2YgdGhlIGl0ZW1zIGluIHRoZSBpdGVtcyBhcnJheS5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NvcnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc29ydChpdGVtcywgb3JkZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcmRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIC8vIG9yZGVyIGJ5IHByb3ZpZGVkIGZpZWxkIG5hbWVcbiAgICAgICAgICB2YXIgbmFtZSA9IG9yZGVyOyAvLyBmaWVsZCBuYW1lXG5cbiAgICAgICAgICBzb3J0KGl0ZW1zKS5jYWxsKGl0ZW1zLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgLy8gQFRPRE86IEhvdyB0byB0cmVhdCBtaXNzaW5nIHByb3BlcnRpZXM/XG4gICAgICAgICAgICB2YXIgYXYgPSBhW25hbWVdO1xuICAgICAgICAgICAgdmFyIGJ2ID0gYltuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBhdiA+IGJ2ID8gMSA6IGF2IDwgYnYgPyAtMSA6IDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9yZGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAvLyBvcmRlciBieSBzb3J0IGZ1bmN0aW9uXG4gICAgICAgICAgc29ydChpdGVtcykuY2FsbChpdGVtcywgb3JkZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRPRE86IGV4dGVuZCBvcmRlciBieSBhbiBPYmplY3Qge2ZpZWxkOnN0cmluZywgZGlyZWN0aW9uOnN0cmluZ31cbiAgICAgICAgICAvLyAgICAgICB3aGVyZSBkaXJlY3Rpb24gY2FuIGJlICdhc2MnIG9yICdkZXNjJ1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPcmRlciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZW1vdmUgYW4gaXRlbSBvciBtdWx0aXBsZSBpdGVtcyBieSDigJxyZWZlcmVuY2XigJ0gKG9ubHkgdGhlIGlkIGlzIHVzZWQpIG9yIGJ5IGlkLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBUaGUgbWV0aG9kIGlnbm9yZXMgcmVtb3ZhbCBvZiBub24tZXhpc3RpbmcgaXRlbXMsIGFuZCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGlkcyBvZiB0aGUgaXRlbXMgd2hpY2ggYXJlIGFjdHVhbGx5IHJlbW92ZWQgZnJvbSB0aGUgRGF0YVNldC5cclxuICAgICAgICpcclxuICAgICAgICogQWZ0ZXIgdGhlIGl0ZW1zIGFyZSByZW1vdmVkLCB0aGUgRGF0YVNldCB3aWxsIHRyaWdnZXIgYW4gZXZlbnQgYHJlbW92ZWAgZm9yIHRoZSByZW1vdmVkIGl0ZW1zLiBXaGVuIGEgYHNlbmRlcklkYCBpcyBwcm92aWRlZCwgdGhpcyBpZCB3aWxsIGJlIHBhc3NlZCB3aXRoIHRoZSB0cmlnZ2VyZWQgZXZlbnQgdG8gYWxsIHN1YnNjcmliZXJzLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAjIyBFeGFtcGxlXHJcbiAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICogLy8gY3JlYXRlIGEgRGF0YVNldFxyXG4gICAgICAgKiBjb25zdCBkYXRhID0gbmV3IHZpcy5EYXRhU2V0KFtcclxuICAgICAgICogICB7IGlkOiAxLCB0ZXh0OiAnaXRlbSAxJyB9LFxyXG4gICAgICAgKiAgIHsgaWQ6IDIsIHRleHQ6ICdpdGVtIDInIH0sXHJcbiAgICAgICAqICAgeyBpZDogMywgdGV4dDogJ2l0ZW0gMycgfVxyXG4gICAgICAgKiBdKVxyXG4gICAgICAgKlxyXG4gICAgICAgKiAvLyByZW1vdmUgaXRlbXNcclxuICAgICAgICogY29uc3QgaWRzID0gZGF0YS5yZW1vdmUoWzIsIHsgaWQ6IDMgfSwgNF0pXHJcbiAgICAgICAqXHJcbiAgICAgICAqIGNvbnNvbGUubG9nKGlkcykgLy8gWzIsIDNdXHJcbiAgICAgICAqIGBgYFxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gaWQgLSBPbmUgb3IgbW9yZSBpdGVtcyBvciBpZHMgb2YgaXRlbXMgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAgICogQHBhcmFtIHNlbmRlcklkIC0gU2VuZGVyIGlkLlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgaWRzIG9mIHRoZSByZW1vdmVkIGl0ZW1zLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoaWQsIHNlbmRlcklkKSB7XG4gICAgICAgIHZhciByZW1vdmVkSWRzID0gW107XG4gICAgICAgIHZhciByZW1vdmVkSXRlbXMgPSBbXTsgLy8gZm9yY2UgZXZlcnl0aGluZyB0byBiZSBhbiBhcnJheSBmb3Igc2ltcGxpY2l0eVxuXG4gICAgICAgIHZhciBpZHMgPSBpc0FycmF5JDEoaWQpID8gaWQgOiBbaWRdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX3JlbW92ZShpZHNbaV0pO1xuXG4gICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBpdGVtSWQgPSBpdGVtW3RoaXMuX2lkUHJvcF07XG5cbiAgICAgICAgICAgIGlmIChpdGVtSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZW1vdmVkSWRzLnB1c2goaXRlbUlkKTtcbiAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbW92ZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlcihcInJlbW92ZVwiLCB7XG4gICAgICAgICAgICBpdGVtczogcmVtb3ZlZElkcyxcbiAgICAgICAgICAgIG9sZERhdGE6IHJlbW92ZWRJdGVtc1xuICAgICAgICAgIH0sIHNlbmRlcklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW1vdmVkSWRzO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIFJlbW92ZSBhbiBpdGVtIGJ5IGl0cyBpZCBvciByZWZlcmVuY2UuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBpZCAtIElkIG9mIGFuIGl0ZW0gb3IgdGhlIGl0ZW0gaXRzZWxmLlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgcmVtb3ZlZCBpdGVtIGlmIHJlbW92ZWQsIG51bGwgb3RoZXJ3aXNlLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVtb3ZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZShpZCkge1xuICAgICAgICAvLyBAVE9ETzogSXQgb3JpZ2lhbmxseSByZXR1cm5lZCB0aGUgaXRlbSBhbHRob3VnaCB0aGUgZG9jcyBzYXkgaWQuXG4gICAgICAgIC8vIFRoZSBjb2RlIGV4cGVjdHMgdGhlIGl0ZW0sIHNvIHByb2JhYmx5IGFuIGVycm9yIGluIHRoZSBkb2NzLlxuICAgICAgICB2YXIgaWRlbnQ7IC8vIGNvbmZpcm0gdGhlIGlkIHRvIHVzZSBiYXNlZCBvbiB0aGUgYXJncyB0eXBlXG5cbiAgICAgICAgaWYgKGlzSWQoaWQpKSB7XG4gICAgICAgICAgaWRlbnQgPSBpZDtcbiAgICAgICAgfSBlbHNlIGlmIChpZCAmJiBfdHlwZW9mKGlkKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlkZW50ID0gaWRbdGhpcy5faWRQcm9wXTsgLy8gbG9vayBmb3IgdGhlIGlkZW50aWZpZXIgZmllbGQgdXNpbmcgLl9pZFByb3BcbiAgICAgICAgfSAvLyBkbyB0aGUgcmVtb3ZpbmcgaWYgdGhlIGl0ZW0gaXMgZm91bmRcblxuXG4gICAgICAgIGlmIChpZGVudCAhPSBudWxsICYmIHRoaXMuX2RhdGEuaGFzKGlkZW50KSkge1xuICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5fZGF0YS5nZXQoaWRlbnQpIHx8IG51bGw7XG5cbiAgICAgICAgICB0aGlzLl9kYXRhLmRlbGV0ZShpZGVudCk7XG5cbiAgICAgICAgICAtLXRoaXMubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogQ2xlYXIgdGhlIGVudGlyZSBkYXRhIHNldC5cclxuICAgICAgICpcclxuICAgICAgICogQWZ0ZXIgdGhlIGl0ZW1zIGFyZSByZW1vdmVkLCB0aGUgW1tEYXRhU2V0XV0gd2lsbCB0cmlnZ2VyIGFuIGV2ZW50IGByZW1vdmVgIGZvciBhbGwgcmVtb3ZlZCBpdGVtcy4gV2hlbiBhIGBzZW5kZXJJZGAgaXMgcHJvdmlkZWQsIHRoaXMgaWQgd2lsbCBiZSBwYXNzZWQgd2l0aCB0aGUgdHJpZ2dlcmVkIGV2ZW50IHRvIGFsbCBzdWJzY3JpYmVycy5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHNlbmRlcklkIC0gU2VuZGVyIGlkLlxyXG4gICAgICAgKiBAcmV0dXJucyByZW1vdmVkSWRzIC0gVGhlIGlkcyBvZiBhbGwgcmVtb3ZlZCBpdGVtcy5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xlYXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcihzZW5kZXJJZCkge1xuICAgICAgICB2YXIgX2NvbnRleHQ0O1xuXG4gICAgICAgIHZhciBpZHMgPSBfdG9Db25zdW1hYmxlQXJyYXkoa2V5cyhfY29udGV4dDQgPSB0aGlzLl9kYXRhKS5jYWxsKF9jb250ZXh0NCkpO1xuXG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKHRoaXMuX2RhdGEuZ2V0KGlkc1tpXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGF0YS5jbGVhcigpO1xuXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgICAgICB0aGlzLl90cmlnZ2VyKFwicmVtb3ZlXCIsIHtcbiAgICAgICAgICBpdGVtczogaWRzLFxuICAgICAgICAgIG9sZERhdGE6IGl0ZW1zXG4gICAgICAgIH0sIHNlbmRlcklkKTtcblxuICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIEZpbmQgdGhlIGl0ZW0gd2l0aCBtYXhpbXVtIHZhbHVlIG9mIGEgc3BlY2lmaWVkIGZpZWxkLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gZmllbGQgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSBzZWFyY2hlZCBmb3IgbWF4IHZhbHVlLlxyXG4gICAgICAgKiBAcmV0dXJucyBJdGVtIGNvbnRhaW5pbmcgbWF4IHZhbHVlLCBvciBudWxsIGlmIG5vIGl0ZW1zLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXgoZmllbGQpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NTtcblxuICAgICAgICB2YXIgbWF4ID0gbnVsbDtcbiAgICAgICAgdmFyIG1heEZpZWxkID0gbnVsbDtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMSh2YWx1ZXMoX2NvbnRleHQ1ID0gdGhpcy5fZGF0YSkuY2FsbChfY29udGV4dDUpKSxcbiAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgaXRlbUZpZWxkID0gaXRlbVtmaWVsZF07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbUZpZWxkID09PSBcIm51bWJlclwiICYmIChtYXhGaWVsZCA9PSBudWxsIHx8IGl0ZW1GaWVsZCA+IG1heEZpZWxkKSkge1xuICAgICAgICAgICAgICBtYXggPSBpdGVtO1xuICAgICAgICAgICAgICBtYXhGaWVsZCA9IGl0ZW1GaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXggfHwgbnVsbDtcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBGaW5kIHRoZSBpdGVtIHdpdGggbWluaW11bSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBmaWVsZC5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIGZpZWxkIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgc2VhcmNoZWQgZm9yIG1pbiB2YWx1ZS5cclxuICAgICAgICogQHJldHVybnMgSXRlbSBjb250YWluaW5nIG1pbiB2YWx1ZSwgb3IgbnVsbCBpZiBubyBpdGVtcy5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWluXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWluKGZpZWxkKSB7XG4gICAgICAgIHZhciBfY29udGV4dDY7XG5cbiAgICAgICAgdmFyIG1pbiA9IG51bGw7XG4gICAgICAgIHZhciBtaW5GaWVsZCA9IG51bGw7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKHZhbHVlcyhfY29udGV4dDYgPSB0aGlzLl9kYXRhKS5jYWxsKF9jb250ZXh0NikpLFxuICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGl0ZW1GaWVsZCA9IGl0ZW1bZmllbGRdO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW1GaWVsZCA9PT0gXCJudW1iZXJcIiAmJiAobWluRmllbGQgPT0gbnVsbCB8fCBpdGVtRmllbGQgPCBtaW5GaWVsZCkpIHtcbiAgICAgICAgICAgICAgbWluID0gaXRlbTtcbiAgICAgICAgICAgICAgbWluRmllbGQgPSBpdGVtRmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtaW4gfHwgbnVsbDtcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBGaW5kIGFsbCBkaXN0aW5jdCB2YWx1ZXMgb2YgYSBzcGVjaWZpZWQgZmllbGRcclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHByb3AgLSBUaGUgcHJvcGVydHkgbmFtZSB3aG9zZSBkaXN0aW5jdCB2YWx1ZXMgc2hvdWxkIGJlIHJldHVybmVkLlxyXG4gICAgICAgKiBAcmV0dXJucyBVbm9yZGVyZWQgYXJyYXkgY29udGFpbmluZyBhbGwgZGlzdGluY3QgdmFsdWVzLiBJdGVtcyB3aXRob3V0IHNwZWNpZmllZCBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGlzdGluY3RcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0aW5jdChwcm9wKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB2YXIgaXRlbUlkcyA9IF90b0NvbnN1bWFibGVBcnJheShrZXlzKGRhdGEpLmNhbGwoZGF0YSkpO1xuXG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBpZCA9IGl0ZW1JZHNbaV07XG4gICAgICAgICAgdmFyIGl0ZW0gPSBkYXRhLmdldChpZCk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gaXRlbVtwcm9wXTtcbiAgICAgICAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbal0gPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFleGlzdHMgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWVzW2NvdW50XSA9IHZhbHVlO1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIEFkZCBhIHNpbmdsZSBpdGVtLiBXaWxsIGZhaWwgd2hlbiBhbiBpdGVtIHdpdGggdGhlIHNhbWUgaWQgYWxyZWFkeSBleGlzdHMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBpdGVtIC0gQSBuZXcgaXRlbSB0byBiZSBhZGRlZC5cclxuICAgICAgICogQHJldHVybnMgQWRkZWQgaXRlbSdzIGlkLiBBbiBpZCBpcyBnZW5lcmF0ZWQgd2hlbiBpdCBpcyBub3QgcHJlc2VudCBpbiB0aGUgaXRlbS5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2FkZEl0ZW1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkSXRlbShpdGVtKSB7XG4gICAgICAgIHZhciBmdWxsSXRlbSA9IGVuc3VyZUZ1bGxJdGVtKGl0ZW0sIHRoaXMuX2lkUHJvcCk7XG4gICAgICAgIHZhciBpZCA9IGZ1bGxJdGVtW3RoaXMuX2lkUHJvcF07IC8vIGNoZWNrIHdoZXRoZXIgdGhpcyBpZCBpcyBhbHJlYWR5IHRha2VuXG5cbiAgICAgICAgaWYgKHRoaXMuX2RhdGEuaGFzKGlkKSkge1xuICAgICAgICAgIC8vIGl0ZW0gYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIGl0ZW06IGl0ZW0gd2l0aCBpZCBcIiArIGlkICsgXCIgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kYXRhLnNldChpZCwgZnVsbEl0ZW0pO1xuXG4gICAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBVcGRhdGUgYSBzaW5nbGUgaXRlbTogbWVyZ2Ugd2l0aCBleGlzdGluZyBpdGVtLlxyXG4gICAgICAgKiBXaWxsIGZhaWwgd2hlbiB0aGUgaXRlbSBoYXMgbm8gaWQsIG9yIHdoZW4gdGhlcmUgZG9lcyBub3QgZXhpc3QgYW4gaXRlbSB3aXRoIHRoZSBzYW1lIGlkLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gdXBkYXRlIC0gVGhlIG5ldyBpdGVtXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSBpZCBvZiB0aGUgdXBkYXRlZCBpdGVtLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfdXBkYXRlSXRlbVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVJdGVtKHVwZGF0ZSkge1xuICAgICAgICB2YXIgaWQgPSB1cGRhdGVbdGhpcy5faWRQcm9wXTtcblxuICAgICAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgaXRlbTogaXRlbSBoYXMgbm8gaWQgKGl0ZW06IFwiICsgc3RyaW5naWZ5JDEodXBkYXRlKSArIFwiKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5fZGF0YS5nZXQoaWQpO1xuXG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgIC8vIGl0ZW0gZG9lc24ndCBleGlzdFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgaXRlbTogbm8gaXRlbSB3aXRoIGlkIFwiICsgaWQgKyBcIiBmb3VuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RhdGEuc2V0KGlkLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGl0ZW0pLCB1cGRhdGUpKTtcblxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9XG4gICAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdHJlYW1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJlYW0oaWRzKSB7XG4gICAgICAgIGlmIChpZHMpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRhU3RyZWFtKF9kZWZpbmVQcm9wZXJ0eSh7fSwgaXRlcmF0b3IsIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yMywgX3N0ZXAzLCBpZCwgaXRlbTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKGlkcyk7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMTtcblxuICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IzLnMoKTtcblxuICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlkID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gZGF0YS5nZXQoaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGl0ZW0gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbaWQsIGl0ZW1dO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDEzO1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcudDAgPSBfY29udGV4dDdbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IzLmUoX2NvbnRleHQ3LnQwKTtcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAxNjtcblxuICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IzLmYoKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmZpbmlzaCgxNik7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1sxLCAxMywgMTYsIDE5XV0pO1xuICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0ODtcblxuICAgICAgICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbShfZGVmaW5lUHJvcGVydHkoe30sIGl0ZXJhdG9yLCBiaW5kJDYoX2NvbnRleHQ4ID0gZW50cmllcyh0aGlzLl9kYXRhKSkuY2FsbChfY29udGV4dDgsIHRoaXMuX2RhdGEpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRGF0YVNldDtcbiAgfShEYXRhU2V0UGFydCk7XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIHN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChpc0FycmF5JDEobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IHZhciBfY29udGV4dDU7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IHNsaWNlKF9jb250ZXh0NSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDUsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb20kMyhvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbiAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbiAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4gIC8qKlxyXG4gICAqIERhdGFWaWV3XHJcbiAgICpcclxuICAgKiBBIERhdGFWaWV3IG9mZmVycyBhIGZpbHRlcmVkIGFuZC9vciBmb3JtYXR0ZWQgdmlldyBvbiBhIERhdGFTZXQuIE9uZSBjYW4gc3Vic2NyaWJlIHRvIGNoYW5nZXMgaW4gYSBEYXRhVmlldywgYW5kIGVhc2lseSBnZXQgZmlsdGVyZWQgb3IgZm9ybWF0dGVkIGRhdGEgd2l0aG91dCBoYXZpbmcgdG8gc3BlY2lmeSBmaWx0ZXJzIGFuZCBmaWVsZCB0eXBlcyBhbGwgdGhlIHRpbWUuXHJcbiAgICpcclxuICAgKiAjIyBFeGFtcGxlXHJcbiAgICogYGBgamF2YXNjcmlwdFxyXG4gICAqIC8vIGNyZWF0ZSBhIERhdGFTZXRcclxuICAgKiB2YXIgZGF0YSA9IG5ldyB2aXMuRGF0YVNldCgpO1xyXG4gICAqIGRhdGEuYWRkKFtcclxuICAgKiAgIHtpZDogMSwgdGV4dDogJ2l0ZW0gMScsIGRhdGU6IG5ldyBEYXRlKDIwMTMsIDYsIDIwKSwgZ3JvdXA6IDEsIGZpcnN0OiB0cnVlfSxcclxuICAgKiAgIHtpZDogMiwgdGV4dDogJ2l0ZW0gMicsIGRhdGU6ICcyMDEzLTA2LTIzJywgZ3JvdXA6IDJ9LFxyXG4gICAqICAge2lkOiAzLCB0ZXh0OiAnaXRlbSAzJywgZGF0ZTogJzIwMTMtMDYtMjUnLCBncm91cDogMn0sXHJcbiAgICogICB7aWQ6IDQsIHRleHQ6ICdpdGVtIDQnfVxyXG4gICAqIF0pO1xyXG4gICAqXHJcbiAgICogLy8gY3JlYXRlIGEgRGF0YVZpZXdcclxuICAgKiAvLyB0aGUgdmlldyB3aWxsIG9ubHkgY29udGFpbiBpdGVtcyBoYXZpbmcgYSBwcm9wZXJ0eSBncm91cCB3aXRoIHZhbHVlIDEsXHJcbiAgICogLy8gYW5kIHdpbGwgb25seSBvdXRwdXQgZmllbGRzIGlkLCB0ZXh0LCBhbmQgZGF0ZS5cclxuICAgKiB2YXIgdmlldyA9IG5ldyB2aXMuRGF0YVZpZXcoZGF0YSwge1xyXG4gICAqICAgZmlsdGVyOiBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAqICAgICByZXR1cm4gKGl0ZW0uZ3JvdXAgPT0gMSk7XHJcbiAgICogICB9LFxyXG4gICAqICAgZmllbGRzOiBbJ2lkJywgJ3RleHQnLCAnZGF0ZSddXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiAvLyBzdWJzY3JpYmUgdG8gYW55IGNoYW5nZSBpbiB0aGUgRGF0YVZpZXdcclxuICAgKiB2aWV3Lm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50LCBwcm9wZXJ0aWVzLCBzZW5kZXJJZCkge1xyXG4gICAqICAgY29uc29sZS5sb2coJ2V2ZW50JywgZXZlbnQsIHByb3BlcnRpZXMpO1xyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogLy8gdXBkYXRlIGFuIGl0ZW0gaW4gdGhlIGRhdGEgc2V0XHJcbiAgICogZGF0YS51cGRhdGUoe2lkOiAyLCBncm91cDogMX0pO1xyXG4gICAqXHJcbiAgICogLy8gZ2V0IGFsbCBpZHMgaW4gdGhlIHZpZXdcclxuICAgKiB2YXIgaWRzID0gdmlldy5nZXRJZHMoKTtcclxuICAgKiBjb25zb2xlLmxvZygnaWRzJywgaWRzKTsgLy8gd2lsbCBvdXRwdXQgWzEsIDJdXHJcbiAgICpcclxuICAgKiAvLyBnZXQgYWxsIGl0ZW1zIGluIHRoZSB2aWV3XHJcbiAgICogdmFyIGl0ZW1zID0gdmlldy5nZXQoKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEB0eXBlUGFyYW0gSXRlbSAtIEl0ZW0gdHlwZSB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgYW4gaWQuXHJcbiAgICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpZC5cclxuICAgKi9cblxuICB2YXIgRGF0YVZpZXcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EYXRhU2V0UGFydCkge1xuICAgIF9pbmhlcml0cyhEYXRhVmlldywgX0RhdGFTZXRQYXJ0KTtcblxuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGF0YVZpZXcpO1xuXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBEYXRhVmlldy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBpbnN0YW5jZSBjb250YWluaW5nIGRhdGEgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHkpLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGlzIGRhdGEgdmlldy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERhdGFWaWV3KGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfY29udGV4dDtcblxuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YVZpZXcpO1xuXG4gICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibGVuZ3RoXCIsIDApO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX2xpc3RlbmVyXCIsIHZvaWQgMCk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfZGF0YVwiLCB2b2lkIDApO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX2lkc1wiLCBuZXcgc2V0KCkpO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX29wdGlvbnNcIiwgdm9pZCAwKTtcblxuICAgICAgX3RoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgX3RoaXMuX2xpc3RlbmVyID0gYmluZCQ2KF9jb250ZXh0ID0gX3RoaXMuX29uRXZlbnQpLmNhbGwoX2NvbnRleHQsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgX3RoaXMuc2V0RGF0YShkYXRhKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH0gLy8gVE9ETzogaW1wbGVtZW50IGEgZnVuY3Rpb24gLmNvbmZpZygpIHRvIGR5bmFtaWNhbGx5IHVwZGF0ZSB0aGluZ3MgbGlrZSBjb25maWd1cmVkIGZpbHRlclxuICAgIC8vIGFuZCB0cmlnZ2VyIGNoYW5nZXMgYWNjb3JkaW5nbHlcblxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgZGF0YSBzb3VyY2UgZm9yIHRoZSB2aWV3LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGluc3RhbmNlIGNvbnRhaW5pbmcgZGF0YSAoZGlyZWN0bHkgb3IgaW5kaXJlY3RseSkuXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogTm90ZSB0aGF0IHdoZW4gdGhlIGRhdGEgdmlldyBpcyBib3VuZCB0byBhIGRhdGEgc2V0IGl0IHdvbid0IGJlIGdhcmJhZ2VcclxuICAgICAqIGNvbGxlY3RlZCB1bmxlc3MgdGhlIGRhdGEgc2V0IGlzIHRvby4gVXNlIGBkYXRhVmlldy5zZXREYXRhKG51bGwpYCBvclxyXG4gICAgICogYGRhdGFWaWV3LmRpc3Bvc2UoKWAgdG8gZW5hYmxlIGdhcmJhZ2UgY29sbGVjdGlvbiBiZWZvcmUgeW91IGxvc2UgdGhlIGxhc3RcclxuICAgICAqIHJlZmVyZW5jZS5cclxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoRGF0YVZpZXcsIFt7XG4gICAgICBrZXk6IFwiaWRQcm9wXCIsXG4gICAgICBnZXQ6XG4gICAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICAgICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFTZXQoKS5pZFByb3A7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldERhdGFcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGN1cnJlbnQgZGF0YXNldFxuICAgICAgICAgIGlmICh0aGlzLl9kYXRhLm9mZikge1xuICAgICAgICAgICAgdGhpcy5fZGF0YS5vZmYoXCIqXCIsIHRoaXMuX2xpc3RlbmVyKTtcbiAgICAgICAgICB9IC8vIHRyaWdnZXIgYSByZW1vdmUgb2YgYWxsIGl0ZW1zIGluIG1lbW9yeVxuXG5cbiAgICAgICAgICB2YXIgaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoe1xuICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIodGhpcy5fb3B0aW9ucylcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXMuX2RhdGEuZ2V0KGlkcyk7XG5cbiAgICAgICAgICB0aGlzLl9pZHMuY2xlYXIoKTtcblxuICAgICAgICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIiwge1xuICAgICAgICAgICAgaXRlbXM6IGlkcyxcbiAgICAgICAgICAgIG9sZERhdGE6IGl0ZW1zXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7IC8vIHRyaWdnZXIgYW4gYWRkIG9mIGFsbCBhZGRlZCBpdGVtc1xuXG4gICAgICAgICAgdmFyIF9pZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7XG4gICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcih0aGlzLl9vcHRpb25zKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IF9pZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZCA9IF9pZHNbaV07XG5cbiAgICAgICAgICAgIHRoaXMuX2lkcy5hZGQoaWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubGVuZ3RoID0gX2lkcy5sZW5ndGg7XG5cbiAgICAgICAgICB0aGlzLl90cmlnZ2VyKFwiYWRkXCIsIHtcbiAgICAgICAgICAgIGl0ZW1zOiBfaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBEYXRhU2V0KCk7XG4gICAgICAgIH0gLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG5cblxuICAgICAgICBpZiAodGhpcy5fZGF0YS5vbikge1xuICAgICAgICAgIHRoaXMuX2RhdGEub24oXCIqXCIsIHRoaXMuX2xpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIFJlZnJlc2ggdGhlIERhdGFWaWV3LlxyXG4gICAgICAgKiBVc2VmdWwgd2hlbiB0aGUgRGF0YVZpZXcgaGFzIGEgZmlsdGVyIGZ1bmN0aW9uIGNvbnRhaW5pbmcgYSB2YXJpYWJsZSBwYXJhbWV0ZXIuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJlZnJlc2hcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgICB2YXIgaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoe1xuICAgICAgICAgIGZpbHRlcjogZmlsdGVyKHRoaXMuX29wdGlvbnMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBvbGRJZHMgPSBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5faWRzKTtcblxuICAgICAgICB2YXIgbmV3SWRzID0ge307XG4gICAgICAgIHZhciBhZGRlZElkcyA9IFtdO1xuICAgICAgICB2YXIgcmVtb3ZlZElkcyA9IFtdO1xuICAgICAgICB2YXIgcmVtb3ZlZEl0ZW1zID0gW107IC8vIGNoZWNrIGZvciBhZGRpdGlvbnNcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICAgIG5ld0lkc1tpZF0gPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLl9pZHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2lkcy5hZGQoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBjaGVjayBmb3IgcmVtb3ZhbHNcblxuXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2xlbiA9IG9sZElkcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHZhciBfaWQgPSBvbGRJZHNbX2ldO1xuXG4gICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9kYXRhLmdldChfaWQpO1xuXG4gICAgICAgICAgaWYgKGl0ZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQFRPRE86IEludmVzdGlnYXRlLlxuICAgICAgICAgICAgLy8gRG9lc24ndCBoYXBwZW4gZHVyaW5nIHRlc3RzIG9yIGV4YW1wbGVzLlxuICAgICAgICAgICAgLy8gSXMgaXQgcmVhbGx5IGltcG9zc2libGUgb3IgY291bGQgaXQgZXZlbnR1YWxseSBoYXBwZW4/XG4gICAgICAgICAgICAvLyBIb3cgdG8gaGFuZGxlIGl0IGlmIGl0IGRvZXM/IFRoZSB0eXBlcyBndWFyYW50ZWUgbm9uLW51bGxhYmxlIGl0ZW1zLlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIklmIHlvdSBzZWUgdGhpcywgcmVwb3J0IGl0IHBsZWFzZS5cIik7XG4gICAgICAgICAgfSBlbHNlIGlmICghbmV3SWRzW19pZF0pIHtcbiAgICAgICAgICAgIHJlbW92ZWRJZHMucHVzaChfaWQpO1xuICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2goaXRlbSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2lkcy5kZWxldGUoX2lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxlbmd0aCArPSBhZGRlZElkcy5sZW5ndGggLSByZW1vdmVkSWRzLmxlbmd0aDsgLy8gdHJpZ2dlciBldmVudHNcblxuICAgICAgICBpZiAoYWRkZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlcihcImFkZFwiLCB7XG4gICAgICAgICAgICBpdGVtczogYWRkZWRJZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW1vdmVkSWRzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIiwge1xuICAgICAgICAgICAgaXRlbXM6IHJlbW92ZWRJZHMsXG4gICAgICAgICAgICBvbGREYXRhOiByZW1vdmVkSXRlbXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IC8vIHBhcnNlIHRoZSBhcmd1bWVudHNcblxuXG4gICAgICAgIHZhciBpZHMgPSBudWxsO1xuICAgICAgICB2YXIgb3B0aW9ucztcblxuICAgICAgICBpZiAoaXNJZChmaXJzdCkgfHwgaXNBcnJheSQxKGZpcnN0KSkge1xuICAgICAgICAgIGlkcyA9IGZpcnN0O1xuICAgICAgICAgIG9wdGlvbnMgPSBzZWNvbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGZpcnN0O1xuICAgICAgICB9IC8vIGV4dGVuZCB0aGUgb3B0aW9ucyB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMgYW5kIHByb3ZpZGVkIG9wdGlvbnNcblxuXG4gICAgICAgIHZhciB2aWV3T3B0aW9ucyA9IGFzc2lnbiQyKHt9LCB0aGlzLl9vcHRpb25zLCBvcHRpb25zKTsgLy8gY3JlYXRlIGEgY29tYmluZWQgZmlsdGVyIG1ldGhvZCB3aGVuIG5lZWRlZFxuXG5cbiAgICAgICAgdmFyIHRoaXNGaWx0ZXIgPSBmaWx0ZXIodGhpcy5fb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIG9wdGlvbnNGaWx0ZXIgPSBvcHRpb25zICYmIGZpbHRlcihvcHRpb25zKTtcblxuICAgICAgICBpZiAodGhpc0ZpbHRlciAmJiBvcHRpb25zRmlsdGVyKSB7XG4gICAgICAgICAgdmlld09wdGlvbnMuZmlsdGVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzRmlsdGVyKGl0ZW0pICYmIG9wdGlvbnNGaWx0ZXIoaXRlbSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpZHMgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldCh2aWV3T3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0KGlkcywgdmlld09wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRJZHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJZHMob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5fZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGVmYXVsdEZpbHRlciA9IGZpbHRlcih0aGlzLl9vcHRpb25zKTtcblxuICAgICAgICAgIHZhciBvcHRpb25zRmlsdGVyID0gb3B0aW9ucyAhPSBudWxsID8gZmlsdGVyKG9wdGlvbnMpIDogbnVsbDtcbiAgICAgICAgICB2YXIgZmlsdGVyJDE7XG5cbiAgICAgICAgICBpZiAob3B0aW9uc0ZpbHRlcikge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgZmlsdGVyJDEgPSBmdW5jdGlvbiBmaWx0ZXIoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RmlsdGVyKGl0ZW0pICYmIG9wdGlvbnNGaWx0ZXIoaXRlbSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaWx0ZXIkMSA9IG9wdGlvbnNGaWx0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlciQxID0gZGVmYXVsdEZpbHRlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXRJZHMoe1xuICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIkMSxcbiAgICAgICAgICAgIG9yZGVyOiBvcHRpb25zICYmIG9wdGlvbnMub3JkZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImZvckVhY2hcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0MjtcblxuICAgICAgICAgIHZhciBkZWZhdWx0RmlsdGVyID0gZmlsdGVyKHRoaXMuX29wdGlvbnMpO1xuXG4gICAgICAgICAgdmFyIG9wdGlvbnNGaWx0ZXIgPSBvcHRpb25zICYmIGZpbHRlcihvcHRpb25zKTtcblxuICAgICAgICAgIHZhciBmaWx0ZXIkMTtcblxuICAgICAgICAgIGlmIChvcHRpb25zRmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdEZpbHRlcikge1xuICAgICAgICAgICAgICBmaWx0ZXIkMSA9IGZ1bmN0aW9uIGZpbHRlcihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXIoaXRlbSkgJiYgb3B0aW9uc0ZpbHRlcihpdGVtKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpbHRlciQxID0gb3B0aW9uc0ZpbHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlsdGVyJDEgPSBkZWZhdWx0RmlsdGVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvckVhY2gkMShfY29udGV4dDIgPSB0aGlzLl9kYXRhKS5jYWxsKF9jb250ZXh0MiwgY2FsbGJhY2ssIHtcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyJDEsXG4gICAgICAgICAgICBvcmRlcjogb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1hcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgICAgIHZhciBfY29udGV4dDM7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdEZpbHRlciA9IGZpbHRlcih0aGlzLl9vcHRpb25zKTtcblxuICAgICAgICAgIHZhciBvcHRpb25zRmlsdGVyID0gb3B0aW9ucyAmJiBmaWx0ZXIob3B0aW9ucyk7XG5cbiAgICAgICAgICB2YXIgZmlsdGVyJDE7XG5cbiAgICAgICAgICBpZiAob3B0aW9uc0ZpbHRlcikge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgZmlsdGVyJDEgPSBmdW5jdGlvbiBmaWx0ZXIoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RmlsdGVyKGl0ZW0pICYmIG9wdGlvbnNGaWx0ZXIoaXRlbSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaWx0ZXIkMSA9IG9wdGlvbnNGaWx0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlciQxID0gZGVmYXVsdEZpbHRlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbWFwJDMoX2NvbnRleHQzID0gdGhpcy5fZGF0YSkuY2FsbChfY29udGV4dDMsIGNhbGxiYWNrLCB7XG4gICAgICAgICAgICBmaWx0ZXI6IGZpbHRlciQxLFxuICAgICAgICAgICAgb3JkZXI6IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0RGF0YVNldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGFTZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldERhdGFTZXQoKTtcbiAgICAgIH1cbiAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInN0cmVhbVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmVhbShpZHMpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NDtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5zdHJlYW0oaWRzIHx8IF9kZWZpbmVQcm9wZXJ0eSh7fSwgaXRlcmF0b3IsIGJpbmQkNihfY29udGV4dDQgPSBrZXlzKHRoaXMuX2lkcykpLmNhbGwoX2NvbnRleHQ0LCB0aGlzLl9pZHMpKSk7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogUmVuZGVyIHRoZSBpbnN0YW5jZSB1bnVzYWJsZSBwcmlvciB0byBnYXJiYWdlIGNvbGxlY3Rpb24uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZW1hcmtzXHJcbiAgICAgICAqIFRoZSBpbnRlbnRpb24gb2YgdGhpcyBtZXRob2QgaXMgdG8gaGVscCBkaXNjb3ZlciBzY2VuYXJpb3Mgd2hlcmUgdGhlIGRhdGFcclxuICAgICAgICogdmlldyBpcyBiZWluZyB1c2VkIHdoZW4gdGhlIHByb2dyYW1tZXIgdGhpbmtzIGl0IGhhcyBiZWVuIGdhcmJhZ2UgY29sbGVjdGVkXHJcbiAgICAgICAqIGFscmVhZHkuIEl0J3Mgc3RyaWN0ZXIgdmVyc2lvbiBvZiBgZGF0YVZpZXcuc2V0RGF0YShudWxsKWAuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICB2YXIgX3RoaXMkX2RhdGE7XG5cbiAgICAgICAgaWYgKChfdGhpcyRfZGF0YSA9IHRoaXMuX2RhdGEpICE9PSBudWxsICYmIF90aGlzJF9kYXRhICE9PSB2b2lkIDAgJiYgX3RoaXMkX2RhdGEub2ZmKSB7XG4gICAgICAgICAgdGhpcy5fZGF0YS5vZmYoXCIqXCIsIHRoaXMuX2xpc3RlbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJUaGlzIGRhdGEgdmlldyBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkIG9mLlwiO1xuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIob3duS2V5cyQxKERhdGFWaWV3LnByb3RvdHlwZSkpLFxuICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSQ0KHRoaXMsIGtleSwgcmVwbGFjZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogRXZlbnQgbGlzdGVuZXIuIFdpbGwgcHJvcGFnYXRlIGFsbCBldmVudHMgZnJvbSB0aGUgY29ubmVjdGVkIGRhdGEgc2V0IHRvIHRoZSBzdWJzY3JpYmVycyBvZiB0aGUgRGF0YVZpZXcsIGJ1dCB3aWxsIGZpbHRlciB0aGUgaXRlbXMgYW5kIG9ubHkgdHJpZ2dlciB3aGVuIHRoZXJlIGFyZSBjaGFuZ2VzIGluIHRoZSBmaWx0ZXJlZCBkYXRhIHNldC5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBvZiB0aGUgZXZlbnQuXHJcbiAgICAgICAqIEBwYXJhbSBzZW5kZXJJZCAtIElkIHN1cHBsaWVkIGJ5IHRoZSBzZW5kZXIuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9vbkV2ZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRXZlbnQoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMgfHwgIXBhcmFtcy5pdGVtcyB8fCAhdGhpcy5fZGF0YSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZHMgPSBwYXJhbXMuaXRlbXM7XG4gICAgICAgIHZhciBhZGRlZElkcyA9IFtdO1xuICAgICAgICB2YXIgdXBkYXRlZElkcyA9IFtdO1xuICAgICAgICB2YXIgcmVtb3ZlZElkcyA9IFtdO1xuICAgICAgICB2YXIgb2xkSXRlbXMgPSBbXTtcbiAgICAgICAgdmFyIHVwZGF0ZWRJdGVtcyA9IFtdO1xuICAgICAgICB2YXIgcmVtb3ZlZEl0ZW1zID0gW107XG5cbiAgICAgICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICAgIGNhc2UgXCJhZGRcIjpcbiAgICAgICAgICAgIC8vIGZpbHRlciB0aGUgaWRzIG9mIHRoZSBhZGRlZCBpdGVtc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5nZXQoaWQpO1xuXG4gICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faWRzLmFkZChpZCk7XG5cbiAgICAgICAgICAgICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZXZlbnQgZnJvbSB0aGUgdmlld3Mgdmlld3BvaW50OiBhbiB1cGRhdGVkXG4gICAgICAgICAgICAvLyBpdGVtIGNhbiBiZSBhZGRlZCwgdXBkYXRlZCwgb3IgcmVtb3ZlZCBmcm9tIHRoaXMgdmlldy5cbiAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9sZW4yID0gaWRzLmxlbmd0aDsgX2kyIDwgX2xlbjI7IF9pMisrKSB7XG4gICAgICAgICAgICAgIHZhciBfaWQyID0gaWRzW19pMl07XG5cbiAgICAgICAgICAgICAgdmFyIF9pdGVtID0gdGhpcy5nZXQoX2lkMik7XG5cbiAgICAgICAgICAgICAgaWYgKF9pdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lkcy5oYXMoX2lkMikpIHtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZWRJZHMucHVzaChfaWQyKTtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZWRJdGVtcy5wdXNoKHBhcmFtcy5kYXRhW19pMl0pO1xuICAgICAgICAgICAgICAgICAgb2xkSXRlbXMucHVzaChwYXJhbXMub2xkRGF0YVtfaTJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5faWRzLmFkZChfaWQyKTtcblxuICAgICAgICAgICAgICAgICAgYWRkZWRJZHMucHVzaChfaWQyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lkcy5oYXMoX2lkMikpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2lkcy5kZWxldGUoX2lkMik7XG5cbiAgICAgICAgICAgICAgICAgIHJlbW92ZWRJZHMucHVzaChfaWQyKTtcbiAgICAgICAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKHBhcmFtcy5vbGREYXRhW19pMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgICAgICAgIC8vIGZpbHRlciB0aGUgaWRzIG9mIHRoZSByZW1vdmVkIGl0ZW1zXG4gICAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwLCBfbGVuMyA9IGlkcy5sZW5ndGg7IF9pMyA8IF9sZW4zOyBfaTMrKykge1xuICAgICAgICAgICAgICB2YXIgX2lkMyA9IGlkc1tfaTNdO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pZHMuaGFzKF9pZDMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faWRzLmRlbGV0ZShfaWQzKTtcblxuICAgICAgICAgICAgICAgIHJlbW92ZWRJZHMucHVzaChfaWQzKTtcbiAgICAgICAgICAgICAgICByZW1vdmVkSXRlbXMucHVzaChwYXJhbXMub2xkRGF0YVtfaTNdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGFkZGVkSWRzLmxlbmd0aCAtIHJlbW92ZWRJZHMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyKFwiYWRkXCIsIHtcbiAgICAgICAgICAgIGl0ZW1zOiBhZGRlZElkc1xuICAgICAgICAgIH0sIHNlbmRlcklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cGRhdGVkSWRzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXCJ1cGRhdGVcIiwge1xuICAgICAgICAgICAgaXRlbXM6IHVwZGF0ZWRJZHMsXG4gICAgICAgICAgICBvbGREYXRhOiBvbGRJdGVtcyxcbiAgICAgICAgICAgIGRhdGE6IHVwZGF0ZWRJdGVtc1xuICAgICAgICAgIH0sIHNlbmRlcklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW1vdmVkSWRzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIiwge1xuICAgICAgICAgICAgaXRlbXM6IHJlbW92ZWRJZHMsXG4gICAgICAgICAgICBvbGREYXRhOiByZW1vdmVkSXRlbXNcbiAgICAgICAgICB9LCBzZW5kZXJJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRGF0YVZpZXc7XG4gIH0oRGF0YVNldFBhcnQpO1xuXG4gIC8qKlxyXG4gICAqIENoZWNrIHRoYXQgZ2l2ZW4gdmFsdWUgaXMgY29tcGF0aWJsZSB3aXRoIFZpcyBEYXRhIFNldCBpbnRlcmZhY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaWRQcm9wIC0gVGhlIGV4cGVjdGVkIHByb3BlcnR5IHRvIGNvbnRhaW4gaXRlbSBpZC5cclxuICAgKiBAcGFyYW0gdiAtIFRoZSB2YWx1ZSB0byBiZSB0ZXN0ZWQuXHJcbiAgICogQHJldHVybnMgVHJ1ZSBpZiBhbGwgZXhwZWN0ZWQgdmFsdWVzIGFuZCBtZXRob2RzIG1hdGNoLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICovXG4gIGZ1bmN0aW9uIGlzRGF0YVNldExpa2UoaWRQcm9wLCB2KSB7XG4gICAgcmV0dXJuIF90eXBlb2YodikgPT09IFwib2JqZWN0XCIgJiYgdiAhPT0gbnVsbCAmJiBpZFByb3AgPT09IHYuaWRQcm9wICYmIHR5cGVvZiB2LmFkZCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LmNsZWFyID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuZGlzdGluY3QgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZm9yRWFjaCQxKHYpID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuZ2V0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuZ2V0RGF0YVNldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LmdldElkcyA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgbWFwJDModikgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5tYXggPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5taW4gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5vZmYgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5vbiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LnNldE9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5zdHJlYW0gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi51cGRhdGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi51cGRhdGVPbmx5ID09PSBcImZ1bmN0aW9uXCI7XG4gIH1cblxuICAvKipcclxuICAgKiBDaGVjayB0aGF0IGdpdmVuIHZhbHVlIGlzIGNvbXBhdGlibGUgd2l0aCBWaXMgRGF0YSBWaWV3IGludGVyZmFjZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBpZFByb3AgLSBUaGUgZXhwZWN0ZWQgcHJvcGVydHkgdG8gY29udGFpbiBpdGVtIGlkLlxyXG4gICAqIEBwYXJhbSB2IC0gVGhlIHZhbHVlIHRvIGJlIHRlc3RlZC5cclxuICAgKiBAcmV0dXJucyBUcnVlIGlmIGFsbCBleHBlY3RlZCB2YWx1ZXMgYW5kIG1ldGhvZHMgbWF0Y2gsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgKi9cblxuICBmdW5jdGlvbiBpc0RhdGFWaWV3TGlrZShpZFByb3AsIHYpIHtcbiAgICByZXR1cm4gX3R5cGVvZih2KSA9PT0gXCJvYmplY3RcIiAmJiB2ICE9PSBudWxsICYmIGlkUHJvcCA9PT0gdi5pZFByb3AgJiYgdHlwZW9mIGZvckVhY2gkMSh2KSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LmdldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LmdldERhdGFTZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5nZXRJZHMgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5sZW5ndGggPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG1hcCQzKHYpID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYub2ZmID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYub24gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5zdHJlYW0gPT09IFwiZnVuY3Rpb25cIiAmJiBpc0RhdGFTZXRMaWtlKGlkUHJvcCwgdi5nZXREYXRhU2V0KCkpO1xuICB9XG5cbiAgZXhwb3J0cy5ERUxFVEUgPSBERUxFVEU7XG4gIGV4cG9ydHMuRGF0YVNldCA9IERhdGFTZXQ7XG4gIGV4cG9ydHMuRGF0YVN0cmVhbSA9IERhdGFTdHJlYW07XG4gIGV4cG9ydHMuRGF0YVZpZXcgPSBEYXRhVmlldztcbiAgZXhwb3J0cy5RdWV1ZSA9IFF1ZXVlO1xuICBleHBvcnRzLmNyZWF0ZU5ld0RhdGFQaXBlRnJvbSA9IGNyZWF0ZU5ld0RhdGFQaXBlRnJvbTtcbiAgZXhwb3J0cy5pc0RhdGFTZXRMaWtlID0gaXNEYXRhU2V0TGlrZTtcbiAgZXhwb3J0cy5pc0RhdGFWaWV3TGlrZSA9IGlzRGF0YVZpZXdMaWtlO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpcy1kYXRhLmpzLm1hcFxuIiwiLyoqXG4gKiB2aXMtZGF0YVxuICogaHR0cDovL3Zpc2pzLm9yZy9cbiAqXG4gKiBNYW5hZ2UgdW5zdHJ1Y3R1cmVkIGRhdGEgdXNpbmcgRGF0YVNldC4gQWRkLCB1cGRhdGUsIGFuZCByZW1vdmUgZGF0YSwgYW5kIGxpc3RlbiBmb3IgY2hhbmdlcyBpbiB0aGUgZGF0YS5cbiAqXG4gKiBAdmVyc2lvbiA3LjEuNFxuICogQGRhdGUgICAgMjAyMi0wMy0xNVQxNToyMzo1OS4yNDVaXG4gKlxuICogQGNvcHlyaWdodCAoYykgMjAxMS0yMDE3IEFsbWVuZGUgQi5WLCBodHRwOi8vYWxtZW5kZS5jb21cbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTctMjAxOSB2aXNqcyBjb250cmlidXRvcnMsIGh0dHBzOi8vZ2l0aHViLmNvbS92aXNqc1xuICpcbiAqIEBsaWNlbnNlXG4gKiB2aXMuanMgaXMgZHVhbCBsaWNlbnNlZCB1bmRlciBib3RoXG4gKlxuICogICAxLiBUaGUgQXBhY2hlIDIuMCBMaWNlbnNlXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICAgYW5kXG4gKlxuICogICAyLiBUaGUgTUlUIExpY2Vuc2VcbiAqICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICpcbiAqIHZpcy5qcyBtYXkgYmUgZGlzdHJpYnV0ZWQgdW5kZXIgZWl0aGVyIGxpY2Vuc2UuXG4gKi9cbiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP2UoZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLGUpOmUoKHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS52aXM9dC52aXN8fHt9KX0odGhpcywoZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9dmFyIHI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnt9LG49e2V4cG9ydHM6e319LGk9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuTWF0aD09TWF0aCYmdH0sbz1pKFwib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWxUaGlzJiZnbG9iYWxUaGlzKXx8aShcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cpfHxpKFwib2JqZWN0XCI9PXR5cGVvZiBzZWxmJiZzZWxmKXx8aShcIm9iamVjdFwiPT10eXBlb2YgciYmcil8fGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCl8fEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSxhPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4hIXQoKX1jYXRjaCh0KXtyZXR1cm4hMH19LHU9IWEoKGZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24oKXt9LmJpbmQoKTtyZXR1cm5cImZ1bmN0aW9uXCIhPXR5cGVvZiB0fHx0Lmhhc093blByb3BlcnR5KFwicHJvdG90eXBlXCIpfSkpLHM9dSxjPUZ1bmN0aW9uLnByb3RvdHlwZSxmPWMuYXBwbHksbD1jLmNhbGwsaD1cIm9iamVjdFwiPT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5hcHBseXx8KHM/bC5iaW5kKGYpOmZ1bmN0aW9uKCl7cmV0dXJuIGwuYXBwbHkoZixhcmd1bWVudHMpfSkscD11LHY9RnVuY3Rpb24ucHJvdG90eXBlLGQ9di5iaW5kLHk9di5jYWxsLGc9cCYmZC5iaW5kKHkseSksbT1wP2Z1bmN0aW9uKHQpe3JldHVybiB0JiZnKHQpfTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmZnVuY3Rpb24oKXtyZXR1cm4geS5hcHBseSh0LGFyZ3VtZW50cyl9fSxiPWZ1bmN0aW9uKHQpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHR9LF89e30sdz0hYSgoZnVuY3Rpb24oKXtyZXR1cm4gNyE9T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LDEse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pWzFdfSkpLE89dSxFPUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLFQ9Tz9FLmJpbmQoRSk6ZnVuY3Rpb24oKXtyZXR1cm4gRS5hcHBseShFLGFyZ3VtZW50cyl9LHg9e30saz17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxTPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsQT1TJiYhay5jYWxsKHsxOjJ9LDEpO3guZj1BP2Z1bmN0aW9uKHQpe3ZhciBlPVModGhpcyx0KTtyZXR1cm4hIWUmJmUuZW51bWVyYWJsZX06azt2YXIgaixQLEk9ZnVuY3Rpb24odCxlKXtyZXR1cm57ZW51bWVyYWJsZTohKDEmdCksY29uZmlndXJhYmxlOiEoMiZ0KSx3cml0YWJsZTohKDQmdCksdmFsdWU6ZX19LEQ9bSxMPUQoe30udG9TdHJpbmcpLEM9RChcIlwiLnNsaWNlKSxSPWZ1bmN0aW9uKHQpe3JldHVybiBDKEwodCksOCwtMSl9LE09bSxGPWEsTj1SLHo9by5PYmplY3QscT1NKFwiXCIuc3BsaXQpLFk9RigoZnVuY3Rpb24oKXtyZXR1cm4heihcInpcIikucHJvcGVydHlJc0VudW1lcmFibGUoMCl9KSk/ZnVuY3Rpb24odCl7cmV0dXJuXCJTdHJpbmdcIj09Tih0KT9xKHQsXCJcIik6eih0KX06eixHPW8uVHlwZUVycm9yLFg9ZnVuY3Rpb24odCl7aWYobnVsbD09dCl0aHJvdyBHKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIrdCk7cmV0dXJuIHR9LFU9WSxXPVgsVj1mdW5jdGlvbih0KXtyZXR1cm4gVShXKHQpKX0sSD1iLCQ9ZnVuY3Rpb24odCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHQ/bnVsbCE9PXQ6SCh0KX0sQj17fSxKPUIsSz1vLFE9YixaPWZ1bmN0aW9uKHQpe3JldHVybiBRKHQpP3Q6dm9pZCAwfSx0dD1mdW5jdGlvbih0LGUpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPDI/WihKW3RdKXx8WihLW3RdKTpKW3RdJiZKW3RdW2VdfHxLW3RdJiZLW3RdW2VdfSxldD1tKHt9LmlzUHJvdG90eXBlT2YpLHJ0PXR0KFwibmF2aWdhdG9yXCIsXCJ1c2VyQWdlbnRcIil8fFwiXCIsbnQ9byxpdD1ydCxvdD1udC5wcm9jZXNzLGF0PW50LkRlbm8sdXQ9b3QmJm90LnZlcnNpb25zfHxhdCYmYXQudmVyc2lvbixzdD11dCYmdXQudjg7c3QmJihQPShqPXN0LnNwbGl0KFwiLlwiKSlbMF0+MCYmalswXTw0PzE6KyhqWzBdK2pbMV0pKSwhUCYmaXQmJighKGo9aXQubWF0Y2goL0VkZ2VcXC8oXFxkKykvKSl8fGpbMV0+PTc0KSYmKGo9aXQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pKSYmKFA9K2pbMV0pO3ZhciBjdD1QLGZ0PWN0LGx0PWEsaHQ9ISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzJiYhbHQoKGZ1bmN0aW9uKCl7dmFyIHQ9U3ltYm9sKCk7cmV0dXJuIVN0cmluZyh0KXx8IShPYmplY3QodClpbnN0YW5jZW9mIFN5bWJvbCl8fCFTeW1ib2wuc2hhbSYmZnQmJmZ0PDQxfSkpLHB0PWh0JiYhU3ltYm9sLnNoYW0mJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3IsdnQ9dHQsZHQ9Yix5dD1ldCxndD1wdCxtdD1vLk9iamVjdCxidD1ndD9mdW5jdGlvbih0KXtyZXR1cm5cInN5bWJvbFwiPT10eXBlb2YgdH06ZnVuY3Rpb24odCl7dmFyIGU9dnQoXCJTeW1ib2xcIik7cmV0dXJuIGR0KGUpJiZ5dChlLnByb3RvdHlwZSxtdCh0KSl9LF90PW8uU3RyaW5nLHd0PWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gX3QodCl9Y2F0Y2godCl7cmV0dXJuXCJPYmplY3RcIn19LE90PWIsRXQ9d3QsVHQ9by5UeXBlRXJyb3IseHQ9ZnVuY3Rpb24odCl7aWYoT3QodCkpcmV0dXJuIHQ7dGhyb3cgVHQoRXQodCkrXCIgaXMgbm90IGEgZnVuY3Rpb25cIil9LGt0PXh0LFN0PWZ1bmN0aW9uKHQsZSl7dmFyIHI9dFtlXTtyZXR1cm4gbnVsbD09cj92b2lkIDA6a3Qocil9LEF0PVQsanQ9YixQdD0kLEl0PW8uVHlwZUVycm9yLER0PXtleHBvcnRzOnt9fSxMdD1vLEN0PU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxSdD1mdW5jdGlvbih0LGUpe3RyeXtDdChMdCx0LHt2YWx1ZTplLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pfWNhdGNoKHIpe0x0W3RdPWV9cmV0dXJuIGV9LE10PVwiX19jb3JlLWpzX3NoYXJlZF9fXCIsRnQ9b1tNdF18fFJ0KE10LHt9KSxOdD1GdDsoRHQuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybiBOdFt0XXx8KE50W3RdPXZvaWQgMCE9PWU/ZTp7fSl9KShcInZlcnNpb25zXCIsW10pLnB1c2goe3ZlcnNpb246XCIzLjIxLjFcIixtb2RlOlwicHVyZVwiLGNvcHlyaWdodDpcIsKpIDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KVwiLGxpY2Vuc2U6XCJodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjIxLjEvTElDRU5TRVwiLHNvdXJjZTpcImh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzXCJ9KTt2YXIgenQ9WCxxdD1vLk9iamVjdCxZdD1mdW5jdGlvbih0KXtyZXR1cm4gcXQoenQodCkpfSxHdD1ZdCxYdD1tKHt9Lmhhc093blByb3BlcnR5KSxVdD1PYmplY3QuaGFzT3dufHxmdW5jdGlvbih0LGUpe3JldHVybiBYdChHdCh0KSxlKX0sV3Q9bSxWdD0wLEh0PU1hdGgucmFuZG9tKCksJHQ9V3QoMS4udG9TdHJpbmcpLEJ0PWZ1bmN0aW9uKHQpe3JldHVyblwiU3ltYm9sKFwiKyh2b2lkIDA9PT10P1wiXCI6dCkrXCIpX1wiKyR0KCsrVnQrSHQsMzYpfSxKdD1vLEt0PUR0LmV4cG9ydHMsUXQ9VXQsWnQ9QnQsdGU9aHQsZWU9cHQscmU9S3QoXCJ3a3NcIiksbmU9SnQuU3ltYm9sLGllPW5lJiZuZS5mb3Isb2U9ZWU/bmU6bmUmJm5lLndpdGhvdXRTZXR0ZXJ8fFp0LGFlPWZ1bmN0aW9uKHQpe2lmKCFRdChyZSx0KXx8IXRlJiZcInN0cmluZ1wiIT10eXBlb2YgcmVbdF0pe3ZhciBlPVwiU3ltYm9sLlwiK3Q7dGUmJlF0KG5lLHQpP3JlW3RdPW5lW3RdOnJlW3RdPWVlJiZpZT9pZShlKTpvZShlKX1yZXR1cm4gcmVbdF19LHVlPVQsc2U9JCxjZT1idCxmZT1TdCxsZT1mdW5jdGlvbih0LGUpe3ZhciByLG47aWYoXCJzdHJpbmdcIj09PWUmJmp0KHI9dC50b1N0cmluZykmJiFQdChuPUF0KHIsdCkpKXJldHVybiBuO2lmKGp0KHI9dC52YWx1ZU9mKSYmIVB0KG49QXQocix0KSkpcmV0dXJuIG47aWYoXCJzdHJpbmdcIiE9PWUmJmp0KHI9dC50b1N0cmluZykmJiFQdChuPUF0KHIsdCkpKXJldHVybiBuO3Rocm93IEl0KFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpfSxoZT1hZSxwZT1vLlR5cGVFcnJvcix2ZT1oZShcInRvUHJpbWl0aXZlXCIpLGRlPWZ1bmN0aW9uKHQsZSl7aWYoIXNlKHQpfHxjZSh0KSlyZXR1cm4gdDt2YXIgcixuPWZlKHQsdmUpO2lmKG4pe2lmKHZvaWQgMD09PWUmJihlPVwiZGVmYXVsdFwiKSxyPXVlKG4sdCxlKSwhc2Uocil8fGNlKHIpKXJldHVybiByO3Rocm93IHBlKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpfXJldHVybiB2b2lkIDA9PT1lJiYoZT1cIm51bWJlclwiKSxsZSh0LGUpfSx5ZT1idCxnZT1mdW5jdGlvbih0KXt2YXIgZT1kZSh0LFwic3RyaW5nXCIpO3JldHVybiB5ZShlKT9lOmUrXCJcIn0sbWU9JCxiZT1vLmRvY3VtZW50LF9lPW1lKGJlKSYmbWUoYmUuY3JlYXRlRWxlbWVudCksd2U9ZnVuY3Rpb24odCl7cmV0dXJuIF9lP2JlLmNyZWF0ZUVsZW1lbnQodCk6e319LE9lPXdlLEVlPSF3JiYhYSgoZnVuY3Rpb24oKXtyZXR1cm4gNyE9T2JqZWN0LmRlZmluZVByb3BlcnR5KE9lKFwiZGl2XCIpLFwiYVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hfSkpLFRlPXcseGU9VCxrZT14LFNlPUksQWU9VixqZT1nZSxQZT1VdCxJZT1FZSxEZT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO18uZj1UZT9EZTpmdW5jdGlvbih0LGUpe2lmKHQ9QWUodCksZT1qZShlKSxJZSl0cnl7cmV0dXJuIERlKHQsZSl9Y2F0Y2godCl7fWlmKFBlKHQsZSkpcmV0dXJuIFNlKCF4ZShrZS5mLHQsZSksdFtlXSl9O3ZhciBMZT1hLENlPWIsUmU9LyN8XFwucHJvdG90eXBlXFwuLyxNZT1mdW5jdGlvbih0LGUpe3ZhciByPU5lW0ZlKHQpXTtyZXR1cm4gcj09cWV8fHIhPXplJiYoQ2UoZSk/TGUoZSk6ISFlKX0sRmU9TWUubm9ybWFsaXplPWZ1bmN0aW9uKHQpe3JldHVybiBTdHJpbmcodCkucmVwbGFjZShSZSxcIi5cIikudG9Mb3dlckNhc2UoKX0sTmU9TWUuZGF0YT17fSx6ZT1NZS5OQVRJVkU9XCJOXCIscWU9TWUuUE9MWUZJTEw9XCJQXCIsWWU9TWUsR2U9eHQsWGU9dSxVZT1tKG0uYmluZCksV2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gR2UodCksdm9pZCAwPT09ZT90OlhlP1VlKHQsZSk6ZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShlLGFyZ3VtZW50cyl9fSxWZT17fSxIZT13JiZhKChmdW5jdGlvbigpe3JldHVybiA0MiE9T2JqZWN0LmRlZmluZVByb3BlcnR5KChmdW5jdGlvbigpe30pLFwicHJvdG90eXBlXCIse3ZhbHVlOjQyLHdyaXRhYmxlOiExfSkucHJvdG90eXBlfSkpLCRlPW8sQmU9JCxKZT0kZS5TdHJpbmcsS2U9JGUuVHlwZUVycm9yLFFlPWZ1bmN0aW9uKHQpe2lmKEJlKHQpKXJldHVybiB0O3Rocm93IEtlKEplKHQpK1wiIGlzIG5vdCBhbiBvYmplY3RcIil9LFplPXcsdHI9RWUsZXI9SGUscnI9UWUsbnI9Z2UsaXI9by5UeXBlRXJyb3Isb3I9T2JqZWN0LmRlZmluZVByb3BlcnR5LGFyPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsdXI9XCJlbnVtZXJhYmxlXCIsc3I9XCJjb25maWd1cmFibGVcIixjcj1cIndyaXRhYmxlXCI7VmUuZj1aZT9lcj9mdW5jdGlvbih0LGUscil7aWYocnIodCksZT1ucihlKSxycihyKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiZcInByb3RvdHlwZVwiPT09ZSYmXCJ2YWx1ZVwiaW4gciYmY3IgaW4gciYmIXIud3JpdGFibGUpe3ZhciBuPWFyKHQsZSk7biYmbi53cml0YWJsZSYmKHRbZV09ci52YWx1ZSxyPXtjb25maWd1cmFibGU6c3IgaW4gcj9yLmNvbmZpZ3VyYWJsZTpuLmNvbmZpZ3VyYWJsZSxlbnVtZXJhYmxlOnVyIGluIHI/ci5lbnVtZXJhYmxlOm4uZW51bWVyYWJsZSx3cml0YWJsZTohMX0pfXJldHVybiBvcih0LGUscil9Om9yOmZ1bmN0aW9uKHQsZSxyKXtpZihycih0KSxlPW5yKGUpLHJyKHIpLHRyKXRyeXtyZXR1cm4gb3IodCxlLHIpfWNhdGNoKHQpe31pZihcImdldFwiaW4gcnx8XCJzZXRcImluIHIpdGhyb3cgaXIoXCJBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm5cInZhbHVlXCJpbiByJiYodFtlXT1yLnZhbHVlKSx0fTt2YXIgZnI9VmUsbHI9SSxocj13P2Z1bmN0aW9uKHQsZSxyKXtyZXR1cm4gZnIuZih0LGUsbHIoMSxyKSl9OmZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdFtlXT1yLHR9LHByPW8sdnI9aCxkcj1tLHlyPWIsZ3I9Xy5mLG1yPVllLGJyPUIsX3I9V2Usd3I9aHIsT3I9VXQsRXI9ZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24ocixuLGkpe2lmKHRoaXMgaW5zdGFuY2VvZiBlKXtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBuZXcgdDtjYXNlIDE6cmV0dXJuIG5ldyB0KHIpO2Nhc2UgMjpyZXR1cm4gbmV3IHQocixuKX1yZXR1cm4gbmV3IHQocixuLGkpfXJldHVybiB2cih0LHRoaXMsYXJndW1lbnRzKX07cmV0dXJuIGUucHJvdG90eXBlPXQucHJvdG90eXBlLGV9LFRyPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbixpLG8sYSx1LHMsYyxmPXQudGFyZ2V0LGw9dC5nbG9iYWwsaD10LnN0YXQscD10LnByb3RvLHY9bD9wcjpoP3ByW2ZdOihwcltmXXx8e30pLnByb3RvdHlwZSxkPWw/YnI6YnJbZl18fHdyKGJyLGYse30pW2ZdLHk9ZC5wcm90b3R5cGU7Zm9yKGkgaW4gZSlyPSFtcihsP2k6ZisoaD9cIi5cIjpcIiNcIikraSx0LmZvcmNlZCkmJnYmJk9yKHYsaSksYT1kW2ldLHImJih1PXQubm9UYXJnZXRHZXQ/KGM9Z3IodixpKSkmJmMudmFsdWU6dltpXSksbz1yJiZ1P3U6ZVtpXSxyJiZ0eXBlb2YgYT09dHlwZW9mIG98fChzPXQuYmluZCYmcj9fcihvLHByKTp0LndyYXAmJnI/RXIobyk6cCYmeXIobyk/ZHIobyk6bywodC5zaGFtfHxvJiZvLnNoYW18fGEmJmEuc2hhbSkmJndyKHMsXCJzaGFtXCIsITApLHdyKGQsaSxzKSxwJiYoT3IoYnIsbj1mK1wiUHJvdG90eXBlXCIpfHx3cihicixuLHt9KSx3cihicltuXSxpLG8pLHQucmVhbCYmeSYmIXlbaV0mJndyKHksaSxvKSkpfSx4cj1Ucixrcj13LFNyPVZlLmY7eHIoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOk9iamVjdC5kZWZpbmVQcm9wZXJ0eSE9PVNyLHNoYW06IWtyfSx7ZGVmaW5lUHJvcGVydHk6U3J9KTt2YXIgQXI9Qi5PYmplY3QsanI9bi5leHBvcnRzPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gQXIuZGVmaW5lUHJvcGVydHkodCxlLHIpfTtBci5kZWZpbmVQcm9wZXJ0eS5zaGFtJiYoanIuc2hhbT0hMCk7dmFyIFByPW4uZXhwb3J0cyxJcj1QcjtmdW5jdGlvbiBEcih0LGUpe2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgbj1lW3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxJcih0LG4ua2V5LG4pfX1mdW5jdGlvbiBMcih0LGUscil7cmV0dXJuIGUmJkRyKHQucHJvdG90eXBlLGUpLHImJkRyKHQsciksSXIodCxcInByb3RvdHlwZVwiLHt3cml0YWJsZTohMX0pLHR9ZnVuY3Rpb24gQ3IodCxlLHIpe3JldHVybiBlIGluIHQ/SXIodCxlLHt2YWx1ZTpyLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1yLHR9dmFyIFJyPW0oW10uc2xpY2UpLE1yPW0sRnI9eHQsTnI9JCx6cj1VdCxxcj1ScixZcj11LEdyPW8uRnVuY3Rpb24sWHI9TXIoW10uY29uY2F0KSxVcj1NcihbXS5qb2luKSxXcj17fSxWcj1mdW5jdGlvbih0LGUscil7aWYoIXpyKFdyLGUpKXtmb3IodmFyIG49W10saT0wO2k8ZTtpKyspbltpXT1cImFbXCIraStcIl1cIjtXcltlXT1HcihcIkMsYVwiLFwicmV0dXJuIG5ldyBDKFwiK1VyKG4sXCIsXCIpK1wiKVwiKX1yZXR1cm4gV3JbZV0odCxyKX0sSHI9WXI/R3IuYmluZDpmdW5jdGlvbih0KXt2YXIgZT1Gcih0aGlzKSxyPWUucHJvdG90eXBlLG49cXIoYXJndW1lbnRzLDEpLGk9ZnVuY3Rpb24oKXt2YXIgcj1YcihuLHFyKGFyZ3VtZW50cykpO3JldHVybiB0aGlzIGluc3RhbmNlb2YgaT9WcihlLHIubGVuZ3RoLHIpOmUuYXBwbHkodCxyKX07cmV0dXJuIE5yKHIpJiYoaS5wcm90b3R5cGU9ciksaX0sJHI9SHI7VHIoe3RhcmdldDpcIkZ1bmN0aW9uXCIscHJvdG86ITAsZm9yY2VkOkZ1bmN0aW9uLmJpbmQhPT0kcn0se2JpbmQ6JHJ9KTt2YXIgQnI9QixKcj1mdW5jdGlvbih0KXtyZXR1cm4gQnJbdCtcIlByb3RvdHlwZVwiXX0sS3I9SnIoXCJGdW5jdGlvblwiKS5iaW5kLFFyPWV0LFpyPUtyLHRuPUZ1bmN0aW9uLnByb3RvdHlwZSxlbj1mdW5jdGlvbih0KXt2YXIgZT10LmJpbmQ7cmV0dXJuIHQ9PT10bnx8UXIodG4sdCkmJmU9PT10bi5iaW5kP1pyOmV9LHJuPU1hdGguY2VpbCxubj1NYXRoLmZsb29yLG9uPWZ1bmN0aW9uKHQpe3ZhciBlPSt0O3JldHVybiBlIT1lfHwwPT09ZT8wOihlPjA/bm46cm4pKGUpfSxhbj1vbix1bj1NYXRoLm1pbixzbj1mdW5jdGlvbih0KXtyZXR1cm4gdD4wP3VuKGFuKHQpLDkwMDcxOTkyNTQ3NDA5OTEpOjB9LGNuPWZ1bmN0aW9uKHQpe3JldHVybiBzbih0Lmxlbmd0aCl9LGZuPXh0LGxuPVl0LGhuPVkscG49Y24sdm49by5UeXBlRXJyb3IsZG49ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUscixuLGkpe2ZuKHIpO3ZhciBvPWxuKGUpLGE9aG4obyksdT1wbihvKSxzPXQ/dS0xOjAsYz10Py0xOjE7aWYobjwyKWZvcig7Oyl7aWYocyBpbiBhKXtpPWFbc10scys9YzticmVha31pZihzKz1jLHQ/czwwOnU8PXMpdGhyb3cgdm4oXCJSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlXCIpfWZvcig7dD9zPj0wOnU+cztzKz1jKXMgaW4gYSYmKGk9cihpLGFbc10scyxvKSk7cmV0dXJuIGl9fSx5bj17bGVmdDpkbighMSkscmlnaHQ6ZG4oITApfSxnbj1hLG1uPWZ1bmN0aW9uKHQsZSl7dmFyIHI9W11bdF07cmV0dXJuISFyJiZnbigoZnVuY3Rpb24oKXtyLmNhbGwobnVsbCxlfHxmdW5jdGlvbigpe3JldHVybiAxfSwxKX0pKX0sYm49XCJwcm9jZXNzXCI9PVIoby5wcm9jZXNzKSxfbj15bi5sZWZ0LHduPWN0LE9uPWJuO1RyKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohbW4oXCJyZWR1Y2VcIil8fCFPbiYmd24+NzkmJnduPDgzfSx7cmVkdWNlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg7cmV0dXJuIF9uKHRoaXMsdCxlLGU+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19KTt2YXIgRW49SnIoXCJBcnJheVwiKS5yZWR1Y2UsVG49ZXQseG49RW4sa249QXJyYXkucHJvdG90eXBlLFNuPWZ1bmN0aW9uKHQpe3ZhciBlPXQucmVkdWNlO3JldHVybiB0PT09a258fFRuKGtuLHQpJiZlPT09a24ucmVkdWNlP3huOmV9LEFuPVIsam49QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24odCl7cmV0dXJuXCJBcnJheVwiPT1Bbih0KX0sUG49e307UG5bYWUoXCJ0b1N0cmluZ1RhZ1wiKV09XCJ6XCI7dmFyIEluPVwiW29iamVjdCB6XVwiPT09U3RyaW5nKFBuKSxEbj1vLExuPUluLENuPWIsUm49UixNbj1hZShcInRvU3RyaW5nVGFnXCIpLEZuPURuLk9iamVjdCxObj1cIkFyZ3VtZW50c1wiPT1SbihmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpLHpuPUxuP1JuOmZ1bmN0aW9uKHQpe3ZhciBlLHIsbjtyZXR1cm4gdm9pZCAwPT09dD9cIlVuZGVmaW5lZFwiOm51bGw9PT10P1wiTnVsbFwiOlwic3RyaW5nXCI9PXR5cGVvZihyPWZ1bmN0aW9uKHQsZSl7dHJ5e3JldHVybiB0W2VdfWNhdGNoKHQpe319KGU9Rm4odCksTW4pKT9yOk5uP1JuKGUpOlwiT2JqZWN0XCI9PShuPVJuKGUpKSYmQ24oZS5jYWxsZWUpP1wiQXJndW1lbnRzXCI6bn0scW49YixZbj1GdCxHbj1tKEZ1bmN0aW9uLnRvU3RyaW5nKTtxbihZbi5pbnNwZWN0U291cmNlKXx8KFluLmluc3BlY3RTb3VyY2U9ZnVuY3Rpb24odCl7cmV0dXJuIEduKHQpfSk7dmFyIFhuPVluLmluc3BlY3RTb3VyY2UsVW49bSxXbj1hLFZuPWIsSG49em4sJG49WG4sQm49ZnVuY3Rpb24oKXt9LEpuPVtdLEtuPXR0KFwiUmVmbGVjdFwiLFwiY29uc3RydWN0XCIpLFFuPS9eXFxzKig/OmNsYXNzfGZ1bmN0aW9uKVxcYi8sWm49VW4oUW4uZXhlYyksdGk9IVFuLmV4ZWMoQm4pLGVpPWZ1bmN0aW9uKHQpe2lmKCFWbih0KSlyZXR1cm4hMTt0cnl7cmV0dXJuIEtuKEJuLEpuLHQpLCEwfWNhdGNoKHQpe3JldHVybiExfX0scmk9ZnVuY3Rpb24odCl7aWYoIVZuKHQpKXJldHVybiExO3N3aXRjaChIbih0KSl7Y2FzZVwiQXN5bmNGdW5jdGlvblwiOmNhc2VcIkdlbmVyYXRvckZ1bmN0aW9uXCI6Y2FzZVwiQXN5bmNHZW5lcmF0b3JGdW5jdGlvblwiOnJldHVybiExfXRyeXtyZXR1cm4gdGl8fCEhWm4oUW4sJG4odCkpfWNhdGNoKHQpe3JldHVybiEwfX07cmkuc2hhbT0hMDt2YXIgbmk9IUtufHxXbigoZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gZWkoZWkuY2FsbCl8fCFlaShPYmplY3QpfHwhZWkoKGZ1bmN0aW9uKCl7dD0hMH0pKXx8dH0pKT9yaTplaSxpaT1vLG9pPWpuLGFpPW5pLHVpPSQsc2k9YWUoXCJzcGVjaWVzXCIpLGNpPWlpLkFycmF5LGZpPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBvaSh0KSYmKGU9dC5jb25zdHJ1Y3RvciwoYWkoZSkmJihlPT09Y2l8fG9pKGUucHJvdG90eXBlKSl8fHVpKGUpJiZudWxsPT09KGU9ZVtzaV0pKSYmKGU9dm9pZCAwKSksdm9pZCAwPT09ZT9jaTplfSxsaT1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcoZmkodCkpKDA9PT1lPzA6ZSl9LGhpPVdlLHBpPVksdmk9WXQsZGk9Y24seWk9bGksZ2k9bShbXS5wdXNoKSxtaT1mdW5jdGlvbih0KXt2YXIgZT0xPT10LHI9Mj09dCxuPTM9PXQsaT00PT10LG89Nj09dCxhPTc9PXQsdT01PT10fHxvO3JldHVybiBmdW5jdGlvbihzLGMsZixsKXtmb3IodmFyIGgscCx2PXZpKHMpLGQ9cGkodikseT1oaShjLGYpLGc9ZGkoZCksbT0wLGI9bHx8eWksXz1lP2IocyxnKTpyfHxhP2IocywwKTp2b2lkIDA7Zz5tO20rKylpZigodXx8bSBpbiBkKSYmKHA9eShoPWRbbV0sbSx2KSx0KSlpZihlKV9bbV09cDtlbHNlIGlmKHApc3dpdGNoKHQpe2Nhc2UgMzpyZXR1cm4hMDtjYXNlIDU6cmV0dXJuIGg7Y2FzZSA2OnJldHVybiBtO2Nhc2UgMjpnaShfLGgpfWVsc2Ugc3dpdGNoKHQpe2Nhc2UgNDpyZXR1cm4hMTtjYXNlIDc6Z2koXyxoKX1yZXR1cm4gbz8tMTpufHxpP2k6X319LGJpPXtmb3JFYWNoOm1pKDApLG1hcDptaSgxKSxmaWx0ZXI6bWkoMiksc29tZTptaSgzKSxldmVyeTptaSg0KSxmaW5kOm1pKDUpLGZpbmRJbmRleDptaSg2KSxmaWx0ZXJSZWplY3Q6bWkoNyl9LF9pPWEsd2k9Y3QsT2k9YWUoXCJzcGVjaWVzXCIpLEVpPWZ1bmN0aW9uKHQpe3JldHVybiB3aT49NTF8fCFfaSgoZnVuY3Rpb24oKXt2YXIgZT1bXTtyZXR1cm4oZS5jb25zdHJ1Y3Rvcj17fSlbT2ldPWZ1bmN0aW9uKCl7cmV0dXJue2ZvbzoxfX0sMSE9PWVbdF0oQm9vbGVhbikuZm9vfSkpfSxUaT1iaS5maWx0ZXI7VHIoe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOiFFaShcImZpbHRlclwiKX0se2ZpbHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gVGkodGhpcyx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19KTt2YXIgeGk9SnIoXCJBcnJheVwiKS5maWx0ZXIsa2k9ZXQsU2k9eGksQWk9QXJyYXkucHJvdG90eXBlLGppPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZmlsdGVyO3JldHVybiB0PT09QWl8fGtpKEFpLHQpJiZlPT09QWkuZmlsdGVyP1NpOmV9LFBpPWJpLm1hcDtUcih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IUVpKFwibWFwXCIpfSx7bWFwOmZ1bmN0aW9uKHQpe3JldHVybiBQaSh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pO3ZhciBJaT1KcihcIkFycmF5XCIpLm1hcCxEaT1ldCxMaT1JaSxDaT1BcnJheS5wcm90b3R5cGUsUmk9ZnVuY3Rpb24odCl7dmFyIGU9dC5tYXA7cmV0dXJuIHQ9PT1DaXx8RGkoQ2ksdCkmJmU9PT1DaS5tYXA/TGk6ZX0sTWk9am4sRmk9Y24sTmk9V2Usemk9by5UeXBlRXJyb3IscWk9ZnVuY3Rpb24odCxlLHIsbixpLG8sYSx1KXtmb3IodmFyIHMsYyxmPWksbD0wLGg9ISFhJiZOaShhLHUpO2w8bjspe2lmKGwgaW4gcil7aWYocz1oP2gocltsXSxsLGUpOnJbbF0sbz4wJiZNaShzKSljPUZpKHMpLGY9cWkodCxlLHMsYyxmLG8tMSktMTtlbHNle2lmKGY+PTkwMDcxOTkyNTQ3NDA5OTEpdGhyb3cgemkoXCJFeGNlZWQgdGhlIGFjY2VwdGFibGUgYXJyYXkgbGVuZ3RoXCIpO3RbZl09c31mKyt9bCsrfXJldHVybiBmfSxZaT1xaSxHaT14dCxYaT1ZdCxVaT1jbixXaT1saTtUcih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMH0se2ZsYXRNYXA6ZnVuY3Rpb24odCl7dmFyIGUscj1YaSh0aGlzKSxuPVVpKHIpO3JldHVybiBHaSh0KSwoZT1XaShyLDApKS5sZW5ndGg9WWkoZSxyLHIsbiwwLDEsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCksZX19KTt2YXIgVmk9SnIoXCJBcnJheVwiKS5mbGF0TWFwLEhpPWV0LCRpPVZpLEJpPUFycmF5LnByb3RvdHlwZSxKaT1mdW5jdGlvbih0KXt2YXIgZT10LmZsYXRNYXA7cmV0dXJuIHQ9PT1CaXx8SGkoQmksdCkmJmU9PT1CaS5mbGF0TWFwPyRpOmV9O3ZhciBLaSxRaSxaaSx0bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQocixuLGkpe3ZhciBvLGEsdTtlKHRoaXMsdCksQ3IodGhpcyxcIl9zb3VyY2VcIix2b2lkIDApLENyKHRoaXMsXCJfdHJhbnNmb3JtZXJzXCIsdm9pZCAwKSxDcih0aGlzLFwiX3RhcmdldFwiLHZvaWQgMCksQ3IodGhpcyxcIl9saXN0ZW5lcnNcIix7YWRkOmVuKG89dGhpcy5fYWRkKS5jYWxsKG8sdGhpcykscmVtb3ZlOmVuKGE9dGhpcy5fcmVtb3ZlKS5jYWxsKGEsdGhpcyksdXBkYXRlOmVuKHU9dGhpcy5fdXBkYXRlKS5jYWxsKHUsdGhpcyl9KSx0aGlzLl9zb3VyY2U9cix0aGlzLl90cmFuc2Zvcm1lcnM9bix0aGlzLl90YXJnZXQ9aX1yZXR1cm4gTHIodCxbe2tleTpcImFsbFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RhcmdldC51cGRhdGUodGhpcy5fdHJhbnNmb3JtSXRlbXModGhpcy5fc291cmNlLmdldCgpKSksdGhpc319LHtrZXk6XCJzdGFydFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NvdXJjZS5vbihcImFkZFwiLHRoaXMuX2xpc3RlbmVycy5hZGQpLHRoaXMuX3NvdXJjZS5vbihcInJlbW92ZVwiLHRoaXMuX2xpc3RlbmVycy5yZW1vdmUpLHRoaXMuX3NvdXJjZS5vbihcInVwZGF0ZVwiLHRoaXMuX2xpc3RlbmVycy51cGRhdGUpLHRoaXN9fSx7a2V5Olwic3RvcFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NvdXJjZS5vZmYoXCJhZGRcIix0aGlzLl9saXN0ZW5lcnMuYWRkKSx0aGlzLl9zb3VyY2Uub2ZmKFwicmVtb3ZlXCIsdGhpcy5fbGlzdGVuZXJzLnJlbW92ZSksdGhpcy5fc291cmNlLm9mZihcInVwZGF0ZVwiLHRoaXMuX2xpc3RlbmVycy51cGRhdGUpLHRoaXN9fSx7a2V5OlwiX3RyYW5zZm9ybUl0ZW1zXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIFNuKGU9dGhpcy5fdHJhbnNmb3JtZXJzKS5jYWxsKGUsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUodCl9KSx0KX19LHtrZXk6XCJfYWRkXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtudWxsIT1lJiZ0aGlzLl90YXJnZXQuYWRkKHRoaXMuX3RyYW5zZm9ybUl0ZW1zKHRoaXMuX3NvdXJjZS5nZXQoZS5pdGVtcykpKX19LHtrZXk6XCJfdXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtudWxsIT1lJiZ0aGlzLl90YXJnZXQudXBkYXRlKHRoaXMuX3RyYW5zZm9ybUl0ZW1zKHRoaXMuX3NvdXJjZS5nZXQoZS5pdGVtcykpKX19LHtrZXk6XCJfcmVtb3ZlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtudWxsIT1lJiZ0aGlzLl90YXJnZXQucmVtb3ZlKHRoaXMuX3RyYW5zZm9ybUl0ZW1zKGUub2xkRGF0YSkpfX1dKSx0fSgpLGVvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChyKXtlKHRoaXMsdCksQ3IodGhpcyxcIl9zb3VyY2VcIix2b2lkIDApLENyKHRoaXMsXCJfdHJhbnNmb3JtZXJzXCIsW10pLHRoaXMuX3NvdXJjZT1yfXJldHVybiBMcih0LFt7a2V5OlwiZmlsdGVyXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3RyYW5zZm9ybWVycy5wdXNoKChmdW5jdGlvbihlKXtyZXR1cm4gamkoZSkuY2FsbChlLHQpfSkpLHRoaXN9fSx7a2V5OlwibWFwXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3RyYW5zZm9ybWVycy5wdXNoKChmdW5jdGlvbihlKXtyZXR1cm4gUmkoZSkuY2FsbChlLHQpfSkpLHRoaXN9fSx7a2V5OlwiZmxhdE1hcFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl90cmFuc2Zvcm1lcnMucHVzaCgoZnVuY3Rpb24oZSl7cmV0dXJuIEppKGUpLmNhbGwoZSx0KX0pKSx0aGlzfX0se2tleTpcInRvXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyB0byh0aGlzLl9zb3VyY2UsdGhpcy5fdHJhbnNmb3JtZXJzLHQpfX1dKSx0fSgpLHJvPXpuLG5vPW8uU3RyaW5nLGlvPWZ1bmN0aW9uKHQpe2lmKFwiU3ltYm9sXCI9PT1ybyh0KSl0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZ1wiKTtyZXR1cm4gbm8odCl9LG9vPW0sYW89b24sdW89aW8sc289WCxjbz1vbyhcIlwiLmNoYXJBdCksZm89b28oXCJcIi5jaGFyQ29kZUF0KSxsbz1vbyhcIlwiLnNsaWNlKSxobz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxyKXt2YXIgbixpLG89dW8oc28oZSkpLGE9YW8ociksdT1vLmxlbmd0aDtyZXR1cm4gYTwwfHxhPj11P3Q/XCJcIjp2b2lkIDA6KG49Zm8obyxhKSk8NTUyOTZ8fG4+NTYzMTl8fGErMT09PXV8fChpPWZvKG8sYSsxKSk8NTYzMjB8fGk+NTczNDM/dD9jbyhvLGEpOm46dD9sbyhvLGEsYSsyKTppLTU2MzIwKyhuLTU1Mjk2PDwxMCkrNjU1MzZ9fSxwbz17Y29kZUF0OmhvKCExKSxjaGFyQXQ6aG8oITApfSx2bz1iLHlvPVhuLGdvPW8uV2Vha01hcCxtbz12byhnbykmJi9uYXRpdmUgY29kZS8udGVzdCh5byhnbykpLGJvPUR0LmV4cG9ydHMsX289QnQsd289Ym8oXCJrZXlzXCIpLE9vPWZ1bmN0aW9uKHQpe3JldHVybiB3b1t0XXx8KHdvW3RdPV9vKHQpKX0sRW89e30sVG89bW8seG89byxrbz1tLFNvPSQsQW89aHIsam89VXQsUG89RnQsSW89T28sRG89RW8sTG89XCJPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZFwiLENvPXhvLlR5cGVFcnJvcixSbz14by5XZWFrTWFwO2lmKFRvfHxQby5zdGF0ZSl7dmFyIE1vPVBvLnN0YXRlfHwoUG8uc3RhdGU9bmV3IFJvKSxGbz1rbyhNby5nZXQpLE5vPWtvKE1vLmhhcyksem89a28oTW8uc2V0KTtLaT1mdW5jdGlvbih0LGUpe2lmKE5vKE1vLHQpKXRocm93IG5ldyBDbyhMbyk7cmV0dXJuIGUuZmFjYWRlPXQsem8oTW8sdCxlKSxlfSxRaT1mdW5jdGlvbih0KXtyZXR1cm4gRm8oTW8sdCl8fHt9fSxaaT1mdW5jdGlvbih0KXtyZXR1cm4gTm8oTW8sdCl9fWVsc2V7dmFyIHFvPUlvKFwic3RhdGVcIik7RG9bcW9dPSEwLEtpPWZ1bmN0aW9uKHQsZSl7aWYoam8odCxxbykpdGhyb3cgbmV3IENvKExvKTtyZXR1cm4gZS5mYWNhZGU9dCxBbyh0LHFvLGUpLGV9LFFpPWZ1bmN0aW9uKHQpe3JldHVybiBqbyh0LHFvKT90W3FvXTp7fX0sWmk9ZnVuY3Rpb24odCl7cmV0dXJuIGpvKHQscW8pfX12YXIgWW89e3NldDpLaSxnZXQ6UWksaGFzOlppLGVuZm9yY2U6ZnVuY3Rpb24odCl7cmV0dXJuIFppKHQpP1FpKHQpOktpKHQse30pfSxnZXR0ZXJGb3I6ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciByO2lmKCFTbyhlKXx8KHI9UWkoZSkpLnR5cGUhPT10KXRocm93IENvKFwiSW5jb21wYXRpYmxlIHJlY2VpdmVyLCBcIit0K1wiIHJlcXVpcmVkXCIpO3JldHVybiByfX19LEdvPXcsWG89VXQsVW89RnVuY3Rpb24ucHJvdG90eXBlLFdvPUdvJiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFZvPVhvKFVvLFwibmFtZVwiKSxIbz17RVhJU1RTOlZvLFBST1BFUjpWbyYmXCJzb21ldGhpbmdcIj09PWZ1bmN0aW9uKCl7fS5uYW1lLENPTkZJR1VSQUJMRTpWbyYmKCFHb3x8R28mJldvKFVvLFwibmFtZVwiKS5jb25maWd1cmFibGUpfSwkbz17fSxCbz1vbixKbz1NYXRoLm1heCxLbz1NYXRoLm1pbixRbz1mdW5jdGlvbih0LGUpe3ZhciByPUJvKHQpO3JldHVybiByPDA/Sm8ocitlLDApOktvKHIsZSl9LFpvPVYsdGE9UW8sZWE9Y24scmE9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUscixuKXt2YXIgaSxvPVpvKGUpLGE9ZWEobyksdT10YShuLGEpO2lmKHQmJnIhPXIpe2Zvcig7YT51OylpZigoaT1vW3UrK10pIT1pKXJldHVybiEwfWVsc2UgZm9yKDthPnU7dSsrKWlmKCh0fHx1IGluIG8pJiZvW3VdPT09cilyZXR1cm4gdHx8dXx8MDtyZXR1cm4hdCYmLTF9fSxuYT17aW5jbHVkZXM6cmEoITApLGluZGV4T2Y6cmEoITEpfSxpYT1VdCxvYT1WLGFhPW5hLmluZGV4T2YsdWE9RW8sc2E9bShbXS5wdXNoKSxjYT1mdW5jdGlvbih0LGUpe3ZhciByLG49b2EodCksaT0wLG89W107Zm9yKHIgaW4gbikhaWEodWEscikmJmlhKG4scikmJnNhKG8scik7Zm9yKDtlLmxlbmd0aD5pOylpYShuLHI9ZVtpKytdKSYmKH5hYShvLHIpfHxzYShvLHIpKTtyZXR1cm4gb30sZmE9W1wiY29uc3RydWN0b3JcIixcImhhc093blByb3BlcnR5XCIsXCJpc1Byb3RvdHlwZU9mXCIsXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLFwidG9Mb2NhbGVTdHJpbmdcIixcInRvU3RyaW5nXCIsXCJ2YWx1ZU9mXCJdLGxhPWNhLGhhPWZhLHBhPU9iamVjdC5rZXlzfHxmdW5jdGlvbih0KXtyZXR1cm4gbGEodCxoYSl9LHZhPXcsZGE9SGUseWE9VmUsZ2E9UWUsbWE9VixiYT1wYTskby5mPXZhJiYhZGE/T2JqZWN0LmRlZmluZVByb3BlcnRpZXM6ZnVuY3Rpb24odCxlKXtnYSh0KTtmb3IodmFyIHIsbj1tYShlKSxpPWJhKGUpLG89aS5sZW5ndGgsYT0wO28+YTspeWEuZih0LHI9aVthKytdLG5bcl0pO3JldHVybiB0fTt2YXIgX2Esd2E9dHQoXCJkb2N1bWVudFwiLFwiZG9jdW1lbnRFbGVtZW50XCIpLE9hPVFlLEVhPSRvLFRhPWZhLHhhPUVvLGthPXdhLFNhPXdlLEFhPU9vKFwiSUVfUFJPVE9cIiksamE9ZnVuY3Rpb24oKXt9LFBhPWZ1bmN0aW9uKHQpe3JldHVyblwiPHNjcmlwdD5cIit0K1wiPC9cIitcInNjcmlwdD5cIn0sSWE9ZnVuY3Rpb24odCl7dC53cml0ZShQYShcIlwiKSksdC5jbG9zZSgpO3ZhciBlPXQucGFyZW50V2luZG93Lk9iamVjdDtyZXR1cm4gdD1udWxsLGV9LERhPWZ1bmN0aW9uKCl7dHJ5e19hPW5ldyBBY3RpdmVYT2JqZWN0KFwiaHRtbGZpbGVcIil9Y2F0Y2godCl7fXZhciB0LGU7RGE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50P2RvY3VtZW50LmRvbWFpbiYmX2E/SWEoX2EpOigoZT1TYShcImlmcmFtZVwiKSkuc3R5bGUuZGlzcGxheT1cIm5vbmVcIixrYS5hcHBlbmRDaGlsZChlKSxlLnNyYz1TdHJpbmcoXCJqYXZhc2NyaXB0OlwiKSwodD1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQpLm9wZW4oKSx0LndyaXRlKFBhKFwiZG9jdW1lbnQuRj1PYmplY3RcIikpLHQuY2xvc2UoKSx0LkYpOklhKF9hKTtmb3IodmFyIHI9VGEubGVuZ3RoO3ItLTspZGVsZXRlIERhLnByb3RvdHlwZVtUYVtyXV07cmV0dXJuIERhKCl9O3hhW0FhXT0hMDt2YXIgTGEsQ2EsUmEsTWE9T2JqZWN0LmNyZWF0ZXx8ZnVuY3Rpb24odCxlKXt2YXIgcjtyZXR1cm4gbnVsbCE9PXQ/KGphLnByb3RvdHlwZT1PYSh0KSxyPW5ldyBqYSxqYS5wcm90b3R5cGU9bnVsbCxyW0FhXT10KTpyPURhKCksdm9pZCAwPT09ZT9yOkVhLmYocixlKX0sRmE9IWEoKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuY29uc3RydWN0b3I9bnVsbCxPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IHQpIT09dC5wcm90b3R5cGV9KSksTmE9byx6YT1VdCxxYT1iLFlhPVl0LEdhPUZhLFhhPU9vKFwiSUVfUFJPVE9cIiksVWE9TmEuT2JqZWN0LFdhPVVhLnByb3RvdHlwZSxWYT1HYT9VYS5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbih0KXt2YXIgZT1ZYSh0KTtpZih6YShlLFhhKSlyZXR1cm4gZVtYYV07dmFyIHI9ZS5jb25zdHJ1Y3RvcjtyZXR1cm4gcWEocikmJmUgaW5zdGFuY2VvZiByP3IucHJvdG90eXBlOmUgaW5zdGFuY2VvZiBVYT9XYTpudWxsfSxIYT1ociwkYT1mdW5jdGlvbih0LGUscixuKXtuJiZuLmVudW1lcmFibGU/dFtlXT1yOkhhKHQsZSxyKX0sQmE9YSxKYT1iLEthPU1hLFFhPVZhLFphPSRhLHR1PWFlKFwiaXRlcmF0b3JcIiksZXU9ITE7W10ua2V5cyYmKFwibmV4dFwiaW4oUmE9W10ua2V5cygpKT8oQ2E9UWEoUWEoUmEpKSkhPT1PYmplY3QucHJvdG90eXBlJiYoTGE9Q2EpOmV1PSEwKTt2YXIgcnU9bnVsbD09TGF8fEJhKChmdW5jdGlvbigpe3ZhciB0PXt9O3JldHVybiBMYVt0dV0uY2FsbCh0KSE9PXR9KSk7SmEoKExhPXJ1P3t9OkthKExhKSlbdHVdKXx8WmEoTGEsdHUsKGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSk7dmFyIG51PXtJdGVyYXRvclByb3RvdHlwZTpMYSxCVUdHWV9TQUZBUklfSVRFUkFUT1JTOmV1fSxpdT16bixvdT1Jbj97fS50b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiW29iamVjdCBcIitpdSh0aGlzKStcIl1cIn0sYXU9SW4sdXU9VmUuZixzdT1ocixjdT1VdCxmdT1vdSxsdT1hZShcInRvU3RyaW5nVGFnXCIpLGh1PWZ1bmN0aW9uKHQsZSxyLG4pe2lmKHQpe3ZhciBpPXI/dDp0LnByb3RvdHlwZTtjdShpLGx1KXx8dXUoaSxsdSx7Y29uZmlndXJhYmxlOiEwLHZhbHVlOmV9KSxuJiYhYXUmJnN1KGksXCJ0b1N0cmluZ1wiLGZ1KX19LHB1PXt9LHZ1PW51Lkl0ZXJhdG9yUHJvdG90eXBlLGR1PU1hLHl1PUksZ3U9aHUsbXU9cHUsYnU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sX3U9byx3dT1iLE91PV91LlN0cmluZyxFdT1fdS5UeXBlRXJyb3IsVHU9bSx4dT1RZSxrdT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiPT10eXBlb2YgdHx8d3UodCkpcmV0dXJuIHQ7dGhyb3cgRXUoXCJDYW4ndCBzZXQgXCIrT3UodCkrXCIgYXMgYSBwcm90b3R5cGVcIil9LFN1PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8KFwiX19wcm90b19fXCJpbnt9P2Z1bmN0aW9uKCl7dmFyIHQsZT0hMSxyPXt9O3RyeXsodD1UdShPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsXCJfX3Byb3RvX19cIikuc2V0KSkocixbXSksZT1yIGluc3RhbmNlb2YgQXJyYXl9Y2F0Y2godCl7fXJldHVybiBmdW5jdGlvbihyLG4pe3JldHVybiB4dShyKSxrdShuKSxlP3QocixuKTpyLl9fcHJvdG9fXz1uLHJ9fSgpOnZvaWQgMCksQXU9VHIsanU9VCxQdT1mdW5jdGlvbih0LGUscixuKXt2YXIgaT1lK1wiIEl0ZXJhdG9yXCI7cmV0dXJuIHQucHJvdG90eXBlPWR1KHZ1LHtuZXh0Onl1KCshbixyKX0pLGd1KHQsaSwhMSwhMCksbXVbaV09YnUsdH0sSXU9VmEsRHU9aHUsTHU9JGEsQ3U9cHUsUnU9SG8uUFJPUEVSLE11PW51LkJVR0dZX1NBRkFSSV9JVEVSQVRPUlMsRnU9YWUoXCJpdGVyYXRvclwiKSxOdT1cImtleXNcIix6dT1cInZhbHVlc1wiLHF1PVwiZW50cmllc1wiLFl1PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LEd1PWZ1bmN0aW9uKHQsZSxyLG4saSxvLGEpe1B1KHIsZSxuKTt2YXIgdSxzLGMsZj1mdW5jdGlvbih0KXtpZih0PT09aSYmZClyZXR1cm4gZDtpZighTXUmJnQgaW4gcClyZXR1cm4gcFt0XTtzd2l0Y2godCl7Y2FzZSBOdTpjYXNlIHp1OmNhc2UgcXU6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyByKHRoaXMsdCl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgcih0aGlzKX19LGw9ZStcIiBJdGVyYXRvclwiLGg9ITEscD10LnByb3RvdHlwZSx2PXBbRnVdfHxwW1wiQEBpdGVyYXRvclwiXXx8aSYmcFtpXSxkPSFNdSYmdnx8ZihpKSx5PVwiQXJyYXlcIj09ZSYmcC5lbnRyaWVzfHx2O2lmKHkmJih1PUl1KHkuY2FsbChuZXcgdCkpKSE9PU9iamVjdC5wcm90b3R5cGUmJnUubmV4dCYmKER1KHUsbCwhMCwhMCksQ3VbbF09WXUpLFJ1JiZpPT16dSYmdiYmdi5uYW1lIT09enUmJihoPSEwLGQ9ZnVuY3Rpb24oKXtyZXR1cm4ganUodix0aGlzKX0pLGkpaWYocz17dmFsdWVzOmYoenUpLGtleXM6bz9kOmYoTnUpLGVudHJpZXM6ZihxdSl9LGEpZm9yKGMgaW4gcykoTXV8fGh8fCEoYyBpbiBwKSkmJkx1KHAsYyxzW2NdKTtlbHNlIEF1KHt0YXJnZXQ6ZSxwcm90bzohMCxmb3JjZWQ6TXV8fGh9LHMpO3JldHVybiBhJiZwW0Z1XSE9PWQmJkx1KHAsRnUsZCx7bmFtZTppfSksQ3VbZV09ZCxzfSxYdT1wby5jaGFyQXQsVXU9aW8sV3U9WW8sVnU9R3UsSHU9XCJTdHJpbmcgSXRlcmF0b3JcIiwkdT1XdS5zZXQsQnU9V3UuZ2V0dGVyRm9yKEh1KTtWdShTdHJpbmcsXCJTdHJpbmdcIiwoZnVuY3Rpb24odCl7JHUodGhpcyx7dHlwZTpIdSxzdHJpbmc6VXUodCksaW5kZXg6MH0pfSksKGZ1bmN0aW9uKCl7dmFyIHQsZT1CdSh0aGlzKSxyPWUuc3RyaW5nLG49ZS5pbmRleDtyZXR1cm4gbj49ci5sZW5ndGg/e3ZhbHVlOnZvaWQgMCxkb25lOiEwfToodD1YdShyLG4pLGUuaW5kZXgrPXQubGVuZ3RoLHt2YWx1ZTp0LGRvbmU6ITF9KX0pKTt2YXIgSnU9VCxLdT1RZSxRdT1TdCxadT1mdW5jdGlvbih0LGUscil7dmFyIG4saTtLdSh0KTt0cnl7aWYoIShuPVF1KHQsXCJyZXR1cm5cIikpKXtpZihcInRocm93XCI9PT1lKXRocm93IHI7cmV0dXJuIHJ9bj1KdShuLHQpfWNhdGNoKHQpe2k9ITAsbj10fWlmKFwidGhyb3dcIj09PWUpdGhyb3cgcjtpZihpKXRocm93IG47cmV0dXJuIEt1KG4pLHJ9LHRzPVFlLGVzPVp1LHJzPXB1LG5zPWFlKFwiaXRlcmF0b3JcIiksaXM9QXJyYXkucHJvdG90eXBlLG9zPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10JiYocnMuQXJyYXk9PT10fHxpc1tuc109PT10KX0sYXM9Z2UsdXM9VmUsc3M9SSxjcz1mdW5jdGlvbih0LGUscil7dmFyIG49YXMoZSk7biBpbiB0P3VzLmYodCxuLHNzKDAscikpOnRbbl09cn0sZnM9em4sbHM9U3QsaHM9cHUscHM9YWUoXCJpdGVyYXRvclwiKSx2cz1mdW5jdGlvbih0KXtpZihudWxsIT10KXJldHVybiBscyh0LHBzKXx8bHModCxcIkBAaXRlcmF0b3JcIil8fGhzW2ZzKHQpXX0sZHM9VCx5cz14dCxncz1RZSxtcz13dCxicz12cyxfcz1vLlR5cGVFcnJvcix3cz1mdW5jdGlvbih0LGUpe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg8Mj9icyh0KTplO2lmKHlzKHIpKXJldHVybiBncyhkcyhyLHQpKTt0aHJvdyBfcyhtcyh0KStcIiBpcyBub3QgaXRlcmFibGVcIil9LE9zPVdlLEVzPVQsVHM9WXQseHM9ZnVuY3Rpb24odCxlLHIsbil7dHJ5e3JldHVybiBuP2UodHMocilbMF0sclsxXSk6ZShyKX1jYXRjaChlKXtlcyh0LFwidGhyb3dcIixlKX19LGtzPW9zLFNzPW5pLEFzPWNuLGpzPWNzLFBzPXdzLElzPXZzLERzPW8uQXJyYXksTHM9YWUoXCJpdGVyYXRvclwiKSxDcz0hMTt0cnl7dmFyIFJzPTAsTXM9e25leHQ6ZnVuY3Rpb24oKXtyZXR1cm57ZG9uZTohIVJzKyt9fSxyZXR1cm46ZnVuY3Rpb24oKXtDcz0hMH19O01zW0xzXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxBcnJheS5mcm9tKE1zLChmdW5jdGlvbigpe3Rocm93IDJ9KSl9Y2F0Y2godCl7fXZhciBGcz1mdW5jdGlvbih0KXt2YXIgZT1Ucyh0KSxyPVNzKHRoaXMpLG49YXJndW1lbnRzLmxlbmd0aCxpPW4+MT9hcmd1bWVudHNbMV06dm9pZCAwLG89dm9pZCAwIT09aTtvJiYoaT1PcyhpLG4+Mj9hcmd1bWVudHNbMl06dm9pZCAwKSk7dmFyIGEsdSxzLGMsZixsLGg9SXMoZSkscD0wO2lmKCFofHx0aGlzPT1EcyYma3MoaCkpZm9yKGE9QXMoZSksdT1yP25ldyB0aGlzKGEpOkRzKGEpO2E+cDtwKyspbD1vP2koZVtwXSxwKTplW3BdLGpzKHUscCxsKTtlbHNlIGZvcihmPShjPVBzKGUsaCkpLm5leHQsdT1yP25ldyB0aGlzOltdOyEocz1FcyhmLGMpKS5kb25lO3ArKylsPW8/eHMoYyxpLFtzLnZhbHVlLHBdLCEwKTpzLnZhbHVlLGpzKHUscCxsKTtyZXR1cm4gdS5sZW5ndGg9cCx1fSxOcz1mdW5jdGlvbih0LGUpe2lmKCFlJiYhQ3MpcmV0dXJuITE7dmFyIHI9ITE7dHJ5e3ZhciBuPXt9O25bTHNdPWZ1bmN0aW9uKCl7cmV0dXJue25leHQ6ZnVuY3Rpb24oKXtyZXR1cm57ZG9uZTpyPSEwfX19fSx0KG4pfWNhdGNoKHQpe31yZXR1cm4gcn07VHIoe3RhcmdldDpcIkFycmF5XCIsc3RhdDohMCxmb3JjZWQ6IU5zKChmdW5jdGlvbih0KXtBcnJheS5mcm9tKHQpfSkpfSx7ZnJvbTpGc30pO3ZhciB6cz1CLkFycmF5LmZyb20scXM9enMsWXM9VixHcz1wdSxYcz1ZbztWZS5mO3ZhciBVcz1HdSxXcz1cIkFycmF5IEl0ZXJhdG9yXCIsVnM9WHMuc2V0LEhzPVhzLmdldHRlckZvcihXcyk7VXMoQXJyYXksXCJBcnJheVwiLChmdW5jdGlvbih0LGUpe1ZzKHRoaXMse3R5cGU6V3MsdGFyZ2V0OllzKHQpLGluZGV4OjAsa2luZDplfSl9KSwoZnVuY3Rpb24oKXt2YXIgdD1Icyh0aGlzKSxlPXQudGFyZ2V0LHI9dC5raW5kLG49dC5pbmRleCsrO3JldHVybiFlfHxuPj1lLmxlbmd0aD8odC50YXJnZXQ9dm9pZCAwLHt2YWx1ZTp2b2lkIDAsZG9uZTohMH0pOlwia2V5c1wiPT1yP3t2YWx1ZTpuLGRvbmU6ITF9OlwidmFsdWVzXCI9PXI/e3ZhbHVlOmVbbl0sZG9uZTohMX06e3ZhbHVlOltuLGVbbl1dLGRvbmU6ITF9fSksXCJ2YWx1ZXNcIiksR3MuQXJndW1lbnRzPUdzLkFycmF5O3ZhciAkcz12cyxCcz17Q1NTUnVsZUxpc3Q6MCxDU1NTdHlsZURlY2xhcmF0aW9uOjAsQ1NTVmFsdWVMaXN0OjAsQ2xpZW50UmVjdExpc3Q6MCxET01SZWN0TGlzdDowLERPTVN0cmluZ0xpc3Q6MCxET01Ub2tlbkxpc3Q6MSxEYXRhVHJhbnNmZXJJdGVtTGlzdDowLEZpbGVMaXN0OjAsSFRNTEFsbENvbGxlY3Rpb246MCxIVE1MQ29sbGVjdGlvbjowLEhUTUxGb3JtRWxlbWVudDowLEhUTUxTZWxlY3RFbGVtZW50OjAsTWVkaWFMaXN0OjAsTWltZVR5cGVBcnJheTowLE5hbWVkTm9kZU1hcDowLE5vZGVMaXN0OjEsUGFpbnRSZXF1ZXN0TGlzdDowLFBsdWdpbjowLFBsdWdpbkFycmF5OjAsU1ZHTGVuZ3RoTGlzdDowLFNWR051bWJlckxpc3Q6MCxTVkdQYXRoU2VnTGlzdDowLFNWR1BvaW50TGlzdDowLFNWR1N0cmluZ0xpc3Q6MCxTVkdUcmFuc2Zvcm1MaXN0OjAsU291cmNlQnVmZmVyTGlzdDowLFN0eWxlU2hlZXRMaXN0OjAsVGV4dFRyYWNrQ3VlTGlzdDowLFRleHRUcmFja0xpc3Q6MCxUb3VjaExpc3Q6MH0sSnM9byxLcz16bixRcz1ocixacz1wdSx0Yz1hZShcInRvU3RyaW5nVGFnXCIpO2Zvcih2YXIgZWMgaW4gQnMpe3ZhciByYz1Kc1tlY10sbmM9cmMmJnJjLnByb3RvdHlwZTtuYyYmS3MobmMpIT09dGMmJlFzKG5jLHRjLGVjKSxac1tlY109WnMuQXJyYXl9dmFyIGljPSRzLG9jPXt9LGFjPWNhLHVjPWZhLmNvbmNhdChcImxlbmd0aFwiLFwicHJvdG90eXBlXCIpO29jLmY9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXN8fGZ1bmN0aW9uKHQpe3JldHVybiBhYyh0LHVjKX07dmFyIHNjPXt9LGNjPVFvLGZjPWNuLGxjPWNzLGhjPW8uQXJyYXkscGM9TWF0aC5tYXgsdmM9ZnVuY3Rpb24odCxlLHIpe2Zvcih2YXIgbj1mYyh0KSxpPWNjKGUsbiksbz1jYyh2b2lkIDA9PT1yP246cixuKSxhPWhjKHBjKG8taSwwKSksdT0wO2k8bztpKyssdSsrKWxjKGEsdSx0W2ldKTtyZXR1cm4gYS5sZW5ndGg9dSxhfSxkYz1SLHljPVYsZ2M9b2MuZixtYz12YyxiYz1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzP09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdyk6W107c2MuZj1mdW5jdGlvbih0KXtyZXR1cm4gYmMmJlwiV2luZG93XCI9PWRjKHQpP2Z1bmN0aW9uKHQpe3RyeXtyZXR1cm4gZ2ModCl9Y2F0Y2godCl7cmV0dXJuIG1jKGJjKX19KHQpOmdjKHljKHQpKX07dmFyIF9jPXt9O19jLmY9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sczt2YXIgd2M9e30sT2M9YWU7d2MuZj1PYzt2YXIgRWM9QixUYz1VdCx4Yz13YyxrYz1WZS5mLFNjPWZ1bmN0aW9uKHQpe3ZhciBlPUVjLlN5bWJvbHx8KEVjLlN5bWJvbD17fSk7VGMoZSx0KXx8a2MoZSx0LHt2YWx1ZTp4Yy5mKHQpfSl9LEFjPVRyLGpjPW8sUGM9dHQsSWM9aCxEYz1ULExjPW0sQ2M9dyxSYz1odCxNYz1hLEZjPVV0LE5jPWpuLHpjPWIscWM9JCxZYz1ldCxHYz1idCxYYz1RZSxVYz1ZdCxXYz1WLFZjPWdlLEhjPWlvLCRjPUksQmM9TWEsSmM9cGEsS2M9b2MsUWM9c2MsWmM9X2MsdGY9XyxlZj1WZSxyZj0kbyxuZj14LG9mPVJyLGFmPSRhLHVmPUR0LmV4cG9ydHMsc2Y9RW8sY2Y9QnQsZmY9YWUsbGY9d2MsaGY9U2MscGY9aHUsdmY9WW8sZGY9YmkuZm9yRWFjaCx5Zj1PbyhcImhpZGRlblwiKSxnZj1cIlN5bWJvbFwiLG1mPWZmKFwidG9QcmltaXRpdmVcIiksYmY9dmYuc2V0LF9mPXZmLmdldHRlckZvcihnZiksd2Y9T2JqZWN0LnByb3RvdHlwZSxPZj1qYy5TeW1ib2wsRWY9T2YmJk9mLnByb3RvdHlwZSxUZj1qYy5UeXBlRXJyb3IseGY9amMuUU9iamVjdCxrZj1QYyhcIkpTT05cIixcInN0cmluZ2lmeVwiKSxTZj10Zi5mLEFmPWVmLmYsamY9UWMuZixQZj1uZi5mLElmPUxjKFtdLnB1c2gpLERmPXVmKFwic3ltYm9sc1wiKSxMZj11ZihcIm9wLXN5bWJvbHNcIiksQ2Y9dWYoXCJzdHJpbmctdG8tc3ltYm9sLXJlZ2lzdHJ5XCIpLFJmPXVmKFwic3ltYm9sLXRvLXN0cmluZy1yZWdpc3RyeVwiKSxNZj11ZihcIndrc1wiKSxGZj0heGZ8fCF4Zi5wcm90b3R5cGV8fCF4Zi5wcm90b3R5cGUuZmluZENoaWxkLE5mPUNjJiZNYygoZnVuY3Rpb24oKXtyZXR1cm4gNyE9QmMoQWYoe30sXCJhXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBBZih0aGlzLFwiYVwiLHt2YWx1ZTo3fSkuYX19KSkuYX0pKT9mdW5jdGlvbih0LGUscil7dmFyIG49U2Yod2YsZSk7biYmZGVsZXRlIHdmW2VdLEFmKHQsZSxyKSxuJiZ0IT09d2YmJkFmKHdmLGUsbil9OkFmLHpmPWZ1bmN0aW9uKHQsZSl7dmFyIHI9RGZbdF09QmMoRWYpO3JldHVybiBiZihyLHt0eXBlOmdmLHRhZzp0LGRlc2NyaXB0aW9uOmV9KSxDY3x8KHIuZGVzY3JpcHRpb249ZSkscn0scWY9ZnVuY3Rpb24odCxlLHIpe3Q9PT13ZiYmcWYoTGYsZSxyKSxYYyh0KTt2YXIgbj1WYyhlKTtyZXR1cm4gWGMociksRmMoRGYsbik/KHIuZW51bWVyYWJsZT8oRmModCx5ZikmJnRbeWZdW25dJiYodFt5Zl1bbl09ITEpLHI9QmMocix7ZW51bWVyYWJsZTokYygwLCExKX0pKTooRmModCx5Zil8fEFmKHQseWYsJGMoMSx7fSkpLHRbeWZdW25dPSEwKSxOZih0LG4scikpOkFmKHQsbixyKX0sWWY9ZnVuY3Rpb24odCxlKXtYYyh0KTt2YXIgcj1XYyhlKSxuPUpjKHIpLmNvbmNhdChXZihyKSk7cmV0dXJuIGRmKG4sKGZ1bmN0aW9uKGUpe0NjJiYhRGMoR2YscixlKXx8cWYodCxlLHJbZV0pfSkpLHR9LEdmPWZ1bmN0aW9uKHQpe3ZhciBlPVZjKHQpLHI9RGMoUGYsdGhpcyxlKTtyZXR1cm4hKHRoaXM9PT13ZiYmRmMoRGYsZSkmJiFGYyhMZixlKSkmJighKHJ8fCFGYyh0aGlzLGUpfHwhRmMoRGYsZSl8fEZjKHRoaXMseWYpJiZ0aGlzW3lmXVtlXSl8fHIpfSxYZj1mdW5jdGlvbih0LGUpe3ZhciByPVdjKHQpLG49VmMoZSk7aWYociE9PXdmfHwhRmMoRGYsbil8fEZjKExmLG4pKXt2YXIgaT1TZihyLG4pO3JldHVybiFpfHwhRmMoRGYsbil8fEZjKHIseWYpJiZyW3lmXVtuXXx8KGkuZW51bWVyYWJsZT0hMCksaX19LFVmPWZ1bmN0aW9uKHQpe3ZhciBlPWpmKFdjKHQpKSxyPVtdO3JldHVybiBkZihlLChmdW5jdGlvbih0KXtGYyhEZix0KXx8RmMoc2YsdCl8fElmKHIsdCl9KSkscn0sV2Y9ZnVuY3Rpb24odCl7dmFyIGU9dD09PXdmLHI9amYoZT9MZjpXYyh0KSksbj1bXTtyZXR1cm4gZGYociwoZnVuY3Rpb24odCl7IUZjKERmLHQpfHxlJiYhRmMod2YsdCl8fElmKG4sRGZbdF0pfSkpLG59O2lmKFJjfHwoT2Y9ZnVuY3Rpb24oKXtpZihZYyhFZix0aGlzKSl0aHJvdyBUZihcIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvclwiKTt2YXIgdD1hcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/SGMoYXJndW1lbnRzWzBdKTp2b2lkIDAsZT1jZih0KSxyPWZ1bmN0aW9uKHQpe3RoaXM9PT13ZiYmRGMocixMZix0KSxGYyh0aGlzLHlmKSYmRmModGhpc1t5Zl0sZSkmJih0aGlzW3lmXVtlXT0hMSksTmYodGhpcyxlLCRjKDEsdCkpfTtyZXR1cm4gQ2MmJkZmJiZOZih3ZixlLHtjb25maWd1cmFibGU6ITAsc2V0OnJ9KSx6ZihlLHQpfSxhZihFZj1PZi5wcm90b3R5cGUsXCJ0b1N0cmluZ1wiLChmdW5jdGlvbigpe3JldHVybiBfZih0aGlzKS50YWd9KSksYWYoT2YsXCJ3aXRob3V0U2V0dGVyXCIsKGZ1bmN0aW9uKHQpe3JldHVybiB6ZihjZih0KSx0KX0pKSxuZi5mPUdmLGVmLmY9cWYscmYuZj1ZZix0Zi5mPVhmLEtjLmY9UWMuZj1VZixaYy5mPVdmLGxmLmY9ZnVuY3Rpb24odCl7cmV0dXJuIHpmKGZmKHQpLHQpfSxDYyYmQWYoRWYsXCJkZXNjcmlwdGlvblwiLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIF9mKHRoaXMpLmRlc2NyaXB0aW9ufX0pKSxBYyh7Z2xvYmFsOiEwLHdyYXA6ITAsZm9yY2VkOiFSYyxzaGFtOiFSY30se1N5bWJvbDpPZn0pLGRmKEpjKE1mKSwoZnVuY3Rpb24odCl7aGYodCl9KSksQWMoe3RhcmdldDpnZixzdGF0OiEwLGZvcmNlZDohUmN9LHtmb3I6ZnVuY3Rpb24odCl7dmFyIGU9SGModCk7aWYoRmMoQ2YsZSkpcmV0dXJuIENmW2VdO3ZhciByPU9mKGUpO3JldHVybiBDZltlXT1yLFJmW3JdPWUscn0sa2V5Rm9yOmZ1bmN0aW9uKHQpe2lmKCFHYyh0KSl0aHJvdyBUZih0K1wiIGlzIG5vdCBhIHN5bWJvbFwiKTtpZihGYyhSZix0KSlyZXR1cm4gUmZbdF19LHVzZVNldHRlcjpmdW5jdGlvbigpe0ZmPSEwfSx1c2VTaW1wbGU6ZnVuY3Rpb24oKXtGZj0hMX19KSxBYyh7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxmb3JjZWQ6IVJjLHNoYW06IUNjfSx7Y3JlYXRlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWU/QmModCk6WWYoQmModCksZSl9LGRlZmluZVByb3BlcnR5OnFmLGRlZmluZVByb3BlcnRpZXM6WWYsZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOlhmfSksQWMoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOiFSY30se2dldE93blByb3BlcnR5TmFtZXM6VWYsZ2V0T3duUHJvcGVydHlTeW1ib2xzOldmfSksQWMoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOk1jKChmdW5jdGlvbigpe1pjLmYoMSl9KSl9LHtnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ZnVuY3Rpb24odCl7cmV0dXJuIFpjLmYoVWModCkpfX0pLGtmKXt2YXIgVmY9IVJjfHxNYygoZnVuY3Rpb24oKXt2YXIgdD1PZigpO3JldHVyblwiW251bGxdXCIhPWtmKFt0XSl8fFwie31cIiE9a2Yoe2E6dH0pfHxcInt9XCIhPWtmKE9iamVjdCh0KSl9KSk7QWMoe3RhcmdldDpcIkpTT05cIixzdGF0OiEwLGZvcmNlZDpWZn0se3N0cmluZ2lmeTpmdW5jdGlvbih0LGUscil7dmFyIG49b2YoYXJndW1lbnRzKSxpPWU7aWYoKHFjKGUpfHx2b2lkIDAhPT10KSYmIUdjKHQpKXJldHVybiBOYyhlKXx8KGU9ZnVuY3Rpb24odCxlKXtpZih6YyhpKSYmKGU9RGMoaSx0aGlzLHQsZSkpLCFHYyhlKSlyZXR1cm4gZX0pLG5bMV09ZSxJYyhrZixudWxsLG4pfX0pfWlmKCFFZlttZl0pe3ZhciBIZj1FZi52YWx1ZU9mO2FmKEVmLG1mLChmdW5jdGlvbih0KXtyZXR1cm4gRGMoSGYsdGhpcyl9KSl9cGYoT2YsZ2YpLHNmW3lmXT0hMDt2YXIgJGY9Qi5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLEJmPXtleHBvcnRzOnt9fSxKZj1UcixLZj1hLFFmPVYsWmY9Xy5mLHRsPXcsZWw9S2YoKGZ1bmN0aW9uKCl7WmYoMSl9KSk7SmYoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOiF0bHx8ZWwsc2hhbTohdGx9LHtnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ZnVuY3Rpb24odCxlKXtyZXR1cm4gWmYoUWYodCksZSl9fSk7dmFyIHJsPUIuT2JqZWN0LG5sPUJmLmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gcmwuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsZSl9O3JsLmdldE93blByb3BlcnR5RGVzY3JpcHRvci5zaGFtJiYobmwuc2hhbT0hMCk7dmFyIGlsPUJmLmV4cG9ydHMsb2w9dHQsYWw9b2MsdWw9X2Msc2w9UWUsY2w9bShbXS5jb25jYXQpLGZsPW9sKFwiUmVmbGVjdFwiLFwib3duS2V5c1wiKXx8ZnVuY3Rpb24odCl7dmFyIGU9YWwuZihzbCh0KSkscj11bC5mO3JldHVybiByP2NsKGUscih0KSk6ZX0sbGw9ZmwsaGw9VixwbD1fLHZsPWNzO1RyKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLHNoYW06IXd9LHtnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxyLG49aGwodCksaT1wbC5mLG89bGwobiksYT17fSx1PTA7by5sZW5ndGg+dTspdm9pZCAwIT09KHI9aShuLGU9b1t1KytdKSkmJnZsKGEsZSxyKTtyZXR1cm4gYX19KTt2YXIgZGw9Qi5PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyx5bD17ZXhwb3J0czp7fX0sZ2w9VHIsbWw9dyxibD0kby5mO2dsKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDpPYmplY3QuZGVmaW5lUHJvcGVydGllcyE9PWJsLHNoYW06IW1sfSx7ZGVmaW5lUHJvcGVydGllczpibH0pO3ZhciBfbD1CLk9iamVjdCx3bD15bC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIF9sLmRlZmluZVByb3BlcnRpZXModCxlKX07X2wuZGVmaW5lUHJvcGVydGllcy5zaGFtJiYod2wuc2hhbT0hMCk7dmFyIE9sPXlsLmV4cG9ydHMsRWw9UHI7VHIoe3RhcmdldDpcIkFycmF5XCIsc3RhdDohMH0se2lzQXJyYXk6am59KTt2YXIgVGw9Qi5BcnJheS5pc0FycmF5LHhsPVRsO3ZhciBrbD1UcixTbD1vLEFsPWEsamw9am4sUGw9JCxJbD1ZdCxEbD1jbixMbD1jcyxDbD1saSxSbD1FaSxNbD1jdCxGbD1hZShcImlzQ29uY2F0U3ByZWFkYWJsZVwiKSxObD05MDA3MTk5MjU0NzQwOTkxLHpsPVwiTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkXCIscWw9U2wuVHlwZUVycm9yLFlsPU1sPj01MXx8IUFsKChmdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiB0W0ZsXT0hMSx0LmNvbmNhdCgpWzBdIT09dH0pKSxHbD1SbChcImNvbmNhdFwiKSxYbD1mdW5jdGlvbih0KXtpZighUGwodCkpcmV0dXJuITE7dmFyIGU9dFtGbF07cmV0dXJuIHZvaWQgMCE9PWU/ISFlOmpsKHQpfTtrbCh7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IVlsfHwhR2x9LHtjb25jYXQ6ZnVuY3Rpb24odCl7dmFyIGUscixuLGksbyxhPUlsKHRoaXMpLHU9Q2woYSwwKSxzPTA7Zm9yKGU9LTEsbj1hcmd1bWVudHMubGVuZ3RoO2U8bjtlKyspaWYoWGwobz0tMT09PWU/YTphcmd1bWVudHNbZV0pKXtpZihzKyhpPURsKG8pKT5ObCl0aHJvdyBxbCh6bCk7Zm9yKHI9MDtyPGk7cisrLHMrKylyIGluIG8mJkxsKHUscyxvW3JdKX1lbHNle2lmKHM+PU5sKXRocm93IHFsKHpsKTtMbCh1LHMrKyxvKX1yZXR1cm4gdS5sZW5ndGg9cyx1fX0pLFNjKFwiYXN5bmNJdGVyYXRvclwiKSxTYyhcImhhc0luc3RhbmNlXCIpLFNjKFwiaXNDb25jYXRTcHJlYWRhYmxlXCIpLFNjKFwiaXRlcmF0b3JcIiksU2MoXCJtYXRjaFwiKSxTYyhcIm1hdGNoQWxsXCIpLFNjKFwicmVwbGFjZVwiKSxTYyhcInNlYXJjaFwiKSxTYyhcInNwZWNpZXNcIiksU2MoXCJzcGxpdFwiKSxTYyhcInRvUHJpbWl0aXZlXCIpLFNjKFwidG9TdHJpbmdUYWdcIiksU2MoXCJ1bnNjb3BhYmxlc1wiKSxodShvLkpTT04sXCJKU09OXCIsITApO3ZhciBVbD1CLlN5bWJvbCxXbD1VbDtTYyhcImFzeW5jRGlzcG9zZVwiKSxTYyhcImRpc3Bvc2VcIiksU2MoXCJtYXRjaGVyXCIpLFNjKFwibWV0YWRhdGFcIiksU2MoXCJvYnNlcnZhYmxlXCIpLFNjKFwicGF0dGVybk1hdGNoXCIpLFNjKFwicmVwbGFjZUFsbFwiKTt2YXIgVmw9V2w7dmFyIEhsPVRyLCRsPW8sQmw9am4sSmw9bmksS2w9JCxRbD1RbyxabD1jbix0aD1WLGVoPWNzLHJoPWFlLG5oPVJyLGloPUVpKFwic2xpY2VcIiksb2g9cmgoXCJzcGVjaWVzXCIpLGFoPSRsLkFycmF5LHVoPU1hdGgubWF4O0hsKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohaWh9LHtzbGljZTpmdW5jdGlvbih0LGUpe3ZhciByLG4saSxvPXRoKHRoaXMpLGE9WmwobyksdT1RbCh0LGEpLHM9UWwodm9pZCAwPT09ZT9hOmUsYSk7aWYoQmwobykmJihyPW8uY29uc3RydWN0b3IsKEpsKHIpJiYocj09PWFofHxCbChyLnByb3RvdHlwZSkpfHxLbChyKSYmbnVsbD09PShyPXJbb2hdKSkmJihyPXZvaWQgMCkscj09PWFofHx2b2lkIDA9PT1yKSlyZXR1cm4gbmgobyx1LHMpO2ZvcihuPW5ldyh2b2lkIDA9PT1yP2FoOnIpKHVoKHMtdSwwKSksaT0wO3U8czt1KyssaSsrKXUgaW4gbyYmZWgobixpLG9bdV0pO3JldHVybiBuLmxlbmd0aD1pLG59fSk7dmFyIHNoPUpyKFwiQXJyYXlcIikuc2xpY2UsY2g9ZXQsZmg9c2gsbGg9QXJyYXkucHJvdG90eXBlLGhoPWZ1bmN0aW9uKHQpe3ZhciBlPXQuc2xpY2U7cmV0dXJuIHQ9PT1saHx8Y2gobGgsdCkmJmU9PT1saC5zbGljZT9maDplfSxwaD1oaCx2aD16cztmdW5jdGlvbiBkaCh0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgcj0wLG49bmV3IEFycmF5KGUpO3I8ZTtyKyspbltyXT10W3JdO3JldHVybiBufWZ1bmN0aW9uIHloKHQsZSl7dmFyIHI7aWYodCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIGRoKHQsZSk7dmFyIG49cGgocj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpLmNhbGwociw4LC0xKTtyZXR1cm5cIk9iamVjdFwiPT09biYmdC5jb25zdHJ1Y3RvciYmKG49dC5jb25zdHJ1Y3Rvci5uYW1lKSxcIk1hcFwiPT09bnx8XCJTZXRcIj09PW4/dmgodCk6XCJBcmd1bWVudHNcIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pP2RoKHQsZSk6dm9pZCAwfX1mdW5jdGlvbiBnaCh0LGUpe3JldHVybiBmdW5jdGlvbih0KXtpZih4bCh0KSlyZXR1cm4gdH0odCl8fGZ1bmN0aW9uKHQsZSl7dmFyIHI9bnVsbD09dD9udWxsOnZvaWQgMCE9PVZsJiZpYyh0KXx8dFtcIkBAaXRlcmF0b3JcIl07aWYobnVsbCE9cil7dmFyIG4saSxvPVtdLGE9ITAsdT0hMTt0cnl7Zm9yKHI9ci5jYWxsKHQpOyEoYT0obj1yLm5leHQoKSkuZG9uZSkmJihvLnB1c2gobi52YWx1ZSksIWV8fG8ubGVuZ3RoIT09ZSk7YT0hMCk7fWNhdGNoKHQpe3U9ITAsaT10fWZpbmFsbHl7dHJ5e2F8fG51bGw9PXIucmV0dXJufHxyLnJldHVybigpfWZpbmFsbHl7aWYodSl0aHJvdyBpfX1yZXR1cm4gb319KHQsZSl8fHloKHQsZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX0oKX12YXIgbWg9d2MuZihcIml0ZXJhdG9yXCIpLGJoPW1oO2Z1bmN0aW9uIF9oKHQpe3JldHVybiBfaD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBWbCYmXCJzeW1ib2xcIj09dHlwZW9mIGJoP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFZsJiZ0LmNvbnN0cnVjdG9yPT09VmwmJnQhPT1WbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0sX2godCl9ZnVuY3Rpb24gd2godCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKHhsKHQpKXJldHVybiBkaCh0KX0odCl8fGZ1bmN0aW9uKHQpe2lmKHZvaWQgMCE9PVZsJiZudWxsIT1pYyh0KXx8bnVsbCE9dFtcIkBAaXRlcmF0b3JcIl0pcmV0dXJuIHZoKHQpfSh0KXx8eWgodCl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCl9dmFyIE9oPVVsLEVoPUpyKFwiQXJyYXlcIikuY29uY2F0LFRoPWV0LHhoPUVoLGtoPUFycmF5LnByb3RvdHlwZSxTaD1mdW5jdGlvbih0KXt2YXIgZT10LmNvbmNhdDtyZXR1cm4gdD09PWtofHxUaChraCx0KSYmZT09PWtoLmNvbmNhdD94aDplfSxBaD1oaDtUcih7dGFyZ2V0OlwiUmVmbGVjdFwiLHN0YXQ6ITB9LHtvd25LZXlzOmZsfSk7dmFyIGpoPUIuUmVmbGVjdC5vd25LZXlzLFBoPVRsLEloPVl0LERoPXBhO1RyKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDphKChmdW5jdGlvbigpe0RoKDEpfSkpfSx7a2V5czpmdW5jdGlvbih0KXtyZXR1cm4gRGgoSWgodCkpfX0pO3ZhciBMaD1CLk9iamVjdC5rZXlzLENoPVRyLFJoPW0sTWg9by5EYXRlLEZoPVJoKE1oLnByb3RvdHlwZS5nZXRUaW1lKTtDaCh7dGFyZ2V0OlwiRGF0ZVwiLHN0YXQ6ITB9LHtub3c6ZnVuY3Rpb24oKXtyZXR1cm4gRmgobmV3IE1oKX19KSxCLkRhdGUubm93O3ZhciBOaD1iaS5mb3JFYWNoLHpoPW1uKFwiZm9yRWFjaFwiKT9bXS5mb3JFYWNoOmZ1bmN0aW9uKHQpe3JldHVybiBOaCh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfTtUcih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6W10uZm9yRWFjaCE9emh9LHtmb3JFYWNoOnpofSk7dmFyIHFoPUpyKFwiQXJyYXlcIikuZm9yRWFjaCxZaD16bixHaD1VdCxYaD1ldCxVaD1xaCxXaD1BcnJheS5wcm90b3R5cGUsVmg9e0RPTVRva2VuTGlzdDohMCxOb2RlTGlzdDohMH0sSGg9ZnVuY3Rpb24odCl7dmFyIGU9dC5mb3JFYWNoO3JldHVybiB0PT09V2h8fFhoKFdoLHQpJiZlPT09V2guZm9yRWFjaHx8R2goVmgsWWgodCkpP1VoOmV9LCRoPVRyLEJoPWpuLEpoPW0oW10ucmV2ZXJzZSksS2g9WzEsMl07JGgoe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOlN0cmluZyhLaCk9PT1TdHJpbmcoS2gucmV2ZXJzZSgpKX0se3JldmVyc2U6ZnVuY3Rpb24oKXtyZXR1cm4gQmgodGhpcykmJih0aGlzLmxlbmd0aD10aGlzLmxlbmd0aCksSmgodGhpcyl9fSk7dmFyIFFoPUpyKFwiQXJyYXlcIikucmV2ZXJzZSxaaD1ldCx0cD1RaCxlcD1BcnJheS5wcm90b3R5cGUscnA9ZnVuY3Rpb24odCl7dmFyIGU9dC5yZXZlcnNlO3JldHVybiB0PT09ZXB8fFpoKGVwLHQpJiZlPT09ZXAucmV2ZXJzZT90cDplfSxucD1UcixpcD1vLG9wPVFvLGFwPW9uLHVwPWNuLHNwPVl0LGNwPWxpLGZwPWNzLGxwPUVpKFwic3BsaWNlXCIpLGhwPWlwLlR5cGVFcnJvcixwcD1NYXRoLm1heCx2cD1NYXRoLm1pbixkcD05MDA3MTk5MjU0NzQwOTkxLHlwPVwiTWF4aW11bSBhbGxvd2VkIGxlbmd0aCBleGNlZWRlZFwiO25wKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohbHB9LHtzcGxpY2U6ZnVuY3Rpb24odCxlKXt2YXIgcixuLGksbyxhLHUscz1zcCh0aGlzKSxjPXVwKHMpLGY9b3AodCxjKSxsPWFyZ3VtZW50cy5sZW5ndGg7aWYoMD09PWw/cj1uPTA6MT09PWw/KHI9MCxuPWMtZik6KHI9bC0yLG49dnAocHAoYXAoZSksMCksYy1mKSksYytyLW4+ZHApdGhyb3cgaHAoeXApO2ZvcihpPWNwKHMsbiksbz0wO288bjtvKyspKGE9ZitvKWluIHMmJmZwKGksbyxzW2FdKTtpZihpLmxlbmd0aD1uLHI8bil7Zm9yKG89ZjtvPGMtbjtvKyspdT1vK3IsKGE9bytuKWluIHM/c1t1XT1zW2FdOmRlbGV0ZSBzW3VdO2ZvcihvPWM7bz5jLW4rcjtvLS0pZGVsZXRlIHNbby0xXX1lbHNlIGlmKHI+bilmb3Iobz1jLW47bz5mO28tLSl1PW8rci0xLChhPW8rbi0xKWluIHM/c1t1XT1zW2FdOmRlbGV0ZSBzW3VdO2ZvcihvPTA7bzxyO28rKylzW28rZl09YXJndW1lbnRzW28rMl07cmV0dXJuIHMubGVuZ3RoPWMtbityLGl9fSk7dmFyIGdwPUpyKFwiQXJyYXlcIikuc3BsaWNlLG1wPWV0LGJwPWdwLF9wPUFycmF5LnByb3RvdHlwZSx3cD1mdW5jdGlvbih0KXt2YXIgZT10LnNwbGljZTtyZXR1cm4gdD09PV9wfHxtcChfcCx0KSYmZT09PV9wLnNwbGljZT9icDplfSxPcD13LEVwPW0sVHA9VCx4cD1hLGtwPXBhLFNwPV9jLEFwPXgsanA9WXQsUHA9WSxJcD1PYmplY3QuYXNzaWduLERwPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxMcD1FcChbXS5jb25jYXQpLENwPSFJcHx8eHAoKGZ1bmN0aW9uKCl7aWYoT3AmJjEhPT1JcCh7YjoxfSxJcChEcCh7fSxcImFcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtEcCh0aGlzLFwiYlwiLHt2YWx1ZTozLGVudW1lcmFibGU6ITF9KX19KSx7YjoyfSkpLmIpcmV0dXJuITA7dmFyIHQ9e30sZT17fSxyPVN5bWJvbCgpLG49XCJhYmNkZWZnaGlqa2xtbm9wcXJzdFwiO3JldHVybiB0W3JdPTcsbi5zcGxpdChcIlwiKS5mb3JFYWNoKChmdW5jdGlvbih0KXtlW3RdPXR9KSksNyE9SXAoe30sdClbcl18fGtwKElwKHt9LGUpKS5qb2luKFwiXCIpIT1ufSkpP2Z1bmN0aW9uKHQsZSl7Zm9yKHZhciByPWpwKHQpLG49YXJndW1lbnRzLmxlbmd0aCxpPTEsbz1TcC5mLGE9QXAuZjtuPmk7KWZvcih2YXIgdSxzPVBwKGFyZ3VtZW50c1tpKytdKSxjPW8/THAoa3AocyksbyhzKSk6a3AocyksZj1jLmxlbmd0aCxsPTA7Zj5sOyl1PWNbbCsrXSxPcCYmIVRwKGEscyx1KXx8KHJbdV09c1t1XSk7cmV0dXJuIHJ9OklwLFJwPUNwO1RyKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDpPYmplY3QuYXNzaWduIT09UnB9LHthc3NpZ246UnB9KTt2YXIgTXA9Qi5PYmplY3QuYXNzaWduLEZwPW5hLmluY2x1ZGVzO1RyKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwfSx7aW5jbHVkZXM6ZnVuY3Rpb24odCl7cmV0dXJuIEZwKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSksSnIoXCJBcnJheVwiKS5pbmNsdWRlczt2YXIgTnA9JCx6cD1SLHFwPWFlKFwibWF0Y2hcIiksWXA9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIE5wKHQpJiYodm9pZCAwIT09KGU9dFtxcF0pPyEhZTpcIlJlZ0V4cFwiPT16cCh0KSl9LEdwPW8uVHlwZUVycm9yLFhwPWFlKFwibWF0Y2hcIiksVXA9VHIsV3A9ZnVuY3Rpb24odCl7aWYoWXAodCkpdGhyb3cgR3AoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7cmV0dXJuIHR9LFZwPVgsSHA9aW8sJHA9ZnVuY3Rpb24odCl7dmFyIGU9Ly4vO3RyeXtcIi8uL1wiW3RdKGUpfWNhdGNoKHIpe3RyeXtyZXR1cm4gZVtYcF09ITEsXCIvLi9cIlt0XShlKX1jYXRjaCh0KXt9fXJldHVybiExfSxCcD1tKFwiXCIuaW5kZXhPZik7VXAoe3RhcmdldDpcIlN0cmluZ1wiLHByb3RvOiEwLGZvcmNlZDohJHAoXCJpbmNsdWRlc1wiKX0se2luY2x1ZGVzOmZ1bmN0aW9uKHQpe3JldHVybiEhfkJwKEhwKFZwKHRoaXMpKSxIcChXcCh0KSksYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pLEpyKFwiU3RyaW5nXCIpLmluY2x1ZGVzO3ZhciBKcD1ZdCxLcD1WYSxRcD1GYTtUcih7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxmb3JjZWQ6YSgoZnVuY3Rpb24oKXtLcCgxKX0pKSxzaGFtOiFRcH0se2dldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3JldHVybiBLcChKcCh0KSl9fSk7dmFyIFpwPUIuT2JqZWN0LmdldFByb3RvdHlwZU9mLHR2PXcsZXY9bSxydj1wYSxudj1WLGl2PWV2KHguZiksb3Y9ZXYoW10ucHVzaCksYXY9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Zvcih2YXIgcixuPW52KGUpLGk9cnYobiksbz1pLmxlbmd0aCxhPTAsdT1bXTtvPmE7KXI9aVthKytdLHR2JiYhaXYobixyKXx8b3YodSx0P1tyLG5bcl1dOm5bcl0pO3JldHVybiB1fX0sdXY9e2VudHJpZXM6YXYoITApLHZhbHVlczphdighMSl9LnZhbHVlcztUcih7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMH0se3ZhbHVlczpmdW5jdGlvbih0KXtyZXR1cm4gdXYodCl9fSksQi5PYmplY3QudmFsdWVzO3ZhciBzdj1cIlxcdFxcblxcdlxcZlxcciDCoOGagOKAgOKAgeKAguKAg+KAhOKAheKAhuKAh+KAiOKAieKAiuKAr+KBn+OAgFxcdTIwMjhcXHUyMDI5XFx1ZmVmZlwiLGN2PVgsZnY9aW8sbHY9bShcIlwiLnJlcGxhY2UpLGh2PVwiW1xcdFxcblxcdlxcZlxcciDCoOGagOKAgOKAgeKAguKAg+KAhOKAheKAhuKAh+KAiOKAieKAiuKAr+KBn+OAgFxcdTIwMjhcXHUyMDI5XFx1ZmVmZl1cIixwdj1SZWdFeHAoXCJeXCIraHYraHYrXCIqXCIpLHZ2PVJlZ0V4cChoditoditcIiokXCIpLGR2PWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgcj1mdihjdihlKSk7cmV0dXJuIDEmdCYmKHI9bHYocixwdixcIlwiKSksMiZ0JiYocj1sdihyLHZ2LFwiXCIpKSxyfX0seXY9e3N0YXJ0OmR2KDEpLGVuZDpkdigyKSx0cmltOmR2KDMpfSxndj1vLG12PWEsYnY9bSxfdj1pbyx3dj15di50cmltLE92PXN2LEV2PWd2LnBhcnNlSW50LFR2PWd2LlN5bWJvbCx4dj1UdiYmVHYuaXRlcmF0b3Isa3Y9L15bKy1dPzB4L2ksU3Y9YnYoa3YuZXhlYyksQXY9OCE9PUV2KE92K1wiMDhcIil8fDIyIT09RXYoT3YrXCIweDE2XCIpfHx4diYmIW12KChmdW5jdGlvbigpe0V2KE9iamVjdCh4dikpfSkpP2Z1bmN0aW9uKHQsZSl7dmFyIHI9d3YoX3YodCkpO3JldHVybiBFdihyLGU+Pj4wfHwoU3Yoa3Yscik/MTY6MTApKX06RXY7VHIoe2dsb2JhbDohMCxmb3JjZWQ6cGFyc2VJbnQhPUF2fSx7cGFyc2VJbnQ6QXZ9KTt2YXIganY9VHIsUHY9bmEuaW5kZXhPZixJdj1tbixEdj1tKFtdLmluZGV4T2YpLEx2PSEhRHYmJjEvRHYoWzFdLDEsLTApPDAsQ3Y9SXYoXCJpbmRleE9mXCIpO2p2KHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDpMdnx8IUN2fSx7aW5kZXhPZjpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMDtyZXR1cm4gTHY/RHYodGhpcyx0LGUpfHwwOlB2KHRoaXMsdCxlKX19KSxKcihcIkFycmF5XCIpLmluZGV4T2Y7dmFyIFJ2PUhvLlBST1BFUixNdj1hLEZ2PXN2LE52PXl2LnRyaW07VHIoe3RhcmdldDpcIlN0cmluZ1wiLHByb3RvOiEwLGZvcmNlZDpmdW5jdGlvbih0KXtyZXR1cm4gTXYoKGZ1bmN0aW9uKCl7cmV0dXJuISFGdlt0XSgpfHxcIuKAi8KF4aCOXCIhPT1cIuKAi8KF4aCOXCJbdF0oKXx8UnYmJkZ2W3RdLm5hbWUhPT10fSkpfShcInRyaW1cIil9LHt0cmltOmZ1bmN0aW9uKCl7cmV0dXJuIE52KHRoaXMpfX0pLEpyKFwiU3RyaW5nXCIpLnRyaW0sVHIoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsc2hhbTohd30se2NyZWF0ZTpNYX0pO3ZhciB6dj1CLk9iamVjdCxxdj1mdW5jdGlvbih0LGUpe3JldHVybiB6di5jcmVhdGUodCxlKX0sWXY9cXYsR3Y9VHIsWHY9dHQsVXY9aCxXdj1tLFZ2PWEsSHY9by5BcnJheSwkdj1YdihcIkpTT05cIixcInN0cmluZ2lmeVwiKSxCdj1XdigvLi8uZXhlYyksSnY9V3YoXCJcIi5jaGFyQXQpLEt2PVd2KFwiXCIuY2hhckNvZGVBdCksUXY9V3YoXCJcIi5yZXBsYWNlKSxadj1XdigxLi50b1N0cmluZyksdGQ9L1tcXHVEODAwLVxcdURGRkZdL2csZWQ9L15bXFx1RDgwMC1cXHVEQkZGXSQvLHJkPS9eW1xcdURDMDAtXFx1REZGRl0kLyxuZD1mdW5jdGlvbih0LGUscil7dmFyIG49SnYocixlLTEpLGk9SnYocixlKzEpO3JldHVybiBCdihlZCx0KSYmIUJ2KHJkLGkpfHxCdihyZCx0KSYmIUJ2KGVkLG4pP1wiXFxcXHVcIitadihLdih0LDApLDE2KTp0fSxpZD1WdigoZnVuY3Rpb24oKXtyZXR1cm4nXCJcXFxcdWRmMDZcXFxcdWQ4MzRcIichPT0kdihcIlxcdWRmMDZcXHVkODM0XCIpfHwnXCJcXFxcdWRlYWRcIichPT0kdihcIlxcdWRlYWRcIil9KSk7JHYmJkd2KHt0YXJnZXQ6XCJKU09OXCIsc3RhdDohMCxmb3JjZWQ6aWR9LHtzdHJpbmdpZnk6ZnVuY3Rpb24odCxlLHIpe2Zvcih2YXIgbj0wLGk9YXJndW1lbnRzLmxlbmd0aCxvPUh2KGkpO248aTtuKyspb1tuXT1hcmd1bWVudHNbbl07dmFyIGE9VXYoJHYsbnVsbCxvKTtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgYT9RdihhLHRkLG5kKTphfX0pO3ZhciBvZD1CLGFkPWg7b2QuSlNPTnx8KG9kLkpTT049e3N0cmluZ2lmeTpKU09OLnN0cmluZ2lmeX0pO3ZhciB1ZD1mdW5jdGlvbih0LGUscil7cmV0dXJuIGFkKG9kLkpTT04uc3RyaW5naWZ5LG51bGwsYXJndW1lbnRzKX0sc2Q9dWQsY2Q9by5UeXBlRXJyb3IsZmQ9VHIsbGQ9byxoZD1oLHBkPWIsdmQ9UnIsZGQ9ZnVuY3Rpb24odCxlKXtpZih0PGUpdGhyb3cgY2QoXCJOb3QgZW5vdWdoIGFyZ3VtZW50c1wiKTtyZXR1cm4gdH0seWQ9L01TSUUgLlxcLi8udGVzdChydCksZ2Q9bGQuRnVuY3Rpb24sbWQ9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUscil7dmFyIG49ZGQoYXJndW1lbnRzLmxlbmd0aCwxKT4yLGk9cGQoZSk/ZTpnZChlKSxvPW4/dmQoYXJndW1lbnRzLDIpOnZvaWQgMDtyZXR1cm4gdChuP2Z1bmN0aW9uKCl7aGQoaSx0aGlzLG8pfTppLHIpfX07ZmQoe2dsb2JhbDohMCxiaW5kOiEwLGZvcmNlZDp5ZH0se3NldFRpbWVvdXQ6bWQobGQuc2V0VGltZW91dCksc2V0SW50ZXJ2YWw6bWQobGQuc2V0SW50ZXJ2YWwpfSk7dmFyIGJkPUIuc2V0VGltZW91dCxfZD1ZdCx3ZD1RbyxPZD1jbixFZD1mdW5jdGlvbih0KXtmb3IodmFyIGU9X2QodGhpcykscj1PZChlKSxuPWFyZ3VtZW50cy5sZW5ndGgsaT13ZChuPjE/YXJndW1lbnRzWzFdOnZvaWQgMCxyKSxvPW4+Mj9hcmd1bWVudHNbMl06dm9pZCAwLGE9dm9pZCAwPT09bz9yOndkKG8scik7YT5pOyllW2krK109dDtyZXR1cm4gZX07VHIoe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITB9LHtmaWxsOkVkfSksSnIoXCJBcnJheVwiKS5maWxsO3ZhciBUZD17ZXhwb3J0czp7fX07IWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7aWYodClyZXR1cm4gZnVuY3Rpb24odCl7Zm9yKHZhciByIGluIGUucHJvdG90eXBlKXRbcl09ZS5wcm90b3R5cGVbcl07cmV0dXJuIHR9KHQpfXQuZXhwb3J0cz1lLGUucHJvdG90eXBlLm9uPWUucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e30sKHRoaXMuX2NhbGxiYWNrc1tcIiRcIit0XT10aGlzLl9jYWxsYmFja3NbXCIkXCIrdF18fFtdKS5wdXNoKGUpLHRoaXN9LGUucHJvdG90eXBlLm9uY2U9ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiByKCl7dGhpcy5vZmYodCxyKSxlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gci5mbj1lLHRoaXMub24odCxyKSx0aGlzfSxlLnByb3RvdHlwZS5vZmY9ZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI9ZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzPWUucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24odCxlKXtpZih0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzfHx7fSwwPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl9jYWxsYmFja3M9e30sdGhpczt2YXIgcixuPXRoaXMuX2NhbGxiYWNrc1tcIiRcIit0XTtpZighbilyZXR1cm4gdGhpcztpZigxPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW1wiJFwiK3RdLHRoaXM7Zm9yKHZhciBpPTA7aTxuLmxlbmd0aDtpKyspaWYoKHI9bltpXSk9PT1lfHxyLmZuPT09ZSl7bi5zcGxpY2UoaSwxKTticmVha31yZXR1cm4gMD09PW4ubGVuZ3RoJiZkZWxldGUgdGhpcy5fY2FsbGJhY2tzW1wiJFwiK3RdLHRoaXN9LGUucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24odCl7dGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e307Zm9yKHZhciBlPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpLHI9dGhpcy5fY2FsbGJhY2tzW1wiJFwiK3RdLG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKWVbbi0xXT1hcmd1bWVudHNbbl07aWYocil7bj0wO2Zvcih2YXIgaT0ocj1yLnNsaWNlKDApKS5sZW5ndGg7bjxpOysrbilyW25dLmFwcGx5KHRoaXMsZSl9cmV0dXJuIHRoaXN9LGUucHJvdG90eXBlLmxpc3RlbmVycz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e30sdGhpcy5fY2FsbGJhY2tzW1wiJFwiK3RdfHxbXX0sZS5wcm90b3R5cGUuaGFzTGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3JldHVybiEhdGhpcy5saXN0ZW5lcnModCkubGVuZ3RofX0oVGQpO3ZhciB4ZCxrZD1UZC5leHBvcnRzO1xuLyohIEhhbW1lci5KUyAtIHYyLjAuMTctcmMgLSAyMDE5LTEyLTE2XG4gICAqIGh0dHA6Ly9uYXZlci5naXRodWIuaW8vZWdqc1xuICAgKlxuICAgKiBGb3JrZWQgQnkgTmF2ZXIgZWdqc1xuICAgKiBDb3B5cmlnaHQgKGMpIGhhbW1lcmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL2Z1bmN0aW9uIFNkKCl7cmV0dXJuIFNkPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciByPWFyZ3VtZW50c1tlXTtmb3IodmFyIG4gaW4gcilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixuKSYmKHRbbl09cltuXSl9cmV0dXJuIHR9LFNkLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBBZCh0LGUpe3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXQsdC5fX3Byb3RvX189ZX1mdW5jdGlvbiBqZCh0KXtpZih2b2lkIDA9PT10KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gdH14ZD1cImZ1bmN0aW9uXCIhPXR5cGVvZiBPYmplY3QuYXNzaWduP2Z1bmN0aW9uKHQpe2lmKG51bGw9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdFwiKTtmb3IodmFyIGU9T2JqZWN0KHQpLHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt2YXIgbj1hcmd1bWVudHNbcl07aWYobnVsbCE9bilmb3IodmFyIGkgaW4gbiluLmhhc093blByb3BlcnR5KGkpJiYoZVtpXT1uW2ldKX1yZXR1cm4gZX06T2JqZWN0LmFzc2lnbjt2YXIgUGQsSWQ9eGQsRGQ9W1wiXCIsXCJ3ZWJraXRcIixcIk1velwiLFwiTVNcIixcIm1zXCIsXCJvXCJdLExkPVwidW5kZWZpbmVkXCI9PXR5cGVvZiBkb2N1bWVudD97c3R5bGU6e319OmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksQ2Q9TWF0aC5yb3VuZCxSZD1NYXRoLmFicyxNZD1EYXRlLm5vdztmdW5jdGlvbiBGZCh0LGUpe2Zvcih2YXIgcixuLGk9ZVswXS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSksbz0wO288RGQubGVuZ3RoOyl7aWYoKG49KHI9RGRbb10pP3IraTplKWluIHQpcmV0dXJuIG47bysrfX1QZD1cInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93P3t9OndpbmRvdzt2YXIgTmQ9RmQoTGQuc3R5bGUsXCJ0b3VjaEFjdGlvblwiKSx6ZD12b2lkIDAhPT1OZDt2YXIgcWQ9XCJjb21wdXRlXCIsWWQ9XCJhdXRvXCIsR2Q9XCJtYW5pcHVsYXRpb25cIixYZD1cIm5vbmVcIixVZD1cInBhbi14XCIsV2Q9XCJwYW4teVwiLFZkPWZ1bmN0aW9uKCl7aWYoIXpkKXJldHVybiExO3ZhciB0PXt9LGU9UGQuQ1NTJiZQZC5DU1Muc3VwcG9ydHM7cmV0dXJuW1wiYXV0b1wiLFwibWFuaXB1bGF0aW9uXCIsXCJwYW4teVwiLFwicGFuLXhcIixcInBhbi14IHBhbi15XCIsXCJub25lXCJdLmZvckVhY2goKGZ1bmN0aW9uKHIpe3JldHVybiB0W3JdPSFlfHxQZC5DU1Muc3VwcG9ydHMoXCJ0b3VjaC1hY3Rpb25cIixyKX0pKSx0fSgpLEhkPVwib250b3VjaHN0YXJ0XCJpbiBQZCwkZD12b2lkIDAhPT1GZChQZCxcIlBvaW50ZXJFdmVudFwiKSxCZD1IZCYmL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksSmQ9XCJ0b3VjaFwiLEtkPVwibW91c2VcIixRZD0xNixaZD0yNCx0eT1bXCJ4XCIsXCJ5XCJdLGV5PVtcImNsaWVudFhcIixcImNsaWVudFlcIl07ZnVuY3Rpb24gcnkodCxlLHIpe3ZhciBuO2lmKHQpaWYodC5mb3JFYWNoKXQuZm9yRWFjaChlLHIpO2Vsc2UgaWYodm9pZCAwIT09dC5sZW5ndGgpZm9yKG49MDtuPHQubGVuZ3RoOyllLmNhbGwocix0W25dLG4sdCksbisrO2Vsc2UgZm9yKG4gaW4gdCl0Lmhhc093blByb3BlcnR5KG4pJiZlLmNhbGwocix0W25dLG4sdCl9ZnVuY3Rpb24gbnkodCxlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3QuYXBwbHkoZSYmZVswXXx8dm9pZCAwLGUpOnR9ZnVuY3Rpb24gaXkodCxlKXtyZXR1cm4gdC5pbmRleE9mKGUpPi0xfXZhciBveT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLm1hbmFnZXI9dCx0aGlzLnNldChlKX12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5zZXQ9ZnVuY3Rpb24odCl7dD09PXFkJiYodD10aGlzLmNvbXB1dGUoKSksemQmJnRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlJiZWZFt0XSYmKHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW05kXT10KSx0aGlzLmFjdGlvbnM9dC50b0xvd2VyQ2FzZSgpLnRyaW0oKX0sZS51cGRhdGU9ZnVuY3Rpb24oKXt0aGlzLnNldCh0aGlzLm1hbmFnZXIub3B0aW9ucy50b3VjaEFjdGlvbil9LGUuY29tcHV0ZT1mdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiByeSh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsKGZ1bmN0aW9uKGUpe255KGUub3B0aW9ucy5lbmFibGUsW2VdKSYmKHQ9dC5jb25jYXQoZS5nZXRUb3VjaEFjdGlvbigpKSl9KSksZnVuY3Rpb24odCl7aWYoaXkodCxYZCkpcmV0dXJuIFhkO3ZhciBlPWl5KHQsVWQpLHI9aXkodCxXZCk7cmV0dXJuIGUmJnI/WGQ6ZXx8cj9lP1VkOldkOml5KHQsR2QpP0dkOllkfSh0LmpvaW4oXCIgXCIpKX0sZS5wcmV2ZW50RGVmYXVsdHM9ZnVuY3Rpb24odCl7dmFyIGU9dC5zcmNFdmVudCxyPXQub2Zmc2V0RGlyZWN0aW9uO2lmKHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCllLnByZXZlbnREZWZhdWx0KCk7ZWxzZXt2YXIgbj10aGlzLmFjdGlvbnMsaT1peShuLFhkKSYmIVZkLm5vbmUsbz1peShuLFdkKSYmIVZkW1wicGFuLXlcIl0sYT1peShuLFVkKSYmIVZkW1wicGFuLXhcIl07aWYoaSl7dmFyIHU9MT09PXQucG9pbnRlcnMubGVuZ3RoLHM9dC5kaXN0YW5jZTwyLGM9dC5kZWx0YVRpbWU8MjUwO2lmKHUmJnMmJmMpcmV0dXJufWlmKCFhfHwhbylyZXR1cm4gaXx8byYmNiZyfHxhJiZyJlpkP3RoaXMucHJldmVudFNyYyhlKTp2b2lkIDB9fSxlLnByZXZlbnRTcmM9ZnVuY3Rpb24odCl7dGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkPSEwLHQucHJldmVudERlZmF1bHQoKX0sdH0oKTtmdW5jdGlvbiBheSh0LGUpe2Zvcig7dDspe2lmKHQ9PT1lKXJldHVybiEwO3Q9dC5wYXJlbnROb2RlfXJldHVybiExfWZ1bmN0aW9uIHV5KHQpe3ZhciBlPXQubGVuZ3RoO2lmKDE9PT1lKXJldHVybnt4OkNkKHRbMF0uY2xpZW50WCkseTpDZCh0WzBdLmNsaWVudFkpfTtmb3IodmFyIHI9MCxuPTAsaT0wO2k8ZTspcis9dFtpXS5jbGllbnRYLG4rPXRbaV0uY2xpZW50WSxpKys7cmV0dXJue3g6Q2Qoci9lKSx5OkNkKG4vZSl9fWZ1bmN0aW9uIHN5KHQpe2Zvcih2YXIgZT1bXSxyPTA7cjx0LnBvaW50ZXJzLmxlbmd0aDspZVtyXT17Y2xpZW50WDpDZCh0LnBvaW50ZXJzW3JdLmNsaWVudFgpLGNsaWVudFk6Q2QodC5wb2ludGVyc1tyXS5jbGllbnRZKX0scisrO3JldHVybnt0aW1lU3RhbXA6TWQoKSxwb2ludGVyczplLGNlbnRlcjp1eShlKSxkZWx0YVg6dC5kZWx0YVgsZGVsdGFZOnQuZGVsdGFZfX1mdW5jdGlvbiBjeSh0LGUscil7cnx8KHI9dHkpO3ZhciBuPWVbclswXV0tdFtyWzBdXSxpPWVbclsxXV0tdFtyWzFdXTtyZXR1cm4gTWF0aC5zcXJ0KG4qbitpKmkpfWZ1bmN0aW9uIGZ5KHQsZSxyKXtyfHwocj10eSk7dmFyIG49ZVtyWzBdXS10W3JbMF1dLGk9ZVtyWzFdXS10W3JbMV1dO3JldHVybiAxODAqTWF0aC5hdGFuMihpLG4pL01hdGguUEl9ZnVuY3Rpb24gbHkodCxlKXtyZXR1cm4gdD09PWU/MTpSZCh0KT49UmQoZSk/dDwwPzI6NDplPDA/ODpRZH1mdW5jdGlvbiBoeSh0LGUscil7cmV0dXJue3g6ZS90fHwwLHk6ci90fHwwfX1mdW5jdGlvbiBweSh0LGUpe3ZhciByPXQuc2Vzc2lvbixuPWUucG9pbnRlcnMsaT1uLmxlbmd0aDtyLmZpcnN0SW5wdXR8fChyLmZpcnN0SW5wdXQ9c3koZSkpLGk+MSYmIXIuZmlyc3RNdWx0aXBsZT9yLmZpcnN0TXVsdGlwbGU9c3koZSk6MT09PWkmJihyLmZpcnN0TXVsdGlwbGU9ITEpO3ZhciBvPXIuZmlyc3RJbnB1dCxhPXIuZmlyc3RNdWx0aXBsZSx1PWE/YS5jZW50ZXI6by5jZW50ZXIscz1lLmNlbnRlcj11eShuKTtlLnRpbWVTdGFtcD1NZCgpLGUuZGVsdGFUaW1lPWUudGltZVN0YW1wLW8udGltZVN0YW1wLGUuYW5nbGU9ZnkodSxzKSxlLmRpc3RhbmNlPWN5KHUscyksZnVuY3Rpb24odCxlKXt2YXIgcj1lLmNlbnRlcixuPXQub2Zmc2V0RGVsdGF8fHt9LGk9dC5wcmV2RGVsdGF8fHt9LG89dC5wcmV2SW5wdXR8fHt9OzEhPT1lLmV2ZW50VHlwZSYmNCE9PW8uZXZlbnRUeXBlfHwoaT10LnByZXZEZWx0YT17eDpvLmRlbHRhWHx8MCx5Om8uZGVsdGFZfHwwfSxuPXQub2Zmc2V0RGVsdGE9e3g6ci54LHk6ci55fSksZS5kZWx0YVg9aS54KyhyLngtbi54KSxlLmRlbHRhWT1pLnkrKHIueS1uLnkpfShyLGUpLGUub2Zmc2V0RGlyZWN0aW9uPWx5KGUuZGVsdGFYLGUuZGVsdGFZKTt2YXIgYyxmLGw9aHkoZS5kZWx0YVRpbWUsZS5kZWx0YVgsZS5kZWx0YVkpO2Uub3ZlcmFsbFZlbG9jaXR5WD1sLngsZS5vdmVyYWxsVmVsb2NpdHlZPWwueSxlLm92ZXJhbGxWZWxvY2l0eT1SZChsLngpPlJkKGwueSk/bC54OmwueSxlLnNjYWxlPWE/KGM9YS5wb2ludGVycyxjeSgoZj1uKVswXSxmWzFdLGV5KS9jeShjWzBdLGNbMV0sZXkpKToxLGUucm90YXRpb249YT9mdW5jdGlvbih0LGUpe3JldHVybiBmeShlWzFdLGVbMF0sZXkpK2Z5KHRbMV0sdFswXSxleSl9KGEucG9pbnRlcnMsbik6MCxlLm1heFBvaW50ZXJzPXIucHJldklucHV0P2UucG9pbnRlcnMubGVuZ3RoPnIucHJldklucHV0Lm1heFBvaW50ZXJzP2UucG9pbnRlcnMubGVuZ3RoOnIucHJldklucHV0Lm1heFBvaW50ZXJzOmUucG9pbnRlcnMubGVuZ3RoLGZ1bmN0aW9uKHQsZSl7dmFyIHIsbixpLG8sYT10Lmxhc3RJbnRlcnZhbHx8ZSx1PWUudGltZVN0YW1wLWEudGltZVN0YW1wO2lmKDghPT1lLmV2ZW50VHlwZSYmKHU+MjV8fHZvaWQgMD09PWEudmVsb2NpdHkpKXt2YXIgcz1lLmRlbHRhWC1hLmRlbHRhWCxjPWUuZGVsdGFZLWEuZGVsdGFZLGY9aHkodSxzLGMpO249Zi54LGk9Zi55LHI9UmQoZi54KT5SZChmLnkpP2YueDpmLnksbz1seShzLGMpLHQubGFzdEludGVydmFsPWV9ZWxzZSByPWEudmVsb2NpdHksbj1hLnZlbG9jaXR5WCxpPWEudmVsb2NpdHlZLG89YS5kaXJlY3Rpb247ZS52ZWxvY2l0eT1yLGUudmVsb2NpdHlYPW4sZS52ZWxvY2l0eVk9aSxlLmRpcmVjdGlvbj1vfShyLGUpO3ZhciBoLHA9dC5lbGVtZW50LHY9ZS5zcmNFdmVudDtheShoPXYuY29tcG9zZWRQYXRoP3YuY29tcG9zZWRQYXRoKClbMF06di5wYXRoP3YucGF0aFswXTp2LnRhcmdldCxwKSYmKHA9aCksZS50YXJnZXQ9cH1mdW5jdGlvbiB2eSh0LGUscil7dmFyIG49ci5wb2ludGVycy5sZW5ndGgsaT1yLmNoYW5nZWRQb2ludGVycy5sZW5ndGgsbz0xJmUmJm4taT09MCxhPTEyJmUmJm4taT09MDtyLmlzRmlyc3Q9ISFvLHIuaXNGaW5hbD0hIWEsbyYmKHQuc2Vzc2lvbj17fSksci5ldmVudFR5cGU9ZSxweSh0LHIpLHQuZW1pdChcImhhbW1lci5pbnB1dFwiLHIpLHQucmVjb2duaXplKHIpLHQuc2Vzc2lvbi5wcmV2SW5wdXQ9cn1mdW5jdGlvbiBkeSh0KXtyZXR1cm4gdC50cmltKCkuc3BsaXQoL1xccysvZyl9ZnVuY3Rpb24geXkodCxlLHIpe3J5KGR5KGUpLChmdW5jdGlvbihlKXt0LmFkZEV2ZW50TGlzdGVuZXIoZSxyLCExKX0pKX1mdW5jdGlvbiBneSh0LGUscil7cnkoZHkoZSksKGZ1bmN0aW9uKGUpe3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLHIsITEpfSkpfWZ1bmN0aW9uIG15KHQpe3ZhciBlPXQub3duZXJEb2N1bWVudHx8dDtyZXR1cm4gZS5kZWZhdWx0Vmlld3x8ZS5wYXJlbnRXaW5kb3d8fHdpbmRvd312YXIgYnk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dmFyIHI9dGhpczt0aGlzLm1hbmFnZXI9dCx0aGlzLmNhbGxiYWNrPWUsdGhpcy5lbGVtZW50PXQuZWxlbWVudCx0aGlzLnRhcmdldD10Lm9wdGlvbnMuaW5wdXRUYXJnZXQsdGhpcy5kb21IYW5kbGVyPWZ1bmN0aW9uKGUpe255KHQub3B0aW9ucy5lbmFibGUsW3RdKSYmci5oYW5kbGVyKGUpfSx0aGlzLmluaXQoKX12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5oYW5kbGVyPWZ1bmN0aW9uKCl7fSxlLmluaXQ9ZnVuY3Rpb24oKXt0aGlzLmV2RWwmJnl5KHRoaXMuZWxlbWVudCx0aGlzLmV2RWwsdGhpcy5kb21IYW5kbGVyKSx0aGlzLmV2VGFyZ2V0JiZ5eSh0aGlzLnRhcmdldCx0aGlzLmV2VGFyZ2V0LHRoaXMuZG9tSGFuZGxlciksdGhpcy5ldldpbiYmeXkobXkodGhpcy5lbGVtZW50KSx0aGlzLmV2V2luLHRoaXMuZG9tSGFuZGxlcil9LGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZXZFbCYmZ3kodGhpcy5lbGVtZW50LHRoaXMuZXZFbCx0aGlzLmRvbUhhbmRsZXIpLHRoaXMuZXZUYXJnZXQmJmd5KHRoaXMudGFyZ2V0LHRoaXMuZXZUYXJnZXQsdGhpcy5kb21IYW5kbGVyKSx0aGlzLmV2V2luJiZneShteSh0aGlzLmVsZW1lbnQpLHRoaXMuZXZXaW4sdGhpcy5kb21IYW5kbGVyKX0sdH0oKTtmdW5jdGlvbiBfeSh0LGUscil7aWYodC5pbmRleE9mJiYhcilyZXR1cm4gdC5pbmRleE9mKGUpO2Zvcih2YXIgbj0wO248dC5sZW5ndGg7KXtpZihyJiZ0W25dW3JdPT1lfHwhciYmdFtuXT09PWUpcmV0dXJuIG47bisrfXJldHVybi0xfXZhciB3eT17cG9pbnRlcmRvd246MSxwb2ludGVybW92ZToyLHBvaW50ZXJ1cDo0LHBvaW50ZXJjYW5jZWw6OCxwb2ludGVyb3V0Ojh9LE95PXsyOkpkLDM6XCJwZW5cIiw0OktkLDU6XCJraW5lY3RcIn0sRXk9XCJwb2ludGVyZG93blwiLFR5PVwicG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWxcIjtQZC5NU1BvaW50ZXJFdmVudCYmIVBkLlBvaW50ZXJFdmVudCYmKEV5PVwiTVNQb2ludGVyRG93blwiLFR5PVwiTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWxcIik7dmFyIHh5PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgcixuPWUucHJvdG90eXBlO3JldHVybiBuLmV2RWw9RXksbi5ldldpbj1UeSwocj10LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcykuc3RvcmU9ci5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cz1bXSxyfXJldHVybiBBZChlLHQpLGUucHJvdG90eXBlLmhhbmRsZXI9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5zdG9yZSxyPSExLG49dC50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZShcIm1zXCIsXCJcIiksaT13eVtuXSxvPU95W3QucG9pbnRlclR5cGVdfHx0LnBvaW50ZXJUeXBlLGE9bz09PUpkLHU9X3koZSx0LnBvaW50ZXJJZCxcInBvaW50ZXJJZFwiKTsxJmkmJigwPT09dC5idXR0b258fGEpP3U8MCYmKGUucHVzaCh0KSx1PWUubGVuZ3RoLTEpOjEyJmkmJihyPSEwKSx1PDB8fChlW3VdPXQsdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsaSx7cG9pbnRlcnM6ZSxjaGFuZ2VkUG9pbnRlcnM6W3RdLHBvaW50ZXJUeXBlOm8sc3JjRXZlbnQ6dH0pLHImJmUuc3BsaWNlKHUsMSkpfSxlfShieSk7ZnVuY3Rpb24ga3kodCl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQsMCl9ZnVuY3Rpb24gU3kodCxlLHIpe2Zvcih2YXIgbj1bXSxpPVtdLG89MDtvPHQubGVuZ3RoOyl7dmFyIGE9ZT90W29dW2VdOnRbb107X3koaSxhKTwwJiZuLnB1c2godFtvXSksaVtvXT1hLG8rK31yZXR1cm4gciYmKG49ZT9uLnNvcnQoKGZ1bmN0aW9uKHQscil7cmV0dXJuIHRbZV0+cltlXX0pKTpuLnNvcnQoKSksbn12YXIgQXk9e3RvdWNoc3RhcnQ6MSx0b3VjaG1vdmU6Mix0b3VjaGVuZDo0LHRvdWNoY2FuY2VsOjh9LGp5PVwidG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWxcIixQeT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHI7cmV0dXJuIGUucHJvdG90eXBlLmV2VGFyZ2V0PWp5LChyPXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzKS50YXJnZXRJZHM9e30scn1yZXR1cm4gQWQoZSx0KSxlLnByb3RvdHlwZS5oYW5kbGVyPWZ1bmN0aW9uKHQpe3ZhciBlPUF5W3QudHlwZV0scj1JeS5jYWxsKHRoaXMsdCxlKTtyJiZ0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlcixlLHtwb2ludGVyczpyWzBdLGNoYW5nZWRQb2ludGVyczpyWzFdLHBvaW50ZXJUeXBlOkpkLHNyY0V2ZW50OnR9KX0sZX0oYnkpO2Z1bmN0aW9uIEl5KHQsZSl7dmFyIHIsbixpPWt5KHQudG91Y2hlcyksbz10aGlzLnRhcmdldElkcztpZigzJmUmJjE9PT1pLmxlbmd0aClyZXR1cm4gb1tpWzBdLmlkZW50aWZpZXJdPSEwLFtpLGldO3ZhciBhPWt5KHQuY2hhbmdlZFRvdWNoZXMpLHU9W10scz10aGlzLnRhcmdldDtpZihuPWkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gYXkodC50YXJnZXQscyl9KSksMT09PWUpZm9yKHI9MDtyPG4ubGVuZ3RoOylvW25bcl0uaWRlbnRpZmllcl09ITAscisrO2ZvcihyPTA7cjxhLmxlbmd0aDspb1thW3JdLmlkZW50aWZpZXJdJiZ1LnB1c2goYVtyXSksMTImZSYmZGVsZXRlIG9bYVtyXS5pZGVudGlmaWVyXSxyKys7cmV0dXJuIHUubGVuZ3RoP1tTeShuLmNvbmNhdCh1KSxcImlkZW50aWZpZXJcIiwhMCksdV06dm9pZCAwfXZhciBEeT17bW91c2Vkb3duOjEsbW91c2Vtb3ZlOjIsbW91c2V1cDo0fSxMeT1cIm1vdXNlZG93blwiLEN5PVwibW91c2Vtb3ZlIG1vdXNldXBcIixSeT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHIsbj1lLnByb3RvdHlwZTtyZXR1cm4gbi5ldkVsPUx5LG4uZXZXaW49Q3ksKHI9dC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXMpLnByZXNzZWQ9ITEscn1yZXR1cm4gQWQoZSx0KSxlLnByb3RvdHlwZS5oYW5kbGVyPWZ1bmN0aW9uKHQpe3ZhciBlPUR5W3QudHlwZV07MSZlJiYwPT09dC5idXR0b24mJih0aGlzLnByZXNzZWQ9ITApLDImZSYmMSE9PXQud2hpY2gmJihlPTQpLHRoaXMucHJlc3NlZCYmKDQmZSYmKHRoaXMucHJlc3NlZD0hMSksdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsZSx7cG9pbnRlcnM6W3RdLGNoYW5nZWRQb2ludGVyczpbdF0scG9pbnRlclR5cGU6S2Qsc3JjRXZlbnQ6dH0pKX0sZX0oYnkpO2Z1bmN0aW9uIE15KHQpe3ZhciBlPXQuY2hhbmdlZFBvaW50ZXJzWzBdO2lmKGUuaWRlbnRpZmllcj09PXRoaXMucHJpbWFyeVRvdWNoKXt2YXIgcj17eDplLmNsaWVudFgseTplLmNsaWVudFl9LG49dGhpcy5sYXN0VG91Y2hlczt0aGlzLmxhc3RUb3VjaGVzLnB1c2gocik7c2V0VGltZW91dCgoZnVuY3Rpb24oKXt2YXIgdD1uLmluZGV4T2Yocik7dD4tMSYmbi5zcGxpY2UodCwxKX0pLDI1MDApfX1mdW5jdGlvbiBGeSh0LGUpezEmdD8odGhpcy5wcmltYXJ5VG91Y2g9ZS5jaGFuZ2VkUG9pbnRlcnNbMF0uaWRlbnRpZmllcixNeS5jYWxsKHRoaXMsZSkpOjEyJnQmJk15LmNhbGwodGhpcyxlKX1mdW5jdGlvbiBOeSh0KXtmb3IodmFyIGU9dC5zcmNFdmVudC5jbGllbnRYLHI9dC5zcmNFdmVudC5jbGllbnRZLG49MDtuPHRoaXMubGFzdFRvdWNoZXMubGVuZ3RoO24rKyl7dmFyIGk9dGhpcy5sYXN0VG91Y2hlc1tuXSxvPU1hdGguYWJzKGUtaS54KSxhPU1hdGguYWJzKHItaS55KTtpZihvPD0yNSYmYTw9MjUpcmV0dXJuITB9cmV0dXJuITF9dmFyIHp5PWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2YXIgbjtyZXR1cm4obj10LmNhbGwodGhpcyxlLHIpfHx0aGlzKS5oYW5kbGVyPWZ1bmN0aW9uKHQsZSxyKXt2YXIgaT1yLnBvaW50ZXJUeXBlPT09SmQsbz1yLnBvaW50ZXJUeXBlPT09S2Q7aWYoIShvJiZyLnNvdXJjZUNhcGFiaWxpdGllcyYmci5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykpe2lmKGkpRnkuY2FsbChqZChqZChuKSksZSxyKTtlbHNlIGlmKG8mJk55LmNhbGwoamQoamQobikpLHIpKXJldHVybjtuLmNhbGxiYWNrKHQsZSxyKX19LG4udG91Y2g9bmV3IFB5KG4ubWFuYWdlcixuLmhhbmRsZXIpLG4ubW91c2U9bmV3IFJ5KG4ubWFuYWdlcixuLmhhbmRsZXIpLG4ucHJpbWFyeVRvdWNoPW51bGwsbi5sYXN0VG91Y2hlcz1bXSxufXJldHVybiBBZChlLHQpLGUucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLnRvdWNoLmRlc3Ryb3koKSx0aGlzLm1vdXNlLmRlc3Ryb3koKX0sZX0oYnkpfSgpO2Z1bmN0aW9uIHF5KHQsZSxyKXtyZXR1cm4hIUFycmF5LmlzQXJyYXkodCkmJihyeSh0LHJbZV0sciksITApfXZhciBZeT0zMixHeT0xO2Z1bmN0aW9uIFh5KHQsZSl7dmFyIHI9ZS5tYW5hZ2VyO3JldHVybiByP3IuZ2V0KHQpOnR9ZnVuY3Rpb24gVXkodCl7cmV0dXJuIDE2JnQ/XCJjYW5jZWxcIjo4JnQ/XCJlbmRcIjo0JnQ/XCJtb3ZlXCI6MiZ0P1wic3RhcnRcIjpcIlwifXZhciBXeT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dm9pZCAwPT09dCYmKHQ9e30pLHRoaXMub3B0aW9ucz1TZCh7ZW5hYmxlOiEwfSx0KSx0aGlzLmlkPUd5KyssdGhpcy5tYW5hZ2VyPW51bGwsdGhpcy5zdGF0ZT0xLHRoaXMuc2ltdWx0YW5lb3VzPXt9LHRoaXMucmVxdWlyZUZhaWw9W119dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuc2V0PWZ1bmN0aW9uKHQpe3JldHVybiBJZCh0aGlzLm9wdGlvbnMsdCksdGhpcy5tYW5hZ2VyJiZ0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCksdGhpc30sZS5yZWNvZ25pemVXaXRoPWZ1bmN0aW9uKHQpe2lmKHF5KHQsXCJyZWNvZ25pemVXaXRoXCIsdGhpcykpcmV0dXJuIHRoaXM7dmFyIGU9dGhpcy5zaW11bHRhbmVvdXM7cmV0dXJuIGVbKHQ9WHkodCx0aGlzKSkuaWRdfHwoZVt0LmlkXT10LHQucmVjb2duaXplV2l0aCh0aGlzKSksdGhpc30sZS5kcm9wUmVjb2duaXplV2l0aD1mdW5jdGlvbih0KXtyZXR1cm4gcXkodCxcImRyb3BSZWNvZ25pemVXaXRoXCIsdGhpcyl8fCh0PVh5KHQsdGhpcyksZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW3QuaWRdKSx0aGlzfSxlLnJlcXVpcmVGYWlsdXJlPWZ1bmN0aW9uKHQpe2lmKHF5KHQsXCJyZXF1aXJlRmFpbHVyZVwiLHRoaXMpKXJldHVybiB0aGlzO3ZhciBlPXRoaXMucmVxdWlyZUZhaWw7cmV0dXJuLTE9PT1feShlLHQ9WHkodCx0aGlzKSkmJihlLnB1c2godCksdC5yZXF1aXJlRmFpbHVyZSh0aGlzKSksdGhpc30sZS5kcm9wUmVxdWlyZUZhaWx1cmU9ZnVuY3Rpb24odCl7aWYocXkodCxcImRyb3BSZXF1aXJlRmFpbHVyZVwiLHRoaXMpKXJldHVybiB0aGlzO3Q9WHkodCx0aGlzKTt2YXIgZT1feSh0aGlzLnJlcXVpcmVGYWlsLHQpO3JldHVybiBlPi0xJiZ0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShlLDEpLHRoaXN9LGUuaGFzUmVxdWlyZUZhaWx1cmVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoPjB9LGUuY2FuUmVjb2duaXplV2l0aD1mdW5jdGlvbih0KXtyZXR1cm4hIXRoaXMuc2ltdWx0YW5lb3VzW3QuaWRdfSxlLmVtaXQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPXRoaXMuc3RhdGU7ZnVuY3Rpb24gbihyKXtlLm1hbmFnZXIuZW1pdChyLHQpfXI8OCYmbihlLm9wdGlvbnMuZXZlbnQrVXkocikpLG4oZS5vcHRpb25zLmV2ZW50KSx0LmFkZGl0aW9uYWxFdmVudCYmbih0LmFkZGl0aW9uYWxFdmVudCkscj49OCYmbihlLm9wdGlvbnMuZXZlbnQrVXkocikpfSxlLnRyeUVtaXQ9ZnVuY3Rpb24odCl7aWYodGhpcy5jYW5FbWl0KCkpcmV0dXJuIHRoaXMuZW1pdCh0KTt0aGlzLnN0YXRlPVl5fSxlLmNhbkVtaXQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoOyl7aWYoISgzMyZ0aGlzLnJlcXVpcmVGYWlsW3RdLnN0YXRlKSlyZXR1cm4hMTt0Kyt9cmV0dXJuITB9LGUucmVjb2duaXplPWZ1bmN0aW9uKHQpe3ZhciBlPUlkKHt9LHQpO2lmKCFueSh0aGlzLm9wdGlvbnMuZW5hYmxlLFt0aGlzLGVdKSlyZXR1cm4gdGhpcy5yZXNldCgpLHZvaWQodGhpcy5zdGF0ZT1ZeSk7NTYmdGhpcy5zdGF0ZSYmKHRoaXMuc3RhdGU9MSksdGhpcy5zdGF0ZT10aGlzLnByb2Nlc3MoZSksMzAmdGhpcy5zdGF0ZSYmdGhpcy50cnlFbWl0KGUpfSxlLnByb2Nlc3M9ZnVuY3Rpb24odCl7fSxlLmdldFRvdWNoQWN0aW9uPWZ1bmN0aW9uKCl7fSxlLnJlc2V0PWZ1bmN0aW9uKCl7fSx0fSgpLFZ5PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIHI7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSwocj10LmNhbGwodGhpcyxTZCh7ZXZlbnQ6XCJ0YXBcIixwb2ludGVyczoxLHRhcHM6MSxpbnRlcnZhbDozMDAsdGltZToyNTAsdGhyZXNob2xkOjkscG9zVGhyZXNob2xkOjEwfSxlKSl8fHRoaXMpLnBUaW1lPSExLHIucENlbnRlcj0hMSxyLl90aW1lcj1udWxsLHIuX2lucHV0PW51bGwsci5jb3VudD0wLHJ9QWQoZSx0KTt2YXIgcj1lLnByb3RvdHlwZTtyZXR1cm4gci5nZXRUb3VjaEFjdGlvbj1mdW5jdGlvbigpe3JldHVybltHZF19LHIucHJvY2Vzcz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9dGhpcy5vcHRpb25zLG49dC5wb2ludGVycy5sZW5ndGg9PT1yLnBvaW50ZXJzLGk9dC5kaXN0YW5jZTxyLnRocmVzaG9sZCxvPXQuZGVsdGFUaW1lPHIudGltZTtpZih0aGlzLnJlc2V0KCksMSZ0LmV2ZW50VHlwZSYmMD09PXRoaXMuY291bnQpcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtpZihpJiZvJiZuKXtpZig0IT09dC5ldmVudFR5cGUpcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTt2YXIgYT0hdGhpcy5wVGltZXx8dC50aW1lU3RhbXAtdGhpcy5wVGltZTxyLmludGVydmFsLHU9IXRoaXMucENlbnRlcnx8Y3kodGhpcy5wQ2VudGVyLHQuY2VudGVyKTxyLnBvc1RocmVzaG9sZDtpZih0aGlzLnBUaW1lPXQudGltZVN0YW1wLHRoaXMucENlbnRlcj10LmNlbnRlcix1JiZhP3RoaXMuY291bnQrPTE6dGhpcy5jb3VudD0xLHRoaXMuX2lucHV0PXQsMD09PXRoaXMuY291bnQlci50YXBzKXJldHVybiB0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpPyh0aGlzLl90aW1lcj1zZXRUaW1lb3V0KChmdW5jdGlvbigpe2Uuc3RhdGU9OCxlLnRyeUVtaXQoKX0pLHIuaW50ZXJ2YWwpLDIpOjh9cmV0dXJuIFl5fSxyLmZhaWxUaW1lb3V0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gdGhpcy5fdGltZXI9c2V0VGltZW91dCgoZnVuY3Rpb24oKXt0LnN0YXRlPVl5fSksdGhpcy5vcHRpb25zLmludGVydmFsKSxZeX0sci5yZXNldD1mdW5jdGlvbigpe2NsZWFyVGltZW91dCh0aGlzLl90aW1lcil9LHIuZW1pdD1mdW5jdGlvbigpezg9PT10aGlzLnN0YXRlJiYodGhpcy5faW5wdXQudGFwQ291bnQ9dGhpcy5jb3VudCx0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsdGhpcy5faW5wdXQpKX0sZX0oV3kpLEh5PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSx0LmNhbGwodGhpcyxTZCh7cG9pbnRlcnM6MX0sZSkpfHx0aGlzfUFkKGUsdCk7dmFyIHI9ZS5wcm90b3R5cGU7cmV0dXJuIHIuYXR0clRlc3Q9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5vcHRpb25zLnBvaW50ZXJzO3JldHVybiAwPT09ZXx8dC5wb2ludGVycy5sZW5ndGg9PT1lfSxyLnByb2Nlc3M9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5zdGF0ZSxyPXQuZXZlbnRUeXBlLG49NiZlLGk9dGhpcy5hdHRyVGVzdCh0KTtyZXR1cm4gbiYmKDgmcnx8IWkpPzE2fGU6bnx8aT80JnI/OHxlOjImZT80fGU6MjpZeX0sZX0oV3kpO2Z1bmN0aW9uICR5KHQpe3JldHVybiB0PT09UWQ/XCJkb3duXCI6OD09PXQ/XCJ1cFwiOjI9PT10P1wibGVmdFwiOjQ9PT10P1wicmlnaHRcIjpcIlwifXZhciBCeT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciByO3JldHVybiB2b2lkIDA9PT1lJiYoZT17fSksKHI9dC5jYWxsKHRoaXMsU2Qoe2V2ZW50OlwicGFuXCIsdGhyZXNob2xkOjEwLHBvaW50ZXJzOjEsZGlyZWN0aW9uOjMwfSxlKSl8fHRoaXMpLnBYPW51bGwsci5wWT1udWxsLHJ9QWQoZSx0KTt2YXIgcj1lLnByb3RvdHlwZTtyZXR1cm4gci5nZXRUb3VjaEFjdGlvbj1mdW5jdGlvbigpe3ZhciB0PXRoaXMub3B0aW9ucy5kaXJlY3Rpb24sZT1bXTtyZXR1cm4gNiZ0JiZlLnB1c2goV2QpLHQmWmQmJmUucHVzaChVZCksZX0sci5kaXJlY3Rpb25UZXN0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMub3B0aW9ucyxyPSEwLG49dC5kaXN0YW5jZSxpPXQuZGlyZWN0aW9uLG89dC5kZWx0YVgsYT10LmRlbHRhWTtyZXR1cm4gaSZlLmRpcmVjdGlvbnx8KDYmZS5kaXJlY3Rpb24/KGk9MD09PW8/MTpvPDA/Mjo0LHI9byE9PXRoaXMucFgsbj1NYXRoLmFicyh0LmRlbHRhWCkpOihpPTA9PT1hPzE6YTwwPzg6UWQscj1hIT09dGhpcy5wWSxuPU1hdGguYWJzKHQuZGVsdGFZKSkpLHQuZGlyZWN0aW9uPWksciYmbj5lLnRocmVzaG9sZCYmaSZlLmRpcmVjdGlvbn0sci5hdHRyVGVzdD1mdW5jdGlvbih0KXtyZXR1cm4gSHkucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcyx0KSYmKDImdGhpcy5zdGF0ZXx8ISgyJnRoaXMuc3RhdGUpJiZ0aGlzLmRpcmVjdGlvblRlc3QodCkpfSxyLmVtaXQ9ZnVuY3Rpb24oZSl7dGhpcy5wWD1lLmRlbHRhWCx0aGlzLnBZPWUuZGVsdGFZO3ZhciByPSR5KGUuZGlyZWN0aW9uKTtyJiYoZS5hZGRpdGlvbmFsRXZlbnQ9dGhpcy5vcHRpb25zLmV2ZW50K3IpLHQucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLGUpfSxlfShIeSksSnk9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9e30pLHQuY2FsbCh0aGlzLFNkKHtldmVudDpcInN3aXBlXCIsdGhyZXNob2xkOjEwLHZlbG9jaXR5Oi4zLGRpcmVjdGlvbjozMCxwb2ludGVyczoxfSxlKSl8fHRoaXN9QWQoZSx0KTt2YXIgcj1lLnByb3RvdHlwZTtyZXR1cm4gci5nZXRUb3VjaEFjdGlvbj1mdW5jdGlvbigpe3JldHVybiBCeS5wcm90b3R5cGUuZ2V0VG91Y2hBY3Rpb24uY2FsbCh0aGlzKX0sci5hdHRyVGVzdD1mdW5jdGlvbihlKXt2YXIgcixuPXRoaXMub3B0aW9ucy5kaXJlY3Rpb247cmV0dXJuIDMwJm4/cj1lLm92ZXJhbGxWZWxvY2l0eTo2Jm4/cj1lLm92ZXJhbGxWZWxvY2l0eVg6biZaZCYmKHI9ZS5vdmVyYWxsVmVsb2NpdHlZKSx0LnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsZSkmJm4mZS5vZmZzZXREaXJlY3Rpb24mJmUuZGlzdGFuY2U+dGhpcy5vcHRpb25zLnRocmVzaG9sZCYmZS5tYXhQb2ludGVycz09PXRoaXMub3B0aW9ucy5wb2ludGVycyYmUmQocik+dGhpcy5vcHRpb25zLnZlbG9jaXR5JiY0JmUuZXZlbnRUeXBlfSxyLmVtaXQ9ZnVuY3Rpb24odCl7dmFyIGU9JHkodC5vZmZzZXREaXJlY3Rpb24pO2UmJnRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCtlLHQpLHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCx0KX0sZX0oSHkpLEt5PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSx0LmNhbGwodGhpcyxTZCh7ZXZlbnQ6XCJwaW5jaFwiLHRocmVzaG9sZDowLHBvaW50ZXJzOjJ9LGUpKXx8dGhpc31BZChlLHQpO3ZhciByPWUucHJvdG90eXBlO3JldHVybiByLmdldFRvdWNoQWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuW1hkXX0sci5hdHRyVGVzdD1mdW5jdGlvbihlKXtyZXR1cm4gdC5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLGUpJiYoTWF0aC5hYnMoZS5zY2FsZS0xKT50aGlzLm9wdGlvbnMudGhyZXNob2xkfHwyJnRoaXMuc3RhdGUpfSxyLmVtaXQ9ZnVuY3Rpb24oZSl7aWYoMSE9PWUuc2NhbGUpe3ZhciByPWUuc2NhbGU8MT9cImluXCI6XCJvdXRcIjtlLmFkZGl0aW9uYWxFdmVudD10aGlzLm9wdGlvbnMuZXZlbnQrcn10LnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcyxlKX0sZX0oSHkpLFF5PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSx0LmNhbGwodGhpcyxTZCh7ZXZlbnQ6XCJyb3RhdGVcIix0aHJlc2hvbGQ6MCxwb2ludGVyczoyfSxlKSl8fHRoaXN9QWQoZSx0KTt2YXIgcj1lLnByb3RvdHlwZTtyZXR1cm4gci5nZXRUb3VjaEFjdGlvbj1mdW5jdGlvbigpe3JldHVybltYZF19LHIuYXR0clRlc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHQucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcyxlKSYmKE1hdGguYWJzKGUucm90YXRpb24pPnRoaXMub3B0aW9ucy50aHJlc2hvbGR8fDImdGhpcy5zdGF0ZSl9LGV9KEh5KSxaeT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciByO3JldHVybiB2b2lkIDA9PT1lJiYoZT17fSksKHI9dC5jYWxsKHRoaXMsU2Qoe2V2ZW50OlwicHJlc3NcIixwb2ludGVyczoxLHRpbWU6MjUxLHRocmVzaG9sZDo5fSxlKSl8fHRoaXMpLl90aW1lcj1udWxsLHIuX2lucHV0PW51bGwscn1BZChlLHQpO3ZhciByPWUucHJvdG90eXBlO3JldHVybiByLmdldFRvdWNoQWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuW1lkXX0sci5wcm9jZXNzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj10aGlzLm9wdGlvbnMsbj10LnBvaW50ZXJzLmxlbmd0aD09PXIucG9pbnRlcnMsaT10LmRpc3RhbmNlPHIudGhyZXNob2xkLG89dC5kZWx0YVRpbWU+ci50aW1lO2lmKHRoaXMuX2lucHV0PXQsIWl8fCFufHwxMiZ0LmV2ZW50VHlwZSYmIW8pdGhpcy5yZXNldCgpO2Vsc2UgaWYoMSZ0LmV2ZW50VHlwZSl0aGlzLnJlc2V0KCksdGhpcy5fdGltZXI9c2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLnN0YXRlPTgsZS50cnlFbWl0KCl9KSxyLnRpbWUpO2Vsc2UgaWYoNCZ0LmV2ZW50VHlwZSlyZXR1cm4gODtyZXR1cm4gWXl9LHIucmVzZXQ9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpfSxyLmVtaXQ9ZnVuY3Rpb24odCl7OD09PXRoaXMuc3RhdGUmJih0JiY0JnQuZXZlbnRUeXBlP3RoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCtcInVwXCIsdCk6KHRoaXMuX2lucHV0LnRpbWVTdGFtcD1NZCgpLHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCx0aGlzLl9pbnB1dCkpKX0sZX0oV3kpLHRnPXtkb21FdmVudHM6ITEsdG91Y2hBY3Rpb246cWQsZW5hYmxlOiEwLGlucHV0VGFyZ2V0Om51bGwsaW5wdXRDbGFzczpudWxsLGNzc1Byb3BzOnt1c2VyU2VsZWN0Olwibm9uZVwiLHRvdWNoU2VsZWN0Olwibm9uZVwiLHRvdWNoQ2FsbG91dDpcIm5vbmVcIixjb250ZW50Wm9vbWluZzpcIm5vbmVcIix1c2VyRHJhZzpcIm5vbmVcIix0YXBIaWdobGlnaHRDb2xvcjpcInJnYmEoMCwwLDAsMClcIn19LGVnPVtbUXkse2VuYWJsZTohMX1dLFtLeSx7ZW5hYmxlOiExfSxbXCJyb3RhdGVcIl1dLFtKeSx7ZGlyZWN0aW9uOjZ9XSxbQnkse2RpcmVjdGlvbjo2fSxbXCJzd2lwZVwiXV0sW1Z5XSxbVnkse2V2ZW50OlwiZG91YmxldGFwXCIsdGFwczoyfSxbXCJ0YXBcIl1dLFtaeV1dO2Z1bmN0aW9uIHJnKHQsZSl7dmFyIHIsbj10LmVsZW1lbnQ7bi5zdHlsZSYmKHJ5KHQub3B0aW9ucy5jc3NQcm9wcywoZnVuY3Rpb24oaSxvKXtyPUZkKG4uc3R5bGUsbyksZT8odC5vbGRDc3NQcm9wc1tyXT1uLnN0eWxlW3JdLG4uc3R5bGVbcl09aSk6bi5zdHlsZVtyXT10Lm9sZENzc1Byb3BzW3JdfHxcIlwifSkpLGV8fCh0Lm9sZENzc1Byb3BzPXt9KSl9dmFyIG5nPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3ZhciByLG49dGhpczt0aGlzLm9wdGlvbnM9SWQoe30sdGcsZXx8e30pLHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldD10aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXR8fHQsdGhpcy5oYW5kbGVycz17fSx0aGlzLnNlc3Npb249e30sdGhpcy5yZWNvZ25pemVycz1bXSx0aGlzLm9sZENzc1Byb3BzPXt9LHRoaXMuZWxlbWVudD10LHRoaXMuaW5wdXQ9bmV3KChyPXRoaXMpLm9wdGlvbnMuaW5wdXRDbGFzc3x8KCRkP3h5OkJkP1B5OkhkP3p5OlJ5KSkocix2eSksdGhpcy50b3VjaEFjdGlvbj1uZXcgb3kodGhpcyx0aGlzLm9wdGlvbnMudG91Y2hBY3Rpb24pLHJnKHRoaXMsITApLHJ5KHRoaXMub3B0aW9ucy5yZWNvZ25pemVycywoZnVuY3Rpb24odCl7dmFyIGU9bi5hZGQobmV3IHRbMF0odFsxXSkpO3RbMl0mJmUucmVjb2duaXplV2l0aCh0WzJdKSx0WzNdJiZlLnJlcXVpcmVGYWlsdXJlKHRbM10pfSksdGhpcyl9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuc2V0PWZ1bmN0aW9uKHQpe3JldHVybiBJZCh0aGlzLm9wdGlvbnMsdCksdC50b3VjaEFjdGlvbiYmdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKSx0LmlucHV0VGFyZ2V0JiYodGhpcy5pbnB1dC5kZXN0cm95KCksdGhpcy5pbnB1dC50YXJnZXQ9dC5pbnB1dFRhcmdldCx0aGlzLmlucHV0LmluaXQoKSksdGhpc30sZS5zdG9wPWZ1bmN0aW9uKHQpe3RoaXMuc2Vzc2lvbi5zdG9wcGVkPXQ/MjoxfSxlLnJlY29nbml6ZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnNlc3Npb247aWYoIWUuc3RvcHBlZCl7dmFyIHI7dGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHModCk7dmFyIG49dGhpcy5yZWNvZ25pemVycyxpPWUuY3VyUmVjb2duaXplcjsoIWl8fGkmJjgmaS5zdGF0ZSkmJihlLmN1clJlY29nbml6ZXI9bnVsbCxpPW51bGwpO2Zvcih2YXIgbz0wO288bi5sZW5ndGg7KXI9bltvXSwyPT09ZS5zdG9wcGVkfHxpJiZyIT09aSYmIXIuY2FuUmVjb2duaXplV2l0aChpKT9yLnJlc2V0KCk6ci5yZWNvZ25pemUodCksIWkmJjE0JnIuc3RhdGUmJihlLmN1clJlY29nbml6ZXI9cixpPXIpLG8rK319LGUuZ2V0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBXeSlyZXR1cm4gdDtmb3IodmFyIGU9dGhpcy5yZWNvZ25pemVycyxyPTA7cjxlLmxlbmd0aDtyKyspaWYoZVtyXS5vcHRpb25zLmV2ZW50PT09dClyZXR1cm4gZVtyXTtyZXR1cm4gbnVsbH0sZS5hZGQ9ZnVuY3Rpb24odCl7aWYocXkodCxcImFkZFwiLHRoaXMpKXJldHVybiB0aGlzO3ZhciBlPXRoaXMuZ2V0KHQub3B0aW9ucy5ldmVudCk7cmV0dXJuIGUmJnRoaXMucmVtb3ZlKGUpLHRoaXMucmVjb2duaXplcnMucHVzaCh0KSx0Lm1hbmFnZXI9dGhpcyx0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpLHR9LGUucmVtb3ZlPWZ1bmN0aW9uKHQpe2lmKHF5KHQsXCJyZW1vdmVcIix0aGlzKSlyZXR1cm4gdGhpczt2YXIgZT10aGlzLmdldCh0KTtpZih0KXt2YXIgcj10aGlzLnJlY29nbml6ZXJzLG49X3kocixlKTstMSE9PW4mJihyLnNwbGljZShuLDEpLHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCkpfXJldHVybiB0aGlzfSxlLm9uPWZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwPT09dHx8dm9pZCAwPT09ZSlyZXR1cm4gdGhpczt2YXIgcj10aGlzLmhhbmRsZXJzO3JldHVybiByeShkeSh0KSwoZnVuY3Rpb24odCl7clt0XT1yW3RdfHxbXSxyW3RdLnB1c2goZSl9KSksdGhpc30sZS5vZmY9ZnVuY3Rpb24odCxlKXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzO3ZhciByPXRoaXMuaGFuZGxlcnM7cmV0dXJuIHJ5KGR5KHQpLChmdW5jdGlvbih0KXtlP3JbdF0mJnJbdF0uc3BsaWNlKF95KHJbdF0sZSksMSk6ZGVsZXRlIHJbdF19KSksdGhpc30sZS5lbWl0PWZ1bmN0aW9uKHQsZSl7dGhpcy5vcHRpb25zLmRvbUV2ZW50cyYmZnVuY3Rpb24odCxlKXt2YXIgcj1kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO3IuaW5pdEV2ZW50KHQsITAsITApLHIuZ2VzdHVyZT1lLGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQocil9KHQsZSk7dmFyIHI9dGhpcy5oYW5kbGVyc1t0XSYmdGhpcy5oYW5kbGVyc1t0XS5zbGljZSgpO2lmKHImJnIubGVuZ3RoKXtlLnR5cGU9dCxlLnByZXZlbnREZWZhdWx0PWZ1bmN0aW9uKCl7ZS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpfTtmb3IodmFyIG49MDtuPHIubGVuZ3RoOylyW25dKGUpLG4rK319LGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZWxlbWVudCYmcmcodGhpcywhMSksdGhpcy5oYW5kbGVycz17fSx0aGlzLnNlc3Npb249e30sdGhpcy5pbnB1dC5kZXN0cm95KCksdGhpcy5lbGVtZW50PW51bGx9LHR9KCksaWc9e3RvdWNoc3RhcnQ6MSx0b3VjaG1vdmU6Mix0b3VjaGVuZDo0LHRvdWNoY2FuY2VsOjh9LG9nPVwidG91Y2hzdGFydFwiLGFnPVwidG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWxcIix1Zz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHIsbj1lLnByb3RvdHlwZTtyZXR1cm4gbi5ldlRhcmdldD1vZyxuLmV2V2luPWFnLChyPXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzKS5zdGFydGVkPSExLHJ9cmV0dXJuIEFkKGUsdCksZS5wcm90b3R5cGUuaGFuZGxlcj1mdW5jdGlvbih0KXt2YXIgZT1pZ1t0LnR5cGVdO2lmKDE9PT1lJiYodGhpcy5zdGFydGVkPSEwKSx0aGlzLnN0YXJ0ZWQpe3ZhciByPXNnLmNhbGwodGhpcyx0LGUpOzEyJmUmJnJbMF0ubGVuZ3RoLXJbMV0ubGVuZ3RoPT0wJiYodGhpcy5zdGFydGVkPSExKSx0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlcixlLHtwb2ludGVyczpyWzBdLGNoYW5nZWRQb2ludGVyczpyWzFdLHBvaW50ZXJUeXBlOkpkLHNyY0V2ZW50OnR9KX19LGV9KGJ5KTtmdW5jdGlvbiBzZyh0LGUpe3ZhciByPWt5KHQudG91Y2hlcyksbj1reSh0LmNoYW5nZWRUb3VjaGVzKTtyZXR1cm4gMTImZSYmKHI9U3koci5jb25jYXQobiksXCJpZGVudGlmaWVyXCIsITApKSxbcixuXX1mdW5jdGlvbiBjZyh0LGUscil7dmFyIG49XCJERVBSRUNBVEVEIE1FVEhPRDogXCIrZStcIlxcblwiK3IrXCIgQVQgXFxuXCI7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9bmV3IEVycm9yKFwiZ2V0LXN0YWNrLXRyYWNlXCIpLHI9ZSYmZS5zdGFjaz9lLnN0YWNrLnJlcGxhY2UoL15bXlxcKF0rP1tcXG4kXS9nbSxcIlwiKS5yZXBsYWNlKC9eXFxzK2F0XFxzKy9nbSxcIlwiKS5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKC9nbSxcInthbm9ueW1vdXN9KClAXCIpOlwiVW5rbm93biBTdGFjayBUcmFjZVwiLGk9d2luZG93LmNvbnNvbGUmJih3aW5kb3cuY29uc29sZS53YXJufHx3aW5kb3cuY29uc29sZS5sb2cpO3JldHVybiBpJiZpLmNhbGwod2luZG93LmNvbnNvbGUsbixyKSx0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dmFyIGZnPWNnKChmdW5jdGlvbih0LGUscil7Zm9yKHZhciBuPU9iamVjdC5rZXlzKGUpLGk9MDtpPG4ubGVuZ3RoOykoIXJ8fHImJnZvaWQgMD09PXRbbltpXV0pJiYodFtuW2ldXT1lW25baV1dKSxpKys7cmV0dXJuIHR9KSxcImV4dGVuZFwiLFwiVXNlIGBhc3NpZ25gLlwiKSxsZz1jZygoZnVuY3Rpb24odCxlKXtyZXR1cm4gZmcodCxlLCEwKX0pLFwibWVyZ2VcIixcIlVzZSBgYXNzaWduYC5cIik7ZnVuY3Rpb24gaGcodCxlLHIpe3ZhciBuLGk9ZS5wcm90b3R5cGU7KG49dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShpKSkuY29uc3RydWN0b3I9dCxuLl9zdXBlcj1pLHImJklkKG4scil9ZnVuY3Rpb24gcGcodCxlKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShlLGFyZ3VtZW50cyl9fXZhciB2Zz1mdW5jdGlvbigpe3ZhciB0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSxuZXcgbmcodCxTZCh7cmVjb2duaXplcnM6ZWcuY29uY2F0KCl9LGUpKX07cmV0dXJuIHQuVkVSU0lPTj1cIjIuMC4xNy1yY1wiLHQuRElSRUNUSU9OX0FMTD0zMCx0LkRJUkVDVElPTl9ET1dOPVFkLHQuRElSRUNUSU9OX0xFRlQ9Mix0LkRJUkVDVElPTl9SSUdIVD00LHQuRElSRUNUSU9OX1VQPTgsdC5ESVJFQ1RJT05fSE9SSVpPTlRBTD02LHQuRElSRUNUSU9OX1ZFUlRJQ0FMPVpkLHQuRElSRUNUSU9OX05PTkU9MSx0LkRJUkVDVElPTl9ET1dOPVFkLHQuSU5QVVRfU1RBUlQ9MSx0LklOUFVUX01PVkU9Mix0LklOUFVUX0VORD00LHQuSU5QVVRfQ0FOQ0VMPTgsdC5TVEFURV9QT1NTSUJMRT0xLHQuU1RBVEVfQkVHQU49Mix0LlNUQVRFX0NIQU5HRUQ9NCx0LlNUQVRFX0VOREVEPTgsdC5TVEFURV9SRUNPR05JWkVEPTgsdC5TVEFURV9DQU5DRUxMRUQ9MTYsdC5TVEFURV9GQUlMRUQ9WXksdC5NYW5hZ2VyPW5nLHQuSW5wdXQ9YnksdC5Ub3VjaEFjdGlvbj1veSx0LlRvdWNoSW5wdXQ9UHksdC5Nb3VzZUlucHV0PVJ5LHQuUG9pbnRlckV2ZW50SW5wdXQ9eHksdC5Ub3VjaE1vdXNlSW5wdXQ9enksdC5TaW5nbGVUb3VjaElucHV0PXVnLHQuUmVjb2duaXplcj1XeSx0LkF0dHJSZWNvZ25pemVyPUh5LHQuVGFwPVZ5LHQuUGFuPUJ5LHQuU3dpcGU9SnksdC5QaW5jaD1LeSx0LlJvdGF0ZT1ReSx0LlByZXNzPVp5LHQub249eXksdC5vZmY9Z3ksdC5lYWNoPXJ5LHQubWVyZ2U9bGcsdC5leHRlbmQ9ZmcsdC5iaW5kRm49cGcsdC5hc3NpZ249SWQsdC5pbmhlcml0PWhnLHQuYmluZEZuPXBnLHQucHJlZml4ZWQ9RmQsdC50b0FycmF5PWt5LHQuaW5BcnJheT1feSx0LnVuaXF1ZUFycmF5PVN5LHQuc3BsaXRTdHI9ZHksdC5ib29sT3JGbj1ueSx0Lmhhc1BhcmVudD1heSx0LmFkZEV2ZW50TGlzdGVuZXJzPXl5LHQucmVtb3ZlRXZlbnRMaXN0ZW5lcnM9Z3ksdC5kZWZhdWx0cz1JZCh7fSx0Zyx7cHJlc2V0OmVnfSksdH0oKTtmdW5jdGlvbiBkZyh0LGUpe3ZhciByPXZvaWQgMCE9PU9oJiZpYyh0KXx8dFtcIkBAaXRlcmF0b3JcIl07aWYoIXIpe2lmKFBoKHQpfHwocj1mdW5jdGlvbih0LGUpe3ZhciByO2lmKCF0KXJldHVybjtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4geWcodCxlKTt2YXIgbj1BaChyPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkuY2FsbChyLDgsLTEpO1wiT2JqZWN0XCI9PT1uJiZ0LmNvbnN0cnVjdG9yJiYobj10LmNvbnN0cnVjdG9yLm5hbWUpO2lmKFwiTWFwXCI9PT1ufHxcIlNldFwiPT09bilyZXR1cm4gcXModCk7aWYoXCJBcmd1bWVudHNcIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKXJldHVybiB5Zyh0LGUpfSh0KSl8fGUmJnQmJlwibnVtYmVyXCI9PXR5cGVvZiB0Lmxlbmd0aCl7ciYmKHQ9cik7dmFyIG49MCxpPWZ1bmN0aW9uKCl7fTtyZXR1cm57czppLG46ZnVuY3Rpb24oKXtyZXR1cm4gbj49dC5sZW5ndGg/e2RvbmU6ITB9Ontkb25lOiExLHZhbHVlOnRbbisrXX19LGU6ZnVuY3Rpb24odCl7dGhyb3cgdH0sZjppfX10aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9dmFyIG8sYT0hMCx1PSExO3JldHVybntzOmZ1bmN0aW9uKCl7cj1yLmNhbGwodCl9LG46ZnVuY3Rpb24oKXt2YXIgdD1yLm5leHQoKTtyZXR1cm4gYT10LmRvbmUsdH0sZTpmdW5jdGlvbih0KXt1PSEwLG89dH0sZjpmdW5jdGlvbigpe3RyeXthfHxudWxsPT1yLnJldHVybnx8ci5yZXR1cm4oKX1maW5hbGx5e2lmKHUpdGhyb3cgb319fX1mdW5jdGlvbiB5Zyh0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgcj0wLG49bmV3IEFycmF5KGUpO3I8ZTtyKyspbltyXT10W3JdO3JldHVybiBufXZhciBnZz1PaChcIkRFTEVURVwiKTtmdW5jdGlvbiBtZygpe3ZhciB0PWJnLmFwcGx5KHZvaWQgMCxhcmd1bWVudHMpO3JldHVybiB3Zyh0KSx0fWZ1bmN0aW9uIGJnKCl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsZT1uZXcgQXJyYXkodCkscj0wO3I8dDtyKyspZVtyXT1hcmd1bWVudHNbcl07aWYoZS5sZW5ndGg8MilyZXR1cm4gZVswXTt2YXIgbjtpZihlLmxlbmd0aD4yKXJldHVybiBiZy5hcHBseSh2b2lkIDAsU2gobj1bbWcoZVswXSxlWzFdKV0pLmNhbGwobix3aChBaChlKS5jYWxsKGUsMikpKSk7dmFyIGksbz1lWzBdLGE9ZVsxXSx1PWRnKGpoKGEpKTt0cnl7Zm9yKHUucygpOyEoaT11Lm4oKSkuZG9uZTspe3ZhciBzPWkudmFsdWU7T2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGEscykmJihhW3NdPT09Z2c/ZGVsZXRlIG9bc106bnVsbD09PW9bc118fG51bGw9PT1hW3NdfHxcIm9iamVjdFwiIT09X2gob1tzXSl8fFwib2JqZWN0XCIhPT1faChhW3NdKXx8UGgob1tzXSl8fFBoKGFbc10pP29bc109X2coYVtzXSk6b1tzXT1iZyhvW3NdLGFbc10pKX19Y2F0Y2godCl7dS5lKHQpfWZpbmFsbHl7dS5mKCl9cmV0dXJuIG99ZnVuY3Rpb24gX2codCl7cmV0dXJuIFBoKHQpP1JpKHQpLmNhbGwodCwoZnVuY3Rpb24odCl7cmV0dXJuIF9nKHQpfSkpOlwib2JqZWN0XCI9PT1faCh0KSYmbnVsbCE9PXQ/Ymcoe30sdCk6dH1mdW5jdGlvbiB3Zyh0KXtmb3IodmFyIGU9MCxyPUxoKHQpO2U8ci5sZW5ndGg7ZSsrKXt2YXIgbj1yW2VdO3Rbbl09PT1nZz9kZWxldGUgdFtuXTpcIm9iamVjdFwiPT09X2godFtuXSkmJm51bGwhPT10W25dJiZ3Zyh0W25dKX19dmFyIE9nPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93LkhhbW1lcnx8dmc6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbigpe307cmV0dXJue29uOnQsb2ZmOnQsZGVzdHJveTp0LGVtaXQ6dCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm57c2V0OnR9fX19KCl9O2Z1bmN0aW9uIEVnKHQpe3ZhciBlLHI9dGhpczt0aGlzLl9jbGVhbnVwUXVldWU9W10sdGhpcy5hY3RpdmU9ITEsdGhpcy5fZG9tPXtjb250YWluZXI6dCxvdmVybGF5OmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIil9LHRoaXMuX2RvbS5vdmVybGF5LmNsYXNzTGlzdC5hZGQoXCJ2aXMtb3ZlcmxheVwiKSx0aGlzLl9kb20uY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2RvbS5vdmVybGF5KSx0aGlzLl9jbGVhbnVwUXVldWUucHVzaCgoZnVuY3Rpb24oKXtyLl9kb20ub3ZlcmxheS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHIuX2RvbS5vdmVybGF5KX0pKTt2YXIgbj1PZyh0aGlzLl9kb20ub3ZlcmxheSk7bi5vbihcInRhcFwiLGVuKGU9dGhpcy5fb25UYXBPdmVybGF5KS5jYWxsKGUsdGhpcykpLHRoaXMuX2NsZWFudXBRdWV1ZS5wdXNoKChmdW5jdGlvbigpe24uZGVzdHJveSgpfSkpO3ZhciBpPVtcInRhcFwiLFwiZG91YmxldGFwXCIsXCJwcmVzc1wiLFwicGluY2hcIixcInBhblwiLFwicGFuc3RhcnRcIixcInBhbm1vdmVcIixcInBhbmVuZFwiXTtIaChpKS5jYWxsKGksKGZ1bmN0aW9uKHQpe24ub24odCwoZnVuY3Rpb24odCl7dC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKX0pKX0pKSxkb2N1bWVudCYmZG9jdW1lbnQuYm9keSYmKHRoaXMuX29uQ2xpY2s9ZnVuY3Rpb24oZSl7KGZ1bmN0aW9uKHQsZSl7Zm9yKDt0Oyl7aWYodD09PWUpcmV0dXJuITA7dD10LnBhcmVudE5vZGV9cmV0dXJuITF9KShlLnRhcmdldCx0KXx8ci5kZWFjdGl2YXRlKCl9LGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5fb25DbGljayksdGhpcy5fY2xlYW51cFF1ZXVlLnB1c2goKGZ1bmN0aW9uKCl7ZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIixyLl9vbkNsaWNrKX0pKSksdGhpcy5fZXNjTGlzdGVuZXI9ZnVuY3Rpb24odCl7KFwia2V5XCJpbiB0P1wiRXNjYXBlXCI9PT10LmtleToyNz09PXQua2V5Q29kZSkmJnIuZGVhY3RpdmF0ZSgpfX1rZChFZy5wcm90b3R5cGUpLEVnLmN1cnJlbnQ9bnVsbCxFZy5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3ZhciB0LGU7dGhpcy5kZWFjdGl2YXRlKCk7dmFyIHIsbj1kZyhycCh0PXdwKGU9dGhpcy5fY2xlYW51cFF1ZXVlKS5jYWxsKGUsMCkpLmNhbGwodCkpO3RyeXtmb3Iobi5zKCk7IShyPW4ubigpKS5kb25lOyl7KDAsci52YWx1ZSkoKX19Y2F0Y2godCl7bi5lKHQpfWZpbmFsbHl7bi5mKCl9fSxFZy5wcm90b3R5cGUuYWN0aXZhdGU9ZnVuY3Rpb24oKXtFZy5jdXJyZW50JiZFZy5jdXJyZW50LmRlYWN0aXZhdGUoKSxFZy5jdXJyZW50PXRoaXMsdGhpcy5hY3RpdmU9ITAsdGhpcy5fZG9tLm92ZXJsYXkuc3R5bGUuZGlzcGxheT1cIm5vbmVcIix0aGlzLl9kb20uY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ2aXMtYWN0aXZlXCIpLHRoaXMuZW1pdChcImNoYW5nZVwiKSx0aGlzLmVtaXQoXCJhY3RpdmF0ZVwiKSxkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5fZXNjTGlzdGVuZXIpfSxFZy5wcm90b3R5cGUuZGVhY3RpdmF0ZT1mdW5jdGlvbigpe3RoaXMuYWN0aXZlPSExLHRoaXMuX2RvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHRoaXMuX2RvbS5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcInZpcy1hY3RpdmVcIiksZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMuX2VzY0xpc3RlbmVyKSx0aGlzLmVtaXQoXCJjaGFuZ2VcIiksdGhpcy5lbWl0KFwiZGVhY3RpdmF0ZVwiKX0sRWcucHJvdG90eXBlLl9vblRhcE92ZXJsYXk9ZnVuY3Rpb24odCl7dGhpcy5hY3RpdmF0ZSgpLHQuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCl9O3ZhciBUZz1uaSx4Zz13dCxrZz1vLlR5cGVFcnJvcixTZz1UcixBZz1oLGpnPUhyLFBnPWZ1bmN0aW9uKHQpe2lmKFRnKHQpKXJldHVybiB0O3Rocm93IGtnKHhnKHQpK1wiIGlzIG5vdCBhIGNvbnN0cnVjdG9yXCIpfSxJZz1RZSxEZz0kLExnPU1hLENnPWEsUmc9dHQoXCJSZWZsZWN0XCIsXCJjb25zdHJ1Y3RcIiksTWc9T2JqZWN0LnByb3RvdHlwZSxGZz1bXS5wdXNoLE5nPUNnKChmdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIShSZygoZnVuY3Rpb24oKXt9KSxbXSx0KWluc3RhbmNlb2YgdCl9KSksemc9IUNnKChmdW5jdGlvbigpe1JnKChmdW5jdGlvbigpe30pKX0pKSxxZz1OZ3x8emc7U2coe3RhcmdldDpcIlJlZmxlY3RcIixzdGF0OiEwLGZvcmNlZDpxZyxzaGFtOnFnfSx7Y29uc3RydWN0OmZ1bmN0aW9uKHQsZSl7UGcodCksSWcoZSk7dmFyIHI9YXJndW1lbnRzLmxlbmd0aDwzP3Q6UGcoYXJndW1lbnRzWzJdKTtpZih6ZyYmIU5nKXJldHVybiBSZyh0LGUscik7aWYodD09cil7c3dpdGNoKGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIG5ldyB0O2Nhc2UgMTpyZXR1cm4gbmV3IHQoZVswXSk7Y2FzZSAyOnJldHVybiBuZXcgdChlWzBdLGVbMV0pO2Nhc2UgMzpyZXR1cm4gbmV3IHQoZVswXSxlWzFdLGVbMl0pO2Nhc2UgNDpyZXR1cm4gbmV3IHQoZVswXSxlWzFdLGVbMl0sZVszXSl9dmFyIG49W251bGxdO3JldHVybiBBZyhGZyxuLGUpLG5ldyhBZyhqZyx0LG4pKX12YXIgaT1yLnByb3RvdHlwZSxvPUxnKERnKGkpP2k6TWcpLGE9QWcodCxvLGUpO3JldHVybiBEZyhhKT9hOm99fSk7dmFyIFlnPUIuUmVmbGVjdC5jb25zdHJ1Y3Q7ZnVuY3Rpb24gR2codCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9dmFyIFhnPXF2O1RyKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwfSx7c2V0UHJvdG90eXBlT2Y6U3V9KTt2YXIgVWc9Qi5PYmplY3Quc2V0UHJvdG90eXBlT2Y7ZnVuY3Rpb24gV2codCxlKXtyZXR1cm4gV2c9VWd8fGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuX19wcm90b19fPWUsdH0sV2codCxlKX1mdW5jdGlvbiBWZyh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTt0LnByb3RvdHlwZT1YZyhlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLElyKHQsXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KSxlJiZXZyh0LGUpfWZ1bmN0aW9uIEhnKHQsZSl7aWYoZSYmKFwib2JqZWN0XCI9PT1faChlKXx8XCJmdW5jdGlvblwiPT10eXBlb2YgZSkpcmV0dXJuIGU7aWYodm9pZCAwIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7cmV0dXJuIEdnKHQpfXZhciAkZz1acDtmdW5jdGlvbiBCZyh0KXtyZXR1cm4gQmc9VWc/JGc6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19ffHwkZyh0KX0sQmcodCl9dmFyIEpnPXtleHBvcnRzOnt9fTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24odCl7dmFyIGUscj1PYmplY3QucHJvdG90eXBlLG49ci5oYXNPd25Qcm9wZXJ0eSxpPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbD9TeW1ib2w6e30sbz1pLml0ZXJhdG9yfHxcIkBAaXRlcmF0b3JcIixhPWkuYXN5bmNJdGVyYXRvcnx8XCJAQGFzeW5jSXRlcmF0b3JcIix1PWkudG9TdHJpbmdUYWd8fFwiQEB0b1N0cmluZ1RhZ1wiO2Z1bmN0aW9uIHModCxlLHIpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpyLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSksdFtlXX10cnl7cyh7fSxcIlwiKX1jYXRjaCh0KXtzPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdFtlXT1yfX1mdW5jdGlvbiBjKHQsZSxyLG4pe3ZhciBpPWUmJmUucHJvdG90eXBlIGluc3RhbmNlb2YgeT9lOnksbz1PYmplY3QuY3JlYXRlKGkucHJvdG90eXBlKSxhPW5ldyBBKG58fFtdKTtyZXR1cm4gby5faW52b2tlPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1sO3JldHVybiBmdW5jdGlvbihpLG8pe2lmKG49PT1wKXRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7aWYobj09PXYpe2lmKFwidGhyb3dcIj09PWkpdGhyb3cgbztyZXR1cm4gUCgpfWZvcihyLm1ldGhvZD1pLHIuYXJnPW87Oyl7dmFyIGE9ci5kZWxlZ2F0ZTtpZihhKXt2YXIgdT14KGEscik7aWYodSl7aWYodT09PWQpY29udGludWU7cmV0dXJuIHV9fWlmKFwibmV4dFwiPT09ci5tZXRob2Qpci5zZW50PXIuX3NlbnQ9ci5hcmc7ZWxzZSBpZihcInRocm93XCI9PT1yLm1ldGhvZCl7aWYobj09PWwpdGhyb3cgbj12LHIuYXJnO3IuZGlzcGF0Y2hFeGNlcHRpb24oci5hcmcpfWVsc2VcInJldHVyblwiPT09ci5tZXRob2QmJnIuYWJydXB0KFwicmV0dXJuXCIsci5hcmcpO249cDt2YXIgcz1mKHQsZSxyKTtpZihcIm5vcm1hbFwiPT09cy50eXBlKXtpZihuPXIuZG9uZT92Omgscy5hcmc9PT1kKWNvbnRpbnVlO3JldHVybnt2YWx1ZTpzLmFyZyxkb25lOnIuZG9uZX19XCJ0aHJvd1wiPT09cy50eXBlJiYobj12LHIubWV0aG9kPVwidGhyb3dcIixyLmFyZz1zLmFyZyl9fX0odCxyLGEpLG99ZnVuY3Rpb24gZih0LGUscil7dHJ5e3JldHVybnt0eXBlOlwibm9ybWFsXCIsYXJnOnQuY2FsbChlLHIpfX1jYXRjaCh0KXtyZXR1cm57dHlwZTpcInRocm93XCIsYXJnOnR9fX10LndyYXA9Yzt2YXIgbD1cInN1c3BlbmRlZFN0YXJ0XCIsaD1cInN1c3BlbmRlZFlpZWxkXCIscD1cImV4ZWN1dGluZ1wiLHY9XCJjb21wbGV0ZWRcIixkPXt9O2Z1bmN0aW9uIHkoKXt9ZnVuY3Rpb24gZygpe31mdW5jdGlvbiBtKCl7fXZhciBiPXt9O3MoYixvLChmdW5jdGlvbigpe3JldHVybiB0aGlzfSkpO3ZhciBfPU9iamVjdC5nZXRQcm90b3R5cGVPZix3PV8mJl8oXyhqKFtdKSkpO3cmJnchPT1yJiZuLmNhbGwodyxvKSYmKGI9dyk7dmFyIE89bS5wcm90b3R5cGU9eS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShiKTtmdW5jdGlvbiBFKHQpe1tcIm5leHRcIixcInRocm93XCIsXCJyZXR1cm5cIl0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7cyh0LGUsKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9pbnZva2UoZSx0KX0pKX0pKX1mdW5jdGlvbiBUKHQsZSl7ZnVuY3Rpb24gcihpLG8sYSx1KXt2YXIgcz1mKHRbaV0sdCxvKTtpZihcInRocm93XCIhPT1zLnR5cGUpe3ZhciBjPXMuYXJnLGw9Yy52YWx1ZTtyZXR1cm4gbCYmXCJvYmplY3RcIj09dHlwZW9mIGwmJm4uY2FsbChsLFwiX19hd2FpdFwiKT9lLnJlc29sdmUobC5fX2F3YWl0KS50aGVuKChmdW5jdGlvbih0KXtyKFwibmV4dFwiLHQsYSx1KX0pLChmdW5jdGlvbih0KXtyKFwidGhyb3dcIix0LGEsdSl9KSk6ZS5yZXNvbHZlKGwpLnRoZW4oKGZ1bmN0aW9uKHQpe2MudmFsdWU9dCxhKGMpfSksKGZ1bmN0aW9uKHQpe3JldHVybiByKFwidGhyb3dcIix0LGEsdSl9KSl9dShzLmFyZyl9dmFyIGk7dGhpcy5faW52b2tlPWZ1bmN0aW9uKHQsbil7ZnVuY3Rpb24gbygpe3JldHVybiBuZXcgZSgoZnVuY3Rpb24oZSxpKXtyKHQsbixlLGkpfSkpfXJldHVybiBpPWk/aS50aGVuKG8sbyk6bygpfX1mdW5jdGlvbiB4KHQscil7dmFyIG49dC5pdGVyYXRvcltyLm1ldGhvZF07aWYobj09PWUpe2lmKHIuZGVsZWdhdGU9bnVsbCxcInRocm93XCI9PT1yLm1ldGhvZCl7aWYodC5pdGVyYXRvci5yZXR1cm4mJihyLm1ldGhvZD1cInJldHVyblwiLHIuYXJnPWUseCh0LHIpLFwidGhyb3dcIj09PXIubWV0aG9kKSlyZXR1cm4gZDtyLm1ldGhvZD1cInRocm93XCIsci5hcmc9bmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIil9cmV0dXJuIGR9dmFyIGk9ZihuLHQuaXRlcmF0b3Isci5hcmcpO2lmKFwidGhyb3dcIj09PWkudHlwZSlyZXR1cm4gci5tZXRob2Q9XCJ0aHJvd1wiLHIuYXJnPWkuYXJnLHIuZGVsZWdhdGU9bnVsbCxkO3ZhciBvPWkuYXJnO3JldHVybiBvP28uZG9uZT8oclt0LnJlc3VsdE5hbWVdPW8udmFsdWUsci5uZXh0PXQubmV4dExvYyxcInJldHVyblwiIT09ci5tZXRob2QmJihyLm1ldGhvZD1cIm5leHRcIixyLmFyZz1lKSxyLmRlbGVnYXRlPW51bGwsZCk6bzooci5tZXRob2Q9XCJ0aHJvd1wiLHIuYXJnPW5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSxyLmRlbGVnYXRlPW51bGwsZCl9ZnVuY3Rpb24gayh0KXt2YXIgZT17dHJ5TG9jOnRbMF19OzEgaW4gdCYmKGUuY2F0Y2hMb2M9dFsxXSksMiBpbiB0JiYoZS5maW5hbGx5TG9jPXRbMl0sZS5hZnRlckxvYz10WzNdKSx0aGlzLnRyeUVudHJpZXMucHVzaChlKX1mdW5jdGlvbiBTKHQpe3ZhciBlPXQuY29tcGxldGlvbnx8e307ZS50eXBlPVwibm9ybWFsXCIsZGVsZXRlIGUuYXJnLHQuY29tcGxldGlvbj1lfWZ1bmN0aW9uIEEodCl7dGhpcy50cnlFbnRyaWVzPVt7dHJ5TG9jOlwicm9vdFwifV0sdC5mb3JFYWNoKGssdGhpcyksdGhpcy5yZXNldCghMCl9ZnVuY3Rpb24gaih0KXtpZih0KXt2YXIgcj10W29dO2lmKHIpcmV0dXJuIHIuY2FsbCh0KTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0Lm5leHQpcmV0dXJuIHQ7aWYoIWlzTmFOKHQubGVuZ3RoKSl7dmFyIGk9LTEsYT1mdW5jdGlvbiByKCl7Zm9yKDsrK2k8dC5sZW5ndGg7KWlmKG4uY2FsbCh0LGkpKXJldHVybiByLnZhbHVlPXRbaV0sci5kb25lPSExLHI7cmV0dXJuIHIudmFsdWU9ZSxyLmRvbmU9ITAscn07cmV0dXJuIGEubmV4dD1hfX1yZXR1cm57bmV4dDpQfX1mdW5jdGlvbiBQKCl7cmV0dXJue3ZhbHVlOmUsZG9uZTohMH19cmV0dXJuIGcucHJvdG90eXBlPW0scyhPLFwiY29uc3RydWN0b3JcIixtKSxzKG0sXCJjb25zdHJ1Y3RvclwiLGcpLGcuZGlzcGxheU5hbWU9cyhtLHUsXCJHZW5lcmF0b3JGdW5jdGlvblwiKSx0LmlzR2VuZXJhdG9yRnVuY3Rpb249ZnVuY3Rpb24odCl7dmFyIGU9XCJmdW5jdGlvblwiPT10eXBlb2YgdCYmdC5jb25zdHJ1Y3RvcjtyZXR1cm4hIWUmJihlPT09Z3x8XCJHZW5lcmF0b3JGdW5jdGlvblwiPT09KGUuZGlzcGxheU5hbWV8fGUubmFtZSkpfSx0Lm1hcms9ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxtKToodC5fX3Byb3RvX189bSxzKHQsdSxcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSx0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKE8pLHR9LHQuYXdyYXA9ZnVuY3Rpb24odCl7cmV0dXJue19fYXdhaXQ6dH19LEUoVC5wcm90b3R5cGUpLHMoVC5wcm90b3R5cGUsYSwoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pKSx0LkFzeW5jSXRlcmF0b3I9VCx0LmFzeW5jPWZ1bmN0aW9uKGUscixuLGksbyl7dm9pZCAwPT09byYmKG89UHJvbWlzZSk7dmFyIGE9bmV3IFQoYyhlLHIsbixpKSxvKTtyZXR1cm4gdC5pc0dlbmVyYXRvckZ1bmN0aW9uKHIpP2E6YS5uZXh0KCkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHQuZG9uZT90LnZhbHVlOmEubmV4dCgpfSkpfSxFKE8pLHMoTyx1LFwiR2VuZXJhdG9yXCIpLHMoTyxvLChmdW5jdGlvbigpe3JldHVybiB0aGlzfSkpLHMoTyxcInRvU3RyaW5nXCIsKGZ1bmN0aW9uKCl7cmV0dXJuXCJbb2JqZWN0IEdlbmVyYXRvcl1cIn0pKSx0LmtleXM9ZnVuY3Rpb24odCl7dmFyIGU9W107Zm9yKHZhciByIGluIHQpZS5wdXNoKHIpO3JldHVybiBlLnJldmVyc2UoKSxmdW5jdGlvbiByKCl7Zm9yKDtlLmxlbmd0aDspe3ZhciBuPWUucG9wKCk7aWYobiBpbiB0KXJldHVybiByLnZhbHVlPW4sci5kb25lPSExLHJ9cmV0dXJuIHIuZG9uZT0hMCxyfX0sdC52YWx1ZXM9aixBLnByb3RvdHlwZT17Y29uc3RydWN0b3I6QSxyZXNldDpmdW5jdGlvbih0KXtpZih0aGlzLnByZXY9MCx0aGlzLm5leHQ9MCx0aGlzLnNlbnQ9dGhpcy5fc2VudD1lLHRoaXMuZG9uZT0hMSx0aGlzLmRlbGVnYXRlPW51bGwsdGhpcy5tZXRob2Q9XCJuZXh0XCIsdGhpcy5hcmc9ZSx0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChTKSwhdClmb3IodmFyIHIgaW4gdGhpcylcInRcIj09PXIuY2hhckF0KDApJiZuLmNhbGwodGhpcyxyKSYmIWlzTmFOKCtyLnNsaWNlKDEpKSYmKHRoaXNbcl09ZSl9LHN0b3A6ZnVuY3Rpb24oKXt0aGlzLmRvbmU9ITA7dmFyIHQ9dGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247aWYoXCJ0aHJvd1wiPT09dC50eXBlKXRocm93IHQuYXJnO3JldHVybiB0aGlzLnJ2YWx9LGRpc3BhdGNoRXhjZXB0aW9uOmZ1bmN0aW9uKHQpe2lmKHRoaXMuZG9uZSl0aHJvdyB0O3ZhciByPXRoaXM7ZnVuY3Rpb24gaShuLGkpe3JldHVybiB1LnR5cGU9XCJ0aHJvd1wiLHUuYXJnPXQsci5uZXh0PW4saSYmKHIubWV0aG9kPVwibmV4dFwiLHIuYXJnPWUpLCEhaX1mb3IodmFyIG89dGhpcy50cnlFbnRyaWVzLmxlbmd0aC0xO28+PTA7LS1vKXt2YXIgYT10aGlzLnRyeUVudHJpZXNbb10sdT1hLmNvbXBsZXRpb247aWYoXCJyb290XCI9PT1hLnRyeUxvYylyZXR1cm4gaShcImVuZFwiKTtpZihhLnRyeUxvYzw9dGhpcy5wcmV2KXt2YXIgcz1uLmNhbGwoYSxcImNhdGNoTG9jXCIpLGM9bi5jYWxsKGEsXCJmaW5hbGx5TG9jXCIpO2lmKHMmJmMpe2lmKHRoaXMucHJldjxhLmNhdGNoTG9jKXJldHVybiBpKGEuY2F0Y2hMb2MsITApO2lmKHRoaXMucHJldjxhLmZpbmFsbHlMb2MpcmV0dXJuIGkoYS5maW5hbGx5TG9jKX1lbHNlIGlmKHMpe2lmKHRoaXMucHJldjxhLmNhdGNoTG9jKXJldHVybiBpKGEuY2F0Y2hMb2MsITApfWVsc2V7aWYoIWMpdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7aWYodGhpcy5wcmV2PGEuZmluYWxseUxvYylyZXR1cm4gaShhLmZpbmFsbHlMb2MpfX19fSxhYnJ1cHQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9dGhpcy50cnlFbnRyaWVzLmxlbmd0aC0xO3I+PTA7LS1yKXt2YXIgaT10aGlzLnRyeUVudHJpZXNbcl07aWYoaS50cnlMb2M8PXRoaXMucHJldiYmbi5jYWxsKGksXCJmaW5hbGx5TG9jXCIpJiZ0aGlzLnByZXY8aS5maW5hbGx5TG9jKXt2YXIgbz1pO2JyZWFrfX1vJiYoXCJicmVha1wiPT09dHx8XCJjb250aW51ZVwiPT09dCkmJm8udHJ5TG9jPD1lJiZlPD1vLmZpbmFsbHlMb2MmJihvPW51bGwpO3ZhciBhPW8/by5jb21wbGV0aW9uOnt9O3JldHVybiBhLnR5cGU9dCxhLmFyZz1lLG8/KHRoaXMubWV0aG9kPVwibmV4dFwiLHRoaXMubmV4dD1vLmZpbmFsbHlMb2MsZCk6dGhpcy5jb21wbGV0ZShhKX0sY29tcGxldGU6ZnVuY3Rpb24odCxlKXtpZihcInRocm93XCI9PT10LnR5cGUpdGhyb3cgdC5hcmc7cmV0dXJuXCJicmVha1wiPT09dC50eXBlfHxcImNvbnRpbnVlXCI9PT10LnR5cGU/dGhpcy5uZXh0PXQuYXJnOlwicmV0dXJuXCI9PT10LnR5cGU/KHRoaXMucnZhbD10aGlzLmFyZz10LmFyZyx0aGlzLm1ldGhvZD1cInJldHVyblwiLHRoaXMubmV4dD1cImVuZFwiKTpcIm5vcm1hbFwiPT09dC50eXBlJiZlJiYodGhpcy5uZXh0PWUpLGR9LGZpbmlzaDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy50cnlFbnRyaWVzLmxlbmd0aC0xO2U+PTA7LS1lKXt2YXIgcj10aGlzLnRyeUVudHJpZXNbZV07aWYoci5maW5hbGx5TG9jPT09dClyZXR1cm4gdGhpcy5jb21wbGV0ZShyLmNvbXBsZXRpb24sci5hZnRlckxvYyksUyhyKSxkfX0sY2F0Y2g6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtlPj0wOy0tZSl7dmFyIHI9dGhpcy50cnlFbnRyaWVzW2VdO2lmKHIudHJ5TG9jPT09dCl7dmFyIG49ci5jb21wbGV0aW9uO2lmKFwidGhyb3dcIj09PW4udHlwZSl7dmFyIGk9bi5hcmc7UyhyKX1yZXR1cm4gaX19dGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpfSxkZWxlZ2F0ZVlpZWxkOmZ1bmN0aW9uKHQscixuKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZT17aXRlcmF0b3I6aih0KSxyZXN1bHROYW1lOnIsbmV4dExvYzpufSxcIm5leHRcIj09PXRoaXMubWV0aG9kJiYodGhpcy5hcmc9ZSksZH19LHR9KHQuZXhwb3J0cyk7dHJ5e3JlZ2VuZXJhdG9yUnVudGltZT1lfWNhdGNoKHQpe1wib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lPWU6RnVuY3Rpb24oXCJyXCIsXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKGUpfX0oSmcpO3ZhciBLZz1KZy5leHBvcnRzLFFnPXtleHBvcnRzOnt9fSxaZz1hKChmdW5jdGlvbigpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIEFycmF5QnVmZmVyKXt2YXIgdD1uZXcgQXJyYXlCdWZmZXIoOCk7T2JqZWN0LmlzRXh0ZW5zaWJsZSh0KSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJhXCIse3ZhbHVlOjh9KX19KSksdG09YSxlbT0kLHJtPVIsbm09WmcsaW09T2JqZWN0LmlzRXh0ZW5zaWJsZSxvbT10bSgoZnVuY3Rpb24oKXtpbSgxKX0pKXx8bm0/ZnVuY3Rpb24odCl7cmV0dXJuISFlbSh0KSYmKCghbm18fFwiQXJyYXlCdWZmZXJcIiE9cm0odCkpJiYoIWltfHxpbSh0KSkpfTppbSxhbT0hYSgoZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKX0pKSx1bT1UcixzbT1tLGNtPUVvLGZtPSQsbG09VXQsaG09VmUuZixwbT1vYyx2bT1zYyxkbT1vbSx5bT1hbSxnbT0hMSxtbT1CdChcIm1ldGFcIiksYm09MCxfbT1mdW5jdGlvbih0KXtobSh0LG1tLHt2YWx1ZTp7b2JqZWN0SUQ6XCJPXCIrYm0rKyx3ZWFrRGF0YTp7fX19KX0sd209UWcuZXhwb3J0cz17ZW5hYmxlOmZ1bmN0aW9uKCl7d20uZW5hYmxlPWZ1bmN0aW9uKCl7fSxnbT0hMDt2YXIgdD1wbS5mLGU9c20oW10uc3BsaWNlKSxyPXt9O3JbbW1dPTEsdChyKS5sZW5ndGgmJihwbS5mPWZ1bmN0aW9uKHIpe2Zvcih2YXIgbj10KHIpLGk9MCxvPW4ubGVuZ3RoO2k8bztpKyspaWYobltpXT09PW1tKXtlKG4saSwxKTticmVha31yZXR1cm4gbn0sdW0oe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOiEwfSx7Z2V0T3duUHJvcGVydHlOYW1lczp2bS5mfSkpfSxmYXN0S2V5OmZ1bmN0aW9uKHQsZSl7aWYoIWZtKHQpKXJldHVyblwic3ltYm9sXCI9PXR5cGVvZiB0P3Q6KFwic3RyaW5nXCI9PXR5cGVvZiB0P1wiU1wiOlwiUFwiKSt0O2lmKCFsbSh0LG1tKSl7aWYoIWRtKHQpKXJldHVyblwiRlwiO2lmKCFlKXJldHVyblwiRVwiO19tKHQpfXJldHVybiB0W21tXS5vYmplY3RJRH0sZ2V0V2Vha0RhdGE6ZnVuY3Rpb24odCxlKXtpZighbG0odCxtbSkpe2lmKCFkbSh0KSlyZXR1cm4hMDtpZighZSlyZXR1cm4hMTtfbSh0KX1yZXR1cm4gdFttbV0ud2Vha0RhdGF9LG9uRnJlZXplOmZ1bmN0aW9uKHQpe3JldHVybiB5bSYmZ20mJmRtKHQpJiYhbG0odCxtbSkmJl9tKHQpLHR9fTtjbVttbV09ITA7dmFyIE9tPVdlLEVtPVQsVG09UWUseG09d3Qsa209b3MsU209Y24sQW09ZXQsam09d3MsUG09dnMsSW09WnUsRG09by5UeXBlRXJyb3IsTG09ZnVuY3Rpb24odCxlKXt0aGlzLnN0b3BwZWQ9dCx0aGlzLnJlc3VsdD1lfSxDbT1MbS5wcm90b3R5cGUsUm09ZnVuY3Rpb24odCxlLHIpe3ZhciBuLGksbyxhLHUscyxjLGY9ciYmci50aGF0LGw9ISghcnx8IXIuQVNfRU5UUklFUyksaD0hKCFyfHwhci5JU19JVEVSQVRPUikscD0hKCFyfHwhci5JTlRFUlJVUFRFRCksdj1PbShlLGYpLGQ9ZnVuY3Rpb24odCl7cmV0dXJuIG4mJkltKG4sXCJub3JtYWxcIix0KSxuZXcgTG0oITAsdCl9LHk9ZnVuY3Rpb24odCl7cmV0dXJuIGw/KFRtKHQpLHA/dih0WzBdLHRbMV0sZCk6dih0WzBdLHRbMV0pKTpwP3YodCxkKTp2KHQpfTtpZihoKW49dDtlbHNle2lmKCEoaT1QbSh0KSkpdGhyb3cgRG0oeG0odCkrXCIgaXMgbm90IGl0ZXJhYmxlXCIpO2lmKGttKGkpKXtmb3Iobz0wLGE9U20odCk7YT5vO28rKylpZigodT15KHRbb10pKSYmQW0oQ20sdSkpcmV0dXJuIHU7cmV0dXJuIG5ldyBMbSghMSl9bj1qbSh0LGkpfWZvcihzPW4ubmV4dDshKGM9RW0ocyxuKSkuZG9uZTspe3RyeXt1PXkoYy52YWx1ZSl9Y2F0Y2godCl7SW0obixcInRocm93XCIsdCl9aWYoXCJvYmplY3RcIj09dHlwZW9mIHUmJnUmJkFtKENtLHUpKXJldHVybiB1fXJldHVybiBuZXcgTG0oITEpfSxNbT1ldCxGbT1vLlR5cGVFcnJvcixObT1mdW5jdGlvbih0LGUpe2lmKE1tKGUsdCkpcmV0dXJuIHQ7dGhyb3cgRm0oXCJJbmNvcnJlY3QgaW52b2NhdGlvblwiKX0sem09VHIscW09byxZbT1RZy5leHBvcnRzLEdtPWEsWG09aHIsVW09Um0sV209Tm0sVm09YixIbT0kLCRtPWh1LEJtPVZlLmYsSm09YmkuZm9yRWFjaCxLbT13LFFtPVlvLnNldCxabT1Zby5nZXR0ZXJGb3IsdGI9ZnVuY3Rpb24odCxlLHIpe3ZhciBuLGk9LTEhPT10LmluZGV4T2YoXCJNYXBcIiksbz0tMSE9PXQuaW5kZXhPZihcIldlYWtcIiksYT1pP1wic2V0XCI6XCJhZGRcIix1PXFtW3RdLHM9dSYmdS5wcm90b3R5cGUsYz17fTtpZihLbSYmVm0odSkmJihvfHxzLmZvckVhY2gmJiFHbSgoZnVuY3Rpb24oKXsobmV3IHUpLmVudHJpZXMoKS5uZXh0KCl9KSkpKXt2YXIgZj0obj1lKChmdW5jdGlvbihlLHIpe1FtKFdtKGUsZikse3R5cGU6dCxjb2xsZWN0aW9uOm5ldyB1fSksbnVsbCE9ciYmVW0ocixlW2FdLHt0aGF0OmUsQVNfRU5UUklFUzppfSl9KSkpLnByb3RvdHlwZSxsPVptKHQpO0ptKFtcImFkZFwiLFwiY2xlYXJcIixcImRlbGV0ZVwiLFwiZm9yRWFjaFwiLFwiZ2V0XCIsXCJoYXNcIixcInNldFwiLFwia2V5c1wiLFwidmFsdWVzXCIsXCJlbnRyaWVzXCJdLChmdW5jdGlvbih0KXt2YXIgZT1cImFkZFwiPT10fHxcInNldFwiPT10OyEodCBpbiBzKXx8byYmXCJjbGVhclwiPT10fHxYbShmLHQsKGZ1bmN0aW9uKHIsbil7dmFyIGk9bCh0aGlzKS5jb2xsZWN0aW9uO2lmKCFlJiZvJiYhSG0ocikpcmV0dXJuXCJnZXRcIj09dCYmdm9pZCAwO3ZhciBhPWlbdF0oMD09PXI/MDpyLG4pO3JldHVybiBlP3RoaXM6YX0pKX0pKSxvfHxCbShmLFwic2l6ZVwiLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGwodGhpcykuY29sbGVjdGlvbi5zaXplfX0pfWVsc2Ugbj1yLmdldENvbnN0cnVjdG9yKGUsdCxpLGEpLFltLmVuYWJsZSgpO3JldHVybiAkbShuLHQsITEsITApLGNbdF09bix6bSh7Z2xvYmFsOiEwLGZvcmNlZDohMH0sYyksb3x8ci5zZXRTdHJvbmcobix0LGkpLG59LGViPSRhLHJiPXR0LG5iPVZlLGliPXcsb2I9YWUoXCJzcGVjaWVzXCIpLGFiPVZlLmYsdWI9TWEsc2I9ZnVuY3Rpb24odCxlLHIpe2Zvcih2YXIgbiBpbiBlKXImJnIudW5zYWZlJiZ0W25dP3Rbbl09ZVtuXTplYih0LG4sZVtuXSxyKTtyZXR1cm4gdH0sY2I9V2UsZmI9Tm0sbGI9Um0saGI9R3UscGI9ZnVuY3Rpb24odCl7dmFyIGU9cmIodCkscj1uYi5mO2liJiZlJiYhZVtvYl0mJnIoZSxvYix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzfX0pfSx2Yj13LGRiPVFnLmV4cG9ydHMuZmFzdEtleSx5Yj1Zby5zZXQsZ2I9WW8uZ2V0dGVyRm9yLG1iPXtnZXRDb25zdHJ1Y3RvcjpmdW5jdGlvbih0LGUscixuKXt2YXIgaT10KChmdW5jdGlvbih0LGkpe2ZiKHQsbykseWIodCx7dHlwZTplLGluZGV4OnViKG51bGwpLGZpcnN0OnZvaWQgMCxsYXN0OnZvaWQgMCxzaXplOjB9KSx2Ynx8KHQuc2l6ZT0wKSxudWxsIT1pJiZsYihpLHRbbl0se3RoYXQ6dCxBU19FTlRSSUVTOnJ9KX0pKSxvPWkucHJvdG90eXBlLGE9Z2IoZSksdT1mdW5jdGlvbih0LGUscil7dmFyIG4saSxvPWEodCksdT1zKHQsZSk7cmV0dXJuIHU/dS52YWx1ZT1yOihvLmxhc3Q9dT17aW5kZXg6aT1kYihlLCEwKSxrZXk6ZSx2YWx1ZTpyLHByZXZpb3VzOm49by5sYXN0LG5leHQ6dm9pZCAwLHJlbW92ZWQ6ITF9LG8uZmlyc3R8fChvLmZpcnN0PXUpLG4mJihuLm5leHQ9dSksdmI/by5zaXplKys6dC5zaXplKyssXCJGXCIhPT1pJiYoby5pbmRleFtpXT11KSksdH0scz1mdW5jdGlvbih0LGUpe3ZhciByLG49YSh0KSxpPWRiKGUpO2lmKFwiRlwiIT09aSlyZXR1cm4gbi5pbmRleFtpXTtmb3Iocj1uLmZpcnN0O3I7cj1yLm5leHQpaWYoci5rZXk9PWUpcmV0dXJuIHJ9O3JldHVybiBzYihvLHtjbGVhcjpmdW5jdGlvbigpe2Zvcih2YXIgdD1hKHRoaXMpLGU9dC5pbmRleCxyPXQuZmlyc3Q7cjspci5yZW1vdmVkPSEwLHIucHJldmlvdXMmJihyLnByZXZpb3VzPXIucHJldmlvdXMubmV4dD12b2lkIDApLGRlbGV0ZSBlW3IuaW5kZXhdLHI9ci5uZXh0O3QuZmlyc3Q9dC5sYXN0PXZvaWQgMCx2Yj90LnNpemU9MDp0aGlzLnNpemU9MH0sZGVsZXRlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj1hKGUpLG49cyhlLHQpO2lmKG4pe3ZhciBpPW4ubmV4dCxvPW4ucHJldmlvdXM7ZGVsZXRlIHIuaW5kZXhbbi5pbmRleF0sbi5yZW1vdmVkPSEwLG8mJihvLm5leHQ9aSksaSYmKGkucHJldmlvdXM9byksci5maXJzdD09biYmKHIuZmlyc3Q9aSksci5sYXN0PT1uJiYoci5sYXN0PW8pLHZiP3Iuc2l6ZS0tOmUuc2l6ZS0tfXJldHVybiEhbn0sZm9yRWFjaDpmdW5jdGlvbih0KXtmb3IodmFyIGUscj1hKHRoaXMpLG49Y2IodCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCk7ZT1lP2UubmV4dDpyLmZpcnN0Oylmb3IobihlLnZhbHVlLGUua2V5LHRoaXMpO2UmJmUucmVtb3ZlZDspZT1lLnByZXZpb3VzfSxoYXM6ZnVuY3Rpb24odCl7cmV0dXJuISFzKHRoaXMsdCl9fSksc2IobyxyP3tnZXQ6ZnVuY3Rpb24odCl7dmFyIGU9cyh0aGlzLHQpO3JldHVybiBlJiZlLnZhbHVlfSxzZXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdSh0aGlzLDA9PT10PzA6dCxlKX19OnthZGQ6ZnVuY3Rpb24odCl7cmV0dXJuIHUodGhpcyx0PTA9PT10PzA6dCx0KX19KSx2YiYmYWIobyxcInNpemVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEodGhpcykuc2l6ZX19KSxpfSxzZXRTdHJvbmc6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPWUrXCIgSXRlcmF0b3JcIixpPWdiKGUpLG89Z2Iobik7aGIodCxlLChmdW5jdGlvbih0LGUpe3liKHRoaXMse3R5cGU6bix0YXJnZXQ6dCxzdGF0ZTppKHQpLGtpbmQ6ZSxsYXN0OnZvaWQgMH0pfSksKGZ1bmN0aW9uKCl7Zm9yKHZhciB0PW8odGhpcyksZT10LmtpbmQscj10Lmxhc3Q7ciYmci5yZW1vdmVkOylyPXIucHJldmlvdXM7cmV0dXJuIHQudGFyZ2V0JiYodC5sYXN0PXI9cj9yLm5leHQ6dC5zdGF0ZS5maXJzdCk/XCJrZXlzXCI9PWU/e3ZhbHVlOnIua2V5LGRvbmU6ITF9OlwidmFsdWVzXCI9PWU/e3ZhbHVlOnIudmFsdWUsZG9uZTohMX06e3ZhbHVlOltyLmtleSxyLnZhbHVlXSxkb25lOiExfToodC50YXJnZXQ9dm9pZCAwLHt2YWx1ZTp2b2lkIDAsZG9uZTohMH0pfSkscj9cImVudHJpZXNcIjpcInZhbHVlc1wiLCFyLCEwKSxwYihlKX19O3RiKFwiTWFwXCIsKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0KHRoaXMsYXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMF06dm9pZCAwKX19KSxtYik7dmFyIGJiPUIuTWFwLF9iPWJpLnNvbWU7VHIoe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOiFtbihcInNvbWVcIil9LHtzb21lOmZ1bmN0aW9uKHQpe3JldHVybiBfYih0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pO3ZhciB3Yj1KcihcIkFycmF5XCIpLnNvbWUsT2I9ZXQsRWI9d2IsVGI9QXJyYXkucHJvdG90eXBlLHhiPWZ1bmN0aW9uKHQpe3ZhciBlPXQuc29tZTtyZXR1cm4gdD09PVRifHxPYihUYix0KSYmZT09PVRiLnNvbWU/RWI6ZX0sa2I9SnIoXCJBcnJheVwiKS5rZXlzLFNiPXpuLEFiPVV0LGpiPWV0LFBiPWtiLEliPUFycmF5LnByb3RvdHlwZSxEYj17RE9NVG9rZW5MaXN0OiEwLE5vZGVMaXN0OiEwfSxMYj1mdW5jdGlvbih0KXt2YXIgZT10LmtleXM7cmV0dXJuIHQ9PT1JYnx8amIoSWIsdCkmJmU9PT1JYi5rZXlzfHxBYihEYixTYih0KSk/UGI6ZX0sQ2I9dmMsUmI9TWF0aC5mbG9vcixNYj1mdW5jdGlvbih0LGUpe3ZhciByPXQubGVuZ3RoLG49UmIoci8yKTtyZXR1cm4gcjw4P0ZiKHQsZSk6TmIodCxNYihDYih0LDAsbiksZSksTWIoQ2IodCxuKSxlKSxlKX0sRmI9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHIsbixpPXQubGVuZ3RoLG89MTtvPGk7KXtmb3Iobj1vLHI9dFtvXTtuJiZlKHRbbi0xXSxyKT4wOyl0W25dPXRbLS1uXTtuIT09bysrJiYodFtuXT1yKX1yZXR1cm4gdH0sTmI9ZnVuY3Rpb24odCxlLHIsbil7Zm9yKHZhciBpPWUubGVuZ3RoLG89ci5sZW5ndGgsYT0wLHU9MDthPGl8fHU8bzspdFthK3VdPWE8aSYmdTxvP24oZVthXSxyW3VdKTw9MD9lW2ErK106clt1KytdOmE8aT9lW2ErK106clt1KytdO3JldHVybiB0fSx6Yj1NYixxYj1ydC5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS9pKSxZYj0hIXFiJiYrcWJbMV0sR2I9L01TSUV8VHJpZGVudC8udGVzdChydCksWGI9cnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvKFxcZCspXFwuLyksVWI9ISFYYiYmK1hiWzFdLFdiPVRyLFZiPW0sSGI9eHQsJGI9WXQsQmI9Y24sSmI9aW8sS2I9YSxRYj16YixaYj1tbix0Xz1ZYixlXz1HYixyXz1jdCxuXz1VYixpXz1bXSxvXz1WYihpXy5zb3J0KSxhXz1WYihpXy5wdXNoKSx1Xz1LYigoZnVuY3Rpb24oKXtpXy5zb3J0KHZvaWQgMCl9KSksc189S2IoKGZ1bmN0aW9uKCl7aV8uc29ydChudWxsKX0pKSxjXz1aYihcInNvcnRcIiksZl89IUtiKChmdW5jdGlvbigpe2lmKHJfKXJldHVybiByXzw3MDtpZighKHRfJiZ0Xz4zKSl7aWYoZV8pcmV0dXJuITA7aWYobl8pcmV0dXJuIG5fPDYwMzt2YXIgdCxlLHIsbixpPVwiXCI7Zm9yKHQ9NjU7dDw3Njt0Kyspe3N3aXRjaChlPVN0cmluZy5mcm9tQ2hhckNvZGUodCksdCl7Y2FzZSA2NjpjYXNlIDY5OmNhc2UgNzA6Y2FzZSA3MjpyPTM7YnJlYWs7Y2FzZSA2ODpjYXNlIDcxOnI9NDticmVhaztkZWZhdWx0OnI9Mn1mb3Iobj0wO248NDc7bisrKWlfLnB1c2goe2s6ZStuLHY6cn0pfWZvcihpXy5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiBlLnYtdC52fSkpLG49MDtuPGlfLmxlbmd0aDtuKyspZT1pX1tuXS5rLmNoYXJBdCgwKSxpLmNoYXJBdChpLmxlbmd0aC0xKSE9PWUmJihpKz1lKTtyZXR1cm5cIkRHQkVGSEFDSUpLXCIhPT1pfX0pKTtXYih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6dV98fCFzX3x8IWNffHwhZl99LHtzb3J0OmZ1bmN0aW9uKHQpe3ZvaWQgMCE9PXQmJkhiKHQpO3ZhciBlPSRiKHRoaXMpO2lmKGZfKXJldHVybiB2b2lkIDA9PT10P29fKGUpOm9fKGUsdCk7dmFyIHIsbixpPVtdLG89QmIoZSk7Zm9yKG49MDtuPG87bisrKW4gaW4gZSYmYV8oaSxlW25dKTtmb3IoUWIoaSxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxyKXtyZXR1cm4gdm9pZCAwPT09cj8tMTp2b2lkIDA9PT1lPzE6dm9pZCAwIT09dD8rdChlLHIpfHwwOkpiKGUpPkpiKHIpPzE6LTF9fSh0KSkscj1pLmxlbmd0aCxuPTA7bjxyOyllW25dPWlbbisrXTtmb3IoO248bzspZGVsZXRlIGVbbisrXTtyZXR1cm4gZX19KTt2YXIgbF8saF89SnIoXCJBcnJheVwiKS5zb3J0LHBfPWV0LHZfPWhfLGRfPUFycmF5LnByb3RvdHlwZSx5Xz1mdW5jdGlvbih0KXt2YXIgZT10LnNvcnQ7cmV0dXJuIHQ9PT1kX3x8cF8oZF8sdCkmJmU9PT1kXy5zb3J0P3ZfOmV9LGdfPUpyKFwiQXJyYXlcIikudmFsdWVzLG1fPXpuLGJfPVV0LF9fPWV0LHdfPWdfLE9fPUFycmF5LnByb3RvdHlwZSxFXz17RE9NVG9rZW5MaXN0OiEwLE5vZGVMaXN0OiEwfSxUXz1mdW5jdGlvbih0KXt2YXIgZT10LnZhbHVlcztyZXR1cm4gdD09PU9ffHxfXyhPXyx0KSYmZT09PU9fLnZhbHVlc3x8Yl8oRV8sbV8odCkpP3dfOmV9LHhfPW1oLGtfPUpyKFwiQXJyYXlcIikuZW50cmllcyxTXz16bixBXz1VdCxqXz1ldCxQXz1rXyxJXz1BcnJheS5wcm90b3R5cGUsRF89e0RPTVRva2VuTGlzdDohMCxOb2RlTGlzdDohMH0sTF89ZnVuY3Rpb24odCl7dmFyIGU9dC5lbnRyaWVzO3JldHVybiB0PT09SV98fGpfKElfLHQpJiZlPT09SV8uZW50cmllc3x8QV8oRF8sU18odCkpP1BfOmV9LENfPW5ldyBVaW50OEFycmF5KDE2KTtmdW5jdGlvbiBSXygpe2lmKCFsXyYmIShsXz1cInVuZGVmaW5lZFwiIT10eXBlb2YgY3J5cHRvJiZjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzJiZjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKXx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1zQ3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMmJm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKSkpdGhyb3cgbmV3IEVycm9yKFwiY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWRcIik7cmV0dXJuIGxfKENfKX12YXIgTV89L14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO2Z1bmN0aW9uIEZfKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0JiZNXy50ZXN0KHQpfWZvcih2YXIgTl89W10sel89MDt6XzwyNTY7Kyt6XylOXy5wdXNoKCh6XysyNTYpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO2Z1bmN0aW9uIHFfKHQsZSxyKXt2YXIgbj0odD10fHx7fSkucmFuZG9tfHwodC5ybmd8fFJfKSgpO2lmKG5bNl09MTUmbls2XXw2NCxuWzhdPTYzJm5bOF18MTI4LGUpe3I9cnx8MDtmb3IodmFyIGk9MDtpPDE2OysraSllW3IraV09bltpXTtyZXR1cm4gZX1yZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjAscj0oTl9bdFtlKzBdXStOX1t0W2UrMV1dK05fW3RbZSsyXV0rTl9bdFtlKzNdXStcIi1cIitOX1t0W2UrNF1dK05fW3RbZSs1XV0rXCItXCIrTl9bdFtlKzZdXStOX1t0W2UrN11dK1wiLVwiK05fW3RbZSs4XV0rTl9bdFtlKzldXStcIi1cIitOX1t0W2UrMTBdXStOX1t0W2UrMTFdXStOX1t0W2UrMTJdXStOX1t0W2UrMTNdXStOX1t0W2UrMTRdXStOX1t0W2UrMTVdXSkudG9Mb3dlckNhc2UoKTtpZighRl8ocikpdGhyb3cgVHlwZUVycm9yKFwiU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkXCIpO3JldHVybiByfShuKX1mdW5jdGlvbiBZXyh0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdHx8XCJudW1iZXJcIj09dHlwZW9mIHR9dmFyIEdfPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChyKXtlKHRoaXMsdCksQ3IodGhpcyxcImRlbGF5XCIsdm9pZCAwKSxDcih0aGlzLFwibWF4XCIsdm9pZCAwKSxDcih0aGlzLFwiX3F1ZXVlXCIsW10pLENyKHRoaXMsXCJfdGltZW91dFwiLG51bGwpLENyKHRoaXMsXCJfZXh0ZW5kZWRcIixudWxsKSx0aGlzLmRlbGF5PW51bGwsdGhpcy5tYXg9MS8wLHRoaXMuc2V0T3B0aW9ucyhyKX1yZXR1cm4gTHIodCxbe2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt0JiZ2b2lkIDAhPT10LmRlbGF5JiYodGhpcy5kZWxheT10LmRlbGF5KSx0JiZ2b2lkIDAhPT10Lm1heCYmKHRoaXMubWF4PXQubWF4KSx0aGlzLl9mbHVzaElmTmVlZGVkKCl9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5mbHVzaCgpLHRoaXMuX2V4dGVuZGVkKXtmb3IodmFyIHQ9dGhpcy5fZXh0ZW5kZWQub2JqZWN0LGU9dGhpcy5fZXh0ZW5kZWQubWV0aG9kcyxyPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBuPWVbcl07bi5vcmlnaW5hbD90W24ubmFtZV09bi5vcmlnaW5hbDpkZWxldGUgdFtuLm5hbWVdfXRoaXMuX2V4dGVuZGVkPW51bGx9fX0se2tleTpcInJlcGxhY2VcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciByPXRoaXMsbj10W2VdO2lmKCFuKXRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBcIitlK1wiIHVuZGVmaW5lZFwiKTt0W2VdPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsZT1uZXcgQXJyYXkodCksaT0wO2k8dDtpKyspZVtpXT1hcmd1bWVudHNbaV07ci5xdWV1ZSh7YXJnczplLGZuOm4sY29udGV4dDp0aGlzfSl9fX0se2tleTpcInF1ZXVlXCIsdmFsdWU6ZnVuY3Rpb24odCl7XCJmdW5jdGlvblwiPT10eXBlb2YgdD90aGlzLl9xdWV1ZS5wdXNoKHtmbjp0fSk6dGhpcy5fcXVldWUucHVzaCh0KSx0aGlzLl9mbHVzaElmTmVlZGVkKCl9fSx7a2V5OlwiX2ZsdXNoSWZOZWVkZWRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5fcXVldWUubGVuZ3RoPnRoaXMubWF4JiZ0aGlzLmZsdXNoKCksbnVsbCE9dGhpcy5fdGltZW91dCYmKGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSx0aGlzLl90aW1lb3V0PW51bGwpLHRoaXMucXVldWUubGVuZ3RoPjAmJlwibnVtYmVyXCI9PXR5cGVvZiB0aGlzLmRlbGF5JiYodGhpcy5fdGltZW91dD1iZCgoZnVuY3Rpb24oKXt0LmZsdXNoKCl9KSx0aGlzLmRlbGF5KSl9fSx7a2V5OlwiZmx1c2hcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGU7SGgodD13cChlPXRoaXMuX3F1ZXVlKS5jYWxsKGUsMCkpLmNhbGwodCwoZnVuY3Rpb24odCl7dC5mbi5hcHBseSh0LmNvbnRleHR8fHQuZm4sdC5hcmdzfHxbXSl9KSl9fV0sW3trZXk6XCJleHRlbmRcIix2YWx1ZTpmdW5jdGlvbihlLHIpe3ZhciBuPW5ldyB0KHIpO2lmKHZvaWQgMCE9PWUuZmx1c2gpdGhyb3cgbmV3IEVycm9yKFwiVGFyZ2V0IG9iamVjdCBhbHJlYWR5IGhhcyBhIHByb3BlcnR5IGZsdXNoXCIpO2UuZmx1c2g9ZnVuY3Rpb24oKXtuLmZsdXNoKCl9O3ZhciBpPVt7bmFtZTpcImZsdXNoXCIsb3JpZ2luYWw6dm9pZCAwfV07aWYociYmci5yZXBsYWNlKWZvcih2YXIgbz0wO288ci5yZXBsYWNlLmxlbmd0aDtvKyspe3ZhciBhPXIucmVwbGFjZVtvXTtpLnB1c2goe25hbWU6YSxvcmlnaW5hbDplW2FdfSksbi5yZXBsYWNlKGUsYSl9cmV0dXJuIG4uX2V4dGVuZGVkPXtvYmplY3Q6ZSxtZXRob2RzOml9LG59fV0pLHR9KCksWF89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7ZSh0aGlzLHQpLENyKHRoaXMsXCJfc3Vic2NyaWJlcnNcIix7XCIqXCI6W10sYWRkOltdLHJlbW92ZTpbXSx1cGRhdGU6W119KSxDcih0aGlzLFwic3Vic2NyaWJlXCIsdC5wcm90b3R5cGUub24pLENyKHRoaXMsXCJ1bnN1YnNjcmliZVwiLHQucHJvdG90eXBlLm9mZil9cmV0dXJuIExyKHQsW3trZXk6XCJfdHJpZ2dlclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbixpO2lmKFwiKlwiPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdHJpZ2dlciBldmVudCAqXCIpO0hoKG49U2goaT1bXSkuY2FsbChpLHdoKHRoaXMuX3N1YnNjcmliZXJzW3RdKSx3aCh0aGlzLl9zdWJzY3JpYmVyc1tcIipcIl0pKSkuY2FsbChuLChmdW5jdGlvbihuKXtuKHQsZSxudWxsIT1yP3I6bnVsbCl9KSl9fSx7a2V5Olwib25cIix2YWx1ZTpmdW5jdGlvbih0LGUpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGUmJnRoaXMuX3N1YnNjcmliZXJzW3RdLnB1c2goZSl9fSx7a2V5Olwib2ZmXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgcjt0aGlzLl9zdWJzY3JpYmVyc1t0XT1qaShyPXRoaXMuX3N1YnNjcmliZXJzW3RdKS5jYWxsKHIsKGZ1bmN0aW9uKHQpe3JldHVybiB0IT09ZX0pKX19XSksdH0oKTt0YihcIlNldFwiLChmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdCh0aGlzLGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzBdOnZvaWQgMCl9fSksbWIpO3ZhciBVXyxXXz1CLlNldCxWXz13cztmdW5jdGlvbiBIXyh0LGUpe3ZhciByPXZvaWQgMCE9PU9oJiZpYyh0KXx8dFtcIkBAaXRlcmF0b3JcIl07aWYoIXIpe2lmKFBoKHQpfHwocj1mdW5jdGlvbih0LGUpe3ZhciByO2lmKCF0KXJldHVybjtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gJF8odCxlKTt2YXIgbj1BaChyPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkuY2FsbChyLDgsLTEpO1wiT2JqZWN0XCI9PT1uJiZ0LmNvbnN0cnVjdG9yJiYobj10LmNvbnN0cnVjdG9yLm5hbWUpO2lmKFwiTWFwXCI9PT1ufHxcIlNldFwiPT09bilyZXR1cm4gcXModCk7aWYoXCJBcmd1bWVudHNcIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKXJldHVybiAkXyh0LGUpfSh0KSl8fGUmJnQmJlwibnVtYmVyXCI9PXR5cGVvZiB0Lmxlbmd0aCl7ciYmKHQ9cik7dmFyIG49MCxpPWZ1bmN0aW9uKCl7fTtyZXR1cm57czppLG46ZnVuY3Rpb24oKXtyZXR1cm4gbj49dC5sZW5ndGg/e2RvbmU6ITB9Ontkb25lOiExLHZhbHVlOnRbbisrXX19LGU6ZnVuY3Rpb24odCl7dGhyb3cgdH0sZjppfX10aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9dmFyIG8sYT0hMCx1PSExO3JldHVybntzOmZ1bmN0aW9uKCl7cj1yLmNhbGwodCl9LG46ZnVuY3Rpb24oKXt2YXIgdD1yLm5leHQoKTtyZXR1cm4gYT10LmRvbmUsdH0sZTpmdW5jdGlvbih0KXt1PSEwLG89dH0sZjpmdW5jdGlvbigpe3RyeXthfHxudWxsPT1yLnJldHVybnx8ci5yZXR1cm4oKX1maW5hbGx5e2lmKHUpdGhyb3cgb319fX1mdW5jdGlvbiAkXyh0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgcj0wLG49bmV3IEFycmF5KGUpO3I8ZTtyKyspbltyXT10W3JdO3JldHVybiBufVVfPXhfO3ZhciBCXz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQocil7ZSh0aGlzLHQpLENyKHRoaXMsXCJfcGFpcnNcIix2b2lkIDApLHRoaXMuX3BhaXJzPXJ9cmV0dXJuIExyKHQsW3trZXk6VV8sdmFsdWU6S2cubWFyaygoZnVuY3Rpb24gdCgpe3ZhciBlLHIsbixpLG87cmV0dXJuIEtnLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOmU9SF8odGhpcy5fcGFpcnMpLHQucHJldj0xLGUucygpO2Nhc2UgMzppZigocj1lLm4oKSkuZG9uZSl7dC5uZXh0PTk7YnJlYWt9cmV0dXJuIG49Z2goci52YWx1ZSwyKSxpPW5bMF0sbz1uWzFdLHQubmV4dD03LFtpLG9dO2Nhc2UgNzp0Lm5leHQ9MzticmVhaztjYXNlIDk6dC5uZXh0PTE0O2JyZWFrO2Nhc2UgMTE6dC5wcmV2PTExLHQudDA9dC5jYXRjaCgxKSxlLmUodC50MCk7Y2FzZSAxNDpyZXR1cm4gdC5wcmV2PTE0LGUuZigpLHQuZmluaXNoKDE0KTtjYXNlIDE3OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMsW1sxLDExLDE0LDE3XV0pfSkpfSx7a2V5OlwiZW50cmllc1wiLHZhbHVlOktnLm1hcmsoKGZ1bmN0aW9uIHQoKXt2YXIgZSxyLG4saSxvO3JldHVybiBLZy53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDplPUhfKHRoaXMuX3BhaXJzKSx0LnByZXY9MSxlLnMoKTtjYXNlIDM6aWYoKHI9ZS5uKCkpLmRvbmUpe3QubmV4dD05O2JyZWFrfXJldHVybiBuPWdoKHIudmFsdWUsMiksaT1uWzBdLG89blsxXSx0Lm5leHQ9NyxbaSxvXTtjYXNlIDc6dC5uZXh0PTM7YnJlYWs7Y2FzZSA5OnQubmV4dD0xNDticmVhaztjYXNlIDExOnQucHJldj0xMSx0LnQwPXQuY2F0Y2goMSksZS5lKHQudDApO2Nhc2UgMTQ6cmV0dXJuIHQucHJldj0xNCxlLmYoKSx0LmZpbmlzaCgxNCk7Y2FzZSAxNzpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzLFtbMSwxMSwxNCwxN11dKX0pKX0se2tleTpcImtleXNcIix2YWx1ZTpLZy5tYXJrKChmdW5jdGlvbiB0KCl7dmFyIGUscixuLGk7cmV0dXJuIEtnLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOmU9SF8odGhpcy5fcGFpcnMpLHQucHJldj0xLGUucygpO2Nhc2UgMzppZigocj1lLm4oKSkuZG9uZSl7dC5uZXh0PTk7YnJlYWt9cmV0dXJuIG49Z2goci52YWx1ZSwxKSxpPW5bMF0sdC5uZXh0PTcsaTtjYXNlIDc6dC5uZXh0PTM7YnJlYWs7Y2FzZSA5OnQubmV4dD0xNDticmVhaztjYXNlIDExOnQucHJldj0xMSx0LnQwPXQuY2F0Y2goMSksZS5lKHQudDApO2Nhc2UgMTQ6cmV0dXJuIHQucHJldj0xNCxlLmYoKSx0LmZpbmlzaCgxNCk7Y2FzZSAxNzpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzLFtbMSwxMSwxNCwxN11dKX0pKX0se2tleTpcInZhbHVlc1wiLHZhbHVlOktnLm1hcmsoKGZ1bmN0aW9uIHQoKXt2YXIgZSxyLG4saTtyZXR1cm4gS2cud3JhcCgoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6ZT1IXyh0aGlzLl9wYWlycyksdC5wcmV2PTEsZS5zKCk7Y2FzZSAzOmlmKChyPWUubigpKS5kb25lKXt0Lm5leHQ9OTticmVha31yZXR1cm4gbj1naChyLnZhbHVlLDIpLGk9blsxXSx0Lm5leHQ9NyxpO2Nhc2UgNzp0Lm5leHQ9MzticmVhaztjYXNlIDk6dC5uZXh0PTE0O2JyZWFrO2Nhc2UgMTE6dC5wcmV2PTExLHQudDA9dC5jYXRjaCgxKSxlLmUodC50MCk7Y2FzZSAxNDpyZXR1cm4gdC5wcmV2PTE0LGUuZigpLHQuZmluaXNoKDE0KTtjYXNlIDE3OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMsW1sxLDExLDE0LDE3XV0pfSkpfSx7a2V5OlwidG9JZEFycmF5XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gUmkodD13aCh0aGlzLl9wYWlycykpLmNhbGwodCwoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19KSl9fSx7a2V5OlwidG9JdGVtQXJyYXlcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0O3JldHVybiBSaSh0PXdoKHRoaXMuX3BhaXJzKSkuY2FsbCh0LChmdW5jdGlvbih0KXtyZXR1cm4gdFsxXX0pKX19LHtrZXk6XCJ0b0VudHJ5QXJyYXlcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB3aCh0aGlzLl9wYWlycyl9fSx7a2V5OlwidG9PYmplY3RNYXBcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGU9WXYobnVsbCkscj1IXyh0aGlzLl9wYWlycyk7dHJ5e2ZvcihyLnMoKTshKHQ9ci5uKCkpLmRvbmU7KXt2YXIgbj1naCh0LnZhbHVlLDIpLGk9blswXSxvPW5bMV07ZVtpXT1vfX1jYXRjaCh0KXtyLmUodCl9ZmluYWxseXtyLmYoKX1yZXR1cm4gZX19LHtrZXk6XCJ0b01hcFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBiYih0aGlzLl9wYWlycyl9fSx7a2V5OlwidG9JZFNldFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBXXyh0aGlzLnRvSWRBcnJheSgpKX19LHtrZXk6XCJ0b0l0ZW1TZXRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBuZXcgV18odGhpcy50b0l0ZW1BcnJheSgpKX19LHtrZXk6XCJjYWNoZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB0KHdoKHRoaXMuX3BhaXJzKSl9fSx7a2V5OlwiZGlzdGluY3RcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZSxyPW5ldyBXXyxuPUhfKHRoaXMuX3BhaXJzKTt0cnl7Zm9yKG4ucygpOyEoZT1uLm4oKSkuZG9uZTspe3ZhciBpPWdoKGUudmFsdWUsMiksbz1pWzBdLGE9aVsxXTtyLmFkZCh0KGEsbykpfX1jYXRjaCh0KXtuLmUodCl9ZmluYWxseXtuLmYoKX1yZXR1cm4gcn19LHtrZXk6XCJmaWx0ZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgcj10aGlzLl9wYWlycztyZXR1cm4gbmV3IHQoQ3Ioe30seF8sS2cubWFyaygoZnVuY3Rpb24gdCgpe3ZhciBuLGksbyxhLHU7cmV0dXJuIEtnLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOm49SF8ociksdC5wcmV2PTEsbi5zKCk7Y2FzZSAzOmlmKChpPW4ubigpKS5kb25lKXt0Lm5leHQ9MTA7YnJlYWt9aWYobz1naChpLnZhbHVlLDIpLGE9b1swXSx1PW9bMV0sIWUodSxhKSl7dC5uZXh0PTg7YnJlYWt9cmV0dXJuIHQubmV4dD04LFthLHVdO2Nhc2UgODp0Lm5leHQ9MzticmVhaztjYXNlIDEwOnQubmV4dD0xNTticmVhaztjYXNlIDEyOnQucHJldj0xMix0LnQwPXQuY2F0Y2goMSksbi5lKHQudDApO2Nhc2UgMTU6cmV0dXJuIHQucHJldj0xNSxuLmYoKSx0LmZpbmlzaCgxNSk7Y2FzZSAxODpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCxudWxsLFtbMSwxMiwxNSwxOF1dKX0pKSkpfX0se2tleTpcImZvckVhY2hcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZSxyPUhfKHRoaXMuX3BhaXJzKTt0cnl7Zm9yKHIucygpOyEoZT1yLm4oKSkuZG9uZTspe3ZhciBuPWdoKGUudmFsdWUsMiksaT1uWzBdO3QoblsxXSxpKX19Y2F0Y2godCl7ci5lKHQpfWZpbmFsbHl7ci5mKCl9fX0se2tleTpcIm1hcFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciByPXRoaXMuX3BhaXJzO3JldHVybiBuZXcgdChDcih7fSx4XyxLZy5tYXJrKChmdW5jdGlvbiB0KCl7dmFyIG4saSxvLGEsdTtyZXR1cm4gS2cud3JhcCgoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6bj1IXyhyKSx0LnByZXY9MSxuLnMoKTtjYXNlIDM6aWYoKGk9bi5uKCkpLmRvbmUpe3QubmV4dD05O2JyZWFrfXJldHVybiBvPWdoKGkudmFsdWUsMiksYT1vWzBdLHU9b1sxXSx0Lm5leHQ9NyxbYSxlKHUsYSldO2Nhc2UgNzp0Lm5leHQ9MzticmVhaztjYXNlIDk6dC5uZXh0PTE0O2JyZWFrO2Nhc2UgMTE6dC5wcmV2PTExLHQudDA9dC5jYXRjaCgxKSxuLmUodC50MCk7Y2FzZSAxNDpyZXR1cm4gdC5wcmV2PTE0LG4uZigpLHQuZmluaXNoKDE0KTtjYXNlIDE3OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LG51bGwsW1sxLDExLDE0LDE3XV0pfSkpKSl9fSx7a2V5OlwibWF4XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9Vl8odGhpcy5fcGFpcnMpLHI9ZS5uZXh0KCk7aWYoci5kb25lKXJldHVybiBudWxsO2Zvcih2YXIgbj1yLnZhbHVlWzFdLGk9dChyLnZhbHVlWzFdLHIudmFsdWVbMF0pOyEocj1lLm5leHQoKSkuZG9uZTspe3ZhciBvPWdoKHIudmFsdWUsMiksYT1vWzBdLHU9b1sxXSxzPXQodSxhKTtzPmkmJihpPXMsbj11KX1yZXR1cm4gbn19LHtrZXk6XCJtaW5cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1WXyh0aGlzLl9wYWlycykscj1lLm5leHQoKTtpZihyLmRvbmUpcmV0dXJuIG51bGw7Zm9yKHZhciBuPXIudmFsdWVbMV0saT10KHIudmFsdWVbMV0sci52YWx1ZVswXSk7IShyPWUubmV4dCgpKS5kb25lOyl7dmFyIG89Z2goci52YWx1ZSwyKSxhPW9bMF0sdT1vWzFdLHM9dCh1LGEpO3M8aSYmKGk9cyxuPXUpfXJldHVybiBufX0se2tleTpcInJlZHVjZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIHIsbj1IXyh0aGlzLl9wYWlycyk7dHJ5e2ZvcihuLnMoKTshKHI9bi5uKCkpLmRvbmU7KXt2YXIgaT1naChyLnZhbHVlLDIpLG89aVswXTtlPXQoZSxpWzFdLG8pfX1jYXRjaCh0KXtuLmUodCl9ZmluYWxseXtuLmYoKX1yZXR1cm4gZX19LHtrZXk6XCJzb3J0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHI9dGhpcztyZXR1cm4gbmV3IHQoQ3Ioe30seF8sKGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIFZfKHlfKHQ9d2goci5fcGFpcnMpKS5jYWxsKHQsKGZ1bmN0aW9uKHQscil7dmFyIG49Z2godCwyKSxpPW5bMF0sbz1uWzFdLGE9Z2gociwyKSx1PWFbMF0scz1hWzFdO3JldHVybiBlKG8scyxpLHUpfSkpKX0pKSl9fV0pLHR9KCk7ZnVuY3Rpb24gSl8odCxlKXt2YXIgcj1MaCh0KTtpZigkZil7dmFyIG49JGYodCk7ZSYmKG49amkobikuY2FsbChuLChmdW5jdGlvbihlKXtyZXR1cm4gaWwodCxlKS5lbnVtZXJhYmxlfSkpKSxyLnB1c2guYXBwbHkocixuKX1yZXR1cm4gcn1mdW5jdGlvbiBLXyh0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgcixuLGk9bnVsbCE9YXJndW1lbnRzW2VdP2FyZ3VtZW50c1tlXTp7fTtlJTI/SGgocj1KXyhPYmplY3QoaSksITApKS5jYWxsKHIsKGZ1bmN0aW9uKGUpe0NyKHQsZSxpW2VdKX0pKTpkbD9PbCh0LGRsKGkpKTpIaChuPUpfKE9iamVjdChpKSkpLmNhbGwobiwoZnVuY3Rpb24oZSl7RWwodCxlLGlsKGksZSkpfSkpfXJldHVybiB0fWZ1bmN0aW9uIFFfKHQsZSl7dmFyIHI9dm9pZCAwIT09T2gmJmljKHQpfHx0W1wiQEBpdGVyYXRvclwiXTtpZighcil7aWYoUGgodCl8fChyPWZ1bmN0aW9uKHQsZSl7dmFyIHI7aWYoIXQpcmV0dXJuO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXJldHVybiBaXyh0LGUpO3ZhciBuPUFoKHI9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKS5jYWxsKHIsOCwtMSk7XCJPYmplY3RcIj09PW4mJnQuY29uc3RydWN0b3ImJihuPXQuY29uc3RydWN0b3IubmFtZSk7aWYoXCJNYXBcIj09PW58fFwiU2V0XCI9PT1uKXJldHVybiBxcyh0KTtpZihcIkFyZ3VtZW50c1wiPT09bnx8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpcmV0dXJuIFpfKHQsZSl9KHQpKXx8ZSYmdCYmXCJudW1iZXJcIj09dHlwZW9mIHQubGVuZ3RoKXtyJiYodD1yKTt2YXIgbj0wLGk9ZnVuY3Rpb24oKXt9O3JldHVybntzOmksbjpmdW5jdGlvbigpe3JldHVybiBuPj10Lmxlbmd0aD97ZG9uZTohMH06e2RvbmU6ITEsdmFsdWU6dFtuKytdfX0sZTpmdW5jdGlvbih0KXt0aHJvdyB0fSxmOml9fXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX12YXIgbyxhPSEwLHU9ITE7cmV0dXJue3M6ZnVuY3Rpb24oKXtyPXIuY2FsbCh0KX0sbjpmdW5jdGlvbigpe3ZhciB0PXIubmV4dCgpO3JldHVybiBhPXQuZG9uZSx0fSxlOmZ1bmN0aW9uKHQpe3U9ITAsbz10fSxmOmZ1bmN0aW9uKCl7dHJ5e2F8fG51bGw9PXIucmV0dXJufHxyLnJldHVybigpfWZpbmFsbHl7aWYodSl0aHJvdyBvfX19fWZ1bmN0aW9uIFpfKHQsZSl7KG51bGw9PWV8fGU+dC5sZW5ndGgpJiYoZT10Lmxlbmd0aCk7Zm9yKHZhciByPTAsbj1uZXcgQXJyYXkoZSk7cjxlO3IrKyluW3JdPXRbcl07cmV0dXJuIG59ZnVuY3Rpb24gdHcodCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IVlnKXJldHVybiExO2lmKFlnLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoWWcoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgcixuPUJnKHQpO2lmKGUpe3ZhciBpPUJnKHRoaXMpLmNvbnN0cnVjdG9yO3I9WWcobixhcmd1bWVudHMsaSl9ZWxzZSByPW4uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBIZyh0aGlzLHIpfX12YXIgZXc9ZnVuY3Rpb24odCl7Vmcobix0KTt2YXIgcj10dyhuKTtmdW5jdGlvbiBuKHQsaSl7dmFyIG87cmV0dXJuIGUodGhpcyxuKSxDcihHZyhvPXIuY2FsbCh0aGlzKSksXCJmbHVzaFwiLHZvaWQgMCksQ3IoR2cobyksXCJsZW5ndGhcIix2b2lkIDApLENyKEdnKG8pLFwiX29wdGlvbnNcIix2b2lkIDApLENyKEdnKG8pLFwiX2RhdGFcIix2b2lkIDApLENyKEdnKG8pLFwiX2lkUHJvcFwiLHZvaWQgMCksQ3IoR2cobyksXCJfcXVldWVcIixudWxsKSx0JiYhUGgodCkmJihpPXQsdD1bXSksby5fb3B0aW9ucz1pfHx7fSxvLl9kYXRhPW5ldyBiYixvLmxlbmd0aD0wLG8uX2lkUHJvcD1vLl9vcHRpb25zLmZpZWxkSWR8fFwiaWRcIix0JiZ0Lmxlbmd0aCYmby5hZGQodCksby5zZXRPcHRpb25zKGkpLG99cmV0dXJuIExyKG4sW3trZXk6XCJpZFByb3BcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faWRQcm9wfX0se2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt0JiZ2b2lkIDAhPT10LnF1ZXVlJiYoITE9PT10LnF1ZXVlP3RoaXMuX3F1ZXVlJiYodGhpcy5fcXVldWUuZGVzdHJveSgpLHRoaXMuX3F1ZXVlPW51bGwpOih0aGlzLl9xdWV1ZXx8KHRoaXMuX3F1ZXVlPUdfLmV4dGVuZCh0aGlzLHtyZXBsYWNlOltcImFkZFwiLFwidXBkYXRlXCIsXCJyZW1vdmVcIl19KSksdC5xdWV1ZSYmXCJvYmplY3RcIj09PV9oKHQucXVldWUpJiZ0aGlzLl9xdWV1ZS5zZXRPcHRpb25zKHQucXVldWUpKSl9fSx7a2V5OlwiYWRkXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgcixuPXRoaXMsaT1bXTtpZihQaCh0KSl7dmFyIG89UmkodCkuY2FsbCh0LChmdW5jdGlvbih0KXtyZXR1cm4gdFtuLl9pZFByb3BdfSkpO2lmKHhiKG8pLmNhbGwobywoZnVuY3Rpb24odCl7cmV0dXJuIG4uX2RhdGEuaGFzKHQpfSkpKXRocm93IG5ldyBFcnJvcihcIkEgZHVwbGljYXRlIGlkIHdhcyBmb3VuZCBpbiB0aGUgcGFyYW1ldGVyIGFycmF5LlwiKTtmb3IodmFyIGE9MCx1PXQubGVuZ3RoO2E8dTthKyspcj10aGlzLl9hZGRJdGVtKHRbYV0pLGkucHVzaChyKX1lbHNle2lmKCF0fHxcIm9iamVjdFwiIT09X2godCkpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhVHlwZVwiKTtyPXRoaXMuX2FkZEl0ZW0odCksaS5wdXNoKHIpfXJldHVybiBpLmxlbmd0aCYmdGhpcy5fdHJpZ2dlcihcImFkZFwiLHtpdGVtczppfSxlKSxpfX0se2tleTpcInVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcyxuPVtdLGk9W10sbz1bXSxhPVtdLHU9dGhpcy5faWRQcm9wLHM9ZnVuY3Rpb24odCl7dmFyIGU9dFt1XTtpZihudWxsIT1lJiZyLl9kYXRhLmhhcyhlKSl7dmFyIHM9dCxjPU1wKHt9LHIuX2RhdGEuZ2V0KGUpKSxmPXIuX3VwZGF0ZUl0ZW0ocyk7aS5wdXNoKGYpLGEucHVzaChzKSxvLnB1c2goYyl9ZWxzZXt2YXIgbD1yLl9hZGRJdGVtKHQpO24ucHVzaChsKX19O2lmKFBoKHQpKWZvcih2YXIgYz0wLGY9dC5sZW5ndGg7YzxmO2MrKyl0W2NdJiZcIm9iamVjdFwiPT09X2godFtjXSk/cyh0W2NdKTpjb25zb2xlLndhcm4oXCJJZ25vcmluZyBpbnB1dCBpdGVtLCB3aGljaCBpcyBub3QgYW4gb2JqZWN0IGF0IGluZGV4IFwiK2MpO2Vsc2V7aWYoIXR8fFwib2JqZWN0XCIhPT1faCh0KSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFUeXBlXCIpO3ModCl9aWYobi5sZW5ndGgmJnRoaXMuX3RyaWdnZXIoXCJhZGRcIix7aXRlbXM6bn0sZSksaS5sZW5ndGgpe3ZhciBsPXtpdGVtczppLG9sZERhdGE6byxkYXRhOmF9O3RoaXMuX3RyaWdnZXIoXCJ1cGRhdGVcIixsLGUpfXJldHVybiBTaChuKS5jYWxsKG4saSl9fSx7a2V5OlwidXBkYXRlT25seVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIHIsbj10aGlzO1BoKHQpfHwodD1bdF0pO3ZhciBpPVJpKHI9UmkodCkuY2FsbCh0LChmdW5jdGlvbih0KXt2YXIgZT1uLl9kYXRhLmdldCh0W24uX2lkUHJvcF0pO2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwiVXBkYXRpbmcgbm9uLWV4aXN0ZW50IGl0ZW1zIGlzIG5vdCBhbGxvd2VkLlwiKTtyZXR1cm57b2xkRGF0YTplLHVwZGF0ZTp0fX0pKSkuY2FsbChyLChmdW5jdGlvbih0KXt2YXIgZT10Lm9sZERhdGEscj10LnVwZGF0ZSxpPWVbbi5faWRQcm9wXSxvPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxyPWFyZ3VtZW50cy5sZW5ndGgsbj1uZXcgQXJyYXkocj4xP3ItMTowKSxpPTE7aTxyO2krKyluW2ktMV09YXJndW1lbnRzW2ldO3JldHVybiBtZy5hcHBseSh2b2lkIDAsU2goZT1be30sdF0pLmNhbGwoZSxuKSl9KGUscik7cmV0dXJuIG4uX2RhdGEuc2V0KGksbykse2lkOmksb2xkRGF0YTplLHVwZGF0ZWREYXRhOm99fSkpO2lmKGkubGVuZ3RoKXt2YXIgbz17aXRlbXM6UmkoaSkuY2FsbChpLChmdW5jdGlvbih0KXtyZXR1cm4gdC5pZH0pKSxvbGREYXRhOlJpKGkpLmNhbGwoaSwoZnVuY3Rpb24odCl7cmV0dXJuIHQub2xkRGF0YX0pKSxkYXRhOlJpKGkpLmNhbGwoaSwoZnVuY3Rpb24odCl7cmV0dXJuIHQudXBkYXRlZERhdGF9KSl9O3JldHVybiB0aGlzLl90cmlnZ2VyKFwidXBkYXRlXCIsbyxlKSxvLml0ZW1zfXJldHVybltdfX0se2tleTpcImdldFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIHI9dm9pZCAwLG49dm9pZCAwLGk9dm9pZCAwO1lfKHQpPyhyPXQsaT1lKTpQaCh0KT8obj10LGk9ZSk6aT10O3ZhciBvLGE9aSYmXCJPYmplY3RcIj09PWkucmV0dXJuVHlwZT9cIk9iamVjdFwiOlwiQXJyYXlcIix1PWkmJmppKGkpLHM9W10sYz12b2lkIDAsZj12b2lkIDAsbD12b2lkIDA7aWYobnVsbCE9cikoYz10aGlzLl9kYXRhLmdldChyKSkmJnUmJiF1KGMpJiYoYz12b2lkIDApO2Vsc2UgaWYobnVsbCE9bilmb3IodmFyIGg9MCxwPW4ubGVuZ3RoO2g8cDtoKyspbnVsbD09KGM9dGhpcy5fZGF0YS5nZXQobltoXSkpfHx1JiYhdShjKXx8cy5wdXNoKGMpO2Vsc2UgZm9yKHZhciB2LGQ9MCx5PShmPXdoKExiKHY9dGhpcy5fZGF0YSkuY2FsbCh2KSkpLmxlbmd0aDtkPHk7ZCsrKWw9ZltkXSxudWxsPT0oYz10aGlzLl9kYXRhLmdldChsKSl8fHUmJiF1KGMpfHxzLnB1c2goYyk7aWYoaSYmaS5vcmRlciYmbnVsbD09ciYmdGhpcy5fc29ydChzLGkub3JkZXIpLGkmJmkuZmllbGRzKXt2YXIgZz1pLmZpZWxkcztpZihudWxsIT1yJiZudWxsIT1jKWM9dGhpcy5fZmlsdGVyRmllbGRzKGMsZyk7ZWxzZSBmb3IodmFyIG09MCxiPXMubGVuZ3RoO208YjttKyspc1ttXT10aGlzLl9maWx0ZXJGaWVsZHMoc1ttXSxnKX1pZihcIk9iamVjdFwiPT1hKXtmb3IodmFyIF89e30sdz0wLE89cy5sZW5ndGg7dzxPO3crKyl7dmFyIEU9c1t3XTtfW0VbdGhpcy5faWRQcm9wXV09RX1yZXR1cm4gX31yZXR1cm4gbnVsbCE9cj9udWxsIT09KG89YykmJnZvaWQgMCE9PW8/bzpudWxsOnN9fSx7a2V5OlwiZ2V0SWRzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fZGF0YSxyPXQmJmppKHQpLG49dCYmdC5vcmRlcixpPXdoKExiKGUpLmNhbGwoZSkpLG89W107aWYocilpZihuKXtmb3IodmFyIGE9W10sdT0wLHM9aS5sZW5ndGg7dTxzO3UrKyl7dmFyIGM9aVt1XSxmPXRoaXMuX2RhdGEuZ2V0KGMpO251bGwhPWYmJnIoZikmJmEucHVzaChmKX10aGlzLl9zb3J0KGEsbik7Zm9yKHZhciBsPTAsaD1hLmxlbmd0aDtsPGg7bCsrKW8ucHVzaChhW2xdW3RoaXMuX2lkUHJvcF0pfWVsc2UgZm9yKHZhciBwPTAsdj1pLmxlbmd0aDtwPHY7cCsrKXt2YXIgZD1pW3BdLHk9dGhpcy5fZGF0YS5nZXQoZCk7bnVsbCE9eSYmcih5KSYmby5wdXNoKHlbdGhpcy5faWRQcm9wXSl9ZWxzZSBpZihuKXtmb3IodmFyIGc9W10sbT0wLGI9aS5sZW5ndGg7bTxiO20rKyl7dmFyIF89aVttXTtnLnB1c2goZS5nZXQoXykpfXRoaXMuX3NvcnQoZyxuKTtmb3IodmFyIHc9MCxPPWcubGVuZ3RoO3c8Tzt3Kyspby5wdXNoKGdbd11bdGhpcy5faWRQcm9wXSl9ZWxzZSBmb3IodmFyIEU9MCxUPWkubGVuZ3RoO0U8VDtFKyspe3ZhciB4PWlbRV0saz1lLmdldCh4KTtudWxsIT1rJiZvLnB1c2goa1t0aGlzLl9pZFByb3BdKX1yZXR1cm4gb319LHtrZXk6XCJnZXREYXRhU2V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc319LHtrZXk6XCJmb3JFYWNoXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgcj1lJiZqaShlKSxuPXRoaXMuX2RhdGEsaT13aChMYihuKS5jYWxsKG4pKTtpZihlJiZlLm9yZGVyKWZvcih2YXIgbz10aGlzLmdldChlKSxhPTAsdT1vLmxlbmd0aDthPHU7YSsrKXt2YXIgcz1vW2FdO3QocyxzW3RoaXMuX2lkUHJvcF0pfWVsc2UgZm9yKHZhciBjPTAsZj1pLmxlbmd0aDtjPGY7YysrKXt2YXIgbD1pW2NdLGg9dGhpcy5fZGF0YS5nZXQobCk7bnVsbD09aHx8ciYmIXIoaCl8fHQoaCxsKX19fSx7a2V5OlwibWFwXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9ZSYmamkoZSksbj1bXSxpPXRoaXMuX2RhdGEsbz13aChMYihpKS5jYWxsKGkpKSxhPTAsdT1vLmxlbmd0aDthPHU7YSsrKXt2YXIgcz1vW2FdLGM9dGhpcy5fZGF0YS5nZXQocyk7bnVsbD09Y3x8ciYmIXIoYyl8fG4ucHVzaCh0KGMscykpfXJldHVybiBlJiZlLm9yZGVyJiZ0aGlzLl9zb3J0KG4sZS5vcmRlciksbn19LHtrZXk6XCJfZmlsdGVyRmllbGRzXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgcjtyZXR1cm4gdD9TbihyPVBoKGUpP2U6TGgoZSkpLmNhbGwociwoZnVuY3Rpb24oZSxyKXtyZXR1cm4gZVtyXT10W3JdLGV9KSx7fSk6dH19LHtrZXk6XCJfc29ydFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe3ZhciByPWU7eV8odCkuY2FsbCh0LChmdW5jdGlvbih0LGUpe3ZhciBuPXRbcl0saT1lW3JdO3JldHVybiBuPmk/MTpuPGk/LTE6MH0pKX1lbHNle2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9yZGVyIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1wiKTt5Xyh0KS5jYWxsKHQsZSl9fX0se2tleTpcInJlbW92ZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPVtdLG49W10saT1QaCh0KT90Olt0XSxvPTAsYT1pLmxlbmd0aDtvPGE7bysrKXt2YXIgdT10aGlzLl9yZW1vdmUoaVtvXSk7aWYodSl7dmFyIHM9dVt0aGlzLl9pZFByb3BdO251bGwhPXMmJihyLnB1c2gocyksbi5wdXNoKHUpKX19cmV0dXJuIHIubGVuZ3RoJiZ0aGlzLl90cmlnZ2VyKFwicmVtb3ZlXCIse2l0ZW1zOnIsb2xkRGF0YTpufSxlKSxyfX0se2tleTpcIl9yZW1vdmVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZTtpZihZXyh0KT9lPXQ6dCYmXCJvYmplY3RcIj09PV9oKHQpJiYoZT10W3RoaXMuX2lkUHJvcF0pLG51bGwhPWUmJnRoaXMuX2RhdGEuaGFzKGUpKXt2YXIgcj10aGlzLl9kYXRhLmdldChlKXx8bnVsbDtyZXR1cm4gdGhpcy5fZGF0YS5kZWxldGUoZSksLS10aGlzLmxlbmd0aCxyfXJldHVybiBudWxsfX0se2tleTpcImNsZWFyXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlLHI9d2goTGIoZT10aGlzLl9kYXRhKS5jYWxsKGUpKSxuPVtdLGk9MCxvPXIubGVuZ3RoO2k8bztpKyspbi5wdXNoKHRoaXMuX2RhdGEuZ2V0KHJbaV0pKTtyZXR1cm4gdGhpcy5fZGF0YS5jbGVhcigpLHRoaXMubGVuZ3RoPTAsdGhpcy5fdHJpZ2dlcihcInJlbW92ZVwiLHtpdGVtczpyLG9sZERhdGE6bn0sdCkscn19LHtrZXk6XCJtYXhcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZSxyLG49bnVsbCxpPW51bGwsbz1RXyhUXyhlPXRoaXMuX2RhdGEpLmNhbGwoZSkpO3RyeXtmb3Ioby5zKCk7IShyPW8ubigpKS5kb25lOyl7dmFyIGE9ci52YWx1ZSx1PWFbdF07XCJudW1iZXJcIj09dHlwZW9mIHUmJihudWxsPT1pfHx1PmkpJiYobj1hLGk9dSl9fWNhdGNoKHQpe28uZSh0KX1maW5hbGx5e28uZigpfXJldHVybiBufHxudWxsfX0se2tleTpcIm1pblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlLHIsbj1udWxsLGk9bnVsbCxvPVFfKFRfKGU9dGhpcy5fZGF0YSkuY2FsbChlKSk7dHJ5e2ZvcihvLnMoKTshKHI9by5uKCkpLmRvbmU7KXt2YXIgYT1yLnZhbHVlLHU9YVt0XTtcIm51bWJlclwiPT10eXBlb2YgdSYmKG51bGw9PWl8fHU8aSkmJihuPWEsaT11KX19Y2F0Y2godCl7by5lKHQpfWZpbmFsbHl7by5mKCl9cmV0dXJuIG58fG51bGx9fSx7a2V5OlwiZGlzdGluY3RcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5fZGF0YSxyPXdoKExiKGUpLmNhbGwoZSkpLG49W10saT0wLG89MCxhPXIubGVuZ3RoO288YTtvKyspe2Zvcih2YXIgdT1yW29dLHM9ZS5nZXQodSlbdF0sYz0hMSxmPTA7ZjxpO2YrKylpZihuW2ZdPT1zKXtjPSEwO2JyZWFrfWN8fHZvaWQgMD09PXN8fChuW2ldPXMsaSsrKX1yZXR1cm4gbn19LHtrZXk6XCJfYWRkSXRlbVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGw9PXRbZV0mJih0W2VdPXFfKCkpLHR9KHQsdGhpcy5faWRQcm9wKSxyPWVbdGhpcy5faWRQcm9wXTtpZih0aGlzLl9kYXRhLmhhcyhyKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIGl0ZW06IGl0ZW0gd2l0aCBpZCBcIityK1wiIGFscmVhZHkgZXhpc3RzXCIpO3JldHVybiB0aGlzLl9kYXRhLnNldChyLGUpLCsrdGhpcy5sZW5ndGgscn19LHtrZXk6XCJfdXBkYXRlSXRlbVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRbdGhpcy5faWRQcm9wXTtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgaXRlbTogaXRlbSBoYXMgbm8gaWQgKGl0ZW06IFwiK3NkKHQpK1wiKVwiKTt2YXIgcj10aGlzLl9kYXRhLmdldChlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIGl0ZW06IG5vIGl0ZW0gd2l0aCBpZCBcIitlK1wiIGZvdW5kXCIpO3JldHVybiB0aGlzLl9kYXRhLnNldChlLEtfKEtfKHt9LHIpLHQpKSxlfX0se2tleTpcInN0cmVhbVwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHQpe3ZhciBlPXRoaXMuX2RhdGE7cmV0dXJuIG5ldyBCXyhDcih7fSx4XyxLZy5tYXJrKChmdW5jdGlvbiByKCl7dmFyIG4saSxvLGE7cmV0dXJuIEtnLndyYXAoKGZ1bmN0aW9uKHIpe2Zvcig7Oylzd2l0Y2goci5wcmV2PXIubmV4dCl7Y2FzZSAwOm49UV8odCksci5wcmV2PTEsbi5zKCk7Y2FzZSAzOmlmKChpPW4ubigpKS5kb25lKXtyLm5leHQ9MTE7YnJlYWt9aWYobz1pLnZhbHVlLG51bGw9PShhPWUuZ2V0KG8pKSl7ci5uZXh0PTk7YnJlYWt9cmV0dXJuIHIubmV4dD05LFtvLGFdO2Nhc2UgOTpyLm5leHQ9MzticmVhaztjYXNlIDExOnIubmV4dD0xNjticmVhaztjYXNlIDEzOnIucHJldj0xMyxyLnQwPXIuY2F0Y2goMSksbi5lKHIudDApO2Nhc2UgMTY6cmV0dXJuIHIucHJldj0xNixuLmYoKSxyLmZpbmlzaCgxNik7Y2FzZSAxOTpjYXNlXCJlbmRcIjpyZXR1cm4gci5zdG9wKCl9fSkscixudWxsLFtbMSwxMywxNiwxOV1dKX0pKSkpfXZhciByO3JldHVybiBuZXcgQl8oQ3Ioe30seF8sZW4ocj1MXyh0aGlzLl9kYXRhKSkuY2FsbChyLHRoaXMuX2RhdGEpKSl9fV0pLG59KFhfKTtmdW5jdGlvbiBydyh0LGUpe3ZhciByPXZvaWQgMCE9PU9oJiZpYyh0KXx8dFtcIkBAaXRlcmF0b3JcIl07aWYoIXIpe2lmKFBoKHQpfHwocj1mdW5jdGlvbih0LGUpe3ZhciByO2lmKCF0KXJldHVybjtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gbncodCxlKTt2YXIgbj1BaChyPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkuY2FsbChyLDgsLTEpO1wiT2JqZWN0XCI9PT1uJiZ0LmNvbnN0cnVjdG9yJiYobj10LmNvbnN0cnVjdG9yLm5hbWUpO2lmKFwiTWFwXCI9PT1ufHxcIlNldFwiPT09bilyZXR1cm4gcXModCk7aWYoXCJBcmd1bWVudHNcIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKXJldHVybiBudyh0LGUpfSh0KSl8fGUmJnQmJlwibnVtYmVyXCI9PXR5cGVvZiB0Lmxlbmd0aCl7ciYmKHQ9cik7dmFyIG49MCxpPWZ1bmN0aW9uKCl7fTtyZXR1cm57czppLG46ZnVuY3Rpb24oKXtyZXR1cm4gbj49dC5sZW5ndGg/e2RvbmU6ITB9Ontkb25lOiExLHZhbHVlOnRbbisrXX19LGU6ZnVuY3Rpb24odCl7dGhyb3cgdH0sZjppfX10aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9dmFyIG8sYT0hMCx1PSExO3JldHVybntzOmZ1bmN0aW9uKCl7cj1yLmNhbGwodCl9LG46ZnVuY3Rpb24oKXt2YXIgdD1yLm5leHQoKTtyZXR1cm4gYT10LmRvbmUsdH0sZTpmdW5jdGlvbih0KXt1PSEwLG89dH0sZjpmdW5jdGlvbigpe3RyeXthfHxudWxsPT1yLnJldHVybnx8ci5yZXR1cm4oKX1maW5hbGx5e2lmKHUpdGhyb3cgb319fX1mdW5jdGlvbiBudyh0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgcj0wLG49bmV3IEFycmF5KGUpO3I8ZTtyKyspbltyXT10W3JdO3JldHVybiBufWZ1bmN0aW9uIGl3KHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFZZylyZXR1cm4hMTtpZihZZy5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFlnKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHIsbj1CZyh0KTtpZihlKXt2YXIgaT1CZyh0aGlzKS5jb25zdHJ1Y3RvcjtyPVlnKG4sYXJndW1lbnRzLGkpfWVsc2Ugcj1uLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gSGcodGhpcyxyKX19dmFyIG93PWZ1bmN0aW9uKHQpe1ZnKG4sdCk7dmFyIHI9aXcobik7ZnVuY3Rpb24gbih0LGkpe3ZhciBvLGE7cmV0dXJuIGUodGhpcyxuKSxDcihHZyhhPXIuY2FsbCh0aGlzKSksXCJsZW5ndGhcIiwwKSxDcihHZyhhKSxcIl9saXN0ZW5lclwiLHZvaWQgMCksQ3IoR2coYSksXCJfZGF0YVwiLHZvaWQgMCksQ3IoR2coYSksXCJfaWRzXCIsbmV3IFdfKSxDcihHZyhhKSxcIl9vcHRpb25zXCIsdm9pZCAwKSxhLl9vcHRpb25zPWl8fHt9LGEuX2xpc3RlbmVyPWVuKG89YS5fb25FdmVudCkuY2FsbChvLEdnKGEpKSxhLnNldERhdGEodCksYX1yZXR1cm4gTHIobixbe2tleTpcImlkUHJvcFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldERhdGFTZXQoKS5pZFByb3B9fSx7a2V5Olwic2V0RGF0YVwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHRoaXMuX2RhdGEpe3RoaXMuX2RhdGEub2ZmJiZ0aGlzLl9kYXRhLm9mZihcIipcIix0aGlzLl9saXN0ZW5lcik7dmFyIGU9dGhpcy5fZGF0YS5nZXRJZHMoe2ZpbHRlcjpqaSh0aGlzLl9vcHRpb25zKX0pLHI9dGhpcy5fZGF0YS5nZXQoZSk7dGhpcy5faWRzLmNsZWFyKCksdGhpcy5sZW5ndGg9MCx0aGlzLl90cmlnZ2VyKFwicmVtb3ZlXCIse2l0ZW1zOmUsb2xkRGF0YTpyfSl9aWYobnVsbCE9dCl7dGhpcy5fZGF0YT10O2Zvcih2YXIgbj10aGlzLl9kYXRhLmdldElkcyh7ZmlsdGVyOmppKHRoaXMuX29wdGlvbnMpfSksaT0wLG89bi5sZW5ndGg7aTxvO2krKyl7dmFyIGE9bltpXTt0aGlzLl9pZHMuYWRkKGEpfXRoaXMubGVuZ3RoPW4ubGVuZ3RoLHRoaXMuX3RyaWdnZXIoXCJhZGRcIix7aXRlbXM6bn0pfWVsc2UgdGhpcy5fZGF0YT1uZXcgZXc7dGhpcy5fZGF0YS5vbiYmdGhpcy5fZGF0YS5vbihcIipcIix0aGlzLl9saXN0ZW5lcil9fSx7a2V5OlwicmVmcmVzaFwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuX2RhdGEuZ2V0SWRzKHtmaWx0ZXI6amkodGhpcy5fb3B0aW9ucyl9KSxlPXdoKHRoaXMuX2lkcykscj17fSxuPVtdLGk9W10sbz1bXSxhPTAsdT10Lmxlbmd0aDthPHU7YSsrKXt2YXIgcz10W2FdO3Jbc109ITAsdGhpcy5faWRzLmhhcyhzKXx8KG4ucHVzaChzKSx0aGlzLl9pZHMuYWRkKHMpKX1mb3IodmFyIGM9MCxmPWUubGVuZ3RoO2M8ZjtjKyspe3ZhciBsPWVbY10saD10aGlzLl9kYXRhLmdldChsKTtudWxsPT1oP2NvbnNvbGUuZXJyb3IoXCJJZiB5b3Ugc2VlIHRoaXMsIHJlcG9ydCBpdCBwbGVhc2UuXCIpOnJbbF18fChpLnB1c2gobCksby5wdXNoKGgpLHRoaXMuX2lkcy5kZWxldGUobCkpfXRoaXMubGVuZ3RoKz1uLmxlbmd0aC1pLmxlbmd0aCxuLmxlbmd0aCYmdGhpcy5fdHJpZ2dlcihcImFkZFwiLHtpdGVtczpufSksaS5sZW5ndGgmJnRoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIix7aXRlbXM6aSxvbGREYXRhOm99KX19LHtrZXk6XCJnZXRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKG51bGw9PXRoaXMuX2RhdGEpcmV0dXJuIG51bGw7dmFyIHIsbj1udWxsO1lfKHQpfHxQaCh0KT8obj10LHI9ZSk6cj10O3ZhciBpPU1wKHt9LHRoaXMuX29wdGlvbnMsciksbz1qaSh0aGlzLl9vcHRpb25zKSxhPXImJmppKHIpO3JldHVybiBvJiZhJiYoaS5maWx0ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIG8odCkmJmEodCl9KSxudWxsPT1uP3RoaXMuX2RhdGEuZ2V0KGkpOnRoaXMuX2RhdGEuZ2V0KG4saSl9fSx7a2V5OlwiZ2V0SWRzXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodGhpcy5fZGF0YS5sZW5ndGgpe3ZhciBlLHI9amkodGhpcy5fb3B0aW9ucyksbj1udWxsIT10P2ppKHQpOm51bGw7cmV0dXJuIGU9bj9yP2Z1bmN0aW9uKHQpe3JldHVybiByKHQpJiZuKHQpfTpuOnIsdGhpcy5fZGF0YS5nZXRJZHMoe2ZpbHRlcjplLG9yZGVyOnQmJnQub3JkZXJ9KX1yZXR1cm5bXX19LHtrZXk6XCJmb3JFYWNoXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZih0aGlzLl9kYXRhKXt2YXIgcixuLGk9amkodGhpcy5fb3B0aW9ucyksbz1lJiZqaShlKTtuPW8/aT9mdW5jdGlvbih0KXtyZXR1cm4gaSh0KSYmbyh0KX06bzppLEhoKHI9dGhpcy5fZGF0YSkuY2FsbChyLHQse2ZpbHRlcjpuLG9yZGVyOmUmJmUub3JkZXJ9KX19fSx7a2V5OlwibWFwXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZih0aGlzLl9kYXRhKXt2YXIgcixuLGk9amkodGhpcy5fb3B0aW9ucyksbz1lJiZqaShlKTtyZXR1cm4gbj1vP2k/ZnVuY3Rpb24odCl7cmV0dXJuIGkodCkmJm8odCl9Om86aSxSaShyPXRoaXMuX2RhdGEpLmNhbGwocix0LHtmaWx0ZXI6bixvcmRlcjplJiZlLm9yZGVyfSl9cmV0dXJuW119fSx7a2V5OlwiZ2V0RGF0YVNldFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2RhdGEuZ2V0RGF0YVNldCgpfX0se2tleTpcInN0cmVhbVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiB0aGlzLl9kYXRhLnN0cmVhbSh0fHxDcih7fSx4XyxlbihlPUxiKHRoaXMuX2lkcykpLmNhbGwoZSx0aGlzLl9pZHMpKSl9fSx7a2V5OlwiZGlzcG9zZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ7bnVsbCE9PSh0PXRoaXMuX2RhdGEpJiZ2b2lkIDAhPT10JiZ0Lm9mZiYmdGhpcy5fZGF0YS5vZmYoXCIqXCIsdGhpcy5fbGlzdGVuZXIpO3ZhciBlLHI9XCJUaGlzIGRhdGEgdmlldyBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkIG9mLlwiLGk9e2dldDpmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihyKX0sc2V0OmZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKHIpfSxjb25maWd1cmFibGU6ITF9LG89cncoamgobi5wcm90b3R5cGUpKTt0cnl7Zm9yKG8ucygpOyEoZT1vLm4oKSkuZG9uZTspe3ZhciBhPWUudmFsdWU7RWwodGhpcyxhLGkpfX1jYXRjaCh0KXtvLmUodCl9ZmluYWxseXtvLmYoKX19fSx7a2V5OlwiX29uRXZlbnRcIix2YWx1ZTpmdW5jdGlvbih0LGUscil7aWYoZSYmZS5pdGVtcyYmdGhpcy5fZGF0YSl7dmFyIG49ZS5pdGVtcyxpPVtdLG89W10sYT1bXSx1PVtdLHM9W10sYz1bXTtzd2l0Y2godCl7Y2FzZVwiYWRkXCI6Zm9yKHZhciBmPTAsbD1uLmxlbmd0aDtmPGw7ZisrKXt2YXIgaD1uW2ZdO3RoaXMuZ2V0KGgpJiYodGhpcy5faWRzLmFkZChoKSxpLnB1c2goaCkpfWJyZWFrO2Nhc2VcInVwZGF0ZVwiOmZvcih2YXIgcD0wLHY9bi5sZW5ndGg7cDx2O3ArKyl7dmFyIGQ9bltwXTt0aGlzLmdldChkKT90aGlzLl9pZHMuaGFzKGQpPyhvLnB1c2goZCkscy5wdXNoKGUuZGF0YVtwXSksdS5wdXNoKGUub2xkRGF0YVtwXSkpOih0aGlzLl9pZHMuYWRkKGQpLGkucHVzaChkKSk6dGhpcy5faWRzLmhhcyhkKSYmKHRoaXMuX2lkcy5kZWxldGUoZCksYS5wdXNoKGQpLGMucHVzaChlLm9sZERhdGFbcF0pKX1icmVhaztjYXNlXCJyZW1vdmVcIjpmb3IodmFyIHk9MCxnPW4ubGVuZ3RoO3k8Zzt5Kyspe3ZhciBtPW5beV07dGhpcy5faWRzLmhhcyhtKSYmKHRoaXMuX2lkcy5kZWxldGUobSksYS5wdXNoKG0pLGMucHVzaChlLm9sZERhdGFbeV0pKX19dGhpcy5sZW5ndGgrPWkubGVuZ3RoLWEubGVuZ3RoLGkubGVuZ3RoJiZ0aGlzLl90cmlnZ2VyKFwiYWRkXCIse2l0ZW1zOml9LHIpLG8ubGVuZ3RoJiZ0aGlzLl90cmlnZ2VyKFwidXBkYXRlXCIse2l0ZW1zOm8sb2xkRGF0YTp1LGRhdGE6c30sciksYS5sZW5ndGgmJnRoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIix7aXRlbXM6YSxvbGREYXRhOmN9LHIpfX19XSksbn0oWF8pO2Z1bmN0aW9uIGF3KHQsZSl7cmV0dXJuXCJvYmplY3RcIj09PV9oKGUpJiZudWxsIT09ZSYmdD09PWUuaWRQcm9wJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmFkZCYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5jbGVhciYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5kaXN0aW5jdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgSGgoZSkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZ2V0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmdldERhdGFTZXQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZ2V0SWRzJiZcIm51bWJlclwiPT10eXBlb2YgZS5sZW5ndGgmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFJpKGUpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLm1heCYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5taW4mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUub2ZmJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLm9uJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnJlbW92ZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5zZXRPcHRpb25zJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnN0cmVhbSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS51cGRhdGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUudXBkYXRlT25seX10LkRFTEVURT1nZyx0LkRhdGFTZXQ9ZXcsdC5EYXRhU3RyZWFtPUJfLHQuRGF0YVZpZXc9b3csdC5RdWV1ZT1HXyx0LmNyZWF0ZU5ld0RhdGFQaXBlRnJvbT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGVvKHQpfSx0LmlzRGF0YVNldExpa2U9YXcsdC5pc0RhdGFWaWV3TGlrZT1mdW5jdGlvbih0LGUpe3JldHVyblwib2JqZWN0XCI9PT1faChlKSYmbnVsbCE9PWUmJnQ9PT1lLmlkUHJvcCYmXCJmdW5jdGlvblwiPT10eXBlb2YgSGgoZSkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZ2V0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmdldERhdGFTZXQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZ2V0SWRzJiZcIm51bWJlclwiPT10eXBlb2YgZS5sZW5ndGgmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFJpKGUpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLm9mZiYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5vbiYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5zdHJlYW0mJmF3KHQsZS5nZXREYXRhU2V0KCkpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpcy1kYXRhLm1pbi5qcy5tYXBcbiIsIi8qKlxuICogdmlzLW5ldHdvcmtcbiAqIGh0dHBzOi8vdmlzanMuZ2l0aHViLmlvL3Zpcy1uZXR3b3JrL1xuICpcbiAqIEEgZHluYW1pYywgYnJvd3Nlci1iYXNlZCB2aXN1YWxpemF0aW9uIGxpYnJhcnkuXG4gKlxuICogQHZlcnNpb24gOS4wLjRcbiAqIEBkYXRlICAgIDIwMjEtMDMtMTZUMDU6NDE6NDAuODE4WlxuICpcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTEtMjAxNyBBbG1lbmRlIEIuViwgaHR0cDovL2FsbWVuZGUuY29tXG4gKiBAY29weXJpZ2h0IChjKSAyMDE3LTIwMTkgdmlzanMgY29udHJpYnV0b3JzLCBodHRwczovL2dpdGh1Yi5jb20vdmlzanNcbiAqXG4gKiBAbGljZW5zZVxuICogdmlzLmpzIGlzIGR1YWwgbGljZW5zZWQgdW5kZXIgYm90aFxuICpcbiAqICAgMS4gVGhlIEFwYWNoZSAyLjAgTGljZW5zZVxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgIGFuZFxuICpcbiAqICAgMi4gVGhlIE1JVCBMaWNlbnNlXG4gKiAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiB2aXMuanMgbWF5IGJlIGRpc3RyaWJ1dGVkIHVuZGVyIGVpdGhlciBsaWNlbnNlLlxuICovXG4hZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9lKGV4cG9ydHMscmVxdWlyZShcInZpcy1kYXRhL3BlZXIvdW1kL3Zpcy1kYXRhLmpzXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIixcInZpcy1kYXRhL3BlZXIvdW1kL3Zpcy1kYXRhLmpzXCJdLGUpOmUoKHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS52aXM9dC52aXN8fHt9LHQudmlzKX0odGhpcywoZnVuY3Rpb24odCxlKXt2YXIgaT1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6e307ZnVuY3Rpb24gbyh0KXt2YXIgZT17ZXhwb3J0czp7fX07cmV0dXJuIHQoZSxlLmV4cG9ydHMpLGUuZXhwb3J0c312YXIgbj1mdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5NYXRoPT1NYXRoJiZ0fSxyPW4oXCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbFRoaXMmJmdsb2JhbFRoaXMpfHxuKFwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdyl8fG4oXCJvYmplY3RcIj09dHlwZW9mIHNlbGYmJnNlbGYpfHxuKFwib2JqZWN0XCI9PXR5cGVvZiBpJiZpKXx8ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKXx8RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpLHM9ZnVuY3Rpb24odCl7dHJ5e3JldHVybiEhdCgpfWNhdGNoKHQpe3JldHVybiEwfX0sYT0hcygoZnVuY3Rpb24oKXtyZXR1cm4gNyE9T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LDEse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pWzFdfSkpLGg9e30ucHJvcGVydHlJc0VudW1lcmFibGUsZD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLGw9e2Y6ZCYmIWguY2FsbCh7MToyfSwxKT9mdW5jdGlvbih0KXt2YXIgZT1kKHRoaXMsdCk7cmV0dXJuISFlJiZlLmVudW1lcmFibGV9Omh9LGM9ZnVuY3Rpb24odCxlKXtyZXR1cm57ZW51bWVyYWJsZTohKDEmdCksY29uZmlndXJhYmxlOiEoMiZ0KSx3cml0YWJsZTohKDQmdCksdmFsdWU6ZX19LHU9e30udG9TdHJpbmcsZj1mdW5jdGlvbih0KXtyZXR1cm4gdS5jYWxsKHQpLnNsaWNlKDgsLTEpfSxwPVwiXCIuc3BsaXQsdj1zKChmdW5jdGlvbigpe3JldHVybiFPYmplY3QoXCJ6XCIpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApfSkpP2Z1bmN0aW9uKHQpe3JldHVyblwiU3RyaW5nXCI9PWYodCk/cC5jYWxsKHQsXCJcIik6T2JqZWN0KHQpfTpPYmplY3QsZz1mdW5jdGlvbih0KXtpZihudWxsPT10KXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiK3QpO3JldHVybiB0fSx5PWZ1bmN0aW9uKHQpe3JldHVybiB2KGcodCkpfSxtPWZ1bmN0aW9uKHQpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiB0P251bGwhPT10OlwiZnVuY3Rpb25cIj09dHlwZW9mIHR9LGI9ZnVuY3Rpb24odCxlKXtpZighbSh0KSlyZXR1cm4gdDt2YXIgaSxvO2lmKGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mKGk9dC50b1N0cmluZykmJiFtKG89aS5jYWxsKHQpKSlyZXR1cm4gbztpZihcImZ1bmN0aW9uXCI9PXR5cGVvZihpPXQudmFsdWVPZikmJiFtKG89aS5jYWxsKHQpKSlyZXR1cm4gbztpZighZSYmXCJmdW5jdGlvblwiPT10eXBlb2YoaT10LnRvU3RyaW5nKSYmIW0obz1pLmNhbGwodCkpKXJldHVybiBvO3Rocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKX0sdz17fS5oYXNPd25Qcm9wZXJ0eSxrPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHcuY2FsbCh0LGUpfSxfPXIuZG9jdW1lbnQseD1tKF8pJiZtKF8uY3JlYXRlRWxlbWVudCksRT1mdW5jdGlvbih0KXtyZXR1cm4geD9fLmNyZWF0ZUVsZW1lbnQodCk6e319LE89IWEmJiFzKChmdW5jdGlvbigpe3JldHVybiA3IT1PYmplY3QuZGVmaW5lUHJvcGVydHkoRShcImRpdlwiKSxcImFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYX0pKSxDPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsUz17ZjphP0M6ZnVuY3Rpb24odCxlKXtpZih0PXkodCksZT1iKGUsITApLE8pdHJ5e3JldHVybiBDKHQsZSl9Y2F0Y2godCl7fWlmKGsodCxlKSlyZXR1cm4gYyghbC5mLmNhbGwodCxlKSx0W2VdKX19LFQ9LyN8XFwucHJvdG90eXBlXFwuLyxNPWZ1bmN0aW9uKHQsZSl7dmFyIGk9RFtQKHQpXTtyZXR1cm4gaT09SXx8aSE9QiYmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGU/cyhlKTohIWUpfSxQPU0ubm9ybWFsaXplPWZ1bmN0aW9uKHQpe3JldHVybiBTdHJpbmcodCkucmVwbGFjZShULFwiLlwiKS50b0xvd2VyQ2FzZSgpfSxEPU0uZGF0YT17fSxCPU0uTkFUSVZFPVwiTlwiLEk9TS5QT0xZRklMTD1cIlBcIix6PU0sRj17fSxOPWZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgVHlwZUVycm9yKFN0cmluZyh0KStcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtyZXR1cm4gdH0sQT1mdW5jdGlvbih0LGUsaSl7aWYoTih0KSx2b2lkIDA9PT1lKXJldHVybiB0O3N3aXRjaChpKXtjYXNlIDA6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuY2FsbChlKX07Y2FzZSAxOnJldHVybiBmdW5jdGlvbihpKXtyZXR1cm4gdC5jYWxsKGUsaSl9O2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24oaSxvKXtyZXR1cm4gdC5jYWxsKGUsaSxvKX07Y2FzZSAzOnJldHVybiBmdW5jdGlvbihpLG8sbil7cmV0dXJuIHQuY2FsbChlLGksbyxuKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkoZSxhcmd1bWVudHMpfX0sUj1mdW5jdGlvbih0KXtpZighbSh0KSl0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKHQpK1wiIGlzIG5vdCBhbiBvYmplY3RcIik7cmV0dXJuIHR9LGo9T2JqZWN0LmRlZmluZVByb3BlcnR5LEw9e2Y6YT9qOmZ1bmN0aW9uKHQsZSxpKXtpZihSKHQpLGU9YihlLCEwKSxSKGkpLE8pdHJ5e3JldHVybiBqKHQsZSxpKX1jYXRjaCh0KXt9aWYoXCJnZXRcImluIGl8fFwic2V0XCJpbiBpKXRocm93IFR5cGVFcnJvcihcIkFjY2Vzc29ycyBub3Qgc3VwcG9ydGVkXCIpO3JldHVyblwidmFsdWVcImluIGkmJih0W2VdPWkudmFsdWUpLHR9fSxIPWE/ZnVuY3Rpb24odCxlLGkpe3JldHVybiBMLmYodCxlLGMoMSxpKSl9OmZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gdFtlXT1pLHR9LFc9Uy5mLFY9ZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oZSxpLG8pe2lmKHRoaXMgaW5zdGFuY2VvZiB0KXtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBuZXcgdDtjYXNlIDE6cmV0dXJuIG5ldyB0KGUpO2Nhc2UgMjpyZXR1cm4gbmV3IHQoZSxpKX1yZXR1cm4gbmV3IHQoZSxpLG8pfXJldHVybiB0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07cmV0dXJuIGUucHJvdG90eXBlPXQucHJvdG90eXBlLGV9LHE9ZnVuY3Rpb24odCxlKXt2YXIgaSxvLG4scyxhLGgsZCxsLGM9dC50YXJnZXQsdT10Lmdsb2JhbCxmPXQuc3RhdCxwPXQucHJvdG8sdj11P3I6Zj9yW2NdOihyW2NdfHx7fSkucHJvdG90eXBlLGc9dT9GOkZbY118fChGW2NdPXt9KSx5PWcucHJvdG90eXBlO2ZvcihuIGluIGUpaT0heih1P246YysoZj9cIi5cIjpcIiNcIikrbix0LmZvcmNlZCkmJnYmJmsodixuKSxhPWdbbl0saSYmKGg9dC5ub1RhcmdldEdldD8obD1XKHYsbikpJiZsLnZhbHVlOnZbbl0pLHM9aSYmaD9oOmVbbl0saSYmdHlwZW9mIGE9PXR5cGVvZiBzfHwoZD10LmJpbmQmJmk/QShzLHIpOnQud3JhcCYmaT9WKHMpOnAmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHM/QShGdW5jdGlvbi5jYWxsLHMpOnMsKHQuc2hhbXx8cyYmcy5zaGFtfHxhJiZhLnNoYW0pJiZIKGQsXCJzaGFtXCIsITApLGdbbl09ZCxwJiYoayhGLG89YytcIlByb3RvdHlwZVwiKXx8SChGLG8se30pLEZbb11bbl09cyx0LnJlYWwmJnkmJiF5W25dJiZIKHksbixzKSkpfSxVPU1hdGguY2VpbCxZPU1hdGguZmxvb3IsWD1mdW5jdGlvbih0KXtyZXR1cm4gaXNOYU4odD0rdCk/MDoodD4wP1k6VSkodCl9LEc9TWF0aC5taW4sSz1mdW5jdGlvbih0KXtyZXR1cm4gdD4wP0coWCh0KSw5MDA3MTk5MjU0NzQwOTkxKTowfSwkPU1hdGgubWF4LFE9TWF0aC5taW4sWj1mdW5jdGlvbih0LGUpe3ZhciBpPVgodCk7cmV0dXJuIGk8MD8kKGkrZSwwKTpRKGksZSl9LEo9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUsaSxvKXt2YXIgbixyPXkoZSkscz1LKHIubGVuZ3RoKSxhPVoobyxzKTtpZih0JiZpIT1pKXtmb3IoO3M+YTspaWYoKG49clthKytdKSE9bilyZXR1cm4hMH1lbHNlIGZvcig7cz5hO2ErKylpZigodHx8YSBpbiByKSYmclthXT09PWkpcmV0dXJuIHR8fGF8fDA7cmV0dXJuIXQmJi0xfX0sdHQ9e2luY2x1ZGVzOkooITApLGluZGV4T2Y6SighMSl9LGV0PXt9LGl0PXR0LmluZGV4T2Ysb3Q9ZnVuY3Rpb24odCxlKXt2YXIgaSxvPXkodCksbj0wLHI9W107Zm9yKGkgaW4gbykhayhldCxpKSYmayhvLGkpJiZyLnB1c2goaSk7Zm9yKDtlLmxlbmd0aD5uOylrKG8saT1lW24rK10pJiYofml0KHIsaSl8fHIucHVzaChpKSk7cmV0dXJuIHJ9LG50PVtcImNvbnN0cnVjdG9yXCIsXCJoYXNPd25Qcm9wZXJ0eVwiLFwiaXNQcm90b3R5cGVPZlwiLFwicHJvcGVydHlJc0VudW1lcmFibGVcIixcInRvTG9jYWxlU3RyaW5nXCIsXCJ0b1N0cmluZ1wiLFwidmFsdWVPZlwiXSxydD1PYmplY3Qua2V5c3x8ZnVuY3Rpb24odCl7cmV0dXJuIG90KHQsbnQpfSxzdD17ZjpPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzfSxhdD1mdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0KGcodCkpfSxodD1PYmplY3QuYXNzaWduLGR0PU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxsdD0haHR8fHMoKGZ1bmN0aW9uKCl7aWYoYSYmMSE9PWh0KHtiOjF9LGh0KGR0KHt9LFwiYVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe2R0KHRoaXMsXCJiXCIse3ZhbHVlOjMsZW51bWVyYWJsZTohMX0pfX0pLHtiOjJ9KSkuYilyZXR1cm4hMDt2YXIgdD17fSxlPXt9LGk9U3ltYm9sKCksbz1cImFiY2RlZmdoaWprbG1ub3BxcnN0XCI7cmV0dXJuIHRbaV09NyxvLnNwbGl0KFwiXCIpLmZvckVhY2goKGZ1bmN0aW9uKHQpe2VbdF09dH0pKSw3IT1odCh7fSx0KVtpXXx8cnQoaHQoe30sZSkpLmpvaW4oXCJcIikhPW99KSk/ZnVuY3Rpb24odCxlKXtmb3IodmFyIGk9YXQodCksbz1hcmd1bWVudHMubGVuZ3RoLG49MSxyPXN0LmYscz1sLmY7bz5uOylmb3IodmFyIGgsZD12KGFyZ3VtZW50c1tuKytdKSxjPXI/cnQoZCkuY29uY2F0KHIoZCkpOnJ0KGQpLHU9Yy5sZW5ndGgsZj0wO3U+ZjspaD1jW2YrK10sYSYmIXMuY2FsbChkLGgpfHwoaVtoXT1kW2hdKTtyZXR1cm4gaX06aHQ7cSh7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxmb3JjZWQ6T2JqZWN0LmFzc2lnbiE9PWx0fSx7YXNzaWduOmx0fSk7dmFyIGN0PUYuT2JqZWN0LmFzc2lnbix1dD1bXS5zbGljZSxmdD17fSxwdD1mdW5jdGlvbih0LGUsaSl7aWYoIShlIGluIGZ0KSl7Zm9yKHZhciBvPVtdLG49MDtuPGU7bisrKW9bbl09XCJhW1wiK24rXCJdXCI7ZnRbZV09RnVuY3Rpb24oXCJDLGFcIixcInJldHVybiBuZXcgQyhcIitvLmpvaW4oXCIsXCIpK1wiKVwiKX1yZXR1cm4gZnRbZV0odCxpKX0sdnQ9RnVuY3Rpb24uYmluZHx8ZnVuY3Rpb24odCl7dmFyIGU9Tih0aGlzKSxpPXV0LmNhbGwoYXJndW1lbnRzLDEpLG89ZnVuY3Rpb24oKXt2YXIgbj1pLmNvbmNhdCh1dC5jYWxsKGFyZ3VtZW50cykpO3JldHVybiB0aGlzIGluc3RhbmNlb2Ygbz9wdChlLG4ubGVuZ3RoLG4pOmUuYXBwbHkodCxuKX07cmV0dXJuIG0oZS5wcm90b3R5cGUpJiYoby5wcm90b3R5cGU9ZS5wcm90b3R5cGUpLG99O3Eoe3RhcmdldDpcIkZ1bmN0aW9uXCIscHJvdG86ITB9LHtiaW5kOnZ0fSk7dmFyIGd0PWZ1bmN0aW9uKHQpe3JldHVybiBGW3QrXCJQcm90b3R5cGVcIl19LHl0PWd0KFwiRnVuY3Rpb25cIikuYmluZCxtdD1GdW5jdGlvbi5wcm90b3R5cGUsYnQ9ZnVuY3Rpb24odCl7dmFyIGU9dC5iaW5kO3JldHVybiB0PT09bXR8fHQgaW5zdGFuY2VvZiBGdW5jdGlvbiYmZT09PW10LmJpbmQ/eXQ6ZX07ZnVuY3Rpb24gd3QodCxlLGksbyl7dC5iZWdpblBhdGgoKSx0LmFyYyhlLGksbywwLDIqTWF0aC5QSSwhMSksdC5jbG9zZVBhdGgoKX1mdW5jdGlvbiBrdCh0LGUsaSxvLG4scil7dmFyIHM9TWF0aC5QSS8xODA7by0yKnI8MCYmKHI9by8yKSxuLTIqcjwwJiYocj1uLzIpLHQuYmVnaW5QYXRoKCksdC5tb3ZlVG8oZStyLGkpLHQubGluZVRvKGUrby1yLGkpLHQuYXJjKGUrby1yLGkrcixyLDI3MCpzLDM2MCpzLCExKSx0LmxpbmVUbyhlK28saStuLXIpLHQuYXJjKGUrby1yLGkrbi1yLHIsMCw5MCpzLCExKSx0LmxpbmVUbyhlK3IsaStuKSx0LmFyYyhlK3IsaStuLXIsciw5MCpzLDE4MCpzLCExKSx0LmxpbmVUbyhlLGkrciksdC5hcmMoZStyLGkrcixyLDE4MCpzLDI3MCpzLCExKSx0LmNsb3NlUGF0aCgpfWZ1bmN0aW9uIF90KHQsZSxpLG8sbil7dmFyIHI9LjU1MjI4NDgscz1vLzIqcixhPW4vMipyLGg9ZStvLGQ9aStuLGw9ZStvLzIsYz1pK24vMjt0LmJlZ2luUGF0aCgpLHQubW92ZVRvKGUsYyksdC5iZXppZXJDdXJ2ZVRvKGUsYy1hLGwtcyxpLGwsaSksdC5iZXppZXJDdXJ2ZVRvKGwrcyxpLGgsYy1hLGgsYyksdC5iZXppZXJDdXJ2ZVRvKGgsYythLGwrcyxkLGwsZCksdC5iZXppZXJDdXJ2ZVRvKGwtcyxkLGUsYythLGUsYyksdC5jbG9zZVBhdGgoKX1mdW5jdGlvbiB4dCh0LGUsaSxvLG4pe3ZhciByPW4qKDEvMykscz0uNTUyMjg0OCxhPW8vMipzLGg9ci8yKnMsZD1lK28sbD1pK3IsYz1lK28vMix1PWkrci8yLGY9aSsobi1yLzIpLHA9aStuO3QuYmVnaW5QYXRoKCksdC5tb3ZlVG8oZCx1KSx0LmJlemllckN1cnZlVG8oZCx1K2gsYythLGwsYyxsKSx0LmJlemllckN1cnZlVG8oYy1hLGwsZSx1K2gsZSx1KSx0LmJlemllckN1cnZlVG8oZSx1LWgsYy1hLGksYyxpKSx0LmJlemllckN1cnZlVG8oYythLGksZCx1LWgsZCx1KSx0LmxpbmVUbyhkLGYpLHQuYmV6aWVyQ3VydmVUbyhkLGYraCxjK2EscCxjLHApLHQuYmV6aWVyQ3VydmVUbyhjLWEscCxlLGYraCxlLGYpLHQubGluZVRvKGUsdSl9ZnVuY3Rpb24gRXQodCxlLGksbyxuLHIpe3QuYmVnaW5QYXRoKCksdC5tb3ZlVG8oZSxpKTtmb3IodmFyIHM9ci5sZW5ndGgsYT1vLWUsaD1uLWksZD1oL2EsbD1NYXRoLnNxcnQoYSphK2gqaCksYz0wLHU9ITAsZj0wLHA9K3JbMF07bD49LjE7KShwPStyW2MrKyVzXSk+bCYmKHA9bCksZj1NYXRoLnNxcnQocCpwLygxK2QqZCkpLGUrPWY9YTwwPy1mOmYsaSs9ZCpmLCEwPT09dT90LmxpbmVUbyhlLGkpOnQubW92ZVRvKGUsaSksbC09cCx1PSF1fXZhciBPdD17Y2lyY2xlOnd0LGRhc2hlZExpbmU6RXQsZGF0YWJhc2U6eHQsZGlhbW9uZDpmdW5jdGlvbih0LGUsaSxvKXt0LmJlZ2luUGF0aCgpLHQubGluZVRvKGUsaStvKSx0LmxpbmVUbyhlK28saSksdC5saW5lVG8oZSxpLW8pLHQubGluZVRvKGUtbyxpKSx0LmNsb3NlUGF0aCgpfSxlbGxpcHNlOl90LGVsbGlwc2VfdmlzOl90LGhleGFnb246ZnVuY3Rpb24odCxlLGksbyl7dC5iZWdpblBhdGgoKTt2YXIgbj0yKk1hdGguUEkvNjt0Lm1vdmVUbyhlK28saSk7Zm9yKHZhciByPTE7cjw2O3IrKyl0LmxpbmVUbyhlK28qTWF0aC5jb3MobipyKSxpK28qTWF0aC5zaW4obipyKSk7dC5jbG9zZVBhdGgoKX0scm91bmRSZWN0Omt0LHNxdWFyZTpmdW5jdGlvbih0LGUsaSxvKXt0LmJlZ2luUGF0aCgpLHQucmVjdChlLW8saS1vLDIqbywyKm8pLHQuY2xvc2VQYXRoKCl9LHN0YXI6ZnVuY3Rpb24odCxlLGksbyl7dC5iZWdpblBhdGgoKSxpKz0uMSoobyo9LjgyKTtmb3IodmFyIG49MDtuPDEwO24rKyl7dmFyIHI9biUyPT0wPzEuMypvOi41Km87dC5saW5lVG8oZStyKk1hdGguc2luKDIqbipNYXRoLlBJLzEwKSxpLXIqTWF0aC5jb3MoMipuKk1hdGguUEkvMTApKX10LmNsb3NlUGF0aCgpfSx0cmlhbmdsZTpmdW5jdGlvbih0LGUsaSxvKXt0LmJlZ2luUGF0aCgpLGkrPS4yNzUqKG8qPTEuMTUpO3ZhciBuPTIqbyxyPW4vMixzPU1hdGguc3FydCgzKS82Km4sYT1NYXRoLnNxcnQobipuLXIqcik7dC5tb3ZlVG8oZSxpLShhLXMpKSx0LmxpbmVUbyhlK3IsaStzKSx0LmxpbmVUbyhlLXIsaStzKSx0LmxpbmVUbyhlLGktKGEtcykpLHQuY2xvc2VQYXRoKCl9LHRyaWFuZ2xlRG93bjpmdW5jdGlvbih0LGUsaSxvKXt0LmJlZ2luUGF0aCgpLGktPS4yNzUqKG8qPTEuMTUpO3ZhciBuPTIqbyxyPW4vMixzPU1hdGguc3FydCgzKS82Km4sYT1NYXRoLnNxcnQobipuLXIqcik7dC5tb3ZlVG8oZSxpKyhhLXMpKSx0LmxpbmVUbyhlK3IsaS1zKSx0LmxpbmVUbyhlLXIsaS1zKSx0LmxpbmVUbyhlLGkrKGEtcykpLHQuY2xvc2VQYXRoKCl9fTt2YXIgQ3Q9bygoZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtpZih0KXJldHVybiBmdW5jdGlvbih0KXtmb3IodmFyIGkgaW4gZS5wcm90b3R5cGUpdFtpXT1lLnByb3RvdHlwZVtpXTtyZXR1cm4gdH0odCl9dC5leHBvcnRzPWUsZS5wcm90b3R5cGUub249ZS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzfHx7fSwodGhpcy5fY2FsbGJhY2tzW1wiJFwiK3RdPXRoaXMuX2NhbGxiYWNrc1tcIiRcIit0XXx8W10pLnB1c2goZSksdGhpc30sZS5wcm90b3R5cGUub25jZT1mdW5jdGlvbih0LGUpe2Z1bmN0aW9uIGkoKXt0aGlzLm9mZih0LGkpLGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBpLmZuPWUsdGhpcy5vbih0LGkpLHRoaXN9LGUucHJvdG90eXBlLm9mZj1lLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1lLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM9ZS5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbih0LGUpe2lmKHRoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9LDA9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX2NhbGxiYWNrcz17fSx0aGlzO3ZhciBpLG89dGhpcy5fY2FsbGJhY2tzW1wiJFwiK3RdO2lmKCFvKXJldHVybiB0aGlzO2lmKDE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbXCIkXCIrdF0sdGhpcztmb3IodmFyIG49MDtuPG8ubGVuZ3RoO24rKylpZigoaT1vW25dKT09PWV8fGkuZm49PT1lKXtvLnNwbGljZShuLDEpO2JyZWFrfXJldHVybiAwPT09by5sZW5ndGgmJmRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbXCIkXCIrdF0sdGhpc30sZS5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbih0KXt0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzfHx7fTtmb3IodmFyIGU9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSksaT10aGlzLl9jYWxsYmFja3NbXCIkXCIrdF0sbz0xO288YXJndW1lbnRzLmxlbmd0aDtvKyspZVtvLTFdPWFyZ3VtZW50c1tvXTtpZihpKXtvPTA7Zm9yKHZhciBuPShpPWkuc2xpY2UoMCkpLmxlbmd0aDtvPG47KytvKWlbb10uYXBwbHkodGhpcyxlKX1yZXR1cm4gdGhpc30sZS5wcm90b3R5cGUubGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzfHx7fSx0aGlzLl9jYWxsYmFja3NbXCIkXCIrdF18fFtdfSxlLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnM9ZnVuY3Rpb24odCl7cmV0dXJuISF0aGlzLmxpc3RlbmVycyh0KS5sZW5ndGh9fSkpLFN0PWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLGkpe3ZhciBvLG4scj1TdHJpbmcoZyhlKSkscz1YKGkpLGE9ci5sZW5ndGg7cmV0dXJuIHM8MHx8cz49YT90P1wiXCI6dm9pZCAwOihvPXIuY2hhckNvZGVBdChzKSk8NTUyOTZ8fG8+NTYzMTl8fHMrMT09PWF8fChuPXIuY2hhckNvZGVBdChzKzEpKTw1NjMyMHx8bj41NzM0Mz90P3IuY2hhckF0KHMpOm86dD9yLnNsaWNlKHMscysyKTpuLTU2MzIwKyhvLTU1Mjk2PDwxMCkrNjU1MzZ9fSxUdD17Y29kZUF0OlN0KCExKSxjaGFyQXQ6U3QoITApfSxNdD1cIl9fY29yZS1qc19zaGFyZWRfX1wiLFB0PXJbTXRdfHxmdW5jdGlvbih0LGUpe3RyeXtIKHIsdCxlKX1jYXRjaChpKXtyW3RdPWV9cmV0dXJuIGV9KE10LHt9KSxEdD1GdW5jdGlvbi50b1N0cmluZztcImZ1bmN0aW9uXCIhPXR5cGVvZiBQdC5pbnNwZWN0U291cmNlJiYoUHQuaW5zcGVjdFNvdXJjZT1mdW5jdGlvbih0KXtyZXR1cm4gRHQuY2FsbCh0KX0pO3ZhciBCdCxJdCx6dCxGdD1QdC5pbnNwZWN0U291cmNlLE50PXIuV2Vha01hcCxBdD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBOdCYmL25hdGl2ZSBjb2RlLy50ZXN0KEZ0KE50KSksUnQ9bygoZnVuY3Rpb24odCl7KHQuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybiBQdFt0XXx8KFB0W3RdPXZvaWQgMCE9PWU/ZTp7fSl9KShcInZlcnNpb25zXCIsW10pLnB1c2goe3ZlcnNpb246XCIzLjkuMVwiLG1vZGU6XCJwdXJlXCIsY29weXJpZ2h0OlwiwqkgMjAyMSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KVwifSl9KSksanQ9MCxMdD1NYXRoLnJhbmRvbSgpLEh0PWZ1bmN0aW9uKHQpe3JldHVyblwiU3ltYm9sKFwiK1N0cmluZyh2b2lkIDA9PT10P1wiXCI6dCkrXCIpX1wiKygrK2p0K0x0KS50b1N0cmluZygzNil9LFd0PVJ0KFwia2V5c1wiKSxWdD1mdW5jdGlvbih0KXtyZXR1cm4gV3RbdF18fChXdFt0XT1IdCh0KSl9LHF0PXIuV2Vha01hcDtpZihBdCl7dmFyIFV0PVB0LnN0YXRlfHwoUHQuc3RhdGU9bmV3IHF0KSxZdD1VdC5nZXQsWHQ9VXQuaGFzLEd0PVV0LnNldDtCdD1mdW5jdGlvbih0LGUpe3JldHVybiBlLmZhY2FkZT10LEd0LmNhbGwoVXQsdCxlKSxlfSxJdD1mdW5jdGlvbih0KXtyZXR1cm4gWXQuY2FsbChVdCx0KXx8e319LHp0PWZ1bmN0aW9uKHQpe3JldHVybiBYdC5jYWxsKFV0LHQpfX1lbHNle3ZhciBLdD1WdChcInN0YXRlXCIpO2V0W0t0XT0hMCxCdD1mdW5jdGlvbih0LGUpe3JldHVybiBlLmZhY2FkZT10LEgodCxLdCxlKSxlfSxJdD1mdW5jdGlvbih0KXtyZXR1cm4gayh0LEt0KT90W0t0XTp7fX0senQ9ZnVuY3Rpb24odCl7cmV0dXJuIGsodCxLdCl9fXZhciAkdCxRdCxadD17c2V0OkJ0LGdldDpJdCxoYXM6enQsZW5mb3JjZTpmdW5jdGlvbih0KXtyZXR1cm4genQodCk/SXQodCk6QnQodCx7fSl9LGdldHRlckZvcjpmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIGk7aWYoIW0oZSl8fChpPUl0KGUpKS50eXBlIT09dCl0aHJvdyBUeXBlRXJyb3IoXCJJbmNvbXBhdGlibGUgcmVjZWl2ZXIsIFwiK3QrXCIgcmVxdWlyZWRcIik7cmV0dXJuIGl9fX0sSnQ9IXMoKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuY29uc3RydWN0b3I9bnVsbCxPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IHQpIT09dC5wcm90b3R5cGV9KSksdGU9VnQoXCJJRV9QUk9UT1wiKSxlZT1PYmplY3QucHJvdG90eXBlLGllPUp0P09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbih0KXtyZXR1cm4gdD1hdCh0KSxrKHQsdGUpP3RbdGVdOlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuY29uc3RydWN0b3ImJnQgaW5zdGFuY2VvZiB0LmNvbnN0cnVjdG9yP3QuY29uc3RydWN0b3IucHJvdG90eXBlOnQgaW5zdGFuY2VvZiBPYmplY3Q/ZWU6bnVsbH0sb2U9XCJwcm9jZXNzXCI9PWYoci5wcm9jZXNzKSxuZT1mdW5jdGlvbih0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Q6dm9pZCAwfSxyZT1mdW5jdGlvbih0LGUpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPDI/bmUoRlt0XSl8fG5lKHJbdF0pOkZbdF0mJkZbdF1bZV18fHJbdF0mJnJbdF1bZV19LHNlPXJlKFwibmF2aWdhdG9yXCIsXCJ1c2VyQWdlbnRcIil8fFwiXCIsYWU9ci5wcm9jZXNzLGhlPWFlJiZhZS52ZXJzaW9ucyxkZT1oZSYmaGUudjg7ZGU/UXQ9KCR0PWRlLnNwbGl0KFwiLlwiKSlbMF0rJHRbMV06c2UmJighKCR0PXNlLm1hdGNoKC9FZGdlXFwvKFxcZCspLykpfHwkdFsxXT49NzQpJiYoJHQ9c2UubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pKSYmKFF0PSR0WzFdKTt2YXIgbGUsY2UsdWUsZmU9UXQmJitRdCxwZT0hIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMmJiFzKChmdW5jdGlvbigpe3JldHVybiFTeW1ib2wuc2hhbSYmKG9lPzM4PT09ZmU6ZmU+MzcmJmZlPDQxKX0pKSx2ZT1wZSYmIVN5bWJvbC5zaGFtJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yLGdlPVJ0KFwid2tzXCIpLHllPXIuU3ltYm9sLG1lPXZlP3llOnllJiZ5ZS53aXRob3V0U2V0dGVyfHxIdCxiZT1mdW5jdGlvbih0KXtyZXR1cm4gayhnZSx0KSYmKHBlfHxcInN0cmluZ1wiPT10eXBlb2YgZ2VbdF0pfHwocGUmJmsoeWUsdCk/Z2VbdF09eWVbdF06Z2VbdF09bWUoXCJTeW1ib2wuXCIrdCkpLGdlW3RdfSx3ZT1iZShcIml0ZXJhdG9yXCIpLGtlPSExO1tdLmtleXMmJihcIm5leHRcImluKHVlPVtdLmtleXMoKSk/KGNlPWllKGllKHVlKSkpIT09T2JqZWN0LnByb3RvdHlwZSYmKGxlPWNlKTprZT0hMCk7dmFyIF9lPW51bGw9PWxlfHxzKChmdW5jdGlvbigpe3ZhciB0PXt9O3JldHVybiBsZVt3ZV0uY2FsbCh0KSE9PXR9KSk7X2UmJihsZT17fSksX2UmJiFrKGxlLHdlKSYmSChsZSx3ZSwoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pKTt2YXIgeGUsRWU9e0l0ZXJhdG9yUHJvdG90eXBlOmxlLEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6a2V9LE9lPWE/T2JqZWN0LmRlZmluZVByb3BlcnRpZXM6ZnVuY3Rpb24odCxlKXtSKHQpO2Zvcih2YXIgaSxvPXJ0KGUpLG49by5sZW5ndGgscj0wO24+cjspTC5mKHQsaT1vW3IrK10sZVtpXSk7cmV0dXJuIHR9LENlPXJlKFwiZG9jdW1lbnRcIixcImRvY3VtZW50RWxlbWVudFwiKSxTZT1WdChcIklFX1BST1RPXCIpLFRlPWZ1bmN0aW9uKCl7fSxNZT1mdW5jdGlvbih0KXtyZXR1cm5cIjxzY3JpcHQ+XCIrdCtcIjwvXCIrXCJzY3JpcHQ+XCJ9LFBlPWZ1bmN0aW9uKCl7dHJ5e3hlPWRvY3VtZW50LmRvbWFpbiYmbmV3IEFjdGl2ZVhPYmplY3QoXCJodG1sZmlsZVwiKX1jYXRjaCh0KXt9dmFyIHQsZTtQZT14ZT9mdW5jdGlvbih0KXt0LndyaXRlKE1lKFwiXCIpKSx0LmNsb3NlKCk7dmFyIGU9dC5wYXJlbnRXaW5kb3cuT2JqZWN0O3JldHVybiB0PW51bGwsZX0oeGUpOigoZT1FKFwiaWZyYW1lXCIpKS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLENlLmFwcGVuZENoaWxkKGUpLGUuc3JjPVN0cmluZyhcImphdmFzY3JpcHQ6XCIpLCh0PWUuY29udGVudFdpbmRvdy5kb2N1bWVudCkub3BlbigpLHQud3JpdGUoTWUoXCJkb2N1bWVudC5GPU9iamVjdFwiKSksdC5jbG9zZSgpLHQuRik7Zm9yKHZhciBpPW50Lmxlbmd0aDtpLS07KWRlbGV0ZSBQZS5wcm90b3R5cGVbbnRbaV1dO3JldHVybiBQZSgpfTtldFtTZV09ITA7dmFyIERlPU9iamVjdC5jcmVhdGV8fGZ1bmN0aW9uKHQsZSl7dmFyIGk7cmV0dXJuIG51bGwhPT10PyhUZS5wcm90b3R5cGU9Uih0KSxpPW5ldyBUZSxUZS5wcm90b3R5cGU9bnVsbCxpW1NlXT10KTppPVBlKCksdm9pZCAwPT09ZT9pOk9lKGksZSl9LEJlPXt9O0JlW2JlKFwidG9TdHJpbmdUYWdcIildPVwielwiO3ZhciBJZT1cIltvYmplY3Qgel1cIj09PVN0cmluZyhCZSksemU9YmUoXCJ0b1N0cmluZ1RhZ1wiKSxGZT1cIkFyZ3VtZW50c1wiPT1mKGZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c30oKSksTmU9SWU/ZjpmdW5jdGlvbih0KXt2YXIgZSxpLG87cmV0dXJuIHZvaWQgMD09PXQ/XCJVbmRlZmluZWRcIjpudWxsPT09dD9cIk51bGxcIjpcInN0cmluZ1wiPT10eXBlb2YoaT1mdW5jdGlvbih0LGUpe3RyeXtyZXR1cm4gdFtlXX1jYXRjaCh0KXt9fShlPU9iamVjdCh0KSx6ZSkpP2k6RmU/ZihlKTpcIk9iamVjdFwiPT0obz1mKGUpKSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5jYWxsZWU/XCJBcmd1bWVudHNcIjpvfSxBZT1JZT97fS50b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiW29iamVjdCBcIitOZSh0aGlzKStcIl1cIn0sUmU9TC5mLGplPWJlKFwidG9TdHJpbmdUYWdcIiksTGU9ZnVuY3Rpb24odCxlLGksbyl7aWYodCl7dmFyIG49aT90OnQucHJvdG90eXBlO2sobixqZSl8fFJlKG4samUse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTplfSksbyYmIUllJiZIKG4sXCJ0b1N0cmluZ1wiLEFlKX19LEhlPXt9LFdlPUVlLkl0ZXJhdG9yUHJvdG90eXBlLFZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LHFlPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8KFwiX19wcm90b19fXCJpbnt9P2Z1bmN0aW9uKCl7dmFyIHQsZT0hMSxpPXt9O3RyeXsodD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsXCJfX3Byb3RvX19cIikuc2V0KS5jYWxsKGksW10pLGU9aSBpbnN0YW5jZW9mIEFycmF5fWNhdGNoKHQpe31yZXR1cm4gZnVuY3Rpb24oaSxvKXtyZXR1cm4gUihpKSxmdW5jdGlvbih0KXtpZighbSh0KSYmbnVsbCE9PXQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3Qgc2V0IFwiK1N0cmluZyh0KStcIiBhcyBhIHByb3RvdHlwZVwiKX0obyksZT90LmNhbGwoaSxvKTppLl9fcHJvdG9fXz1vLGl9fSgpOnZvaWQgMCksVWU9ZnVuY3Rpb24odCxlLGksbyl7byYmby5lbnVtZXJhYmxlP3RbZV09aTpIKHQsZSxpKX0sWWU9RWUuSXRlcmF0b3JQcm90b3R5cGUsWGU9RWUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUyxHZT1iZShcIml0ZXJhdG9yXCIpLEtlPVwia2V5c1wiLCRlPVwidmFsdWVzXCIsUWU9XCJlbnRyaWVzXCIsWmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sSmU9ZnVuY3Rpb24odCxlLGksbyxuLHIscyl7IWZ1bmN0aW9uKHQsZSxpKXt2YXIgbz1lK1wiIEl0ZXJhdG9yXCI7dC5wcm90b3R5cGU9RGUoV2Use25leHQ6YygxLGkpfSksTGUodCxvLCExLCEwKSxIZVtvXT1WZX0oaSxlLG8pO3ZhciBhLGgsZCxsPWZ1bmN0aW9uKHQpe2lmKHQ9PT1uJiZnKXJldHVybiBnO2lmKCFYZSYmdCBpbiBwKXJldHVybiBwW3RdO3N3aXRjaCh0KXtjYXNlIEtlOmNhc2UgJGU6Y2FzZSBRZTpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGkodGhpcyx0KX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBpKHRoaXMpfX0sdT1lK1wiIEl0ZXJhdG9yXCIsZj0hMSxwPXQucHJvdG90eXBlLHY9cFtHZV18fHBbXCJAQGl0ZXJhdG9yXCJdfHxuJiZwW25dLGc9IVhlJiZ2fHxsKG4pLHk9XCJBcnJheVwiPT1lJiZwLmVudHJpZXN8fHY7aWYoeSYmKGE9aWUoeS5jYWxsKG5ldyB0KSksWWUhPT1PYmplY3QucHJvdG90eXBlJiZhLm5leHQmJihMZShhLHUsITAsITApLEhlW3VdPVplKSksbj09JGUmJnYmJnYubmFtZSE9PSRlJiYoZj0hMCxnPWZ1bmN0aW9uKCl7cmV0dXJuIHYuY2FsbCh0aGlzKX0pLHMmJnBbR2VdIT09ZyYmSChwLEdlLGcpLEhlW2VdPWcsbilpZihoPXt2YWx1ZXM6bCgkZSksa2V5czpyP2c6bChLZSksZW50cmllczpsKFFlKX0scylmb3IoZCBpbiBoKShYZXx8Znx8IShkIGluIHApKSYmVWUocCxkLGhbZF0pO2Vsc2UgcSh7dGFyZ2V0OmUscHJvdG86ITAsZm9yY2VkOlhlfHxmfSxoKTtyZXR1cm4gaH0sdGk9VHQuY2hhckF0LGVpPVwiU3RyaW5nIEl0ZXJhdG9yXCIsaWk9WnQuc2V0LG9pPVp0LmdldHRlckZvcihlaSk7SmUoU3RyaW5nLFwiU3RyaW5nXCIsKGZ1bmN0aW9uKHQpe2lpKHRoaXMse3R5cGU6ZWksc3RyaW5nOlN0cmluZyh0KSxpbmRleDowfSl9KSwoZnVuY3Rpb24oKXt2YXIgdCxlPW9pKHRoaXMpLGk9ZS5zdHJpbmcsbz1lLmluZGV4O3JldHVybiBvPj1pLmxlbmd0aD97dmFsdWU6dm9pZCAwLGRvbmU6ITB9Oih0PXRpKGksbyksZS5pbmRleCs9dC5sZW5ndGgse3ZhbHVlOnQsZG9uZTohMX0pfSkpO3ZhciBuaT1mdW5jdGlvbih0KXt2YXIgZT10LnJldHVybjtpZih2b2lkIDAhPT1lKXJldHVybiBSKGUuY2FsbCh0KSkudmFsdWV9LHJpPWZ1bmN0aW9uKHQsZSxpLG8pe3RyeXtyZXR1cm4gbz9lKFIoaSlbMF0saVsxXSk6ZShpKX1jYXRjaChlKXt0aHJvdyBuaSh0KSxlfX0sc2k9YmUoXCJpdGVyYXRvclwiKSxhaT1BcnJheS5wcm90b3R5cGUsaGk9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXQmJihIZS5BcnJheT09PXR8fGFpW3NpXT09PXQpfSxkaT1mdW5jdGlvbih0LGUsaSl7dmFyIG89YihlKTtvIGluIHQ/TC5mKHQsbyxjKDAsaSkpOnRbb109aX0sbGk9YmUoXCJpdGVyYXRvclwiKSxjaT1mdW5jdGlvbih0KXtpZihudWxsIT10KXJldHVybiB0W2xpXXx8dFtcIkBAaXRlcmF0b3JcIl18fEhlW05lKHQpXX0sdWk9YmUoXCJpdGVyYXRvclwiKSxmaT0hMTt0cnl7dmFyIHBpPTAsdmk9e25leHQ6ZnVuY3Rpb24oKXtyZXR1cm57ZG9uZTohIXBpKyt9fSxyZXR1cm46ZnVuY3Rpb24oKXtmaT0hMH19O3ZpW3VpXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxBcnJheS5mcm9tKHZpLChmdW5jdGlvbigpe3Rocm93IDJ9KSl9Y2F0Y2godCl7fXZhciBnaT0hZnVuY3Rpb24odCxlKXtpZighZSYmIWZpKXJldHVybiExO3ZhciBpPSExO3RyeXt2YXIgbz17fTtvW3VpXT1mdW5jdGlvbigpe3JldHVybntuZXh0OmZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6aT0hMH19fX0sdChvKX1jYXRjaCh0KXt9cmV0dXJuIGl9KChmdW5jdGlvbih0KXtBcnJheS5mcm9tKHQpfSkpO3Eoe3RhcmdldDpcIkFycmF5XCIsc3RhdDohMCxmb3JjZWQ6Z2l9LHtmcm9tOmZ1bmN0aW9uKHQpe3ZhciBlLGksbyxuLHIscyxhPWF0KHQpLGg9XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcz90aGlzOkFycmF5LGQ9YXJndW1lbnRzLmxlbmd0aCxsPWQ+MT9hcmd1bWVudHNbMV06dm9pZCAwLGM9dm9pZCAwIT09bCx1PWNpKGEpLGY9MDtpZihjJiYobD1BKGwsZD4yP2FyZ3VtZW50c1syXTp2b2lkIDAsMikpLG51bGw9PXV8fGg9PUFycmF5JiZoaSh1KSlmb3IoaT1uZXcgaChlPUsoYS5sZW5ndGgpKTtlPmY7ZisrKXM9Yz9sKGFbZl0sZik6YVtmXSxkaShpLGYscyk7ZWxzZSBmb3Iocj0obj11LmNhbGwoYSkpLm5leHQsaT1uZXcgaDshKG89ci5jYWxsKG4pKS5kb25lO2YrKylzPWM/cmkobixsLFtvLnZhbHVlLGZdLCEwKTpvLnZhbHVlLGRpKGksZixzKTtyZXR1cm4gaS5sZW5ndGg9ZixpfX0pO3ZhciB5aT1GLkFycmF5LmZyb20sbWk9eWksYmk9XCJBcnJheSBJdGVyYXRvclwiLHdpPVp0LnNldCxraT1adC5nZXR0ZXJGb3IoYmkpO0plKEFycmF5LFwiQXJyYXlcIiwoZnVuY3Rpb24odCxlKXt3aSh0aGlzLHt0eXBlOmJpLHRhcmdldDp5KHQpLGluZGV4OjAsa2luZDplfSl9KSwoZnVuY3Rpb24oKXt2YXIgdD1raSh0aGlzKSxlPXQudGFyZ2V0LGk9dC5raW5kLG89dC5pbmRleCsrO3JldHVybiFlfHxvPj1lLmxlbmd0aD8odC50YXJnZXQ9dm9pZCAwLHt2YWx1ZTp2b2lkIDAsZG9uZTohMH0pOlwia2V5c1wiPT1pP3t2YWx1ZTpvLGRvbmU6ITF9OlwidmFsdWVzXCI9PWk/e3ZhbHVlOmVbb10sZG9uZTohMX06e3ZhbHVlOltvLGVbb11dLGRvbmU6ITF9fSksXCJ2YWx1ZXNcIiksSGUuQXJndW1lbnRzPUhlLkFycmF5O3ZhciBfaT1iZShcInRvU3RyaW5nVGFnXCIpO2Zvcih2YXIgeGkgaW57Q1NTUnVsZUxpc3Q6MCxDU1NTdHlsZURlY2xhcmF0aW9uOjAsQ1NTVmFsdWVMaXN0OjAsQ2xpZW50UmVjdExpc3Q6MCxET01SZWN0TGlzdDowLERPTVN0cmluZ0xpc3Q6MCxET01Ub2tlbkxpc3Q6MSxEYXRhVHJhbnNmZXJJdGVtTGlzdDowLEZpbGVMaXN0OjAsSFRNTEFsbENvbGxlY3Rpb246MCxIVE1MQ29sbGVjdGlvbjowLEhUTUxGb3JtRWxlbWVudDowLEhUTUxTZWxlY3RFbGVtZW50OjAsTWVkaWFMaXN0OjAsTWltZVR5cGVBcnJheTowLE5hbWVkTm9kZU1hcDowLE5vZGVMaXN0OjEsUGFpbnRSZXF1ZXN0TGlzdDowLFBsdWdpbjowLFBsdWdpbkFycmF5OjAsU1ZHTGVuZ3RoTGlzdDowLFNWR051bWJlckxpc3Q6MCxTVkdQYXRoU2VnTGlzdDowLFNWR1BvaW50TGlzdDowLFNWR1N0cmluZ0xpc3Q6MCxTVkdUcmFuc2Zvcm1MaXN0OjAsU291cmNlQnVmZmVyTGlzdDowLFN0eWxlU2hlZXRMaXN0OjAsVGV4dFRyYWNrQ3VlTGlzdDowLFRleHRUcmFja0xpc3Q6MCxUb3VjaExpc3Q6MH0pe3ZhciBFaT1yW3hpXSxPaT1FaSYmRWkucHJvdG90eXBlO09pJiZOZShPaSkhPT1faSYmSChPaSxfaSx4aSksSGVbeGldPUhlLkFycmF5fXZhciBDaT1jaSxTaT1mdW5jdGlvbih0KXt2YXIgZT1jaSh0KTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IFR5cGVFcnJvcihTdHJpbmcodCkrXCIgaXMgbm90IGl0ZXJhYmxlXCIpO3JldHVybiBSKGUuY2FsbCh0KSl9LFRpPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKHQpe3JldHVyblwiQXJyYXlcIj09Zih0KX0sTWk9bnQuY29uY2F0KFwibGVuZ3RoXCIsXCJwcm90b3R5cGVcIiksUGk9e2Y6T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXN8fGZ1bmN0aW9uKHQpe3JldHVybiBvdCh0LE1pKX19LERpPVBpLmYsQmk9e30udG9TdHJpbmcsSWk9XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyYmd2luZG93JiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz9PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpOltdLHppPXtmOmZ1bmN0aW9uKHQpe3JldHVybiBJaSYmXCJbb2JqZWN0IFdpbmRvd11cIj09QmkuY2FsbCh0KT9mdW5jdGlvbih0KXt0cnl7cmV0dXJuIERpKHQpfWNhdGNoKHQpe3JldHVybiBJaS5zbGljZSgpfX0odCk6RGkoeSh0KSl9fSxGaT17ZjpiZX0sTmk9TC5mLEFpPWZ1bmN0aW9uKHQpe3ZhciBlPUYuU3ltYm9sfHwoRi5TeW1ib2w9e30pO2soZSx0KXx8TmkoZSx0LHt2YWx1ZTpGaS5mKHQpfSl9LFJpPWJlKFwic3BlY2llc1wiKSxqaT1mdW5jdGlvbih0LGUpe3ZhciBpO3JldHVybiBUaSh0KSYmKFwiZnVuY3Rpb25cIiE9dHlwZW9mKGk9dC5jb25zdHJ1Y3Rvcil8fGkhPT1BcnJheSYmIVRpKGkucHJvdG90eXBlKT9tKGkpJiZudWxsPT09KGk9aVtSaV0pJiYoaT12b2lkIDApOmk9dm9pZCAwKSxuZXcodm9pZCAwPT09aT9BcnJheTppKSgwPT09ZT8wOmUpfSxMaT1bXS5wdXNoLEhpPWZ1bmN0aW9uKHQpe3ZhciBlPTE9PXQsaT0yPT10LG89Mz09dCxuPTQ9PXQscj02PT10LHM9Nz09dCxhPTU9PXR8fHI7cmV0dXJuIGZ1bmN0aW9uKGgsZCxsLGMpe2Zvcih2YXIgdSxmLHA9YXQoaCksZz12KHApLHk9QShkLGwsMyksbT1LKGcubGVuZ3RoKSxiPTAsdz1jfHxqaSxrPWU/dyhoLG0pOml8fHM/dyhoLDApOnZvaWQgMDttPmI7YisrKWlmKChhfHxiIGluIGcpJiYoZj15KHU9Z1tiXSxiLHApLHQpKWlmKGUpa1tiXT1mO2Vsc2UgaWYoZilzd2l0Y2godCl7Y2FzZSAzOnJldHVybiEwO2Nhc2UgNTpyZXR1cm4gdTtjYXNlIDY6cmV0dXJuIGI7Y2FzZSAyOkxpLmNhbGwoayx1KX1lbHNlIHN3aXRjaCh0KXtjYXNlIDQ6cmV0dXJuITE7Y2FzZSA3OkxpLmNhbGwoayx1KX1yZXR1cm4gcj8tMTpvfHxuP246a319LFdpPXtmb3JFYWNoOkhpKDApLG1hcDpIaSgxKSxmaWx0ZXI6SGkoMiksc29tZTpIaSgzKSxldmVyeTpIaSg0KSxmaW5kOkhpKDUpLGZpbmRJbmRleDpIaSg2KSxmaWx0ZXJPdXQ6SGkoNyl9LFZpPVdpLmZvckVhY2gscWk9VnQoXCJoaWRkZW5cIiksVWk9XCJTeW1ib2xcIixZaT1iZShcInRvUHJpbWl0aXZlXCIpLFhpPVp0LnNldCxHaT1adC5nZXR0ZXJGb3IoVWkpLEtpPU9iamVjdC5wcm90b3R5cGUsJGk9ci5TeW1ib2wsUWk9cmUoXCJKU09OXCIsXCJzdHJpbmdpZnlcIiksWmk9Uy5mLEppPUwuZix0bz16aS5mLGVvPWwuZixpbz1SdChcInN5bWJvbHNcIiksb289UnQoXCJvcC1zeW1ib2xzXCIpLG5vPVJ0KFwic3RyaW5nLXRvLXN5bWJvbC1yZWdpc3RyeVwiKSxybz1SdChcInN5bWJvbC10by1zdHJpbmctcmVnaXN0cnlcIiksc289UnQoXCJ3a3NcIiksYW89ci5RT2JqZWN0LGhvPSFhb3x8IWFvLnByb3RvdHlwZXx8IWFvLnByb3RvdHlwZS5maW5kQ2hpbGQsbG89YSYmcygoZnVuY3Rpb24oKXtyZXR1cm4gNyE9RGUoSmkoe30sXCJhXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBKaSh0aGlzLFwiYVwiLHt2YWx1ZTo3fSkuYX19KSkuYX0pKT9mdW5jdGlvbih0LGUsaSl7dmFyIG89WmkoS2ksZSk7byYmZGVsZXRlIEtpW2VdLEppKHQsZSxpKSxvJiZ0IT09S2kmJkppKEtpLGUsbyl9OkppLGNvPWZ1bmN0aW9uKHQsZSl7dmFyIGk9aW9bdF09RGUoJGkucHJvdG90eXBlKTtyZXR1cm4gWGkoaSx7dHlwZTpVaSx0YWc6dCxkZXNjcmlwdGlvbjplfSksYXx8KGkuZGVzY3JpcHRpb249ZSksaX0sdW89dmU/ZnVuY3Rpb24odCl7cmV0dXJuXCJzeW1ib2xcIj09dHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QodClpbnN0YW5jZW9mICRpfSxmbz1mdW5jdGlvbih0LGUsaSl7dD09PUtpJiZmbyhvbyxlLGkpLFIodCk7dmFyIG89YihlLCEwKTtyZXR1cm4gUihpKSxrKGlvLG8pPyhpLmVudW1lcmFibGU/KGsodCxxaSkmJnRbcWldW29dJiYodFtxaV1bb109ITEpLGk9RGUoaSx7ZW51bWVyYWJsZTpjKDAsITEpfSkpOihrKHQscWkpfHxKaSh0LHFpLGMoMSx7fSkpLHRbcWldW29dPSEwKSxsbyh0LG8saSkpOkppKHQsbyxpKX0scG89ZnVuY3Rpb24odCxlKXtSKHQpO3ZhciBpPXkoZSksbz1ydChpKS5jb25jYXQobW8oaSkpO3JldHVybiBWaShvLChmdW5jdGlvbihlKXthJiYhdm8uY2FsbChpLGUpfHxmbyh0LGUsaVtlXSl9KSksdH0sdm89ZnVuY3Rpb24odCl7dmFyIGU9Yih0LCEwKSxpPWVvLmNhbGwodGhpcyxlKTtyZXR1cm4hKHRoaXM9PT1LaSYmayhpbyxlKSYmIWsob28sZSkpJiYoIShpfHwhayh0aGlzLGUpfHwhayhpbyxlKXx8ayh0aGlzLHFpKSYmdGhpc1txaV1bZV0pfHxpKX0sZ289ZnVuY3Rpb24odCxlKXt2YXIgaT15KHQpLG89YihlLCEwKTtpZihpIT09S2l8fCFrKGlvLG8pfHxrKG9vLG8pKXt2YXIgbj1aaShpLG8pO3JldHVybiFufHwhayhpbyxvKXx8ayhpLHFpKSYmaVtxaV1bb118fChuLmVudW1lcmFibGU9ITApLG59fSx5bz1mdW5jdGlvbih0KXt2YXIgZT10byh5KHQpKSxpPVtdO3JldHVybiBWaShlLChmdW5jdGlvbih0KXtrKGlvLHQpfHxrKGV0LHQpfHxpLnB1c2godCl9KSksaX0sbW89ZnVuY3Rpb24odCl7dmFyIGU9dD09PUtpLGk9dG8oZT9vbzp5KHQpKSxvPVtdO3JldHVybiBWaShpLChmdW5jdGlvbih0KXshayhpbyx0KXx8ZSYmIWsoS2ksdCl8fG8ucHVzaChpb1t0XSl9KSksb307aWYocGV8fChVZSgoJGk9ZnVuY3Rpb24oKXtpZih0aGlzIGluc3RhbmNlb2YgJGkpdGhyb3cgVHlwZUVycm9yKFwiU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yXCIpO3ZhciB0PWFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9TdHJpbmcoYXJndW1lbnRzWzBdKTp2b2lkIDAsZT1IdCh0KSxpPWZ1bmN0aW9uKHQpe3RoaXM9PT1LaSYmaS5jYWxsKG9vLHQpLGsodGhpcyxxaSkmJmsodGhpc1txaV0sZSkmJih0aGlzW3FpXVtlXT0hMSksbG8odGhpcyxlLGMoMSx0KSl9O3JldHVybiBhJiZobyYmbG8oS2ksZSx7Y29uZmlndXJhYmxlOiEwLHNldDppfSksY28oZSx0KX0pLnByb3RvdHlwZSxcInRvU3RyaW5nXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEdpKHRoaXMpLnRhZ30pKSxVZSgkaSxcIndpdGhvdXRTZXR0ZXJcIiwoZnVuY3Rpb24odCl7cmV0dXJuIGNvKEh0KHQpLHQpfSkpLGwuZj12byxMLmY9Zm8sUy5mPWdvLFBpLmY9emkuZj15byxzdC5mPW1vLEZpLmY9ZnVuY3Rpb24odCl7cmV0dXJuIGNvKGJlKHQpLHQpfSxhJiZKaSgkaS5wcm90b3R5cGUsXCJkZXNjcmlwdGlvblwiLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEdpKHRoaXMpLmRlc2NyaXB0aW9ufX0pKSxxKHtnbG9iYWw6ITAsd3JhcDohMCxmb3JjZWQ6IXBlLHNoYW06IXBlfSx7U3ltYm9sOiRpfSksVmkocnQoc28pLChmdW5jdGlvbih0KXtBaSh0KX0pKSxxKHt0YXJnZXQ6VWksc3RhdDohMCxmb3JjZWQ6IXBlfSx7Zm9yOmZ1bmN0aW9uKHQpe3ZhciBlPVN0cmluZyh0KTtpZihrKG5vLGUpKXJldHVybiBub1tlXTt2YXIgaT0kaShlKTtyZXR1cm4gbm9bZV09aSxyb1tpXT1lLGl9LGtleUZvcjpmdW5jdGlvbih0KXtpZighdW8odCkpdGhyb3cgVHlwZUVycm9yKHQrXCIgaXMgbm90IGEgc3ltYm9sXCIpO2lmKGsocm8sdCkpcmV0dXJuIHJvW3RdfSx1c2VTZXR0ZXI6ZnVuY3Rpb24oKXtobz0hMH0sdXNlU2ltcGxlOmZ1bmN0aW9uKCl7aG89ITF9fSkscSh7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxmb3JjZWQ6IXBlLHNoYW06IWF9LHtjcmVhdGU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZT9EZSh0KTpwbyhEZSh0KSxlKX0sZGVmaW5lUHJvcGVydHk6Zm8sZGVmaW5lUHJvcGVydGllczpwbyxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6Z299KSxxKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDohcGV9LHtnZXRPd25Qcm9wZXJ0eU5hbWVzOnlvLGdldE93blByb3BlcnR5U3ltYm9sczptb30pLHEoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOnMoKGZ1bmN0aW9uKCl7c3QuZigxKX0pKX0se2dldE93blByb3BlcnR5U3ltYm9sczpmdW5jdGlvbih0KXtyZXR1cm4gc3QuZihhdCh0KSl9fSksUWkpe3ZhciBibz0hcGV8fHMoKGZ1bmN0aW9uKCl7dmFyIHQ9JGkoKTtyZXR1cm5cIltudWxsXVwiIT1RaShbdF0pfHxcInt9XCIhPVFpKHthOnR9KXx8XCJ7fVwiIT1RaShPYmplY3QodCkpfSkpO3Eoe3RhcmdldDpcIkpTT05cIixzdGF0OiEwLGZvcmNlZDpib30se3N0cmluZ2lmeTpmdW5jdGlvbih0LGUsaSl7Zm9yKHZhciBvLG49W3RdLHI9MTthcmd1bWVudHMubGVuZ3RoPnI7KW4ucHVzaChhcmd1bWVudHNbcisrXSk7aWYobz1lLChtKGUpfHx2b2lkIDAhPT10KSYmIXVvKHQpKXJldHVybiBUaShlKXx8KGU9ZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBvJiYoZT1vLmNhbGwodGhpcyx0LGUpKSwhdW8oZSkpcmV0dXJuIGV9KSxuWzFdPWUsUWkuYXBwbHkobnVsbCxuKX19KX0kaS5wcm90b3R5cGVbWWldfHxIKCRpLnByb3RvdHlwZSxZaSwkaS5wcm90b3R5cGUudmFsdWVPZiksTGUoJGksVWkpLGV0W3FpXT0hMDt2YXIgd289Ri5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLGtvPVMuZixfbz1zKChmdW5jdGlvbigpe2tvKDEpfSkpO3Eoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOiFhfHxfbyxzaGFtOiFhfSx7Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGtvKHkodCksZSl9fSk7dmFyIHhvPW8oKGZ1bmN0aW9uKHQpe3ZhciBlPUYuT2JqZWN0LGk9dC5leHBvcnRzPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIGUuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsaSl9O2UuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLnNoYW0mJihpLnNoYW09ITApfSkpLEVvPXhvLE9vPXJlKFwiUmVmbGVjdFwiLFwib3duS2V5c1wiKXx8ZnVuY3Rpb24odCl7dmFyIGU9UGkuZihSKHQpKSxpPXN0LmY7cmV0dXJuIGk/ZS5jb25jYXQoaSh0KSk6ZX07cSh7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxzaGFtOiFhfSx7Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczpmdW5jdGlvbih0KXtmb3IodmFyIGUsaSxvPXkodCksbj1TLmYscj1PbyhvKSxzPXt9LGE9MDtyLmxlbmd0aD5hOyl2b2lkIDAhPT0oaT1uKG8sZT1yW2ErK10pKSYmZGkocyxlLGkpO3JldHVybiBzfX0pO3ZhciBDbz1GLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO3Eoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOiFhLHNoYW06IWF9LHtkZWZpbmVQcm9wZXJ0aWVzOk9lfSk7dmFyIFNvPW8oKGZ1bmN0aW9uKHQpe3ZhciBlPUYuT2JqZWN0LGk9dC5leHBvcnRzPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIGUuZGVmaW5lUHJvcGVydGllcyh0LGkpfTtlLmRlZmluZVByb3BlcnRpZXMuc2hhbSYmKGkuc2hhbT0hMCl9KSk7cSh7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxmb3JjZWQ6IWEsc2hhbTohYX0se2RlZmluZVByb3BlcnR5OkwuZn0pO3ZhciBUbz1vKChmdW5jdGlvbih0KXt2YXIgZT1GLk9iamVjdCxpPXQuZXhwb3J0cz1mdW5jdGlvbih0LGksbyl7cmV0dXJuIGUuZGVmaW5lUHJvcGVydHkodCxpLG8pfTtlLmRlZmluZVByb3BlcnR5LnNoYW0mJihpLnNoYW09ITApfSkpLE1vPVRvO2Z1bmN0aW9uIFBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX12YXIgRG89VG87ZnVuY3Rpb24gQm8odCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG89ZVtpXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksRG8odCxvLmtleSxvKX19ZnVuY3Rpb24gSW8odCxlLGkpe3JldHVybiBlJiZCbyh0LnByb3RvdHlwZSxlKSxpJiZCbyh0LGkpLHR9ZnVuY3Rpb24gem8odCxlLGkpe3JldHVybiBlIGluIHQ/RG8odCxlLHt2YWx1ZTppLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1pLHR9cSh7dGFyZ2V0OlwiQXJyYXlcIixzdGF0OiEwfSx7aXNBcnJheTpUaX0pO3ZhciBGbz1GLkFycmF5LmlzQXJyYXksTm89Rm87dmFyIEFvPWJlKFwic3BlY2llc1wiKSxSbz1mdW5jdGlvbih0KXtyZXR1cm4gZmU+PTUxfHwhcygoZnVuY3Rpb24oKXt2YXIgZT1bXTtyZXR1cm4oZS5jb25zdHJ1Y3Rvcj17fSlbQW9dPWZ1bmN0aW9uKCl7cmV0dXJue2ZvbzoxfX0sMSE9PWVbdF0oQm9vbGVhbikuZm9vfSkpfSxqbz1iZShcImlzQ29uY2F0U3ByZWFkYWJsZVwiKSxMbz05MDA3MTk5MjU0NzQwOTkxLEhvPVwiTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkXCIsV289ZmU+PTUxfHwhcygoZnVuY3Rpb24oKXt2YXIgdD1bXTtyZXR1cm4gdFtqb109ITEsdC5jb25jYXQoKVswXSE9PXR9KSksVm89Um8oXCJjb25jYXRcIikscW89ZnVuY3Rpb24odCl7aWYoIW0odCkpcmV0dXJuITE7dmFyIGU9dFtqb107cmV0dXJuIHZvaWQgMCE9PWU/ISFlOlRpKHQpfTtxKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohV298fCFWb30se2NvbmNhdDpmdW5jdGlvbih0KXt2YXIgZSxpLG8sbixyLHM9YXQodGhpcyksYT1qaShzLDApLGg9MDtmb3IoZT0tMSxvPWFyZ3VtZW50cy5sZW5ndGg7ZTxvO2UrKylpZihxbyhyPS0xPT09ZT9zOmFyZ3VtZW50c1tlXSkpe2lmKGgrKG49SyhyLmxlbmd0aCkpPkxvKXRocm93IFR5cGVFcnJvcihIbyk7Zm9yKGk9MDtpPG47aSsrLGgrKylpIGluIHImJmRpKGEsaCxyW2ldKX1lbHNle2lmKGg+PUxvKXRocm93IFR5cGVFcnJvcihIbyk7ZGkoYSxoKysscil9cmV0dXJuIGEubGVuZ3RoPWgsYX19KSxBaShcImFzeW5jSXRlcmF0b3JcIiksQWkoXCJoYXNJbnN0YW5jZVwiKSxBaShcImlzQ29uY2F0U3ByZWFkYWJsZVwiKSxBaShcIml0ZXJhdG9yXCIpLEFpKFwibWF0Y2hcIiksQWkoXCJtYXRjaEFsbFwiKSxBaShcInJlcGxhY2VcIiksQWkoXCJzZWFyY2hcIiksQWkoXCJzcGVjaWVzXCIpLEFpKFwic3BsaXRcIiksQWkoXCJ0b1ByaW1pdGl2ZVwiKSxBaShcInRvU3RyaW5nVGFnXCIpLEFpKFwidW5zY29wYWJsZXNcIiksTGUoci5KU09OLFwiSlNPTlwiLCEwKTt2YXIgVW89Ri5TeW1ib2w7QWkoXCJhc3luY0Rpc3Bvc2VcIiksQWkoXCJkaXNwb3NlXCIpLEFpKFwib2JzZXJ2YWJsZVwiKSxBaShcInBhdHRlcm5NYXRjaFwiKSxBaShcInJlcGxhY2VBbGxcIik7dmFyIFlvPVVvLFhvPWJlKFwiaXRlcmF0b3JcIiksR289ZnVuY3Rpb24odCl7dmFyIGU9T2JqZWN0KHQpO3JldHVybiB2b2lkIDAhPT1lW1hvXXx8XCJAQGl0ZXJhdG9yXCJpbiBlfHxIZS5oYXNPd25Qcm9wZXJ0eShOZShlKSl9O3ZhciBLbz1SbyhcInNsaWNlXCIpLCRvPWJlKFwic3BlY2llc1wiKSxRbz1bXS5zbGljZSxabz1NYXRoLm1heDtxKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohS299LHtzbGljZTpmdW5jdGlvbih0LGUpe3ZhciBpLG8sbixyPXkodGhpcykscz1LKHIubGVuZ3RoKSxhPVoodCxzKSxoPVoodm9pZCAwPT09ZT9zOmUscyk7aWYoVGkocikmJihcImZ1bmN0aW9uXCIhPXR5cGVvZihpPXIuY29uc3RydWN0b3IpfHxpIT09QXJyYXkmJiFUaShpLnByb3RvdHlwZSk/bShpKSYmbnVsbD09PShpPWlbJG9dKSYmKGk9dm9pZCAwKTppPXZvaWQgMCxpPT09QXJyYXl8fHZvaWQgMD09PWkpKXJldHVybiBRby5jYWxsKHIsYSxoKTtmb3Iobz1uZXcodm9pZCAwPT09aT9BcnJheTppKShabyhoLWEsMCkpLG49MDthPGg7YSsrLG4rKylhIGluIHImJmRpKG8sbixyW2FdKTtyZXR1cm4gby5sZW5ndGg9bixvfX0pO3ZhciBKbz1ndChcIkFycmF5XCIpLnNsaWNlLHRuPUFycmF5LnByb3RvdHlwZSxlbj1mdW5jdGlvbih0KXt2YXIgZT10LnNsaWNlO3JldHVybiB0PT09dG58fHQgaW5zdGFuY2VvZiBBcnJheSYmZT09PXRuLnNsaWNlP0pvOmV9LG9uPWVuLG5uPXlpO2Z1bmN0aW9uIHJuKHQsZSl7KG51bGw9PWV8fGU+dC5sZW5ndGgpJiYoZT10Lmxlbmd0aCk7Zm9yKHZhciBpPTAsbz1uZXcgQXJyYXkoZSk7aTxlO2krKylvW2ldPXRbaV07cmV0dXJuIG99ZnVuY3Rpb24gc24odCxlKXt2YXIgaTtpZih0KXtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gcm4odCxlKTt2YXIgbz1vbihpPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkuY2FsbChpLDgsLTEpO3JldHVyblwiT2JqZWN0XCI9PT1vJiZ0LmNvbnN0cnVjdG9yJiYobz10LmNvbnN0cnVjdG9yLm5hbWUpLFwiTWFwXCI9PT1vfHxcIlNldFwiPT09bz9ubih0KTpcIkFyZ3VtZW50c1wiPT09b3x8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3Qobyk/cm4odCxlKTp2b2lkIDB9fWZ1bmN0aW9uIGFuKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKE5vKHQpKXJldHVybiB0fSh0KXx8ZnVuY3Rpb24odCxlKXtpZih2b2lkIDAhPT1ZbyYmR28oT2JqZWN0KHQpKSl7dmFyIGk9W10sbz0hMCxuPSExLHI9dm9pZCAwO3RyeXtmb3IodmFyIHMsYT1TaSh0KTshKG89KHM9YS5uZXh0KCkpLmRvbmUpJiYoaS5wdXNoKHMudmFsdWUpLCFlfHxpLmxlbmd0aCE9PWUpO289ITApO31jYXRjaCh0KXtuPSEwLHI9dH1maW5hbGx5e3RyeXtvfHxudWxsPT1hLnJldHVybnx8YS5yZXR1cm4oKX1maW5hbGx5e2lmKG4pdGhyb3cgcn19cmV0dXJuIGl9fSh0LGUpfHxzbih0LGUpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCl9dmFyIGhuPUZpLmYoXCJpdGVyYXRvclwiKTtmdW5jdGlvbiBkbih0KXtyZXR1cm4oZG49XCJmdW5jdGlvblwiPT10eXBlb2YgWW8mJlwic3ltYm9sXCI9PXR5cGVvZiBobj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBZbyYmdC5jb25zdHJ1Y3Rvcj09PVlvJiZ0IT09WW8ucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1mdW5jdGlvbiBsbih0KXtyZXR1cm4gZnVuY3Rpb24odCl7aWYoTm8odCkpcmV0dXJuIHJuKHQpfSh0KXx8ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09WW8mJkdvKE9iamVjdCh0KSkpcmV0dXJuIG5uKHQpfSh0KXx8c24odCl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCl9dmFyIGNuPVVvLHVuPWd0KFwiQXJyYXlcIikuY29uY2F0LGZuPUFycmF5LnByb3RvdHlwZSxwbj1mdW5jdGlvbih0KXt2YXIgZT10LmNvbmNhdDtyZXR1cm4gdD09PWZufHx0IGluc3RhbmNlb2YgQXJyYXkmJmU9PT1mbi5jb25jYXQ/dW46ZX0sdm49ZW47cSh7dGFyZ2V0OlwiUmVmbGVjdFwiLHN0YXQ6ITB9LHtvd25LZXlzOk9vfSksRi5SZWZsZWN0Lm93bktleXM7dmFyIGduPUZvLHluPVdpLm1hcCxtbj1SbyhcIm1hcFwiKTtxKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohbW59LHttYXA6ZnVuY3Rpb24odCl7cmV0dXJuIHluKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSk7dmFyIGJuPWd0KFwiQXJyYXlcIikubWFwLHduPUFycmF5LnByb3RvdHlwZSxrbj1mdW5jdGlvbih0KXt2YXIgZT10Lm1hcDtyZXR1cm4gdD09PXdufHx0IGluc3RhbmNlb2YgQXJyYXkmJmU9PT13bi5tYXA/Ym46ZX0sX249cygoZnVuY3Rpb24oKXtydCgxKX0pKTtxKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDpfbn0se2tleXM6ZnVuY3Rpb24odCl7cmV0dXJuIHJ0KGF0KHQpKX19KTt2YXIgeG49Ri5PYmplY3Qua2V5cztxKHt0YXJnZXQ6XCJEYXRlXCIsc3RhdDohMH0se25vdzpmdW5jdGlvbigpe3JldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpfX0pO3ZhciBFbj1GLkRhdGUubm93LE9uPWZ1bmN0aW9uKHQsZSl7dmFyIGk9W11bdF07cmV0dXJuISFpJiZzKChmdW5jdGlvbigpe2kuY2FsbChudWxsLGV8fGZ1bmN0aW9uKCl7dGhyb3cgMX0sMSl9KSl9LENuPVdpLmZvckVhY2gsU249T24oXCJmb3JFYWNoXCIpP1tdLmZvckVhY2g6ZnVuY3Rpb24odCl7cmV0dXJuIENuKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9O3Eoe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOltdLmZvckVhY2ghPVNufSx7Zm9yRWFjaDpTbn0pO3ZhciBUbj1ndChcIkFycmF5XCIpLmZvckVhY2gsTW49QXJyYXkucHJvdG90eXBlLFBuPXtET01Ub2tlbkxpc3Q6ITAsTm9kZUxpc3Q6ITB9LERuPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZm9yRWFjaDtyZXR1cm4gdD09PU1ufHx0IGluc3RhbmNlb2YgQXJyYXkmJmU9PT1Nbi5mb3JFYWNofHxQbi5oYXNPd25Qcm9wZXJ0eShOZSh0KSk/VG46ZX0sQm49W10ucmV2ZXJzZSxJbj1bMSwyXTtxKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDpTdHJpbmcoSW4pPT09U3RyaW5nKEluLnJldmVyc2UoKSl9LHtyZXZlcnNlOmZ1bmN0aW9uKCl7cmV0dXJuIFRpKHRoaXMpJiYodGhpcy5sZW5ndGg9dGhpcy5sZW5ndGgpLEJuLmNhbGwodGhpcyl9fSk7dmFyIHpuPWd0KFwiQXJyYXlcIikucmV2ZXJzZSxGbj1BcnJheS5wcm90b3R5cGUsTm49ZnVuY3Rpb24odCl7dmFyIGU9dC5yZXZlcnNlO3JldHVybiB0PT09Rm58fHQgaW5zdGFuY2VvZiBBcnJheSYmZT09PUZuLnJldmVyc2U/em46ZX0sQW49Um8oXCJzcGxpY2VcIiksUm49TWF0aC5tYXgsam49TWF0aC5taW4sTG49OTAwNzE5OTI1NDc0MDk5MSxIbj1cIk1heGltdW0gYWxsb3dlZCBsZW5ndGggZXhjZWVkZWRcIjtxKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohQW59LHtzcGxpY2U6ZnVuY3Rpb24odCxlKXt2YXIgaSxvLG4scixzLGEsaD1hdCh0aGlzKSxkPUsoaC5sZW5ndGgpLGw9Wih0LGQpLGM9YXJndW1lbnRzLmxlbmd0aDtpZigwPT09Yz9pPW89MDoxPT09Yz8oaT0wLG89ZC1sKTooaT1jLTIsbz1qbihSbihYKGUpLDApLGQtbCkpLGQraS1vPkxuKXRocm93IFR5cGVFcnJvcihIbik7Zm9yKG49amkoaCxvKSxyPTA7cjxvO3IrKykocz1sK3IpaW4gaCYmZGkobixyLGhbc10pO2lmKG4ubGVuZ3RoPW8saTxvKXtmb3Iocj1sO3I8ZC1vO3IrKylhPXIraSwocz1yK28paW4gaD9oW2FdPWhbc106ZGVsZXRlIGhbYV07Zm9yKHI9ZDtyPmQtbytpO3ItLSlkZWxldGUgaFtyLTFdfWVsc2UgaWYoaT5vKWZvcihyPWQtbztyPmw7ci0tKWE9citpLTEsKHM9citvLTEpaW4gaD9oW2FdPWhbc106ZGVsZXRlIGhbYV07Zm9yKHI9MDtyPGk7cisrKWhbcitsXT1hcmd1bWVudHNbcisyXTtyZXR1cm4gaC5sZW5ndGg9ZC1vK2ksbn19KTt2YXIgV249Z3QoXCJBcnJheVwiKS5zcGxpY2UsVm49QXJyYXkucHJvdG90eXBlLHFuPWZ1bmN0aW9uKHQpe3ZhciBlPXQuc3BsaWNlO3JldHVybiB0PT09Vm58fHQgaW5zdGFuY2VvZiBBcnJheSYmZT09PVZuLnNwbGljZT9XbjplfSxVbj10dC5pbmNsdWRlcztxKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwfSx7aW5jbHVkZXM6ZnVuY3Rpb24odCl7cmV0dXJuIFVuKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSk7dmFyIFluPWd0KFwiQXJyYXlcIikuaW5jbHVkZXMsWG49YmUoXCJtYXRjaFwiKSxHbj1mdW5jdGlvbih0KXtpZihmdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gbSh0KSYmKHZvaWQgMCE9PShlPXRbWG5dKT8hIWU6XCJSZWdFeHBcIj09Zih0KSl9KHQpKXRocm93IFR5cGVFcnJvcihcIlRoZSBtZXRob2QgZG9lc24ndCBhY2NlcHQgcmVndWxhciBleHByZXNzaW9uc1wiKTtyZXR1cm4gdH0sS249YmUoXCJtYXRjaFwiKTtxKHt0YXJnZXQ6XCJTdHJpbmdcIixwcm90bzohMCxmb3JjZWQ6IWZ1bmN0aW9uKHQpe3ZhciBlPS8uLzt0cnl7XCIvLi9cIlt0XShlKX1jYXRjaChpKXt0cnl7cmV0dXJuIGVbS25dPSExLFwiLy4vXCJbdF0oZSl9Y2F0Y2godCl7fX1yZXR1cm4hMX0oXCJpbmNsdWRlc1wiKX0se2luY2x1ZGVzOmZ1bmN0aW9uKHQpe3JldHVybiEhflN0cmluZyhnKHRoaXMpKS5pbmRleE9mKEduKHQpLGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19KTt2YXIgJG49Z3QoXCJTdHJpbmdcIikuaW5jbHVkZXMsUW49QXJyYXkucHJvdG90eXBlLFpuPVN0cmluZy5wcm90b3R5cGUsSm49ZnVuY3Rpb24odCl7dmFyIGU9dC5pbmNsdWRlcztyZXR1cm4gdD09PVFufHx0IGluc3RhbmNlb2YgQXJyYXkmJmU9PT1Rbi5pbmNsdWRlcz9ZbjpcInN0cmluZ1wiPT10eXBlb2YgdHx8dD09PVpufHx0IGluc3RhbmNlb2YgU3RyaW5nJiZlPT09Wm4uaW5jbHVkZXM/JG46ZX0sdHI9cygoZnVuY3Rpb24oKXtpZSgxKX0pKTtxKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDp0cixzaGFtOiFKdH0se2dldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3JldHVybiBpZShhdCh0KSl9fSk7dmFyIGVyPUYuT2JqZWN0LmdldFByb3RvdHlwZU9mLGlyPWVyLG9yPVdpLmZpbHRlcixucj1SbyhcImZpbHRlclwiKTtxKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohbnJ9LHtmaWx0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIG9yKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSk7dmFyIHJyPWd0KFwiQXJyYXlcIikuZmlsdGVyLHNyPUFycmF5LnByb3RvdHlwZSxhcj1mdW5jdGlvbih0KXt2YXIgZT10LmZpbHRlcjtyZXR1cm4gdD09PXNyfHx0IGluc3RhbmNlb2YgQXJyYXkmJmU9PT1zci5maWx0ZXI/cnI6ZX0saHI9bC5mLGRyPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtmb3IodmFyIGksbz15KGUpLG49cnQobykscj1uLmxlbmd0aCxzPTAsaD1bXTtyPnM7KWk9bltzKytdLGEmJiFoci5jYWxsKG8saSl8fGgucHVzaCh0P1tpLG9baV1dOm9baV0pO3JldHVybiBofX0sbHI9e2VudHJpZXM6ZHIoITApLHZhbHVlczpkcighMSl9LnZhbHVlcztxKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwfSx7dmFsdWVzOmZ1bmN0aW9uKHQpe3JldHVybiBscih0KX19KSxGLk9iamVjdC52YWx1ZXM7dmFyIGNyPVwiXFx0XFxuXFx2XFxmXFxyIMKg4ZqA4oCA4oCB4oCC4oCD4oCE4oCF4oCG4oCH4oCI4oCJ4oCK4oCv4oGf44CAXFx1MjAyOFxcdTIwMjlcXHVmZWZmXCIsdXI9XCJbXCIrY3IrXCJdXCIsZnI9UmVnRXhwKFwiXlwiK3VyK3VyK1wiKlwiKSxwcj1SZWdFeHAodXIrdXIrXCIqJFwiKSx2cj1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIGk9U3RyaW5nKGcoZSkpO3JldHVybiAxJnQmJihpPWkucmVwbGFjZShmcixcIlwiKSksMiZ0JiYoaT1pLnJlcGxhY2UocHIsXCJcIikpLGl9fSxncj17c3RhcnQ6dnIoMSksZW5kOnZyKDIpLHRyaW06dnIoMyl9LHlyPWdyLnRyaW0sbXI9ci5wYXJzZUludCxicj0vXlsrLV0/MFtYeF0vLHdyPTghPT1tcihjcitcIjA4XCIpfHwyMiE9PW1yKGNyK1wiMHgxNlwiKT9mdW5jdGlvbih0LGUpe3ZhciBpPXlyKFN0cmluZyh0KSk7cmV0dXJuIG1yKGksZT4+PjB8fChici50ZXN0KGkpPzE2OjEwKSl9Om1yO3Eoe2dsb2JhbDohMCxmb3JjZWQ6cGFyc2VJbnQhPXdyfSx7cGFyc2VJbnQ6d3J9KTt2YXIga3I9Ri5wYXJzZUludCxfcj10dC5pbmRleE9mLHhyPVtdLmluZGV4T2YsRXI9ISF4ciYmMS9bMV0uaW5kZXhPZigxLC0wKTwwLE9yPU9uKFwiaW5kZXhPZlwiKTtxKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDpFcnx8IU9yfSx7aW5kZXhPZjpmdW5jdGlvbih0KXtyZXR1cm4gRXI/eHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfHwwOl9yKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSk7dmFyIENyLFNyPWd0KFwiQXJyYXlcIikuaW5kZXhPZixUcj1BcnJheS5wcm90b3R5cGUsTXI9ZnVuY3Rpb24odCl7dmFyIGU9dC5pbmRleE9mO3JldHVybiB0PT09VHJ8fHQgaW5zdGFuY2VvZiBBcnJheSYmZT09PVRyLmluZGV4T2Y/U3I6ZX0sUHI9Z3IudHJpbTtxKHt0YXJnZXQ6XCJTdHJpbmdcIixwcm90bzohMCxmb3JjZWQ6KENyPVwidHJpbVwiLHMoKGZ1bmN0aW9uKCl7cmV0dXJuISFjcltDcl0oKXx8XCLigIvCheGgjlwiIT1cIuKAi8KF4aCOXCJbQ3JdKCl8fGNyW0NyXS5uYW1lIT09Q3J9KSkpfSx7dHJpbTpmdW5jdGlvbigpe3JldHVybiBQcih0aGlzKX19KSxndChcIlN0cmluZ1wiKS50cmltLHEoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsc2hhbTohYX0se2NyZWF0ZTpEZX0pO3ZhciBEcj1GLk9iamVjdCxCcj1mdW5jdGlvbih0LGUpe3JldHVybiBEci5jcmVhdGUodCxlKX0sSXI9QnIsenI9cmUoXCJKU09OXCIsXCJzdHJpbmdpZnlcIiksRnI9L1tcXHVEODAwLVxcdURGRkZdL2csTnI9L15bXFx1RDgwMC1cXHVEQkZGXSQvLEFyPS9eW1xcdURDMDAtXFx1REZGRl0kLyxScj1mdW5jdGlvbih0LGUsaSl7dmFyIG89aS5jaGFyQXQoZS0xKSxuPWkuY2hhckF0KGUrMSk7cmV0dXJuIE5yLnRlc3QodCkmJiFBci50ZXN0KG4pfHxBci50ZXN0KHQpJiYhTnIudGVzdChvKT9cIlxcXFx1XCIrdC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTp0fSxqcj1zKChmdW5jdGlvbigpe3JldHVybidcIlxcXFx1ZGYwNlxcXFx1ZDgzNFwiJyE9PXpyKFwiXFx1ZGYwNlxcdWQ4MzRcIil8fCdcIlxcXFx1ZGVhZFwiJyE9PXpyKFwiXFx1ZGVhZFwiKX0pKTt6ciYmcSh7dGFyZ2V0OlwiSlNPTlwiLHN0YXQ6ITAsZm9yY2VkOmpyfSx7c3RyaW5naWZ5OmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz16ci5hcHBseShudWxsLGFyZ3VtZW50cyk7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIG8/by5yZXBsYWNlKEZyLFJyKTpvfX0pLEYuSlNPTnx8KEYuSlNPTj17c3RyaW5naWZ5OkpTT04uc3RyaW5naWZ5fSk7dmFyIExyPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gRi5KU09OLnN0cmluZ2lmeS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEhyPVtdLnNsaWNlLFdyPS9NU0lFIC5cXC4vLnRlc3Qoc2UpLFZyPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLGkpe3ZhciBvPWFyZ3VtZW50cy5sZW5ndGg+MixuPW8/SHIuY2FsbChhcmd1bWVudHMsMik6dm9pZCAwO3JldHVybiB0KG8/ZnVuY3Rpb24oKXsoXCJmdW5jdGlvblwiPT10eXBlb2YgZT9lOkZ1bmN0aW9uKGUpKS5hcHBseSh0aGlzLG4pfTplLGkpfX07cSh7Z2xvYmFsOiEwLGJpbmQ6ITAsZm9yY2VkOldyfSx7c2V0VGltZW91dDpWcihyLnNldFRpbWVvdXQpLHNldEludGVydmFsOlZyKHIuc2V0SW50ZXJ2YWwpfSk7dmFyIHFyPUYuc2V0VGltZW91dDtxKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwfSx7ZmlsbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9YXQodGhpcyksaT1LKGUubGVuZ3RoKSxvPWFyZ3VtZW50cy5sZW5ndGgsbj1aKG8+MT9hcmd1bWVudHNbMV06dm9pZCAwLGkpLHI9bz4yP2FyZ3VtZW50c1syXTp2b2lkIDAscz12b2lkIDA9PT1yP2k6WihyLGkpO3M+bjspZVtuKytdPXQ7cmV0dXJuIGV9fSk7dmFyIFVyPWd0KFwiQXJyYXlcIikuZmlsbCxZcj1BcnJheS5wcm90b3R5cGUsWHI9ZnVuY3Rpb24odCl7dmFyIGU9dC5maWxsO3JldHVybiB0PT09WXJ8fHQgaW5zdGFuY2VvZiBBcnJheSYmZT09PVlyLmZpbGw/VXI6ZX07XG4vKiEgSGFtbWVyLkpTIC0gdjIuMC4xNy1yYyAtIDIwMTktMTItMTZcblx0ICogaHR0cDovL25hdmVyLmdpdGh1Yi5pby9lZ2pzXG5cdCAqXG5cdCAqIEZvcmtlZCBCeSBOYXZlciBlZ2pzXG5cdCAqIENvcHlyaWdodCAoYykgaGFtbWVyanNcblx0ICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlICovXG5mdW5jdGlvbiBHcigpe3JldHVybihHcj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgaT1hcmd1bWVudHNbZV07Zm9yKHZhciBvIGluIGkpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGksbykmJih0W29dPWlbb10pfXJldHVybiB0fSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIEtyKHQsZSl7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSksdC5wcm90b3R5cGUuY29uc3RydWN0b3I9dCx0Ll9fcHJvdG9fXz1lfWZ1bmN0aW9uICRyKHQpe2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiB0fXZhciBRcixacj1cImZ1bmN0aW9uXCIhPXR5cGVvZiBPYmplY3QuYXNzaWduP2Z1bmN0aW9uKHQpe2lmKG51bGw9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdFwiKTtmb3IodmFyIGU9T2JqZWN0KHQpLGk9MTtpPGFyZ3VtZW50cy5sZW5ndGg7aSsrKXt2YXIgbz1hcmd1bWVudHNbaV07aWYobnVsbCE9bylmb3IodmFyIG4gaW4gbylvLmhhc093blByb3BlcnR5KG4pJiYoZVtuXT1vW25dKX1yZXR1cm4gZX06T2JqZWN0LmFzc2lnbixKcj1bXCJcIixcIndlYmtpdFwiLFwiTW96XCIsXCJNU1wiLFwibXNcIixcIm9cIl0sdHM9XCJ1bmRlZmluZWRcIj09dHlwZW9mIGRvY3VtZW50P3tzdHlsZTp7fX06ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxlcz1NYXRoLnJvdW5kLGlzPU1hdGguYWJzLG9zPURhdGUubm93O2Z1bmN0aW9uIG5zKHQsZSl7Zm9yKHZhciBpLG8sbj1lWzBdLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSxyPTA7cjxKci5sZW5ndGg7KXtpZigobz0oaT1KcltyXSk/aStuOmUpaW4gdClyZXR1cm4gbztyKyt9fVFyPVwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3c/e306d2luZG93O3ZhciBycz1ucyh0cy5zdHlsZSxcInRvdWNoQWN0aW9uXCIpLHNzPXZvaWQgMCE9PXJzO3ZhciBhcz1cImNvbXB1dGVcIixocz1cImF1dG9cIixkcz1cIm1hbmlwdWxhdGlvblwiLGxzPVwibm9uZVwiLGNzPVwicGFuLXhcIix1cz1cInBhbi15XCIsZnM9ZnVuY3Rpb24oKXtpZighc3MpcmV0dXJuITE7dmFyIHQ9e30sZT1Rci5DU1MmJlFyLkNTUy5zdXBwb3J0cztyZXR1cm5bXCJhdXRvXCIsXCJtYW5pcHVsYXRpb25cIixcInBhbi15XCIsXCJwYW4teFwiLFwicGFuLXggcGFuLXlcIixcIm5vbmVcIl0uZm9yRWFjaCgoZnVuY3Rpb24oaSl7cmV0dXJuIHRbaV09IWV8fFFyLkNTUy5zdXBwb3J0cyhcInRvdWNoLWFjdGlvblwiLGkpfSkpLHR9KCkscHM9XCJvbnRvdWNoc3RhcnRcImluIFFyLHZzPXZvaWQgMCE9PW5zKFFyLFwiUG9pbnRlckV2ZW50XCIpLGdzPXBzJiYvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSx5cz1cInRvdWNoXCIsbXM9XCJtb3VzZVwiLGJzPTE2LHdzPTI0LGtzPVtcInhcIixcInlcIl0sX3M9W1wiY2xpZW50WFwiLFwiY2xpZW50WVwiXTtmdW5jdGlvbiB4cyh0LGUsaSl7dmFyIG87aWYodClpZih0LmZvckVhY2gpdC5mb3JFYWNoKGUsaSk7ZWxzZSBpZih2b2lkIDAhPT10Lmxlbmd0aClmb3Iobz0wO288dC5sZW5ndGg7KWUuY2FsbChpLHRbb10sbyx0KSxvKys7ZWxzZSBmb3IobyBpbiB0KXQuaGFzT3duUHJvcGVydHkobykmJmUuY2FsbChpLHRbb10sbyx0KX1mdW5jdGlvbiBFcyh0LGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dC5hcHBseShlJiZlWzBdfHx2b2lkIDAsZSk6dH1mdW5jdGlvbiBPcyh0LGUpe3JldHVybiB0LmluZGV4T2YoZSk+LTF9dmFyIENzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3RoaXMubWFuYWdlcj10LHRoaXMuc2V0KGUpfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLnNldD1mdW5jdGlvbih0KXt0PT09YXMmJih0PXRoaXMuY29tcHV0ZSgpKSxzcyYmdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUmJmZzW3RdJiYodGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGVbcnNdPXQpLHRoaXMuYWN0aW9ucz10LnRvTG93ZXJDYXNlKCkudHJpbSgpfSxlLnVwZGF0ZT1mdW5jdGlvbigpe3RoaXMuc2V0KHRoaXMubWFuYWdlci5vcHRpb25zLnRvdWNoQWN0aW9uKX0sZS5jb21wdXRlPWZ1bmN0aW9uKCl7dmFyIHQ9W107cmV0dXJuIHhzKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywoZnVuY3Rpb24oZSl7RXMoZS5vcHRpb25zLmVuYWJsZSxbZV0pJiYodD10LmNvbmNhdChlLmdldFRvdWNoQWN0aW9uKCkpKX0pKSxmdW5jdGlvbih0KXtpZihPcyh0LGxzKSlyZXR1cm4gbHM7dmFyIGU9T3ModCxjcyksaT1Pcyh0LHVzKTtyZXR1cm4gZSYmaT9sczplfHxpP2U/Y3M6dXM6T3ModCxkcyk/ZHM6aHN9KHQuam9pbihcIiBcIikpfSxlLnByZXZlbnREZWZhdWx0cz1mdW5jdGlvbih0KXt2YXIgZT10LnNyY0V2ZW50LGk9dC5vZmZzZXREaXJlY3Rpb247aWYodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKWUucHJldmVudERlZmF1bHQoKTtlbHNle3ZhciBvPXRoaXMuYWN0aW9ucyxuPU9zKG8sbHMpJiYhZnMubm9uZSxyPU9zKG8sdXMpJiYhZnNbXCJwYW4teVwiXSxzPU9zKG8sY3MpJiYhZnNbXCJwYW4teFwiXTtpZihuKXt2YXIgYT0xPT09dC5wb2ludGVycy5sZW5ndGgsaD10LmRpc3RhbmNlPDIsZD10LmRlbHRhVGltZTwyNTA7aWYoYSYmaCYmZClyZXR1cm59aWYoIXN8fCFyKXJldHVybiBufHxyJiY2Jml8fHMmJmkmd3M/dGhpcy5wcmV2ZW50U3JjKGUpOnZvaWQgMH19LGUucHJldmVudFNyYz1mdW5jdGlvbih0KXt0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQ9ITAsdC5wcmV2ZW50RGVmYXVsdCgpfSx0fSgpO2Z1bmN0aW9uIFNzKHQsZSl7Zm9yKDt0Oyl7aWYodD09PWUpcmV0dXJuITA7dD10LnBhcmVudE5vZGV9cmV0dXJuITF9ZnVuY3Rpb24gVHModCl7dmFyIGU9dC5sZW5ndGg7aWYoMT09PWUpcmV0dXJue3g6ZXModFswXS5jbGllbnRYKSx5OmVzKHRbMF0uY2xpZW50WSl9O2Zvcih2YXIgaT0wLG89MCxuPTA7bjxlOylpKz10W25dLmNsaWVudFgsbys9dFtuXS5jbGllbnRZLG4rKztyZXR1cm57eDplcyhpL2UpLHk6ZXMoby9lKX19ZnVuY3Rpb24gTXModCl7Zm9yKHZhciBlPVtdLGk9MDtpPHQucG9pbnRlcnMubGVuZ3RoOyllW2ldPXtjbGllbnRYOmVzKHQucG9pbnRlcnNbaV0uY2xpZW50WCksY2xpZW50WTplcyh0LnBvaW50ZXJzW2ldLmNsaWVudFkpfSxpKys7cmV0dXJue3RpbWVTdGFtcDpvcygpLHBvaW50ZXJzOmUsY2VudGVyOlRzKGUpLGRlbHRhWDp0LmRlbHRhWCxkZWx0YVk6dC5kZWx0YVl9fWZ1bmN0aW9uIFBzKHQsZSxpKXtpfHwoaT1rcyk7dmFyIG89ZVtpWzBdXS10W2lbMF1dLG49ZVtpWzFdXS10W2lbMV1dO3JldHVybiBNYXRoLnNxcnQobypvK24qbil9ZnVuY3Rpb24gRHModCxlLGkpe2l8fChpPWtzKTt2YXIgbz1lW2lbMF1dLXRbaVswXV0sbj1lW2lbMV1dLXRbaVsxXV07cmV0dXJuIDE4MCpNYXRoLmF0YW4yKG4sbykvTWF0aC5QSX1mdW5jdGlvbiBCcyh0LGUpe3JldHVybiB0PT09ZT8xOmlzKHQpPj1pcyhlKT90PDA/Mjo0OmU8MD84OmJzfWZ1bmN0aW9uIElzKHQsZSxpKXtyZXR1cm57eDplL3R8fDAseTppL3R8fDB9fWZ1bmN0aW9uIHpzKHQsZSl7dmFyIGk9dC5zZXNzaW9uLG89ZS5wb2ludGVycyxuPW8ubGVuZ3RoO2kuZmlyc3RJbnB1dHx8KGkuZmlyc3RJbnB1dD1NcyhlKSksbj4xJiYhaS5maXJzdE11bHRpcGxlP2kuZmlyc3RNdWx0aXBsZT1NcyhlKToxPT09biYmKGkuZmlyc3RNdWx0aXBsZT0hMSk7dmFyIHI9aS5maXJzdElucHV0LHM9aS5maXJzdE11bHRpcGxlLGE9cz9zLmNlbnRlcjpyLmNlbnRlcixoPWUuY2VudGVyPVRzKG8pO2UudGltZVN0YW1wPW9zKCksZS5kZWx0YVRpbWU9ZS50aW1lU3RhbXAtci50aW1lU3RhbXAsZS5hbmdsZT1EcyhhLGgpLGUuZGlzdGFuY2U9UHMoYSxoKSxmdW5jdGlvbih0LGUpe3ZhciBpPWUuY2VudGVyLG89dC5vZmZzZXREZWx0YXx8e30sbj10LnByZXZEZWx0YXx8e30scj10LnByZXZJbnB1dHx8e307MSE9PWUuZXZlbnRUeXBlJiY0IT09ci5ldmVudFR5cGV8fChuPXQucHJldkRlbHRhPXt4OnIuZGVsdGFYfHwwLHk6ci5kZWx0YVl8fDB9LG89dC5vZmZzZXREZWx0YT17eDppLngseTppLnl9KSxlLmRlbHRhWD1uLngrKGkueC1vLngpLGUuZGVsdGFZPW4ueSsoaS55LW8ueSl9KGksZSksZS5vZmZzZXREaXJlY3Rpb249QnMoZS5kZWx0YVgsZS5kZWx0YVkpO3ZhciBkLGwsYz1JcyhlLmRlbHRhVGltZSxlLmRlbHRhWCxlLmRlbHRhWSk7ZS5vdmVyYWxsVmVsb2NpdHlYPWMueCxlLm92ZXJhbGxWZWxvY2l0eVk9Yy55LGUub3ZlcmFsbFZlbG9jaXR5PWlzKGMueCk+aXMoYy55KT9jLng6Yy55LGUuc2NhbGU9cz8oZD1zLnBvaW50ZXJzLFBzKChsPW8pWzBdLGxbMV0sX3MpL1BzKGRbMF0sZFsxXSxfcykpOjEsZS5yb3RhdGlvbj1zP2Z1bmN0aW9uKHQsZSl7cmV0dXJuIERzKGVbMV0sZVswXSxfcykrRHModFsxXSx0WzBdLF9zKX0ocy5wb2ludGVycyxvKTowLGUubWF4UG9pbnRlcnM9aS5wcmV2SW5wdXQ/ZS5wb2ludGVycy5sZW5ndGg+aS5wcmV2SW5wdXQubWF4UG9pbnRlcnM/ZS5wb2ludGVycy5sZW5ndGg6aS5wcmV2SW5wdXQubWF4UG9pbnRlcnM6ZS5wb2ludGVycy5sZW5ndGgsZnVuY3Rpb24odCxlKXt2YXIgaSxvLG4scixzPXQubGFzdEludGVydmFsfHxlLGE9ZS50aW1lU3RhbXAtcy50aW1lU3RhbXA7aWYoOCE9PWUuZXZlbnRUeXBlJiYoYT4yNXx8dm9pZCAwPT09cy52ZWxvY2l0eSkpe3ZhciBoPWUuZGVsdGFYLXMuZGVsdGFYLGQ9ZS5kZWx0YVktcy5kZWx0YVksbD1JcyhhLGgsZCk7bz1sLngsbj1sLnksaT1pcyhsLngpPmlzKGwueSk/bC54OmwueSxyPUJzKGgsZCksdC5sYXN0SW50ZXJ2YWw9ZX1lbHNlIGk9cy52ZWxvY2l0eSxvPXMudmVsb2NpdHlYLG49cy52ZWxvY2l0eVkscj1zLmRpcmVjdGlvbjtlLnZlbG9jaXR5PWksZS52ZWxvY2l0eVg9byxlLnZlbG9jaXR5WT1uLGUuZGlyZWN0aW9uPXJ9KGksZSk7dmFyIHUsZj10LmVsZW1lbnQscD1lLnNyY0V2ZW50O1NzKHU9cC5jb21wb3NlZFBhdGg/cC5jb21wb3NlZFBhdGgoKVswXTpwLnBhdGg/cC5wYXRoWzBdOnAudGFyZ2V0LGYpJiYoZj11KSxlLnRhcmdldD1mfWZ1bmN0aW9uIEZzKHQsZSxpKXt2YXIgbz1pLnBvaW50ZXJzLmxlbmd0aCxuPWkuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aCxyPTEmZSYmby1uPT0wLHM9MTImZSYmby1uPT0wO2kuaXNGaXJzdD0hIXIsaS5pc0ZpbmFsPSEhcyxyJiYodC5zZXNzaW9uPXt9KSxpLmV2ZW50VHlwZT1lLHpzKHQsaSksdC5lbWl0KFwiaGFtbWVyLmlucHV0XCIsaSksdC5yZWNvZ25pemUoaSksdC5zZXNzaW9uLnByZXZJbnB1dD1pfWZ1bmN0aW9uIE5zKHQpe3JldHVybiB0LnRyaW0oKS5zcGxpdCgvXFxzKy9nKX1mdW5jdGlvbiBBcyh0LGUsaSl7eHMoTnMoZSksKGZ1bmN0aW9uKGUpe3QuYWRkRXZlbnRMaXN0ZW5lcihlLGksITEpfSkpfWZ1bmN0aW9uIFJzKHQsZSxpKXt4cyhOcyhlKSwoZnVuY3Rpb24oZSl7dC5yZW1vdmVFdmVudExpc3RlbmVyKGUsaSwhMSl9KSl9ZnVuY3Rpb24ganModCl7dmFyIGU9dC5vd25lckRvY3VtZW50fHx0O3JldHVybiBlLmRlZmF1bHRWaWV3fHxlLnBhcmVudFdpbmRvd3x8d2luZG93fXZhciBMcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt2YXIgaT10aGlzO3RoaXMubWFuYWdlcj10LHRoaXMuY2FsbGJhY2s9ZSx0aGlzLmVsZW1lbnQ9dC5lbGVtZW50LHRoaXMudGFyZ2V0PXQub3B0aW9ucy5pbnB1dFRhcmdldCx0aGlzLmRvbUhhbmRsZXI9ZnVuY3Rpb24oZSl7RXModC5vcHRpb25zLmVuYWJsZSxbdF0pJiZpLmhhbmRsZXIoZSl9LHRoaXMuaW5pdCgpfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLmhhbmRsZXI9ZnVuY3Rpb24oKXt9LGUuaW5pdD1mdW5jdGlvbigpe3RoaXMuZXZFbCYmQXModGhpcy5lbGVtZW50LHRoaXMuZXZFbCx0aGlzLmRvbUhhbmRsZXIpLHRoaXMuZXZUYXJnZXQmJkFzKHRoaXMudGFyZ2V0LHRoaXMuZXZUYXJnZXQsdGhpcy5kb21IYW5kbGVyKSx0aGlzLmV2V2luJiZBcyhqcyh0aGlzLmVsZW1lbnQpLHRoaXMuZXZXaW4sdGhpcy5kb21IYW5kbGVyKX0sZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5ldkVsJiZScyh0aGlzLmVsZW1lbnQsdGhpcy5ldkVsLHRoaXMuZG9tSGFuZGxlciksdGhpcy5ldlRhcmdldCYmUnModGhpcy50YXJnZXQsdGhpcy5ldlRhcmdldCx0aGlzLmRvbUhhbmRsZXIpLHRoaXMuZXZXaW4mJlJzKGpzKHRoaXMuZWxlbWVudCksdGhpcy5ldldpbix0aGlzLmRvbUhhbmRsZXIpfSx0fSgpO2Z1bmN0aW9uIEhzKHQsZSxpKXtpZih0LmluZGV4T2YmJiFpKXJldHVybiB0LmluZGV4T2YoZSk7Zm9yKHZhciBvPTA7bzx0Lmxlbmd0aDspe2lmKGkmJnRbb11baV09PWV8fCFpJiZ0W29dPT09ZSlyZXR1cm4gbztvKyt9cmV0dXJuLTF9dmFyIFdzPXtwb2ludGVyZG93bjoxLHBvaW50ZXJtb3ZlOjIscG9pbnRlcnVwOjQscG9pbnRlcmNhbmNlbDo4LHBvaW50ZXJvdXQ6OH0sVnM9ezI6eXMsMzpcInBlblwiLDQ6bXMsNTpcImtpbmVjdFwifSxxcz1cInBvaW50ZXJkb3duXCIsVXM9XCJwb2ludGVybW92ZSBwb2ludGVydXAgcG9pbnRlcmNhbmNlbFwiO1FyLk1TUG9pbnRlckV2ZW50JiYhUXIuUG9pbnRlckV2ZW50JiYocXM9XCJNU1BvaW50ZXJEb3duXCIsVXM9XCJNU1BvaW50ZXJNb3ZlIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbFwiKTt2YXIgWXM9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciBpLG89ZS5wcm90b3R5cGU7cmV0dXJuIG8uZXZFbD1xcyxvLmV2V2luPVVzLChpPXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzKS5zdG9yZT1pLm1hbmFnZXIuc2Vzc2lvbi5wb2ludGVyRXZlbnRzPVtdLGl9cmV0dXJuIEtyKGUsdCksZS5wcm90b3R5cGUuaGFuZGxlcj1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnN0b3JlLGk9ITEsbz10LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKFwibXNcIixcIlwiKSxuPVdzW29dLHI9VnNbdC5wb2ludGVyVHlwZV18fHQucG9pbnRlclR5cGUscz1yPT09eXMsYT1IcyhlLHQucG9pbnRlcklkLFwicG9pbnRlcklkXCIpOzEmbiYmKDA9PT10LmJ1dHRvbnx8cyk/YTwwJiYoZS5wdXNoKHQpLGE9ZS5sZW5ndGgtMSk6MTImbiYmKGk9ITApLGE8MHx8KGVbYV09dCx0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlcixuLHtwb2ludGVyczplLGNoYW5nZWRQb2ludGVyczpbdF0scG9pbnRlclR5cGU6cixzcmNFdmVudDp0fSksaSYmZS5zcGxpY2UoYSwxKSl9LGV9KExzKTtmdW5jdGlvbiBYcyh0KXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodCwwKX1mdW5jdGlvbiBHcyh0LGUsaSl7Zm9yKHZhciBvPVtdLG49W10scj0wO3I8dC5sZW5ndGg7KXt2YXIgcz1lP3Rbcl1bZV06dFtyXTtIcyhuLHMpPDAmJm8ucHVzaCh0W3JdKSxuW3JdPXMscisrfXJldHVybiBpJiYobz1lP28uc29ydCgoZnVuY3Rpb24odCxpKXtyZXR1cm4gdFtlXT5pW2VdfSkpOm8uc29ydCgpKSxvfXZhciBLcz17dG91Y2hzdGFydDoxLHRvdWNobW92ZToyLHRvdWNoZW5kOjQsdG91Y2hjYW5jZWw6OH0sJHM9XCJ0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbFwiLFFzPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgaTtyZXR1cm4gZS5wcm90b3R5cGUuZXZUYXJnZXQ9JHMsKGk9dC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXMpLnRhcmdldElkcz17fSxpfXJldHVybiBLcihlLHQpLGUucHJvdG90eXBlLmhhbmRsZXI9ZnVuY3Rpb24odCl7dmFyIGU9S3NbdC50eXBlXSxpPVpzLmNhbGwodGhpcyx0LGUpO2kmJnRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLGUse3BvaW50ZXJzOmlbMF0sY2hhbmdlZFBvaW50ZXJzOmlbMV0scG9pbnRlclR5cGU6eXMsc3JjRXZlbnQ6dH0pfSxlfShMcyk7ZnVuY3Rpb24gWnModCxlKXt2YXIgaSxvLG49WHModC50b3VjaGVzKSxyPXRoaXMudGFyZ2V0SWRzO2lmKDMmZSYmMT09PW4ubGVuZ3RoKXJldHVybiByW25bMF0uaWRlbnRpZmllcl09ITAsW24sbl07dmFyIHM9WHModC5jaGFuZ2VkVG91Y2hlcyksYT1bXSxoPXRoaXMudGFyZ2V0O2lmKG89bi5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBTcyh0LnRhcmdldCxoKX0pKSwxPT09ZSlmb3IoaT0wO2k8by5sZW5ndGg7KXJbb1tpXS5pZGVudGlmaWVyXT0hMCxpKys7Zm9yKGk9MDtpPHMubGVuZ3RoOylyW3NbaV0uaWRlbnRpZmllcl0mJmEucHVzaChzW2ldKSwxMiZlJiZkZWxldGUgcltzW2ldLmlkZW50aWZpZXJdLGkrKztyZXR1cm4gYS5sZW5ndGg/W0dzKG8uY29uY2F0KGEpLFwiaWRlbnRpZmllclwiLCEwKSxhXTp2b2lkIDB9dmFyIEpzPXttb3VzZWRvd246MSxtb3VzZW1vdmU6Mixtb3VzZXVwOjR9LHRhPVwibW91c2Vkb3duXCIsZWE9XCJtb3VzZW1vdmUgbW91c2V1cFwiLGlhPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgaSxvPWUucHJvdG90eXBlO3JldHVybiBvLmV2RWw9dGEsby5ldldpbj1lYSwoaT10LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcykucHJlc3NlZD0hMSxpfXJldHVybiBLcihlLHQpLGUucHJvdG90eXBlLmhhbmRsZXI9ZnVuY3Rpb24odCl7dmFyIGU9SnNbdC50eXBlXTsxJmUmJjA9PT10LmJ1dHRvbiYmKHRoaXMucHJlc3NlZD0hMCksMiZlJiYxIT09dC53aGljaCYmKGU9NCksdGhpcy5wcmVzc2VkJiYoNCZlJiYodGhpcy5wcmVzc2VkPSExKSx0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlcixlLHtwb2ludGVyczpbdF0sY2hhbmdlZFBvaW50ZXJzOlt0XSxwb2ludGVyVHlwZTptcyxzcmNFdmVudDp0fSkpfSxlfShMcyk7ZnVuY3Rpb24gb2EodCl7dmFyIGU9dC5jaGFuZ2VkUG9pbnRlcnNbMF07aWYoZS5pZGVudGlmaWVyPT09dGhpcy5wcmltYXJ5VG91Y2gpe3ZhciBpPXt4OmUuY2xpZW50WCx5OmUuY2xpZW50WX0sbz10aGlzLmxhc3RUb3VjaGVzO3RoaXMubGFzdFRvdWNoZXMucHVzaChpKTtzZXRUaW1lb3V0KChmdW5jdGlvbigpe3ZhciB0PW8uaW5kZXhPZihpKTt0Pi0xJiZvLnNwbGljZSh0LDEpfSksMjUwMCl9fWZ1bmN0aW9uIG5hKHQsZSl7MSZ0Pyh0aGlzLnByaW1hcnlUb3VjaD1lLmNoYW5nZWRQb2ludGVyc1swXS5pZGVudGlmaWVyLG9hLmNhbGwodGhpcyxlKSk6MTImdCYmb2EuY2FsbCh0aGlzLGUpfWZ1bmN0aW9uIHJhKHQpe2Zvcih2YXIgZT10LnNyY0V2ZW50LmNsaWVudFgsaT10LnNyY0V2ZW50LmNsaWVudFksbz0wO288dGhpcy5sYXN0VG91Y2hlcy5sZW5ndGg7bysrKXt2YXIgbj10aGlzLmxhc3RUb3VjaGVzW29dLHI9TWF0aC5hYnMoZS1uLngpLHM9TWF0aC5hYnMoaS1uLnkpO2lmKHI8PTI1JiZzPD0yNSlyZXR1cm4hMH1yZXR1cm4hMX12YXIgc2E9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLGkpe3ZhciBvO3JldHVybihvPXQuY2FsbCh0aGlzLGUsaSl8fHRoaXMpLmhhbmRsZXI9ZnVuY3Rpb24odCxlLGkpe3ZhciBuPWkucG9pbnRlclR5cGU9PT15cyxyPWkucG9pbnRlclR5cGU9PT1tcztpZighKHImJmkuc291cmNlQ2FwYWJpbGl0aWVzJiZpLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSl7aWYobiluYS5jYWxsKCRyKCRyKG8pKSxlLGkpO2Vsc2UgaWYociYmcmEuY2FsbCgkcigkcihvKSksaSkpcmV0dXJuO28uY2FsbGJhY2sodCxlLGkpfX0sby50b3VjaD1uZXcgUXMoby5tYW5hZ2VyLG8uaGFuZGxlciksby5tb3VzZT1uZXcgaWEoby5tYW5hZ2VyLG8uaGFuZGxlciksby5wcmltYXJ5VG91Y2g9bnVsbCxvLmxhc3RUb3VjaGVzPVtdLG99cmV0dXJuIEtyKGUsdCksZS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMudG91Y2guZGVzdHJveSgpLHRoaXMubW91c2UuZGVzdHJveSgpfSxlfShMcyl9KCk7ZnVuY3Rpb24gYWEodCxlLGkpe3JldHVybiEhQXJyYXkuaXNBcnJheSh0KSYmKHhzKHQsaVtlXSxpKSwhMCl9dmFyIGhhPTMyLGRhPTE7ZnVuY3Rpb24gbGEodCxlKXt2YXIgaT1lLm1hbmFnZXI7cmV0dXJuIGk/aS5nZXQodCk6dH1mdW5jdGlvbiBjYSh0KXtyZXR1cm4gMTYmdD9cImNhbmNlbFwiOjgmdD9cImVuZFwiOjQmdD9cIm1vdmVcIjoyJnQ/XCJzdGFydFwiOlwiXCJ9dmFyIHVhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt2b2lkIDA9PT10JiYodD17fSksdGhpcy5vcHRpb25zPUdyKHtlbmFibGU6ITB9LHQpLHRoaXMuaWQ9ZGErKyx0aGlzLm1hbmFnZXI9bnVsbCx0aGlzLnN0YXRlPTEsdGhpcy5zaW11bHRhbmVvdXM9e30sdGhpcy5yZXF1aXJlRmFpbD1bXX12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5zZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIFpyKHRoaXMub3B0aW9ucyx0KSx0aGlzLm1hbmFnZXImJnRoaXMubWFuYWdlci50b3VjaEFjdGlvbi51cGRhdGUoKSx0aGlzfSxlLnJlY29nbml6ZVdpdGg9ZnVuY3Rpb24odCl7aWYoYWEodCxcInJlY29nbml6ZVdpdGhcIix0aGlzKSlyZXR1cm4gdGhpczt2YXIgZT10aGlzLnNpbXVsdGFuZW91cztyZXR1cm4gZVsodD1sYSh0LHRoaXMpKS5pZF18fChlW3QuaWRdPXQsdC5yZWNvZ25pemVXaXRoKHRoaXMpKSx0aGlzfSxlLmRyb3BSZWNvZ25pemVXaXRoPWZ1bmN0aW9uKHQpe3JldHVybiBhYSh0LFwiZHJvcFJlY29nbml6ZVdpdGhcIix0aGlzKXx8KHQ9bGEodCx0aGlzKSxkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbdC5pZF0pLHRoaXN9LGUucmVxdWlyZUZhaWx1cmU9ZnVuY3Rpb24odCl7aWYoYWEodCxcInJlcXVpcmVGYWlsdXJlXCIsdGhpcykpcmV0dXJuIHRoaXM7dmFyIGU9dGhpcy5yZXF1aXJlRmFpbDtyZXR1cm4tMT09PUhzKGUsdD1sYSh0LHRoaXMpKSYmKGUucHVzaCh0KSx0LnJlcXVpcmVGYWlsdXJlKHRoaXMpKSx0aGlzfSxlLmRyb3BSZXF1aXJlRmFpbHVyZT1mdW5jdGlvbih0KXtpZihhYSh0LFwiZHJvcFJlcXVpcmVGYWlsdXJlXCIsdGhpcykpcmV0dXJuIHRoaXM7dD1sYSh0LHRoaXMpO3ZhciBlPUhzKHRoaXMucmVxdWlyZUZhaWwsdCk7cmV0dXJuIGU+LTEmJnRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGUsMSksdGhpc30sZS5oYXNSZXF1aXJlRmFpbHVyZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGg+MH0sZS5jYW5SZWNvZ25pemVXaXRoPWZ1bmN0aW9uKHQpe3JldHVybiEhdGhpcy5zaW11bHRhbmVvdXNbdC5pZF19LGUuZW1pdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLGk9dGhpcy5zdGF0ZTtmdW5jdGlvbiBvKGkpe2UubWFuYWdlci5lbWl0KGksdCl9aTw4JiZvKGUub3B0aW9ucy5ldmVudCtjYShpKSksbyhlLm9wdGlvbnMuZXZlbnQpLHQuYWRkaXRpb25hbEV2ZW50JiZvKHQuYWRkaXRpb25hbEV2ZW50KSxpPj04JiZvKGUub3B0aW9ucy5ldmVudCtjYShpKSl9LGUudHJ5RW1pdD1mdW5jdGlvbih0KXtpZih0aGlzLmNhbkVtaXQoKSlyZXR1cm4gdGhpcy5lbWl0KHQpO3RoaXMuc3RhdGU9aGF9LGUuY2FuRW1pdD1mdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8dGhpcy5yZXF1aXJlRmFpbC5sZW5ndGg7KXtpZighKDMzJnRoaXMucmVxdWlyZUZhaWxbdF0uc3RhdGUpKXJldHVybiExO3QrK31yZXR1cm4hMH0sZS5yZWNvZ25pemU9ZnVuY3Rpb24odCl7dmFyIGU9WnIoe30sdCk7aWYoIUVzKHRoaXMub3B0aW9ucy5lbmFibGUsW3RoaXMsZV0pKXJldHVybiB0aGlzLnJlc2V0KCksdm9pZCh0aGlzLnN0YXRlPWhhKTs1NiZ0aGlzLnN0YXRlJiYodGhpcy5zdGF0ZT0xKSx0aGlzLnN0YXRlPXRoaXMucHJvY2VzcyhlKSwzMCZ0aGlzLnN0YXRlJiZ0aGlzLnRyeUVtaXQoZSl9LGUucHJvY2Vzcz1mdW5jdGlvbih0KXt9LGUuZ2V0VG91Y2hBY3Rpb249ZnVuY3Rpb24oKXt9LGUucmVzZXQ9ZnVuY3Rpb24oKXt9LHR9KCksZmE9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgaTtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9e30pLChpPXQuY2FsbCh0aGlzLEdyKHtldmVudDpcInRhcFwiLHBvaW50ZXJzOjEsdGFwczoxLGludGVydmFsOjMwMCx0aW1lOjI1MCx0aHJlc2hvbGQ6OSxwb3NUaHJlc2hvbGQ6MTB9LGUpKXx8dGhpcykucFRpbWU9ITEsaS5wQ2VudGVyPSExLGkuX3RpbWVyPW51bGwsaS5faW5wdXQ9bnVsbCxpLmNvdW50PTAsaX1LcihlLHQpO3ZhciBpPWUucHJvdG90eXBlO3JldHVybiBpLmdldFRvdWNoQWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuW2RzXX0saS5wcm9jZXNzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsaT10aGlzLm9wdGlvbnMsbz10LnBvaW50ZXJzLmxlbmd0aD09PWkucG9pbnRlcnMsbj10LmRpc3RhbmNlPGkudGhyZXNob2xkLHI9dC5kZWx0YVRpbWU8aS50aW1lO2lmKHRoaXMucmVzZXQoKSwxJnQuZXZlbnRUeXBlJiYwPT09dGhpcy5jb3VudClyZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO2lmKG4mJnImJm8pe2lmKDQhPT10LmV2ZW50VHlwZSlyZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO3ZhciBzPSF0aGlzLnBUaW1lfHx0LnRpbWVTdGFtcC10aGlzLnBUaW1lPGkuaW50ZXJ2YWwsYT0hdGhpcy5wQ2VudGVyfHxQcyh0aGlzLnBDZW50ZXIsdC5jZW50ZXIpPGkucG9zVGhyZXNob2xkO2lmKHRoaXMucFRpbWU9dC50aW1lU3RhbXAsdGhpcy5wQ2VudGVyPXQuY2VudGVyLGEmJnM/dGhpcy5jb3VudCs9MTp0aGlzLmNvdW50PTEsdGhpcy5faW5wdXQ9dCwwPT09dGhpcy5jb3VudCVpLnRhcHMpcmV0dXJuIHRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCk/KHRoaXMuX3RpbWVyPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZS5zdGF0ZT04LGUudHJ5RW1pdCgpfSksaS5pbnRlcnZhbCksMik6OH1yZXR1cm4gaGF9LGkuZmFpbFRpbWVvdXQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiB0aGlzLl90aW1lcj1zZXRUaW1lb3V0KChmdW5jdGlvbigpe3Quc3RhdGU9aGF9KSx0aGlzLm9wdGlvbnMuaW50ZXJ2YWwpLGhhfSxpLnJlc2V0PWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKX0saS5lbWl0PWZ1bmN0aW9uKCl7OD09PXRoaXMuc3RhdGUmJih0aGlzLl9pbnB1dC50YXBDb3VudD10aGlzLmNvdW50LHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCx0aGlzLl9pbnB1dCkpfSxlfSh1YSkscGE9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9e30pLHQuY2FsbCh0aGlzLEdyKHtwb2ludGVyczoxfSxlKSl8fHRoaXN9S3IoZSx0KTt2YXIgaT1lLnByb3RvdHlwZTtyZXR1cm4gaS5hdHRyVGVzdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLm9wdGlvbnMucG9pbnRlcnM7cmV0dXJuIDA9PT1lfHx0LnBvaW50ZXJzLmxlbmd0aD09PWV9LGkucHJvY2Vzcz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnN0YXRlLGk9dC5ldmVudFR5cGUsbz02JmUsbj10aGlzLmF0dHJUZXN0KHQpO3JldHVybiBvJiYoOCZpfHwhbik/MTZ8ZTpvfHxuPzQmaT84fGU6MiZlPzR8ZToyOmhhfSxlfSh1YSk7ZnVuY3Rpb24gdmEodCl7cmV0dXJuIHQ9PT1icz9cImRvd25cIjo4PT09dD9cInVwXCI6Mj09PXQ/XCJsZWZ0XCI6ND09PXQ/XCJyaWdodFwiOlwiXCJ9dmFyIGdhPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIGk7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSwoaT10LmNhbGwodGhpcyxHcih7ZXZlbnQ6XCJwYW5cIix0aHJlc2hvbGQ6MTAscG9pbnRlcnM6MSxkaXJlY3Rpb246MzB9LGUpKXx8dGhpcykucFg9bnVsbCxpLnBZPW51bGwsaX1LcihlLHQpO3ZhciBpPWUucHJvdG90eXBlO3JldHVybiBpLmdldFRvdWNoQWN0aW9uPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5vcHRpb25zLmRpcmVjdGlvbixlPVtdO3JldHVybiA2JnQmJmUucHVzaCh1cyksdCZ3cyYmZS5wdXNoKGNzKSxlfSxpLmRpcmVjdGlvblRlc3Q9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5vcHRpb25zLGk9ITAsbz10LmRpc3RhbmNlLG49dC5kaXJlY3Rpb24scj10LmRlbHRhWCxzPXQuZGVsdGFZO3JldHVybiBuJmUuZGlyZWN0aW9ufHwoNiZlLmRpcmVjdGlvbj8obj0wPT09cj8xOnI8MD8yOjQsaT1yIT09dGhpcy5wWCxvPU1hdGguYWJzKHQuZGVsdGFYKSk6KG49MD09PXM/MTpzPDA/ODpicyxpPXMhPT10aGlzLnBZLG89TWF0aC5hYnModC5kZWx0YVkpKSksdC5kaXJlY3Rpb249bixpJiZvPmUudGhyZXNob2xkJiZuJmUuZGlyZWN0aW9ufSxpLmF0dHJUZXN0PWZ1bmN0aW9uKHQpe3JldHVybiBwYS5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLHQpJiYoMiZ0aGlzLnN0YXRlfHwhKDImdGhpcy5zdGF0ZSkmJnRoaXMuZGlyZWN0aW9uVGVzdCh0KSl9LGkuZW1pdD1mdW5jdGlvbihlKXt0aGlzLnBYPWUuZGVsdGFYLHRoaXMucFk9ZS5kZWx0YVk7dmFyIGk9dmEoZS5kaXJlY3Rpb24pO2kmJihlLmFkZGl0aW9uYWxFdmVudD10aGlzLm9wdGlvbnMuZXZlbnQraSksdC5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsZSl9LGV9KHBhKSx5YT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT17fSksdC5jYWxsKHRoaXMsR3Ioe2V2ZW50Olwic3dpcGVcIix0aHJlc2hvbGQ6MTAsdmVsb2NpdHk6LjMsZGlyZWN0aW9uOjMwLHBvaW50ZXJzOjF9LGUpKXx8dGhpc31LcihlLHQpO3ZhciBpPWUucHJvdG90eXBlO3JldHVybiBpLmdldFRvdWNoQWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGdhLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpfSxpLmF0dHJUZXN0PWZ1bmN0aW9uKGUpe3ZhciBpLG89dGhpcy5vcHRpb25zLmRpcmVjdGlvbjtyZXR1cm4gMzAmbz9pPWUub3ZlcmFsbFZlbG9jaXR5OjYmbz9pPWUub3ZlcmFsbFZlbG9jaXR5WDpvJndzJiYoaT1lLm92ZXJhbGxWZWxvY2l0eVkpLHQucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcyxlKSYmbyZlLm9mZnNldERpcmVjdGlvbiYmZS5kaXN0YW5jZT50aGlzLm9wdGlvbnMudGhyZXNob2xkJiZlLm1heFBvaW50ZXJzPT09dGhpcy5vcHRpb25zLnBvaW50ZXJzJiZpcyhpKT50aGlzLm9wdGlvbnMudmVsb2NpdHkmJjQmZS5ldmVudFR5cGV9LGkuZW1pdD1mdW5jdGlvbih0KXt2YXIgZT12YSh0Lm9mZnNldERpcmVjdGlvbik7ZSYmdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50K2UsdCksdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LHQpfSxlfShwYSksbWE9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9e30pLHQuY2FsbCh0aGlzLEdyKHtldmVudDpcInBpbmNoXCIsdGhyZXNob2xkOjAscG9pbnRlcnM6Mn0sZSkpfHx0aGlzfUtyKGUsdCk7dmFyIGk9ZS5wcm90b3R5cGU7cmV0dXJuIGkuZ2V0VG91Y2hBY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm5bbHNdfSxpLmF0dHJUZXN0PWZ1bmN0aW9uKGUpe3JldHVybiB0LnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsZSkmJihNYXRoLmFicyhlLnNjYWxlLTEpPnRoaXMub3B0aW9ucy50aHJlc2hvbGR8fDImdGhpcy5zdGF0ZSl9LGkuZW1pdD1mdW5jdGlvbihlKXtpZigxIT09ZS5zY2FsZSl7dmFyIGk9ZS5zY2FsZTwxP1wiaW5cIjpcIm91dFwiO2UuYWRkaXRpb25hbEV2ZW50PXRoaXMub3B0aW9ucy5ldmVudCtpfXQucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLGUpfSxlfShwYSksYmE9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9e30pLHQuY2FsbCh0aGlzLEdyKHtldmVudDpcInJvdGF0ZVwiLHRocmVzaG9sZDowLHBvaW50ZXJzOjJ9LGUpKXx8dGhpc31LcihlLHQpO3ZhciBpPWUucHJvdG90eXBlO3JldHVybiBpLmdldFRvdWNoQWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuW2xzXX0saS5hdHRyVGVzdD1mdW5jdGlvbihlKXtyZXR1cm4gdC5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLGUpJiYoTWF0aC5hYnMoZS5yb3RhdGlvbik+dGhpcy5vcHRpb25zLnRocmVzaG9sZHx8MiZ0aGlzLnN0YXRlKX0sZX0ocGEpLHdhPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIGk7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSwoaT10LmNhbGwodGhpcyxHcih7ZXZlbnQ6XCJwcmVzc1wiLHBvaW50ZXJzOjEsdGltZToyNTEsdGhyZXNob2xkOjl9LGUpKXx8dGhpcykuX3RpbWVyPW51bGwsaS5faW5wdXQ9bnVsbCxpfUtyKGUsdCk7dmFyIGk9ZS5wcm90b3R5cGU7cmV0dXJuIGkuZ2V0VG91Y2hBY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm5baHNdfSxpLnByb2Nlc3M9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxpPXRoaXMub3B0aW9ucyxvPXQucG9pbnRlcnMubGVuZ3RoPT09aS5wb2ludGVycyxuPXQuZGlzdGFuY2U8aS50aHJlc2hvbGQscj10LmRlbHRhVGltZT5pLnRpbWU7aWYodGhpcy5faW5wdXQ9dCwhbnx8IW98fDEyJnQuZXZlbnRUeXBlJiYhcil0aGlzLnJlc2V0KCk7ZWxzZSBpZigxJnQuZXZlbnRUeXBlKXRoaXMucmVzZXQoKSx0aGlzLl90aW1lcj1zZXRUaW1lb3V0KChmdW5jdGlvbigpe2Uuc3RhdGU9OCxlLnRyeUVtaXQoKX0pLGkudGltZSk7ZWxzZSBpZig0JnQuZXZlbnRUeXBlKXJldHVybiA4O3JldHVybiBoYX0saS5yZXNldD1mdW5jdGlvbigpe2NsZWFyVGltZW91dCh0aGlzLl90aW1lcil9LGkuZW1pdD1mdW5jdGlvbih0KXs4PT09dGhpcy5zdGF0ZSYmKHQmJjQmdC5ldmVudFR5cGU/dGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50K1widXBcIix0KToodGhpcy5faW5wdXQudGltZVN0YW1wPW9zKCksdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LHRoaXMuX2lucHV0KSkpfSxlfSh1YSksa2E9e2RvbUV2ZW50czohMSx0b3VjaEFjdGlvbjphcyxlbmFibGU6ITAsaW5wdXRUYXJnZXQ6bnVsbCxpbnB1dENsYXNzOm51bGwsY3NzUHJvcHM6e3VzZXJTZWxlY3Q6XCJub25lXCIsdG91Y2hTZWxlY3Q6XCJub25lXCIsdG91Y2hDYWxsb3V0Olwibm9uZVwiLGNvbnRlbnRab29taW5nOlwibm9uZVwiLHVzZXJEcmFnOlwibm9uZVwiLHRhcEhpZ2hsaWdodENvbG9yOlwicmdiYSgwLDAsMCwwKVwifX0sX2E9W1tiYSx7ZW5hYmxlOiExfV0sW21hLHtlbmFibGU6ITF9LFtcInJvdGF0ZVwiXV0sW3lhLHtkaXJlY3Rpb246Nn1dLFtnYSx7ZGlyZWN0aW9uOjZ9LFtcInN3aXBlXCJdXSxbZmFdLFtmYSx7ZXZlbnQ6XCJkb3VibGV0YXBcIix0YXBzOjJ9LFtcInRhcFwiXV0sW3dhXV07ZnVuY3Rpb24geGEodCxlKXt2YXIgaSxvPXQuZWxlbWVudDtvLnN0eWxlJiYoeHModC5vcHRpb25zLmNzc1Byb3BzLChmdW5jdGlvbihuLHIpe2k9bnMoby5zdHlsZSxyKSxlPyh0Lm9sZENzc1Byb3BzW2ldPW8uc3R5bGVbaV0sby5zdHlsZVtpXT1uKTpvLnN0eWxlW2ldPXQub2xkQ3NzUHJvcHNbaV18fFwiXCJ9KSksZXx8KHQub2xkQ3NzUHJvcHM9e30pKX12YXIgRWE9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dmFyIGksbz10aGlzO3RoaXMub3B0aW9ucz1acih7fSxrYSxlfHx7fSksdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0PXRoaXMub3B0aW9ucy5pbnB1dFRhcmdldHx8dCx0aGlzLmhhbmRsZXJzPXt9LHRoaXMuc2Vzc2lvbj17fSx0aGlzLnJlY29nbml6ZXJzPVtdLHRoaXMub2xkQ3NzUHJvcHM9e30sdGhpcy5lbGVtZW50PXQsdGhpcy5pbnB1dD1uZXcoKGk9dGhpcykub3B0aW9ucy5pbnB1dENsYXNzfHwodnM/WXM6Z3M/UXM6cHM/c2E6aWEpKShpLEZzKSx0aGlzLnRvdWNoQWN0aW9uPW5ldyBDcyh0aGlzLHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbikseGEodGhpcywhMCkseHModGhpcy5vcHRpb25zLnJlY29nbml6ZXJzLChmdW5jdGlvbih0KXt2YXIgZT1vLmFkZChuZXcgdFswXSh0WzFdKSk7dFsyXSYmZS5yZWNvZ25pemVXaXRoKHRbMl0pLHRbM10mJmUucmVxdWlyZUZhaWx1cmUodFszXSl9KSx0aGlzKX12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5zZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIFpyKHRoaXMub3B0aW9ucyx0KSx0LnRvdWNoQWN0aW9uJiZ0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpLHQuaW5wdXRUYXJnZXQmJih0aGlzLmlucHV0LmRlc3Ryb3koKSx0aGlzLmlucHV0LnRhcmdldD10LmlucHV0VGFyZ2V0LHRoaXMuaW5wdXQuaW5pdCgpKSx0aGlzfSxlLnN0b3A9ZnVuY3Rpb24odCl7dGhpcy5zZXNzaW9uLnN0b3BwZWQ9dD8yOjF9LGUucmVjb2duaXplPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuc2Vzc2lvbjtpZighZS5zdG9wcGVkKXt2YXIgaTt0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyh0KTt2YXIgbz10aGlzLnJlY29nbml6ZXJzLG49ZS5jdXJSZWNvZ25pemVyOyghbnx8biYmOCZuLnN0YXRlKSYmKGUuY3VyUmVjb2duaXplcj1udWxsLG49bnVsbCk7Zm9yKHZhciByPTA7cjxvLmxlbmd0aDspaT1vW3JdLDI9PT1lLnN0b3BwZWR8fG4mJmkhPT1uJiYhaS5jYW5SZWNvZ25pemVXaXRoKG4pP2kucmVzZXQoKTppLnJlY29nbml6ZSh0KSwhbiYmMTQmaS5zdGF0ZSYmKGUuY3VyUmVjb2duaXplcj1pLG49aSkscisrfX0sZS5nZXQ9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIHVhKXJldHVybiB0O2Zvcih2YXIgZT10aGlzLnJlY29nbml6ZXJzLGk9MDtpPGUubGVuZ3RoO2krKylpZihlW2ldLm9wdGlvbnMuZXZlbnQ9PT10KXJldHVybiBlW2ldO3JldHVybiBudWxsfSxlLmFkZD1mdW5jdGlvbih0KXtpZihhYSh0LFwiYWRkXCIsdGhpcykpcmV0dXJuIHRoaXM7dmFyIGU9dGhpcy5nZXQodC5vcHRpb25zLmV2ZW50KTtyZXR1cm4gZSYmdGhpcy5yZW1vdmUoZSksdGhpcy5yZWNvZ25pemVycy5wdXNoKHQpLHQubWFuYWdlcj10aGlzLHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCksdH0sZS5yZW1vdmU9ZnVuY3Rpb24odCl7aWYoYWEodCxcInJlbW92ZVwiLHRoaXMpKXJldHVybiB0aGlzO3ZhciBlPXRoaXMuZ2V0KHQpO2lmKHQpe3ZhciBpPXRoaXMucmVjb2duaXplcnMsbz1IcyhpLGUpOy0xIT09byYmKGkuc3BsaWNlKG8sMSksdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKSl9cmV0dXJuIHRoaXN9LGUub249ZnVuY3Rpb24odCxlKXtpZih2b2lkIDA9PT10fHx2b2lkIDA9PT1lKXJldHVybiB0aGlzO3ZhciBpPXRoaXMuaGFuZGxlcnM7cmV0dXJuIHhzKE5zKHQpLChmdW5jdGlvbih0KXtpW3RdPWlbdF18fFtdLGlbdF0ucHVzaChlKX0pKSx0aGlzfSxlLm9mZj1mdW5jdGlvbih0LGUpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXM7dmFyIGk9dGhpcy5oYW5kbGVycztyZXR1cm4geHMoTnModCksKGZ1bmN0aW9uKHQpe2U/aVt0XSYmaVt0XS5zcGxpY2UoSHMoaVt0XSxlKSwxKTpkZWxldGUgaVt0XX0pKSx0aGlzfSxlLmVtaXQ9ZnVuY3Rpb24odCxlKXt0aGlzLm9wdGlvbnMuZG9tRXZlbnRzJiZmdW5jdGlvbih0LGUpe3ZhciBpPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7aS5pbml0RXZlbnQodCwhMCwhMCksaS5nZXN0dXJlPWUsZS50YXJnZXQuZGlzcGF0Y2hFdmVudChpKX0odCxlKTt2YXIgaT10aGlzLmhhbmRsZXJzW3RdJiZ0aGlzLmhhbmRsZXJzW3RdLnNsaWNlKCk7aWYoaSYmaS5sZW5ndGgpe2UudHlwZT10LGUucHJldmVudERlZmF1bHQ9ZnVuY3Rpb24oKXtlLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCl9O2Zvcih2YXIgbz0wO288aS5sZW5ndGg7KWlbb10oZSksbysrfX0sZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5lbGVtZW50JiZ4YSh0aGlzLCExKSx0aGlzLmhhbmRsZXJzPXt9LHRoaXMuc2Vzc2lvbj17fSx0aGlzLmlucHV0LmRlc3Ryb3koKSx0aGlzLmVsZW1lbnQ9bnVsbH0sdH0oKSxPYT17dG91Y2hzdGFydDoxLHRvdWNobW92ZToyLHRvdWNoZW5kOjQsdG91Y2hjYW5jZWw6OH0sQ2E9XCJ0b3VjaHN0YXJ0XCIsU2E9XCJ0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbFwiLFRhPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgaSxvPWUucHJvdG90eXBlO3JldHVybiBvLmV2VGFyZ2V0PUNhLG8uZXZXaW49U2EsKGk9dC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXMpLnN0YXJ0ZWQ9ITEsaX1yZXR1cm4gS3IoZSx0KSxlLnByb3RvdHlwZS5oYW5kbGVyPWZ1bmN0aW9uKHQpe3ZhciBlPU9hW3QudHlwZV07aWYoMT09PWUmJih0aGlzLnN0YXJ0ZWQ9ITApLHRoaXMuc3RhcnRlZCl7dmFyIGk9TWEuY2FsbCh0aGlzLHQsZSk7MTImZSYmaVswXS5sZW5ndGgtaVsxXS5sZW5ndGg9PTAmJih0aGlzLnN0YXJ0ZWQ9ITEpLHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLGUse3BvaW50ZXJzOmlbMF0sY2hhbmdlZFBvaW50ZXJzOmlbMV0scG9pbnRlclR5cGU6eXMsc3JjRXZlbnQ6dH0pfX0sZX0oTHMpO2Z1bmN0aW9uIE1hKHQsZSl7dmFyIGk9WHModC50b3VjaGVzKSxvPVhzKHQuY2hhbmdlZFRvdWNoZXMpO3JldHVybiAxMiZlJiYoaT1HcyhpLmNvbmNhdChvKSxcImlkZW50aWZpZXJcIiwhMCkpLFtpLG9dfWZ1bmN0aW9uIFBhKHQsZSxpKXt2YXIgbz1cIkRFUFJFQ0FURUQgTUVUSE9EOiBcIitlK1wiXFxuXCIraStcIiBBVCBcXG5cIjtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT1uZXcgRXJyb3IoXCJnZXQtc3RhY2stdHJhY2VcIiksaT1lJiZlLnN0YWNrP2Uuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLFwiXCIpLnJlcGxhY2UoL15cXHMrYXRcXHMrL2dtLFwiXCIpLnJlcGxhY2UoL15PYmplY3QuPGFub255bW91cz5cXHMqXFwoL2dtLFwie2Fub255bW91c30oKUBcIik6XCJVbmtub3duIFN0YWNrIFRyYWNlXCIsbj13aW5kb3cuY29uc29sZSYmKHdpbmRvdy5jb25zb2xlLndhcm58fHdpbmRvdy5jb25zb2xlLmxvZyk7cmV0dXJuIG4mJm4uY2FsbCh3aW5kb3cuY29uc29sZSxvLGkpLHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfX12YXIgRGE9UGEoKGZ1bmN0aW9uKHQsZSxpKXtmb3IodmFyIG89T2JqZWN0LmtleXMoZSksbj0wO248by5sZW5ndGg7KSghaXx8aSYmdm9pZCAwPT09dFtvW25dXSkmJih0W29bbl1dPWVbb1tuXV0pLG4rKztyZXR1cm4gdH0pLFwiZXh0ZW5kXCIsXCJVc2UgYGFzc2lnbmAuXCIpLEJhPVBhKChmdW5jdGlvbih0LGUpe3JldHVybiBEYSh0LGUsITApfSksXCJtZXJnZVwiLFwiVXNlIGBhc3NpZ25gLlwiKTtmdW5jdGlvbiBJYSh0LGUsaSl7dmFyIG8sbj1lLnByb3RvdHlwZTsobz10LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKG4pKS5jb25zdHJ1Y3Rvcj10LG8uX3N1cGVyPW4saSYmWnIobyxpKX1mdW5jdGlvbiB6YSh0LGUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KGUsYXJndW1lbnRzKX19dmFyIEZhPWZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9e30pLG5ldyBFYSh0LEdyKHtyZWNvZ25pemVyczpfYS5jb25jYXQoKX0sZSkpfTtyZXR1cm4gdC5WRVJTSU9OPVwiMi4wLjE3LXJjXCIsdC5ESVJFQ1RJT05fQUxMPTMwLHQuRElSRUNUSU9OX0RPV049YnMsdC5ESVJFQ1RJT05fTEVGVD0yLHQuRElSRUNUSU9OX1JJR0hUPTQsdC5ESVJFQ1RJT05fVVA9OCx0LkRJUkVDVElPTl9IT1JJWk9OVEFMPTYsdC5ESVJFQ1RJT05fVkVSVElDQUw9d3MsdC5ESVJFQ1RJT05fTk9ORT0xLHQuRElSRUNUSU9OX0RPV049YnMsdC5JTlBVVF9TVEFSVD0xLHQuSU5QVVRfTU9WRT0yLHQuSU5QVVRfRU5EPTQsdC5JTlBVVF9DQU5DRUw9OCx0LlNUQVRFX1BPU1NJQkxFPTEsdC5TVEFURV9CRUdBTj0yLHQuU1RBVEVfQ0hBTkdFRD00LHQuU1RBVEVfRU5ERUQ9OCx0LlNUQVRFX1JFQ09HTklaRUQ9OCx0LlNUQVRFX0NBTkNFTExFRD0xNix0LlNUQVRFX0ZBSUxFRD1oYSx0Lk1hbmFnZXI9RWEsdC5JbnB1dD1Mcyx0LlRvdWNoQWN0aW9uPUNzLHQuVG91Y2hJbnB1dD1Rcyx0Lk1vdXNlSW5wdXQ9aWEsdC5Qb2ludGVyRXZlbnRJbnB1dD1Zcyx0LlRvdWNoTW91c2VJbnB1dD1zYSx0LlNpbmdsZVRvdWNoSW5wdXQ9VGEsdC5SZWNvZ25pemVyPXVhLHQuQXR0clJlY29nbml6ZXI9cGEsdC5UYXA9ZmEsdC5QYW49Z2EsdC5Td2lwZT15YSx0LlBpbmNoPW1hLHQuUm90YXRlPWJhLHQuUHJlc3M9d2EsdC5vbj1Bcyx0Lm9mZj1Scyx0LmVhY2g9eHMsdC5tZXJnZT1CYSx0LmV4dGVuZD1EYSx0LmJpbmRGbj16YSx0LmFzc2lnbj1acix0LmluaGVyaXQ9SWEsdC5iaW5kRm49emEsdC5wcmVmaXhlZD1ucyx0LnRvQXJyYXk9WHMsdC5pbkFycmF5PUhzLHQudW5pcXVlQXJyYXk9R3MsdC5zcGxpdFN0cj1Ocyx0LmJvb2xPckZuPUVzLHQuaGFzUGFyZW50PVNzLHQuYWRkRXZlbnRMaXN0ZW5lcnM9QXMsdC5yZW1vdmVFdmVudExpc3RlbmVycz1Scyx0LmRlZmF1bHRzPVpyKHt9LGthLHtwcmVzZXQ6X2F9KSx0fSgpO2Z1bmN0aW9uIE5hKHQsZSl7dmFyIGk7aWYodm9pZCAwPT09Y258fG51bGw9PUNpKHQpKXtpZihnbih0KXx8KGk9ZnVuY3Rpb24odCxlKXt2YXIgaTtpZighdClyZXR1cm47aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIEFhKHQsZSk7dmFyIG89dm4oaT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpLmNhbGwoaSw4LC0xKTtcIk9iamVjdFwiPT09byYmdC5jb25zdHJ1Y3RvciYmKG89dC5jb25zdHJ1Y3Rvci5uYW1lKTtpZihcIk1hcFwiPT09b3x8XCJTZXRcIj09PW8pcmV0dXJuIG1pKHQpO2lmKFwiQXJndW1lbnRzXCI9PT1vfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChvKSlyZXR1cm4gQWEodCxlKX0odCkpfHxlJiZ0JiZcIm51bWJlclwiPT10eXBlb2YgdC5sZW5ndGgpe2kmJih0PWkpO3ZhciBvPTAsbj1mdW5jdGlvbigpe307cmV0dXJue3M6bixuOmZ1bmN0aW9uKCl7cmV0dXJuIG8+PXQubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTp0W28rK119fSxlOmZ1bmN0aW9uKHQpe3Rocm93IHR9LGY6bn19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXZhciByLHM9ITAsYT0hMTtyZXR1cm57czpmdW5jdGlvbigpe2k9U2kodCl9LG46ZnVuY3Rpb24oKXt2YXIgdD1pLm5leHQoKTtyZXR1cm4gcz10LmRvbmUsdH0sZTpmdW5jdGlvbih0KXthPSEwLHI9dH0sZjpmdW5jdGlvbigpe3RyeXtzfHxudWxsPT1pLnJldHVybnx8aS5yZXR1cm4oKX1maW5hbGx5e2lmKGEpdGhyb3cgcn19fX1mdW5jdGlvbiBBYSh0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgaT0wLG89bmV3IEFycmF5KGUpO2k8ZTtpKyspb1tpXT10W2ldO3JldHVybiBvfWZ1bmN0aW9uIFJhKCl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsZT1uZXcgQXJyYXkodCksaT0wO2k8dDtpKyspZVtpXT1hcmd1bWVudHNbaV07cmV0dXJuIGphKGUubGVuZ3RoP2U6W0VuKCldKX1mdW5jdGlvbiBqYSh0KXt2YXIgZT1hbihmdW5jdGlvbigpe2Zvcih2YXIgdD1MYSgpLGU9dChcIiBcIiksaT10KFwiIFwiKSxvPXQoXCIgXCIpLG49MDtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKShlLT10KG48MHx8YXJndW1lbnRzLmxlbmd0aDw9bj92b2lkIDA6YXJndW1lbnRzW25dKSk8MCYmKGUrPTEpLChpLT10KG48MHx8YXJndW1lbnRzLmxlbmd0aDw9bj92b2lkIDA6YXJndW1lbnRzW25dKSk8MCYmKGkrPTEpLChvLT10KG48MHx8YXJndW1lbnRzLmxlbmd0aDw9bj92b2lkIDA6YXJndW1lbnRzW25dKSk8MCYmKG8rPTEpO3JldHVybltlLGksb119KHQpLDMpLGk9ZVswXSxvPWVbMV0sbj1lWzJdLHI9MSxzPWZ1bmN0aW9uKCl7dmFyIHQ9MjA5MTYzOSppKzIuMzI4MzA2NDM2NTM4Njk2M2UtMTAqcjtyZXR1cm4gaT1vLG89bixuPXQtKHI9MHx0KX07cmV0dXJuIHMudWludDMyPWZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5NjcyOTYqcygpfSxzLmZyYWN0NTM9ZnVuY3Rpb24oKXtyZXR1cm4gcygpKzExMTAyMjMwMjQ2MjUxNTY1ZS0zMiooMjA5NzE1MipzKCl8MCl9LHMuYWxnb3JpdGhtPVwiQWxlYVwiLHMuc2VlZD10LHMudmVyc2lvbj1cIjAuOVwiLHN9ZnVuY3Rpb24gTGEoKXt2YXIgdD00MDIyODcxMTk3O3JldHVybiBmdW5jdGlvbihlKXtmb3IodmFyIGk9ZS50b1N0cmluZygpLG89MDtvPGkubGVuZ3RoO28rKyl7dmFyIG49LjAyNTE5NjAzMjgyNDE2OTM4Kih0Kz1pLmNoYXJDb2RlQXQobykpO24tPXQ9bj4+PjAsdD0obio9dCk+Pj4wLHQrPTQyOTQ5NjcyOTYqKG4tPXQpfXJldHVybiAyLjMyODMwNjQzNjUzODY5NjNlLTEwKih0Pj4+MCl9fWNuKFwiREVMRVRFXCIpO3ZhciBIYT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5IYW1tZXJ8fEZhOmZ1bmN0aW9uKCl7cmV0dXJue29uOnQ9ZnVuY3Rpb24oKXt9LG9mZjp0LGRlc3Ryb3k6dCxlbWl0OnQsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJue3NldDp0fX19O3ZhciB0fTtmdW5jdGlvbiBXYSh0KXt2YXIgZSxpPXRoaXM7dGhpcy5fY2xlYW51cFF1ZXVlPVtdLHRoaXMuYWN0aXZlPSExLHRoaXMuX2RvbT17Y29udGFpbmVyOnQsb3ZlcmxheTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpfSx0aGlzLl9kb20ub3ZlcmxheS5jbGFzc0xpc3QuYWRkKFwidmlzLW92ZXJsYXlcIiksdGhpcy5fZG9tLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kb20ub3ZlcmxheSksdGhpcy5fY2xlYW51cFF1ZXVlLnB1c2goKGZ1bmN0aW9uKCl7aS5fZG9tLm92ZXJsYXkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpLl9kb20ub3ZlcmxheSl9KSk7dmFyIG89SGEodGhpcy5fZG9tLm92ZXJsYXkpO28ub24oXCJ0YXBcIixidChlPXRoaXMuX29uVGFwT3ZlcmxheSkuY2FsbChlLHRoaXMpKSx0aGlzLl9jbGVhbnVwUXVldWUucHVzaCgoZnVuY3Rpb24oKXtvLmRlc3Ryb3koKX0pKTt2YXIgbj1bXCJ0YXBcIixcImRvdWJsZXRhcFwiLFwicHJlc3NcIixcInBpbmNoXCIsXCJwYW5cIixcInBhbnN0YXJ0XCIsXCJwYW5tb3ZlXCIsXCJwYW5lbmRcIl07RG4obikuY2FsbChuLChmdW5jdGlvbih0KXtvLm9uKHQsKGZ1bmN0aW9uKHQpe3Quc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCl9KSl9KSksZG9jdW1lbnQmJmRvY3VtZW50LmJvZHkmJih0aGlzLl9vbkNsaWNrPWZ1bmN0aW9uKGUpeyhmdW5jdGlvbih0LGUpe2Zvcig7dDspe2lmKHQ9PT1lKXJldHVybiEwO3Q9dC5wYXJlbnROb2RlfXJldHVybiExfSkoZS50YXJnZXQsdCl8fGkuZGVhY3RpdmF0ZSgpfSxkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX29uQ2xpY2spLHRoaXMuX2NsZWFudXBRdWV1ZS5wdXNoKChmdW5jdGlvbigpe2RvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsaS5fb25DbGljayl9KSkpLHRoaXMuX2VzY0xpc3RlbmVyPWZ1bmN0aW9uKHQpeyhcImtleVwiaW4gdD9cIkVzY2FwZVwiPT09dC5rZXk6Mjc9PT10LmtleUNvZGUpJiZpLmRlYWN0aXZhdGUoKX19Q3QoV2EucHJvdG90eXBlKSxXYS5jdXJyZW50PW51bGwsV2EucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt2YXIgdCxlO3RoaXMuZGVhY3RpdmF0ZSgpO3ZhciBpLG89TmEoTm4odD1xbihlPXRoaXMuX2NsZWFudXBRdWV1ZSkuY2FsbChlLDApKS5jYWxsKHQpKTt0cnl7Zm9yKG8ucygpOyEoaT1vLm4oKSkuZG9uZTspeygwLGkudmFsdWUpKCl9fWNhdGNoKHQpe28uZSh0KX1maW5hbGx5e28uZigpfX0sV2EucHJvdG90eXBlLmFjdGl2YXRlPWZ1bmN0aW9uKCl7V2EuY3VycmVudCYmV2EuY3VycmVudC5kZWFjdGl2YXRlKCksV2EuY3VycmVudD10aGlzLHRoaXMuYWN0aXZlPSEwLHRoaXMuX2RvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy5fZG9tLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidmlzLWFjdGl2ZVwiKSx0aGlzLmVtaXQoXCJjaGFuZ2VcIiksdGhpcy5lbWl0KFwiYWN0aXZhdGVcIiksZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMuX2VzY0xpc3RlbmVyKX0sV2EucHJvdG90eXBlLmRlYWN0aXZhdGU9ZnVuY3Rpb24oKXt0aGlzLmFjdGl2ZT0hMSx0aGlzLl9kb20ub3ZlcmxheS5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIix0aGlzLl9kb20uY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJ2aXMtYWN0aXZlXCIpLGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLl9lc2NMaXN0ZW5lciksdGhpcy5lbWl0KFwiY2hhbmdlXCIpLHRoaXMuZW1pdChcImRlYWN0aXZhdGVcIil9LFdhLnByb3RvdHlwZS5fb25UYXBPdmVybGF5PWZ1bmN0aW9uKHQpe3RoaXMuYWN0aXZhdGUoKSx0LnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpfTt2YXIgVmE9L14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaSxxYT0vXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pLFVhPS9ecmdiXFwoICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqLCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICpcXCkkL2ksWWE9L15yZ2JhXFwoICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqLCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICosICooWzAxXXwwP1xcLlxcZCspICpcXCkkL2k7ZnVuY3Rpb24gWGEodCl7aWYodClmb3IoOyEwPT09dC5oYXNDaGlsZE5vZGVzKCk7KXt2YXIgZT10LmZpcnN0Q2hpbGQ7ZSYmKFhhKGUpLHQucmVtb3ZlQ2hpbGQoZSkpfX1mdW5jdGlvbiBHYSh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFN0cmluZ3x8XCJzdHJpbmdcIj09dHlwZW9mIHR9ZnVuY3Rpb24gS2EodCl7cmV0dXJuXCJvYmplY3RcIj09PWRuKHQpJiZudWxsIT09dH1mdW5jdGlvbiAkYSh0LGUsaSxvKXt2YXIgbj0hMTshMD09PW8mJihuPW51bGw9PT1lW2ldJiZ2b2lkIDAhPT10W2ldKSxuP2RlbGV0ZSB0W2ldOnRbaV09ZVtpXX1mdW5jdGlvbiBRYSh0LGUpe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07Zm9yKHZhciBvIGluIHQpaWYodm9pZCAwIT09ZVtvXSlpZihudWxsPT09ZVtvXXx8XCJvYmplY3RcIiE9PWRuKGVbb10pKSRhKHQsZSxvLGkpO2Vsc2V7dmFyIG49dFtvXSxyPWVbb107S2EobikmJkthKHIpJiZRYShuLHIsaSl9fWZ1bmN0aW9uIFphKHQsZSxpKXt2YXIgbz1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXSYmYXJndW1lbnRzWzNdO2lmKGduKGkpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZFwiKTtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSxyKSlpZihpW3JdJiZpW3JdLmNvbnN0cnVjdG9yPT09T2JqZWN0KXZvaWQgMD09PWVbcl0mJihlW3JdPXt9KSxlW3JdLmNvbnN0cnVjdG9yPT09T2JqZWN0P3RoKGVbcl0saVtyXSwhMSxvKTokYShlLGkscixvKTtlbHNle2lmKGduKGlbcl0pKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZFwiKTskYShlLGkscixvKX19cmV0dXJuIGV9ZnVuY3Rpb24gSmEodCxlLGkpe3ZhciBvPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdJiZhcmd1bWVudHNbM107aWYoZ24oaSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kXCIpO2Zvcih2YXIgbiBpbiBpKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLG4pJiYhSm4odCkuY2FsbCh0LG4pKWlmKGlbbl0mJmlbbl0uY29uc3RydWN0b3I9PT1PYmplY3Qpdm9pZCAwPT09ZVtuXSYmKGVbbl09e30pLGVbbl0uY29uc3RydWN0b3I9PT1PYmplY3Q/dGgoZVtuXSxpW25dKTokYShlLGksbixvKTtlbHNlIGlmKGduKGlbbl0pKXtlW25dPVtdO2Zvcih2YXIgcj0wO3I8aVtuXS5sZW5ndGg7cisrKWVbbl0ucHVzaChpW25dW3JdKX1lbHNlICRhKGUsaSxuLG8pO3JldHVybiBlfWZ1bmN0aW9uIHRoKHQsZSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXSxvPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdJiZhcmd1bWVudHNbM107Zm9yKHZhciBuIGluIGUpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbil8fCEwPT09aSlpZihcIm9iamVjdFwiPT09ZG4oZVtuXSkmJm51bGwhPT1lW25dJiZpcihlW25dKT09PU9iamVjdC5wcm90b3R5cGUpdm9pZCAwPT09dFtuXT90W25dPXRoKHt9LGVbbl0saSk6XCJvYmplY3RcIj09PWRuKHRbbl0pJiZudWxsIT09dFtuXSYmaXIodFtuXSk9PT1PYmplY3QucHJvdG90eXBlP3RoKHRbbl0sZVtuXSxpKTokYSh0LGUsbixvKTtlbHNlIGlmKGduKGVbbl0pKXt2YXIgcjt0W25dPXZuKHI9ZVtuXSkuY2FsbChyKX1lbHNlICRhKHQsZSxuLG8pO3JldHVybiB0fWZ1bmN0aW9uIGVoKHQsZSl7dmFyIGk7cmV0dXJuIHBuKGk9W10pLmNhbGwoaSxsbih0KSxbZV0pfWZ1bmN0aW9uIGloKHQpe3JldHVybiB2bih0KS5jYWxsKHQpfWZ1bmN0aW9uIG9oKHQpe3JldHVybiB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcH1mdW5jdGlvbiBuaCh0LGUpe2lmKGduKHQpKWZvcih2YXIgaT10Lmxlbmd0aCxvPTA7bzxpO28rKyllKHRbb10sbyx0KTtlbHNlIGZvcih2YXIgbiBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiZlKHRbbl0sbix0KX1mdW5jdGlvbiByaCh0KXt2YXIgZTtzd2l0Y2godC5sZW5ndGgpe2Nhc2UgMzpjYXNlIDQ6cmV0dXJuKGU9cWEuZXhlYyh0KSk/e3I6a3IoZVsxXStlWzFdLDE2KSxnOmtyKGVbMl0rZVsyXSwxNiksYjprcihlWzNdK2VbM10sMTYpfTpudWxsO2Nhc2UgNjpjYXNlIDc6cmV0dXJuKGU9VmEuZXhlYyh0KSk/e3I6a3IoZVsxXSwxNiksZzprcihlWzJdLDE2KSxiOmtyKGVbM10sMTYpfTpudWxsO2RlZmF1bHQ6cmV0dXJuIG51bGx9fWZ1bmN0aW9uIHNoKHQsZSl7aWYoSm4odCkuY2FsbCh0LFwicmdiYVwiKSlyZXR1cm4gdDtpZihKbih0KS5jYWxsKHQsXCJyZ2JcIikpe3ZhciBpPXQuc3Vic3RyKE1yKHQpLmNhbGwodCxcIihcIikrMSkucmVwbGFjZShcIilcIixcIlwiKS5zcGxpdChcIixcIik7cmV0dXJuXCJyZ2JhKFwiK2lbMF0rXCIsXCIraVsxXStcIixcIitpWzJdK1wiLFwiK2UrXCIpXCJ9dmFyIG89cmgodCk7cmV0dXJuIG51bGw9PW8/dDpcInJnYmEoXCIrby5yK1wiLFwiK28uZytcIixcIitvLmIrXCIsXCIrZStcIilcIn1mdW5jdGlvbiBhaCh0LGUsaSl7dmFyIG87cmV0dXJuXCIjXCIrdm4obz0oKDE8PDI0KSsodDw8MTYpKyhlPDw4KStpKS50b1N0cmluZygxNikpLmNhbGwobywxKX1mdW5jdGlvbiBoaCh0LGUpe2lmKEdhKHQpKXt2YXIgaT10O2lmKGZoKGkpKXt2YXIgbyxuPWtuKG89aS5zdWJzdHIoNCkuc3Vic3RyKDAsaS5sZW5ndGgtNSkuc3BsaXQoXCIsXCIpKS5jYWxsKG8sKGZ1bmN0aW9uKHQpe3JldHVybiBrcih0KX0pKTtpPWFoKG5bMF0sblsxXSxuWzJdKX1pZighMD09PXVoKGkpKXt2YXIgcj1mdW5jdGlvbih0KXt2YXIgZT1yaCh0KTtpZighZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ1wiLmNvbmNhdCh0LFwiJyBpcyBub3QgYSB2YWxpZCBjb2xvci5cIikpO3JldHVybiBkaChlLnIsZS5nLGUuYil9KGkpLHM9e2g6ci5oLHM6Ljgqci5zLHY6TWF0aC5taW4oMSwxLjAyKnIudil9LGE9e2g6ci5oLHM6TWF0aC5taW4oMSwxLjI1KnIucyksdjouOCpyLnZ9LGg9Y2goYS5oLGEucyxhLnYpLGQ9Y2gocy5oLHMucyxzLnYpO3JldHVybntiYWNrZ3JvdW5kOmksYm9yZGVyOmgsaGlnaGxpZ2h0OntiYWNrZ3JvdW5kOmQsYm9yZGVyOmh9LGhvdmVyOntiYWNrZ3JvdW5kOmQsYm9yZGVyOmh9fX1yZXR1cm57YmFja2dyb3VuZDppLGJvcmRlcjppLGhpZ2hsaWdodDp7YmFja2dyb3VuZDppLGJvcmRlcjppfSxob3Zlcjp7YmFja2dyb3VuZDppLGJvcmRlcjppfX19cmV0dXJuIGU/e2JhY2tncm91bmQ6dC5iYWNrZ3JvdW5kfHxlLmJhY2tncm91bmQsYm9yZGVyOnQuYm9yZGVyfHxlLmJvcmRlcixoaWdobGlnaHQ6R2EodC5oaWdobGlnaHQpP3tib3JkZXI6dC5oaWdobGlnaHQsYmFja2dyb3VuZDp0LmhpZ2hsaWdodH06e2JhY2tncm91bmQ6dC5oaWdobGlnaHQmJnQuaGlnaGxpZ2h0LmJhY2tncm91bmR8fGUuaGlnaGxpZ2h0LmJhY2tncm91bmQsYm9yZGVyOnQuaGlnaGxpZ2h0JiZ0LmhpZ2hsaWdodC5ib3JkZXJ8fGUuaGlnaGxpZ2h0LmJvcmRlcn0saG92ZXI6R2EodC5ob3Zlcik/e2JvcmRlcjp0LmhvdmVyLGJhY2tncm91bmQ6dC5ob3Zlcn06e2JvcmRlcjp0LmhvdmVyJiZ0LmhvdmVyLmJvcmRlcnx8ZS5ob3Zlci5ib3JkZXIsYmFja2dyb3VuZDp0LmhvdmVyJiZ0LmhvdmVyLmJhY2tncm91bmR8fGUuaG92ZXIuYmFja2dyb3VuZH19OntiYWNrZ3JvdW5kOnQuYmFja2dyb3VuZHx8dm9pZCAwLGJvcmRlcjp0LmJvcmRlcnx8dm9pZCAwLGhpZ2hsaWdodDpHYSh0LmhpZ2hsaWdodCk/e2JvcmRlcjp0LmhpZ2hsaWdodCxiYWNrZ3JvdW5kOnQuaGlnaGxpZ2h0fTp7YmFja2dyb3VuZDp0LmhpZ2hsaWdodCYmdC5oaWdobGlnaHQuYmFja2dyb3VuZHx8dm9pZCAwLGJvcmRlcjp0LmhpZ2hsaWdodCYmdC5oaWdobGlnaHQuYm9yZGVyfHx2b2lkIDB9LGhvdmVyOkdhKHQuaG92ZXIpP3tib3JkZXI6dC5ob3ZlcixiYWNrZ3JvdW5kOnQuaG92ZXJ9Ontib3JkZXI6dC5ob3ZlciYmdC5ob3Zlci5ib3JkZXJ8fHZvaWQgMCxiYWNrZ3JvdW5kOnQuaG92ZXImJnQuaG92ZXIuYmFja2dyb3VuZHx8dm9pZCAwfX19ZnVuY3Rpb24gZGgodCxlLGkpe3QvPTI1NSxlLz0yNTUsaS89MjU1O3ZhciBvPU1hdGgubWluKHQsTWF0aC5taW4oZSxpKSksbj1NYXRoLm1heCh0LE1hdGgubWF4KGUsaSkpO3JldHVybiBvPT09bj97aDowLHM6MCx2Om99OntoOjYwKigodD09PW8/MzppPT09bz8xOjUpLSh0PT09bz9lLWk6aT09PW8/dC1lOmktdCkvKG4tbykpLzM2MCxzOihuLW8pL24sdjpufX1mdW5jdGlvbiBsaCh0LGUsaSl7dmFyIG8sbixyLHM9TWF0aC5mbG9vcig2KnQpLGE9Nip0LXMsaD1pKigxLWUpLGQ9aSooMS1hKmUpLGw9aSooMS0oMS1hKSplKTtzd2l0Y2gocyU2KXtjYXNlIDA6bz1pLG49bCxyPWg7YnJlYWs7Y2FzZSAxOm89ZCxuPWkscj1oO2JyZWFrO2Nhc2UgMjpvPWgsbj1pLHI9bDticmVhaztjYXNlIDM6bz1oLG49ZCxyPWk7YnJlYWs7Y2FzZSA0Om89bCxuPWgscj1pO2JyZWFrO2Nhc2UgNTpvPWksbj1oLHI9ZH1yZXR1cm57cjpNYXRoLmZsb29yKDI1NSpvKSxnOk1hdGguZmxvb3IoMjU1Km4pLGI6TWF0aC5mbG9vcigyNTUqcil9fWZ1bmN0aW9uIGNoKHQsZSxpKXt2YXIgbz1saCh0LGUsaSk7cmV0dXJuIGFoKG8ucixvLmcsby5iKX1mdW5jdGlvbiB1aCh0KXtyZXR1cm4vKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpL2kudGVzdCh0KX1mdW5jdGlvbiBmaCh0KXtyZXR1cm4gVWEudGVzdCh0KX1mdW5jdGlvbiBwaCh0KXtyZXR1cm4gWWEudGVzdCh0KX1mdW5jdGlvbiB2aCh0KXtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9PWRuKHQpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiBFbGVtZW50KXJldHVybiB0O3ZhciBlPUlyKHQpO2Zvcih2YXIgaSBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGkpJiZcIm9iamVjdFwiPT1kbih0W2ldKSYmKGVbaV09dmgodFtpXSkpO3JldHVybiBlfWZ1bmN0aW9uIGdoKHQsZSxpKXt2YXIgbz1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106e30sbj1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dH0scj1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9PXQmJlwib2JqZWN0XCI9PT1kbih0KX0scz1mdW5jdGlvbih0KXtmb3IodmFyIGUgaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSlyZXR1cm4hMTtyZXR1cm4hMH07aWYoIXIodCkpdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG1lcmdlVGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0XCIpO2lmKCFyKGUpKXRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0XCIpO2lmKCFuKGkpKXRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBvcHRpb24gbXVzdCBoYXZlIGEgdmFsdWVcIik7aWYoIXIobykpdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIGdsb2JhbE9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3RcIik7dmFyIGE9ZnVuY3Rpb24odCxlLGkpe3IodFtpXSl8fCh0W2ldPXt9KTt2YXIgbz1lW2ldLG49dFtpXTtmb3IodmFyIHMgaW4gbylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobyxzKSYmKG5bc109b1tzXSl9LGg9ZVtpXSxkPXIobykmJiFzKG8pLGw9ZD9vW2ldOnZvaWQgMCxjPWw/bC5lbmFibGVkOnZvaWQgMDtpZih2b2lkIDAhPT1oKXtpZihcImJvb2xlYW5cIj09dHlwZW9mIGgpcmV0dXJuIHIodFtpXSl8fCh0W2ldPXt9KSx2b2lkKHRbaV0uZW5hYmxlZD1oKTtpZihudWxsPT09aCYmIXIodFtpXSkpe2lmKCFuKGwpKXJldHVybjt0W2ldPUlyKGwpfWlmKHIoaCkpe3ZhciB1PSEwO3ZvaWQgMCE9PWguZW5hYmxlZD91PWguZW5hYmxlZDp2b2lkIDAhPT1jJiYodT1sLmVuYWJsZWQpLGEodCxlLGkpLHRbaV0uZW5hYmxlZD11fX19dmFyIHloPXtsaW5lYXI6ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGVhc2VJblF1YWQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQqdH0sZWFzZU91dFF1YWQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQqKDItdCl9LGVhc2VJbk91dFF1YWQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQ8LjU/Mip0KnQ6KDQtMip0KSp0LTF9LGVhc2VJbkN1YmljOmZ1bmN0aW9uKHQpe3JldHVybiB0KnQqdH0sZWFzZU91dEN1YmljOmZ1bmN0aW9uKHQpe3JldHVybi0tdCp0KnQrMX0sZWFzZUluT3V0Q3ViaWM6ZnVuY3Rpb24odCl7cmV0dXJuIHQ8LjU/NCp0KnQqdDoodC0xKSooMip0LTIpKigyKnQtMikrMX0sZWFzZUluUXVhcnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQqdCp0KnR9LGVhc2VPdXRRdWFydDpmdW5jdGlvbih0KXtyZXR1cm4gMS0gLS10KnQqdCp0fSxlYXNlSW5PdXRRdWFydDpmdW5jdGlvbih0KXtyZXR1cm4gdDwuNT84KnQqdCp0KnQ6MS04Ki0tdCp0KnQqdH0sZWFzZUluUXVpbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQqdCp0KnQqdH0sZWFzZU91dFF1aW50OmZ1bmN0aW9uKHQpe3JldHVybiAxKy0tdCp0KnQqdCp0fSxlYXNlSW5PdXRRdWludDpmdW5jdGlvbih0KXtyZXR1cm4gdDwuNT8xNip0KnQqdCp0KnQ6MSsxNiotLXQqdCp0KnQqdH19O2Z1bmN0aW9uIG1oKHQsZSl7dmFyIGk7Z24oZSl8fChlPVtlXSk7dmFyIG8sbj1OYSh0KTt0cnl7Zm9yKG4ucygpOyEobz1uLm4oKSkuZG9uZTspe3ZhciByPW8udmFsdWU7aWYocil7aT1yW2VbMF1dO2Zvcih2YXIgcz0xO3M8ZS5sZW5ndGg7cysrKWkmJihpPWlbZVtzXV0pO2lmKHZvaWQgMCE9PWkpYnJlYWt9fX1jYXRjaCh0KXtuLmUodCl9ZmluYWxseXtuLmYoKX1yZXR1cm4gaX12YXIgYmg9e2JsYWNrOlwiIzAwMDAwMFwiLG5hdnk6XCIjMDAwMDgwXCIsZGFya2JsdWU6XCIjMDAwMDhCXCIsbWVkaXVtYmx1ZTpcIiMwMDAwQ0RcIixibHVlOlwiIzAwMDBGRlwiLGRhcmtncmVlbjpcIiMwMDY0MDBcIixncmVlbjpcIiMwMDgwMDBcIix0ZWFsOlwiIzAwODA4MFwiLGRhcmtjeWFuOlwiIzAwOEI4QlwiLGRlZXBza3libHVlOlwiIzAwQkZGRlwiLGRhcmt0dXJxdW9pc2U6XCIjMDBDRUQxXCIsbWVkaXVtc3ByaW5nZ3JlZW46XCIjMDBGQTlBXCIsbGltZTpcIiMwMEZGMDBcIixzcHJpbmdncmVlbjpcIiMwMEZGN0ZcIixhcXVhOlwiIzAwRkZGRlwiLGN5YW46XCIjMDBGRkZGXCIsbWlkbmlnaHRibHVlOlwiIzE5MTk3MFwiLGRvZGdlcmJsdWU6XCIjMUU5MEZGXCIsbGlnaHRzZWFncmVlbjpcIiMyMEIyQUFcIixmb3Jlc3RncmVlbjpcIiMyMjhCMjJcIixzZWFncmVlbjpcIiMyRThCNTdcIixkYXJrc2xhdGVncmF5OlwiIzJGNEY0RlwiLGxpbWVncmVlbjpcIiMzMkNEMzJcIixtZWRpdW1zZWFncmVlbjpcIiMzQ0IzNzFcIix0dXJxdW9pc2U6XCIjNDBFMEQwXCIscm95YWxibHVlOlwiIzQxNjlFMVwiLHN0ZWVsYmx1ZTpcIiM0NjgyQjRcIixkYXJrc2xhdGVibHVlOlwiIzQ4M0Q4QlwiLG1lZGl1bXR1cnF1b2lzZTpcIiM0OEQxQ0NcIixpbmRpZ286XCIjNEIwMDgyXCIsZGFya29saXZlZ3JlZW46XCIjNTU2QjJGXCIsY2FkZXRibHVlOlwiIzVGOUVBMFwiLGNvcm5mbG93ZXJibHVlOlwiIzY0OTVFRFwiLG1lZGl1bWFxdWFtYXJpbmU6XCIjNjZDREFBXCIsZGltZ3JheTpcIiM2OTY5NjlcIixzbGF0ZWJsdWU6XCIjNkE1QUNEXCIsb2xpdmVkcmFiOlwiIzZCOEUyM1wiLHNsYXRlZ3JheTpcIiM3MDgwOTBcIixsaWdodHNsYXRlZ3JheTpcIiM3Nzg4OTlcIixtZWRpdW1zbGF0ZWJsdWU6XCIjN0I2OEVFXCIsbGF3bmdyZWVuOlwiIzdDRkMwMFwiLGNoYXJ0cmV1c2U6XCIjN0ZGRjAwXCIsYXF1YW1hcmluZTpcIiM3RkZGRDRcIixtYXJvb246XCIjODAwMDAwXCIscHVycGxlOlwiIzgwMDA4MFwiLG9saXZlOlwiIzgwODAwMFwiLGdyYXk6XCIjODA4MDgwXCIsc2t5Ymx1ZTpcIiM4N0NFRUJcIixsaWdodHNreWJsdWU6XCIjODdDRUZBXCIsYmx1ZXZpb2xldDpcIiM4QTJCRTJcIixkYXJrcmVkOlwiIzhCMDAwMFwiLGRhcmttYWdlbnRhOlwiIzhCMDA4QlwiLHNhZGRsZWJyb3duOlwiIzhCNDUxM1wiLGRhcmtzZWFncmVlbjpcIiM4RkJDOEZcIixsaWdodGdyZWVuOlwiIzkwRUU5MFwiLG1lZGl1bXB1cnBsZTpcIiM5MzcwRDhcIixkYXJrdmlvbGV0OlwiIzk0MDBEM1wiLHBhbGVncmVlbjpcIiM5OEZCOThcIixkYXJrb3JjaGlkOlwiIzk5MzJDQ1wiLHllbGxvd2dyZWVuOlwiIzlBQ0QzMlwiLHNpZW5uYTpcIiNBMDUyMkRcIixicm93bjpcIiNBNTJBMkFcIixkYXJrZ3JheTpcIiNBOUE5QTlcIixsaWdodGJsdWU6XCIjQUREOEU2XCIsZ3JlZW55ZWxsb3c6XCIjQURGRjJGXCIscGFsZXR1cnF1b2lzZTpcIiNBRkVFRUVcIixsaWdodHN0ZWVsYmx1ZTpcIiNCMEM0REVcIixwb3dkZXJibHVlOlwiI0IwRTBFNlwiLGZpcmVicmljazpcIiNCMjIyMjJcIixkYXJrZ29sZGVucm9kOlwiI0I4ODYwQlwiLG1lZGl1bW9yY2hpZDpcIiNCQTU1RDNcIixyb3N5YnJvd246XCIjQkM4RjhGXCIsZGFya2toYWtpOlwiI0JEQjc2QlwiLHNpbHZlcjpcIiNDMEMwQzBcIixtZWRpdW12aW9sZXRyZWQ6XCIjQzcxNTg1XCIsaW5kaWFucmVkOlwiI0NENUM1Q1wiLHBlcnU6XCIjQ0Q4NTNGXCIsY2hvY29sYXRlOlwiI0QyNjkxRVwiLHRhbjpcIiNEMkI0OENcIixsaWdodGdyZXk6XCIjRDNEM0QzXCIscGFsZXZpb2xldHJlZDpcIiNEODcwOTNcIix0aGlzdGxlOlwiI0Q4QkZEOFwiLG9yY2hpZDpcIiNEQTcwRDZcIixnb2xkZW5yb2Q6XCIjREFBNTIwXCIsY3JpbXNvbjpcIiNEQzE0M0NcIixnYWluc2Jvcm86XCIjRENEQ0RDXCIscGx1bTpcIiNEREEwRERcIixidXJseXdvb2Q6XCIjREVCODg3XCIsbGlnaHRjeWFuOlwiI0UwRkZGRlwiLGxhdmVuZGVyOlwiI0U2RTZGQVwiLGRhcmtzYWxtb246XCIjRTk5NjdBXCIsdmlvbGV0OlwiI0VFODJFRVwiLHBhbGVnb2xkZW5yb2Q6XCIjRUVFOEFBXCIsbGlnaHRjb3JhbDpcIiNGMDgwODBcIixraGFraTpcIiNGMEU2OENcIixhbGljZWJsdWU6XCIjRjBGOEZGXCIsaG9uZXlkZXc6XCIjRjBGRkYwXCIsYXp1cmU6XCIjRjBGRkZGXCIsc2FuZHlicm93bjpcIiNGNEE0NjBcIix3aGVhdDpcIiNGNURFQjNcIixiZWlnZTpcIiNGNUY1RENcIix3aGl0ZXNtb2tlOlwiI0Y1RjVGNVwiLG1pbnRjcmVhbTpcIiNGNUZGRkFcIixnaG9zdHdoaXRlOlwiI0Y4RjhGRlwiLHNhbG1vbjpcIiNGQTgwNzJcIixhbnRpcXVld2hpdGU6XCIjRkFFQkQ3XCIsbGluZW46XCIjRkFGMEU2XCIsbGlnaHRnb2xkZW5yb2R5ZWxsb3c6XCIjRkFGQUQyXCIsb2xkbGFjZTpcIiNGREY1RTZcIixyZWQ6XCIjRkYwMDAwXCIsZnVjaHNpYTpcIiNGRjAwRkZcIixtYWdlbnRhOlwiI0ZGMDBGRlwiLGRlZXBwaW5rOlwiI0ZGMTQ5M1wiLG9yYW5nZXJlZDpcIiNGRjQ1MDBcIix0b21hdG86XCIjRkY2MzQ3XCIsaG90cGluazpcIiNGRjY5QjRcIixjb3JhbDpcIiNGRjdGNTBcIixkYXJrb3JhbmdlOlwiI0ZGOEMwMFwiLGxpZ2h0c2FsbW9uOlwiI0ZGQTA3QVwiLG9yYW5nZTpcIiNGRkE1MDBcIixsaWdodHBpbms6XCIjRkZCNkMxXCIscGluazpcIiNGRkMwQ0JcIixnb2xkOlwiI0ZGRDcwMFwiLHBlYWNocHVmZjpcIiNGRkRBQjlcIixuYXZham93aGl0ZTpcIiNGRkRFQURcIixtb2NjYXNpbjpcIiNGRkU0QjVcIixiaXNxdWU6XCIjRkZFNEM0XCIsbWlzdHlyb3NlOlwiI0ZGRTRFMVwiLGJsYW5jaGVkYWxtb25kOlwiI0ZGRUJDRFwiLHBhcGF5YXdoaXA6XCIjRkZFRkQ1XCIsbGF2ZW5kZXJibHVzaDpcIiNGRkYwRjVcIixzZWFzaGVsbDpcIiNGRkY1RUVcIixjb3Juc2lsazpcIiNGRkY4RENcIixsZW1vbmNoaWZmb246XCIjRkZGQUNEXCIsZmxvcmFsd2hpdGU6XCIjRkZGQUYwXCIsc25vdzpcIiNGRkZBRkFcIix5ZWxsb3c6XCIjRkZGRjAwXCIsbGlnaHR5ZWxsb3c6XCIjRkZGRkUwXCIsaXZvcnk6XCIjRkZGRkYwXCIsd2hpdGU6XCIjRkZGRkZGXCJ9LHdoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXToxO1BvKHRoaXMsdCksdGhpcy5waXhlbFJhdGlvPWUsdGhpcy5nZW5lcmF0ZWQ9ITEsdGhpcy5jZW50ZXJDb29yZGluYXRlcz17eDoxNDQuNSx5OjE0NC41fSx0aGlzLnI9Mjg5Ki40OSx0aGlzLmNvbG9yPXtyOjI1NSxnOjI1NSxiOjI1NSxhOjF9LHRoaXMuaHVlQ2lyY2xlPXZvaWQgMCx0aGlzLmluaXRpYWxDb2xvcj17cjoyNTUsZzoyNTUsYjoyNTUsYToxfSx0aGlzLnByZXZpb3VzQ29sb3I9dm9pZCAwLHRoaXMuYXBwbGllZD0hMSx0aGlzLnVwZGF0ZUNhbGxiYWNrPWZ1bmN0aW9uKCl7fSx0aGlzLmNsb3NlQ2FsbGJhY2s9ZnVuY3Rpb24oKXt9LHRoaXMuX2NyZWF0ZSgpfXJldHVybiBJbyh0LFt7a2V5OlwiaW5zZXJ0VG9cIix2YWx1ZTpmdW5jdGlvbih0KXt2b2lkIDAhPT10aGlzLmhhbW1lciYmKHRoaXMuaGFtbWVyLmRlc3Ryb3koKSx0aGlzLmhhbW1lcj12b2lkIDApLHRoaXMuY29udGFpbmVyPXQsdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSksdGhpcy5fYmluZEhhbW1lcigpLHRoaXMuX3NldFNpemUoKX19LHtrZXk6XCJzZXRVcGRhdGVDYWxsYmFja1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gYXR0ZW1wdGVkIHRvIHNldCBhcyBjb2xvclBpY2tlciB1cGRhdGUgY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uXCIpO3RoaXMudXBkYXRlQ2FsbGJhY2s9dH19LHtrZXk6XCJzZXRDbG9zZUNhbGxiYWNrXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBhdHRlbXB0ZWQgdG8gc2V0IGFzIGNvbG9yUGlja2VyIGNsb3NpbmcgY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uXCIpO3RoaXMuY2xvc2VDYWxsYmFjaz10fX0se2tleTpcIl9pc0NvbG9yU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIGJoW3RdfX0se2tleTpcInNldENvbG9yXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9IShhcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSl8fGFyZ3VtZW50c1sxXTtpZihcIm5vbmVcIiE9PXQpe3ZhciBpLG89dGhpcy5faXNDb2xvclN0cmluZyh0KTtpZih2b2lkIDAhPT1vJiYodD1vKSwhMD09PUdhKHQpKXtpZighMD09PWZoKHQpKXt2YXIgbj10LnN1YnN0cig0KS5zdWJzdHIoMCx0Lmxlbmd0aC01KS5zcGxpdChcIixcIik7aT17cjpuWzBdLGc6blsxXSxiOm5bMl0sYToxfX1lbHNlIGlmKCEwPT09cGgodCkpe3ZhciByPXQuc3Vic3RyKDUpLnN1YnN0cigwLHQubGVuZ3RoLTYpLnNwbGl0KFwiLFwiKTtpPXtyOnJbMF0sZzpyWzFdLGI6clsyXSxhOnJbM119fWVsc2UgaWYoITA9PT11aCh0KSl7dmFyIHM9cmgodCk7aT17cjpzLnIsZzpzLmcsYjpzLmIsYToxfX19ZWxzZSBpZih0IGluc3RhbmNlb2YgT2JqZWN0JiZ2b2lkIDAhPT10LnImJnZvaWQgMCE9PXQuZyYmdm9pZCAwIT09dC5iKXt2YXIgYT12b2lkIDAhPT10LmE/dC5hOlwiMS4wXCI7aT17cjp0LnIsZzp0LmcsYjp0LmIsYTphfX1pZih2b2lkIDA9PT1pKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29sb3IgcGFzc2VkIHRvIHRoZSBjb2xvclBpY2tlci4gU3VwcG9ydGVkIGFyZSBzdHJpbmdzOiByZ2IsIGhleCwgcmdiYS4gT2JqZWN0OiByZ2IgKHtyOnIsZzpnLGI6YixbYTphXX0pLiBTdXBwbGllZDogXCIrTHIodCkpO3RoaXMuX3NldENvbG9yKGksZSl9fX0se2tleTpcInNob3dcIix2YWx1ZTpmdW5jdGlvbigpe3ZvaWQgMCE9PXRoaXMuY2xvc2VDYWxsYmFjayYmKHRoaXMuY2xvc2VDYWxsYmFjaygpLHRoaXMuY2xvc2VDYWxsYmFjaz12b2lkIDApLHRoaXMuYXBwbGllZD0hMSx0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHRoaXMuX2dlbmVyYXRlSHVlQ2lyY2xlKCl9fSx7a2V5OlwiX2hpZGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT0hKGFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdKXx8YXJndW1lbnRzWzBdOyEwPT09ZSYmKHRoaXMucHJldmlvdXNDb2xvcj1jdCh7fSx0aGlzLmNvbG9yKSksITA9PT10aGlzLmFwcGxpZWQmJnRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5pbml0aWFsQ29sb3IpLHRoaXMuZnJhbWUuc3R5bGUuZGlzcGxheT1cIm5vbmVcIixxcigoZnVuY3Rpb24oKXt2b2lkIDAhPT10LmNsb3NlQ2FsbGJhY2smJih0LmNsb3NlQ2FsbGJhY2soKSx0LmNsb3NlQ2FsbGJhY2s9dm9pZCAwKX0pLDApfX0se2tleTpcIl9zYXZlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuY29sb3IpLHRoaXMuYXBwbGllZD0hMSx0aGlzLl9oaWRlKCl9fSx7a2V5OlwiX2FwcGx5XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmFwcGxpZWQ9ITAsdGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmNvbG9yKSx0aGlzLl91cGRhdGVQaWNrZXIodGhpcy5jb2xvcil9fSx7a2V5OlwiX2xvYWRMYXN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2b2lkIDAhPT10aGlzLnByZXZpb3VzQ29sb3I/dGhpcy5zZXRDb2xvcih0aGlzLnByZXZpb3VzQ29sb3IsITEpOmFsZXJ0KFwiVGhlcmUgaXMgbm8gbGFzdCBjb2xvciB0byBsb2FkLi4uXCIpfX0se2tleTpcIl9zZXRDb2xvclwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV07ITA9PT1lJiYodGhpcy5pbml0aWFsQ29sb3I9Y3Qoe30sdCkpLHRoaXMuY29sb3I9dDt2YXIgaT1kaCh0LnIsdC5nLHQuYiksbz0yKk1hdGguUEksbj10aGlzLnIqaS5zLHI9dGhpcy5jZW50ZXJDb29yZGluYXRlcy54K24qTWF0aC5zaW4obyppLmgpLHM9dGhpcy5jZW50ZXJDb29yZGluYXRlcy55K24qTWF0aC5jb3MobyppLmgpO3RoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS5sZWZ0PXItLjUqdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudFdpZHRoK1wicHhcIix0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wPXMtLjUqdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudEhlaWdodCtcInB4XCIsdGhpcy5fdXBkYXRlUGlja2VyKHQpfX0se2tleTpcIl9zZXRPcGFjaXR5XCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5jb2xvci5hPXQvMTAwLHRoaXMuX3VwZGF0ZVBpY2tlcih0aGlzLmNvbG9yKX19LHtrZXk6XCJfc2V0QnJpZ2h0bmVzc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWRoKHRoaXMuY29sb3Iucix0aGlzLmNvbG9yLmcsdGhpcy5jb2xvci5iKTtlLnY9dC8xMDA7dmFyIGk9bGgoZS5oLGUucyxlLnYpO2kuYT10aGlzLmNvbG9yLmEsdGhpcy5jb2xvcj1pLHRoaXMuX3VwZGF0ZVBpY2tlcigpfX0se2tleTpcIl91cGRhdGVQaWNrZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp0aGlzLmNvbG9yLGU9ZGgodC5yLHQuZyx0LmIpLGk9dGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7dm9pZCAwPT09dGhpcy5waXhlbFJhdGlvbiYmKHRoaXMucGl4ZWxSYXRpbz0od2luZG93LmRldmljZVBpeGVsUmF0aW98fDEpLyhpLndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW98fGkubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8aS5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW98fGkub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW98fGkuYmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8MSkpLGkuc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywwLDAsdGhpcy5waXhlbFJhdGlvLDAsMCk7dmFyIG89dGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRXaWR0aCxuPXRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50SGVpZ2h0O2kuY2xlYXJSZWN0KDAsMCxvLG4pLGkucHV0SW1hZ2VEYXRhKHRoaXMuaHVlQ2lyY2xlLDAsMCksaS5maWxsU3R5bGU9XCJyZ2JhKDAsMCwwLFwiKygxLWUudikrXCIpXCIsaS5jaXJjbGUodGhpcy5jZW50ZXJDb29yZGluYXRlcy54LHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSx0aGlzLnIpLFhyKGkpLmNhbGwoaSksdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWU9MTAwKmUudix0aGlzLm9wYWNpdHlSYW5nZS52YWx1ZT0xMDAqdC5hLHRoaXMuaW5pdGlhbENvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvcj1cInJnYmEoXCIrdGhpcy5pbml0aWFsQ29sb3IucitcIixcIit0aGlzLmluaXRpYWxDb2xvci5nK1wiLFwiK3RoaXMuaW5pdGlhbENvbG9yLmIrXCIsXCIrdGhpcy5pbml0aWFsQ29sb3IuYStcIilcIix0aGlzLm5ld0NvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvcj1cInJnYmEoXCIrdGhpcy5jb2xvci5yK1wiLFwiK3RoaXMuY29sb3IuZytcIixcIit0aGlzLmNvbG9yLmIrXCIsXCIrdGhpcy5jb2xvci5hK1wiKVwifX0se2tleTpcIl9zZXRTaXplXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmNvbG9yUGlja2VyQ2FudmFzLnN0eWxlLndpZHRoPVwiMTAwJVwiLHRoaXMuY29sb3JQaWNrZXJDYW52YXMuc3R5bGUuaGVpZ2h0PVwiMTAwJVwiLHRoaXMuY29sb3JQaWNrZXJDYW52YXMud2lkdGg9Mjg5KnRoaXMucGl4ZWxSYXRpbyx0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmhlaWdodD0yODkqdGhpcy5waXhlbFJhdGlvfX0se2tleTpcIl9jcmVhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGUsaSxvO2lmKHRoaXMuZnJhbWU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLmZyYW1lLmNsYXNzTmFtZT1cInZpcy1jb2xvci1waWNrZXJcIix0aGlzLmNvbG9yUGlja2VyRGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsYXNzTmFtZT1cInZpcy1zZWxlY3RvclwiLHRoaXMuY29sb3JQaWNrZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlclNlbGVjdG9yKSx0aGlzLmNvbG9yUGlja2VyQ2FudmFzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksdGhpcy5jb2xvclBpY2tlckRpdi5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyQ2FudmFzKSx0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQpe3ZhciBuPXRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO3RoaXMucGl4ZWxSYXRpbz0od2luZG93LmRldmljZVBpeGVsUmF0aW98fDEpLyhuLndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW98fG4ubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8bi5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW98fG4ub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW98fG4uYmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8MSksdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywwLDAsdGhpcy5waXhlbFJhdGlvLDAsMCl9ZWxzZXt2YXIgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO3Iuc3R5bGUuY29sb3I9XCJyZWRcIixyLnN0eWxlLmZvbnRXZWlnaHQ9XCJib2xkXCIsci5zdHlsZS5wYWRkaW5nPVwiMTBweFwiLHIuaW5uZXJUZXh0PVwiRXJyb3I6IHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgY2FudmFzXCIsdGhpcy5jb2xvclBpY2tlckNhbnZhcy5hcHBlbmRDaGlsZChyKX10aGlzLmNvbG9yUGlja2VyRGl2LmNsYXNzTmFtZT1cInZpcy1jb2xvclwiLHRoaXMub3BhY2l0eURpdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMub3BhY2l0eURpdi5jbGFzc05hbWU9XCJ2aXMtb3BhY2l0eVwiLHRoaXMuYnJpZ2h0bmVzc0Rpdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuYnJpZ2h0bmVzc0Rpdi5jbGFzc05hbWU9XCJ2aXMtYnJpZ2h0bmVzc1wiLHRoaXMuYXJyb3dEaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLmFycm93RGl2LmNsYXNzTmFtZT1cInZpcy1hcnJvd1wiLHRoaXMub3BhY2l0eVJhbmdlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTt0cnl7dGhpcy5vcGFjaXR5UmFuZ2UudHlwZT1cInJhbmdlXCIsdGhpcy5vcGFjaXR5UmFuZ2UubWluPVwiMFwiLHRoaXMub3BhY2l0eVJhbmdlLm1heD1cIjEwMFwifWNhdGNoKHQpe310aGlzLm9wYWNpdHlSYW5nZS52YWx1ZT1cIjEwMFwiLHRoaXMub3BhY2l0eVJhbmdlLmNsYXNzTmFtZT1cInZpcy1yYW5nZVwiLHRoaXMuYnJpZ2h0bmVzc1JhbmdlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTt0cnl7dGhpcy5icmlnaHRuZXNzUmFuZ2UudHlwZT1cInJhbmdlXCIsdGhpcy5icmlnaHRuZXNzUmFuZ2UubWluPVwiMFwiLHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm1heD1cIjEwMFwifWNhdGNoKHQpe310aGlzLmJyaWdodG5lc3NSYW5nZS52YWx1ZT1cIjEwMFwiLHRoaXMuYnJpZ2h0bmVzc1JhbmdlLmNsYXNzTmFtZT1cInZpcy1yYW5nZVwiLHRoaXMub3BhY2l0eURpdi5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlSYW5nZSksdGhpcy5icmlnaHRuZXNzRGl2LmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc1JhbmdlKTt2YXIgcz10aGlzO3RoaXMub3BhY2l0eVJhbmdlLm9uY2hhbmdlPWZ1bmN0aW9uKCl7cy5fc2V0T3BhY2l0eSh0aGlzLnZhbHVlKX0sdGhpcy5vcGFjaXR5UmFuZ2Uub25pbnB1dD1mdW5jdGlvbigpe3MuX3NldE9wYWNpdHkodGhpcy52YWx1ZSl9LHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm9uY2hhbmdlPWZ1bmN0aW9uKCl7cy5fc2V0QnJpZ2h0bmVzcyh0aGlzLnZhbHVlKX0sdGhpcy5icmlnaHRuZXNzUmFuZ2Uub25pbnB1dD1mdW5jdGlvbigpe3MuX3NldEJyaWdodG5lc3ModGhpcy52YWx1ZSl9LHRoaXMuYnJpZ2h0bmVzc0xhYmVsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5icmlnaHRuZXNzTGFiZWwuY2xhc3NOYW1lPVwidmlzLWxhYmVsIHZpcy1icmlnaHRuZXNzXCIsdGhpcy5icmlnaHRuZXNzTGFiZWwuaW5uZXJUZXh0PVwiYnJpZ2h0bmVzczpcIix0aGlzLm9wYWNpdHlMYWJlbD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMub3BhY2l0eUxhYmVsLmNsYXNzTmFtZT1cInZpcy1sYWJlbCB2aXMtb3BhY2l0eVwiLHRoaXMub3BhY2l0eUxhYmVsLmlubmVyVGV4dD1cIm9wYWNpdHk6XCIsdGhpcy5uZXdDb2xvckRpdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMubmV3Q29sb3JEaXYuY2xhc3NOYW1lPVwidmlzLW5ldy1jb2xvclwiLHRoaXMubmV3Q29sb3JEaXYuaW5uZXJUZXh0PVwibmV3XCIsdGhpcy5pbml0aWFsQ29sb3JEaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLmluaXRpYWxDb2xvckRpdi5jbGFzc05hbWU9XCJ2aXMtaW5pdGlhbC1jb2xvclwiLHRoaXMuaW5pdGlhbENvbG9yRGl2LmlubmVyVGV4dD1cImluaXRpYWxcIix0aGlzLmNhbmNlbEJ1dHRvbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuY2FuY2VsQnV0dG9uLmNsYXNzTmFtZT1cInZpcy1idXR0b24gdmlzLWNhbmNlbFwiLHRoaXMuY2FuY2VsQnV0dG9uLmlubmVyVGV4dD1cImNhbmNlbFwiLHRoaXMuY2FuY2VsQnV0dG9uLm9uY2xpY2s9YnQodD10aGlzLl9oaWRlKS5jYWxsKHQsdGhpcywhMSksdGhpcy5hcHBseUJ1dHRvbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuYXBwbHlCdXR0b24uY2xhc3NOYW1lPVwidmlzLWJ1dHRvbiB2aXMtYXBwbHlcIix0aGlzLmFwcGx5QnV0dG9uLmlubmVyVGV4dD1cImFwcGx5XCIsdGhpcy5hcHBseUJ1dHRvbi5vbmNsaWNrPWJ0KGU9dGhpcy5fYXBwbHkpLmNhbGwoZSx0aGlzKSx0aGlzLnNhdmVCdXR0b249ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLnNhdmVCdXR0b24uY2xhc3NOYW1lPVwidmlzLWJ1dHRvbiB2aXMtc2F2ZVwiLHRoaXMuc2F2ZUJ1dHRvbi5pbm5lclRleHQ9XCJzYXZlXCIsdGhpcy5zYXZlQnV0dG9uLm9uY2xpY2s9YnQoaT10aGlzLl9zYXZlKS5jYWxsKGksdGhpcyksdGhpcy5sb2FkQnV0dG9uPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5sb2FkQnV0dG9uLmNsYXNzTmFtZT1cInZpcy1idXR0b24gdmlzLWxvYWRcIix0aGlzLmxvYWRCdXR0b24uaW5uZXJUZXh0PVwibG9hZCBsYXN0XCIsdGhpcy5sb2FkQnV0dG9uLm9uY2xpY2s9YnQobz10aGlzLl9sb2FkTGFzdCkuY2FsbChvLHRoaXMpLHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlckRpdiksdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmFycm93RGl2KSx0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc0xhYmVsKSx0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc0RpdiksdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlMYWJlbCksdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlEaXYpLHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5uZXdDb2xvckRpdiksdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmluaXRpYWxDb2xvckRpdiksdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNhbmNlbEJ1dHRvbiksdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmFwcGx5QnV0dG9uKSx0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuc2F2ZUJ1dHRvbiksdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmxvYWRCdXR0b24pfX0se2tleTpcIl9iaW5kSGFtbWVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuZHJhZz17fSx0aGlzLnBpbmNoPXt9LHRoaXMuaGFtbWVyPW5ldyBIYSh0aGlzLmNvbG9yUGlja2VyQ2FudmFzKSx0aGlzLmhhbW1lci5nZXQoXCJwaW5jaFwiKS5zZXQoe2VuYWJsZTohMH0pLHRoaXMuaGFtbWVyLm9uKFwiaGFtbWVyLmlucHV0XCIsKGZ1bmN0aW9uKGUpe2UuaXNGaXJzdCYmdC5fbW92ZVNlbGVjdG9yKGUpfSkpLHRoaXMuaGFtbWVyLm9uKFwidGFwXCIsKGZ1bmN0aW9uKGUpe3QuX21vdmVTZWxlY3RvcihlKX0pKSx0aGlzLmhhbW1lci5vbihcInBhbnN0YXJ0XCIsKGZ1bmN0aW9uKGUpe3QuX21vdmVTZWxlY3RvcihlKX0pKSx0aGlzLmhhbW1lci5vbihcInBhbm1vdmVcIiwoZnVuY3Rpb24oZSl7dC5fbW92ZVNlbGVjdG9yKGUpfSkpLHRoaXMuaGFtbWVyLm9uKFwicGFuZW5kXCIsKGZ1bmN0aW9uKGUpe3QuX21vdmVTZWxlY3RvcihlKX0pKX19LHtrZXk6XCJfZ2VuZXJhdGVIdWVDaXJjbGVcIix2YWx1ZTpmdW5jdGlvbigpe2lmKCExPT09dGhpcy5nZW5lcmF0ZWQpe3ZhciB0PXRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO3ZvaWQgMD09PXRoaXMucGl4ZWxSYXRpb24mJih0aGlzLnBpeGVsUmF0aW89KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfHwxKS8odC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvfHx0Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW98fHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvfHx0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvfHx0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW98fDEpKSx0LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sMCwwLHRoaXMucGl4ZWxSYXRpbywwLDApO3ZhciBlLGksbyxuLHI9dGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRXaWR0aCxzPXRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50SGVpZ2h0O3QuY2xlYXJSZWN0KDAsMCxyLHMpLHRoaXMuY2VudGVyQ29vcmRpbmF0ZXM9e3g6LjUqcix5Oi41KnN9LHRoaXMucj0uNDkqcjt2YXIgYSxoPTIqTWF0aC5QSS8zNjAsZD0xL3RoaXMucjtmb3Iobz0wO288MzYwO28rKylmb3Iobj0wO248dGhpcy5yO24rKyllPXRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCtuKk1hdGguc2luKGgqbyksaT10aGlzLmNlbnRlckNvb3JkaW5hdGVzLnkrbipNYXRoLmNvcyhoKm8pLGE9bGgoLjAwMjc3Nzc3Nzc3Nzc3Nzc3OCpvLG4qZCwxKSx0LmZpbGxTdHlsZT1cInJnYihcIithLnIrXCIsXCIrYS5nK1wiLFwiK2EuYitcIilcIix0LmZpbGxSZWN0KGUtLjUsaS0uNSwyLDIpO3Quc3Ryb2tlU3R5bGU9XCJyZ2JhKDAsMCwwLDEpXCIsdC5jaXJjbGUodGhpcy5jZW50ZXJDb29yZGluYXRlcy54LHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSx0aGlzLnIpLHQuc3Ryb2tlKCksdGhpcy5odWVDaXJjbGU9dC5nZXRJbWFnZURhdGEoMCwwLHIscyl9dGhpcy5nZW5lcmF0ZWQ9ITB9fSx7a2V5OlwiX21vdmVTZWxlY3RvclwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuY29sb3JQaWNrZXJEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksaT10LmNlbnRlci54LWUubGVmdCxvPXQuY2VudGVyLnktZS50b3Asbj0uNSp0aGlzLmNvbG9yUGlja2VyRGl2LmNsaWVudEhlaWdodCxyPS41KnRoaXMuY29sb3JQaWNrZXJEaXYuY2xpZW50V2lkdGgscz1pLXIsYT1vLW4saD1NYXRoLmF0YW4yKHMsYSksZD0uOTgqTWF0aC5taW4oTWF0aC5zcXJ0KHMqcythKmEpLHIpLGw9TWF0aC5jb3MoaCkqZCtuLGM9TWF0aC5zaW4oaCkqZCtyO3RoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS50b3A9bC0uNSp0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50SGVpZ2h0K1wicHhcIix0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUubGVmdD1jLS41KnRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRXaWR0aCtcInB4XCI7dmFyIHU9aC8oMipNYXRoLlBJKTt1PXU8MD91KzE6dTt2YXIgZj1kL3RoaXMucixwPWRoKHRoaXMuY29sb3Iucix0aGlzLmNvbG9yLmcsdGhpcy5jb2xvci5iKTtwLmg9dSxwLnM9Zjt2YXIgdj1saChwLmgscC5zLHAudik7di5hPXRoaXMuY29sb3IuYSx0aGlzLmNvbG9yPXYsdGhpcy5pbml0aWFsQ29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yPVwicmdiYShcIit0aGlzLmluaXRpYWxDb2xvci5yK1wiLFwiK3RoaXMuaW5pdGlhbENvbG9yLmcrXCIsXCIrdGhpcy5pbml0aWFsQ29sb3IuYitcIixcIit0aGlzLmluaXRpYWxDb2xvci5hK1wiKVwiLHRoaXMubmV3Q29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yPVwicmdiYShcIit0aGlzLmNvbG9yLnIrXCIsXCIrdGhpcy5jb2xvci5nK1wiLFwiK3RoaXMuY29sb3IuYitcIixcIit0aGlzLmNvbG9yLmErXCIpXCJ9fV0pLHR9KCk7ZnVuY3Rpb24ga2goKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxlPW5ldyBBcnJheSh0KSxpPTA7aTx0O2krKyllW2ldPWFyZ3VtZW50c1tpXTtpZihlLmxlbmd0aDwxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cy5cIik7aWYoMT09PWUubGVuZ3RoKXJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlWzBdKTt2YXIgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KGVbMF0pO3JldHVybiBvLmFwcGVuZENoaWxkKGtoLmFwcGx5KHZvaWQgMCxsbih2bihlKS5jYWxsKGUsMSkpKSksb312YXIgX2gseGg9ITEsRWg9XCJiYWNrZ3JvdW5kOiAjRkZlZWVlOyBjb2xvcjogI2RkMDAwMFwiLE9oPVdhLENoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLGksbyl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOjEscj1hcmd1bWVudHMubGVuZ3RoPjQmJnZvaWQgMCE9PWFyZ3VtZW50c1s0XT9hcmd1bWVudHNbNF06ZnVuY3Rpb24oKXtyZXR1cm4hMX07UG8odGhpcyx0KSx0aGlzLnBhcmVudD1lLHRoaXMuY2hhbmdlZE9wdGlvbnM9W10sdGhpcy5jb250YWluZXI9aSx0aGlzLmFsbG93Q3JlYXRpb249ITEsdGhpcy5oaWRlT3B0aW9uPXIsdGhpcy5vcHRpb25zPXt9LHRoaXMuaW5pdGlhbGl6ZWQ9ITEsdGhpcy5wb3B1cENvdW50ZXI9MCx0aGlzLmRlZmF1bHRPcHRpb25zPXtlbmFibGVkOiExLGZpbHRlcjohMCxjb250YWluZXI6dm9pZCAwLHNob3dCdXR0b246ITB9LGN0KHRoaXMub3B0aW9ucyx0aGlzLmRlZmF1bHRPcHRpb25zKSx0aGlzLmNvbmZpZ3VyZU9wdGlvbnM9byx0aGlzLm1vZHVsZU9wdGlvbnM9e30sdGhpcy5kb21FbGVtZW50cz1bXSx0aGlzLnBvcHVwRGl2PXt9LHRoaXMucG9wdXBMaW1pdD01LHRoaXMucG9wdXBIaXN0b3J5PXt9LHRoaXMuY29sb3JQaWNrZXI9bmV3IHdoKG4pLHRoaXMud3JhcHBlcj12b2lkIDB9cmV0dXJuIElvKHQsW3trZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dCl7dGhpcy5wb3B1cEhpc3Rvcnk9e30sdGhpcy5fcmVtb3ZlUG9wdXAoKTt2YXIgZT0hMDtpZihcInN0cmluZ1wiPT10eXBlb2YgdCl0aGlzLm9wdGlvbnMuZmlsdGVyPXQ7ZWxzZSBpZihnbih0KSl0aGlzLm9wdGlvbnMuZmlsdGVyPXQuam9pbigpO2Vsc2UgaWYoXCJvYmplY3RcIj09PWRuKHQpKXtpZihudWxsPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb25zIGNhbm5vdCBiZSBudWxsXCIpO3ZvaWQgMCE9PXQuY29udGFpbmVyJiYodGhpcy5vcHRpb25zLmNvbnRhaW5lcj10LmNvbnRhaW5lciksdm9pZCAwIT09YXIodCkmJih0aGlzLm9wdGlvbnMuZmlsdGVyPWFyKHQpKSx2b2lkIDAhPT10LnNob3dCdXR0b24mJih0aGlzLm9wdGlvbnMuc2hvd0J1dHRvbj10LnNob3dCdXR0b24pLHZvaWQgMCE9PXQuZW5hYmxlZCYmKGU9dC5lbmFibGVkKX1lbHNlXCJib29sZWFuXCI9PXR5cGVvZiB0Pyh0aGlzLm9wdGlvbnMuZmlsdGVyPSEwLGU9dCk6XCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKHRoaXMub3B0aW9ucy5maWx0ZXI9dCxlPSEwKTshMT09PWFyKHRoaXMub3B0aW9ucykmJihlPSExKSx0aGlzLm9wdGlvbnMuZW5hYmxlZD1lfXRoaXMuX2NsZWFuKCl9fSx7a2V5Olwic2V0TW9kdWxlT3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMubW9kdWxlT3B0aW9ucz10LCEwPT09dGhpcy5vcHRpb25zLmVuYWJsZWQmJih0aGlzLl9jbGVhbigpLHZvaWQgMCE9PXRoaXMub3B0aW9ucy5jb250YWluZXImJih0aGlzLmNvbnRhaW5lcj10aGlzLm9wdGlvbnMuY29udGFpbmVyKSx0aGlzLl9jcmVhdGUoKSl9fSx7a2V5OlwiX2NyZWF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fY2xlYW4oKSx0aGlzLmNoYW5nZWRPcHRpb25zPVtdO3ZhciB0PWFyKHRoaXMub3B0aW9ucyksZT0wLGk9ITE7Zm9yKHZhciBvIGluIHRoaXMuY29uZmlndXJlT3B0aW9ucylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb25maWd1cmVPcHRpb25zLG8pJiYodGhpcy5hbGxvd0NyZWF0aW9uPSExLGk9ITEsXCJmdW5jdGlvblwiPT10eXBlb2YgdD9pPShpPXQobyxbXSkpfHx0aGlzLl9oYW5kbGVPYmplY3QodGhpcy5jb25maWd1cmVPcHRpb25zW29dLFtvXSwhMCk6ITAhPT10JiYtMT09PU1yKHQpLmNhbGwodCxvKXx8KGk9ITApLCExIT09aSYmKHRoaXMuYWxsb3dDcmVhdGlvbj0hMCxlPjAmJnRoaXMuX21ha2VJdGVtKFtdKSx0aGlzLl9tYWtlSGVhZGVyKG8pLHRoaXMuX2hhbmRsZU9iamVjdCh0aGlzLmNvbmZpZ3VyZU9wdGlvbnNbb10sW29dKSksZSsrKTt0aGlzLl9tYWtlQnV0dG9uKCksdGhpcy5fcHVzaCgpfX0se2tleTpcIl9wdXNoXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLndyYXBwZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLndyYXBwZXIuY2xhc3NOYW1lPVwidmlzLWNvbmZpZ3VyYXRpb24td3JhcHBlclwiLHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMud3JhcHBlcik7Zm9yKHZhciB0PTA7dDx0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDt0KyspdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudHNbdF0pO3RoaXMuX3Nob3dQb3B1cElmTmVlZGVkKCl9fSx7a2V5OlwiX2NsZWFuXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoO3QrKyl0aGlzLndyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50c1t0XSk7dm9pZCAwIT09dGhpcy53cmFwcGVyJiYodGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy53cmFwcGVyKSx0aGlzLndyYXBwZXI9dm9pZCAwKSx0aGlzLmRvbUVsZW1lbnRzPVtdLHRoaXMuX3JlbW92ZVBvcHVwKCl9fSx7a2V5OlwiX2dldFZhbHVlXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMubW9kdWxlT3B0aW9ucyxpPTA7aTx0Lmxlbmd0aDtpKyspe2lmKHZvaWQgMD09PWVbdFtpXV0pe2U9dm9pZCAwO2JyZWFrfWU9ZVt0W2ldXX1yZXR1cm4gZX19LHtrZXk6XCJfbWFrZUl0ZW1cIix2YWx1ZTpmdW5jdGlvbih0KXtpZighMD09PXRoaXMuYWxsb3dDcmVhdGlvbil7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtlLmNsYXNzTmFtZT1cInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctaXRlbSB2aXMtY29uZmlnLXNcIit0Lmxlbmd0aDtmb3IodmFyIGk9YXJndW1lbnRzLmxlbmd0aCxvPW5ldyBBcnJheShpPjE/aS0xOjApLG49MTtuPGk7bisrKW9bbi0xXT1hcmd1bWVudHNbbl07cmV0dXJuIERuKG8pLmNhbGwobywoZnVuY3Rpb24odCl7ZS5hcHBlbmRDaGlsZCh0KX0pKSx0aGlzLmRvbUVsZW1lbnRzLnB1c2goZSksdGhpcy5kb21FbGVtZW50cy5sZW5ndGh9cmV0dXJuIDB9fSx7a2V5OlwiX21ha2VIZWFkZXJcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2UuY2xhc3NOYW1lPVwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1oZWFkZXJcIixlLmlubmVyVGV4dD10LHRoaXMuX21ha2VJdGVtKFtdLGUpfX0se2tleTpcIl9tYWtlTGFiZWxcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl0sbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2lmKG8uY2xhc3NOYW1lPVwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1sYWJlbCB2aXMtY29uZmlnLXNcIitlLmxlbmd0aCwhMD09PWkpe2Zvcig7by5maXJzdENoaWxkOylvLnJlbW92ZUNoaWxkKG8uZmlyc3RDaGlsZCk7by5hcHBlbmRDaGlsZChraChcImlcIixcImJcIix0KSl9ZWxzZSBvLmlubmVyVGV4dD10K1wiOlwiO3JldHVybiBvfX0se2tleTpcIl9tYWtlRHJvcGRvd25cIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dmFyIG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtvLmNsYXNzTmFtZT1cInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctc2VsZWN0XCI7dmFyIG49MDt2b2lkIDAhPT1lJiYtMSE9PU1yKHQpLmNhbGwodCxlKSYmKG49TXIodCkuY2FsbCh0LGUpKTtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtzLnZhbHVlPXRbcl0scj09PW4mJihzLnNlbGVjdGVkPVwic2VsZWN0ZWRcIikscy5pbm5lclRleHQ9dFtyXSxvLmFwcGVuZENoaWxkKHMpfXZhciBhPXRoaXM7by5vbmNoYW5nZT1mdW5jdGlvbigpe2EuX3VwZGF0ZSh0aGlzLnZhbHVlLGkpfTt2YXIgaD10aGlzLl9tYWtlTGFiZWwoaVtpLmxlbmd0aC0xXSxpKTt0aGlzLl9tYWtlSXRlbShpLGgsbyl9fSx7a2V5OlwiX21ha2VSYW5nZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz10WzBdLG49dFsxXSxyPXRbMl0scz10WzNdLGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO2EuY2xhc3NOYW1lPVwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1yYW5nZVwiO3RyeXthLnR5cGU9XCJyYW5nZVwiLGEubWluPW4sYS5tYXg9cn1jYXRjaCh0KXt9YS5zdGVwPXM7dmFyIGg9XCJcIixkPTA7aWYodm9pZCAwIT09ZSl7dmFyIGw9MS4yO2U8MCYmZSpsPG4/KGEubWluPU1hdGguY2VpbChlKmwpLGQ9YS5taW4saD1cInJhbmdlIGluY3JlYXNlZFwiKTplL2w8biYmKGEubWluPU1hdGguY2VpbChlL2wpLGQ9YS5taW4saD1cInJhbmdlIGluY3JlYXNlZFwiKSxlKmw+ciYmMSE9PXImJihhLm1heD1NYXRoLmNlaWwoZSpsKSxkPWEubWF4LGg9XCJyYW5nZSBpbmNyZWFzZWRcIiksYS52YWx1ZT1lfWVsc2UgYS52YWx1ZT1vO3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtjLmNsYXNzTmFtZT1cInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctcmFuZ2VpbnB1dFwiLGMudmFsdWU9YS52YWx1ZTt2YXIgdT10aGlzO2Eub25jaGFuZ2U9ZnVuY3Rpb24oKXtjLnZhbHVlPXRoaXMudmFsdWUsdS5fdXBkYXRlKE51bWJlcih0aGlzLnZhbHVlKSxpKX0sYS5vbmlucHV0PWZ1bmN0aW9uKCl7Yy52YWx1ZT10aGlzLnZhbHVlfTt2YXIgZj10aGlzLl9tYWtlTGFiZWwoaVtpLmxlbmd0aC0xXSxpKSxwPXRoaXMuX21ha2VJdGVtKGksZixhLGMpO1wiXCIhPT1oJiZ0aGlzLnBvcHVwSGlzdG9yeVtwXSE9PWQmJih0aGlzLnBvcHVwSGlzdG9yeVtwXT1kLHRoaXMuX3NldHVwUG9wdXAoaCxwKSl9fSx7a2V5OlwiX21ha2VCdXR0b25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYoITA9PT10aGlzLm9wdGlvbnMuc2hvd0J1dHRvbil7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtlLmNsYXNzTmFtZT1cInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uXCIsZS5pbm5lclRleHQ9XCJnZW5lcmF0ZSBvcHRpb25zXCIsZS5vbmNsaWNrPWZ1bmN0aW9uKCl7dC5fcHJpbnRPcHRpb25zKCl9LGUub25tb3VzZW92ZXI9ZnVuY3Rpb24oKXtlLmNsYXNzTmFtZT1cInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uIGhvdmVyXCJ9LGUub25tb3VzZW91dD1mdW5jdGlvbigpe2UuY2xhc3NOYW1lPVwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b25cIn0sdGhpcy5vcHRpb25zQ29udGFpbmVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5vcHRpb25zQ29udGFpbmVyLmNsYXNzTmFtZT1cInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctb3B0aW9uLWNvbnRhaW5lclwiLHRoaXMuZG9tRWxlbWVudHMucHVzaCh0aGlzLm9wdGlvbnNDb250YWluZXIpLHRoaXMuZG9tRWxlbWVudHMucHVzaChlKX19fSx7a2V5OlwiX3NldHVwUG9wdXBcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXM7aWYoITA9PT10aGlzLmluaXRpYWxpemVkJiYhMD09PXRoaXMuYWxsb3dDcmVhdGlvbiYmdGhpcy5wb3B1cENvdW50ZXI8dGhpcy5wb3B1cExpbWl0KXt2YXIgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO28uaWQ9XCJ2aXMtY29uZmlndXJhdGlvbi1wb3B1cFwiLG8uY2xhc3NOYW1lPVwidmlzLWNvbmZpZ3VyYXRpb24tcG9wdXBcIixvLmlubmVyVGV4dD10LG8ub25jbGljaz1mdW5jdGlvbigpe2kuX3JlbW92ZVBvcHVwKCl9LHRoaXMucG9wdXBDb3VudGVyKz0xLHRoaXMucG9wdXBEaXY9e2h0bWw6byxpbmRleDplfX19fSx7a2V5OlwiX3JlbW92ZVBvcHVwXCIsdmFsdWU6ZnVuY3Rpb24oKXt2b2lkIDAhPT10aGlzLnBvcHVwRGl2Lmh0bWwmJih0aGlzLnBvcHVwRGl2Lmh0bWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpLGNsZWFyVGltZW91dCh0aGlzLnBvcHVwRGl2LmhpZGVUaW1lb3V0KSxjbGVhclRpbWVvdXQodGhpcy5wb3B1cERpdi5kZWxldGVUaW1lb3V0KSx0aGlzLnBvcHVwRGl2PXt9KX19LHtrZXk6XCJfc2hvd1BvcHVwSWZOZWVkZWRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYodm9pZCAwIT09dGhpcy5wb3B1cERpdi5odG1sKXt2YXIgZT10aGlzLmRvbUVsZW1lbnRzW3RoaXMucG9wdXBEaXYuaW5kZXhdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3RoaXMucG9wdXBEaXYuaHRtbC5zdHlsZS5sZWZ0PWUubGVmdCtcInB4XCIsdGhpcy5wb3B1cERpdi5odG1sLnN0eWxlLnRvcD1lLnRvcC0zMCtcInB4XCIsZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpLHRoaXMucG9wdXBEaXYuaGlkZVRpbWVvdXQ9cXIoKGZ1bmN0aW9uKCl7dC5wb3B1cERpdi5odG1sLnN0eWxlLm9wYWNpdHk9MH0pLDE1MDApLHRoaXMucG9wdXBEaXYuZGVsZXRlVGltZW91dD1xcigoZnVuY3Rpb24oKXt0Ll9yZW1vdmVQb3B1cCgpfSksMTgwMCl9fX0se2tleTpcIl9tYWtlQ2hlY2tib3hcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dmFyIG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO28udHlwZT1cImNoZWNrYm94XCIsby5jbGFzc05hbWU9XCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNoZWNrYm94XCIsby5jaGVja2VkPXQsdm9pZCAwIT09ZSYmKG8uY2hlY2tlZD1lLGUhPT10JiYoXCJvYmplY3RcIj09PWRuKHQpP2UhPT10LmVuYWJsZWQmJnRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7cGF0aDppLHZhbHVlOmV9KTp0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe3BhdGg6aSx2YWx1ZTplfSkpKTt2YXIgbj10aGlzO28ub25jaGFuZ2U9ZnVuY3Rpb24oKXtuLl91cGRhdGUodGhpcy5jaGVja2VkLGkpfTt2YXIgcj10aGlzLl9tYWtlTGFiZWwoaVtpLmxlbmd0aC0xXSxpKTt0aGlzLl9tYWtlSXRlbShpLHIsbyl9fSx7a2V5OlwiX21ha2VUZXh0SW5wdXRcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dmFyIG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO28udHlwZT1cInRleHRcIixvLmNsYXNzTmFtZT1cInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctdGV4dFwiLG8udmFsdWU9ZSxlIT09dCYmdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtwYXRoOmksdmFsdWU6ZX0pO3ZhciBuPXRoaXM7by5vbmNoYW5nZT1mdW5jdGlvbigpe24uX3VwZGF0ZSh0aGlzLnZhbHVlLGkpfTt2YXIgcj10aGlzLl9tYWtlTGFiZWwoaVtpLmxlbmd0aC0xXSxpKTt0aGlzLl9tYWtlSXRlbShpLHIsbyl9fSx7a2V5OlwiX21ha2VDb2xvckZpZWxkXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3ZhciBvPXRoaXMsbj10WzFdLHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcIm5vbmVcIiE9PShlPXZvaWQgMD09PWU/bjplKT8oci5jbGFzc05hbWU9XCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNvbG9yQmxvY2tcIixyLnN0eWxlLmJhY2tncm91bmRDb2xvcj1lKTpyLmNsYXNzTmFtZT1cInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY29sb3JCbG9jayBub25lXCIsZT12b2lkIDA9PT1lP246ZSxyLm9uY2xpY2s9ZnVuY3Rpb24oKXtvLl9zaG93Q29sb3JQaWNrZXIoZSxyLGkpfTt2YXIgcz10aGlzLl9tYWtlTGFiZWwoaVtpLmxlbmd0aC0xXSxpKTt0aGlzLl9tYWtlSXRlbShpLHMscil9fSx7a2V5OlwiX3Nob3dDb2xvclBpY2tlclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz10aGlzO2Uub25jbGljaz1mdW5jdGlvbigpe30sdGhpcy5jb2xvclBpY2tlci5pbnNlcnRUbyhlKSx0aGlzLmNvbG9yUGlja2VyLnNob3coKSx0aGlzLmNvbG9yUGlja2VyLnNldENvbG9yKHQpLHRoaXMuY29sb3JQaWNrZXIuc2V0VXBkYXRlQ2FsbGJhY2soKGZ1bmN0aW9uKHQpe3ZhciBuPVwicmdiYShcIit0LnIrXCIsXCIrdC5nK1wiLFwiK3QuYitcIixcIit0LmErXCIpXCI7ZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9bixvLl91cGRhdGUobixpKX0pKSx0aGlzLmNvbG9yUGlja2VyLnNldENsb3NlQ2FsbGJhY2soKGZ1bmN0aW9uKCl7ZS5vbmNsaWNrPWZ1bmN0aW9uKCl7by5fc2hvd0NvbG9yUGlja2VyKHQsZSxpKX19KSl9fSx7a2V5OlwiX2hhbmRsZU9iamVjdFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpbXSxpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl0sbz0hMSxuPWFyKHRoaXMub3B0aW9ucykscj0hMTtmb3IodmFyIHMgaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxzKSl7bz0hMDt2YXIgYT10W3NdLGg9ZWgoZSxzKTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBuJiYhMT09PShvPW4ocyxlKSkmJiFnbihhKSYmXCJzdHJpbmdcIiE9dHlwZW9mIGEmJlwiYm9vbGVhblwiIT10eXBlb2YgYSYmYSBpbnN0YW5jZW9mIE9iamVjdCYmKHRoaXMuYWxsb3dDcmVhdGlvbj0hMSxvPXRoaXMuX2hhbmRsZU9iamVjdChhLGgsITApLHRoaXMuYWxsb3dDcmVhdGlvbj0hMT09PWkpLCExIT09byl7cj0hMDt2YXIgZD10aGlzLl9nZXRWYWx1ZShoKTtpZihnbihhKSl0aGlzLl9oYW5kbGVBcnJheShhLGQsaCk7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgYSl0aGlzLl9tYWtlVGV4dElucHV0KGEsZCxoKTtlbHNlIGlmKFwiYm9vbGVhblwiPT10eXBlb2YgYSl0aGlzLl9tYWtlQ2hlY2tib3goYSxkLGgpO2Vsc2UgaWYoYSBpbnN0YW5jZW9mIE9iamVjdCl7aWYoIXRoaXMuaGlkZU9wdGlvbihlLHMsdGhpcy5tb2R1bGVPcHRpb25zKSlpZih2b2lkIDAhPT1hLmVuYWJsZWQpe3ZhciBsPWVoKGgsXCJlbmFibGVkXCIpLGM9dGhpcy5fZ2V0VmFsdWUobCk7aWYoITA9PT1jKXt2YXIgdT10aGlzLl9tYWtlTGFiZWwocyxoLCEwKTt0aGlzLl9tYWtlSXRlbShoLHUpLHI9dGhpcy5faGFuZGxlT2JqZWN0KGEsaCl8fHJ9ZWxzZSB0aGlzLl9tYWtlQ2hlY2tib3goYSxjLGgpfWVsc2V7dmFyIGY9dGhpcy5fbWFrZUxhYmVsKHMsaCwhMCk7dGhpcy5fbWFrZUl0ZW0oaCxmKSxyPXRoaXMuX2hhbmRsZU9iamVjdChhLGgpfHxyfX1lbHNlIGNvbnNvbGUuZXJyb3IoXCJkb250IGtub3cgaG93IHRvIGhhbmRsZVwiLGEscyxoKX19cmV0dXJuIHJ9fSx7a2V5OlwiX2hhbmRsZUFycmF5XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe1wic3RyaW5nXCI9PXR5cGVvZiB0WzBdJiZcImNvbG9yXCI9PT10WzBdPyh0aGlzLl9tYWtlQ29sb3JGaWVsZCh0LGUsaSksdFsxXSE9PWUmJnRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7cGF0aDppLHZhbHVlOmV9KSk6XCJzdHJpbmdcIj09dHlwZW9mIHRbMF0/KHRoaXMuX21ha2VEcm9wZG93bih0LGUsaSksdFswXSE9PWUmJnRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7cGF0aDppLHZhbHVlOmV9KSk6XCJudW1iZXJcIj09dHlwZW9mIHRbMF0mJih0aGlzLl9tYWtlUmFuZ2UodCxlLGkpLHRbMF0hPT1lJiZ0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe3BhdGg6aSx2YWx1ZTpOdW1iZXIoZSl9KSl9fSx7a2V5OlwiX3VwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9dGhpcy5fY29uc3RydWN0T3B0aW9ucyh0LGUpO3RoaXMucGFyZW50LmJvZHkmJnRoaXMucGFyZW50LmJvZHkuZW1pdHRlciYmdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyLmVtaXQmJnRoaXMucGFyZW50LmJvZHkuZW1pdHRlci5lbWl0KFwiY29uZmlnQ2hhbmdlXCIsaSksdGhpcy5pbml0aWFsaXplZD0hMCx0aGlzLnBhcmVudC5zZXRPcHRpb25zKGkpfX0se2tleTpcIl9jb25zdHJ1Y3RPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e30sbz1pO3Q9XCJmYWxzZVwiIT09KHQ9XCJ0cnVlXCI9PT10fHx0KSYmdDtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKylcImdsb2JhbFwiIT09ZVtuXSYmKHZvaWQgMD09PW9bZVtuXV0mJihvW2Vbbl1dPXt9KSxuIT09ZS5sZW5ndGgtMT9vPW9bZVtuXV06b1tlW25dXT10KTtyZXR1cm4gaX19LHtrZXk6XCJfcHJpbnRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5nZXRPcHRpb25zKCk7dGhpcy5vcHRpb25zQ29udGFpbmVyLmZpcnN0Q2hpbGQ7KXRoaXMub3B0aW9uc0NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLm9wdGlvbnNDb250YWluZXIuZmlyc3RDaGlsZCk7dGhpcy5vcHRpb25zQ29udGFpbmVyLmFwcGVuZENoaWxkKGtoKFwicHJlXCIsXCJjb25zdCBvcHRpb25zID0gXCIrTHIodCxudWxsLDIpKSl9fSx7a2V5OlwiZ2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXt9LGU9MDtlPHRoaXMuY2hhbmdlZE9wdGlvbnMubGVuZ3RoO2UrKyl0aGlzLl9jb25zdHJ1Y3RPcHRpb25zKHRoaXMuY2hhbmdlZE9wdGlvbnNbZV0udmFsdWUsdGhpcy5jaGFuZ2VkT3B0aW9uc1tlXS5wYXRoLHQpO3JldHVybiB0fX1dKSx0fSgpLFNoPUhhLFRoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLGkpe1BvKHRoaXMsdCksdGhpcy5jb250YWluZXI9ZSx0aGlzLm92ZXJmbG93TWV0aG9kPWl8fFwiY2FwXCIsdGhpcy54PTAsdGhpcy55PTAsdGhpcy5wYWRkaW5nPTUsdGhpcy5oaWRkZW49ITEsdGhpcy5mcmFtZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuZnJhbWUuY2xhc3NOYW1lPVwidmlzLXRvb2x0aXBcIix0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKX1yZXR1cm4gSW8odCxbe2tleTpcInNldFBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLng9a3IodCksdGhpcy55PWtyKGUpfX0se2tleTpcInNldFRleHRcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgRWxlbWVudCl7Zm9yKDt0aGlzLmZyYW1lLmZpcnN0Q2hpbGQ7KXRoaXMuZnJhbWUucmVtb3ZlQ2hpbGQodGhpcy5mcmFtZS5maXJzdENoaWxkKTt0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHQpfWVsc2UgdGhpcy5mcmFtZS5pbm5lclRleHQ9dH19LHtrZXk6XCJzaG93XCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dCYmKHQ9ITApLCEwPT09dCl7dmFyIGU9dGhpcy5mcmFtZS5jbGllbnRIZWlnaHQsaT10aGlzLmZyYW1lLmNsaWVudFdpZHRoLG89dGhpcy5mcmFtZS5wYXJlbnROb2RlLmNsaWVudEhlaWdodCxuPXRoaXMuZnJhbWUucGFyZW50Tm9kZS5jbGllbnRXaWR0aCxyPTAscz0wO2lmKFwiZmxpcFwiPT10aGlzLm92ZXJmbG93TWV0aG9kKXt2YXIgYT0hMSxoPSEwO3RoaXMueS1lPHRoaXMucGFkZGluZyYmKGg9ITEpLHRoaXMueCtpPm4tdGhpcy5wYWRkaW5nJiYoYT0hMCkscj1hP3RoaXMueC1pOnRoaXMueCxzPWg/dGhpcy55LWU6dGhpcy55fWVsc2Uocz10aGlzLnktZSkrZSt0aGlzLnBhZGRpbmc+byYmKHM9by1lLXRoaXMucGFkZGluZyksczx0aGlzLnBhZGRpbmcmJihzPXRoaXMucGFkZGluZyksKHI9dGhpcy54KStpK3RoaXMucGFkZGluZz5uJiYocj1uLWktdGhpcy5wYWRkaW5nKSxyPHRoaXMucGFkZGluZyYmKHI9dGhpcy5wYWRkaW5nKTt0aGlzLmZyYW1lLnN0eWxlLmxlZnQ9citcInB4XCIsdGhpcy5mcmFtZS5zdHlsZS50b3A9cytcInB4XCIsdGhpcy5mcmFtZS5zdHlsZS52aXNpYmlsaXR5PVwidmlzaWJsZVwiLHRoaXMuaGlkZGVuPSExfWVsc2UgdGhpcy5oaWRlKCl9fSx7a2V5OlwiaGlkZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5oaWRkZW49ITAsdGhpcy5mcmFtZS5zdHlsZS5sZWZ0PVwiMFwiLHRoaXMuZnJhbWUuc3R5bGUudG9wPVwiMFwiLHRoaXMuZnJhbWUuc3R5bGUudmlzaWJpbGl0eT1cImhpZGRlblwifX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZyYW1lKX19XSksdH0oKSxNaD1FaCxQaD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtQbyh0aGlzLHQpfXJldHVybiBJbyh0LG51bGwsW3trZXk6XCJ2YWxpZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsaSxvKXt4aD0hMSxfaD1pO3ZhciBuPWk7cmV0dXJuIHZvaWQgMCE9PW8mJihuPWlbb10pLHQucGFyc2UoZSxuLFtdKSx4aH19LHtrZXk6XCJwYXJzZVwiLHZhbHVlOmZ1bmN0aW9uKGUsaSxvKXtmb3IodmFyIG4gaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxuKSYmdC5jaGVjayhuLGUsaSxvKX19LHtrZXk6XCJjaGVja1wiLHZhbHVlOmZ1bmN0aW9uKGUsaSxvLG4pe2lmKHZvaWQgMCE9PW9bZV18fHZvaWQgMCE9PW8uX19hbnlfXyl7dmFyIHI9ZSxzPSEwO3ZvaWQgMD09PW9bZV0mJnZvaWQgMCE9PW8uX19hbnlfXyYmKHI9XCJfX2FueV9fXCIscz1cIm9iamVjdFwiPT09dC5nZXRUeXBlKGlbZV0pKTt2YXIgYT1vW3JdO3MmJnZvaWQgMCE9PWEuX190eXBlX18mJihhPWEuX190eXBlX18pLHQuY2hlY2tGaWVsZHMoZSxpLG8scixhLG4pfWVsc2UgdC5nZXRTdWdnZXN0aW9uKGUsbyxuKX19LHtrZXk6XCJjaGVja0ZpZWxkc1wiLHZhbHVlOmZ1bmN0aW9uKGUsaSxvLG4scixzKXt2YXIgYT1mdW5jdGlvbihpKXtjb25zb2xlLmVycm9yKFwiJWNcIitpK3QucHJpbnRMb2NhdGlvbihzLGUpLEVoKX0saD10LmdldFR5cGUoaVtlXSksZD1yW2hdO3ZvaWQgMCE9PWQ/XCJhcnJheVwiPT09dC5nZXRUeXBlKGQpJiYtMT09PU1yKGQpLmNhbGwoZCxpW2VdKT8oYSgnSW52YWxpZCBvcHRpb24gZGV0ZWN0ZWQgaW4gXCInK2UrJ1wiLiBBbGxvd2VkIHZhbHVlcyBhcmU6Jyt0LnByaW50KGQpKycgbm90IFwiJytpW2VdKydcIi4gJykseGg9ITApOlwib2JqZWN0XCI9PT1oJiZcIl9fYW55X19cIiE9PW4mJihzPWVoKHMsZSksdC5wYXJzZShpW2VdLG9bbl0scykpOnZvaWQgMD09PXIuYW55JiYoYSgnSW52YWxpZCB0eXBlIHJlY2VpdmVkIGZvciBcIicrZSsnXCIuIEV4cGVjdGVkOiAnK3QucHJpbnQoeG4ocikpK1wiLiBSZWNlaXZlZCBbXCIraCsnXSBcIicraVtlXSsnXCInKSx4aD0hMCl9fSx7a2V5OlwiZ2V0VHlwZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWRuKHQpO3JldHVyblwib2JqZWN0XCI9PT1lP251bGw9PT10P1wibnVsbFwiOnQgaW5zdGFuY2VvZiBCb29sZWFuP1wiYm9vbGVhblwiOnQgaW5zdGFuY2VvZiBOdW1iZXI/XCJudW1iZXJcIjp0IGluc3RhbmNlb2YgU3RyaW5nP1wic3RyaW5nXCI6Z24odCk/XCJhcnJheVwiOnQgaW5zdGFuY2VvZiBEYXRlP1wiZGF0ZVwiOnZvaWQgMCE9PXQubm9kZVR5cGU/XCJkb21cIjohMD09PXQuX2lzQU1vbWVudE9iamVjdD9cIm1vbWVudFwiOlwib2JqZWN0XCI6XCJudW1iZXJcIj09PWU/XCJudW1iZXJcIjpcImJvb2xlYW5cIj09PWU/XCJib29sZWFuXCI6XCJzdHJpbmdcIj09PWU/XCJzdHJpbmdcIjp2b2lkIDA9PT1lP1widW5kZWZpbmVkXCI6ZX19LHtrZXk6XCJnZXRTdWdnZXN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oZSxpLG8pe3ZhciBuLHI9dC5maW5kSW5PcHRpb25zKGUsaSxvLCExKSxzPXQuZmluZEluT3B0aW9ucyhlLF9oLFtdLCEwKTtuPXZvaWQgMCE9PXIuaW5kZXhNYXRjaD9cIiBpbiBcIit0LnByaW50TG9jYXRpb24oci5wYXRoLGUsXCJcIikrJ1BlcmhhcHMgaXQgd2FzIGluY29tcGxldGU/IERpZCB5b3UgbWVhbjogXCInK3IuaW5kZXhNYXRjaCsnXCI/XFxuXFxuJzpzLmRpc3RhbmNlPD00JiZyLmRpc3RhbmNlPnMuZGlzdGFuY2U/XCIgaW4gXCIrdC5wcmludExvY2F0aW9uKHIucGF0aCxlLFwiXCIpK1wiUGVyaGFwcyBpdCB3YXMgbWlzcGxhY2VkPyBNYXRjaGluZyBvcHRpb24gZm91bmQgYXQ6IFwiK3QucHJpbnRMb2NhdGlvbihzLnBhdGgscy5jbG9zZXN0TWF0Y2gsXCJcIik6ci5kaXN0YW5jZTw9OD8nLiBEaWQgeW91IG1lYW4gXCInK3IuY2xvc2VzdE1hdGNoKydcIj8nK3QucHJpbnRMb2NhdGlvbihyLnBhdGgsZSk6XCIuIERpZCB5b3UgbWVhbiBvbmUgb2YgdGhlc2U6IFwiK3QucHJpbnQoeG4oaSkpK3QucHJpbnRMb2NhdGlvbihvLGUpLGNvbnNvbGUuZXJyb3IoJyVjVW5rbm93biBvcHRpb24gZGV0ZWN0ZWQ6IFwiJytlKydcIicrbixFaCkseGg9ITB9fSx7a2V5OlwiZmluZEluT3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKGUsaSxvKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXSYmYXJndW1lbnRzWzNdLHI9MWU5LHM9XCJcIixhPVtdLGg9ZS50b0xvd2VyQ2FzZSgpLGQ9dm9pZCAwO2Zvcih2YXIgbCBpbiBpKXt2YXIgYz12b2lkIDA7aWYodm9pZCAwIT09aVtsXS5fX3R5cGVfXyYmITA9PT1uKXt2YXIgdT10LmZpbmRJbk9wdGlvbnMoZSxpW2xdLGVoKG8sbCkpO3I+dS5kaXN0YW5jZSYmKHM9dS5jbG9zZXN0TWF0Y2gsYT11LnBhdGgscj11LmRpc3RhbmNlLGQ9dS5pbmRleE1hdGNoKX1lbHNle3ZhciBmOy0xIT09TXIoZj1sLnRvTG93ZXJDYXNlKCkpLmNhbGwoZixoKSYmKGQ9bCkscj4oYz10LmxldmVuc2h0ZWluRGlzdGFuY2UoZSxsKSkmJihzPWwsYT1paChvKSxyPWMpfX1yZXR1cm57Y2xvc2VzdE1hdGNoOnMscGF0aDphLGRpc3RhbmNlOnIsaW5kZXhNYXRjaDpkfX19LHtrZXk6XCJwcmludExvY2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOlwiUHJvYmxlbSB2YWx1ZSBmb3VuZCBhdDogXFxuXCIsbz1cIlxcblxcblwiK2krXCJvcHRpb25zID0ge1xcblwiLG49MDtuPHQubGVuZ3RoO24rKyl7Zm9yKHZhciByPTA7cjxuKzE7cisrKW8rPVwiICBcIjtvKz10W25dK1wiOiB7XFxuXCJ9Zm9yKHZhciBzPTA7czx0Lmxlbmd0aCsxO3MrKylvKz1cIiAgXCI7bys9ZStcIlxcblwiO2Zvcih2YXIgYT0wO2E8dC5sZW5ndGgrMTthKyspe2Zvcih2YXIgaD0wO2g8dC5sZW5ndGgtYTtoKyspbys9XCIgIFwiO28rPVwifVxcblwifXJldHVybiBvK1wiXFxuXFxuXCJ9fSx7a2V5OlwicHJpbnRcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gTHIodCkucmVwbGFjZSgvKFwiKXwoXFxbKXwoXFxdKXwoLFwiX190eXBlX19cIikvZyxcIlwiKS5yZXBsYWNlKC8oLCkvZyxcIiwgXCIpfX0se2tleTpcImxldmVuc2h0ZWluRGlzdGFuY2VcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gZS5sZW5ndGg7aWYoMD09PWUubGVuZ3RoKXJldHVybiB0Lmxlbmd0aDt2YXIgaSxvLG49W107Zm9yKGk9MDtpPD1lLmxlbmd0aDtpKyspbltpXT1baV07Zm9yKG89MDtvPD10Lmxlbmd0aDtvKyspblswXVtvXT1vO2ZvcihpPTE7aTw9ZS5sZW5ndGg7aSsrKWZvcihvPTE7bzw9dC5sZW5ndGg7bysrKWUuY2hhckF0KGktMSk9PXQuY2hhckF0KG8tMSk/bltpXVtvXT1uW2ktMV1bby0xXTpuW2ldW29dPU1hdGgubWluKG5baS0xXVtvLTFdKzEsTWF0aC5taW4obltpXVtvLTFdKzEsbltpLTFdW29dKzEpKTtyZXR1cm4gbltlLmxlbmd0aF1bdC5sZW5ndGhdfX1dKSx0fSgpO2Z1bmN0aW9uIERoKHQpe3JldHVybiBqaD10LGZ1bmN0aW9uKCl7dmFyIHQ9e307TGg9MCx2b2lkKEhoPWpoLmNoYXJBdCgwKSksWmgoKSxcInN0cmljdFwiPT09V2gmJih0LnN0cmljdD0hMCxaaCgpKTtcImdyYXBoXCIhPT1XaCYmXCJkaWdyYXBoXCIhPT1XaHx8KHQudHlwZT1XaCxaaCgpKTtWaD09PU5oJiYodC5pZD1XaCxaaCgpKTtpZihcIntcIiE9V2gpdGhyb3cgbmQoXCJBbmdsZSBicmFja2V0IHsgZXhwZWN0ZWRcIik7aWYoWmgoKSxKaCh0KSxcIn1cIiE9V2gpdGhyb3cgbmQoXCJBbmdsZSBicmFja2V0IH0gZXhwZWN0ZWRcIik7aWYoWmgoKSxcIlwiIT09V2gpdGhyb3cgbmQoXCJFbmQgb2YgZmlsZSBleHBlY3RlZFwiKTtyZXR1cm4gWmgoKSxkZWxldGUgdC5ub2RlLGRlbGV0ZSB0LmVkZ2UsZGVsZXRlIHQuZ3JhcGgsdH0oKX12YXIgQmg9e2ZvbnRzaXplOlwiZm9udC5zaXplXCIsZm9udGNvbG9yOlwiZm9udC5jb2xvclwiLGxhYmVsZm9udGNvbG9yOlwiZm9udC5jb2xvclwiLGZvbnRuYW1lOlwiZm9udC5mYWNlXCIsY29sb3I6W1wiY29sb3IuYm9yZGVyXCIsXCJjb2xvci5iYWNrZ3JvdW5kXCJdLGZpbGxjb2xvcjpcImNvbG9yLmJhY2tncm91bmRcIix0b29sdGlwOlwidGl0bGVcIixsYWJlbHRvb2x0aXA6XCJ0aXRsZVwifSxJaD1JcihCaCk7SWguY29sb3I9XCJjb2xvci5jb2xvclwiLEloLnN0eWxlPVwiZGFzaGVzXCI7dmFyIHpoPTAsRmg9MSxOaD0yLEFoPTMsUmg9e1wie1wiOiEwLFwifVwiOiEwLFwiW1wiOiEwLFwiXVwiOiEwLFwiO1wiOiEwLFwiPVwiOiEwLFwiLFwiOiEwLFwiLT5cIjohMCxcIi0tXCI6ITB9LGpoPVwiXCIsTGg9MCxIaD1cIlwiLFdoPVwiXCIsVmg9emg7ZnVuY3Rpb24gcWgoKXtMaCsrLEhoPWpoLmNoYXJBdChMaCl9ZnVuY3Rpb24gVWgoKXtyZXR1cm4gamguY2hhckF0KExoKzEpfWZ1bmN0aW9uIFloKHQpe3ZhciBlPXQuY2hhckNvZGVBdCgwKTtyZXR1cm4gZTw0Nz8zNT09PWV8fDQ2PT09ZTplPDU5P2U+NDc6ZTw5MT9lPjY0OmU8OTY/OTU9PT1lOmU8MTIzJiZlPjk2fWZ1bmN0aW9uIFhoKHQsZSl7aWYodHx8KHQ9e30pLGUpZm9yKHZhciBpIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShpKSYmKHRbaV09ZVtpXSk7cmV0dXJuIHR9ZnVuY3Rpb24gR2godCxlLGkpe2Zvcih2YXIgbz1lLnNwbGl0KFwiLlwiKSxuPXQ7by5sZW5ndGg7KXt2YXIgcj1vLnNoaWZ0KCk7by5sZW5ndGg/KG5bcl18fChuW3JdPXt9KSxuPW5bcl0pOm5bcl09aX19ZnVuY3Rpb24gS2godCxlKXtmb3IodmFyIGksbyxuPW51bGwscj1bdF0scz10O3MucGFyZW50OylyLnB1c2gocy5wYXJlbnQpLHM9cy5wYXJlbnQ7aWYocy5ub2Rlcylmb3IoaT0wLG89cy5ub2Rlcy5sZW5ndGg7aTxvO2krKylpZihlLmlkPT09cy5ub2Rlc1tpXS5pZCl7bj1zLm5vZGVzW2ldO2JyZWFrfWZvcihufHwobj17aWQ6ZS5pZH0sdC5ub2RlJiYobi5hdHRyPVhoKG4uYXR0cix0Lm5vZGUpKSksaT1yLmxlbmd0aC0xO2k+PTA7aS0tKXt2YXIgYSxoPXJbaV07aC5ub2Rlc3x8KGgubm9kZXM9W10pLC0xPT09TXIoYT1oLm5vZGVzKS5jYWxsKGEsbikmJmgubm9kZXMucHVzaChuKX1lLmF0dHImJihuLmF0dHI9WGgobi5hdHRyLGUuYXR0cikpfWZ1bmN0aW9uICRoKHQsZSl7aWYodC5lZGdlc3x8KHQuZWRnZXM9W10pLHQuZWRnZXMucHVzaChlKSx0LmVkZ2Upe3ZhciBpPVhoKHt9LHQuZWRnZSk7ZS5hdHRyPVhoKGksZS5hdHRyKX19ZnVuY3Rpb24gUWgodCxlLGksbyxuKXt2YXIgcj17ZnJvbTplLHRvOmksdHlwZTpvfTtyZXR1cm4gdC5lZGdlJiYoci5hdHRyPVhoKHt9LHQuZWRnZSkpLHIuYXR0cj1YaChyLmF0dHJ8fHt9LG4pLG51bGwhPW4mJm4uaGFzT3duUHJvcGVydHkoXCJhcnJvd3NcIikmJm51bGwhPW4uYXJyb3dzJiYoci5hcnJvd3M9e3RvOntlbmFibGVkOiEwLHR5cGU6bi5hcnJvd3MudHlwZX19LG4uYXJyb3dzPW51bGwpLHJ9ZnVuY3Rpb24gWmgoKXtmb3IoVmg9emgsV2g9XCJcIjtcIiBcIj09PUhofHxcIlxcdFwiPT09SGh8fFwiXFxuXCI9PT1IaHx8XCJcXHJcIj09PUhoOylxaCgpO2Rve3ZhciB0PSExO2lmKFwiI1wiPT09SGgpe2Zvcih2YXIgZT1MaC0xO1wiIFwiPT09amguY2hhckF0KGUpfHxcIlxcdFwiPT09amguY2hhckF0KGUpOyllLS07aWYoXCJcXG5cIj09PWpoLmNoYXJBdChlKXx8XCJcIj09PWpoLmNoYXJBdChlKSl7Zm9yKDtcIlwiIT1IaCYmXCJcXG5cIiE9SGg7KXFoKCk7dD0hMH19aWYoXCIvXCI9PT1IaCYmXCIvXCI9PT1VaCgpKXtmb3IoO1wiXCIhPUhoJiZcIlxcblwiIT1IaDspcWgoKTt0PSEwfWlmKFwiL1wiPT09SGgmJlwiKlwiPT09VWgoKSl7Zm9yKDtcIlwiIT1IaDspe2lmKFwiKlwiPT09SGgmJlwiL1wiPT09VWgoKSl7cWgoKSxxaCgpO2JyZWFrfXFoKCl9dD0hMH1mb3IoO1wiIFwiPT09SGh8fFwiXFx0XCI9PT1IaHx8XCJcXG5cIj09PUhofHxcIlxcclwiPT09SGg7KXFoKCl9d2hpbGUodCk7aWYoXCJcIiE9PUhoKXt2YXIgaT1IaCtVaCgpO2lmKFJoW2ldKXJldHVybiBWaD1GaCxXaD1pLHFoKCksdm9pZCBxaCgpO2lmKFJoW0hoXSlyZXR1cm4gVmg9RmgsV2g9SGgsdm9pZCBxaCgpO2lmKFloKEhoKXx8XCItXCI9PT1IaCl7Zm9yKFdoKz1IaCxxaCgpO1loKEhoKTspV2grPUhoLHFoKCk7cmV0dXJuXCJmYWxzZVwiPT09V2g/V2g9ITE6XCJ0cnVlXCI9PT1XaD9XaD0hMDppc05hTihOdW1iZXIoV2gpKXx8KFdoPU51bWJlcihXaCkpLHZvaWQoVmg9TmgpfWlmKCdcIic9PT1IaCl7Zm9yKHFoKCk7XCJcIiE9SGgmJignXCInIT1IaHx8J1wiJz09PUhoJiYnXCInPT09VWgoKSk7KSdcIic9PT1IaD8oV2grPUhoLHFoKCkpOlwiXFxcXFwiPT09SGgmJlwiblwiPT09VWgoKT8oV2grPVwiXFxuXCIscWgoKSk6V2grPUhoLHFoKCk7aWYoJ1wiJyE9SGgpdGhyb3cgbmQoJ0VuZCBvZiBzdHJpbmcgXCIgZXhwZWN0ZWQnKTtyZXR1cm4gcWgoKSx2b2lkKFZoPU5oKX1mb3IoVmg9QWg7XCJcIiE9SGg7KVdoKz1IaCxxaCgpO3Rocm93IG5ldyBTeW50YXhFcnJvcignU3ludGF4IGVycm9yIGluIHBhcnQgXCInK3JkKFdoLDMwKSsnXCInKX1WaD1GaH1mdW5jdGlvbiBKaCh0KXtmb3IoO1wiXCIhPT1XaCYmXCJ9XCIhPVdoOyl0ZCh0KSxcIjtcIj09PVdoJiZaaCgpfWZ1bmN0aW9uIHRkKHQpe3ZhciBlPWVkKHQpO2lmKGUpaWQodCxlKTtlbHNlIGlmKCFmdW5jdGlvbih0KXtpZihcIm5vZGVcIj09PVdoKXJldHVybiBaaCgpLHQubm9kZT1vZCgpLFwibm9kZVwiO2lmKFwiZWRnZVwiPT09V2gpcmV0dXJuIFpoKCksdC5lZGdlPW9kKCksXCJlZGdlXCI7aWYoXCJncmFwaFwiPT09V2gpcmV0dXJuIFpoKCksdC5ncmFwaD1vZCgpLFwiZ3JhcGhcIjtyZXR1cm4gbnVsbH0odCkpe2lmKFZoIT1OaCl0aHJvdyBuZChcIklkZW50aWZpZXIgZXhwZWN0ZWRcIik7dmFyIGk9V2g7aWYoWmgoKSxcIj1cIj09PVdoKXtpZihaaCgpLFZoIT1OaCl0aHJvdyBuZChcIklkZW50aWZpZXIgZXhwZWN0ZWRcIik7dFtpXT1XaCxaaCgpfWVsc2UhZnVuY3Rpb24odCxlKXt2YXIgaT17aWQ6ZX0sbz1vZCgpO28mJihpLmF0dHI9byk7S2godCxpKSxpZCh0LGUpfSh0LGkpfX1mdW5jdGlvbiBlZCh0KXt2YXIgZT1udWxsO2lmKFwic3ViZ3JhcGhcIj09PVdoJiYoKGU9e30pLnR5cGU9XCJzdWJncmFwaFwiLFpoKCksVmg9PT1OaCYmKGUuaWQ9V2gsWmgoKSkpLFwie1wiPT09V2gpe2lmKFpoKCksZXx8KGU9e30pLGUucGFyZW50PXQsZS5ub2RlPXQubm9kZSxlLmVkZ2U9dC5lZGdlLGUuZ3JhcGg9dC5ncmFwaCxKaChlKSxcIn1cIiE9V2gpdGhyb3cgbmQoXCJBbmdsZSBicmFja2V0IH0gZXhwZWN0ZWRcIik7WmgoKSxkZWxldGUgZS5ub2RlLGRlbGV0ZSBlLmVkZ2UsZGVsZXRlIGUuZ3JhcGgsZGVsZXRlIGUucGFyZW50LHQuc3ViZ3JhcGhzfHwodC5zdWJncmFwaHM9W10pLHQuc3ViZ3JhcGhzLnB1c2goZSl9cmV0dXJuIGV9ZnVuY3Rpb24gaWQodCxlKXtmb3IoO1wiLT5cIj09PVdofHxcIi0tXCI9PT1XaDspe3ZhciBpLG89V2g7WmgoKTt2YXIgbj1lZCh0KTtpZihuKWk9bjtlbHNle2lmKFZoIT1OaCl0aHJvdyBuZChcIklkZW50aWZpZXIgb3Igc3ViZ3JhcGggZXhwZWN0ZWRcIik7S2godCx7aWQ6aT1XaH0pLFpoKCl9JGgodCxRaCh0LGUsaSxvLG9kKCkpKSxlPWl9fWZ1bmN0aW9uIG9kKCl7Zm9yKHZhciB0LGUsaT1udWxsLG89e2Rhc2hlZDohMCxzb2xpZDohMSxkb3R0ZWQ6WzEsNV19LG49e2RvdDpcImNpcmNsZVwiLGJveDpcImJveFwiLGNyb3c6XCJjcm93XCIsY3VydmU6XCJjdXJ2ZVwiLGljdXJ2ZTpcImludl9jdXJ2ZVwiLG5vcm1hbDpcInRyaWFuZ2xlXCIsaW52OlwiaW52X3RyaWFuZ2xlXCIsZGlhbW9uZDpcImRpYW1vbmRcIix0ZWU6XCJiYXJcIix2ZWU6XCJ2ZWVcIn0scj1uZXcgQXJyYXkscz1uZXcgQXJyYXk7XCJbXCI9PT1XaDspe2ZvcihaaCgpLGk9e307XCJcIiE9PVdoJiZcIl1cIiE9V2g7KXtpZihWaCE9TmgpdGhyb3cgbmQoXCJBdHRyaWJ1dGUgbmFtZSBleHBlY3RlZFwiKTt2YXIgYT1XaDtpZihaaCgpLFwiPVwiIT1XaCl0aHJvdyBuZChcIkVxdWFsIHNpZ24gPSBleHBlY3RlZFwiKTtpZihaaCgpLFZoIT1OaCl0aHJvdyBuZChcIkF0dHJpYnV0ZSB2YWx1ZSBleHBlY3RlZFwiKTt2YXIgaD1XaDtcInN0eWxlXCI9PT1hJiYoaD1vW2hdKSxcImFycm93aGVhZFwiPT09YSYmKGE9XCJhcnJvd3NcIixoPXt0bzp7ZW5hYmxlZDohMCx0eXBlOm5baF19fSksXCJhcnJvd3RhaWxcIj09PWEmJihhPVwiYXJyb3dzXCIsaD17ZnJvbTp7ZW5hYmxlZDohMCx0eXBlOm5baF19fSksci5wdXNoKHthdHRyOmksbmFtZTphLHZhbHVlOmh9KSxzLnB1c2goYSksWmgoKSxcIixcIj09V2gmJlpoKCl9aWYoXCJdXCIhPVdoKXRocm93IG5kKFwiQnJhY2tldCBdIGV4cGVjdGVkXCIpO1poKCl9aWYoSm4ocykuY2FsbChzLFwiZGlyXCIpKXt2YXIgZD17YXJyb3dzOnt9fTtmb3IodD0wO3Q8ci5sZW5ndGg7dCsrKWlmKFwiYXJyb3dzXCI9PT1yW3RdLm5hbWUpaWYobnVsbCE9clt0XS52YWx1ZS50bylkLmFycm93cy50bz10O2Vsc2V7aWYobnVsbD09clt0XS52YWx1ZS5mcm9tKXRocm93IG5kKFwiSW52YWxpZCB2YWx1ZSBvZiBhcnJvd3NcIik7ZC5hcnJvd3MuZnJvbT10fWVsc2VcImRpclwiPT09clt0XS5uYW1lJiYoZC5kaXI9dCk7dmFyIGwsYyx1PXJbZC5kaXJdLnZhbHVlO2lmKCFKbihzKS5jYWxsKHMsXCJhcnJvd3NcIikpaWYoXCJib3RoXCI9PT11KXIucHVzaCh7YXR0cjpyW2QuZGlyXS5hdHRyLG5hbWU6XCJhcnJvd3NcIix2YWx1ZTp7dG86e2VuYWJsZWQ6ITB9fX0pLGQuYXJyb3dzLnRvPXIubGVuZ3RoLTEsci5wdXNoKHthdHRyOnJbZC5kaXJdLmF0dHIsbmFtZTpcImFycm93c1wiLHZhbHVlOntmcm9tOntlbmFibGVkOiEwfX19KSxkLmFycm93cy5mcm9tPXIubGVuZ3RoLTE7ZWxzZSBpZihcImZvcndhcmRcIj09PXUpci5wdXNoKHthdHRyOnJbZC5kaXJdLmF0dHIsbmFtZTpcImFycm93c1wiLHZhbHVlOnt0bzp7ZW5hYmxlZDohMH19fSksZC5hcnJvd3MudG89ci5sZW5ndGgtMTtlbHNlIGlmKFwiYmFja1wiPT09dSlyLnB1c2goe2F0dHI6cltkLmRpcl0uYXR0cixuYW1lOlwiYXJyb3dzXCIsdmFsdWU6e2Zyb206e2VuYWJsZWQ6ITB9fX0pLGQuYXJyb3dzLmZyb209ci5sZW5ndGgtMTtlbHNle2lmKFwibm9uZVwiIT09dSl0aHJvdyBuZCgnSW52YWxpZCBkaXIgdHlwZSBcIicrdSsnXCInKTtyLnB1c2goe2F0dHI6cltkLmRpcl0uYXR0cixuYW1lOlwiYXJyb3dzXCIsdmFsdWU6XCJcIn0pLGQuYXJyb3dzLnRvPXIubGVuZ3RoLTF9aWYoXCJib3RoXCI9PT11KWQuYXJyb3dzLnRvJiZkLmFycm93cy5mcm9tPyhjPXJbZC5hcnJvd3MudG9dLnZhbHVlLnRvLnR5cGUsbD1yW2QuYXJyb3dzLmZyb21dLnZhbHVlLmZyb20udHlwZSxyW2QuYXJyb3dzLnRvXT17YXR0cjpyW2QuYXJyb3dzLnRvXS5hdHRyLG5hbWU6cltkLmFycm93cy50b10ubmFtZSx2YWx1ZTp7dG86e2VuYWJsZWQ6ITAsdHlwZTpjfSxmcm9tOntlbmFibGVkOiEwLHR5cGU6bH19fSxxbihyKS5jYWxsKHIsZC5hcnJvd3MuZnJvbSwxKSk6ZC5hcnJvd3MudG8/KGM9cltkLmFycm93cy50b10udmFsdWUudG8udHlwZSxsPVwiYXJyb3dcIixyW2QuYXJyb3dzLnRvXT17YXR0cjpyW2QuYXJyb3dzLnRvXS5hdHRyLG5hbWU6cltkLmFycm93cy50b10ubmFtZSx2YWx1ZTp7dG86e2VuYWJsZWQ6ITAsdHlwZTpjfSxmcm9tOntlbmFibGVkOiEwLHR5cGU6bH19fSk6ZC5hcnJvd3MuZnJvbSYmKGM9XCJhcnJvd1wiLGw9cltkLmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGUscltkLmFycm93cy5mcm9tXT17YXR0cjpyW2QuYXJyb3dzLmZyb21dLmF0dHIsbmFtZTpyW2QuYXJyb3dzLmZyb21dLm5hbWUsdmFsdWU6e3RvOntlbmFibGVkOiEwLHR5cGU6Y30sZnJvbTp7ZW5hYmxlZDohMCx0eXBlOmx9fX0pO2Vsc2UgaWYoXCJiYWNrXCI9PT11KWQuYXJyb3dzLnRvJiZkLmFycm93cy5mcm9tPyhjPVwiXCIsbD1yW2QuYXJyb3dzLmZyb21dLnZhbHVlLmZyb20udHlwZSxyW2QuYXJyb3dzLmZyb21dPXthdHRyOnJbZC5hcnJvd3MuZnJvbV0uYXR0cixuYW1lOnJbZC5hcnJvd3MuZnJvbV0ubmFtZSx2YWx1ZTp7dG86e2VuYWJsZWQ6ITAsdHlwZTpjfSxmcm9tOntlbmFibGVkOiEwLHR5cGU6bH19fSk6ZC5hcnJvd3MudG8/KGM9XCJcIixsPVwiYXJyb3dcIixkLmFycm93cy5mcm9tPWQuYXJyb3dzLnRvLHJbZC5hcnJvd3MuZnJvbV09e2F0dHI6cltkLmFycm93cy5mcm9tXS5hdHRyLG5hbWU6cltkLmFycm93cy5mcm9tXS5uYW1lLHZhbHVlOnt0bzp7ZW5hYmxlZDohMCx0eXBlOmN9LGZyb206e2VuYWJsZWQ6ITAsdHlwZTpsfX19KTpkLmFycm93cy5mcm9tJiYoYz1cIlwiLGw9cltkLmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGUscltkLmFycm93cy50b109e2F0dHI6cltkLmFycm93cy5mcm9tXS5hdHRyLG5hbWU6cltkLmFycm93cy5mcm9tXS5uYW1lLHZhbHVlOnt0bzp7ZW5hYmxlZDohMCx0eXBlOmN9LGZyb206e2VuYWJsZWQ6ITAsdHlwZTpsfX19KSxyW2QuYXJyb3dzLmZyb21dPXthdHRyOnJbZC5hcnJvd3MuZnJvbV0uYXR0cixuYW1lOnJbZC5hcnJvd3MuZnJvbV0ubmFtZSx2YWx1ZTp7ZnJvbTp7ZW5hYmxlZDohMCx0eXBlOnJbZC5hcnJvd3MuZnJvbV0udmFsdWUuZnJvbS50eXBlfX19O2Vsc2UgaWYoXCJub25lXCI9PT11KXt2YXIgZjtyW2Y9ZC5hcnJvd3MudG8/ZC5hcnJvd3MudG86ZC5hcnJvd3MuZnJvbV09e2F0dHI6cltmXS5hdHRyLG5hbWU6cltmXS5uYW1lLHZhbHVlOlwiXCJ9fWVsc2V7aWYoXCJmb3J3YXJkXCIhPT11KXRocm93IG5kKCdJbnZhbGlkIGRpciB0eXBlIFwiJyt1KydcIicpO2QuYXJyb3dzLnRvJiZkLmFycm93cy5mcm9tfHxkLmFycm93cy50bz8oYz1yW2QuYXJyb3dzLnRvXS52YWx1ZS50by50eXBlLGw9XCJcIixyW2QuYXJyb3dzLnRvXT17YXR0cjpyW2QuYXJyb3dzLnRvXS5hdHRyLG5hbWU6cltkLmFycm93cy50b10ubmFtZSx2YWx1ZTp7dG86e2VuYWJsZWQ6ITAsdHlwZTpjfSxmcm9tOntlbmFibGVkOiEwLHR5cGU6bH19fSk6ZC5hcnJvd3MuZnJvbSYmKGM9XCJhcnJvd1wiLGw9XCJcIixkLmFycm93cy50bz1kLmFycm93cy5mcm9tLHJbZC5hcnJvd3MudG9dPXthdHRyOnJbZC5hcnJvd3MudG9dLmF0dHIsbmFtZTpyW2QuYXJyb3dzLnRvXS5uYW1lLHZhbHVlOnt0bzp7ZW5hYmxlZDohMCx0eXBlOmN9LGZyb206e2VuYWJsZWQ6ITAsdHlwZTpsfX19KSxyW2QuYXJyb3dzLnRvXT17YXR0cjpyW2QuYXJyb3dzLnRvXS5hdHRyLG5hbWU6cltkLmFycm93cy50b10ubmFtZSx2YWx1ZTp7dG86e2VuYWJsZWQ6ITAsdHlwZTpyW2QuYXJyb3dzLnRvXS52YWx1ZS50by50eXBlfX19fXFuKHIpLmNhbGwocixkLmRpciwxKX1pZihKbihzKS5jYWxsKHMsXCJwZW53aWR0aFwiKSl7dmFyIHA9W107Zm9yKGU9ci5sZW5ndGgsdD0wO3Q8ZTt0KyspXCJ3aWR0aFwiIT09clt0XS5uYW1lJiYoXCJwZW53aWR0aFwiPT09clt0XS5uYW1lJiYoclt0XS5uYW1lPVwid2lkdGhcIikscC5wdXNoKHJbdF0pKTtyPXB9Zm9yKGU9ci5sZW5ndGgsdD0wO3Q8ZTt0KyspR2goclt0XS5hdHRyLHJbdF0ubmFtZSxyW3RdLnZhbHVlKTtyZXR1cm4gaX1mdW5jdGlvbiBuZCh0KXtyZXR1cm4gbmV3IFN5bnRheEVycm9yKHQrJywgZ290IFwiJytyZChXaCwzMCkrJ1wiIChjaGFyICcrTGgrXCIpXCIpfWZ1bmN0aW9uIHJkKHQsZSl7cmV0dXJuIHQubGVuZ3RoPD1lP3Q6dC5zdWJzdHIoMCwyNykrXCIuLi5cIn1mdW5jdGlvbiBzZCh0LGUsaSl7Zm9yKHZhciBvPWUuc3BsaXQoXCIuXCIpLG49by5wb3AoKSxyPXQscz0wO3M8by5sZW5ndGg7cysrKXt2YXIgYT1vW3NdO2EgaW4gcnx8KHJbYV09e30pLHI9clthXX1yZXR1cm4gcltuXT1pLHR9ZnVuY3Rpb24gYWQodCxlKXt2YXIgaT17fTtmb3IodmFyIG8gaW4gdClpZih0Lmhhc093blByb3BlcnR5KG8pKXt2YXIgbj1lW29dO2duKG4pP0RuKG4pLmNhbGwobiwoZnVuY3Rpb24oZSl7c2QoaSxlLHRbb10pfSkpOnNkKGksXCJzdHJpbmdcIj09dHlwZW9mIG4/bjpvLHRbb10pfXJldHVybiBpfWZ1bmN0aW9uIGhkKHQpe3ZhciBlLGk9RGgodCksbz17bm9kZXM6W10sZWRnZXM6W10sb3B0aW9uczp7fX07aS5ub2RlcyYmRG4oZT1pLm5vZGVzKS5jYWxsKGUsKGZ1bmN0aW9uKHQpe3ZhciBlPXtpZDp0LmlkLGxhYmVsOlN0cmluZyh0LmxhYmVsfHx0LmlkKX07WGgoZSxhZCh0LmF0dHIsQmgpKSxlLmltYWdlJiYoZS5zaGFwZT1cImltYWdlXCIpLG8ubm9kZXMucHVzaChlKX0pKTtpZihpLmVkZ2VzKXt2YXIgbixyPWZ1bmN0aW9uKHQpe3ZhciBlPXtmcm9tOnQuZnJvbSx0bzp0LnRvfTtyZXR1cm4gWGgoZSxhZCh0LmF0dHIsSWgpKSxudWxsPT1lLmFycm93cyYmXCItPlwiPT09dC50eXBlJiYoZS5hcnJvd3M9XCJ0b1wiKSxlfTtEbihuPWkuZWRnZXMpLmNhbGwobiwoZnVuY3Rpb24odCl7dmFyIGUsaSxuLHMsYSxoLGQ7KGU9dC5mcm9tIGluc3RhbmNlb2YgT2JqZWN0P3QuZnJvbS5ub2Rlczp7aWQ6dC5mcm9tfSxpPXQudG8gaW5zdGFuY2VvZiBPYmplY3Q/dC50by5ub2Rlczp7aWQ6dC50b30sdC5mcm9tIGluc3RhbmNlb2YgT2JqZWN0JiZ0LmZyb20uZWRnZXMpJiZEbihuPXQuZnJvbS5lZGdlcykuY2FsbChuLChmdW5jdGlvbih0KXt2YXIgZT1yKHQpO28uZWRnZXMucHVzaChlKX0pKTsoYT1pLGg9ZnVuY3Rpb24oZSxpKXt2YXIgbj1RaChvLGUuaWQsaS5pZCx0LnR5cGUsdC5hdHRyKSxzPXIobik7by5lZGdlcy5wdXNoKHMpfSxnbihzPWUpP0RuKHMpLmNhbGwocywoZnVuY3Rpb24odCl7Z24oYSk/RG4oYSkuY2FsbChhLChmdW5jdGlvbihlKXtoKHQsZSl9KSk6aCh0LGEpfSkpOmduKGEpP0RuKGEpLmNhbGwoYSwoZnVuY3Rpb24odCl7aChzLHQpfSkpOmgocyxhKSx0LnRvIGluc3RhbmNlb2YgT2JqZWN0JiZ0LnRvLmVkZ2VzKSYmRG4oZD10LnRvLmVkZ2VzKS5jYWxsKGQsKGZ1bmN0aW9uKHQpe3ZhciBlPXIodCk7by5lZGdlcy5wdXNoKGUpfSkpfSkpfXJldHVybiBpLmF0dHImJihvLm9wdGlvbnM9aS5hdHRyKSxvfXZhciBkZD1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxwYXJzZURPVDpEaCxET1RUb0dyYXBoOmhkfSk7ZnVuY3Rpb24gbGQodCxlKXt2YXIgaSxvPXtlZGdlczp7aW5oZXJpdENvbG9yOiExfSxub2Rlczp7Zml4ZWQ6ITEscGFyc2VDb2xvcjohMX19O251bGwhPWUmJihudWxsIT1lLmZpeGVkJiYoby5ub2Rlcy5maXhlZD1lLmZpeGVkKSxudWxsIT1lLnBhcnNlQ29sb3ImJihvLm5vZGVzLnBhcnNlQ29sb3I9ZS5wYXJzZUNvbG9yKSxudWxsIT1lLmluaGVyaXRDb2xvciYmKG8uZWRnZXMuaW5oZXJpdENvbG9yPWUuaW5oZXJpdENvbG9yKSk7dmFyIG49dC5lZGdlcyxyPWtuKG4pLmNhbGwobiwoZnVuY3Rpb24odCl7dmFyIGU9e2Zyb206dC5zb3VyY2UsaWQ6dC5pZCx0bzp0LnRhcmdldH07cmV0dXJuIG51bGwhPXQuYXR0cmlidXRlcyYmKGUuYXR0cmlidXRlcz10LmF0dHJpYnV0ZXMpLG51bGwhPXQubGFiZWwmJihlLmxhYmVsPXQubGFiZWwpLG51bGwhPXQuYXR0cmlidXRlcyYmbnVsbCE9dC5hdHRyaWJ1dGVzLnRpdGxlJiYoZS50aXRsZT10LmF0dHJpYnV0ZXMudGl0bGUpLFwiRGlyZWN0ZWRcIj09PXQudHlwZSYmKGUuYXJyb3dzPVwidG9cIiksdC5jb2xvciYmITE9PT1vLmVkZ2VzLmluaGVyaXRDb2xvciYmKGUuY29sb3I9dC5jb2xvciksZX0pKTtyZXR1cm57bm9kZXM6a24oaT10Lm5vZGVzKS5jYWxsKGksKGZ1bmN0aW9uKHQpe3ZhciBlPXtpZDp0LmlkLGZpeGVkOm8ubm9kZXMuZml4ZWQmJm51bGwhPXQueCYmbnVsbCE9dC55fTtyZXR1cm4gbnVsbCE9dC5hdHRyaWJ1dGVzJiYoZS5hdHRyaWJ1dGVzPXQuYXR0cmlidXRlcyksbnVsbCE9dC5sYWJlbCYmKGUubGFiZWw9dC5sYWJlbCksbnVsbCE9dC5zaXplJiYoZS5zaXplPXQuc2l6ZSksbnVsbCE9dC5hdHRyaWJ1dGVzJiZudWxsIT10LmF0dHJpYnV0ZXMudGl0bGUmJihlLnRpdGxlPXQuYXR0cmlidXRlcy50aXRsZSksbnVsbCE9dC50aXRsZSYmKGUudGl0bGU9dC50aXRsZSksbnVsbCE9dC54JiYoZS54PXQueCksbnVsbCE9dC55JiYoZS55PXQueSksbnVsbCE9dC5jb2xvciYmKCEwPT09by5ub2Rlcy5wYXJzZUNvbG9yP2UuY29sb3I9dC5jb2xvcjplLmNvbG9yPXtiYWNrZ3JvdW5kOnQuY29sb3IsYm9yZGVyOnQuY29sb3IsaGlnaGxpZ2h0OntiYWNrZ3JvdW5kOnQuY29sb3IsYm9yZGVyOnQuY29sb3J9LGhvdmVyOntiYWNrZ3JvdW5kOnQuY29sb3IsYm9yZGVyOnQuY29sb3J9fSksZX0pKSxlZGdlczpyfX12YXIgY2Q9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwscGFyc2VHZXBoaTpsZH0pLHVkPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGVuOnthZGREZXNjcmlwdGlvbjpcIkNsaWNrIGluIGFuIGVtcHR5IHNwYWNlIHRvIHBsYWNlIGEgbmV3IG5vZGUuXCIsYWRkRWRnZTpcIkFkZCBFZGdlXCIsYWRkTm9kZTpcIkFkZCBOb2RlXCIsYmFjazpcIkJhY2tcIixjbG9zZTpcIkNsb3NlXCIsY3JlYXRlRWRnZUVycm9yOlwiQ2Fubm90IGxpbmsgZWRnZXMgdG8gYSBjbHVzdGVyLlwiLGRlbDpcIkRlbGV0ZSBzZWxlY3RlZFwiLGRlbGV0ZUNsdXN0ZXJFcnJvcjpcIkNsdXN0ZXJzIGNhbm5vdCBiZSBkZWxldGVkLlwiLGVkZ2VEZXNjcmlwdGlvbjpcIkNsaWNrIG9uIGEgbm9kZSBhbmQgZHJhZyB0aGUgZWRnZSB0byBhbm90aGVyIG5vZGUgdG8gY29ubmVjdCB0aGVtLlwiLGVkaXQ6XCJFZGl0XCIsZWRpdENsdXN0ZXJFcnJvcjpcIkNsdXN0ZXJzIGNhbm5vdCBiZSBlZGl0ZWQuXCIsZWRpdEVkZ2U6XCJFZGl0IEVkZ2VcIixlZGl0RWRnZURlc2NyaXB0aW9uOlwiQ2xpY2sgb24gdGhlIGNvbnRyb2wgcG9pbnRzIGFuZCBkcmFnIHRoZW0gdG8gYSBub2RlIHRvIGNvbm5lY3QgdG8gaXQuXCIsZWRpdE5vZGU6XCJFZGl0IE5vZGVcIn0sZGU6e2FkZERlc2NyaXB0aW9uOlwiS2xpY2tlIGF1ZiBlaW5lIGZyZWllIFN0ZWxsZSwgdW0gZWluZW4gbmV1ZW4gS25vdGVuIHp1IHBsYXppZXJlbi5cIixhZGRFZGdlOlwiS2FudGUgaGluenVmw7xnZW5cIixhZGROb2RlOlwiS25vdGVuIGhpbnp1ZsO8Z2VuXCIsYmFjazpcIlp1csO8Y2tcIixjbG9zZTpcIlNjaGxpZcOfZW5cIixjcmVhdGVFZGdlRXJyb3I6XCJFcyBpc3QgbmljaHQgbcO2Z2xpY2gsIEthbnRlbiBtaXQgQ2x1c3Rlcm4genUgdmVyYmluZGVuLlwiLGRlbDpcIkzDtnNjaGUgQXVzd2FobFwiLGRlbGV0ZUNsdXN0ZXJFcnJvcjpcIkNsdXN0ZXIga8O2bm5lbiBuaWNodCBnZWzDtnNjaHQgd2VyZGVuLlwiLGVkZ2VEZXNjcmlwdGlvbjpcIktsaWNrZSBhdWYgZWluZW4gS25vdGVuIHVuZCB6aWVoZSBkaWUgS2FudGUgenUgZWluZW0gYW5kZXJlbiBLbm90ZW4sIHVtIGRpZXNlIHp1IHZlcmJpbmRlbi5cIixlZGl0OlwiRWRpdGllcmVuXCIsZWRpdENsdXN0ZXJFcnJvcjpcIkNsdXN0ZXIga8O2bm5lbiBuaWNodCBlZGl0aWVydCB3ZXJkZW4uXCIsZWRpdEVkZ2U6XCJLYW50ZSBlZGl0aWVyZW5cIixlZGl0RWRnZURlc2NyaXB0aW9uOlwiS2xpY2tlIGF1ZiBkaWUgVmVyYmluZHVuZ3NwdW5rdGUgdW5kIHppZWhlIGRpZXNlIGF1ZiBlaW5lbiBLbm90ZW4sIHVtIHNpZSB6dSB2ZXJiaW5kZW4uXCIsZWRpdE5vZGU6XCJLbm90ZW4gZWRpdGllcmVuXCJ9LGVzOnthZGREZXNjcmlwdGlvbjpcIkhhZ2EgY2xpYyBlbiB1biBsdWdhciB2YWPDrW8gcGFyYSBjb2xvY2FyIHVuIG51ZXZvIG5vZG8uXCIsYWRkRWRnZTpcIkHDsWFkaXIgYXJpc3RhXCIsYWRkTm9kZTpcIkHDsWFkaXIgbm9kb1wiLGJhY2s6XCJBdHLDoXNcIixjbG9zZTpcIkNlcnJhclwiLGNyZWF0ZUVkZ2VFcnJvcjpcIk5vIHNlIHB1ZWRlIGNvbmVjdGFyIHVuYSBhcmlzdGEgYSB1biBncnVwby5cIixkZWw6XCJFbGltaW5hciBzZWxlY2Npw7NuXCIsZGVsZXRlQ2x1c3RlckVycm9yOlwiTm8gZXMgcG9zaWJsZSBlbGltaW5hciBncnVwb3MuXCIsZWRnZURlc2NyaXB0aW9uOlwiSGFnYSBjbGljIGVuIHVuIG5vZG8geSBhcnJhc3RyZSBsYSBhcmlzdGEgaGFjaWEgb3RybyBub2RvIHBhcmEgY29uZWN0YXJsb3MuXCIsZWRpdDpcIkVkaXRhclwiLGVkaXRDbHVzdGVyRXJyb3I6XCJObyBlcyBwb3NpYmxlIGVkaXRhciBncnVwb3MuXCIsZWRpdEVkZ2U6XCJFZGl0YXIgYXJpc3RhXCIsZWRpdEVkZ2VEZXNjcmlwdGlvbjpcIkhhZ2EgY2xpYyBlbiB1biBwdW50byBkZSBjb250cm9sIHkgYXJyYXN0cmVsbyBhIHVuIG5vZG8gcGFyYSBjb25lY3RhcmxvLlwiLGVkaXROb2RlOlwiRWRpdGFyIG5vZG9cIn0saXQ6e2FkZERlc2NyaXB0aW9uOlwiQ2xpY2NhIHBlciBhZ2dpdW5nZXJlIHVuIG51b3ZvIG5vZG9cIixhZGRFZGdlOlwiQWdnaXVuZ2kgdW4gdmVydGljZVwiLGFkZE5vZGU6XCJBZ2dpdW5naSB1biBub2RvXCIsYmFjazpcIkluZGlldHJvXCIsY2xvc2U6XCJDaGl1ZGVyZVwiLGNyZWF0ZUVkZ2VFcnJvcjpcIk5vbiBzaSBwb3Nzb25vIGNvbGxlZ2FyZSB2ZXJ0aWNpIGFkIHVuIGNsdXN0ZXJcIixkZWw6XCJDYW5jZWxsYSBsYSBzZWxlemlvbmVcIixkZWxldGVDbHVzdGVyRXJyb3I6XCJJIGNsdXN0ZXIgbm9uIHBvc3Nvbm8gZXNzZXJlIGNhbmNlbGxhdGlcIixlZGdlRGVzY3JpcHRpb246XCJDbGljY2Egc3UgdW4gbm9kbyBlIHRyYXNjaW5hbG8gYWQgdW4gYWx0cm8gbm9kbyBwZXIgY29ubmV0dGVybGkuXCIsZWRpdDpcIk1vZGlmaWNhXCIsZWRpdENsdXN0ZXJFcnJvcjpcIkkgY2x1c3RlcnMgbm9uIHBvc3Nvbm8gZXNzZXJlIG1vZGlmaWNhdGkuXCIsZWRpdEVkZ2U6XCJNb2RpZmljYSBpbCB2ZXJ0aWNlXCIsZWRpdEVkZ2VEZXNjcmlwdGlvbjpcIkNsaWNjYSBzdWkgUHVudGkgZGkgY29udHJvbGxvIGUgdHJhc2NpbmFsaSBhZCB1biBub2RvIHBlciBjb25uZXR0ZXJsaS5cIixlZGl0Tm9kZTpcIk1vZGlmaWNhIGlsIG5vZG9cIn0sbmw6e2FkZERlc2NyaXB0aW9uOlwiS2xpayBvcCBlZW4gbGVlZyBnZWJpZWQgb20gZWVuIG5pZXV3ZSBub2RlIHRlIG1ha2VuLlwiLGFkZEVkZ2U6XCJMaW5rIHRvZXZvZWdlblwiLGFkZE5vZGU6XCJOb2RlIHRvZXZvZWdlblwiLGJhY2s6XCJUZXJ1Z1wiLGNsb3NlOlwiU2x1aXRlblwiLGNyZWF0ZUVkZ2VFcnJvcjpcIkthbiBnZWVuIGxpbmsgbWFrZW4gbmFhciBlZW4gY2x1c3Rlci5cIixkZWw6XCJTZWxlY3RpZSB2ZXJ3aWpkZXJlblwiLGRlbGV0ZUNsdXN0ZXJFcnJvcjpcIkNsdXN0ZXJzIGt1bm5lbiBuaWV0IHdvcmRlbiB2ZXJ3aWpkZXJkLlwiLGVkZ2VEZXNjcmlwdGlvbjpcIktsaWsgb3AgZWVuIG5vZGUgZW4gc2xlZXAgZGUgbGluayBuYWFyIGVlbiBhbmRlcmUgbm9kZSBvbSB6ZSB0ZSB2ZXJiaW5kZW4uXCIsZWRpdDpcIldpanppZ2VuXCIsZWRpdENsdXN0ZXJFcnJvcjpcIkNsdXN0ZXJzIGt1bm5lbiBuaWV0IHdvcmRlbiBhYW5nZXBhc3QuXCIsZWRpdEVkZ2U6XCJMaW5rIHdpanppZ2VuXCIsZWRpdEVkZ2VEZXNjcmlwdGlvbjpcIktsaWsgb3AgZGUgdmVyYmluZGluZ3NwdW50ZW4gZW4gc2xlZXAgemUgbmFhciBlZW4gbm9kZSBvbSBkYWFybWVlIHRlIHZlcmJpbmRlbi5cIixlZGl0Tm9kZTpcIk5vZGUgd2lqemlnZW5cIn0scHQ6e2FkZERlc2NyaXB0aW9uOlwiQ2xpcXVlIGVtIHVtIGVzcGHDp28gZW0gYnJhbmNvIHBhcmEgYWRpY2lvbmFyIHVtIG5vdm8gbsOzXCIsYWRkRWRnZTpcIkFkaWNpb25hciBhcmVzdGFcIixhZGROb2RlOlwiQWRpY2lvbmFyIG7Ds1wiLGJhY2s6XCJWb2x0YXJcIixjbG9zZTpcIkZlY2hhclwiLGNyZWF0ZUVkZ2VFcnJvcjpcIk7Do28gZm9pIHBvc3PDrXZlbCBsaW5rYXIgYXJlc3RhcyBhIHVtIGNsdXN0ZXIuXCIsZGVsOlwiUmVtb3ZlciBzZWxlY2lvbmFkb1wiLGRlbGV0ZUNsdXN0ZXJFcnJvcjpcIkNsdXN0ZXJzIG7Do28gcHVkZXJhbSBzZXIgcmVtb3ZpZG9zLlwiLGVkZ2VEZXNjcmlwdGlvbjpcIkNsaXF1ZSBlbSB1bSBuw7MgZSBhcnJhc3RlIGEgYXJlc3RhIGF0w6kgb3V0cm8gbsOzIHBhcmEgY29uZWN0w6EtbG9zXCIsZWRpdDpcIkVkaXRhclwiLGVkaXRDbHVzdGVyRXJyb3I6XCJDbHVzdGVycyBuw6NvIHB1ZGVyYW0gc2VyIGVkaXRhZG9zLlwiLGVkaXRFZGdlOlwiRWRpdGFyIGFyZXN0YVwiLGVkaXRFZGdlRGVzY3JpcHRpb246XCJDbGlxdWUgbm9zIHBvbnRvcyBkZSBjb250cm9sZSBlIG9zIGFycmFzdGUgcGFyYSB1bSBuw7MgcGFyYSBjb25lY3TDoS1sb3NcIixlZGl0Tm9kZTpcIkVkaXRhciBuw7NcIn0scnU6e2FkZERlc2NyaXB0aW9uOlwi0JrQu9C40LrQvdC40YLQtSDQsiDRgdCy0L7QsdC+0LTQvdC+0LUg0LzQtdGB0YLQviwg0YfRgtC+0LHRiyDQtNC+0LHQsNCy0LjRgtGMINC90L7QstGL0Lkg0YPQt9C10LsuXCIsYWRkRWRnZTpcItCU0L7QsdCw0LLQuNGC0Ywg0YDQtdCx0YDQvlwiLGFkZE5vZGU6XCLQlNC+0LHQsNCy0LjRgtGMINGD0LfQtdC7XCIsYmFjazpcItCd0LDQt9Cw0LRcIixjbG9zZTpcItCX0LDQutGA0YvQstCw0YLRjFwiLGNyZWF0ZUVkZ2VFcnJvcjpcItCd0LXQstC+0LfQvNC+0LbQvdC+INGB0L7QtdC00LjQvdC40YLRjCDRgNC10LHRgNCwINCyINC60LvQsNGB0YLQtdGALlwiLGRlbDpcItCj0LTQsNC70LjRgtGMINCy0YvQsdGA0LDQvdC90L7QtVwiLGRlbGV0ZUNsdXN0ZXJFcnJvcjpcItCa0LvQsNGB0YLQtdGA0Ysg0L3QtSDQvNC+0LPRg9GCINCx0YvRgtGMINGD0LTQsNC70LXQvdGLXCIsZWRnZURlc2NyaXB0aW9uOlwi0JrQu9C40LrQvdC40YLQtSDQvdCwINGD0LfQtdC7INC4INC/0YDQvtGC0Y/QvdC40YLQtSDRgNC10LHRgNC+INC6INC00YDRg9Cz0L7QvNGDINGD0LfQu9GDLCDRh9GC0L7QsdGLINGB0L7QtdC00LjQvdC40YLRjCDQuNGFLlwiLGVkaXQ6XCLQoNC10LTQsNC60YLQuNGA0L7QstCw0YLRjFwiLGVkaXRDbHVzdGVyRXJyb3I6XCLQmtC70LDRgdGC0LXRgNGLINC90LXQtNC+0YHRgtGD0L/QvdGLINC00LvRjyDRgNC10LTQsNC60YLQuNGA0L7QstCw0L3QuNGPLlwiLGVkaXRFZGdlOlwi0KDQtdC00LDQutGC0LjRgNC+0LLQsNGC0Ywg0YDQtdCx0YDQvlwiLGVkaXRFZGdlRGVzY3JpcHRpb246XCLQmtC70LjQutC90LjRgtC1INC90LAg0LrQvtC90YLRgNC+0LvRjNC90YvQtSDRgtC+0YfQutC4INC4INC/0LXRgNC10YLQsNGJ0LjRgtC1INC40YUg0LIg0YPQt9C10LssINGH0YLQvtCx0Ysg0L/QvtC00LrQu9GO0YfQuNGC0YzRgdGPINC6INC90LXQvNGDLlwiLGVkaXROb2RlOlwi0KDQtdC00LDQutGC0LjRgNC+0LLQsNGC0Ywg0YPQt9C10LtcIn0sY246e2FkZERlc2NyaXB0aW9uOlwi5Y2V5Ye756m655m95aSE5pS+572u5paw6IqC54K544CCXCIsYWRkRWRnZTpcIua3u+WKoOi/nuaOpee6v1wiLGFkZE5vZGU6XCLmt7vliqDoioLngrlcIixiYWNrOlwi6L+U5ZueXCIsY2xvc2U6XCLpl5zplolcIixjcmVhdGVFZGdlRXJyb3I6XCLml6Dms5XlsIbov57mjqXnur/ov57mjqXliLDnvqTpm4bjgIJcIixkZWw6XCLliKDpmaTpgInlrppcIixkZWxldGVDbHVzdGVyRXJyb3I6XCLml6Dms5XliKDpmaTnvqTpm4bjgIJcIixlZGdlRGVzY3JpcHRpb246XCLljZXlh7vmn5DkuKroioLngrnlubblsIbor6Xov57mjqXnur/mi5bliqjliLDlj6bkuIDkuKroioLngrnku6Xov57mjqXlroPku6zjgIJcIixlZGl0Olwi57yW6L6RXCIsZWRpdENsdXN0ZXJFcnJvcjpcIuaXoOazlee8lui+kee+pOmbhuOAglwiLGVkaXRFZGdlOlwi57yW6L6R6L+e5o6l57q/XCIsZWRpdEVkZ2VEZXNjcmlwdGlvbjpcIuWNleWHu+aOp+WItuiKgueCueW5tuWwhuWug+S7rOaLluWIsOiKgueCueS4iui/nuaOpeOAglwiLGVkaXROb2RlOlwi57yW6L6R6IqC54K5XCJ9LHVrOnthZGREZXNjcmlwdGlvbjpcIkvQu9GW0LrQvdGW0YLRjCDQvdCwINCy0ZbQu9GM0L3QtSDQvNGW0YHRhtC1LCDRidC+0LEg0LTQvtC00LDRgtC4INC90L7QstC40Lkg0LLRg9C30L7Quy5cIixhZGRFZGdlOlwi0JTQvtC00LDRgtC4INC60YDQsNC5XCIsYWRkTm9kZTpcItCU0L7QtNCw0YLQuCDQstGD0LfQvtC7XCIsYmFjazpcItCd0LDQt9Cw0LRcIixjbG9zZTpcItCX0LDQutGA0LjRgtC4XCIsY3JlYXRlRWRnZUVycm9yOlwi0J3QtSDQvNC+0LbQu9C40LLQviDQvtCxJ9GU0LTQvdCw0YLQuCDQutGA0LDRlyDQsiDQs9GA0YPQv9GDLlwiLGRlbDpcItCS0LjQtNCw0LvQuNGC0Lgg0L7QsdGA0LDQvdC1XCIsZGVsZXRlQ2x1c3RlckVycm9yOlwi0JPRgNGD0L/QuCDQvdC1INC80L7QttGD0YLRjCDQsdGD0YLQuCDQstC40LTQsNC70LXQvdGWLlwiLGVkZ2VEZXNjcmlwdGlvbjpcItCa0LvRltC60L3RltGC0Ywg0L3QsCDQstGD0LfQvtC7INGWINC/0LXRgNC10YLRj9Cz0L3RltGC0Ywg0LrRgNCw0Lkg0LTQviDRltC90YjQvtCz0L4g0LLRg9C30LvQsCwg0YnQvtCxINGX0YUg0Lcn0ZTQtNC90LDRgtC4LlwiLGVkaXQ6XCLQoNC10LTQsNCz0YPQstCw0YLQuFwiLGVkaXRDbHVzdGVyRXJyb3I6XCLQk9GA0YPQv9C4INC90LXQtNC+0YHRgtGD0L/QvdGWINC00LvRjyDRgNC10LTQsNCz0YPQstCw0L3QvdGPLlwiLGVkaXRFZGdlOlwi0KDQtdC00LDQs9GD0LLQsNGC0Lgg0LrRgNCw0LlcIixlZGl0RWRnZURlc2NyaXB0aW9uOlwi0JrQu9GW0LrQvdGW0YLRjCDQvdCwINC60L7QvdGC0YDQvtC70YzQvdGWINGC0L7Rh9C60Lgg0ZYg0L/QtdGA0LXRgtGP0LPQvdGW0YLRjCDRl9GFINGDINCy0YPQt9C+0LssINGJ0L7QsSDQv9GW0LTQutC70Y7Rh9C40YLQuNGB0Y8g0LTQviDQvdGM0L7Qs9C+LlwiLGVkaXROb2RlOlwi0KDQtdC00LDQs9GD0LLQsNGC0Lgg0LLRg9C30L7Qu1wifSxmcjp7YWRkRGVzY3JpcHRpb246XCJDbGlxdWV6IGRhbnMgdW4gZW5kcm9pdCB2aWRlIHBvdXIgcGxhY2VyIHVuIG7Fk3VkLlwiLGFkZEVkZ2U6XCJBam91dGVyIHVuIGxpZW5cIixhZGROb2RlOlwiQWpvdXRlciB1biBuxZN1ZFwiLGJhY2s6XCJSZXRvdXJcIixjbG9zZTpcIkZlcm1lclwiLGNyZWF0ZUVkZ2VFcnJvcjpcIkltcG9zc2libGUgZGUgY3LDqWVyIHVuIGxpZW4gdmVycyB1biBjbHVzdGVyLlwiLGRlbDpcIkVmZmFjZXIgbGEgc8OpbGVjdGlvblwiLGRlbGV0ZUNsdXN0ZXJFcnJvcjpcIkxlcyBjbHVzdGVycyBuZSBwZXV2ZW50IHBhcyDDqnRyZSBlZmZhY8Opcy5cIixlZGdlRGVzY3JpcHRpb246XCJDbGlxdWV6IHN1ciB1biBuxZN1ZCBldCBnbGlzc2V6IGxlIGxpZW4gdmVycyB1biBhdXRyZSBuxZN1ZCBwb3VyIGxlcyBjb25uZWN0ZXIuXCIsZWRpdDpcIsOJZGl0ZXJcIixlZGl0Q2x1c3RlckVycm9yOlwiTGVzIGNsdXN0ZXJzIG5lIHBldXZlbnQgcGFzIMOqdHJlIMOpZGl0w6lzLlwiLGVkaXRFZGdlOlwiw4lkaXRlciBsZSBsaWVuXCIsZWRpdEVkZ2VEZXNjcmlwdGlvbjpcIkNsaXF1ZXogc3VyIGxlcyBwb2ludHMgZGUgY29udHLDtGxlIGV0IGdsaXNzZXotbGVzIHBvdXIgY29ubmVjdGVyIHVuIG7Fk3VkLlwiLGVkaXROb2RlOlwiw4lkaXRlciBsZSBuxZN1ZFwifSxjczp7YWRkRGVzY3JpcHRpb246XCJLbHVrbnV0w61tIGRvIHByw6F6ZG7DqWhvIHByb3N0b3J1IG3Fr8W+ZXRlIHDFmWlkYXQgbm92w70gdnJjaG9sLlwiLGFkZEVkZ2U6XCJQxZlpZGF0IGhyYW51XCIsYWRkTm9kZTpcIlDFmWlkYXQgdnJjaG9sXCIsYmFjazpcIlpwxJt0XCIsY2xvc2U6XCJaYXbFmcOtdFwiLGNyZWF0ZUVkZ2VFcnJvcjpcIk5lbHplIHDFmWlwb2ppdCBocmFudSBrZSBzaGx1a3UuXCIsZGVsOlwiU21hemF0IHbDvWLEm3JcIixkZWxldGVDbHVzdGVyRXJyb3I6XCJOZWx6ZSBtYXphdCBzaGx1a3kuXCIsZWRnZURlc2NyaXB0aW9uOlwiUMWZZXRhxb5lbsOtbSB6IGplZG5vaG8gdnJjaG9sdSBkbyBkcnVow6lobyBtxa/FvmV0ZSBzcG9qaXQgdHl0byB2cmNob2x5IG5vdm91IGhyYW5vdS5cIixlZGl0OlwiVXByYXZpdFwiLGVkaXRDbHVzdGVyRXJyb3I6XCJOZWx6ZSB1cHJhdm92YXQgc2hsdWt5LlwiLGVkaXRFZGdlOlwiVXByYXZpdCBocmFudVwiLGVkaXRFZGdlRGVzY3JpcHRpb246XCJQxZlldGHFvmVuw61tIGtvbnRyb2xuw61obyB2cmNob2x1IGhyYW55IGppIG3Fr8W+ZXRlIHDFmWlwb2ppdCBrIGppbsOpbXUgdnJjaG9sdS5cIixlZGl0Tm9kZTpcIlVwcmF2aXQgdnJjaG9sXCJ9fSk7dmFyIGZkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCksdGhpcy5OVU1fSVRFUkFUSU9OUz00LHRoaXMuaW1hZ2U9bmV3IEltYWdlLHRoaXMuY2FudmFzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIil9cmV0dXJuIElvKHQsW3trZXk6XCJpbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXtpZighdGhpcy5pbml0aWFsaXplZCgpKXt0aGlzLnNyYz10aGlzLmltYWdlLnNyYzt2YXIgdD10aGlzLmltYWdlLndpZHRoLGU9dGhpcy5pbWFnZS5oZWlnaHQ7dGhpcy53aWR0aD10LHRoaXMuaGVpZ2h0PWU7dmFyIGk9TWF0aC5mbG9vcihlLzIpLG89TWF0aC5mbG9vcihlLzQpLG49TWF0aC5mbG9vcihlLzgpLHI9TWF0aC5mbG9vcihlLzE2KSxzPU1hdGguZmxvb3IodC8yKSxhPU1hdGguZmxvb3IodC80KSxoPU1hdGguZmxvb3IodC84KSxkPU1hdGguZmxvb3IodC8xNik7dGhpcy5jYW52YXMud2lkdGg9MyphLHRoaXMuY2FudmFzLmhlaWdodD1pLHRoaXMuY29vcmRpbmF0ZXM9W1swLDAscyxpXSxbcywwLGEsb10sW3MsbyxoLG5dLFs1KmgsbyxkLHJdXSx0aGlzLl9maWxsTWlwTWFwKCl9fX0se2tleTpcImluaXRpYWxpemVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5jb29yZGluYXRlc319LHtrZXk6XCJfZmlsbE1pcE1hcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLGU9dGhpcy5jb29yZGluYXRlc1swXTt0LmRyYXdJbWFnZSh0aGlzLmltYWdlLGVbMF0sZVsxXSxlWzJdLGVbM10pO2Zvcih2YXIgaT0xO2k8dGhpcy5OVU1fSVRFUkFUSU9OUztpKyspe3ZhciBvPXRoaXMuY29vcmRpbmF0ZXNbaS0xXSxuPXRoaXMuY29vcmRpbmF0ZXNbaV07dC5kcmF3SW1hZ2UodGhpcy5jYW52YXMsb1swXSxvWzFdLG9bMl0sb1szXSxuWzBdLG5bMV0sblsyXSxuWzNdKX19fSx7a2V5OlwiZHJhd0ltYWdlQXRQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXtpZih0aGlzLmluaXRpYWxpemVkKCkpaWYoZT4yKXtlKj0uNTtmb3IodmFyIHM9MDtlPjImJnM8dGhpcy5OVU1fSVRFUkFUSU9OUzspZSo9LjUscys9MTtzPj10aGlzLk5VTV9JVEVSQVRJT05TJiYocz10aGlzLk5VTV9JVEVSQVRJT05TLTEpO3ZhciBhPXRoaXMuY29vcmRpbmF0ZXNbc107dC5kcmF3SW1hZ2UodGhpcy5jYW52YXMsYVswXSxhWzFdLGFbMl0sYVszXSxpLG8sbixyKX1lbHNlIHQuZHJhd0ltYWdlKHRoaXMuaW1hZ2UsaSxvLG4scil9fV0pLHR9KCkscGQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe1BvKHRoaXMsdCksdGhpcy5pbWFnZXM9e30sdGhpcy5pbWFnZUJyb2tlbj17fSx0aGlzLmNhbGxiYWNrPWV9cmV0dXJuIElvKHQsW3trZXk6XCJfdHJ5bG9hZEJyb2tlblVybFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2b2lkIDAhPT10JiZ2b2lkIDAhPT1pJiYodm9pZCAwIT09ZT8oaS5pbWFnZS5vbmVycm9yPWZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBsb2FkIGJyb2tlbkltYWdlOlwiLGUpfSxpLmltYWdlLnNyYz1lKTpjb25zb2xlLndhcm4oXCJObyBicm9rZW4gdXJsIGltYWdlIGRlZmluZWRcIikpfX0se2tleTpcIl9yZWRyYXdXaXRoSW1hZ2VcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmNhbGxiYWNrJiZ0aGlzLmNhbGxiYWNrKHQpfX0se2tleTpcImxvYWRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMsbz10aGlzLmltYWdlc1t0XTtpZihvKXJldHVybiBvO3ZhciBuPW5ldyBmZDtyZXR1cm4gdGhpcy5pbWFnZXNbdF09bixuLmltYWdlLm9ubG9hZD1mdW5jdGlvbigpe2kuX2ZpeEltYWdlQ29vcmRpbmF0ZXMobi5pbWFnZSksbi5pbml0KCksaS5fcmVkcmF3V2l0aEltYWdlKG4pfSxuLmltYWdlLm9uZXJyb3I9ZnVuY3Rpb24oKXtjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IGxvYWQgaW1hZ2U6XCIsdCksaS5fdHJ5bG9hZEJyb2tlblVybCh0LGUsbil9LG4uaW1hZ2Uuc3JjPXQsbn19LHtrZXk6XCJfZml4SW1hZ2VDb29yZGluYXRlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpezA9PT10LndpZHRoJiYoZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0KSx0LndpZHRoPXQub2Zmc2V0V2lkdGgsdC5oZWlnaHQ9dC5vZmZzZXRIZWlnaHQsZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0KSl9fV0pLHR9KCksdmQ9IXMoKGZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSl9KSksZ2Q9bygoZnVuY3Rpb24odCl7dmFyIGU9TC5mLGk9SHQoXCJtZXRhXCIpLG89MCxuPU9iamVjdC5pc0V4dGVuc2libGV8fGZ1bmN0aW9uKCl7cmV0dXJuITB9LHI9ZnVuY3Rpb24odCl7ZSh0LGkse3ZhbHVlOntvYmplY3RJRDpcIk9cIisgKytvLHdlYWtEYXRhOnt9fX0pfSxzPXQuZXhwb3J0cz17UkVRVUlSRUQ6ITEsZmFzdEtleTpmdW5jdGlvbih0LGUpe2lmKCFtKHQpKXJldHVyblwic3ltYm9sXCI9PXR5cGVvZiB0P3Q6KFwic3RyaW5nXCI9PXR5cGVvZiB0P1wiU1wiOlwiUFwiKSt0O2lmKCFrKHQsaSkpe2lmKCFuKHQpKXJldHVyblwiRlwiO2lmKCFlKXJldHVyblwiRVwiO3IodCl9cmV0dXJuIHRbaV0ub2JqZWN0SUR9LGdldFdlYWtEYXRhOmZ1bmN0aW9uKHQsZSl7aWYoIWsodCxpKSl7aWYoIW4odCkpcmV0dXJuITA7aWYoIWUpcmV0dXJuITE7cih0KX1yZXR1cm4gdFtpXS53ZWFrRGF0YX0sb25GcmVlemU6ZnVuY3Rpb24odCl7cmV0dXJuIHZkJiZzLlJFUVVJUkVEJiZuKHQpJiYhayh0LGkpJiZyKHQpLHR9fTtldFtpXT0hMH0pKSx5ZD1mdW5jdGlvbih0LGUpe3RoaXMuc3RvcHBlZD10LHRoaXMucmVzdWx0PWV9LG1kPWZ1bmN0aW9uKHQsZSxpKXt2YXIgbyxuLHIscyxhLGgsZCxsPWkmJmkudGhhdCxjPSEoIWl8fCFpLkFTX0VOVFJJRVMpLHU9ISghaXx8IWkuSVNfSVRFUkFUT1IpLGY9ISghaXx8IWkuSU5URVJSVVBURUQpLHA9QShlLGwsMStjK2YpLHY9ZnVuY3Rpb24odCl7cmV0dXJuIG8mJm5pKG8pLG5ldyB5ZCghMCx0KX0sZz1mdW5jdGlvbih0KXtyZXR1cm4gYz8oUih0KSxmP3AodFswXSx0WzFdLHYpOnAodFswXSx0WzFdKSk6Zj9wKHQsdik6cCh0KX07aWYodSlvPXQ7ZWxzZXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZihuPWNpKHQpKSl0aHJvdyBUeXBlRXJyb3IoXCJUYXJnZXQgaXMgbm90IGl0ZXJhYmxlXCIpO2lmKGhpKG4pKXtmb3Iocj0wLHM9Syh0Lmxlbmd0aCk7cz5yO3IrKylpZigoYT1nKHRbcl0pKSYmYSBpbnN0YW5jZW9mIHlkKXJldHVybiBhO3JldHVybiBuZXcgeWQoITEpfW89bi5jYWxsKHQpfWZvcihoPW8ubmV4dDshKGQ9aC5jYWxsKG8pKS5kb25lOyl7dHJ5e2E9ZyhkLnZhbHVlKX1jYXRjaCh0KXt0aHJvdyBuaShvKSx0fWlmKFwib2JqZWN0XCI9PXR5cGVvZiBhJiZhJiZhIGluc3RhbmNlb2YgeWQpcmV0dXJuIGF9cmV0dXJuIG5ldyB5ZCghMSl9LGJkPWZ1bmN0aW9uKHQsZSxpKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBUeXBlRXJyb3IoXCJJbmNvcnJlY3QgXCIrKGk/aStcIiBcIjpcIlwiKStcImludm9jYXRpb25cIik7cmV0dXJuIHR9LHdkPUwuZixrZD1XaS5mb3JFYWNoLF9kPVp0LnNldCx4ZD1adC5nZXR0ZXJGb3IsRWQ9ZnVuY3Rpb24odCxlLGkpe3ZhciBvLG49LTEhPT10LmluZGV4T2YoXCJNYXBcIiksaD0tMSE9PXQuaW5kZXhPZihcIldlYWtcIiksZD1uP1wic2V0XCI6XCJhZGRcIixsPXJbdF0sYz1sJiZsLnByb3RvdHlwZSx1PXt9O2lmKGEmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGwmJihofHxjLmZvckVhY2gmJiFzKChmdW5jdGlvbigpeyhuZXcgbCkuZW50cmllcygpLm5leHQoKX0pKSkpe289ZSgoZnVuY3Rpb24oZSxpKXtfZChiZChlLG8sdCkse3R5cGU6dCxjb2xsZWN0aW9uOm5ldyBsfSksbnVsbCE9aSYmbWQoaSxlW2RdLHt0aGF0OmUsQVNfRU5UUklFUzpufSl9KSk7dmFyIGY9eGQodCk7a2QoW1wiYWRkXCIsXCJjbGVhclwiLFwiZGVsZXRlXCIsXCJmb3JFYWNoXCIsXCJnZXRcIixcImhhc1wiLFwic2V0XCIsXCJrZXlzXCIsXCJ2YWx1ZXNcIixcImVudHJpZXNcIl0sKGZ1bmN0aW9uKHQpe3ZhciBlPVwiYWRkXCI9PXR8fFwic2V0XCI9PXQ7ISh0IGluIGMpfHxoJiZcImNsZWFyXCI9PXR8fEgoby5wcm90b3R5cGUsdCwoZnVuY3Rpb24oaSxvKXt2YXIgbj1mKHRoaXMpLmNvbGxlY3Rpb247aWYoIWUmJmgmJiFtKGkpKXJldHVyblwiZ2V0XCI9PXQmJnZvaWQgMDt2YXIgcj1uW3RdKDA9PT1pPzA6aSxvKTtyZXR1cm4gZT90aGlzOnJ9KSl9KSksaHx8d2Qoby5wcm90b3R5cGUsXCJzaXplXCIse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZih0aGlzKS5jb2xsZWN0aW9uLnNpemV9fSl9ZWxzZSBvPWkuZ2V0Q29uc3RydWN0b3IoZSx0LG4sZCksZ2QuUkVRVUlSRUQ9ITA7cmV0dXJuIExlKG8sdCwhMSwhMCksdVt0XT1vLHEoe2dsb2JhbDohMCxmb3JjZWQ6ITB9LHUpLGh8fGkuc2V0U3Ryb25nKG8sdCxuKSxvfSxPZD1mdW5jdGlvbih0LGUsaSl7Zm9yKHZhciBvIGluIGUpaSYmaS51bnNhZmUmJnRbb10/dFtvXT1lW29dOlVlKHQsbyxlW29dLGkpO3JldHVybiB0fSxDZD1iZShcInNwZWNpZXNcIiksU2Q9TC5mLFRkPWdkLmZhc3RLZXksTWQ9WnQuc2V0LFBkPVp0LmdldHRlckZvcixEZD17Z2V0Q29uc3RydWN0b3I6ZnVuY3Rpb24odCxlLGksbyl7dmFyIG49dCgoZnVuY3Rpb24odCxyKXtiZCh0LG4sZSksTWQodCx7dHlwZTplLGluZGV4OkRlKG51bGwpLGZpcnN0OnZvaWQgMCxsYXN0OnZvaWQgMCxzaXplOjB9KSxhfHwodC5zaXplPTApLG51bGwhPXImJm1kKHIsdFtvXSx7dGhhdDp0LEFTX0VOVFJJRVM6aX0pfSkpLHI9UGQoZSkscz1mdW5jdGlvbih0LGUsaSl7dmFyIG8sbixzPXIodCksZD1oKHQsZSk7cmV0dXJuIGQ/ZC52YWx1ZT1pOihzLmxhc3Q9ZD17aW5kZXg6bj1UZChlLCEwKSxrZXk6ZSx2YWx1ZTppLHByZXZpb3VzOm89cy5sYXN0LG5leHQ6dm9pZCAwLHJlbW92ZWQ6ITF9LHMuZmlyc3R8fChzLmZpcnN0PWQpLG8mJihvLm5leHQ9ZCksYT9zLnNpemUrKzp0LnNpemUrKyxcIkZcIiE9PW4mJihzLmluZGV4W25dPWQpKSx0fSxoPWZ1bmN0aW9uKHQsZSl7dmFyIGksbz1yKHQpLG49VGQoZSk7aWYoXCJGXCIhPT1uKXJldHVybiBvLmluZGV4W25dO2ZvcihpPW8uZmlyc3Q7aTtpPWkubmV4dClpZihpLmtleT09ZSlyZXR1cm4gaX07cmV0dXJuIE9kKG4ucHJvdG90eXBlLHtjbGVhcjpmdW5jdGlvbigpe2Zvcih2YXIgdD1yKHRoaXMpLGU9dC5pbmRleCxpPXQuZmlyc3Q7aTspaS5yZW1vdmVkPSEwLGkucHJldmlvdXMmJihpLnByZXZpb3VzPWkucHJldmlvdXMubmV4dD12b2lkIDApLGRlbGV0ZSBlW2kuaW5kZXhdLGk9aS5uZXh0O3QuZmlyc3Q9dC5sYXN0PXZvaWQgMCxhP3Quc2l6ZT0wOnRoaXMuc2l6ZT0wfSxkZWxldGU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxpPXIoZSksbz1oKGUsdCk7aWYobyl7dmFyIG49by5uZXh0LHM9by5wcmV2aW91cztkZWxldGUgaS5pbmRleFtvLmluZGV4XSxvLnJlbW92ZWQ9ITAscyYmKHMubmV4dD1uKSxuJiYobi5wcmV2aW91cz1zKSxpLmZpcnN0PT1vJiYoaS5maXJzdD1uKSxpLmxhc3Q9PW8mJihpLmxhc3Q9cyksYT9pLnNpemUtLTplLnNpemUtLX1yZXR1cm4hIW99LGZvckVhY2g6ZnVuY3Rpb24odCl7Zm9yKHZhciBlLGk9cih0aGlzKSxvPUEodCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCwzKTtlPWU/ZS5uZXh0OmkuZmlyc3Q7KWZvcihvKGUudmFsdWUsZS5rZXksdGhpcyk7ZSYmZS5yZW1vdmVkOyllPWUucHJldmlvdXN9LGhhczpmdW5jdGlvbih0KXtyZXR1cm4hIWgodGhpcyx0KX19KSxPZChuLnByb3RvdHlwZSxpP3tnZXQ6ZnVuY3Rpb24odCl7dmFyIGU9aCh0aGlzLHQpO3JldHVybiBlJiZlLnZhbHVlfSxzZXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gcyh0aGlzLDA9PT10PzA6dCxlKX19OnthZGQ6ZnVuY3Rpb24odCl7cmV0dXJuIHModGhpcyx0PTA9PT10PzA6dCx0KX19KSxhJiZTZChuLnByb3RvdHlwZSxcInNpemVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcykuc2l6ZX19KSxufSxzZXRTdHJvbmc6ZnVuY3Rpb24odCxlLGkpe3ZhciBvPWUrXCIgSXRlcmF0b3JcIixuPVBkKGUpLHI9UGQobyk7SmUodCxlLChmdW5jdGlvbih0LGUpe01kKHRoaXMse3R5cGU6byx0YXJnZXQ6dCxzdGF0ZTpuKHQpLGtpbmQ6ZSxsYXN0OnZvaWQgMH0pfSksKGZ1bmN0aW9uKCl7Zm9yKHZhciB0PXIodGhpcyksZT10LmtpbmQsaT10Lmxhc3Q7aSYmaS5yZW1vdmVkOylpPWkucHJldmlvdXM7cmV0dXJuIHQudGFyZ2V0JiYodC5sYXN0PWk9aT9pLm5leHQ6dC5zdGF0ZS5maXJzdCk/XCJrZXlzXCI9PWU/e3ZhbHVlOmkua2V5LGRvbmU6ITF9OlwidmFsdWVzXCI9PWU/e3ZhbHVlOmkudmFsdWUsZG9uZTohMX06e3ZhbHVlOltpLmtleSxpLnZhbHVlXSxkb25lOiExfToodC50YXJnZXQ9dm9pZCAwLHt2YWx1ZTp2b2lkIDAsZG9uZTohMH0pfSksaT9cImVudHJpZXNcIjpcInZhbHVlc1wiLCFpLCEwKSxmdW5jdGlvbih0KXt2YXIgZT1yZSh0KSxpPUwuZjthJiZlJiYhZVtDZF0mJmkoZSxDZCx7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzfX0pfShlKX19O0VkKFwiTWFwXCIsKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0KHRoaXMsYXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMF06dm9pZCAwKX19KSxEZCk7dmFyIEJkPUYuTWFwLElkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCksdGhpcy5jbGVhcigpLHRoaXMuX2RlZmF1bHRJbmRleD0wLHRoaXMuX2dyb3VwSW5kZXg9MCx0aGlzLl9kZWZhdWx0R3JvdXBzPVt7Ym9yZGVyOlwiIzJCN0NFOVwiLGJhY2tncm91bmQ6XCIjOTdDMkZDXCIsaGlnaGxpZ2h0Ontib3JkZXI6XCIjMkI3Q0U5XCIsYmFja2dyb3VuZDpcIiNEMkU1RkZcIn0saG92ZXI6e2JvcmRlcjpcIiMyQjdDRTlcIixiYWNrZ3JvdW5kOlwiI0QyRTVGRlwifX0se2JvcmRlcjpcIiNGRkE1MDBcIixiYWNrZ3JvdW5kOlwiI0ZGRkYwMFwiLGhpZ2hsaWdodDp7Ym9yZGVyOlwiI0ZGQTUwMFwiLGJhY2tncm91bmQ6XCIjRkZGRkEzXCJ9LGhvdmVyOntib3JkZXI6XCIjRkZBNTAwXCIsYmFja2dyb3VuZDpcIiNGRkZGQTNcIn19LHtib3JkZXI6XCIjRkEwQTEwXCIsYmFja2dyb3VuZDpcIiNGQjdFODFcIixoaWdobGlnaHQ6e2JvcmRlcjpcIiNGQTBBMTBcIixiYWNrZ3JvdW5kOlwiI0ZGQUZCMVwifSxob3Zlcjp7Ym9yZGVyOlwiI0ZBMEExMFwiLGJhY2tncm91bmQ6XCIjRkZBRkIxXCJ9fSx7Ym9yZGVyOlwiIzQxQTkwNlwiLGJhY2tncm91bmQ6XCIjN0JFMTQxXCIsaGlnaGxpZ2h0Ontib3JkZXI6XCIjNDFBOTA2XCIsYmFja2dyb3VuZDpcIiNBMUVDNzZcIn0saG92ZXI6e2JvcmRlcjpcIiM0MUE5MDZcIixiYWNrZ3JvdW5kOlwiI0ExRUM3NlwifX0se2JvcmRlcjpcIiNFMTI5RjBcIixiYWNrZ3JvdW5kOlwiI0VCN0RGNFwiLGhpZ2hsaWdodDp7Ym9yZGVyOlwiI0UxMjlGMFwiLGJhY2tncm91bmQ6XCIjRjBCM0Y1XCJ9LGhvdmVyOntib3JkZXI6XCIjRTEyOUYwXCIsYmFja2dyb3VuZDpcIiNGMEIzRjVcIn19LHtib3JkZXI6XCIjN0MyOUYwXCIsYmFja2dyb3VuZDpcIiNBRDg1RTRcIixoaWdobGlnaHQ6e2JvcmRlcjpcIiM3QzI5RjBcIixiYWNrZ3JvdW5kOlwiI0QzQkRGMFwifSxob3Zlcjp7Ym9yZGVyOlwiIzdDMjlGMFwiLGJhY2tncm91bmQ6XCIjRDNCREYwXCJ9fSx7Ym9yZGVyOlwiI0MzN0YwMFwiLGJhY2tncm91bmQ6XCIjRkZBODA3XCIsaGlnaGxpZ2h0Ontib3JkZXI6XCIjQzM3RjAwXCIsYmFja2dyb3VuZDpcIiNGRkNBNjZcIn0saG92ZXI6e2JvcmRlcjpcIiNDMzdGMDBcIixiYWNrZ3JvdW5kOlwiI0ZGQ0E2NlwifX0se2JvcmRlcjpcIiM0MjIwRkJcIixiYWNrZ3JvdW5kOlwiIzZFNkVGRFwiLGhpZ2hsaWdodDp7Ym9yZGVyOlwiIzQyMjBGQlwiLGJhY2tncm91bmQ6XCIjOUI5QkZEXCJ9LGhvdmVyOntib3JkZXI6XCIjNDIyMEZCXCIsYmFja2dyb3VuZDpcIiM5QjlCRkRcIn19LHtib3JkZXI6XCIjRkQ1QTc3XCIsYmFja2dyb3VuZDpcIiNGRkMwQ0JcIixoaWdobGlnaHQ6e2JvcmRlcjpcIiNGRDVBNzdcIixiYWNrZ3JvdW5kOlwiI0ZGRDFEOVwifSxob3Zlcjp7Ym9yZGVyOlwiI0ZENUE3N1wiLGJhY2tncm91bmQ6XCIjRkZEMUQ5XCJ9fSx7Ym9yZGVyOlwiIzRBRDYzQVwiLGJhY2tncm91bmQ6XCIjQzJGQUJDXCIsaGlnaGxpZ2h0Ontib3JkZXI6XCIjNEFENjNBXCIsYmFja2dyb3VuZDpcIiNFNkZGRTNcIn0saG92ZXI6e2JvcmRlcjpcIiM0QUQ2M0FcIixiYWNrZ3JvdW5kOlwiI0U2RkZFM1wifX0se2JvcmRlcjpcIiM5OTAwMDBcIixiYWNrZ3JvdW5kOlwiI0VFMDAwMFwiLGhpZ2hsaWdodDp7Ym9yZGVyOlwiI0JCMDAwMFwiLGJhY2tncm91bmQ6XCIjRkYzMzMzXCJ9LGhvdmVyOntib3JkZXI6XCIjQkIwMDAwXCIsYmFja2dyb3VuZDpcIiNGRjMzMzNcIn19LHtib3JkZXI6XCIjRkY2MDAwXCIsYmFja2dyb3VuZDpcIiNGRjYwMDBcIixoaWdobGlnaHQ6e2JvcmRlcjpcIiNGRjYwMDBcIixiYWNrZ3JvdW5kOlwiI0ZGNjAwMFwifSxob3Zlcjp7Ym9yZGVyOlwiI0ZGNjAwMFwiLGJhY2tncm91bmQ6XCIjRkY2MDAwXCJ9fSx7Ym9yZGVyOlwiIzk3QzJGQ1wiLGJhY2tncm91bmQ6XCIjMkI3Q0U5XCIsaGlnaGxpZ2h0Ontib3JkZXI6XCIjRDJFNUZGXCIsYmFja2dyb3VuZDpcIiMyQjdDRTlcIn0saG92ZXI6e2JvcmRlcjpcIiNEMkU1RkZcIixiYWNrZ3JvdW5kOlwiIzJCN0NFOVwifX0se2JvcmRlcjpcIiMzOTk2MDVcIixiYWNrZ3JvdW5kOlwiIzI1NUMwM1wiLGhpZ2hsaWdodDp7Ym9yZGVyOlwiIzM5OTYwNVwiLGJhY2tncm91bmQ6XCIjMjU1QzAzXCJ9LGhvdmVyOntib3JkZXI6XCIjMzk5NjA1XCIsYmFja2dyb3VuZDpcIiMyNTVDMDNcIn19LHtib3JkZXI6XCIjQjcwMDU0XCIsYmFja2dyb3VuZDpcIiNGRjAwN0VcIixoaWdobGlnaHQ6e2JvcmRlcjpcIiNCNzAwNTRcIixiYWNrZ3JvdW5kOlwiI0ZGMDA3RVwifSxob3Zlcjp7Ym9yZGVyOlwiI0I3MDA1NFwiLGJhY2tncm91bmQ6XCIjRkYwMDdFXCJ9fSx7Ym9yZGVyOlwiI0FEODVFNFwiLGJhY2tncm91bmQ6XCIjN0MyOUYwXCIsaGlnaGxpZ2h0Ontib3JkZXI6XCIjRDNCREYwXCIsYmFja2dyb3VuZDpcIiM3QzI5RjBcIn0saG92ZXI6e2JvcmRlcjpcIiNEM0JERjBcIixiYWNrZ3JvdW5kOlwiIzdDMjlGMFwifX0se2JvcmRlcjpcIiM0NTU3RkFcIixiYWNrZ3JvdW5kOlwiIzAwMEVBMVwiLGhpZ2hsaWdodDp7Ym9yZGVyOlwiIzZFNkVGRFwiLGJhY2tncm91bmQ6XCIjMDAwRUExXCJ9LGhvdmVyOntib3JkZXI6XCIjNkU2RUZEXCIsYmFja2dyb3VuZDpcIiMwMDBFQTFcIn19LHtib3JkZXI6XCIjRkZDMENCXCIsYmFja2dyb3VuZDpcIiNGRDVBNzdcIixoaWdobGlnaHQ6e2JvcmRlcjpcIiNGRkQxRDlcIixiYWNrZ3JvdW5kOlwiI0ZENUE3N1wifSxob3Zlcjp7Ym9yZGVyOlwiI0ZGRDFEOVwiLGJhY2tncm91bmQ6XCIjRkQ1QTc3XCJ9fSx7Ym9yZGVyOlwiI0MyRkFCQ1wiLGJhY2tncm91bmQ6XCIjNzRENjZBXCIsaGlnaGxpZ2h0Ontib3JkZXI6XCIjRTZGRkUzXCIsYmFja2dyb3VuZDpcIiM3NEQ2NkFcIn0saG92ZXI6e2JvcmRlcjpcIiNFNkZGRTNcIixiYWNrZ3JvdW5kOlwiIzc0RDY2QVwifX0se2JvcmRlcjpcIiNFRTAwMDBcIixiYWNrZ3JvdW5kOlwiIzk5MDAwMFwiLGhpZ2hsaWdodDp7Ym9yZGVyOlwiI0ZGMzMzM1wiLGJhY2tncm91bmQ6XCIjQkIwMDAwXCJ9LGhvdmVyOntib3JkZXI6XCIjRkYzMzMzXCIsYmFja2dyb3VuZDpcIiNCQjAwMDBcIn19XSx0aGlzLm9wdGlvbnM9e30sdGhpcy5kZWZhdWx0T3B0aW9ucz17dXNlRGVmYXVsdEdyb3VwczohMH0sY3QodGhpcy5vcHRpb25zLHRoaXMuZGVmYXVsdE9wdGlvbnMpfXJldHVybiBJbyh0LFt7a2V5Olwic2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPVtcInVzZURlZmF1bHRHcm91cHNcIl07aWYodm9pZCAwIT09dClmb3IodmFyIGkgaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxpKSYmLTE9PT1NcihlKS5jYWxsKGUsaSkpe3ZhciBvPXRbaV07dGhpcy5hZGQoaSxvKX19fSx7a2V5OlwiY2xlYXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2dyb3Vwcz1uZXcgQmQsdGhpcy5fZ3JvdXBOYW1lcz1bXX19LHtrZXk6XCJnZXRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT0hKGFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdKXx8YXJndW1lbnRzWzFdLGk9dGhpcy5fZ3JvdXBzLmdldCh0KTtpZih2b2lkIDA9PT1pJiZlKWlmKCExPT09dGhpcy5vcHRpb25zLnVzZURlZmF1bHRHcm91cHMmJnRoaXMuX2dyb3VwTmFtZXMubGVuZ3RoPjApe3ZhciBvPXRoaXMuX2dyb3VwSW5kZXgldGhpcy5fZ3JvdXBOYW1lcy5sZW5ndGg7Kyt0aGlzLl9ncm91cEluZGV4LChpPXt9KS5jb2xvcj10aGlzLl9ncm91cHMuZ2V0KHRoaXMuX2dyb3VwTmFtZXNbb10pLHRoaXMuX2dyb3Vwcy5zZXQodCxpKX1lbHNle3ZhciBuPXRoaXMuX2RlZmF1bHRJbmRleCV0aGlzLl9kZWZhdWx0R3JvdXBzLmxlbmd0aDt0aGlzLl9kZWZhdWx0SW5kZXgrKywoaT17fSkuY29sb3I9dGhpcy5fZGVmYXVsdEdyb3Vwc1tuXSx0aGlzLl9ncm91cHMuc2V0KHQsaSl9cmV0dXJuIGl9fSx7a2V5OlwiYWRkXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZ3JvdXBzLmhhcyh0KXx8dGhpcy5fZ3JvdXBOYW1lcy5wdXNoKHQpLHRoaXMuX2dyb3Vwcy5zZXQodCxlKSxlfX1dKSx0fSgpO3Eoe3RhcmdldDpcIk51bWJlclwiLHN0YXQ6ITB9LHtpc05hTjpmdW5jdGlvbih0KXtyZXR1cm4gdCE9dH19KTt2YXIgemQ9Ri5OdW1iZXIuaXNOYU4sRmQ9ci5pc0Zpbml0ZSxOZD1OdW1iZXIuaXNGaW5pdGV8fGZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZGZCh0KX07cSh7dGFyZ2V0OlwiTnVtYmVyXCIsc3RhdDohMH0se2lzRmluaXRlOk5kfSk7dmFyIEFkPUYuTnVtYmVyLmlzRmluaXRlLFJkPVdpLnNvbWUsamQ9T24oXCJzb21lXCIpO3Eoe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOiFqZH0se3NvbWU6ZnVuY3Rpb24odCl7cmV0dXJuIFJkKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSk7dmFyIExkPWd0KFwiQXJyYXlcIikuc29tZSxIZD1BcnJheS5wcm90b3R5cGUsV2Q9ZnVuY3Rpb24odCl7dmFyIGU9dC5zb21lO3JldHVybiB0PT09SGR8fHQgaW5zdGFuY2VvZiBBcnJheSYmZT09PUhkLnNvbWU/TGQ6ZX0sVmQ9Z3IudHJpbSxxZD1yLnBhcnNlRmxvYXQsVWQ9MS9xZChjcitcIi0wXCIpIT0tMS8wP2Z1bmN0aW9uKHQpe3ZhciBlPVZkKFN0cmluZyh0KSksaT1xZChlKTtyZXR1cm4gMD09PWkmJlwiLVwiPT1lLmNoYXJBdCgwKT8tMDppfTpxZDtxKHtnbG9iYWw6ITAsZm9yY2VkOnBhcnNlRmxvYXQhPVVkfSx7cGFyc2VGbG9hdDpVZH0pO3ZhciBZZD1GLnBhcnNlRmxvYXQsWGQ9emkuZixHZD1zKChmdW5jdGlvbigpe3JldHVybiFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygxKX0pKTtxKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDpHZH0se2dldE93blByb3BlcnR5TmFtZXM6WGR9KTt2YXIgS2Q9Ri5PYmplY3QsJGQ9ZnVuY3Rpb24odCl7cmV0dXJuIEtkLmdldE93blByb3BlcnR5TmFtZXModCl9O2Z1bmN0aW9uIFFkKHQsZSl7dmFyIGk9W1wibm9kZVwiLFwiZWRnZVwiLFwibGFiZWxcIl0sbz0hMCxuPW1oKGUsXCJjaG9zZW5cIik7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBuKW89bjtlbHNlIGlmKFwib2JqZWN0XCI9PT1kbihuKSl7aWYoLTE9PT1NcihpKS5jYWxsKGksdCkpdGhyb3cgbmV3IEVycm9yKFwiY2hvb3NpZnk6IHN1Yk9wdGlvbiAnXCIrdCtcIicgc2hvdWxkIGJlIG9uZSBvZiAnXCIraS5qb2luKFwiJywgJ1wiKStcIidcIik7dmFyIHI9bWgoZSxbXCJjaG9zZW5cIix0XSk7XCJib29sZWFuXCIhPXR5cGVvZiByJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiByfHwobz1yKX1yZXR1cm4gb31mdW5jdGlvbiBaZCh0LGUsaSl7aWYodC53aWR0aDw9MHx8dC5oZWlnaHQ8PTApcmV0dXJuITE7aWYodm9pZCAwIT09aSl7dmFyIG89e3g6ZS54LWkueCx5OmUueS1pLnl9O2lmKDAhPT1pLmFuZ2xlKXt2YXIgbj0taS5hbmdsZTtlPXt4Ok1hdGguY29zKG4pKm8ueC1NYXRoLnNpbihuKSpvLnkseTpNYXRoLnNpbihuKSpvLngrTWF0aC5jb3Mobikqby55fX1lbHNlIGU9b312YXIgcj10LngrdC53aWR0aCxzPXQueSt0LndpZHRoO3JldHVybiB0LmxlZnQ8ZS54JiZyPmUueCYmdC50b3A8ZS55JiZzPmUueX1mdW5jdGlvbiBKZCh0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdCYmXCJcIiE9PXR9ZnVuY3Rpb24gdGwodCxlLGksbyl7dmFyIG49by54LHI9by55O2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG8uZGlzdGFuY2VUb0JvcmRlcil7dmFyIHM9by5kaXN0YW5jZVRvQm9yZGVyKHQsZSksYT1NYXRoLnNpbihlKSpzLGg9TWF0aC5jb3MoZSkqcztoPT09cz8obis9cyxyPW8ueSk6YT09PXM/KG49by54LHItPXMpOihuKz1oLHItPWEpfWVsc2Ugby5zaGFwZS53aWR0aD5vLnNoYXBlLmhlaWdodD8obj1vLngrLjUqby5zaGFwZS53aWR0aCxyPW8ueS1pKToobj1vLngraSxyPW8ueS0uNSpvLnNoYXBlLmhlaWdodCk7cmV0dXJue3g6bix5OnJ9fXZhciBlbD1ndChcIkFycmF5XCIpLnZhbHVlcyxpbD1BcnJheS5wcm90b3R5cGUsb2w9e0RPTVRva2VuTGlzdDohMCxOb2RlTGlzdDohMH0sbmw9ZnVuY3Rpb24odCl7dmFyIGU9dC52YWx1ZXM7cmV0dXJuIHQ9PT1pbHx8dCBpbnN0YW5jZW9mIEFycmF5JiZlPT09aWwudmFsdWVzfHxvbC5oYXNPd25Qcm9wZXJ0eShOZSh0KSk/ZWw6ZX0scmw9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe1BvKHRoaXMsdCksdGhpcy5tZWFzdXJlVGV4dD1lLHRoaXMuY3VycmVudD0wLHRoaXMud2lkdGg9MCx0aGlzLmhlaWdodD0wLHRoaXMubGluZXM9W119cmV0dXJuIElvKHQsW3trZXk6XCJfYWRkXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06XCJub3JtYWxcIjt2b2lkIDA9PT10aGlzLmxpbmVzW3RdJiYodGhpcy5saW5lc1t0XT17d2lkdGg6MCxoZWlnaHQ6MCxibG9ja3M6W119KTt2YXIgbz1lO3ZvaWQgMCE9PWUmJlwiXCIhPT1lfHwobz1cIiBcIik7dmFyIG49dGhpcy5tZWFzdXJlVGV4dChvLGkpLHI9Y3Qoe30sbmwobikpO3IudGV4dD1lLHIud2lkdGg9bi53aWR0aCxyLm1vZD1pLHZvaWQgMCE9PWUmJlwiXCIhPT1lfHwoci53aWR0aD0wKSx0aGlzLmxpbmVzW3RdLmJsb2Nrcy5wdXNoKHIpLHRoaXMubGluZXNbdF0ud2lkdGgrPXIud2lkdGh9fSx7a2V5OlwiY3VyV2lkdGhcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMubGluZXNbdGhpcy5jdXJyZW50XTtyZXR1cm4gdm9pZCAwPT09dD8wOnQud2lkdGh9fSx7a2V5OlwiYXBwZW5kXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOlwibm9ybWFsXCI7dGhpcy5fYWRkKHRoaXMuY3VycmVudCx0LGUpfX0se2tleTpcIm5ld0xpbmVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06XCJub3JtYWxcIjt0aGlzLl9hZGQodGhpcy5jdXJyZW50LHQsZSksdGhpcy5jdXJyZW50Kyt9fSx7a2V5OlwiZGV0ZXJtaW5lTGluZUhlaWdodHNcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8dGhpcy5saW5lcy5sZW5ndGg7dCsrKXt2YXIgZT10aGlzLmxpbmVzW3RdLGk9MDtpZih2b2lkIDAhPT1lLmJsb2Nrcylmb3IodmFyIG89MDtvPGUuYmxvY2tzLmxlbmd0aDtvKyspe3ZhciBuPWUuYmxvY2tzW29dO2k8bi5oZWlnaHQmJihpPW4uaGVpZ2h0KX1lLmhlaWdodD1pfX19LHtrZXk6XCJkZXRlcm1pbmVMYWJlbFNpemVcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MCxpPTA7aTx0aGlzLmxpbmVzLmxlbmd0aDtpKyspe3ZhciBvPXRoaXMubGluZXNbaV07by53aWR0aD50JiYodD1vLndpZHRoKSxlKz1vLmhlaWdodH10aGlzLndpZHRoPXQsdGhpcy5oZWlnaHQ9ZX19LHtrZXk6XCJyZW1vdmVFbXB0eUJsb2Nrc1wiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MDtlPHRoaXMubGluZXMubGVuZ3RoO2UrKyl7dmFyIGk9dGhpcy5saW5lc1tlXTtpZigwIT09aS5ibG9ja3MubGVuZ3RoJiYoZSE9PXRoaXMubGluZXMubGVuZ3RoLTF8fDAhPT1pLndpZHRoKSl7dmFyIG89e307Y3QobyxpKSxvLmJsb2Nrcz1bXTtmb3IodmFyIG49dm9pZCAwLHI9W10scz0wO3M8aS5ibG9ja3MubGVuZ3RoO3MrKyl7dmFyIGE9aS5ibG9ja3Nbc107MCE9PWEud2lkdGg/ci5wdXNoKGEpOnZvaWQgMD09PW4mJihuPWEpfTA9PT1yLmxlbmd0aCYmdm9pZCAwIT09biYmci5wdXNoKG4pLG8uYmxvY2tzPXIsdC5wdXNoKG8pfX1yZXR1cm4gdH19LHtrZXk6XCJmaW5hbGl6ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5kZXRlcm1pbmVMaW5lSGVpZ2h0cygpLHRoaXMuZGV0ZXJtaW5lTGFiZWxTaXplKCk7dmFyIHQ9dGhpcy5yZW1vdmVFbXB0eUJsb2NrcygpO3JldHVybnt3aWR0aDp0aGlzLndpZHRoLGhlaWdodDp0aGlzLmhlaWdodCxsaW5lczp0fX19XSksdH0oKSxzbD17XCI8Yj5cIjovPGI+LyxcIjxpPlwiOi88aT4vLFwiPGNvZGU+XCI6Lzxjb2RlPi8sXCI8L2I+XCI6LzxcXC9iPi8sXCI8L2k+XCI6LzxcXC9pPi8sXCI8L2NvZGU+XCI6LzxcXC9jb2RlPi8sXCIqXCI6L1xcKi8sXzovXy8sXCJgXCI6L2AvLGFmdGVyQm9sZDovW14qXS8sYWZ0ZXJJdGFsOi9bXl9dLyxhZnRlck1vbm86L1teYF0vfSxhbD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7UG8odGhpcyx0KSx0aGlzLnRleHQ9ZSx0aGlzLmJvbGQ9ITEsdGhpcy5pdGFsPSExLHRoaXMubW9ubz0hMSx0aGlzLnNwYWNpbmc9ITEsdGhpcy5wb3NpdGlvbj0wLHRoaXMuYnVmZmVyPVwiXCIsdGhpcy5tb2RTdGFjaz1bXSx0aGlzLmJsb2Nrcz1bXX1yZXR1cm4gSW8odCxbe2tleTpcIm1vZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLm1vZFN0YWNrLmxlbmd0aD9cIm5vcm1hbFwiOnRoaXMubW9kU3RhY2tbMF19fSx7a2V5OlwibW9kTmFtZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLm1vZFN0YWNrLmxlbmd0aD9cIm5vcm1hbFwiOlwibW9ub1wiPT09dGhpcy5tb2RTdGFja1swXT9cIm1vbm9cIjp0aGlzLmJvbGQmJnRoaXMuaXRhbD9cImJvbGRpdGFsXCI6dGhpcy5ib2xkP1wiYm9sZFwiOnRoaXMuaXRhbD9cIml0YWxcIjp2b2lkIDB9fSx7a2V5OlwiZW1pdEJsb2NrXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNwYWNpbmcmJih0aGlzLmFkZChcIiBcIiksdGhpcy5zcGFjaW5nPSExKSx0aGlzLmJ1ZmZlci5sZW5ndGg+MCYmKHRoaXMuYmxvY2tzLnB1c2goe3RleHQ6dGhpcy5idWZmZXIsbW9kOnRoaXMubW9kTmFtZSgpfSksdGhpcy5idWZmZXI9XCJcIil9fSx7a2V5OlwiYWRkXCIsdmFsdWU6ZnVuY3Rpb24odCl7XCIgXCI9PT10JiYodGhpcy5zcGFjaW5nPSEwKSx0aGlzLnNwYWNpbmcmJih0aGlzLmJ1ZmZlcis9XCIgXCIsdGhpcy5zcGFjaW5nPSExKSxcIiBcIiE9dCYmKHRoaXMuYnVmZmVyKz10KX19LHtrZXk6XCJwYXJzZVdTXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuISEvWyBcXHRdLy50ZXN0KHQpJiYodGhpcy5tb25vP3RoaXMuYWRkKHQpOnRoaXMuc3BhY2luZz0hMCwhMCl9fSx7a2V5Olwic2V0VGFnXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5lbWl0QmxvY2soKSx0aGlzW3RdPSEwLHRoaXMubW9kU3RhY2sudW5zaGlmdCh0KX19LHtrZXk6XCJ1bnNldFRhZ1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuZW1pdEJsb2NrKCksdGhpc1t0XT0hMSx0aGlzLm1vZFN0YWNrLnNoaWZ0KCl9fSx7a2V5OlwicGFyc2VTdGFydFRhZ1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuISh0aGlzLm1vbm98fHRoaXNbdF18fCF0aGlzLm1hdGNoKGUpKSYmKHRoaXMuc2V0VGFnKHQpLCEwKX19LHtrZXk6XCJtYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV0saT10aGlzLnByZXBhcmVSZWdFeHAodCksbz1hbihpLDIpLG49b1swXSxyPW9bMV0scz1uLnRlc3QodGhpcy50ZXh0LnN1YnN0cih0aGlzLnBvc2l0aW9uLHIpKTtyZXR1cm4gcyYmZSYmKHRoaXMucG9zaXRpb24rPXItMSksc319LHtrZXk6XCJwYXJzZUVuZFRhZ1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz10aGlzLm1vZCgpPT09dDtyZXR1cm4hKCEobz1cIm1vbm9cIj09PXQ/byYmdGhpcy5tb25vOm8mJiF0aGlzLm1vbm8pfHwhdGhpcy5tYXRjaChlKSkmJih2b2lkIDAhPT1pPyh0aGlzLnBvc2l0aW9uPT09dGhpcy50ZXh0Lmxlbmd0aC0xfHx0aGlzLm1hdGNoKGksITEpKSYmdGhpcy51bnNldFRhZyh0KTp0aGlzLnVuc2V0VGFnKHQpLCEwKX19LHtrZXk6XCJyZXBsYWNlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4hIXRoaXMubWF0Y2godCkmJih0aGlzLmFkZChlKSx0aGlzLnBvc2l0aW9uKz1sZW5ndGgtMSwhMCl9fSx7a2V5OlwicHJlcGFyZVJlZ0V4cFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlLGk7aWYodCBpbnN0YW5jZW9mIFJlZ0V4cClpPXQsZT0xO2Vsc2V7dmFyIG89c2xbdF07aT12b2lkIDAhPT1vP286bmV3IFJlZ0V4cCh0KSxlPXQubGVuZ3RofXJldHVybltpLGVdfX1dKSx0fSgpLGhsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLGksbyxuKXt2YXIgcj10aGlzO1BvKHRoaXMsdCksdGhpcy5jdHg9ZSx0aGlzLnBhcmVudD1pLHRoaXMuc2VsZWN0ZWQ9byx0aGlzLmhvdmVyPW47dGhpcy5saW5lcz1uZXcgcmwoKGZ1bmN0aW9uKHQsaSl7aWYodm9pZCAwPT09dClyZXR1cm4gMDt2YXIgcz1yLnBhcmVudC5nZXRGb3JtYXR0aW5nVmFsdWVzKGUsbyxuLGkpLGE9MDtcIlwiIT09dCYmKGE9ci5jdHgubWVhc3VyZVRleHQodCkud2lkdGgpO3JldHVybnt3aWR0aDphLHZhbHVlczpzfX0pKX1yZXR1cm4gSW8odCxbe2tleTpcInByb2Nlc3NcIix2YWx1ZTpmdW5jdGlvbih0KXtpZighSmQodCkpcmV0dXJuIHRoaXMubGluZXMuZmluYWxpemUoKTt2YXIgZT10aGlzLnBhcmVudC5mb250T3B0aW9uczt0PSh0PXQucmVwbGFjZSgvXFxyXFxuL2csXCJcXG5cIikpLnJlcGxhY2UoL1xcci9nLFwiXFxuXCIpO3ZhciBpPVN0cmluZyh0KS5zcGxpdChcIlxcblwiKSxvPWkubGVuZ3RoO2lmKGUubXVsdGkpZm9yKHZhciBuPTA7bjxvO24rKyl7dmFyIHI9dGhpcy5zcGxpdEJsb2NrcyhpW25dLGUubXVsdGkpO2lmKHZvaWQgMCE9PXIpaWYoMCE9PXIubGVuZ3RoKXtpZihlLm1heFdkdD4wKWZvcih2YXIgcz0wO3M8ci5sZW5ndGg7cysrKXt2YXIgYT1yW3NdLm1vZCxoPXJbc10udGV4dDt0aGlzLnNwbGl0U3RyaW5nSW50b0xpbmVzKGgsYSwhMCl9ZWxzZSBmb3IodmFyIGQ9MDtkPHIubGVuZ3RoO2QrKyl7dmFyIGw9cltkXS5tb2QsYz1yW2RdLnRleHQ7dGhpcy5saW5lcy5hcHBlbmQoYyxsKX10aGlzLmxpbmVzLm5ld0xpbmUoKX1lbHNlIHRoaXMubGluZXMubmV3TGluZShcIlwiKX1lbHNlIGlmKGUubWF4V2R0PjApZm9yKHZhciB1PTA7dTxvO3UrKyl0aGlzLnNwbGl0U3RyaW5nSW50b0xpbmVzKGlbdV0pO2Vsc2UgZm9yKHZhciBmPTA7ZjxvO2YrKyl0aGlzLmxpbmVzLm5ld0xpbmUoaVtmXSk7cmV0dXJuIHRoaXMubGluZXMuZmluYWxpemUoKX19LHtrZXk6XCJkZWNvZGVNYXJrdXBTeXN0ZW1cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1cIm5vbmVcIjtyZXR1cm5cIm1hcmtkb3duXCI9PT10fHxcIm1kXCI9PT10P2U9XCJtYXJrZG93blwiOiEwIT09dCYmXCJodG1sXCIhPT10fHwoZT1cImh0bWxcIiksZX19LHtrZXk6XCJzcGxpdEh0bWxCbG9ja3NcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IGFsKHQpLGk9ZnVuY3Rpb24odCl7cmV0dXJuISEvJi8udGVzdCh0KSYmKGUucmVwbGFjZShlLnRleHQsXCImbHQ7XCIsXCI8XCIpfHxlLnJlcGxhY2UoZS50ZXh0LFwiJmFtcDtcIixcIiZcIil8fGUuYWRkKFwiJlwiKSwhMCl9O2UucG9zaXRpb248ZS50ZXh0Lmxlbmd0aDspe3ZhciBvPWUudGV4dC5jaGFyQXQoZS5wb3NpdGlvbik7ZS5wYXJzZVdTKG8pfHwvPC8udGVzdChvKSYmKGUucGFyc2VTdGFydFRhZyhcImJvbGRcIixcIjxiPlwiKXx8ZS5wYXJzZVN0YXJ0VGFnKFwiaXRhbFwiLFwiPGk+XCIpfHxlLnBhcnNlU3RhcnRUYWcoXCJtb25vXCIsXCI8Y29kZT5cIil8fGUucGFyc2VFbmRUYWcoXCJib2xkXCIsXCI8L2I+XCIpfHxlLnBhcnNlRW5kVGFnKFwiaXRhbFwiLFwiPC9pPlwiKXx8ZS5wYXJzZUVuZFRhZyhcIm1vbm9cIixcIjwvY29kZT5cIikpfHxpKG8pfHxlLmFkZChvKSxlLnBvc2l0aW9uKyt9cmV0dXJuIGUuZW1pdEJsb2NrKCksZS5ibG9ja3N9fSx7a2V5Olwic3BsaXRNYXJrZG93bkJsb2Nrc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLGk9bmV3IGFsKHQpLG89ITAsbj1mdW5jdGlvbih0KXtyZXR1cm4hIS9cXFxcLy50ZXN0KHQpJiYoaS5wb3NpdGlvbjxlLnRleHQubGVuZ3RoKzEmJihpLnBvc2l0aW9uKyssdD1lLnRleHQuY2hhckF0KGkucG9zaXRpb24pLC8gXFx0Ly50ZXN0KHQpP2kuc3BhY2luZz0hMDooaS5hZGQodCksbz0hMSkpLCEwKX07aS5wb3NpdGlvbjxpLnRleHQubGVuZ3RoOyl7dmFyIHI9aS50ZXh0LmNoYXJBdChpLnBvc2l0aW9uKTtpLnBhcnNlV1Mocil8fG4ocil8fChvfHxpLnNwYWNpbmcpJiYoaS5wYXJzZVN0YXJ0VGFnKFwiYm9sZFwiLFwiKlwiKXx8aS5wYXJzZVN0YXJ0VGFnKFwiaXRhbFwiLFwiX1wiKXx8aS5wYXJzZVN0YXJ0VGFnKFwibW9ub1wiLFwiYFwiKSl8fGkucGFyc2VFbmRUYWcoXCJib2xkXCIsXCIqXCIsXCJhZnRlckJvbGRcIil8fGkucGFyc2VFbmRUYWcoXCJpdGFsXCIsXCJfXCIsXCJhZnRlckl0YWxcIil8fGkucGFyc2VFbmRUYWcoXCJtb25vXCIsXCJgXCIsXCJhZnRlck1vbm9cIil8fChpLmFkZChyKSxvPSExKSxpLnBvc2l0aW9uKyt9cmV0dXJuIGkuZW1pdEJsb2NrKCksaS5ibG9ja3N9fSx7a2V5Olwic3BsaXRCbG9ja3NcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMuZGVjb2RlTWFya3VwU3lzdGVtKGUpO3JldHVyblwibm9uZVwiPT09aT9be3RleHQ6dCxtb2Q6XCJub3JtYWxcIn1dOlwibWFya2Rvd25cIj09PWk/dGhpcy5zcGxpdE1hcmtkb3duQmxvY2tzKHQpOlwiaHRtbFwiPT09aT90aGlzLnNwbGl0SHRtbEJsb2Nrcyh0KTp2b2lkIDB9fSx7a2V5Olwib3Zlck1heFdpZHRoXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5jdHgubWVhc3VyZVRleHQodCkud2lkdGg7cmV0dXJuIHRoaXMubGluZXMuY3VyV2lkdGgoKStlPnRoaXMucGFyZW50LmZvbnRPcHRpb25zLm1heFdkdH19LHtrZXk6XCJnZXRMb25nZXN0Rml0XCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVwiXCIsaT0wO2k8dC5sZW5ndGg7KXt2YXIgbz1lKyhcIlwiPT09ZT9cIlwiOlwiIFwiKSt0W2ldO2lmKHRoaXMub3Zlck1heFdpZHRoKG8pKWJyZWFrO2U9byxpKyt9cmV0dXJuIGl9fSx7a2V5OlwiZ2V0TG9uZ2VzdEZpdFdvcmRcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoJiYhdGhpcy5vdmVyTWF4V2lkdGgodm4odCkuY2FsbCh0LDAsZSkpOyllKys7cmV0dXJuIGV9fSx7a2V5Olwic3BsaXRTdHJpbmdJbnRvTGluZXNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06XCJub3JtYWxcIixpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07dGhpcy5wYXJlbnQuZ2V0Rm9ybWF0dGluZ1ZhbHVlcyh0aGlzLmN0eCx0aGlzLnNlbGVjdGVkLHRoaXMuaG92ZXIsZSk7Zm9yKHZhciBvPSh0PSh0PXQucmVwbGFjZSgvXiggKykvZyxcIiQxXFxyXCIpKS5yZXBsYWNlKC8oW15cXHJdW14gXSopKCArKS9nLFwiJDFcXHIkMlxcclwiKSkuc3BsaXQoXCJcXHJcIik7by5sZW5ndGg+MDspe3ZhciBuPXRoaXMuZ2V0TG9uZ2VzdEZpdChvKTtpZigwPT09bil7dmFyIHI9b1swXSxzPXRoaXMuZ2V0TG9uZ2VzdEZpdFdvcmQocik7dGhpcy5saW5lcy5uZXdMaW5lKHZuKHIpLmNhbGwociwwLHMpLGUpLG9bMF09dm4ocikuY2FsbChyLHMpfWVsc2V7dmFyIGE9bjtcIiBcIj09PW9bbi0xXT9uLS06XCIgXCI9PT1vW2FdJiZhKys7dmFyIGg9dm4obykuY2FsbChvLDAsbikuam9pbihcIlwiKTtuPT1vLmxlbmd0aCYmaT90aGlzLmxpbmVzLmFwcGVuZChoLGUpOnRoaXMubGluZXMubmV3TGluZShoLGUpLG89dm4obykuY2FsbChvLGEpfX19fV0pLHR9KCksZGw9W1wiYm9sZFwiLFwiaXRhbFwiLFwiYm9sZGl0YWxcIixcIm1vbm9cIl0sbGw9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsaSl7dmFyIG89YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXTtQbyh0aGlzLHQpLHRoaXMuYm9keT1lLHRoaXMucG9pbnRUb1NlbGY9ITEsdGhpcy5iYXNlU2l6ZT12b2lkIDAsdGhpcy5mb250T3B0aW9ucz17fSx0aGlzLnNldE9wdGlvbnMoaSksdGhpcy5zaXplPXt0b3A6MCxsZWZ0OjAsd2lkdGg6MCxoZWlnaHQ6MCx5TGluZTowfSx0aGlzLmlzRWRnZUxhYmVsPW99cmV0dXJuIElvKHQsW3trZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodGhpcy5lbGVtZW50T3B0aW9ucz10LHRoaXMuaW5pdEZvbnRPcHRpb25zKHQuZm9udCksSmQodC5sYWJlbCk/dGhpcy5sYWJlbERpcnR5PSEwOnQubGFiZWw9dm9pZCAwLHZvaWQgMCE9PXQuZm9udCYmbnVsbCE9PXQuZm9udClpZihcInN0cmluZ1wiPT10eXBlb2YgdC5mb250KXRoaXMuYmFzZVNpemU9dGhpcy5mb250T3B0aW9ucy5zaXplO2Vsc2UgaWYoXCJvYmplY3RcIj09PWRuKHQuZm9udCkpe3ZhciBlPXQuZm9udC5zaXplO3ZvaWQgMCE9PWUmJih0aGlzLmJhc2VTaXplPWUpfX19LHtrZXk6XCJpbml0Rm9udE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgaT10aGlzO25oKGRsLChmdW5jdGlvbih0KXtpLmZvbnRPcHRpb25zW3RdPXt9fSkpLHQucGFyc2VGb250U3RyaW5nKHRoaXMuZm9udE9wdGlvbnMsZSk/dGhpcy5mb250T3B0aW9ucy52YWRqdXN0PTA6bmgoZSwoZnVuY3Rpb24odCxlKXtudWxsIT10JiZcIm9iamVjdFwiIT09ZG4odCkmJihpLmZvbnRPcHRpb25zW2VdPXQpfSkpfX0se2tleTpcImNvbnN0cmFpblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXtjb25zdHJhaW5XaWR0aDohMSxtYXhXZHQ6LTEsbWluV2R0Oi0xLGNvbnN0cmFpbkhlaWdodDohMSxtaW5IZ3Q6LTEsdmFsaWduOlwibWlkZGxlXCJ9LGk9bWgodCxcIndpZHRoQ29uc3RyYWludFwiKTtpZihcIm51bWJlclwiPT10eXBlb2YgaSllLm1heFdkdD1OdW1iZXIoaSksZS5taW5XZHQ9TnVtYmVyKGkpO2Vsc2UgaWYoXCJvYmplY3RcIj09PWRuKGkpKXt2YXIgbz1taCh0LFtcIndpZHRoQ29uc3RyYWludFwiLFwibWF4aW11bVwiXSk7XCJudW1iZXJcIj09dHlwZW9mIG8mJihlLm1heFdkdD1OdW1iZXIobykpO3ZhciBuPW1oKHQsW1wid2lkdGhDb25zdHJhaW50XCIsXCJtaW5pbXVtXCJdKTtcIm51bWJlclwiPT10eXBlb2YgbiYmKGUubWluV2R0PU51bWJlcihuKSl9dmFyIHI9bWgodCxcImhlaWdodENvbnN0cmFpbnRcIik7aWYoXCJudW1iZXJcIj09dHlwZW9mIHIpZS5taW5IZ3Q9TnVtYmVyKHIpO2Vsc2UgaWYoXCJvYmplY3RcIj09PWRuKHIpKXt2YXIgcz1taCh0LFtcImhlaWdodENvbnN0cmFpbnRcIixcIm1pbmltdW1cIl0pO1wibnVtYmVyXCI9PXR5cGVvZiBzJiYoZS5taW5IZ3Q9TnVtYmVyKHMpKTt2YXIgYT1taCh0LFtcImhlaWdodENvbnN0cmFpbnRcIixcInZhbGlnblwiXSk7XCJzdHJpbmdcIj09dHlwZW9mIGEmJihcInRvcFwiIT09YSYmXCJib3R0b21cIiE9PWF8fChlLnZhbGlnbj1hKSl9cmV0dXJuIGV9fSx7a2V5OlwidXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLnNldE9wdGlvbnModCwhMCksdGhpcy5wcm9wYWdhdGVGb250cyhlKSx0aCh0aGlzLmZvbnRPcHRpb25zLHRoaXMuY29uc3RyYWluKGUpKSx0aGlzLmZvbnRPcHRpb25zLmNob29zZXI9UWQoXCJsYWJlbFwiLGUpfX0se2tleTpcImFkanVzdFNpemVzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dD90LnJpZ2h0K3QubGVmdDowO3RoaXMuZm9udE9wdGlvbnMuY29uc3RyYWluV2lkdGgmJih0aGlzLmZvbnRPcHRpb25zLm1heFdkdC09ZSx0aGlzLmZvbnRPcHRpb25zLm1pbldkdC09ZSk7dmFyIGk9dD90LnRvcCt0LmJvdHRvbTowO3RoaXMuZm9udE9wdGlvbnMuY29uc3RyYWluSGVpZ2h0JiYodGhpcy5mb250T3B0aW9ucy5taW5IZ3QtPWkpfX0se2tleTpcImFkZEZvbnRPcHRpb25zVG9QaWxlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoOysraSl0aGlzLmFkZEZvbnRUb1BpbGUodCxlW2ldKX19LHtrZXk6XCJhZGRGb250VG9QaWxlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZih2b2lkIDAhPT1lJiZ2b2lkIDAhPT1lLmZvbnQmJm51bGwhPT1lLmZvbnQpe3ZhciBpPWUuZm9udDt0LnB1c2goaSl9fX0se2tleTpcImdldEJhc2ljT3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgaT17fSxvPTA7bzxlLmxlbmd0aDsrK28pe3ZhciBuPWVbb10scj17fTt0LnBhcnNlRm9udFN0cmluZyhyLG4pJiYobj1yKSxuaChuLChmdW5jdGlvbih0LGUpe3ZvaWQgMCE9PXQmJihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSxlKXx8KC0xIT09TXIoZGwpLmNhbGwoZGwsZSk/aVtlXT17fTppW2VdPXQpKX0pKX1yZXR1cm4gaX19LHtrZXk6XCJnZXRGb250T3B0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oZSxpLG8pe2Zvcih2YXIgbixyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBzPWVbcl07aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsaSkpe2lmKG51bGw9PShuPXNbaV0pKWNvbnRpbnVlO3ZhciBhPXt9O2lmKHQucGFyc2VGb250U3RyaW5nKGEsbikmJihuPWEpLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLG8pKXJldHVybiBuW29dfX1pZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5mb250T3B0aW9ucyxvKSlyZXR1cm4gdGhpcy5mb250T3B0aW9uc1tvXTt0aHJvdyBuZXcgRXJyb3IoXCJEaWQgbm90IGZpbmQgdmFsdWUgZm9yIG11bHRpLWZvbnQgZm9yIHByb3BlcnR5OiAnXCIrbytcIidcIil9fSx7a2V5OlwiZ2V0Rm9udE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgaT17fSxvPVtcImNvbG9yXCIsXCJzaXplXCIsXCJmYWNlXCIsXCJtb2RcIixcInZhZGp1c3RcIl0sbj0wO248by5sZW5ndGg7KytuKXt2YXIgcj1vW25dO2lbcl09dGhpcy5nZXRGb250T3B0aW9uKHQsZSxyKX1yZXR1cm4gaX19LHtrZXk6XCJwcm9wYWdhdGVGb250c1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsaT1bXTt0aGlzLmFkZEZvbnRPcHRpb25zVG9QaWxlKGksdCksdGhpcy5mb250T3B0aW9ucz10aGlzLmdldEJhc2ljT3B0aW9ucyhpKTtmb3IodmFyIG89ZnVuY3Rpb24odCl7dmFyIG89ZGxbdF0sbj1lLmZvbnRPcHRpb25zW29dO25oKGUuZ2V0Rm9udE9wdGlvbnMoaSxvKSwoZnVuY3Rpb24odCxlKXtuW2VdPXR9KSksbi5zaXplPU51bWJlcihuLnNpemUpLG4udmFkanVzdD1OdW1iZXIobi52YWRqdXN0KX0sbj0wO248ZGwubGVuZ3RoOysrbilvKG4pfX0se2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4pe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+NSYmdm9pZCAwIT09YXJndW1lbnRzWzVdP2FyZ3VtZW50c1s1XTpcIm1pZGRsZVwiO2lmKHZvaWQgMCE9PXRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWwpe3ZhciBzPXRoaXMuZm9udE9wdGlvbnMuc2l6ZSp0aGlzLmJvZHkudmlldy5zY2FsZTt0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsJiZzPHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkLTF8fChzPj10aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwubWF4VmlzaWJsZSYmKHM9TnVtYmVyKHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXhWaXNpYmxlKS90aGlzLmJvZHkudmlldy5zY2FsZSksdGhpcy5jYWxjdWxhdGVMYWJlbFNpemUodCxvLG4sZSxpLHIpLHRoaXMuX2RyYXdCYWNrZ3JvdW5kKHQpLHRoaXMuX2RyYXdUZXh0KHQsZSx0aGlzLnNpemUueUxpbmUscixzKSl9fX0se2tleTpcIl9kcmF3QmFja2dyb3VuZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMCE9PXRoaXMuZm9udE9wdGlvbnMuYmFja2dyb3VuZCYmXCJub25lXCIhPT10aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQpe3QuZmlsbFN0eWxlPXRoaXMuZm9udE9wdGlvbnMuYmFja2dyb3VuZDt2YXIgZT10aGlzLmdldFNpemUoKTt0LmZpbGxSZWN0KGUubGVmdCxlLnRvcCxlLndpZHRoLGUuaGVpZ2h0KX19fSx7a2V5OlwiX2RyYXdUZXh0XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3ZhciBvPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTpcIm1pZGRsZVwiLG49YXJndW1lbnRzLmxlbmd0aD40P2FyZ3VtZW50c1s0XTp2b2lkIDAscj10aGlzLl9zZXRBbGlnbm1lbnQodCxlLGksbykscz1hbihyLDIpO2U9c1swXSxpPXNbMV0sdC50ZXh0QWxpZ249XCJsZWZ0XCIsZS09dGhpcy5zaXplLndpZHRoLzIsdGhpcy5mb250T3B0aW9ucy52YWxpZ24mJnRoaXMuc2l6ZS5oZWlnaHQ+dGhpcy5zaXplLmxhYmVsSGVpZ2h0JiYoXCJ0b3BcIj09PXRoaXMuZm9udE9wdGlvbnMudmFsaWduJiYoaS09KHRoaXMuc2l6ZS5oZWlnaHQtdGhpcy5zaXplLmxhYmVsSGVpZ2h0KS8yKSxcImJvdHRvbVwiPT09dGhpcy5mb250T3B0aW9ucy52YWxpZ24mJihpKz0odGhpcy5zaXplLmhlaWdodC10aGlzLnNpemUubGFiZWxIZWlnaHQpLzIpKTtmb3IodmFyIGE9MDthPHRoaXMubGluZUNvdW50O2ErKyl7dmFyIGg9dGhpcy5saW5lc1thXTtpZihoJiZoLmJsb2Nrcyl7dmFyIGQ9MDt0aGlzLmlzRWRnZUxhYmVsfHxcImNlbnRlclwiPT09dGhpcy5mb250T3B0aW9ucy5hbGlnbj9kKz0odGhpcy5zaXplLndpZHRoLWgud2lkdGgpLzI6XCJyaWdodFwiPT09dGhpcy5mb250T3B0aW9ucy5hbGlnbiYmKGQrPXRoaXMuc2l6ZS53aWR0aC1oLndpZHRoKTtmb3IodmFyIGw9MDtsPGguYmxvY2tzLmxlbmd0aDtsKyspe3ZhciBjPWguYmxvY2tzW2xdO3QuZm9udD1jLmZvbnQ7dmFyIHU9dGhpcy5fZ2V0Q29sb3IoYy5jb2xvcixuLGMuc3Ryb2tlQ29sb3IpLGY9YW4odSwyKSxwPWZbMF0sdj1mWzFdO2Muc3Ryb2tlV2lkdGg+MCYmKHQubGluZVdpZHRoPWMuc3Ryb2tlV2lkdGgsdC5zdHJva2VTdHlsZT12LHQubGluZUpvaW49XCJyb3VuZFwiKSx0LmZpbGxTdHlsZT1wLGMuc3Ryb2tlV2lkdGg+MCYmdC5zdHJva2VUZXh0KGMudGV4dCxlK2QsaStjLnZhZGp1c3QpLHQuZmlsbFRleHQoYy50ZXh0LGUrZCxpK2MudmFkanVzdCksZCs9Yy53aWR0aH1pKz1oLmhlaWdodH19fX0se2tleTpcIl9zZXRBbGlnbm1lbnRcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvKXtpZih0aGlzLmlzRWRnZUxhYmVsJiZcImhvcml6b250YWxcIiE9PXRoaXMuZm9udE9wdGlvbnMuYWxpZ24mJiExPT09dGhpcy5wb2ludFRvU2VsZil7ZT0wLGk9MDtcInRvcFwiPT09dGhpcy5mb250T3B0aW9ucy5hbGlnbj8odC50ZXh0QmFzZWxpbmU9XCJhbHBoYWJldGljXCIsaS09NCk6XCJib3R0b21cIj09PXRoaXMuZm9udE9wdGlvbnMuYWxpZ24/KHQudGV4dEJhc2VsaW5lPVwiaGFuZ2luZ1wiLGkrPTQpOnQudGV4dEJhc2VsaW5lPVwibWlkZGxlXCJ9ZWxzZSB0LnRleHRCYXNlbGluZT1vO3JldHVybltlLGldfX0se2tleTpcIl9nZXRDb2xvclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz10fHxcIiMwMDAwMDBcIixuPWl8fFwiI2ZmZmZmZlwiO2lmKGU8PXRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkKXt2YXIgcj1NYXRoLm1heCgwLE1hdGgubWluKDEsMS0odGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQtZSkpKTtvPXNoKG8sciksbj1zaChuLHIpfXJldHVybltvLG5dfX0se2tleTpcImdldFRleHRTaXplXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXSxpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07cmV0dXJuIHRoaXMuX3Byb2Nlc3NMYWJlbCh0LGUsaSkse3dpZHRoOnRoaXMuc2l6ZS53aWR0aCxoZWlnaHQ6dGhpcy5zaXplLmhlaWdodCxsaW5lQ291bnQ6dGhpcy5saW5lQ291bnR9fX0se2tleTpcImdldFNpemVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc2l6ZS5sZWZ0LGU9dGhpcy5zaXplLnRvcC0xO2lmKHRoaXMuaXNFZGdlTGFiZWwpe3ZhciBpPS41Ki10aGlzLnNpemUud2lkdGg7c3dpdGNoKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24pe2Nhc2VcIm1pZGRsZVwiOnQ9aSxlPS41Ki10aGlzLnNpemUuaGVpZ2h0O2JyZWFrO2Nhc2VcInRvcFwiOnQ9aSxlPS0odGhpcy5zaXplLmhlaWdodCsyKTticmVhaztjYXNlXCJib3R0b21cIjp0PWksZT0yfX1yZXR1cm57bGVmdDp0LHRvcDplLHdpZHRoOnRoaXMuc2l6ZS53aWR0aCxoZWlnaHQ6dGhpcy5zaXplLmhlaWdodH19fSx7a2V5OlwiY2FsY3VsYXRlTGFiZWxTaXplXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3ZhciBvPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTowLG49YXJndW1lbnRzLmxlbmd0aD40JiZ2b2lkIDAhPT1hcmd1bWVudHNbNF0/YXJndW1lbnRzWzRdOjAscj1hcmd1bWVudHMubGVuZ3RoPjUmJnZvaWQgMCE9PWFyZ3VtZW50c1s1XT9hcmd1bWVudHNbNV06XCJtaWRkbGVcIjt0aGlzLl9wcm9jZXNzTGFiZWwodCxlLGkpLHRoaXMuc2l6ZS5sZWZ0PW8tLjUqdGhpcy5zaXplLndpZHRoLHRoaXMuc2l6ZS50b3A9bi0uNSp0aGlzLnNpemUuaGVpZ2h0LHRoaXMuc2l6ZS55TGluZT1uKy41KigxLXRoaXMubGluZUNvdW50KSp0aGlzLmZvbnRPcHRpb25zLnNpemUsXCJoYW5naW5nXCI9PT1yJiYodGhpcy5zaXplLnRvcCs9LjUqdGhpcy5mb250T3B0aW9ucy5zaXplLHRoaXMuc2l6ZS50b3ArPTQsdGhpcy5zaXplLnlMaW5lKz00KX19LHtrZXk6XCJnZXRGb3JtYXR0aW5nVmFsdWVzXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyl7dmFyIG49ZnVuY3Rpb24odCxlLGkpe3JldHVyblwibm9ybWFsXCI9PT1lP1wibW9kXCI9PT1pP1wiXCI6dFtpXTp2b2lkIDAhPT10W2VdW2ldP3RbZV1baV06dFtpXX0scj17Y29sb3I6bih0aGlzLmZvbnRPcHRpb25zLG8sXCJjb2xvclwiKSxzaXplOm4odGhpcy5mb250T3B0aW9ucyxvLFwic2l6ZVwiKSxmYWNlOm4odGhpcy5mb250T3B0aW9ucyxvLFwiZmFjZVwiKSxtb2Q6bih0aGlzLmZvbnRPcHRpb25zLG8sXCJtb2RcIiksdmFkanVzdDpuKHRoaXMuZm9udE9wdGlvbnMsbyxcInZhZGp1c3RcIiksc3Ryb2tlV2lkdGg6dGhpcy5mb250T3B0aW9ucy5zdHJva2VXaWR0aCxzdHJva2VDb2xvcjp0aGlzLmZvbnRPcHRpb25zLnN0cm9rZUNvbG9yfTsoZXx8aSkmJihcIm5vcm1hbFwiPT09byYmITA9PT10aGlzLmZvbnRPcHRpb25zLmNob29zZXImJnRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWxIaWdobGlnaHRCb2xkP3IubW9kPVwiYm9sZFwiOlwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuZm9udE9wdGlvbnMuY2hvb3NlciYmdGhpcy5mb250T3B0aW9ucy5jaG9vc2VyKHIsdGhpcy5lbGVtZW50T3B0aW9ucy5pZCxlLGkpKTt2YXIgcz1cIlwiO3JldHVybiB2b2lkIDAhPT1yLm1vZCYmXCJcIiE9PXIubW9kJiYocys9ci5tb2QrXCIgXCIpLHMrPXIuc2l6ZStcInB4IFwiK3IuZmFjZSx0LmZvbnQ9cy5yZXBsYWNlKC9cIi9nLFwiXCIpLHIuZm9udD10LmZvbnQsci5oZWlnaHQ9ci5zaXplLHJ9fSx7a2V5OlwiZGlmZmVyZW50U3RhdGVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0IT09dGhpcy5zZWxlY3RlZFN0YXRlfHxlIT09dGhpcy5ob3ZlclN0YXRlfX0se2tleTpcIl9wcm9jZXNzTGFiZWxUZXh0XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyl7cmV0dXJuIG5ldyBobCh0LHRoaXMsZSxpKS5wcm9jZXNzKG8pfX0se2tleTpcIl9wcm9jZXNzTGFiZWxcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7aWYoITEhPT10aGlzLmxhYmVsRGlydHl8fHRoaXMuZGlmZmVyZW50U3RhdGUoZSxpKSl7dmFyIG89dGhpcy5fcHJvY2Vzc0xhYmVsVGV4dCh0LGUsaSx0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsKTt0aGlzLmZvbnRPcHRpb25zLm1pbldkdD4wJiZvLndpZHRoPHRoaXMuZm9udE9wdGlvbnMubWluV2R0JiYoby53aWR0aD10aGlzLmZvbnRPcHRpb25zLm1pbldkdCksdGhpcy5zaXplLmxhYmVsSGVpZ2h0PW8uaGVpZ2h0LHRoaXMuZm9udE9wdGlvbnMubWluSGd0PjAmJm8uaGVpZ2h0PHRoaXMuZm9udE9wdGlvbnMubWluSGd0JiYoby5oZWlnaHQ9dGhpcy5mb250T3B0aW9ucy5taW5IZ3QpLHRoaXMubGluZXM9by5saW5lcyx0aGlzLmxpbmVDb3VudD1vLmxpbmVzLmxlbmd0aCx0aGlzLnNpemUud2lkdGg9by53aWR0aCx0aGlzLnNpemUuaGVpZ2h0PW8uaGVpZ2h0LHRoaXMuc2VsZWN0ZWRTdGF0ZT1lLHRoaXMuaG92ZXJTdGF0ZT1pLHRoaXMubGFiZWxEaXJ0eT0hMX19fSx7a2V5OlwidmlzaWJsZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIDAhPT10aGlzLnNpemUud2lkdGgmJjAhPT10aGlzLnNpemUuaGVpZ2h0JiZ2b2lkIDAhPT10aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsJiYhKHRoaXMuZm9udE9wdGlvbnMuc2l6ZSp0aGlzLmJvZHkudmlldy5zY2FsZTx0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZC0xKX19XSxbe2tleTpcInBhcnNlRm9udFN0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYoIWV8fFwic3RyaW5nXCIhPXR5cGVvZiBlKXJldHVybiExO3ZhciBpPWUuc3BsaXQoXCIgXCIpO3JldHVybiB0LnNpemU9K2lbMF0ucmVwbGFjZShcInB4XCIsXCJcIiksdC5mYWNlPWlbMV0sdC5jb2xvcj1pWzJdLCEwfX1dKSx0fSgpLGNsPXJlKFwiUmVmbGVjdFwiLFwiY29uc3RydWN0XCIpLHVsPXMoKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4hKGNsKChmdW5jdGlvbigpe30pLFtdLHQpaW5zdGFuY2VvZiB0KX0pKSxmbD0hcygoZnVuY3Rpb24oKXtjbCgoZnVuY3Rpb24oKXt9KSl9KSkscGw9dWx8fGZsO3Eoe3RhcmdldDpcIlJlZmxlY3RcIixzdGF0OiEwLGZvcmNlZDpwbCxzaGFtOnBsfSx7Y29uc3RydWN0OmZ1bmN0aW9uKHQsZSl7Tih0KSxSKGUpO3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg8Mz90Ok4oYXJndW1lbnRzWzJdKTtpZihmbCYmIXVsKXJldHVybiBjbCh0LGUsaSk7aWYodD09aSl7c3dpdGNoKGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIG5ldyB0O2Nhc2UgMTpyZXR1cm4gbmV3IHQoZVswXSk7Y2FzZSAyOnJldHVybiBuZXcgdChlWzBdLGVbMV0pO2Nhc2UgMzpyZXR1cm4gbmV3IHQoZVswXSxlWzFdLGVbMl0pO2Nhc2UgNDpyZXR1cm4gbmV3IHQoZVswXSxlWzFdLGVbMl0sZVszXSl9dmFyIG89W251bGxdO3JldHVybiBvLnB1c2guYXBwbHkobyxlKSxuZXcodnQuYXBwbHkodCxvKSl9dmFyIG49aS5wcm90b3R5cGUscj1EZShtKG4pP246T2JqZWN0LnByb3RvdHlwZSkscz1GdW5jdGlvbi5hcHBseS5jYWxsKHQscixlKTtyZXR1cm4gbShzKT9zOnJ9fSk7dmFyIHZsPUYuUmVmbGVjdC5jb25zdHJ1Y3QsZ2w9QnI7cSh7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMH0se3NldFByb3RvdHlwZU9mOnFlfSk7dmFyIHlsPUYuT2JqZWN0LnNldFByb3RvdHlwZU9mO2Z1bmN0aW9uIG1sKHQsZSl7cmV0dXJuKG1sPXlsfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfWZ1bmN0aW9uIGJsKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO3QucHJvdG90eXBlPWdsKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmbWwodCxlKX1mdW5jdGlvbiB3bCh0LGUpe3JldHVybiFlfHxcIm9iamVjdFwiIT09ZG4oZSkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9KHQpOmV9dmFyIGtsPWVyO2Z1bmN0aW9uIF9sKHQpe3JldHVybihfbD15bD9rbDpmdW5jdGlvbih0KXtyZXR1cm4gdC5fX3Byb3RvX198fGtsKHQpfSkodCl9dmFyIHhsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLGksbyl7UG8odGhpcyx0KSx0aGlzLmJvZHk9aSx0aGlzLmxhYmVsTW9kdWxlPW8sdGhpcy5zZXRPcHRpb25zKGUpLHRoaXMudG9wPXZvaWQgMCx0aGlzLmxlZnQ9dm9pZCAwLHRoaXMuaGVpZ2h0PXZvaWQgMCx0aGlzLndpZHRoPXZvaWQgMCx0aGlzLnJhZGl1cz12b2lkIDAsdGhpcy5tYXJnaW49dm9pZCAwLHRoaXMucmVmcmVzaE5lZWRlZD0hMCx0aGlzLmJvdW5kaW5nQm94PXt0b3A6MCxsZWZ0OjAscmlnaHQ6MCxib3R0b206MH19cmV0dXJuIElvKHQsW3trZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5vcHRpb25zPXR9fSx7a2V5OlwiX3NldE1hcmdpbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLm1hcmdpbj17fSx0aGlzLm9wdGlvbnMubWFyZ2luJiYoXCJvYmplY3RcIj09ZG4odGhpcy5vcHRpb25zLm1hcmdpbik/KHRoaXMubWFyZ2luLnRvcD10aGlzLm9wdGlvbnMubWFyZ2luLnRvcCx0aGlzLm1hcmdpbi5yaWdodD10aGlzLm9wdGlvbnMubWFyZ2luLnJpZ2h0LHRoaXMubWFyZ2luLmJvdHRvbT10aGlzLm9wdGlvbnMubWFyZ2luLmJvdHRvbSx0aGlzLm1hcmdpbi5sZWZ0PXRoaXMub3B0aW9ucy5tYXJnaW4ubGVmdCk6KHRoaXMubWFyZ2luLnRvcD10aGlzLm9wdGlvbnMubWFyZ2luLHRoaXMubWFyZ2luLnJpZ2h0PXRoaXMub3B0aW9ucy5tYXJnaW4sdGhpcy5tYXJnaW4uYm90dG9tPXRoaXMub3B0aW9ucy5tYXJnaW4sdGhpcy5tYXJnaW4ubGVmdD10aGlzLm9wdGlvbnMubWFyZ2luKSksdC5hZGp1c3RTaXplcyh0aGlzLm1hcmdpbil9fSx7a2V5OlwiX2Rpc3RhbmNlVG9Cb3JkZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtyZXR1cm4gdCYmdGhpcy5yZXNpemUodCksTWF0aC5taW4oTWF0aC5hYnModGhpcy53aWR0aC8yL01hdGguY29zKGUpKSxNYXRoLmFicyh0aGlzLmhlaWdodC8yL01hdGguc2luKGUpKSkraX19LHtrZXk6XCJlbmFibGVTaGFkb3dcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2Uuc2hhZG93JiYodC5zaGFkb3dDb2xvcj1lLnNoYWRvd0NvbG9yLHQuc2hhZG93Qmx1cj1lLnNoYWRvd1NpemUsdC5zaGFkb3dPZmZzZXRYPWUuc2hhZG93WCx0LnNoYWRvd09mZnNldFk9ZS5zaGFkb3dZKX19LHtrZXk6XCJkaXNhYmxlU2hhZG93XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtlLnNoYWRvdyYmKHQuc2hhZG93Q29sb3I9XCJyZ2JhKDAsMCwwLDApXCIsdC5zaGFkb3dCbHVyPTAsdC5zaGFkb3dPZmZzZXRYPTAsdC5zaGFkb3dPZmZzZXRZPTApfX0se2tleTpcImVuYWJsZUJvcmRlckRhc2hlc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYoITEhPT1lLmJvcmRlckRhc2hlcylpZih2b2lkIDAhPT10LnNldExpbmVEYXNoKXt2YXIgaT1lLmJvcmRlckRhc2hlczshMD09PWkmJihpPVs1LDE1XSksdC5zZXRMaW5lRGFzaChpKX1lbHNlIGNvbnNvbGUud2FybihcInNldExpbmVEYXNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBUaGUgZGFzaGVkIGJvcmRlcnMgY2Fubm90IGJlIHVzZWQuXCIpLHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzPSExLGUuYm9yZGVyRGFzaGVzPSExfX0se2tleTpcImRpc2FibGVCb3JkZXJEYXNoZXNcIix2YWx1ZTpmdW5jdGlvbih0LGUpeyExIT09ZS5ib3JkZXJEYXNoZXMmJih2b2lkIDAhPT10LnNldExpbmVEYXNoP3Quc2V0TGluZURhc2goWzBdKTooY29uc29sZS53YXJuKFwic2V0TGluZURhc2ggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFRoZSBkYXNoZWQgYm9yZGVycyBjYW5ub3QgYmUgdXNlZC5cIiksdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXM9ITEsZS5ib3JkZXJEYXNoZXM9ITEpKX19LHtrZXk6XCJuZWVkc1JlZnJlc2hcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiEwPT09dGhpcy5yZWZyZXNoTmVlZGVkPyh0aGlzLnJlZnJlc2hOZWVkZWQ9ITEsITApOnZvaWQgMD09PXRoaXMud2lkdGh8fHRoaXMubGFiZWxNb2R1bGUuZGlmZmVyZW50U3RhdGUodCxlKX19LHtrZXk6XCJpbml0Q29udGV4dEZvckRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPWUuYm9yZGVyV2lkdGgvdGhpcy5ib2R5LnZpZXcuc2NhbGU7dC5saW5lV2lkdGg9TWF0aC5taW4odGhpcy53aWR0aCxpKSx0LnN0cm9rZVN0eWxlPWUuYm9yZGVyQ29sb3IsdC5maWxsU3R5bGU9ZS5jb2xvcn19LHtrZXk6XCJwZXJmb3JtU3Ryb2tlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT1lLmJvcmRlcldpZHRoL3RoaXMuYm9keS52aWV3LnNjYWxlO3Quc2F2ZSgpLGk+MCYmKHRoaXMuZW5hYmxlQm9yZGVyRGFzaGVzKHQsZSksdC5zdHJva2UoKSx0aGlzLmRpc2FibGVCb3JkZXJEYXNoZXModCxlKSksdC5yZXN0b3JlKCl9fSx7a2V5OlwicGVyZm9ybUZpbGxcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3Quc2F2ZSgpLHQuZmlsbFN0eWxlPWUuY29sb3IsdGhpcy5lbmFibGVTaGFkb3codCxlKSxYcih0KS5jYWxsKHQpLHRoaXMuZGlzYWJsZVNoYWRvdyh0LGUpLHQucmVzdG9yZSgpLHRoaXMucGVyZm9ybVN0cm9rZSh0LGUpfX0se2tleTpcIl9hZGRCb3VuZGluZ0JveE1hcmdpblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuYm91bmRpbmdCb3gubGVmdC09dCx0aGlzLmJvdW5kaW5nQm94LnRvcC09dCx0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSs9dCx0aGlzLmJvdW5kaW5nQm94LnJpZ2h0Kz10fX0se2tleTpcIl91cGRhdGVCb3VuZGluZ0JveFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbil7dm9pZCAwIT09aSYmdGhpcy5yZXNpemUoaSxvLG4pLHRoaXMubGVmdD10LXRoaXMud2lkdGgvMix0aGlzLnRvcD1lLXRoaXMuaGVpZ2h0LzIsdGhpcy5ib3VuZGluZ0JveC5sZWZ0PXRoaXMubGVmdCx0aGlzLmJvdW5kaW5nQm94LnRvcD10aGlzLnRvcCx0aGlzLmJvdW5kaW5nQm94LmJvdHRvbT10aGlzLnRvcCt0aGlzLmhlaWdodCx0aGlzLmJvdW5kaW5nQm94LnJpZ2h0PXRoaXMubGVmdCt0aGlzLndpZHRofX0se2tleTpcInVwZGF0ZUJvdW5kaW5nQm94XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuKXt0aGlzLl91cGRhdGVCb3VuZGluZ0JveCh0LGUsaSxvLG4pfX0se2tleTpcImdldERpbWVuc2lvbnNGcm9tTGFiZWxcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dGhpcy50ZXh0U2l6ZT10aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKHQsZSxpKTt2YXIgbz10aGlzLnRleHRTaXplLndpZHRoLG49dGhpcy50ZXh0U2l6ZS5oZWlnaHQ7cmV0dXJuIDA9PT1vJiYobz0xNCxuPTE0KSx7d2lkdGg6byxoZWlnaHQ6bn19fV0pLHR9KCk7ZnVuY3Rpb24gRWwodCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgT2w9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1FbChpKTtmdW5jdGlvbiBpKHQsbyxuKXt2YXIgcjtyZXR1cm4gUG8odGhpcyxpKSwocj1lLmNhbGwodGhpcyx0LG8sbikpLl9zZXRNYXJnaW5zKG4pLHJ9cmV0dXJuIElvKGksW3trZXk6XCJyZXNpemVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5zZWxlY3RlZCxpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp0aGlzLmhvdmVyO2lmKHRoaXMubmVlZHNSZWZyZXNoKGUsaSkpe3ZhciBvPXRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbCh0LGUsaSk7dGhpcy53aWR0aD1vLndpZHRoK3RoaXMubWFyZ2luLnJpZ2h0K3RoaXMubWFyZ2luLmxlZnQsdGhpcy5oZWlnaHQ9by5oZWlnaHQrdGhpcy5tYXJnaW4udG9wK3RoaXMubWFyZ2luLmJvdHRvbSx0aGlzLnJhZGl1cz10aGlzLndpZHRoLzJ9fX0se2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7dGhpcy5yZXNpemUodCxvLG4pLHRoaXMubGVmdD1lLXRoaXMud2lkdGgvMix0aGlzLnRvcD1pLXRoaXMuaGVpZ2h0LzIsdGhpcy5pbml0Q29udGV4dEZvckRyYXcodCxyKSxrdCh0LHRoaXMubGVmdCx0aGlzLnRvcCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0LHIuYm9yZGVyUmFkaXVzKSx0aGlzLnBlcmZvcm1GaWxsKHQsciksdGhpcy51cGRhdGVCb3VuZGluZ0JveChlLGksdCxvLG4pLHRoaXMubGFiZWxNb2R1bGUuZHJhdyh0LHRoaXMubGVmdCt0aGlzLnRleHRTaXplLndpZHRoLzIrdGhpcy5tYXJnaW4ubGVmdCx0aGlzLnRvcCt0aGlzLnRleHRTaXplLmhlaWdodC8yK3RoaXMubWFyZ2luLnRvcCxvLG4pfX0se2tleTpcInVwZGF0ZUJvdW5kaW5nQm94XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuKXt0aGlzLl91cGRhdGVCb3VuZGluZ0JveCh0LGUsaSxvLG4pO3ZhciByPXRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyUmFkaXVzO3RoaXMuX2FkZEJvdW5kaW5nQm94TWFyZ2luKHIpfX0se2tleTpcImRpc3RhbmNlVG9Cb3JkZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3QmJnRoaXMucmVzaXplKHQpO3ZhciBpPXRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtyZXR1cm4gTWF0aC5taW4oTWF0aC5hYnModGhpcy53aWR0aC8yL01hdGguY29zKGUpKSxNYXRoLmFicyh0aGlzLmhlaWdodC8yL01hdGguc2luKGUpKSkraX19XSksaX0oeGwpO2Z1bmN0aW9uIENsKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIFNsPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9Q2woaSk7ZnVuY3Rpb24gaSh0LG8sbil7dmFyIHI7cmV0dXJuIFBvKHRoaXMsaSksKHI9ZS5jYWxsKHRoaXMsdCxvLG4pKS5sYWJlbE9mZnNldD0wLHIuc2VsZWN0ZWQ9ITEscn1yZXR1cm4gSW8oaSxbe2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dGhpcy5vcHRpb25zPXQsdm9pZCAwPT09ZSYmdm9pZCAwPT09aXx8dGhpcy5zZXRJbWFnZXMoZSxpKX19LHtrZXk6XCJzZXRJbWFnZXNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2UmJnRoaXMuc2VsZWN0ZWQ/KHRoaXMuaW1hZ2VPYmo9ZSx0aGlzLmltYWdlT2JqQWx0PXQpOih0aGlzLmltYWdlT2JqPXQsdGhpcy5pbWFnZU9iakFsdD1lKX19LHtrZXk6XCJzd2l0Y2hJbWFnZXNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10JiYhdGhpcy5zZWxlY3RlZHx8IXQmJnRoaXMuc2VsZWN0ZWQ7aWYodGhpcy5zZWxlY3RlZD10LHZvaWQgMCE9PXRoaXMuaW1hZ2VPYmpBbHQmJmUpe3ZhciBpPXRoaXMuaW1hZ2VPYmo7dGhpcy5pbWFnZU9iaj10aGlzLmltYWdlT2JqQWx0LHRoaXMuaW1hZ2VPYmpBbHQ9aX19fSx7a2V5OlwiX2dldEltYWdlUGFkZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9e3RvcDowLHJpZ2h0OjAsYm90dG9tOjAsbGVmdDowfTtpZih0aGlzLm9wdGlvbnMuaW1hZ2VQYWRkaW5nKXt2YXIgZT10aGlzLm9wdGlvbnMuaW1hZ2VQYWRkaW5nO1wib2JqZWN0XCI9PWRuKGUpPyh0LnRvcD1lLnRvcCx0LnJpZ2h0PWUucmlnaHQsdC5ib3R0b209ZS5ib3R0b20sdC5sZWZ0PWUubGVmdCk6KHQudG9wPWUsdC5yaWdodD1lLHQuYm90dG9tPWUsdC5sZWZ0PWUpfXJldHVybiB0fX0se2tleTpcIl9yZXNpemVJbWFnZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZTtpZighMT09PXRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMudXNlSW1hZ2VTaXplKXt2YXIgaT0xLG89MTt0aGlzLmltYWdlT2JqLndpZHRoJiZ0aGlzLmltYWdlT2JqLmhlaWdodCYmKHRoaXMuaW1hZ2VPYmoud2lkdGg+dGhpcy5pbWFnZU9iai5oZWlnaHQ/aT10aGlzLmltYWdlT2JqLndpZHRoL3RoaXMuaW1hZ2VPYmouaGVpZ2h0Om89dGhpcy5pbWFnZU9iai5oZWlnaHQvdGhpcy5pbWFnZU9iai53aWR0aCksdD0yKnRoaXMub3B0aW9ucy5zaXplKmksZT0yKnRoaXMub3B0aW9ucy5zaXplKm99ZWxzZXt2YXIgbj10aGlzLl9nZXRJbWFnZVBhZGRpbmcoKTt0PXRoaXMuaW1hZ2VPYmoud2lkdGgrbi5sZWZ0K24ucmlnaHQsZT10aGlzLmltYWdlT2JqLmhlaWdodCtuLnRvcCtuLmJvdHRvbX10aGlzLndpZHRoPXQsdGhpcy5oZWlnaHQ9ZSx0aGlzLnJhZGl1cz0uNSp0aGlzLndpZHRofX0se2tleTpcIl9kcmF3UmF3Q2lyY2xlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyl7dGhpcy5pbml0Q29udGV4dEZvckRyYXcodCxvKSx3dCh0LGUsaSxvLnNpemUpLHRoaXMucGVyZm9ybUZpbGwodCxvKX19LHtrZXk6XCJfZHJhd0ltYWdlQXRQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYoMCE9dGhpcy5pbWFnZU9iai53aWR0aCl7dC5nbG9iYWxBbHBoYT12b2lkIDAhPT1lLm9wYWNpdHk/ZS5vcGFjaXR5OjEsdGhpcy5lbmFibGVTaGFkb3codCxlKTt2YXIgaT0xOyEwPT09dGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5pbnRlcnBvbGF0aW9uJiYoaT10aGlzLmltYWdlT2JqLndpZHRoL3RoaXMud2lkdGgvdGhpcy5ib2R5LnZpZXcuc2NhbGUpO3ZhciBvPXRoaXMuX2dldEltYWdlUGFkZGluZygpLG49dGhpcy5sZWZ0K28ubGVmdCxyPXRoaXMudG9wK28udG9wLHM9dGhpcy53aWR0aC1vLmxlZnQtby5yaWdodCxhPXRoaXMuaGVpZ2h0LW8udG9wLW8uYm90dG9tO3RoaXMuaW1hZ2VPYmouZHJhd0ltYWdlQXRQb3NpdGlvbih0LGksbixyLHMsYSksdGhpcy5kaXNhYmxlU2hhZG93KHQsZSl9fX0se2tleTpcIl9kcmF3SW1hZ2VMYWJlbFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbil7dmFyIHI9MDtpZih2b2lkIDAhPT10aGlzLmhlaWdodCl7cj0uNSp0aGlzLmhlaWdodDt2YXIgcz10aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKHQsbyxuKTtzLmxpbmVDb3VudD49MSYmKHIrPXMuaGVpZ2h0LzIpfXZhciBhPWkrcjt0aGlzLm9wdGlvbnMubGFiZWwmJih0aGlzLmxhYmVsT2Zmc2V0PXIpLHRoaXMubGFiZWxNb2R1bGUuZHJhdyh0LGUsYSxvLG4sXCJoYW5naW5nXCIpfX1dKSxpfSh4bCk7ZnVuY3Rpb24gVGwodCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgTWw9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1UbChpKTtmdW5jdGlvbiBpKHQsbyxuKXt2YXIgcjtyZXR1cm4gUG8odGhpcyxpKSwocj1lLmNhbGwodGhpcyx0LG8sbikpLl9zZXRNYXJnaW5zKG4pLHJ9cmV0dXJuIElvKGksW3trZXk6XCJyZXNpemVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5zZWxlY3RlZCxpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp0aGlzLmhvdmVyO2lmKHRoaXMubmVlZHNSZWZyZXNoKGUsaSkpe3ZhciBvPXRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbCh0LGUsaSksbj1NYXRoLm1heChvLndpZHRoK3RoaXMubWFyZ2luLnJpZ2h0K3RoaXMubWFyZ2luLmxlZnQsby5oZWlnaHQrdGhpcy5tYXJnaW4udG9wK3RoaXMubWFyZ2luLmJvdHRvbSk7dGhpcy5vcHRpb25zLnNpemU9bi8yLHRoaXMud2lkdGg9bix0aGlzLmhlaWdodD1uLHRoaXMucmFkaXVzPXRoaXMud2lkdGgvMn19fSx7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXt0aGlzLnJlc2l6ZSh0LG8sbiksdGhpcy5sZWZ0PWUtdGhpcy53aWR0aC8yLHRoaXMudG9wPWktdGhpcy5oZWlnaHQvMix0aGlzLl9kcmF3UmF3Q2lyY2xlKHQsZSxpLHIpLHRoaXMudXBkYXRlQm91bmRpbmdCb3goZSxpKSx0aGlzLmxhYmVsTW9kdWxlLmRyYXcodCx0aGlzLmxlZnQrdGhpcy50ZXh0U2l6ZS53aWR0aC8yK3RoaXMubWFyZ2luLmxlZnQsaSxvLG4pfX0se2tleTpcInVwZGF0ZUJvdW5kaW5nQm94XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLmJvdW5kaW5nQm94LnRvcD1lLXRoaXMub3B0aW9ucy5zaXplLHRoaXMuYm91bmRpbmdCb3gubGVmdD10LXRoaXMub3B0aW9ucy5zaXplLHRoaXMuYm91bmRpbmdCb3gucmlnaHQ9dCt0aGlzLm9wdGlvbnMuc2l6ZSx0aGlzLmJvdW5kaW5nQm94LmJvdHRvbT1lK3RoaXMub3B0aW9ucy5zaXplfX0se2tleTpcImRpc3RhbmNlVG9Cb3JkZXJcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmdGhpcy5yZXNpemUodCksLjUqdGhpcy53aWR0aH19XSksaX0oU2wpO2Z1bmN0aW9uIFBsKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIERsPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9UGwoaSk7ZnVuY3Rpb24gaSh0LG8sbixyLHMpe3ZhciBhO3JldHVybiBQbyh0aGlzLGkpLChhPWUuY2FsbCh0aGlzLHQsbyxuKSkuc2V0SW1hZ2VzKHIscyksYX1yZXR1cm4gSW8oaSxbe2tleTpcInJlc2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLnNlbGVjdGVkLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnRoaXMuaG92ZXIsbz12b2lkIDA9PT10aGlzLmltYWdlT2JqLnNyY3x8dm9pZCAwPT09dGhpcy5pbWFnZU9iai53aWR0aHx8dm9pZCAwPT09dGhpcy5pbWFnZU9iai5oZWlnaHQ7aWYobyl7dmFyIG49Mip0aGlzLm9wdGlvbnMuc2l6ZTtyZXR1cm4gdGhpcy53aWR0aD1uLHRoaXMuaGVpZ2h0PW4sdm9pZCh0aGlzLnJhZGl1cz0uNSp0aGlzLndpZHRoKX10aGlzLm5lZWRzUmVmcmVzaChlLGkpJiZ0aGlzLl9yZXNpemVJbWFnZSgpfX0se2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7dGhpcy5zd2l0Y2hJbWFnZXMobyksdGhpcy5yZXNpemUoKTt2YXIgcz1lLGE9aTtcInRvcC1sZWZ0XCI9PT10aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4/KHRoaXMubGVmdD1lLHRoaXMudG9wPWkscys9dGhpcy53aWR0aC8yLGErPXRoaXMuaGVpZ2h0LzIpOih0aGlzLmxlZnQ9ZS10aGlzLndpZHRoLzIsdGhpcy50b3A9aS10aGlzLmhlaWdodC8yKSx0aGlzLl9kcmF3UmF3Q2lyY2xlKHQscyxhLHIpLHQuc2F2ZSgpLHQuY2xpcCgpLHRoaXMuX2RyYXdJbWFnZUF0UG9zaXRpb24odCxyKSx0LnJlc3RvcmUoKSx0aGlzLl9kcmF3SW1hZ2VMYWJlbCh0LHMsYSxvLG4pLHRoaXMudXBkYXRlQm91bmRpbmdCb3goZSxpKX19LHtrZXk6XCJ1cGRhdGVCb3VuZGluZ0JveFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7XCJ0b3AtbGVmdFwiPT09dGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luPyh0aGlzLmJvdW5kaW5nQm94LnRvcD1lLHRoaXMuYm91bmRpbmdCb3gubGVmdD10LHRoaXMuYm91bmRpbmdCb3gucmlnaHQ9dCsyKnRoaXMub3B0aW9ucy5zaXplLHRoaXMuYm91bmRpbmdCb3guYm90dG9tPWUrMip0aGlzLm9wdGlvbnMuc2l6ZSk6KHRoaXMuYm91bmRpbmdCb3gudG9wPWUtdGhpcy5vcHRpb25zLnNpemUsdGhpcy5ib3VuZGluZ0JveC5sZWZ0PXQtdGhpcy5vcHRpb25zLnNpemUsdGhpcy5ib3VuZGluZ0JveC5yaWdodD10K3RoaXMub3B0aW9ucy5zaXplLHRoaXMuYm91bmRpbmdCb3guYm90dG9tPWUrdGhpcy5vcHRpb25zLnNpemUpLHRoaXMuYm91bmRpbmdCb3gubGVmdD1NYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQpLHRoaXMuYm91bmRpbmdCb3gucmlnaHQ9TWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5yaWdodCx0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCt0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGgpLHRoaXMuYm91bmRpbmdCb3guYm90dG9tPU1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLHRoaXMuYm91bmRpbmdCb3guYm90dG9tK3RoaXMubGFiZWxPZmZzZXQpfX0se2tleTpcImRpc3RhbmNlVG9Cb3JkZXJcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmdGhpcy5yZXNpemUodCksLjUqdGhpcy53aWR0aH19XSksaX0oU2wpO2Z1bmN0aW9uIEJsKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIElsPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9QmwoaSk7ZnVuY3Rpb24gaSh0LG8sbil7cmV0dXJuIFBvKHRoaXMsaSksZS5jYWxsKHRoaXMsdCxvLG4pfXJldHVybiBJbyhpLFt7a2V5OlwicmVzaXplXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMuc2VsZWN0ZWQsaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dGhpcy5ob3ZlcixvPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTp7c2l6ZTp0aGlzLm9wdGlvbnMuc2l6ZX07aWYodGhpcy5uZWVkc1JlZnJlc2goZSxpKSl7dmFyIG4scjt0aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKHQsZSxpKTt2YXIgcz0yKm8uc2l6ZTt0aGlzLndpZHRoPW51bGwhPT0obj10aGlzLmN1c3RvbVNpemVXaWR0aCkmJnZvaWQgMCE9PW4/bjpzLHRoaXMuaGVpZ2h0PW51bGwhPT0ocj10aGlzLmN1c3RvbVNpemVIZWlnaHQpJiZ2b2lkIDAhPT1yP3I6cyx0aGlzLnJhZGl1cz0uNSp0aGlzLndpZHRofX19LHtrZXk6XCJfZHJhd1NoYXBlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIscyxhKXt2YXIgaCxkPXRoaXM7cmV0dXJuIHRoaXMucmVzaXplKHQscixzLGEpLHRoaXMubGVmdD1vLXRoaXMud2lkdGgvMix0aGlzLnRvcD1uLXRoaXMuaGVpZ2h0LzIsdGhpcy5pbml0Q29udGV4dEZvckRyYXcodCxhKSwoaD1lLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChPdCxoKT9PdFtoXTpmdW5jdGlvbih0KXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCxpPW5ldyBBcnJheShlPjE/ZS0xOjApLG89MTtvPGU7bysrKWlbby0xXT1hcmd1bWVudHNbb107Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZVtoXS5jYWxsKHQsaSl9KSh0LG8sbixhLnNpemUpLHRoaXMucGVyZm9ybUZpbGwodCxhKSx2b2lkIDAhPT10aGlzLm9wdGlvbnMuaWNvbiYmdm9pZCAwIT09dGhpcy5vcHRpb25zLmljb24uY29kZSYmKHQuZm9udD0ocj9cImJvbGQgXCI6XCJcIikrdGhpcy5oZWlnaHQvMitcInB4IFwiKyh0aGlzLm9wdGlvbnMuaWNvbi5mYWNlfHxcIkZvbnRBd2Vzb21lXCIpLHQuZmlsbFN0eWxlPXRoaXMub3B0aW9ucy5pY29uLmNvbG9yfHxcImJsYWNrXCIsdC50ZXh0QWxpZ249XCJjZW50ZXJcIix0LnRleHRCYXNlbGluZT1cIm1pZGRsZVwiLHQuZmlsbFRleHQodGhpcy5vcHRpb25zLmljb24uY29kZSxvLG4pKSx7ZHJhd0V4dGVybmFsTGFiZWw6ZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1kLm9wdGlvbnMubGFiZWwpe2QubGFiZWxNb2R1bGUuY2FsY3VsYXRlTGFiZWxTaXplKHQscixzLG8sbixcImhhbmdpbmdcIik7dmFyIGU9bisuNSpkLmhlaWdodCsuNSpkLmxhYmVsTW9kdWxlLnNpemUuaGVpZ2h0O2QubGFiZWxNb2R1bGUuZHJhdyh0LG8sZSxyLHMsXCJoYW5naW5nXCIpfWQudXBkYXRlQm91bmRpbmdCb3gobyxuKX19fX0se2tleTpcInVwZGF0ZUJvdW5kaW5nQm94XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLmJvdW5kaW5nQm94LnRvcD1lLXRoaXMub3B0aW9ucy5zaXplLHRoaXMuYm91bmRpbmdCb3gubGVmdD10LXRoaXMub3B0aW9ucy5zaXplLHRoaXMuYm91bmRpbmdCb3gucmlnaHQ9dCt0aGlzLm9wdGlvbnMuc2l6ZSx0aGlzLmJvdW5kaW5nQm94LmJvdHRvbT1lK3RoaXMub3B0aW9ucy5zaXplLHZvaWQgMCE9PXRoaXMub3B0aW9ucy5sYWJlbCYmdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoPjAmJih0aGlzLmJvdW5kaW5nQm94LmxlZnQ9TWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KSx0aGlzLmJvdW5kaW5nQm94LnJpZ2h0PU1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQrdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKSx0aGlzLmJvdW5kaW5nQm94LmJvdHRvbT1NYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSx0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSt0aGlzLmxhYmVsTW9kdWxlLnNpemUuaGVpZ2h0KSl9fV0pLGl9KHhsKTtmdW5jdGlvbiB6bCh0LGUpe3ZhciBpPXhuKHQpO2lmKHdvKXt2YXIgbz13byh0KTtlJiYobz1hcihvKS5jYWxsKG8sKGZ1bmN0aW9uKGUpe3JldHVybiBFbyh0LGUpLmVudW1lcmFibGV9KSkpLGkucHVzaC5hcHBseShpLG8pfXJldHVybiBpfWZ1bmN0aW9uIEZsKHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciBpLG89bnVsbCE9YXJndW1lbnRzW2VdP2FyZ3VtZW50c1tlXTp7fTtpZihlJTIpRG4oaT16bChPYmplY3QobyksITApKS5jYWxsKGksKGZ1bmN0aW9uKGUpe3pvKHQsZSxvW2VdKX0pKTtlbHNlIGlmKENvKVNvKHQsQ28obykpO2Vsc2V7dmFyIG47RG4obj16bChPYmplY3QobykpKS5jYWxsKG4sKGZ1bmN0aW9uKGUpe01vKHQsZSxFbyhvLGUpKX0pKX19cmV0dXJuIHR9ZnVuY3Rpb24gTmwodCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgQWw9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1ObChpKTtmdW5jdGlvbiBpKHQsbyxuLHIpe3ZhciBzO3JldHVybiBQbyh0aGlzLGkpLChzPWUuY2FsbCh0aGlzLHQsbyxuLHIpKS5jdHhSZW5kZXJlcj1yLHN9cmV0dXJuIElvKGksW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3RoaXMucmVzaXplKHQsbyxuLHIpLHRoaXMubGVmdD1lLXRoaXMud2lkdGgvMix0aGlzLnRvcD1pLXRoaXMuaGVpZ2h0LzIsdC5zYXZlKCk7dmFyIHM9dGhpcy5jdHhSZW5kZXJlcih7Y3R4OnQsaWQ6dGhpcy5vcHRpb25zLmlkLHg6ZSx5Omksc3RhdGU6e3NlbGVjdGVkOm8saG92ZXI6bn0sc3R5bGU6Rmwoe30sciksbGFiZWw6dGhpcy5vcHRpb25zLmxhYmVsfSk7aWYobnVsbCE9cy5kcmF3Tm9kZSYmcy5kcmF3Tm9kZSgpLHQucmVzdG9yZSgpLHMuZHJhd0V4dGVybmFsTGFiZWwpe3ZhciBhPXMuZHJhd0V4dGVybmFsTGFiZWw7cy5kcmF3RXh0ZXJuYWxMYWJlbD1mdW5jdGlvbigpe3Quc2F2ZSgpLGEoKSx0LnJlc3RvcmUoKX19cmV0dXJuIHMubm9kZURpbWVuc2lvbnMmJih0aGlzLmN1c3RvbVNpemVXaWR0aD1zLm5vZGVEaW1lbnNpb25zLndpZHRoLHRoaXMuY3VzdG9tU2l6ZUhlaWdodD1zLm5vZGVEaW1lbnNpb25zLmhlaWdodCksc319LHtrZXk6XCJkaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcih0LGUpfX1dKSxpfShJbCk7ZnVuY3Rpb24gUmwodCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgamw9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1SbChpKTtmdW5jdGlvbiBpKHQsbyxuKXt2YXIgcjtyZXR1cm4gUG8odGhpcyxpKSwocj1lLmNhbGwodGhpcyx0LG8sbikpLl9zZXRNYXJnaW5zKG4pLHJ9cmV0dXJuIElvKGksW3trZXk6XCJyZXNpemVcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7aWYodGhpcy5uZWVkc1JlZnJlc2goZSxpKSl7dmFyIG89dGhpcy5nZXREaW1lbnNpb25zRnJvbUxhYmVsKHQsZSxpKS53aWR0aCt0aGlzLm1hcmdpbi5yaWdodCt0aGlzLm1hcmdpbi5sZWZ0O3RoaXMud2lkdGg9byx0aGlzLmhlaWdodD1vLHRoaXMucmFkaXVzPXRoaXMud2lkdGgvMn19fSx7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXt0aGlzLnJlc2l6ZSh0LG8sbiksdGhpcy5sZWZ0PWUtdGhpcy53aWR0aC8yLHRoaXMudG9wPWktdGhpcy5oZWlnaHQvMix0aGlzLmluaXRDb250ZXh0Rm9yRHJhdyh0LHIpLHh0KHQsZS10aGlzLndpZHRoLzIsaS10aGlzLmhlaWdodC8yLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMucGVyZm9ybUZpbGwodCxyKSx0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KGUsaSx0LG8sbiksdGhpcy5sYWJlbE1vZHVsZS5kcmF3KHQsdGhpcy5sZWZ0K3RoaXMudGV4dFNpemUud2lkdGgvMit0aGlzLm1hcmdpbi5sZWZ0LHRoaXMudG9wK3RoaXMudGV4dFNpemUuaGVpZ2h0LzIrdGhpcy5tYXJnaW4udG9wLG8sbil9fSx7a2V5OlwiZGlzdGFuY2VUb0JvcmRlclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIodCxlKX19XSksaX0oeGwpO2Z1bmN0aW9uIExsKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIEhsPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9TGwoaSk7ZnVuY3Rpb24gaSh0LG8sbil7cmV0dXJuIFBvKHRoaXMsaSksZS5jYWxsKHRoaXMsdCxvLG4pfXJldHVybiBJbyhpLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXtyZXR1cm4gdGhpcy5fZHJhd1NoYXBlKHQsXCJkaWFtb25kXCIsNCxlLGksbyxuLHIpfX0se2tleTpcImRpc3RhbmNlVG9Cb3JkZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKHQsZSl9fV0pLGl9KElsKTtmdW5jdGlvbiBXbCh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciBWbD1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPVdsKGkpO2Z1bmN0aW9uIGkodCxvLG4pe3JldHVybiBQbyh0aGlzLGkpLGUuY2FsbCh0aGlzLHQsbyxuKX1yZXR1cm4gSW8oaSxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7cmV0dXJuIHRoaXMuX2RyYXdTaGFwZSh0LFwiY2lyY2xlXCIsMixlLGksbyxuLHIpfX0se2tleTpcImRpc3RhbmNlVG9Cb3JkZXJcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmdGhpcy5yZXNpemUodCksdGhpcy5vcHRpb25zLnNpemV9fV0pLGl9KElsKTtmdW5jdGlvbiBxbCh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciBVbD1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPXFsKGkpO2Z1bmN0aW9uIGkodCxvLG4pe3JldHVybiBQbyh0aGlzLGkpLGUuY2FsbCh0aGlzLHQsbyxuKX1yZXR1cm4gSW8oaSxbe2tleTpcInJlc2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLnNlbGVjdGVkLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnRoaXMuaG92ZXI7aWYodGhpcy5uZWVkc1JlZnJlc2goZSxpKSl7dmFyIG89dGhpcy5nZXREaW1lbnNpb25zRnJvbUxhYmVsKHQsZSxpKTt0aGlzLmhlaWdodD0yKm8uaGVpZ2h0LHRoaXMud2lkdGg9by53aWR0aCtvLmhlaWdodCx0aGlzLnJhZGl1cz0uNSp0aGlzLndpZHRofX19LHtrZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3RoaXMucmVzaXplKHQsbyxuKSx0aGlzLmxlZnQ9ZS0uNSp0aGlzLndpZHRoLHRoaXMudG9wPWktLjUqdGhpcy5oZWlnaHQsdGhpcy5pbml0Q29udGV4dEZvckRyYXcodCxyKSxfdCh0LHRoaXMubGVmdCx0aGlzLnRvcCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLnBlcmZvcm1GaWxsKHQsciksdGhpcy51cGRhdGVCb3VuZGluZ0JveChlLGksdCxvLG4pLHRoaXMubGFiZWxNb2R1bGUuZHJhdyh0LGUsaSxvLG4pfX0se2tleTpcImRpc3RhbmNlVG9Cb3JkZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3QmJnRoaXMucmVzaXplKHQpO3ZhciBpPS41KnRoaXMud2lkdGgsbz0uNSp0aGlzLmhlaWdodCxuPU1hdGguc2luKGUpKmkscj1NYXRoLmNvcyhlKSpvO3JldHVybiBpKm8vTWF0aC5zcXJ0KG4qbityKnIpfX1dKSxpfSh4bCk7ZnVuY3Rpb24gWWwodCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgWGw9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1ZbChpKTtmdW5jdGlvbiBpKHQsbyxuKXt2YXIgcjtyZXR1cm4gUG8odGhpcyxpKSwocj1lLmNhbGwodGhpcyx0LG8sbikpLl9zZXRNYXJnaW5zKG4pLHJ9cmV0dXJuIElvKGksW3trZXk6XCJyZXNpemVcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dGhpcy5uZWVkc1JlZnJlc2goZSxpKSYmKHRoaXMuaWNvblNpemU9e3dpZHRoOk51bWJlcih0aGlzLm9wdGlvbnMuaWNvbi5zaXplKSxoZWlnaHQ6TnVtYmVyKHRoaXMub3B0aW9ucy5pY29uLnNpemUpfSx0aGlzLndpZHRoPXRoaXMuaWNvblNpemUud2lkdGgrdGhpcy5tYXJnaW4ucmlnaHQrdGhpcy5tYXJnaW4ubGVmdCx0aGlzLmhlaWdodD10aGlzLmljb25TaXplLmhlaWdodCt0aGlzLm1hcmdpbi50b3ArdGhpcy5tYXJnaW4uYm90dG9tLHRoaXMucmFkaXVzPS41KnRoaXMud2lkdGgpfX0se2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7dmFyIHM9dGhpcztyZXR1cm4gdGhpcy5yZXNpemUodCxvLG4pLHRoaXMub3B0aW9ucy5pY29uLnNpemU9dGhpcy5vcHRpb25zLmljb24uc2l6ZXx8NTAsdGhpcy5sZWZ0PWUtdGhpcy53aWR0aC8yLHRoaXMudG9wPWktdGhpcy5oZWlnaHQvMix0aGlzLl9pY29uKHQsZSxpLG8sbixyKSx7ZHJhd0V4dGVybmFsTGFiZWw6ZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1zLm9wdGlvbnMubGFiZWwpe3MubGFiZWxNb2R1bGUuZHJhdyh0LHMubGVmdCtzLmljb25TaXplLndpZHRoLzIrcy5tYXJnaW4ubGVmdCxpK3MuaGVpZ2h0LzIrNSxvKX1zLnVwZGF0ZUJvdW5kaW5nQm94KGUsaSl9fX19LHtrZXk6XCJ1cGRhdGVCb3VuZGluZ0JveFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYodGhpcy5ib3VuZGluZ0JveC50b3A9ZS0uNSp0aGlzLm9wdGlvbnMuaWNvbi5zaXplLHRoaXMuYm91bmRpbmdCb3gubGVmdD10LS41KnRoaXMub3B0aW9ucy5pY29uLnNpemUsdGhpcy5ib3VuZGluZ0JveC5yaWdodD10Ky41KnRoaXMub3B0aW9ucy5pY29uLnNpemUsdGhpcy5ib3VuZGluZ0JveC5ib3R0b209ZSsuNSp0aGlzLm9wdGlvbnMuaWNvbi5zaXplLHZvaWQgMCE9PXRoaXMub3B0aW9ucy5sYWJlbCYmdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoPjApe3RoaXMuYm91bmRpbmdCb3gubGVmdD1NYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQpLHRoaXMuYm91bmRpbmdCb3gucmlnaHQ9TWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5yaWdodCx0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCt0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGgpLHRoaXMuYm91bmRpbmdCb3guYm90dG9tPU1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLHRoaXMuYm91bmRpbmdCb3guYm90dG9tK3RoaXMubGFiZWxNb2R1bGUuc2l6ZS5oZWlnaHQrNSl9fX0se2tleTpcIl9pY29uXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3ZhciBzPU51bWJlcih0aGlzLm9wdGlvbnMuaWNvbi5zaXplKTt2b2lkIDAhPT10aGlzLm9wdGlvbnMuaWNvbi5jb2RlPyh0LmZvbnQ9W251bGwhPXRoaXMub3B0aW9ucy5pY29uLndlaWdodD90aGlzLm9wdGlvbnMuaWNvbi53ZWlnaHQ6bz9cImJvbGRcIjpcIlwiLChudWxsIT10aGlzLm9wdGlvbnMuaWNvbi53ZWlnaHQmJm8/NTowKStzK1wicHhcIix0aGlzLm9wdGlvbnMuaWNvbi5mYWNlXS5qb2luKFwiIFwiKSx0LmZpbGxTdHlsZT10aGlzLm9wdGlvbnMuaWNvbi5jb2xvcnx8XCJibGFja1wiLHQudGV4dEFsaWduPVwiY2VudGVyXCIsdC50ZXh0QmFzZWxpbmU9XCJtaWRkbGVcIix0aGlzLmVuYWJsZVNoYWRvdyh0LHIpLHQuZmlsbFRleHQodGhpcy5vcHRpb25zLmljb24uY29kZSxlLGkpLHRoaXMuZGlzYWJsZVNoYWRvdyh0LHIpKTpjb25zb2xlLmVycm9yKFwiV2hlbiB1c2luZyB0aGUgaWNvbiBzaGFwZSwgeW91IG5lZWQgdG8gZGVmaW5lIHRoZSBjb2RlIGluIHRoZSBpY29uIG9wdGlvbnMgb2JqZWN0LiBUaGlzIGNhbiBiZSBkb25lIHBlciBub2RlIG9yIGdsb2JhbGx5LlwiKX19LHtrZXk6XCJkaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcih0LGUpfX1dKSxpfSh4bCk7ZnVuY3Rpb24gR2wodCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgS2w9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1HbChpKTtmdW5jdGlvbiBpKHQsbyxuLHIscyl7dmFyIGE7cmV0dXJuIFBvKHRoaXMsaSksKGE9ZS5jYWxsKHRoaXMsdCxvLG4pKS5zZXRJbWFnZXMocixzKSxhfXJldHVybiBJbyhpLFt7a2V5OlwicmVzaXplXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMuc2VsZWN0ZWQsaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dGhpcy5ob3ZlcixvPXZvaWQgMD09PXRoaXMuaW1hZ2VPYmouc3JjfHx2b2lkIDA9PT10aGlzLmltYWdlT2JqLndpZHRofHx2b2lkIDA9PT10aGlzLmltYWdlT2JqLmhlaWdodDtpZihvKXt2YXIgbj0yKnRoaXMub3B0aW9ucy5zaXplO3JldHVybiB0aGlzLndpZHRoPW4sdm9pZCh0aGlzLmhlaWdodD1uKX10aGlzLm5lZWRzUmVmcmVzaChlLGkpJiZ0aGlzLl9yZXNpemVJbWFnZSgpfX0se2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7dC5zYXZlKCksdGhpcy5zd2l0Y2hJbWFnZXMobyksdGhpcy5yZXNpemUoKTt2YXIgcz1lLGE9aTtpZihcInRvcC1sZWZ0XCI9PT10aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4/KHRoaXMubGVmdD1lLHRoaXMudG9wPWkscys9dGhpcy53aWR0aC8yLGErPXRoaXMuaGVpZ2h0LzIpOih0aGlzLmxlZnQ9ZS10aGlzLndpZHRoLzIsdGhpcy50b3A9aS10aGlzLmhlaWdodC8yKSwhMD09PXRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMudXNlQm9yZGVyV2l0aEltYWdlKXt2YXIgaD10aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgsZD10aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGhTZWxlY3RlZHx8Mip0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgsbD0obz9kOmgpL3RoaXMuYm9keS52aWV3LnNjYWxlO3QubGluZVdpZHRoPU1hdGgubWluKHRoaXMud2lkdGgsbCksdC5iZWdpblBhdGgoKTt2YXIgYz1vP3RoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyOm4/dGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlcjp0aGlzLm9wdGlvbnMuY29sb3IuYm9yZGVyLHU9bz90aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQ6bj90aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZDp0aGlzLm9wdGlvbnMuY29sb3IuYmFja2dyb3VuZDt2b2lkIDAhPT1yLm9wYWNpdHkmJihjPXNoKGMsci5vcGFjaXR5KSx1PXNoKHUsci5vcGFjaXR5KSksdC5zdHJva2VTdHlsZT1jLHQuZmlsbFN0eWxlPXUsdC5yZWN0KHRoaXMubGVmdC0uNSp0LmxpbmVXaWR0aCx0aGlzLnRvcC0uNSp0LmxpbmVXaWR0aCx0aGlzLndpZHRoK3QubGluZVdpZHRoLHRoaXMuaGVpZ2h0K3QubGluZVdpZHRoKSxYcih0KS5jYWxsKHQpLHRoaXMucGVyZm9ybVN0cm9rZSh0LHIpLHQuY2xvc2VQYXRoKCl9dGhpcy5fZHJhd0ltYWdlQXRQb3NpdGlvbih0LHIpLHRoaXMuX2RyYXdJbWFnZUxhYmVsKHQscyxhLG8sbiksdGhpcy51cGRhdGVCb3VuZGluZ0JveChlLGkpLHQucmVzdG9yZSgpfX0se2tleTpcInVwZGF0ZUJvdW5kaW5nQm94XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLnJlc2l6ZSgpLFwidG9wLWxlZnRcIj09PXRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuY29vcmRpbmF0ZU9yaWdpbj8odGhpcy5sZWZ0PXQsdGhpcy50b3A9ZSk6KHRoaXMubGVmdD10LXRoaXMud2lkdGgvMix0aGlzLnRvcD1lLXRoaXMuaGVpZ2h0LzIpLHRoaXMuYm91bmRpbmdCb3gubGVmdD10aGlzLmxlZnQsdGhpcy5ib3VuZGluZ0JveC50b3A9dGhpcy50b3AsdGhpcy5ib3VuZGluZ0JveC5ib3R0b209dGhpcy50b3ArdGhpcy5oZWlnaHQsdGhpcy5ib3VuZGluZ0JveC5yaWdodD10aGlzLmxlZnQrdGhpcy53aWR0aCx2b2lkIDAhPT10aGlzLm9wdGlvbnMubGFiZWwmJnRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aD4wJiYodGhpcy5ib3VuZGluZ0JveC5sZWZ0PU1hdGgubWluKHRoaXMuYm91bmRpbmdCb3gubGVmdCx0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCksdGhpcy5ib3VuZGluZ0JveC5yaWdodD1NYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0K3RoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCksdGhpcy5ib3VuZGluZ0JveC5ib3R0b209TWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sdGhpcy5ib3VuZGluZ0JveC5ib3R0b20rdGhpcy5sYWJlbE9mZnNldCkpfX0se2tleTpcImRpc3RhbmNlVG9Cb3JkZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKHQsZSl9fV0pLGl9KFNsKTtmdW5jdGlvbiAkbCh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciBRbD1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPSRsKGkpO2Z1bmN0aW9uIGkodCxvLG4pe3JldHVybiBQbyh0aGlzLGkpLGUuY2FsbCh0aGlzLHQsbyxuKX1yZXR1cm4gSW8oaSxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7cmV0dXJuIHRoaXMuX2RyYXdTaGFwZSh0LFwic3F1YXJlXCIsMixlLGksbyxuLHIpfX0se2tleTpcImRpc3RhbmNlVG9Cb3JkZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKHQsZSl9fV0pLGl9KElsKTtmdW5jdGlvbiBabCh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciBKbD1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPVpsKGkpO2Z1bmN0aW9uIGkodCxvLG4pe3JldHVybiBQbyh0aGlzLGkpLGUuY2FsbCh0aGlzLHQsbyxuKX1yZXR1cm4gSW8oaSxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7cmV0dXJuIHRoaXMuX2RyYXdTaGFwZSh0LFwiaGV4YWdvblwiLDQsZSxpLG8sbixyKX19LHtrZXk6XCJkaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcih0LGUpfX1dKSxpfShJbCk7ZnVuY3Rpb24gdGModCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgZWM9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT10YyhpKTtmdW5jdGlvbiBpKHQsbyxuKXtyZXR1cm4gUG8odGhpcyxpKSxlLmNhbGwodGhpcyx0LG8sbil9cmV0dXJuIElvKGksW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3JldHVybiB0aGlzLl9kcmF3U2hhcGUodCxcInN0YXJcIiw0LGUsaSxvLG4scil9fSx7a2V5OlwiZGlzdGFuY2VUb0JvcmRlclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIodCxlKX19XSksaX0oSWwpO2Z1bmN0aW9uIGljKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIG9jPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9aWMoaSk7ZnVuY3Rpb24gaSh0LG8sbil7dmFyIHI7cmV0dXJuIFBvKHRoaXMsaSksKHI9ZS5jYWxsKHRoaXMsdCxvLG4pKS5fc2V0TWFyZ2lucyhuKSxyfXJldHVybiBJbyhpLFt7a2V5OlwicmVzaXplXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3RoaXMubmVlZHNSZWZyZXNoKGUsaSkmJih0aGlzLnRleHRTaXplPXRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUodCxlLGkpLHRoaXMud2lkdGg9dGhpcy50ZXh0U2l6ZS53aWR0aCt0aGlzLm1hcmdpbi5yaWdodCt0aGlzLm1hcmdpbi5sZWZ0LHRoaXMuaGVpZ2h0PXRoaXMudGV4dFNpemUuaGVpZ2h0K3RoaXMubWFyZ2luLnRvcCt0aGlzLm1hcmdpbi5ib3R0b20sdGhpcy5yYWRpdXM9LjUqdGhpcy53aWR0aCl9fSx7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXt0aGlzLnJlc2l6ZSh0LG8sbiksdGhpcy5sZWZ0PWUtdGhpcy53aWR0aC8yLHRoaXMudG9wPWktdGhpcy5oZWlnaHQvMix0aGlzLmVuYWJsZVNoYWRvdyh0LHIpLHRoaXMubGFiZWxNb2R1bGUuZHJhdyh0LHRoaXMubGVmdCt0aGlzLnRleHRTaXplLndpZHRoLzIrdGhpcy5tYXJnaW4ubGVmdCx0aGlzLnRvcCt0aGlzLnRleHRTaXplLmhlaWdodC8yK3RoaXMubWFyZ2luLnRvcCxvLG4pLHRoaXMuZGlzYWJsZVNoYWRvdyh0LHIpLHRoaXMudXBkYXRlQm91bmRpbmdCb3goZSxpLHQsbyxuKX19LHtrZXk6XCJkaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcih0LGUpfX1dKSxpfSh4bCk7ZnVuY3Rpb24gbmModCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgcmM9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1uYyhpKTtmdW5jdGlvbiBpKHQsbyxuKXtyZXR1cm4gUG8odGhpcyxpKSxlLmNhbGwodGhpcyx0LG8sbil9cmV0dXJuIElvKGksW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3JldHVybiB0aGlzLl9kcmF3U2hhcGUodCxcInRyaWFuZ2xlXCIsMyxlLGksbyxuLHIpfX0se2tleTpcImRpc3RhbmNlVG9Cb3JkZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKHQsZSl9fV0pLGl9KElsKTtmdW5jdGlvbiBzYyh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciBhYz1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPXNjKGkpO2Z1bmN0aW9uIGkodCxvLG4pe3JldHVybiBQbyh0aGlzLGkpLGUuY2FsbCh0aGlzLHQsbyxuKX1yZXR1cm4gSW8oaSxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7cmV0dXJuIHRoaXMuX2RyYXdTaGFwZSh0LFwidHJpYW5nbGVEb3duXCIsMyxlLGksbyxuLHIpfX0se2tleTpcImRpc3RhbmNlVG9Cb3JkZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKHQsZSl9fV0pLGl9KElsKTtmdW5jdGlvbiBoYyh0LGUpe3ZhciBpPXhuKHQpO2lmKHdvKXt2YXIgbz13byh0KTtlJiYobz1hcihvKS5jYWxsKG8sKGZ1bmN0aW9uKGUpe3JldHVybiBFbyh0LGUpLmVudW1lcmFibGV9KSkpLGkucHVzaC5hcHBseShpLG8pfXJldHVybiBpfWZ1bmN0aW9uIGRjKHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciBpLG89bnVsbCE9YXJndW1lbnRzW2VdP2FyZ3VtZW50c1tlXTp7fTtpZihlJTIpRG4oaT1oYyhPYmplY3QobyksITApKS5jYWxsKGksKGZ1bmN0aW9uKGUpe3pvKHQsZSxvW2VdKX0pKTtlbHNlIGlmKENvKVNvKHQsQ28obykpO2Vsc2V7dmFyIG47RG4obj1oYyhPYmplY3QobykpKS5jYWxsKG4sKGZ1bmN0aW9uKGUpe01vKHQsZSxFbyhvLGUpKX0pKX19cmV0dXJuIHR9dmFyIGxjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLGksbyxuLHIscyl7UG8odGhpcyx0KSx0aGlzLm9wdGlvbnM9dmgociksdGhpcy5nbG9iYWxPcHRpb25zPXIsdGhpcy5kZWZhdWx0T3B0aW9ucz1zLHRoaXMuYm9keT1pLHRoaXMuZWRnZXM9W10sdGhpcy5pZD12b2lkIDAsdGhpcy5pbWFnZWxpc3Q9byx0aGlzLmdyb3VwbGlzdD1uLHRoaXMueD12b2lkIDAsdGhpcy55PXZvaWQgMCx0aGlzLmJhc2VTaXplPXRoaXMub3B0aW9ucy5zaXplLHRoaXMuYmFzZUZvbnRTaXplPXRoaXMub3B0aW9ucy5mb250LnNpemUsdGhpcy5wcmVkZWZpbmVkUG9zaXRpb249ITEsdGhpcy5zZWxlY3RlZD0hMSx0aGlzLmhvdmVyPSExLHRoaXMubGFiZWxNb2R1bGU9bmV3IGxsKHRoaXMuYm9keSx0aGlzLm9wdGlvbnMsITEpLHRoaXMuc2V0T3B0aW9ucyhlKX1yZXR1cm4gSW8odCxbe2tleTpcImF0dGFjaEVkZ2VcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZTstMT09PU1yKGU9dGhpcy5lZGdlcykuY2FsbChlLHQpJiZ0aGlzLmVkZ2VzLnB1c2godCl9fSx7a2V5OlwiZGV0YWNoRWRnZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlLGksbz1NcihlPXRoaXMuZWRnZXMpLmNhbGwoZSx0KTstMSE9byYmcW4oaT10aGlzLmVkZ2VzKS5jYWxsKGksbywxKX19LHtrZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIGk9dGhpcy5vcHRpb25zLnNoYXBlO2lmKGUpe2lmKHZvaWQgMCE9PWUuY29sb3ImJih0aGlzLl9sb2NhbENvbG9yPWUuY29sb3IpLHZvaWQgMCE9PWUuaWQmJih0aGlzLmlkPWUuaWQpLHZvaWQgMD09PXRoaXMuaWQpdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBtdXN0IGhhdmUgYW4gaWRcIik7dC5jaGVja01hc3MoZSx0aGlzLmlkKSx2b2lkIDAhPT1lLngmJihudWxsPT09ZS54Pyh0aGlzLng9dm9pZCAwLHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uPSExKToodGhpcy54PWtyKGUueCksdGhpcy5wcmVkZWZpbmVkUG9zaXRpb249ITApKSx2b2lkIDAhPT1lLnkmJihudWxsPT09ZS55Pyh0aGlzLnk9dm9pZCAwLHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uPSExKToodGhpcy55PWtyKGUueSksdGhpcy5wcmVkZWZpbmVkUG9zaXRpb249ITApKSx2b2lkIDAhPT1lLnNpemUmJih0aGlzLmJhc2VTaXplPWUuc2l6ZSksdm9pZCAwIT09ZS52YWx1ZSYmKGUudmFsdWU9WWQoZS52YWx1ZSkpLHQucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucyxlLCEwLHRoaXMuZ2xvYmFsT3B0aW9ucyx0aGlzLmdyb3VwbGlzdCk7dmFyIG89W2UsdGhpcy5vcHRpb25zLHRoaXMuZGVmYXVsdE9wdGlvbnNdO3JldHVybiB0aGlzLmNob29zZXI9UWQoXCJub2RlXCIsbyksdGhpcy5fbG9hZF9pbWFnZXMoKSx0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKGUpLHZvaWQgMCE9PWUub3BhY2l0eSYmdC5jaGVja09wYWNpdHkoZS5vcGFjaXR5KSYmKHRoaXMub3B0aW9ucy5vcGFjaXR5PWUub3BhY2l0eSksdGhpcy51cGRhdGVTaGFwZShpKSx2b2lkIDAhPT1lLmhpZGRlbnx8dm9pZCAwIT09ZS5waHlzaWNzfX19LHtrZXk6XCJfbG9hZF9pbWFnZXNcIix2YWx1ZTpmdW5jdGlvbigpe2lmKChcImNpcmN1bGFySW1hZ2VcIj09PXRoaXMub3B0aW9ucy5zaGFwZXx8XCJpbWFnZVwiPT09dGhpcy5vcHRpb25zLnNoYXBlKSYmdm9pZCAwPT09dGhpcy5vcHRpb25zLmltYWdlKXRocm93IG5ldyBFcnJvcihcIk9wdGlvbiBpbWFnZSBtdXN0IGJlIGRlZmluZWQgZm9yIG5vZGUgdHlwZSAnXCIrdGhpcy5vcHRpb25zLnNoYXBlK1wiJ1wiKTtpZih2b2lkIDAhPT10aGlzLm9wdGlvbnMuaW1hZ2Upe2lmKHZvaWQgMD09PXRoaXMuaW1hZ2VsaXN0KXRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEVycm9yOiBObyBpbWFnZXMgcHJvdmlkZWRcIik7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHRoaXMub3B0aW9ucy5pbWFnZSl0aGlzLmltYWdlT2JqPXRoaXMuaW1hZ2VsaXN0LmxvYWQodGhpcy5vcHRpb25zLmltYWdlLHRoaXMub3B0aW9ucy5icm9rZW5JbWFnZSx0aGlzLmlkKTtlbHNle2lmKHZvaWQgMD09PXRoaXMub3B0aW9ucy5pbWFnZS51bnNlbGVjdGVkKXRocm93IG5ldyBFcnJvcihcIk5vIHVuc2VsZWN0ZWQgaW1hZ2UgcHJvdmlkZWRcIik7dGhpcy5pbWFnZU9iaj10aGlzLmltYWdlbGlzdC5sb2FkKHRoaXMub3B0aW9ucy5pbWFnZS51bnNlbGVjdGVkLHRoaXMub3B0aW9ucy5icm9rZW5JbWFnZSx0aGlzLmlkKSx2b2lkIDAhPT10aGlzLm9wdGlvbnMuaW1hZ2Uuc2VsZWN0ZWQ/dGhpcy5pbWFnZU9iakFsdD10aGlzLmltYWdlbGlzdC5sb2FkKHRoaXMub3B0aW9ucy5pbWFnZS5zZWxlY3RlZCx0aGlzLm9wdGlvbnMuYnJva2VuSW1hZ2UsdGhpcy5pZCk6dGhpcy5pbWFnZU9iakFsdD12b2lkIDB9fX19LHtrZXk6XCJnZXRGb3JtYXR0aW5nVmFsdWVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD17Y29sb3I6dGhpcy5vcHRpb25zLmNvbG9yLmJhY2tncm91bmQsb3BhY2l0eTp0aGlzLm9wdGlvbnMub3BhY2l0eSxib3JkZXJXaWR0aDp0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgsYm9yZGVyQ29sb3I6dGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcixzaXplOnRoaXMub3B0aW9ucy5zaXplLGJvcmRlckRhc2hlczp0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlcyxib3JkZXJSYWRpdXM6dGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJSYWRpdXMsc2hhZG93OnRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZCxzaGFkb3dDb2xvcjp0aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yLHNoYWRvd1NpemU6dGhpcy5vcHRpb25zLnNoYWRvdy5zaXplLHNoYWRvd1g6dGhpcy5vcHRpb25zLnNoYWRvdy54LHNoYWRvd1k6dGhpcy5vcHRpb25zLnNoYWRvdy55fTtpZih0aGlzLnNlbGVjdGVkfHx0aGlzLmhvdmVyPyEwPT09dGhpcy5jaG9vc2VyP3RoaXMuc2VsZWN0ZWQ/KG51bGwhPXRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aFNlbGVjdGVkP3QuYm9yZGVyV2lkdGg9dGhpcy5vcHRpb25zLmJvcmRlcldpZHRoU2VsZWN0ZWQ6dC5ib3JkZXJXaWR0aCo9Mix0LmNvbG9yPXRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCx0LmJvcmRlckNvbG9yPXRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyLHQuc2hhZG93PXRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZCk6dGhpcy5ob3ZlciYmKHQuY29sb3I9dGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJhY2tncm91bmQsdC5ib3JkZXJDb2xvcj10aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYm9yZGVyLHQuc2hhZG93PXRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZCk6XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5jaG9vc2VyJiYodGhpcy5jaG9vc2VyKHQsdGhpcy5vcHRpb25zLmlkLHRoaXMuc2VsZWN0ZWQsdGhpcy5ob3ZlciksITE9PT10LnNoYWRvdyYmKHQuc2hhZG93Q29sb3I9PT10aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yJiZ0LnNoYWRvd1NpemU9PT10aGlzLm9wdGlvbnMuc2hhZG93LnNpemUmJnQuc2hhZG93WD09PXRoaXMub3B0aW9ucy5zaGFkb3cueCYmdC5zaGFkb3dZPT09dGhpcy5vcHRpb25zLnNoYWRvdy55fHwodC5zaGFkb3c9ITApKSk6dC5zaGFkb3c9dGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkLHZvaWQgMCE9PXRoaXMub3B0aW9ucy5vcGFjaXR5KXt2YXIgZT10aGlzLm9wdGlvbnMub3BhY2l0eTt0LmJvcmRlckNvbG9yPXNoKHQuYm9yZGVyQ29sb3IsZSksdC5jb2xvcj1zaCh0LmNvbG9yLGUpLHQuc2hhZG93Q29sb3I9c2godC5zaGFkb3dDb2xvcixlKX1yZXR1cm4gdH19LHtrZXk6XCJ1cGRhdGVMYWJlbE1vZHVsZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZvaWQgMCE9PXRoaXMub3B0aW9ucy5sYWJlbCYmbnVsbCE9PXRoaXMub3B0aW9ucy5sYWJlbHx8KHRoaXMub3B0aW9ucy5sYWJlbD1cIlwiKSx0LnVwZGF0ZUdyb3VwT3B0aW9ucyh0aGlzLm9wdGlvbnMsZGMoZGMoe30sZSkse30se2NvbG9yOmUmJmUuY29sb3J8fHRoaXMuX2xvY2FsQ29sb3J8fHZvaWQgMH0pLHRoaXMuZ3JvdXBsaXN0KTt2YXIgaT10aGlzLmdyb3VwbGlzdC5nZXQodGhpcy5vcHRpb25zLmdyb3VwLCExKSxvPVtlLHRoaXMub3B0aW9ucyxpLHRoaXMuZ2xvYmFsT3B0aW9ucyx0aGlzLmRlZmF1bHRPcHRpb25zXTt0aGlzLmxhYmVsTW9kdWxlLnVwZGF0ZSh0aGlzLm9wdGlvbnMsbyksdm9pZCAwIT09dGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZSYmKHRoaXMuYmFzZUZvbnRTaXplPXRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemUpfX0se2tleTpcInVwZGF0ZVNoYXBlXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodD09PXRoaXMub3B0aW9ucy5zaGFwZSYmdGhpcy5zaGFwZSl0aGlzLnNoYXBlLnNldE9wdGlvbnModGhpcy5vcHRpb25zLHRoaXMuaW1hZ2VPYmosdGhpcy5pbWFnZU9iakFsdCk7ZWxzZSBzd2l0Y2godGhpcy5vcHRpb25zLnNoYXBlKXtjYXNlXCJib3hcIjp0aGlzLnNoYXBlPW5ldyBPbCh0aGlzLm9wdGlvbnMsdGhpcy5ib2R5LHRoaXMubGFiZWxNb2R1bGUpO2JyZWFrO2Nhc2VcImNpcmNsZVwiOnRoaXMuc2hhcGU9bmV3IE1sKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSk7YnJlYWs7Y2FzZVwiY2lyY3VsYXJJbWFnZVwiOnRoaXMuc2hhcGU9bmV3IERsKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSx0aGlzLmltYWdlT2JqLHRoaXMuaW1hZ2VPYmpBbHQpO2JyZWFrO2Nhc2VcImN1c3RvbVwiOnRoaXMuc2hhcGU9bmV3IEFsKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSx0aGlzLm9wdGlvbnMuY3R4UmVuZGVyZXIpO2JyZWFrO2Nhc2VcImRhdGFiYXNlXCI6dGhpcy5zaGFwZT1uZXcgamwodGhpcy5vcHRpb25zLHRoaXMuYm9keSx0aGlzLmxhYmVsTW9kdWxlKTticmVhaztjYXNlXCJkaWFtb25kXCI6dGhpcy5zaGFwZT1uZXcgSGwodGhpcy5vcHRpb25zLHRoaXMuYm9keSx0aGlzLmxhYmVsTW9kdWxlKTticmVhaztjYXNlXCJkb3RcIjp0aGlzLnNoYXBlPW5ldyBWbCh0aGlzLm9wdGlvbnMsdGhpcy5ib2R5LHRoaXMubGFiZWxNb2R1bGUpO2JyZWFrO2Nhc2VcImVsbGlwc2VcIjp0aGlzLnNoYXBlPW5ldyBVbCh0aGlzLm9wdGlvbnMsdGhpcy5ib2R5LHRoaXMubGFiZWxNb2R1bGUpO2JyZWFrO2Nhc2VcImljb25cIjp0aGlzLnNoYXBlPW5ldyBYbCh0aGlzLm9wdGlvbnMsdGhpcy5ib2R5LHRoaXMubGFiZWxNb2R1bGUpO2JyZWFrO2Nhc2VcImltYWdlXCI6dGhpcy5zaGFwZT1uZXcgS2wodGhpcy5vcHRpb25zLHRoaXMuYm9keSx0aGlzLmxhYmVsTW9kdWxlLHRoaXMuaW1hZ2VPYmosdGhpcy5pbWFnZU9iakFsdCk7YnJlYWs7Y2FzZVwic3F1YXJlXCI6dGhpcy5zaGFwZT1uZXcgUWwodGhpcy5vcHRpb25zLHRoaXMuYm9keSx0aGlzLmxhYmVsTW9kdWxlKTticmVhaztjYXNlXCJoZXhhZ29uXCI6dGhpcy5zaGFwZT1uZXcgSmwodGhpcy5vcHRpb25zLHRoaXMuYm9keSx0aGlzLmxhYmVsTW9kdWxlKTticmVhaztjYXNlXCJzdGFyXCI6dGhpcy5zaGFwZT1uZXcgZWModGhpcy5vcHRpb25zLHRoaXMuYm9keSx0aGlzLmxhYmVsTW9kdWxlKTticmVhaztjYXNlXCJ0ZXh0XCI6dGhpcy5zaGFwZT1uZXcgb2ModGhpcy5vcHRpb25zLHRoaXMuYm9keSx0aGlzLmxhYmVsTW9kdWxlKTticmVhaztjYXNlXCJ0cmlhbmdsZVwiOnRoaXMuc2hhcGU9bmV3IHJjKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSk7YnJlYWs7Y2FzZVwidHJpYW5nbGVEb3duXCI6dGhpcy5zaGFwZT1uZXcgYWModGhpcy5vcHRpb25zLHRoaXMuYm9keSx0aGlzLmxhYmVsTW9kdWxlKTticmVhaztkZWZhdWx0OnRoaXMuc2hhcGU9bmV3IFVsKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSl9dGhpcy5uZWVkc1JlZnJlc2goKX19LHtrZXk6XCJzZWxlY3RcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2VsZWN0ZWQ9ITAsdGhpcy5uZWVkc1JlZnJlc2goKX19LHtrZXk6XCJ1bnNlbGVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zZWxlY3RlZD0hMSx0aGlzLm5lZWRzUmVmcmVzaCgpfX0se2tleTpcIm5lZWRzUmVmcmVzaFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zaGFwZS5yZWZyZXNoTmVlZGVkPSEwfX0se2tleTpcImdldFRpdGxlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25zLnRpdGxlfX0se2tleTpcImRpc3RhbmNlVG9Cb3JkZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnNoYXBlLmRpc3RhbmNlVG9Cb3JkZXIodCxlKX19LHtrZXk6XCJpc0ZpeGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25zLmZpeGVkLngmJnRoaXMub3B0aW9ucy5maXhlZC55fX0se2tleTpcImlzU2VsZWN0ZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbGVjdGVkfX0se2tleTpcImdldFZhbHVlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlfX0se2tleTpcImdldExhYmVsU2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWxNb2R1bGUuc2l6ZSgpfX0se2tleTpcInNldFZhbHVlUmFuZ2VcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7aWYodm9pZCAwIT09dGhpcy5vcHRpb25zLnZhbHVlKXt2YXIgbz10aGlzLm9wdGlvbnMuc2NhbGluZy5jdXN0b21TY2FsaW5nRnVuY3Rpb24odCxlLGksdGhpcy5vcHRpb25zLnZhbHVlKSxuPXRoaXMub3B0aW9ucy5zY2FsaW5nLm1heC10aGlzLm9wdGlvbnMuc2NhbGluZy5taW47aWYoITA9PT10aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5lbmFibGVkKXt2YXIgcj10aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXgtdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluO3RoaXMub3B0aW9ucy5mb250LnNpemU9dGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluK28qcn10aGlzLm9wdGlvbnMuc2l6ZT10aGlzLm9wdGlvbnMuc2NhbGluZy5taW4rbypufWVsc2UgdGhpcy5vcHRpb25zLnNpemU9dGhpcy5iYXNlU2l6ZSx0aGlzLm9wdGlvbnMuZm9udC5zaXplPXRoaXMuYmFzZUZvbnRTaXplO3RoaXMudXBkYXRlTGFiZWxNb2R1bGUoKX19LHtrZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRGb3JtYXR0aW5nVmFsdWVzKCk7cmV0dXJuIHRoaXMuc2hhcGUuZHJhdyh0LHRoaXMueCx0aGlzLnksdGhpcy5zZWxlY3RlZCx0aGlzLmhvdmVyLGUpfHx7fX19LHtrZXk6XCJ1cGRhdGVCb3VuZGluZ0JveFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuc2hhcGUudXBkYXRlQm91bmRpbmdCb3godGhpcy54LHRoaXMueSx0KX19LHtrZXk6XCJyZXNpemVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldEZvcm1hdHRpbmdWYWx1ZXMoKTt0aGlzLnNoYXBlLnJlc2l6ZSh0LHRoaXMuc2VsZWN0ZWQsdGhpcy5ob3ZlcixlKX19LHtrZXk6XCJnZXRJdGVtc09uUG9pbnRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1bXTtyZXR1cm4gdGhpcy5sYWJlbE1vZHVsZS52aXNpYmxlKCkmJlpkKHRoaXMubGFiZWxNb2R1bGUuZ2V0U2l6ZSgpLHQpJiZlLnB1c2goe25vZGVJZDp0aGlzLmlkLGxhYmVsSWQ6MH0pLFpkKHRoaXMuc2hhcGUuYm91bmRpbmdCb3gsdCkmJmUucHVzaCh7bm9kZUlkOnRoaXMuaWR9KSxlfX0se2tleTpcImlzT3ZlcmxhcHBpbmdXaXRoXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc2hhcGUubGVmdDx0LnJpZ2h0JiZ0aGlzLnNoYXBlLmxlZnQrdGhpcy5zaGFwZS53aWR0aD50LmxlZnQmJnRoaXMuc2hhcGUudG9wPHQuYm90dG9tJiZ0aGlzLnNoYXBlLnRvcCt0aGlzLnNoYXBlLmhlaWdodD50LnRvcH19LHtrZXk6XCJpc0JvdW5kaW5nQm94T3ZlcmxhcHBpbmdXaXRoXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc2hhcGUuYm91bmRpbmdCb3gubGVmdDx0LnJpZ2h0JiZ0aGlzLnNoYXBlLmJvdW5kaW5nQm94LnJpZ2h0PnQubGVmdCYmdGhpcy5zaGFwZS5ib3VuZGluZ0JveC50b3A8dC5ib3R0b20mJnRoaXMuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tPnQudG9wfX1dLFt7a2V5OlwiY2hlY2tPcGFjaXR5XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIDA8PXQmJnQ8PTF9fSx7a2V5OlwiY2hlY2tDb29yZGluYXRlT3JpZ2luXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXR8fFwiY2VudGVyXCI9PT10fHxcInRvcC1sZWZ0XCI9PT10fX0se2tleTpcInVwZGF0ZUdyb3VwT3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKGUsaSxvKXt2YXIgbjtpZih2b2lkIDAhPT1vKXt2YXIgcj1lLmdyb3VwO2lmKHZvaWQgMCE9PWkmJnZvaWQgMCE9PWkuZ3JvdXAmJnIhPT1pLmdyb3VwKXRocm93IG5ldyBFcnJvcihcInVwZGF0ZUdyb3VwT3B0aW9uczogZ3JvdXAgdmFsdWVzIGluIG9wdGlvbnMgZG9uJ3QgbWF0Y2guXCIpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiByfHxcInN0cmluZ1wiPT10eXBlb2YgciYmXCJcIiE9cil7dmFyIHM9by5nZXQocik7dm9pZCAwIT09cy5vcGFjaXR5JiZ2b2lkIDA9PT1pLm9wYWNpdHkmJih0LmNoZWNrT3BhY2l0eShzLm9wYWNpdHkpfHwoY29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIG9wYWNpdHkuIFZhbHVlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBmb3VuZDogXCIrcy5vcGFjaXR5KSxzLm9wYWNpdHk9dm9pZCAwKSk7dmFyIGE9YXIobj0kZChpKSkuY2FsbChuLChmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9aVt0XX0pKTthLnB1c2goXCJmb250XCIpLEphKGEsZSxzKSxlLmNvbG9yPWhoKGUuY29sb3IpfX19fSx7a2V5OlwicGFyc2VPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24oZSxpKXt2YXIgbz1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdLG49YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOnt9LHI9YXJndW1lbnRzLmxlbmd0aD40P2FyZ3VtZW50c1s0XTp2b2lkIDAscz1bXCJjb2xvclwiLFwiZml4ZWRcIixcInNoYWRvd1wiXTtpZihKYShzLGUsaSxvKSx0LmNoZWNrTWFzcyhpKSx2b2lkIDAhPT1lLm9wYWNpdHkmJih0LmNoZWNrT3BhY2l0eShlLm9wYWNpdHkpfHwoY29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIG9wYWNpdHkuIFZhbHVlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBmb3VuZDogXCIrZS5vcGFjaXR5KSxlLm9wYWNpdHk9dm9pZCAwKSksdm9pZCAwIT09aS5vcGFjaXR5JiYodC5jaGVja09wYWNpdHkoaS5vcGFjaXR5KXx8KGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBmb3Igbm9kZSBvcGFjaXR5LiBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZm91bmQ6IFwiK2kub3BhY2l0eSksaS5vcGFjaXR5PXZvaWQgMCkpLGkuc2hhcGVQcm9wZXJ0aWVzJiYhdC5jaGVja0Nvb3JkaW5hdGVPcmlnaW4oaS5zaGFwZVByb3BlcnRpZXMuY29vcmRpbmF0ZU9yaWdpbikmJmNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBmb3Igbm9kZSBjb29yZGluYXRlT3JpZ2luLCBmb3VuZDogXCIraS5zaGFwZVByb3BlcnRpZXMuY29vcmRpbmF0ZU9yaWdpbiksZ2goZSxpLFwic2hhZG93XCIsbiksdm9pZCAwIT09aS5jb2xvciYmbnVsbCE9PWkuY29sb3Ipe3ZhciBhPWhoKGkuY29sb3IpO1FhKGUuY29sb3IsYSl9ZWxzZSEwPT09byYmbnVsbD09PWkuY29sb3ImJihlLmNvbG9yPXZoKG4uY29sb3IpKTt2b2lkIDAhPT1pLmZpeGVkJiZudWxsIT09aS5maXhlZCYmKFwiYm9vbGVhblwiPT10eXBlb2YgaS5maXhlZD8oZS5maXhlZC54PWkuZml4ZWQsZS5maXhlZC55PWkuZml4ZWQpOih2b2lkIDAhPT1pLmZpeGVkLngmJlwiYm9vbGVhblwiPT10eXBlb2YgaS5maXhlZC54JiYoZS5maXhlZC54PWkuZml4ZWQueCksdm9pZCAwIT09aS5maXhlZC55JiZcImJvb2xlYW5cIj09dHlwZW9mIGkuZml4ZWQueSYmKGUuZml4ZWQueT1pLmZpeGVkLnkpKSksITA9PT1vJiZudWxsPT09aS5mb250JiYoZS5mb250PXZoKG4uZm9udCkpLHQudXBkYXRlR3JvdXBPcHRpb25zKGUsaSxyKSx2b2lkIDAhPT1pLnNjYWxpbmcmJmdoKGUuc2NhbGluZyxpLnNjYWxpbmcsXCJsYWJlbFwiLG4uc2NhbGluZyl9fSx7a2V5OlwiY2hlY2tNYXNzXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZih2b2lkIDAhPT10Lm1hc3MmJnQubWFzczw9MCl7dmFyIGk9XCJcIjt2b2lkIDAhPT1lJiYoaT1cIiBpbiBub2RlIGlkOiBcIitlKSxjb25zb2xlLmVycm9yKFwiJWNOZWdhdGl2ZSBvciB6ZXJvIG1hc3MgZGlzYWxsb3dlZFwiK2krXCIsIHNldHRpbmcgbWFzcyB0byAxLlwiLE1oKSx0Lm1hc3M9MX19fV0pLHR9KCk7ZnVuY3Rpb24gY2ModCxlKXt2YXIgaTtpZih2b2lkIDA9PT1jbnx8bnVsbD09Q2kodCkpe2lmKGduKHQpfHwoaT1mdW5jdGlvbih0LGUpe3ZhciBpO2lmKCF0KXJldHVybjtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gdWModCxlKTt2YXIgbz12bihpPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkuY2FsbChpLDgsLTEpO1wiT2JqZWN0XCI9PT1vJiZ0LmNvbnN0cnVjdG9yJiYobz10LmNvbnN0cnVjdG9yLm5hbWUpO2lmKFwiTWFwXCI9PT1vfHxcIlNldFwiPT09bylyZXR1cm4gbWkodCk7aWYoXCJBcmd1bWVudHNcIj09PW98fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG8pKXJldHVybiB1Yyh0LGUpfSh0KSl8fGUmJnQmJlwibnVtYmVyXCI9PXR5cGVvZiB0Lmxlbmd0aCl7aSYmKHQ9aSk7dmFyIG89MCxuPWZ1bmN0aW9uKCl7fTtyZXR1cm57czpuLG46ZnVuY3Rpb24oKXtyZXR1cm4gbz49dC5sZW5ndGg/e2RvbmU6ITB9Ontkb25lOiExLHZhbHVlOnRbbysrXX19LGU6ZnVuY3Rpb24odCl7dGhyb3cgdH0sZjpufX10aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9dmFyIHIscz0hMCxhPSExO3JldHVybntzOmZ1bmN0aW9uKCl7aT1TaSh0KX0sbjpmdW5jdGlvbigpe3ZhciB0PWkubmV4dCgpO3JldHVybiBzPXQuZG9uZSx0fSxlOmZ1bmN0aW9uKHQpe2E9ITAscj10fSxmOmZ1bmN0aW9uKCl7dHJ5e3N8fG51bGw9PWkucmV0dXJufHxpLnJldHVybigpfWZpbmFsbHl7aWYoYSl0aHJvdyByfX19fWZ1bmN0aW9uIHVjKHQsZSl7KG51bGw9PWV8fGU+dC5sZW5ndGgpJiYoZT10Lmxlbmd0aCk7Zm9yKHZhciBpPTAsbz1uZXcgQXJyYXkoZSk7aTxlO2krKylvW2ldPXRbaV07cmV0dXJuIG99dmFyIGZjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLGksbyxuKXt2YXIgcixzPXRoaXM7aWYoUG8odGhpcyx0KSx0aGlzLmJvZHk9ZSx0aGlzLmltYWdlcz1pLHRoaXMuZ3JvdXBzPW8sdGhpcy5sYXlvdXRFbmdpbmU9bix0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGU9YnQocj10aGlzLmNyZWF0ZSkuY2FsbChyLHRoaXMpLHRoaXMubm9kZXNMaXN0ZW5lcnM9e2FkZDpmdW5jdGlvbih0LGUpe3MuYWRkKGUuaXRlbXMpfSx1cGRhdGU6ZnVuY3Rpb24odCxlKXtzLnVwZGF0ZShlLml0ZW1zLGUuZGF0YSxlLm9sZERhdGEpfSxyZW1vdmU6ZnVuY3Rpb24odCxlKXtzLnJlbW92ZShlLml0ZW1zKX19LHRoaXMuZGVmYXVsdE9wdGlvbnM9e2JvcmRlcldpZHRoOjEsYm9yZGVyV2lkdGhTZWxlY3RlZDp2b2lkIDAsYnJva2VuSW1hZ2U6dm9pZCAwLGNvbG9yOntib3JkZXI6XCIjMkI3Q0U5XCIsYmFja2dyb3VuZDpcIiM5N0MyRkNcIixoaWdobGlnaHQ6e2JvcmRlcjpcIiMyQjdDRTlcIixiYWNrZ3JvdW5kOlwiI0QyRTVGRlwifSxob3Zlcjp7Ym9yZGVyOlwiIzJCN0NFOVwiLGJhY2tncm91bmQ6XCIjRDJFNUZGXCJ9fSxvcGFjaXR5OnZvaWQgMCxmaXhlZDp7eDohMSx5OiExfSxmb250Ontjb2xvcjpcIiMzNDM0MzRcIixzaXplOjE0LGZhY2U6XCJhcmlhbFwiLGJhY2tncm91bmQ6XCJub25lXCIsc3Ryb2tlV2lkdGg6MCxzdHJva2VDb2xvcjpcIiNmZmZmZmZcIixhbGlnbjpcImNlbnRlclwiLHZhZGp1c3Q6MCxtdWx0aTohMSxib2xkOnttb2Q6XCJib2xkXCJ9LGJvbGRpdGFsOnttb2Q6XCJib2xkIGl0YWxpY1wifSxpdGFsOnttb2Q6XCJpdGFsaWNcIn0sbW9ubzp7bW9kOlwiXCIsc2l6ZToxNSxmYWNlOlwibW9ub3NwYWNlXCIsdmFkanVzdDoyfX0sZ3JvdXA6dm9pZCAwLGhpZGRlbjohMSxpY29uOntmYWNlOlwiRm9udEF3ZXNvbWVcIixjb2RlOnZvaWQgMCxzaXplOjUwLGNvbG9yOlwiIzJCN0NFOVwifSxpbWFnZTp2b2lkIDAsaW1hZ2VQYWRkaW5nOnt0b3A6MCxyaWdodDowLGJvdHRvbTowLGxlZnQ6MH0sbGFiZWw6dm9pZCAwLGxhYmVsSGlnaGxpZ2h0Qm9sZDohMCxsZXZlbDp2b2lkIDAsbWFyZ2luOnt0b3A6NSxyaWdodDo1LGJvdHRvbTo1LGxlZnQ6NX0sbWFzczoxLHBoeXNpY3M6ITAsc2NhbGluZzp7bWluOjEwLG1heDozMCxsYWJlbDp7ZW5hYmxlZDohMSxtaW46MTQsbWF4OjMwLG1heFZpc2libGU6MzAsZHJhd1RocmVzaG9sZDo1fSxjdXN0b21TY2FsaW5nRnVuY3Rpb246ZnVuY3Rpb24odCxlLGksbyl7aWYoZT09PXQpcmV0dXJuLjU7dmFyIG49MS8oZS10KTtyZXR1cm4gTWF0aC5tYXgoMCwoby10KSpuKX19LHNoYWRvdzp7ZW5hYmxlZDohMSxjb2xvcjpcInJnYmEoMCwwLDAsMC41KVwiLHNpemU6MTAseDo1LHk6NX0sc2hhcGU6XCJlbGxpcHNlXCIsc2hhcGVQcm9wZXJ0aWVzOntib3JkZXJEYXNoZXM6ITEsYm9yZGVyUmFkaXVzOjYsaW50ZXJwb2xhdGlvbjohMCx1c2VJbWFnZVNpemU6ITEsdXNlQm9yZGVyV2l0aEltYWdlOiExLGNvb3JkaW5hdGVPcmlnaW46XCJjZW50ZXJcIn0sc2l6ZToyNSx0aXRsZTp2b2lkIDAsdmFsdWU6dm9pZCAwLHg6dm9pZCAwLHk6dm9pZCAwfSx0aGlzLmRlZmF1bHRPcHRpb25zLm1hc3M8PTApdGhyb3dcIkludGVybmFsIGVycm9yOiBtYXNzIGluIGRlZmF1bHRPcHRpb25zIG9mIE5vZGVzSGFuZGxlciBtYXkgbm90IGJlIHplcm8gb3IgbmVnYXRpdmVcIjt0aGlzLm9wdGlvbnM9dmgodGhpcy5kZWZhdWx0T3B0aW9ucyksdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKX1yZXR1cm4gSW8odCxbe2tleTpcImJpbmRFdmVudExpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZSxpPXRoaXM7dGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZWZyZXNoTm9kZXNcIixidCh0PXRoaXMucmVmcmVzaCkuY2FsbCh0LHRoaXMpKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlZnJlc2hcIixidChlPXRoaXMucmVmcmVzaCkuY2FsbChlLHRoaXMpKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwoZnVuY3Rpb24oKXtuaChpLm5vZGVzTGlzdGVuZXJzLChmdW5jdGlvbih0LGUpe2kuYm9keS5kYXRhLm5vZGVzJiZpLmJvZHkuZGF0YS5ub2Rlcy5vZmYoZSx0KX0pKSxkZWxldGUgaS5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlLGRlbGV0ZSBpLm5vZGVzTGlzdGVuZXJzLmFkZCxkZWxldGUgaS5ub2Rlc0xpc3RlbmVycy51cGRhdGUsZGVsZXRlIGkubm9kZXNMaXN0ZW5lcnMucmVtb3ZlLGRlbGV0ZSBpLm5vZGVzTGlzdGVuZXJzfSkpfX0se2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih2b2lkIDAhPT10KXtpZihsYy5wYXJzZU9wdGlvbnModGhpcy5vcHRpb25zLHQpLHZvaWQgMCE9PXQub3BhY2l0eSYmKHpkKHQub3BhY2l0eSl8fCFBZCh0Lm9wYWNpdHkpfHx0Lm9wYWNpdHk8MHx8dC5vcGFjaXR5PjE/Y29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIG9wYWNpdHkuIFZhbHVlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBmb3VuZDogXCIrdC5vcGFjaXR5KTp0aGlzLm9wdGlvbnMub3BhY2l0eT10Lm9wYWNpdHkpLHZvaWQgMCE9PXQuc2hhcGUpZm9yKHZhciBlIGluIHRoaXMuYm9keS5ub2RlcylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLGUpJiZ0aGlzLmJvZHkubm9kZXNbZV0udXBkYXRlU2hhcGUoKTtpZih2b2lkIDAhPT10LmZvbnR8fHZvaWQgMCE9PXQud2lkdGhDb25zdHJhaW50fHx2b2lkIDAhPT10LmhlaWdodENvbnN0cmFpbnQpZm9yKHZhciBpPTAsbz14bih0aGlzLmJvZHkubm9kZXMpO2k8by5sZW5ndGg7aSsrKXt2YXIgbj1vW2ldO3RoaXMuYm9keS5ub2Rlc1tuXS51cGRhdGVMYWJlbE1vZHVsZSgpLHRoaXMuYm9keS5ub2Rlc1tuXS5uZWVkc1JlZnJlc2goKX1pZih2b2lkIDAhPT10LnNpemUpZm9yKHZhciByIGluIHRoaXMuYm9keS5ub2RlcylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLHIpJiZ0aGlzLmJvZHkubm9kZXNbcl0ubmVlZHNSZWZyZXNoKCk7dm9pZCAwPT09dC5oaWRkZW4mJnZvaWQgMD09PXQucGh5c2ljc3x8dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKX19fSx7a2V5Olwic2V0RGF0YVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV0sbz10aGlzLmJvZHkuZGF0YS5ub2RlcztpZihlLmlzRGF0YVZpZXdMaWtlKFwiaWRcIix0KSl0aGlzLmJvZHkuZGF0YS5ub2Rlcz10O2Vsc2UgaWYoZ24odCkpdGhpcy5ib2R5LmRhdGEubm9kZXM9bmV3IGUuRGF0YVNldCx0aGlzLmJvZHkuZGF0YS5ub2Rlcy5hZGQodCk7ZWxzZXtpZih0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcnJheSBvciBEYXRhU2V0IGV4cGVjdGVkXCIpO3RoaXMuYm9keS5kYXRhLm5vZGVzPW5ldyBlLkRhdGFTZXR9aWYobyYmbmgodGhpcy5ub2Rlc0xpc3RlbmVycywoZnVuY3Rpb24odCxlKXtvLm9mZihlLHQpfSkpLHRoaXMuYm9keS5ub2Rlcz17fSx0aGlzLmJvZHkuZGF0YS5ub2Rlcyl7dmFyIG49dGhpcztuaCh0aGlzLm5vZGVzTGlzdGVuZXJzLChmdW5jdGlvbih0LGUpe24uYm9keS5kYXRhLm5vZGVzLm9uKGUsdCl9KSk7dmFyIHI9dGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0SWRzKCk7dGhpcy5hZGQociwhMCl9ITE9PT1pJiZ0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpfX0se2tleTpcImFkZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxpPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV0sbz1bXSxuPTA7bjx0Lmxlbmd0aDtuKyspe2U9dFtuXTt2YXIgcj10aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXQoZSkscz10aGlzLmNyZWF0ZShyKTtvLnB1c2gocyksdGhpcy5ib2R5Lm5vZGVzW2VdPXN9dGhpcy5sYXlvdXRFbmdpbmUucG9zaXRpb25Jbml0aWFsbHkobyksITE9PT1pJiZ0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpfX0se2tleTpcInVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXtmb3IodmFyIG89dGhpcy5ib2R5Lm5vZGVzLG49ITEscj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgcz10W3JdLGE9b1tzXSxoPWVbcl07dm9pZCAwIT09YT9hLnNldE9wdGlvbnMoaCkmJihuPSEwKToobj0hMCxhPXRoaXMuY3JlYXRlKGgpLG9bc109YSl9bnx8dm9pZCAwPT09aXx8KG49V2QoZSkuY2FsbChlLChmdW5jdGlvbih0LGUpe3ZhciBvPWlbZV07cmV0dXJuIG8mJm8ubGV2ZWwhPT10LmxldmVsfSkpKSwhMD09PW4/dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTp0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFVcGRhdGVkXCIpfX0se2tleTpcInJlbW92ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmJvZHkubm9kZXMsaT0wO2k8dC5sZW5ndGg7aSsrKXtkZWxldGUgZVt0W2ldXX10aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpfX0se2tleTpcImNyZWF0ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpsYztyZXR1cm4gbmV3IGUodCx0aGlzLmJvZHksdGhpcy5pbWFnZXMsdGhpcy5ncm91cHMsdGhpcy5vcHRpb25zLHRoaXMuZGVmYXVsdE9wdGlvbnMpfX0se2tleTpcInJlZnJlc2hcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSYmYXJndW1lbnRzWzBdO25oKHRoaXMuYm9keS5ub2RlcywoZnVuY3Rpb24oaSxvKXt2YXIgbj10LmJvZHkuZGF0YS5ub2Rlcy5nZXQobyk7dm9pZCAwIT09biYmKCEwPT09ZSYmaS5zZXRPcHRpb25zKHt4Om51bGwseTpudWxsfSksaS5zZXRPcHRpb25zKHtmaXhlZDohMX0pLGkuc2V0T3B0aW9ucyhuKSl9KSl9fSx7a2V5OlwiZ2V0UG9zaXRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9e307aWYodm9pZCAwIT09dCl7aWYoITA9PT1nbih0KSl7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspaWYodm9pZCAwIT09dGhpcy5ib2R5Lm5vZGVzW3RbaV1dKXt2YXIgbz10aGlzLmJvZHkubm9kZXNbdFtpXV07ZVt0W2ldXT17eDpNYXRoLnJvdW5kKG8ueCkseTpNYXRoLnJvdW5kKG8ueSl9fX1lbHNlIGlmKHZvaWQgMCE9PXRoaXMuYm9keS5ub2Rlc1t0XSl7dmFyIG49dGhpcy5ib2R5Lm5vZGVzW3RdO2VbdF09e3g6TWF0aC5yb3VuZChuLngpLHk6TWF0aC5yb3VuZChuLnkpfX19ZWxzZSBmb3IodmFyIHI9MDtyPHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7cisrKXt2YXIgcz10aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW3JdXTtlW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tyXV09e3g6TWF0aC5yb3VuZChzLngpLHk6TWF0aC5yb3VuZChzLnkpfX1yZXR1cm4gZX19LHtrZXk6XCJnZXRQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKG51bGw9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIGlkIHdhcyBzcGVjaWZpZWQgZm9yIGdldFBvc2l0aW9uIG1ldGhvZC5cIik7aWYobnVsbD09dGhpcy5ib2R5Lm5vZGVzW3RdKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIk5vZGVJZCBwcm92aWRlZCBmb3IgZ2V0UG9zaXRpb24gZG9lcyBub3QgZXhpc3QuIFByb3ZpZGVkOiBcIi5jb25jYXQodCkpO3JldHVybnt4Ok1hdGgucm91bmQodGhpcy5ib2R5Lm5vZGVzW3RdLngpLHk6TWF0aC5yb3VuZCh0aGlzLmJvZHkubm9kZXNbdF0ueSl9fX0se2tleTpcInN0b3JlUG9zaXRpb25zXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlPVtdLGk9dGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLG89Y2MoaS5nZXQoKSk7dHJ5e2ZvcihvLnMoKTshKHQ9by5uKCkpLmRvbmU7KXt2YXIgbj10LnZhbHVlLHI9bi5pZCxzPXRoaXMuYm9keS5ub2Rlc1tyXSxhPU1hdGgucm91bmQocy54KSxoPU1hdGgucm91bmQocy55KTtuLng9PT1hJiZuLnk9PT1ofHxlLnB1c2goe2lkOnIseDphLHk6aH0pfX1jYXRjaCh0KXtvLmUodCl9ZmluYWxseXtvLmYoKX1pLnVwZGF0ZShlKX19LHtrZXk6XCJnZXRCb3VuZGluZ0JveFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMCE9PXRoaXMuYm9keS5ub2Rlc1t0XSlyZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW3RdLnNoYXBlLmJvdW5kaW5nQm94fX0se2tleTpcImdldENvbm5lY3RlZE5vZGVzXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT1bXTtpZih2b2lkIDAhPT10aGlzLmJvZHkubm9kZXNbdF0pZm9yKHZhciBvPXRoaXMuYm9keS5ub2Rlc1t0XSxuPXt9LHI9MDtyPG8uZWRnZXMubGVuZ3RoO3IrKyl7dmFyIHM9by5lZGdlc1tyXTtcInRvXCIhPT1lJiZzLnRvSWQ9PW8uaWQ/dm9pZCAwPT09bltzLmZyb21JZF0mJihpLnB1c2gocy5mcm9tSWQpLG5bcy5mcm9tSWRdPSEwKTpcImZyb21cIiE9PWUmJnMuZnJvbUlkPT1vLmlkJiZ2b2lkIDA9PT1uW3MudG9JZF0mJihpLnB1c2gocy50b0lkKSxuW3MudG9JZF09ITApfXJldHVybiBpfX0se2tleTpcImdldENvbm5lY3RlZEVkZ2VzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9W107aWYodm9pZCAwIT09dGhpcy5ib2R5Lm5vZGVzW3RdKWZvcih2YXIgaT10aGlzLmJvZHkubm9kZXNbdF0sbz0wO288aS5lZGdlcy5sZW5ndGg7bysrKWUucHVzaChpLmVkZ2VzW29dLmlkKTtlbHNlIGNvbnNvbGUuZXJyb3IoXCJOb2RlSWQgcHJvdmlkZWQgZm9yIGdldENvbm5lY3RlZEVkZ2VzIGRvZXMgbm90IGV4aXN0LiBQcm92aWRlZDogXCIsdCk7cmV0dXJuIGV9fSx7a2V5OlwibW92ZU5vZGVcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dmFyIG89dGhpczt2b2lkIDAhPT10aGlzLmJvZHkubm9kZXNbdF0/KHRoaXMuYm9keS5ub2Rlc1t0XS54PU51bWJlcihlKSx0aGlzLmJvZHkubm9kZXNbdF0ueT1OdW1iZXIoaSkscXIoKGZ1bmN0aW9uKCl7by5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKX0pLDApKTpjb25zb2xlLmVycm9yKFwiTm9kZSBpZCBzdXBwbGllZCB0byBtb3ZlTm9kZSBkb2VzIG5vdCBleGlzdC4gUHJvdmlkZWQ6IFwiLHQpfX1dKSx0fSgpO3Eoe3RhcmdldDpcIlJlZmxlY3RcIixzdGF0OiEwfSx7Z2V0OmZ1bmN0aW9uIHQoZSxpKXt2YXIgbyxuLHI9YXJndW1lbnRzLmxlbmd0aDwzP2U6YXJndW1lbnRzWzJdO3JldHVybiBSKGUpPT09cj9lW2ldOihvPVMuZihlLGkpKT9rKG8sXCJ2YWx1ZVwiKT9vLnZhbHVlOnZvaWQgMD09PW8uZ2V0P3ZvaWQgMDpvLmdldC5jYWxsKHIpOm0obj1pZShlKSk/dChuLGkscik6dm9pZCAwfX0pO3ZhciBwYz1GLlJlZmxlY3QuZ2V0LHZjPXhvO2Z1bmN0aW9uIGdjKHQsZSxpKXtyZXR1cm4oZ2M9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFJlZmxlY3QmJnBjP3BjOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz1mdW5jdGlvbih0LGUpe2Zvcig7IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpJiZudWxsIT09KHQ9X2wodCkpOyk7cmV0dXJuIHR9KHQsZSk7aWYobyl7dmFyIG49dmMobyxlKTtyZXR1cm4gbi5nZXQ/bi5nZXQuY2FsbChpKTpuLnZhbHVlfX0pKHQsZSxpfHx0KX12YXIgeWM9TWF0aC5oeXBvdCxtYz1NYXRoLmFicyxiYz1NYXRoLnNxcnQsd2M9ISF5YyYmeWMoMS8wLE5hTikhPT0xLzA7cSh7dGFyZ2V0OlwiTWF0aFwiLHN0YXQ6ITAsZm9yY2VkOndjfSx7aHlwb3Q6ZnVuY3Rpb24odCxlKXtmb3IodmFyIGksbyxuPTAscj0wLHM9YXJndW1lbnRzLmxlbmd0aCxhPTA7cjxzOylhPChpPW1jKGFyZ3VtZW50c1tyKytdKSk/KG49bioobz1hL2kpKm8rMSxhPWkpOm4rPWk+MD8obz1pL2EpKm86aTtyZXR1cm4gYT09PTEvMD8xLzA6YSpiYyhuKX19KTt2YXIga2M9Ri5NYXRoLmh5cG90O2Z1bmN0aW9uIF9jKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIHhjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCl9cmV0dXJuIElvKHQsbnVsbCxbe2tleTpcInRyYW5zZm9ybVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7Z24odCl8fCh0PVt0XSk7Zm9yKHZhciBpPWUucG9pbnQueCxvPWUucG9pbnQueSxuPWUuYW5nbGUscj1lLmxlbmd0aCxzPTA7czx0Lmxlbmd0aDsrK3Mpe3ZhciBhPXRbc10saD1hLngqTWF0aC5jb3MobiktYS55Kk1hdGguc2luKG4pLGQ9YS54Kk1hdGguc2luKG4pK2EueSpNYXRoLmNvcyhuKTthLng9aStyKmgsYS55PW8rcipkfX19LHtrZXk6XCJkcmF3UGF0aFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dC5iZWdpblBhdGgoKSx0Lm1vdmVUbyhlWzBdLngsZVswXS55KTtmb3IodmFyIGk9MTtpPGUubGVuZ3RoOysraSl0LmxpbmVUbyhlW2ldLngsZVtpXS55KTt0LmNsb3NlUGF0aCgpfX1dKSx0fSgpLEVjPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9X2MoaSk7ZnVuY3Rpb24gaSgpe3JldHVybiBQbyh0aGlzLGkpLGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBJbyhpLG51bGwsW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZihlLmltYWdlKXt0LnNhdmUoKSx0LnRyYW5zbGF0ZShlLnBvaW50LngsZS5wb2ludC55KSx0LnJvdGF0ZShNYXRoLlBJLzIrZS5hbmdsZSk7dmFyIGk9bnVsbCE9ZS5pbWFnZVdpZHRoP2UuaW1hZ2VXaWR0aDplLmltYWdlLndpZHRoLG89bnVsbCE9ZS5pbWFnZUhlaWdodD9lLmltYWdlSGVpZ2h0OmUuaW1hZ2UuaGVpZ2h0O2UuaW1hZ2UuZHJhd0ltYWdlQXRQb3NpdGlvbih0LDEsLWkvMiwwLGksbyksdC5yZXN0b3JlKCl9cmV0dXJuITF9fV0pLGl9KHhjKSxPYz1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPV9jKGkpO2Z1bmN0aW9uIGkoKXtyZXR1cm4gUG8odGhpcyxpKSxlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gSW8oaSxudWxsLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9W3t4OjAseTowfSx7eDotMSx5Oi4zfSx7eDotLjkseTowfSx7eDotMSx5Oi0uM31dO3JldHVybiB4Yy50cmFuc2Zvcm0oaSxlKSx4Yy5kcmF3UGF0aCh0LGkpLCEwfX1dKSxpfSh4YyksQ2M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7UG8odGhpcyx0KX1yZXR1cm4gSW8odCxudWxsLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9W3t4Oi0xLHk6MH0se3g6MCx5Oi4zfSx7eDotLjQseTowfSx7eDowLHk6LS4zfV07cmV0dXJuIHhjLnRyYW5zZm9ybShpLGUpLHhjLmRyYXdQYXRoKHQsaSksITB9fV0pLHR9KCksU2M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7UG8odGhpcyx0KX1yZXR1cm4gSW8odCxudWxsLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9e3g6LS40LHk6MH07eGMudHJhbnNmb3JtKGksZSksdC5zdHJva2VTdHlsZT10LmZpbGxTdHlsZSx0LmZpbGxTdHlsZT1cInJnYmEoMCwgMCwgMCwgMClcIjt2YXIgbz1NYXRoLlBJLG49ZS5hbmdsZS1vLzIscj1lLmFuZ2xlK28vMjtyZXR1cm4gdC5iZWdpblBhdGgoKSx0LmFyYyhpLngsaS55LC40KmUubGVuZ3RoLG4sciwhMSksdC5zdHJva2UoKSwhMH19XSksdH0oKSxUYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtQbyh0aGlzLHQpfXJldHVybiBJbyh0LG51bGwsW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT17eDotLjMseTowfTt4Yy50cmFuc2Zvcm0oaSxlKSx0LnN0cm9rZVN0eWxlPXQuZmlsbFN0eWxlLHQuZmlsbFN0eWxlPVwicmdiYSgwLCAwLCAwLCAwKVwiO3ZhciBvPU1hdGguUEksbj1lLmFuZ2xlK28vMixyPWUuYW5nbGUrMypvLzI7cmV0dXJuIHQuYmVnaW5QYXRoKCksdC5hcmMoaS54LGkueSwuNCplLmxlbmd0aCxuLHIsITEpLHQuc3Ryb2tlKCksITB9fV0pLHR9KCksTWM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7UG8odGhpcyx0KX1yZXR1cm4gSW8odCxudWxsLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9W3t4Oi4wMix5OjB9LHt4Oi0xLHk6LjN9LHt4Oi0xLHk6LS4zfV07cmV0dXJuIHhjLnRyYW5zZm9ybShpLGUpLHhjLmRyYXdQYXRoKHQsaSksITB9fV0pLHR9KCksUGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7UG8odGhpcyx0KX1yZXR1cm4gSW8odCxudWxsLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9W3t4OjAseTouM30se3g6MCx5Oi0uM30se3g6LTEseTowfV07cmV0dXJuIHhjLnRyYW5zZm9ybShpLGUpLHhjLmRyYXdQYXRoKHQsaSksITB9fV0pLHR9KCksRGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7UG8odGhpcyx0KX1yZXR1cm4gSW8odCxudWxsLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9e3g6LS40LHk6MH07cmV0dXJuIHhjLnRyYW5zZm9ybShpLGUpLHd0KHQsaS54LGkueSwuNCplLmxlbmd0aCksITB9fV0pLHR9KCksQmM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7UG8odGhpcyx0KX1yZXR1cm4gSW8odCxudWxsLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9W3t4OjAseTouNX0se3g6MCx5Oi0uNX0se3g6LS4xNSx5Oi0uNX0se3g6LS4xNSx5Oi41fV07cmV0dXJuIHhjLnRyYW5zZm9ybShpLGUpLHhjLmRyYXdQYXRoKHQsaSksITB9fV0pLHR9KCksSWM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7UG8odGhpcyx0KX1yZXR1cm4gSW8odCxudWxsLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9W3t4OjAseTouM30se3g6MCx5Oi0uM30se3g6LS42LHk6LS4zfSx7eDotLjYseTouM31dO3JldHVybiB4Yy50cmFuc2Zvcm0oaSxlKSx4Yy5kcmF3UGF0aCh0LGkpLCEwfX1dKSx0fSgpLHpjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCl9cmV0dXJuIElvKHQsbnVsbCxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPVt7eDowLHk6MH0se3g6LS41LHk6LS4zfSx7eDotMSx5OjB9LHt4Oi0uNSx5Oi4zfV07cmV0dXJuIHhjLnRyYW5zZm9ybShpLGUpLHhjLmRyYXdQYXRoKHQsaSksITB9fV0pLHR9KCksRmM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7UG8odGhpcyx0KX1yZXR1cm4gSW8odCxudWxsLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9W3t4Oi0xLHk6LjN9LHt4Oi0uNSx5OjB9LHt4Oi0xLHk6LS4zfSx7eDowLHk6MH1dO3JldHVybiB4Yy50cmFuc2Zvcm0oaSxlKSx4Yy5kcmF3UGF0aCh0LGkpLCEwfX1dKSx0fSgpLE5jPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCl9cmV0dXJuIElvKHQsbnVsbCxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpO3N3aXRjaChlLnR5cGUmJihpPWUudHlwZS50b0xvd2VyQ2FzZSgpKSxpKXtjYXNlXCJpbWFnZVwiOnJldHVybiBFYy5kcmF3KHQsZSk7Y2FzZVwiY2lyY2xlXCI6cmV0dXJuIERjLmRyYXcodCxlKTtjYXNlXCJib3hcIjpyZXR1cm4gSWMuZHJhdyh0LGUpO2Nhc2VcImNyb3dcIjpyZXR1cm4gQ2MuZHJhdyh0LGUpO2Nhc2VcImN1cnZlXCI6cmV0dXJuIFNjLmRyYXcodCxlKTtjYXNlXCJkaWFtb25kXCI6cmV0dXJuIHpjLmRyYXcodCxlKTtjYXNlXCJpbnZfY3VydmVcIjpyZXR1cm4gVGMuZHJhdyh0LGUpO2Nhc2VcInRyaWFuZ2xlXCI6cmV0dXJuIE1jLmRyYXcodCxlKTtjYXNlXCJpbnZfdHJpYW5nbGVcIjpyZXR1cm4gUGMuZHJhdyh0LGUpO2Nhc2VcImJhclwiOnJldHVybiBCYy5kcmF3KHQsZSk7Y2FzZVwidmVlXCI6cmV0dXJuIEZjLmRyYXcodCxlKTtjYXNlXCJhcnJvd1wiOmRlZmF1bHQ6cmV0dXJuIE9jLmRyYXcodCxlKX19fV0pLHR9KCk7ZnVuY3Rpb24gQWModCxlKXt2YXIgaT14bih0KTtpZih3byl7dmFyIG89d28odCk7ZSYmKG89YXIobykuY2FsbChvLChmdW5jdGlvbihlKXtyZXR1cm4gRW8odCxlKS5lbnVtZXJhYmxlfSkpKSxpLnB1c2guYXBwbHkoaSxvKX1yZXR1cm4gaX1mdW5jdGlvbiBSYyh0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgaSxvPW51bGwhPWFyZ3VtZW50c1tlXT9hcmd1bWVudHNbZV06e307aWYoZSUyKURuKGk9QWMoT2JqZWN0KG8pLCEwKSkuY2FsbChpLChmdW5jdGlvbihlKXt6byh0LGUsb1tlXSl9KSk7ZWxzZSBpZihDbylTbyh0LENvKG8pKTtlbHNle3ZhciBuO0RuKG49QWMoT2JqZWN0KG8pKSkuY2FsbChuLChmdW5jdGlvbihlKXtNbyh0LGUsRW8obyxlKSl9KSl9fXJldHVybiB0fXZhciBqYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8pe1BvKHRoaXMsdCksdGhpcy5fYm9keT1pLHRoaXMuX2xhYmVsTW9kdWxlPW8sdGhpcy5jb2xvcj17fSx0aGlzLmNvbG9yRGlydHk9ITAsdGhpcy5ob3ZlcldpZHRoPTEuNSx0aGlzLnNlbGVjdGlvbldpZHRoPTIsdGhpcy5zZXRPcHRpb25zKGUpLHRoaXMuZnJvbVBvaW50PXRoaXMuZnJvbSx0aGlzLnRvUG9pbnQ9dGhpcy50b31yZXR1cm4gSW8odCxbe2tleTpcImNvbm5lY3RcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZnJvbT10aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy5mcm9tXSx0aGlzLnRvPXRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXX19LHtrZXk6XCJjbGVhbnVwXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4hMX19LHtrZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5vcHRpb25zPXQsdGhpcy5mcm9tPXRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dLHRoaXMudG89dGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dLHRoaXMuaWQ9dGhpcy5vcHRpb25zLmlkfX0se2tleTpcImRyYXdMaW5lXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD40JiZ2b2lkIDAhPT1hcmd1bWVudHNbNF0/YXJndW1lbnRzWzRdOnRoaXMuZ2V0VmlhTm9kZSgpO3Quc3Ryb2tlU3R5bGU9dGhpcy5nZXRDb2xvcih0LGUpLHQubGluZVdpZHRoPWUud2lkdGgsITEhPT1lLmRhc2hlcz90aGlzLl9kcmF3RGFzaGVkTGluZSh0LGUsbik6dGhpcy5fZHJhd0xpbmUodCxlLG4pfX0se2tleTpcIl9kcmF3TGluZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbil7aWYodGhpcy5mcm9tIT10aGlzLnRvKXRoaXMuX2xpbmUodCxlLGksbyxuKTtlbHNle3ZhciByPWFuKHRoaXMuX2dldENpcmNsZURhdGEodCksMykscz1yWzBdLGE9clsxXSxoPXJbMl07dGhpcy5fY2lyY2xlKHQsZSxzLGEsaCl9fX0se2tleTpcIl9kcmF3RGFzaGVkTGluZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbil7dC5saW5lQ2FwPVwicm91bmRcIjt2YXIgcj1nbihlLmRhc2hlcyk/ZS5kYXNoZXM6WzUsNV07aWYodm9pZCAwIT09dC5zZXRMaW5lRGFzaCl7aWYodC5zYXZlKCksdC5zZXRMaW5lRGFzaChyKSx0LmxpbmVEYXNoT2Zmc2V0PTAsdGhpcy5mcm9tIT10aGlzLnRvKXRoaXMuX2xpbmUodCxlLGkpO2Vsc2V7dmFyIHM9YW4odGhpcy5fZ2V0Q2lyY2xlRGF0YSh0KSwzKSxhPXNbMF0saD1zWzFdLGQ9c1syXTt0aGlzLl9jaXJjbGUodCxlLGEsaCxkKX10LnNldExpbmVEYXNoKFswXSksdC5saW5lRGFzaE9mZnNldD0wLHQucmVzdG9yZSgpfWVsc2V7aWYodGhpcy5mcm9tIT10aGlzLnRvKUV0KHQsdGhpcy5mcm9tLngsdGhpcy5mcm9tLnksdGhpcy50by54LHRoaXMudG8ueSxyKTtlbHNle3ZhciBsPWFuKHRoaXMuX2dldENpcmNsZURhdGEodCksMyksYz1sWzBdLHU9bFsxXSxmPWxbMl07dGhpcy5fY2lyY2xlKHQsZSxjLHUsZil9dGhpcy5lbmFibGVTaGFkb3codCxlKSx0LnN0cm9rZSgpLHRoaXMuZGlzYWJsZVNoYWRvdyh0LGUpfX19LHtrZXk6XCJmaW5kQm9yZGVyUG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7cmV0dXJuIHRoaXMuZnJvbSE9dGhpcy50bz90aGlzLl9maW5kQm9yZGVyUG9zaXRpb24odCxlLGkpOnRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0LGUsaSl9fSx7a2V5OlwiZmluZEJvcmRlclBvc2l0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHRoaXMuZnJvbSE9dGhpcy50bylyZXR1cm57ZnJvbTp0aGlzLl9maW5kQm9yZGVyUG9zaXRpb24odGhpcy5mcm9tLHQpLHRvOnRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbih0aGlzLnRvLHQpfTt2YXIgZSxpPWFuKHZuKGU9dGhpcy5fZ2V0Q2lyY2xlRGF0YSh0KSkuY2FsbChlLDAsMiksMiksbz1pWzBdLG49aVsxXTtyZXR1cm57ZnJvbTp0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLHQse3g6byx5Om4sbG93Oi4yNSxoaWdoOi42LGRpcmVjdGlvbjotMX0pLHRvOnRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sdCx7eDpvLHk6bixsb3c6LjYsaGlnaDouOCxkaXJlY3Rpb246MX0pfX19LHtrZXk6XCJfZ2V0Q2lyY2xlRGF0YVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLnNpemU7dm9pZCAwIT09dCYmdm9pZCAwPT09dGhpcy5mcm9tLnNoYXBlLndpZHRoJiZ0aGlzLmZyb20uc2hhcGUucmVzaXplKHQpO3ZhciBpPXRsKHQsdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUsZSx0aGlzLmZyb20pO3JldHVybltpLngsaS55LGVdfX0se2tleTpcIl9wb2ludE9uQ2lyY2xlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyl7dmFyIG49MipvKk1hdGguUEk7cmV0dXJue3g6dCtpKk1hdGguY29zKG4pLHk6ZS1pKk1hdGguc2luKG4pfX19LHtrZXk6XCJfZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3ZhciBvLG49aS54LHI9aS55LHM9aS5sb3csYT1pLmhpZ2gsaD1pLmRpcmVjdGlvbixkPXRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLnNpemUsbD0uNSoocythKSxjPTA7ITA9PT10aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoJiYoLTE9PT1oP2M9dGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb206MT09PWgmJihjPXRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldC50bykpO3ZhciB1PTA7ZG97bD0uNSoocythKSxvPXRoaXMuX3BvaW50T25DaXJjbGUobixyLGQsbCk7dmFyIGY9TWF0aC5hdGFuMih0Lnktby55LHQueC1vLngpLHA9dC5kaXN0YW5jZVRvQm9yZGVyKGUsZikrYy1NYXRoLnNxcnQoTWF0aC5wb3coby54LXQueCwyKStNYXRoLnBvdyhvLnktdC55LDIpKTtpZihNYXRoLmFicyhwKTwuMDUpYnJlYWs7cD4wP2g+MD9zPWw6YT1sOmg+MD9hPWw6cz1sLCsrdX13aGlsZShzPD1hJiZ1PDEwKTtyZXR1cm4gUmMoUmMoe30sbykse30se3Q6bH0pfX0se2tleTpcImdldExpbmVXaWR0aFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuITA9PT10P01hdGgubWF4KHRoaXMuc2VsZWN0aW9uV2lkdGgsLjMvdGhpcy5fYm9keS52aWV3LnNjYWxlKTohMD09PWU/TWF0aC5tYXgodGhpcy5ob3ZlcldpZHRoLC4zL3RoaXMuX2JvZHkudmlldy5zY2FsZSk6TWF0aC5tYXgodGhpcy5vcHRpb25zLndpZHRoLC4zL3RoaXMuX2JvZHkudmlldy5zY2FsZSl9fSx7a2V5OlwiZ2V0Q29sb3JcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKCExIT09ZS5pbmhlcml0c0NvbG9yKXtpZihcImJvdGhcIj09PWUuaW5oZXJpdHNDb2xvciYmdGhpcy5mcm9tLmlkIT09dGhpcy50by5pZCl7dmFyIGk9dC5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLmZyb20ueCx0aGlzLmZyb20ueSx0aGlzLnRvLngsdGhpcy50by55KSxvPXRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXIsbj10aGlzLnRvLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtyZXR1cm4hMT09PXRoaXMuZnJvbS5zZWxlY3RlZCYmITE9PT10aGlzLnRvLnNlbGVjdGVkPyhvPXNoKHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmJvcmRlcixlLm9wYWNpdHkpLG49c2godGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlcixlLm9wYWNpdHkpKTohMD09PXRoaXMuZnJvbS5zZWxlY3RlZCYmITE9PT10aGlzLnRvLnNlbGVjdGVkP249dGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlcjohMT09PXRoaXMuZnJvbS5zZWxlY3RlZCYmITA9PT10aGlzLnRvLnNlbGVjdGVkJiYobz10aGlzLmZyb20ub3B0aW9ucy5jb2xvci5ib3JkZXIpLGkuYWRkQ29sb3JTdG9wKDAsbyksaS5hZGRDb2xvclN0b3AoMSxuKSxpfXJldHVyblwidG9cIj09PWUuaW5oZXJpdHNDb2xvcj9zaCh0aGlzLnRvLm9wdGlvbnMuY29sb3IuYm9yZGVyLGUub3BhY2l0eSk6c2godGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuYm9yZGVyLGUub3BhY2l0eSl9cmV0dXJuIHNoKGUuY29sb3IsZS5vcGFjaXR5KX19LHtrZXk6XCJfY2lyY2xlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuKXt0aGlzLmVuYWJsZVNoYWRvdyh0LGUpO3ZhciByPTAscz0yKk1hdGguUEk7aWYoIXRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLnJlbmRlckJlaGluZFRoZU5vZGUpe3ZhciBhPXRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlLGg9dGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUrTWF0aC5QSSxkPXRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sdCx7eDppLHk6byxsb3c6YSxoaWdoOmgsZGlyZWN0aW9uOi0xfSksbD10aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLHQse3g6aSx5Om8sbG93OmEsaGlnaDpoLGRpcmVjdGlvbjoxfSk7cj1NYXRoLmF0YW4yKGQueS1vLGQueC1pKSxzPU1hdGguYXRhbjIobC55LW8sbC54LWkpfXQuYmVnaW5QYXRoKCksdC5hcmMoaSxvLG4scixzLCExKSx0LnN0cm9rZSgpLHRoaXMuZGlzYWJsZVNoYWRvdyh0LGUpfX0se2tleTpcImdldERpc3RhbmNlVG9FZGdlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe2lmKHRoaXMuZnJvbSE9dGhpcy50bylyZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0VkZ2UodCxlLGksbyxuLHIpO3ZhciBzPWFuKHRoaXMuX2dldENpcmNsZURhdGEodm9pZCAwKSwzKSxhPXNbMF0saD1zWzFdLGQ9c1syXSxsPWEtbixjPWgtcjtyZXR1cm4gTWF0aC5hYnMoTWF0aC5zcXJ0KGwqbCtjKmMpLWQpfX0se2tleTpcIl9nZXREaXN0YW5jZVRvTGluZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXt2YXIgcz1pLXQsYT1vLWUsaD0oKG4tdCkqcysoci1lKSphKS8ocypzK2EqYSk7aD4xP2g9MTpoPDAmJihoPTApO3ZhciBkPXQraCpzLW4sbD1lK2gqYS1yO3JldHVybiBNYXRoLnNxcnQoZCpkK2wqbCl9fSx7a2V5OlwiZ2V0QXJyb3dEYXRhXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3ZhciBzLGEsaCxkLGwsYyx1LGY9ci53aWR0aDtcImZyb21cIj09PWU/KGg9dGhpcy5mcm9tLGQ9dGhpcy50byxsPXIuZnJvbUFycm93U2NhbGU8MCxjPU1hdGguYWJzKHIuZnJvbUFycm93U2NhbGUpLHU9ci5mcm9tQXJyb3dUeXBlKTpcInRvXCI9PT1lPyhoPXRoaXMudG8sZD10aGlzLmZyb20sbD1yLnRvQXJyb3dTY2FsZTwwLGM9TWF0aC5hYnMoci50b0Fycm93U2NhbGUpLHU9ci50b0Fycm93VHlwZSk6KGg9dGhpcy50byxkPXRoaXMuZnJvbSxsPXIubWlkZGxlQXJyb3dTY2FsZTwwLGM9TWF0aC5hYnMoci5taWRkbGVBcnJvd1NjYWxlKSx1PXIubWlkZGxlQXJyb3dUeXBlKTt2YXIgcD0xNSpjKzMqZjtpZihoIT1kKXt2YXIgdj1wL2tjKGgueC1kLngsaC55LWQueSk7aWYoXCJtaWRkbGVcIiE9PWUpaWYoITA9PT10aGlzLm9wdGlvbnMuc21vb3RoLmVuYWJsZWQpe3ZhciBnPXRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbihoLHQse3ZpYTppfSkseT10aGlzLmdldFBvaW50KGcudCt2KihcImZyb21cIj09PWU/MTotMSksaSk7cz1NYXRoLmF0YW4yKGcueS15LnksZy54LXkueCksYT1nfWVsc2Ugcz1NYXRoLmF0YW4yKGgueS1kLnksaC54LWQueCksYT10aGlzLl9maW5kQm9yZGVyUG9zaXRpb24oaCx0KTtlbHNle3ZhciBtPShsPy12OnYpLzIsYj10aGlzLmdldFBvaW50KC41K20saSksdz10aGlzLmdldFBvaW50KC41LW0saSk7cz1NYXRoLmF0YW4yKGIueS13LnksYi54LXcueCksYT10aGlzLmdldFBvaW50KC41LGkpfX1lbHNle3ZhciBrPWFuKHRoaXMuX2dldENpcmNsZURhdGEodCksMyksXz1rWzBdLHg9a1sxXSxFPWtbMl07aWYoXCJmcm9tXCI9PT1lKXt2YXIgTz10aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSxDPXRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlK01hdGguUEksUz10aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLHQse3g6Xyx5OngsbG93Ok8saGlnaDpDLGRpcmVjdGlvbjotMX0pO3M9LTIqUy50Kk1hdGguUEkrMS41Kk1hdGguUEkrLjEqTWF0aC5QSSxhPVN9ZWxzZSBpZihcInRvXCI9PT1lKXt2YXIgVD10aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSxNPXRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlK01hdGguUEksUD10aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLHQse3g6Xyx5OngsbG93OlQsaGlnaDpNLGRpcmVjdGlvbjoxfSk7cz0tMipQLnQqTWF0aC5QSSsxLjUqTWF0aC5QSS0xLjEqTWF0aC5QSSxhPVB9ZWxzZXt2YXIgRD10aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZS8oMipNYXRoLlBJKTthPXRoaXMuX3BvaW50T25DaXJjbGUoXyx4LEUsRCkscz0tMipEKk1hdGguUEkrMS41Kk1hdGguUEkrLjEqTWF0aC5QSX19cmV0dXJue3BvaW50OmEsY29yZTp7eDphLngtLjkqcCpNYXRoLmNvcyhzKSx5OmEueS0uOSpwKk1hdGguc2luKHMpfSxhbmdsZTpzLGxlbmd0aDpwLHR5cGU6dX19fSx7a2V5OlwiZHJhd0Fycm93SGVhZFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbil7dC5zdHJva2VTdHlsZT10aGlzLmdldENvbG9yKHQsZSksdC5maWxsU3R5bGU9dC5zdHJva2VTdHlsZSx0LmxpbmVXaWR0aD1lLndpZHRoLE5jLmRyYXcodCxuKSYmKHRoaXMuZW5hYmxlU2hhZG93KHQsZSksWHIodCkuY2FsbCh0KSx0aGlzLmRpc2FibGVTaGFkb3codCxlKSl9fSx7a2V5OlwiZW5hYmxlU2hhZG93XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXshMD09PWUuc2hhZG93JiYodC5zaGFkb3dDb2xvcj1lLnNoYWRvd0NvbG9yLHQuc2hhZG93Qmx1cj1lLnNoYWRvd1NpemUsdC5zaGFkb3dPZmZzZXRYPWUuc2hhZG93WCx0LnNoYWRvd09mZnNldFk9ZS5zaGFkb3dZKX19LHtrZXk6XCJkaXNhYmxlU2hhZG93XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXshMD09PWUuc2hhZG93JiYodC5zaGFkb3dDb2xvcj1cInJnYmEoMCwwLDAsMClcIix0LnNoYWRvd0JsdXI9MCx0LnNoYWRvd09mZnNldFg9MCx0LnNoYWRvd09mZnNldFk9MCl9fSx7a2V5OlwiZHJhd0JhY2tncm91bmRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKCExIT09ZS5iYWNrZ3JvdW5kKXt2YXIgaT17c3Ryb2tlU3R5bGU6dC5zdHJva2VTdHlsZSxsaW5lV2lkdGg6dC5saW5lV2lkdGgsZGFzaGVzOnQuZGFzaGVzfTt0LnN0cm9rZVN0eWxlPWUuYmFja2dyb3VuZENvbG9yLHQubGluZVdpZHRoPWUuYmFja2dyb3VuZFNpemUsdGhpcy5zZXRTdHJva2VEYXNoZWQodCxlLmJhY2tncm91bmREYXNoZXMpLHQuc3Ryb2tlKCksdC5zdHJva2VTdHlsZT1pLnN0cm9rZVN0eWxlLHQubGluZVdpZHRoPWkubGluZVdpZHRoLHQuZGFzaGVzPWkuZGFzaGVzLHRoaXMuc2V0U3Ryb2tlRGFzaGVkKHQsZS5kYXNoZXMpfX19LHtrZXk6XCJzZXRTdHJva2VEYXNoZWRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKCExIT09ZSlpZih2b2lkIDAhPT10LnNldExpbmVEYXNoKXt2YXIgaT1nbihlKT9lOls1LDVdO3Quc2V0TGluZURhc2goaSl9ZWxzZSBjb25zb2xlLndhcm4oXCJzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBzdHJva2UgY2Fubm90IGJlIHVzZWQuXCIpO2Vsc2Ugdm9pZCAwIT09dC5zZXRMaW5lRGFzaD90LnNldExpbmVEYXNoKFtdKTpjb25zb2xlLndhcm4oXCJzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBzdHJva2UgY2Fubm90IGJlIHVzZWQuXCIpfX1dKSx0fSgpO2Z1bmN0aW9uIExjKHQsZSl7dmFyIGk9eG4odCk7aWYod28pe3ZhciBvPXdvKHQpO2UmJihvPWFyKG8pLmNhbGwobywoZnVuY3Rpb24oZSl7cmV0dXJuIEVvKHQsZSkuZW51bWVyYWJsZX0pKSksaS5wdXNoLmFwcGx5KGksbyl9cmV0dXJuIGl9ZnVuY3Rpb24gSGModCl7Zm9yKHZhciBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIGksbz1udWxsIT1hcmd1bWVudHNbZV0/YXJndW1lbnRzW2VdOnt9O2lmKGUlMilEbihpPUxjKE9iamVjdChvKSwhMCkpLmNhbGwoaSwoZnVuY3Rpb24oZSl7em8odCxlLG9bZV0pfSkpO2Vsc2UgaWYoQ28pU28odCxDbyhvKSk7ZWxzZXt2YXIgbjtEbihuPUxjKE9iamVjdChvKSkpLmNhbGwobiwoZnVuY3Rpb24oZSl7TW8odCxlLEVvKG8sZSkpfSkpfX1yZXR1cm4gdH1mdW5jdGlvbiBXYyh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciBWYz1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPVdjKGkpO2Z1bmN0aW9uIGkodCxvLG4pe3JldHVybiBQbyh0aGlzLGkpLGUuY2FsbCh0aGlzLHQsbyxuKX1yZXR1cm4gSW8oaSxbe2tleTpcIl9maW5kQm9yZGVyUG9zaXRpb25CZXppZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpLG8sbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKSxyPTEwLHM9LjIsYT0hMSxoPTEsZD0wLGw9dGhpcy50byxjPXRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldD90aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG86MDt0LmlkPT09dGhpcy5mcm9tLmlkJiYobD10aGlzLmZyb20sYT0hMCxjPXRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldD90aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbTowKSwhMT09PXRoaXMub3B0aW9ucy5hcnJvd1N0cmlrZXRocm91Z2gmJihjPTApO3ZhciB1PTA7ZG97bz0uNSooZCtoKSxpPXRoaXMuZ2V0UG9pbnQobyxuKTt2YXIgZj1NYXRoLmF0YW4yKGwueS1pLnksbC54LWkueCkscD1sLmRpc3RhbmNlVG9Cb3JkZXIoZSxmKStjLHY9TWF0aC5zcXJ0KE1hdGgucG93KGkueC1sLngsMikrTWF0aC5wb3coaS55LWwueSwyKSksZz1wLXY7aWYoTWF0aC5hYnMoZyk8cylicmVhaztnPDA/ITE9PT1hP2Q9bzpoPW86ITE9PT1hP2g9bzpkPW8sKyt1fXdoaWxlKGQ8PWgmJnU8cik7cmV0dXJuIEhjKEhjKHt9LGkpLHt9LHt0Om99KX19LHtrZXk6XCJfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2VcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scixzKXt2YXIgYSxoLGQsbCxjLHU9MWU5LGY9dCxwPWU7Zm9yKGg9MTtoPDEwO2grKylkPS4xKmgsbD1NYXRoLnBvdygxLWQsMikqdCsyKmQqKDEtZCkqcy54K01hdGgucG93KGQsMikqaSxjPU1hdGgucG93KDEtZCwyKSplKzIqZCooMS1kKSpzLnkrTWF0aC5wb3coZCwyKSpvLGg+MCYmKHU9KGE9dGhpcy5fZ2V0RGlzdGFuY2VUb0xpbmUoZixwLGwsYyxuLHIpKTx1P2E6dSksZj1sLHA9YztyZXR1cm4gdX19LHtrZXk6XCJfYmV6aWVyQ3VydmVcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvKXt0LmJlZ2luUGF0aCgpLHQubW92ZVRvKHRoaXMuZnJvbVBvaW50LngsdGhpcy5mcm9tUG9pbnQueSksbnVsbCE9aSYmbnVsbCE9aS54P251bGwhPW8mJm51bGwhPW8ueD90LmJlemllckN1cnZlVG8oaS54LGkueSxvLngsby55LHRoaXMudG9Qb2ludC54LHRoaXMudG9Qb2ludC55KTp0LnF1YWRyYXRpY0N1cnZlVG8oaS54LGkueSx0aGlzLnRvUG9pbnQueCx0aGlzLnRvUG9pbnQueSk6dC5saW5lVG8odGhpcy50b1BvaW50LngsdGhpcy50b1BvaW50LnkpLHRoaXMuZHJhd0JhY2tncm91bmQodCxlKSx0aGlzLmVuYWJsZVNoYWRvdyh0LGUpLHQuc3Ryb2tlKCksdGhpcy5kaXNhYmxlU2hhZG93KHQsZSl9fSx7a2V5OlwiZ2V0VmlhTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCl9fV0pLGl9KGpjKTtmdW5jdGlvbiBxYyh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciBVYz1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPXFjKGkpO2Z1bmN0aW9uIGkodCxvLG4pe3ZhciByO3JldHVybiBQbyh0aGlzLGkpLChyPWUuY2FsbCh0aGlzLHQsbyxuKSkudmlhPXIudmlhLHIuX2JvdW5kRnVuY3Rpb249ZnVuY3Rpb24oKXtyLnBvc2l0aW9uQmV6aWVyTm9kZSgpfSxyLl9ib2R5LmVtaXR0ZXIub24oXCJfcmVwb3NpdGlvbkJlemllck5vZGVzXCIsci5fYm91bmRGdW5jdGlvbikscn1yZXR1cm4gSW8oaSxbe2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXtnYyhfbChpLnByb3RvdHlwZSksXCJzZXRPcHRpb25zXCIsdGhpcykuY2FsbCh0aGlzLHQpO3ZhciBlPSExO3RoaXMub3B0aW9ucy5waHlzaWNzIT09dC5waHlzaWNzJiYoZT0hMCksdGhpcy5vcHRpb25zPXQsdGhpcy5pZD10aGlzLm9wdGlvbnMuaWQsdGhpcy5mcm9tPXRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dLHRoaXMudG89dGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dLHRoaXMuc2V0dXBTdXBwb3J0Tm9kZSgpLHRoaXMuY29ubmVjdCgpLCEwPT09ZSYmKHRoaXMudmlhLnNldE9wdGlvbnMoe3BoeXNpY3M6dGhpcy5vcHRpb25zLnBoeXNpY3N9KSx0aGlzLnBvc2l0aW9uQmV6aWVyTm9kZSgpKX19LHtrZXk6XCJjb25uZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmZyb209dGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV0sdGhpcy50bz10aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b10sdm9pZCAwPT09dGhpcy5mcm9tfHx2b2lkIDA9PT10aGlzLnRvfHwhMT09PXRoaXMub3B0aW9ucy5waHlzaWNzfHx0aGlzLmZyb20uaWQ9PT10aGlzLnRvLmlkP3RoaXMudmlhLnNldE9wdGlvbnMoe3BoeXNpY3M6ITF9KTp0aGlzLnZpYS5zZXRPcHRpb25zKHtwaHlzaWNzOiEwfSl9fSx7a2V5OlwiY2xlYW51cFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JvZHkuZW1pdHRlci5vZmYoXCJfcmVwb3NpdGlvbkJlemllck5vZGVzXCIsdGhpcy5fYm91bmRGdW5jdGlvbiksdm9pZCAwIT09dGhpcy52aWEmJihkZWxldGUgdGhpcy5fYm9keS5ub2Rlc1t0aGlzLnZpYS5pZF0sdGhpcy52aWE9dm9pZCAwLCEwKX19LHtrZXk6XCJzZXR1cFN1cHBvcnROb2RlXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih2b2lkIDA9PT10aGlzLnZpYSl7dmFyIHQ9XCJlZGdlSWQ6XCIrdGhpcy5pZCxlPXRoaXMuX2JvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUoe2lkOnQsc2hhcGU6XCJjaXJjbGVcIixwaHlzaWNzOiEwLGhpZGRlbjohMH0pO3RoaXMuX2JvZHkubm9kZXNbdF09ZSx0aGlzLnZpYT1lLHRoaXMudmlhLnBhcmVudEVkZ2VJZD10aGlzLmlkLHRoaXMucG9zaXRpb25CZXppZXJOb2RlKCl9fX0se2tleTpcInBvc2l0aW9uQmV6aWVyTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dm9pZCAwIT09dGhpcy52aWEmJnZvaWQgMCE9PXRoaXMuZnJvbSYmdm9pZCAwIT09dGhpcy50bz8odGhpcy52aWEueD0uNSoodGhpcy5mcm9tLngrdGhpcy50by54KSx0aGlzLnZpYS55PS41Kih0aGlzLmZyb20ueSt0aGlzLnRvLnkpKTp2b2lkIDAhPT10aGlzLnZpYSYmKHRoaXMudmlhLng9MCx0aGlzLnZpYS55PTApfX0se2tleTpcIl9saW5lXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3RoaXMuX2JlemllckN1cnZlKHQsZSxpKX19LHtrZXk6XCJfZ2V0VmlhQ29vcmRpbmF0ZXNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZpYX19LHtrZXk6XCJnZXRWaWFOb2RlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWF9fSx7a2V5OlwiZ2V0UG9pbnRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy52aWE7aWYodGhpcy5mcm9tPT09dGhpcy50byl7dmFyIGk9dGhpcy5fZ2V0Q2lyY2xlRGF0YSgpLG89YW4oaSwzKSxuPW9bMF0scj1vWzFdLHM9b1syXSxhPTIqTWF0aC5QSSooMS10KTtyZXR1cm57eDpuK3MqTWF0aC5zaW4oYSkseTpyK3MtcyooMS1NYXRoLmNvcyhhKSl9fXJldHVybnt4Ok1hdGgucG93KDEtdCwyKSp0aGlzLmZyb21Qb2ludC54KzIqdCooMS10KSplLngrTWF0aC5wb3codCwyKSp0aGlzLnRvUG9pbnQueCx5Ok1hdGgucG93KDEtdCwyKSp0aGlzLmZyb21Qb2ludC55KzIqdCooMS10KSplLnkrTWF0aC5wb3codCwyKSp0aGlzLnRvUG9pbnQueX19fSx7a2V5OlwiX2ZpbmRCb3JkZXJQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcih0LGUsdGhpcy52aWEpfX0se2tleTpcIl9nZXREaXN0YW5jZVRvRWRnZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXtyZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UodCxlLGksbyxuLHIsdGhpcy52aWEpfX1dKSxpfShWYyk7ZnVuY3Rpb24gWWModCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgWGM9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1ZYyhpKTtmdW5jdGlvbiBpKHQsbyxuKXtyZXR1cm4gUG8odGhpcyxpKSxlLmNhbGwodGhpcyx0LG8sbil9cmV0dXJuIElvKGksW3trZXk6XCJfbGluZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt0aGlzLl9iZXppZXJDdXJ2ZSh0LGUsaSl9fSx7a2V5OlwiZ2V0VmlhTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCl9fSx7a2V5OlwiX2dldFZpYUNvb3JkaW5hdGVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlLGk9dGhpcy5vcHRpb25zLnNtb290aC5yb3VuZG5lc3Msbz10aGlzLm9wdGlvbnMuc21vb3RoLnR5cGUsbj1NYXRoLmFicyh0aGlzLmZyb20ueC10aGlzLnRvLngpLHI9TWF0aC5hYnModGhpcy5mcm9tLnktdGhpcy50by55KTtpZihcImRpc2NyZXRlXCI9PT1vfHxcImRpYWdvbmFsQ3Jvc3NcIj09PW8pe3ZhciBzLGE7cz1hPW48PXI/aSpyOmkqbix0aGlzLmZyb20ueD50aGlzLnRvLngmJihzPS1zKSx0aGlzLmZyb20ueT49dGhpcy50by55JiYoYT0tYSk7dmFyIGg9dGhpcy5mcm9tLngrcyxkPXRoaXMuZnJvbS55K2E7cmV0dXJuXCJkaXNjcmV0ZVwiPT09byYmKG48PXI/aD1uPGkqcj90aGlzLmZyb20ueDpoOmQ9cjxpKm4/dGhpcy5mcm9tLnk6ZCkse3g6aCx5OmR9fWlmKFwic3RyYWlnaHRDcm9zc1wiPT09byl7dmFyIGw9KDEtaSkqbixjPSgxLWkpKnI7cmV0dXJuIG48PXI/KGw9MCx0aGlzLmZyb20ueTx0aGlzLnRvLnkmJihjPS1jKSk6KHRoaXMuZnJvbS54PHRoaXMudG8ueCYmKGw9LWwpLGM9MCkse3g6dGhpcy50by54K2wseTp0aGlzLnRvLnkrY319aWYoXCJob3Jpem9udGFsXCI9PT1vKXt2YXIgdT0oMS1pKSpuO3JldHVybiB0aGlzLmZyb20ueDx0aGlzLnRvLngmJih1PS11KSx7eDp0aGlzLnRvLngrdSx5OnRoaXMuZnJvbS55fX1pZihcInZlcnRpY2FsXCI9PT1vKXt2YXIgZj0oMS1pKSpyO3JldHVybiB0aGlzLmZyb20ueTx0aGlzLnRvLnkmJihmPS1mKSx7eDp0aGlzLmZyb20ueCx5OnRoaXMudG8ueStmfX1pZihcImN1cnZlZENXXCI9PT1vKXtuPXRoaXMudG8ueC10aGlzLmZyb20ueCxyPXRoaXMuZnJvbS55LXRoaXMudG8ueTt2YXIgcD1NYXRoLnNxcnQobipuK3Iqciksdj1NYXRoLlBJLGc9KE1hdGguYXRhbjIocixuKSsoLjUqaSsuNSkqdiklKDIqdik7cmV0dXJue3g6dGhpcy5mcm9tLngrKC41KmkrLjUpKnAqTWF0aC5zaW4oZykseTp0aGlzLmZyb20ueSsoLjUqaSsuNSkqcCpNYXRoLmNvcyhnKX19aWYoXCJjdXJ2ZWRDQ1dcIj09PW8pe249dGhpcy50by54LXRoaXMuZnJvbS54LHI9dGhpcy5mcm9tLnktdGhpcy50by55O3ZhciB5PU1hdGguc3FydChuKm4rcipyKSxtPU1hdGguUEksYj0oTWF0aC5hdGFuMihyLG4pKyguNSotaSsuNSkqbSklKDIqbSk7cmV0dXJue3g6dGhpcy5mcm9tLngrKC41KmkrLjUpKnkqTWF0aC5zaW4oYikseTp0aGlzLmZyb20ueSsoLjUqaSsuNSkqeSpNYXRoLmNvcyhiKX19dD1lPW48PXI/aSpyOmkqbix0aGlzLmZyb20ueD50aGlzLnRvLngmJih0PS10KSx0aGlzLmZyb20ueT49dGhpcy50by55JiYoZT0tZSk7dmFyIHc9dGhpcy5mcm9tLngrdCxrPXRoaXMuZnJvbS55K2U7cmV0dXJuIG48PXI/dz10aGlzLmZyb20ueDw9dGhpcy50by54P3RoaXMudG8ueDx3P3RoaXMudG8ueDp3OnRoaXMudG8ueD53P3RoaXMudG8ueDp3Oms9dGhpcy5mcm9tLnk+PXRoaXMudG8ueT90aGlzLnRvLnk+az90aGlzLnRvLnk6azp0aGlzLnRvLnk8az90aGlzLnRvLnk6ayx7eDp3LHk6a319fSx7a2V5OlwiX2ZpbmRCb3JkZXJQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnt9O3JldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIodCxlLGkudmlhKX19LHtrZXk6XCJfZ2V0RGlzdGFuY2VUb0VkZ2VcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7dmFyIHM9YXJndW1lbnRzLmxlbmd0aD42JiZ2b2lkIDAhPT1hcmd1bWVudHNbNl0/YXJndW1lbnRzWzZdOnRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7cmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHQsZSxpLG8sbixyLHMpfX0se2tleTpcImdldFBvaW50XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCksaT10LG89TWF0aC5wb3coMS1pLDIpKnRoaXMuZnJvbVBvaW50LngrMippKigxLWkpKmUueCtNYXRoLnBvdyhpLDIpKnRoaXMudG9Qb2ludC54LG49TWF0aC5wb3coMS1pLDIpKnRoaXMuZnJvbVBvaW50LnkrMippKigxLWkpKmUueStNYXRoLnBvdyhpLDIpKnRoaXMudG9Qb2ludC55O3JldHVybnt4Om8seTpufX19XSksaX0oVmMpO2Z1bmN0aW9uIEdjKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19ZnVuY3Rpb24gS2ModCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgJGM9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1LYyhpKTtmdW5jdGlvbiBpKHQsbyxuKXtyZXR1cm4gUG8odGhpcyxpKSxlLmNhbGwodGhpcyx0LG8sbil9cmV0dXJuIElvKGksW3trZXk6XCJfbGluZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz1pWzBdLG49aVsxXTt0aGlzLl9iZXppZXJDdXJ2ZSh0LGUsbyxuKX19LHtrZXk6XCJfZ2V0VmlhQ29vcmRpbmF0ZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGUsaSxvLG49dGhpcy5mcm9tLngtdGhpcy50by54LHI9dGhpcy5mcm9tLnktdGhpcy50by55LHM9dGhpcy5vcHRpb25zLnNtb290aC5yb3VuZG5lc3M7cmV0dXJuKE1hdGguYWJzKG4pPk1hdGguYWJzKHIpfHwhMD09PXRoaXMub3B0aW9ucy5zbW9vdGguZm9yY2VEaXJlY3Rpb258fFwiaG9yaXpvbnRhbFwiPT09dGhpcy5vcHRpb25zLnNtb290aC5mb3JjZURpcmVjdGlvbikmJlwidmVydGljYWxcIiE9PXRoaXMub3B0aW9ucy5zbW9vdGguZm9yY2VEaXJlY3Rpb24/KGU9dGhpcy5mcm9tLnksbz10aGlzLnRvLnksdD10aGlzLmZyb20ueC1zKm4saT10aGlzLnRvLngrcypuKTooZT10aGlzLmZyb20ueS1zKnIsbz10aGlzLnRvLnkrcypyLHQ9dGhpcy5mcm9tLngsaT10aGlzLnRvLngpLFt7eDp0LHk6ZX0se3g6aSx5Om99XX19LHtrZXk6XCJnZXRWaWFOb2RlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKX19LHtrZXk6XCJfZmluZEJvcmRlclBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKHQsZSl9fSx7a2V5OlwiX2dldERpc3RhbmNlVG9FZGdlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3ZhciBzPWFyZ3VtZW50cy5sZW5ndGg+NiYmdm9pZCAwIT09YXJndW1lbnRzWzZdP2FyZ3VtZW50c1s2XTp0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpLGE9YW4ocywyKSxoPWFbMF0sZD1hWzFdO3JldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZTIodCxlLGksbyxuLHIsaCxkKX19LHtrZXk6XCJnZXRQb2ludFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpLGk9YW4oZSwyKSxvPWlbMF0sbj1pWzFdLHI9dCxzPVtNYXRoLnBvdygxLXIsMyksMypyKk1hdGgucG93KDEtciwyKSwzKk1hdGgucG93KHIsMikqKDEtciksTWF0aC5wb3cociwzKV0sYT1zWzBdKnRoaXMuZnJvbVBvaW50Lngrc1sxXSpvLngrc1syXSpuLngrc1szXSp0aGlzLnRvUG9pbnQueCxoPXNbMF0qdGhpcy5mcm9tUG9pbnQueStzWzFdKm8ueStzWzJdKm4ueStzWzNdKnRoaXMudG9Qb2ludC55O3JldHVybnt4OmEseTpofX19XSksaX0oZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1HYyhpKTtmdW5jdGlvbiBpKHQsbyxuKXtyZXR1cm4gUG8odGhpcyxpKSxlLmNhbGwodGhpcyx0LG8sbil9cmV0dXJuIElvKGksW3trZXk6XCJfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UyXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIscyxhKXtmb3IodmFyIGg9MWU5LGQ9dCxsPWUsYz1bMCwwLDAsMF0sdT0xO3U8MTA7dSsrKXt2YXIgZj0uMSp1O2NbMF09TWF0aC5wb3coMS1mLDMpLGNbMV09MypmKk1hdGgucG93KDEtZiwyKSxjWzJdPTMqTWF0aC5wb3coZiwyKSooMS1mKSxjWzNdPU1hdGgucG93KGYsMyk7dmFyIHA9Y1swXSp0K2NbMV0qcy54K2NbMl0qYS54K2NbM10qaSx2PWNbMF0qZStjWzFdKnMueStjWzJdKmEueStjWzNdKm87aWYodT4wKXt2YXIgZz10aGlzLl9nZXREaXN0YW5jZVRvTGluZShkLGwscCx2LG4scik7aD1nPGg/ZzpofWQ9cCxsPXZ9cmV0dXJuIGh9fV0pLGl9KFZjKSk7ZnVuY3Rpb24gUWModCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgWmM9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1RYyhpKTtmdW5jdGlvbiBpKHQsbyxuKXtyZXR1cm4gUG8odGhpcyxpKSxlLmNhbGwodGhpcyx0LG8sbil9cmV0dXJuIElvKGksW3trZXk6XCJfbGluZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dC5iZWdpblBhdGgoKSx0Lm1vdmVUbyh0aGlzLmZyb21Qb2ludC54LHRoaXMuZnJvbVBvaW50LnkpLHQubGluZVRvKHRoaXMudG9Qb2ludC54LHRoaXMudG9Qb2ludC55KSx0aGlzLmVuYWJsZVNoYWRvdyh0LGUpLHQuc3Ryb2tlKCksdGhpcy5kaXNhYmxlU2hhZG93KHQsZSl9fSx7a2V5OlwiZ2V0VmlhTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcImdldFBvaW50XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJue3g6KDEtdCkqdGhpcy5mcm9tUG9pbnQueCt0KnRoaXMudG9Qb2ludC54LHk6KDEtdCkqdGhpcy5mcm9tUG9pbnQueSt0KnRoaXMudG9Qb2ludC55fX19LHtrZXk6XCJfZmluZEJvcmRlclBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLnRvLG89dGhpcy5mcm9tO3QuaWQ9PT10aGlzLmZyb20uaWQmJihpPXRoaXMuZnJvbSxvPXRoaXMudG8pO3ZhciBuPU1hdGguYXRhbjIoaS55LW8ueSxpLngtby54KSxyPWkueC1vLngscz1pLnktby55LGE9TWF0aC5zcXJ0KHIqcitzKnMpLGg9KGEtdC5kaXN0YW5jZVRvQm9yZGVyKGUsbikpL2E7cmV0dXJue3g6KDEtaCkqby54K2gqaS54LHk6KDEtaCkqby55K2gqaS55LHQ6MH19fSx7a2V5OlwiX2dldERpc3RhbmNlVG9FZGdlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3JldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvTGluZSh0LGUsaSxvLG4scil9fV0pLGl9KGpjKSxKYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8sbixyKXtpZihQbyh0aGlzLHQpLHZvaWQgMD09PWkpdGhyb3cgbmV3IEVycm9yKFwiTm8gYm9keSBwcm92aWRlZFwiKTt0aGlzLm9wdGlvbnM9dmgobiksdGhpcy5nbG9iYWxPcHRpb25zPW4sdGhpcy5kZWZhdWx0T3B0aW9ucz1yLHRoaXMuYm9keT1pLHRoaXMuaW1hZ2VsaXN0PW8sdGhpcy5pZD12b2lkIDAsdGhpcy5mcm9tSWQ9dm9pZCAwLHRoaXMudG9JZD12b2lkIDAsdGhpcy5zZWxlY3RlZD0hMSx0aGlzLmhvdmVyPSExLHRoaXMubGFiZWxEaXJ0eT0hMCx0aGlzLmJhc2VXaWR0aD10aGlzLm9wdGlvbnMud2lkdGgsdGhpcy5iYXNlRm9udFNpemU9dGhpcy5vcHRpb25zLmZvbnQuc2l6ZSx0aGlzLmZyb209dm9pZCAwLHRoaXMudG89dm9pZCAwLHRoaXMuZWRnZVR5cGU9dm9pZCAwLHRoaXMuY29ubmVjdGVkPSExLHRoaXMubGFiZWxNb2R1bGU9bmV3IGxsKHRoaXMuYm9keSx0aGlzLm9wdGlvbnMsITApLHRoaXMuc2V0T3B0aW9ucyhlKX1yZXR1cm4gSW8odCxbe2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbihlKXtpZihlKXt2YXIgaT12b2lkIDAhPT1lLnBoeXNpY3MmJnRoaXMub3B0aW9ucy5waHlzaWNzIT09ZS5waHlzaWNzfHx2b2lkIDAhPT1lLmhpZGRlbiYmKHRoaXMub3B0aW9ucy5oaWRkZW58fCExKSE9PShlLmhpZGRlbnx8ITEpfHx2b2lkIDAhPT1lLmZyb20mJnRoaXMub3B0aW9ucy5mcm9tIT09ZS5mcm9tfHx2b2lkIDAhPT1lLnRvJiZ0aGlzLm9wdGlvbnMudG8hPT1lLnRvO3QucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucyxlLCEwLHRoaXMuZ2xvYmFsT3B0aW9ucyksdm9pZCAwIT09ZS5pZCYmKHRoaXMuaWQ9ZS5pZCksdm9pZCAwIT09ZS5mcm9tJiYodGhpcy5mcm9tSWQ9ZS5mcm9tKSx2b2lkIDAhPT1lLnRvJiYodGhpcy50b0lkPWUudG8pLHZvaWQgMCE9PWUudGl0bGUmJih0aGlzLnRpdGxlPWUudGl0bGUpLHZvaWQgMCE9PWUudmFsdWUmJihlLnZhbHVlPVlkKGUudmFsdWUpKTt2YXIgbz1bZSx0aGlzLm9wdGlvbnMsdGhpcy5kZWZhdWx0T3B0aW9uc107cmV0dXJuIHRoaXMuY2hvb3Nlcj1RZChcImVkZ2VcIixvKSx0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKGUpLGk9dGhpcy51cGRhdGVFZGdlVHlwZSgpfHxpLHRoaXMuX3NldEludGVyYWN0aW9uV2lkdGhzKCksdGhpcy5jb25uZWN0KCksaX19fSx7a2V5OlwiZ2V0Rm9ybWF0dGluZ1ZhbHVlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9ITA9PT10aGlzLm9wdGlvbnMuYXJyb3dzLnRvfHwhMD09PXRoaXMub3B0aW9ucy5hcnJvd3MudG8uZW5hYmxlZCxlPSEwPT09dGhpcy5vcHRpb25zLmFycm93cy5mcm9tfHwhMD09PXRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS5lbmFibGVkLGk9ITA9PT10aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZXx8ITA9PT10aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5lbmFibGVkLG89dGhpcy5vcHRpb25zLmNvbG9yLmluaGVyaXQsbj17dG9BcnJvdzp0LHRvQXJyb3dTY2FsZTp0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLnNjYWxlRmFjdG9yLHRvQXJyb3dUeXBlOnRoaXMub3B0aW9ucy5hcnJvd3MudG8udHlwZSx0b0Fycm93U3JjOnRoaXMub3B0aW9ucy5hcnJvd3MudG8uc3JjLHRvQXJyb3dJbWFnZVdpZHRoOnRoaXMub3B0aW9ucy5hcnJvd3MudG8uaW1hZ2VXaWR0aCx0b0Fycm93SW1hZ2VIZWlnaHQ6dGhpcy5vcHRpb25zLmFycm93cy50by5pbWFnZUhlaWdodCxtaWRkbGVBcnJvdzppLG1pZGRsZUFycm93U2NhbGU6dGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuc2NhbGVGYWN0b3IsbWlkZGxlQXJyb3dUeXBlOnRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLnR5cGUsbWlkZGxlQXJyb3dTcmM6dGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuc3JjLG1pZGRsZUFycm93SW1hZ2VXaWR0aDp0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5pbWFnZVdpZHRoLG1pZGRsZUFycm93SW1hZ2VIZWlnaHQ6dGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuaW1hZ2VIZWlnaHQsZnJvbUFycm93OmUsZnJvbUFycm93U2NhbGU6dGhpcy5vcHRpb25zLmFycm93cy5mcm9tLnNjYWxlRmFjdG9yLGZyb21BcnJvd1R5cGU6dGhpcy5vcHRpb25zLmFycm93cy5mcm9tLnR5cGUsZnJvbUFycm93U3JjOnRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS5zcmMsZnJvbUFycm93SW1hZ2VXaWR0aDp0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uaW1hZ2VXaWR0aCxmcm9tQXJyb3dJbWFnZUhlaWdodDp0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uaW1hZ2VIZWlnaHQsYXJyb3dTdHJpa2V0aHJvdWdoOnRoaXMub3B0aW9ucy5hcnJvd1N0cmlrZXRocm91Z2gsY29sb3I6bz92b2lkIDA6dGhpcy5vcHRpb25zLmNvbG9yLmNvbG9yLGluaGVyaXRzQ29sb3I6byxvcGFjaXR5OnRoaXMub3B0aW9ucy5jb2xvci5vcGFjaXR5LGhpZGRlbjp0aGlzLm9wdGlvbnMuaGlkZGVuLGxlbmd0aDp0aGlzLm9wdGlvbnMubGVuZ3RoLHNoYWRvdzp0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQsc2hhZG93Q29sb3I6dGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvcixzaGFkb3dTaXplOnRoaXMub3B0aW9ucy5zaGFkb3cuc2l6ZSxzaGFkb3dYOnRoaXMub3B0aW9ucy5zaGFkb3cueCxzaGFkb3dZOnRoaXMub3B0aW9ucy5zaGFkb3cueSxkYXNoZXM6dGhpcy5vcHRpb25zLmRhc2hlcyx3aWR0aDp0aGlzLm9wdGlvbnMud2lkdGgsYmFja2dyb3VuZDp0aGlzLm9wdGlvbnMuYmFja2dyb3VuZC5lbmFibGVkLGJhY2tncm91bmRDb2xvcjp0aGlzLm9wdGlvbnMuYmFja2dyb3VuZC5jb2xvcixiYWNrZ3JvdW5kU2l6ZTp0aGlzLm9wdGlvbnMuYmFja2dyb3VuZC5zaXplLGJhY2tncm91bmREYXNoZXM6dGhpcy5vcHRpb25zLmJhY2tncm91bmQuZGFzaGVzfTtpZih0aGlzLnNlbGVjdGVkfHx0aGlzLmhvdmVyKWlmKCEwPT09dGhpcy5jaG9vc2VyKXtpZih0aGlzLnNlbGVjdGVkKXt2YXIgcj10aGlzLm9wdGlvbnMuc2VsZWN0aW9uV2lkdGg7XCJmdW5jdGlvblwiPT10eXBlb2Ygcj9uLndpZHRoPXIobi53aWR0aCk6XCJudW1iZXJcIj09dHlwZW9mIHImJihuLndpZHRoKz1yKSxuLndpZHRoPU1hdGgubWF4KG4ud2lkdGgsLjMvdGhpcy5ib2R5LnZpZXcuc2NhbGUpLG4uY29sb3I9dGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodCxuLnNoYWRvdz10aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWR9ZWxzZSBpZih0aGlzLmhvdmVyKXt2YXIgcz10aGlzLm9wdGlvbnMuaG92ZXJXaWR0aDtcImZ1bmN0aW9uXCI9PXR5cGVvZiBzP24ud2lkdGg9cyhuLndpZHRoKTpcIm51bWJlclwiPT10eXBlb2YgcyYmKG4ud2lkdGgrPXMpLG4ud2lkdGg9TWF0aC5tYXgobi53aWR0aCwuMy90aGlzLmJvZHkudmlldy5zY2FsZSksbi5jb2xvcj10aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIsbi5zaGFkb3c9dGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkfX1lbHNlXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5jaG9vc2VyJiYodGhpcy5jaG9vc2VyKG4sdGhpcy5vcHRpb25zLmlkLHRoaXMuc2VsZWN0ZWQsdGhpcy5ob3Zlciksdm9pZCAwIT09bi5jb2xvciYmKG4uaW5oZXJpdHNDb2xvcj0hMSksITE9PT1uLnNoYWRvdyYmKG4uc2hhZG93Q29sb3I9PT10aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yJiZuLnNoYWRvd1NpemU9PT10aGlzLm9wdGlvbnMuc2hhZG93LnNpemUmJm4uc2hhZG93WD09PXRoaXMub3B0aW9ucy5zaGFkb3cueCYmbi5zaGFkb3dZPT09dGhpcy5vcHRpb25zLnNoYWRvdy55fHwobi5zaGFkb3c9ITApKSk7ZWxzZSBuLnNoYWRvdz10aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQsbi53aWR0aD1NYXRoLm1heChuLndpZHRoLC4zL3RoaXMuYm9keS52aWV3LnNjYWxlKTtyZXR1cm4gbn19LHtrZXk6XCJ1cGRhdGVMYWJlbE1vZHVsZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPVt0LHRoaXMub3B0aW9ucyx0aGlzLmdsb2JhbE9wdGlvbnMsdGhpcy5kZWZhdWx0T3B0aW9uc107dGhpcy5sYWJlbE1vZHVsZS51cGRhdGUodGhpcy5vcHRpb25zLGUpLHZvaWQgMCE9PXRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemUmJih0aGlzLmJhc2VGb250U2l6ZT10aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplKX19LHtrZXk6XCJ1cGRhdGVFZGdlVHlwZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5vcHRpb25zLnNtb290aCxlPSExLGk9ITA7cmV0dXJuIHZvaWQgMCE9PXRoaXMuZWRnZVR5cGUmJigodGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIFVjJiYhMD09PXQuZW5hYmxlZCYmXCJkeW5hbWljXCI9PT10LnR5cGV8fHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiAkYyYmITA9PT10LmVuYWJsZWQmJlwiY3ViaWNCZXppZXJcIj09PXQudHlwZXx8dGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIFhjJiYhMD09PXQuZW5hYmxlZCYmXCJkeW5hbWljXCIhPT10LnR5cGUmJlwiY3ViaWNCZXppZXJcIiE9PXQudHlwZXx8dGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIFpjJiYhMT09PXQudHlwZS5lbmFibGVkKSYmKGk9ITEpLCEwPT09aSYmKGU9dGhpcy5jbGVhbnVwKCkpKSwhMD09PWk/ITA9PT10LmVuYWJsZWQ/XCJkeW5hbWljXCI9PT10LnR5cGU/KGU9ITAsdGhpcy5lZGdlVHlwZT1uZXcgVWModGhpcy5vcHRpb25zLHRoaXMuYm9keSx0aGlzLmxhYmVsTW9kdWxlKSk6XCJjdWJpY0JlemllclwiPT09dC50eXBlP3RoaXMuZWRnZVR5cGU9bmV3ICRjKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSk6dGhpcy5lZGdlVHlwZT1uZXcgWGModGhpcy5vcHRpb25zLHRoaXMuYm9keSx0aGlzLmxhYmVsTW9kdWxlKTp0aGlzLmVkZ2VUeXBlPW5ldyBaYyh0aGlzLm9wdGlvbnMsdGhpcy5ib2R5LHRoaXMubGFiZWxNb2R1bGUpOnRoaXMuZWRnZVR5cGUuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpLGV9fSx7a2V5OlwiY29ubmVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5kaXNjb25uZWN0KCksdGhpcy5mcm9tPXRoaXMuYm9keS5ub2Rlc1t0aGlzLmZyb21JZF18fHZvaWQgMCx0aGlzLnRvPXRoaXMuYm9keS5ub2Rlc1t0aGlzLnRvSWRdfHx2b2lkIDAsdGhpcy5jb25uZWN0ZWQ9dm9pZCAwIT09dGhpcy5mcm9tJiZ2b2lkIDAhPT10aGlzLnRvLCEwPT09dGhpcy5jb25uZWN0ZWQ/KHRoaXMuZnJvbS5hdHRhY2hFZGdlKHRoaXMpLHRoaXMudG8uYXR0YWNoRWRnZSh0aGlzKSk6KHRoaXMuZnJvbSYmdGhpcy5mcm9tLmRldGFjaEVkZ2UodGhpcyksdGhpcy50byYmdGhpcy50by5kZXRhY2hFZGdlKHRoaXMpKSx0aGlzLmVkZ2VUeXBlLmNvbm5lY3QoKX19LHtrZXk6XCJkaXNjb25uZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmZyb20mJih0aGlzLmZyb20uZGV0YWNoRWRnZSh0aGlzKSx0aGlzLmZyb209dm9pZCAwKSx0aGlzLnRvJiYodGhpcy50by5kZXRhY2hFZGdlKHRoaXMpLHRoaXMudG89dm9pZCAwKSx0aGlzLmNvbm5lY3RlZD0hMX19LHtrZXk6XCJnZXRUaXRsZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGl0bGV9fSx7a2V5OlwiaXNTZWxlY3RlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VsZWN0ZWR9fSx7a2V5OlwiZ2V0VmFsdWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbnMudmFsdWV9fSx7a2V5Olwic2V0VmFsdWVSYW5nZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXtpZih2b2lkIDAhPT10aGlzLm9wdGlvbnMudmFsdWUpe3ZhciBvPXRoaXMub3B0aW9ucy5zY2FsaW5nLmN1c3RvbVNjYWxpbmdGdW5jdGlvbih0LGUsaSx0aGlzLm9wdGlvbnMudmFsdWUpLG49dGhpcy5vcHRpb25zLnNjYWxpbmcubWF4LXRoaXMub3B0aW9ucy5zY2FsaW5nLm1pbjtpZighMD09PXRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLmVuYWJsZWQpe3ZhciByPXRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1heC10aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW47dGhpcy5vcHRpb25zLmZvbnQuc2l6ZT10aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW4rbypyfXRoaXMub3B0aW9ucy53aWR0aD10aGlzLm9wdGlvbnMuc2NhbGluZy5taW4rbypufWVsc2UgdGhpcy5vcHRpb25zLndpZHRoPXRoaXMuYmFzZVdpZHRoLHRoaXMub3B0aW9ucy5mb250LnNpemU9dGhpcy5iYXNlRm9udFNpemU7dGhpcy5fc2V0SW50ZXJhY3Rpb25XaWR0aHMoKSx0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKCl9fSx7a2V5OlwiX3NldEludGVyYWN0aW9uV2lkdGhzXCIsdmFsdWU6ZnVuY3Rpb24oKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuaG92ZXJXaWR0aD90aGlzLmVkZ2VUeXBlLmhvdmVyV2lkdGg9dGhpcy5vcHRpb25zLmhvdmVyV2lkdGgodGhpcy5vcHRpb25zLndpZHRoKTp0aGlzLmVkZ2VUeXBlLmhvdmVyV2lkdGg9dGhpcy5vcHRpb25zLmhvdmVyV2lkdGgrdGhpcy5vcHRpb25zLndpZHRoLFwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aD90aGlzLmVkZ2VUeXBlLnNlbGVjdGlvbldpZHRoPXRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aCh0aGlzLm9wdGlvbnMud2lkdGgpOnRoaXMuZWRnZVR5cGUuc2VsZWN0aW9uV2lkdGg9dGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoK3RoaXMub3B0aW9ucy53aWR0aH19LHtrZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRGb3JtYXR0aW5nVmFsdWVzKCk7aWYoIWUuaGlkZGVuKXt2YXIgaT10aGlzLmVkZ2VUeXBlLmdldFZpYU5vZGUoKTt0aGlzLmVkZ2VUeXBlLmRyYXdMaW5lKHQsZSx0aGlzLnNlbGVjdGVkLHRoaXMuaG92ZXIsaSksdGhpcy5kcmF3TGFiZWwodCxpKX19fSx7a2V5OlwiZHJhd0Fycm93c1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpO2lmKCFlLmhpZGRlbil7dmFyIGk9dGhpcy5lZGdlVHlwZS5nZXRWaWFOb2RlKCksbz17fTt0aGlzLmVkZ2VUeXBlLmZyb21Qb2ludD10aGlzLmVkZ2VUeXBlLmZyb20sdGhpcy5lZGdlVHlwZS50b1BvaW50PXRoaXMuZWRnZVR5cGUudG8sZS5mcm9tQXJyb3cmJihvLmZyb209dGhpcy5lZGdlVHlwZS5nZXRBcnJvd0RhdGEodCxcImZyb21cIixpLHRoaXMuc2VsZWN0ZWQsdGhpcy5ob3ZlcixlKSwhMT09PWUuYXJyb3dTdHJpa2V0aHJvdWdoJiYodGhpcy5lZGdlVHlwZS5mcm9tUG9pbnQ9by5mcm9tLmNvcmUpLGUuZnJvbUFycm93U3JjJiYoby5mcm9tLmltYWdlPXRoaXMuaW1hZ2VsaXN0LmxvYWQoZS5mcm9tQXJyb3dTcmMpKSxlLmZyb21BcnJvd0ltYWdlV2lkdGgmJihvLmZyb20uaW1hZ2VXaWR0aD1lLmZyb21BcnJvd0ltYWdlV2lkdGgpLGUuZnJvbUFycm93SW1hZ2VIZWlnaHQmJihvLmZyb20uaW1hZ2VIZWlnaHQ9ZS5mcm9tQXJyb3dJbWFnZUhlaWdodCkpLGUudG9BcnJvdyYmKG8udG89dGhpcy5lZGdlVHlwZS5nZXRBcnJvd0RhdGEodCxcInRvXCIsaSx0aGlzLnNlbGVjdGVkLHRoaXMuaG92ZXIsZSksITE9PT1lLmFycm93U3RyaWtldGhyb3VnaCYmKHRoaXMuZWRnZVR5cGUudG9Qb2ludD1vLnRvLmNvcmUpLGUudG9BcnJvd1NyYyYmKG8udG8uaW1hZ2U9dGhpcy5pbWFnZWxpc3QubG9hZChlLnRvQXJyb3dTcmMpKSxlLnRvQXJyb3dJbWFnZVdpZHRoJiYoby50by5pbWFnZVdpZHRoPWUudG9BcnJvd0ltYWdlV2lkdGgpLGUudG9BcnJvd0ltYWdlSGVpZ2h0JiYoby50by5pbWFnZUhlaWdodD1lLnRvQXJyb3dJbWFnZUhlaWdodCkpLGUubWlkZGxlQXJyb3cmJihvLm1pZGRsZT10aGlzLmVkZ2VUeXBlLmdldEFycm93RGF0YSh0LFwibWlkZGxlXCIsaSx0aGlzLnNlbGVjdGVkLHRoaXMuaG92ZXIsZSksZS5taWRkbGVBcnJvd1NyYyYmKG8ubWlkZGxlLmltYWdlPXRoaXMuaW1hZ2VsaXN0LmxvYWQoZS5taWRkbGVBcnJvd1NyYykpLGUubWlkZGxlQXJyb3dJbWFnZVdpZHRoJiYoby5taWRkbGUuaW1hZ2VXaWR0aD1lLm1pZGRsZUFycm93SW1hZ2VXaWR0aCksZS5taWRkbGVBcnJvd0ltYWdlSGVpZ2h0JiYoby5taWRkbGUuaW1hZ2VIZWlnaHQ9ZS5taWRkbGVBcnJvd0ltYWdlSGVpZ2h0KSksZS5mcm9tQXJyb3cmJnRoaXMuZWRnZVR5cGUuZHJhd0Fycm93SGVhZCh0LGUsdGhpcy5zZWxlY3RlZCx0aGlzLmhvdmVyLG8uZnJvbSksZS5taWRkbGVBcnJvdyYmdGhpcy5lZGdlVHlwZS5kcmF3QXJyb3dIZWFkKHQsZSx0aGlzLnNlbGVjdGVkLHRoaXMuaG92ZXIsby5taWRkbGUpLGUudG9BcnJvdyYmdGhpcy5lZGdlVHlwZS5kcmF3QXJyb3dIZWFkKHQsZSx0aGlzLnNlbGVjdGVkLHRoaXMuaG92ZXIsby50byl9fX0se2tleTpcImRyYXdMYWJlbFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwIT09dGhpcy5vcHRpb25zLmxhYmVsKXt2YXIgaSxvPXRoaXMuZnJvbSxuPXRoaXMudG87aWYodGhpcy5sYWJlbE1vZHVsZS5kaWZmZXJlbnRTdGF0ZSh0aGlzLnNlbGVjdGVkLHRoaXMuaG92ZXIpJiZ0aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKHQsdGhpcy5zZWxlY3RlZCx0aGlzLmhvdmVyKSxvLmlkIT1uLmlkKXt0aGlzLmxhYmVsTW9kdWxlLnBvaW50VG9TZWxmPSExLGk9dGhpcy5lZGdlVHlwZS5nZXRQb2ludCguNSxlKSx0LnNhdmUoKTt2YXIgcj10aGlzLl9nZXRSb3RhdGlvbih0KTswIT1yLmFuZ2xlJiYodC50cmFuc2xhdGUoci54LHIueSksdC5yb3RhdGUoci5hbmdsZSkpLHRoaXMubGFiZWxNb2R1bGUuZHJhdyh0LGkueCxpLnksdGhpcy5zZWxlY3RlZCx0aGlzLmhvdmVyKSx0LnJlc3RvcmUoKX1lbHNle3RoaXMubGFiZWxNb2R1bGUucG9pbnRUb1NlbGY9ITA7dmFyIHM9dGwodCx0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSx0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplLG8pO2k9dGhpcy5fcG9pbnRPbkNpcmNsZShzLngscy55LHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLnNpemUsdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUpLHRoaXMubGFiZWxNb2R1bGUuZHJhdyh0LGkueCxpLnksdGhpcy5zZWxlY3RlZCx0aGlzLmhvdmVyKX19fX0se2tleTpcImdldEl0ZW1zT25Qb2ludFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPVtdO2lmKHRoaXMubGFiZWxNb2R1bGUudmlzaWJsZSgpKXt2YXIgaT10aGlzLl9nZXRSb3RhdGlvbigpO1pkKHRoaXMubGFiZWxNb2R1bGUuZ2V0U2l6ZSgpLHQsaSkmJmUucHVzaCh7ZWRnZUlkOnRoaXMuaWQsbGFiZWxJZDowfSl9dmFyIG89e2xlZnQ6dC54LHRvcDp0Lnl9O3JldHVybiB0aGlzLmlzT3ZlcmxhcHBpbmdXaXRoKG8pJiZlLnB1c2goe2VkZ2VJZDp0aGlzLmlkfSksZX19LHtrZXk6XCJpc092ZXJsYXBwaW5nV2l0aFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHRoaXMuY29ubmVjdGVkKXt2YXIgZT10aGlzLmZyb20ueCxpPXRoaXMuZnJvbS55LG89dGhpcy50by54LG49dGhpcy50by55LHI9dC5sZWZ0LHM9dC50b3A7cmV0dXJuIHRoaXMuZWRnZVR5cGUuZ2V0RGlzdGFuY2VUb0VkZ2UoZSxpLG8sbixyLHMpPDEwfXJldHVybiExfX0se2tleTpcIl9nZXRSb3RhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZWRnZVR5cGUuZ2V0VmlhTm9kZSgpLGk9dGhpcy5lZGdlVHlwZS5nZXRQb2ludCguNSxlKTt2b2lkIDAhPT10JiZ0aGlzLmxhYmVsTW9kdWxlLmNhbGN1bGF0ZUxhYmVsU2l6ZSh0LHRoaXMuc2VsZWN0ZWQsdGhpcy5ob3ZlcixpLngsaS55KTt2YXIgbz17eDppLngseTp0aGlzLmxhYmVsTW9kdWxlLnNpemUueUxpbmUsYW5nbGU6MH07aWYoIXRoaXMubGFiZWxNb2R1bGUudmlzaWJsZSgpKXJldHVybiBvO2lmKFwiaG9yaXpvbnRhbFwiPT09dGhpcy5vcHRpb25zLmZvbnQuYWxpZ24pcmV0dXJuIG87dmFyIG49dGhpcy5mcm9tLnktdGhpcy50by55LHI9dGhpcy5mcm9tLngtdGhpcy50by54LHM9TWF0aC5hdGFuMihuLHIpO3JldHVybihzPC0xJiZyPDB8fHM+MCYmcjwwKSYmKHMrPU1hdGguUEkpLG8uYW5nbGU9cyxvfX0se2tleTpcIl9wb2ludE9uQ2lyY2xlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyl7cmV0dXJue3g6dCtpKk1hdGguY29zKG8pLHk6ZS1pKk1hdGguc2luKG8pfX19LHtrZXk6XCJzZWxlY3RcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2VsZWN0ZWQ9ITB9fSx7a2V5OlwidW5zZWxlY3RcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2VsZWN0ZWQ9ITF9fSx7a2V5OlwiY2xlYW51cFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZVR5cGUuY2xlYW51cCgpfX0se2tleTpcInJlbW92ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jbGVhbnVwKCksdGhpcy5kaXNjb25uZWN0KCksZGVsZXRlIHRoaXMuYm9keS5lZGdlc1t0aGlzLmlkXX19LHtrZXk6XCJlbmRQb2ludHNWYWxpZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuYm9keS5ub2Rlc1t0aGlzLmZyb21JZF0mJnZvaWQgMCE9PXRoaXMuYm9keS5ub2Rlc1t0aGlzLnRvSWRdfX1dLFt7a2V5OlwicGFyc2VPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdLG89YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOnt9LG49YXJndW1lbnRzLmxlbmd0aD40JiZ2b2lkIDAhPT1hcmd1bWVudHNbNF0mJmFyZ3VtZW50c1s0XSxyPVtcImVuZFBvaW50T2Zmc2V0XCIsXCJhcnJvd1N0cmlrZXRocm91Z2hcIixcImlkXCIsXCJmcm9tXCIsXCJoaWRkZW5cIixcImhvdmVyV2lkdGhcIixcImxhYmVsSGlnaGxpZ2h0Qm9sZFwiLFwibGVuZ3RoXCIsXCJsaW5lXCIsXCJvcGFjaXR5XCIsXCJwaHlzaWNzXCIsXCJzY2FsaW5nXCIsXCJzZWxlY3Rpb25XaWR0aFwiLFwic2VsZlJlZmVyZW5jZVNpemVcIixcInNlbGZSZWZlcmVuY2VcIixcInRvXCIsXCJ0aXRsZVwiLFwidmFsdWVcIixcIndpZHRoXCIsXCJmb250XCIsXCJjaG9zZW5cIixcIndpZHRoQ29uc3RyYWludFwiXTtpZihaYShyLHQsZSxpKSx2b2lkIDAhPT1lLmVuZFBvaW50T2Zmc2V0JiZ2b2lkIDAhPT1lLmVuZFBvaW50T2Zmc2V0LmZyb20mJihBZChlLmVuZFBvaW50T2Zmc2V0LmZyb20pP3QuZW5kUG9pbnRPZmZzZXQuZnJvbT1lLmVuZFBvaW50T2Zmc2V0LmZyb206KHQuZW5kUG9pbnRPZmZzZXQuZnJvbT12b2lkIDAhPT1vLmVuZFBvaW50T2Zmc2V0LmZyb20/by5lbmRQb2ludE9mZnNldC5mcm9tOjAsY29uc29sZS5lcnJvcihcImVuZFBvaW50T2Zmc2V0LmZyb20gaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIpKSksdm9pZCAwIT09ZS5lbmRQb2ludE9mZnNldCYmdm9pZCAwIT09ZS5lbmRQb2ludE9mZnNldC50byYmKEFkKGUuZW5kUG9pbnRPZmZzZXQudG8pP3QuZW5kUG9pbnRPZmZzZXQudG89ZS5lbmRQb2ludE9mZnNldC50bzoodC5lbmRQb2ludE9mZnNldC50bz12b2lkIDAhPT1vLmVuZFBvaW50T2Zmc2V0LnRvP28uZW5kUG9pbnRPZmZzZXQudG86MCxjb25zb2xlLmVycm9yKFwiZW5kUG9pbnRPZmZzZXQudG8gaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIpKSksSmQoZS5sYWJlbCk/dC5sYWJlbD1lLmxhYmVsOkpkKHQubGFiZWwpfHwodC5sYWJlbD12b2lkIDApLGdoKHQsZSxcInNtb290aFwiLG8pLGdoKHQsZSxcInNoYWRvd1wiLG8pLGdoKHQsZSxcImJhY2tncm91bmRcIixvKSx2b2lkIDAhPT1lLmRhc2hlcyYmbnVsbCE9PWUuZGFzaGVzP3QuZGFzaGVzPWUuZGFzaGVzOiEwPT09aSYmbnVsbD09PWUuZGFzaGVzJiYodC5kYXNoZXM9SXIoby5kYXNoZXMpKSx2b2lkIDAhPT1lLnNjYWxpbmcmJm51bGwhPT1lLnNjYWxpbmc/KHZvaWQgMCE9PWUuc2NhbGluZy5taW4mJih0LnNjYWxpbmcubWluPWUuc2NhbGluZy5taW4pLHZvaWQgMCE9PWUuc2NhbGluZy5tYXgmJih0LnNjYWxpbmcubWF4PWUuc2NhbGluZy5tYXgpLGdoKHQuc2NhbGluZyxlLnNjYWxpbmcsXCJsYWJlbFwiLG8uc2NhbGluZykpOiEwPT09aSYmbnVsbD09PWUuc2NhbGluZyYmKHQuc2NhbGluZz1JcihvLnNjYWxpbmcpKSx2b2lkIDAhPT1lLmFycm93cyYmbnVsbCE9PWUuYXJyb3dzKWlmKFwic3RyaW5nXCI9PXR5cGVvZiBlLmFycm93cyl7dmFyIHM9ZS5hcnJvd3MudG9Mb3dlckNhc2UoKTt0LmFycm93cy50by5lbmFibGVkPS0xIT1NcihzKS5jYWxsKHMsXCJ0b1wiKSx0LmFycm93cy5taWRkbGUuZW5hYmxlZD0tMSE9TXIocykuY2FsbChzLFwibWlkZGxlXCIpLHQuYXJyb3dzLmZyb20uZW5hYmxlZD0tMSE9TXIocykuY2FsbChzLFwiZnJvbVwiKX1lbHNle2lmKFwib2JqZWN0XCIhPT1kbihlLmFycm93cykpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFycm93IG5ld09wdGlvbnMgY2FuIG9ubHkgYmUgYW4gb2JqZWN0IG9yIGEgc3RyaW5nLiBSZWZlciB0byB0aGUgZG9jdW1lbnRhdGlvbi4gWW91IHVzZWQ6XCIrTHIoZS5hcnJvd3MpKTtnaCh0LmFycm93cyxlLmFycm93cyxcInRvXCIsby5hcnJvd3MpLGdoKHQuYXJyb3dzLGUuYXJyb3dzLFwibWlkZGxlXCIsby5hcnJvd3MpLGdoKHQuYXJyb3dzLGUuYXJyb3dzLFwiZnJvbVwiLG8uYXJyb3dzKX1lbHNlITA9PT1pJiZudWxsPT09ZS5hcnJvd3MmJih0LmFycm93cz1JcihvLmFycm93cykpO2lmKHZvaWQgMCE9PWUuY29sb3ImJm51bGwhPT1lLmNvbG9yKXt2YXIgYT1HYShlLmNvbG9yKT97Y29sb3I6ZS5jb2xvcixoaWdobGlnaHQ6ZS5jb2xvcixob3ZlcjplLmNvbG9yLGluaGVyaXQ6ITEsb3BhY2l0eToxfTplLmNvbG9yLGg9dC5jb2xvcjtpZihuKXRoKGgsby5jb2xvciwhMSxpKTtlbHNlIGZvcih2YXIgZCBpbiBoKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoLGQpJiZkZWxldGUgaFtkXTtpZihHYShoKSloLmNvbG9yPWgsaC5oaWdobGlnaHQ9aCxoLmhvdmVyPWgsaC5pbmhlcml0PSExLHZvaWQgMD09PWEub3BhY2l0eSYmKGgub3BhY2l0eT0xKTtlbHNle3ZhciBsPSExO3ZvaWQgMCE9PWEuY29sb3ImJihoLmNvbG9yPWEuY29sb3IsbD0hMCksdm9pZCAwIT09YS5oaWdobGlnaHQmJihoLmhpZ2hsaWdodD1hLmhpZ2hsaWdodCxsPSEwKSx2b2lkIDAhPT1hLmhvdmVyJiYoaC5ob3Zlcj1hLmhvdmVyLGw9ITApLHZvaWQgMCE9PWEuaW5oZXJpdCYmKGguaW5oZXJpdD1hLmluaGVyaXQpLHZvaWQgMCE9PWEub3BhY2l0eSYmKGgub3BhY2l0eT1NYXRoLm1pbigxLE1hdGgubWF4KDAsYS5vcGFjaXR5KSkpLCEwPT09bD9oLmluaGVyaXQ9ITE6dm9pZCAwPT09aC5pbmhlcml0JiYoaC5pbmhlcml0PVwiZnJvbVwiKX19ZWxzZSEwPT09aSYmbnVsbD09PWUuY29sb3ImJih0LmNvbG9yPXZoKG8uY29sb3IpKTshMD09PWkmJm51bGw9PT1lLmZvbnQmJih0LmZvbnQ9dmgoby5mb250KSksT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJzZWxmUmVmZXJlbmNlU2l6ZVwiKSYmKGNvbnNvbGUud2FybihcIlRoZSBzZWxmUmVmZXJlbmNlU2l6ZSBwcm9wZXJ0eSBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHNlbGZSZWZlcmVuY2UgcHJvcGVydHkgaW5zdGVhZC4gVGhlIHNlbGZSZWZlcmVuY2UgY2FuIGJlIHNldCBsaWtlIHRoaXNlIHNlbGZSZWZlcmVuY2U6e3NpemU6MzAsIGFuZ2xlOk1hdGguUEkgLyA0fVwiKSx0LnNlbGZSZWZlcmVuY2Uuc2l6ZT1lLnNlbGZSZWZlcmVuY2VTaXplKX19XSksdH0oKSx0dT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8pe3ZhciBuLHI9dGhpcztQbyh0aGlzLHQpLHRoaXMuYm9keT1lLHRoaXMuaW1hZ2VzPWksdGhpcy5ncm91cHM9byx0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2U9YnQobj10aGlzLmNyZWF0ZSkuY2FsbChuLHRoaXMpLHRoaXMuZWRnZXNMaXN0ZW5lcnM9e2FkZDpmdW5jdGlvbih0LGUpe3IuYWRkKGUuaXRlbXMpfSx1cGRhdGU6ZnVuY3Rpb24odCxlKXtyLnVwZGF0ZShlLml0ZW1zKX0scmVtb3ZlOmZ1bmN0aW9uKHQsZSl7ci5yZW1vdmUoZS5pdGVtcyl9fSx0aGlzLm9wdGlvbnM9e30sdGhpcy5kZWZhdWx0T3B0aW9ucz17YXJyb3dzOnt0bzp7ZW5hYmxlZDohMSxzY2FsZUZhY3RvcjoxLHR5cGU6XCJhcnJvd1wifSxtaWRkbGU6e2VuYWJsZWQ6ITEsc2NhbGVGYWN0b3I6MSx0eXBlOlwiYXJyb3dcIn0sZnJvbTp7ZW5hYmxlZDohMSxzY2FsZUZhY3RvcjoxLHR5cGU6XCJhcnJvd1wifX0sZW5kUG9pbnRPZmZzZXQ6e2Zyb206MCx0bzowfSxhcnJvd1N0cmlrZXRocm91Z2g6ITAsY29sb3I6e2NvbG9yOlwiIzg0ODQ4NFwiLGhpZ2hsaWdodDpcIiM4NDg0ODRcIixob3ZlcjpcIiM4NDg0ODRcIixpbmhlcml0OlwiZnJvbVwiLG9wYWNpdHk6MX0sZGFzaGVzOiExLGZvbnQ6e2NvbG9yOlwiIzM0MzQzNFwiLHNpemU6MTQsZmFjZTpcImFyaWFsXCIsYmFja2dyb3VuZDpcIm5vbmVcIixzdHJva2VXaWR0aDoyLHN0cm9rZUNvbG9yOlwiI2ZmZmZmZlwiLGFsaWduOlwiaG9yaXpvbnRhbFwiLG11bHRpOiExLHZhZGp1c3Q6MCxib2xkOnttb2Q6XCJib2xkXCJ9LGJvbGRpdGFsOnttb2Q6XCJib2xkIGl0YWxpY1wifSxpdGFsOnttb2Q6XCJpdGFsaWNcIn0sbW9ubzp7bW9kOlwiXCIsc2l6ZToxNSxmYWNlOlwiY291cmllciBuZXdcIix2YWRqdXN0OjJ9fSxoaWRkZW46ITEsaG92ZXJXaWR0aDoxLjUsbGFiZWw6dm9pZCAwLGxhYmVsSGlnaGxpZ2h0Qm9sZDohMCxsZW5ndGg6dm9pZCAwLHBoeXNpY3M6ITAsc2NhbGluZzp7bWluOjEsbWF4OjE1LGxhYmVsOntlbmFibGVkOiEwLG1pbjoxNCxtYXg6MzAsbWF4VmlzaWJsZTozMCxkcmF3VGhyZXNob2xkOjV9LGN1c3RvbVNjYWxpbmdGdW5jdGlvbjpmdW5jdGlvbih0LGUsaSxvKXtpZihlPT09dClyZXR1cm4uNTt2YXIgbj0xLyhlLXQpO3JldHVybiBNYXRoLm1heCgwLChvLXQpKm4pfX0sc2VsZWN0aW9uV2lkdGg6MS41LHNlbGZSZWZlcmVuY2U6e3NpemU6MjAsYW5nbGU6TWF0aC5QSS80LHJlbmRlckJlaGluZFRoZU5vZGU6ITB9LHNoYWRvdzp7ZW5hYmxlZDohMSxjb2xvcjpcInJnYmEoMCwwLDAsMC41KVwiLHNpemU6MTAseDo1LHk6NX0sYmFja2dyb3VuZDp7ZW5hYmxlZDohMSxjb2xvcjpcInJnYmEoMTExLDExMSwxMTEsMSlcIixzaXplOjEwLGRhc2hlczohMX0sc21vb3RoOntlbmFibGVkOiEwLHR5cGU6XCJkeW5hbWljXCIsZm9yY2VEaXJlY3Rpb246XCJub25lXCIscm91bmRuZXNzOi41fSx0aXRsZTp2b2lkIDAsd2lkdGg6MSx2YWx1ZTp2b2lkIDB9LHRoKHRoaXMub3B0aW9ucyx0aGlzLmRlZmF1bHRPcHRpb25zKSx0aGlzLmJpbmRFdmVudExpc3RlbmVycygpfXJldHVybiBJbyh0LFt7a2V5OlwiYmluZEV2ZW50TGlzdGVuZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlLGk9dGhpczt0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9mb3JjZURpc2FibGVEeW5hbWljQ3VydmVzXCIsKGZ1bmN0aW9uKHQpe3ZhciBlPSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV07XCJkeW5hbWljXCI9PT10JiYodD1cImNvbnRpbnVvdXNcIik7dmFyIG89ITE7Zm9yKHZhciBuIGluIGkuYm9keS5lZGdlcylpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaS5ib2R5LmVkZ2VzLG4pKXt2YXIgcj1pLmJvZHkuZWRnZXNbbl0scz1pLmJvZHkuZGF0YS5lZGdlcy5nZXQobik7aWYobnVsbCE9cyl7dmFyIGE9cy5zbW9vdGg7dm9pZCAwIT09YSYmITA9PT1hLmVuYWJsZWQmJlwiZHluYW1pY1wiPT09YS50eXBlJiYodm9pZCAwPT09dD9yLnNldE9wdGlvbnMoe3Ntb290aDohMX0pOnIuc2V0T3B0aW9ucyh7c21vb3RoOnt0eXBlOnR9fSksbz0hMCl9fSEwPT09ZSYmITA9PT1vJiZpLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFVcGRhdGVkXCIsKGZ1bmN0aW9uKCl7aS5yZWNvbm5lY3RFZGdlcygpfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVmcmVzaEVkZ2VzXCIsYnQodD10aGlzLnJlZnJlc2gpLmNhbGwodCx0aGlzKSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZWZyZXNoXCIsYnQoZT10aGlzLnJlZnJlc2gpLmNhbGwoZSx0aGlzKSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsKGZ1bmN0aW9uKCl7bmgoaS5lZGdlc0xpc3RlbmVycywoZnVuY3Rpb24odCxlKXtpLmJvZHkuZGF0YS5lZGdlcyYmaS5ib2R5LmRhdGEuZWRnZXMub2ZmKGUsdCl9KSksZGVsZXRlIGkuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZSxkZWxldGUgaS5lZGdlc0xpc3RlbmVycy5hZGQsZGVsZXRlIGkuZWRnZXNMaXN0ZW5lcnMudXBkYXRlLGRlbGV0ZSBpLmVkZ2VzTGlzdGVuZXJzLnJlbW92ZSxkZWxldGUgaS5lZGdlc0xpc3RlbmVyc30pKX19LHtrZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dCl7SmMucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucyx0LCEwLHRoaXMuZGVmYXVsdE9wdGlvbnMsITApO3ZhciBlPSExO2lmKHZvaWQgMCE9PXQuc21vb3RoKWZvcih2YXIgaSBpbiB0aGlzLmJvZHkuZWRnZXMpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5lZGdlcyxpKSYmKGU9dGhpcy5ib2R5LmVkZ2VzW2ldLnVwZGF0ZUVkZ2VUeXBlKCl8fGUpO2lmKHZvaWQgMCE9PXQuZm9udClmb3IodmFyIG8gaW4gdGhpcy5ib2R5LmVkZ2VzKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkuZWRnZXMsbykmJnRoaXMuYm9keS5lZGdlc1tvXS51cGRhdGVMYWJlbE1vZHVsZSgpO3ZvaWQgMD09PXQuaGlkZGVuJiZ2b2lkIDA9PT10LnBoeXNpY3MmJiEwIT09ZXx8dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKX19fSx7a2V5Olwic2V0RGF0YVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMsbz1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdLG49dGhpcy5ib2R5LmRhdGEuZWRnZXM7aWYoZS5pc0RhdGFWaWV3TGlrZShcImlkXCIsdCkpdGhpcy5ib2R5LmRhdGEuZWRnZXM9dDtlbHNlIGlmKGduKHQpKXRoaXMuYm9keS5kYXRhLmVkZ2VzPW5ldyBlLkRhdGFTZXQsdGhpcy5ib2R5LmRhdGEuZWRnZXMuYWRkKHQpO2Vsc2V7aWYodCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXkgb3IgRGF0YVNldCBleHBlY3RlZFwiKTt0aGlzLmJvZHkuZGF0YS5lZGdlcz1uZXcgZS5EYXRhU2V0fWlmKG4mJm5oKHRoaXMuZWRnZXNMaXN0ZW5lcnMsKGZ1bmN0aW9uKHQsZSl7bi5vZmYoZSx0KX0pKSx0aGlzLmJvZHkuZWRnZXM9e30sdGhpcy5ib2R5LmRhdGEuZWRnZXMpe25oKHRoaXMuZWRnZXNMaXN0ZW5lcnMsKGZ1bmN0aW9uKHQsZSl7aS5ib2R5LmRhdGEuZWRnZXMub24oZSx0KX0pKTt2YXIgcj10aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXRJZHMoKTt0aGlzLmFkZChyLCEwKX10aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2FkanVzdEVkZ2VzRm9ySGllcmFyY2hpY2FsTGF5b3V0XCIpLCExPT09byYmdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKX19LHtrZXk6XCJhZGRcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXSxpPXRoaXMuYm9keS5lZGdlcyxvPXRoaXMuYm9keS5kYXRhLmVkZ2VzLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXSxzPWlbcl07cyYmcy5kaXNjb25uZWN0KCk7dmFyIGE9by5nZXQocix7c2hvd0ludGVybmFsSWRzOiEwfSk7aVtyXT10aGlzLmNyZWF0ZShhKX10aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2FkanVzdEVkZ2VzRm9ySGllcmFyY2hpY2FsTGF5b3V0XCIpLCExPT09ZSYmdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKX19LHtrZXk6XCJ1cGRhdGVcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5ib2R5LmVkZ2VzLGk9dGhpcy5ib2R5LmRhdGEuZWRnZXMsbz0hMSxuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl0scz1pLmdldChyKSxhPWVbcl07dm9pZCAwIT09YT8oYS5kaXNjb25uZWN0KCksbz1hLnNldE9wdGlvbnMocyl8fG8sYS5jb25uZWN0KCkpOih0aGlzLmJvZHkuZWRnZXNbcl09dGhpcy5jcmVhdGUocyksbz0hMCl9ITA9PT1vPyh0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2FkanVzdEVkZ2VzRm9ySGllcmFyY2hpY2FsTGF5b3V0XCIpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIikpOnRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YVVwZGF0ZWRcIil9fSx7a2V5OlwicmVtb3ZlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9IShhcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSl8fGFyZ3VtZW50c1sxXTtpZigwIT09dC5sZW5ndGgpe3ZhciBpPXRoaXMuYm9keS5lZGdlcztuaCh0LChmdW5jdGlvbih0KXt2YXIgZT1pW3RdO3ZvaWQgMCE9PWUmJmUucmVtb3ZlKCl9KSksZSYmdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKX19fSx7a2V5OlwicmVmcmVzaFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztuaCh0aGlzLmJvZHkuZWRnZXMsKGZ1bmN0aW9uKGUsaSl7dmFyIG89dC5ib2R5LmRhdGEuZWRnZXMuZ2V0KGkpO3ZvaWQgMCE9PW8mJmUuc2V0T3B0aW9ucyhvKX0pKX19LHtrZXk6XCJjcmVhdGVcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IEpjKHQsdGhpcy5ib2R5LHRoaXMuaW1hZ2VzLHRoaXMub3B0aW9ucyx0aGlzLmRlZmF1bHRPcHRpb25zKX19LHtrZXk6XCJyZWNvbm5lY3RFZGdlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZT10aGlzLmJvZHkubm9kZXMsaT10aGlzLmJvZHkuZWRnZXM7Zm9yKHQgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSYmKGVbdF0uZWRnZXM9W10pO2Zvcih0IGluIGkpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGksdCkpe3ZhciBvPWlbdF07by5mcm9tPW51bGwsby50bz1udWxsLG8uY29ubmVjdCgpfX19LHtrZXk6XCJnZXRDb25uZWN0ZWROb2Rlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPVtdO2lmKHZvaWQgMCE9PXRoaXMuYm9keS5lZGdlc1t0XSl7dmFyIGk9dGhpcy5ib2R5LmVkZ2VzW3RdO3ZvaWQgMCE9PWkuZnJvbUlkJiZlLnB1c2goaS5mcm9tSWQpLHZvaWQgMCE9PWkudG9JZCYmZS5wdXNoKGkudG9JZCl9cmV0dXJuIGV9fSx7a2V5OlwiX3VwZGF0ZVN0YXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9hZGRNaXNzaW5nRWRnZXMoKSx0aGlzLl9yZW1vdmVJbnZhbGlkRWRnZXMoKX19LHtrZXk6XCJfcmVtb3ZlSW52YWxpZEVkZ2VzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9W107bmgodGhpcy5ib2R5LmVkZ2VzLChmdW5jdGlvbihpLG8pe3ZhciBuPXQuYm9keS5ub2Rlc1tpLnRvSWRdLHI9dC5ib2R5Lm5vZGVzW2kuZnJvbUlkXTt2b2lkIDAhPT1uJiYhMD09PW4uaXNDbHVzdGVyfHx2b2lkIDAhPT1yJiYhMD09PXIuaXNDbHVzdGVyfHx2b2lkIDAhPT1uJiZ2b2lkIDAhPT1yfHxlLnB1c2gobyl9KSksdGhpcy5yZW1vdmUoZSwhMSl9fSx7a2V5OlwiX2FkZE1pc3NpbmdFZGdlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5ib2R5LmRhdGEuZWRnZXM7aWYobnVsbCE9dCl7dmFyIGU9dGhpcy5ib2R5LmVkZ2VzLGk9W107RG4odCkuY2FsbCh0LChmdW5jdGlvbih0LG8pe3ZvaWQgMD09PWVbb10mJmkucHVzaChvKX0pKSx0aGlzLmFkZChpLCEwKX19fV0pLHR9KCksZXU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsaSxvKXtQbyh0aGlzLHQpLHRoaXMuYm9keT1lLHRoaXMucGh5c2ljc0JvZHk9aSx0aGlzLmJhcm5lc0h1dFRyZWUsdGhpcy5zZXRPcHRpb25zKG8pLHRoaXMuX3JuZz1SYShcIkJBUk5FUyBIVVQgU09MVkVSXCIpfXJldHVybiBJbyh0LFt7a2V5Olwic2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMub3B0aW9ucz10LHRoaXMudGhldGFJbnZlcnNlZD0xL3RoaXMub3B0aW9ucy50aGV0YSx0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3I9MS1NYXRoLm1heCgwLE1hdGgubWluKDEsdGhpcy5vcHRpb25zLmF2b2lkT3ZlcmxhcCkpfX0se2tleTpcInNvbHZlXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZigwIT09dGhpcy5vcHRpb25zLmdyYXZpdGF0aW9uYWxDb25zdGFudCYmdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMubGVuZ3RoPjApe3ZhciB0LGU9dGhpcy5ib2R5Lm5vZGVzLGk9dGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMsbz1pLmxlbmd0aCxuPXRoaXMuX2Zvcm1CYXJuZXNIdXRUcmVlKGUsaSk7dGhpcy5iYXJuZXNIdXRUcmVlPW47Zm9yKHZhciByPTA7cjxvO3IrKykodD1lW2lbcl1dKS5vcHRpb25zLm1hc3M+MCYmdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb25zKG4ucm9vdCx0KX19fSx7a2V5OlwiX2dldEZvcmNlQ29udHJpYnV0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24odC5jaGlsZHJlbi5OVyxlKSx0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbih0LmNoaWxkcmVuLk5FLGUpLHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHQuY2hpbGRyZW4uU1csZSksdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24odC5jaGlsZHJlbi5TRSxlKX19LHtrZXk6XCJfZ2V0Rm9yY2VDb250cmlidXRpb25cIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKHQuY2hpbGRyZW5Db3VudD4wKXt2YXIgaT10LmNlbnRlck9mTWFzcy54LWUueCxvPXQuY2VudGVyT2ZNYXNzLnktZS55LG49TWF0aC5zcXJ0KGkqaStvKm8pO24qdC5jYWxjU2l6ZT50aGlzLnRoZXRhSW52ZXJzZWQ/dGhpcy5fY2FsY3VsYXRlRm9yY2VzKG4saSxvLGUsdCk6ND09PXQuY2hpbGRyZW5Db3VudD90aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbnModCxlKTp0LmNoaWxkcmVuLmRhdGEuaWQhPWUuaWQmJnRoaXMuX2NhbGN1bGF0ZUZvcmNlcyhuLGksbyxlLHQpfX19LHtrZXk6XCJfY2FsY3VsYXRlRm9yY2VzXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuKXswPT09dCYmKGU9dD0uMSksdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yPDEmJm8uc2hhcGUucmFkaXVzJiYodD1NYXRoLm1heCguMSt0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3Iqby5zaGFwZS5yYWRpdXMsdC1vLnNoYXBlLnJhZGl1cykpO3ZhciByPXRoaXMub3B0aW9ucy5ncmF2aXRhdGlvbmFsQ29uc3RhbnQqbi5tYXNzKm8ub3B0aW9ucy5tYXNzL01hdGgucG93KHQsMykscz1lKnIsYT1pKnI7dGhpcy5waHlzaWNzQm9keS5mb3JjZXNbby5pZF0ueCs9cyx0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tvLmlkXS55Kz1hfX0se2tleTpcIl9mb3JtQmFybmVzSHV0VHJlZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpLG89ZS5sZW5ndGgsbj10W2VbMF1dLngscj10W2VbMF1dLnkscz10W2VbMF1dLngsYT10W2VbMF1dLnksaD0xO2g8bztoKyspe3ZhciBkPXRbZVtoXV0sbD1kLngsYz1kLnk7ZC5vcHRpb25zLm1hc3M+MCYmKGw8biYmKG49bCksbD5zJiYocz1sKSxjPHImJihyPWMpLGM+YSYmKGE9YykpfXZhciB1PU1hdGguYWJzKHMtbiktTWF0aC5hYnMoYS1yKTt1PjA/KHItPS41KnUsYSs9LjUqdSk6KG4rPS41KnUscy09LjUqdSk7dmFyIGY9TWF0aC5tYXgoMWUtNSxNYXRoLmFicyhzLW4pKSxwPS41KmYsdj0uNSoobitzKSxnPS41KihyK2EpLHk9e3Jvb3Q6e2NlbnRlck9mTWFzczp7eDowLHk6MH0sbWFzczowLHJhbmdlOnttaW5YOnYtcCxtYXhYOnYrcCxtaW5ZOmctcCxtYXhZOmcrcH0sc2l6ZTpmLGNhbGNTaXplOjEvZixjaGlsZHJlbjp7ZGF0YTpudWxsfSxtYXhXaWR0aDowLGxldmVsOjAsY2hpbGRyZW5Db3VudDo0fX07dGhpcy5fc3BsaXRCcmFuY2goeS5yb290KTtmb3IodmFyIG09MDttPG87bSsrKShpPXRbZVttXV0pLm9wdGlvbnMubWFzcz4wJiZ0aGlzLl9wbGFjZUluVHJlZSh5LnJvb3QsaSk7cmV0dXJuIHl9fSx7a2V5OlwiX3VwZGF0ZUJyYW5jaE1hc3NcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXQuY2VudGVyT2ZNYXNzLG89dC5tYXNzK2Uub3B0aW9ucy5tYXNzLG49MS9vO2kueD1pLngqdC5tYXNzK2UueCplLm9wdGlvbnMubWFzcyxpLngqPW4saS55PWkueSp0Lm1hc3MrZS55KmUub3B0aW9ucy5tYXNzLGkueSo9bix0Lm1hc3M9bzt2YXIgcj1NYXRoLm1heChNYXRoLm1heChlLmhlaWdodCxlLnJhZGl1cyksZS53aWR0aCk7dC5tYXhXaWR0aD10Lm1heFdpZHRoPHI/cjp0Lm1heFdpZHRofX0se2tleTpcIl9wbGFjZUluVHJlZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXsxPT1pJiZ2b2lkIDAhPT1pfHx0aGlzLl91cGRhdGVCcmFuY2hNYXNzKHQsZSk7dmFyIG8sbj10LmNoaWxkcmVuLk5XLnJhbmdlO289bi5tYXhYPmUueD9uLm1heFk+ZS55P1wiTldcIjpcIlNXXCI6bi5tYXhZPmUueT9cIk5FXCI6XCJTRVwiLHRoaXMuX3BsYWNlSW5SZWdpb24odCxlLG8pfX0se2tleTpcIl9wbGFjZUluUmVnaW9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3ZhciBvPXQuY2hpbGRyZW5baV07c3dpdGNoKG8uY2hpbGRyZW5Db3VudCl7Y2FzZSAwOm8uY2hpbGRyZW4uZGF0YT1lLG8uY2hpbGRyZW5Db3VudD0xLHRoaXMuX3VwZGF0ZUJyYW5jaE1hc3MobyxlKTticmVhaztjYXNlIDE6by5jaGlsZHJlbi5kYXRhLng9PT1lLngmJm8uY2hpbGRyZW4uZGF0YS55PT09ZS55PyhlLngrPXRoaXMuX3JuZygpLGUueSs9dGhpcy5fcm5nKCkpOih0aGlzLl9zcGxpdEJyYW5jaChvKSx0aGlzLl9wbGFjZUluVHJlZShvLGUpKTticmVhaztjYXNlIDQ6dGhpcy5fcGxhY2VJblRyZWUobyxlKX19fSx7a2V5OlwiX3NwbGl0QnJhbmNoXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9bnVsbDsxPT09dC5jaGlsZHJlbkNvdW50JiYoZT10LmNoaWxkcmVuLmRhdGEsdC5tYXNzPTAsdC5jZW50ZXJPZk1hc3MueD0wLHQuY2VudGVyT2ZNYXNzLnk9MCksdC5jaGlsZHJlbkNvdW50PTQsdC5jaGlsZHJlbi5kYXRhPW51bGwsdGhpcy5faW5zZXJ0UmVnaW9uKHQsXCJOV1wiKSx0aGlzLl9pbnNlcnRSZWdpb24odCxcIk5FXCIpLHRoaXMuX2luc2VydFJlZ2lvbih0LFwiU1dcIiksdGhpcy5faW5zZXJ0UmVnaW9uKHQsXCJTRVwiKSxudWxsIT1lJiZ0aGlzLl9wbGFjZUluVHJlZSh0LGUpfX0se2tleTpcIl9pbnNlcnRSZWdpb25cIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpLG8sbixyLHM9LjUqdC5zaXplO3N3aXRjaChlKXtjYXNlXCJOV1wiOmk9dC5yYW5nZS5taW5YLG89dC5yYW5nZS5taW5YK3Msbj10LnJhbmdlLm1pblkscj10LnJhbmdlLm1pblkrczticmVhaztjYXNlXCJORVwiOmk9dC5yYW5nZS5taW5YK3Msbz10LnJhbmdlLm1heFgsbj10LnJhbmdlLm1pblkscj10LnJhbmdlLm1pblkrczticmVhaztjYXNlXCJTV1wiOmk9dC5yYW5nZS5taW5YLG89dC5yYW5nZS5taW5YK3Msbj10LnJhbmdlLm1pblkrcyxyPXQucmFuZ2UubWF4WTticmVhaztjYXNlXCJTRVwiOmk9dC5yYW5nZS5taW5YK3Msbz10LnJhbmdlLm1heFgsbj10LnJhbmdlLm1pblkrcyxyPXQucmFuZ2UubWF4WX10LmNoaWxkcmVuW2VdPXtjZW50ZXJPZk1hc3M6e3g6MCx5OjB9LG1hc3M6MCxyYW5nZTp7bWluWDppLG1heFg6byxtaW5ZOm4sbWF4WTpyfSxzaXplOi41KnQuc2l6ZSxjYWxjU2l6ZToyKnQuY2FsY1NpemUsY2hpbGRyZW46e2RhdGE6bnVsbH0sbWF4V2lkdGg6MCxsZXZlbDp0LmxldmVsKzEsY2hpbGRyZW5Db3VudDowfX19LHtrZXk6XCJfZGVidWdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZvaWQgMCE9PXRoaXMuYmFybmVzSHV0VHJlZSYmKHQubGluZVdpZHRoPTEsdGhpcy5fZHJhd0JyYW5jaCh0aGlzLmJhcm5lc0h1dFRyZWUucm9vdCx0LGUpKX19LHtrZXk6XCJfZHJhd0JyYW5jaFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2b2lkIDA9PT1pJiYoaT1cIiNGRjAwMDBcIiksND09PXQuY2hpbGRyZW5Db3VudCYmKHRoaXMuX2RyYXdCcmFuY2godC5jaGlsZHJlbi5OVyxlKSx0aGlzLl9kcmF3QnJhbmNoKHQuY2hpbGRyZW4uTkUsZSksdGhpcy5fZHJhd0JyYW5jaCh0LmNoaWxkcmVuLlNFLGUpLHRoaXMuX2RyYXdCcmFuY2godC5jaGlsZHJlbi5TVyxlKSksZS5zdHJva2VTdHlsZT1pLGUuYmVnaW5QYXRoKCksZS5tb3ZlVG8odC5yYW5nZS5taW5YLHQucmFuZ2UubWluWSksZS5saW5lVG8odC5yYW5nZS5tYXhYLHQucmFuZ2UubWluWSksZS5zdHJva2UoKSxlLmJlZ2luUGF0aCgpLGUubW92ZVRvKHQucmFuZ2UubWF4WCx0LnJhbmdlLm1pblkpLGUubGluZVRvKHQucmFuZ2UubWF4WCx0LnJhbmdlLm1heFkpLGUuc3Ryb2tlKCksZS5iZWdpblBhdGgoKSxlLm1vdmVUbyh0LnJhbmdlLm1heFgsdC5yYW5nZS5tYXhZKSxlLmxpbmVUbyh0LnJhbmdlLm1pblgsdC5yYW5nZS5tYXhZKSxlLnN0cm9rZSgpLGUuYmVnaW5QYXRoKCksZS5tb3ZlVG8odC5yYW5nZS5taW5YLHQucmFuZ2UubWF4WSksZS5saW5lVG8odC5yYW5nZS5taW5YLHQucmFuZ2UubWluWSksZS5zdHJva2UoKX19XSksdH0oKSxpdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8pe1BvKHRoaXMsdCksdGhpcy5fcm5nPVJhKFwiUkVQVUxTSU9OIFNPTFZFUlwiKSx0aGlzLmJvZHk9ZSx0aGlzLnBoeXNpY3NCb2R5PWksdGhpcy5zZXRPcHRpb25zKG8pfXJldHVybiBJbyh0LFt7a2V5Olwic2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMub3B0aW9ucz10fX0se2tleTpcInNvbHZlXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQsZSxpLG8sbixyLHMsYSxoPXRoaXMuYm9keS5ub2RlcyxkPXRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLGw9dGhpcy5waHlzaWNzQm9keS5mb3JjZXMsYz10aGlzLm9wdGlvbnMubm9kZURpc3RhbmNlLHU9LTIvMy9jLGY9MDtmPGQubGVuZ3RoLTE7ZisrKXtzPWhbZFtmXV07Zm9yKHZhciBwPWYrMTtwPGQubGVuZ3RoO3ArKyl0PShhPWhbZFtwXV0pLngtcy54LGU9YS55LXMueSwwPT09KGk9TWF0aC5zcXJ0KHQqdCtlKmUpKSYmKHQ9aT0uMSp0aGlzLl9ybmcoKSksaTwyKmMmJihyPWk8LjUqYz8xOnUqaSsxLjMzMzMzMzMzMzMzMzMzMzMsbz10KihyLz1pKSxuPWUqcixsW3MuaWRdLngtPW8sbFtzLmlkXS55LT1uLGxbYS5pZF0ueCs9byxsW2EuaWRdLnkrPW4pfX19XSksdH0oKSxvdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8pe1BvKHRoaXMsdCksdGhpcy5ib2R5PWUsdGhpcy5waHlzaWNzQm9keT1pLHRoaXMuc2V0T3B0aW9ucyhvKX1yZXR1cm4gSW8odCxbe2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLm9wdGlvbnM9dCx0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3I9TWF0aC5tYXgoMCxNYXRoLm1pbigxLHRoaXMub3B0aW9ucy5hdm9pZE92ZXJsYXB8fDApKX19LHtrZXk6XCJzb2x2ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuYm9keS5ub2RlcyxlPXRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLGk9dGhpcy5waHlzaWNzQm9keS5mb3JjZXMsbz10aGlzLm9wdGlvbnMubm9kZURpc3RhbmNlLG49MDtuPGUubGVuZ3RoLTE7bisrKWZvcih2YXIgcj10W2Vbbl1dLHM9bisxO3M8ZS5sZW5ndGg7cysrKXt2YXIgYT10W2Vbc11dO2lmKHIubGV2ZWw9PT1hLmxldmVsKXt2YXIgaD1vK3RoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciooKHIuc2hhcGUucmFkaXVzfHwwKS8yKyhhLnNoYXBlLnJhZGl1c3x8MCkvMiksZD1hLngtci54LGw9YS55LXIueSxjPU1hdGguc3FydChkKmQrbCpsKSx1PXZvaWQgMDt1PWM8aD8tTWF0aC5wb3coLjA1KmMsMikrTWF0aC5wb3coLjA1KmgsMik6MCwwIT09YyYmKHUvPWMpO3ZhciBmPWQqdSxwPWwqdTtpW3IuaWRdLngtPWYsaVtyLmlkXS55LT1wLGlbYS5pZF0ueCs9ZixpW2EuaWRdLnkrPXB9fX19XSksdH0oKSxudT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8pe1BvKHRoaXMsdCksdGhpcy5ib2R5PWUsdGhpcy5waHlzaWNzQm9keT1pLHRoaXMuc2V0T3B0aW9ucyhvKX1yZXR1cm4gSW8odCxbe2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLm9wdGlvbnM9dH19LHtrZXk6XCJzb2x2ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0LGUsaSxvLG4scj10aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcyxzPXRoaXMuYm9keS5lZGdlcyxhPTA7YTxyLmxlbmd0aDthKyspITA9PT0oZT1zW3JbYV1dKS5jb25uZWN0ZWQmJmUudG9JZCE9PWUuZnJvbUlkJiZ2b2lkIDAhPT10aGlzLmJvZHkubm9kZXNbZS50b0lkXSYmdm9pZCAwIT09dGhpcy5ib2R5Lm5vZGVzW2UuZnJvbUlkXSYmKHZvaWQgMCE9PWUuZWRnZVR5cGUudmlhPyh0PXZvaWQgMD09PWUub3B0aW9ucy5sZW5ndGg/dGhpcy5vcHRpb25zLnNwcmluZ0xlbmd0aDplLm9wdGlvbnMubGVuZ3RoLGk9ZS50byxvPWUuZWRnZVR5cGUudmlhLG49ZS5mcm9tLHRoaXMuX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlKGksbywuNSp0KSx0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShvLG4sLjUqdCkpOih0PXZvaWQgMD09PWUub3B0aW9ucy5sZW5ndGg/MS41KnRoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGg6ZS5vcHRpb25zLmxlbmd0aCx0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShlLmZyb20sZS50byx0KSkpfX0se2tleTpcIl9jYWxjdWxhdGVTcHJpbmdGb3JjZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz10LngtZS54LG49dC55LWUueSxyPU1hdGgubWF4KE1hdGguc3FydChvKm8rbipuKSwuMDEpLHM9dGhpcy5vcHRpb25zLnNwcmluZ0NvbnN0YW50KihpLXIpL3IsYT1vKnMsaD1uKnM7dm9pZCAwIT09dGhpcy5waHlzaWNzQm9keS5mb3JjZXNbdC5pZF0mJih0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1t0LmlkXS54Kz1hLHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW3QuaWRdLnkrPWgpLHZvaWQgMCE9PXRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW2UuaWRdJiYodGhpcy5waHlzaWNzQm9keS5mb3JjZXNbZS5pZF0ueC09YSx0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tlLmlkXS55LT1oKX19XSksdH0oKSxydT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8pe1BvKHRoaXMsdCksdGhpcy5ib2R5PWUsdGhpcy5waHlzaWNzQm9keT1pLHRoaXMuc2V0T3B0aW9ucyhvKX1yZXR1cm4gSW8odCxbe2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLm9wdGlvbnM9dH19LHtrZXk6XCJzb2x2ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0LGUsaSxvLG4scixzLGEsaCxkLGw9dGhpcy5ib2R5LmVkZ2VzLGM9LjUsdT10aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcyxmPXRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLHA9dGhpcy5waHlzaWNzQm9keS5mb3JjZXMsdj0wO3Y8Zi5sZW5ndGg7disrKXt2YXIgZz1mW3ZdO3BbZ10uc3ByaW5nRng9MCxwW2ddLnNwcmluZ0Z5PTB9Zm9yKHZhciB5PTA7eTx1Lmxlbmd0aDt5KyspITA9PT0oZT1sW3VbeV1dKS5jb25uZWN0ZWQmJih0PXZvaWQgMD09PWUub3B0aW9ucy5sZW5ndGg/dGhpcy5vcHRpb25zLnNwcmluZ0xlbmd0aDplLm9wdGlvbnMubGVuZ3RoLGk9ZS5mcm9tLngtZS50by54LG89ZS5mcm9tLnktZS50by55LGE9MD09PShhPU1hdGguc3FydChpKmkrbypvKSk/LjAxOmEsbj1pKihzPXRoaXMub3B0aW9ucy5zcHJpbmdDb25zdGFudCoodC1hKS9hKSxyPW8qcyxlLnRvLmxldmVsIT1lLmZyb20ubGV2ZWw/KHZvaWQgMCE9PXBbZS50b0lkXSYmKHBbZS50b0lkXS5zcHJpbmdGeC09bixwW2UudG9JZF0uc3ByaW5nRnktPXIpLHZvaWQgMCE9PXBbZS5mcm9tSWRdJiYocFtlLmZyb21JZF0uc3ByaW5nRngrPW4scFtlLmZyb21JZF0uc3ByaW5nRnkrPXIpKToodm9pZCAwIT09cFtlLnRvSWRdJiYocFtlLnRvSWRdLngtPWMqbixwW2UudG9JZF0ueS09YypyKSx2b2lkIDAhPT1wW2UuZnJvbUlkXSYmKHBbZS5mcm9tSWRdLngrPWMqbixwW2UuZnJvbUlkXS55Kz1jKnIpKSk7cz0xO2Zvcih2YXIgbT0wO208Zi5sZW5ndGg7bSsrKXt2YXIgYj1mW21dO2g9TWF0aC5taW4ocyxNYXRoLm1heCgtcyxwW2JdLnNwcmluZ0Z4KSksZD1NYXRoLm1pbihzLE1hdGgubWF4KC1zLHBbYl0uc3ByaW5nRnkpKSxwW2JdLngrPWgscFtiXS55Kz1kfWZvcih2YXIgdz0wLGs9MCxfPTA7XzxmLmxlbmd0aDtfKyspe3ZhciB4PWZbX107dys9cFt4XS54LGsrPXBbeF0ueX1mb3IodmFyIEU9dy9mLmxlbmd0aCxPPWsvZi5sZW5ndGgsQz0wO0M8Zi5sZW5ndGg7QysrKXt2YXIgUz1mW0NdO3BbU10ueC09RSxwW1NdLnktPU99fX1dKSx0fSgpLHN1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLGksbyl7UG8odGhpcyx0KSx0aGlzLmJvZHk9ZSx0aGlzLnBoeXNpY3NCb2R5PWksdGhpcy5zZXRPcHRpb25zKG8pfXJldHVybiBJbyh0LFt7a2V5Olwic2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMub3B0aW9ucz10fX0se2tleTpcInNvbHZlXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQsZSxpLG8sbj10aGlzLmJvZHkubm9kZXMscj10aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcyxzPXRoaXMucGh5c2ljc0JvZHkuZm9yY2VzLGE9MDthPHIubGVuZ3RoO2ErKyl7dD0tKG89bltyW2FdXSkueCxlPS1vLnksaT1NYXRoLnNxcnQodCp0K2UqZSksdGhpcy5fY2FsY3VsYXRlRm9yY2VzKGksdCxlLHMsbyl9fX0se2tleTpcIl9jYWxjdWxhdGVGb3JjZXNcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4pe3ZhciByPTA9PT10PzA6dGhpcy5vcHRpb25zLmNlbnRyYWxHcmF2aXR5L3Q7b1tuLmlkXS54PWUqcixvW24uaWRdLnk9aSpyfX1dKSx0fSgpO2Z1bmN0aW9uIGF1KHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIGh1PWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9YXUoaSk7ZnVuY3Rpb24gaSh0LG8sbil7dmFyIHI7cmV0dXJuIFBvKHRoaXMsaSksKHI9ZS5jYWxsKHRoaXMsdCxvLG4pKS5fcm5nPVJhKFwiRk9SQ0UgQVRMQVMgMiBCQVNFRCBSRVBVTFNJT04gU09MVkVSXCIpLHJ9cmV0dXJuIElvKGksW3trZXk6XCJfY2FsY3VsYXRlRm9yY2VzXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuKXswPT09dCYmKGU9dD0uMSp0aGlzLl9ybmcoKSksdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yPDEmJm8uc2hhcGUucmFkaXVzJiYodD1NYXRoLm1heCguMSt0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3Iqby5zaGFwZS5yYWRpdXMsdC1vLnNoYXBlLnJhZGl1cykpO3ZhciByPW8uZWRnZXMubGVuZ3RoKzEscz10aGlzLm9wdGlvbnMuZ3Jhdml0YXRpb25hbENvbnN0YW50Km4ubWFzcypvLm9wdGlvbnMubWFzcypyL01hdGgucG93KHQsMiksYT1lKnMsaD1pKnM7dGhpcy5waHlzaWNzQm9keS5mb3JjZXNbby5pZF0ueCs9YSx0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tvLmlkXS55Kz1ofX1dKSxpfShldSk7ZnVuY3Rpb24gZHUodCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgbHUsY3U9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1kdShpKTtmdW5jdGlvbiBpKHQsbyxuKXtyZXR1cm4gUG8odGhpcyxpKSxlLmNhbGwodGhpcyx0LG8sbil9cmV0dXJuIElvKGksW3trZXk6XCJfY2FsY3VsYXRlRm9yY2VzXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuKXtpZih0PjApe3ZhciByPW4uZWRnZXMubGVuZ3RoKzEscz10aGlzLm9wdGlvbnMuY2VudHJhbEdyYXZpdHkqcipuLm9wdGlvbnMubWFzcztvW24uaWRdLng9ZSpzLG9bbi5pZF0ueT1pKnN9fX1dKSxpfShzdSksdXU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe1BvKHRoaXMsdCksdGhpcy5ib2R5PWUsdGhpcy5waHlzaWNzQm9keT17cGh5c2ljc05vZGVJbmRpY2VzOltdLHBoeXNpY3NFZGdlSW5kaWNlczpbXSxmb3JjZXM6e30sdmVsb2NpdGllczp7fX0sdGhpcy5waHlzaWNzRW5hYmxlZD0hMCx0aGlzLnNpbXVsYXRpb25JbnRlcnZhbD0xZTMvNjAsdGhpcy5yZXF1aXJlc1RpbWVvdXQ9ITAsdGhpcy5wcmV2aW91c1N0YXRlcz17fSx0aGlzLnJlZmVyZW5jZVN0YXRlPXt9LHRoaXMuZnJlZXplQ2FjaGU9e30sdGhpcy5yZW5kZXJUaW1lcj12b2lkIDAsdGhpcy5hZGFwdGl2ZVRpbWVzdGVwPSExLHRoaXMuYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQ9ITEsdGhpcy5hZGFwdGl2ZUNvdW50ZXI9MCx0aGlzLmFkYXB0aXZlSW50ZXJ2YWw9Myx0aGlzLnN0YWJpbGl6ZWQ9ITEsdGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbj0hMSx0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zPTAsdGhpcy5yZWFkeT0hMSx0aGlzLm9wdGlvbnM9e30sdGhpcy5kZWZhdWx0T3B0aW9ucz17ZW5hYmxlZDohMCxiYXJuZXNIdXQ6e3RoZXRhOi41LGdyYXZpdGF0aW9uYWxDb25zdGFudDotMmUzLGNlbnRyYWxHcmF2aXR5Oi4zLHNwcmluZ0xlbmd0aDo5NSxzcHJpbmdDb25zdGFudDouMDQsZGFtcGluZzouMDksYXZvaWRPdmVybGFwOjB9LGZvcmNlQXRsYXMyQmFzZWQ6e3RoZXRhOi41LGdyYXZpdGF0aW9uYWxDb25zdGFudDotNTAsY2VudHJhbEdyYXZpdHk6LjAxLHNwcmluZ0NvbnN0YW50Oi4wOCxzcHJpbmdMZW5ndGg6MTAwLGRhbXBpbmc6LjQsYXZvaWRPdmVybGFwOjB9LHJlcHVsc2lvbjp7Y2VudHJhbEdyYXZpdHk6LjIsc3ByaW5nTGVuZ3RoOjIwMCxzcHJpbmdDb25zdGFudDouMDUsbm9kZURpc3RhbmNlOjEwMCxkYW1waW5nOi4wOSxhdm9pZE92ZXJsYXA6MH0saGllcmFyY2hpY2FsUmVwdWxzaW9uOntjZW50cmFsR3Jhdml0eTowLHNwcmluZ0xlbmd0aDoxMDAsc3ByaW5nQ29uc3RhbnQ6LjAxLG5vZGVEaXN0YW5jZToxMjAsZGFtcGluZzouMDl9LG1heFZlbG9jaXR5OjUwLG1pblZlbG9jaXR5Oi43NSxzb2x2ZXI6XCJiYXJuZXNIdXRcIixzdGFiaWxpemF0aW9uOntlbmFibGVkOiEwLGl0ZXJhdGlvbnM6MWUzLHVwZGF0ZUludGVydmFsOjUwLG9ubHlEeW5hbWljRWRnZXM6ITEsZml0OiEwfSx0aW1lc3RlcDouNSxhZGFwdGl2ZVRpbWVzdGVwOiEwLHdpbmQ6e3g6MCx5OjB9fSxjdCh0aGlzLm9wdGlvbnMsdGhpcy5kZWZhdWx0T3B0aW9ucyksdGhpcy50aW1lc3RlcD0uNSx0aGlzLmxheW91dEZhaWxlZD0hMSx0aGlzLmJpbmRFdmVudExpc3RlbmVycygpfXJldHVybiBJbyh0LFt7a2V5OlwiYmluZEV2ZW50TGlzdGVuZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFBoeXNpY3NcIiwoZnVuY3Rpb24oKXt0LmluaXRQaHlzaWNzKCl9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfbGF5b3V0RmFpbGVkXCIsKGZ1bmN0aW9uKCl7dC5sYXlvdXRGYWlsZWQ9ITB9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZXNldFBoeXNpY3NcIiwoZnVuY3Rpb24oKXt0LnN0b3BTaW11bGF0aW9uKCksdC5yZWFkeT0hMX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcImRpc2FibGVQaHlzaWNzXCIsKGZ1bmN0aW9uKCl7dC5waHlzaWNzRW5hYmxlZD0hMSx0LnN0b3BTaW11bGF0aW9uKCl9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZXN0b3JlUGh5c2ljc1wiLChmdW5jdGlvbigpe3Quc2V0T3B0aW9ucyh0Lm9wdGlvbnMpLCEwPT09dC5yZWFkeSYmdC5zdGFydFNpbXVsYXRpb24oKX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcInN0YXJ0U2ltdWxhdGlvblwiLChmdW5jdGlvbigpeyEwPT09dC5yZWFkeSYmdC5zdGFydFNpbXVsYXRpb24oKX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcInN0b3BTaW11bGF0aW9uXCIsKGZ1bmN0aW9uKCl7dC5zdG9wU2ltdWxhdGlvbigpfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLChmdW5jdGlvbigpe3Quc3RvcFNpbXVsYXRpb24oITEpLHQuYm9keS5lbWl0dGVyLm9mZigpfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsKGZ1bmN0aW9uKCl7dC51cGRhdGVQaHlzaWNzRGF0YSgpfSkpfX0se2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih2b2lkIDAhPT10KWlmKCExPT09dCl0aGlzLm9wdGlvbnMuZW5hYmxlZD0hMSx0aGlzLnBoeXNpY3NFbmFibGVkPSExLHRoaXMuc3RvcFNpbXVsYXRpb24oKTtlbHNlIGlmKCEwPT09dCl0aGlzLm9wdGlvbnMuZW5hYmxlZD0hMCx0aGlzLnBoeXNpY3NFbmFibGVkPSEwLHRoaXMuc3RhcnRTaW11bGF0aW9uKCk7ZWxzZXt0aGlzLnBoeXNpY3NFbmFibGVkPSEwLEphKFtcInN0YWJpbGl6YXRpb25cIl0sdGhpcy5vcHRpb25zLHQpLGdoKHRoaXMub3B0aW9ucyx0LFwic3RhYmlsaXphdGlvblwiKSx2b2lkIDA9PT10LmVuYWJsZWQmJih0aGlzLm9wdGlvbnMuZW5hYmxlZD0hMCksITE9PT10aGlzLm9wdGlvbnMuZW5hYmxlZCYmKHRoaXMucGh5c2ljc0VuYWJsZWQ9ITEsdGhpcy5zdG9wU2ltdWxhdGlvbigpKTt2YXIgZT10aGlzLm9wdGlvbnMud2luZDtlJiYoKFwibnVtYmVyXCIhPXR5cGVvZiBlLnh8fHpkKGUueCkpJiYoZS54PTApLChcIm51bWJlclwiIT10eXBlb2YgZS55fHx6ZChlLnkpKSYmKGUueT0wKSksdGhpcy50aW1lc3RlcD10aGlzLm9wdGlvbnMudGltZXN0ZXB9dGhpcy5pbml0KCl9fSx7a2V5OlwiaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ7XCJmb3JjZUF0bGFzMkJhc2VkXCI9PT10aGlzLm9wdGlvbnMuc29sdmVyPyh0PXRoaXMub3B0aW9ucy5mb3JjZUF0bGFzMkJhc2VkLHRoaXMubm9kZXNTb2x2ZXI9bmV3IGh1KHRoaXMuYm9keSx0aGlzLnBoeXNpY3NCb2R5LHQpLHRoaXMuZWRnZXNTb2x2ZXI9bmV3IG51KHRoaXMuYm9keSx0aGlzLnBoeXNpY3NCb2R5LHQpLHRoaXMuZ3Jhdml0eVNvbHZlcj1uZXcgY3UodGhpcy5ib2R5LHRoaXMucGh5c2ljc0JvZHksdCkpOlwicmVwdWxzaW9uXCI9PT10aGlzLm9wdGlvbnMuc29sdmVyPyh0PXRoaXMub3B0aW9ucy5yZXB1bHNpb24sdGhpcy5ub2Rlc1NvbHZlcj1uZXcgaXUodGhpcy5ib2R5LHRoaXMucGh5c2ljc0JvZHksdCksdGhpcy5lZGdlc1NvbHZlcj1uZXcgbnUodGhpcy5ib2R5LHRoaXMucGh5c2ljc0JvZHksdCksdGhpcy5ncmF2aXR5U29sdmVyPW5ldyBzdSh0aGlzLmJvZHksdGhpcy5waHlzaWNzQm9keSx0KSk6XCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIj09PXRoaXMub3B0aW9ucy5zb2x2ZXI/KHQ9dGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbFJlcHVsc2lvbix0aGlzLm5vZGVzU29sdmVyPW5ldyBvdSh0aGlzLmJvZHksdGhpcy5waHlzaWNzQm9keSx0KSx0aGlzLmVkZ2VzU29sdmVyPW5ldyBydSh0aGlzLmJvZHksdGhpcy5waHlzaWNzQm9keSx0KSx0aGlzLmdyYXZpdHlTb2x2ZXI9bmV3IHN1KHRoaXMuYm9keSx0aGlzLnBoeXNpY3NCb2R5LHQpKToodD10aGlzLm9wdGlvbnMuYmFybmVzSHV0LHRoaXMubm9kZXNTb2x2ZXI9bmV3IGV1KHRoaXMuYm9keSx0aGlzLnBoeXNpY3NCb2R5LHQpLHRoaXMuZWRnZXNTb2x2ZXI9bmV3IG51KHRoaXMuYm9keSx0aGlzLnBoeXNpY3NCb2R5LHQpLHRoaXMuZ3Jhdml0eVNvbHZlcj1uZXcgc3UodGhpcy5ib2R5LHRoaXMucGh5c2ljc0JvZHksdCkpLHRoaXMubW9kZWxPcHRpb25zPXR9fSx7a2V5OlwiaW5pdFBoeXNpY3NcIix2YWx1ZTpmdW5jdGlvbigpeyEwPT09dGhpcy5waHlzaWNzRW5hYmxlZCYmITA9PT10aGlzLm9wdGlvbnMuZW5hYmxlZD8hMD09PXRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLmVuYWJsZWQ/dGhpcy5zdGFiaWxpemUoKToodGhpcy5zdGFiaWxpemVkPSExLHRoaXMucmVhZHk9ITAsdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImZpdFwiLHt9LHRoaXMubGF5b3V0RmFpbGVkKSx0aGlzLnN0YXJ0U2ltdWxhdGlvbigpKToodGhpcy5yZWFkeT0hMCx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZml0XCIpKX19LHtrZXk6XCJzdGFydFNpbXVsYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0OyEwPT09dGhpcy5waHlzaWNzRW5hYmxlZCYmITA9PT10aGlzLm9wdGlvbnMuZW5hYmxlZD8odGhpcy5zdGFiaWxpemVkPSExLHRoaXMuYWRhcHRpdmVUaW1lc3RlcD0hMSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2l6ZU5vZGVzXCIpLHZvaWQgMD09PXRoaXMudmlld0Z1bmN0aW9uJiYodGhpcy52aWV3RnVuY3Rpb249YnQodD10aGlzLnNpbXVsYXRpb25TdGVwKS5jYWxsKHQsdGhpcyksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsdGhpcy52aWV3RnVuY3Rpb24pLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RhcnRSZW5kZXJpbmdcIikpKTp0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKX19LHtrZXk6XCJzdG9wU2ltdWxhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9IShhcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSl8fGFyZ3VtZW50c1swXTt0aGlzLnN0YWJpbGl6ZWQ9ITAsITA9PT10JiZ0aGlzLl9lbWl0U3RhYmlsaXplZCgpLHZvaWQgMCE9PXRoaXMudmlld0Z1bmN0aW9uJiYodGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLHRoaXMudmlld0Z1bmN0aW9uKSx0aGlzLnZpZXdGdW5jdGlvbj12b2lkIDAsITA9PT10JiZ0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIikpfX0se2tleTpcInNpbXVsYXRpb25TdGVwXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD1FbigpO3RoaXMucGh5c2ljc1RpY2soKSwoRW4oKS10PC40KnRoaXMuc2ltdWxhdGlvbkludGVydmFsfHwhMD09PXRoaXMucnVuRG91YmxlU3BlZWQpJiYhMT09PXRoaXMuc3RhYmlsaXplZCYmKHRoaXMucGh5c2ljc1RpY2soKSx0aGlzLnJ1bkRvdWJsZVNwZWVkPSEwKSwhMD09PXRoaXMuc3RhYmlsaXplZCYmdGhpcy5zdG9wU2ltdWxhdGlvbigpfX0se2tleTpcIl9lbWl0U3RhYmlsaXplZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zOyh0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zPjF8fCEwPT09dGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbikmJnFyKChmdW5jdGlvbigpe3QuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFiaWxpemVkXCIse2l0ZXJhdGlvbnM6ZX0pLHQuc3RhcnRlZFN0YWJpbGl6YXRpb249ITEsdC5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucz0wfSksMCl9fSx7a2V5OlwicGh5c2ljc1N0ZXBcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZ3Jhdml0eVNvbHZlci5zb2x2ZSgpLHRoaXMubm9kZXNTb2x2ZXIuc29sdmUoKSx0aGlzLmVkZ2VzU29sdmVyLnNvbHZlKCksdGhpcy5tb3ZlTm9kZXMoKX19LHtrZXk6XCJhZGp1c3RUaW1lU3RlcFwiLHZhbHVlOmZ1bmN0aW9uKCl7ITA9PT10aGlzLl9ldmFsdWF0ZVN0ZXBRdWFsaXR5KCk/dGhpcy50aW1lc3RlcD0xLjIqdGhpcy50aW1lc3RlcDp0aGlzLnRpbWVzdGVwLzEuMjx0aGlzLm9wdGlvbnMudGltZXN0ZXA/dGhpcy50aW1lc3RlcD10aGlzLm9wdGlvbnMudGltZXN0ZXA6KHRoaXMuYWRhcHRpdmVDb3VudGVyPS0xLHRoaXMudGltZXN0ZXA9TWF0aC5tYXgodGhpcy5vcHRpb25zLnRpbWVzdGVwLHRoaXMudGltZXN0ZXAvMS4yKSl9fSx7a2V5OlwicGh5c2ljc1RpY2tcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuX3N0YXJ0U3RhYmlsaXppbmcoKSwhMCE9PXRoaXMuc3RhYmlsaXplZCl7aWYoITA9PT10aGlzLmFkYXB0aXZlVGltZXN0ZXAmJiEwPT09dGhpcy5hZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCl0aGlzLmFkYXB0aXZlQ291bnRlciV0aGlzLmFkYXB0aXZlSW50ZXJ2YWw9PTA/KHRoaXMudGltZXN0ZXA9Mip0aGlzLnRpbWVzdGVwLHRoaXMucGh5c2ljc1N0ZXAoKSx0aGlzLnJldmVydCgpLHRoaXMudGltZXN0ZXA9LjUqdGhpcy50aW1lc3RlcCx0aGlzLnBoeXNpY3NTdGVwKCksdGhpcy5waHlzaWNzU3RlcCgpLHRoaXMuYWRqdXN0VGltZVN0ZXAoKSk6dGhpcy5waHlzaWNzU3RlcCgpLHRoaXMuYWRhcHRpdmVDb3VudGVyKz0xO2Vsc2UgdGhpcy50aW1lc3RlcD10aGlzLm9wdGlvbnMudGltZXN0ZXAsdGhpcy5waHlzaWNzU3RlcCgpOyEwPT09dGhpcy5zdGFiaWxpemVkJiZ0aGlzLnJldmVydCgpLHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMrK319fSx7a2V5OlwidXBkYXRlUGh5c2ljc0RhdGFcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGh5c2ljc0JvZHkuZm9yY2VzPXt9LHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzPVtdLHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzPVtdO3ZhciB0PXRoaXMuYm9keS5ub2RlcyxlPXRoaXMuYm9keS5lZGdlcztmb3IodmFyIGkgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxpKSYmITA9PT10W2ldLm9wdGlvbnMucGh5c2ljcyYmdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMucHVzaCh0W2ldLmlkKTtmb3IodmFyIG8gaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxvKSYmITA9PT1lW29dLm9wdGlvbnMucGh5c2ljcyYmdGhpcy5waHlzaWNzQm9keS5waHlzaWNzRWRnZUluZGljZXMucHVzaChlW29dLmlkKTtmb3IodmFyIG49MDtuPHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aDtuKyspe3ZhciByPXRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzW25dO3RoaXMucGh5c2ljc0JvZHkuZm9yY2VzW3JdPXt4OjAseTowfSx2b2lkIDA9PT10aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXNbcl0mJih0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXNbcl09e3g6MCx5OjB9KX1mb3IodmFyIHMgaW4gdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzKXZvaWQgMD09PXRbc10mJmRlbGV0ZSB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXNbc119fSx7a2V5OlwicmV2ZXJ0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD14bih0aGlzLnByZXZpb3VzU3RhdGVzKSxlPXRoaXMuYm9keS5ub2RlcyxpPXRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllczt0aGlzLnJlZmVyZW5jZVN0YXRlPXt9O2Zvcih2YXIgbz0wO288dC5sZW5ndGg7bysrKXt2YXIgbj10W29dO3ZvaWQgMCE9PWVbbl0/ITA9PT1lW25dLm9wdGlvbnMucGh5c2ljcyYmKHRoaXMucmVmZXJlbmNlU3RhdGVbbl09e3Bvc2l0aW9uczp7eDplW25dLngseTplW25dLnl9fSxpW25dLng9dGhpcy5wcmV2aW91c1N0YXRlc1tuXS52eCxpW25dLnk9dGhpcy5wcmV2aW91c1N0YXRlc1tuXS52eSxlW25dLng9dGhpcy5wcmV2aW91c1N0YXRlc1tuXS54LGVbbl0ueT10aGlzLnByZXZpb3VzU3RhdGVzW25dLnkpOmRlbGV0ZSB0aGlzLnByZXZpb3VzU3RhdGVzW25dfX19LHtrZXk6XCJfZXZhbHVhdGVTdGVwUXVhbGl0eVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZSxpPXRoaXMuYm9keS5ub2RlcyxvPXRoaXMucmVmZXJlbmNlU3RhdGU7Zm9yKHZhciBuIGluIHRoaXMucmVmZXJlbmNlU3RhdGUpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucmVmZXJlbmNlU3RhdGUsbikmJnZvaWQgMCE9PWlbbl0mJih0PWlbbl0ueC1vW25dLnBvc2l0aW9ucy54LGU9aVtuXS55LW9bbl0ucG9zaXRpb25zLnksTWF0aC5zcXJ0KE1hdGgucG93KHQsMikrTWF0aC5wb3coZSwyKSk+LjMpKXJldHVybiExO3JldHVybiEwfX0se2tleTpcIm1vdmVOb2Rlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLGU9MCxpPTAsbz0wO288dC5sZW5ndGg7bysrKXt2YXIgbj10W29dLHI9dGhpcy5fcGVyZm9ybVN0ZXAobik7ZT1NYXRoLm1heChlLHIpLGkrPXJ9dGhpcy5hZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZD1pL3QubGVuZ3RoPDUsdGhpcy5zdGFiaWxpemVkPWU8dGhpcy5vcHRpb25zLm1pblZlbG9jaXR5fX0se2tleTpcImNhbGN1bGF0ZUNvbXBvbmVudFZlbG9jaXR5XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3QrPShlLXRoaXMubW9kZWxPcHRpb25zLmRhbXBpbmcqdCkvaSp0aGlzLnRpbWVzdGVwO3ZhciBvPXRoaXMub3B0aW9ucy5tYXhWZWxvY2l0eXx8MWU5O3JldHVybiBNYXRoLmFicyh0KT5vJiYodD10PjA/bzotbyksdH19LHtrZXk6XCJfcGVyZm9ybVN0ZXBcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmJvZHkubm9kZXNbdF0saT10aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1t0XTt0aGlzLm9wdGlvbnMud2luZCYmKGkueCs9dGhpcy5vcHRpb25zLndpbmQueCxpLnkrPXRoaXMub3B0aW9ucy53aW5kLnkpO3ZhciBvPXRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1t0XTtyZXR1cm4gdGhpcy5wcmV2aW91c1N0YXRlc1t0XT17eDplLngseTplLnksdng6by54LHZ5Om8ueX0sITE9PT1lLm9wdGlvbnMuZml4ZWQueD8oby54PXRoaXMuY2FsY3VsYXRlQ29tcG9uZW50VmVsb2NpdHkoby54LGkueCxlLm9wdGlvbnMubWFzcyksZS54Kz1vLngqdGhpcy50aW1lc3RlcCk6KGkueD0wLG8ueD0wKSwhMT09PWUub3B0aW9ucy5maXhlZC55PyhvLnk9dGhpcy5jYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eShvLnksaS55LGUub3B0aW9ucy5tYXNzKSxlLnkrPW8ueSp0aGlzLnRpbWVzdGVwKTooaS55PTAsby55PTApLE1hdGguc3FydChNYXRoLnBvdyhvLngsMikrTWF0aC5wb3coby55LDIpKX19LHtrZXk6XCJfZnJlZXplTm9kZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuYm9keS5ub2Rlcztmb3IodmFyIGUgaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSYmdFtlXS54JiZ0W2VdLnkpe3ZhciBpPXRbZV0ub3B0aW9ucy5maXhlZDt0aGlzLmZyZWV6ZUNhY2hlW2VdPXt4OmkueCx5OmkueX0saS54PSEwLGkueT0hMH19fSx7a2V5OlwiX3Jlc3RvcmVGcm96ZW5Ob2Rlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5ib2R5Lm5vZGVzO2Zvcih2YXIgZSBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpJiZ2b2lkIDAhPT10aGlzLmZyZWV6ZUNhY2hlW2VdJiYodFtlXS5vcHRpb25zLmZpeGVkLng9dGhpcy5mcmVlemVDYWNoZVtlXS54LHRbZV0ub3B0aW9ucy5maXhlZC55PXRoaXMuZnJlZXplQ2FjaGVbZV0ueSk7dGhpcy5mcmVlemVDYWNoZT17fX19LHtrZXk6XCJzdGFiaWxpemVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06dGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uaXRlcmF0aW9ucztcIm51bWJlclwiIT10eXBlb2YgZSYmKGU9dGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uaXRlcmF0aW9ucyxjb25zb2xlLmVycm9yKFwiVGhlIHN0YWJpbGl6ZSBtZXRob2QgbmVlZHMgYSBudW1lcmljIGFtb3VudCBvZiBpdGVyYXRpb25zLiBTd2l0Y2hpbmcgdG8gZGVmYXVsdDogXCIsZSkpLDAhPT10aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGg/KHRoaXMuYWRhcHRpdmVUaW1lc3RlcD10aGlzLm9wdGlvbnMuYWRhcHRpdmVUaW1lc3RlcCx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2l6ZU5vZGVzXCIpLHRoaXMuc3RvcFNpbXVsYXRpb24oKSx0aGlzLnN0YWJpbGl6ZWQ9ITEsdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9ibG9ja1JlZHJhd1wiKSx0aGlzLnRhcmdldEl0ZXJhdGlvbnM9ZSwhMD09PXRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLm9ubHlEeW5hbWljRWRnZXMmJnRoaXMuX2ZyZWV6ZU5vZGVzKCksdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucz0wLHFyKChmdW5jdGlvbigpe3JldHVybiB0Ll9zdGFiaWxpemF0aW9uQmF0Y2goKX0pLDApKTp0aGlzLnJlYWR5PSEwfX0se2tleTpcIl9zdGFydFN0YWJpbGl6aW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4hMCE9PXRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24mJih0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTdGFiaWxpemluZ1wiKSx0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uPSEwLCEwKX19LHtrZXk6XCJfc3RhYmlsaXphdGlvbkJhdGNoXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9ZnVuY3Rpb24oKXtyZXR1cm4hMT09PXQuc3RhYmlsaXplZCYmdC5zdGFiaWxpemF0aW9uSXRlcmF0aW9uczx0LnRhcmdldEl0ZXJhdGlvbnN9LGk9ZnVuY3Rpb24oKXt0LmJvZHkuZW1pdHRlci5lbWl0KFwic3RhYmlsaXphdGlvblByb2dyZXNzXCIse2l0ZXJhdGlvbnM6dC5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyx0b3RhbDp0LnRhcmdldEl0ZXJhdGlvbnN9KX07dGhpcy5fc3RhcnRTdGFiaWxpemluZygpJiZpKCk7Zm9yKHZhciBvLG49MDtlKCkmJm48dGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24udXBkYXRlSW50ZXJ2YWw7KXRoaXMucGh5c2ljc1RpY2soKSxuKys7KGkoKSxlKCkpP3FyKGJ0KG89dGhpcy5fc3RhYmlsaXphdGlvbkJhdGNoKS5jYWxsKG8sdGhpcyksMCk6dGhpcy5fZmluYWxpemVTdGFiaWxpemF0aW9uKCl9fSx7a2V5OlwiX2ZpbmFsaXplU3RhYmlsaXphdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9hbGxvd1JlZHJhd1wiKSwhMD09PXRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLmZpdCYmdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImZpdFwiKSwhMD09PXRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLm9ubHlEeW5hbWljRWRnZXMmJnRoaXMuX3Jlc3RvcmVGcm96ZW5Ob2RlcygpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFiaWxpemF0aW9uSXRlcmF0aW9uc0RvbmVcIiksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpLCEwPT09dGhpcy5zdGFiaWxpemVkP3RoaXMuX2VtaXRTdGFiaWxpemVkKCk6dGhpcy5zdGFydFNpbXVsYXRpb24oKSx0aGlzLnJlYWR5PSEwfX0se2tleTpcIl9kcmF3Rm9yY2VzXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGg7ZSsrKXt2YXIgaT10aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlc1tlXSxvPXRoaXMuYm9keS5ub2Rlc1tpXSxuPXRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW2ldLHI9TWF0aC5zcXJ0KE1hdGgucG93KG4ueCwyKStNYXRoLnBvdyhuLngsMikpLHM9TWF0aC5taW4oTWF0aC5tYXgoNSxyKSwxNSksYT0zKnMsaD1jaCgoMTgwLTE4MCpNYXRoLm1pbigxLE1hdGgubWF4KDAsLjAzKnIpKSkvMzYwLDEsMSksZD17eDpvLngrMjAqbi54LHk6by55KzIwKm4ueX07dC5saW5lV2lkdGg9cyx0LnN0cm9rZVN0eWxlPWgsdC5iZWdpblBhdGgoKSx0Lm1vdmVUbyhvLngsby55KSx0LmxpbmVUbyhkLngsZC55KSx0LnN0cm9rZSgpO3ZhciBsPU1hdGguYXRhbjIobi55LG4ueCk7dC5maWxsU3R5bGU9aCxOYy5kcmF3KHQse3R5cGU6XCJhcnJvd1wiLHBvaW50OmQsYW5nbGU6bCxsZW5ndGg6YX0pLFhyKHQpLmNhbGwodCl9fX1dKSx0fSgpLGZ1PW5ldyBVaW50OEFycmF5KDE2KTtmdW5jdGlvbiBwdSgpe2lmKCFsdSYmIShsdT1cInVuZGVmaW5lZFwiIT10eXBlb2YgY3J5cHRvJiZjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzJiZjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKXx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1zQ3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMmJm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKSkpdGhyb3cgbmV3IEVycm9yKFwiY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWRcIik7cmV0dXJuIGx1KGZ1KX12YXIgdnU9L14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO2Z1bmN0aW9uIGd1KHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0JiZ2dS50ZXN0KHQpfWZvcih2YXIgeXU9W10sbXU9MDttdTwyNTY7KyttdSl5dS5wdXNoKChtdSsyNTYpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO2Z1bmN0aW9uIGJ1KHQsZSxpKXt2YXIgbz0odD10fHx7fSkucmFuZG9tfHwodC5ybmd8fHB1KSgpO2lmKG9bNl09MTUmb1s2XXw2NCxvWzhdPTYzJm9bOF18MTI4LGUpe2k9aXx8MDtmb3IodmFyIG49MDtuPDE2OysrbillW2krbl09b1tuXTtyZXR1cm4gZX1yZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjAsaT0oeXVbdFtlKzBdXSt5dVt0W2UrMV1dK3l1W3RbZSsyXV0reXVbdFtlKzNdXStcIi1cIit5dVt0W2UrNF1dK3l1W3RbZSs1XV0rXCItXCIreXVbdFtlKzZdXSt5dVt0W2UrN11dK1wiLVwiK3l1W3RbZSs4XV0reXVbdFtlKzldXStcIi1cIit5dVt0W2UrMTBdXSt5dVt0W2UrMTFdXSt5dVt0W2UrMTJdXSt5dVt0W2UrMTNdXSt5dVt0W2UrMTRdXSt5dVt0W2UrMTVdXSkudG9Mb3dlckNhc2UoKTtpZighZ3UoaSkpdGhyb3cgVHlwZUVycm9yKFwiU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkXCIpO3JldHVybiBpfShvKX12YXIgd3U9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7UG8odGhpcyx0KX1yZXR1cm4gSW8odCxudWxsLFt7a2V5OlwiZ2V0UmFuZ2VcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZSxpPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpbXSxvPTFlOSxuPS0xZTkscj0xZTkscz0tMWU5O2lmKGkubGVuZ3RoPjApZm9yKHZhciBhPTA7YTxpLmxlbmd0aDthKyspcj4oZT10W2lbYV1dKS5zaGFwZS5ib3VuZGluZ0JveC5sZWZ0JiYocj1lLnNoYXBlLmJvdW5kaW5nQm94LmxlZnQpLHM8ZS5zaGFwZS5ib3VuZGluZ0JveC5yaWdodCYmKHM9ZS5zaGFwZS5ib3VuZGluZ0JveC5yaWdodCksbz5lLnNoYXBlLmJvdW5kaW5nQm94LnRvcCYmKG89ZS5zaGFwZS5ib3VuZGluZ0JveC50b3ApLG48ZS5zaGFwZS5ib3VuZGluZ0JveC5ib3R0b20mJihuPWUuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tKTtyZXR1cm4gMWU5PT09ciYmLTFlOT09PXMmJjFlOT09PW8mJi0xZTk9PT1uJiYobz0wLG49MCxyPTAscz0wKSx7bWluWDpyLG1heFg6cyxtaW5ZOm8sbWF4WTpufX19LHtrZXk6XCJnZXRSYW5nZUNvcmVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZSxpPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpbXSxvPTFlOSxuPS0xZTkscj0xZTkscz0tMWU5O2lmKGkubGVuZ3RoPjApZm9yKHZhciBhPTA7YTxpLmxlbmd0aDthKyspcj4oZT10W2lbYV1dKS54JiYocj1lLngpLHM8ZS54JiYocz1lLngpLG8+ZS55JiYobz1lLnkpLG48ZS55JiYobj1lLnkpO3JldHVybiAxZTk9PT1yJiYtMWU5PT09cyYmMWU5PT09byYmLTFlOT09PW4mJihvPTAsbj0wLHI9MCxzPTApLHttaW5YOnIsbWF4WDpzLG1pblk6byxtYXhZOm59fX0se2tleTpcImZpbmRDZW50ZXJcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm57eDouNSoodC5tYXhYK3QubWluWCkseTouNSoodC5tYXhZK3QubWluWSl9fX0se2tleTpcImNsb25lT3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9e307cmV0dXJuIHZvaWQgMD09PWV8fFwibm9kZVwiPT09ZT8odGgoaSx0Lm9wdGlvbnMsITApLGkueD10LngsaS55PXQueSxpLmFtb3VudE9mQ29ubmVjdGlvbnM9dC5lZGdlcy5sZW5ndGgpOnRoKGksdC5vcHRpb25zLCEwKSxpfX1dKSx0fSgpO2Z1bmN0aW9uIGt1KHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIF91PWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9a3UoaSk7ZnVuY3Rpb24gaSh0LG8sbixyLHMsYSl7dmFyIGg7cmV0dXJuIFBvKHRoaXMsaSksKGg9ZS5jYWxsKHRoaXMsdCxvLG4scixzLGEpKS5pc0NsdXN0ZXI9ITAsaC5jb250YWluZWROb2Rlcz17fSxoLmNvbnRhaW5lZEVkZ2VzPXt9LGh9cmV0dXJuIElvKGksW3trZXk6XCJfb3BlbkNoaWxkQ2x1c3RlclwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsaT10aGlzLmJvZHkubm9kZXNbdF07aWYodm9pZCAwPT09dGhpcy5jb250YWluZWROb2Rlc1t0XSl0aHJvdyBuZXcgRXJyb3IoXCJub2RlIHdpdGggaWQ6IFwiK3QrXCIgbm90IGluIGN1cnJlbnQgY2x1c3RlclwiKTtpZighaS5pc0NsdXN0ZXIpdGhyb3cgbmV3IEVycm9yKFwibm9kZSB3aXRoIGlkOiBcIit0K1wiIGlzIG5vdCBhIGNsdXN0ZXJcIik7ZGVsZXRlIHRoaXMuY29udGFpbmVkTm9kZXNbdF0sbmgoaS5lZGdlcywoZnVuY3Rpb24odCl7ZGVsZXRlIGUuY29udGFpbmVkRWRnZXNbdC5pZF19KSksbmgoaS5jb250YWluZWROb2RlcywoZnVuY3Rpb24odCxpKXtlLmNvbnRhaW5lZE5vZGVzW2ldPXR9KSksaS5jb250YWluZWROb2Rlcz17fSxuaChpLmNvbnRhaW5lZEVkZ2VzLChmdW5jdGlvbih0LGkpe2UuY29udGFpbmVkRWRnZXNbaV09dH0pKSxpLmNvbnRhaW5lZEVkZ2VzPXt9LG5oKGkuZWRnZXMsKGZ1bmN0aW9uKHQpe25oKGUuZWRnZXMsKGZ1bmN0aW9uKGkpe3ZhciBvLG4scj1NcihvPWkuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMpLmNhbGwobyx0LmlkKTstMSE9PXImJihuaCh0LmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLChmdW5jdGlvbih0KXtpLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLnB1c2godCksZS5ib2R5LmVkZ2VzW3RdLmVkZ2VSZXBsYWNlZEJ5SWQ9aS5pZH0pKSxxbihuPWkuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMpLmNhbGwobixyLDEpKX0pKX0pKSxpLmVkZ2VzPVtdfX1dKSxpfShsYykseHU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe3ZhciBpPXRoaXM7UG8odGhpcyx0KSx0aGlzLmJvZHk9ZSx0aGlzLmNsdXN0ZXJlZE5vZGVzPXt9LHRoaXMuY2x1c3RlcmVkRWRnZXM9e30sdGhpcy5vcHRpb25zPXt9LHRoaXMuZGVmYXVsdE9wdGlvbnM9e30sY3QodGhpcy5vcHRpb25zLHRoaXMuZGVmYXVsdE9wdGlvbnMpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3Jlc2V0RGF0YVwiLChmdW5jdGlvbigpe2kuY2x1c3RlcmVkTm9kZXM9e30saS5jbHVzdGVyZWRFZGdlcz17fX0pKX1yZXR1cm4gSW8odCxbe2tleTpcImNsdXN0ZXJCeUh1YnNpemVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PXQ/dD10aGlzLl9nZXRIdWJTaXplKCk6XCJvYmplY3RcIj09PWRuKHQpJiYoZT10aGlzLl9jaGVja09wdGlvbnModCksdD10aGlzLl9nZXRIdWJTaXplKCkpO2Zvcih2YXIgaT1bXSxvPTA7bzx0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO28rKyl7dmFyIG49dGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tvXV07bi5lZGdlcy5sZW5ndGg+PXQmJmkucHVzaChuLmlkKX1mb3IodmFyIHI9MDtyPGkubGVuZ3RoO3IrKyl0aGlzLmNsdXN0ZXJCeUNvbm5lY3Rpb24oaVtyXSxlLCEwKTt0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpfX0se2tleTpcImNsdXN0ZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30saT0hKGFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdKXx8YXJndW1lbnRzWzFdO2lmKHZvaWQgMD09PWUuam9pbkNvbmRpdGlvbil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBjbHVzdGVyQnlOb2RlRGF0YSB3aXRob3V0IGEgam9pbkNvbmRpdGlvbiBmdW5jdGlvbiBpbiB0aGUgb3B0aW9ucy5cIik7ZT10aGlzLl9jaGVja09wdGlvbnMoZSk7dmFyIG89e30sbj17fTtuaCh0aGlzLmJvZHkubm9kZXMsKGZ1bmN0aW9uKGkscil7aS5vcHRpb25zJiYhMD09PWUuam9pbkNvbmRpdGlvbihpLm9wdGlvbnMpJiYob1tyXT1pLG5oKGkuZWRnZXMsKGZ1bmN0aW9uKGUpe3ZvaWQgMD09PXQuY2x1c3RlcmVkRWRnZXNbZS5pZF0mJihuW2UuaWRdPWUpfSkpKX0pKSx0aGlzLl9jbHVzdGVyKG8sbixlLGkpfX0se2tleTpcImNsdXN0ZXJCeUVkZ2VDb3VudFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9dGhpcyxvPSEoYXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0pfHxhcmd1bWVudHNbMl07ZT10aGlzLl9jaGVja09wdGlvbnMoZSk7Zm9yKHZhciBuLHIscyxhPVtdLGg9e30sZD1mdW5jdGlvbihvKXt2YXIgZD17fSxsPXt9LGM9aS5ib2R5Lm5vZGVJbmRpY2VzW29dLHU9aS5ib2R5Lm5vZGVzW2NdO2lmKHZvaWQgMD09PWhbY10pe3M9MCxyPVtdO2Zvcih2YXIgZj0wO2Y8dS5lZGdlcy5sZW5ndGg7ZisrKW49dS5lZGdlc1tmXSx2b2lkIDA9PT1pLmNsdXN0ZXJlZEVkZ2VzW24uaWRdJiYobi50b0lkIT09bi5mcm9tSWQmJnMrKyxyLnB1c2gobikpO2lmKHM9PT10KXtmb3IodmFyIHA9ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09ZS5qb2luQ29uZGl0aW9ufHxudWxsPT09ZS5qb2luQ29uZGl0aW9uKXJldHVybiEwO3ZhciBpPXd1LmNsb25lT3B0aW9ucyh0KTtyZXR1cm4gZS5qb2luQ29uZGl0aW9uKGkpfSx2PSEwLGc9MDtnPHIubGVuZ3RoO2crKyl7bj1yW2ddO3ZhciB5PWkuX2dldENvbm5lY3RlZElkKG4sYyk7aWYoIXAodSkpe3Y9ITE7YnJlYWt9bFtuLmlkXT1uLGRbY109dSxkW3ldPWkuYm9keS5ub2Rlc1t5XSxoW2NdPSEwfWlmKHhuKGQpLmxlbmd0aD4wJiZ4bihsKS5sZW5ndGg+MCYmITA9PT12KXt2YXIgbT1mdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8YS5sZW5ndGg7Kyt0KWZvcih2YXIgZSBpbiBkKWlmKHZvaWQgMCE9PWFbdF0ubm9kZXNbZV0pcmV0dXJuIGFbdF19KCk7aWYodm9pZCAwIT09bSl7Zm9yKHZhciBiIGluIGQpdm9pZCAwPT09bS5ub2Rlc1tiXSYmKG0ubm9kZXNbYl09ZFtiXSk7Zm9yKHZhciB3IGluIGwpdm9pZCAwPT09bS5lZGdlc1t3XSYmKG0uZWRnZXNbd109bFt3XSl9ZWxzZSBhLnB1c2goe25vZGVzOmQsZWRnZXM6bH0pfX19fSxsPTA7bDx0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO2wrKylkKGwpO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKXRoaXMuX2NsdXN0ZXIoYVtjXS5ub2RlcyxhW2NdLmVkZ2VzLGUsITEpOyEwPT09byYmdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKX19LHtrZXk6XCJjbHVzdGVyT3V0bGllcnNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT0hKGFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdKXx8YXJndW1lbnRzWzFdO3RoaXMuY2x1c3RlckJ5RWRnZUNvdW50KDEsdCxlKX19LHtrZXk6XCJjbHVzdGVyQnJpZGdlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV07dGhpcy5jbHVzdGVyQnlFZGdlQ291bnQoMix0LGUpfX0se2tleTpcImNsdXN0ZXJCeUNvbm5lY3Rpb25cIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpLG89IShhcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSl8fGFyZ3VtZW50c1syXTtpZih2b2lkIDA9PT10KXRocm93IG5ldyBFcnJvcihcIk5vIG5vZGVJZCBzdXBwbGllZCB0byBjbHVzdGVyQnlDb25uZWN0aW9uIVwiKTtpZih2b2lkIDA9PT10aGlzLmJvZHkubm9kZXNbdF0pdGhyb3cgbmV3IEVycm9yKFwiVGhlIG5vZGVJZCBnaXZlbiB0byBjbHVzdGVyQnlDb25uZWN0aW9uIGRvZXMgbm90IGV4aXN0IVwiKTt2YXIgbj10aGlzLmJvZHkubm9kZXNbdF07dm9pZCAwPT09KGU9dGhpcy5fY2hlY2tPcHRpb25zKGUsbikpLmNsdXN0ZXJOb2RlUHJvcGVydGllcy54JiYoZS5jbHVzdGVyTm9kZVByb3BlcnRpZXMueD1uLngpLHZvaWQgMD09PWUuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkmJihlLmNsdXN0ZXJOb2RlUHJvcGVydGllcy55PW4ueSksdm9pZCAwPT09ZS5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQmJihlLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZD17fSxlLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZC54PW4ub3B0aW9ucy5maXhlZC54LGUuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkLnk9bi5vcHRpb25zLmZpeGVkLnkpO3ZhciByPXt9LHM9e30sYT1uLmlkLGg9d3UuY2xvbmVPcHRpb25zKG4pO3JbYV09bjtmb3IodmFyIGQ9MDtkPG4uZWRnZXMubGVuZ3RoO2QrKyl7dmFyIGw9bi5lZGdlc1tkXTtpZih2b2lkIDA9PT10aGlzLmNsdXN0ZXJlZEVkZ2VzW2wuaWRdKXt2YXIgYz10aGlzLl9nZXRDb25uZWN0ZWRJZChsLGEpO2lmKHZvaWQgMD09PXRoaXMuY2x1c3RlcmVkTm9kZXNbY10paWYoYyE9PWEpaWYodm9pZCAwPT09ZS5qb2luQ29uZGl0aW9uKXNbbC5pZF09bCxyW2NdPXRoaXMuYm9keS5ub2Rlc1tjXTtlbHNle3ZhciB1PXd1LmNsb25lT3B0aW9ucyh0aGlzLmJvZHkubm9kZXNbY10pOyEwPT09ZS5qb2luQ29uZGl0aW9uKGgsdSkmJihzW2wuaWRdPWwscltjXT10aGlzLmJvZHkubm9kZXNbY10pfWVsc2Ugc1tsLmlkXT1sfX12YXIgZj1rbihpPXhuKHIpKS5jYWxsKGksKGZ1bmN0aW9uKHQpe3JldHVybiByW3RdLmlkfSkpO2Zvcih2YXIgcCBpbiByKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLHApKWZvcih2YXIgdj1yW3BdLGc9MDtnPHYuZWRnZXMubGVuZ3RoO2crKyl7dmFyIHk9di5lZGdlc1tnXTtNcihmKS5jYWxsKGYsdGhpcy5fZ2V0Q29ubmVjdGVkSWQoeSx2LmlkKSk+LTEmJihzW3kuaWRdPXkpfXRoaXMuX2NsdXN0ZXIocixzLGUsbyl9fSx7a2V5OlwiX2NyZWF0ZUNsdXN0ZXJFZGdlc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8pe2Zvcih2YXIgbixyLHMsYSxoLGQsbD14bih0KSxjPVtdLHU9MDt1PGwubGVuZ3RoO3UrKyl7cz10W3I9bFt1XV07Zm9yKHZhciBmPTA7ZjxzLmVkZ2VzLmxlbmd0aDtmKyspbj1zLmVkZ2VzW2ZdLHZvaWQgMD09PXRoaXMuY2x1c3RlcmVkRWRnZXNbbi5pZF0mJihuLnRvSWQ9PW4uZnJvbUlkP2Vbbi5pZF09bjpuLnRvSWQ9PXI/KGE9aS5pZCxkPWg9bi5mcm9tSWQpOihhPW4udG9JZCxoPWkuaWQsZD1hKSx2b2lkIDA9PT10W2RdJiZjLnB1c2goe2VkZ2U6bixmcm9tSWQ6aCx0b0lkOmF9KSl9Zm9yKHZhciBwPVtdLHY9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTxwLmxlbmd0aDtlKyspe3ZhciBpPXBbZV0sbz10LmZyb21JZD09PWkuZnJvbUlkJiZ0LnRvSWQ9PT1pLnRvSWQsbj10LmZyb21JZD09PWkudG9JZCYmdC50b0lkPT09aS5mcm9tSWQ7aWYob3x8bilyZXR1cm4gaX1yZXR1cm4gbnVsbH0sZz0wO2c8Yy5sZW5ndGg7ZysrKXt2YXIgeT1jW2ddLG09eS5lZGdlLGI9dih5KTtudWxsPT09Yj8oYj10aGlzLl9jcmVhdGVDbHVzdGVyZWRFZGdlKHkuZnJvbUlkLHkudG9JZCxtLG8pLHAucHVzaChiKSk6Yi5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcy5wdXNoKG0uaWQpLHRoaXMuYm9keS5lZGdlc1ttLmlkXS5lZGdlUmVwbGFjZWRCeUlkPWIuaWQsdGhpcy5fYmFja3VwRWRnZU9wdGlvbnMobSksbS5zZXRPcHRpb25zKHtwaHlzaWNzOiExfSl9fX0se2tleTpcIl9jaGVja09wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtyZXR1cm4gdm9pZCAwPT09dC5jbHVzdGVyRWRnZVByb3BlcnRpZXMmJih0LmNsdXN0ZXJFZGdlUHJvcGVydGllcz17fSksdm9pZCAwPT09dC5jbHVzdGVyTm9kZVByb3BlcnRpZXMmJih0LmNsdXN0ZXJOb2RlUHJvcGVydGllcz17fSksdH19LHtrZXk6XCJfY2x1c3RlclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz0hKGFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdKXx8YXJndW1lbnRzWzNdLG49W107Zm9yKHZhciByIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQscikmJnZvaWQgMCE9PXRoaXMuY2x1c3RlcmVkTm9kZXNbcl0mJm4ucHVzaChyKTtmb3IodmFyIHM9MDtzPG4ubGVuZ3RoOysrcylkZWxldGUgdFtuW3NdXTtpZigwIT14bih0KS5sZW5ndGgmJigxIT14bih0KS5sZW5ndGh8fDE9PWkuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmFsbG93U2luZ2xlTm9kZUNsdXN0ZXIpKXt2YXIgYT10aCh7fSxpLmNsdXN0ZXJOb2RlUHJvcGVydGllcyk7aWYodm9pZCAwIT09aS5wcm9jZXNzUHJvcGVydGllcyl7dmFyIGg9W107Zm9yKHZhciBkIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZCkpe3ZhciBsPXd1LmNsb25lT3B0aW9ucyh0W2RdKTtoLnB1c2gobCl9dmFyIGM9W107Zm9yKHZhciB1IGluIGUpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdSkmJlwiY2x1c3RlckVkZ2U6XCIhPT11LnN1YnN0cigwLDEyKSl7dmFyIGY9d3UuY2xvbmVPcHRpb25zKGVbdV0sXCJlZGdlXCIpO2MucHVzaChmKX1pZighKGE9aS5wcm9jZXNzUHJvcGVydGllcyhhLGgsYykpKXRocm93IG5ldyBFcnJvcihcIlRoZSBwcm9jZXNzUHJvcGVydGllcyBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gcHJvcGVydGllcyFcIil9dm9pZCAwPT09YS5pZCYmKGEuaWQ9XCJjbHVzdGVyOlwiK2J1KCkpO3ZhciBwPWEuaWQ7dm9pZCAwPT09YS5sYWJlbCYmKGEubGFiZWw9XCJjbHVzdGVyXCIpO3ZhciB2PXZvaWQgMDt2b2lkIDA9PT1hLngmJih2PXRoaXMuX2dldENsdXN0ZXJQb3NpdGlvbih0KSxhLng9di54KSx2b2lkIDA9PT1hLnkmJih2b2lkIDA9PT12JiYodj10aGlzLl9nZXRDbHVzdGVyUG9zaXRpb24odCkpLGEueT12LnkpLGEuaWQ9cDt2YXIgZz10aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUoYSxfdSk7Zy5jb250YWluZWROb2Rlcz10LGcuY29udGFpbmVkRWRnZXM9ZSxnLmNsdXN0ZXJFZGdlUHJvcGVydGllcz1pLmNsdXN0ZXJFZGdlUHJvcGVydGllcyx0aGlzLmJvZHkubm9kZXNbYS5pZF09Zyx0aGlzLl9jbHVzdGVyRWRnZXModCxlLGEsaS5jbHVzdGVyRWRnZVByb3BlcnRpZXMpLGEuaWQ9dm9pZCAwLCEwPT09byYmdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKX19fSx7a2V5OlwiX2JhY2t1cEVkZ2VPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7dm9pZCAwPT09dGhpcy5jbHVzdGVyZWRFZGdlc1t0LmlkXSYmKHRoaXMuY2x1c3RlcmVkRWRnZXNbdC5pZF09e3BoeXNpY3M6dC5vcHRpb25zLnBoeXNpY3N9KX19LHtrZXk6XCJfcmVzdG9yZUVkZ2VcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmNsdXN0ZXJlZEVkZ2VzW3QuaWRdO3ZvaWQgMCE9PWUmJih0LnNldE9wdGlvbnMoe3BoeXNpY3M6ZS5waHlzaWNzfSksZGVsZXRlIHRoaXMuY2x1c3RlcmVkRWRnZXNbdC5pZF0pfX0se2tleTpcImlzQ2x1c3RlclwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10aGlzLmJvZHkubm9kZXNbdF0/ITA9PT10aGlzLmJvZHkubm9kZXNbdF0uaXNDbHVzdGVyOihjb25zb2xlLmVycm9yKFwiTm9kZSBkb2VzIG5vdCBleGlzdC5cIiksITEpfX0se2tleTpcIl9nZXRDbHVzdGVyUG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGUsaT14bih0KSxvPXRbaVswXV0ueCxuPXRbaVswXV0ueCxyPXRbaVswXV0ueSxzPXRbaVswXV0ueSxhPTE7YTxpLmxlbmd0aDthKyspbz0oZT10W2lbYV1dKS54PG8/ZS54Om8sbj1lLng+bj9lLng6bixyPWUueTxyP2UueTpyLHM9ZS55PnM/ZS55OnM7cmV0dXJue3g6LjUqKG8rbikseTouNSoocitzKX19fSx7a2V5Olwib3BlbkNsdXN0ZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPSEoYXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0pfHxhcmd1bWVudHNbMl07aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJObyBjbHVzdGVyTm9kZUlkIHN1cHBsaWVkIHRvIG9wZW5DbHVzdGVyLlwiKTt2YXIgbz10aGlzLmJvZHkubm9kZXNbdF07aWYodm9pZCAwPT09byl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY2x1c3Rlck5vZGVJZCBzdXBwbGllZCB0byBvcGVuQ2x1c3RlciBkb2VzIG5vdCBleGlzdC5cIik7aWYoITAhPT1vLmlzQ2x1c3Rlcnx8dm9pZCAwPT09by5jb250YWluZWROb2Rlc3x8dm9pZCAwPT09by5jb250YWluZWRFZGdlcyl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbm9kZTpcIit0K1wiIGlzIG5vdCBhIHZhbGlkIGNsdXN0ZXIuXCIpO3ZhciBuPXRoaXMuZmluZE5vZGUodCkscj1NcihuKS5jYWxsKG4sdCktMTtpZihyPj0wKXt2YXIgcz1uW3JdLGE9dGhpcy5ib2R5Lm5vZGVzW3NdO3JldHVybiBhLl9vcGVuQ2hpbGRDbHVzdGVyKHQpLGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbdF0sdm9pZCghMD09PWkmJnRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIikpfXZhciBoPW8uY29udGFpbmVkTm9kZXMsZD1vLmNvbnRhaW5lZEVkZ2VzO2lmKHZvaWQgMCE9PWUmJnZvaWQgMCE9PWUucmVsZWFzZUZ1bmN0aW9uJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnJlbGVhc2VGdW5jdGlvbil7dmFyIGw9e30sYz17eDpvLngseTpvLnl9O2Zvcih2YXIgdSBpbiBoKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoLHUpKXt2YXIgZj10aGlzLmJvZHkubm9kZXNbdV07bFt1XT17eDpmLngseTpmLnl9fXZhciBwPWUucmVsZWFzZUZ1bmN0aW9uKGMsbCk7Zm9yKHZhciB2IGluIGgpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGgsdikpe3ZhciBnPXRoaXMuYm9keS5ub2Rlc1t2XTt2b2lkIDAhPT1wW3ZdJiYoZy54PXZvaWQgMD09PXBbdl0ueD9vLng6cFt2XS54LGcueT12b2lkIDA9PT1wW3ZdLnk/by55OnBbdl0ueSl9fWVsc2UgbmgoaCwoZnVuY3Rpb24odCl7ITE9PT10Lm9wdGlvbnMuZml4ZWQueCYmKHQueD1vLngpLCExPT09dC5vcHRpb25zLmZpeGVkLnkmJih0Lnk9by55KX0pKTtmb3IodmFyIHkgaW4gaClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaCx5KSl7dmFyIG09dGhpcy5ib2R5Lm5vZGVzW3ldO20udng9by52eCxtLnZ5PW8udnksbS5zZXRPcHRpb25zKHtwaHlzaWNzOiEwfSksZGVsZXRlIHRoaXMuY2x1c3RlcmVkTm9kZXNbeV19Zm9yKHZhciBiPVtdLHc9MDt3PG8uZWRnZXMubGVuZ3RoO3crKyliLnB1c2goby5lZGdlc1t3XSk7Zm9yKHZhciBrPTA7azxiLmxlbmd0aDtrKyspe2Zvcih2YXIgXz1iW2tdLHg9dGhpcy5fZ2V0Q29ubmVjdGVkSWQoXyx0KSxFPXRoaXMuY2x1c3RlcmVkTm9kZXNbeF0sTz0wO088Xy5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcy5sZW5ndGg7TysrKXt2YXIgQz1fLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzW09dLFM9dGhpcy5ib2R5LmVkZ2VzW0NdO2lmKHZvaWQgMCE9PVMpaWYodm9pZCAwIT09RSl7dmFyIFQ9dGhpcy5ib2R5Lm5vZGVzW0UuY2x1c3RlcklkXTtULmNvbnRhaW5lZEVkZ2VzW1MuaWRdPVMsZGVsZXRlIGRbUy5pZF07dmFyIE09Uy5mcm9tSWQsUD1TLnRvSWQ7Uy50b0lkPT14P1A9RS5jbHVzdGVySWQ6TT1FLmNsdXN0ZXJJZCx0aGlzLl9jcmVhdGVDbHVzdGVyZWRFZGdlKE0sUCxTLFQuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzLHtoaWRkZW46ITEscGh5c2ljczohMH0pfWVsc2UgdGhpcy5fcmVzdG9yZUVkZ2UoUyl9Xy5yZW1vdmUoKX1mb3IodmFyIEQgaW4gZClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZCxEKSYmdGhpcy5fcmVzdG9yZUVkZ2UoZFtEXSk7ZGVsZXRlIHRoaXMuYm9keS5ub2Rlc1t0XSwhMD09PWkmJnRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIil9fSx7a2V5OlwiZ2V0Tm9kZXNJbkNsdXN0ZXJcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1bXTtpZighMD09PXRoaXMuaXNDbHVzdGVyKHQpKXt2YXIgaT10aGlzLmJvZHkubm9kZXNbdF0uY29udGFpbmVkTm9kZXM7Zm9yKHZhciBvIGluIGkpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGksbykmJmUucHVzaCh0aGlzLmJvZHkubm9kZXNbb10uaWQpfXJldHVybiBlfX0se2tleTpcImZpbmROb2RlXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlLGk9W10sbz0wO3ZvaWQgMCE9PXRoaXMuY2x1c3RlcmVkTm9kZXNbdF0mJm88MTAwOyl7aWYodm9pZCAwPT09KGU9dGhpcy5ib2R5Lm5vZGVzW3RdKSlyZXR1cm5bXTtpLnB1c2goZS5pZCksdD10aGlzLmNsdXN0ZXJlZE5vZGVzW3RdLmNsdXN0ZXJJZCxvKyt9cmV0dXJuIHZvaWQgMD09PShlPXRoaXMuYm9keS5ub2Rlc1t0XSk/W106KGkucHVzaChlLmlkKSxObihpKS5jYWxsKGkpLGkpfX0se2tleTpcInVwZGF0ZUNsdXN0ZXJlZE5vZGVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IEVycm9yKFwiTm8gY2x1c3RlcmVkTm9kZUlkIHN1cHBsaWVkIHRvIHVwZGF0ZUNsdXN0ZXJlZE5vZGUuXCIpO2lmKHZvaWQgMD09PWUpdGhyb3cgbmV3IEVycm9yKFwiTm8gbmV3T3B0aW9ucyBzdXBwbGllZCB0byB1cGRhdGVDbHVzdGVyZWROb2RlLlwiKTtpZih2b2lkIDA9PT10aGlzLmJvZHkubm9kZXNbdF0pdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNsdXN0ZXJlZE5vZGVJZCBzdXBwbGllZCB0byB1cGRhdGVDbHVzdGVyZWROb2RlIGRvZXMgbm90IGV4aXN0LlwiKTt0aGlzLmJvZHkubm9kZXNbdF0uc2V0T3B0aW9ucyhlKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpfX0se2tleTpcInVwZGF0ZUVkZ2VcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IEVycm9yKFwiTm8gc3RhcnRFZGdlSWQgc3VwcGxpZWQgdG8gdXBkYXRlRWRnZS5cIik7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJObyBuZXdPcHRpb25zIHN1cHBsaWVkIHRvIHVwZGF0ZUVkZ2UuXCIpO2lmKHZvaWQgMD09PXRoaXMuYm9keS5lZGdlc1t0XSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3RhcnRFZGdlSWQgc3VwcGxpZWQgdG8gdXBkYXRlRWRnZSBkb2VzIG5vdCBleGlzdC5cIik7Zm9yKHZhciBpPXRoaXMuZ2V0Q2x1c3RlcmVkRWRnZXModCksbz0wO288aS5sZW5ndGg7bysrKXt0aGlzLmJvZHkuZWRnZXNbaVtvXV0uc2V0T3B0aW9ucyhlKX10aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpfX0se2tleTpcImdldENsdXN0ZXJlZEVkZ2VzXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLGk9MDt2b2lkIDAhPT10JiZ2b2lkIDAhPT10aGlzLmJvZHkuZWRnZXNbdF0mJmk8MTAwOyllLnB1c2godGhpcy5ib2R5LmVkZ2VzW3RdLmlkKSx0PXRoaXMuYm9keS5lZGdlc1t0XS5lZGdlUmVwbGFjZWRCeUlkLGkrKztyZXR1cm4gTm4oZSkuY2FsbChlKSxlfX0se2tleTpcImdldEJhc2VFZGdlXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0QmFzZUVkZ2VzKHQpWzBdfX0se2tleTpcImdldEJhc2VFZGdlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bdF0saT1bXSxvPVtdLG49MDtlLmxlbmd0aD4wJiZuPDEwMDspe3ZhciByPWUucG9wKCk7aWYodm9pZCAwIT09cil7dmFyIHM9dGhpcy5ib2R5LmVkZ2VzW3JdO2lmKHZvaWQgMCE9PXMpe24rKzt2YXIgYT1zLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzO2lmKHZvaWQgMD09PWEpby5wdXNoKHIpO2Vsc2UgZm9yKHZhciBoPTA7aDxhLmxlbmd0aDsrK2gpe3ZhciBkPWFbaF07LTE9PT1NcihlKS5jYWxsKGUsYSkmJi0xPT09TXIoaSkuY2FsbChpLGEpJiZlLnB1c2goZCl9aS5wdXNoKHIpfX19cmV0dXJuIG99fSx7a2V5OlwiX2dldENvbm5lY3RlZElkXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC50b0lkIT1lP3QudG9JZDoodC5mcm9tSWQsdC5mcm9tSWQpfX0se2tleTpcIl9nZXRIdWJTaXplXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTAsaT0wLG89MCxuPTA7bjx0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO24rKyl7dmFyIHI9dGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tuXV07ci5lZGdlcy5sZW5ndGg+byYmKG89ci5lZGdlcy5sZW5ndGgpLHQrPXIuZWRnZXMubGVuZ3RoLGUrPU1hdGgucG93KHIuZWRnZXMubGVuZ3RoLDIpLGkrPTF9dC89aTt2YXIgcz0oZS89aSktTWF0aC5wb3codCwyKSxhPU1hdGguc3FydChzKSxoPU1hdGguZmxvb3IodCsyKmEpO3JldHVybiBoPm8mJihoPW8pLGh9fSx7a2V5OlwiX2NyZWF0ZUNsdXN0ZXJlZEVkZ2VcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4pe3ZhciByPXd1LmNsb25lT3B0aW9ucyhpLFwiZWRnZVwiKTt0aChyLG8pLHIuZnJvbT10LHIudG89ZSxyLmlkPVwiY2x1c3RlckVkZ2U6XCIrYnUoKSx2b2lkIDAhPT1uJiZ0aChyLG4pO3ZhciBzPXRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZShyKTtyZXR1cm4gcy5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcz1baS5pZF0scy5jb25uZWN0KCksdGhpcy5ib2R5LmVkZ2VzW3MuaWRdPXMsc319LHtrZXk6XCJfY2x1c3RlckVkZ2VzXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyl7aWYoZSBpbnN0YW5jZW9mIEpjKXt2YXIgbj1lLHI9e307cltuLmlkXT1uLGU9cn1pZih0IGluc3RhbmNlb2YgbGMpe3ZhciBzPXQsYT17fTthW3MuaWRdPXMsdD1hfWlmKG51bGw9PWkpdGhyb3cgbmV3IEVycm9yKFwiX2NsdXN0ZXJFZGdlczogcGFyYW1ldGVyIGNsdXN0ZXJOb2RlIHJlcXVpcmVkXCIpO2Zvcih2YXIgaCBpbiB2b2lkIDA9PT1vJiYobz1pLmNsdXN0ZXJFZGdlUHJvcGVydGllcyksdGhpcy5fY3JlYXRlQ2x1c3RlckVkZ2VzKHQsZSxpLG8pLGUpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsaCkmJnZvaWQgMCE9PXRoaXMuYm9keS5lZGdlc1toXSl7dmFyIGQ9dGhpcy5ib2R5LmVkZ2VzW2hdO3RoaXMuX2JhY2t1cEVkZ2VPcHRpb25zKGQpLGQuc2V0T3B0aW9ucyh7cGh5c2ljczohMX0pfWZvcih2YXIgbCBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGwpJiYodGhpcy5jbHVzdGVyZWROb2Rlc1tsXT17Y2x1c3RlcklkOmkuaWQsbm9kZTp0aGlzLmJvZHkubm9kZXNbbF19LHRoaXMuYm9keS5ub2Rlc1tsXS5zZXRPcHRpb25zKHtwaHlzaWNzOiExfSkpfX0se2tleTpcIl9nZXRDbHVzdGVyTm9kZUZvck5vZGVcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih2b2lkIDAhPT10KXt2YXIgZT10aGlzLmNsdXN0ZXJlZE5vZGVzW3RdO2lmKHZvaWQgMCE9PWUpe3ZhciBpPWUuY2x1c3RlcklkO2lmKHZvaWQgMCE9PWkpcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1tpXX19fX0se2tleTpcIl9maWx0ZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPVtdO3JldHVybiBuaCh0LChmdW5jdGlvbih0KXtlKHQpJiZpLnB1c2godCl9KSksaX19LHtrZXk6XCJfdXBkYXRlU3RhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGU9dGhpcyxpPVtdLG89e30sbj1mdW5jdGlvbih0KXtuaChlLmJvZHkubm9kZXMsKGZ1bmN0aW9uKGUpeyEwPT09ZS5pc0NsdXN0ZXImJnQoZSl9KSl9O2Zvcih0IGluIHRoaXMuY2x1c3RlcmVkTm9kZXMpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNsdXN0ZXJlZE5vZGVzLHQpKXZvaWQgMD09PXRoaXMuYm9keS5ub2Rlc1t0XSYmaS5wdXNoKHQpfW4oKGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8aS5sZW5ndGg7ZSsrKWRlbGV0ZSB0LmNvbnRhaW5lZE5vZGVzW2lbZV1dfSkpO2Zvcih2YXIgcj0wO3I8aS5sZW5ndGg7cisrKWRlbGV0ZSB0aGlzLmNsdXN0ZXJlZE5vZGVzW2lbcl1dO25oKHRoaXMuY2x1c3RlcmVkRWRnZXMsKGZ1bmN0aW9uKHQpe3ZhciBpPWUuYm9keS5lZGdlc1t0XTt2b2lkIDAhPT1pJiZpLmVuZFBvaW50c1ZhbGlkKCl8fChvW3RdPXQpfSkpLG4oKGZ1bmN0aW9uKHQpe25oKHQuY29udGFpbmVkRWRnZXMsKGZ1bmN0aW9uKHQsZSl7dC5lbmRQb2ludHNWYWxpZCgpfHxvW2VdfHwob1tlXT1lKX0pKX0pKSxuaCh0aGlzLmJvZHkuZWRnZXMsKGZ1bmN0aW9uKHQsaSl7dmFyIG49ITAscj10LmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzO2lmKHZvaWQgMCE9PXIpe3ZhciBzPTA7bmgociwoZnVuY3Rpb24odCl7dmFyIGk9ZS5ib2R5LmVkZ2VzW3RdO3ZvaWQgMCE9PWkmJmkuZW5kUG9pbnRzVmFsaWQoKSYmKHMrPTEpfSkpLG49cz4wfXQuZW5kUG9pbnRzVmFsaWQoKSYmbnx8KG9baV09aSl9KSksbigoZnVuY3Rpb24odCl7bmgobywoZnVuY3Rpb24oaSl7ZGVsZXRlIHQuY29udGFpbmVkRWRnZXNbaV0sbmgodC5lZGdlcywoZnVuY3Rpb24obixyKXtuLmlkIT09aT9uLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzPWUuX2ZpbHRlcihuLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLChmdW5jdGlvbih0KXtyZXR1cm4hb1t0XX0pKTp0LmVkZ2VzW3JdPW51bGx9KSksdC5lZGdlcz1lLl9maWx0ZXIodC5lZGdlcywoZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10fSkpfSkpfSkpLG5oKG8sKGZ1bmN0aW9uKHQpe2RlbGV0ZSBlLmNsdXN0ZXJlZEVkZ2VzW3RdfSkpLG5oKG8sKGZ1bmN0aW9uKHQpe2RlbGV0ZSBlLmJvZHkuZWRnZXNbdF19KSksbmgoeG4odGhpcy5ib2R5LmVkZ2VzKSwoZnVuY3Rpb24odCl7dmFyIGk9ZS5ib2R5LmVkZ2VzW3RdLG89ZS5faXNDbHVzdGVyZWROb2RlKGkuZnJvbUlkKXx8ZS5faXNDbHVzdGVyZWROb2RlKGkudG9JZCk7aWYobyE9PWUuX2lzQ2x1c3RlcmVkRWRnZShpLmlkKSlpZihvKXt2YXIgbj1lLl9nZXRDbHVzdGVyTm9kZUZvck5vZGUoaS5mcm9tSWQpO3ZvaWQgMCE9PW4mJmUuX2NsdXN0ZXJFZGdlcyhlLmJvZHkubm9kZXNbaS5mcm9tSWRdLGksbik7dmFyIHI9ZS5fZ2V0Q2x1c3Rlck5vZGVGb3JOb2RlKGkudG9JZCk7dm9pZCAwIT09ciYmZS5fY2x1c3RlckVkZ2VzKGUuYm9keS5ub2Rlc1tpLnRvSWRdLGkscil9ZWxzZSBkZWxldGUgZS5fY2x1c3RlckVkZ2VzW3RdLGUuX3Jlc3RvcmVFZGdlKGkpfSkpO2Zvcih2YXIgcz0hMSxhPSEwLGg9ZnVuY3Rpb24oKXt2YXIgdD1bXTtuKChmdW5jdGlvbihlKXt2YXIgaT14bihlLmNvbnRhaW5lZE5vZGVzKS5sZW5ndGgsbz0hMD09PWUub3B0aW9ucy5hbGxvd1NpbmdsZU5vZGVDbHVzdGVyOyhvJiZpPDF8fCFvJiZpPDIpJiZ0LnB1c2goZS5pZCl9KSk7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDsrK2kpZS5vcGVuQ2x1c3Rlcih0W2ldLHt9LCExKTthPXQubGVuZ3RoPjAscz1zfHxhfTthOyloKCk7cyYmdGhpcy5fdXBkYXRlU3RhdGUoKX19LHtrZXk6XCJfaXNDbHVzdGVyZWROb2RlXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuY2x1c3RlcmVkTm9kZXNbdF19fSx7a2V5OlwiX2lzQ2x1c3RlcmVkRWRnZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10aGlzLmNsdXN0ZXJlZEVkZ2VzW3RdfX1dKSx0fSgpO2Z1bmN0aW9uIEV1KHQsZSl7dmFyIGk7aWYodm9pZCAwPT09Y258fG51bGw9PUNpKHQpKXtpZihnbih0KXx8KGk9ZnVuY3Rpb24odCxlKXt2YXIgaTtpZighdClyZXR1cm47aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIE91KHQsZSk7dmFyIG89dm4oaT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpLmNhbGwoaSw4LC0xKTtcIk9iamVjdFwiPT09byYmdC5jb25zdHJ1Y3RvciYmKG89dC5jb25zdHJ1Y3Rvci5uYW1lKTtpZihcIk1hcFwiPT09b3x8XCJTZXRcIj09PW8pcmV0dXJuIG1pKHQpO2lmKFwiQXJndW1lbnRzXCI9PT1vfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChvKSlyZXR1cm4gT3UodCxlKX0odCkpfHxlJiZ0JiZcIm51bWJlclwiPT10eXBlb2YgdC5sZW5ndGgpe2kmJih0PWkpO3ZhciBvPTAsbj1mdW5jdGlvbigpe307cmV0dXJue3M6bixuOmZ1bmN0aW9uKCl7cmV0dXJuIG8+PXQubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTp0W28rK119fSxlOmZ1bmN0aW9uKHQpe3Rocm93IHR9LGY6bn19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXZhciByLHM9ITAsYT0hMTtyZXR1cm57czpmdW5jdGlvbigpe2k9U2kodCl9LG46ZnVuY3Rpb24oKXt2YXIgdD1pLm5leHQoKTtyZXR1cm4gcz10LmRvbmUsdH0sZTpmdW5jdGlvbih0KXthPSEwLHI9dH0sZjpmdW5jdGlvbigpe3RyeXtzfHxudWxsPT1pLnJldHVybnx8aS5yZXR1cm4oKX1maW5hbGx5e2lmKGEpdGhyb3cgcn19fX1mdW5jdGlvbiBPdSh0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgaT0wLG89bmV3IEFycmF5KGUpO2k8ZTtpKyspb1tpXT10W2ldO3JldHVybiBvfXZhciBDdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpKXt2YXIgbztQbyh0aGlzLHQpLHZvaWQgMCE9PXdpbmRvdyYmKG89d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSx3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lPXZvaWQgMD09PW8/ZnVuY3Rpb24odCl7dCgpfTpvLHRoaXMuYm9keT1lLHRoaXMuY2FudmFzPWksdGhpcy5yZWRyYXdSZXF1ZXN0ZWQ9ITEsdGhpcy5yZW5kZXJUaW1lcj12b2lkIDAsdGhpcy5yZXF1aXJlc1RpbWVvdXQ9ITAsdGhpcy5yZW5kZXJpbmdBY3RpdmU9ITEsdGhpcy5yZW5kZXJSZXF1ZXN0cz0wLHRoaXMuYWxsb3dSZWRyYXc9ITAsdGhpcy5kcmFnZ2luZz0hMSx0aGlzLnpvb21pbmc9ITEsdGhpcy5vcHRpb25zPXt9LHRoaXMuZGVmYXVsdE9wdGlvbnM9e2hpZGVFZGdlc09uRHJhZzohMSxoaWRlRWRnZXNPblpvb206ITEsaGlkZU5vZGVzT25EcmFnOiExfSxjdCh0aGlzLm9wdGlvbnMsdGhpcy5kZWZhdWx0T3B0aW9ucyksdGhpcy5fZGV0ZXJtaW5lQnJvd3Nlck1ldGhvZCgpLHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCl9cmV0dXJuIElvKHQsW3trZXk6XCJiaW5kRXZlbnRMaXN0ZW5lcnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGU9dGhpczt0aGlzLmJvZHkuZW1pdHRlci5vbihcImRyYWdTdGFydFwiLChmdW5jdGlvbigpe2UuZHJhZ2dpbmc9ITB9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkcmFnRW5kXCIsKGZ1bmN0aW9uKCl7ZS5kcmFnZ2luZz0hMX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcInpvb21cIiwoZnVuY3Rpb24oKXtlLnpvb21pbmc9ITAsd2luZG93LmNsZWFyVGltZW91dChlLnpvb21UaW1lb3V0SWQpLGUuem9vbVRpbWVvdXRJZD1xcigoZnVuY3Rpb24oKXt2YXIgdDtlLnpvb21pbmc9ITEsYnQodD1lLl9yZXF1ZXN0UmVkcmF3KS5jYWxsKHQsZSkoKX0pLDI1MCl9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVzaXplTm9kZXNcIiwoZnVuY3Rpb24oKXtlLl9yZXNpemVOb2RlcygpfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3JlZHJhd1wiLChmdW5jdGlvbigpeyExPT09ZS5yZW5kZXJpbmdBY3RpdmUmJmUuX3JlZHJhdygpfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2Jsb2NrUmVkcmF3XCIsKGZ1bmN0aW9uKCl7ZS5hbGxvd1JlZHJhdz0hMX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9hbGxvd1JlZHJhd1wiLChmdW5jdGlvbigpe2UuYWxsb3dSZWRyYXc9ITAsZS5yZWRyYXdSZXF1ZXN0ZWQ9ITF9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVxdWVzdFJlZHJhd1wiLGJ0KHQ9dGhpcy5fcmVxdWVzdFJlZHJhdykuY2FsbCh0LHRoaXMpKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9zdGFydFJlbmRlcmluZ1wiLChmdW5jdGlvbigpe2UucmVuZGVyUmVxdWVzdHMrPTEsZS5yZW5kZXJpbmdBY3RpdmU9ITAsZS5fc3RhcnRSZW5kZXJpbmcoKX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9zdG9wUmVuZGVyaW5nXCIsKGZ1bmN0aW9uKCl7ZS5yZW5kZXJSZXF1ZXN0cy09MSxlLnJlbmRlcmluZ0FjdGl2ZT1lLnJlbmRlclJlcXVlc3RzPjAsZS5yZW5kZXJUaW1lcj12b2lkIDB9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsKGZ1bmN0aW9uKCl7ZS5yZW5kZXJSZXF1ZXN0cz0wLGUuYWxsb3dSZWRyYXc9ITEsZS5yZW5kZXJpbmdBY3RpdmU9ITEsITA9PT1lLnJlcXVpcmVzVGltZW91dD9jbGVhclRpbWVvdXQoZS5yZW5kZXJUaW1lcik6d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGUucmVuZGVyVGltZXIpLGUuYm9keS5lbWl0dGVyLm9mZigpfSkpfX0se2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih2b2lkIDAhPT10KXtaYShbXCJoaWRlRWRnZXNPbkRyYWdcIixcImhpZGVFZGdlc09uWm9vbVwiLFwiaGlkZU5vZGVzT25EcmFnXCJdLHRoaXMub3B0aW9ucyx0KX19fSx7a2V5OlwiX3JlcXVlc3ROZXh0RnJhbWVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cpe3ZhciBpLG89d2luZG93O3JldHVybiEwPT09dGhpcy5yZXF1aXJlc1RpbWVvdXQ/aT1xcih0LGUpOm8ucmVxdWVzdEFuaW1hdGlvbkZyYW1lJiYoaT1vLnJlcXVlc3RBbmltYXRpb25GcmFtZSh0KSksaX19fSx7a2V5OlwiX3N0YXJ0UmVuZGVyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdDshMD09PXRoaXMucmVuZGVyaW5nQWN0aXZlJiYodm9pZCAwPT09dGhpcy5yZW5kZXJUaW1lciYmKHRoaXMucmVuZGVyVGltZXI9dGhpcy5fcmVxdWVzdE5leHRGcmFtZShidCh0PXRoaXMuX3JlbmRlclN0ZXApLmNhbGwodCx0aGlzKSx0aGlzLnNpbXVsYXRpb25JbnRlcnZhbCkpKX19LHtrZXk6XCJfcmVuZGVyU3RlcFwiLHZhbHVlOmZ1bmN0aW9uKCl7ITA9PT10aGlzLnJlbmRlcmluZ0FjdGl2ZSYmKHRoaXMucmVuZGVyVGltZXI9dm9pZCAwLCEwPT09dGhpcy5yZXF1aXJlc1RpbWVvdXQmJnRoaXMuX3N0YXJ0UmVuZGVyaW5nKCksdGhpcy5fcmVkcmF3KCksITE9PT10aGlzLnJlcXVpcmVzVGltZW91dCYmdGhpcy5fc3RhcnRSZW5kZXJpbmcoKSl9fSx7a2V5OlwicmVkcmF3XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic2V0U2l6ZVwiKSx0aGlzLl9yZWRyYXcoKX19LHtrZXk6XCJfcmVxdWVzdFJlZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczshMCE9PXRoaXMucmVkcmF3UmVxdWVzdGVkJiYhMT09PXRoaXMucmVuZGVyaW5nQWN0aXZlJiYhMD09PXRoaXMuYWxsb3dSZWRyYXcmJih0aGlzLnJlZHJhd1JlcXVlc3RlZD0hMCx0aGlzLl9yZXF1ZXN0TmV4dEZyYW1lKChmdW5jdGlvbigpe3QuX3JlZHJhdyghMSl9KSwwKSl9fSx7a2V5OlwiX3JlZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXTtpZighMD09PXRoaXMuYWxsb3dSZWRyYXcpe3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJpbml0UmVkcmF3XCIpLHRoaXMucmVkcmF3UmVxdWVzdGVkPSExO3ZhciBlPXtkcmF3RXh0ZXJuYWxMYWJlbHM6bnVsbH07MCE9PXRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy53aWR0aCYmMCE9PXRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5oZWlnaHR8fHRoaXMuY2FudmFzLnNldFNpemUoKSx0aGlzLmNhbnZhcy5zZXRUcmFuc2Zvcm0oKTt2YXIgaT10aGlzLmNhbnZhcy5nZXRDb250ZXh0KCksbz10aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsbj10aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0O2lmKGkuY2xlYXJSZWN0KDAsMCxvLG4pLDA9PT10aGlzLmNhbnZhcy5mcmFtZS5jbGllbnRXaWR0aClyZXR1cm47aWYoaS5zYXZlKCksaS50cmFuc2xhdGUodGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCx0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KSxpLnNjYWxlKHRoaXMuYm9keS52aWV3LnNjYWxlLHRoaXMuYm9keS52aWV3LnNjYWxlKSxpLmJlZ2luUGF0aCgpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJiZWZvcmVEcmF3aW5nXCIsaSksaS5jbG9zZVBhdGgoKSwhMT09PXQmJighMT09PXRoaXMuZHJhZ2dpbmd8fCEwPT09dGhpcy5kcmFnZ2luZyYmITE9PT10aGlzLm9wdGlvbnMuaGlkZUVkZ2VzT25EcmFnKSYmKCExPT09dGhpcy56b29taW5nfHwhMD09PXRoaXMuem9vbWluZyYmITE9PT10aGlzLm9wdGlvbnMuaGlkZUVkZ2VzT25ab29tKSYmdGhpcy5fZHJhd0VkZ2VzKGkpLCExPT09dGhpcy5kcmFnZ2luZ3x8ITA9PT10aGlzLmRyYWdnaW5nJiYhMT09PXRoaXMub3B0aW9ucy5oaWRlTm9kZXNPbkRyYWcpe3ZhciByPXRoaXMuX2RyYXdOb2RlcyhpLHQpLHM9ci5kcmF3RXh0ZXJuYWxMYWJlbHM7ZS5kcmF3RXh0ZXJuYWxMYWJlbHM9c30hMT09PXQmJighMT09PXRoaXMuZHJhZ2dpbmd8fCEwPT09dGhpcy5kcmFnZ2luZyYmITE9PT10aGlzLm9wdGlvbnMuaGlkZUVkZ2VzT25EcmFnKSYmKCExPT09dGhpcy56b29taW5nfHwhMD09PXRoaXMuem9vbWluZyYmITE9PT10aGlzLm9wdGlvbnMuaGlkZUVkZ2VzT25ab29tKSYmdGhpcy5fZHJhd0Fycm93cyhpKSxudWxsIT1lLmRyYXdFeHRlcm5hbExhYmVscyYmZS5kcmF3RXh0ZXJuYWxMYWJlbHMoKSwhMT09PXQmJnRoaXMuX2RyYXdTZWxlY3Rpb25Cb3goaSksaS5iZWdpblBhdGgoKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYWZ0ZXJEcmF3aW5nXCIsaSksaS5jbG9zZVBhdGgoKSxpLnJlc3RvcmUoKSwhMD09PXQmJmkuY2xlYXJSZWN0KDAsMCxvLG4pfX19LHtrZXk6XCJfcmVzaXplTm9kZXNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY2FudmFzLnNldFRyYW5zZm9ybSgpO3ZhciB0PXRoaXMuY2FudmFzLmdldENvbnRleHQoKTt0LnNhdmUoKSx0LnRyYW5zbGF0ZSh0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54LHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkpLHQuc2NhbGUodGhpcy5ib2R5LnZpZXcuc2NhbGUsdGhpcy5ib2R5LnZpZXcuc2NhbGUpO3ZhciBlLGk9dGhpcy5ib2R5Lm5vZGVzO2Zvcih2YXIgbyBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLG8pJiYoKGU9aVtvXSkucmVzaXplKHQpLGUudXBkYXRlQm91bmRpbmdCb3godCxlLnNlbGVjdGVkKSk7dC5yZXN0b3JlKCl9fSx7a2V5OlwiX2RyYXdOb2Rlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxpLG89YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXSxuPXRoaXMuYm9keS5ub2RlcyxyPXRoaXMuYm9keS5ub2RlSW5kaWNlcyxzPVtdLGE9W10saD0yMCxkPXRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHt4Oi1oLHk6LWh9KSxsPXRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHt4OnRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCtoLHk6dGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCtofSksYz17dG9wOmQueSxsZWZ0OmQueCxib3R0b206bC55LHJpZ2h0OmwueH0sdT1bXSxmPTA7ZjxyLmxlbmd0aDtmKyspaWYoKGU9bltyW2ZdXSkuaG92ZXIpYS5wdXNoKHJbZl0pO2Vsc2UgaWYoZS5pc1NlbGVjdGVkKCkpcy5wdXNoKHJbZl0pO2Vsc2UgaWYoITA9PT1vKXt2YXIgcD1lLmRyYXcodCk7bnVsbCE9cC5kcmF3RXh0ZXJuYWxMYWJlbCYmdS5wdXNoKHAuZHJhd0V4dGVybmFsTGFiZWwpfWVsc2UgaWYoITA9PT1lLmlzQm91bmRpbmdCb3hPdmVybGFwcGluZ1dpdGgoYykpe3ZhciB2PWUuZHJhdyh0KTtudWxsIT12LmRyYXdFeHRlcm5hbExhYmVsJiZ1LnB1c2godi5kcmF3RXh0ZXJuYWxMYWJlbCl9ZWxzZSBlLnVwZGF0ZUJvdW5kaW5nQm94KHQsZS5zZWxlY3RlZCk7dmFyIGc9cy5sZW5ndGgseT1hLmxlbmd0aDtmb3IoaT0wO2k8ZztpKyspe3ZhciBtPShlPW5bc1tpXV0pLmRyYXcodCk7bnVsbCE9bS5kcmF3RXh0ZXJuYWxMYWJlbCYmdS5wdXNoKG0uZHJhd0V4dGVybmFsTGFiZWwpfWZvcihpPTA7aTx5O2krKyl7dmFyIGI9KGU9blthW2ldXSkuZHJhdyh0KTtudWxsIT1iLmRyYXdFeHRlcm5hbExhYmVsJiZ1LnB1c2goYi5kcmF3RXh0ZXJuYWxMYWJlbCl9cmV0dXJue2RyYXdFeHRlcm5hbExhYmVsczpmdW5jdGlvbigpe3ZhciB0LGU9RXUodSk7dHJ5e2ZvcihlLnMoKTshKHQ9ZS5uKCkpLmRvbmU7KXsoMCx0LnZhbHVlKSgpfX1jYXRjaCh0KXtlLmUodCl9ZmluYWxseXtlLmYoKX19fX19LHtrZXk6XCJfZHJhd0VkZ2VzXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuYm9keS5lZGdlcyxpPXRoaXMuYm9keS5lZGdlSW5kaWNlcyxvPTA7bzxpLmxlbmd0aDtvKyspe3ZhciBuPWVbaVtvXV07ITA9PT1uLmNvbm5lY3RlZCYmbi5kcmF3KHQpfX19LHtrZXk6XCJfZHJhd0Fycm93c1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmJvZHkuZWRnZXMsaT10aGlzLmJvZHkuZWRnZUluZGljZXMsbz0wO288aS5sZW5ndGg7bysrKXt2YXIgbj1lW2lbb11dOyEwPT09bi5jb25uZWN0ZWQmJm4uZHJhd0Fycm93cyh0KX19fSx7a2V5OlwiX2RldGVybWluZUJyb3dzZXJNZXRob2RcIix2YWx1ZTpmdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cpe3ZhciB0PW5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTt0aGlzLnJlcXVpcmVzVGltZW91dD0hMSwoLTEhPU1yKHQpLmNhbGwodCxcIm1zaWUgOS4wXCIpfHwtMSE9TXIodCkuY2FsbCh0LFwic2FmYXJpXCIpJiZNcih0KS5jYWxsKHQsXCJjaHJvbWVcIik8PS0xKSYmKHRoaXMucmVxdWlyZXNUaW1lb3V0PSEwKX1lbHNlIHRoaXMucmVxdWlyZXNUaW1lb3V0PSEwfX0se2tleTpcIl9kcmF3U2VsZWN0aW9uQm94XCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodGhpcy5ib2R5LnNlbGVjdGlvbkJveC5zaG93KXt0LmJlZ2luUGF0aCgpO3ZhciBlPXRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uZW5kLngtdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC54LGk9dGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5lbmQueS10aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0Lnk7dC5yZWN0KHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQueCx0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0LnksZSxpKSx0LmZpbGxTdHlsZT1cInJnYmEoMTUxLCAxOTQsIDI1MiwgMC4yKVwiLHQuZmlsbFJlY3QodGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC54LHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQueSxlLGkpLHQuc3Ryb2tlU3R5bGU9XCJyZ2JhKDE1MSwgMTk0LCAyNTIsIDEpXCIsdC5zdHJva2UoKX1lbHNlIHQuY2xvc2VQYXRoKCl9fV0pLHR9KCksU3U9Ri5zZXRJbnRlcnZhbDtmdW5jdGlvbiBUdSh0LGUpe2UuaW5wdXRIYW5kbGVyPWZ1bmN0aW9uKHQpe3QuaXNGaXJzdCYmZSh0KX0sdC5vbihcImhhbW1lci5pbnB1dFwiLGUuaW5wdXRIYW5kbGVyKX1mdW5jdGlvbiBNdSh0LGUpe3JldHVybiBlLmlucHV0SGFuZGxlcj1mdW5jdGlvbih0KXt0LmlzRmluYWwmJmUodCl9LHQub24oXCJoYW1tZXIuaW5wdXRcIixlLmlucHV0SGFuZGxlcil9dmFyIFB1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXtQbyh0aGlzLHQpLHRoaXMuYm9keT1lLHRoaXMucGl4ZWxSYXRpbz0xLHRoaXMuY2FtZXJhU3RhdGU9e30sdGhpcy5pbml0aWFsaXplZD0hMSx0aGlzLmNhbnZhc1ZpZXdDZW50ZXI9e30sdGhpcy5fY2xlYW51cENhbGxiYWNrcz1bXSx0aGlzLm9wdGlvbnM9e30sdGhpcy5kZWZhdWx0T3B0aW9ucz17YXV0b1Jlc2l6ZTohMCxoZWlnaHQ6XCIxMDAlXCIsd2lkdGg6XCIxMDAlXCJ9LGN0KHRoaXMub3B0aW9ucyx0aGlzLmRlZmF1bHRPcHRpb25zKSx0aGlzLmJpbmRFdmVudExpc3RlbmVycygpfXJldHVybiBJbyh0LFt7a2V5OlwiYmluZEV2ZW50TGlzdGVuZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlPXRoaXM7dGhpcy5ib2R5LmVtaXR0ZXIub25jZShcInJlc2l6ZVwiLChmdW5jdGlvbih0KXswIT09dC53aWR0aCYmKGUuYm9keS52aWV3LnRyYW5zbGF0aW9uLng9LjUqdC53aWR0aCksMCE9PXQuaGVpZ2h0JiYoZS5ib2R5LnZpZXcudHJhbnNsYXRpb24ueT0uNSp0LmhlaWdodCl9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJzZXRTaXplXCIsYnQodD10aGlzLnNldFNpemUpLmNhbGwodCx0aGlzKSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsKGZ1bmN0aW9uKCl7ZS5oYW1tZXJGcmFtZS5kZXN0cm95KCksZS5oYW1tZXIuZGVzdHJveSgpLGUuX2NsZWFuVXAoKX0pKX19LHtrZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGUsaSxvLG4scixzPXRoaXM7aWYodm9pZCAwIT09dCl7WmEoW1wid2lkdGhcIixcImhlaWdodFwiLFwiYXV0b1Jlc2l6ZVwiXSx0aGlzLm9wdGlvbnMsdCl9aWYodGhpcy5fY2xlYW5VcCgpLCEwPT09dGhpcy5vcHRpb25zLmF1dG9SZXNpemUpe3ZhciBhO2lmKHdpbmRvdy5SZXNpemVPYnNlcnZlcil7dmFyIGg9bmV3IFJlc2l6ZU9ic2VydmVyKChmdW5jdGlvbigpeyEwPT09cy5zZXRTaXplKCkmJnMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKX0pKSxkPXRoaXMuZnJhbWU7aC5vYnNlcnZlKGQpLHRoaXMuX2NsZWFudXBDYWxsYmFja3MucHVzaCgoZnVuY3Rpb24oKXtoLnVub2JzZXJ2ZShkKX0pKX1lbHNle3ZhciBsPVN1KChmdW5jdGlvbigpeyEwPT09cy5zZXRTaXplKCkmJnMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKX0pLDFlMyk7dGhpcy5fY2xlYW51cENhbGxiYWNrcy5wdXNoKChmdW5jdGlvbigpe2NsZWFySW50ZXJ2YWwobCl9KSl9dmFyIGM9YnQoYT10aGlzLl9vblJlc2l6ZSkuY2FsbChhLHRoaXMpO2U9d2luZG93LGk9XCJyZXNpemVcIixvPWMsZS5hZGRFdmVudExpc3RlbmVyPyh2b2lkIDA9PT1uJiYobj0hMSksXCJtb3VzZXdoZWVsXCI9PT1pJiZKbihyPW5hdmlnYXRvci51c2VyQWdlbnQpLmNhbGwocixcIkZpcmVmb3hcIikmJihpPVwiRE9NTW91c2VTY3JvbGxcIiksZS5hZGRFdmVudExpc3RlbmVyKGksbyxuKSk6ZS5hdHRhY2hFdmVudChcIm9uXCIraSxvKSx0aGlzLl9jbGVhbnVwQ2FsbGJhY2tzLnB1c2goKGZ1bmN0aW9uKCl7IWZ1bmN0aW9uKHQsZSxpLG8pe3ZhciBuO3QucmVtb3ZlRXZlbnRMaXN0ZW5lcj8odm9pZCAwPT09byYmKG89ITEpLFwibW91c2V3aGVlbFwiPT09ZSYmSm4obj1uYXZpZ2F0b3IudXNlckFnZW50KS5jYWxsKG4sXCJGaXJlZm94XCIpJiYoZT1cIkRPTU1vdXNlU2Nyb2xsXCIpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLGksbykpOnQuZGV0YWNoRXZlbnQoXCJvblwiK2UsaSl9KHdpbmRvdyxcInJlc2l6ZVwiLGMpfSkpfX19LHtrZXk6XCJfY2xlYW5VcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZSxpO0RuKHQ9Tm4oZT1xbihpPXRoaXMuX2NsZWFudXBDYWxsYmFja3MpLmNhbGwoaSwwKSkuY2FsbChlKSkuY2FsbCh0LChmdW5jdGlvbih0KXt0cnl7dCgpfWNhdGNoKHQpe2NvbnNvbGUuZXJyb3IodCl9fSkpfX0se2tleTpcIl9vblJlc2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zZXRTaXplKCksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIil9fSx7a2V5OlwiX2dldENhbWVyYVN0YXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06dGhpcy5waXhlbFJhdGlvOyEwPT09dGhpcy5pbml0aWFsaXplZCYmKHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNXaWR0aD10aGlzLmZyYW1lLmNhbnZhcy53aWR0aC90LHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNIZWlnaHQ9dGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0L3QsdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZT10aGlzLmJvZHkudmlldy5zY2FsZSx0aGlzLmNhbWVyYVN0YXRlLnBvc2l0aW9uPXRoaXMuRE9NdG9DYW52YXMoe3g6LjUqdGhpcy5mcmFtZS5jYW52YXMud2lkdGgvdCx5Oi41KnRoaXMuZnJhbWUuY2FudmFzLmhlaWdodC90fSkpfX0se2tleTpcIl9zZXRDYW1lcmFTdGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodm9pZCAwIT09dGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSYmMCE9PXRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoJiYwIT09dGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0JiYwIT09dGhpcy5waXhlbFJhdGlvJiZ0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzV2lkdGg+MCYmdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c0hlaWdodD4wKXt2YXIgdD10aGlzLmZyYW1lLmNhbnZhcy53aWR0aC90aGlzLnBpeGVsUmF0aW8vdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c1dpZHRoLGU9dGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0L3RoaXMucGl4ZWxSYXRpby90aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzSGVpZ2h0LGk9dGhpcy5jYW1lcmFTdGF0ZS5zY2FsZTsxIT10JiYxIT1lP2k9LjUqdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSoodCtlKToxIT10P2k9dGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSp0OjEhPWUmJihpPXRoaXMuY2FtZXJhU3RhdGUuc2NhbGUqZSksdGhpcy5ib2R5LnZpZXcuc2NhbGU9aTt2YXIgbz10aGlzLkRPTXRvQ2FudmFzKHt4Oi41KnRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLHk6LjUqdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0fSksbj17eDpvLngtdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbi54LHk6by55LXRoaXMuY2FtZXJhU3RhdGUucG9zaXRpb24ueX07dGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCs9bi54KnRoaXMuYm9keS52aWV3LnNjYWxlLHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkrPW4ueSp0aGlzLmJvZHkudmlldy5zY2FsZX19fSx7a2V5OlwiX3ByZXBhcmVWYWx1ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXJldHVybiB0K1wicHhcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgdCl7aWYoLTEhPT1Ncih0KS5jYWxsKHQsXCIlXCIpfHwtMSE9PU1yKHQpLmNhbGwodCxcInB4XCIpKXJldHVybiB0O2lmKC0xPT09TXIodCkuY2FsbCh0LFwiJVwiKSlyZXR1cm4gdCtcInB4XCJ9dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHVzZSB0aGUgdmFsdWUgc3VwcGxpZWQgZm9yIHdpZHRoIG9yIGhlaWdodDpcIit0KX19LHtrZXk6XCJfY3JlYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IoO3RoaXMuYm9keS5jb250YWluZXIuaGFzQ2hpbGROb2RlcygpOyl0aGlzLmJvZHkuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuYm9keS5jb250YWluZXIuZmlyc3RDaGlsZCk7aWYodGhpcy5mcmFtZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuZnJhbWUuY2xhc3NOYW1lPVwidmlzLW5ldHdvcmtcIix0aGlzLmZyYW1lLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIix0aGlzLmZyYW1lLnN0eWxlLm92ZXJmbG93PVwiaGlkZGVuXCIsdGhpcy5mcmFtZS50YWJJbmRleD0wLHRoaXMuZnJhbWUuY2FudmFzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksdGhpcy5mcmFtZS5jYW52YXMuc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwiLHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZS5jYW52YXMpLHRoaXMuZnJhbWUuY2FudmFzLmdldENvbnRleHQpdGhpcy5fc2V0UGl4ZWxSYXRpbygpLHRoaXMuc2V0VHJhbnNmb3JtKCk7ZWxzZXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO3Quc3R5bGUuY29sb3I9XCJyZWRcIix0LnN0eWxlLmZvbnRXZWlnaHQ9XCJib2xkXCIsdC5zdHlsZS5wYWRkaW5nPVwiMTBweFwiLHQuaW5uZXJUZXh0PVwiRXJyb3I6IHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgY2FudmFzXCIsdGhpcy5mcmFtZS5jYW52YXMuYXBwZW5kQ2hpbGQodCl9dGhpcy5ib2R5LmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKSx0aGlzLmJvZHkudmlldy5zY2FsZT0xLHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uPXt4Oi41KnRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLHk6LjUqdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0fSx0aGlzLl9iaW5kSGFtbWVyKCl9fSx7a2V5OlwiX2JpbmRIYW1tZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dm9pZCAwIT09dGhpcy5oYW1tZXImJnRoaXMuaGFtbWVyLmRlc3Ryb3koKSx0aGlzLmRyYWc9e30sdGhpcy5waW5jaD17fSx0aGlzLmhhbW1lcj1uZXcgU2godGhpcy5mcmFtZS5jYW52YXMpLHRoaXMuaGFtbWVyLmdldChcInBpbmNoXCIpLnNldCh7ZW5hYmxlOiEwfSksdGhpcy5oYW1tZXIuZ2V0KFwicGFuXCIpLnNldCh7dGhyZXNob2xkOjUsZGlyZWN0aW9uOlNoLkRJUkVDVElPTl9BTEx9KSxUdSh0aGlzLmhhbW1lciwoZnVuY3Rpb24oZSl7dC5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVG91Y2goZSl9KSksdGhpcy5oYW1tZXIub24oXCJ0YXBcIiwoZnVuY3Rpb24oZSl7dC5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVGFwKGUpfSkpLHRoaXMuaGFtbWVyLm9uKFwiZG91YmxldGFwXCIsKGZ1bmN0aW9uKGUpe3QuYm9keS5ldmVudExpc3RlbmVycy5vbkRvdWJsZVRhcChlKX0pKSx0aGlzLmhhbW1lci5vbihcInByZXNzXCIsKGZ1bmN0aW9uKGUpe3QuYm9keS5ldmVudExpc3RlbmVycy5vbkhvbGQoZSl9KSksdGhpcy5oYW1tZXIub24oXCJwYW5zdGFydFwiLChmdW5jdGlvbihlKXt0LmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnU3RhcnQoZSl9KSksdGhpcy5oYW1tZXIub24oXCJwYW5tb3ZlXCIsKGZ1bmN0aW9uKGUpe3QuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWcoZSl9KSksdGhpcy5oYW1tZXIub24oXCJwYW5lbmRcIiwoZnVuY3Rpb24oZSl7dC5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ0VuZChlKX0pKSx0aGlzLmhhbW1lci5vbihcInBpbmNoXCIsKGZ1bmN0aW9uKGUpe3QuYm9keS5ldmVudExpc3RlbmVycy5vblBpbmNoKGUpfSkpLHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLChmdW5jdGlvbihlKXt0LmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZVdoZWVsKGUpfSkpLHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwoZnVuY3Rpb24oZSl7dC5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uTW91c2VNb3ZlKGUpfSkpLHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLChmdW5jdGlvbihlKXt0LmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Db250ZXh0KGUpfSkpLHRoaXMuaGFtbWVyRnJhbWU9bmV3IFNoKHRoaXMuZnJhbWUpLE11KHRoaXMuaGFtbWVyRnJhbWUsKGZ1bmN0aW9uKGUpe3QuYm9keS5ldmVudExpc3RlbmVycy5vblJlbGVhc2UoZSl9KSl9fSx7a2V5Olwic2V0U2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnRoaXMub3B0aW9ucy53aWR0aCxlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLm9wdGlvbnMuaGVpZ2h0O3Q9dGhpcy5fcHJlcGFyZVZhbHVlKHQpLGU9dGhpcy5fcHJlcGFyZVZhbHVlKGUpO3ZhciBpPSExLG89dGhpcy5mcmFtZS5jYW52YXMud2lkdGgsbj10aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQscj10aGlzLnBpeGVsUmF0aW87aWYodGhpcy5fc2V0UGl4ZWxSYXRpbygpLHQhPXRoaXMub3B0aW9ucy53aWR0aHx8ZSE9dGhpcy5vcHRpb25zLmhlaWdodHx8dGhpcy5mcmFtZS5zdHlsZS53aWR0aCE9dHx8dGhpcy5mcmFtZS5zdHlsZS5oZWlnaHQhPWUpdGhpcy5fZ2V0Q2FtZXJhU3RhdGUociksdGhpcy5mcmFtZS5zdHlsZS53aWR0aD10LHRoaXMuZnJhbWUuc3R5bGUuaGVpZ2h0PWUsdGhpcy5mcmFtZS5jYW52YXMuc3R5bGUud2lkdGg9XCIxMDAlXCIsdGhpcy5mcmFtZS5jYW52YXMuc3R5bGUuaGVpZ2h0PVwiMTAwJVwiLHRoaXMuZnJhbWUuY2FudmFzLndpZHRoPU1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgqdGhpcy5waXhlbFJhdGlvKSx0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQ9TWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQqdGhpcy5waXhlbFJhdGlvKSx0aGlzLm9wdGlvbnMud2lkdGg9dCx0aGlzLm9wdGlvbnMuaGVpZ2h0PWUsdGhpcy5jYW52YXNWaWV3Q2VudGVyPXt4Oi41KnRoaXMuZnJhbWUuY2xpZW50V2lkdGgseTouNSp0aGlzLmZyYW1lLmNsaWVudEhlaWdodH0saT0hMDtlbHNle3ZhciBzPU1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgqdGhpcy5waXhlbFJhdGlvKSxhPU1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0KnRoaXMucGl4ZWxSYXRpbyk7dGhpcy5mcmFtZS5jYW52YXMud2lkdGg9PT1zJiZ0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQ9PT1hfHx0aGlzLl9nZXRDYW1lcmFTdGF0ZShyKSx0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCE9PXMmJih0aGlzLmZyYW1lLmNhbnZhcy53aWR0aD1zLGk9ITApLHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCE9PWEmJih0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQ9YSxpPSEwKX1yZXR1cm4hMD09PWkmJih0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVzaXplXCIse3dpZHRoOk1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMud2lkdGgvdGhpcy5waXhlbFJhdGlvKSxoZWlnaHQ6TWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQvdGhpcy5waXhlbFJhdGlvKSxvbGRXaWR0aDpNYXRoLnJvdW5kKG8vdGhpcy5waXhlbFJhdGlvKSxvbGRIZWlnaHQ6TWF0aC5yb3VuZChuL3RoaXMucGl4ZWxSYXRpbyl9KSx0aGlzLl9zZXRDYW1lcmFTdGF0ZSgpKSx0aGlzLmluaXRpYWxpemVkPSEwLGl9fSx7a2V5OlwiZ2V0Q29udGV4dFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZnJhbWUuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKX19LHtrZXk6XCJfZGV0ZXJtaW5lUGl4ZWxSYXRpb1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRDb250ZXh0KCk7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IGNhbnZheCBjb250ZXh0XCIpO3ZhciBlPTE7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmKGU9d2luZG93LmRldmljZVBpeGVsUmF0aW98fDEpLGUvKHQud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvfHx0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvfHwxKX19LHtrZXk6XCJfc2V0UGl4ZWxSYXRpb1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5waXhlbFJhdGlvPXRoaXMuX2RldGVybWluZVBpeGVsUmF0aW8oKX19LHtrZXk6XCJzZXRUcmFuc2Zvcm1cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0Q29udGV4dCgpO2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGdldCBjYW52YXggY29udGV4dFwiKTt0LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sMCwwLHRoaXMucGl4ZWxSYXRpbywwLDApfX0se2tleTpcIl9YY29udmVydERPTXRvQ2FudmFzXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuKHQtdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCkvdGhpcy5ib2R5LnZpZXcuc2NhbGV9fSx7a2V5OlwiX1hjb252ZXJ0Q2FudmFzVG9ET01cIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdCp0aGlzLmJvZHkudmlldy5zY2FsZSt0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54fX0se2tleTpcIl9ZY29udmVydERPTXRvQ2FudmFzXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuKHQtdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSkvdGhpcy5ib2R5LnZpZXcuc2NhbGV9fSx7a2V5OlwiX1ljb252ZXJ0Q2FudmFzVG9ET01cIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdCp0aGlzLmJvZHkudmlldy5zY2FsZSt0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55fX0se2tleTpcImNhbnZhc1RvRE9NXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJue3g6dGhpcy5fWGNvbnZlcnRDYW52YXNUb0RPTSh0LngpLHk6dGhpcy5fWWNvbnZlcnRDYW52YXNUb0RPTSh0LnkpfX19LHtrZXk6XCJET010b0NhbnZhc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybnt4OnRoaXMuX1hjb252ZXJ0RE9NdG9DYW52YXModC54KSx5OnRoaXMuX1ljb252ZXJ0RE9NdG9DYW52YXModC55KX19fV0pLHR9KCk7ZnVuY3Rpb24gRHUodCxlKXt2YXIgaT1jdCh7bm9kZXM6ZSxtaW5ab29tTGV2ZWw6TnVtYmVyLk1JTl9WQUxVRSxtYXhab29tTGV2ZWw6MX0sbnVsbCE9dD90Ont9KTtpZighZ24oaS5ub2RlcykpdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vZGVzIGhhcyB0byBiZSBhbiBhcnJheSBvZiBpZHMuXCIpO2lmKDA9PT1pLm5vZGVzLmxlbmd0aCYmKGkubm9kZXM9ZSksIShcIm51bWJlclwiPT10eXBlb2YgaS5taW5ab29tTGV2ZWwmJmkubWluWm9vbUxldmVsPjApKXRocm93IG5ldyBUeXBlRXJyb3IoXCJNaW4gem9vbSBsZXZlbCBoYXMgdG8gYmUgYSBudW1iZXIgaGlnaGVyIHRoYW4gemVyby5cIik7aWYoIShcIm51bWJlclwiPT10eXBlb2YgaS5tYXhab29tTGV2ZWwmJmkubWluWm9vbUxldmVsPD1pLm1heFpvb21MZXZlbCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1heCB6b29tIGxldmVsIGhhcyB0byBiZSBhIG51bWJlciBoaWdoZXIgdGhhbiBtaW4gem9vbSBsZXZlbC5cIik7cmV0dXJuIGl9dmFyIEJ1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLGkpe3ZhciBvLG4scj10aGlzO1BvKHRoaXMsdCksdGhpcy5ib2R5PWUsdGhpcy5jYW52YXM9aSx0aGlzLmFuaW1hdGlvblNwZWVkPTEvdGhpcy5yZW5kZXJSZWZyZXNoUmF0ZSx0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uPVwiZWFzZUluT3V0UXVpbnRcIix0aGlzLmVhc2luZ1RpbWU9MCx0aGlzLnNvdXJjZVNjYWxlPTAsdGhpcy50YXJnZXRTY2FsZT0wLHRoaXMuc291cmNlVHJhbnNsYXRpb249MCx0aGlzLnRhcmdldFRyYW5zbGF0aW9uPTAsdGhpcy5sb2NrZWRPbk5vZGVJZD12b2lkIDAsdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQ9dm9pZCAwLHRoaXMudG91Y2hUaW1lPTAsdGhpcy52aWV3RnVuY3Rpb249dm9pZCAwLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZml0XCIsYnQobz10aGlzLmZpdCkuY2FsbChvLHRoaXMpKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcImFuaW1hdGlvbkZpbmlzaGVkXCIsKGZ1bmN0aW9uKCl7ci5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdG9wUmVuZGVyaW5nXCIpfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwidW5sb2NrTm9kZVwiLGJ0KG49dGhpcy5yZWxlYXNlTm9kZSkuY2FsbChuLHRoaXMpKX1yZXR1cm4gSW8odCxbe2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTt0aGlzLm9wdGlvbnM9dH19LHtrZXk6XCJmaXRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdO3Q9RHUodCx0aGlzLmJvZHkubm9kZUluZGljZXMpO3ZhciBpLG8sbj10aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgscj10aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0O2lmKDA9PT1ufHwwPT09cilvPTEsaT13dS5nZXRSYW5nZSh0aGlzLmJvZHkubm9kZXMsdC5ub2Rlcyk7ZWxzZSBpZighMD09PWUpe3ZhciBzPTA7Zm9yKHZhciBhIGluIHRoaXMuYm9keS5ub2RlcylpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLGEpKXt2YXIgaD10aGlzLmJvZHkubm9kZXNbYV07ITA9PT1oLnByZWRlZmluZWRQb3NpdGlvbiYmKHMrPTEpfWlmKHM+LjUqdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aClyZXR1cm4gdm9pZCB0aGlzLmZpdCh0LCExKTtpPXd1LmdldFJhbmdlKHRoaXMuYm9keS5ub2Rlcyx0Lm5vZGVzKTt2YXIgZD10aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO289MTIuNjYyLyhkKzcuNDE0NykrLjA5NjQ4MjI7dmFyIGw9TWF0aC5taW4obi82MDAsci82MDApO28qPWx9ZWxzZXt0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2l6ZU5vZGVzXCIpLGk9d3UuZ2V0UmFuZ2UodGhpcy5ib2R5Lm5vZGVzLHQubm9kZXMpO3ZhciBjPTEuMSpNYXRoLmFicyhpLm1heFgtaS5taW5YKSx1PTEuMSpNYXRoLmFicyhpLm1heFktaS5taW5ZKSxmPW4vYyxwPXIvdTtvPWY8PXA/ZjpwfW8+dC5tYXhab29tTGV2ZWw/bz10Lm1heFpvb21MZXZlbDpvPHQubWluWm9vbUxldmVsJiYobz10Lm1pblpvb21MZXZlbCk7dmFyIHY9d3UuZmluZENlbnRlcihpKSxnPXtwb3NpdGlvbjp2LHNjYWxlOm8sYW5pbWF0aW9uOnQuYW5pbWF0aW9ufTt0aGlzLm1vdmVUbyhnKX19LHtrZXk6XCJmb2N1c1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtpZih2b2lkIDAhPT10aGlzLmJvZHkubm9kZXNbdF0pe3ZhciBpPXt4OnRoaXMuYm9keS5ub2Rlc1t0XS54LHk6dGhpcy5ib2R5Lm5vZGVzW3RdLnl9O2UucG9zaXRpb249aSxlLmxvY2tlZE9uTm9kZT10LHRoaXMubW92ZVRvKGUpfWVsc2UgY29uc29sZS5lcnJvcihcIk5vZGU6IFwiK3QrXCIgY2Fubm90IGJlIGZvdW5kLlwiKX19LHtrZXk6XCJtb3ZlVG9cIix2YWx1ZTpmdW5jdGlvbih0KXtpZih2b2lkIDAhPT10KXtpZihudWxsIT10Lm9mZnNldCl7aWYobnVsbCE9dC5vZmZzZXQueCl7aWYodC5vZmZzZXQueD0rdC5vZmZzZXQueCwhQWQodC5vZmZzZXQueCkpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9wdGlvbiBcIm9mZnNldC54XCIgaGFzIHRvIGJlIGEgZmluaXRlIG51bWJlci4nKX1lbHNlIHQub2Zmc2V0Lng9MDtpZihudWxsIT10Lm9mZnNldC55KXtpZih0Lm9mZnNldC55PSt0Lm9mZnNldC55LCFBZCh0Lm9mZnNldC55KSl0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgb3B0aW9uIFwib2Zmc2V0LnlcIiBoYXMgdG8gYmUgYSBmaW5pdGUgbnVtYmVyLicpfWVsc2UgdC5vZmZzZXQueD0wfWVsc2UgdC5vZmZzZXQ9e3g6MCx5OjB9O2lmKG51bGwhPXQucG9zaXRpb24pe2lmKG51bGwhPXQucG9zaXRpb24ueCl7aWYodC5wb3NpdGlvbi54PSt0LnBvc2l0aW9uLngsIUFkKHQucG9zaXRpb24ueCkpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9wdGlvbiBcInBvc2l0aW9uLnhcIiBoYXMgdG8gYmUgYSBmaW5pdGUgbnVtYmVyLicpfWVsc2UgdC5wb3NpdGlvbi54PTA7aWYobnVsbCE9dC5wb3NpdGlvbi55KXtpZih0LnBvc2l0aW9uLnk9K3QucG9zaXRpb24ueSwhQWQodC5wb3NpdGlvbi55KSl0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgb3B0aW9uIFwicG9zaXRpb24ueVwiIGhhcyB0byBiZSBhIGZpbml0ZSBudW1iZXIuJyl9ZWxzZSB0LnBvc2l0aW9uLng9MH1lbHNlIHQucG9zaXRpb249dGhpcy5nZXRWaWV3UG9zaXRpb24oKTtpZihudWxsIT10LnNjYWxlKXtpZih0LnNjYWxlPSt0LnNjYWxlLCEodC5zY2FsZT4wKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgb3B0aW9uIFwic2NhbGVcIiBoYXMgdG8gYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIHplcm8uJyl9ZWxzZSB0LnNjYWxlPXRoaXMuYm9keS52aWV3LnNjYWxlO3ZvaWQgMD09PXQuYW5pbWF0aW9uJiYodC5hbmltYXRpb249e2R1cmF0aW9uOjB9KSwhMT09PXQuYW5pbWF0aW9uJiYodC5hbmltYXRpb249e2R1cmF0aW9uOjB9KSwhMD09PXQuYW5pbWF0aW9uJiYodC5hbmltYXRpb249e30pLHZvaWQgMD09PXQuYW5pbWF0aW9uLmR1cmF0aW9uJiYodC5hbmltYXRpb24uZHVyYXRpb249MWUzKSx2b2lkIDA9PT10LmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbiYmKHQuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uPVwiZWFzZUluT3V0UXVhZFwiKSx0aGlzLmFuaW1hdGVWaWV3KHQpfWVsc2UgdD17fX19LHtrZXk6XCJhbmltYXRlVmlld1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMCE9PXQpe3RoaXMuYW5pbWF0aW9uRWFzaW5nRnVuY3Rpb249dC5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb24sdGhpcy5yZWxlYXNlTm9kZSgpLCEwPT09dC5sb2NrZWQmJih0aGlzLmxvY2tlZE9uTm9kZUlkPXQubG9ja2VkT25Ob2RlLHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0PXQub2Zmc2V0KSwwIT10aGlzLmVhc2luZ1RpbWUmJnRoaXMuX3RyYW5zaXRpb25SZWRyYXcoITApLHRoaXMuc291cmNlU2NhbGU9dGhpcy5ib2R5LnZpZXcuc2NhbGUsdGhpcy5zb3VyY2VUcmFuc2xhdGlvbj10aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbix0aGlzLnRhcmdldFNjYWxlPXQuc2NhbGUsdGhpcy5ib2R5LnZpZXcuc2NhbGU9dGhpcy50YXJnZXRTY2FsZTt2YXIgZSxpLG89dGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe3g6LjUqdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLHk6LjUqdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodH0pLG49by54LXQucG9zaXRpb24ueCxyPW8ueS10LnBvc2l0aW9uLnk7aWYodGhpcy50YXJnZXRUcmFuc2xhdGlvbj17eDp0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLngrbip0aGlzLnRhcmdldFNjYWxlK3Qub2Zmc2V0LngseTp0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkrcip0aGlzLnRhcmdldFNjYWxlK3Qub2Zmc2V0Lnl9LDA9PT10LmFuaW1hdGlvbi5kdXJhdGlvbilpZihudWxsIT10aGlzLmxvY2tlZE9uTm9kZUlkKXRoaXMudmlld0Z1bmN0aW9uPWJ0KGU9dGhpcy5fbG9ja2VkUmVkcmF3KS5jYWxsKGUsdGhpcyksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsdGhpcy52aWV3RnVuY3Rpb24pO2Vsc2UgdGhpcy5ib2R5LnZpZXcuc2NhbGU9dGhpcy50YXJnZXRTY2FsZSx0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbj10aGlzLnRhcmdldFRyYW5zbGF0aW9uLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtlbHNlIHRoaXMuYW5pbWF0aW9uU3BlZWQ9MS8oNjAqdC5hbmltYXRpb24uZHVyYXRpb24qLjAwMSl8fDEvNjAsdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbj10LmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbix0aGlzLnZpZXdGdW5jdGlvbj1idChpPXRoaXMuX3RyYW5zaXRpb25SZWRyYXcpLmNhbGwoaSx0aGlzKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIix0aGlzLnZpZXdGdW5jdGlvbiksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdGFydFJlbmRlcmluZ1wiKX19fSx7a2V5OlwiX2xvY2tlZFJlZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5ib2R5Lm5vZGVzW3RoaXMubG9ja2VkT25Ob2RlSWRdLngsZT10aGlzLmJvZHkubm9kZXNbdGhpcy5sb2NrZWRPbk5vZGVJZF0ueSxpPXRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHt4Oi41KnRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCx5Oi41KnRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHR9KSxvPWkueC10LG49aS55LWUscj10aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbixzPXt4OnIueCtvKnRoaXMuYm9keS52aWV3LnNjYWxlK3RoaXMubG9ja2VkT25Ob2RlT2Zmc2V0LngseTpyLnkrbip0aGlzLmJvZHkudmlldy5zY2FsZSt0aGlzLmxvY2tlZE9uTm9kZU9mZnNldC55fTt0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbj1zfX0se2tleTpcInJlbGVhc2VOb2RlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2b2lkIDAhPT10aGlzLmxvY2tlZE9uTm9kZUlkJiZ2b2lkIDAhPT10aGlzLnZpZXdGdW5jdGlvbiYmKHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIix0aGlzLnZpZXdGdW5jdGlvbiksdGhpcy5sb2NrZWRPbk5vZGVJZD12b2lkIDAsdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQ9dm9pZCAwKX19LHtrZXk6XCJfdHJhbnNpdGlvblJlZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXTt0aGlzLmVhc2luZ1RpbWUrPXRoaXMuYW5pbWF0aW9uU3BlZWQsdGhpcy5lYXNpbmdUaW1lPSEwPT09dD8xOnRoaXMuZWFzaW5nVGltZTt2YXIgZT15aFt0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uXSh0aGlzLmVhc2luZ1RpbWUpO2lmKHRoaXMuYm9keS52aWV3LnNjYWxlPXRoaXMuc291cmNlU2NhbGUrKHRoaXMudGFyZ2V0U2NhbGUtdGhpcy5zb3VyY2VTY2FsZSkqZSx0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbj17eDp0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLngrKHRoaXMudGFyZ2V0VHJhbnNsYXRpb24ueC10aGlzLnNvdXJjZVRyYW5zbGF0aW9uLngpKmUseTp0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkrKHRoaXMudGFyZ2V0VHJhbnNsYXRpb24ueS10aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkpKmV9LHRoaXMuZWFzaW5nVGltZT49MSl7dmFyIGk7aWYodGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLHRoaXMudmlld0Z1bmN0aW9uKSx0aGlzLmVhc2luZ1RpbWU9MCxudWxsIT10aGlzLmxvY2tlZE9uTm9kZUlkKXRoaXMudmlld0Z1bmN0aW9uPWJ0KGk9dGhpcy5fbG9ja2VkUmVkcmF3KS5jYWxsKGksdGhpcyksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsdGhpcy52aWV3RnVuY3Rpb24pO3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJhbmltYXRpb25GaW5pc2hlZFwiKX19fSx7a2V5OlwiZ2V0U2NhbGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJvZHkudmlldy5zY2FsZX19LHtrZXk6XCJnZXRWaWV3UG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7eDouNSp0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgseTouNSp0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0fSl9fV0pLHR9KCk7ZnVuY3Rpb24gSXUodCl7dmFyIGUsaT10JiZ0LnByZXZlbnREZWZhdWx0fHwhMSxvPXQmJnQuY29udGFpbmVyfHx3aW5kb3csbj17fSxyPXtrZXlkb3duOnt9LGtleXVwOnt9fSxzPXt9O2ZvcihlPTk3O2U8PTEyMjtlKyspc1tTdHJpbmcuZnJvbUNoYXJDb2RlKGUpXT17Y29kZTplLTk3KzY1LHNoaWZ0OiExfTtmb3IoZT02NTtlPD05MDtlKyspc1tTdHJpbmcuZnJvbUNoYXJDb2RlKGUpXT17Y29kZTplLHNoaWZ0OiEwfTtmb3IoZT0wO2U8PTk7ZSsrKXNbXCJcIitlXT17Y29kZTo0OCtlLHNoaWZ0OiExfTtmb3IoZT0xO2U8PTEyO2UrKylzW1wiRlwiK2VdPXtjb2RlOjExMStlLHNoaWZ0OiExfTtmb3IoZT0wO2U8PTk7ZSsrKXNbXCJudW1cIitlXT17Y29kZTo5NitlLHNoaWZ0OiExfTtzW1wibnVtKlwiXT17Y29kZToxMDYsc2hpZnQ6ITF9LHNbXCJudW0rXCJdPXtjb2RlOjEwNyxzaGlmdDohMX0sc1tcIm51bS1cIl09e2NvZGU6MTA5LHNoaWZ0OiExfSxzW1wibnVtL1wiXT17Y29kZToxMTEsc2hpZnQ6ITF9LHNbXCJudW0uXCJdPXtjb2RlOjExMCxzaGlmdDohMX0scy5sZWZ0PXtjb2RlOjM3LHNoaWZ0OiExfSxzLnVwPXtjb2RlOjM4LHNoaWZ0OiExfSxzLnJpZ2h0PXtjb2RlOjM5LHNoaWZ0OiExfSxzLmRvd249e2NvZGU6NDAsc2hpZnQ6ITF9LHMuc3BhY2U9e2NvZGU6MzIsc2hpZnQ6ITF9LHMuZW50ZXI9e2NvZGU6MTMsc2hpZnQ6ITF9LHMuc2hpZnQ9e2NvZGU6MTYsc2hpZnQ6dm9pZCAwfSxzLmVzYz17Y29kZToyNyxzaGlmdDohMX0scy5iYWNrc3BhY2U9e2NvZGU6OCxzaGlmdDohMX0scy50YWI9e2NvZGU6OSxzaGlmdDohMX0scy5jdHJsPXtjb2RlOjE3LHNoaWZ0OiExfSxzLmFsdD17Y29kZToxOCxzaGlmdDohMX0scy5kZWxldGU9e2NvZGU6NDYsc2hpZnQ6ITF9LHMucGFnZXVwPXtjb2RlOjMzLHNoaWZ0OiExfSxzLnBhZ2Vkb3duPXtjb2RlOjM0LHNoaWZ0OiExfSxzW1wiPVwiXT17Y29kZToxODcsc2hpZnQ6ITF9LHNbXCItXCJdPXtjb2RlOjE4OSxzaGlmdDohMX0sc1tcIl1cIl09e2NvZGU6MjIxLHNoaWZ0OiExfSxzW1wiW1wiXT17Y29kZToyMTksc2hpZnQ6ITF9O3ZhciBhPWZ1bmN0aW9uKHQpe2QodCxcImtleWRvd25cIil9LGg9ZnVuY3Rpb24odCl7ZCh0LFwia2V5dXBcIil9LGQ9ZnVuY3Rpb24odCxlKXtpZih2b2lkIDAhPT1yW2VdW3Qua2V5Q29kZV0pe2Zvcih2YXIgbz1yW2VdW3Qua2V5Q29kZV0sbj0wO248by5sZW5ndGg7bisrKSh2b2lkIDA9PT1vW25dLnNoaWZ0fHwxPT1vW25dLnNoaWZ0JiYxPT10LnNoaWZ0S2V5fHwwPT1vW25dLnNoaWZ0JiYwPT10LnNoaWZ0S2V5KSYmb1tuXS5mbih0KTsxPT1pJiZ0LnByZXZlbnREZWZhdWx0KCl9fTtyZXR1cm4gbi5iaW5kPWZ1bmN0aW9uKHQsZSxpKXtpZih2b2lkIDA9PT1pJiYoaT1cImtleWRvd25cIiksdm9pZCAwPT09c1t0XSl0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXk6IFwiK3QpO3ZvaWQgMD09PXJbaV1bc1t0XS5jb2RlXSYmKHJbaV1bc1t0XS5jb2RlXT1bXSkscltpXVtzW3RdLmNvZGVdLnB1c2goe2ZuOmUsc2hpZnQ6c1t0XS5zaGlmdH0pfSxuLmJpbmRBbGw9ZnVuY3Rpb24odCxlKXtmb3IodmFyIGkgaW4gdm9pZCAwPT09ZSYmKGU9XCJrZXlkb3duXCIpLHMpcy5oYXNPd25Qcm9wZXJ0eShpKSYmbi5iaW5kKGksdCxlKX0sbi5nZXRLZXk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIHMpaWYocy5oYXNPd25Qcm9wZXJ0eShlKSl7aWYoMT09dC5zaGlmdEtleSYmMT09c1tlXS5zaGlmdCYmdC5rZXlDb2RlPT1zW2VdLmNvZGUpcmV0dXJuIGU7aWYoMD09dC5zaGlmdEtleSYmMD09c1tlXS5zaGlmdCYmdC5rZXlDb2RlPT1zW2VdLmNvZGUpcmV0dXJuIGU7aWYodC5rZXlDb2RlPT1zW2VdLmNvZGUmJlwic2hpZnRcIj09ZSlyZXR1cm4gZX1yZXR1cm5cInVua25vd24ga2V5LCBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwifSxuLnVuYmluZD1mdW5jdGlvbih0LGUsaSl7aWYodm9pZCAwPT09aSYmKGk9XCJrZXlkb3duXCIpLHZvaWQgMD09PXNbdF0pdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQga2V5OiBcIit0KTtpZih2b2lkIDAhPT1lKXt2YXIgbz1bXSxuPXJbaV1bc1t0XS5jb2RlXTtpZih2b2lkIDAhPT1uKWZvcih2YXIgYT0wO2E8bi5sZW5ndGg7YSsrKW5bYV0uZm49PWUmJm5bYV0uc2hpZnQ9PXNbdF0uc2hpZnR8fG8ucHVzaChyW2ldW3NbdF0uY29kZV1bYV0pO3JbaV1bc1t0XS5jb2RlXT1vfWVsc2UgcltpXVtzW3RdLmNvZGVdPVtdfSxuLnJlc2V0PWZ1bmN0aW9uKCl7cj17a2V5ZG93bjp7fSxrZXl1cDp7fX19LG4uZGVzdHJveT1mdW5jdGlvbigpe3I9e2tleWRvd246e30sa2V5dXA6e319LG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIixhLCEwKSxvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLGgsITApfSxvLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsYSwhMCksby5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIixoLCEwKSxufXZhciB6dT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpKXt2YXIgbz10aGlzO1BvKHRoaXMsdCksdGhpcy5ib2R5PWUsdGhpcy5jYW52YXM9aSx0aGlzLmljb25zQ3JlYXRlZD0hMSx0aGlzLm5hdmlnYXRpb25IYW1tZXJzPVtdLHRoaXMuYm91bmRGdW5jdGlvbnM9e30sdGhpcy50b3VjaFRpbWU9MCx0aGlzLmFjdGl2YXRlZD0hMSx0aGlzLmJvZHkuZW1pdHRlci5vbihcImFjdGl2YXRlXCIsKGZ1bmN0aW9uKCl7by5hY3RpdmF0ZWQ9ITAsby5jb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCl9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZWFjdGl2YXRlXCIsKGZ1bmN0aW9uKCl7by5hY3RpdmF0ZWQ9ITEsby5jb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCl9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsKGZ1bmN0aW9uKCl7dm9pZCAwIT09by5rZXljaGFybSYmby5rZXljaGFybS5kZXN0cm95KCl9KSksdGhpcy5vcHRpb25zPXt9fXJldHVybiBJbyh0LFt7a2V5Olwic2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZvaWQgMCE9PXQmJih0aGlzLm9wdGlvbnM9dCx0aGlzLmNyZWF0ZSgpKX19LHtrZXk6XCJjcmVhdGVcIix2YWx1ZTpmdW5jdGlvbigpeyEwPT09dGhpcy5vcHRpb25zLm5hdmlnYXRpb25CdXR0b25zPyExPT09dGhpcy5pY29uc0NyZWF0ZWQmJnRoaXMubG9hZE5hdmlnYXRpb25FbGVtZW50cygpOiEwPT09dGhpcy5pY29uc0NyZWF0ZWQmJnRoaXMuY2xlYW5OYXZpZ2F0aW9uKCksdGhpcy5jb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCl9fSx7a2V5OlwiY2xlYW5OYXZpZ2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZigwIT10aGlzLm5hdmlnYXRpb25IYW1tZXJzLmxlbmd0aCl7Zm9yKHZhciB0PTA7dDx0aGlzLm5hdmlnYXRpb25IYW1tZXJzLmxlbmd0aDt0KyspdGhpcy5uYXZpZ2F0aW9uSGFtbWVyc1t0XS5kZXN0cm95KCk7dGhpcy5uYXZpZ2F0aW9uSGFtbWVycz1bXX10aGlzLm5hdmlnYXRpb25ET00mJnRoaXMubmF2aWdhdGlvbkRPTS53cmFwcGVyJiZ0aGlzLm5hdmlnYXRpb25ET00ud3JhcHBlci5wYXJlbnROb2RlJiZ0aGlzLm5hdmlnYXRpb25ET00ud3JhcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubmF2aWdhdGlvbkRPTS53cmFwcGVyKSx0aGlzLmljb25zQ3JlYXRlZD0hMX19LHtrZXk6XCJsb2FkTmF2aWdhdGlvbkVsZW1lbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuY2xlYW5OYXZpZ2F0aW9uKCksdGhpcy5uYXZpZ2F0aW9uRE9NPXt9O3ZhciBlPVtcInVwXCIsXCJkb3duXCIsXCJsZWZ0XCIsXCJyaWdodFwiLFwiem9vbUluXCIsXCJ6b29tT3V0XCIsXCJ6b29tRXh0ZW5kc1wiXSxpPVtcIl9tb3ZlVXBcIixcIl9tb3ZlRG93blwiLFwiX21vdmVMZWZ0XCIsXCJfbW92ZVJpZ2h0XCIsXCJfem9vbUluXCIsXCJfem9vbU91dFwiLFwiX2ZpdFwiXTt0aGlzLm5hdmlnYXRpb25ET00ud3JhcHBlcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMubmF2aWdhdGlvbkRPTS53cmFwcGVyLmNsYXNzTmFtZT1cInZpcy1uYXZpZ2F0aW9uXCIsdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5uYXZpZ2F0aW9uRE9NLndyYXBwZXIpO2Zvcih2YXIgbz0wO288ZS5sZW5ndGg7bysrKXt0aGlzLm5hdmlnYXRpb25ET01bZVtvXV09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLm5hdmlnYXRpb25ET01bZVtvXV0uY2xhc3NOYW1lPVwidmlzLWJ1dHRvbiB2aXMtXCIrZVtvXSx0aGlzLm5hdmlnYXRpb25ET00ud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLm5hdmlnYXRpb25ET01bZVtvXV0pO3ZhciBuLHIscz1uZXcgU2godGhpcy5uYXZpZ2F0aW9uRE9NW2Vbb11dKTtpZihcIl9maXRcIj09PWlbb10pVHUocyxidChuPXRoaXMuX2ZpdCkuY2FsbChuLHRoaXMpKTtlbHNlIFR1KHMsYnQocj10aGlzLmJpbmRUb1JlZHJhdykuY2FsbChyLHRoaXMsaVtvXSkpO3RoaXMubmF2aWdhdGlvbkhhbW1lcnMucHVzaChzKX12YXIgYT1uZXcgU2godGhpcy5jYW52YXMuZnJhbWUpO011KGEsKGZ1bmN0aW9uKCl7dC5fc3RvcE1vdmVtZW50KCl9KSksdGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5wdXNoKGEpLHRoaXMuaWNvbnNDcmVhdGVkPSEwfX0se2tleTpcImJpbmRUb1JlZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlO3ZvaWQgMD09PXRoaXMuYm91bmRGdW5jdGlvbnNbdF0mJih0aGlzLmJvdW5kRnVuY3Rpb25zW3RdPWJ0KGU9dGhpc1t0XSkuY2FsbChlLHRoaXMpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLHRoaXMuYm91bmRGdW5jdGlvbnNbdF0pLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RhcnRSZW5kZXJpbmdcIikpfX0se2tleTpcInVuYmluZEZyb21SZWRyYXdcIix2YWx1ZTpmdW5jdGlvbih0KXt2b2lkIDAhPT10aGlzLmJvdW5kRnVuY3Rpb25zW3RdJiYodGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLHRoaXMuYm91bmRGdW5jdGlvbnNbdF0pLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RvcFJlbmRlcmluZ1wiKSxkZWxldGUgdGhpcy5ib3VuZEZ1bmN0aW9uc1t0XSl9fSx7a2V5OlwiX2ZpdFwiLHZhbHVlOmZ1bmN0aW9uKCl7KG5ldyBEYXRlKS52YWx1ZU9mKCktdGhpcy50b3VjaFRpbWU+NzAwJiYodGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImZpdFwiLHtkdXJhdGlvbjo3MDB9KSx0aGlzLnRvdWNoVGltZT0obmV3IERhdGUpLnZhbHVlT2YoKSl9fSx7a2V5OlwiX3N0b3BNb3ZlbWVudFwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMuYm91bmRGdW5jdGlvbnMpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm91bmRGdW5jdGlvbnMsdCkmJih0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsdGhpcy5ib3VuZEZ1bmN0aW9uc1t0XSksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdG9wUmVuZGVyaW5nXCIpKTt0aGlzLmJvdW5kRnVuY3Rpb25zPXt9fX0se2tleTpcIl9tb3ZlVXBcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkrPXRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC55fX0se2tleTpcIl9tb3ZlRG93blwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueS09dGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnl9fSx7a2V5OlwiX21vdmVMZWZ0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54Kz10aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueH19LHtrZXk6XCJfbW92ZVJpZ2h0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54LT10aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueH19LHtrZXk6XCJfem9vbUluXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmJvZHkudmlldy5zY2FsZSxlPXRoaXMuYm9keS52aWV3LnNjYWxlKigxK3RoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC56b29tKSxpPXRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLG89ZS90LG49KDEtbykqdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci54K2kueCpvLHI9KDEtbykqdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci55K2kueSpvO3RoaXMuYm9keS52aWV3LnNjYWxlPWUsdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb249e3g6bix5OnJ9LHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJ6b29tXCIse2RpcmVjdGlvbjpcIitcIixzY2FsZTp0aGlzLmJvZHkudmlldy5zY2FsZSxwb2ludGVyOm51bGx9KX19LHtrZXk6XCJfem9vbU91dFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5ib2R5LnZpZXcuc2NhbGUsZT10aGlzLmJvZHkudmlldy5zY2FsZS8oMSt0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQuem9vbSksaT10aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbixvPWUvdCxuPSgxLW8pKnRoaXMuY2FudmFzLmNhbnZhc1ZpZXdDZW50ZXIueCtpLngqbyxyPSgxLW8pKnRoaXMuY2FudmFzLmNhbnZhc1ZpZXdDZW50ZXIueStpLnkqbzt0aGlzLmJvZHkudmlldy5zY2FsZT1lLHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uPXt4Om4seTpyfSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiem9vbVwiLHtkaXJlY3Rpb246XCItXCIsc2NhbGU6dGhpcy5ib2R5LnZpZXcuc2NhbGUscG9pbnRlcjpudWxsfSl9fSx7a2V5OlwiY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5nc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZSxpLG8sbixyLHMsYSxoLGQsbCxjLHUsZixwLHYsZyx5LG0sYix3LGssXyx4LEU9dGhpczsodm9pZCAwIT09dGhpcy5rZXljaGFybSYmdGhpcy5rZXljaGFybS5kZXN0cm95KCksITA9PT10aGlzLm9wdGlvbnMua2V5Ym9hcmQuZW5hYmxlZCkmJighMD09PXRoaXMub3B0aW9ucy5rZXlib2FyZC5iaW5kVG9XaW5kb3c/dGhpcy5rZXljaGFybT1JdSh7Y29udGFpbmVyOndpbmRvdyxwcmV2ZW50RGVmYXVsdDohMH0pOnRoaXMua2V5Y2hhcm09SXUoe2NvbnRhaW5lcjp0aGlzLmNhbnZhcy5mcmFtZSxwcmV2ZW50RGVmYXVsdDohMH0pLHRoaXMua2V5Y2hhcm0ucmVzZXQoKSwhMD09PXRoaXMuYWN0aXZhdGVkJiYoYnQodD10aGlzLmtleWNoYXJtKS5jYWxsKHQsXCJ1cFwiLChmdW5jdGlvbigpe0UuYmluZFRvUmVkcmF3KFwiX21vdmVVcFwiKX0pLFwia2V5ZG93blwiKSxidChlPXRoaXMua2V5Y2hhcm0pLmNhbGwoZSxcImRvd25cIiwoZnVuY3Rpb24oKXtFLmJpbmRUb1JlZHJhdyhcIl9tb3ZlRG93blwiKX0pLFwia2V5ZG93blwiKSxidChpPXRoaXMua2V5Y2hhcm0pLmNhbGwoaSxcImxlZnRcIiwoZnVuY3Rpb24oKXtFLmJpbmRUb1JlZHJhdyhcIl9tb3ZlTGVmdFwiKX0pLFwia2V5ZG93blwiKSxidChvPXRoaXMua2V5Y2hhcm0pLmNhbGwobyxcInJpZ2h0XCIsKGZ1bmN0aW9uKCl7RS5iaW5kVG9SZWRyYXcoXCJfbW92ZVJpZ2h0XCIpfSksXCJrZXlkb3duXCIpLGJ0KG49dGhpcy5rZXljaGFybSkuY2FsbChuLFwiPVwiLChmdW5jdGlvbigpe0UuYmluZFRvUmVkcmF3KFwiX3pvb21JblwiKX0pLFwia2V5ZG93blwiKSxidChyPXRoaXMua2V5Y2hhcm0pLmNhbGwocixcIm51bStcIiwoZnVuY3Rpb24oKXtFLmJpbmRUb1JlZHJhdyhcIl96b29tSW5cIil9KSxcImtleWRvd25cIiksYnQocz10aGlzLmtleWNoYXJtKS5jYWxsKHMsXCJudW0tXCIsKGZ1bmN0aW9uKCl7RS5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKX0pLFwia2V5ZG93blwiKSxidChhPXRoaXMua2V5Y2hhcm0pLmNhbGwoYSxcIi1cIiwoZnVuY3Rpb24oKXtFLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpfSksXCJrZXlkb3duXCIpLGJ0KGg9dGhpcy5rZXljaGFybSkuY2FsbChoLFwiW1wiLChmdW5jdGlvbigpe0UuYmluZFRvUmVkcmF3KFwiX3pvb21PdXRcIil9KSxcImtleWRvd25cIiksYnQoZD10aGlzLmtleWNoYXJtKS5jYWxsKGQsXCJdXCIsKGZ1bmN0aW9uKCl7RS5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpfSksXCJrZXlkb3duXCIpLGJ0KGw9dGhpcy5rZXljaGFybSkuY2FsbChsLFwicGFnZXVwXCIsKGZ1bmN0aW9uKCl7RS5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpfSksXCJrZXlkb3duXCIpLGJ0KGM9dGhpcy5rZXljaGFybSkuY2FsbChjLFwicGFnZWRvd25cIiwoZnVuY3Rpb24oKXtFLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpfSksXCJrZXlkb3duXCIpLGJ0KHU9dGhpcy5rZXljaGFybSkuY2FsbCh1LFwidXBcIiwoZnVuY3Rpb24oKXtFLnVuYmluZEZyb21SZWRyYXcoXCJfbW92ZVVwXCIpfSksXCJrZXl1cFwiKSxidChmPXRoaXMua2V5Y2hhcm0pLmNhbGwoZixcImRvd25cIiwoZnVuY3Rpb24oKXtFLnVuYmluZEZyb21SZWRyYXcoXCJfbW92ZURvd25cIil9KSxcImtleXVwXCIpLGJ0KHA9dGhpcy5rZXljaGFybSkuY2FsbChwLFwibGVmdFwiLChmdW5jdGlvbigpe0UudW5iaW5kRnJvbVJlZHJhdyhcIl9tb3ZlTGVmdFwiKX0pLFwia2V5dXBcIiksYnQodj10aGlzLmtleWNoYXJtKS5jYWxsKHYsXCJyaWdodFwiLChmdW5jdGlvbigpe0UudW5iaW5kRnJvbVJlZHJhdyhcIl9tb3ZlUmlnaHRcIil9KSxcImtleXVwXCIpLGJ0KGc9dGhpcy5rZXljaGFybSkuY2FsbChnLFwiPVwiLChmdW5jdGlvbigpe0UudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIil9KSxcImtleXVwXCIpLGJ0KHk9dGhpcy5rZXljaGFybSkuY2FsbCh5LFwibnVtK1wiLChmdW5jdGlvbigpe0UudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIil9KSxcImtleXVwXCIpLGJ0KG09dGhpcy5rZXljaGFybSkuY2FsbChtLFwibnVtLVwiLChmdW5jdGlvbigpe0UudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tT3V0XCIpfSksXCJrZXl1cFwiKSxidChiPXRoaXMua2V5Y2hhcm0pLmNhbGwoYixcIi1cIiwoZnVuY3Rpb24oKXtFLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbU91dFwiKX0pLFwia2V5dXBcIiksYnQodz10aGlzLmtleWNoYXJtKS5jYWxsKHcsXCJbXCIsKGZ1bmN0aW9uKCl7RS51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIil9KSxcImtleXVwXCIpLGJ0KGs9dGhpcy5rZXljaGFybSkuY2FsbChrLFwiXVwiLChmdW5jdGlvbigpe0UudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIil9KSxcImtleXVwXCIpLGJ0KF89dGhpcy5rZXljaGFybSkuY2FsbChfLFwicGFnZXVwXCIsKGZ1bmN0aW9uKCl7RS51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21JblwiKX0pLFwia2V5dXBcIiksYnQoeD10aGlzLmtleWNoYXJtKS5jYWxsKHgsXCJwYWdlZG93blwiLChmdW5jdGlvbigpe0UudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tT3V0XCIpfSksXCJrZXl1cFwiKSkpfX1dKSx0fSgpO2Z1bmN0aW9uIEZ1KHQsZSl7dmFyIGk7aWYodm9pZCAwPT09Y258fG51bGw9PUNpKHQpKXtpZihnbih0KXx8KGk9ZnVuY3Rpb24odCxlKXt2YXIgaTtpZighdClyZXR1cm47aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIE51KHQsZSk7dmFyIG89dm4oaT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpLmNhbGwoaSw4LC0xKTtcIk9iamVjdFwiPT09byYmdC5jb25zdHJ1Y3RvciYmKG89dC5jb25zdHJ1Y3Rvci5uYW1lKTtpZihcIk1hcFwiPT09b3x8XCJTZXRcIj09PW8pcmV0dXJuIG1pKHQpO2lmKFwiQXJndW1lbnRzXCI9PT1vfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChvKSlyZXR1cm4gTnUodCxlKX0odCkpfHxlJiZ0JiZcIm51bWJlclwiPT10eXBlb2YgdC5sZW5ndGgpe2kmJih0PWkpO3ZhciBvPTAsbj1mdW5jdGlvbigpe307cmV0dXJue3M6bixuOmZ1bmN0aW9uKCl7cmV0dXJuIG8+PXQubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTp0W28rK119fSxlOmZ1bmN0aW9uKHQpe3Rocm93IHR9LGY6bn19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXZhciByLHM9ITAsYT0hMTtyZXR1cm57czpmdW5jdGlvbigpe2k9U2kodCl9LG46ZnVuY3Rpb24oKXt2YXIgdD1pLm5leHQoKTtyZXR1cm4gcz10LmRvbmUsdH0sZTpmdW5jdGlvbih0KXthPSEwLHI9dH0sZjpmdW5jdGlvbigpe3RyeXtzfHxudWxsPT1pLnJldHVybnx8aS5yZXR1cm4oKX1maW5hbGx5e2lmKGEpdGhyb3cgcn19fX1mdW5jdGlvbiBOdSh0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgaT0wLG89bmV3IEFycmF5KGUpO2k8ZTtpKyspb1tpXT10W2ldO3JldHVybiBvfXZhciBBdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8pe3ZhciBuLHIscyxhLGgsZCxsLGMsdSxmLHAsdixnO1BvKHRoaXMsdCksdGhpcy5ib2R5PWUsdGhpcy5jYW52YXM9aSx0aGlzLnNlbGVjdGlvbkhhbmRsZXI9byx0aGlzLm5hdmlnYXRpb25IYW5kbGVyPW5ldyB6dShlLGkpLHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vblRhcD1idChuPXRoaXMub25UYXApLmNhbGwobix0aGlzKSx0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ub3VjaD1idChyPXRoaXMub25Ub3VjaCkuY2FsbChyLHRoaXMpLHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkRvdWJsZVRhcD1idChzPXRoaXMub25Eb3VibGVUYXApLmNhbGwocyx0aGlzKSx0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ib2xkPWJ0KGE9dGhpcy5vbkhvbGQpLmNhbGwoYSx0aGlzKSx0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnU3RhcnQ9YnQoaD10aGlzLm9uRHJhZ1N0YXJ0KS5jYWxsKGgsdGhpcyksdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZz1idChkPXRoaXMub25EcmFnKS5jYWxsKGQsdGhpcyksdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ0VuZD1idChsPXRoaXMub25EcmFnRW5kKS5jYWxsKGwsdGhpcyksdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uTW91c2VXaGVlbD1idChjPXRoaXMub25Nb3VzZVdoZWVsKS5jYWxsKGMsdGhpcyksdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUGluY2g9YnQodT10aGlzLm9uUGluY2gpLmNhbGwodSx0aGlzKSx0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZU1vdmU9YnQoZj10aGlzLm9uTW91c2VNb3ZlKS5jYWxsKGYsdGhpcyksdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUmVsZWFzZT1idChwPXRoaXMub25SZWxlYXNlKS5jYWxsKHAsdGhpcyksdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uQ29udGV4dD1idCh2PXRoaXMub25Db250ZXh0KS5jYWxsKHYsdGhpcyksdGhpcy50b3VjaFRpbWU9MCx0aGlzLmRyYWc9e30sdGhpcy5waW5jaD17fSx0aGlzLnBvcHVwPXZvaWQgMCx0aGlzLnBvcHVwT2JqPXZvaWQgMCx0aGlzLnBvcHVwVGltZXI9dm9pZCAwLHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcj1idChnPXRoaXMuZ2V0UG9pbnRlcikuY2FsbChnLHRoaXMpLHRoaXMub3B0aW9ucz17fSx0aGlzLmRlZmF1bHRPcHRpb25zPXtkcmFnTm9kZXM6ITAsZHJhZ1ZpZXc6ITAsaG92ZXI6ITEsa2V5Ym9hcmQ6e2VuYWJsZWQ6ITEsc3BlZWQ6e3g6MTAseToxMCx6b29tOi4wMn0sYmluZFRvV2luZG93OiEwfSxuYXZpZ2F0aW9uQnV0dG9uczohMSx0b29sdGlwRGVsYXk6MzAwLHpvb21WaWV3OiEwLHpvb21TcGVlZDoxfSxjdCh0aGlzLm9wdGlvbnMsdGhpcy5kZWZhdWx0T3B0aW9ucyksdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKX1yZXR1cm4gSW8odCxbe2tleTpcImJpbmRFdmVudExpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwoZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodC5wb3B1cFRpbWVyKSxkZWxldGUgdC5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyfSkpfX0se2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih2b2lkIDAhPT10KXtKYShbXCJoaWRlRWRnZXNPbkRyYWdcIixcImhpZGVFZGdlc09uWm9vbVwiLFwiaGlkZU5vZGVzT25EcmFnXCIsXCJrZXlib2FyZFwiLFwibXVsdGlzZWxlY3RcIixcInNlbGVjdGFibGVcIixcInNlbGVjdENvbm5lY3RlZEVkZ2VzXCJdLHRoaXMub3B0aW9ucyx0KSxnaCh0aGlzLm9wdGlvbnMsdCxcImtleWJvYXJkXCIpLHQudG9vbHRpcCYmKGN0KHRoaXMub3B0aW9ucy50b29sdGlwLHQudG9vbHRpcCksdC50b29sdGlwLmNvbG9yJiYodGhpcy5vcHRpb25zLnRvb2x0aXAuY29sb3I9aGgodC50b29sdGlwLmNvbG9yKSkpfXRoaXMubmF2aWdhdGlvbkhhbmRsZXIuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpfX0se2tleTpcImdldFBvaW50ZXJcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm57eDp0LngtKGU9dGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkseTp0Lnktb2godGhpcy5jYW52YXMuZnJhbWUuY2FudmFzKX07dmFyIGV9fSx7a2V5Olwib25Ub3VjaFwiLHZhbHVlOmZ1bmN0aW9uKHQpeyhuZXcgRGF0ZSkudmFsdWVPZigpLXRoaXMudG91Y2hUaW1lPjUwJiYodGhpcy5kcmFnLnBvaW50ZXI9dGhpcy5nZXRQb2ludGVyKHQuY2VudGVyKSx0aGlzLmRyYWcucGluY2hlZD0hMSx0aGlzLnBpbmNoLnNjYWxlPXRoaXMuYm9keS52aWV3LnNjYWxlLHRoaXMudG91Y2hUaW1lPShuZXcgRGF0ZSkudmFsdWVPZigpKX19LHtrZXk6XCJvblRhcFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0UG9pbnRlcih0LmNlbnRlciksaT10aGlzLnNlbGVjdGlvbkhhbmRsZXIub3B0aW9ucy5tdWx0aXNlbGVjdCYmKHQuY2hhbmdlZFBvaW50ZXJzWzBdLmN0cmxLZXl8fHQuY2hhbmdlZFBvaW50ZXJzWzBdLm1ldGFLZXkpO3RoaXMuY2hlY2tTZWxlY3Rpb25DaGFuZ2VzKGUsaSksdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmNvbW1pdEFuZEVtaXQoZSx0KSx0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiY2xpY2tcIix0LGUpfX0se2tleTpcIm9uRG91YmxlVGFwXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRQb2ludGVyKHQuY2VudGVyKTt0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZG91YmxlQ2xpY2tcIix0LGUpfX0se2tleTpcIm9uSG9sZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0UG9pbnRlcih0LmNlbnRlciksaT10aGlzLnNlbGVjdGlvbkhhbmRsZXIub3B0aW9ucy5tdWx0aXNlbGVjdDt0aGlzLmNoZWNrU2VsZWN0aW9uQ2hhbmdlcyhlLGkpLHRoaXMuc2VsZWN0aW9uSGFuZGxlci5jb21taXRBbmRFbWl0KGUsdCksdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImNsaWNrXCIsdCxlKSx0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiaG9sZFwiLHQsZSl9fSx7a2V5Olwib25SZWxlYXNlXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoKG5ldyBEYXRlKS52YWx1ZU9mKCktdGhpcy50b3VjaFRpbWU+MTApe3ZhciBlPXRoaXMuZ2V0UG9pbnRlcih0LmNlbnRlcik7dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcInJlbGVhc2VcIix0LGUpLHRoaXMudG91Y2hUaW1lPShuZXcgRGF0ZSkudmFsdWVPZigpfX19LHtrZXk6XCJvbkNvbnRleHRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldFBvaW50ZXIoe3g6dC5jbGllbnRYLHk6dC5jbGllbnRZfSk7dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcIm9uY29udGV4dFwiLHQsZSl9fSx7a2V5OlwiY2hlY2tTZWxlY3Rpb25DaGFuZ2VzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXTshMD09PWU/dGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdEFkZGl0aW9uYWxPblBvaW50KHQpOnRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPblBvaW50KHQpfX0se2tleTpcIl9kZXRlcm1pbmVEaWZmZXJlbmNlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT1mdW5jdGlvbih0LGUpe2Zvcih2YXIgaT1bXSxvPTA7bzx0Lmxlbmd0aDtvKyspe3ZhciBuPXRbb107LTE9PT1NcihlKS5jYWxsKGUsbikmJmkucHVzaChuKX1yZXR1cm4gaX07cmV0dXJue25vZGVzOmkodC5ub2RlcyxlLm5vZGVzKSxlZGdlczppKHQuZWRnZXMsZS5lZGdlcyl9fX0se2tleTpcIm9uRHJhZ1N0YXJ0XCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoIXRoaXMuZHJhZy5kcmFnZ2luZyl7dm9pZCAwPT09dGhpcy5kcmFnLnBvaW50ZXImJnRoaXMub25Ub3VjaCh0KTt2YXIgZT10aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHRoaXMuZHJhZy5wb2ludGVyKTtpZih0aGlzLmRyYWcuZHJhZ2dpbmc9ITAsdGhpcy5kcmFnLnNlbGVjdGlvbj1bXSx0aGlzLmRyYWcudHJhbnNsYXRpb249Y3Qoe30sdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24pLHRoaXMuZHJhZy5ub2RlSWQ9dm9pZCAwLHQuc3JjRXZlbnQuc2hpZnRLZXkpe3RoaXMuYm9keS5zZWxlY3Rpb25Cb3guc2hvdz0hMDt2YXIgaT10aGlzLmdldFBvaW50ZXIodC5jZW50ZXIpO3RoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQ9e3g6dGhpcy5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXMoaS54KSx5OnRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKGkueSl9LHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uZW5kPXt4OnRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKGkueCkseTp0aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhpLnkpfX1pZih2b2lkIDAhPT1lJiYhMD09PXRoaXMub3B0aW9ucy5kcmFnTm9kZXMpe3RoaXMuZHJhZy5ub2RlSWQ9ZS5pZCwhMT09PWUuaXNTZWxlY3RlZCgpJiYodGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCksdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE9iamVjdChlKSksdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdTdGFydFwiLHQsdGhpcy5kcmFnLnBvaW50ZXIpO3ZhciBvLG49RnUodGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZXMoKSk7dHJ5e2ZvcihuLnMoKTshKG89bi5uKCkpLmRvbmU7KXt2YXIgcj1vLnZhbHVlLHM9e2lkOnIuaWQsbm9kZTpyLHg6ci54LHk6ci55LHhGaXhlZDpyLm9wdGlvbnMuZml4ZWQueCx5Rml4ZWQ6ci5vcHRpb25zLmZpeGVkLnl9O3Iub3B0aW9ucy5maXhlZC54PSEwLHIub3B0aW9ucy5maXhlZC55PSEwLHRoaXMuZHJhZy5zZWxlY3Rpb24ucHVzaChzKX19Y2F0Y2godCl7bi5lKHQpfWZpbmFsbHl7bi5mKCl9fWVsc2UgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdTdGFydFwiLHQsdGhpcy5kcmFnLnBvaW50ZXIsdm9pZCAwLCEwKX19fSx7a2V5Olwib25EcmFnXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZighMCE9PXRoaXMuZHJhZy5waW5jaGVkKXt0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwidW5sb2NrTm9kZVwiKTt2YXIgaT10aGlzLmdldFBvaW50ZXIodC5jZW50ZXIpLG89dGhpcy5kcmFnLnNlbGVjdGlvbjtpZihvJiZvLmxlbmd0aCYmITA9PT10aGlzLm9wdGlvbnMuZHJhZ05vZGVzKXt0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ2dpbmdcIix0LGkpO3ZhciBuPWkueC10aGlzLmRyYWcucG9pbnRlci54LHI9aS55LXRoaXMuZHJhZy5wb2ludGVyLnk7RG4obykuY2FsbChvLChmdW5jdGlvbih0KXt2YXIgaT10Lm5vZGU7ITE9PT10LnhGaXhlZCYmKGkueD1lLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhlLmNhbnZhcy5fWGNvbnZlcnRDYW52YXNUb0RPTSh0LngpK24pKSwhMT09PXQueUZpeGVkJiYoaS55PWUuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKGUuY2FudmFzLl9ZY29udmVydENhbnZhc1RvRE9NKHQueSkrcikpfSkpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIil9ZWxzZXtpZih0LnNyY0V2ZW50LnNoaWZ0S2V5KXtpZih0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ2dpbmdcIix0LGksdm9pZCAwLCEwKSx2b2lkIDA9PT10aGlzLmRyYWcucG9pbnRlcilyZXR1cm4gdm9pZCB0aGlzLm9uRHJhZ1N0YXJ0KHQpO3RoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uZW5kPXt4OnRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKGkueCkseTp0aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhpLnkpfSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIil9aWYoITA9PT10aGlzLm9wdGlvbnMuZHJhZ1ZpZXcmJiF0LnNyY0V2ZW50LnNoaWZ0S2V5KXtpZih0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ2dpbmdcIix0LGksdm9pZCAwLCEwKSx2b2lkIDA9PT10aGlzLmRyYWcucG9pbnRlcilyZXR1cm4gdm9pZCB0aGlzLm9uRHJhZ1N0YXJ0KHQpO3ZhciBzPWkueC10aGlzLmRyYWcucG9pbnRlci54LGE9aS55LXRoaXMuZHJhZy5wb2ludGVyLnk7dGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb249e3g6dGhpcy5kcmFnLnRyYW5zbGF0aW9uLngrcyx5OnRoaXMuZHJhZy50cmFuc2xhdGlvbi55K2F9LHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKX19fX19LHtrZXk6XCJvbkRyYWdFbmRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKHRoaXMuZHJhZy5kcmFnZ2luZz0hMSx0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnNob3cpe3ZhciBpO3RoaXMuYm9keS5zZWxlY3Rpb25Cb3guc2hvdz0hMTt2YXIgbz10aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLG49e21pblg6TWF0aC5taW4oby5zdGFydC54LG8uZW5kLngpLG1pblk6TWF0aC5taW4oby5zdGFydC55LG8uZW5kLnkpLG1heFg6TWF0aC5tYXgoby5zdGFydC54LG8uZW5kLngpLG1heFk6TWF0aC5tYXgoby5zdGFydC55LG8uZW5kLnkpfSxyPWFyKGk9dGhpcy5ib2R5Lm5vZGVJbmRpY2VzKS5jYWxsKGksKGZ1bmN0aW9uKHQpe3ZhciBpPWUuYm9keS5ub2Rlc1t0XTtyZXR1cm4gaS54Pj1uLm1pblgmJmkueDw9bi5tYXhYJiZpLnk+PW4ubWluWSYmaS55PD1uLm1heFl9KSk7RG4ocikuY2FsbChyLChmdW5jdGlvbih0KXtyZXR1cm4gZS5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE9iamVjdChlLmJvZHkubm9kZXNbdF0pfSkpO3ZhciBzPXRoaXMuZ2V0UG9pbnRlcih0LmNlbnRlcik7dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmNvbW1pdEFuZEVtaXQocyx0KSx0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ0VuZFwiLHQsdGhpcy5nZXRQb2ludGVyKHQuY2VudGVyKSx2b2lkIDAsITApLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKX1lbHNle3ZhciBhPXRoaXMuZHJhZy5zZWxlY3Rpb247YSYmYS5sZW5ndGg/KERuKGEpLmNhbGwoYSwoZnVuY3Rpb24odCl7dC5ub2RlLm9wdGlvbnMuZml4ZWQueD10LnhGaXhlZCx0Lm5vZGUub3B0aW9ucy5maXhlZC55PXQueUZpeGVkfSkpLHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnRW5kXCIsdCx0aGlzLmdldFBvaW50ZXIodC5jZW50ZXIpKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpKToodGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdFbmRcIix0LHRoaXMuZ2V0UG9pbnRlcih0LmNlbnRlciksdm9pZCAwLCEwKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIikpfX19LHtrZXk6XCJvblBpbmNoXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRQb2ludGVyKHQuY2VudGVyKTt0aGlzLmRyYWcucGluY2hlZD0hMCx2b2lkIDA9PT10aGlzLnBpbmNoLnNjYWxlJiYodGhpcy5waW5jaC5zY2FsZT0xKTt2YXIgaT10aGlzLnBpbmNoLnNjYWxlKnQuc2NhbGU7dGhpcy56b29tKGksZSl9fSx7a2V5Olwiem9vbVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYoITA9PT10aGlzLm9wdGlvbnMuem9vbVZpZXcpe3ZhciBpPXRoaXMuYm9keS52aWV3LnNjYWxlO3Q8MWUtNSYmKHQ9MWUtNSksdD4xMCYmKHQ9MTApO3ZhciBvPXZvaWQgMDt2b2lkIDAhPT10aGlzLmRyYWcmJiEwPT09dGhpcy5kcmFnLmRyYWdnaW5nJiYobz10aGlzLmNhbnZhcy5ET010b0NhbnZhcyh0aGlzLmRyYWcucG9pbnRlcikpO3ZhciBuPXRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLHI9dC9pLHM9KDEtcikqZS54K24ueCpyLGE9KDEtcikqZS55K24ueSpyO2lmKHRoaXMuYm9keS52aWV3LnNjYWxlPXQsdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb249e3g6cyx5OmF9LG51bGwhPW8pe3ZhciBoPXRoaXMuY2FudmFzLmNhbnZhc1RvRE9NKG8pO3RoaXMuZHJhZy5wb2ludGVyLng9aC54LHRoaXMuZHJhZy5wb2ludGVyLnk9aC55fXRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKSxpPHQ/dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInpvb21cIix7ZGlyZWN0aW9uOlwiK1wiLHNjYWxlOnRoaXMuYm9keS52aWV3LnNjYWxlLHBvaW50ZXI6ZX0pOnRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJ6b29tXCIse2RpcmVjdGlvbjpcIi1cIixzY2FsZTp0aGlzLmJvZHkudmlldy5zY2FsZSxwb2ludGVyOmV9KX19fSx7a2V5Olwib25Nb3VzZVdoZWVsXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoITA9PT10aGlzLm9wdGlvbnMuem9vbVZpZXcpe2lmKDAhPT10LmRlbHRhWSl7dmFyIGU9dGhpcy5ib2R5LnZpZXcuc2NhbGU7ZSo9MSsodC5kZWx0YVk8MD8xOi0xKSooLjEqdGhpcy5vcHRpb25zLnpvb21TcGVlZCk7dmFyIGk9dGhpcy5nZXRQb2ludGVyKHt4OnQuY2xpZW50WCx5OnQuY2xpZW50WX0pO3RoaXMuem9vbShlLGkpfXQucHJldmVudERlZmF1bHQoKX19fSx7a2V5Olwib25Nb3VzZU1vdmVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLGk9dGhpcy5nZXRQb2ludGVyKHt4OnQuY2xpZW50WCx5OnQuY2xpZW50WX0pLG89ITE7dm9pZCAwIT09dGhpcy5wb3B1cCYmKCExPT09dGhpcy5wb3B1cC5oaWRkZW4mJnRoaXMuX2NoZWNrSGlkZVBvcHVwKGkpLCExPT09dGhpcy5wb3B1cC5oaWRkZW4mJihvPSEwLHRoaXMucG9wdXAuc2V0UG9zaXRpb24oaS54KzMsaS55LTUpLHRoaXMucG9wdXAuc2hvdygpKSksITE9PT10aGlzLm9wdGlvbnMua2V5Ym9hcmQuYmluZFRvV2luZG93JiYhMD09PXRoaXMub3B0aW9ucy5rZXlib2FyZC5lbmFibGVkJiZ0aGlzLmNhbnZhcy5mcmFtZS5mb2N1cygpLCExPT09byYmKHZvaWQgMCE9PXRoaXMucG9wdXBUaW1lciYmKGNsZWFySW50ZXJ2YWwodGhpcy5wb3B1cFRpbWVyKSx0aGlzLnBvcHVwVGltZXI9dm9pZCAwKSx0aGlzLmRyYWcuZHJhZ2dpbmd8fCh0aGlzLnBvcHVwVGltZXI9cXIoKGZ1bmN0aW9uKCl7cmV0dXJuIGUuX2NoZWNrU2hvd1BvcHVwKGkpfSksdGhpcy5vcHRpb25zLnRvb2x0aXBEZWxheSkpKSwhMD09PXRoaXMub3B0aW9ucy5ob3ZlciYmdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmhvdmVyT2JqZWN0KHQsaSl9fSx7a2V5OlwiX2NoZWNrU2hvd1BvcHVwXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXModC54KSxpPXRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHQueSksbz17bGVmdDplLHRvcDppLHJpZ2h0OmUsYm90dG9tOml9LG49dm9pZCAwPT09dGhpcy5wb3B1cE9iaj92b2lkIDA6dGhpcy5wb3B1cE9iai5pZCxyPSExLHM9XCJub2RlXCI7aWYodm9pZCAwPT09dGhpcy5wb3B1cE9iail7Zm9yKHZhciBhLGg9dGhpcy5ib2R5Lm5vZGVJbmRpY2VzLGQ9dGhpcy5ib2R5Lm5vZGVzLGw9W10sYz0wO2M8aC5sZW5ndGg7YysrKSEwPT09KGE9ZFtoW2NdXSkuaXNPdmVybGFwcGluZ1dpdGgobykmJihyPSEwLHZvaWQgMCE9PWEuZ2V0VGl0bGUoKSYmbC5wdXNoKGhbY10pKTtsLmxlbmd0aD4wJiYodGhpcy5wb3B1cE9iaj1kW2xbbC5sZW5ndGgtMV1dLHI9ITApfWlmKHZvaWQgMD09PXRoaXMucG9wdXBPYmomJiExPT09cil7Zm9yKHZhciB1LGY9dGhpcy5ib2R5LmVkZ2VJbmRpY2VzLHA9dGhpcy5ib2R5LmVkZ2VzLHY9W10sZz0wO2c8Zi5sZW5ndGg7ZysrKSEwPT09KHU9cFtmW2ddXSkuaXNPdmVybGFwcGluZ1dpdGgobykmJiEwPT09dS5jb25uZWN0ZWQmJnZvaWQgMCE9PXUuZ2V0VGl0bGUoKSYmdi5wdXNoKGZbZ10pO3YubGVuZ3RoPjAmJih0aGlzLnBvcHVwT2JqPXBbdlt2Lmxlbmd0aC0xXV0scz1cImVkZ2VcIil9dm9pZCAwIT09dGhpcy5wb3B1cE9iaj90aGlzLnBvcHVwT2JqLmlkIT09biYmKHZvaWQgMD09PXRoaXMucG9wdXAmJih0aGlzLnBvcHVwPW5ldyBUaCh0aGlzLmNhbnZhcy5mcmFtZSkpLHRoaXMucG9wdXAucG9wdXBUYXJnZXRUeXBlPXMsdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkPXRoaXMucG9wdXBPYmouaWQsdGhpcy5wb3B1cC5zZXRQb3NpdGlvbih0LngrMyx0LnktNSksdGhpcy5wb3B1cC5zZXRUZXh0KHRoaXMucG9wdXBPYmouZ2V0VGl0bGUoKSksdGhpcy5wb3B1cC5zaG93KCksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInNob3dQb3B1cFwiLHRoaXMucG9wdXBPYmouaWQpKTp2b2lkIDAhPT10aGlzLnBvcHVwJiYodGhpcy5wb3B1cC5oaWRlKCksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImhpZGVQb3B1cFwiKSl9fSx7a2V5OlwiX2NoZWNrSGlkZVBvcHVwXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdCh0KSxpPSExO2lmKFwibm9kZVwiPT09dGhpcy5wb3B1cC5wb3B1cFRhcmdldFR5cGUpe2lmKHZvaWQgMCE9PXRoaXMuYm9keS5ub2Rlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdJiYhMD09PShpPXRoaXMuYm9keS5ub2Rlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdLmlzT3ZlcmxhcHBpbmdXaXRoKGUpKSl7dmFyIG89dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdCh0KTtpPXZvaWQgMCE9PW8mJm8uaWQ9PT10aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWR9fWVsc2Ugdm9pZCAwPT09dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdCh0KSYmdm9pZCAwIT09dGhpcy5ib2R5LmVkZ2VzW3RoaXMucG9wdXAucG9wdXBUYXJnZXRJZF0mJihpPXRoaXMuYm9keS5lZGdlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdLmlzT3ZlcmxhcHBpbmdXaXRoKGUpKTshMT09PWkmJih0aGlzLnBvcHVwT2JqPXZvaWQgMCx0aGlzLnBvcHVwLmhpZGUoKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaGlkZVBvcHVwXCIpKX19XSksdH0oKTtFZChcIlNldFwiLChmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdCh0aGlzLGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzBdOnZvaWQgMCl9fSksRGQpO3ZhciBSdT1GLlNldCxqdT1nZC5nZXRXZWFrRGF0YSxMdT1adC5zZXQsSHU9WnQuZ2V0dGVyRm9yLFd1PVdpLmZpbmQsVnU9V2kuZmluZEluZGV4LHF1PTAsVXU9ZnVuY3Rpb24odCl7cmV0dXJuIHQuZnJvemVufHwodC5mcm96ZW49bmV3IFl1KX0sWXU9ZnVuY3Rpb24oKXt0aGlzLmVudHJpZXM9W119LFh1PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFd1KHQuZW50cmllcywoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF09PT1lfSkpfTtZdS5wcm90b3R5cGU9e2dldDpmdW5jdGlvbih0KXt2YXIgZT1YdSh0aGlzLHQpO2lmKGUpcmV0dXJuIGVbMV19LGhhczpmdW5jdGlvbih0KXtyZXR1cm4hIVh1KHRoaXMsdCl9LHNldDpmdW5jdGlvbih0LGUpe3ZhciBpPVh1KHRoaXMsdCk7aT9pWzFdPWU6dGhpcy5lbnRyaWVzLnB1c2goW3QsZV0pfSxkZWxldGU6ZnVuY3Rpb24odCl7dmFyIGU9VnUodGhpcy5lbnRyaWVzLChmdW5jdGlvbihlKXtyZXR1cm4gZVswXT09PXR9KSk7cmV0dXJufmUmJnRoaXMuZW50cmllcy5zcGxpY2UoZSwxKSwhIX5lfX07dmFyIEd1PXtnZXRDb25zdHJ1Y3RvcjpmdW5jdGlvbih0LGUsaSxvKXt2YXIgbj10KChmdW5jdGlvbih0LHIpe2JkKHQsbixlKSxMdSh0LHt0eXBlOmUsaWQ6cXUrKyxmcm96ZW46dm9pZCAwfSksbnVsbCE9ciYmbWQocix0W29dLHt0aGF0OnQsQVNfRU5UUklFUzppfSl9KSkscj1IdShlKSxzPWZ1bmN0aW9uKHQsZSxpKXt2YXIgbz1yKHQpLG49anUoUihlKSwhMCk7cmV0dXJuITA9PT1uP1V1KG8pLnNldChlLGkpOm5bby5pZF09aSx0fTtyZXR1cm4gT2Qobi5wcm90b3R5cGUse2RlbGV0ZTpmdW5jdGlvbih0KXt2YXIgZT1yKHRoaXMpO2lmKCFtKHQpKXJldHVybiExO3ZhciBpPWp1KHQpO3JldHVybiEwPT09aT9VdShlKS5kZWxldGUodCk6aSYmayhpLGUuaWQpJiZkZWxldGUgaVtlLmlkXX0saGFzOmZ1bmN0aW9uKHQpe3ZhciBlPXIodGhpcyk7aWYoIW0odCkpcmV0dXJuITE7dmFyIGk9anUodCk7cmV0dXJuITA9PT1pP1V1KGUpLmhhcyh0KTppJiZrKGksZS5pZCl9fSksT2Qobi5wcm90b3R5cGUsaT97Z2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXIodGhpcyk7aWYobSh0KSl7dmFyIGk9anUodCk7cmV0dXJuITA9PT1pP1V1KGUpLmdldCh0KTppP2lbZS5pZF06dm9pZCAwfX0sc2V0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHModGhpcyx0LGUpfX06e2FkZDpmdW5jdGlvbih0KXtyZXR1cm4gcyh0aGlzLHQsITApfX0pLG59fTtvKChmdW5jdGlvbih0KXt2YXIgZSxpPVp0LmVuZm9yY2Usbz0hci5BY3RpdmVYT2JqZWN0JiZcIkFjdGl2ZVhPYmplY3RcImluIHIsbj1PYmplY3QuaXNFeHRlbnNpYmxlLHM9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQodGhpcyxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1swXTp2b2lkIDApfX0sYT10LmV4cG9ydHM9RWQoXCJXZWFrTWFwXCIscyxHdSk7aWYoQXQmJm8pe2U9R3UuZ2V0Q29uc3RydWN0b3IocyxcIldlYWtNYXBcIiwhMCksZ2QuUkVRVUlSRUQ9ITA7dmFyIGg9YS5wcm90b3R5cGUsZD1oLmRlbGV0ZSxsPWguaGFzLGM9aC5nZXQsdT1oLnNldDtPZChoLHtkZWxldGU6ZnVuY3Rpb24odCl7aWYobSh0KSYmIW4odCkpe3ZhciBvPWkodGhpcyk7cmV0dXJuIG8uZnJvemVufHwoby5mcm96ZW49bmV3IGUpLGQuY2FsbCh0aGlzLHQpfHxvLmZyb3plbi5kZWxldGUodCl9cmV0dXJuIGQuY2FsbCh0aGlzLHQpfSxoYXM6ZnVuY3Rpb24odCl7aWYobSh0KSYmIW4odCkpe3ZhciBvPWkodGhpcyk7cmV0dXJuIG8uZnJvemVufHwoby5mcm96ZW49bmV3IGUpLGwuY2FsbCh0aGlzLHQpfHxvLmZyb3plbi5oYXModCl9cmV0dXJuIGwuY2FsbCh0aGlzLHQpfSxnZXQ6ZnVuY3Rpb24odCl7aWYobSh0KSYmIW4odCkpe3ZhciBvPWkodGhpcyk7cmV0dXJuIG8uZnJvemVufHwoby5mcm96ZW49bmV3IGUpLGwuY2FsbCh0aGlzLHQpP2MuY2FsbCh0aGlzLHQpOm8uZnJvemVuLmdldCh0KX1yZXR1cm4gYy5jYWxsKHRoaXMsdCl9LHNldDpmdW5jdGlvbih0LG8pe2lmKG0odCkmJiFuKHQpKXt2YXIgcj1pKHRoaXMpO3IuZnJvemVufHwoci5mcm96ZW49bmV3IGUpLGwuY2FsbCh0aGlzLHQpP3UuY2FsbCh0aGlzLHQsbyk6ci5mcm96ZW4uc2V0KHQsbyl9ZWxzZSB1LmNhbGwodGhpcyx0LG8pO3JldHVybiB0aGlzfX0pfX0pKTt2YXIgS3UsJHUsUXUsWnUsSnUsdGY9Ri5XZWFrTWFwO1xuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5cdFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuXHRwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuXHRSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcblx0QU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuXHRJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cblx0TE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcblx0T1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuXHRQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuXHQqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuZnVuY3Rpb24gZWYodCxlKXtpZighZS5oYXModCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIGUuZ2V0KHQpfWZ1bmN0aW9uIG9mKHQsZSxpKXtpZighZS5oYXModCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIGUuc2V0KHQsaSksaX1mdW5jdGlvbiBuZih0LGUpe3ZhciBpO2lmKHZvaWQgMD09PWNufHxudWxsPT1DaSh0KSl7aWYoZ24odCl8fChpPWZ1bmN0aW9uKHQsZSl7dmFyIGk7aWYoIXQpcmV0dXJuO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXJldHVybiByZih0LGUpO3ZhciBvPXZuKGk9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKS5jYWxsKGksOCwtMSk7XCJPYmplY3RcIj09PW8mJnQuY29uc3RydWN0b3ImJihvPXQuY29uc3RydWN0b3IubmFtZSk7aWYoXCJNYXBcIj09PW98fFwiU2V0XCI9PT1vKXJldHVybiBtaSh0KTtpZihcIkFyZ3VtZW50c1wiPT09b3x8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobykpcmV0dXJuIHJmKHQsZSl9KHQpKXx8ZSYmdCYmXCJudW1iZXJcIj09dHlwZW9mIHQubGVuZ3RoKXtpJiYodD1pKTt2YXIgbz0wLG49ZnVuY3Rpb24oKXt9O3JldHVybntzOm4sbjpmdW5jdGlvbigpe3JldHVybiBvPj10Lmxlbmd0aD97ZG9uZTohMH06e2RvbmU6ITEsdmFsdWU6dFtvKytdfX0sZTpmdW5jdGlvbih0KXt0aHJvdyB0fSxmOm59fXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX12YXIgcixzPSEwLGE9ITE7cmV0dXJue3M6ZnVuY3Rpb24oKXtpPVNpKHQpfSxuOmZ1bmN0aW9uKCl7dmFyIHQ9aS5uZXh0KCk7cmV0dXJuIHM9dC5kb25lLHR9LGU6ZnVuY3Rpb24odCl7YT0hMCxyPXR9LGY6ZnVuY3Rpb24oKXt0cnl7c3x8bnVsbD09aS5yZXR1cm58fGkucmV0dXJuKCl9ZmluYWxseXtpZihhKXRocm93IHJ9fX19ZnVuY3Rpb24gcmYodCxlKXsobnVsbD09ZXx8ZT50Lmxlbmd0aCkmJihlPXQubGVuZ3RoKTtmb3IodmFyIGk9MCxvPW5ldyBBcnJheShlKTtpPGU7aSsrKW9baV09dFtpXTtyZXR1cm4gb31mdW5jdGlvbiBzZih0LGUpe3ZhciBpLG89bmV3IFJ1LG49bmYoZSk7dHJ5e2ZvcihuLnMoKTshKGk9bi5uKCkpLmRvbmU7KXt2YXIgcj1pLnZhbHVlO3QuaGFzKHIpfHxvLmFkZChyKX19Y2F0Y2godCl7bi5lKHQpfWZpbmFsbHl7bi5mKCl9cmV0dXJuIG99dmFyIGFmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCksS3Uuc2V0KHRoaXMsbmV3IFJ1KSwkdS5zZXQodGhpcyxuZXcgUnUpfXJldHVybiBJbyh0LFt7a2V5Olwic2l6ZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBlZih0aGlzLCR1KS5zaXplfX0se2tleTpcImFkZFwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsZT1uZXcgQXJyYXkodCksaT0wO2k8dDtpKyspZVtpXT1hcmd1bWVudHNbaV07Zm9yKHZhciBvPTAsbj1lO288bi5sZW5ndGg7bysrKXt2YXIgcj1uW29dO2VmKHRoaXMsJHUpLmFkZChyKX19fSx7a2V5OlwiZGVsZXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxlPW5ldyBBcnJheSh0KSxpPTA7aTx0O2krKyllW2ldPWFyZ3VtZW50c1tpXTtmb3IodmFyIG89MCxuPWU7bzxuLmxlbmd0aDtvKyspe3ZhciByPW5bb107ZWYodGhpcywkdSkuZGVsZXRlKHIpfX19LHtrZXk6XCJjbGVhclwiLHZhbHVlOmZ1bmN0aW9uKCl7ZWYodGhpcywkdSkuY2xlYXIoKX19LHtrZXk6XCJnZXRTZWxlY3Rpb25cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBsbihlZih0aGlzLCR1KSl9fSx7a2V5OlwiZ2V0Q2hhbmdlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJue2FkZGVkOmxuKHNmKGVmKHRoaXMsS3UpLGVmKHRoaXMsJHUpKSksZGVsZXRlZDpsbihzZihlZih0aGlzLCR1KSxlZih0aGlzLEt1KSkpLHByZXZpb3VzOmxuKG5ldyBSdShlZih0aGlzLEt1KSkpLGN1cnJlbnQ6bG4obmV3IFJ1KGVmKHRoaXMsJHUpKSl9fX0se2tleTpcImNvbW1pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRDaGFuZ2VzKCk7b2YodGhpcyxLdSxlZih0aGlzLCR1KSksb2YodGhpcywkdSxuZXcgUnUoZWYodGhpcyxLdSkpKTt2YXIgZSxpPW5mKHQuYWRkZWQpO3RyeXtmb3IoaS5zKCk7IShlPWkubigpKS5kb25lOyl7ZS52YWx1ZS5zZWxlY3QoKX19Y2F0Y2godCl7aS5lKHQpfWZpbmFsbHl7aS5mKCl9dmFyIG8sbj1uZih0LmRlbGV0ZWQpO3RyeXtmb3Iobi5zKCk7IShvPW4ubigpKS5kb25lOyl7by52YWx1ZS51bnNlbGVjdCgpfX1jYXRjaCh0KXtuLmUodCl9ZmluYWxseXtuLmYoKX1yZXR1cm4gdH19XSksdH0oKTtLdT1uZXcgdGYsJHU9bmV3IHRmO3ZhciBoZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06ZnVuY3Rpb24oKXt9O1BvKHRoaXMsdCksUXUuc2V0KHRoaXMsbmV3IGFmKSxadS5zZXQodGhpcyxuZXcgYWYpLEp1LnNldCh0aGlzLHZvaWQgMCksb2YodGhpcyxKdSxlKX1yZXR1cm4gSW8odCxbe2tleTpcInNpemVOb2Rlc1wiLGdldDpmdW5jdGlvbigpe3JldHVybiBlZih0aGlzLFF1KS5zaXplfX0se2tleTpcInNpemVFZGdlc1wiLGdldDpmdW5jdGlvbigpe3JldHVybiBlZih0aGlzLFp1KS5zaXplfX0se2tleTpcImdldE5vZGVzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gZWYodGhpcyxRdSkuZ2V0U2VsZWN0aW9uKCl9fSx7a2V5OlwiZ2V0RWRnZXNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBlZih0aGlzLFp1KS5nZXRTZWxlY3Rpb24oKX19LHtrZXk6XCJhZGROb2Rlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ7KHQ9ZWYodGhpcyxRdSkpLmFkZC5hcHBseSh0LGFyZ3VtZW50cyl9fSx7a2V5OlwiYWRkRWRnZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0Oyh0PWVmKHRoaXMsWnUpKS5hZGQuYXBwbHkodCxhcmd1bWVudHMpfX0se2tleTpcImRlbGV0ZU5vZGVzXCIsdmFsdWU6ZnVuY3Rpb24odCl7ZWYodGhpcyxRdSkuZGVsZXRlKHQpfX0se2tleTpcImRlbGV0ZUVkZ2VzXCIsdmFsdWU6ZnVuY3Rpb24odCl7ZWYodGhpcyxadSkuZGVsZXRlKHQpfX0se2tleTpcImNsZWFyXCIsdmFsdWU6ZnVuY3Rpb24oKXtlZih0aGlzLFF1KS5jbGVhcigpLGVmKHRoaXMsWnUpLmNsZWFyKCl9fSx7a2V5OlwiY29tbWl0XCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQsZSxpPXtub2RlczplZih0aGlzLFF1KS5jb21taXQoKSxlZGdlczplZih0aGlzLFp1KS5jb21taXQoKX0sbz1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KG8pLHI9MDtyPG87cisrKW5bcl09YXJndW1lbnRzW3JdO3JldHVybih0PWVmKHRoaXMsSnUpKS5jYWxsLmFwcGx5KHQscG4oZT1bdGhpcyxpXSkuY2FsbChlLG4pKSxpfX1dKSx0fSgpO2Z1bmN0aW9uIGRmKHQsZSl7dmFyIGk7aWYodm9pZCAwPT09Y258fG51bGw9PUNpKHQpKXtpZihnbih0KXx8KGk9ZnVuY3Rpb24odCxlKXt2YXIgaTtpZighdClyZXR1cm47aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIGxmKHQsZSk7dmFyIG89dm4oaT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpLmNhbGwoaSw4LC0xKTtcIk9iamVjdFwiPT09byYmdC5jb25zdHJ1Y3RvciYmKG89dC5jb25zdHJ1Y3Rvci5uYW1lKTtpZihcIk1hcFwiPT09b3x8XCJTZXRcIj09PW8pcmV0dXJuIG1pKHQpO2lmKFwiQXJndW1lbnRzXCI9PT1vfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChvKSlyZXR1cm4gbGYodCxlKX0odCkpfHxlJiZ0JiZcIm51bWJlclwiPT10eXBlb2YgdC5sZW5ndGgpe2kmJih0PWkpO3ZhciBvPTAsbj1mdW5jdGlvbigpe307cmV0dXJue3M6bixuOmZ1bmN0aW9uKCl7cmV0dXJuIG8+PXQubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTp0W28rK119fSxlOmZ1bmN0aW9uKHQpe3Rocm93IHR9LGY6bn19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXZhciByLHM9ITAsYT0hMTtyZXR1cm57czpmdW5jdGlvbigpe2k9U2kodCl9LG46ZnVuY3Rpb24oKXt2YXIgdD1pLm5leHQoKTtyZXR1cm4gcz10LmRvbmUsdH0sZTpmdW5jdGlvbih0KXthPSEwLHI9dH0sZjpmdW5jdGlvbigpe3RyeXtzfHxudWxsPT1pLnJldHVybnx8aS5yZXR1cm4oKX1maW5hbGx5e2lmKGEpdGhyb3cgcn19fX1mdW5jdGlvbiBsZih0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgaT0wLG89bmV3IEFycmF5KGUpO2k8ZTtpKyspb1tpXT10W2ldO3JldHVybiBvfVF1PW5ldyB0ZixadT1uZXcgdGYsSnU9bmV3IHRmO3ZhciBjZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpKXt2YXIgbz10aGlzO1BvKHRoaXMsdCksdGhpcy5ib2R5PWUsdGhpcy5jYW52YXM9aSx0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvcj1uZXcgaGYsdGhpcy5ob3Zlck9iaj17bm9kZXM6e30sZWRnZXM6e319LHRoaXMub3B0aW9ucz17fSx0aGlzLmRlZmF1bHRPcHRpb25zPXttdWx0aXNlbGVjdDohMSxzZWxlY3RhYmxlOiEwLHNlbGVjdENvbm5lY3RlZEVkZ2VzOiEwLGhvdmVyQ29ubmVjdGVkRWRnZXM6ITB9LGN0KHRoaXMub3B0aW9ucyx0aGlzLmRlZmF1bHRPcHRpb25zKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhQ2hhbmdlZFwiLChmdW5jdGlvbigpe28udXBkYXRlU2VsZWN0aW9uKCl9KSl9cmV0dXJuIElvKHQsW3trZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dCl7WmEoW1wibXVsdGlzZWxlY3RcIixcImhvdmVyQ29ubmVjdGVkRWRnZXNcIixcInNlbGVjdGFibGVcIixcInNlbGVjdENvbm5lY3RlZEVkZ2VzXCJdLHRoaXMub3B0aW9ucyx0KX19fSx7a2V5Olwic2VsZWN0T25Qb2ludFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPSExO2lmKCEwPT09dGhpcy5vcHRpb25zLnNlbGVjdGFibGUpe3ZhciBpPXRoaXMuZ2V0Tm9kZUF0KHQpfHx0aGlzLmdldEVkZ2VBdCh0KTt0aGlzLnVuc2VsZWN0QWxsKCksdm9pZCAwIT09aSYmKGU9dGhpcy5zZWxlY3RPYmplY3QoaSkpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKX1yZXR1cm4gZX19LHtrZXk6XCJzZWxlY3RBZGRpdGlvbmFsT25Qb2ludFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPSExO2lmKCEwPT09dGhpcy5vcHRpb25zLnNlbGVjdGFibGUpe3ZhciBpPXRoaXMuZ2V0Tm9kZUF0KHQpfHx0aGlzLmdldEVkZ2VBdCh0KTt2b2lkIDAhPT1pJiYoZT0hMCwhMD09PWkuaXNTZWxlY3RlZCgpP3RoaXMuZGVzZWxlY3RPYmplY3QoaSk6dGhpcy5zZWxlY3RPYmplY3QoaSksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpKX1yZXR1cm4gZX19LHtrZXk6XCJfaW5pdEJhc2VFdmVudFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9e307cmV0dXJuIGkucG9pbnRlcj17RE9NOnt4OmUueCx5OmUueX0sY2FudmFzOnRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKGUpfSxpLmV2ZW50PXQsaX19LHtrZXk6XCJnZW5lcmF0ZUNsaWNrRXZlbnRcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjQmJnZvaWQgMCE9PWFyZ3VtZW50c1s0XSYmYXJndW1lbnRzWzRdLHI9dGhpcy5faW5pdEJhc2VFdmVudChlLGkpO2lmKCEwPT09bilyLm5vZGVzPVtdLHIuZWRnZXM9W107ZWxzZXt2YXIgcz10aGlzLmdldFNlbGVjdGlvbigpO3Iubm9kZXM9cy5ub2RlcyxyLmVkZ2VzPXMuZWRnZXN9dm9pZCAwIT09byYmKHIucHJldmlvdXNTZWxlY3Rpb249byksXCJjbGlja1wiPT10JiYoci5pdGVtcz10aGlzLmdldENsaWNrZWRJdGVtcyhpKSksdm9pZCAwIT09ZS5jb250cm9sRWRnZSYmKHIuY29udHJvbEVkZ2U9ZS5jb250cm9sRWRnZSksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCh0LHIpfX0se2tleTpcInNlbGVjdE9iamVjdFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLm9wdGlvbnMuc2VsZWN0Q29ubmVjdGVkRWRnZXM7aWYodm9pZCAwIT09dCl7aWYodCBpbnN0YW5jZW9mIGxjKXt2YXIgaTtpZighMD09PWUpKGk9dGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IpLmFkZEVkZ2VzLmFwcGx5KGksbG4odC5lZGdlcykpO3RoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmFkZE5vZGVzKHQpfWVsc2UgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuYWRkRWRnZXModCk7cmV0dXJuITB9cmV0dXJuITF9fSx7a2V5OlwiZGVzZWxlY3RPYmplY3RcIix2YWx1ZTpmdW5jdGlvbih0KXshMD09PXQuaXNTZWxlY3RlZCgpJiYodC5zZWxlY3RlZD0hMSx0aGlzLl9yZW1vdmVGcm9tU2VsZWN0aW9uKHQpKX19LHtrZXk6XCJfZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGhcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10saT10aGlzLmJvZHkubm9kZXMsbz0wO288dGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDtvKyspe3ZhciBuPXRoaXMuYm9keS5ub2RlSW5kaWNlc1tvXTtpW25dLmlzT3ZlcmxhcHBpbmdXaXRoKHQpJiZlLnB1c2gobil9cmV0dXJuIGV9fSx7a2V5OlwiX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5jYW52YXMuRE9NdG9DYW52YXModCk7cmV0dXJue2xlZnQ6ZS54LTEsdG9wOmUueSsxLHJpZ2h0OmUueCsxLGJvdHRvbTplLnktMX19fSx7a2V5OlwiZ2V0Tm9kZUF0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9IShhcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSl8fGFyZ3VtZW50c1sxXSxpPXRoaXMuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHQpLG89dGhpcy5fZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgoaSk7cmV0dXJuIG8ubGVuZ3RoPjA/ITA9PT1lP3RoaXMuYm9keS5ub2Rlc1tvW28ubGVuZ3RoLTFdXTpvW28ubGVuZ3RoLTFdOnZvaWQgMH19LHtrZXk6XCJfZ2V0RWRnZXNPdmVybGFwcGluZ1dpdGhcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgaT10aGlzLmJvZHkuZWRnZXMsbz0wO288dGhpcy5ib2R5LmVkZ2VJbmRpY2VzLmxlbmd0aDtvKyspe3ZhciBuPXRoaXMuYm9keS5lZGdlSW5kaWNlc1tvXTtpW25dLmlzT3ZlcmxhcHBpbmdXaXRoKHQpJiZlLnB1c2gobil9fX0se2tleTpcIl9nZXRBbGxFZGdlc092ZXJsYXBwaW5nV2l0aFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPVtdO3JldHVybiB0aGlzLl9nZXRFZGdlc092ZXJsYXBwaW5nV2l0aCh0LGUpLGV9fSx7a2V5OlwiZ2V0RWRnZUF0XCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV0saT10aGlzLmNhbnZhcy5ET010b0NhbnZhcyh0KSxvPTEwLG49bnVsbCxyPXRoaXMuYm9keS5lZGdlcyxzPTA7czx0aGlzLmJvZHkuZWRnZUluZGljZXMubGVuZ3RoO3MrKyl7dmFyIGE9dGhpcy5ib2R5LmVkZ2VJbmRpY2VzW3NdLGg9clthXTtpZihoLmNvbm5lY3RlZCl7dmFyIGQ9aC5mcm9tLngsbD1oLmZyb20ueSxjPWgudG8ueCx1PWgudG8ueSxmPWguZWRnZVR5cGUuZ2V0RGlzdGFuY2VUb0VkZ2UoZCxsLGMsdSxpLngsaS55KTtmPG8mJihuPWEsbz1mKX19cmV0dXJuIG51bGwhPT1uPyEwPT09ZT90aGlzLmJvZHkuZWRnZXNbbl06bjp2b2lkIDB9fSx7a2V5OlwiX2FkZFRvSG92ZXJcIix2YWx1ZTpmdW5jdGlvbih0KXt0IGluc3RhbmNlb2YgbGM/dGhpcy5ob3Zlck9iai5ub2Rlc1t0LmlkXT10OnRoaXMuaG92ZXJPYmouZWRnZXNbdC5pZF09dH19LHtrZXk6XCJfcmVtb3ZlRnJvbVNlbGVjdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlO3QgaW5zdGFuY2VvZiBsYz8odGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZGVsZXRlTm9kZXModCksKGU9dGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IpLmRlbGV0ZUVkZ2VzLmFwcGx5KGUsbG4odC5lZGdlcykpKTp0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5kZWxldGVFZGdlcyh0KX19LHtrZXk6XCJ1bnNlbGVjdEFsbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuY2xlYXIoKX19LHtrZXk6XCJnZXRTZWxlY3RlZE5vZGVDb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLnNpemVOb2Rlc319LHtrZXk6XCJnZXRTZWxlY3RlZEVkZ2VDb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLnNpemVFZGdlc319LHtrZXk6XCJfaG92ZXJDb25uZWN0ZWRFZGdlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5lZGdlcy5sZW5ndGg7ZSsrKXt2YXIgaT10LmVkZ2VzW2VdO2kuaG92ZXI9ITAsdGhpcy5fYWRkVG9Ib3ZlcihpKX19fSx7a2V5OlwiZW1pdEJsdXJFdmVudFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz10aGlzLl9pbml0QmFzZUV2ZW50KHQsZSk7ITA9PT1pLmhvdmVyJiYoaS5ob3Zlcj0hMSxpIGluc3RhbmNlb2YgbGM/KG8ubm9kZT1pLmlkLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJibHVyTm9kZVwiLG8pKTooby5lZGdlPWkuaWQsdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImJsdXJFZGdlXCIsbykpKX19LHtrZXk6XCJlbWl0SG92ZXJFdmVudFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz10aGlzLl9pbml0QmFzZUV2ZW50KHQsZSksbj0hMTtyZXR1cm4hMT09PWkuaG92ZXImJihpLmhvdmVyPSEwLHRoaXMuX2FkZFRvSG92ZXIoaSksbj0hMCxpIGluc3RhbmNlb2YgbGM/KG8ubm9kZT1pLmlkLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJob3Zlck5vZGVcIixvKSk6KG8uZWRnZT1pLmlkLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJob3ZlckVkZ2VcIixvKSkpLG59fSx7a2V5OlwiaG92ZXJPYmplY3RcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMuZ2V0Tm9kZUF0KGUpO3ZvaWQgMD09PWkmJihpPXRoaXMuZ2V0RWRnZUF0KGUpKTt2YXIgbz0hMTtmb3IodmFyIG4gaW4gdGhpcy5ob3Zlck9iai5ub2RlcylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ob3Zlck9iai5ub2RlcyxuKSYmKHZvaWQgMD09PWl8fGkgaW5zdGFuY2VvZiBsYyYmaS5pZCE9bnx8aSBpbnN0YW5jZW9mIEpjKSYmKHRoaXMuZW1pdEJsdXJFdmVudCh0LGUsdGhpcy5ob3Zlck9iai5ub2Rlc1tuXSksZGVsZXRlIHRoaXMuaG92ZXJPYmoubm9kZXNbbl0sbz0hMCk7Zm9yKHZhciByIGluIHRoaXMuaG92ZXJPYmouZWRnZXMpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuaG92ZXJPYmouZWRnZXMscikmJighMD09PW8/KHRoaXMuaG92ZXJPYmouZWRnZXNbcl0uaG92ZXI9ITEsZGVsZXRlIHRoaXMuaG92ZXJPYmouZWRnZXNbcl0pOih2b2lkIDA9PT1pfHxpIGluc3RhbmNlb2YgSmMmJmkuaWQhPXJ8fGkgaW5zdGFuY2VvZiBsYyYmIWkuaG92ZXIpJiYodGhpcy5lbWl0Qmx1ckV2ZW50KHQsZSx0aGlzLmhvdmVyT2JqLmVkZ2VzW3JdKSxkZWxldGUgdGhpcy5ob3Zlck9iai5lZGdlc1tyXSxvPSEwKSk7aWYodm9pZCAwIT09aSl7dmFyIHM9eG4odGhpcy5ob3Zlck9iai5lZGdlcykubGVuZ3RoLGE9eG4odGhpcy5ob3Zlck9iai5ub2RlcykubGVuZ3RoOyhvfHxpIGluc3RhbmNlb2YgSmMmJjA9PT1zJiYwPT09YXx8aSBpbnN0YW5jZW9mIGxjJiYwPT09cyYmMD09PWEpJiYobz10aGlzLmVtaXRIb3ZlckV2ZW50KHQsZSxpKSksaSBpbnN0YW5jZW9mIGxjJiYhMD09PXRoaXMub3B0aW9ucy5ob3ZlckNvbm5lY3RlZEVkZ2VzJiZ0aGlzLl9ob3ZlckNvbm5lY3RlZEVkZ2VzKGkpfSEwPT09byYmdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpfX0se2tleTpcImNvbW1pdFdpdGhvdXRFbWl0dGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuY29tbWl0KCl9fSx7a2V5OlwiY29tbWl0QW5kRW1pdFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9ITEsbz10aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5jb21taXQoKSxuPXtub2RlczpvLm5vZGVzLnByZXZpb3VzLGVkZ2VzOm8uZWRnZXMucHJldmlvdXN9O28uZWRnZXMuZGVsZXRlZC5sZW5ndGg+MCYmKHRoaXMuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZGVzZWxlY3RFZGdlXCIsZSx0LG4pLGk9ITApLG8ubm9kZXMuZGVsZXRlZC5sZW5ndGg+MCYmKHRoaXMuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZGVzZWxlY3ROb2RlXCIsZSx0LG4pLGk9ITApLG8ubm9kZXMuYWRkZWQubGVuZ3RoPjAmJih0aGlzLmdlbmVyYXRlQ2xpY2tFdmVudChcInNlbGVjdE5vZGVcIixlLHQpLGk9ITApLG8uZWRnZXMuYWRkZWQubGVuZ3RoPjAmJih0aGlzLmdlbmVyYXRlQ2xpY2tFdmVudChcInNlbGVjdEVkZ2VcIixlLHQpLGk9ITApLCEwPT09aSYmdGhpcy5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJzZWxlY3RcIixlLHQpfX0se2tleTpcImdldFNlbGVjdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJue25vZGVzOnRoaXMuZ2V0U2VsZWN0ZWROb2RlSWRzKCksZWRnZXM6dGhpcy5nZXRTZWxlY3RlZEVkZ2VJZHMoKX19fSx7a2V5OlwiZ2V0U2VsZWN0ZWROb2Rlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmdldE5vZGVzKCl9fSx7a2V5OlwiZ2V0U2VsZWN0ZWRFZGdlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmdldEVkZ2VzKCl9fSx7a2V5OlwiZ2V0U2VsZWN0ZWROb2RlSWRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4ga24odD10aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXROb2RlcygpKS5jYWxsKHQsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlkfSkpfX0se2tleTpcImdldFNlbGVjdGVkRWRnZUlkc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIGtuKHQ9dGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZ2V0RWRnZXMoKSkuY2FsbCh0LChmdW5jdGlvbih0KXtyZXR1cm4gdC5pZH0pKX19LHtrZXk6XCJzZXRTZWxlY3Rpb25cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e307aWYoIXR8fCF0Lm5vZGVzJiYhdC5lZGdlcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU2VsZWN0aW9uIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggbm9kZXMgYW5kL29yIGVkZ2VzIHByb3BlcnRpZXNcIik7aWYoKGUudW5zZWxlY3RBbGx8fHZvaWQgMD09PWUudW5zZWxlY3RBbGwpJiZ0aGlzLnVuc2VsZWN0QWxsKCksdC5ub2Rlcyl7dmFyIGksbz1kZih0Lm5vZGVzKTt0cnl7Zm9yKG8ucygpOyEoaT1vLm4oKSkuZG9uZTspe3ZhciBuPWkudmFsdWUscj10aGlzLmJvZHkubm9kZXNbbl07aWYoIXIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ05vZGUgd2l0aCBpZCBcIicrbisnXCIgbm90IGZvdW5kJyk7dGhpcy5zZWxlY3RPYmplY3QocixlLmhpZ2hsaWdodEVkZ2VzKX19Y2F0Y2godCl7by5lKHQpfWZpbmFsbHl7by5mKCl9fWlmKHQuZWRnZXMpe3ZhciBzLGE9ZGYodC5lZGdlcyk7dHJ5e2ZvcihhLnMoKTshKHM9YS5uKCkpLmRvbmU7KXt2YXIgaD1zLnZhbHVlLGQ9dGhpcy5ib2R5LmVkZ2VzW2hdO2lmKCFkKXRocm93IG5ldyBSYW5nZUVycm9yKCdFZGdlIHdpdGggaWQgXCInK2grJ1wiIG5vdCBmb3VuZCcpO3RoaXMuc2VsZWN0T2JqZWN0KGQpfX1jYXRjaCh0KXthLmUodCl9ZmluYWxseXthLmYoKX19dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpLHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmNvbW1pdCgpfX0se2tleTpcInNlbGVjdE5vZGVzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9IShhcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSl8fGFyZ3VtZW50c1sxXTtpZighdHx8dm9pZCAwPT09dC5sZW5ndGgpdGhyb3dcIlNlbGVjdGlvbiBtdXN0IGJlIGFuIGFycmF5IHdpdGggaWRzXCI7dGhpcy5zZXRTZWxlY3Rpb24oe25vZGVzOnR9LHtoaWdobGlnaHRFZGdlczplfSl9fSx7a2V5Olwic2VsZWN0RWRnZXNcIix2YWx1ZTpmdW5jdGlvbih0KXtpZighdHx8dm9pZCAwPT09dC5sZW5ndGgpdGhyb3dcIlNlbGVjdGlvbiBtdXN0IGJlIGFuIGFycmF5IHdpdGggaWRzXCI7dGhpcy5zZXRTZWxlY3Rpb24oe2VkZ2VzOnR9KX19LHtrZXk6XCJ1cGRhdGVTZWxlY3Rpb25cIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXROb2RlcygpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsdC5pZCl8fHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmRlbGV0ZU5vZGVzKHQpO2Zvcih2YXIgZSBpbiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXRFZGdlcygpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkuZWRnZXMsZS5pZCl8fHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmRlbGV0ZUVkZ2VzKGUpfX0se2tleTpcImdldENsaWNrZWRJdGVtc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmNhbnZhcy5ET010b0NhbnZhcyh0KSxpPVtdLG89dGhpcy5ib2R5Lm5vZGVJbmRpY2VzLG49dGhpcy5ib2R5Lm5vZGVzLHI9by5sZW5ndGgtMTtyPj0wO3ItLSl7dmFyIHM9bltvW3JdXS5nZXRJdGVtc09uUG9pbnQoZSk7aS5wdXNoLmFwcGx5KGkscyl9Zm9yKHZhciBhPXRoaXMuYm9keS5lZGdlSW5kaWNlcyxoPXRoaXMuYm9keS5lZGdlcyxkPWEubGVuZ3RoLTE7ZD49MDtkLS0pe3ZhciBsPWhbYVtkXV0uZ2V0SXRlbXNPblBvaW50KGUpO2kucHVzaC5hcHBseShpLGwpfXJldHVybiBpfX1dKSx0fSgpLHVmPVtdLGZmPXVmLnNvcnQscGY9cygoZnVuY3Rpb24oKXt1Zi5zb3J0KHZvaWQgMCl9KSksdmY9cygoZnVuY3Rpb24oKXt1Zi5zb3J0KG51bGwpfSkpLGdmPU9uKFwic29ydFwiKTtxKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDpwZnx8IXZmfHwhZ2Z9LHtzb3J0OmZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10P2ZmLmNhbGwoYXQodGhpcykpOmZmLmNhbGwoYXQodGhpcyksTih0KSl9fSk7dmFyIHlmPWd0KFwiQXJyYXlcIikuc29ydCxtZj1BcnJheS5wcm90b3R5cGUsYmY9ZnVuY3Rpb24odCl7dmFyIGU9dC5zb3J0O3JldHVybiB0PT09bWZ8fHQgaW5zdGFuY2VvZiBBcnJheSYmZT09PW1mLnNvcnQ/eWY6ZX0sd2Y9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUsaSxvLG4pe04oaSk7dmFyIHI9YXQoZSkscz12KHIpLGE9SyhyLmxlbmd0aCksaD10P2EtMTowLGQ9dD8tMToxO2lmKG88Milmb3IoOzspe2lmKGggaW4gcyl7bj1zW2hdLGgrPWQ7YnJlYWt9aWYoaCs9ZCx0P2g8MDphPD1oKXRocm93IFR5cGVFcnJvcihcIlJlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWVcIil9Zm9yKDt0P2g+PTA6YT5oO2grPWQpaCBpbiBzJiYobj1pKG4sc1toXSxoLHIpKTtyZXR1cm4gbn19LGtmPXtsZWZ0OndmKCExKSxyaWdodDp3ZighMCl9LmxlZnQsX2Y9T24oXCJyZWR1Y2VcIik7cSh7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IV9mfHwhb2UmJmZlPjc5JiZmZTw4M30se3JlZHVjZTpmdW5jdGlvbih0KXtyZXR1cm4ga2YodGhpcyx0LGFyZ3VtZW50cy5sZW5ndGgsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pO3ZhciB4Zj1ndChcIkFycmF5XCIpLnJlZHVjZSxFZj1BcnJheS5wcm90b3R5cGUsT2Y9ZnVuY3Rpb24odCl7dmFyIGU9dC5yZWR1Y2U7cmV0dXJuIHQ9PT1FZnx8dCBpbnN0YW5jZW9mIEFycmF5JiZlPT09RWYucmVkdWNlP3hmOmV9LENmPW8oKGZ1bmN0aW9uKHQsZSl7IWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfXQuX19lc01vZHVsZT0hMCx0LnNvcnQ9djt2YXIgaT0zMixvPTcsbj0yNTYscj1bMSwxMCwxMDAsMWUzLDFlNCwxZTUsMWU2LDFlNywxZTgsMWU5XTtmdW5jdGlvbiBzKHQpe3JldHVybiB0PDFlNT90PDEwMD90PDEwPzA6MTp0PDFlND90PDFlMz8yOjM6NDp0PDFlNz90PDFlNj81OjY6dDwxZTk/dDwxZTg/Nzo4Ojl9ZnVuY3Rpb24gYSh0LGUpe2lmKHQ9PT1lKXJldHVybiAwO2lmKH5+dD09PXQmJn5+ZT09PWUpe2lmKDA9PT10fHwwPT09ZSlyZXR1cm4gdDxlPy0xOjE7aWYodDwwfHxlPDApe2lmKGU+PTApcmV0dXJuLTE7aWYodD49MClyZXR1cm4gMTt0PS10LGU9LWV9dmFyIGk9cyh0KSxvPXMoZSksbj0wO3JldHVybiBpPG8/KHQqPXJbby1pLTFdLGUvPTEwLG49LTEpOmk+byYmKGUqPXJbaS1vLTFdLHQvPTEwLG49MSksdD09PWU/bjp0PGU/LTE6MX12YXIgYT1TdHJpbmcodCksaD1TdHJpbmcoZSk7cmV0dXJuIGE9PT1oPzA6YTxoPy0xOjF9ZnVuY3Rpb24gaCh0KXtmb3IodmFyIGU9MDt0Pj1pOyllfD0xJnQsdD4+PTE7cmV0dXJuIHQrZX1mdW5jdGlvbiBkKHQsZSxpLG8pe3ZhciBuPWUrMTtpZihuPT09aSlyZXR1cm4gMTtpZihvKHRbbisrXSx0W2VdKTwwKXtmb3IoO248aSYmbyh0W25dLHRbbi0xXSk8MDspbisrO2wodCxlLG4pfWVsc2UgZm9yKDtuPGkmJm8odFtuXSx0W24tMV0pPj0wOyluKys7cmV0dXJuIG4tZX1mdW5jdGlvbiBsKHQsZSxpKXtmb3IoaS0tO2U8aTspe3ZhciBvPXRbZV07dFtlKytdPXRbaV0sdFtpLS1dPW99fWZ1bmN0aW9uIGModCxlLGksbyxuKXtmb3Iobz09PWUmJm8rKztvPGk7bysrKXtmb3IodmFyIHI9dFtvXSxzPWUsYT1vO3M8YTspe3ZhciBoPXMrYT4+PjE7bihyLHRbaF0pPDA/YT1oOnM9aCsxfXZhciBkPW8tcztzd2l0Y2goZCl7Y2FzZSAzOnRbcyszXT10W3MrMl07Y2FzZSAyOnRbcysyXT10W3MrMV07Y2FzZSAxOnRbcysxXT10W3NdO2JyZWFrO2RlZmF1bHQ6Zm9yKDtkPjA7KXRbcytkXT10W3MrZC0xXSxkLS19dFtzXT1yfX1mdW5jdGlvbiB1KHQsZSxpLG8sbixyKXt2YXIgcz0wLGE9MCxoPTE7aWYocih0LGVbaStuXSk+MCl7Zm9yKGE9by1uO2g8YSYmcih0LGVbaStuK2hdKT4wOylzPWgsKGg9MSsoaDw8MSkpPD0wJiYoaD1hKTtoPmEmJihoPWEpLHMrPW4saCs9bn1lbHNle2ZvcihhPW4rMTtoPGEmJnIodCxlW2krbi1oXSk8PTA7KXM9aCwoaD0xKyhoPDwxKSk8PTAmJihoPWEpO2g+YSYmKGg9YSk7dmFyIGQ9cztzPW4taCxoPW4tZH1mb3IocysrO3M8aDspe3ZhciBsPXMrKGgtcz4+PjEpO3IodCxlW2krbF0pPjA/cz1sKzE6aD1sfXJldHVybiBofWZ1bmN0aW9uIGYodCxlLGksbyxuLHIpe3ZhciBzPTAsYT0wLGg9MTtpZihyKHQsZVtpK25dKTwwKXtmb3IoYT1uKzE7aDxhJiZyKHQsZVtpK24taF0pPDA7KXM9aCwoaD0xKyhoPDwxKSk8PTAmJihoPWEpO2g+YSYmKGg9YSk7dmFyIGQ9cztzPW4taCxoPW4tZH1lbHNle2ZvcihhPW8tbjtoPGEmJnIodCxlW2krbitoXSk+PTA7KXM9aCwoaD0xKyhoPDwxKSk8PTAmJihoPWEpO2g+YSYmKGg9YSkscys9bixoKz1ufWZvcihzKys7czxoOyl7dmFyIGw9cysoaC1zPj4+MSk7cih0LGVbaStsXSk8MD9oPWw6cz1sKzF9cmV0dXJuIGh9dmFyIHA9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGkscil7ZSh0aGlzLHQpLHRoaXMuYXJyYXk9bnVsbCx0aGlzLmNvbXBhcmU9bnVsbCx0aGlzLm1pbkdhbGxvcD1vLHRoaXMubGVuZ3RoPTAsdGhpcy50bXBTdG9yYWdlTGVuZ3RoPW4sdGhpcy5zdGFja0xlbmd0aD0wLHRoaXMucnVuU3RhcnQ9bnVsbCx0aGlzLnJ1bkxlbmd0aD1udWxsLHRoaXMuc3RhY2tTaXplPTAsdGhpcy5hcnJheT1pLHRoaXMuY29tcGFyZT1yLHRoaXMubGVuZ3RoPWkubGVuZ3RoLHRoaXMubGVuZ3RoPDIqbiYmKHRoaXMudG1wU3RvcmFnZUxlbmd0aD10aGlzLmxlbmd0aD4+PjEpLHRoaXMudG1wPW5ldyBBcnJheSh0aGlzLnRtcFN0b3JhZ2VMZW5ndGgpLHRoaXMuc3RhY2tMZW5ndGg9dGhpcy5sZW5ndGg8MTIwPzU6dGhpcy5sZW5ndGg8MTU0Mj8xMDp0aGlzLmxlbmd0aDwxMTkxNTE/MTk6NDAsdGhpcy5ydW5TdGFydD1uZXcgQXJyYXkodGhpcy5zdGFja0xlbmd0aCksdGhpcy5ydW5MZW5ndGg9bmV3IEFycmF5KHRoaXMuc3RhY2tMZW5ndGgpfXJldHVybiB0LnByb3RvdHlwZS5wdXNoUnVuPWZ1bmN0aW9uKHQsZSl7dGhpcy5ydW5TdGFydFt0aGlzLnN0YWNrU2l6ZV09dCx0aGlzLnJ1bkxlbmd0aFt0aGlzLnN0YWNrU2l6ZV09ZSx0aGlzLnN0YWNrU2l6ZSs9MX0sdC5wcm90b3R5cGUubWVyZ2VSdW5zPWZ1bmN0aW9uKCl7Zm9yKDt0aGlzLnN0YWNrU2l6ZT4xOyl7dmFyIHQ9dGhpcy5zdGFja1NpemUtMjtpZih0Pj0xJiZ0aGlzLnJ1bkxlbmd0aFt0LTFdPD10aGlzLnJ1bkxlbmd0aFt0XSt0aGlzLnJ1bkxlbmd0aFt0KzFdfHx0Pj0yJiZ0aGlzLnJ1bkxlbmd0aFt0LTJdPD10aGlzLnJ1bkxlbmd0aFt0XSt0aGlzLnJ1bkxlbmd0aFt0LTFdKXRoaXMucnVuTGVuZ3RoW3QtMV08dGhpcy5ydW5MZW5ndGhbdCsxXSYmdC0tO2Vsc2UgaWYodGhpcy5ydW5MZW5ndGhbdF0+dGhpcy5ydW5MZW5ndGhbdCsxXSlicmVhazt0aGlzLm1lcmdlQXQodCl9fSx0LnByb3RvdHlwZS5mb3JjZU1lcmdlUnVucz1mdW5jdGlvbigpe2Zvcig7dGhpcy5zdGFja1NpemU+MTspe3ZhciB0PXRoaXMuc3RhY2tTaXplLTI7dD4wJiZ0aGlzLnJ1bkxlbmd0aFt0LTFdPHRoaXMucnVuTGVuZ3RoW3QrMV0mJnQtLSx0aGlzLm1lcmdlQXQodCl9fSx0LnByb3RvdHlwZS5tZXJnZUF0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuY29tcGFyZSxpPXRoaXMuYXJyYXksbz10aGlzLnJ1blN0YXJ0W3RdLG49dGhpcy5ydW5MZW5ndGhbdF0scj10aGlzLnJ1blN0YXJ0W3QrMV0scz10aGlzLnJ1bkxlbmd0aFt0KzFdO3RoaXMucnVuTGVuZ3RoW3RdPW4rcyx0PT09dGhpcy5zdGFja1NpemUtMyYmKHRoaXMucnVuU3RhcnRbdCsxXT10aGlzLnJ1blN0YXJ0W3QrMl0sdGhpcy5ydW5MZW5ndGhbdCsxXT10aGlzLnJ1bkxlbmd0aFt0KzJdKSx0aGlzLnN0YWNrU2l6ZS0tO3ZhciBhPWYoaVtyXSxpLG8sbiwwLGUpO28rPWEsMCE9KG4tPWEpJiYwIT09KHM9dShpW28rbi0xXSxpLHIscyxzLTEsZSkpJiYobjw9cz90aGlzLm1lcmdlTG93KG8sbixyLHMpOnRoaXMubWVyZ2VIaWdoKG8sbixyLHMpKX0sdC5wcm90b3R5cGUubWVyZ2VMb3c9ZnVuY3Rpb24odCxlLGksbil7dmFyIHI9dGhpcy5jb21wYXJlLHM9dGhpcy5hcnJheSxhPXRoaXMudG1wLGg9MDtmb3IoaD0wO2g8ZTtoKyspYVtoXT1zW3QraF07dmFyIGQ9MCxsPWksYz10O2lmKHNbYysrXT1zW2wrK10sMCE9LS1uKWlmKDEhPT1lKXtmb3IodmFyIHA9dGhpcy5taW5HYWxsb3A7Oyl7dmFyIHY9MCxnPTAseT0hMTtkb3tpZihyKHNbbF0sYVtkXSk8MCl7aWYoc1tjKytdPXNbbCsrXSxnKyssdj0wLDA9PS0tbil7eT0hMDticmVha319ZWxzZSBpZihzW2MrK109YVtkKytdLHYrKyxnPTAsMT09LS1lKXt5PSEwO2JyZWFrfX13aGlsZSgodnxnKTxwKTtpZih5KWJyZWFrO2Rve2lmKDAhPT0odj1mKHNbbF0sYSxkLGUsMCxyKSkpe2ZvcihoPTA7aDx2O2grKylzW2MraF09YVtkK2hdO2lmKGMrPXYsZCs9diwoZS09dik8PTEpe3k9ITA7YnJlYWt9fWlmKHNbYysrXT1zW2wrK10sMD09LS1uKXt5PSEwO2JyZWFrfWlmKDAhPT0oZz11KGFbZF0scyxsLG4sMCxyKSkpe2ZvcihoPTA7aDxnO2grKylzW2MraF09c1tsK2hdO2lmKGMrPWcsbCs9ZywwPT0obi09Zykpe3k9ITA7YnJlYWt9fWlmKHNbYysrXT1hW2QrK10sMT09LS1lKXt5PSEwO2JyZWFrfXAtLX13aGlsZSh2Pj1vfHxnPj1vKTtpZih5KWJyZWFrO3A8MCYmKHA9MCkscCs9Mn1pZih0aGlzLm1pbkdhbGxvcD1wLHA8MSYmKHRoaXMubWluR2FsbG9wPTEpLDE9PT1lKXtmb3IoaD0wO2g8bjtoKyspc1tjK2hdPXNbbCtoXTtzW2Mrbl09YVtkXX1lbHNle2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIm1lcmdlTG93IHByZWNvbmRpdGlvbnMgd2VyZSBub3QgcmVzcGVjdGVkXCIpO2ZvcihoPTA7aDxlO2grKylzW2MraF09YVtkK2hdfX1lbHNle2ZvcihoPTA7aDxuO2grKylzW2MraF09c1tsK2hdO3NbYytuXT1hW2RdfWVsc2UgZm9yKGg9MDtoPGU7aCsrKXNbYytoXT1hW2QraF19LHQucHJvdG90eXBlLm1lcmdlSGlnaD1mdW5jdGlvbih0LGUsaSxuKXt2YXIgcj10aGlzLmNvbXBhcmUscz10aGlzLmFycmF5LGE9dGhpcy50bXAsaD0wO2ZvcihoPTA7aDxuO2grKylhW2hdPXNbaStoXTt2YXIgZD10K2UtMSxsPW4tMSxjPWkrbi0xLHA9MCx2PTA7aWYoc1tjLS1dPXNbZC0tXSwwIT0tLWUpaWYoMSE9PW4pe2Zvcih2YXIgZz10aGlzLm1pbkdhbGxvcDs7KXt2YXIgeT0wLG09MCxiPSExO2Rve2lmKHIoYVtsXSxzW2RdKTwwKXtpZihzW2MtLV09c1tkLS1dLHkrKyxtPTAsMD09LS1lKXtiPSEwO2JyZWFrfX1lbHNlIGlmKHNbYy0tXT1hW2wtLV0sbSsrLHk9MCwxPT0tLW4pe2I9ITA7YnJlYWt9fXdoaWxlKCh5fG0pPGcpO2lmKGIpYnJlYWs7ZG97aWYoMCE9KHk9ZS1mKGFbbF0scyx0LGUsZS0xLHIpKSl7Zm9yKGUtPXksdj0xKyhjLT15KSxwPTErKGQtPXkpLGg9eS0xO2g+PTA7aC0tKXNbditoXT1zW3AraF07aWYoMD09PWUpe2I9ITA7YnJlYWt9fWlmKHNbYy0tXT1hW2wtLV0sMT09LS1uKXtiPSEwO2JyZWFrfWlmKDAhPShtPW4tdShzW2RdLGEsMCxuLG4tMSxyKSkpe2ZvcihuLT1tLHY9MSsoYy09bSkscD0xKyhsLT1tKSxoPTA7aDxtO2grKylzW3YraF09YVtwK2hdO2lmKG48PTEpe2I9ITA7YnJlYWt9fWlmKHNbYy0tXT1zW2QtLV0sMD09LS1lKXtiPSEwO2JyZWFrfWctLX13aGlsZSh5Pj1vfHxtPj1vKTtpZihiKWJyZWFrO2c8MCYmKGc9MCksZys9Mn1pZih0aGlzLm1pbkdhbGxvcD1nLGc8MSYmKHRoaXMubWluR2FsbG9wPTEpLDE9PT1uKXtmb3Iodj0xKyhjLT1lKSxwPTErKGQtPWUpLGg9ZS0xO2g+PTA7aC0tKXNbditoXT1zW3AraF07c1tjXT1hW2xdfWVsc2V7aWYoMD09PW4pdGhyb3cgbmV3IEVycm9yKFwibWVyZ2VIaWdoIHByZWNvbmRpdGlvbnMgd2VyZSBub3QgcmVzcGVjdGVkXCIpO2ZvcihwPWMtKG4tMSksaD0wO2g8bjtoKyspc1twK2hdPWFbaF19fWVsc2V7Zm9yKHY9MSsoYy09ZSkscD0xKyhkLT1lKSxoPWUtMTtoPj0wO2gtLSlzW3YraF09c1twK2hdO3NbY109YVtsXX1lbHNlIGZvcihwPWMtKG4tMSksaD0wO2g8bjtoKyspc1twK2hdPWFbaF19LHR9KCk7ZnVuY3Rpb24gdih0LGUsbyxuKXtpZighQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG9ubHkgc29ydCBhcnJheXNcIik7ZT9cImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiYobj1vLG89ZSxlPWEpOmU9YSxvfHwobz0wKSxufHwobj10Lmxlbmd0aCk7dmFyIHI9bi1vO2lmKCEocjwyKSl7dmFyIHM9MDtpZihyPGkpYyh0LG8sbixvKyhzPWQodCxvLG4sZSkpLGUpO2Vsc2V7dmFyIGw9bmV3IHAodCxlKSx1PWgocik7ZG97aWYoKHM9ZCh0LG8sbixlKSk8dSl7dmFyIGY9cjtmPnUmJihmPXUpLGModCxvLG8rZixvK3MsZSkscz1mfWwucHVzaFJ1bihvLHMpLGwubWVyZ2VSdW5zKCksci09cyxvKz1zfXdoaWxlKDAhPT1yKTtsLmZvcmNlTWVyZ2VSdW5zKCl9fX19KGUpfSkpO2Z1bmN0aW9uIFNmKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIFRmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCl9cmV0dXJuIElvKHQsW3trZXk6XCJhYnN0cmFjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgaW5zdGFudGlhdGUgYWJzdHJhY3QgY2xhc3MhXCIpfX0se2tleTpcImZha2VfdXNlXCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwiY3VydmVUeXBlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hYnN0cmFjdCgpfX0se2tleTpcImdldFBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmFrZV91c2UodCksdGhpcy5hYnN0cmFjdCgpfX0se2tleTpcInNldFBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dm9pZCAwO3RoaXMuZmFrZV91c2UodCxlLGkpLHRoaXMuYWJzdHJhY3QoKX19LHtrZXk6XCJnZXRUcmVlU2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZha2VfdXNlKHQpLHRoaXMuYWJzdHJhY3QoKX19LHtrZXk6XCJzb3J0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5mYWtlX3VzZSh0KSx0aGlzLmFic3RyYWN0KCl9fSx7a2V5OlwiZml4XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLmZha2VfdXNlKHQsZSksdGhpcy5hYnN0cmFjdCgpfX0se2tleTpcInNoaWZ0XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLmZha2VfdXNlKHQsZSksdGhpcy5hYnN0cmFjdCgpfX1dKSx0fSgpLE1mPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9U2YoaSk7ZnVuY3Rpb24gaSh0KXt2YXIgbztyZXR1cm4gUG8odGhpcyxpKSwobz1lLmNhbGwodGhpcykpLmxheW91dD10LG99cmV0dXJuIElvKGksW3trZXk6XCJjdXJ2ZVR5cGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVyblwiaG9yaXpvbnRhbFwifX0se2tleTpcImdldFBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHQueH19LHtrZXk6XCJzZXRQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnZvaWQgMDt2b2lkIDAhPT1pJiZ0aGlzLmxheW91dC5oaWVyYXJjaGljYWwuYWRkVG9PcmRlcmluZyh0LGkpLHQueD1lfX0se2tleTpcImdldFRyZWVTaXplXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5sYXlvdXQuaGllcmFyY2hpY2FsLmdldFRyZWVTaXplKHRoaXMubGF5b3V0LmJvZHkubm9kZXMsdCk7cmV0dXJue21pbjplLm1pbl94LG1heDplLm1heF94fX19LHtrZXk6XCJzb3J0XCIsdmFsdWU6ZnVuY3Rpb24odCl7Q2Yuc29ydCh0LChmdW5jdGlvbih0LGUpe3JldHVybiB0LngtZS54fSkpfX0se2tleTpcImZpeFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dC55PXRoaXMubGF5b3V0Lm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiplLHQub3B0aW9ucy5maXhlZC55PSEwfX0se2tleTpcInNoaWZ0XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLmxheW91dC5ib2R5Lm5vZGVzW3RdLngrPWV9fV0pLGl9KFRmKSxQZj1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPVNmKGkpO2Z1bmN0aW9uIGkodCl7dmFyIG87cmV0dXJuIFBvKHRoaXMsaSksKG89ZS5jYWxsKHRoaXMpKS5sYXlvdXQ9dCxvfXJldHVybiBJbyhpLFt7a2V5OlwiY3VydmVUeXBlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm5cInZlcnRpY2FsXCJ9fSx7a2V5OlwiZ2V0UG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdC55fX0se2tleTpcInNldFBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dm9pZCAwO3ZvaWQgMCE9PWkmJnRoaXMubGF5b3V0LmhpZXJhcmNoaWNhbC5hZGRUb09yZGVyaW5nKHQsaSksdC55PWV9fSx7a2V5OlwiZ2V0VHJlZVNpemVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmxheW91dC5oaWVyYXJjaGljYWwuZ2V0VHJlZVNpemUodGhpcy5sYXlvdXQuYm9keS5ub2Rlcyx0KTtyZXR1cm57bWluOmUubWluX3ksbWF4OmUubWF4X3l9fX0se2tleTpcInNvcnRcIix2YWx1ZTpmdW5jdGlvbih0KXtDZi5zb3J0KHQsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQueS1lLnl9KSl9fSx7a2V5OlwiZml4XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0Lng9dGhpcy5sYXlvdXQub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uKmUsdC5vcHRpb25zLmZpeGVkLng9ITB9fSx7a2V5Olwic2hpZnRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3RoaXMubGF5b3V0LmJvZHkubm9kZXNbdF0ueSs9ZX19XSksaX0oVGYpLERmPVdpLmV2ZXJ5LEJmPU9uKFwiZXZlcnlcIik7cSh7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IUJmfSx7ZXZlcnk6ZnVuY3Rpb24odCl7cmV0dXJuIERmKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSk7dmFyIElmPWd0KFwiQXJyYXlcIikuZXZlcnksemY9QXJyYXkucHJvdG90eXBlLEZmPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZXZlcnk7cmV0dXJuIHQ9PT16Znx8dCBpbnN0YW5jZW9mIEFycmF5JiZlPT09emYuZXZlcnk/SWY6ZX07ZnVuY3Rpb24gTmYodCxlKXt2YXIgaTtpZih2b2lkIDA9PT1jbnx8bnVsbD09Q2kodCkpe2lmKGduKHQpfHwoaT1mdW5jdGlvbih0LGUpe3ZhciBpO2lmKCF0KXJldHVybjtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gQWYodCxlKTt2YXIgbz12bihpPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkuY2FsbChpLDgsLTEpO1wiT2JqZWN0XCI9PT1vJiZ0LmNvbnN0cnVjdG9yJiYobz10LmNvbnN0cnVjdG9yLm5hbWUpO2lmKFwiTWFwXCI9PT1vfHxcIlNldFwiPT09bylyZXR1cm4gbWkodCk7aWYoXCJBcmd1bWVudHNcIj09PW98fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG8pKXJldHVybiBBZih0LGUpfSh0KSl8fGUmJnQmJlwibnVtYmVyXCI9PXR5cGVvZiB0Lmxlbmd0aCl7aSYmKHQ9aSk7dmFyIG89MCxuPWZ1bmN0aW9uKCl7fTtyZXR1cm57czpuLG46ZnVuY3Rpb24oKXtyZXR1cm4gbz49dC5sZW5ndGg/e2RvbmU6ITB9Ontkb25lOiExLHZhbHVlOnRbbysrXX19LGU6ZnVuY3Rpb24odCl7dGhyb3cgdH0sZjpufX10aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9dmFyIHIscz0hMCxhPSExO3JldHVybntzOmZ1bmN0aW9uKCl7aT1TaSh0KX0sbjpmdW5jdGlvbigpe3ZhciB0PWkubmV4dCgpO3JldHVybiBzPXQuZG9uZSx0fSxlOmZ1bmN0aW9uKHQpe2E9ITAscj10fSxmOmZ1bmN0aW9uKCl7dHJ5e3N8fG51bGw9PWkucmV0dXJufHxpLnJldHVybigpfWZpbmFsbHl7aWYoYSl0aHJvdyByfX19fWZ1bmN0aW9uIEFmKHQsZSl7KG51bGw9PWV8fGU+dC5sZW5ndGgpJiYoZT10Lmxlbmd0aCk7Zm9yKHZhciBpPTAsbz1uZXcgQXJyYXkoZSk7aTxlO2krKylvW2ldPXRbaV07cmV0dXJuIG99ZnVuY3Rpb24gUmYodCxlKXt2YXIgaT1uZXcgUnU7cmV0dXJuIERuKHQpLmNhbGwodCwoZnVuY3Rpb24odCl7dmFyIGU7RG4oZT10LmVkZ2VzKS5jYWxsKGUsKGZ1bmN0aW9uKHQpe3QuY29ubmVjdGVkJiZpLmFkZCh0KX0pKX0pKSxEbihpKS5jYWxsKGksKGZ1bmN0aW9uKHQpe3ZhciBpPXQuZnJvbS5pZCxvPXQudG8uaWQ7bnVsbD09ZVtpXSYmKGVbaV09MCksKG51bGw9PWVbb118fGVbaV0+PWVbb10pJiYoZVtvXT1lW2ldKzEpfSkpLGV9ZnVuY3Rpb24gamYodCxlLGksbyl7dmFyIG4scixzPUlyKG51bGwpLGE9T2Yobj1sbihubChvKS5jYWxsKG8pKSkuY2FsbChuLChmdW5jdGlvbih0LGUpe3JldHVybiB0KzErZS5lZGdlcy5sZW5ndGh9KSwwKSxoPWkrXCJJZFwiLGQ9XCJ0b1wiPT09aT8xOi0xLGw9TmYobyk7dHJ5e3ZhciBjPWZ1bmN0aW9uKCl7dmFyIG49YW4oci52YWx1ZSwyKSxsPW5bMF0sYz1uWzFdO2lmKCFvLmhhcyhsKXx8IXQoYykpcmV0dXJuXCJjb250aW51ZVwiO3NbbF09MDtmb3IodmFyIHU9W2NdLGY9MCxwPXZvaWQgMCx2PWZ1bmN0aW9uKCl7dmFyIHQsbjtpZighby5oYXMobCkpcmV0dXJuXCJjb250aW51ZVwiO3ZhciByPXNbcC5pZF0rZDtpZihEbih0PWFyKG49cC5lZGdlcykuY2FsbChuLChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb25uZWN0ZWQmJnQudG8hPT10LmZyb20mJnRbaV0hPT1wJiZvLmhhcyh0LnRvSWQpJiZvLmhhcyh0LmZyb21JZCl9KSkpLmNhbGwodCwoZnVuY3Rpb24odCl7dmFyIG89dFtoXSxuPXNbb107KG51bGw9PW58fGUocixuKSkmJihzW29dPXIsdS5wdXNoKHRbaV0pKX0pKSxmPmEpcmV0dXJue3Y6e3Y6UmYobyxzKX19OysrZn07cD11LnBvcCgpOyl7dmFyIGc9digpO2lmKFwiY29udGludWVcIiE9PWcmJlwib2JqZWN0XCI9PT1kbihnKSlyZXR1cm4gZy52fX07Zm9yKGwucygpOyEocj1sLm4oKSkuZG9uZTspe3ZhciB1PWMoKTtpZihcImNvbnRpbnVlXCIhPT11JiZcIm9iamVjdFwiPT09ZG4odSkpcmV0dXJuIHUudn19Y2F0Y2godCl7bC5lKHQpfWZpbmFsbHl7bC5mKCl9cmV0dXJuIHN9dmFyIExmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCksdGhpcy5jaGlsZHJlblJlZmVyZW5jZT17fSx0aGlzLnBhcmVudFJlZmVyZW5jZT17fSx0aGlzLnRyZWVzPXt9LHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmc9e30sdGhpcy5sZXZlbHM9e30sdGhpcy5kaXN0cmlidXRpb25JbmRleD17fSx0aGlzLmlzVHJlZT0hMSx0aGlzLnRyZWVJbmRleD0tMX1yZXR1cm4gSW8odCxbe2tleTpcImFkZFJlbGF0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT10aGlzLmNoaWxkcmVuUmVmZXJlbmNlW3RdJiYodGhpcy5jaGlsZHJlblJlZmVyZW5jZVt0XT1bXSksdGhpcy5jaGlsZHJlblJlZmVyZW5jZVt0XS5wdXNoKGUpLHZvaWQgMD09PXRoaXMucGFyZW50UmVmZXJlbmNlW2VdJiYodGhpcy5wYXJlbnRSZWZlcmVuY2VbZV09W10pLHRoaXMucGFyZW50UmVmZXJlbmNlW2VdLnB1c2godCl9fSx7a2V5OlwiY2hlY2tJZlRyZWVcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLnBhcmVudFJlZmVyZW5jZSlpZih0aGlzLnBhcmVudFJlZmVyZW5jZVt0XS5sZW5ndGg+MSlyZXR1cm4gdm9pZCh0aGlzLmlzVHJlZT0hMSk7dGhpcy5pc1RyZWU9ITB9fSx7a2V5OlwibnVtVHJlZXNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyZWVJbmRleCsxfX0se2tleTpcInNldFRyZWVJbmRleFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dm9pZCAwIT09ZSYmdm9pZCAwPT09dGhpcy50cmVlc1t0LmlkXSYmKHRoaXMudHJlZXNbdC5pZF09ZSx0aGlzLnRyZWVJbmRleD1NYXRoLm1heChlLHRoaXMudHJlZUluZGV4KSl9fSx7a2V5OlwiZW5zdXJlTGV2ZWxcIix2YWx1ZTpmdW5jdGlvbih0KXt2b2lkIDA9PT10aGlzLmxldmVsc1t0XSYmKHRoaXMubGV2ZWxzW3RdPTApfX0se2tleTpcImdldE1heExldmVsXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxpPXt9O3JldHVybiBmdW5jdGlvbiB0KG8pe2lmKHZvaWQgMCE9PWlbb10pcmV0dXJuIGlbb107dmFyIG49ZS5sZXZlbHNbb107aWYoZS5jaGlsZHJlblJlZmVyZW5jZVtvXSl7dmFyIHI9ZS5jaGlsZHJlblJlZmVyZW5jZVtvXTtpZihyLmxlbmd0aD4wKWZvcih2YXIgcz0wO3M8ci5sZW5ndGg7cysrKW49TWF0aC5tYXgobix0KHJbc10pKX1yZXR1cm4gaVtvXT1uLG59KHQpfX0se2tleTpcImxldmVsRG93bnN0cmVhbVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09dGhpcy5sZXZlbHNbZS5pZF0mJih2b2lkIDA9PT10aGlzLmxldmVsc1t0LmlkXSYmKHRoaXMubGV2ZWxzW3QuaWRdPTApLHRoaXMubGV2ZWxzW2UuaWRdPXRoaXMubGV2ZWxzW3QuaWRdKzEpfX0se2tleTpcInNldE1pbkxldmVsVG9aZXJvXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9MWU5O2Zvcih2YXIgaSBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGkpJiZ2b2lkIDAhPT10aGlzLmxldmVsc1tpXSYmKGU9TWF0aC5taW4odGhpcy5sZXZlbHNbaV0sZSkpO2Zvcih2YXIgbyBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG8pJiZ2b2lkIDAhPT10aGlzLmxldmVsc1tvXSYmKHRoaXMubGV2ZWxzW29dLT1lKX19LHtrZXk6XCJnZXRUcmVlU2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9MWU5LG89LTFlOSxuPTFlOSxyPS0xZTk7Zm9yKHZhciBzIGluIHRoaXMudHJlZXMpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMudHJlZXMscykmJnRoaXMudHJlZXNbc109PT1lKXt2YXIgYT10W3NdO2k9TWF0aC5taW4oYS54LGkpLG89TWF0aC5tYXgoYS54LG8pLG49TWF0aC5taW4oYS55LG4pLHI9TWF0aC5tYXgoYS55LHIpfXJldHVybnttaW5feDppLG1heF94Om8sbWluX3k6bixtYXhfeTpyfX19LHtrZXk6XCJoYXNTYW1lUGFyZW50XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLnBhcmVudFJlZmVyZW5jZVt0LmlkXSxvPXRoaXMucGFyZW50UmVmZXJlbmNlW2UuaWRdO2lmKHZvaWQgMD09PWl8fHZvaWQgMD09PW8pcmV0dXJuITE7Zm9yKHZhciBuPTA7bjxpLmxlbmd0aDtuKyspZm9yKHZhciByPTA7cjxvLmxlbmd0aDtyKyspaWYoaVtuXT09b1tyXSlyZXR1cm4hMDtyZXR1cm4hMX19LHtrZXk6XCJpblNhbWVTdWJOZXR3b3JrXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50cmVlc1t0LmlkXT09PXRoaXMudHJlZXNbZS5pZF19fSx7a2V5OlwiZ2V0TGV2ZWxzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4geG4odGhpcy5kaXN0cmlidXRpb25PcmRlcmluZyl9fSx7a2V5OlwiYWRkVG9PcmRlcmluZ1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09dGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tlXSYmKHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbZV09W10pO3ZhciBpPSExLG89dGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tlXTtmb3IodmFyIG4gaW4gbylpZihvW25dPT09dCl7aT0hMDticmVha31pfHwodGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tlXS5wdXNoKHQpLHRoaXMuZGlzdHJpYnV0aW9uSW5kZXhbdC5pZF09dGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tlXS5sZW5ndGgtMSl9fV0pLHR9KCksSGY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe1BvKHRoaXMsdCksdGhpcy5ib2R5PWUsdGhpcy5fcmVzZXRSTkcoTWF0aC5yYW5kb20oKStcIjpcIitFbigpKSx0aGlzLnNldFBoeXNpY3M9ITEsdGhpcy5vcHRpb25zPXt9LHRoaXMub3B0aW9uc0JhY2t1cD17cGh5c2ljczp7fX0sdGhpcy5kZWZhdWx0T3B0aW9ucz17cmFuZG9tU2VlZDp2b2lkIDAsaW1wcm92ZWRMYXlvdXQ6ITAsY2x1c3RlclRocmVzaG9sZDoxNTAsaGllcmFyY2hpY2FsOntlbmFibGVkOiExLGxldmVsU2VwYXJhdGlvbjoxNTAsbm9kZVNwYWNpbmc6MTAwLHRyZWVTcGFjaW5nOjIwMCxibG9ja1NoaWZ0aW5nOiEwLGVkZ2VNaW5pbWl6YXRpb246ITAscGFyZW50Q2VudHJhbGl6YXRpb246ITAsZGlyZWN0aW9uOlwiVURcIixzb3J0TWV0aG9kOlwiaHVic2l6ZVwifX0sY3QodGhpcy5vcHRpb25zLHRoaXMuZGVmYXVsdE9wdGlvbnMpLHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCl9cmV0dXJuIElvKHQsW3trZXk6XCJiaW5kRXZlbnRMaXN0ZW5lcnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIiwoZnVuY3Rpb24oKXt0LnNldHVwSGllcmFyY2hpY2FsTGF5b3V0KCl9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUxvYWRlZFwiLChmdW5jdGlvbigpe3QubGF5b3V0TmV0d29yaygpfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3Jlc2V0SGllcmFyY2hpY2FsTGF5b3V0XCIsKGZ1bmN0aW9uKCl7dC5zZXR1cEhpZXJhcmNoaWNhbExheW91dCgpfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2FkanVzdEVkZ2VzRm9ySGllcmFyY2hpY2FsTGF5b3V0XCIsKGZ1bmN0aW9uKCl7aWYoITA9PT10Lm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQpe3ZhciBlPXQuZGlyZWN0aW9uLmN1cnZlVHlwZSgpO3QuYm9keS5lbWl0dGVyLmVtaXQoXCJfZm9yY2VEaXNhYmxlRHluYW1pY0N1cnZlc1wiLGUsITEpfX0pKX19LHtrZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZih2b2lkIDAhPT10KXt2YXIgaT10aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLG89aS5lbmFibGVkO2lmKFphKFtcInJhbmRvbVNlZWRcIixcImltcHJvdmVkTGF5b3V0XCIsXCJjbHVzdGVyVGhyZXNob2xkXCJdLHRoaXMub3B0aW9ucyx0KSxnaCh0aGlzLm9wdGlvbnMsdCxcImhpZXJhcmNoaWNhbFwiKSx2b2lkIDAhPT10LnJhbmRvbVNlZWQmJnRoaXMuX3Jlc2V0Uk5HKHQucmFuZG9tU2VlZCksITA9PT1pLmVuYWJsZWQpcmV0dXJuITA9PT1vJiZ0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVmcmVzaFwiLCEwKSxcIlJMXCI9PT1pLmRpcmVjdGlvbnx8XCJEVVwiPT09aS5kaXJlY3Rpb24/aS5sZXZlbFNlcGFyYXRpb24+MCYmKGkubGV2ZWxTZXBhcmF0aW9uKj0tMSk6aS5sZXZlbFNlcGFyYXRpb248MCYmKGkubGV2ZWxTZXBhcmF0aW9uKj0tMSksdGhpcy5zZXREaXJlY3Rpb25TdHJhdGVneSgpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzZXRIaWVyYXJjaGljYWxMYXlvdXRcIiksdGhpcy5hZGFwdEFsbE9wdGlvbnNGb3JIaWVyYXJjaGljYWxMYXlvdXQoZSk7aWYoITA9PT1vKXJldHVybiB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVmcmVzaFwiKSx0aChlLHRoaXMub3B0aW9uc0JhY2t1cCl9cmV0dXJuIGV9fSx7a2V5OlwiX3Jlc2V0Uk5HXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5pbml0aWFsUmFuZG9tU2VlZD10LHRoaXMuX3JuZz1SYSh0aGlzLmluaXRpYWxSYW5kb21TZWVkKX19LHtrZXk6XCJhZGFwdEFsbE9wdGlvbnNGb3JIaWVyYXJjaGljYWxMYXlvdXRcIix2YWx1ZTpmdW5jdGlvbih0KXtpZighMD09PXRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCl7dmFyIGU9dGhpcy5vcHRpb25zQmFja3VwLnBoeXNpY3M7dm9pZCAwPT09dC5waHlzaWNzfHwhMD09PXQucGh5c2ljcz8odC5waHlzaWNzPXtlbmFibGVkOnZvaWQgMD09PWUuZW5hYmxlZHx8ZS5lbmFibGVkLHNvbHZlcjpcImhpZXJhcmNoaWNhbFJlcHVsc2lvblwifSxlLmVuYWJsZWQ9dm9pZCAwPT09ZS5lbmFibGVkfHxlLmVuYWJsZWQsZS5zb2x2ZXI9ZS5zb2x2ZXJ8fFwiYmFybmVzSHV0XCIpOlwib2JqZWN0XCI9PT1kbih0LnBoeXNpY3MpPyhlLmVuYWJsZWQ9dm9pZCAwPT09dC5waHlzaWNzLmVuYWJsZWR8fHQucGh5c2ljcy5lbmFibGVkLGUuc29sdmVyPXQucGh5c2ljcy5zb2x2ZXJ8fFwiYmFybmVzSHV0XCIsdC5waHlzaWNzLnNvbHZlcj1cImhpZXJhcmNoaWNhbFJlcHVsc2lvblwiKTohMSE9PXQucGh5c2ljcyYmKGUuc29sdmVyPVwiYmFybmVzSHV0XCIsdC5waHlzaWNzPXtzb2x2ZXI6XCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIn0pO3ZhciBpPXRoaXMuZGlyZWN0aW9uLmN1cnZlVHlwZSgpO2lmKHZvaWQgMD09PXQuZWRnZXMpdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzPXtzbW9vdGg6e2VuYWJsZWQ6ITAsdHlwZTpcImR5bmFtaWNcIn19LHQuZWRnZXM9e3Ntb290aDohMX07ZWxzZSBpZih2b2lkIDA9PT10LmVkZ2VzLnNtb290aCl0aGlzLm9wdGlvbnNCYWNrdXAuZWRnZXM9e3Ntb290aDp7ZW5hYmxlZDohMCx0eXBlOlwiZHluYW1pY1wifX0sdC5lZGdlcy5zbW9vdGg9ITE7ZWxzZSBpZihcImJvb2xlYW5cIj09dHlwZW9mIHQuZWRnZXMuc21vb3RoKXRoaXMub3B0aW9uc0JhY2t1cC5lZGdlcz17c21vb3RoOnQuZWRnZXMuc21vb3RofSx0LmVkZ2VzLnNtb290aD17ZW5hYmxlZDp0LmVkZ2VzLnNtb290aCx0eXBlOml9O2Vsc2V7dmFyIG89dC5lZGdlcy5zbW9vdGg7dm9pZCAwIT09by50eXBlJiZcImR5bmFtaWNcIiE9PW8udHlwZSYmKGk9by50eXBlKSx0aGlzLm9wdGlvbnNCYWNrdXAuZWRnZXM9e3Ntb290aDp7ZW5hYmxlZDp2b2lkIDA9PT1vLmVuYWJsZWR8fG8uZW5hYmxlZCx0eXBlOnZvaWQgMD09PW8udHlwZT9cImR5bmFtaWNcIjpvLnR5cGUscm91bmRuZXNzOnZvaWQgMD09PW8ucm91bmRuZXNzPy41Om8ucm91bmRuZXNzLGZvcmNlRGlyZWN0aW9uOnZvaWQgMCE9PW8uZm9yY2VEaXJlY3Rpb24mJm8uZm9yY2VEaXJlY3Rpb259fSx0LmVkZ2VzLnNtb290aD17ZW5hYmxlZDp2b2lkIDA9PT1vLmVuYWJsZWR8fG8uZW5hYmxlZCx0eXBlOmkscm91bmRuZXNzOnZvaWQgMD09PW8ucm91bmRuZXNzPy41Om8ucm91bmRuZXNzLGZvcmNlRGlyZWN0aW9uOnZvaWQgMCE9PW8uZm9yY2VEaXJlY3Rpb24mJm8uZm9yY2VEaXJlY3Rpb259fXRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZm9yY2VEaXNhYmxlRHluYW1pY0N1cnZlc1wiLGkpfXJldHVybiB0fX0se2tleTpcInBvc2l0aW9uSW5pdGlhbGx5XCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoITAhPT10aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQpe3RoaXMuX3Jlc2V0Uk5HKHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQpO2Zvcih2YXIgZT10Lmxlbmd0aCs1MCxpPTA7aTx0Lmxlbmd0aDtpKyspe3ZhciBvPXRbaV0sbj0yKk1hdGguUEkqdGhpcy5fcm5nKCk7dm9pZCAwPT09by54JiYoby54PWUqTWF0aC5jb3MobikpLHZvaWQgMD09PW8ueSYmKG8ueT1lKk1hdGguc2luKG4pKX19fX0se2tleTpcImxheW91dE5ldHdvcmtcIix2YWx1ZTpmdW5jdGlvbigpe2lmKCEwIT09dGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkJiYhMD09PXRoaXMub3B0aW9ucy5pbXByb3ZlZExheW91dCl7Zm9yKHZhciB0PXRoaXMuYm9keS5ub2RlSW5kaWNlcyxlPTAsaT0wO2k8dC5sZW5ndGg7aSsrKXshMD09PXRoaXMuYm9keS5ub2Rlc1t0W2ldXS5wcmVkZWZpbmVkUG9zaXRpb24mJihlKz0xKX1pZihlPC41KnQubGVuZ3RoKXt2YXIgbz0wLG49dGhpcy5vcHRpb25zLmNsdXN0ZXJUaHJlc2hvbGQscj17Y2x1c3Rlck5vZGVQcm9wZXJ0aWVzOntzaGFwZTpcImVsbGlwc2VcIixsYWJlbDpcIlwiLGdyb3VwOlwiXCIsZm9udDp7bXVsdGk6ITF9fSxjbHVzdGVyRWRnZVByb3BlcnRpZXM6e2xhYmVsOlwiXCIsZm9udDp7bXVsdGk6ITF9LHNtb290aDp7ZW5hYmxlZDohMX19fTtpZih0Lmxlbmd0aD5uKXtmb3IodmFyIHM9dC5sZW5ndGg7dC5sZW5ndGg+biYmbzw9MTA7KXtvKz0xO3ZhciBhPXQubGVuZ3RoO2lmKG8lMz09MD90aGlzLmJvZHkubW9kdWxlcy5jbHVzdGVyaW5nLmNsdXN0ZXJCcmlkZ2VzKHIpOnRoaXMuYm9keS5tb2R1bGVzLmNsdXN0ZXJpbmcuY2x1c3Rlck91dGxpZXJzKHIpLGE9PXQubGVuZ3RoJiZvJTMhPTApcmV0dXJuIHRoaXMuX2RlY2x1c3RlckFsbCgpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfbGF5b3V0RmFpbGVkXCIpLHZvaWQgY29uc29sZS5pbmZvKFwiVGhpcyBuZXR3b3JrIGNvdWxkIG5vdCBiZSBwb3NpdGlvbmVkIGJ5IHRoaXMgdmVyc2lvbiBvZiB0aGUgaW1wcm92ZWQgbGF5b3V0IGFsZ29yaXRobS4gUGxlYXNlIGRpc2FibGUgaW1wcm92ZWRMYXlvdXQgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cIil9dGhpcy5ib2R5Lm1vZHVsZXMua2FtYWRhS2F3YWkuc2V0T3B0aW9ucyh7c3ByaW5nTGVuZ3RoOk1hdGgubWF4KDE1MCwyKnMpfSl9bz4xMCYmY29uc29sZS5pbmZvKFwiVGhlIGNsdXN0ZXJpbmcgZGlkbid0IHN1Y2NlZWQgd2l0aGluIHRoZSBhbW91bnQgb2YgaW50ZXJhdGlvbnMgYWxsb3dlZCwgcHJvZ3Jlc3Npbmcgd2l0aCBwYXJ0aWFsIHJlc3VsdC5cIiksdGhpcy5ib2R5Lm1vZHVsZXMua2FtYWRhS2F3YWkuc29sdmUodCx0aGlzLmJvZHkuZWRnZUluZGljZXMsITApLHRoaXMuX3NoaWZ0VG9DZW50ZXIoKTtmb3IodmFyIGg9MDtoPHQubGVuZ3RoO2grKyl7dmFyIGQ9dGhpcy5ib2R5Lm5vZGVzW3RbaF1dOyExPT09ZC5wcmVkZWZpbmVkUG9zaXRpb24mJihkLngrPTcwKiguNS10aGlzLl9ybmcoKSksZC55Kz03MCooLjUtdGhpcy5fcm5nKCkpKX10aGlzLl9kZWNsdXN0ZXJBbGwoKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcG9zaXRpb25CZXppZXJOb2Rlc1wiKX19fX0se2tleTpcIl9zaGlmdFRvQ2VudGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9d3UuZ2V0UmFuZ2VDb3JlKHRoaXMuYm9keS5ub2Rlcyx0aGlzLmJvZHkubm9kZUluZGljZXMpLGU9d3UuZmluZENlbnRlcih0KSxpPTA7aTx0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO2krKyl7dmFyIG89dGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV07by54LT1lLngsby55LT1lLnl9fX0se2tleTpcIl9kZWNsdXN0ZXJBbGxcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0hMDshMD09PXQ7KXt0PSExO2Zvcih2YXIgZT0wO2U8dGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDtlKyspITA9PT10aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2VdXS5pc0NsdXN0ZXImJih0PSEwLHRoaXMuYm9keS5tb2R1bGVzLmNsdXN0ZXJpbmcub3BlbkNsdXN0ZXIodGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2VdLHt9LCExKSk7ITA9PT10JiZ0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpfX19LHtrZXk6XCJnZXRTZWVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbml0aWFsUmFuZG9tU2VlZH19LHtrZXk6XCJzZXR1cEhpZXJhcmNoaWNhbExheW91dFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYoITA9PT10aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQmJnRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg+MCl7dmFyIHQsZSxpPSExLG89ITE7Zm9yKGUgaW4gdGhpcy5sYXN0Tm9kZU9uTGV2ZWw9e30sdGhpcy5oaWVyYXJjaGljYWw9bmV3IExmLHRoaXMuYm9keS5ub2RlcylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLGUpJiYodm9pZCAwIT09KHQ9dGhpcy5ib2R5Lm5vZGVzW2VdKS5vcHRpb25zLmxldmVsPyhpPSEwLHRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1tlXT10Lm9wdGlvbnMubGV2ZWwpOm89ITApO2lmKCEwPT09byYmITA9PT1pKXRocm93IG5ldyBFcnJvcihcIlRvIHVzZSB0aGUgaGllcmFyY2hpY2FsIGxheW91dCwgbm9kZXMgcmVxdWlyZSBlaXRoZXIgbm8gcHJlZGVmaW5lZCBsZXZlbHMgb3IgbGV2ZWxzIGhhdmUgdG8gYmUgZGVmaW5lZCBmb3IgYWxsIG5vZGVzLlwiKTtpZighMD09PW8pe3ZhciBuPXRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuc29ydE1ldGhvZDtcImh1YnNpemVcIj09PW4/dGhpcy5fZGV0ZXJtaW5lTGV2ZWxzQnlIdWJzaXplKCk6XCJkaXJlY3RlZFwiPT09bj90aGlzLl9kZXRlcm1pbmVMZXZlbHNEaXJlY3RlZCgpOlwiY3VzdG9tXCI9PT1uJiZ0aGlzLl9kZXRlcm1pbmVMZXZlbHNDdXN0b21DYWxsYmFjaygpfWZvcih2YXIgciBpbiB0aGlzLmJvZHkubm9kZXMpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2RlcyxyKSYmdGhpcy5oaWVyYXJjaGljYWwuZW5zdXJlTGV2ZWwocik7dmFyIHM9dGhpcy5fZ2V0RGlzdHJpYnV0aW9uKCk7dGhpcy5fZ2VuZXJhdGVNYXAoKSx0aGlzLl9wbGFjZU5vZGVzQnlIaWVyYXJjaHkocyksdGhpcy5fY29uZGVuc2VIaWVyYXJjaHkoKSx0aGlzLl9zaGlmdFRvQ2VudGVyKCl9fX0se2tleTpcIl9jb25kZW5zZUhpZXJhcmNoeVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPSExLGk9e30sbz1mdW5jdGlvbihlLGkpe3ZhciBvPXQuaGllcmFyY2hpY2FsLnRyZWVzO2Zvcih2YXIgbiBpbiBvKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLG4pJiZvW25dPT09ZSYmdC5kaXJlY3Rpb24uc2hpZnQobixpKX0sbj1mdW5jdGlvbigpe2Zvcih2YXIgZT1bXSxpPTA7aTx0LmhpZXJhcmNoaWNhbC5udW1UcmVlcygpO2krKyllLnB1c2godC5kaXJlY3Rpb24uZ2V0VHJlZVNpemUoaSkpO3JldHVybiBlfSxyPWZ1bmN0aW9uIGUoaSxvKXtpZighb1tpLmlkXSYmKG9baS5pZF09ITAsdC5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2VbaS5pZF0pKXt2YXIgbj10LmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtpLmlkXTtpZihuLmxlbmd0aD4wKWZvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKWUodC5ib2R5Lm5vZGVzW25bcl1dLG8pfX0scz1mdW5jdGlvbihlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MWU5LG89MWU5LG49MWU5LHI9MWU5LHM9LTFlOTtmb3IodmFyIGEgaW4gZSlpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxhKSl7dmFyIGg9dC5ib2R5Lm5vZGVzW2FdLGQ9dC5oaWVyYXJjaGljYWwubGV2ZWxzW2guaWRdLGw9dC5kaXJlY3Rpb24uZ2V0UG9zaXRpb24oaCksYz10Ll9nZXRTcGFjZUFyb3VuZE5vZGUoaCxlKSx1PWFuKGMsMiksZj11WzBdLHA9dVsxXTtvPU1hdGgubWluKGYsbyksbj1NYXRoLm1pbihwLG4pLGQ8PWkmJihyPU1hdGgubWluKGwscikscz1NYXRoLm1heChsLHMpKX1yZXR1cm5bcixzLG8sbl19LGE9ZnVuY3Rpb24oZSxpKXt2YXIgbz10LmhpZXJhcmNoaWNhbC5nZXRNYXhMZXZlbChlLmlkKSxuPXQuaGllcmFyY2hpY2FsLmdldE1heExldmVsKGkuaWQpO3JldHVybiBNYXRoLm1pbihvLG4pfSxoPWZ1bmN0aW9uKGUsaSxvKXtmb3IodmFyIG49dC5oaWVyYXJjaGljYWwscj0wO3I8aS5sZW5ndGg7cisrKXt2YXIgcz1pW3JdLGE9bi5kaXN0cmlidXRpb25PcmRlcmluZ1tzXTtpZihhLmxlbmd0aD4xKWZvcih2YXIgaD0wO2g8YS5sZW5ndGgtMTtoKyspe3ZhciBkPWFbaF0sbD1hW2grMV07bi5oYXNTYW1lUGFyZW50KGQsbCkmJm4uaW5TYW1lU3ViTmV0d29yayhkLGwpJiZlKGQsbCxvKX19fSxkPWZ1bmN0aW9uKGksbyl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXSxoPXQuZGlyZWN0aW9uLmdldFBvc2l0aW9uKGkpLGQ9dC5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obyksbD1NYXRoLmFicyhkLWgpLGM9dC5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZztpZihsPmMpe3ZhciB1PXt9LGY9e307cihpLHUpLHIobyxmKTt2YXIgcD1hKGksbyksdj1zKHUscCksZz1zKGYscCkseT12WzFdLG09Z1swXSxiPWdbMl0sdz1NYXRoLmFicyh5LW0pO2lmKHc+Yyl7dmFyIGs9eS1tK2M7azwtYitjJiYoaz0tYitjKSxrPDAmJih0Ll9zaGlmdEJsb2NrKG8uaWQsayksZT0hMCwhMD09PW4mJnQuX2NlbnRlclBhcmVudChvKSl9fX0sbD1mdW5jdGlvbihvLG4pe2Zvcih2YXIgYT1uLmlkLGg9bi5lZGdlcyxkPXQuaGllcmFyY2hpY2FsLmxldmVsc1tuLmlkXSxsPXQub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uKnQub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uLGM9e30sdT1bXSxmPTA7ZjxoLmxlbmd0aDtmKyspe3ZhciBwPWhbZl07aWYocC50b0lkIT1wLmZyb21JZCl7dmFyIHY9cC50b0lkPT1hP3AuZnJvbTpwLnRvO2NbaFtmXS5pZF09dix0LmhpZXJhcmNoaWNhbC5sZXZlbHNbdi5pZF08ZCYmdS5wdXNoKHApfX12YXIgZz1mdW5jdGlvbihlLGkpe2Zvcih2YXIgbz0wLG49MDtuPGkubGVuZ3RoO24rKylpZih2b2lkIDAhPT1jW2lbbl0uaWRdKXt2YXIgcj10LmRpcmVjdGlvbi5nZXRQb3NpdGlvbihjW2lbbl0uaWRdKS1lO28rPXIvTWF0aC5zcXJ0KHIqcitsKX1yZXR1cm4gb30seT1mdW5jdGlvbihlLGkpe2Zvcih2YXIgbz0wLG49MDtuPGkubGVuZ3RoO24rKylpZih2b2lkIDAhPT1jW2lbbl0uaWRdKXt2YXIgcj10LmRpcmVjdGlvbi5nZXRQb3NpdGlvbihjW2lbbl0uaWRdKS1lO28tPWwqTWF0aC5wb3cocipyK2wsLTEuNSl9cmV0dXJuIG99LG09ZnVuY3Rpb24oZSxpKXtmb3IodmFyIG89dC5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obikscj17fSxzPTA7czxlO3MrKyl7dmFyIGE9ZyhvLGkpLGg9eShvLGkpO2lmKHZvaWQgMCE9PXJbby09TWF0aC5tYXgoLTQwLE1hdGgubWluKDQwLE1hdGgucm91bmQoYS9oKSkpXSlicmVhaztyW29dPXN9cmV0dXJuIG99LGI9bShvLHUpOyFmdW5jdGlvbihvKXt2YXIgYT10LmRpcmVjdGlvbi5nZXRQb3NpdGlvbihuKTtpZih2b2lkIDA9PT1pW24uaWRdKXt2YXIgaD17fTtyKG4saCksaVtuLmlkXT1ofXZhciBkPXMoaVtuLmlkXSksbD1kWzJdLGM9ZFszXSx1PW8tYSxmPTA7dT4wP2Y9TWF0aC5taW4odSxjLXQub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpOnU8MCYmKGY9LU1hdGgubWluKC11LGwtdC5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZykpLDAhPWYmJih0Ll9zaGlmdEJsb2NrKG4uaWQsZiksZT0hMCl9KGIpLGZ1bmN0aW9uKGkpe3ZhciBvPXQuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG4pLHI9YW4odC5fZ2V0U3BhY2VBcm91bmROb2RlKG4pLDIpLHM9clswXSxhPXJbMV0saD1pLW8sZD1vO2g+MD9kPU1hdGgubWluKG8rKGEtdC5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyksaSk6aDwwJiYoZD1NYXRoLm1heChvLShzLXQub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpLGkpKSxkIT09byYmKHQuZGlyZWN0aW9uLnNldFBvc2l0aW9uKG4sZCksZT0hMCl9KGI9bShvLGgpKX07ITA9PT10aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmJsb2NrU2hpZnRpbmcmJihmdW5jdGlvbihpKXt2YXIgbz10LmhpZXJhcmNoaWNhbC5nZXRMZXZlbHMoKTtvPU5uKG8pLmNhbGwobyk7Zm9yKHZhciBuPTA7bjxpJiYoZT0hMSxoKGQsbywhMCksITA9PT1lKTtuKyspO30oNSksZnVuY3Rpb24oKXtmb3IodmFyIGUgaW4gdC5ib2R5Lm5vZGVzKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LmJvZHkubm9kZXMsZSkmJnQuX2NlbnRlclBhcmVudCh0LmJvZHkubm9kZXNbZV0pfSgpKSwhMD09PXRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZWRnZU1pbmltaXphdGlvbiYmZnVuY3Rpb24oaSl7dmFyIG89dC5oaWVyYXJjaGljYWwuZ2V0TGV2ZWxzKCk7bz1ObihvKS5jYWxsKG8pO2Zvcih2YXIgbj0wO248aTtuKyspe2U9ITE7Zm9yKHZhciByPTA7cjxvLmxlbmd0aDtyKyspZm9yKHZhciBzPW9bcl0sYT10LmhpZXJhcmNoaWNhbC5kaXN0cmlidXRpb25PcmRlcmluZ1tzXSxoPTA7aDxhLmxlbmd0aDtoKyspbCgxZTMsYVtoXSk7aWYoITAhPT1lKWJyZWFrfX0oMjApLCEwPT09dGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5wYXJlbnRDZW50cmFsaXphdGlvbiYmZnVuY3Rpb24oKXt2YXIgZT10LmhpZXJhcmNoaWNhbC5nZXRMZXZlbHMoKTtlPU5uKGUpLmNhbGwoZSk7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspZm9yKHZhciBvPWVbaV0sbj10LmhpZXJhcmNoaWNhbC5kaXN0cmlidXRpb25PcmRlcmluZ1tvXSxyPTA7cjxuLmxlbmd0aDtyKyspdC5fY2VudGVyUGFyZW50KG5bcl0pfSgpLGZ1bmN0aW9uKCl7Zm9yKHZhciBlPW4oKSxpPTAscj0wO3I8ZS5sZW5ndGgtMTtyKyspe2krPWVbcl0ubWF4LWVbcisxXS5taW4rdC5vcHRpb25zLmhpZXJhcmNoaWNhbC50cmVlU3BhY2luZyxvKHIrMSxpKX19KCl9fSx7a2V5OlwiX2dldFNwYWNlQXJvdW5kTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9ITA7dm9pZCAwPT09ZSYmKGk9ITEpO3ZhciBvPXRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1t0LmlkXTtpZih2b2lkIDAhPT1vKXt2YXIgbj10aGlzLmhpZXJhcmNoaWNhbC5kaXN0cmlidXRpb25JbmRleFt0LmlkXSxyPXRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHQpLHM9dGhpcy5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uT3JkZXJpbmdbb10sYT0xZTksaD0xZTk7aWYoMCE9PW4pe3ZhciBkPXNbbi0xXTtpZighMD09PWkmJnZvaWQgMD09PWVbZC5pZF18fCExPT09aSlhPXItdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24oZCl9aWYobiE9cy5sZW5ndGgtMSl7dmFyIGw9c1tuKzFdO2lmKCEwPT09aSYmdm9pZCAwPT09ZVtsLmlkXXx8ITE9PT1pKXt2YXIgYz10aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihsKTtoPU1hdGgubWluKGgsYy1yKX19cmV0dXJuW2EsaF19cmV0dXJuWzAsMF19fSx7a2V5OlwiX2NlbnRlclBhcmVudFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHRoaXMuaGllcmFyY2hpY2FsLnBhcmVudFJlZmVyZW5jZVt0LmlkXSlmb3IodmFyIGU9dGhpcy5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW3QuaWRdLGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG89ZVtpXSxuPXRoaXMuYm9keS5ub2Rlc1tvXSxyPXRoaXMuaGllcmFyY2hpY2FsLmNoaWxkcmVuUmVmZXJlbmNlW29dO2lmKHZvaWQgMCE9PXIpe3ZhciBzPXRoaXMuX2dldENlbnRlclBvc2l0aW9uKHIpLGE9dGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obiksaD1hbih0aGlzLl9nZXRTcGFjZUFyb3VuZE5vZGUobiksMiksZD1oWzBdLGw9aFsxXSxjPWEtczsoYzwwJiZNYXRoLmFicyhjKTxsLXRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmd8fGM+MCYmTWF0aC5hYnMoYyk8ZC10aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKSYmdGhpcy5kaXJlY3Rpb24uc2V0UG9zaXRpb24obixzKX19fX0se2tleTpcIl9wbGFjZU5vZGVzQnlIaWVyYXJjaHlcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGUgaW4gdGhpcy5wb3NpdGlvbmVkTm9kZXM9e30sdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSl7dmFyIGksbz14bih0W2VdKTtvPXRoaXMuX2luZGV4QXJyYXlUb05vZGVzKG8pLGJmKGk9dGhpcy5kaXJlY3Rpb24pLmNhbGwoaSxvKTtmb3IodmFyIG49MCxyPTA7cjxvLmxlbmd0aDtyKyspe3ZhciBzPW9bcl07aWYodm9pZCAwPT09dGhpcy5wb3NpdGlvbmVkTm9kZXNbcy5pZF0pe3ZhciBhPXRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcsaD1hKm47bj4wJiYoaD10aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihvW3ItMV0pK2EpLHRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKHMsaCxlKSx0aGlzLl92YWxpZGF0ZVBvc2l0aW9uQW5kQ29udGludWUocyxlLGgpLG4rK319fX19LHtrZXk6XCJfcGxhY2VCcmFuY2hOb2Rlc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGksbz10aGlzLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVt0XTtpZih2b2lkIDAhPT1vKXtmb3IodmFyIG49W10scj0wO3I8by5sZW5ndGg7cisrKW4ucHVzaCh0aGlzLmJvZHkubm9kZXNbb1tyXV0pO2JmKGk9dGhpcy5kaXJlY3Rpb24pLmNhbGwoaSxuKTtmb3IodmFyIHM9MDtzPG4ubGVuZ3RoO3MrKyl7dmFyIGE9bltzXSxoPXRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1thLmlkXTtpZighKGg+ZSYmdm9pZCAwPT09dGhpcy5wb3NpdGlvbmVkTm9kZXNbYS5pZF0pKXJldHVybjt2YXIgZD10aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nLGw9dm9pZCAwO2w9MD09PXM/dGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24odGhpcy5ib2R5Lm5vZGVzW3RdKTp0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihuW3MtMV0pK2QsdGhpcy5kaXJlY3Rpb24uc2V0UG9zaXRpb24oYSxsLGgpLHRoaXMuX3ZhbGlkYXRlUG9zaXRpb25BbmRDb250aW51ZShhLGgsbCl9dmFyIGM9dGhpcy5fZ2V0Q2VudGVyUG9zaXRpb24obik7dGhpcy5kaXJlY3Rpb24uc2V0UG9zaXRpb24odGhpcy5ib2R5Lm5vZGVzW3RdLGMsZSl9fX0se2tleTpcIl92YWxpZGF0ZVBvc2l0aW9uQW5kQ29udGludWVcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7aWYodGhpcy5oaWVyYXJjaGljYWwuaXNUcmVlKXtpZih2b2lkIDAhPT10aGlzLmxhc3ROb2RlT25MZXZlbFtlXSl7dmFyIG89dGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24odGhpcy5ib2R5Lm5vZGVzW3RoaXMubGFzdE5vZGVPbkxldmVsW2VdXSk7aWYoaS1vPHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpe3ZhciBuPW8rdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZy1pLHI9dGhpcy5fZmluZENvbW1vblBhcmVudCh0aGlzLmxhc3ROb2RlT25MZXZlbFtlXSx0LmlkKTt0aGlzLl9zaGlmdEJsb2NrKHIud2l0aENoaWxkLG4pfX10aGlzLmxhc3ROb2RlT25MZXZlbFtlXT10LmlkLHRoaXMucG9zaXRpb25lZE5vZGVzW3QuaWRdPSEwLHRoaXMuX3BsYWNlQnJhbmNoTm9kZXModC5pZCxlKX19fSx7a2V5OlwiX2luZGV4QXJyYXlUb05vZGVzXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLGk9MDtpPHQubGVuZ3RoO2krKyllLnB1c2godGhpcy5ib2R5Lm5vZGVzW3RbaV1dKTtyZXR1cm4gZX19LHtrZXk6XCJfZ2V0RGlzdHJpYnV0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlLGk9e307Zm9yKHQgaW4gdGhpcy5ib2R5Lm5vZGVzKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsdCkpe2U9dGhpcy5ib2R5Lm5vZGVzW3RdO3ZhciBvPXZvaWQgMD09PXRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1t0XT8wOnRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1t0XTt0aGlzLmRpcmVjdGlvbi5maXgoZSxvKSx2b2lkIDA9PT1pW29dJiYoaVtvXT17fSksaVtvXVt0XT1lfXJldHVybiBpfX0se2tleTpcIl9nZXRBY3RpdmVFZGdlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsaT1bXTtyZXR1cm4gbmgodC5lZGdlcywoZnVuY3Rpb24odCl7dmFyIG87LTEhPT1NcihvPWUuYm9keS5lZGdlSW5kaWNlcykuY2FsbChvLHQuaWQpJiZpLnB1c2godCl9KSksaX19LHtrZXk6XCJfZ2V0SHViU2l6ZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT17fTtuaCh0aGlzLmJvZHkubm9kZUluZGljZXMsKGZ1bmN0aW9uKGkpe3ZhciBvPXQuYm9keS5ub2Rlc1tpXSxuPXQuX2dldEFjdGl2ZUVkZ2VzKG8pLmxlbmd0aDtlW25dPSEwfSkpO3ZhciBpPVtdO3JldHVybiBuaChlLChmdW5jdGlvbih0KXtpLnB1c2goTnVtYmVyKHQpKX0pKSxiZihDZikuY2FsbChDZixpLChmdW5jdGlvbih0LGUpe3JldHVybiBlLXR9KSksaX19LHtrZXk6XCJfZGV0ZXJtaW5lTGV2ZWxzQnlIdWJzaXplXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcyxlPWZ1bmN0aW9uKGUsaSl7dC5oaWVyYXJjaGljYWwubGV2ZWxEb3duc3RyZWFtKGUsaSl9LGk9dGhpcy5fZ2V0SHViU2l6ZXMoKSxvPWZ1bmN0aW9uKG8pe3ZhciBuPWlbb107aWYoMD09PW4pcmV0dXJuXCJicmVha1wiO25oKHQuYm9keS5ub2RlSW5kaWNlcywoZnVuY3Rpb24oaSl7dmFyIG89dC5ib2R5Lm5vZGVzW2ldO249PT10Ll9nZXRBY3RpdmVFZGdlcyhvKS5sZW5ndGgmJnQuX2NyYXdsTmV0d29yayhlLGkpfSkpfSxuPTA7bjxpLmxlbmd0aDsrK24pe2lmKFwiYnJlYWtcIj09PW8obikpYnJlYWt9fX0se2tleTpcIl9kZXRlcm1pbmVMZXZlbHNDdXN0b21DYWxsYmFja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLl9jcmF3bE5ldHdvcmsoKGZ1bmN0aW9uKGUsaSxvKXt2YXIgbj10LmhpZXJhcmNoaWNhbC5sZXZlbHNbZS5pZF07dm9pZCAwPT09biYmKG49dC5oaWVyYXJjaGljYWwubGV2ZWxzW2UuaWRdPTFlNSk7dmFyIHI9KHd1LmNsb25lT3B0aW9ucyhlLFwibm9kZVwiKSx3dS5jbG9uZU9wdGlvbnMoaSxcIm5vZGVcIiksdm9pZCB3dS5jbG9uZU9wdGlvbnMobyxcImVkZ2VcIikpO3QuaGllcmFyY2hpY2FsLmxldmVsc1tpLmlkXT1uK3J9KSksdGhpcy5oaWVyYXJjaGljYWwuc2V0TWluTGV2ZWxUb1plcm8odGhpcy5ib2R5Lm5vZGVzKX19LHtrZXk6XCJfZGV0ZXJtaW5lTGV2ZWxzRGlyZWN0ZWRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGU9dGhpcyxpPU9mKHQ9dGhpcy5ib2R5Lm5vZGVJbmRpY2VzKS5jYWxsKHQsKGZ1bmN0aW9uKHQsaSl7cmV0dXJuIHQuc2V0KGksZS5ib2R5Lm5vZGVzW2ldKSx0fSksbmV3IEJkKTtcInJvb3RzXCI9PT10aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnNoYWtlVG93YXJkcz90aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHM9ZnVuY3Rpb24odCl7cmV0dXJuIGpmKChmdW5jdGlvbihlKXt2YXIgaSxvO3JldHVybiBGZihpPWFyKG89ZS5lZGdlcykuY2FsbChvLChmdW5jdGlvbihlKXtyZXR1cm4gdC5oYXMoZS50b0lkKX0pKSkuY2FsbChpLChmdW5jdGlvbih0KXtyZXR1cm4gdC5mcm9tPT09ZX0pKX0pLChmdW5jdGlvbih0LGUpe3JldHVybiBlPHR9KSxcInRvXCIsdCl9KGkpOnRoaXMuaGllcmFyY2hpY2FsLmxldmVscz1mdW5jdGlvbih0KXtyZXR1cm4gamYoKGZ1bmN0aW9uKGUpe3ZhciBpLG87cmV0dXJuIEZmKGk9YXIobz1lLmVkZ2VzKS5jYWxsKG8sKGZ1bmN0aW9uKGUpe3JldHVybiB0LmhhcyhlLnRvSWQpfSkpKS5jYWxsKGksKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvPT09ZX0pKX0pLChmdW5jdGlvbih0LGUpe3JldHVybiBlPnR9KSxcImZyb21cIix0KX0oaSksdGhpcy5oaWVyYXJjaGljYWwuc2V0TWluTGV2ZWxUb1plcm8odGhpcy5ib2R5Lm5vZGVzKX19LHtrZXk6XCJfZ2VuZXJhdGVNYXBcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5fY3Jhd2xOZXR3b3JrKChmdW5jdGlvbihlLGkpe3QuaGllcmFyY2hpY2FsLmxldmVsc1tpLmlkXT50LmhpZXJhcmNoaWNhbC5sZXZlbHNbZS5pZF0mJnQuaGllcmFyY2hpY2FsLmFkZFJlbGF0aW9uKGUuaWQsaS5pZCl9KSksdGhpcy5oaWVyYXJjaGljYWwuY2hlY2tJZlRyZWUoKX19LHtrZXk6XCJfY3Jhd2xOZXR3b3JrXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOmZ1bmN0aW9uKCl7fSxpPWFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLG89e30sbj1mdW5jdGlvbiBpKG4scil7aWYodm9pZCAwPT09b1tuLmlkXSl7dmFyIHM7dC5oaWVyYXJjaGljYWwuc2V0VHJlZUluZGV4KG4sciksb1tuLmlkXT0hMDtmb3IodmFyIGE9dC5fZ2V0QWN0aXZlRWRnZXMobiksaD0wO2g8YS5sZW5ndGg7aCsrKXt2YXIgZD1hW2hdOyEwPT09ZC5jb25uZWN0ZWQmJihzPWQudG9JZD09bi5pZD9kLmZyb206ZC50byxuLmlkIT1zLmlkJiYoZShuLHMsZCksaShzLHIpKSl9fX07aWYodm9pZCAwPT09aSlmb3IodmFyIHI9MCxzPTA7czx0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO3MrKyl7dmFyIGE9dGhpcy5ib2R5Lm5vZGVJbmRpY2VzW3NdO2lmKHZvaWQgMD09PW9bYV0pe3ZhciBoPXRoaXMuYm9keS5ub2Rlc1thXTtuKGgscikscis9MX19ZWxzZXt2YXIgZD10aGlzLmJvZHkubm9kZXNbaV07aWYodm9pZCAwPT09ZClyZXR1cm4gdm9pZCBjb25zb2xlLmVycm9yKFwiTm9kZSBub3QgZm91bmQ6XCIsaSk7bihkKX19fSx7a2V5OlwiX3NoaWZ0QmxvY2tcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMsbz17fTshZnVuY3Rpb24gdChuKXtpZighb1tuXSl7b1tuXT0hMCxpLmRpcmVjdGlvbi5zaGlmdChuLGUpO3ZhciByPWkuaGllcmFyY2hpY2FsLmNoaWxkcmVuUmVmZXJlbmNlW25dO2lmKHZvaWQgMCE9PXIpZm9yKHZhciBzPTA7czxyLmxlbmd0aDtzKyspdChyW3NdKX19KHQpfX0se2tleTpcIl9maW5kQ29tbW9uUGFyZW50XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLG89e307cmV0dXJuIGZ1bmN0aW9uIHQoZSxvKXt2YXIgbj1pLmhpZXJhcmNoaWNhbC5wYXJlbnRSZWZlcmVuY2Vbb107aWYodm9pZCAwIT09bilmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIHM9bltyXTtlW3NdPSEwLHQoZSxzKX19KG8sdCksZnVuY3Rpb24gdChlLG8pe3ZhciBuPWkuaGllcmFyY2hpY2FsLnBhcmVudFJlZmVyZW5jZVtvXTtpZih2b2lkIDAhPT1uKWZvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgcz1uW3JdO2lmKHZvaWQgMCE9PWVbc10pcmV0dXJue2ZvdW5kUGFyZW50OnMsd2l0aENoaWxkOm99O3ZhciBhPXQoZSxzKTtpZihudWxsIT09YS5mb3VuZFBhcmVudClyZXR1cm4gYX1yZXR1cm57Zm91bmRQYXJlbnQ6bnVsbCx3aXRoQ2hpbGQ6b319KG8sZSl9fSx7a2V5Olwic2V0RGlyZWN0aW9uU3RyYXRlZ3lcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PVwiVURcIj09PXRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9ufHxcIkRVXCI9PT10aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbjt0aGlzLmRpcmVjdGlvbj10P25ldyBNZih0aGlzKTpuZXcgUGYodGhpcyl9fSx7a2V5OlwiX2dldENlbnRlclBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTFlOSxpPS0xZTksbz0wO288dC5sZW5ndGg7bysrKXt2YXIgbj12b2lkIDA7aWYodm9pZCAwIT09dFtvXS5pZCluPXRbb107ZWxzZXt2YXIgcj10W29dO249dGhpcy5ib2R5Lm5vZGVzW3JdfXZhciBzPXRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG4pO2U9TWF0aC5taW4oZSxzKSxpPU1hdGgubWF4KGkscyl9cmV0dXJuLjUqKGUraSl9fV0pLHR9KCk7ZnVuY3Rpb24gV2YodCxlKXt2YXIgaTtpZih2b2lkIDA9PT1jbnx8bnVsbD09Q2kodCkpe2lmKGduKHQpfHwoaT1mdW5jdGlvbih0LGUpe3ZhciBpO2lmKCF0KXJldHVybjtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gVmYodCxlKTt2YXIgbz12bihpPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkuY2FsbChpLDgsLTEpO1wiT2JqZWN0XCI9PT1vJiZ0LmNvbnN0cnVjdG9yJiYobz10LmNvbnN0cnVjdG9yLm5hbWUpO2lmKFwiTWFwXCI9PT1vfHxcIlNldFwiPT09bylyZXR1cm4gbWkodCk7aWYoXCJBcmd1bWVudHNcIj09PW98fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG8pKXJldHVybiBWZih0LGUpfSh0KSl8fGUmJnQmJlwibnVtYmVyXCI9PXR5cGVvZiB0Lmxlbmd0aCl7aSYmKHQ9aSk7dmFyIG89MCxuPWZ1bmN0aW9uKCl7fTtyZXR1cm57czpuLG46ZnVuY3Rpb24oKXtyZXR1cm4gbz49dC5sZW5ndGg/e2RvbmU6ITB9Ontkb25lOiExLHZhbHVlOnRbbysrXX19LGU6ZnVuY3Rpb24odCl7dGhyb3cgdH0sZjpufX10aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9dmFyIHIscz0hMCxhPSExO3JldHVybntzOmZ1bmN0aW9uKCl7aT1TaSh0KX0sbjpmdW5jdGlvbigpe3ZhciB0PWkubmV4dCgpO3JldHVybiBzPXQuZG9uZSx0fSxlOmZ1bmN0aW9uKHQpe2E9ITAscj10fSxmOmZ1bmN0aW9uKCl7dHJ5e3N8fG51bGw9PWkucmV0dXJufHxpLnJldHVybigpfWZpbmFsbHl7aWYoYSl0aHJvdyByfX19fWZ1bmN0aW9uIFZmKHQsZSl7KG51bGw9PWV8fGU+dC5sZW5ndGgpJiYoZT10Lmxlbmd0aCk7Zm9yKHZhciBpPTAsbz1uZXcgQXJyYXkoZSk7aTxlO2krKylvW2ldPXRbaV07cmV0dXJuIG99dmFyIHFmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLGksbyxuKXt2YXIgcixzLGE9dGhpcztQbyh0aGlzLHQpLHRoaXMuYm9keT1lLHRoaXMuY2FudmFzPWksdGhpcy5zZWxlY3Rpb25IYW5kbGVyPW8sdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXI9bix0aGlzLmVkaXRNb2RlPSExLHRoaXMubWFuaXB1bGF0aW9uRGl2PXZvaWQgMCx0aGlzLmVkaXRNb2RlRGl2PXZvaWQgMCx0aGlzLmNsb3NlRGl2PXZvaWQgMCx0aGlzLl9kb21FdmVudExpc3RlbmVyQ2xlYW51cFF1ZXVlPVtdLHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnM9e30sdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucz1bXSx0aGlzLnRvdWNoVGltZT0wLHRoaXMudGVtcG9yYXJ5SWRzPXtub2RlczpbXSxlZGdlczpbXX0sdGhpcy5ndWlFbmFibGVkPSExLHRoaXMuaW5Nb2RlPSExLHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZT12b2lkIDAsdGhpcy5vcHRpb25zPXt9LHRoaXMuZGVmYXVsdE9wdGlvbnM9e2VuYWJsZWQ6ITEsaW5pdGlhbGx5QWN0aXZlOiExLGFkZE5vZGU6ITAsYWRkRWRnZTohMCxlZGl0Tm9kZTp2b2lkIDAsZWRpdEVkZ2U6ITAsZGVsZXRlTm9kZTohMCxkZWxldGVFZGdlOiEwLGNvbnRyb2xOb2RlU3R5bGU6e3NoYXBlOlwiZG90XCIsc2l6ZTo2LGNvbG9yOntiYWNrZ3JvdW5kOlwiI2ZmMDAwMFwiLGJvcmRlcjpcIiMzYzNjM2NcIixoaWdobGlnaHQ6e2JhY2tncm91bmQ6XCIjMDdmOTY4XCIsYm9yZGVyOlwiIzNjM2MzY1wifX0sYm9yZGVyV2lkdGg6Mixib3JkZXJXaWR0aFNlbGVjdGVkOjJ9fSxjdCh0aGlzLm9wdGlvbnMsdGhpcy5kZWZhdWx0T3B0aW9ucyksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsKGZ1bmN0aW9uKCl7YS5fY2xlYW4oKX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhQ2hhbmdlZFwiLGJ0KHI9dGhpcy5fcmVzdG9yZSkuY2FsbChyLHRoaXMpKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXNldERhdGFcIixidChzPXRoaXMuX3Jlc3RvcmUpLmNhbGwocyx0aGlzKSl9cmV0dXJuIElvKHQsW3trZXk6XCJfcmVzdG9yZVwiLHZhbHVlOmZ1bmN0aW9uKCl7ITEhPT10aGlzLmluTW9kZSYmKCEwPT09dGhpcy5vcHRpb25zLmluaXRpYWxseUFjdGl2ZT90aGlzLmVuYWJsZUVkaXRNb2RlKCk6dGhpcy5kaXNhYmxlRWRpdE1vZGUoKSl9fSx7a2V5Olwic2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2b2lkIDAhPT1lJiYodm9pZCAwIT09ZS5sb2NhbGU/dGhpcy5vcHRpb25zLmxvY2FsZT1lLmxvY2FsZTp0aGlzLm9wdGlvbnMubG9jYWxlPWkubG9jYWxlLHZvaWQgMCE9PWUubG9jYWxlcz90aGlzLm9wdGlvbnMubG9jYWxlcz1lLmxvY2FsZXM6dGhpcy5vcHRpb25zLmxvY2FsZXM9aS5sb2NhbGVzKSx2b2lkIDAhPT10JiYoXCJib29sZWFuXCI9PXR5cGVvZiB0P3RoaXMub3B0aW9ucy5lbmFibGVkPXQ6KHRoaXMub3B0aW9ucy5lbmFibGVkPSEwLHRoKHRoaXMub3B0aW9ucyx0KSksITA9PT10aGlzLm9wdGlvbnMuaW5pdGlhbGx5QWN0aXZlJiYodGhpcy5lZGl0TW9kZT0hMCksdGhpcy5fc2V0dXAoKSl9fSx7a2V5OlwidG9nZ2xlRWRpdE1vZGVcIix2YWx1ZTpmdW5jdGlvbigpeyEwPT09dGhpcy5lZGl0TW9kZT90aGlzLmRpc2FibGVFZGl0TW9kZSgpOnRoaXMuZW5hYmxlRWRpdE1vZGUoKX19LHtrZXk6XCJlbmFibGVFZGl0TW9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5lZGl0TW9kZT0hMCx0aGlzLl9jbGVhbigpLCEwPT09dGhpcy5ndWlFbmFibGVkJiYodGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIix0aGlzLmVkaXRNb2RlRGl2LnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCkpfX0se2tleTpcImRpc2FibGVFZGl0TW9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5lZGl0TW9kZT0hMSx0aGlzLl9jbGVhbigpLCEwPT09dGhpcy5ndWlFbmFibGVkJiYodGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheT1cIm5vbmVcIix0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIix0aGlzLl9jcmVhdGVFZGl0QnV0dG9uKCkpfX0se2tleTpcInNob3dNYW5pcHVsYXRvclRvb2xiYXJcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuX2NsZWFuKCksdGhpcy5tYW5pcHVsYXRpb25ET009e30sITA9PT10aGlzLmd1aUVuYWJsZWQpe3ZhciB0LGU7dGhpcy5lZGl0TW9kZT0hMCx0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIix0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiO3ZhciBpPXRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVDb3VudCgpLG89dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZUNvdW50KCksbj1pK28scj10aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXSxzPSExOyExIT09dGhpcy5vcHRpb25zLmFkZE5vZGUmJih0aGlzLl9jcmVhdGVBZGROb2RlQnV0dG9uKHIpLHM9ITApLCExIT09dGhpcy5vcHRpb25zLmFkZEVkZ2UmJighMD09PXM/dGhpcy5fY3JlYXRlU2VwZXJhdG9yKDEpOnM9ITAsdGhpcy5fY3JlYXRlQWRkRWRnZUJ1dHRvbihyKSksMT09PWkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub3B0aW9ucy5lZGl0Tm9kZT8oITA9PT1zP3RoaXMuX2NyZWF0ZVNlcGVyYXRvcigyKTpzPSEwLHRoaXMuX2NyZWF0ZUVkaXROb2RlQnV0dG9uKHIpKToxPT09byYmMD09PWkmJiExIT09dGhpcy5vcHRpb25zLmVkaXRFZGdlJiYoITA9PT1zP3RoaXMuX2NyZWF0ZVNlcGVyYXRvcigzKTpzPSEwLHRoaXMuX2NyZWF0ZUVkaXRFZGdlQnV0dG9uKHIpKSwwIT09biYmKGk+MCYmITEhPT10aGlzLm9wdGlvbnMuZGVsZXRlTm9kZXx8MD09PWkmJiExIT09dGhpcy5vcHRpb25zLmRlbGV0ZUVkZ2UpJiYoITA9PT1zJiZ0aGlzLl9jcmVhdGVTZXBlcmF0b3IoNCksdGhpcy5fY3JlYXRlRGVsZXRlQnV0dG9uKHIpKSx0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyh0aGlzLmNsb3NlRGl2LGJ0KHQ9dGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbCh0LHRoaXMpKSx0aGlzLl90ZW1wb3JhcnlCaW5kRXZlbnQoXCJzZWxlY3RcIixidChlPXRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcikuY2FsbChlLHRoaXMpKX10aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKX19LHtrZXk6XCJhZGROb2RlTW9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ7aWYoITAhPT10aGlzLmVkaXRNb2RlJiZ0aGlzLmVuYWJsZUVkaXRNb2RlKCksdGhpcy5fY2xlYW4oKSx0aGlzLmluTW9kZT1cImFkZE5vZGVcIiwhMD09PXRoaXMuZ3VpRW5hYmxlZCl7dmFyIGUsaT10aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTt0aGlzLm1hbmlwdWxhdGlvbkRPTT17fSx0aGlzLl9jcmVhdGVCYWNrQnV0dG9uKGkpLHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigpLHRoaXMuX2NyZWF0ZURlc2NyaXB0aW9uKGkuYWRkRGVzY3JpcHRpb258fHRoaXMub3B0aW9ucy5sb2NhbGVzLmVuLmFkZERlc2NyaXB0aW9uKSx0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyh0aGlzLmNsb3NlRGl2LGJ0KGU9dGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbChlLHRoaXMpKX10aGlzLl90ZW1wb3JhcnlCaW5kRXZlbnQoXCJjbGlja1wiLGJ0KHQ9dGhpcy5fcGVyZm9ybUFkZE5vZGUpLmNhbGwodCx0aGlzKSl9fSx7a2V5OlwiZWRpdE5vZGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7ITAhPT10aGlzLmVkaXRNb2RlJiZ0aGlzLmVuYWJsZUVkaXRNb2RlKCksdGhpcy5fY2xlYW4oKTt2YXIgZT10aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2RlcygpWzBdO2lmKHZvaWQgMCE9PWUpe2lmKHRoaXMuaW5Nb2RlPVwiZWRpdE5vZGVcIixcImZ1bmN0aW9uXCIhPXR5cGVvZiB0aGlzLm9wdGlvbnMuZWRpdE5vZGUpdGhyb3cgbmV3IEVycm9yKFwiTm8gZnVuY3Rpb24gaGFzIGJlZW4gY29uZmlndXJlZCB0byBoYW5kbGUgdGhlIGVkaXRpbmcgb2Ygbm9kZXMuXCIpO2lmKCEwIT09ZS5pc0NsdXN0ZXIpe3ZhciBpPXRoKHt9LGUub3B0aW9ucywhMSk7aWYoaS54PWUueCxpLnk9ZS55LDIhPT10aGlzLm9wdGlvbnMuZWRpdE5vZGUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBmb3IgZWRpdCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsIGNhbGxiYWNrKVwiKTt0aGlzLm9wdGlvbnMuZWRpdE5vZGUoaSwoZnVuY3Rpb24oZSl7bnVsbCE9ZSYmXCJlZGl0Tm9kZVwiPT09dC5pbk1vZGUmJnQuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS51cGRhdGUoZSksdC5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCl9KSl9ZWxzZSBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXS5lZGl0Q2x1c3RlckVycm9yfHx0aGlzLm9wdGlvbnMubG9jYWxlcy5lbi5lZGl0Q2x1c3RlckVycm9yKX1lbHNlIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpfX0se2tleTpcImFkZEVkZ2VNb2RlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlLGksbyxuO2lmKCEwIT09dGhpcy5lZGl0TW9kZSYmdGhpcy5lbmFibGVFZGl0TW9kZSgpLHRoaXMuX2NsZWFuKCksdGhpcy5pbk1vZGU9XCJhZGRFZGdlXCIsITA9PT10aGlzLmd1aUVuYWJsZWQpe3ZhciByLHM9dGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07dGhpcy5tYW5pcHVsYXRpb25ET009e30sdGhpcy5fY3JlYXRlQmFja0J1dHRvbihzKSx0aGlzLl9jcmVhdGVTZXBlcmF0b3IoKSx0aGlzLl9jcmVhdGVEZXNjcmlwdGlvbihzLmVkZ2VEZXNjcmlwdGlvbnx8dGhpcy5vcHRpb25zLmxvY2FsZXMuZW4uZWRnZURlc2NyaXB0aW9uKSx0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyh0aGlzLmNsb3NlRGl2LGJ0KHI9dGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbChyLHRoaXMpKX10aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvblRvdWNoXCIsYnQodD10aGlzLl9oYW5kbGVDb25uZWN0KS5jYWxsKHQsdGhpcykpLHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ0VuZFwiLGJ0KGU9dGhpcy5fZmluaXNoQ29ubmVjdCkuY2FsbChlLHRoaXMpKSx0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkRyYWdcIixidChpPXRoaXMuX2RyYWdDb250cm9sTm9kZSkuY2FsbChpLHRoaXMpKSx0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvblJlbGVhc2VcIixidChvPXRoaXMuX2ZpbmlzaENvbm5lY3QpLmNhbGwobyx0aGlzKSksdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnU3RhcnRcIixidChuPXRoaXMuX2RyYWdTdGFydEVkZ2UpLmNhbGwobix0aGlzKSksdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25Ib2xkXCIsKGZ1bmN0aW9uKCl7fSkpfX0se2tleTpcImVkaXRFZGdlTW9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYoITAhPT10aGlzLmVkaXRNb2RlJiZ0aGlzLmVuYWJsZUVkaXRNb2RlKCksdGhpcy5fY2xlYW4oKSx0aGlzLmluTW9kZT1cImVkaXRFZGdlXCIsXCJvYmplY3RcIiE9PWRuKHRoaXMub3B0aW9ucy5lZGl0RWRnZSl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHRoaXMub3B0aW9ucy5lZGl0RWRnZS5lZGl0V2l0aG91dERyYWd8fCh0aGlzLmVkZ2VCZWluZ0VkaXRlZElkPXRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VJZHMoKVswXSx2b2lkIDA9PT10aGlzLmVkZ2VCZWluZ0VkaXRlZElkKSl7aWYoITA9PT10aGlzLmd1aUVuYWJsZWQpe3ZhciB0LGU9dGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07dGhpcy5tYW5pcHVsYXRpb25ET009e30sdGhpcy5fY3JlYXRlQmFja0J1dHRvbihlKSx0aGlzLl9jcmVhdGVTZXBlcmF0b3IoKSx0aGlzLl9jcmVhdGVEZXNjcmlwdGlvbihlLmVkaXRFZGdlRGVzY3JpcHRpb258fHRoaXMub3B0aW9ucy5sb2NhbGVzLmVuLmVkaXRFZGdlRGVzY3JpcHRpb24pLHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKHRoaXMuY2xvc2VEaXYsYnQodD10aGlzLnRvZ2dsZUVkaXRNb2RlKS5jYWxsKHQsdGhpcykpfWlmKHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQ9dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZUlkcygpWzBdLHZvaWQgMCE9PXRoaXMuZWRnZUJlaW5nRWRpdGVkSWQpe3ZhciBpLG8sbixyLHM9dGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdLGE9dGhpcy5fZ2V0TmV3VGFyZ2V0Tm9kZShzLmZyb20ueCxzLmZyb20ueSksaD10aGlzLl9nZXROZXdUYXJnZXROb2RlKHMudG8ueCxzLnRvLnkpO3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLnB1c2goYS5pZCksdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMucHVzaChoLmlkKSx0aGlzLmJvZHkubm9kZXNbYS5pZF09YSx0aGlzLmJvZHkubm9kZUluZGljZXMucHVzaChhLmlkKSx0aGlzLmJvZHkubm9kZXNbaC5pZF09aCx0aGlzLmJvZHkubm9kZUluZGljZXMucHVzaChoLmlkKSx0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvblRvdWNoXCIsYnQoaT10aGlzLl9jb250cm9sTm9kZVRvdWNoKS5jYWxsKGksdGhpcykpLHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uVGFwXCIsKGZ1bmN0aW9uKCl7fSkpLHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uSG9sZFwiLChmdW5jdGlvbigpe30pKSx0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkRyYWdTdGFydFwiLGJ0KG89dGhpcy5fY29udHJvbE5vZGVEcmFnU3RhcnQpLmNhbGwobyx0aGlzKSksdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnXCIsYnQobj10aGlzLl9jb250cm9sTm9kZURyYWcpLmNhbGwobix0aGlzKSksdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnRW5kXCIsYnQocj10aGlzLl9jb250cm9sTm9kZURyYWdFbmQpLmNhbGwocix0aGlzKSksdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25Nb3VzZU1vdmVcIiwoZnVuY3Rpb24oKXt9KSksdGhpcy5fdGVtcG9yYXJ5QmluZEV2ZW50KFwiYmVmb3JlRHJhd2luZ1wiLChmdW5jdGlvbih0KXt2YXIgZT1zLmVkZ2VUeXBlLmZpbmRCb3JkZXJQb3NpdGlvbnModCk7ITE9PT1hLnNlbGVjdGVkJiYoYS54PWUuZnJvbS54LGEueT1lLmZyb20ueSksITE9PT1oLnNlbGVjdGVkJiYoaC54PWUudG8ueCxoLnk9ZS50by55KX0pKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKX1lbHNlIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpfWVsc2V7dmFyIGQ9dGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdO3RoaXMuX3BlcmZvcm1FZGl0RWRnZShkLmZyb20uaWQsZC50by5pZCl9fX0se2tleTpcImRlbGV0ZVNlbGVjdGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzOyEwIT09dGhpcy5lZGl0TW9kZSYmdGhpcy5lbmFibGVFZGl0TW9kZSgpLHRoaXMuX2NsZWFuKCksdGhpcy5pbk1vZGU9XCJkZWxldGVcIjt2YXIgZT10aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2RlSWRzKCksaT10aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlSWRzKCksbz12b2lkIDA7aWYoZS5sZW5ndGg+MCl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspaWYoITA9PT10aGlzLmJvZHkubm9kZXNbZVtuXV0uaXNDbHVzdGVyKXJldHVybiB2b2lkIGFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdLmRlbGV0ZUNsdXN0ZXJFcnJvcnx8dGhpcy5vcHRpb25zLmxvY2FsZXMuZW4uZGVsZXRlQ2x1c3RlckVycm9yKTtcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuZGVsZXRlTm9kZSYmKG89dGhpcy5vcHRpb25zLmRlbGV0ZU5vZGUpfWVsc2UgaS5sZW5ndGg+MCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5vcHRpb25zLmRlbGV0ZUVkZ2UmJihvPXRoaXMub3B0aW9ucy5kZWxldGVFZGdlKTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBvKXt2YXIgcj17bm9kZXM6ZSxlZGdlczppfTtpZigyIT09by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIGZvciBkZWxldGUgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLCBjYWxsYmFjaylcIik7byhyLChmdW5jdGlvbihlKXtudWxsIT1lJiZcImRlbGV0ZVwiPT09dC5pbk1vZGU/KHQuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5yZW1vdmUoZS5lZGdlcyksdC5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShlLm5vZGVzKSx0LmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpLHQuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpKToodC5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKSx0LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKSl9KSl9ZWxzZSB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkucmVtb3ZlKGkpLHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5yZW1vdmUoZSksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKSx0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKX19LHtrZXk6XCJfc2V0dXBcIix2YWx1ZTpmdW5jdGlvbigpeyEwPT09dGhpcy5vcHRpb25zLmVuYWJsZWQ/KHRoaXMuZ3VpRW5hYmxlZD0hMCx0aGlzLl9jcmVhdGVXcmFwcGVycygpLCExPT09dGhpcy5lZGl0TW9kZT90aGlzLl9jcmVhdGVFZGl0QnV0dG9uKCk6dGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCkpOih0aGlzLl9yZW1vdmVNYW5pcHVsYXRpb25ET00oKSx0aGlzLmd1aUVuYWJsZWQ9ITEpfX0se2tleTpcIl9jcmVhdGVXcmFwcGVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZTsodm9pZCAwPT09dGhpcy5tYW5pcHVsYXRpb25EaXYmJih0aGlzLm1hbmlwdWxhdGlvbkRpdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMubWFuaXB1bGF0aW9uRGl2LmNsYXNzTmFtZT1cInZpcy1tYW5pcHVsYXRpb25cIiwhMD09PXRoaXMuZWRpdE1vZGU/dGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheT1cImJsb2NrXCI6dGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheT1cIm5vbmVcIix0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRpdikpLHZvaWQgMD09PXRoaXMuZWRpdE1vZGVEaXYmJih0aGlzLmVkaXRNb2RlRGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5lZGl0TW9kZURpdi5jbGFzc05hbWU9XCJ2aXMtZWRpdC1tb2RlXCIsITA9PT10aGlzLmVkaXRNb2RlP3RoaXMuZWRpdE1vZGVEaXYuc3R5bGUuZGlzcGxheT1cIm5vbmVcIjp0aGlzLmVkaXRNb2RlRGl2LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuZWRpdE1vZGVEaXYpKSx2b2lkIDA9PT10aGlzLmNsb3NlRGl2KSYmKHRoaXMuY2xvc2VEaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSx0aGlzLmNsb3NlRGl2LmNsYXNzTmFtZT1cInZpcy1jbG9zZVwiLHRoaXMuY2xvc2VEaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLG51bGwhPT0odD1udWxsPT09KGU9dGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV0pfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmNsb3NlKSYmdm9pZCAwIT09dD90OnRoaXMub3B0aW9ucy5sb2NhbGVzLmVuLmNsb3NlKSx0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXk9dGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSx0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNsb3NlRGl2KSl9fSx7a2V5OlwiX2dldE5ld1RhcmdldE5vZGVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXRoKHt9LHRoaXMub3B0aW9ucy5jb250cm9sTm9kZVN0eWxlKTtpLmlkPVwidGFyZ2V0Tm9kZVwiK2J1KCksaS5oaWRkZW49ITEsaS5waHlzaWNzPSExLGkueD10LGkueT1lO3ZhciBvPXRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZShpKTtyZXR1cm4gby5zaGFwZS5ib3VuZGluZ0JveD17bGVmdDp0LHJpZ2h0OnQsdG9wOmUsYm90dG9tOmV9LG99fSx7a2V5OlwiX2NyZWF0ZUVkaXRCdXR0b25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0O3RoaXMuX2NsZWFuKCksdGhpcy5tYW5pcHVsYXRpb25ET009e30sWGEodGhpcy5lZGl0TW9kZURpdik7dmFyIGU9dGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV0saT10aGlzLl9jcmVhdGVCdXR0b24oXCJlZGl0TW9kZVwiLFwidmlzLWVkaXQgdmlzLWVkaXQtbW9kZVwiLGUuZWRpdHx8dGhpcy5vcHRpb25zLmxvY2FsZXMuZW4uZWRpdCk7dGhpcy5lZGl0TW9kZURpdi5hcHBlbmRDaGlsZChpKSx0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhpLGJ0KHQ9dGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbCh0LHRoaXMpKX19LHtrZXk6XCJfY2xlYW5cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaW5Nb2RlPSExLCEwPT09dGhpcy5ndWlFbmFibGVkJiYoWGEodGhpcy5lZGl0TW9kZURpdiksWGEodGhpcy5tYW5pcHVsYXRpb25EaXYpLHRoaXMuX2NsZWFudXBET01FdmVudExpc3RlbmVycygpKSx0aGlzLl9jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcygpLHRoaXMuX3VuYmluZFRlbXBvcmFyeVVJcygpLHRoaXMuX3VuYmluZFRlbXBvcmFyeUV2ZW50cygpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZXN0b3JlUGh5c2ljc1wiKX19LHtrZXk6XCJfY2xlYW51cERPTUV2ZW50TGlzdGVuZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlLGk9V2YocW4odD10aGlzLl9kb21FdmVudExpc3RlbmVyQ2xlYW51cFF1ZXVlKS5jYWxsKHQsMCkpO3RyeXtmb3IoaS5zKCk7IShlPWkubigpKS5kb25lOyl7KDAsZS52YWx1ZSkoKX19Y2F0Y2godCl7aS5lKHQpfWZpbmFsbHl7aS5mKCl9fX0se2tleTpcIl9yZW1vdmVNYW5pcHVsYXRpb25ET01cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2NsZWFuKCksWGEodGhpcy5tYW5pcHVsYXRpb25EaXYpLFhhKHRoaXMuZWRpdE1vZGVEaXYpLFhhKHRoaXMuY2xvc2VEaXYpLHRoaXMubWFuaXB1bGF0aW9uRGl2JiZ0aGlzLmNhbnZhcy5mcmFtZS5yZW1vdmVDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRpdiksdGhpcy5lZGl0TW9kZURpdiYmdGhpcy5jYW52YXMuZnJhbWUucmVtb3ZlQ2hpbGQodGhpcy5lZGl0TW9kZURpdiksdGhpcy5jbG9zZURpdiYmdGhpcy5jYW52YXMuZnJhbWUucmVtb3ZlQ2hpbGQodGhpcy5jbG9zZURpdiksdGhpcy5tYW5pcHVsYXRpb25EaXY9dm9pZCAwLHRoaXMuZWRpdE1vZGVEaXY9dm9pZCAwLHRoaXMuY2xvc2VEaXY9dm9pZCAwfX0se2tleTpcIl9jcmVhdGVTZXBlcmF0b3JcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXToxO3RoaXMubWFuaXB1bGF0aW9uRE9NW1wic2VwZXJhdG9yTGluZURpdlwiK3RdPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5tYW5pcHVsYXRpb25ET01bXCJzZXBlcmF0b3JMaW5lRGl2XCIrdF0uY2xhc3NOYW1lPVwidmlzLXNlcGFyYXRvci1saW5lXCIsdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25ET01bXCJzZXBlcmF0b3JMaW5lRGl2XCIrdF0pfX0se2tleTpcIl9jcmVhdGVBZGROb2RlQnV0dG9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGUsaT10aGlzLl9jcmVhdGVCdXR0b24oXCJhZGROb2RlXCIsXCJ2aXMtYWRkXCIsdC5hZGROb2RlfHx0aGlzLm9wdGlvbnMubG9jYWxlcy5lbi5hZGROb2RlKTt0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChpKSx0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhpLGJ0KGU9dGhpcy5hZGROb2RlTW9kZSkuY2FsbChlLHRoaXMpKX19LHtrZXk6XCJfY3JlYXRlQWRkRWRnZUJ1dHRvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlLGk9dGhpcy5fY3JlYXRlQnV0dG9uKFwiYWRkRWRnZVwiLFwidmlzLWNvbm5lY3RcIix0LmFkZEVkZ2V8fHRoaXMub3B0aW9ucy5sb2NhbGVzLmVuLmFkZEVkZ2UpO3RoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGkpLHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKGksYnQoZT10aGlzLmFkZEVkZ2VNb2RlKS5jYWxsKGUsdGhpcykpfX0se2tleTpcIl9jcmVhdGVFZGl0Tm9kZUJ1dHRvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlLGk9dGhpcy5fY3JlYXRlQnV0dG9uKFwiZWRpdE5vZGVcIixcInZpcy1lZGl0XCIsdC5lZGl0Tm9kZXx8dGhpcy5vcHRpb25zLmxvY2FsZXMuZW4uZWRpdE5vZGUpO3RoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGkpLHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKGksYnQoZT10aGlzLmVkaXROb2RlKS5jYWxsKGUsdGhpcykpfX0se2tleTpcIl9jcmVhdGVFZGl0RWRnZUJ1dHRvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlLGk9dGhpcy5fY3JlYXRlQnV0dG9uKFwiZWRpdEVkZ2VcIixcInZpcy1lZGl0XCIsdC5lZGl0RWRnZXx8dGhpcy5vcHRpb25zLmxvY2FsZXMuZW4uZWRpdEVkZ2UpO3RoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGkpLHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKGksYnQoZT10aGlzLmVkaXRFZGdlTW9kZSkuY2FsbChlLHRoaXMpKX19LHtrZXk6XCJfY3JlYXRlRGVsZXRlQnV0dG9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGUsaTtpPXRoaXMub3B0aW9ucy5ydGw/XCJ2aXMtZGVsZXRlLXJ0bFwiOlwidmlzLWRlbGV0ZVwiO3ZhciBvPXRoaXMuX2NyZWF0ZUJ1dHRvbihcImRlbGV0ZVwiLGksdC5kZWx8fHRoaXMub3B0aW9ucy5sb2NhbGVzLmVuLmRlbCk7dGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQobyksdGhpcy5fYmluZEVsZW1lbnRFdmVudHMobyxidChlPXRoaXMuZGVsZXRlU2VsZWN0ZWQpLmNhbGwoZSx0aGlzKSl9fSx7a2V5OlwiX2NyZWF0ZUJhY2tCdXR0b25cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZSxpPXRoaXMuX2NyZWF0ZUJ1dHRvbihcImJhY2tcIixcInZpcy1iYWNrXCIsdC5iYWNrfHx0aGlzLm9wdGlvbnMubG9jYWxlcy5lbi5iYWNrKTt0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChpKSx0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhpLGJ0KGU9dGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKS5jYWxsKGUsdGhpcykpfX0se2tleTpcIl9jcmVhdGVCdXR0b25cIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dmFyIG89YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOlwidmlzLWxhYmVsXCI7cmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uRE9NW3QrXCJEaXZcIl09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSx0aGlzLm1hbmlwdWxhdGlvbkRPTVt0K1wiRGl2XCJdLmNsYXNzTmFtZT1cInZpcy1idXR0b24gXCIrZSx0aGlzLm1hbmlwdWxhdGlvbkRPTVt0K1wiTGFiZWxcIl09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLm1hbmlwdWxhdGlvbkRPTVt0K1wiTGFiZWxcIl0uY2xhc3NOYW1lPW8sdGhpcy5tYW5pcHVsYXRpb25ET01bdCtcIkxhYmVsXCJdLmlubmVyVGV4dD1pLHRoaXMubWFuaXB1bGF0aW9uRE9NW3QrXCJEaXZcIl0uYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25ET01bdCtcIkxhYmVsXCJdKSx0aGlzLm1hbmlwdWxhdGlvbkRPTVt0K1wiRGl2XCJdfX0se2tleTpcIl9jcmVhdGVEZXNjcmlwdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMubWFuaXB1bGF0aW9uRE9NLmRlc2NyaXB0aW9uTGFiZWw9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLm1hbmlwdWxhdGlvbkRPTS5kZXNjcmlwdGlvbkxhYmVsLmNsYXNzTmFtZT1cInZpcy1ub25lXCIsdGhpcy5tYW5pcHVsYXRpb25ET00uZGVzY3JpcHRpb25MYWJlbC5pbm5lclRleHQ9dCx0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRPTS5kZXNjcmlwdGlvbkxhYmVsKX19LHtrZXk6XCJfdGVtcG9yYXJ5QmluZEV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zLnB1c2goe2V2ZW50OnQsYm91bmRGdW5jdGlvbjplfSksdGhpcy5ib2R5LmVtaXR0ZXIub24odCxlKX19LHtrZXk6XCJfdGVtcG9yYXJ5QmluZFVJXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZih2b2lkIDA9PT10aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnNbdF0pdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBVSSBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdC4gVHlwbz8gWW91IHRyaWVkOiBcIit0K1wiIHBvc3NpYmxlIGFyZTogXCIrTHIoeG4odGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzKSkpO3RoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnNbdF09dGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW3RdLHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1t0XT1lfX0se2tleTpcIl91bmJpbmRUZW1wb3JhcnlVSXNcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zLHQpJiYodGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW3RdPXRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnNbdF0sZGVsZXRlIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnNbdF0pO3RoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnM9e319fSx7a2V5OlwiX3VuYmluZFRlbXBvcmFyeUV2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDx0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zLmxlbmd0aDt0Kyspe3ZhciBlPXRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnNbdF0uZXZlbnQsaT10aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zW3RdLmJvdW5kRnVuY3Rpb247dGhpcy5ib2R5LmVtaXR0ZXIub2ZmKGUsaSl9dGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucz1bXX19LHtrZXk6XCJfYmluZEVsZW1lbnRFdmVudHNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPW5ldyBTaCh0LHt9KTtUdShpLGUpLHRoaXMuX2RvbUV2ZW50TGlzdGVuZXJDbGVhbnVwUXVldWUucHVzaCgoZnVuY3Rpb24oKXtpLmRlc3Ryb3koKX0pKTt2YXIgbz1mdW5jdGlvbih0KXt2YXIgaT10LmtleUNvZGUsbz10LmtleTtcIkVudGVyXCIhPT1vJiZcIiBcIiE9PW8mJjEzIT09aSYmMzIhPT1pfHxlKCl9O3QuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsbywhMSksdGhpcy5fZG9tRXZlbnRMaXN0ZW5lckNsZWFudXBRdWV1ZS5wdXNoKChmdW5jdGlvbigpe3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsbywhMSl9KSl9fSx7a2V5OlwiX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzLmxlbmd0aDt0Kyspe3ZhciBlO3RoaXMuYm9keS5lZGdlc1t0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1t0XV0uZGlzY29ubmVjdCgpLGRlbGV0ZSB0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbdF1dO3ZhciBpLG89TXIoZT10aGlzLmJvZHkuZWRnZUluZGljZXMpLmNhbGwoZSx0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1t0XSk7aWYoLTEhPT1vKXFuKGk9dGhpcy5ib2R5LmVkZ2VJbmRpY2VzKS5jYWxsKGksbywxKX1mb3IodmFyIG49MDtuPHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLmxlbmd0aDtuKyspe3ZhciByO2RlbGV0ZSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbbl1dO3ZhciBzLGE9TXIocj10aGlzLmJvZHkubm9kZUluZGljZXMpLmNhbGwocix0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1tuXSk7aWYoLTEhPT1hKXFuKHM9dGhpcy5ib2R5Lm5vZGVJbmRpY2VzKS5jYWxsKHMsYSwxKX10aGlzLnRlbXBvcmFyeUlkcz17bm9kZXM6W10sZWRnZXM6W119fX0se2tleTpcIl9jb250cm9sTm9kZVRvdWNoXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCksdGhpcy5sYXN0VG91Y2g9dGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKHQuY2VudGVyKSx0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbj1jdCh7fSx0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbil9fSx7a2V5OlwiX2NvbnRyb2xOb2RlRHJhZ1N0YXJ0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxhc3RUb3VjaCxlPXRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QodCksaT10aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dLG89dGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzFdXSxuPXRoaXMuYm9keS5lZGdlc1t0aGlzLmVkZ2VCZWluZ0VkaXRlZElkXTt0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGU9dm9pZCAwO3ZhciByPWkuaXNPdmVybGFwcGluZ1dpdGgoZSkscz1vLmlzT3ZlcmxhcHBpbmdXaXRoKGUpOyEwPT09cj8odGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlPWksbi5lZGdlVHlwZS5mcm9tPWkpOiEwPT09cyYmKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZT1vLG4uZWRnZVR5cGUudG89byksdm9pZCAwIT09dGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlJiZ0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0T2JqZWN0KHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIil9fSx7a2V5OlwiX2NvbnRyb2xOb2RlRHJhZ1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJkaXNhYmxlUGh5c2ljc1wiKTt2YXIgZT10aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIodC5jZW50ZXIpLGk9dGhpcy5jYW52YXMuRE9NdG9DYW52YXMoZSk7dm9pZCAwIT09dGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlPyh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUueD1pLngsdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlLnk9aS55KTp0aGlzLmludGVyYWN0aW9uSGFuZGxlci5vbkRyYWcodCksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIil9fSx7a2V5OlwiX2NvbnRyb2xOb2RlRHJhZ0VuZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcih0LmNlbnRlciksaT10aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KGUpLG89dGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdO2lmKHZvaWQgMCE9PXRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSl7dGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7Zm9yKHZhciBuPXRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgoaSkscj12b2lkIDAscz1uLmxlbmd0aC0xO3M+PTA7cy0tKWlmKG5bc10hPT10aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUuaWQpe3I9dGhpcy5ib2R5Lm5vZGVzW25bc11dO2JyZWFrfWlmKHZvaWQgMCE9PXImJnZvaWQgMCE9PXRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSlpZighMD09PXIuaXNDbHVzdGVyKWFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdLmNyZWF0ZUVkZ2VFcnJvcnx8dGhpcy5vcHRpb25zLmxvY2FsZXMuZW4uY3JlYXRlRWRnZUVycm9yKTtlbHNle3ZhciBhPXRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1swXV07dGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlLmlkPT09YS5pZD90aGlzLl9wZXJmb3JtRWRpdEVkZ2Uoci5pZCxvLnRvLmlkKTp0aGlzLl9wZXJmb3JtRWRpdEVkZ2Uoby5mcm9tLmlkLHIuaWQpfWVsc2Ugby51cGRhdGVFZGdlVHlwZSgpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZXN0b3JlUGh5c2ljc1wiKTt0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKX19fSx7a2V5OlwiX2hhbmRsZUNvbm5lY3RcIix2YWx1ZTpmdW5jdGlvbih0KXtpZigobmV3IERhdGUpLnZhbHVlT2YoKS10aGlzLnRvdWNoVGltZT4xMDApe3RoaXMubGFzdFRvdWNoPXRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcih0LmNlbnRlciksdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb249Y3Qoe30sdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24pLHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLmRyYWcucG9pbnRlcj10aGlzLmxhc3RUb3VjaCx0aGlzLmludGVyYWN0aW9uSGFuZGxlci5kcmFnLnRyYW5zbGF0aW9uPXRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uO3ZhciBlPXRoaXMubGFzdFRvdWNoLGk9dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdChlKTtpZih2b2lkIDAhPT1pKWlmKCEwPT09aS5pc0NsdXN0ZXIpYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV0uY3JlYXRlRWRnZUVycm9yfHx0aGlzLm9wdGlvbnMubG9jYWxlcy5lbi5jcmVhdGVFZGdlRXJyb3IpO2Vsc2V7dmFyIG89dGhpcy5fZ2V0TmV3VGFyZ2V0Tm9kZShpLngsaS55KTt0aGlzLmJvZHkubm9kZXNbby5pZF09byx0aGlzLmJvZHkubm9kZUluZGljZXMucHVzaChvLmlkKTt2YXIgbj10aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2Uoe2lkOlwiY29ubmVjdGlvbkVkZ2VcIitidSgpLGZyb206aS5pZCx0bzpvLmlkLHBoeXNpY3M6ITEsc21vb3RoOntlbmFibGVkOiEwLHR5cGU6XCJjb250aW51b3VzXCIscm91bmRuZXNzOi41fX0pO3RoaXMuYm9keS5lZGdlc1tuLmlkXT1uLHRoaXMuYm9keS5lZGdlSW5kaWNlcy5wdXNoKG4uaWQpLHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLnB1c2goby5pZCksdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXMucHVzaChuLmlkKX10aGlzLnRvdWNoVGltZT0obmV3IERhdGUpLnZhbHVlT2YoKX19fSx7a2V5OlwiX2RyYWdDb250cm9sTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcih0LmNlbnRlciksaT10aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KGUpLG89dm9pZCAwO3ZvaWQgMCE9PXRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdJiYobz10aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbMF1dLmZyb21JZCk7Zm9yKHZhciBuPXRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgoaSkscj12b2lkIDAscz1uLmxlbmd0aC0xO3M+PTA7cy0tKXt2YXIgYTtpZigtMT09PU1yKGE9dGhpcy50ZW1wb3JhcnlJZHMubm9kZXMpLmNhbGwoYSxuW3NdKSl7cj10aGlzLmJvZHkubm9kZXNbbltzXV07YnJlYWt9fWlmKHQuY29udHJvbEVkZ2U9e2Zyb206byx0bzpyP3IuaWQ6dm9pZCAwfSx0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiY29udHJvbE5vZGVEcmFnZ2luZ1wiLHQsZSksdm9pZCAwIT09dGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF0pe3ZhciBoPXRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1swXV07aC54PXRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKGUueCksaC55PXRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKGUueSksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIil9ZWxzZSB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5vbkRyYWcodCl9fSx7a2V5OlwiX2ZpbmlzaENvbm5lY3RcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIodC5jZW50ZXIpLGk9dGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChlKSxvPXZvaWQgMDt2b2lkIDAhPT10aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1swXSYmKG89dGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdXS5mcm9tSWQpO2Zvcih2YXIgbj10aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKGkpLHI9dm9pZCAwLHM9bi5sZW5ndGgtMTtzPj0wO3MtLSl7dmFyIGE7aWYoLTE9PT1NcihhPXRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzKS5jYWxsKGEsbltzXSkpe3I9dGhpcy5ib2R5Lm5vZGVzW25bc11dO2JyZWFrfX10aGlzLl9jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcygpLHZvaWQgMCE9PXImJighMD09PXIuaXNDbHVzdGVyP2FsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdLmNyZWF0ZUVkZ2VFcnJvcnx8dGhpcy5vcHRpb25zLmxvY2FsZXMuZW4uY3JlYXRlRWRnZUVycm9yKTp2b2lkIDAhPT10aGlzLmJvZHkubm9kZXNbb10mJnZvaWQgMCE9PXRoaXMuYm9keS5ub2Rlc1tyLmlkXSYmdGhpcy5fcGVyZm9ybUFkZEVkZ2UobyxyLmlkKSksdC5jb250cm9sRWRnZT17ZnJvbTpvLHRvOnI/ci5pZDp2b2lkIDB9LHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJjb250cm9sTm9kZURyYWdFbmRcIix0LGUpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpfX0se2tleTpcIl9kcmFnU3RhcnRFZGdlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5sYXN0VG91Y2g7dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdTdGFydFwiLHQsZSx2b2lkIDAsITApfX0se2tleTpcIl9wZXJmb3JtQWRkTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsaT17aWQ6YnUoKSx4OnQucG9pbnRlci5jYW52YXMueCx5OnQucG9pbnRlci5jYW52YXMueSxsYWJlbDpcIm5ld1wifTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuYWRkTm9kZSl7aWYoMiE9PXRoaXMub3B0aW9ucy5hZGROb2RlLmxlbmd0aCl0aHJvdyB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKSxuZXcgRXJyb3IoXCJUaGUgZnVuY3Rpb24gZm9yIGFkZCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsY2FsbGJhY2spXCIpO3RoaXMub3B0aW9ucy5hZGROb2RlKGksKGZ1bmN0aW9uKHQpe251bGwhPXQmJlwiYWRkTm9kZVwiPT09ZS5pbk1vZGUmJmUuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5hZGQodCksZS5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCl9KSl9ZWxzZSB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkuYWRkKGkpLHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpfX0se2tleTpcIl9wZXJmb3JtQWRkRWRnZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9dGhpcyxvPXtmcm9tOnQsdG86ZX07aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5vcHRpb25zLmFkZEVkZ2Upe2lmKDIhPT10aGlzLm9wdGlvbnMuYWRkRWRnZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIGZvciBjb25uZWN0IGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSxjYWxsYmFjaylcIik7dGhpcy5vcHRpb25zLmFkZEVkZ2UobywoZnVuY3Rpb24odCl7bnVsbCE9dCYmXCJhZGRFZGdlXCI9PT1pLmluTW9kZSYmKGkuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5hZGQodCksaS5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCksaS5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCkpfSkpfWVsc2UgdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLmFkZChvKSx0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKSx0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKX19LHtrZXk6XCJfcGVyZm9ybUVkaXRFZGdlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLG89e2lkOnRoaXMuZWRnZUJlaW5nRWRpdGVkSWQsZnJvbTp0LHRvOmUsbGFiZWw6dGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0KHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQpLmxhYmVsfSxuPXRoaXMub3B0aW9ucy5lZGl0RWRnZTtpZihcIm9iamVjdFwiPT09ZG4obikmJihuPW4uZWRpdFdpdGhvdXREcmFnKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBuKXtpZigyIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIGZvciBlZGl0IGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSwgY2FsbGJhY2spXCIpO24obywoZnVuY3Rpb24odCl7bnVsbD09dHx8XCJlZGl0RWRnZVwiIT09aS5pbk1vZGU/KGkuYm9keS5lZGdlc1tvLmlkXS51cGRhdGVFZGdlVHlwZSgpLGkuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpLGkuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpKTooaS5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnVwZGF0ZSh0KSxpLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKSxpLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKSl9KSl9ZWxzZSB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkudXBkYXRlKG8pLHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpLHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpfX1dKSx0fSgpLFVmPVwic3RyaW5nXCIsWWY9XCJib29sZWFuXCIsWGY9XCJudW1iZXJcIixHZj1cImFycmF5XCIsS2Y9XCJvYmplY3RcIiwkZj1bXCJhcnJvd1wiLFwiYmFyXCIsXCJib3hcIixcImNpcmNsZVwiLFwiY3Jvd1wiLFwiY3VydmVcIixcImRpYW1vbmRcIixcImltYWdlXCIsXCJpbnZfY3VydmVcIixcImludl90cmlhbmdsZVwiLFwidHJpYW5nbGVcIixcInZlZVwiXSxRZj17Ym9yZGVyV2lkdGg6e251bWJlcjpYZn0sYm9yZGVyV2lkdGhTZWxlY3RlZDp7bnVtYmVyOlhmLHVuZGVmaW5lZDpcInVuZGVmaW5lZFwifSxicm9rZW5JbWFnZTp7c3RyaW5nOlVmLHVuZGVmaW5lZDpcInVuZGVmaW5lZFwifSxjaG9zZW46e2xhYmVsOntib29sZWFuOllmLGZ1bmN0aW9uOlwiZnVuY3Rpb25cIn0sbm9kZTp7Ym9vbGVhbjpZZixmdW5jdGlvbjpcImZ1bmN0aW9uXCJ9LF9fdHlwZV9fOntvYmplY3Q6S2YsYm9vbGVhbjpZZn19LGNvbG9yOntib3JkZXI6e3N0cmluZzpVZn0sYmFja2dyb3VuZDp7c3RyaW5nOlVmfSxoaWdobGlnaHQ6e2JvcmRlcjp7c3RyaW5nOlVmfSxiYWNrZ3JvdW5kOntzdHJpbmc6VWZ9LF9fdHlwZV9fOntvYmplY3Q6S2Ysc3RyaW5nOlVmfX0saG92ZXI6e2JvcmRlcjp7c3RyaW5nOlVmfSxiYWNrZ3JvdW5kOntzdHJpbmc6VWZ9LF9fdHlwZV9fOntvYmplY3Q6S2Ysc3RyaW5nOlVmfX0sX190eXBlX186e29iamVjdDpLZixzdHJpbmc6VWZ9fSxvcGFjaXR5OntudW1iZXI6WGYsdW5kZWZpbmVkOlwidW5kZWZpbmVkXCJ9LGZpeGVkOnt4Ontib29sZWFuOllmfSx5Ontib29sZWFuOllmfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWZ9fSxmb250OnthbGlnbjp7c3RyaW5nOlVmfSxjb2xvcjp7c3RyaW5nOlVmfSxzaXplOntudW1iZXI6WGZ9LGZhY2U6e3N0cmluZzpVZn0sYmFja2dyb3VuZDp7c3RyaW5nOlVmfSxzdHJva2VXaWR0aDp7bnVtYmVyOlhmfSxzdHJva2VDb2xvcjp7c3RyaW5nOlVmfSx2YWRqdXN0OntudW1iZXI6WGZ9LG11bHRpOntib29sZWFuOllmLHN0cmluZzpVZn0sYm9sZDp7Y29sb3I6e3N0cmluZzpVZn0sc2l6ZTp7bnVtYmVyOlhmfSxmYWNlOntzdHJpbmc6VWZ9LG1vZDp7c3RyaW5nOlVmfSx2YWRqdXN0OntudW1iZXI6WGZ9LF9fdHlwZV9fOntvYmplY3Q6S2Ysc3RyaW5nOlVmfX0sYm9sZGl0YWw6e2NvbG9yOntzdHJpbmc6VWZ9LHNpemU6e251bWJlcjpYZn0sZmFjZTp7c3RyaW5nOlVmfSxtb2Q6e3N0cmluZzpVZn0sdmFkanVzdDp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLHN0cmluZzpVZn19LGl0YWw6e2NvbG9yOntzdHJpbmc6VWZ9LHNpemU6e251bWJlcjpYZn0sZmFjZTp7c3RyaW5nOlVmfSxtb2Q6e3N0cmluZzpVZn0sdmFkanVzdDp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLHN0cmluZzpVZn19LG1vbm86e2NvbG9yOntzdHJpbmc6VWZ9LHNpemU6e251bWJlcjpYZn0sZmFjZTp7c3RyaW5nOlVmfSxtb2Q6e3N0cmluZzpVZn0sdmFkanVzdDp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLHN0cmluZzpVZn19LF9fdHlwZV9fOntvYmplY3Q6S2Ysc3RyaW5nOlVmfX0sZ3JvdXA6e3N0cmluZzpVZixudW1iZXI6WGYsdW5kZWZpbmVkOlwidW5kZWZpbmVkXCJ9LGhlaWdodENvbnN0cmFpbnQ6e21pbmltdW06e251bWJlcjpYZn0sdmFsaWduOntzdHJpbmc6VWZ9LF9fdHlwZV9fOntvYmplY3Q6S2YsYm9vbGVhbjpZZixudW1iZXI6WGZ9fSxoaWRkZW46e2Jvb2xlYW46WWZ9LGljb246e2ZhY2U6e3N0cmluZzpVZn0sY29kZTp7c3RyaW5nOlVmfSxzaXplOntudW1iZXI6WGZ9LGNvbG9yOntzdHJpbmc6VWZ9LHdlaWdodDp7c3RyaW5nOlVmLG51bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZn19LGlkOntzdHJpbmc6VWYsbnVtYmVyOlhmfSxpbWFnZTp7c2VsZWN0ZWQ6e3N0cmluZzpVZix1bmRlZmluZWQ6XCJ1bmRlZmluZWRcIn0sdW5zZWxlY3RlZDp7c3RyaW5nOlVmLHVuZGVmaW5lZDpcInVuZGVmaW5lZFwifSxfX3R5cGVfXzp7b2JqZWN0OktmLHN0cmluZzpVZn19LGltYWdlUGFkZGluZzp7dG9wOntudW1iZXI6WGZ9LHJpZ2h0OntudW1iZXI6WGZ9LGJvdHRvbTp7bnVtYmVyOlhmfSxsZWZ0OntudW1iZXI6WGZ9LF9fdHlwZV9fOntvYmplY3Q6S2YsbnVtYmVyOlhmfX0sbGFiZWw6e3N0cmluZzpVZix1bmRlZmluZWQ6XCJ1bmRlZmluZWRcIn0sbGFiZWxIaWdobGlnaHRCb2xkOntib29sZWFuOllmfSxsZXZlbDp7bnVtYmVyOlhmLHVuZGVmaW5lZDpcInVuZGVmaW5lZFwifSxtYXJnaW46e3RvcDp7bnVtYmVyOlhmfSxyaWdodDp7bnVtYmVyOlhmfSxib3R0b206e251bWJlcjpYZn0sbGVmdDp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLG51bWJlcjpYZn19LG1hc3M6e251bWJlcjpYZn0scGh5c2ljczp7Ym9vbGVhbjpZZn0sc2NhbGluZzp7bWluOntudW1iZXI6WGZ9LG1heDp7bnVtYmVyOlhmfSxsYWJlbDp7ZW5hYmxlZDp7Ym9vbGVhbjpZZn0sbWluOntudW1iZXI6WGZ9LG1heDp7bnVtYmVyOlhmfSxtYXhWaXNpYmxlOntudW1iZXI6WGZ9LGRyYXdUaHJlc2hvbGQ6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZixib29sZWFuOllmfX0sY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOntmdW5jdGlvbjpcImZ1bmN0aW9uXCJ9LF9fdHlwZV9fOntvYmplY3Q6S2Z9fSxzaGFkb3c6e2VuYWJsZWQ6e2Jvb2xlYW46WWZ9LGNvbG9yOntzdHJpbmc6VWZ9LHNpemU6e251bWJlcjpYZn0seDp7bnVtYmVyOlhmfSx5OntudW1iZXI6WGZ9LF9fdHlwZV9fOntvYmplY3Q6S2YsYm9vbGVhbjpZZn19LHNoYXBlOntzdHJpbmc6W1wiY3VzdG9tXCIsXCJlbGxpcHNlXCIsXCJjaXJjbGVcIixcImRhdGFiYXNlXCIsXCJib3hcIixcInRleHRcIixcImltYWdlXCIsXCJjaXJjdWxhckltYWdlXCIsXCJkaWFtb25kXCIsXCJkb3RcIixcInN0YXJcIixcInRyaWFuZ2xlXCIsXCJ0cmlhbmdsZURvd25cIixcInNxdWFyZVwiLFwiaWNvblwiLFwiaGV4YWdvblwiXX0sY3R4UmVuZGVyZXI6e2Z1bmN0aW9uOlwiZnVuY3Rpb25cIn0sc2hhcGVQcm9wZXJ0aWVzOntib3JkZXJEYXNoZXM6e2Jvb2xlYW46WWYsYXJyYXk6R2Z9LGJvcmRlclJhZGl1czp7bnVtYmVyOlhmfSxpbnRlcnBvbGF0aW9uOntib29sZWFuOllmfSx1c2VJbWFnZVNpemU6e2Jvb2xlYW46WWZ9LHVzZUJvcmRlcldpdGhJbWFnZTp7Ym9vbGVhbjpZZn0sY29vcmRpbmF0ZU9yaWdpbjp7c3RyaW5nOltcImNlbnRlclwiLFwidG9wLWxlZnRcIl19LF9fdHlwZV9fOntvYmplY3Q6S2Z9fSxzaXplOntudW1iZXI6WGZ9LHRpdGxlOntzdHJpbmc6VWYsZG9tOlwiZG9tXCIsdW5kZWZpbmVkOlwidW5kZWZpbmVkXCJ9LHZhbHVlOntudW1iZXI6WGYsdW5kZWZpbmVkOlwidW5kZWZpbmVkXCJ9LHdpZHRoQ29uc3RyYWludDp7bWluaW11bTp7bnVtYmVyOlhmfSxtYXhpbXVtOntudW1iZXI6WGZ9LF9fdHlwZV9fOntvYmplY3Q6S2YsYm9vbGVhbjpZZixudW1iZXI6WGZ9fSx4OntudW1iZXI6WGZ9LHk6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZn19LFpmPXtjb25maWd1cmU6e2VuYWJsZWQ6e2Jvb2xlYW46WWZ9LGZpbHRlcjp7Ym9vbGVhbjpZZixzdHJpbmc6VWYsYXJyYXk6R2YsZnVuY3Rpb246XCJmdW5jdGlvblwifSxjb250YWluZXI6e2RvbTpcImRvbVwifSxzaG93QnV0dG9uOntib29sZWFuOllmfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWYsc3RyaW5nOlVmLGFycmF5OkdmLGZ1bmN0aW9uOlwiZnVuY3Rpb25cIn19LGVkZ2VzOnthcnJvd3M6e3RvOntlbmFibGVkOntib29sZWFuOllmfSxzY2FsZUZhY3Rvcjp7bnVtYmVyOlhmfSx0eXBlOntzdHJpbmc6JGZ9LGltYWdlSGVpZ2h0OntudW1iZXI6WGZ9LGltYWdlV2lkdGg6e251bWJlcjpYZn0sc3JjOntzdHJpbmc6VWZ9LF9fdHlwZV9fOntvYmplY3Q6S2YsYm9vbGVhbjpZZn19LG1pZGRsZTp7ZW5hYmxlZDp7Ym9vbGVhbjpZZn0sc2NhbGVGYWN0b3I6e251bWJlcjpYZn0sdHlwZTp7c3RyaW5nOiRmfSxpbWFnZVdpZHRoOntudW1iZXI6WGZ9LGltYWdlSGVpZ2h0OntudW1iZXI6WGZ9LHNyYzp7c3RyaW5nOlVmfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWZ9fSxmcm9tOntlbmFibGVkOntib29sZWFuOllmfSxzY2FsZUZhY3Rvcjp7bnVtYmVyOlhmfSx0eXBlOntzdHJpbmc6JGZ9LGltYWdlV2lkdGg6e251bWJlcjpYZn0saW1hZ2VIZWlnaHQ6e251bWJlcjpYZn0sc3JjOntzdHJpbmc6VWZ9LF9fdHlwZV9fOntvYmplY3Q6S2YsYm9vbGVhbjpZZn19LF9fdHlwZV9fOntzdHJpbmc6W1wiZnJvbVwiLFwidG9cIixcIm1pZGRsZVwiXSxvYmplY3Q6S2Z9fSxlbmRQb2ludE9mZnNldDp7ZnJvbTp7bnVtYmVyOlhmfSx0bzp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLG51bWJlcjpYZn19LGFycm93U3RyaWtldGhyb3VnaDp7Ym9vbGVhbjpZZn0sYmFja2dyb3VuZDp7ZW5hYmxlZDp7Ym9vbGVhbjpZZn0sY29sb3I6e3N0cmluZzpVZn0sc2l6ZTp7bnVtYmVyOlhmfSxkYXNoZXM6e2Jvb2xlYW46WWYsYXJyYXk6R2Z9LF9fdHlwZV9fOntvYmplY3Q6S2YsYm9vbGVhbjpZZn19LGNob3Nlbjp7bGFiZWw6e2Jvb2xlYW46WWYsZnVuY3Rpb246XCJmdW5jdGlvblwifSxlZGdlOntib29sZWFuOllmLGZ1bmN0aW9uOlwiZnVuY3Rpb25cIn0sX190eXBlX186e29iamVjdDpLZixib29sZWFuOllmfX0sY29sb3I6e2NvbG9yOntzdHJpbmc6VWZ9LGhpZ2hsaWdodDp7c3RyaW5nOlVmfSxob3Zlcjp7c3RyaW5nOlVmfSxpbmhlcml0OntzdHJpbmc6W1wiZnJvbVwiLFwidG9cIixcImJvdGhcIl0sYm9vbGVhbjpZZn0sb3BhY2l0eTp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLHN0cmluZzpVZn19LGRhc2hlczp7Ym9vbGVhbjpZZixhcnJheTpHZn0sZm9udDp7Y29sb3I6e3N0cmluZzpVZn0sc2l6ZTp7bnVtYmVyOlhmfSxmYWNlOntzdHJpbmc6VWZ9LGJhY2tncm91bmQ6e3N0cmluZzpVZn0sc3Ryb2tlV2lkdGg6e251bWJlcjpYZn0sc3Ryb2tlQ29sb3I6e3N0cmluZzpVZn0sYWxpZ246e3N0cmluZzpbXCJob3Jpem9udGFsXCIsXCJ0b3BcIixcIm1pZGRsZVwiLFwiYm90dG9tXCJdfSx2YWRqdXN0OntudW1iZXI6WGZ9LG11bHRpOntib29sZWFuOllmLHN0cmluZzpVZn0sYm9sZDp7Y29sb3I6e3N0cmluZzpVZn0sc2l6ZTp7bnVtYmVyOlhmfSxmYWNlOntzdHJpbmc6VWZ9LG1vZDp7c3RyaW5nOlVmfSx2YWRqdXN0OntudW1iZXI6WGZ9LF9fdHlwZV9fOntvYmplY3Q6S2Ysc3RyaW5nOlVmfX0sYm9sZGl0YWw6e2NvbG9yOntzdHJpbmc6VWZ9LHNpemU6e251bWJlcjpYZn0sZmFjZTp7c3RyaW5nOlVmfSxtb2Q6e3N0cmluZzpVZn0sdmFkanVzdDp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLHN0cmluZzpVZn19LGl0YWw6e2NvbG9yOntzdHJpbmc6VWZ9LHNpemU6e251bWJlcjpYZn0sZmFjZTp7c3RyaW5nOlVmfSxtb2Q6e3N0cmluZzpVZn0sdmFkanVzdDp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLHN0cmluZzpVZn19LG1vbm86e2NvbG9yOntzdHJpbmc6VWZ9LHNpemU6e251bWJlcjpYZn0sZmFjZTp7c3RyaW5nOlVmfSxtb2Q6e3N0cmluZzpVZn0sdmFkanVzdDp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLHN0cmluZzpVZn19LF9fdHlwZV9fOntvYmplY3Q6S2Ysc3RyaW5nOlVmfX0saGlkZGVuOntib29sZWFuOllmfSxob3ZlcldpZHRoOntmdW5jdGlvbjpcImZ1bmN0aW9uXCIsbnVtYmVyOlhmfSxsYWJlbDp7c3RyaW5nOlVmLHVuZGVmaW5lZDpcInVuZGVmaW5lZFwifSxsYWJlbEhpZ2hsaWdodEJvbGQ6e2Jvb2xlYW46WWZ9LGxlbmd0aDp7bnVtYmVyOlhmLHVuZGVmaW5lZDpcInVuZGVmaW5lZFwifSxwaHlzaWNzOntib29sZWFuOllmfSxzY2FsaW5nOnttaW46e251bWJlcjpYZn0sbWF4OntudW1iZXI6WGZ9LGxhYmVsOntlbmFibGVkOntib29sZWFuOllmfSxtaW46e251bWJlcjpYZn0sbWF4OntudW1iZXI6WGZ9LG1heFZpc2libGU6e251bWJlcjpYZn0sZHJhd1RocmVzaG9sZDp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWZ9fSxjdXN0b21TY2FsaW5nRnVuY3Rpb246e2Z1bmN0aW9uOlwiZnVuY3Rpb25cIn0sX190eXBlX186e29iamVjdDpLZn19LHNlbGVjdGlvbldpZHRoOntmdW5jdGlvbjpcImZ1bmN0aW9uXCIsbnVtYmVyOlhmfSxzZWxmUmVmZXJlbmNlU2l6ZTp7bnVtYmVyOlhmfSxzZWxmUmVmZXJlbmNlOntzaXplOntudW1iZXI6WGZ9LGFuZ2xlOntudW1iZXI6WGZ9LHJlbmRlckJlaGluZFRoZU5vZGU6e2Jvb2xlYW46WWZ9LF9fdHlwZV9fOntvYmplY3Q6S2Z9fSxzaGFkb3c6e2VuYWJsZWQ6e2Jvb2xlYW46WWZ9LGNvbG9yOntzdHJpbmc6VWZ9LHNpemU6e251bWJlcjpYZn0seDp7bnVtYmVyOlhmfSx5OntudW1iZXI6WGZ9LF9fdHlwZV9fOntvYmplY3Q6S2YsYm9vbGVhbjpZZn19LHNtb290aDp7ZW5hYmxlZDp7Ym9vbGVhbjpZZn0sdHlwZTp7c3RyaW5nOltcImR5bmFtaWNcIixcImNvbnRpbnVvdXNcIixcImRpc2NyZXRlXCIsXCJkaWFnb25hbENyb3NzXCIsXCJzdHJhaWdodENyb3NzXCIsXCJob3Jpem9udGFsXCIsXCJ2ZXJ0aWNhbFwiLFwiY3VydmVkQ1dcIixcImN1cnZlZENDV1wiLFwiY3ViaWNCZXppZXJcIl19LHJvdW5kbmVzczp7bnVtYmVyOlhmfSxmb3JjZURpcmVjdGlvbjp7c3RyaW5nOltcImhvcml6b250YWxcIixcInZlcnRpY2FsXCIsXCJub25lXCJdLGJvb2xlYW46WWZ9LF9fdHlwZV9fOntvYmplY3Q6S2YsYm9vbGVhbjpZZn19LHRpdGxlOntzdHJpbmc6VWYsdW5kZWZpbmVkOlwidW5kZWZpbmVkXCJ9LHdpZHRoOntudW1iZXI6WGZ9LHdpZHRoQ29uc3RyYWludDp7bWF4aW11bTp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWYsbnVtYmVyOlhmfX0sdmFsdWU6e251bWJlcjpYZix1bmRlZmluZWQ6XCJ1bmRlZmluZWRcIn0sX190eXBlX186e29iamVjdDpLZn19LGdyb3Vwczp7dXNlRGVmYXVsdEdyb3Vwczp7Ym9vbGVhbjpZZn0sX19hbnlfXzpRZixfX3R5cGVfXzp7b2JqZWN0OktmfX0saW50ZXJhY3Rpb246e2RyYWdOb2Rlczp7Ym9vbGVhbjpZZn0sZHJhZ1ZpZXc6e2Jvb2xlYW46WWZ9LGhpZGVFZGdlc09uRHJhZzp7Ym9vbGVhbjpZZn0saGlkZUVkZ2VzT25ab29tOntib29sZWFuOllmfSxoaWRlTm9kZXNPbkRyYWc6e2Jvb2xlYW46WWZ9LGhvdmVyOntib29sZWFuOllmfSxrZXlib2FyZDp7ZW5hYmxlZDp7Ym9vbGVhbjpZZn0sc3BlZWQ6e3g6e251bWJlcjpYZn0seTp7bnVtYmVyOlhmfSx6b29tOntudW1iZXI6WGZ9LF9fdHlwZV9fOntvYmplY3Q6S2Z9fSxiaW5kVG9XaW5kb3c6e2Jvb2xlYW46WWZ9LF9fdHlwZV9fOntvYmplY3Q6S2YsYm9vbGVhbjpZZn19LG11bHRpc2VsZWN0Ontib29sZWFuOllmfSxuYXZpZ2F0aW9uQnV0dG9uczp7Ym9vbGVhbjpZZn0sc2VsZWN0YWJsZTp7Ym9vbGVhbjpZZn0sc2VsZWN0Q29ubmVjdGVkRWRnZXM6e2Jvb2xlYW46WWZ9LGhvdmVyQ29ubmVjdGVkRWRnZXM6e2Jvb2xlYW46WWZ9LHRvb2x0aXBEZWxheTp7bnVtYmVyOlhmfSx6b29tVmlldzp7Ym9vbGVhbjpZZn0sem9vbVNwZWVkOntudW1iZXI6WGZ9LF9fdHlwZV9fOntvYmplY3Q6S2Z9fSxsYXlvdXQ6e3JhbmRvbVNlZWQ6e3VuZGVmaW5lZDpcInVuZGVmaW5lZFwiLG51bWJlcjpYZixzdHJpbmc6VWZ9LGltcHJvdmVkTGF5b3V0Ontib29sZWFuOllmfSxjbHVzdGVyVGhyZXNob2xkOntudW1iZXI6WGZ9LGhpZXJhcmNoaWNhbDp7ZW5hYmxlZDp7Ym9vbGVhbjpZZn0sbGV2ZWxTZXBhcmF0aW9uOntudW1iZXI6WGZ9LG5vZGVTcGFjaW5nOntudW1iZXI6WGZ9LHRyZWVTcGFjaW5nOntudW1iZXI6WGZ9LGJsb2NrU2hpZnRpbmc6e2Jvb2xlYW46WWZ9LGVkZ2VNaW5pbWl6YXRpb246e2Jvb2xlYW46WWZ9LHBhcmVudENlbnRyYWxpemF0aW9uOntib29sZWFuOllmfSxkaXJlY3Rpb246e3N0cmluZzpbXCJVRFwiLFwiRFVcIixcIkxSXCIsXCJSTFwiXX0sc29ydE1ldGhvZDp7c3RyaW5nOltcImh1YnNpemVcIixcImRpcmVjdGVkXCJdfSxzaGFrZVRvd2FyZHM6e3N0cmluZzpbXCJsZWF2ZXNcIixcInJvb3RzXCJdfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWZ9fSxfX3R5cGVfXzp7b2JqZWN0OktmfX0sbWFuaXB1bGF0aW9uOntlbmFibGVkOntib29sZWFuOllmfSxpbml0aWFsbHlBY3RpdmU6e2Jvb2xlYW46WWZ9LGFkZE5vZGU6e2Jvb2xlYW46WWYsZnVuY3Rpb246XCJmdW5jdGlvblwifSxhZGRFZGdlOntib29sZWFuOllmLGZ1bmN0aW9uOlwiZnVuY3Rpb25cIn0sZWRpdE5vZGU6e2Z1bmN0aW9uOlwiZnVuY3Rpb25cIn0sZWRpdEVkZ2U6e2VkaXRXaXRob3V0RHJhZzp7ZnVuY3Rpb246XCJmdW5jdGlvblwifSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWYsZnVuY3Rpb246XCJmdW5jdGlvblwifX0sZGVsZXRlTm9kZTp7Ym9vbGVhbjpZZixmdW5jdGlvbjpcImZ1bmN0aW9uXCJ9LGRlbGV0ZUVkZ2U6e2Jvb2xlYW46WWYsZnVuY3Rpb246XCJmdW5jdGlvblwifSxjb250cm9sTm9kZVN0eWxlOlFmLF9fdHlwZV9fOntvYmplY3Q6S2YsYm9vbGVhbjpZZn19LG5vZGVzOlFmLHBoeXNpY3M6e2VuYWJsZWQ6e2Jvb2xlYW46WWZ9LGJhcm5lc0h1dDp7dGhldGE6e251bWJlcjpYZn0sZ3Jhdml0YXRpb25hbENvbnN0YW50OntudW1iZXI6WGZ9LGNlbnRyYWxHcmF2aXR5OntudW1iZXI6WGZ9LHNwcmluZ0xlbmd0aDp7bnVtYmVyOlhmfSxzcHJpbmdDb25zdGFudDp7bnVtYmVyOlhmfSxkYW1waW5nOntudW1iZXI6WGZ9LGF2b2lkT3ZlcmxhcDp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmfX0sZm9yY2VBdGxhczJCYXNlZDp7dGhldGE6e251bWJlcjpYZn0sZ3Jhdml0YXRpb25hbENvbnN0YW50OntudW1iZXI6WGZ9LGNlbnRyYWxHcmF2aXR5OntudW1iZXI6WGZ9LHNwcmluZ0xlbmd0aDp7bnVtYmVyOlhmfSxzcHJpbmdDb25zdGFudDp7bnVtYmVyOlhmfSxkYW1waW5nOntudW1iZXI6WGZ9LGF2b2lkT3ZlcmxhcDp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmfX0scmVwdWxzaW9uOntjZW50cmFsR3Jhdml0eTp7bnVtYmVyOlhmfSxzcHJpbmdMZW5ndGg6e251bWJlcjpYZn0sc3ByaW5nQ29uc3RhbnQ6e251bWJlcjpYZn0sbm9kZURpc3RhbmNlOntudW1iZXI6WGZ9LGRhbXBpbmc6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZn19LGhpZXJhcmNoaWNhbFJlcHVsc2lvbjp7Y2VudHJhbEdyYXZpdHk6e251bWJlcjpYZn0sc3ByaW5nTGVuZ3RoOntudW1iZXI6WGZ9LHNwcmluZ0NvbnN0YW50OntudW1iZXI6WGZ9LG5vZGVEaXN0YW5jZTp7bnVtYmVyOlhmfSxkYW1waW5nOntudW1iZXI6WGZ9LGF2b2lkT3ZlcmxhcDp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmfX0sbWF4VmVsb2NpdHk6e251bWJlcjpYZn0sbWluVmVsb2NpdHk6e251bWJlcjpYZn0sc29sdmVyOntzdHJpbmc6W1wiYmFybmVzSHV0XCIsXCJyZXB1bHNpb25cIixcImhpZXJhcmNoaWNhbFJlcHVsc2lvblwiLFwiZm9yY2VBdGxhczJCYXNlZFwiXX0sc3RhYmlsaXphdGlvbjp7ZW5hYmxlZDp7Ym9vbGVhbjpZZn0saXRlcmF0aW9uczp7bnVtYmVyOlhmfSx1cGRhdGVJbnRlcnZhbDp7bnVtYmVyOlhmfSxvbmx5RHluYW1pY0VkZ2VzOntib29sZWFuOllmfSxmaXQ6e2Jvb2xlYW46WWZ9LF9fdHlwZV9fOntvYmplY3Q6S2YsYm9vbGVhbjpZZn19LHRpbWVzdGVwOntudW1iZXI6WGZ9LGFkYXB0aXZlVGltZXN0ZXA6e2Jvb2xlYW46WWZ9LHdpbmQ6e3g6e251bWJlcjpYZn0seTp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmfX0sX190eXBlX186e29iamVjdDpLZixib29sZWFuOllmfX0sYXV0b1Jlc2l6ZTp7Ym9vbGVhbjpZZn0sY2xpY2tUb1VzZTp7Ym9vbGVhbjpZZn0sbG9jYWxlOntzdHJpbmc6VWZ9LGxvY2FsZXM6e19fYW55X186e2FueTpcImFueVwifSxfX3R5cGVfXzp7b2JqZWN0OktmfX0saGVpZ2h0OntzdHJpbmc6VWZ9LHdpZHRoOntzdHJpbmc6VWZ9LF9fdHlwZV9fOntvYmplY3Q6S2Z9fSxKZj17bm9kZXM6e2JvcmRlcldpZHRoOlsxLDAsMTAsMV0sYm9yZGVyV2lkdGhTZWxlY3RlZDpbMiwwLDEwLDFdLGNvbG9yOntib3JkZXI6W1wiY29sb3JcIixcIiMyQjdDRTlcIl0sYmFja2dyb3VuZDpbXCJjb2xvclwiLFwiIzk3QzJGQ1wiXSxoaWdobGlnaHQ6e2JvcmRlcjpbXCJjb2xvclwiLFwiIzJCN0NFOVwiXSxiYWNrZ3JvdW5kOltcImNvbG9yXCIsXCIjRDJFNUZGXCJdfSxob3Zlcjp7Ym9yZGVyOltcImNvbG9yXCIsXCIjMkI3Q0U5XCJdLGJhY2tncm91bmQ6W1wiY29sb3JcIixcIiNEMkU1RkZcIl19fSxvcGFjaXR5OlswLDAsMSwuMV0sZml4ZWQ6e3g6ITEseTohMX0sZm9udDp7Y29sb3I6W1wiY29sb3JcIixcIiMzNDM0MzRcIl0sc2l6ZTpbMTQsMCwxMDAsMV0sZmFjZTpbXCJhcmlhbFwiLFwidmVyZGFuYVwiLFwidGFob21hXCJdLGJhY2tncm91bmQ6W1wiY29sb3JcIixcIm5vbmVcIl0sc3Ryb2tlV2lkdGg6WzAsMCw1MCwxXSxzdHJva2VDb2xvcjpbXCJjb2xvclwiLFwiI2ZmZmZmZlwiXX0saGlkZGVuOiExLGxhYmVsSGlnaGxpZ2h0Qm9sZDohMCxwaHlzaWNzOiEwLHNjYWxpbmc6e21pbjpbMTAsMCwyMDAsMV0sbWF4OlszMCwwLDIwMCwxXSxsYWJlbDp7ZW5hYmxlZDohMSxtaW46WzE0LDAsMjAwLDFdLG1heDpbMzAsMCwyMDAsMV0sbWF4VmlzaWJsZTpbMzAsMCwyMDAsMV0sZHJhd1RocmVzaG9sZDpbNSwwLDIwLDFdfX0sc2hhZG93OntlbmFibGVkOiExLGNvbG9yOlwicmdiYSgwLDAsMCwwLjUpXCIsc2l6ZTpbMTAsMCwyMCwxXSx4Ols1LC0zMCwzMCwxXSx5Ols1LC0zMCwzMCwxXX0sc2hhcGU6W1wiZWxsaXBzZVwiLFwiYm94XCIsXCJjaXJjbGVcIixcImRhdGFiYXNlXCIsXCJkaWFtb25kXCIsXCJkb3RcIixcInNxdWFyZVwiLFwic3RhclwiLFwidGV4dFwiLFwidHJpYW5nbGVcIixcInRyaWFuZ2xlRG93blwiLFwiaGV4YWdvblwiXSxzaGFwZVByb3BlcnRpZXM6e2JvcmRlckRhc2hlczohMSxib3JkZXJSYWRpdXM6WzYsMCwyMCwxXSxpbnRlcnBvbGF0aW9uOiEwLHVzZUltYWdlU2l6ZTohMX0sc2l6ZTpbMjUsMCwyMDAsMV19LGVkZ2VzOnthcnJvd3M6e3RvOntlbmFibGVkOiExLHNjYWxlRmFjdG9yOlsxLDAsMywuMDVdLHR5cGU6XCJhcnJvd1wifSxtaWRkbGU6e2VuYWJsZWQ6ITEsc2NhbGVGYWN0b3I6WzEsMCwzLC4wNV0sdHlwZTpcImFycm93XCJ9LGZyb206e2VuYWJsZWQ6ITEsc2NhbGVGYWN0b3I6WzEsMCwzLC4wNV0sdHlwZTpcImFycm93XCJ9fSxlbmRQb2ludE9mZnNldDp7ZnJvbTpbMCwtMTAsMTAsMV0sdG86WzAsLTEwLDEwLDFdfSxhcnJvd1N0cmlrZXRocm91Z2g6ITAsY29sb3I6e2NvbG9yOltcImNvbG9yXCIsXCIjODQ4NDg0XCJdLGhpZ2hsaWdodDpbXCJjb2xvclwiLFwiIzg0ODQ4NFwiXSxob3ZlcjpbXCJjb2xvclwiLFwiIzg0ODQ4NFwiXSxpbmhlcml0OltcImZyb21cIixcInRvXCIsXCJib3RoXCIsITAsITFdLG9wYWNpdHk6WzEsMCwxLC4wNV19LGRhc2hlczohMSxmb250Ontjb2xvcjpbXCJjb2xvclwiLFwiIzM0MzQzNFwiXSxzaXplOlsxNCwwLDEwMCwxXSxmYWNlOltcImFyaWFsXCIsXCJ2ZXJkYW5hXCIsXCJ0YWhvbWFcIl0sYmFja2dyb3VuZDpbXCJjb2xvclwiLFwibm9uZVwiXSxzdHJva2VXaWR0aDpbMiwwLDUwLDFdLHN0cm9rZUNvbG9yOltcImNvbG9yXCIsXCIjZmZmZmZmXCJdLGFsaWduOltcImhvcml6b250YWxcIixcInRvcFwiLFwibWlkZGxlXCIsXCJib3R0b21cIl19LGhpZGRlbjohMSxob3ZlcldpZHRoOlsxLjUsMCw1LC4xXSxsYWJlbEhpZ2hsaWdodEJvbGQ6ITAscGh5c2ljczohMCxzY2FsaW5nOnttaW46WzEsMCwxMDAsMV0sbWF4OlsxNSwwLDEwMCwxXSxsYWJlbDp7ZW5hYmxlZDohMCxtaW46WzE0LDAsMjAwLDFdLG1heDpbMzAsMCwyMDAsMV0sbWF4VmlzaWJsZTpbMzAsMCwyMDAsMV0sZHJhd1RocmVzaG9sZDpbNSwwLDIwLDFdfX0sc2VsZWN0aW9uV2lkdGg6WzEuNSwwLDUsLjFdLHNlbGZSZWZlcmVuY2VTaXplOlsyMCwwLDIwMCwxXSxzZWxmUmVmZXJlbmNlOntzaXplOlsyMCwwLDIwMCwxXSxhbmdsZTpbTWF0aC5QSS8yLC02Kk1hdGguUEksNipNYXRoLlBJLE1hdGguUEkvOF0scmVuZGVyQmVoaW5kVGhlTm9kZTohMH0sc2hhZG93OntlbmFibGVkOiExLGNvbG9yOlwicmdiYSgwLDAsMCwwLjUpXCIsc2l6ZTpbMTAsMCwyMCwxXSx4Ols1LC0zMCwzMCwxXSx5Ols1LC0zMCwzMCwxXX0sc21vb3RoOntlbmFibGVkOiEwLHR5cGU6W1wiZHluYW1pY1wiLFwiY29udGludW91c1wiLFwiZGlzY3JldGVcIixcImRpYWdvbmFsQ3Jvc3NcIixcInN0cmFpZ2h0Q3Jvc3NcIixcImhvcml6b250YWxcIixcInZlcnRpY2FsXCIsXCJjdXJ2ZWRDV1wiLFwiY3VydmVkQ0NXXCIsXCJjdWJpY0JlemllclwiXSxmb3JjZURpcmVjdGlvbjpbXCJob3Jpem9udGFsXCIsXCJ2ZXJ0aWNhbFwiLFwibm9uZVwiXSxyb3VuZG5lc3M6Wy41LDAsMSwuMDVdfSx3aWR0aDpbMSwwLDMwLDFdfSxsYXlvdXQ6e2hpZXJhcmNoaWNhbDp7ZW5hYmxlZDohMSxsZXZlbFNlcGFyYXRpb246WzE1MCwyMCw1MDAsNV0sbm9kZVNwYWNpbmc6WzEwMCwyMCw1MDAsNV0sdHJlZVNwYWNpbmc6WzIwMCwyMCw1MDAsNV0sYmxvY2tTaGlmdGluZzohMCxlZGdlTWluaW1pemF0aW9uOiEwLHBhcmVudENlbnRyYWxpemF0aW9uOiEwLGRpcmVjdGlvbjpbXCJVRFwiLFwiRFVcIixcIkxSXCIsXCJSTFwiXSxzb3J0TWV0aG9kOltcImh1YnNpemVcIixcImRpcmVjdGVkXCJdLHNoYWtlVG93YXJkczpbXCJsZWF2ZXNcIixcInJvb3RzXCJdfX0saW50ZXJhY3Rpb246e2RyYWdOb2RlczohMCxkcmFnVmlldzohMCxoaWRlRWRnZXNPbkRyYWc6ITEsaGlkZUVkZ2VzT25ab29tOiExLGhpZGVOb2Rlc09uRHJhZzohMSxob3ZlcjohMSxrZXlib2FyZDp7ZW5hYmxlZDohMSxzcGVlZDp7eDpbMTAsMCw0MCwxXSx5OlsxMCwwLDQwLDFdLHpvb206Wy4wMiwwLC4xLC4wMDVdfSxiaW5kVG9XaW5kb3c6ITB9LG11bHRpc2VsZWN0OiExLG5hdmlnYXRpb25CdXR0b25zOiExLHNlbGVjdGFibGU6ITAsc2VsZWN0Q29ubmVjdGVkRWRnZXM6ITAsaG92ZXJDb25uZWN0ZWRFZGdlczohMCx0b29sdGlwRGVsYXk6WzMwMCwwLDFlMywyNV0sem9vbVZpZXc6ITAsem9vbVNwZWVkOlsxLC4xLDIsLjFdfSxtYW5pcHVsYXRpb246e2VuYWJsZWQ6ITEsaW5pdGlhbGx5QWN0aXZlOiExfSxwaHlzaWNzOntlbmFibGVkOiEwLGJhcm5lc0h1dDp7dGhldGE6Wy41LC4xLDEsLjA1XSxncmF2aXRhdGlvbmFsQ29uc3RhbnQ6Wy0yZTMsLTNlNCwwLDUwXSxjZW50cmFsR3Jhdml0eTpbLjMsMCwxMCwuMDVdLHNwcmluZ0xlbmd0aDpbOTUsMCw1MDAsNV0sc3ByaW5nQ29uc3RhbnQ6Wy4wNCwwLDEuMiwuMDA1XSxkYW1waW5nOlsuMDksMCwxLC4wMV0sYXZvaWRPdmVybGFwOlswLDAsMSwuMDFdfSxmb3JjZUF0bGFzMkJhc2VkOnt0aGV0YTpbLjUsLjEsMSwuMDVdLGdyYXZpdGF0aW9uYWxDb25zdGFudDpbLTUwLC01MDAsMCwxXSxjZW50cmFsR3Jhdml0eTpbLjAxLDAsMSwuMDA1XSxzcHJpbmdMZW5ndGg6Wzk1LDAsNTAwLDVdLHNwcmluZ0NvbnN0YW50OlsuMDgsMCwxLjIsLjAwNV0sZGFtcGluZzpbLjQsMCwxLC4wMV0sYXZvaWRPdmVybGFwOlswLDAsMSwuMDFdfSxyZXB1bHNpb246e2NlbnRyYWxHcmF2aXR5OlsuMiwwLDEwLC4wNV0sc3ByaW5nTGVuZ3RoOlsyMDAsMCw1MDAsNV0sc3ByaW5nQ29uc3RhbnQ6Wy4wNSwwLDEuMiwuMDA1XSxub2RlRGlzdGFuY2U6WzEwMCwwLDUwMCw1XSxkYW1waW5nOlsuMDksMCwxLC4wMV19LGhpZXJhcmNoaWNhbFJlcHVsc2lvbjp7Y2VudHJhbEdyYXZpdHk6Wy4yLDAsMTAsLjA1XSxzcHJpbmdMZW5ndGg6WzEwMCwwLDUwMCw1XSxzcHJpbmdDb25zdGFudDpbLjAxLDAsMS4yLC4wMDVdLG5vZGVEaXN0YW5jZTpbMTIwLDAsNTAwLDVdLGRhbXBpbmc6Wy4wOSwwLDEsLjAxXSxhdm9pZE92ZXJsYXA6WzAsMCwxLC4wMV19LG1heFZlbG9jaXR5Ols1MCwwLDE1MCwxXSxtaW5WZWxvY2l0eTpbLjEsLjAxLC41LC4wMV0sc29sdmVyOltcImJhcm5lc0h1dFwiLFwiZm9yY2VBdGxhczJCYXNlZFwiLFwicmVwdWxzaW9uXCIsXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIl0sdGltZXN0ZXA6Wy41LC4wMSwxLC4wMV0sd2luZDp7eDpbMCwtMTAsMTAsLjFdLHk6WzAsLTEwLDEwLC4xXX19fSx0cD1mdW5jdGlvbih0LGUsaSl7dmFyIG87cmV0dXJuISghSm4odCkuY2FsbCh0LFwicGh5c2ljc1wiKXx8IUpuKG89SmYucGh5c2ljcy5zb2x2ZXIpLmNhbGwobyxlKXx8aS5waHlzaWNzLnNvbHZlcj09PWV8fFwid2luZFwiPT09ZSl9LGVwPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGNvbmZpZ3VyYXRvckhpZGVPcHRpb246dHAsYWxsT3B0aW9uczpaZixjb25maWd1cmVPcHRpb25zOkpmfSksaXA9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7UG8odGhpcyx0KX1yZXR1cm4gSW8odCxbe2tleTpcImdldERpc3RhbmNlc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXtmb3IodmFyIG89e30sbj10LmVkZ2VzLHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIHM9e307b1tlW3JdXT1zO2Zvcih2YXIgYT0wO2E8ZS5sZW5ndGg7YSsrKXNbZVthXV09cj09YT8wOjFlOX1mb3IodmFyIGg9MDtoPGkubGVuZ3RoO2grKyl7dmFyIGQ9bltpW2hdXTshMD09PWQuY29ubmVjdGVkJiZ2b2lkIDAhPT1vW2QuZnJvbUlkXSYmdm9pZCAwIT09b1tkLnRvSWRdJiYob1tkLmZyb21JZF1bZC50b0lkXT0xLG9bZC50b0lkXVtkLmZyb21JZF09MSl9Zm9yKHZhciBsPWUubGVuZ3RoLGM9MDtjPGw7YysrKWZvcih2YXIgdT1lW2NdLGY9b1t1XSxwPTA7cDxsLTE7cCsrKWZvcih2YXIgdj1lW3BdLGc9b1t2XSx5PXArMTt5PGw7eSsrKXt2YXIgbT1lW3ldLGI9b1ttXSx3PU1hdGgubWluKGdbbV0sZ1t1XStmW21dKTtnW21dPXcsYlt2XT13fXJldHVybiBvfX1dKSx0fSgpLG9wPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLGksbyl7UG8odGhpcyx0KSx0aGlzLmJvZHk9ZSx0aGlzLnNwcmluZ0xlbmd0aD1pLHRoaXMuc3ByaW5nQ29uc3RhbnQ9byx0aGlzLmRpc3RhbmNlU29sdmVyPW5ldyBpcH1yZXR1cm4gSW8odCxbe2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt0JiYodC5zcHJpbmdMZW5ndGgmJih0aGlzLnNwcmluZ0xlbmd0aD10LnNwcmluZ0xlbmd0aCksdC5zcHJpbmdDb25zdGFudCYmKHRoaXMuc3ByaW5nQ29uc3RhbnQ9dC5zcHJpbmdDb25zdGFudCkpfX0se2tleTpcInNvbHZlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdLG89dGhpcy5kaXN0YW5jZVNvbHZlci5nZXREaXN0YW5jZXModGhpcy5ib2R5LHQsZSk7dGhpcy5fY3JlYXRlTF9tYXRyaXgobyksdGhpcy5fY3JlYXRlS19tYXRyaXgobyksdGhpcy5fY3JlYXRlRV9tYXRyaXgoKTtmb3IodmFyIG49LjAxLHI9MSxzPTAsYT1NYXRoLm1heCgxZTMsTWF0aC5taW4oMTAqdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aCw2ZTMpKSxoPTUsZD0xZTksbD0wLGM9MCx1PTAsZj0wLHA9MDtkPm4mJnM8YTspe3MrPTE7dmFyIHY9dGhpcy5fZ2V0SGlnaGVzdEVuZXJneU5vZGUoaSksZz1hbih2LDQpO2ZvcihsPWdbMF0sZD1nWzFdLGM9Z1syXSx1PWdbM10sZj1kLHA9MDtmPnImJnA8aDspe3ArPTEsdGhpcy5fbW92ZU5vZGUobCxjLHUpO3ZhciB5PXRoaXMuX2dldEVuZXJneShsKSxtPWFuKHksMyk7Zj1tWzBdLGM9bVsxXSx1PW1bMl19fX19LHtrZXk6XCJfZ2V0SGlnaGVzdEVuZXJneU5vZGVcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5ib2R5Lm5vZGVJbmRpY2VzLGk9dGhpcy5ib2R5Lm5vZGVzLG89MCxuPWVbMF0scj0wLHM9MCxhPTA7YTxlLmxlbmd0aDthKyspe3ZhciBoPWVbYV07aWYoITAhPT1pW2hdLnByZWRlZmluZWRQb3NpdGlvbnx8ITA9PT1pW2hdLmlzQ2x1c3RlciYmITA9PT10fHwhMCE9PWlbaF0ub3B0aW9ucy5maXhlZC54fHwhMCE9PWlbaF0ub3B0aW9ucy5maXhlZC55KXt2YXIgZD1hbih0aGlzLl9nZXRFbmVyZ3koaCksMyksbD1kWzBdLGM9ZFsxXSx1PWRbMl07bzxsJiYobz1sLG49aCxyPWMscz11KX19cmV0dXJuW24sbyxyLHNdfX0se2tleTpcIl9nZXRFbmVyZ3lcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1hbih0aGlzLkVfc3Vtc1t0XSwyKSxpPWVbMF0sbz1lWzFdO3JldHVybltNYXRoLnNxcnQoTWF0aC5wb3coaSwyKStNYXRoLnBvdyhvLDIpKSxpLG9dfX0se2tleTpcIl9tb3ZlTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXtmb3IodmFyIG89dGhpcy5ib2R5Lm5vZGVJbmRpY2VzLG49dGhpcy5ib2R5Lm5vZGVzLHI9MCxzPTAsYT0wLGg9blt0XS54LGQ9blt0XS55LGw9dGhpcy5LX21hdHJpeFt0XSxjPXRoaXMuTF9tYXRyaXhbdF0sdT0wO3U8by5sZW5ndGg7dSsrKXt2YXIgZj1vW3VdO2lmKGYhPT10KXt2YXIgcD1uW2ZdLngsdj1uW2ZdLnksZz1sW2ZdLHk9Y1tmXSxtPTEvTWF0aC5wb3coTWF0aC5wb3coaC1wLDIpK01hdGgucG93KGQtdiwyKSwxLjUpO3IrPWcqKDEteSpNYXRoLnBvdyhkLXYsMikqbSkscys9ZyooeSooaC1wKSooZC12KSptKSxhKz1nKigxLXkqTWF0aC5wb3coaC1wLDIpKm0pfX12YXIgYj0oZS9yK2kvcykvKHMvci1hL3MpLHc9LShzKmIrZSkvcjtuW3RdLngrPXcsblt0XS55Kz1iLHRoaXMuX3VwZGF0ZUVfbWF0cml4KHQpfX0se2tleTpcIl9jcmVhdGVMX21hdHJpeFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuYm9keS5ub2RlSW5kaWNlcyxpPXRoaXMuc3ByaW5nTGVuZ3RoO3RoaXMuTF9tYXRyaXg9W107Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDtvKyspe3RoaXMuTF9tYXRyaXhbZVtvXV09e307Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspdGhpcy5MX21hdHJpeFtlW29dXVtlW25dXT1pKnRbZVtvXV1bZVtuXV19fX0se2tleTpcIl9jcmVhdGVLX21hdHJpeFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuYm9keS5ub2RlSW5kaWNlcyxpPXRoaXMuc3ByaW5nQ29uc3RhbnQ7dGhpcy5LX21hdHJpeD1bXTtmb3IodmFyIG89MDtvPGUubGVuZ3RoO28rKyl7dGhpcy5LX21hdHJpeFtlW29dXT17fTtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl0aGlzLktfbWF0cml4W2Vbb11dW2Vbbl1dPWkqTWF0aC5wb3codFtlW29dXVtlW25dXSwtMil9fX0se2tleTpcIl9jcmVhdGVFX21hdHJpeFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5ib2R5Lm5vZGVJbmRpY2VzLGU9dGhpcy5ib2R5Lm5vZGVzO3RoaXMuRV9tYXRyaXg9e30sdGhpcy5FX3N1bXM9e307Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspdGhpcy5FX21hdHJpeFt0W2ldXT1bXTtmb3IodmFyIG89MDtvPHQubGVuZ3RoO28rKyl7Zm9yKHZhciBuPXRbb10scj1lW25dLngscz1lW25dLnksYT0wLGg9MCxkPW87ZDx0Lmxlbmd0aDtkKyspe3ZhciBsPXRbZF07aWYobCE9PW4pe3ZhciBjPWVbbF0ueCx1PWVbbF0ueSxmPTEvTWF0aC5zcXJ0KE1hdGgucG93KHItYywyKStNYXRoLnBvdyhzLXUsMikpO3RoaXMuRV9tYXRyaXhbbl1bZF09W3RoaXMuS19tYXRyaXhbbl1bbF0qKHItYy10aGlzLkxfbWF0cml4W25dW2xdKihyLWMpKmYpLHRoaXMuS19tYXRyaXhbbl1bbF0qKHMtdS10aGlzLkxfbWF0cml4W25dW2xdKihzLXUpKmYpXSx0aGlzLkVfbWF0cml4W2xdW29dPXRoaXMuRV9tYXRyaXhbbl1bZF0sYSs9dGhpcy5FX21hdHJpeFtuXVtkXVswXSxoKz10aGlzLkVfbWF0cml4W25dW2RdWzFdfX10aGlzLkVfc3Vtc1tuXT1bYSxoXX19fSx7a2V5OlwiX3VwZGF0ZUVfbWF0cml4XCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuYm9keS5ub2RlSW5kaWNlcyxpPXRoaXMuYm9keS5ub2RlcyxvPXRoaXMuRV9tYXRyaXhbdF0sbj10aGlzLktfbWF0cml4W3RdLHI9dGhpcy5MX21hdHJpeFt0XSxzPWlbdF0ueCxhPWlbdF0ueSxoPTAsZD0wLGw9MDtsPGUubGVuZ3RoO2wrKyl7dmFyIGM9ZVtsXTtpZihjIT09dCl7dmFyIHU9b1tsXSxmPXVbMF0scD11WzFdLHY9aVtjXS54LGc9aVtjXS55LHk9MS9NYXRoLnNxcnQoTWF0aC5wb3cocy12LDIpK01hdGgucG93KGEtZywyKSksbT1uW2NdKihzLXYtcltjXSoocy12KSp5KSxiPW5bY10qKGEtZy1yW2NdKihhLWcpKnkpO29bbF09W20sYl0saCs9bSxkKz1iO3ZhciB3PXRoaXMuRV9zdW1zW2NdO3dbMF0rPW0tZix3WzFdKz1iLXB9fXRoaXMuRV9zdW1zW3RdPVtoLGRdfX1dKSx0fSgpO2Z1bmN0aW9uIG5wKHQsZSxpKXt2YXIgbyxuLHIscyxhPXRoaXM7aWYoISh0aGlzIGluc3RhbmNlb2YgbnApKXRocm93IG5ldyBTeW50YXhFcnJvcihcIkNvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvclwiKTt0aGlzLm9wdGlvbnM9e30sdGhpcy5kZWZhdWx0T3B0aW9ucz17bG9jYWxlOlwiZW5cIixsb2NhbGVzOnVkLGNsaWNrVG9Vc2U6ITF9LGN0KHRoaXMub3B0aW9ucyx0aGlzLmRlZmF1bHRPcHRpb25zKSx0aGlzLmJvZHk9e2NvbnRhaW5lcjp0LG5vZGVzOnt9LG5vZGVJbmRpY2VzOltdLGVkZ2VzOnt9LGVkZ2VJbmRpY2VzOltdLGVtaXR0ZXI6e29uOmJ0KG89dGhpcy5vbikuY2FsbChvLHRoaXMpLG9mZjpidChuPXRoaXMub2ZmKS5jYWxsKG4sdGhpcyksZW1pdDpidChyPXRoaXMuZW1pdCkuY2FsbChyLHRoaXMpLG9uY2U6YnQocz10aGlzLm9uY2UpLmNhbGwocyx0aGlzKX0sZXZlbnRMaXN0ZW5lcnM6e29uVGFwOmZ1bmN0aW9uKCl7fSxvblRvdWNoOmZ1bmN0aW9uKCl7fSxvbkRvdWJsZVRhcDpmdW5jdGlvbigpe30sb25Ib2xkOmZ1bmN0aW9uKCl7fSxvbkRyYWdTdGFydDpmdW5jdGlvbigpe30sb25EcmFnOmZ1bmN0aW9uKCl7fSxvbkRyYWdFbmQ6ZnVuY3Rpb24oKXt9LG9uTW91c2VXaGVlbDpmdW5jdGlvbigpe30sb25QaW5jaDpmdW5jdGlvbigpe30sb25Nb3VzZU1vdmU6ZnVuY3Rpb24oKXt9LG9uUmVsZWFzZTpmdW5jdGlvbigpe30sb25Db250ZXh0OmZ1bmN0aW9uKCl7fX0sZGF0YTp7bm9kZXM6bnVsbCxlZGdlczpudWxsfSxmdW5jdGlvbnM6e2NyZWF0ZU5vZGU6ZnVuY3Rpb24oKXt9LGNyZWF0ZUVkZ2U6ZnVuY3Rpb24oKXt9LGdldFBvaW50ZXI6ZnVuY3Rpb24oKXt9fSxtb2R1bGVzOnt9LHZpZXc6e3NjYWxlOjEsdHJhbnNsYXRpb246e3g6MCx5OjB9fSxzZWxlY3Rpb25Cb3g6e3Nob3c6ITEscG9zaXRpb246e3N0YXJ0Ont4OjAseTowfSxlbmQ6e3g6MCx5OjB9fX19LHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCksdGhpcy5pbWFnZXM9bmV3IHBkKChmdW5jdGlvbigpe3JldHVybiBhLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIil9KSksdGhpcy5ncm91cHM9bmV3IElkLHRoaXMuY2FudmFzPW5ldyBQdSh0aGlzLmJvZHkpLHRoaXMuc2VsZWN0aW9uSGFuZGxlcj1uZXcgY2YodGhpcy5ib2R5LHRoaXMuY2FudmFzKSx0aGlzLmludGVyYWN0aW9uSGFuZGxlcj1uZXcgQXUodGhpcy5ib2R5LHRoaXMuY2FudmFzLHRoaXMuc2VsZWN0aW9uSGFuZGxlciksdGhpcy52aWV3PW5ldyBCdSh0aGlzLmJvZHksdGhpcy5jYW52YXMpLHRoaXMucmVuZGVyZXI9bmV3IEN1KHRoaXMuYm9keSx0aGlzLmNhbnZhcyksdGhpcy5waHlzaWNzPW5ldyB1dSh0aGlzLmJvZHkpLHRoaXMubGF5b3V0RW5naW5lPW5ldyBIZih0aGlzLmJvZHkpLHRoaXMuY2x1c3RlcmluZz1uZXcgeHUodGhpcy5ib2R5KSx0aGlzLm1hbmlwdWxhdGlvbj1uZXcgcWYodGhpcy5ib2R5LHRoaXMuY2FudmFzLHRoaXMuc2VsZWN0aW9uSGFuZGxlcix0aGlzLmludGVyYWN0aW9uSGFuZGxlciksdGhpcy5ub2Rlc0hhbmRsZXI9bmV3IGZjKHRoaXMuYm9keSx0aGlzLmltYWdlcyx0aGlzLmdyb3Vwcyx0aGlzLmxheW91dEVuZ2luZSksdGhpcy5lZGdlc0hhbmRsZXI9bmV3IHR1KHRoaXMuYm9keSx0aGlzLmltYWdlcyx0aGlzLmdyb3VwcyksdGhpcy5ib2R5Lm1vZHVsZXMua2FtYWRhS2F3YWk9bmV3IG9wKHRoaXMuYm9keSwxNTAsLjA1KSx0aGlzLmJvZHkubW9kdWxlcy5jbHVzdGVyaW5nPXRoaXMuY2x1c3RlcmluZyx0aGlzLmNhbnZhcy5fY3JlYXRlKCksdGhpcy5zZXRPcHRpb25zKGkpLHRoaXMuc2V0RGF0YShlKX1DdChucC5wcm90b3R5cGUpLG5wLnByb3RvdHlwZS5zZXRPcHRpb25zPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7aWYobnVsbD09PXQmJih0PXZvaWQgMCksdm9pZCAwIT09dCl7ITA9PT1QaC52YWxpZGF0ZSh0LFpmKSYmY29uc29sZS5lcnJvcihcIiVjRXJyb3JzIGhhdmUgYmVlbiBmb3VuZCBpbiB0aGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3QuXCIsTWgpO2lmKFphKFtcImxvY2FsZVwiLFwibG9jYWxlc1wiLFwiY2xpY2tUb1VzZVwiXSx0aGlzLm9wdGlvbnMsdCksdm9pZCAwIT09dC5sb2NhbGUmJih0LmxvY2FsZT1mdW5jdGlvbih0LGUpe3RyeXt2YXIgaT1hbihlLnNwbGl0KC9bLV8gL10vLDIpLDIpLG89aVswXSxuPWlbMV0scj1udWxsIT1vP28udG9Mb3dlckNhc2UoKTpudWxsLHM9bnVsbCE9bj9uLnRvVXBwZXJDYXNlKCk6bnVsbDtpZihyJiZzKXt2YXIgYSxoPXIrXCItXCIrcztpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxoKSlyZXR1cm4gaDtjb25zb2xlLndhcm4ocG4oYT1cIlVua25vd24gdmFyaWFudCBcIi5jb25jYXQocyxcIiBvZiBsYW5ndWFnZSBcIikpLmNhbGwoYSxyLFwiLlwiKSl9aWYocil7dmFyIGQ9cjtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxkKSlyZXR1cm4gZDtjb25zb2xlLndhcm4oXCJVbmtub3duIGxhbmd1YWdlIFwiLmNvbmNhdChyKSl9cmV0dXJuIGNvbnNvbGUud2FybihcIlVua25vd24gbG9jYWxlIFwiLmNvbmNhdChlLFwiLCBmYWxsaW5nIGJhY2sgdG8gRW5nbGlzaC5cIikpLFwiZW5cIn1jYXRjaCh0KXtyZXR1cm4gY29uc29sZS5lcnJvcih0KSxjb25zb2xlLndhcm4oXCJVbmV4cGVjdGVkIGVycm9yIHdoaWxlIG5vcm1hbGl6aW5nIGxvY2FsZSBcIi5jb25jYXQoZSxcIiwgZmFsbGluZyBiYWNrIHRvIEVuZ2xpc2guXCIpKSxcImVuXCJ9fSh0LmxvY2FsZXN8fHRoaXMub3B0aW9ucy5sb2NhbGVzLHQubG9jYWxlKSksdD10aGlzLmxheW91dEVuZ2luZS5zZXRPcHRpb25zKHQubGF5b3V0LHQpLHRoaXMuY2FudmFzLnNldE9wdGlvbnModCksdGhpcy5ncm91cHMuc2V0T3B0aW9ucyh0Lmdyb3VwcyksdGhpcy5ub2Rlc0hhbmRsZXIuc2V0T3B0aW9ucyh0Lm5vZGVzKSx0aGlzLmVkZ2VzSGFuZGxlci5zZXRPcHRpb25zKHQuZWRnZXMpLHRoaXMucGh5c2ljcy5zZXRPcHRpb25zKHQucGh5c2ljcyksdGhpcy5tYW5pcHVsYXRpb24uc2V0T3B0aW9ucyh0Lm1hbmlwdWxhdGlvbix0LHRoaXMub3B0aW9ucyksdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIuc2V0T3B0aW9ucyh0LmludGVyYWN0aW9uKSx0aGlzLnJlbmRlcmVyLnNldE9wdGlvbnModC5pbnRlcmFjdGlvbiksdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNldE9wdGlvbnModC5pbnRlcmFjdGlvbiksdm9pZCAwIT09dC5ncm91cHMmJnRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZWZyZXNoTm9kZXNcIiksXCJjb25maWd1cmVcImluIHQmJih0aGlzLmNvbmZpZ3VyYXRvcnx8KHRoaXMuY29uZmlndXJhdG9yPW5ldyBDaCh0aGlzLHRoaXMuYm9keS5jb250YWluZXIsSmYsdGhpcy5jYW52YXMucGl4ZWxSYXRpbyx0cCkpLHRoaXMuY29uZmlndXJhdG9yLnNldE9wdGlvbnModC5jb25maWd1cmUpKSx0aGlzLmNvbmZpZ3VyYXRvciYmITA9PT10aGlzLmNvbmZpZ3VyYXRvci5vcHRpb25zLmVuYWJsZWQpe3ZhciBpPXtub2Rlczp7fSxlZGdlczp7fSxsYXlvdXQ6e30saW50ZXJhY3Rpb246e30sbWFuaXB1bGF0aW9uOnt9LHBoeXNpY3M6e30sZ2xvYmFsOnt9fTt0aChpLm5vZGVzLHRoaXMubm9kZXNIYW5kbGVyLm9wdGlvbnMpLHRoKGkuZWRnZXMsdGhpcy5lZGdlc0hhbmRsZXIub3B0aW9ucyksdGgoaS5sYXlvdXQsdGhpcy5sYXlvdXRFbmdpbmUub3B0aW9ucyksdGgoaS5pbnRlcmFjdGlvbix0aGlzLnNlbGVjdGlvbkhhbmRsZXIub3B0aW9ucyksdGgoaS5pbnRlcmFjdGlvbix0aGlzLnJlbmRlcmVyLm9wdGlvbnMpLHRoKGkuaW50ZXJhY3Rpb24sdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIub3B0aW9ucyksdGgoaS5tYW5pcHVsYXRpb24sdGhpcy5tYW5pcHVsYXRpb24ub3B0aW9ucyksdGgoaS5waHlzaWNzLHRoaXMucGh5c2ljcy5vcHRpb25zKSx0aChpLmdsb2JhbCx0aGlzLmNhbnZhcy5vcHRpb25zKSx0aChpLmdsb2JhbCx0aGlzLm9wdGlvbnMpLHRoaXMuY29uZmlndXJhdG9yLnNldE1vZHVsZU9wdGlvbnMoaSl9dm9pZCAwIT09dC5jbGlja1RvVXNlPyEwPT09dC5jbGlja1RvVXNlP3ZvaWQgMD09PXRoaXMuYWN0aXZhdG9yJiYodGhpcy5hY3RpdmF0b3I9bmV3IE9oKHRoaXMuY2FudmFzLmZyYW1lKSx0aGlzLmFjdGl2YXRvci5vbihcImNoYW5nZVwiLChmdW5jdGlvbigpe2UuYm9keS5lbWl0dGVyLmVtaXQoXCJhY3RpdmF0ZVwiKX0pKSk6KHZvaWQgMCE9PXRoaXMuYWN0aXZhdG9yJiYodGhpcy5hY3RpdmF0b3IuZGVzdHJveSgpLGRlbGV0ZSB0aGlzLmFjdGl2YXRvciksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImFjdGl2YXRlXCIpKTp0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYWN0aXZhdGVcIiksdGhpcy5jYW52YXMuc2V0U2l6ZSgpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIil9fSxucC5wcm90b3R5cGUuX3VwZGF0ZVZpc2libGVJbmRpY2VzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5ib2R5Lm5vZGVzLGU9dGhpcy5ib2R5LmVkZ2VzO2Zvcih2YXIgaSBpbiB0aGlzLmJvZHkubm9kZUluZGljZXM9W10sdGhpcy5ib2R5LmVkZ2VJbmRpY2VzPVtdLHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsaSkmJih0aGlzLmNsdXN0ZXJpbmcuX2lzQ2x1c3RlcmVkTm9kZShpKXx8ITEhPT10W2ldLm9wdGlvbnMuaGlkZGVufHx0aGlzLmJvZHkubm9kZUluZGljZXMucHVzaCh0W2ldLmlkKSk7Zm9yKHZhciBvIGluIGUpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbykpe3ZhciBuPWVbb10scj10W24uZnJvbUlkXSxzPXRbbi50b0lkXSxhPXZvaWQgMCE9PXImJnZvaWQgMCE9PXM7IXRoaXMuY2x1c3RlcmluZy5faXNDbHVzdGVyZWRFZGdlKG8pJiYhMT09PW4ub3B0aW9ucy5oaWRkZW4mJmEmJiExPT09ci5vcHRpb25zLmhpZGRlbiYmITE9PT1zLm9wdGlvbnMuaGlkZGVuJiZ0aGlzLmJvZHkuZWRnZUluZGljZXMucHVzaChuLmlkKX19LG5wLnByb3RvdHlwZS5iaW5kRXZlbnRMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsKGZ1bmN0aW9uKCl7dC5lZGdlc0hhbmRsZXIuX3VwZGF0ZVN0YXRlKCksdC5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhVXBkYXRlZFwiKX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhVXBkYXRlZFwiLChmdW5jdGlvbigpe3QuY2x1c3RlcmluZy5fdXBkYXRlU3RhdGUoKSx0Ll91cGRhdGVWaXNpYmxlSW5kaWNlcygpLHQuX3VwZGF0ZVZhbHVlUmFuZ2UodC5ib2R5Lm5vZGVzKSx0Ll91cGRhdGVWYWx1ZVJhbmdlKHQuYm9keS5lZGdlcyksdC5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKSx0LmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIil9KSl9LG5wLnByb3RvdHlwZS5zZXREYXRhPWZ1bmN0aW9uKHQpe2lmKHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZXNldFBoeXNpY3NcIiksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNldERhdGFcIiksdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCksdCYmdC5kb3QmJih0Lm5vZGVzfHx0LmVkZ2VzKSl0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0RhdGEgbXVzdCBjb250YWluIGVpdGhlciBwYXJhbWV0ZXIgXCJkb3RcIiBvciAgcGFyYW1ldGVyIHBhaXIgXCJub2Rlc1wiIGFuZCBcImVkZ2VzXCIsIGJ1dCBub3QgYm90aC4nKTtpZih0aGlzLnNldE9wdGlvbnModCYmdC5vcHRpb25zKSx0JiZ0LmRvdCl7Y29uc29sZS53YXJuKFwiVGhlIGRvdCBwcm9wZXJ0eSBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBzdGF0aWMgY29udmVydERvdCBtZXRob2QgdG8gY29udmVydCBET1QgaW50byB2aXMubmV0d29yayBmb3JtYXQgYW5kIHVzZSB0aGUgbm9ybWFsIGRhdGEgZm9ybWF0IHdpdGggbm9kZXMgYW5kIGVkZ2VzLiBUaGlzIGNvbnZlcnRlciBpcyB1c2VkIGxpa2UgdGhpczogdmFyIGRhdGEgPSB2aXMubmV0d29yay5jb252ZXJ0RG90KGRvdFN0cmluZyk7XCIpO3ZhciBlPWhkKHQuZG90KTt0aGlzLnNldERhdGEoZSl9ZWxzZSBpZih0JiZ0LmdlcGhpKXtjb25zb2xlLndhcm4oXCJUaGUgZ2VwaGkgcHJvcGVydHkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgc3RhdGljIGNvbnZlcnRHZXBoaSBtZXRob2QgdG8gY29udmVydCBnZXBoaSBpbnRvIHZpcy5uZXR3b3JrIGZvcm1hdCBhbmQgdXNlIHRoZSBub3JtYWwgZGF0YSBmb3JtYXQgd2l0aCBub2RlcyBhbmQgZWRnZXMuIFRoaXMgY29udmVydGVyIGlzIHVzZWQgbGlrZSB0aGlzOiB2YXIgZGF0YSA9IHZpcy5uZXR3b3JrLmNvbnZlcnRHZXBoaShnZXBoaUpzb24pO1wiKTt2YXIgaT1sZCh0LmdlcGhpKTt0aGlzLnNldERhdGEoaSl9ZWxzZSB0aGlzLm5vZGVzSGFuZGxlci5zZXREYXRhKHQmJnQubm9kZXMsITApLHRoaXMuZWRnZXNIYW5kbGVyLnNldERhdGEodCYmdC5lZGdlcywhMCksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFMb2FkZWRcIiksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImluaXRQaHlzaWNzXCIpfSxucC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZGVzdHJveVwiKSx0aGlzLmJvZHkuZW1pdHRlci5vZmYoKSx0aGlzLm9mZigpLGRlbGV0ZSB0aGlzLmdyb3VwcyxkZWxldGUgdGhpcy5jYW52YXMsZGVsZXRlIHRoaXMuc2VsZWN0aW9uSGFuZGxlcixkZWxldGUgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIsZGVsZXRlIHRoaXMudmlldyxkZWxldGUgdGhpcy5yZW5kZXJlcixkZWxldGUgdGhpcy5waHlzaWNzLGRlbGV0ZSB0aGlzLmxheW91dEVuZ2luZSxkZWxldGUgdGhpcy5jbHVzdGVyaW5nLGRlbGV0ZSB0aGlzLm1hbmlwdWxhdGlvbixkZWxldGUgdGhpcy5ub2Rlc0hhbmRsZXIsZGVsZXRlIHRoaXMuZWRnZXNIYW5kbGVyLGRlbGV0ZSB0aGlzLmNvbmZpZ3VyYXRvcixkZWxldGUgdGhpcy5pbWFnZXMsdGhpcy5ib2R5Lm5vZGVzKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsdCkmJmRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbdF07Zm9yKHZhciBlIGluIHRoaXMuYm9keS5lZGdlcylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5LmVkZ2VzLGUpJiZkZWxldGUgdGhpcy5ib2R5LmVkZ2VzW2VdO1hhKHRoaXMuYm9keS5jb250YWluZXIpfSxucC5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlUmFuZ2U9ZnVuY3Rpb24odCl7dmFyIGUsaT12b2lkIDAsbz12b2lkIDAsbj0wO2ZvcihlIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSkpe3ZhciByPXRbZV0uZ2V0VmFsdWUoKTt2b2lkIDAhPT1yJiYoaT12b2lkIDA9PT1pP3I6TWF0aC5taW4ocixpKSxvPXZvaWQgMD09PW8/cjpNYXRoLm1heChyLG8pLG4rPXIpfWlmKHZvaWQgMCE9PWkmJnZvaWQgMCE9PW8pZm9yKGUgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSYmdFtlXS5zZXRWYWx1ZVJhbmdlKGksbyxuKX0sbnAucHJvdG90eXBlLmlzQWN0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuYWN0aXZhdG9yfHx0aGlzLmFjdGl2YXRvci5hY3RpdmV9LG5wLnByb3RvdHlwZS5zZXRTaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2FudmFzLnNldFNpemUuYXBwbHkodGhpcy5jYW52YXMsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmNhbnZhc1RvRE9NPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2FudmFzLmNhbnZhc1RvRE9NLmFwcGx5KHRoaXMuY2FudmFzLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5ET010b0NhbnZhcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcy5hcHBseSh0aGlzLmNhbnZhcyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZmluZE5vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmZpbmROb2RlLmFwcGx5KHRoaXMuY2x1c3RlcmluZyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuaXNDbHVzdGVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2x1c3RlcmluZy5pc0NsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5vcGVuQ2x1c3Rlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNsdXN0ZXJpbmcub3BlbkNsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5jbHVzdGVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0Tm9kZXNJbkNsdXN0ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmdldE5vZGVzSW5DbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuY2x1c3RlckJ5Q29ubmVjdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3RlckJ5Q29ubmVjdGlvbi5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmNsdXN0ZXJCeUh1YnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmNsdXN0ZXJCeUh1YnNpemUuYXBwbHkodGhpcy5jbHVzdGVyaW5nLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS51cGRhdGVDbHVzdGVyZWROb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2x1c3RlcmluZy51cGRhdGVDbHVzdGVyZWROb2RlLmFwcGx5KHRoaXMuY2x1c3RlcmluZyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0Q2x1c3RlcmVkRWRnZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmdldENsdXN0ZXJlZEVkZ2VzLmFwcGx5KHRoaXMuY2x1c3RlcmluZyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0QmFzZUVkZ2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmdldEJhc2VFZGdlLmFwcGx5KHRoaXMuY2x1c3RlcmluZyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0QmFzZUVkZ2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2x1c3RlcmluZy5nZXRCYXNlRWRnZXMuYXBwbHkodGhpcy5jbHVzdGVyaW5nLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS51cGRhdGVFZGdlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2x1c3RlcmluZy51cGRhdGVFZGdlLmFwcGx5KHRoaXMuY2x1c3RlcmluZyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuY2x1c3Rlck91dGxpZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyT3V0bGllcnMuYXBwbHkodGhpcy5jbHVzdGVyaW5nLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5nZXRTZWVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGF5b3V0RW5naW5lLmdldFNlZWQuYXBwbHkodGhpcy5sYXlvdXRFbmdpbmUsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmVuYWJsZUVkaXRNb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVuYWJsZUVkaXRNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5kaXNhYmxlRWRpdE1vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZGlzYWJsZUVkaXRNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5hZGROb2RlTW9kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5hZGROb2RlTW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZWRpdE5vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZWRpdE5vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmVkaXROb2RlTW9kZT1mdW5jdGlvbigpe3JldHVybiBjb25zb2xlLndhcm4oXCJEZXByZWNhdGVkOiBQbGVhc2UgdXNlIGVkaXROb2RlIGluc3RlYWQgb2YgZWRpdE5vZGVNb2RlLlwiKSx0aGlzLm1hbmlwdWxhdGlvbi5lZGl0Tm9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuYWRkRWRnZU1vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uYWRkRWRnZU1vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmVkaXRFZGdlTW9kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5lZGl0RWRnZU1vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmRlbGV0ZVNlbGVjdGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmRlbGV0ZVNlbGVjdGVkLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5nZXRQb3NpdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0UG9zaXRpb25zLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5nZXRQb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRQb3NpdGlvbi5hcHBseSh0aGlzLm5vZGVzSGFuZGxlcixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuc3RvcmVQb3NpdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuc3RvcmVQb3NpdGlvbnMuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLm1vdmVOb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLm1vdmVOb2RlLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRCb3VuZGluZ0JveC5hcHBseSh0aGlzLm5vZGVzSGFuZGxlcixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkTm9kZXM9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuYm9keS5ub2Rlc1t0XT90aGlzLm5vZGVzSGFuZGxlci5nZXRDb25uZWN0ZWROb2Rlcy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlcixhcmd1bWVudHMpOnRoaXMuZWRnZXNIYW5kbGVyLmdldENvbm5lY3RlZE5vZGVzLmFwcGx5KHRoaXMuZWRnZXNIYW5kbGVyLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5nZXRDb25uZWN0ZWRFZGdlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRDb25uZWN0ZWRFZGdlcy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlcixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuc3RhcnRTaW11bGF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGh5c2ljcy5zdGFydFNpbXVsYXRpb24uYXBwbHkodGhpcy5waHlzaWNzLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5zdG9wU2ltdWxhdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBoeXNpY3Muc3RvcFNpbXVsYXRpb24uYXBwbHkodGhpcy5waHlzaWNzLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5zdGFiaWxpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5waHlzaWNzLnN0YWJpbGl6ZS5hcHBseSh0aGlzLnBoeXNpY3MsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmdldFNlbGVjdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0aW9uLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlcixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuc2V0U2VsZWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZXRTZWxlY3Rpb24uYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5nZXRTZWxlY3RlZE5vZGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVJZHMuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5nZXRTZWxlY3RlZEVkZ2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VJZHMuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5nZXROb2RlQXQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0LmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlcixhcmd1bWVudHMpO3JldHVybiB2b2lkIDAhPT10JiZ2b2lkIDAhPT10LmlkP3QuaWQ6dH0sbnAucHJvdG90eXBlLmdldEVkZ2VBdD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRFZGdlQXQuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLGFyZ3VtZW50cyk7cmV0dXJuIHZvaWQgMCE9PXQmJnZvaWQgMCE9PXQuaWQ/dC5pZDp0fSxucC5wcm90b3R5cGUuc2VsZWN0Tm9kZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE5vZGVzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlcixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuc2VsZWN0RWRnZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdEVkZ2VzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlcixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUudW5zZWxlY3RBbGw9ZnVuY3Rpb24oKXt0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLGFyZ3VtZW50cyksdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmNvbW1pdFdpdGhvdXRFbWl0dGluZy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIpLHRoaXMucmVkcmF3KCl9LG5wLnByb3RvdHlwZS5yZWRyYXc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZW5kZXJlci5yZWRyYXcuYXBwbHkodGhpcy5yZW5kZXJlcixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0U2NhbGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3LmdldFNjYWxlLmFwcGx5KHRoaXMudmlldyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0Vmlld1Bvc2l0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlldy5nZXRWaWV3UG9zaXRpb24uYXBwbHkodGhpcy52aWV3LGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5maXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3LmZpdC5hcHBseSh0aGlzLnZpZXcsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLm1vdmVUbz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcubW92ZVRvLmFwcGx5KHRoaXMudmlldyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZm9jdXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3LmZvY3VzLmFwcGx5KHRoaXMudmlldyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUucmVsZWFzZU5vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3LnJlbGVhc2VOb2RlLmFwcGx5KHRoaXMudmlldyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0T3B0aW9uc0Zyb21Db25maWd1cmF0b3I9ZnVuY3Rpb24oKXt2YXIgdD17fTtyZXR1cm4gdGhpcy5jb25maWd1cmF0b3ImJih0PXRoaXMuY29uZmlndXJhdG9yLmdldE9wdGlvbnMuYXBwbHkodGhpcy5jb25maWd1cmF0b3IpKSx0fTt2YXIgcnA9aGQ7dC5OZXR3b3JrPW5wLHQuTmV0d29ya0ltYWdlcz1wZCx0Lm5ldHdvcmtET1RQYXJzZXI9ZGQsdC5uZXR3b3JrR2VwaGlQYXJzZXI9Y2QsdC5uZXR3b3JrT3B0aW9ucz1lcCx0LnBhcnNlRE9UTmV0d29yaz1ycCx0LnBhcnNlR2VwaGlOZXR3b3JrPWxkLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlzLW5ldHdvcmsubWluLmpzLm1hcFxuIiwicmVxdWlyZShcImxlYWZsZXQvZGlzdC9sZWFmbGV0LmNzc1wiKTtcbnJlcXVpcmUoJ0BpY29uaWZ5L2ljb25pZnknKTtcbnJlcXVpcmUoJ2xlYWZsZXQnKTtcbnJlcXVpcmUoJy4vcGdfcGFyc2VyX2Jyb3dzZXJpZmllZC5qcycpO1xuXG5cbmxldCB2aXNEYXRhID0gcmVxdWlyZSgndmlzLWRhdGEnKTtcbmxldCB2aXNOZXR3b3JrID0gcmVxdWlyZSgndmlzLW5ldHdvcmsnKTtcblxuY29uc3QgZGVmYXVsdFdpZHRoID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBCbGl0emJvYXJkIHtcbiAgc3RhdGljIGZvbnRMb2FkZWQgPSBmYWxzZTtcbiAgc3RhdGljIGRlZmF1bHRDb25maWcgPSB7XG4gICAgZG91YmxlQ2xpY2tXYWl0OiAyMDAsXG4gICAgbm9kZToge1xuICAgICAgY2FwdGlvbjogWydpZCddLFxuICAgICAgZGVmYXVsdEljb246IHRydWUsXG4gICAgICB0aHVtYm5haWw6ICd0aHVtYm5haWwnLFxuICAgICAgc2F0dXJhdGlvbjogJzEwMCUnLFxuICAgICAgYnJpZ2h0bmVzczogJzM3JScsXG4gICAgICBsaW1pdDogNTAwXG4gICAgfSxcbiAgICBlZGdlOiB7XG4gICAgICBjYXB0aW9uOiBbJ2xhYmVsJ10sXG4gICAgICBzYXR1cmF0aW9uOiAnMCUnLFxuICAgICAgYnJpZ2h0bmVzczogJzYyJScsXG4gICAgICBsaW1pdDogMTAwMDAsXG4gICAgICB3aWR0aDogZGVmYXVsdFdpZHRoXG4gICAgfSxcbiAgICB6b29tOiB7IFxuICAgICAgbWF4OiAzLjAsXG4gICAgICBtaW46IDAuMjUsXG4gICAgfSxcbiAgICBsYXlvdXRTZXR0aW5nczoge1xuICAgICAgdGltZV9mcm9tOiAnZnJvbScsXG4gICAgICB0aW1lX3RvOiAndG8nLFxuICAgICAgbG5nOiAnbG5nJyxcbiAgICAgIGxhdDogJ2xhdCdcbiAgICB9LFxuICAgIHN0eWxlOiBcImJvcmRlcjogc29saWQgMXB4IHNpbHZlcjsgYmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KHdoaXRlLCBzaWx2ZXIpO1wiLFxuICAgIGV4dHJhT3B0aW9uczoge1xuICAgIH1cbiAgfTtcbiAgc3RhdGljIHRvb2x0aXBNYXhXaWR0aCA9IDYwMDtcbiAgc3RhdGljIGljb25QcmVmaXhlcyA9IFsnZmEtc29saWQ6JywgJ2lvbjonLCAnYng6YngtJywgJ2dyaWRpY29uczonLCAnYWthci1pY29uczonXTtcbiAgc3RhdGljIGljb25TaXplQ29lZiA9IDEuNTtcbiAgc3RhdGljIG1pblNjYWxlT25NYXAgPSAwLjM7XG4gIHN0YXRpYyBtYXhTY2FsZU9uTWFwID0gMS4wO1xuICBzdGF0aWMgbWFwQ29udGFpbmVySWQgPSAnbWFwJztcbiAgc3RhdGljIGVkZ2VEZWxpbWl0ZXIgPSAnLSc7XG4gIHN0YXRpYyBub2RlVGVtcGxhdGUgPSB7XG4gICAgaWQ6IG51bGwsXG4gICAgbGFiZWxzOiBbXSxcbiAgICBwcm9wZXJ0aWVzOiB7fVxuICB9XG4gIHN0YXRpYyBlZGdlVGVtcGxhdGUgPSB7XG4gICAgZnJvbTogbnVsbCxcbiAgICB0bzogbnVsbCxcbiAgICBkaXJlY3Rpb246ICctPicsXG4gICAgbGFiZWxzOiBbXSxcbiAgICBwcm9wZXJ0aWVzOiB7fVxuICB9XG5cbiAgc3RhdGljIGxvYWRlZEljb25zID0ge307XG4gIFxuICBzdGF0aWMgcmVuZGVyZWRDb2xvcnMgPSB7fTtcbiAgXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMubm9kZUNvbG9yTWFwID0ge307XG4gICAgdGhpcy5leHBhbmRlZE5vZGVzID0gW107XG4gICAgdGhpcy5ub2RlTWFwID0ge307XG4gICAgdGhpcy5jb25maWcgPSB7IG5vZGU6IHt9LCBlZGdlOiB7fX07XG4gICAgdGhpcy5ub2RlTGluZU1hcCA9IHt9O1xuICAgIHRoaXMuZWRnZU1hcCA9IHt9O1xuICAgIHRoaXMuZWRnZUxpbmVNYXAgPSB7fTtcbiAgICB0aGlzLnByZXZab29tUG9zaXRpb24gPSBudWxsO1xuICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICB0aGlzLmVsZW1lbnRXaXRoVG9vbHRpcCA9IG51bGw7XG4gICAgXG4gICAgdGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIFxuICAgIHRoaXMubmV0d29ya0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMubmV0d29ya0NvbnRhaW5lci5zdHlsZSA9IHRoaXMubmV0d29ya0NvbnRhaW5lck9yaWdpbmFsU3R5bGUgPSBgXG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIHRvcDogMDtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB6LWluZGV4OiAyO1xuICAgIGA7XG4gICAgXG4gICAgdGhpcy5tYXBDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLm1hcENvbnRhaW5lci5zdHlsZSA9IGBcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgdG9wOiAwO1xuICAgICAgbGVmdDogMDtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHotaW5kZXg6IDE7XG4gICAgYDtcbiAgICB0aGlzLm1hcCA9IG51bGw7XG4gICAgdGhpcy50b29sdGlwRHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLnRvb2x0aXBEdW1teS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy50b29sdGlwRHVtbXkuY2xhc3NMaXN0LmFkZCgnYmxpdHpib2FyZC10b29sdGlwJyk7XG4gICAgdGhpcy50b29sdGlwRHVtbXkuc3R5bGVbJ2JhY2tncm91bmQtY29sb3InXSA9ICdyZ2JhKDAsIDAsIDAsIDApJztcbiAgICB0aGlzLnRvb2x0aXBEdW1teS5zdHlsZVsnei1pbmRleCddID0gJzk5OCc7XG5cbiAgICB0aGlzLnRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgdGhpcy50b29sdGlwLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy50b29sdGlwLmNsYXNzTGlzdC5hZGQoJ2JsaXR6Ym9hcmQtdG9vbHRpcHRleHQnKTtcbiAgICB0aGlzLnRvb2x0aXAuY2xhc3NMaXN0LmFkZCgnYmxpdHpib2FyZC10b29sdGlwdGV4dC10b3AnKTtcbiAgICB0aGlzLnRvb2x0aXAuc3R5bGVbJ3otaW5kZXgnXSA9ICc5OTknO1xuXG5cbiAgICB0aGlzLm1pblRpbWUgPSBuZXcgRGF0ZSg4NjQwMDAwMDAwMDAwMDAwKTtcbiAgICB0aGlzLm1heFRpbWUgPSBuZXcgRGF0ZSgtODY0MDAwMDAwMDAwMDAwMCk7XG4gICAgXG4gICAgdGhpcy5wcmV2TW91c2VFdmVudD0gbnVsbDtcbiAgICB0aGlzLnRpbWVTY2FsZSA9IDEwMDA7XG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudExhdExuZyA9IG51bGw7XG4gICAgdGhpcy5yZWRyYXdUaW1lciA9IG51bGw7XG4gICAgdGhpcy5vbk5vZGVBZGRlZCA9IFtdO1xuICAgIHRoaXMub25FZGdlQWRkZWQgPSBbXTtcbiAgICB0aGlzLm9uTm9kZUZvY3VzZWQgPSBbXTtcbiAgICB0aGlzLm9uRWRnZUZvY3VzZWQgPSBbXTtcbiAgICB0aGlzLm9uVXBkYXRlZCA9IFtdO1xuICAgIHRoaXMuYmVmb3JlUGFyc2UgPSBbXTtcbiAgICB0aGlzLm9uUGFyc2VFcnJvciA9IFtdO1xuICAgIHRoaXMubWF4TGluZSA9IDA7XG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25UaW1lcklkID0gbnVsbDtcbiAgICB0aGlzLnNjcmVlbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuc2NyZWVuVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuc2NyZWVuVGV4dC5zdHlsZSA9IGBcbiAgICAgIGZvbnQtc2l6ZTogMnJlbTtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcbiAgICAgIHBhZGRpbmc6IDEwcHg7XG4gICAgYDtcbiAgICB0aGlzLnNjcmVlbi5hcHBlbmRDaGlsZCh0aGlzLnNjcmVlblRleHQpO1xuICAgIHRoaXMuc2NyZWVuVGV4dC5pbm5lclRleHQgPSBcIk5vdyBsb2FkaW5nLi4uXCI7XG4gICAgdGhpcy5zY3JlZW4uc3R5bGUgPSBgXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICB6LWluZGV4OiAzO1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBkaXNwbGF5OiBub25lO1xuICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgZm9udC1zaXplOiAycmVtO1xuICAgIGA7XG4gICAgdGhpcy5kb3VibGVDbGlja1RpbWVyID0gbnVsbDtcbiAgICBcbiAgICBsZXQgYmxpdHpib2FyZCA9IHRoaXM7XG5cbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zY3JlZW4pO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm5ldHdvcmtDb250YWluZXIpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm1hcENvbnRhaW5lcik7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnRvb2x0aXBEdW1teSk7XG4gICAgdGhpcy50b29sdGlwRHVtbXkuYXBwZW5kQ2hpbGQodGhpcy50b29sdGlwKTtcbiAgICB0aGlzLnRvb2x0aXAuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIChlKSA9PiB7XG4gICAgICBpZihlLnJlbGF0ZWRUYXJnZXQgIT09IGJsaXR6Ym9hcmQubmV0d29yay5jYW52YXMuZ2V0Q29udGV4dCgpLmNhbnZhcylcbiAgICAgICAgYmxpdHpib2FyZC5oaWRlVG9vbHRpcCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCAoZSkgPT4ge1xuICAgICAgaWYoYmxpdHpib2FyZC5jb25maWcubGF5b3V0ID09PSAnbWFwJylcbiAgICAgIHtcbiAgICAgICAgaWYoKGUuZGVsdGFZIDwgMCAmJiBibGl0emJvYXJkLm1hcC5fem9vbSA8IGJsaXR6Ym9hcmQubWFwLmdldE1heFpvb20oKSkgfHxcbiAgICAgICAgICAoZS5kZWx0YVkgPiAwICYmIGJsaXR6Ym9hcmQubWFwLl96b29tID4gYmxpdHpib2FyZC5tYXAuZ2V0TWluWm9vbSgpKSApIHtcbiAgICAgICAgICBpZighYmxpdHpib2FyZC5jdXJyZW50TGF0TG5nKSB7XG4gICAgICAgICAgICBibGl0emJvYXJkLmN1cnJlbnRMYXRMbmcgPSBibGl0emJvYXJkLm1hcC5tb3VzZUV2ZW50VG9MYXRMbmcoZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJsaXR6Ym9hcmQubWFwLnNldFpvb21Bcm91bmQoYmxpdHpib2FyZC5jdXJyZW50TGF0TG5nLCBibGl0emJvYXJkLm1hcC5fem9vbSAtIGUuZGVsdGFZICogMC4wMywge2FuaW1hdGU6IGZhbHNlfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1NjYWxlID0gYmxpdHpib2FyZC5tYXAuX3pvb20gLyAxMiArIDAuNDtcbiAgICAgICAgbmV3U2NhbGUgPSBNYXRoLm1pbihCbGl0emJvYXJkLm1heFNjYWxlT25NYXAsIE1hdGgubWF4KG5ld1NjYWxlLCBCbGl0emJvYXJkLm1pblNjYWxlT25NYXApKTtcbiAgICAgICAgc2V0VGltZW91dCggKCkgPT4ge1xuICAgICAgICAgIGJsaXR6Ym9hcmQubmV0d29yay5tb3ZlVG8oe3NjYWxlOiBuZXdTY2FsZX0pO1xuICAgICAgICAgIGJsaXR6Ym9hcmQudXBkYXRlTm9kZUxvY2F0aW9uT25NYXAoKTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgICBibGl0emJvYXJkLm1hcC5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIEluaGliaXQgem9vbSBvbiB2aXMtbmV0d29ya1xuICAgICAgfVxuICAgIH0sIHRydWUpO1xuICAgIFxuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgKGUpID0+IHtcbiAgICAgIGJsaXR6Ym9hcmQuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9LCB0cnVlKTtcblxuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoZSkgPT4ge1xuICAgICAgYmxpdHpib2FyZC5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIH0sIHRydWUpO1xuICAgIFxuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIChlKSA9PiB7XG4gICAgICBpZihibGl0emJvYXJkLmRyYWdnaW5nICYmIGJsaXR6Ym9hcmQuY29uZmlnLmxheW91dCA9PT0gJ21hcCcgJiYgYmxpdHpib2FyZC5wcmV2TW91c2VFdmVudCkge1xuICAgICAgICBibGl0emJvYXJkLm1hcC5wYW5CeShbYmxpdHpib2FyZC5wcmV2TW91c2VFdmVudC54IC0gZS54LCBibGl0emJvYXJkLnByZXZNb3VzZUV2ZW50LnkgLSBlLnldLCB7YW5pbWF0ZTogZmFsc2V9KTtcbiAgICAgIH1cbiAgICAgIGlmKGJsaXR6Ym9hcmQuZWxlbWVudFdpdGhUb29sdGlwPy5lZGdlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcExvY2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBibGl0emJvYXJkLnByZXZNb3VzZUV2ZW50ID0gZTtcbiAgICAgIGJsaXR6Ym9hcmQuY3VycmVudExhdExuZyA9IG51bGw7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIChlKSA9PiB7XG4gICAgICBpZihibGl0emJvYXJkLmNvbmZpZy5sYXlvdXQgPT09ICdtYXAnKSB7XG4gICAgICAgIGJsaXR6Ym9hcmQubWFwLnBhblRvKGJsaXR6Ym9hcmQubWFwLm1vdXNlRXZlbnRUb0xhdExuZyhlKSk7XG4gICAgICB9XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZSkgPT4ge1xuICAgICAgYmxpdHpib2FyZC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICBibGl0emJvYXJkLnByZXZNb3VzZUV2ZW50ID0gZTtcbiAgICB9LCB0cnVlKTtcbiAgICBcbiAgICB0aGlzLmFwcGx5RHluYW1pY1N0eWxlKGBcbiAgICAgIC5ibGl0emJvYXJkLXRvb2x0aXAge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IGRvdHRlZCBibGFjaztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLmJsaXR6Ym9hcmQtdG9vbHRpcCAuYmxpdHpib2FyZC10b29sdGlwdGV4dCB7XG4gICAgICAgIG1heC13aWR0aDogJHtCbGl0emJvYXJkLnRvb2x0aXBNYXhXaWR0aH1weDtcbiAgICAgICAgbWluLXdpZHRoOiAyMDBweDtcbiAgICAgICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjcpO1xuICAgICAgICBjb2xvcjogI2ZmZjtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICAgIHBhZGRpbmc6IDVweDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC5ibGl0emJvYXJkLXRvb2x0aXAgLmJsaXR6Ym9hcmQtdG9vbHRpcHRleHQtdG9wIHtcbiAgICAgICAgYm90dG9tOiAxMjUlO1xuICAgICAgICBsZWZ0OiA1MCU7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAtNnB4O1xuICAgICAgfVxuICAgICAgXG4gICAgICAuYmxpdHpib2FyZC10b29sdGlwIC5ibGl0emJvYXJkLXRvb2x0aXB0ZXh0LWJvdHRvbSB7XG4gICAgICAgIGJvdHRvbTogMTAwJTtcbiAgICAgICAgbGVmdDogNTAlO1xuICAgICAgICBtYXJnaW4tbGVmdDogLTZweDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgXG4gICAgICAuYmxpdHpib2FyZC10b29sdGlwIC5ibGl0emJvYXJkLXRvb2x0aXB0ZXh0LWxlZnQge1xuICAgICAgICB0b3A6IDUwJTtcbiAgICAgICAgbGVmdDogMCU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC5ibGl0emJvYXJkLXRvb2x0aXAgLmJsaXR6Ym9hcmQtdG9vbHRpcHRleHQtcmlnaHQge1xuICAgICAgICB0b3A6IC01MCU7XG4gICAgICAgIGxlZnQ6IDEwMCU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIFxuICAgICAgLmJsaXR6Ym9hcmQtdG9vbHRpcCAuYmxpdHpib2FyZC10b29sdGlwdGV4dDo6YWZ0ZXIge1xuICAgICAgICBjb250ZW50OiBcIlwiO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGJvcmRlci13aWR0aDogNnB4O1xuICAgICAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xuICAgICAgfVxuICAgICAgXG4gICAgICAuYmxpdHpib2FyZC10b29sdGlwIC5ibGl0emJvYXJkLXRvb2x0aXB0ZXh0LWJvdHRvbTo6YWZ0ZXIge1xuICAgICAgICB0b3A6IC0xMnB4O1xuICAgICAgICBsZWZ0OiA1MCU7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzU1NSB0cmFuc3BhcmVudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLmJsaXR6Ym9hcmQtdG9vbHRpcCAuYmxpdHpib2FyZC10b29sdGlwdGV4dC1sZWZ0OjphZnRlciB7XG4gICAgICAgIHRvcDogNTAlO1xuICAgICAgICBsZWZ0OiAxMDAlO1xuICAgICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICM1NTU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC5ibGl0emJvYXJkLXRvb2x0aXAgLmJsaXR6Ym9hcmQtdG9vbHRpcHRleHQtdG9wOjphZnRlciB7XG4gICAgICAgIHRvcDogMTAwJTtcbiAgICAgICAgbGVmdDogNTAlO1xuICAgICAgICBib3JkZXItY29sb3I6ICM1NTUgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIC5ibGl0emJvYXJkLXRvb2x0aXAgLmJsaXR6Ym9hcmQtdG9vbHRpcHRleHQtcmlnaHQ6OmFmdGVyIHtcbiAgICAgICAgdG9wOiA1MCU7XG4gICAgICAgIGxlZnQ6IC0xMnB4O1xuICAgICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50ICM1NTUgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC5ibGl0emJvYXJkLXRvb2x0aXB0ZXh0IHRoLCAuYmxpdHpib2FyZC10b29sdGlwdGV4dCB0ZCB7XG4gICAgICAgIHRleHQtYWxpZ246IGxlZnQ7XG4gICAgICAgIHBhZGRpbmctbGVmdDogMTBweDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLmJsaXR6Ym9hcmQtdG9vbHRpcCBhIHtcbiAgICAgICAgY29sb3I6ICM4OEJCRkY7XG4gICAgICB9XG4gICAgYCk7XG4gIH1cblxuICBzdGF0aWMgYmxpdHpQcm94eSA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmIChwcm9wID09PSAnbGFiZWwnKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQubGFiZWxzWzBdO1xuICAgICAgfVxuICAgICAgaWYgKCEocHJvcCBpbiB0YXJnZXQpICYmIHByb3AgaW4gdGFyZ2V0LnByb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wcm9wZXJ0aWVzW3Byb3BdWzBdOyBcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICB9XG4gIH1cblxuICBhcHBseUR5bmFtaWNTdHlsZShjc3MpIHtcbiAgICB2YXIgc3R5bGVUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHZhciBkeW5hbWljU3R5bGVDc3MgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHN0eWxlVGFnLmFwcGVuZENoaWxkKGR5bmFtaWNTdHlsZUNzcyk7XG4gICAgdmFyIGhlYWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgaGVhZGVyLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcbiAgfTtcblxuICBnZXRIZXhDb2xvcnMoY29sb3JTdHIpIHtcbiAgICBsZXQgY29tcHV0ZWQgPSBCbGl0emJvYXJkLnJlbmRlcmVkQ29sb3JzW2NvbG9yU3RyXTtcbiAgICBpZihjb21wdXRlZCkge1xuICAgICAgcmV0dXJuIGNvbXB1dGVkO1xuICAgIH1cbiAgICBsZXQgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGEuc3R5bGUuY29sb3IgPSBjb2xvclN0cjtcbiAgICBsZXQgY29sb3JzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSkgKS5jb2xvci5tYXRjaCgvXFxkKy9nKS5tYXAoZnVuY3Rpb24oYSl7IHJldHVybiBwYXJzZUludChhLDEwKTsgfSk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhKTtcbiAgICBCbGl0emJvYXJkLnJlbmRlcmVkQ29sb3JzW2NvbG9yU3RyXSA9IGNvbG9ycztcbiAgICByZXR1cm4gY29sb3JzO1xuICB9XG4gIFxuICBoYXNOb2RlKG5vZGVfaWQpIHtcbiAgICByZXR1cm4gISF0aGlzLm5vZGVNYXBbbm9kZV9pZF07XG4gIH1cbiAgXG4gIGhhc0VkZ2UoZnJvbSwgdG8sIGxhYmVsID0gbnVsbCkge1xuICAgIGZvcihsZXQgZWRnZSBvZiB0aGlzLmdyYXBoLmVkZ2VzKSB7XG4gICAgICBpZihlZGdlLmZyb20gPT09IGZyb20gJiYgZWRnZS50byA9PT0gdG8gJiYgKCFsYWJlbCB8fCBlZGdlLmxhYmVscy5pbmNsdWRlcyhsYWJlbCkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIFxuICBnZXRBbGxOb2RlcyhsYWJlbCA9IG51bGwpIHtcbiAgICBpZihsYWJlbClcbiAgICAgIHJldHVybiB0aGlzLmdyYXBoLm5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUubGFiZWxzLmluY2x1ZGVzKGxhYmVsKSkubWFwKG5vZGUgPT4gdGhpcy5nZXROb2RlKG5vZGUuaWQpKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5ncmFwaC5ub2Rlcy5tYXAobm9kZSA9PiB0aGlzLmdldE5vZGUobm9kZS5pZCkpO1xuICB9XG5cbiAgZ2V0Tm9kZShub2RlX2lkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eSh0aGlzLm5vZGVNYXBbbm9kZV9pZF0sIEJsaXR6Ym9hcmQuYmxpdHpQcm94eSk7XG4gIH1cbiAgXG4gIGdldEVkZ2UoZWRnZV9pZCkge1xuICAgIHJldHVybiBuZXcgUHJveHkodGhpcy5lZGdlTWFwW2VkZ2VfaWRdLCBCbGl0emJvYXJkLmJsaXR6UHJveHkpO1xuICB9XG4gIFxuICBjYWxjTm9kZVBvc2l0aW9uKHBnTm9kZSkge1xuICAgIGxldCB4LCB5LCBmaXhlZCwgd2lkdGg7XG4gICAgaWYodGhpcy5jb25maWcubGF5b3V0ID09PSAndGltZWxpbmUnICYmIHRoaXMudGltZUludGVydmFsID4gMCkge1xuICAgICAgeCA9IG51bGw7XG4gICAgICBmaXhlZCA9IGZhbHNlO1xuICAgICAgbGV0IGZyb21Qcm9wID0gdGhpcy5jb25maWcubGF5b3V0U2V0dGluZ3MudGltZV9mcm9tO1xuICAgICAgbGV0IHRvUHJvcCA9IHRoaXMuY29uZmlnLmxheW91dFNldHRpbmdzLnRpbWVfdG87XG4gICAgICBsZXQgZnJvbSA9IHRoaXMubWF4VGltZTtcbiAgICAgIGxldCB0byA9IHRoaXMubWluVGltZTtcblxuICAgICAgZm9yIChsZXQgcHJvcCBvZiBPYmplY3Qua2V5cyhwZ05vZGUucHJvcGVydGllcykpIHtcbiAgICAgICAgaWYgKHByb3AgPT09IGZyb21Qcm9wIHx8IHByb3AgPT09IHRvUHJvcCkge1xuICAgICAgICAgIGZyb20gPSBuZXcgRGF0ZShNYXRoLm1pbihmcm9tLCBuZXcgRGF0ZShwZ05vZGUucHJvcGVydGllc1twcm9wXVswXSkpKTtcbiAgICAgICAgICB0byA9IG5ldyBEYXRlKE1hdGgubWF4KHRvLCBuZXcgRGF0ZShwZ05vZGUucHJvcGVydGllc1twcm9wXVswXSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIFxuICAgICAgaWYoZnJvbSA8PSB0bykge1xuICAgICAgICBmaXhlZCA9IHRydWU7XG4gICAgICAgIGxldCBmcm9tUG9zaXRpb24gPSB0aGlzLnRpbWVTY2FsZSAqIChmcm9tLmdldFRpbWUoKSAtIHRoaXMubWluVGltZS5nZXRUaW1lKCkpICogMS4wIC8gdGhpcy50aW1lSW50ZXJ2YWwgLSB0aGlzLnRpbWVTY2FsZSAqIDAuNTtcbiAgICAgICAgbGV0IHRvUG9zaXRpb24gPSB0aGlzLnRpbWVTY2FsZSAqICh0by5nZXRUaW1lKCkgLSB0aGlzLm1pblRpbWUuZ2V0VGltZSgpKSAqIDEuMCAvIHRoaXMudGltZUludGVydmFsIC0gdGhpcy50aW1lU2NhbGUgKiAwLjU7XG4gICAgICAgIHggPSAoZnJvbVBvc2l0aW9uICsgdG9Qb3NpdGlvbikgLyAyO1xuICAgICAgICBpZihmcm9tID09PSB0bykge1xuICAgICAgICAgIHdpZHRoID0gZnJvbVBvc2l0aW9uIC0gdG9Qb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aWR0aCA9IDI1O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZih0aGlzLmNvbmZpZy5sYXlvdXQgPT0gJ2N1c3RvbScpIHtcbiAgICAgICAgaWYgKHBnTm9kZS5wcm9wZXJ0aWVzW3RoaXMuY29uZmlnLmxheW91dFNldHRpbmdzLnhdIHx8IHBnTm9kZS5wcm9wZXJ0aWVzW3RoaXMuY29uZmlnLmxheW91dFNldHRpbmdzLnldKSB7XG4gICAgICAgICAgeCA9IHBhcnNlSW50KHBnTm9kZS5wcm9wZXJ0aWVzW3RoaXMuY29uZmlnLmxheW91dFNldHRpbmdzLnhdWzBdKTtcbiAgICAgICAgICB5ID0gcGFyc2VJbnQocGdOb2RlLnByb3BlcnRpZXNbdGhpcy5jb25maWcubGF5b3V0U2V0dGluZ3MueV1bMF0pO1xuICAgICAgICAgIGZpeGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IG51bGw7XG4gICAgICAgIHkgPSBudWxsO1xuICAgICAgICBmaXhlZCA9IHRoaXMuY29uZmlnLmxheW91dCA9PT0gJ2hpZXJhcmNoaWNhbCc7XG4gICAgICAgIHdpZHRoID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHt4LCB5LCBmaXhlZCwgd2lkdGh9O1xuICB9XG5cbiAgcmV0cmlldmVUaHVtYm5haWxVcmwobm9kZSkge1xuICAgIGlmKHRoaXMuY29uZmlnLm5vZGUudGh1bWJuYWlsKSB7XG4gICAgICByZXR1cm4gbm9kZS5wcm9wZXJ0aWVzW3RoaXMuY29uZmlnLm5vZGUudGh1bWJuYWlsXT8uWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBcbiAgdG9vbHRpcFBvc2l0aW9uKCkge1xuICAgIGlmKHdpbmRvdy5pbm5lcldpZHRoIDwgd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2TW91c2VFdmVudC5jbGllbnRZIDwgd2luZG93LmlubmVySGVpZ2h0IC8gMiA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByZXZNb3VzZUV2ZW50LmNsaWVudFggPCB3aW5kb3cuaW5uZXJXaWR0aCAvIDIgPyAncmlnaHQnIDogJ2xlZnQnO1xuICB9XG4gIFxuICB1cGRhdGVUb29sdGlwTG9jYXRpb24oKSB7XG4gICAgaWYoIXRoaXMuZWxlbWVudFdpdGhUb29sdGlwKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBwb3NpdGlvbiwgb2Zmc2V0ID0gMTA7XG4gICAgaWYodGhpcy5lbGVtZW50V2l0aFRvb2x0aXAubm9kZSkge1xuICAgICAgcG9zaXRpb24gPSB0aGlzLm5ldHdvcmsuY2FudmFzVG9ET00odGhpcy5uZXR3b3JrLmdldFBvc2l0aW9uKHRoaXMuZWxlbWVudFdpdGhUb29sdGlwLm5vZGUuaWQpKTtcbiAgICAgIGxldCBjbGllbnRSZWN0ID0gdGhpcy5jb250YWluZXIuZ2V0Q2xpZW50UmVjdHMoKVswXTtcbiAgICAgIHBvc2l0aW9uLnggKz0gY2xpZW50UmVjdC54O1xuICAgICAgcG9zaXRpb24ueSArPSBjbGllbnRSZWN0Lnk7XG4gICAgICBvZmZzZXQgKz0gdGhpcy5lbGVtZW50V2l0aFRvb2x0aXAubm9kZS5zaXplICogdGhpcy5uZXR3b3JrLmdldFNjYWxlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHRoaXMucHJldk1vdXNlRXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogdGhpcy5wcmV2TW91c2VFdmVudC5jbGllbnRZXG4gICAgICB9O1xuICAgIH1cbiAgICBwb3NpdGlvbi54ICs9IHdpbmRvdy5zY3JvbGxYO1xuICAgIHBvc2l0aW9uLnkgKz0gd2luZG93LnNjcm9sbFk7XG4gICAgXG4gICAgc3dpdGNoKHRoaXMudG9vbHRpcFBvc2l0aW9uKCkpIHtcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICB0aGlzLnRvb2x0aXAuY2xhc3NMaXN0LmFkZCgnYmxpdHpib2FyZC10b29sdGlwdGV4dC1sZWZ0Jyk7XG4gICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdibGl0emJvYXJkLXRvb2x0aXB0ZXh0LXRvcCcpO1xuICAgICAgICB0aGlzLnRvb2x0aXAuY2xhc3NMaXN0LnJlbW92ZSgnYmxpdHpib2FyZC10b29sdGlwdGV4dC1yaWdodCcpO1xuICAgICAgICB0aGlzLnRvb2x0aXAuY2xhc3NMaXN0LnJlbW92ZSgnYmxpdHpib2FyZC10b29sdGlwdGV4dC1ib3R0b20nKTtcbiAgICAgICAgcG9zaXRpb24ueCAtPSBvZmZzZXQ7XG4gICAgICAgIHBvc2l0aW9uLnggLT0gdGhpcy50b29sdGlwLmNsaWVudFdpZHRoO1xuICAgICAgICBwb3NpdGlvbi55IC09IHRoaXMudG9vbHRpcC5jbGllbnRIZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdibGl0emJvYXJkLXRvb2x0aXB0ZXh0LWxlZnQnKTtcbiAgICAgICAgdGhpcy50b29sdGlwLmNsYXNzTGlzdC5hZGQoJ2JsaXR6Ym9hcmQtdG9vbHRpcHRleHQtdG9wJyk7XG4gICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdibGl0emJvYXJkLXRvb2x0aXB0ZXh0LXJpZ2h0Jyk7XG4gICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdibGl0emJvYXJkLXRvb2x0aXB0ZXh0LWJvdHRvbScpO1xuICAgICAgICBwb3NpdGlvbi54IC09IHRoaXMudG9vbHRpcC5jbGllbnRXaWR0aCAvIDI7XG4gICAgICAgIHBvc2l0aW9uLnkgLT0gb2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgdGhpcy50b29sdGlwLmNsYXNzTGlzdC5yZW1vdmUoJ2JsaXR6Ym9hcmQtdG9vbHRpcHRleHQtbGVmdCcpO1xuICAgICAgICB0aGlzLnRvb2x0aXAuY2xhc3NMaXN0LnJlbW92ZSgnYmxpdHpib2FyZC10b29sdGlwdGV4dC10b3AnKTtcbiAgICAgICAgdGhpcy50b29sdGlwLmNsYXNzTGlzdC5hZGQoJ2JsaXR6Ym9hcmQtdG9vbHRpcHRleHQtcmlnaHQnKTtcbiAgICAgICAgdGhpcy50b29sdGlwLmNsYXNzTGlzdC5yZW1vdmUoJ2JsaXR6Ym9hcmQtdG9vbHRpcHRleHQtYm90dG9tJyk7XG4gICAgICAgIHBvc2l0aW9uLnggKz0gb2Zmc2V0O1xuICAgICAgICBwb3NpdGlvbi55IC09IHRoaXMudG9vbHRpcC5jbGllbnRIZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdibGl0emJvYXJkLXRvb2x0aXB0ZXh0LWxlZnQnKTtcbiAgICAgICAgdGhpcy50b29sdGlwLmNsYXNzTGlzdC5yZW1vdmUoJ2JsaXR6Ym9hcmQtdG9vbHRpcHRleHQtdG9wJyk7XG4gICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdibGl0emJvYXJkLXRvb2x0aXB0ZXh0LXJpZ2h0Jyk7XG4gICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QuYWRkKCdibGl0emJvYXJkLXRvb2x0aXB0ZXh0LWJvdHRvbScpO1xuICAgICAgICBwb3NpdGlvbi54IC09IHRoaXMudG9vbHRpcC5jbGllbnRXaWR0aCAvIDI7XG4gICAgICAgIHBvc2l0aW9uLnkgKz0gdGhpcy50b29sdGlwLmNsaWVudEhlaWdodDtcbiAgICAgICAgcG9zaXRpb24ueSArPSBvZmZzZXQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMudG9vbHRpcER1bW15LnN0eWxlLmxlZnQgPSBgJHtwb3NpdGlvbi54fXB4YDtcbiAgICB0aGlzLnRvb2x0aXBEdW1teS5zdHlsZS50b3AgPSBgJHtwb3NpdGlvbi55fXB4YDtcbiAgfVxuICBcbiAgc2hvd1Rvb2x0aXAoKSB7XG4gICAgdGhpcy51cGRhdGVUb29sdGlwTG9jYXRpb24oKTtcbiAgICBsZXQgdGl0bGUgPSB0aGlzLmVsZW1lbnRXaXRoVG9vbHRpcC5ub2RlID8gdGhpcy5lbGVtZW50V2l0aFRvb2x0aXAubm9kZS5fdGl0bGUgOiB0aGlzLmVsZW1lbnRXaXRoVG9vbHRpcC5lZGdlLl90aXRsZTtcbiAgICBpZighdGl0bGUpXG4gICAgICByZXR1cm47XG4gICAgXG4gICAgdGhpcy50b29sdGlwLmlubmVySFRNTCA9IHRpdGxlO1xuICAgIHRoaXMudG9vbHRpcC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfVxuICBcbiAgaGlkZVRvb2x0aXAoKSB7XG4gICAgaWYodGhpcy5lbGVtZW50V2l0aFRvb2x0aXApIHtcbiAgICAgIHRoaXMudG9vbHRpcC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy5lbGVtZW50V2l0aFRvb2x0aXAgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHRvVmlzTm9kZShwZ05vZGUsIHByb3BzLCBleHRyYU9wdGlvbnMgPSBudWxsKSB7XG4gICAgY29uc3QgZ3JvdXAgPSBbLi4ucGdOb2RlLmxhYmVsc10uc29ydCgpLmpvaW4oJ18nKTtcbiAgICBpZighdGhpcy5ub2RlQ29sb3JNYXBbZ3JvdXBdKSB7XG4gICAgICB0aGlzLm5vZGVDb2xvck1hcFtncm91cF0gPSBnZXRSYW5kb21Db2xvcihncm91cCwgdGhpcy5jb25maWcubm9kZS5zYXR1cmF0aW9uLCB0aGlzLmNvbmZpZy5ub2RlLmJyaWdodG5lc3MpO1xuICAgIH1cbiAgICBcbiAgICBsZXQgeCwgeSwgZml4ZWQsIHdpZHRoO1xuICAgICh7eCwgeSwgZml4ZWQsIHdpZHRofSA9IHRoaXMuY2FsY05vZGVQb3NpdGlvbihwZ05vZGUpKTtcblxuICAgIGxldCB1cmwgPSByZXRyaWV2ZUh0dHBVcmwocGdOb2RlKTtcbiAgICBsZXQgdGh1bWJuYWlsVXJsID0gdGhpcy5yZXRyaWV2ZVRodW1ibmFpbFVybChwZ05vZGUpO1xuICAgIGxldCBleHBhbmRlZCA9IHRoaXMuZXhwYW5kZWROb2Rlcy5pbmNsdWRlcyhwZ05vZGUuaWQpO1xuXG4gICAgbGV0IGRlZ3JlZSA9ICBwZ05vZGUucHJvcGVydGllc1snZGVncmVlJ107XG4gICAgbGV0IGJsaXR6Ym9hcmQgPSB0aGlzO1xuICAgIGlmKGRlZ3JlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWdyZWUgPSBkZWdyZWVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZ3JlZSA9IDI7IC8vIGFzc3VtZSBkZWdyZWUgdG8gYmUgdHdvIChkZWZhdWx0KVxuICAgIH1cblxuICAgIGxldCBjb2xvciA9IHRoaXMucmV0cmlldmVDb25maWdQcm9wKHBnTm9kZSwgJ25vZGUnLCAnY29sb3InKTtcbiAgICBsZXQgb3BhY2l0eSA9IHBhcnNlRmxvYXQodGhpcy5yZXRyaWV2ZUNvbmZpZ1Byb3AocGdOb2RlLCAnbm9kZScsICdvcGFjaXR5JykpO1xuICAgIGxldCBzaXplICA9IHBhcnNlRmxvYXQodGhpcy5yZXRyaWV2ZUNvbmZpZ1Byb3AocGdOb2RlLCAnbm9kZScsICdzaXplJykpO1xuICAgIGxldCB0b29sdGlwICA9IHRoaXMucmV0cmlldmVDb25maWdQcm9wKHBnTm9kZSwgJ25vZGUnLCAndGl0bGUnKTtcblxuICAgIGNvbG9yID0gY29sb3IgfHwgdGhpcy5ub2RlQ29sb3JNYXBbZ3JvdXBdO1xuICAgIFxuICAgIGlmKG9wYWNpdHkgPCAxKSB7XG4gICAgICBsZXQgcmdiID0gdGhpcy5nZXRIZXhDb2xvcnMoY29sb3IpO1xuICAgICAgY29sb3IgPSBgcmdiYSgke3JnYlswXX0sICR7cmdiWzFdfSwgJHtyZ2JbMl19LCAke29wYWNpdHl9KWA7XG4gICAgfVxuXG4gICAgbGV0IGF0dHJzID0ge1xuICAgICAgaWQ6IHBnTm9kZS5pZCxcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIGxhYmVsOiBjcmVhdGVMYWJlbFRleHQocGdOb2RlLCBwcm9wcyksXG4gICAgICBzaGFwZTogJ2RvdCcsXG4gICAgICBzaXplOiBzaXplIHx8IDI1LFxuICAgICAgZGVncmVlOiBkZWdyZWUsXG4gICAgICBfdGl0bGU6IHRvb2x0aXAgfHwgdGhpcy5jcmVhdGVUaXRsZShwZ05vZGUpLFxuICAgICAgZml4ZWQ6IHtcbiAgICAgICAgeDogZml4ZWQsXG4gICAgICAgIHk6IHRoaXMuY29uZmlnLmxheW91dCA9PT0gJ3RpbWVsaW5lJyA/IGZhbHNlIDogZml4ZWRcbiAgICAgIH0sXG4gICAgICBib3JkZXJXaWR0aDogdXJsID8gMyA6IDEsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgY2hvc2VuOiB0aGlzLnJldHJpZXZlQ29uZmlnUHJvcChwZ05vZGUsICdub2RlJywgJ2Nob3NlbicpLFxuICAgICAgZm9udDoge1xuICAgICAgICBjb2xvcjogdXJsID8gJ2JsdWUnIDogJ2JsYWNrJyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICB9LFxuICAgICAgZml4ZWRCeVRpbWU6IGZpeGVkXG4gICAgfTtcbiAgICBcbiAgICBsZXQgb3RoZXJQcm9wcyA9IHRoaXMucmV0cmlldmVDb25maWdQcm9wQWxsKHBnTm9kZSxcbiAgICAgICdub2RlJywgWydjb2xvcicsICdzaXplJywgJ29wYWNpdHknLCAndGl0bGUnXSk7XG4gICAgXG4gICAgZm9yKGxldCBrZXkgb2YgT2JqZWN0LmtleXMob3RoZXJQcm9wcykpIHtcbiAgICAgIGF0dHJzW2tleV0gPSBvdGhlclByb3BzW2tleV0gfHwgYXR0cnNba2V5XTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gaWNvblJlZ2lzdGVyZXIobmFtZSkge1xuICAgICAgcmV0dXJuIChpY29ucykgPT4ge1xuICAgICAgICBpZiAoaWNvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBpY29uID0gbnVsbDtcbiAgICAgICAgICBpZihpY29ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBGaW5kIGljb24gd2l0aCB0aGUgaGlnaGVzdCBwcmlvcml0eSBcbiAgICAgICAgICAgIGZvciAobGV0IHByZWZpeCBvZiBCbGl0emJvYXJkLmljb25QcmVmaXhlcykge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpIG9mIGljb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGAke2kucHJlZml4fToke2kubmFtZX1gLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgICAgICAgaWNvbiA9IGk7IFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpY29uKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWNvbiA9IGljb24gfHwgaWNvbnNbMF07XG4gICAgICAgICAgbGV0IHNpemUgPSBhdHRycy5zaXplICogQmxpdHpib2FyZC5pY29uU2l6ZUNvZWY7XG4gICAgICAgICAgbGV0IHN2ZyA9IEljb25pZnkucmVuZGVyU1ZHKGAke2ljb24ucHJlZml4fToke2ljb24ubmFtZX1gLCB7XG4gICAgICAgICAgICB3aWR0aDogc2l6ZSxcbiAgICAgICAgICAgIGhlaWdodDogc2l6ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICBzdmcucXVlcnlTZWxlY3RvckFsbChcInBhdGgsY2lyY2xlLGVsbGlwc2UscmVjdFwiKS5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgICAgICBwYXRoLnN0eWxlLmZpbGwgPSBcIndoaXRlXCI7XG4gICAgICAgICAgICBwYXRoLnN0eWxlLnN0cm9rZSA9IFwid2hpdGVcIjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbWcuc3JjID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04LCcgKyBlbmNvZGVVUklDb21wb25lbnQoc3ZnLm91dGVySFRNTCk7XG4gICAgICAgICAgQmxpdHpib2FyZC5sb2FkZWRJY29uc1tuYW1lXSA9IGltZztcbiAgICAgICAgICBpZihibGl0emJvYXJkKSB7XG4gICAgICAgICAgICBpZiAoYmxpdHpib2FyZC5yZWRyYXdUaW1lcikge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoYmxpdHpib2FyZC5yZWRyYXdUaW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibGl0emJvYXJkLnJlZHJhd1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7ICAvLyBBZGQgZGVsYXkgdG8gYXZvaWQgcmVkcmF3IHRvbyBvZmVuXG4gICAgICAgICAgICAgIGJsaXR6Ym9hcmQubmV0d29yay5yZWRyYXcoKTtcbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3IobGV0IGxhYmVsIG9mIHBnTm9kZS5sYWJlbHMpIHtcbiAgICAgIGxldCBpY29uO1xuICAgICAgaWYgKGljb24gPSB0aGlzLmNvbmZpZy5ub2RlLmljb24/LltsYWJlbF0pIHtcbiAgICAgICAgaWYoaWNvbi5pbmNsdWRlcygnOicpKSB7IC8vIEZvciBpY29ucyBpbiBpY29uaWZ5XG4gICAgICAgICAgSWNvbmlmeS5sb2FkSWNvbnMoW2ljb25dLCBpY29uUmVnaXN0ZXJlcihpY29uKSk7XG4gICAgICAgICAgYXR0cnNbJ2N1c3RvbUljb24nXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGljb25cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgeyAvLyBGb3IgaWNvbiBjb2RlcyBpbiBJb25pY29ucyAodG8gYmUgYmFja3dhcmQgY29tcGF0aWJsZSlcbiAgICAgICAgICBsZXQgY29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaWNvbiwgMTYpKTtcbiAgICAgICAgICBhdHRyc1snY3VzdG9tSWNvbiddID0ge1xuICAgICAgICAgICAgZmFjZTogJ0lvbmljb25zJyxcbiAgICAgICAgICAgIHNpemU6IGF0dHJzLnNpemUgKiAxLjUsXG4gICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgY29sb3I6ICd3aGl0ZSdcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICBpZighYXR0cnNbJ2N1c3RvbUljb24nXSAmJiB0aGlzLmNvbmZpZy5ub2RlLmRlZmF1bHRJY29uKSB7XG4gICAgICBmb3IobGV0IGxhYmVsIG9mIHBnTm9kZS5sYWJlbHMpIHtcbiAgICAgICAgbGV0IGxvd2VyTGFiZWwgPSBsYWJlbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIUJsaXR6Ym9hcmQubG9hZGVkSWNvbnNbbG93ZXJMYWJlbF0pIHtcbiAgICAgICAgICBCbGl0emJvYXJkLmxvYWRlZEljb25zW2xvd2VyTGFiZWxdID0gJ3JldHJpZXZpbmcuLi4nOyAvLyBKdXN0IGEgcGxhY2Vob2xkZXIgdG8gYXZvaWQgZHVwbGljYXRlIGZldGNoaW5nXG4gICAgICAgICAgSWNvbmlmeS5sb2FkSWNvbnMoXG4gICAgICAgICAgICBCbGl0emJvYXJkLmljb25QcmVmaXhlcy5tYXAoKHByZWZpeCkgPT4gcHJlZml4ICsgbG93ZXJMYWJlbCksXG4gICAgICAgICAgICBpY29uUmVnaXN0ZXJlcihsb3dlckxhYmVsKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYodGh1bWJuYWlsVXJsKSB7XG4gICAgICBhdHRyc1snc2hhcGUnXSA9ICdpbWFnZSc7XG4gICAgICBhdHRyc1snaW1hZ2UnXSA9IHRodW1ibmFpbFVybDtcbiAgICB9XG4gICAgYXR0cnMgPSBPYmplY3QuYXNzaWduKGF0dHJzLCBleHRyYU9wdGlvbnMpO1xuICAgIHJldHVybiBhdHRycztcbiAgfVxuICBcbiAgcmV0cmlldmVQcm9wKHBnRWxlbSwgY29uZmlnLCBsb2FkRnVuY3Rpb24gPSB0cnVlKSB7XG4gICAgaWYoKHR5cGVvZiBjb25maWcpID09PSAnZnVuY3Rpb24nICYmIGxvYWRGdW5jdGlvbikge1xuICAgICAgcmV0dXJuIGNvbmZpZyhuZXcgUHJveHkocGdFbGVtLCBCbGl0emJvYXJkLmJsaXR6UHJveHkpKTtcbiAgICB9IGVsc2UgaWYoKHR5cGVvZiBjb25maWcpID09PSAnc3RyaW5nJyAmJiBjb25maWcuc3RhcnRzV2l0aCgnQCcpKSB7XG4gICAgICByZXR1cm4gcGdFbGVtLnByb3BlcnRpZXNbY29uZmlnLnN1YnN0cigxKV0/LlswXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZzsgLy8gcmV0dXJuIGFzIGNvbnN0YW50XG4gIH1cbiAgXG4gIHJldHJpZXZlQ29uZmlnUHJvcChwZ0VsZW0sIHR5cGUsIHByb3BOYW1lLCBsb2FkRnVuY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgbGFiZWxzID0gcGdFbGVtLmxhYmVscy5qb2luKCdfJyk7XG4gICAgbGV0IHByb3BDb25maWcgPSB0aGlzLmNvbmZpZz8uW3R5cGVdW3Byb3BOYW1lXTtcbiAgICBpZiAoKHR5cGVvZiBwcm9wQ29uZmlnKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldHJpZXZlUHJvcChwZ0VsZW0sIHByb3BDb25maWdbbGFiZWxzXSwgbG9hZEZ1bmN0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZVByb3AocGdFbGVtLCBwcm9wQ29uZmlnLCBsb2FkRnVuY3Rpb24pO1xuICB9XG5cbiAgcmV0cmlldmVDb25maWdQcm9wQWxsKHBnRWxlbSwgdHlwZSwgZXhjZXB0KSB7XG4gICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmNvbmZpZz8uW3R5cGVdKTtcbiAgICBsZXQgcHJvcHMgPSB7fTtcbiAgICBmb3IobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZihleGNlcHQuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgY29udGludWU7XG4gICAgICAvLyBUT0RPOiBIb3cgY2FuIHdlIGFsbG93IGZ1bmN0aW9ucyBmb3IgYXJiaXRyYXJ5IGNvbmZpZz9cbiAgICAgIHByb3BzW2tleV0gPSB0aGlzLnJldHJpZXZlQ29uZmlnUHJvcChwZ0VsZW0sIHR5cGUsIGtleSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cbiAgXG4gIHRvVmlzRWRnZShwZ0VkZ2UsIHByb3BzID0gdGhpcy5jb25maWcuZWRnZS5jYXB0aW9uLCBpZCkge1xuICAgIGNvbnN0IGVkZ2VMYWJlbCA9IHBnRWRnZS5sYWJlbHMuam9pbignXycpO1xuICAgIGlmICghdGhpcy5lZGdlQ29sb3JNYXBbZWRnZUxhYmVsXSkge1xuICAgICAgdGhpcy5lZGdlQ29sb3JNYXBbZWRnZUxhYmVsXSA9IGdldFJhbmRvbUNvbG9yKGVkZ2VMYWJlbCwgdGhpcy5jb25maWcuZWRnZS5zYXR1cmF0aW9uIHx8ICcwJScsIHRoaXMuY29uZmlnLmVkZ2UuYnJpZ2h0bmVzcyB8fCAnMzAlJyk7XG4gICAgfVxuICAgIGxldCBjb2xvciA9IHRoaXMucmV0cmlldmVDb25maWdQcm9wKHBnRWRnZSwgJ2VkZ2UnLCAnY29sb3InKTtcbiAgICBsZXQgb3BhY2l0eSA9IHBhcnNlRmxvYXQodGhpcy5yZXRyaWV2ZUNvbmZpZ1Byb3AocGdFZGdlLCAnZWRnZScsICdvcGFjaXR5JykpIHx8IDE7XG4gICAgbGV0IHdpZHRoID0gcGFyc2VGbG9hdCh0aGlzLnJldHJpZXZlQ29uZmlnUHJvcChwZ0VkZ2UsICdlZGdlJywnd2lkdGgnKSk7XG4gICAgbGV0IHRvb2x0aXAgID0gdGhpcy5yZXRyaWV2ZUNvbmZpZ1Byb3AocGdFZGdlLCAnZWRnZScsICd0aXRsZScpO1xuXG4gICAgY29sb3IgPSBjb2xvciB8fCB0aGlzLmVkZ2VDb2xvck1hcFtlZGdlTGFiZWxdO1xuXG4gICAgaWYob3BhY2l0eSA8IDEpIHtcbiAgICAgIGxldCByZ2IgPSB0aGlzLmdldEhleENvbG9ycyhjb2xvcik7XG4gICAgICBjb2xvciA9IGByZ2JhKCR7cmdiWzBdfSwgJHtyZ2JbMV19LCAke3JnYlsyXX0sICR7b3BhY2l0eX0pYDtcbiAgICB9XG4gICAgXG4gICAgbGV0IGF0dHJzID0ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgZnJvbTogcGdFZGdlLmZyb20sXG4gICAgICB0bzogcGdFZGdlLnRvLFxuICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgbGFiZWw6IGNyZWF0ZUxhYmVsVGV4dChwZ0VkZ2UsIHByb3BzKSxcbiAgICAgIF90aXRsZTogdG9vbHRpcCB8fCB0aGlzLmNyZWF0ZVRpdGxlKHBnRWRnZSksXG4gICAgICByZW1vdGVJZDogaWQsXG4gICAgICB3aWR0aDogd2lkdGggfHwgZGVmYXVsdFdpZHRoLFxuICAgICAgaG92ZXJXaWR0aDogMC41LFxuICAgICAgc21vb3RoOiB0aGlzLm1hcCA/IGZhbHNlIDogeyByb3VuZG5lc3M6IDEgfSxcbiAgICAgIGNob3NlbjogdGhpcy5yZXRyaWV2ZUNvbmZpZ1Byb3AocGdFZGdlLCAnZWRnZScsICdjaG9zZW4nKSxcbiAgICAgIGFycm93czoge1xuICAgICAgICB0bzoge1xuICAgICAgICAgIGVuYWJsZWQ6IHBnRWRnZS5kaXJlY3Rpb24gPT0gJy0+JyB8fCBwZ0VkZ2UudW5kaXJlY3RlZCA9PT0gJ2ZhbHNlJ1xuICAgICAgICB9LFxuICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgb3RoZXJQcm9wcyA9IHRoaXMucmV0cmlldmVDb25maWdQcm9wQWxsKHBnRWRnZSxcbiAgICAgICdlZGdlJywgWydjb2xvcicsICdvcGFjaXR5JywgJ3dpZHRoJywgJ3RpdGxlJ10pO1xuXG4gICAgZm9yKGxldCBrZXkgb2YgT2JqZWN0LmtleXMob3RoZXJQcm9wcykpIHtcbiAgICAgIGF0dHJzW2tleV0gPSBvdGhlclByb3BzW2tleV0gfHwgYXR0cnNba2V5XTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGF0dHJzO1xuICB9XG4gIFxuICBpbmNsdWRlc05vZGUobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmdyYXBoLm5vZGVzLmZpbHRlcihlID0+IGUuaWQgPT09IG5vZGUuaWQpLmxlbmd0aCA+IDA7XG4gIH1cbiAgXG4gIGFkZE5vZGUobm9kZSwgdXBkYXRlID0gdHJ1ZSkge1xuICAgIHRoaXMuYWRkTm9kZXMoW25vZGVdLCB1cGRhdGUpO1xuICB9XG4gIFxuICBhZGROb2Rlcyhub2RlcywgdXBkYXRlID0gdHJ1ZSkge1xuICAgIGxldCBuZXdOb2RlcztcbiAgICBpZiAodHlwZW9mIG5vZGVzID09PSAnc3RyaW5nJyB8fCBub2RlcyBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgbGV0IHBnID0gdGhpcy50cnlQZ1BhcnNlKG5vZGVzKTtcbiAgICAgIG5ld05vZGVzID0gcGcubm9kZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld05vZGVzID0gbm9kZXM7XG4gICAgfVxuICAgIG5ld05vZGVzID0gbmV3Tm9kZXMuZmlsdGVyKG5vZGUgPT4gIXRoaXMuaW5jbHVkZXNOb2RlKG5vZGUpKS5tYXAoKG5vZGUpID0+IHtcbiAgICAgIGxldCBtYXBwZWQgPSBkZWVwTWVyZ2UoQmxpdHpib2FyZC5ub2RlVGVtcGxhdGUsIG5vZGUpO1xuICAgICAgKyt0aGlzLm1heExpbmU7XG4gICAgICBtYXBwZWQubG9jYXRpb24gPSB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgbGluZTogdGhpcy5tYXhMaW5lLFxuICAgICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgbGluZTogdGhpcy5tYXhMaW5lICsgMSxcbiAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfSk7XG4gICAgdGhpcy5ncmFwaC5ub2RlcyA9IHRoaXMuZ3JhcGgubm9kZXMuY29uY2F0KG5ld05vZGVzKTtcbiAgICBmb3IobGV0IGNhbGxiYWNrIG9mIHRoaXMub25Ob2RlQWRkZWQpIHtcbiAgICAgIC8vIFRPRE86IFRoZSBhcmd1bWVudCBzaG91bGQgYmUgcHJveHkgaW5zdGVhZCBvZiBwbGFpbiBvYmplY3RzXG4gICAgICBjYWxsYmFjayhuZXdOb2Rlcyk7XG4gICAgfVxuICAgIGlmKHVwZGF0ZSlcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgXG4gIGFkZEVkZ2UoZWRnZSwgdXBkYXRlID0gdHJ1ZSkge1xuICAgIHRoaXMuYWRkRWRnZXMoW2VkZ2VdLCB1cGRhdGUpO1xuICB9XG4gIFxuICBoaWdobGlnaHROb2RlUGF0aChub2Rlcykge1xuICAgIGxldCBub2RlSWRzID0gbm9kZXM7XG4gICAgaWYobm9kZXMubGVuZ3RoID4gMCAmJiB0eXBlb2Ygbm9kZXNbMF0gIT09ICdzdHJpbmcnKSB7XG4gICAgICBub2RlSWRzID0gbm9kZXMubWFwKChuKSA9PiBuLmlkKTtcbiAgICB9XG4gICAgbGV0IGVkZ2VJZHMgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbm9kZUlkcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIGVkZ2VJZHMucHVzaChgJHtub2RlSWRzW2ldfSR7QmxpdHpib2FyZC5lZGdlRGVsaW1pdGVyfSR7bm9kZUlkc1tpICsgMV19YCk7XG4gICAgfVxuICAgIHRoaXMubmV0d29yay5zZWxlY3RFZGdlcyhlZGdlSWRzKTtcbiAgfVxuXG4gIGFkZEVkZ2VzKGVkZ2VzLCB1cGRhdGUgPSB0cnVlKSB7XG4gICAgbGV0IG5ld0VkZ2VzO1xuICAgIGlmICh0eXBlb2YgZWRnZXMgPT09ICdzdHJpbmcnIHx8IGVkZ2VzIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICBsZXQgcGcgPSB0aGlzLnRyeVBnUGFyc2UoZWRnZXMpO1xuICAgICAgbmV3RWRnZXMgPSBwZy5lZGdlc1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdFZGdlcyA9IGVkZ2VzXG4gICAgfVxuICAgIG5ld0VkZ2VzID0gbmV3RWRnZXMubWFwKChlZGdlKSA9PiB7XG4gICAgICBsZXQgbWFwcGVkID0gZGVlcE1lcmdlKEJsaXR6Ym9hcmQuZWRnZVRlbXBsYXRlLCBlZGdlKTtcbiAgICAgICsrdGhpcy5tYXhMaW5lO1xuICAgICAgbWFwcGVkLmxvY2F0aW9uID0ge1xuICAgICAgICBzdGFydDoge1xuICAgICAgICAgIGxpbmU6IHRoaXMubWF4TGluZSxcbiAgICAgICAgICBjb2x1bW46IDAsIFxuICAgICAgICB9LFxuICAgICAgICBlbmQ6IHtcbiAgICAgICAgICBsaW5lOiB0aGlzLm1heExpbmUgKyAxLFxuICAgICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9KTtcbiAgICB0aGlzLmdyYXBoLmVkZ2VzID0gdGhpcy5ncmFwaC5lZGdlcy5jb25jYXQobmV3RWRnZXMpO1xuICAgIGZvcihsZXQgY2FsbGJhY2sgb2YgdGhpcy5vbkVkZ2VBZGRlZCkge1xuICAgICAgLy8gVE9ETzogVGhlIGFyZ3VtZW50IHNob3VsZCBiZSBwcm94eSBpbnN0ZWFkIG9mIHBsYWluIG9iamVjdHNcbiAgICAgIGNhbGxiYWNrKG5ld0VkZ2VzKTtcbiAgICB9XG4gICAgaWYodXBkYXRlKVxuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG5cbiAgdHJ5UGdQYXJzZShwZykge1xuICAgIGZvcihsZXQgY2FsbGJhY2sgb2YgdGhpcy5iZWZvcmVQYXJzZSkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBwZ1BhcnNlci5wYXJzZShwZyk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBmb3IobGV0IGNhbGxiYWNrIG9mIHRoaXMub25QYXJzZUVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBjcmVhdGVUaXRsZShlbGVtKSB7XG4gICAgbGV0IGZsYXR0ZW5kX3Byb3BzID0gT2JqZWN0LmVudHJpZXMoZWxlbS5wcm9wZXJ0aWVzKS5yZWR1Y2UoKGFjYywgcHJvcCkgPT5cbiAgICAgIGFjYy5jb25jYXQoYDx0ciB2YWxpZ249XCJ0b3BcIj48dGQ+JHtwcm9wWzBdfTwvdGQ+PHRkPiAke2NvbnZlcnRUb0h5cGVyTGlua0lmVVJMKHByb3BbMV0pfTwvdGQ+PC90cj5gKSwgW10pO1xuICAgIGlmICghZWxlbS5mcm9tKSAvLyBmb3Igbm9kZXNcbiAgICB7XG4gICAgICBsZXQgaWRUZXh0ID0gYDx0cj48dGQ+PGI+JHtlbGVtLmlkfTwvYj48L3RkPjx0ZD4gPGI+JHt3cmFwVGV4dChlbGVtLmxhYmVscy5tYXAoKGwpID0+ICc6JyArIGwpLmpvaW4oJyAnKSwgdHJ1ZSl9PC9iPjwvdGQ+PC90cj5gO1xuICAgICAgZmxhdHRlbmRfcHJvcHMuc3BsaWNlKDAsIDAsIGlkVGV4dCk7XG4gICAgfSBlbHNlIGlmKGVsZW0ubGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBpZFRleHQgPSBgPHRyPjx0ZD48Yj4ke3dyYXBUZXh0KGVsZW0ubGFiZWxzLm1hcCgobCkgPT4gJzonICsgbCkuam9pbignICcpLCB0cnVlKX0gPC9iPjwvdGQ+PHRkPjwvdGQ+PC90cj5gO1xuICAgICAgZmxhdHRlbmRfcHJvcHMuc3BsaWNlKDAsIDAsIGlkVGV4dCk7XG4gICAgfVxuICAgIGlmIChmbGF0dGVuZF9wcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gYDx0YWJsZSBzdHlsZT0nZml4ZWQnPiR7ZmxhdHRlbmRfcHJvcHMuam9pbignJyl9PC90YWJsZT5gO1xuICB9XG5cblxuXG4gIHNldEdyYXBoKGlucHV0LCB1cGRhdGUgPSB0cnVlKSB7XG4gICAgdGhpcy5ub2RlQ29sb3JNYXAgPSB7fTtcbiAgICB0aGlzLmVkZ2VDb2xvck1hcCA9IHt9O1xuICAgIHRoaXMucHJldk1vdXNlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICBsZXQgbmV3UGc7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgbmV3UGcgPSB0aGlzLnRyeVBnUGFyc2UoJycpOyAvLyBTZXQgZW1wdHkgcGdcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCBpbnB1dCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3UGcgPSBKU09OLnBhcnNlKGlucHV0KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgU3ludGF4RXJyb3IpXG4gICAgICAgICAgbmV3UGcgPSB0aGlzLnRyeVBnUGFyc2UoaW5wdXQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQZyA9IGlucHV0O1xuICAgIH1cbiAgICBpZiAobmV3UGcgPT09IG51bGwgfHwgbmV3UGcgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmdyYXBoID0gbmV3UGc7XG5cbiAgICBpZih1cGRhdGUpXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cblxuXG4gIHNldENvbmZpZyhjb25maWcsIHVwZGF0ZSA9IHRydWUpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGRlZXBNZXJnZShCbGl0emJvYXJkLmRlZmF1bHRDb25maWcsIGNvbmZpZyk7XG4gICAgaWYoY29uZmlnLmxheW91dCA9PT0gJ2hpZXJhcmNoaWNhbCcpIHtcbiAgICAgIC8vIFJlbW92ZSByZWR1bmRhbnQgc2V0dGluZ3Mgd2hlbiBsYXlvdXQgaXMgaGllcmFyY2hpY2FsXG4gICAgICB0aGlzLmNvbmZpZy5sYXlvdXRTZXR0aW5ncyA9IGNvbmZpZy5sYXlvdXRTZXR0aW5ncztcbiAgICB9XG4gICAgaWYodXBkYXRlKVxuICAgICAgdGhpcy51cGRhdGUoZmFsc2UpO1xuICB9XG4gIFxuICB2YWxpZGF0ZUdyYXBoKCkge1xuICAgIC8vIElmIGR1cGxpY2F0aW9uIG9mIG5vZGVzIGV4aXN0LCByYWlzZSBlcnJvciBcbiAgICBmdW5jdGlvbiBub251bmlxdWVOb2Rlcyhub2Rlcykge1xuICAgICAgbGV0IG5vbnVuaXF1ZSA9IG5ldyBTZXQoKTtcbiAgICAgIGxldCBub2RlTWFwID0ge30gLy8gaWQgLT4gbm9kZVxuICAgICAgZm9yKGxldCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmKG5vZGVNYXBbbm9kZS5pZF0pIHtcbiAgICAgICAgICBub251bmlxdWUuYWRkKG5vZGVNYXBbbm9kZS5pZF0pO1xuICAgICAgICAgIG5vbnVuaXF1ZS5hZGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZU1hcFtub2RlLmlkXSA9IG5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gWy4uLm5vbnVuaXF1ZV07XG4gICAgfVxuXG4gICAgbGV0IG5vbnVuaXF1ZSA9IG5vbnVuaXF1ZU5vZGVzKHRoaXMuZ3JhcGgubm9kZXMpO1xuICAgIGlmKG5vbnVuaXF1ZS5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRHVwbGljYXRlTm9kZUVycm9yKG5vbnVuaXF1ZSk7XG4gICAgfVxuICAgIFxuICAgIGlmKHRoaXMuZ3JhcGgubm9kZXMubGVuZ3RoID49IHRoaXMuY29uZmlnLm5vZGUubGltaXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG51bWJlciBvZiBub2RlcyBleGNlZWRzIHRoZSBjdXJyZW50IGxpbWl0OiAke3RoaXMuY29uZmlnLm5vZGUubGltaXR9LiBgICtcbiAgICAgICAgYFlvdSBjYW4gY2hhbmdlIGl0IHZpYSBub2RlLmxpbWl0IGluIHlvdXIgY29uZmlnLmApO1xuICAgIH1cblxuICAgIGlmKHRoaXMuZ3JhcGguZWRnZXMubGVuZ3RoID49IHRoaXMuY29uZmlnLmVkZ2UubGltaXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG51bWJlciBvZiBlZGdlcyBleGNlZWRzIHRoZSBjdXJyZW50IGxpbWl0OiAke3RoaXMuY29uZmlnLmVkZ2UubGltaXR9LiBgICtcbiAgICAgICAgYFlvdSBjYW4gY2hhbmdlIGl0IHZpYSBlZGdlLmxpbWl0IGluIHlvdXIgY29uZmlnLmApO1xuICAgIH1cblxuICAgIC8vIElmIGVkZ2UgcmVmZXJzIHRvIHVuZGVmaW5lZCBub2RlcywgY3JlYXRlIHdhcm5pbmdzXG4gICAgZm9yKGxldCBlZGdlIG9mIHRoaXMuZ3JhcGguZWRnZXMpIHtcbiAgICAgIGlmKCF0aGlzLm5vZGVNYXBbZWRnZS5mcm9tXSkge1xuICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2goe1xuICAgICAgICAgIGxvY2F0aW9uOiBlZGdlLmxvY2F0aW9uLFxuICAgICAgICAgIG1lc3NhZ2U6IGBTb3VyY2Ugbm9kZSBpcyB1bmRlZmluZWQ6ICR7ZWRnZS5mcm9tfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZighdGhpcy5ub2RlTWFwW2VkZ2UudG9dKSB7XG4gICAgICAgIHRoaXMud2FybmluZ3MucHVzaCh7XG4gICAgICAgICAgbG9jYXRpb246IGVkZ2UubG9jYXRpb24sXG4gICAgICAgICAgbWVzc2FnZTogYFRhcmdldCBub2RlIGlzIHVuZGVmaW5lZDogJHtlZGdlLnRvfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICB1cGRhdGUoYXBwbHlEaWZmID0gdHJ1ZSkge1xuICAgIGxldCBibGl0emJvYXJkID0gdGhpcztcbiAgICB0aGlzLndhcm5pbmdzID0gW107XG4gICAgYXBwbHlEaWZmID0gYXBwbHlEaWZmICYmIHRoaXMubm9kZURhdGFTZXQgJiYgdGhpcy5lZGdlRGF0YVNldDtcbiAgICBcbiAgICBpZih0aGlzLmNvbmZpZy5zdHlsZSAmJiB0aGlzLmNvbmZpZy5sYXlvdXQgIT09ICdtYXAnKSB7XG4gICAgICB0aGlzLm5ldHdvcmtDb250YWluZXIuc3R5bGUgPSB0aGlzLm5ldHdvcmtDb250YWluZXJPcmlnaW5hbFN0eWxlICsgJyAnICsgdGhpcy5jb25maWcuc3R5bGU7XG4gICAgfVxuXG4gICAgaWYoYXBwbHlEaWZmKSB7XG4gICAgICBsZXQgbm9kZXNUb0RlbGV0ZSA9IG5ldyBTZXQoT2JqZWN0LmtleXModGhpcy5ub2RlTWFwKSk7XG4gICAgICBsZXQgbmV3RWRnZU1hcCA9IHt9O1xuXG4gICAgICB0aGlzLm5vZGVMaW5lTWFwID0ge307XG4gICAgICB0aGlzLmVkZ2VMaW5lTWFwID0ge307XG4gICAgICB0aGlzLm1heExpbmUgPSAwO1xuICAgICAgdGhpcy5ncmFwaC5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICBsZXQgZXhpc3RpbmdOb2RlID0gdGhpcy5ub2RlTWFwW25vZGUuaWRdO1xuICAgICAgICBpZihleGlzdGluZ05vZGUpIHtcbiAgICAgICAgICBpZighbm9kZUVxdWFscyhub2RlLCBleGlzdGluZ05vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVEYXRhU2V0LnJlbW92ZShleGlzdGluZ05vZGUpO1xuICAgICAgICAgICAgbGV0IHZpc05vZGUgPSB0aGlzLnRvVmlzTm9kZShub2RlLCB0aGlzLmNvbmZpZy5ub2RlLmNhcHRpb24pO1xuICAgICAgICAgICAgdGhpcy5ub2RlRGF0YVNldC51cGRhdGUodmlzTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCB2aXNOb2RlID0gdGhpcy50b1Zpc05vZGUobm9kZSwgdGhpcy5jb25maWcubm9kZS5jYXB0aW9uKTtcbiAgICAgICAgICB0aGlzLm5vZGVEYXRhU2V0LmFkZCh2aXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVNYXBbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICBub2Rlc1RvRGVsZXRlLmRlbGV0ZShub2RlLmlkKTtcbiAgICAgICAgaWYobm9kZS5sb2NhdGlvbikge1xuICAgICAgICAgIGZvciAobGV0IGkgPSBub2RlLmxvY2F0aW9uLnN0YXJ0LmxpbmU7IGkgPD0gbm9kZS5sb2NhdGlvbi5lbmQubGluZTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IG5vZGUubG9jYXRpb24uZW5kLmxpbmUgfHwgbm9kZS5sb2NhdGlvbi5lbmQuY29sdW1uID4gMSlcbiAgICAgICAgICAgICAgdGhpcy5ub2RlTGluZU1hcFtpXSA9IG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubWF4TGluZSA9IE1hdGgubWF4KHRoaXMubWF4TGluZSwgbm9kZS5sb2NhdGlvbi5lbmQubGluZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmdyYXBoLmVkZ2VzLmZvckVhY2goZWRnZSA9PiB7XG4gICAgICAgIGxldCBpZCA9IHRoaXMudG9Ob2RlUGFpclN0cmluZyhlZGdlKTtcbiAgICAgICAgd2hpbGUobmV3RWRnZU1hcFtpZF0pIHtcbiAgICAgICAgICBpZCArPSAnXyc7XG4gICAgICAgIH1cbiAgICAgICAgZWRnZS5pZCA9IGlkO1xuICAgICAgICBuZXdFZGdlTWFwW2lkXSA9IGVkZ2U7XG4gICAgICAgIGxldCB2aXNFZGdlID0gdGhpcy50b1Zpc0VkZ2UoZWRnZSwgdGhpcy5jb25maWcuZWRnZS5jYXB0aW9uLCBpZCk7XG4gICAgICAgIHRoaXMuZWRnZURhdGFTZXQudXBkYXRlKHZpc0VkZ2UpO1xuICAgICAgICBpZihlZGdlLmxvY2F0aW9uKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGVkZ2UubG9jYXRpb24uc3RhcnQubGluZTsgaSA8PSBlZGdlLmxvY2F0aW9uLmVuZC5saW5lOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDwgZWRnZS5sb2NhdGlvbi5lbmQubGluZSB8fCBlZGdlLmxvY2F0aW9uLmVuZC5jb2x1bW4gPiAxKVxuICAgICAgICAgICAgICB0aGlzLmVkZ2VMaW5lTWFwW2ldID0gdmlzRWRnZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5tYXhMaW5lID0gTWF0aC5tYXgodGhpcy5tYXhMaW5lLCBlZGdlLmxvY2F0aW9uLmVuZC5saW5lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIG5vZGVzVG9EZWxldGUuZm9yRWFjaCgobm9kZUlkKSA9PiB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVNYXBbbm9kZUlkXTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ub2RlRGF0YVNldC5yZW1vdmUoWy4uLm5vZGVzVG9EZWxldGVdKTtcblxuICAgICAgbGV0IGVkZ2VzVG9EZWxldGUgPSBbXTtcbiAgICAgIGZvcihsZXQgZWRnZUlkIG9mIE9iamVjdC5rZXlzKHRoaXMuZWRnZU1hcCkpIHtcbiAgICAgICAgaWYoIW5ld0VkZ2VNYXBbZWRnZUlkXSkge1xuICAgICAgICAgIGVkZ2VzVG9EZWxldGUucHVzaChlZGdlSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmVkZ2VEYXRhU2V0LnJlbW92ZShlZGdlc1RvRGVsZXRlKTtcbiAgICAgIHRoaXMuZWRnZU1hcCA9IG5ld0VkZ2VNYXA7XG4gICAgICBpZih0aGlzLm1hcCkge1xuICAgICAgICBibGl0emJvYXJkLnVwZGF0ZU5vZGVMb2NhdGlvbk9uTWFwKCk7XG4gICAgICB9XG4gICAgICBpZih0aGlzLmNvbmZpZy5sYXlvdXQgPT09ICd0aW1lbGluZScpIHtcbiAgICAgICAgYmxpdHpib2FyZC51cGRhdGVOb2RlTG9jYXRpb25PblRpbWVMaW5lKCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRoaXMucHJldlpvb21Qb3NpdGlvbiA9IG51bGw7XG4gICAgXG4gICAgdGhpcy5taW5UaW1lID0gbmV3IERhdGUoODY0MDAwMDAwMDAwMDAwMCk7XG4gICAgdGhpcy5tYXhUaW1lID0gbmV3IERhdGUoLTg2NDAwMDAwMDAwMDAwMDApO1xuICAgIFxuICAgIGlmKHRoaXMuY29uZmlnLmxheW91dCA9PT0gJ3RpbWVsaW5lJykge1xuICAgICAgbGV0IGZyb21Qcm9wID0gdGhpcy5jb25maWcubGF5b3V0U2V0dGluZ3MudGltZV9mcm9tO1xuICAgICAgbGV0IHRvUHJvcCA9IHRoaXMuY29uZmlnLmxheW91dFNldHRpbmdzLnRpbWVfdG87XG4gICAgICBcbiAgICAgIHRoaXMuZ3JhcGgubm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBvZiBPYmplY3Qua2V5cyhub2RlLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgaWYgKHByb3AgPT09IGZyb21Qcm9wIHx8IHByb3AgPT09IHRvUHJvcCkge1xuICAgICAgICAgICAgdGhpcy5taW5UaW1lID0gbmV3IERhdGUoTWF0aC5taW4odGhpcy5taW5UaW1lLCBuZXcgRGF0ZShub2RlLnByb3BlcnRpZXNbcHJvcF1bMF0pKSk7XG4gICAgICAgICAgICB0aGlzLm1heFRpbWUgPSBuZXcgRGF0ZShNYXRoLm1heCh0aGlzLm1heFRpbWUsIG5ldyBEYXRlKG5vZGUucHJvcGVydGllc1twcm9wXVswXSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy50aW1lSW50ZXJ2YWwgPSB0aGlzLm1heFRpbWUgLSB0aGlzLm1pblRpbWU7XG4gICAgfVxuXG5cbiAgICBpZihhcHBseURpZmYpIHtcbiAgICAgIHRoaXMudmFsaWRhdGVHcmFwaCgpO1xuXG4gICAgICBmb3IobGV0IGNhbGxiYWNrIG9mIHRoaXMub25VcGRhdGVkKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5ub2RlUHJvcHMgPSBuZXcgU2V0KFsnaWQnLCAnbGFiZWwnXSk7XG4gICAgdGhpcy5lZGdlUHJvcHMgPSBuZXcgU2V0KFsnbGFiZWwnXSk7XG4gICAgdGhpcy5ncmFwaC5ub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICB0aGlzLm5vZGVNYXBbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgaWYobm9kZS5sb2NhdGlvbikge1xuICAgICAgICBmb3IgKGxldCBpID0gbm9kZS5sb2NhdGlvbi5zdGFydC5saW5lOyBpIDw9IG5vZGUubG9jYXRpb24uZW5kLmxpbmU7IGkrKylcbiAgICAgICAgICBpZiAoaSA8IG5vZGUubG9jYXRpb24uZW5kLmxpbmUgfHwgbm9kZS5sb2NhdGlvbi5lbmQuY29sdW1uID4gMSlcbiAgICAgICAgICAgIHRoaXMubm9kZUxpbmVNYXBbaV0gPSBub2RlO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXMobm9kZS5wcm9wZXJ0aWVzKS5maWx0ZXIoKHByb3ApID0+IHByb3AgIT0gJ2RlZ3JlZScpLmZvckVhY2godGhpcy5ub2RlUHJvcHMuYWRkLCB0aGlzLm5vZGVQcm9wcyk7XG4gICAgfSk7XG4gICAgdGhpcy5ncmFwaC5lZGdlcy5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhlZGdlLnByb3BlcnRpZXMpLmZvckVhY2godGhpcy5lZGdlUHJvcHMuYWRkLCB0aGlzLmVkZ2VQcm9wcyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnZhbGlkYXRlR3JhcGgoKTtcblxuXG4gICAgbGV0IGRlZmF1bHROb2RlUHJvcHMgPSB0aGlzLmNvbmZpZy5ub2RlLmNhcHRpb247XG4gICAgbGV0IGRlZmF1bHRFZGdlUHJvcHMgPSB0aGlzLmNvbmZpZy5lZGdlLmNhcHRpb247XG5cbiAgICB0aGlzLm5vZGVEYXRhU2V0ID0gbmV3IHZpc0RhdGEuRGF0YVNldCgpO1xuICAgIHRoaXMubm9kZURhdGFTZXQuYWRkKHRoaXMuZ3JhcGgubm9kZXMubWFwKChub2RlKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy50b1Zpc05vZGUobm9kZSwgZGVmYXVsdE5vZGVQcm9wcyk7XG4gICAgfSkpO1xuICAgIFxuICAgIHRoaXMuZWRnZU1hcCA9IHt9O1xuICAgIHRoaXMuZWRnZURhdGFTZXQgPSBuZXcgdmlzRGF0YS5EYXRhU2V0KHRoaXMuZ3JhcGguZWRnZXMubWFwKChlZGdlKSA9PiB7XG4gICAgICBsZXQgaWQgPSB0aGlzLnRvTm9kZVBhaXJTdHJpbmcoZWRnZSk7XG4gICAgICB3aGlsZSh0aGlzLmVkZ2VNYXBbaWRdKSB7XG4gICAgICAgIGlkICs9ICdfJztcbiAgICAgIH1cbiAgICAgIGxldCB2aXNFZGdlID0gdGhpcy50b1Zpc0VkZ2UoZWRnZSwgZGVmYXVsdEVkZ2VQcm9wcywgaWQpO1xuICAgICAgdGhpcy5lZGdlTWFwW3Zpc0VkZ2UuaWRdID0gZWRnZTtcbiAgICAgIGlmKGVkZ2UubG9jYXRpb24pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGVkZ2UubG9jYXRpb24uc3RhcnQubGluZTsgaSA8PSBlZGdlLmxvY2F0aW9uLmVuZC5saW5lOyBpKyspXG4gICAgICAgICAgaWYgKGkgPCBlZGdlLmxvY2F0aW9uLmVuZC5saW5lIHx8IGVkZ2UubG9jYXRpb24uZW5kLmNvbHVtbiA+IDEpXG4gICAgICAgICAgICB0aGlzLmVkZ2VMaW5lTWFwW2ldID0gdmlzRWRnZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZpc0VkZ2U7XG4gICAgfSkpO1xuXG5cblxuICAgIC8vIGNyZWF0ZSBhIG5ldHdvcmtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgIG5vZGVzOiB0aGlzLm5vZGVEYXRhU2V0LFxuICAgICAgZWRnZXM6IHRoaXMuZWRnZURhdGFTZXRcbiAgICB9O1xuXG4gICAgbGV0IGxheW91dCA9IHtcbiAgICAgIHJhbmRvbVNlZWQ6IDFcbiAgICB9O1xuXG4gICAgaWYodGhpcy5jb25maWcubGF5b3V0ID09PSAnaGllcmFyY2hpY2FsJykge1xuICAgICAgbGF5b3V0LmhpZXJhcmNoaWNhbCA9IHRoaXMuY29uZmlnLmxheW91dFNldHRpbmdzO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXlvdXQuaGllcmFyY2hpY2FsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgbGF5b3V0OlxuICAgICAgICBsYXlvdXQsXG4gICAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgICBkcmFnTm9kZXM6IHRoaXMuY29uZmlnLmxheW91dCAhPT0gJ21hcCcsXG4gICAgICAgIGRyYWdWaWV3OiB0aGlzLmNvbmZpZy5sYXlvdXQgIT09ICdtYXAnLFxuICAgICAgICB6b29tVmlldzogdGhpcy5jb25maWcubGF5b3V0ICE9PSAnbWFwJyxcbiAgICAgICAgaG92ZXI6IHRydWUsXG4gICAgICB9LFxuICAgICAgcGh5c2ljczoge1xuICAgICAgICBlbmFibGVkOiB0aGlzLmNvbmZpZy5sYXlvdXQgIT09ICdtYXAnICYmIHRoaXMuY29uZmlnLmxheW91dCAhPT0gJ2hpZXJhcmNoaWNhbCcsXG4gICAgICAgIGJhcm5lc0h1dDoge1xuICAgICAgICAgIHNwcmluZ0NvbnN0YW50OiAgdGhpcy5jb25maWcubGF5b3V0ID09PSAndGltZWxpbmUnID8gMC4wMDQgOiAwLjAxNlxuICAgICAgICB9LFxuICAgICAgICBzdGFiaWxpemF0aW9uOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgaXRlcmF0aW9uczogMjAwLFxuICAgICAgICAgIHVwZGF0ZUludGVydmFsOiAyNVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWFuaXB1bGF0aW9uOiBmYWxzZSxcblxuICAgICAgZWRnZXM6IHtcbiAgICAgICAgYXJyb3dzOiB7XG4gICAgICAgICAgdG86IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBzY2FsZUZhY3RvcjogMC4zLFxuICAgICAgICAgICAgdHlwZTogXCJhcnJvd1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCB0aGlzLmNvbmZpZy5leHRyYU9wdGlvbnMpO1xuICAgIHRoaXMubmV0d29yayA9IG5ldyB2aXNOZXR3b3JrLk5ldHdvcmsodGhpcy5uZXR3b3JrQ29udGFpbmVyLCBkYXRhLCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgaWYodGhpcy5jb25maWcubGF5b3V0ID09PSAnbWFwJykge1xuICAgICAgdGhpcy5tYXBDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLm5ldHdvcmtDb250YWluZXIuc3R5bGUuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICBsZXQgc3RhdGlzdGljcyA9IHN0YXRpc3RpY3NPZk1hcCgpO1xuICAgICAgbGV0IGNlbnRlciA9IHRoaXMuY29uZmlnPy5sYXlvdXRTZXR0aW5ncz8uY2VudGVyIHx8IHN0YXRpc3RpY3MuY2VudGVyO1xuICAgICAgaWYodGhpcy5tYXApIHtcbiAgICAgICAgdGhpcy5tYXAucGFuVG8oY2VudGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWFwID0gTC5tYXAodGhpcy5tYXBDb250YWluZXIsIHtcbiAgICAgICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgICAgICB6b29tOiBzdGF0aXN0aWNzLnNjYWxlLFxuICAgICAgICAgIG1pblpvb206IDMsXG4gICAgICAgICAgem9vbVNuYXA6IDAuMDEsXG4gICAgICAgICAgem9vbUNvbnRyb2w6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHRpbGVMYXllciA9IEwudGlsZUxheWVyKCdodHRwczovL3tzfS50aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZycsIHtcbiAgICAgICAgICBhdHRyaWJ1dGlvbjogJ8KpIDxhIGhyZWY9XCJodHRwOi8vb3NtLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMsIDxhIGhyZWY9XCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1zYS8yLjAvXCI+Q0MtQlktU0E8L2E+JyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRpbGVMYXllci5hZGRUbyh0aGlzLm1hcCk7XG5cbiAgICAgICAgdGhpcy5tYXAub24oJ21vdmUnLCAoKSA9PiBibGl0emJvYXJkLnVwZGF0ZU5vZGVMb2NhdGlvbk9uTWFwKCkpO1xuICAgICAgICB0aGlzLm1hcC5vbignem9vbScsICgpID0+IGJsaXR6Ym9hcmQudXBkYXRlTm9kZUxvY2F0aW9uT25NYXAoKSk7XG4gICAgICB9XG4gICAgICBibGl0emJvYXJkLm5ldHdvcmsubW92ZVRvKHtzY2FsZTogMS4wfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWFwQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBpZih0aGlzLm1hcCkge1xuICAgICAgICB0aGlzLm1hcC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFwID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm5ldHdvcmsub24oJ3pvb20nLCAoZSkgPT4ge1xuICAgICAgYmxpdHpib2FyZC51cGRhdGVUb29sdGlwTG9jYXRpb24oKTtcbiAgICB9KTtcblxuICAgIHRoaXMubmV0d29yay5vbigncmVzaXplJywgKGUpID0+IHtcbiAgICAgIGlmKGJsaXR6Ym9hcmQuY29uZmlnLmxheW91dCA9PT0gJ21hcCcpIHtcbiAgICAgICAgLy8gRml4IHNjYWxlIHRvIDEuMCAoZGVsYXkgaXMgbmVlZGVkIHRvIG92ZXJyaWRlIHNjYWxlIHNldCBieSB2aXMtbmV0d29yaykgIFxuICAgICAgICBsZXQgbmV3U2NhbGUgPSBNYXRoLm1pbihCbGl0emJvYXJkLm1heFNjYWxlT25NYXAsIE1hdGgubWF4KGJsaXR6Ym9hcmQubmV0d29yay5nZXRTY2FsZSgpLCBCbGl0emJvYXJkLm1pblNjYWxlT25NYXApKTtcbiAgICAgICAgc2V0VGltZW91dCggKCkgPT4ge1xuICAgICAgICAgIGJsaXR6Ym9hcmQubmV0d29yay5tb3ZlVG8oe3NjYWxlOiBuZXdTY2FsZX0pO1xuICAgICAgICAgIGJsaXR6Ym9hcmQudXBkYXRlTm9kZUxvY2F0aW9uT25NYXAoKTtcbiAgICAgICAgfSwgMTApOyBcbiAgICAgICAgYmxpdHpib2FyZC5tYXAuaW52YWxpZGF0ZVNpemUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcblxuICAgIHRoaXMubmV0d29yay5vbignZHJhZ1N0YXJ0JywgKGUpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVEYXRhU2V0LmdldChlLm5vZGVzWzBdKTtcbiAgICAgIGlmKGUubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLm5vZGVEYXRhU2V0LnVwZGF0ZSh7XG4gICAgICAgICAgaWQ6IGUubm9kZXNbMF0sXG4gICAgICAgICAgZml4ZWQ6IG5vZGUuZml4ZWRCeVRpbWUgPyB7eDogdHJ1ZSwgeTogdHJ1ZSB9IDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG5cbiAgICBmdW5jdGlvbiBzdGF0aXN0aWNzT2ZNYXAoKSB7XG4gICAgICBsZXQgbG5nS2V5ID0gIGJsaXR6Ym9hcmQuY29uZmlnLmxheW91dFNldHRpbmdzLmxuZztcbiAgICAgIGxldCBsYXRLZXkgPSAgYmxpdHpib2FyZC5jb25maWcubGF5b3V0U2V0dGluZ3MubGF0O1xuICAgICAgbGV0IGxuZ1N1bSA9IDAsIGxhdFN1bSA9IDAsIGNvdW50ID0gMCxcbiAgICAgICAgbG5nTWF4ID0gTnVtYmVyLk1JTl9WQUxVRSwgbG5nTWluID0gTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgbGF0TWF4ID0gTnVtYmVyLk1JTl9WQUxVRSwgbGF0TWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIGJsaXR6Ym9hcmQuZ3JhcGgubm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgaWYobm9kZS5wcm9wZXJ0aWVzW2xhdEtleV0gJiYgbm9kZS5wcm9wZXJ0aWVzW2xuZ0tleV0pIHtcbiAgICAgICAgICBsZXQgbG5nID0gcGFyc2VGbG9hdChub2RlLnByb3BlcnRpZXNbbG5nS2V5XVswXSk7XG4gICAgICAgICAgbGV0IGxhdCA9IHBhcnNlRmxvYXQobm9kZS5wcm9wZXJ0aWVzW2xhdEtleV1bMF0pO1xuICAgICAgICAgIGxuZ1N1bSArPSBsbmc7XG4gICAgICAgICAgbGF0U3VtICs9IGxhdDtcbiAgICAgICAgICBsbmdNYXggPSBNYXRoLm1heChsbmcsIGxuZ01heCk7XG4gICAgICAgICAgbG5nTWluID0gTWF0aC5taW4obG5nLCBsbmdNaW4pO1xuICAgICAgICAgIGxhdE1heCA9IE1hdGgubWF4KGxhdCwgbGF0TWF4KTtcbiAgICAgICAgICBsYXRNaW4gPSBNYXRoLm1pbihsYXQsIGxhdE1pbik7XG4gICAgICAgICAgKytjb3VudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZihjb3VudCA9PT0gMClcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNlbnRlcjogW2xhdFN1bSAvIGNvdW50LCBsbmdTdW0gLyBjb3VudF0sXG4gICAgICAgIHNjYWxlOiBNYXRoLm1heCggLU1hdGgubG9nMihNYXRoLm1heChNYXRoLmFicyhsbmdNYXggLSBsbmdNaW4pLCBNYXRoLmFicyhsYXRNYXggLSBsYXRNaW4pKSAvIDEwMDApLCAwKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBcbiAgICB0aGlzLm5ldHdvcmsub24oXCJ6b29tXCIsIGZ1bmN0aW9uKCl7XG4gICAgICBsZXQgcG9zID0gYmxpdHpib2FyZC5uZXR3b3JrLmdldFZpZXdQb3NpdGlvbigpO1xuICAgICAgaWYoYmxpdHpib2FyZC5jb25maWcuem9vbT8ubWluICYmIGJsaXR6Ym9hcmQubmV0d29yay5nZXRTY2FsZSgpIDwgYmxpdHpib2FyZC5jb25maWcuem9vbS5taW4pXG4gICAgICB7XG4gICAgICAgIGJsaXR6Ym9hcmQubmV0d29yay5tb3ZlVG8oe1xuICAgICAgICAgIHBvc2l0aW9uOiBibGl0emJvYXJkLnByZXZab29tUG9zaXRpb24sXG4gICAgICAgICAgc2NhbGU6IGJsaXR6Ym9hcmQuY29uZmlnLnpvb20/Lm1pblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYoYmxpdHpib2FyZC5jb25maWcuem9vbT8ubWF4ICYmIGJsaXR6Ym9hcmQubmV0d29yay5nZXRTY2FsZSgpID4gYmxpdHpib2FyZC5jb25maWcuem9vbS5tYXgpe1xuICAgICAgICBibGl0emJvYXJkLm5ldHdvcmsubW92ZVRvKHtcbiAgICAgICAgICBwb3NpdGlvbjogYmxpdHpib2FyZC5wcmV2Wm9vbVBvc2l0aW9uLFxuICAgICAgICAgIHNjYWxlOiBibGl0emJvYXJkLmNvbmZpZy56b29tLm1heCxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibGl0emJvYXJkLnByZXZab29tUG9zaXRpb24gPSBwb3M7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgaWYodGhpcy5tYXApIHtcbiAgICAgIHRoaXMudXBkYXRlTm9kZUxvY2F0aW9uT25NYXAoKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5uZXR3b3JrLm9uKFwiaG92ZXJOb2RlXCIsIChlKSA9PiB7XG4gICAgICB0aGlzLm5ldHdvcmsuY2FudmFzLmJvZHkuY29udGFpbmVyLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVEYXRhU2V0LmdldChlLm5vZGUpO1xuICAgICAgaWYobm9kZSkge1xuICAgICAgICBpZiAobm9kZS51cmwpIHtcbiAgICAgICAgICB0aGlzLm5ldHdvcmsuY2FudmFzLmJvZHkuY29udGFpbmVyLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICB0aGlzLm5vZGVEYXRhU2V0LnVwZGF0ZSh7XG4gICAgICAgICAgICBpZDogZS5ub2RlLFxuICAgICAgICAgICAgY29sb3I6ICcjODg4OGZmJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWcubm9kZS5vbkhvdmVyKSB7XG4gICAgICAgICAgdGhpcy5jb25maWcubm9kZS5vbkhvdmVyKHRoaXMuZ2V0Tm9kZShlLm5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5lbGVtZW50V2l0aFRvb2x0aXAgPSB7XG4gICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNob3dUb29sdGlwKCk7XG4gICAgICB9IGVsc2UgaWYobm9kZSAmJiBub2RlLmRlZ3JlZSA+IDEgJiYgIXRoaXMuZXhwYW5kZWROb2Rlcy5pbmNsdWRlcyhlLm5vZGUpKSB7XG4gICAgICAgIHRoaXMubmV0d29yay5jYW52YXMuYm9keS5jb250YWluZXIuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5uZXR3b3JrLm9uKFwiaG92ZXJFZGdlXCIsIChlKSA9PiB7XG4gICAgICBjb25zdCBlZGdlID0gdGhpcy5lZGdlRGF0YVNldC5nZXQoZS5lZGdlKTtcbiAgICAgIGlmIChlZGdlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFdpdGhUb29sdGlwID0ge1xuICAgICAgICAgIGVkZ2U6IGVkZ2UsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IGUuZXZlbnQub2Zmc2V0WCxcbiAgICAgICAgICAgIHk6IGUuZXZlbnQub2Zmc2V0WSxcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2hvd1Rvb2x0aXAoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMubmV0d29yay5vbihcInNlbGVjdE5vZGVcIiwgKGUpID0+IHtcbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSBzaG93IGZpeGVkIHRvb2x0aXAgb24gc2VsZWN0aW9uP1xuICAgICAgLy8gaWYoIXRoaXMubmV0d29yay5nZXRTZWxlY3RlZE5vZGVzKCkubGVuZ3RoICYmICF0aGlzLm5ldHdvcmsuZ2V0U2VsZWN0ZWRFZGdlcygpLmxlbmd0aCkge1xuICAgICAgLy8gICBjb25zdCBub2RlID0gdGhpcy5ub2RlRGF0YVNldC5nZXQoZS5ub2Rlc1swXSk7XG4gICAgICAvLyAgIGlmIChub2RlKSB7XG4gICAgICAvLyAgICAgdGhpcy5lbGVtZW50V2l0aFRvb2x0aXAgPSB7XG4gICAgICAvLyAgICAgICBub2RlOiBub2RlXG4gICAgICAvLyAgICAgfTtcbiAgICAgIC8vICAgICB0aGlzLnNob3dUb29sdGlwKCk7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cbiAgICB9KTtcblxuICAgIHRoaXMubmV0d29yay5vbihcInNlbGVjdEVkZ2VcIiwgKGUpID0+IHtcbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSBzaG93IGZpeGVkIHRvb2x0aXAgb24gc2VsZWN0aW9uP1xuICAgICAgLy8gaWYoIXRoaXMubmV0d29yay5nZXRTZWxlY3RlZE5vZGVzKCkubGVuZ3RoICYmICF0aGlzLm5ldHdvcmsuZ2V0U2VsZWN0ZWRFZGdlcygpLmxlbmd0aCkge1xuICAgICAgLy8gICBjb25zdCBlZGdlID0gdGhpcy5lZGdlRGF0YVNldC5nZXQoZS5lZGdlc1swXSk7XG4gICAgICAvLyAgIGlmIChlZGdlKSB7XG4gICAgICAvLyAgICAgdGhpcy5lbGVtZW50V2l0aFRvb2x0aXAgPSB7XG4gICAgICAvLyAgICAgICBlZGdlOiBlZGdlLFxuICAgICAgLy8gICAgICAgcG9zaXRpb246IHtcbiAgICAgIC8vICAgICAgICAgeDogZS54LFxuICAgICAgLy8gICAgICAgICB5OiBlLnksXG4gICAgICAvLyAgICAgICB9XG4gICAgICAvLyAgICAgfTtcbiAgICAgIC8vICAgICB0aGlzLnNob3dUb29sdGlwKCk7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cbiAgICB9KTtcbiAgICBcblxuICAgIGZ1bmN0aW9uIHBsb3RUaW1lcyhzdGFydFRpbWUsIGludGVydmFsLCBpbnRlcnZhbFVuaXQsIHRpbWVGb3JPbmVQaXhlbCwgb2Zmc2V0WCwgb2Zmc2V0WSwgcmlnaHRNb3N0WCwgY29udGV4dCwgc2NhbGUpIHtcbiAgICAgIGxldCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKHN0YXJ0VGltZSk7XG4gICAgICBzd2l0Y2goaW50ZXJ2YWxVbml0KSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoY3VycmVudFRpbWUuZ2V0RnVsbFllYXIoKSAgLSBjdXJyZW50VGltZS5nZXRGdWxsWWVhcigpICUgaW50ZXJ2YWwsIDAsIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgY3VycmVudFRpbWUgPSBuZXcgRGF0ZShjdXJyZW50VGltZS5nZXRGdWxsWWVhcigpLCBjdXJyZW50VGltZS5nZXRNb250aCgpIC0gY3VycmVudFRpbWUuZ2V0TW9udGgoKSAlIGludGVydmFsLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICBjdXJyZW50VGltZSA9IG5ldyBEYXRlKGN1cnJlbnRUaW1lLmdldEZ1bGxZZWFyKCksIGN1cnJlbnRUaW1lLmdldE1vbnRoKCksIGN1cnJlbnRUaW1lLmdldERhdGUoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgd2hpbGUoKytpIDwgMTAwKSB7XG4gICAgICAgIGNvbnN0IG5leHRQb3NpdGlvbiA9IC1vZmZzZXRYICsgKGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lKSAvIHRpbWVGb3JPbmVQaXhlbDtcbiAgICAgICAgaWYobmV4dFBvc2l0aW9uID4gcmlnaHRNb3N0WCkgYnJlYWs7XG4gICAgICAgIGlmKGludGVydmFsVW5pdCA9PT0gJ3llYXInKVxuICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQoY3VycmVudFRpbWUuZ2V0RnVsbFllYXIoKSwgbmV4dFBvc2l0aW9uLCAtb2Zmc2V0WSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KGN1cnJlbnRUaW1lLnRvTG9jYWxlRGF0ZVN0cmluZygpLCBuZXh0UG9zaXRpb24sIC1vZmZzZXRZKTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8obmV4dFBvc2l0aW9uLCAtb2Zmc2V0WSk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKG5leHRQb3NpdGlvbiwgLW9mZnNldFkgKyAyNSAvIHNjYWxlKTtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgc3dpdGNoKGludGVydmFsVW5pdCkge1xuICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgY3VycmVudFRpbWUuc2V0RnVsbFllYXIoY3VycmVudFRpbWUuZ2V0RnVsbFllYXIoKSArIGludGVydmFsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lLnNldE1vbnRoKGN1cnJlbnRUaW1lLmdldE1vbnRoKCkgKyBpbnRlcnZhbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY3VycmVudFRpbWUuc2V0RGF0ZShjdXJyZW50VGltZS5nZXREYXRlKCkgKyBpbnRlcnZhbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRoaXMubmV0d29yay5vbihcImFmdGVyRHJhd2luZ1wiLCAoY3R4KSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBMb2NhdGlvbigpO1xuICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMuZ3JhcGgubm9kZXMpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMubm9kZURhdGFTZXQuZ2V0KG5vZGUuaWQpO1xuICAgICAgICBpZihub2RlICYmIG5vZGUuc2hhcGUgIT09ICdpbWFnZScgJiYgKG5vZGUuY3VzdG9tSWNvbiB8fCB0aGlzLmNvbmZpZy5ub2RlLmRlZmF1bHRJY29uKSkge1xuICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHRoaXMubmV0d29yay5nZXRQb3NpdGlvbihub2RlLmlkKTtcbiAgICAgICAgICBsZXQgcGdOb2RlID0gdGhpcy5ub2RlTWFwW25vZGUuaWRdO1xuICAgICAgICAgIGlmKG5vZGUuY3VzdG9tSWNvbikge1xuICAgICAgICAgICAgaWYobm9kZS5jdXN0b21JY29uLm5hbWUgJiYgQmxpdHpib2FyZC5sb2FkZWRJY29uc1tub2RlLmN1c3RvbUljb24ubmFtZV0pIHsgLy8gSWNvbml5XG4gICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoQmxpdHpib2FyZC5sb2FkZWRJY29uc1tub2RlLmN1c3RvbUljb24ubmFtZV0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb24ueCAtIG5vZGUuc2l6ZSAqIEJsaXR6Ym9hcmQuaWNvblNpemVDb2VmIC8gMiwgcG9zaXRpb24ueSAtIG5vZGUuc2l6ZSAqIEJsaXR6Ym9hcmQuaWNvblNpemVDb2VmIC8gMixcbiAgICAgICAgICAgICAgICBub2RlLnNpemUgKiBCbGl0emJvYXJkLmljb25TaXplQ29lZiwgXG4gICAgICAgICAgICAgICAgbm9kZS5zaXplICogQmxpdHpib2FyZC5pY29uU2l6ZUNvZWYpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gSW9uaWNvbnNcbiAgICAgICAgICAgICAgY3R4LmZvbnQgPSBgJHtub2RlLmN1c3RvbUljb24uc2l6ZX1weCBJb25pY29uc2A7XG4gICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KG5vZGUuY3VzdG9tSWNvbi5jb2RlLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoIXBnTm9kZSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGxhYmVsIG9mIHBnTm9kZS5sYWJlbHMpIHtcbiAgICAgICAgICAgICAgbGV0IGxvd2VyTGFiZWwgPSBsYWJlbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZiAoQmxpdHpib2FyZC5sb2FkZWRJY29uc1tsb3dlckxhYmVsXSkge1xuICAgICAgICAgICAgICAgIGlmKEJsaXR6Ym9hcmQubG9hZGVkSWNvbnNbbG93ZXJMYWJlbF0gIT0gJ3JldHJpZXZpbmcuLi4nKVxuICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShCbGl0emJvYXJkLmxvYWRlZEljb25zW2xvd2VyTGFiZWxdLCBwb3NpdGlvbi54IC0gbm9kZS5zaXplICogQmxpdHpib2FyZC5pY29uU2l6ZUNvZWYgLyAyLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi55IC0gbm9kZS5zaXplICogQmxpdHpib2FyZC5pY29uU2l6ZUNvZWYgLyAyLFxuICAgICAgICAgICAgICAgICAgICBub2RlLnNpemUgKiBCbGl0emJvYXJkLmljb25TaXplQ29lZixcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zaXplICogQmxpdHpib2FyZC5pY29uU2l6ZUNvZWYpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgaWYodGhpcy5jb25maWcubGF5b3V0ID09PSAndGltZWxpbmUnKXtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMubmV0d29yay5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5uZXR3b3JrLmNhbnZhcy5ib2R5LnZpZXc7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSAodmlldy50cmFuc2xhdGlvbi55IC0gMjApIC8gdmlldy5zY2FsZTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IHZpZXcudHJhbnNsYXRpb24ueCAvIHZpZXcuc2NhbGU7XG4gICAgICAgIGNvbnN0IHRpbWVGb3JPbmVQaXhlbCA9ICh0aGlzLm1heFRpbWUgLSB0aGlzLm1pblRpbWUpIC8gdGhpcy50aW1lU2NhbGU7XG4gICAgICAgIGNvbnN0IHRpbWVPbkxlZnRFZGdlID0gbmV3IERhdGUoKCh0aGlzLm1heFRpbWUuZ2V0VGltZSgpICsgdGhpcy5taW5UaW1lLmdldFRpbWUoKSkgLyAyKSAtIHRpbWVGb3JPbmVQaXhlbCAqIG9mZnNldFgpO1xuICAgICAgICBjb25zdCBjbGllbnRXaWR0aCA9IHRoaXMubmV0d29yay5jYW52YXMuYm9keS5jb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgICAgIGNvbnN0IHJpZ2h0TW9zdCA9IC1vZmZzZXRYICsgY2xpZW50V2lkdGggLyB2aWV3LnNjYWxlO1xuICAgICAgICBjb25zdCBvbmVNb250aCA9IDMxICogMjQgKiA2MCAqIDYwICogMTAwMDtcbiAgICAgICAgY29uc3Qgb25lRGF5ID0gMjQgKiA2MCAqIDYwICogMTAwMDtcbiAgICAgICAgY29uc3QgdHdvTW9udGggPSBvbmVNb250aCAqIDI7XG4gICAgICAgIGNvbnN0IGZvdXJNb250aCA9IHR3b01vbnRoICogMjtcbiAgICAgICAgY29uc3Qgb25lWWVhciA9IDM2NSAqIG9uZURheTtcbiAgICAgICAgY29uc3QgbWluRGlzdGFuY2UgPSAyMDA7XG4gICAgICAgIGNvbnRleHQuZm9udCA9ICgyMCAvIHZpZXcuc2NhbGUpLnRvU3RyaW5nKCkgKyBcInB4IEFyaWFsXCI7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJibHVlXCI7XG4gICAgICAgIGNvbnN0IG1pbmltdW1JbnRlcnZhbCA9IHRpbWVGb3JPbmVQaXhlbCAqIG1pbkRpc3RhbmNlIC8gdmlldy5zY2FsZTtcbiAgICAgICAgaWYobWluaW11bUludGVydmFsID4gb25lWWVhciApIHtcbiAgICAgICAgICBwbG90VGltZXModGltZU9uTGVmdEVkZ2UsIG1pbmltdW1JbnRlcnZhbCAvIG9uZVllYXIsICd5ZWFyJywgdGltZUZvck9uZVBpeGVsLCBvZmZzZXRYLCBvZmZzZXRZLCByaWdodE1vc3QsIGNvbnRleHQsIHZpZXcuc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYobWluaW11bUludGVydmFsID4gZm91ck1vbnRoICkge1xuICAgICAgICAgIHBsb3RUaW1lcyh0aW1lT25MZWZ0RWRnZSwgNCwgJ21vbnRoJywgdGltZUZvck9uZVBpeGVsLCBvZmZzZXRYLCBvZmZzZXRZLCByaWdodE1vc3QsIGNvbnRleHQsIHZpZXcuc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYobWluaW11bUludGVydmFsID4gdHdvTW9udGgpIHtcbiAgICAgICAgICBwbG90VGltZXModGltZU9uTGVmdEVkZ2UsIDIsICdtb250aCcsIHRpbWVGb3JPbmVQaXhlbCwgb2Zmc2V0WCwgb2Zmc2V0WSwgcmlnaHRNb3N0LCBjb250ZXh0LCB2aWV3LnNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKG1pbmltdW1JbnRlcnZhbCA+IG9uZU1vbnRoKSB7XG4gICAgICAgICAgcGxvdFRpbWVzKHRpbWVPbkxlZnRFZGdlLCAxLCAnbW9udGgnLCB0aW1lRm9yT25lUGl4ZWwsIG9mZnNldFgsIG9mZnNldFksIHJpZ2h0TW9zdCwgY29udGV4dCwgdmlldy5zY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZihtaW5pbXVtSW50ZXJ2YWwgPiBvbmVEYXkgKiAxNikge1xuICAgICAgICAgIHBsb3RUaW1lcyh0aW1lT25MZWZ0RWRnZSwgMTYsICdkYXknLCB0aW1lRm9yT25lUGl4ZWwsIG9mZnNldFgsIG9mZnNldFksIHJpZ2h0TW9zdCwgY29udGV4dCwgdmlldy5zY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZihtaW5pbXVtSW50ZXJ2YWwgPiBvbmVEYXkgKiA4KSB7XG4gICAgICAgICAgcGxvdFRpbWVzKHRpbWVPbkxlZnRFZGdlLCA4LCAnZGF5JywgdGltZUZvck9uZVBpeGVsLCBvZmZzZXRYLCBvZmZzZXRZLCByaWdodE1vc3QsIGNvbnRleHQsIHZpZXcuc2NhbGUpO1xuICAgICAgICB9IGVsc2UgaWYobWluaW11bUludGVydmFsID4gb25lRGF5ICogNCkge1xuICAgICAgICAgIHBsb3RUaW1lcyh0aW1lT25MZWZ0RWRnZSwgNCwgJ2RheScsIHRpbWVGb3JPbmVQaXhlbCwgb2Zmc2V0WCwgb2Zmc2V0WSwgcmlnaHRNb3N0LCBjb250ZXh0LCB2aWV3LnNjYWxlKTtcbiAgICAgICAgfSBlbHNlIGlmKG1pbmltdW1JbnRlcnZhbCA+IG9uZURheSAqIDIpIHtcbiAgICAgICAgICBwbG90VGltZXModGltZU9uTGVmdEVkZ2UsIDIsICdkYXknLCB0aW1lRm9yT25lUGl4ZWwsIG9mZnNldFgsIG9mZnNldFksIHJpZ2h0TW9zdCwgY29udGV4dCwgdmlldy5zY2FsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGxvdFRpbWVzKHRpbWVPbkxlZnRFZGdlLCAxLCAnZGF5JywgdGltZUZvck9uZVBpeGVsLCBvZmZzZXRYLCBvZmZzZXRZLCByaWdodE1vc3QsIGNvbnRleHQsIHZpZXcuc2NhbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5uZXR3b3JrLm9uKFwiYmx1ck5vZGVcIiwgKHBhcmFtcykgPT4ge1xuICAgICAgdGhpcy5uZXR3b3JrLmNhbnZhcy5ib2R5LmNvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICBsZXQgbm9kZSA9IHRoaXMubm9kZURhdGFTZXQuZ2V0KHBhcmFtcy5ub2RlKTtcbiAgICAgIGlmKG5vZGUgJiYgbm9kZS51cmwpIHtcbiAgICAgICAgdGhpcy5ub2RlRGF0YVNldC51cGRhdGUoe1xuICAgICAgICAgIGlkOiBwYXJhbXMubm9kZSxcbiAgICAgICAgICBjb2xvcjogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmhpZGVUb29sdGlwKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm5ldHdvcmsub24oXCJibHVyRWRnZVwiLCAocGFyYW1zKSA9PiB7XG4gICAgICB0aGlzLmhpZGVUb29sdGlwKCk7XG4gICAgfSk7XG5cbiAgICBpZiAoIUJsaXR6Ym9hcmQuZm9udExvYWRlZCAmJiBkb2N1bWVudC5mb250cykge1xuICAgICAgQmxpdHpib2FyZC5mb250TG9hZGVkID0gdHJ1ZTtcbiAgICAgIGxldCBibGl0emJvYXJkID0gdGhpcztcbiAgICAgIC8vIERlY2VudCBicm93c2VyczogTWFrZSBzdXJlIHRoZSBmb250cyBhcmUgbG9hZGVkLlxuICAgICAgZG9jdW1lbnQuZm9udHMubG9hZCgnbm9ybWFsIG5vcm1hbCA0MDAgMjRweC8xIFwiRm9udEF3ZXNvbWVcIicpXG4gICAgICAgIC5jYXRjaChcbiAgICAgICAgICBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSwgXCJGYWlsZWQgdG8gbG9hZCBGb250IEF3ZXNvbWUgNC5cIilcbiAgICAgICAgKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYmxpdHpib2FyZC5uZXR3b3JrLnJlZHJhdygpO1xuICAgICAgfSlcbiAgICAgICAgLmNhdGNoKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IuYmluZChcbiAgICAgICAgICAgIGNvbnNvbGUsXG4gICAgICAgICAgICBcIkZhaWxlZCB0byByZW5kZXIgdGhlIG5ldHdvcmsgd2l0aCBGb250IEF3ZXNvbWUgNC5cIlxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGlja0hhbmRsZXIoZSkge1xuICAgICAgYmxpdHpib2FyZC5kb3VibGVDbGlja1RpbWVyID0gbnVsbDtcbiAgICAgIGlmIChlLm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGJsaXR6Ym9hcmQuY29uZmlnLm5vZGUub25DbGljaykge1xuICAgICAgICAgIGJsaXR6Ym9hcmQuY29uZmlnLm5vZGUub25DbGljayhibGl0emJvYXJkLmdldE5vZGUoZS5ub2Rlc1swXSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGUuZWRnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoYmxpdHpib2FyZC5jb25maWcuZWRnZS5vbkNsaWNrKSB7XG4gICAgICAgICAgYmxpdHpib2FyZC5jb25maWcuZWRnZS5vbkNsaWNrKGJsaXR6Ym9hcmQuZ2V0RWRnZShlLmVkZ2VzWzBdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm5ldHdvcmsub24oXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgaWYoIXRoaXMuZG91YmxlQ2xpY2tUaW1lcikge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZG91YmxlQ2xpY2tXYWl0IDw9IDApIHtcbiAgICAgICAgICBjbGlja0hhbmRsZXIoZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kb3VibGVDbGlja1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiBjbGlja0hhbmRsZXIoZSksIHRoaXMuY29uZmlnLmRvdWJsZUNsaWNrV2FpdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIFxuICAgIHRoaXMubmV0d29yay5vbihcImRvdWJsZUNsaWNrXCIsIChlKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5kb3VibGVDbGlja1RpbWVyKTtcbiAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lciA9IG51bGw7XG4gICAgICBpZihlLm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYodGhpcy5jb25maWcubm9kZS5vbkRvdWJsZUNsaWNrKSB7XG4gICAgICAgICAgdGhpcy5jb25maWcubm9kZS5vbkRvdWJsZUNsaWNrKHRoaXMuZ2V0Tm9kZShlLm5vZGVzWzBdKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihlLmVkZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYodGhpcy5jb25maWcuZWRnZS5vbkRvdWJsZUNsaWNrKSB7XG4gICAgICAgICAgdGhpcy5jb25maWcuZWRnZS5vbkRvdWJsZUNsaWNrKHRoaXMuZ2V0RWRnZShlLmVkZ2VzWzBdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvcihsZXQgY2FsbGJhY2sgb2YgdGhpcy5vblVwZGF0ZWQpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cblxuICBzY3JvbGxOb2RlSW50b1ZpZXcobm9kZSwgc2VsZWN0ID0gdHJ1ZSkge1xuICAgIGlmKHR5cGVvZihub2RlKSA9PT0gJ3N0cmluZycpXG4gICAgICBub2RlID0gdGhpcy5ub2RlTWFwW25vZGVdO1xuICAgIGlmKCFub2RlKVxuICAgICAgcmV0dXJuO1xuXG4gICAgaWYodGhpcy5jb25maWcubGF5b3V0ID09PSAnbWFwJykge1xuICAgICAgdGhpcy5zY3JvbGxNYXBUb05vZGUodGhpcy5ub2RlTWFwW25vZGUuaWRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY3JvbGxOZXR3b3JrVG9Qb3NpdGlvbih0aGlzLm5ldHdvcmsuZ2V0UG9zaXRpb24obm9kZS5pZCkpO1xuICAgIH1cbiAgICBpZihzZWxlY3QpXG4gICAgICB0aGlzLm5ldHdvcmsuc2VsZWN0Tm9kZXMoW25vZGUuaWRdKTtcblxuICAgIGZvcihsZXQgY2FsbGJhY2sgb2YgdGhpcy5vbk5vZGVGb2N1c2VkKSB7XG4gICAgICAvLyBUT0RPOiBUaGUgYXJndW1lbnQgc2hvdWxkIGJlIHByb3h5IGluc3RlYWQgb2YgcGxhaW4gb2JqZWN0c1xuICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgfVxuICB9XG4gIFxuICBzY3JvbGxOZXR3b3JrVG9Qb3NpdGlvbihwb3NpdGlvbikge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnNjcm9sbEFuaW1hdGlvblRpbWVySWQpO1xuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uVGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgYW5pbWF0aW9uT3B0aW9uID0ge1xuICAgICAgICBzY2FsZTogMS4wLFxuICAgICAgICBhbmltYXRpb246XG4gICAgICAgICAge1xuICAgICAgICAgICAgZHVyYXRpb246IDUwMCxcbiAgICAgICAgICAgIGVhc2luZ0Z1bnRjaW9uOiBcImVhc2VJbk91dFF1YWRcIlxuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLm5ldHdvcmsubW92ZVRvKHsgLi4ue3Bvc2l0aW9uOiBwb3NpdGlvbn0sIC4uLmFuaW1hdGlvbk9wdGlvbiB9KTtcbiAgICB9LCAyMDApOyAvLyBTZXQgZGVsYXkgdG8gYXZvaWQgY2FsbGluZyBtb3ZlVG8oKSB0b28gbXVjaCAoc2VlbSB0byBjYXVzZSBzb21lIGJ1ZyBvbiBhbmltYXRpb24pXG4gIH1cbiAgXG4gIHVwZGF0ZU5vZGVMb2NhdGlvbk9uTWFwKCkge1xuICAgIGxldCBub2RlUG9zaXRpb25zID0gW107XG4gICAgbGV0IGxuZ0tleSA9ICB0aGlzLmNvbmZpZy5sYXlvdXRTZXR0aW5ncy5sbmc7XG4gICAgbGV0IGxhdEtleSA9ICB0aGlzLmNvbmZpZy5sYXlvdXRTZXR0aW5ncy5sYXQ7XG4gICAgdGhpcy5ncmFwaC5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgaWYobm9kZS5wcm9wZXJ0aWVzW2xhdEtleV0gJiYgbm9kZS5wcm9wZXJ0aWVzW2xuZ0tleV0pIHtcbiAgICAgICAgbGV0IHBvaW50ID0gdGhpcy5tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChbbm9kZS5wcm9wZXJ0aWVzW2xhdEtleV1bMF0sIG5vZGUucHJvcGVydGllc1tsbmdLZXldWzBdXSk7XG4gICAgICAgIHBvaW50ID0gdGhpcy5uZXR3b3JrLkRPTXRvQ2FudmFzKHBvaW50KTtcbiAgICAgICAgbm9kZVBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICB4OiBwb2ludC54LCB5OiBwb2ludC55LCBmaXhlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLm5vZGVEYXRhU2V0LnVwZGF0ZShub2RlUG9zaXRpb25zKTtcbiAgfVxuXG5cbiAgdXBkYXRlTm9kZUxvY2F0aW9uT25UaW1lTGluZSgpIHtcbiAgICBsZXQgbm9kZVBvc2l0aW9ucyA9IFtdO1xuICAgIHRoaXMuZ3JhcGgubm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGxldCB4LCB5LCBmaXhlZCwgd2lkdGg7XG4gICAgICAoe3gsIHksIGZpeGVkLCB3aWR0aH0gPSB0aGlzLmNhbGNOb2RlUG9zaXRpb24obm9kZSkpO1xuICAgICAgbm9kZVBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgIHgsIHlcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMubm9kZURhdGFTZXQudXBkYXRlKG5vZGVQb3NpdGlvbnMpO1xuICB9XG4gIFxuICBzY3JvbGxNYXBUb05vZGUobm9kZSkge1xuICAgIGxldCBsbmdLZXkgPSB0aGlzLmNvbmZpZy5sYXlvdXRTZXR0aW5ncy5sbmc7XG4gICAgbGV0IGxhdEtleSA9IHRoaXMuY29uZmlnLmxheW91dFNldHRpbmdzLmxhdDtcbiAgICB0aGlzLm1hcC5wYW5Ubyhbbm9kZS5wcm9wZXJ0aWVzW2xhdEtleV1bMF0gLG5vZGUucHJvcGVydGllc1tsbmdLZXldWzBdXSk7XG4gIH1cbiAgXG4gIHNjcm9sbEVkZ2VJbnRvVmlldyhlZGdlLCBzZWxlY3QgPSB0cnVlKSB7XG4gICAgaWYodHlwZW9mKGVkZ2UpID09PSAnc3RyaW5nJykge1xuICAgICAgZWRnZSA9IHRoaXMuZWRnZU1hcFtlZGdlXTtcbiAgICB9XG5cbiAgICBpZih0aGlzLmNvbmZpZy5sYXlvdXQgPT09ICdtYXAnKSB7XG4gICAgICB0aGlzLnNjcm9sbE1hcFRvTm9kZSh0aGlzLm5vZGVNYXBbZWRnZS5mcm9tXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZyb20gPSB0aGlzLm5ldHdvcmsuZ2V0UG9zaXRpb24oZWRnZS5mcm9tKTtcbiAgICAgIGNvbnN0IHRvID0gdGhpcy5uZXR3b3JrLmdldFBvc2l0aW9uKGVkZ2UudG8pO1xuICAgICAgdGhpcy5zY3JvbGxOZXR3b3JrVG9Qb3NpdGlvbih7IHg6IChmcm9tLnggKyB0by54KSAvIDIsIHk6IChmcm9tLnkgKyB0by55KSAvMiB9KTtcbiAgICB9XG4gICAgaWYoc2VsZWN0KSB7XG4gICAgICB0aGlzLm5ldHdvcmsuc2VsZWN0RWRnZXMoW2VkZ2UuaWRdKTtcbiAgICB9XG5cbiAgICBmb3IobGV0IGNhbGxiYWNrIG9mIHRoaXMub25FZGdlRm9jdXNlZCkge1xuICAgICAgLy8gVE9ETzogVGhlIGFyZ3VtZW50IHNob3VsZCBiZSBwcm94eSBpbnN0ZWFkIG9mIHBsYWluIG9iamVjdHNcbiAgICAgIGNhbGxiYWNrKGVkZ2UpO1xuICAgIH1cbiAgfVxuICBcbiAgc2hvd0xvYWRlcih0ZXh0ID0gXCJOb3cgbG9hZGluZy4uLlwiKSB7XG4gICAgdGhpcy5zY3JlZW4uc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICB0aGlzLnNjcmVlblRleHQuaW5uZXJUZXh0ID0gdGV4dDtcbiAgICB0aGlzLnNjcmVlblRleHQuc3R5bGUuZGlzcGxheSA9IHRleHQgPyAnYmxvY2snIDogJ25vbmUnO1xuICB9XG4gIFxuICBoaWRlTG9hZGVyKCkge1xuICAgIHRoaXMuc2NyZWVuLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cblxuICB0b05vZGVQYWlyU3RyaW5nKHBnRWRnZSkge1xuICAgIHJldHVybiBgJHtwZ0VkZ2UuZnJvbX0ke0JsaXR6Ym9hcmQuZWRnZURlbGltaXRlcn0ke3BnRWRnZS50b31gO1xuICB9XG59XG5cblxuXG5mdW5jdGlvbiBhcnJheUVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGEpICYmXG4gICAgQXJyYXkuaXNBcnJheShiKSAmJlxuICAgIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJlxuICAgIGEuZXZlcnkoKHZhbCwgaW5kZXgpID0+IHZhbCA9PT0gYltpbmRleF0pO1xufVxuXG5mdW5jdGlvbiBub2RlRXF1YWxzKG5vZGUxLCBub2RlMikge1xuICBpZihub2RlMS5pZCAhPSBub2RlMi5pZCB8fCAhYXJyYXlFcXVhbHMobm9kZTEubGFiZWxzLCBub2RlMi5sYWJlbHMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBub2RlMUtleXMgPSBPYmplY3Qua2V5cyhub2RlMS5wcm9wZXJ0aWVzKTtcbiAgbGV0IG5vZGUyS2V5cyA9IE9iamVjdC5rZXlzKG5vZGUyLnByb3BlcnRpZXMpO1xuICBpZihub2RlMUtleXMubGVuZ3RoICE9IG5vZGUyS2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yKGxldCBrZXkgb2Ygbm9kZTFLZXlzKSB7XG4gICAgaWYoIWFycmF5RXF1YWxzKG5vZGUxLnByb3BlcnRpZXNba2V5XSwgbm9kZTIucHJvcGVydGllc1trZXldKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG5jbGFzcyBEdXBsaWNhdGVOb2RlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG5vZGVzKSB7XG4gICAgc3VwZXIoYER1cGxpY2F0ZSBub2RlOiAke25vZGVzLm1hcChuID0+IG4uaWQpLmpvaW4oJywgJyl9YCk7XG4gICAgdGhpcy5uYW1lID0gXCJOb2RlRHVwbGljYXRpb25FcnJvclwiO1xuICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5EdXBsaWNhdGVOb2RlRXJyb3IgPSBEdXBsaWNhdGVOb2RlRXJyb3I7XG5cblxuZnVuY3Rpb24gZGVlcE1lcmdlKHRhcmdldCwgc291cmNlKSB7XG4gIGNvbnN0IGlzT2JqZWN0ID0gb2JqID0+IG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmopO1xuICBsZXQgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcbiAgaWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGZvciAoY29uc3QgW3NvdXJjZUtleSwgc291cmNlVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcbiAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGFyZ2V0W3NvdXJjZUtleV07XG4gICAgICBpZiAoaXNPYmplY3Qoc291cmNlVmFsdWUpICYmIHRhcmdldC5oYXNPd25Qcm9wZXJ0eShzb3VyY2VLZXkpKSB7XG4gICAgICAgIHJlc3VsdFtzb3VyY2VLZXldID0gZGVlcE1lcmdlKHRhcmdldFZhbHVlLCBzb3VyY2VWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHtbc291cmNlS2V5XTogc291cmNlVmFsdWV9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmV0cmlldmVIdHRwVXJsKG5vZGUpIHtcbiAgbGV0IGNhbmRpZGF0ZXMgPSBbXTtcbiAgZm9yKGxldCBlbnRyeSBvZiBPYmplY3QuZW50cmllcyhub2RlLnByb3BlcnRpZXMpKSB7XG4gICAgZm9yKGxldCBwcm9wIG9mIGVudHJ5WzFdKSB7XG4gICAgICBpZih0eXBlb2YocHJvcCkgPT09ICdzdHJpbmcnICYmIChwcm9wLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSB8fCBwcm9wLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpKSkge1xuICAgICAgICBpZihlbnRyeVswXS50b0xvd2VyQ2FzZSgpID09ICd1cmwnKVxuICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goW2VudHJ5WzBdLCBwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzWzBdO1xufVxuXG5cblxuXG5mdW5jdGlvbiB3cmFwVGV4dChzdHIsIGFzSHRtbCkge1xuICBpZighc3RyKVxuICAgIHJldHVybiBzdHI7XG4gIGlmKEFycmF5LmlzQXJyYXkoc3RyKSlcbiAgICBzdHIgPSBzdHJbMF07XG4gIGNvbnN0IG1heFdpZHRoID0gNDA7XG4gIGxldCBuZXdMaW5lU3RyID0gYXNIdG1sID8gXCI8YnI+XCIgOiBcIlxcblwiLCByZXMgPSAnJztcbiAgd2hpbGUgKHN0ci5sZW5ndGggPiBtYXhXaWR0aCkge1xuICAgIHJlcyArPSBzdHIuc2xpY2UoMCwgbWF4V2lkdGgpICsgbmV3TGluZVN0cjtcbiAgICBzdHIgPSBzdHIuc2xpY2UobWF4V2lkdGgpO1xuICB9XG4gIHJldHVybiByZXMgKyBzdHI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxhYmVsVGV4dChlbGVtLCBwcm9wcyA9IG51bGwpIHtcbiAgaWYgKHByb3BzICE9IG51bGwpIHtcbiAgICAvLyBVc2Ugd2hpdGVzcGFjZSBpbnN0ZWFkIG9mIGVtcHR5IHN0cmluZyBpZiBubyBwcm9wcyBhcmUgc3BlY2lmaWVkIGJlY2F1c2UgVmlzLmpzIGNhbm5vdCB1cGRhdGUgbGFiZWwgd2l0aCBlbXB0eSBzdHJpbmcpXG4gICAgcmV0dXJuIHByb3BzLmxlbmd0aCA/IHByb3BzLm1hcCgocHJvcCkgPT4gcHJvcCA9PT0gJ2lkJyA/IGVsZW0uaWQgOiAocHJvcCA9PT0gJ2xhYmVsJyA/IGVsZW0ubGFiZWxzIDogd3JhcFRleHQoZWxlbS5wcm9wZXJ0aWVzW3Byb3BdKSkpLmZpbHRlcigodmFsKSA9PiB2YWwpLmpvaW4oJ1xcbicpIDogJyAnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb0h5cGVyTGlua0lmVVJMKHRleHQpIHtcbiAgaWYoIXRleHQpXG4gICAgcmV0dXJuIHRleHQ7XG4gIGlmKEFycmF5LmlzQXJyYXkodGV4dCkpXG4gICAgdGV4dCA9IHRleHRbMF07XG4gIGlmKHRleHQuc3RhcnRzV2l0aCgnaHR0cDovLycpIHx8IHRleHQuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSApIHtcbiAgICByZXR1cm4gYDxhIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XCIke3RleHR9XCI+JHt3cmFwVGV4dCh0ZXh0KX08L2E+YDtcbiAgfVxuICByZXR1cm4gd3JhcFRleHQodGV4dCk7XG59XG5cbi8vIENyZWF0ZSByYW5kb20gY29sb3JzLCB3aXRoIHN0ciBhcyBzZWVkLCBhbmQgd2l0aCBmaXhlZCBzYXR1cmF0aW9uIGFuZCBsaWdodG5lc3NcbmZ1bmN0aW9uIGdldFJhbmRvbUNvbG9yKHN0ciwgc2F0dXJhdGlvbiwgYnJpZ2h0bmVzcykge1xuICBsZXQgaGFzaCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaGFzaCA9IHN0ci5jaGFyQ29kZUF0KGkpICsgKChoYXNoIDw8IDUpIC0gaGFzaCk7XG4gICAgaGFzaCA9IGhhc2ggJiBoYXNoO1xuICB9XG4gIGxldCBodWUgPSBoYXNoICUgMzYwO1xuICByZXR1cm4gJ2hzbCgnICsgaHVlICsgYCwgJHtzYXR1cmF0aW9ufSwgJHticmlnaHRuZXNzfSlgO1xufVxuXG5mdW5jdGlvbiBpc0RhdGVTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBpc05hTihzdHIpICYmICFpc05hTihEYXRlLnBhcnNlKHN0cikpXG59XG5cbmZ1bmN0aW9uIGh0bWxUaXRsZShodG1sKSB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICByZXR1cm4gY29udGFpbmVyO1xufVxuIiwiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogR2VuZXJhdGVkIGJ5IFBFRy5qcyAwLjEwLjAuXG4gKlxuICogaHR0cDovL3BlZ2pzLm9yZy9cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gcGVnJHN1YmNsYXNzKGNoaWxkLCBwYXJlbnQpIHtcbiAgZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9XG4gIGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTtcbn1cblxuZnVuY3Rpb24gcGVnJFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgbG9jYXRpb24pIHtcbiAgdGhpcy5tZXNzYWdlICA9IG1lc3NhZ2U7XG4gIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgdGhpcy5mb3VuZCAgICA9IGZvdW5kO1xuICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gIHRoaXMubmFtZSAgICAgPSBcIlN5bnRheEVycm9yXCI7XG5cbiAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgcGVnJFN5bnRheEVycm9yKTtcbiAgfVxufVxuXG5wZWckc3ViY2xhc3MocGVnJFN5bnRheEVycm9yLCBFcnJvcik7XG5cbnBlZyRTeW50YXhFcnJvci5idWlsZE1lc3NhZ2UgPSBmdW5jdGlvbihleHBlY3RlZCwgZm91bmQpIHtcbiAgdmFyIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOUyA9IHtcbiAgICAgICAgbGl0ZXJhbDogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gXCJcXFwiXCIgKyBsaXRlcmFsRXNjYXBlKGV4cGVjdGF0aW9uLnRleHQpICsgXCJcXFwiXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJjbGFzc1wiOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xuICAgICAgICAgIHZhciBlc2NhcGVkUGFydHMgPSBcIlwiLFxuICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGF0aW9uLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlc2NhcGVkUGFydHMgKz0gZXhwZWN0YXRpb24ucGFydHNbaV0gaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICA/IGNsYXNzRXNjYXBlKGV4cGVjdGF0aW9uLnBhcnRzW2ldWzBdKSArIFwiLVwiICsgY2xhc3NFc2NhcGUoZXhwZWN0YXRpb24ucGFydHNbaV1bMV0pXG4gICAgICAgICAgICAgIDogY2xhc3NFc2NhcGUoZXhwZWN0YXRpb24ucGFydHNbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBcIltcIiArIChleHBlY3RhdGlvbi5pbnZlcnRlZCA/IFwiXlwiIDogXCJcIikgKyBlc2NhcGVkUGFydHMgKyBcIl1cIjtcbiAgICAgICAgfSxcblxuICAgICAgICBhbnk6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYW55IGNoYXJhY3RlclwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuZDogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gXCJlbmQgb2YgaW5wdXRcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBvdGhlcjogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gZXhwZWN0YXRpb24uZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgZnVuY3Rpb24gaGV4KGNoKSB7XG4gICAgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXRlcmFsRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgIC5yZXBsYWNlKC9cIi9nLCAgJ1xcXFxcIicpXG4gICAgICAucmVwbGFjZSgvXFwwL2csICdcXFxcMCcpXG4gICAgICAucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpXG4gICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpXG4gICAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpXG4gICAgICAucmVwbGFjZSgvW1xceDAwLVxceDBGXS9nLCAgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDdGLVxceDlGXS9nLCBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4JyAgKyBoZXgoY2gpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgIC5yZXBsYWNlKC9cXF0vZywgJ1xcXFxdJylcbiAgICAgIC5yZXBsYWNlKC9cXF4vZywgJ1xcXFxeJylcbiAgICAgIC5yZXBsYWNlKC8tL2csICAnXFxcXC0nKVxuICAgICAgLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKVxuICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKVxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKVxuICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKVxuICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwRl0vZywgICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceDAnICsgaGV4KGNoKTsgfSlcbiAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg3Ri1cXHg5Rl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceCcgICsgaGV4KGNoKTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgcmV0dXJuIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOU1tleHBlY3RhdGlvbi50eXBlXShleHBlY3RhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGVkKGV4cGVjdGVkKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9ucyA9IG5ldyBBcnJheShleHBlY3RlZC5sZW5ndGgpLFxuICAgICAgICBpLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdGlvbnNbaV0gPSBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGVkW2ldKTtcbiAgICB9XG5cbiAgICBkZXNjcmlwdGlvbnMuc29ydCgpO1xuXG4gICAgaWYgKGRlc2NyaXB0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGkgPSAxLCBqID0gMTsgaSA8IGRlc2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGVzY3JpcHRpb25zW2kgLSAxXSAhPT0gZGVzY3JpcHRpb25zW2ldKSB7XG4gICAgICAgICAgZGVzY3JpcHRpb25zW2pdID0gZGVzY3JpcHRpb25zW2ldO1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVzY3JpcHRpb25zLmxlbmd0aCA9IGo7XG4gICAgfVxuXG4gICAgc3dpdGNoIChkZXNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF07XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uc1swXSArIFwiIG9yIFwiICsgZGVzY3JpcHRpb25zWzFdO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIilcbiAgICAgICAgICArIFwiLCBvciBcIlxuICAgICAgICAgICsgZGVzY3JpcHRpb25zW2Rlc2NyaXB0aW9ucy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUZvdW5kKGZvdW5kKSB7XG4gICAgcmV0dXJuIGZvdW5kID8gXCJcXFwiXCIgKyBsaXRlcmFsRXNjYXBlKGZvdW5kKSArIFwiXFxcIlwiIDogXCJlbmQgb2YgaW5wdXRcIjtcbiAgfVxuXG4gIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZCkgKyBcIiBidXQgXCIgKyBkZXNjcmliZUZvdW5kKGZvdW5kKSArIFwiIGZvdW5kLlwiO1xufTtcblxuZnVuY3Rpb24gcGVnJHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XG5cbiAgdmFyIHBlZyRGQUlMRUQgPSB7fSxcblxuICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucyA9IHsgUEc6IHBlZyRwYXJzZVBHIH0sXG4gICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gID0gcGVnJHBhcnNlUEcsXG5cbiAgICAgIHBlZyRjMCA9IGZ1bmN0aW9uKGxpbmVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZXM6IGxpbmVzLm1hcChsID0+IGwubm9kZSkuZmlsdGVyKHYgPT4gdiksXG4gICAgICAgICAgZWRnZXM6IGxpbmVzLm1hcChsID0+IGwuZWRnZSkuZmlsdGVyKHYgPT4gdiksXG4gICAgICAgICAgbm9kZUNvdW50OiBub2RlQ291bnQsXG4gICAgICAgICAgZWRnZUNvdW50OiBlZGdlQ291bnQsXG4gICAgICAgICAgbm9kZUxhYmVsczogbm9kZUxhYmVsSGFzaCxcbiAgICAgICAgICBlZGdlTGFiZWxzOiBlZGdlTGFiZWxIYXNoLFxuICAgICAgICAgIG5vZGVQcm9wZXJ0aWVzOiBub2RlUHJvcEhhc2gsXG4gICAgICAgICAgZWRnZVByb3BlcnRpZXM6IGVkZ2VQcm9wSGFzaFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGVnJGMxID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBlZyRjMiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlZGdlOiBlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwZWckYzMgPSBmdW5jdGlvbihpZCwgbCwgcCkge1xuICAgICAgICBsZXQgcHJvcE9iaiA9IHt9O1xuICAgICAgICBwLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgaWYgKHByb3BPYmpbcHJvcC5rZXldKSB7XG4gICAgICAgICAgICBwcm9wT2JqW3Byb3Aua2V5XS5wdXNoKHByb3AudmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wT2JqW3Byb3Aua2V5XSA9IFtwcm9wLnZhbHVlXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm9kZVByb3BIYXNoW3Byb3Aua2V5XSA9IHRydWU7XG4gICAgICAgICAgaWYgKG5vZGVQcm9wSGFzaFtwcm9wLmtleV0pIHtcbiAgICAgICAgICAgIG5vZGVQcm9wSGFzaFtwcm9wLmtleV0rKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZVByb3BIYXNoW3Byb3Aua2V5XSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBub2RlQ291bnQrKztcblxuICAgICAgICBsLmZvckVhY2gobGFiZWwgPT4ge1xuICAgICAgICAgIGlmIChub2RlTGFiZWxIYXNoW2xhYmVsXSkge1xuICAgICAgICAgICAgbm9kZUxhYmVsSGFzaFtsYWJlbF0rKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZUxhYmVsSGFzaFtsYWJlbF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uKCksXG4gICAgICAgICAgbGFiZWxzOiBsLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BPYmpcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBlZyRjNCA9IGZ1bmN0aW9uKGYsIGQsIHQsIGwsIHApIHtcbiAgICAgICAgbGV0IHByb3BPYmogPSB7fTtcbiAgICAgICAgcC5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgIGlmIChwcm9wT2JqW3Byb3Aua2V5XSkge1xuICAgICAgICAgICAgcHJvcE9ialtwcm9wLmtleV0ucHVzaChwcm9wLnZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcE9ialtwcm9wLmtleV0gPSBbcHJvcC52YWx1ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVkZ2VQcm9wSGFzaFtwcm9wLmtleV0gPSB0cnVlO1xuICAgICAgICAgIGlmIChlZGdlUHJvcEhhc2hbcHJvcC5rZXldKSB7XG4gICAgICAgICAgICBlZGdlUHJvcEhhc2hbcHJvcC5rZXldKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkZ2VQcm9wSGFzaFtwcm9wLmtleV0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWRnZUNvdW50Kys7XG5cbiAgICAgICAgbC5mb3JFYWNoKGxhYmVsID0+IHtcbiAgICAgICAgICBpZiAoZWRnZUxhYmVsSGFzaFtsYWJlbF0pIHtcbiAgICAgICAgICAgIGVkZ2VMYWJlbEhhc2hbbGFiZWxdKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkZ2VMYWJlbEhhc2hbbGFiZWxdID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnJvbTogZixcbiAgICAgICAgICB0bzogdCxcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24oKSxcbiAgICAgICAgICBkaXJlY3Rpb246IGQsXG4gICAgICAgICAgbGFiZWxzOiBsLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BPYmpcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBlZyRjNSA9IFwiOlwiLFxuICAgICAgcGVnJGM2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjpcIiwgZmFsc2UpLFxuICAgICAgcGVnJGM3ID0gZnVuY3Rpb24obCkge1xuICAgICAgICByZXR1cm4gbFxuICAgICAgfSxcbiAgICAgIHBlZyRjOCA9IGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBrZXk6IGssXG4gICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBlZyRjOSA9IFwiLS1cIixcbiAgICAgIHBlZyRjMTAgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLS1cIiwgZmFsc2UpLFxuICAgICAgcGVnJGMxMSA9IFwiLT5cIixcbiAgICAgIHBlZyRjMTIgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLT5cIiwgZmFsc2UpLFxuICAgICAgcGVnJGMxMyA9IFwiLVwiLFxuICAgICAgcGVnJGMxNCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCItXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMTUgPSBcIi5cIixcbiAgICAgIHBlZyRjMTYgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLlwiLCBmYWxzZSksXG4gICAgICBwZWckYzE3ID0gL15bMC05XS8sXG4gICAgICBwZWckYzE4ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIjBcIiwgXCI5XCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgIHBlZyRjMTkgPSBcIjBcIixcbiAgICAgIHBlZyRjMjAgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiMFwiLCBmYWxzZSksXG4gICAgICBwZWckYzIxID0gL15bMS05XS8sXG4gICAgICBwZWckYzIyID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIjFcIiwgXCI5XCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgIHBlZyRjMjMgPSAvXltlRV0vLFxuICAgICAgcGVnJGMyNCA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcImVcIiwgXCJFXCJdLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgcGVnJGMyNSA9IFwiK1wiLFxuICAgICAgcGVnJGMyNiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIrXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMjcgPSBcIidcIixcbiAgICAgIHBlZyRjMjggPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiJ1wiLCBmYWxzZSksXG4gICAgICBwZWckYzI5ID0gXCJcXFwiXCIsXG4gICAgICBwZWckYzMwID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlxcXCJcIiwgZmFsc2UpLFxuICAgICAgcGVnJGMzMSA9IFwiXFxcXFwiLFxuICAgICAgcGVnJGMzMiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJcXFxcXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMzMgPSBcImJcIixcbiAgICAgIHBlZyRjMzQgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiYlwiLCBmYWxzZSksXG4gICAgICBwZWckYzM1ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlxcYlwiO1xuICAgICAgfSxcbiAgICAgIHBlZyRjMzYgPSBcImZcIixcbiAgICAgIHBlZyRjMzcgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiZlwiLCBmYWxzZSksXG4gICAgICBwZWckYzM4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlxcZlwiO1xuICAgICAgfSxcbiAgICAgIHBlZyRjMzkgPSBcIm5cIixcbiAgICAgIHBlZyRjNDAgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiblwiLCBmYWxzZSksXG4gICAgICBwZWckYzQxID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlxcblwiO1xuICAgICAgfSxcbiAgICAgIHBlZyRjNDIgPSBcInJcIixcbiAgICAgIHBlZyRjNDMgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiclwiLCBmYWxzZSksXG4gICAgICBwZWckYzQ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlxcclwiO1xuICAgICAgfSxcbiAgICAgIHBlZyRjNDUgPSBcInRcIixcbiAgICAgIHBlZyRjNDYgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidFwiLCBmYWxzZSksXG4gICAgICBwZWckYzQ3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlxcdFwiO1xuICAgICAgfSxcbiAgICAgIHBlZyRjNDggPSBcInZcIixcbiAgICAgIHBlZyRjNDkgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidlwiLCBmYWxzZSksXG4gICAgICBwZWckYzUwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlxceDBCXCI7XG4gICAgICB9LFxuICAgICAgcGVnJGM1MSA9IHBlZyRhbnlFeHBlY3RhdGlvbigpLFxuICAgICAgcGVnJGM1MiA9IGZ1bmN0aW9uKGNoYXIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXI7XG4gICAgICB9LFxuICAgICAgcGVnJGM1MyA9IGZ1bmN0aW9uKGVzYykge1xuICAgICAgICByZXR1cm4gZXNjO1xuICAgICAgfSxcbiAgICAgIHBlZyRjNTQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRleHQoKTtcbiAgICAgIH0sXG4gICAgICBwZWckYzU1ID0gZnVuY3Rpb24oY2hhcnMpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgICAgfSxcbiAgICAgIHBlZyRjNTYgPSBmdW5jdGlvbihjaGFycykgeyBcbiAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgICAgfSxcbiAgICAgIHBlZyRjNTcgPSAvXlsgXFx0XS8sXG4gICAgICBwZWckYzU4ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiIFwiLCBcIlxcdFwiXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgIHBlZyRjNTkgPSAvXls6IFxcdFxcclxcbl0vLFxuICAgICAgcGVnJGM2MCA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcIjpcIiwgXCIgXCIsIFwiXFx0XCIsIFwiXFxyXCIsIFwiXFxuXCJdLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgcGVnJGM2MSA9IC9eW146IFxcdFxcclxcbl0vLFxuICAgICAgcGVnJGM2MiA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcIjpcIiwgXCIgXCIsIFwiXFx0XCIsIFwiXFxyXCIsIFwiXFxuXCJdLCB0cnVlLCBmYWxzZSksXG4gICAgICBwZWckYzYzID0gL15bXFxyXFxuXS8sXG4gICAgICBwZWckYzY0ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiXFxyXCIsIFwiXFxuXCJdLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgcGVnJGM2NSA9IC9eW15cXHJcXG5dLyxcbiAgICAgIHBlZyRjNjYgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCJcXHJcIiwgXCJcXG5cIl0sIHRydWUsIGZhbHNlKSxcblxuICAgICAgcGVnJGN1cnJQb3MgICAgICAgICAgPSAwLFxuICAgICAgcGVnJHNhdmVkUG9zICAgICAgICAgPSAwLFxuICAgICAgcGVnJHBvc0RldGFpbHNDYWNoZSAgPSBbeyBsaW5lOiAxLCBjb2x1bW46IDEgfV0sXG4gICAgICBwZWckbWF4RmFpbFBvcyAgICAgICA9IDAsXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkICA9IFtdLFxuICAgICAgcGVnJHNpbGVudEZhaWxzICAgICAgPSAwLFxuXG4gICAgICBwZWckcmVzdWx0O1xuXG4gIGlmIChcInN0YXJ0UnVsZVwiIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlRnVuY3Rpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3RhcnQgcGFyc2luZyBmcm9tIHJ1bGUgXFxcIlwiICsgb3B0aW9ucy5zdGFydFJ1bGUgKyBcIlxcXCIuXCIpO1xuICAgIH1cblxuICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbnNbb3B0aW9ucy5zdGFydFJ1bGVdO1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7XG4gIH1cblxuICBmdW5jdGlvbiBleHBlY3RlZChkZXNjcmlwdGlvbiwgbG9jYXRpb24pIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uICE9PSB2b2lkIDAgPyBsb2NhdGlvbiA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcylcblxuICAgIHRocm93IHBlZyRidWlsZFN0cnVjdHVyZWRFcnJvcihcbiAgICAgIFtwZWckb3RoZXJFeHBlY3RhdGlvbihkZXNjcmlwdGlvbildLFxuICAgICAgaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpLFxuICAgICAgbG9jYXRpb25cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgbG9jYXRpb24pIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uICE9PSB2b2lkIDAgPyBsb2NhdGlvbiA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcylcblxuICAgIHRocm93IHBlZyRidWlsZFNpbXBsZUVycm9yKG1lc3NhZ2UsIGxvY2F0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24odGV4dCwgaWdub3JlQ2FzZSkge1xuICAgIHJldHVybiB7IHR5cGU6IFwibGl0ZXJhbFwiLCB0ZXh0OiB0ZXh0LCBpZ25vcmVDYXNlOiBpZ25vcmVDYXNlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckY2xhc3NFeHBlY3RhdGlvbihwYXJ0cywgaW52ZXJ0ZWQsIGlnbm9yZUNhc2UpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImNsYXNzXCIsIHBhcnRzOiBwYXJ0cywgaW52ZXJ0ZWQ6IGludmVydGVkLCBpZ25vcmVDYXNlOiBpZ25vcmVDYXNlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckYW55RXhwZWN0YXRpb24oKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJhbnlcIiB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGVuZEV4cGVjdGF0aW9uKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiZW5kXCIgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRvdGhlckV4cGVjdGF0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpIHtcbiAgICB2YXIgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcG9zXSwgcDtcblxuICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICByZXR1cm4gZGV0YWlscztcbiAgICB9IGVsc2Uge1xuICAgICAgcCA9IHBvcyAtIDE7XG4gICAgICB3aGlsZSAoIXBlZyRwb3NEZXRhaWxzQ2FjaGVbcF0pIHtcbiAgICAgICAgcC0tO1xuICAgICAgfVxuXG4gICAgICBkZXRhaWxzID0gcGVnJHBvc0RldGFpbHNDYWNoZVtwXTtcbiAgICAgIGRldGFpbHMgPSB7XG4gICAgICAgIGxpbmU6ICAgZGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IGRldGFpbHMuY29sdW1uXG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAocCA8IHBvcykge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwKSA9PT0gMTApIHtcbiAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgfVxuXG4gICAgICAgIHArKztcbiAgICAgIH1cblxuICAgICAgcGVnJHBvc0RldGFpbHNDYWNoZVtwb3NdID0gZGV0YWlscztcbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRjb21wdXRlTG9jYXRpb24oc3RhcnRQb3MsIGVuZFBvcykge1xuICAgIHZhciBzdGFydFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoc3RhcnRQb3MpLFxuICAgICAgICBlbmRQb3NEZXRhaWxzICAgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoZW5kUG9zKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydDoge1xuICAgICAgICBvZmZzZXQ6IHN0YXJ0UG9zLFxuICAgICAgICBsaW5lOiAgIHN0YXJ0UG9zRGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IHN0YXJ0UG9zRGV0YWlscy5jb2x1bW5cbiAgICAgIH0sXG4gICAgICBlbmQ6IHtcbiAgICAgICAgb2Zmc2V0OiBlbmRQb3MsXG4gICAgICAgIGxpbmU6ICAgZW5kUG9zRGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IGVuZFBvc0RldGFpbHMuY29sdW1uXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRmYWlsKGV4cGVjdGVkKSB7XG4gICAgaWYgKHBlZyRjdXJyUG9zIDwgcGVnJG1heEZhaWxQb3MpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAocGVnJGN1cnJQb3MgPiBwZWckbWF4RmFpbFBvcykge1xuICAgICAgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgPSBbXTtcbiAgICB9XG5cbiAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGJ1aWxkU2ltcGxlRXJyb3IobWVzc2FnZSwgbG9jYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IHBlZyRTeW50YXhFcnJvcihtZXNzYWdlLCBudWxsLCBudWxsLCBsb2NhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoZXhwZWN0ZWQsIGZvdW5kLCBsb2NhdGlvbikge1xuICAgIHJldHVybiBuZXcgcGVnJFN5bnRheEVycm9yKFxuICAgICAgcGVnJFN5bnRheEVycm9yLmJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBmb3VuZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZVBHKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IFtdO1xuICAgIHMyID0gcGVnJHBhcnNlTm9kZU9yRWRnZSgpO1xuICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEucHVzaChzMik7XG4gICAgICBzMiA9IHBlZyRwYXJzZU5vZGVPckVkZ2UoKTtcbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZUVPRigpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMChzMSk7XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlTm9kZU9yRWRnZSgpIHtcbiAgICB2YXIgczAsIHMxO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZU5vZGUoKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgczEgPSBwZWckYzEoczEpO1xuICAgIH1cbiAgICBzMCA9IHMxO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlRWRnZSgpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMihzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJHBhcnNlRW1wdHlMaW5lKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlTm9kZSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VLZXkoKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gW107XG4gICAgICBzMyA9IHBlZyRwYXJzZUxhYmVsKCk7XG4gICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgIHMzID0gcGVnJHBhcnNlTGFiZWwoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IFtdO1xuICAgICAgICBzNCA9IHBlZyRwYXJzZVByb3BlcnR5KCk7XG4gICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlUHJvcGVydHkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IFtdO1xuICAgICAgICAgIHM1ID0gcGVnJHBhcnNlV1MoKTtcbiAgICAgICAgICB3aGlsZSAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0LnB1c2goczUpO1xuICAgICAgICAgICAgczUgPSBwZWckcGFyc2VXUygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlRW5kT2ZMaW5lKCk7XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGMzKHMxLCBzMiwgczMpO1xuICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZUVkZ2UoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNywgczgsIHM5O1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZUtleSgpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBbXTtcbiAgICAgIHMzID0gcGVnJHBhcnNlV1MoKTtcbiAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZVdTKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IHBlZyRwYXJzZURpcmVjdGlvbigpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IFtdO1xuICAgICAgICAgIHM1ID0gcGVnJHBhcnNlV1MoKTtcbiAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNC5wdXNoKHM1KTtcbiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VXUygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczUgPSBwZWckcGFyc2VLZXkoKTtcbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNiA9IFtdO1xuICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZUxhYmVsKCk7XG4gICAgICAgICAgICAgIHdoaWxlIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM2LnB1c2goczcpO1xuICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlTGFiZWwoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzNyA9IFtdO1xuICAgICAgICAgICAgICAgIHM4ID0gcGVnJHBhcnNlUHJvcGVydHkoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM3LnB1c2goczgpO1xuICAgICAgICAgICAgICAgICAgczggPSBwZWckcGFyc2VQcm9wZXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM4ID0gW107XG4gICAgICAgICAgICAgICAgICBzOSA9IHBlZyRwYXJzZVdTKCk7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoczkgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczgucHVzaChzOSk7XG4gICAgICAgICAgICAgICAgICAgIHM5ID0gcGVnJHBhcnNlV1MoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzOSA9IHBlZyRwYXJzZUVuZE9mTGluZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoczkgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjNChzMSwgczMsIHM1LCBzNiwgczcpO1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VMYWJlbCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IFtdO1xuICAgIHMyID0gcGVnJHBhcnNlRGVsaW1pdGVyKCk7XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlRGVsaW1pdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgIHMyID0gcGVnJGM1O1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IFtdO1xuICAgICAgICBzNCA9IHBlZyRwYXJzZVdTKCk7XG4gICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlV1MoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZUtleSgpO1xuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjNyhzNCk7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZVByb3BlcnR5KCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNjtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBbXTtcbiAgICBzMiA9IHBlZyRwYXJzZURlbGltaXRlcigpO1xuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICBzMiA9IHBlZyRwYXJzZURlbGltaXRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VLZXkoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IFtdO1xuICAgICAgICBzNCA9IHBlZyRwYXJzZVdTKCk7XG4gICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlV1MoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgICAgICBzNCA9IHBlZyRjNTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gW107XG4gICAgICAgICAgICBzNiA9IHBlZyRwYXJzZVdTKCk7XG4gICAgICAgICAgICB3aGlsZSAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczUucHVzaChzNik7XG4gICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlV1MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZVZhbHVlKCk7XG4gICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJGM4KHMyLCBzNik7XG4gICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZURpcmVjdGlvbigpIHtcbiAgICB2YXIgczA7XG5cbiAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGM5KSB7XG4gICAgICBzMCA9IHBlZyRjOTtcbiAgICAgIHBlZyRjdXJyUG9zICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMCk7IH1cbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGMxMSkge1xuICAgICAgICBzMCA9IHBlZyRjMTE7XG4gICAgICAgIHBlZyRjdXJyUG9zICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMik7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VOdW1iZXIoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2O1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ1KSB7XG4gICAgICBzMSA9IHBlZyRjMTM7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTQpOyB9XG4gICAgfVxuICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlSW50ZWdlcigpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDYpIHtcbiAgICAgICAgICBzNCA9IHBlZyRjMTU7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE2KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM1ID0gW107XG4gICAgICAgICAgaWYgKHBlZyRjMTcudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczYgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE4KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNS5wdXNoKHM2KTtcbiAgICAgICAgICAgICAgaWYgKHBlZyRjMTcudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICAgIHM2ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHM2ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTgpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gW3M0LCBzNV07XG4gICAgICAgICAgICBzMyA9IHM0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczQgPSBwZWckcGFyc2VFeHAoKTtcbiAgICAgICAgICBpZiAoczQgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMSA9IFtzMSwgczIsIHMzLCBzNF07XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZUludGVnZXIoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0OCkge1xuICAgICAgczAgPSBwZWckYzE5O1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIwKTsgfVxuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAocGVnJGMyMS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIyKTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gW107XG4gICAgICAgIGlmIChwZWckYzE3LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE4KTsgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICAgIGlmIChwZWckYzE3LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgIHMzID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxOCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBbczEsIHMyXTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlRXhwKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQ7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChwZWckYzIzLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyNCk7IH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ1KSB7XG4gICAgICAgIHMyID0gcGVnJGMxMztcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE0KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDMpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMjU7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI2KTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gW107XG4gICAgICAgIGlmIChwZWckYzE3LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE4KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczMucHVzaChzNCk7XG4gICAgICAgICAgICBpZiAocGVnJGMxNy50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE4KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBbczEsIHMyLCBzM107XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZUVzY2FwZWRDaGFyKCkge1xuICAgIHZhciBzMCwgczE7XG5cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM5KSB7XG4gICAgICBzMCA9IHBlZyRjMjc7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjgpOyB9XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNCkge1xuICAgICAgICBzMCA9IHBlZyRjMjk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkyKSB7XG4gICAgICAgICAgczAgPSBwZWckYzMxO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMik7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTgpIHtcbiAgICAgICAgICAgIHMxID0gcGVnJGMzMztcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzNCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGMzNSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTAyKSB7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGMzNjtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM3KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjMzgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMTApIHtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMzk7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQwKTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJGM0MSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMTQpIHtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGM0MjtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0Myk7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGM0NCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTE2KSB7XG4gICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGM0NTtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ2KTsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjNDcoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjNDg7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ5KTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGM1MCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlRG91YmxlUXVvdGVkQ2hhcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckY3VyclBvcztcbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM0KSB7XG4gICAgICBzMiA9IHBlZyRjMjk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzApOyB9XG4gICAgfVxuICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mikge1xuICAgICAgICBzMiA9IHBlZyRjMzE7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMik7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHZvaWQgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcGVnJGN1cnJQb3MpIHtcbiAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTEpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM1MihzMik7XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTIpIHtcbiAgICAgICAgczEgPSBwZWckYzMxO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzIpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VFc2NhcGVkQ2hhcigpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNTMoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VTaW5nbGVRdW90ZWRDaGFyKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRjdXJyUG9zO1xuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzkpIHtcbiAgICAgIHMyID0gcGVnJGMyNztcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyOCk7IH1cbiAgICB9XG4gICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkyKSB7XG4gICAgICAgIHMyID0gcGVnJGMzMTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMyKTsgfVxuICAgICAgfVxuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gdm9pZCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMxO1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwZWckY3VyclBvcykge1xuICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1MSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzUyKHMyKTtcbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mikge1xuICAgICAgICBzMSA9IHBlZyRjMzE7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZUVzY2FwZWRDaGFyKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM1MyhzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZUtleSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlTnVtYmVyKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICBzMyA9IHBlZyRwYXJzZVNQRUNJQUxfQ0hBUigpO1xuICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMjtcbiAgICAgICAgczIgPSB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM1NCgpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM0KSB7XG4gICAgICAgIHMxID0gcGVnJGMyOTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMwKTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gW107XG4gICAgICAgIHMzID0gcGVnJHBhcnNlRG91YmxlUXVvdGVkQ2hhcigpO1xuICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZURvdWJsZVF1b3RlZENoYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM0KSB7XG4gICAgICAgICAgICBzMyA9IHBlZyRjMjk7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzApOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjNTUoczIpO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM5KSB7XG4gICAgICAgICAgczEgPSBwZWckYzI3O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyOCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IFtdO1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlU2luZ2xlUXVvdGVkQ2hhcigpO1xuICAgICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgICBzMyA9IHBlZyRwYXJzZVNpbmdsZVF1b3RlZENoYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM5KSB7XG4gICAgICAgICAgICAgIHMzID0gcGVnJGMyNztcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI4KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjNTYoczIpO1xuICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIHMxID0gW107XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VOT05fU1BFQ0lBTF9DSEFSKCk7XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlTk9OX1NQRUNJQUxfQ0hBUigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjNTUoczEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlVmFsdWUoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM0KSB7XG4gICAgICBzMSA9IHBlZyRjMjk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzApOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBbXTtcbiAgICAgIHMzID0gcGVnJHBhcnNlRG91YmxlUXVvdGVkQ2hhcigpO1xuICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICBzMyA9IHBlZyRwYXJzZURvdWJsZVF1b3RlZENoYXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM0KSB7XG4gICAgICAgICAgczMgPSBwZWckYzI5O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNTUoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzOSkge1xuICAgICAgICBzMSA9IHBlZyRjMjc7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyOCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IFtdO1xuICAgICAgICBzMyA9IHBlZyRwYXJzZVNpbmdsZVF1b3RlZENoYXIoKTtcbiAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VTaW5nbGVRdW90ZWRDaGFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzOSkge1xuICAgICAgICAgICAgczMgPSBwZWckYzI3O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI4KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzU2KHMyKTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBbXTtcbiAgICAgICAgczIgPSBwZWckcGFyc2VOT05fU1BFQ0lBTF9DSEFSKCk7XG4gICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTgpIHtcbiAgICAgICAgICAgIHMyID0gcGVnJGM1O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgICBzMiA9IHBlZyRwYXJzZU5PTl9TUEVDSUFMX0NIQVIoKTtcbiAgICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgICAgICAgICAgczIgPSBwZWckYzU7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM1NShzMSk7XG4gICAgICAgIH1cbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VXUygpIHtcbiAgICB2YXIgczA7XG5cbiAgICBpZiAocGVnJGM1Ny50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTgpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlU1BFQ0lBTF9DSEFSKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChwZWckYzU5LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2MCk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VOT05fU1BFQ0lBTF9DSEFSKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChwZWckYzYxLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2Mik7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VORVdMSU5FKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChwZWckYzYzLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2NCk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VOT05fTkVXTElORSgpIHtcbiAgICB2YXIgczA7XG5cbiAgICBpZiAocGVnJGM2NS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjYpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlRU9GKCkge1xuICAgIHZhciBzMCwgczE7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIGlmIChpbnB1dC5sZW5ndGggPiBwZWckY3VyclBvcykge1xuICAgICAgczEgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzUxKTsgfVxuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gdm9pZCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZUVuZE9mTGluZSgpIHtcbiAgICB2YXIgczA7XG5cbiAgICBzMCA9IHBlZyRwYXJzZUVPRigpO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckcGFyc2VORVdMSU5FKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlRGVsaW1pdGVyKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQ7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gW107XG4gICAgczIgPSBwZWckcGFyc2VXUygpO1xuICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEucHVzaChzMik7XG4gICAgICBzMiA9IHBlZyRwYXJzZVdTKCk7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VORVdMSU5FKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBbXTtcbiAgICAgICAgczQgPSBwZWckcGFyc2VXUygpO1xuICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICB3aGlsZSAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgICAgczQgPSBwZWckcGFyc2VXUygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBbczEsIHMyLCBzM107XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gW107XG4gICAgICBzMSA9IHBlZyRwYXJzZVdTKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAucHVzaChzMSk7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2VXUygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlRW1wdHlMaW5lKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IFtdO1xuICAgIHMyID0gcGVnJHBhcnNlV1MoKTtcbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgczIgPSBwZWckcGFyc2VXUygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VFT0YoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IFtzMSwgczJdO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgczIgPSBwZWckcGFyc2VXUygpO1xuICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICBzMiA9IHBlZyRwYXJzZVdTKCk7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VORVdMSU5FKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxID0gW3MxLCBzMl07XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG5cbiAgICBsZXQgbm9kZUNvdW50ID0gMDtcbiAgICBsZXQgZWRnZUNvdW50ID0gMDtcbiAgICBsZXQgbm9kZUxhYmVsSGFzaCA9IHt9O1xuICAgIGxldCBlZGdlTGFiZWxIYXNoID0ge307XG4gICAgbGV0IG5vZGVQcm9wSGFzaCA9IHt9O1xuICAgIGxldCBlZGdlUHJvcEhhc2ggPSB7fTtcblxuXG4gIHBlZyRyZXN1bHQgPSBwZWckc3RhcnRSdWxlRnVuY3Rpb24oKTtcblxuICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBlZyRyZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHBlZyRmYWlsKHBlZyRlbmRFeHBlY3RhdGlvbigpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLFxuICAgICAgcGVnJG1heEZhaWxQb3MgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQXQocGVnJG1heEZhaWxQb3MpIDogbnVsbCxcbiAgICAgIHBlZyRtYXhGYWlsUG9zIDwgaW5wdXQubGVuZ3RoXG4gICAgICAgID8gcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckbWF4RmFpbFBvcywgcGVnJG1heEZhaWxQb3MgKyAxKVxuICAgICAgICA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJG1heEZhaWxQb3MsIHBlZyRtYXhGYWlsUG9zKVxuICAgICk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFN5bnRheEVycm9yOiBwZWckU3ludGF4RXJyb3IsXG4gIHBhcnNlOiAgICAgICBwZWckcGFyc2Vcbn07XG5cbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucGdQYXJzZXIgPSByZXF1aXJlKCcuL3BnX3BhcnNlci5qcycpO1xuXG5sZXQgY29yZVBhcnNlID0gcGdQYXJzZXIucGFyc2U7XG5mdW5jdGlvbiByZW1vdmVDb21tZW50KHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSgvXigoKFwiW15cIlxcXFxdKihcXFxcLlteXCJcXFxcXSopKlwiKXxbXiNcIl0pKikoIy4qKSQvZ20sICckMScpO1xufVxucGdQYXJzZXIucGFyc2UgPSAodGV4dCkgPT4gY29yZVBhcnNlKHJlbW92ZUNvbW1lbnQodGV4dCkpO1xuXG59LHtcIi4vcGdfcGFyc2VyLmpzXCI6MX1dfSx7fSxbMl0pO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdClcblx0XHRzY3JpcHRVcmwgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY1xuXHRpZiAoIXNjcmlwdFVybCkge1xuXHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG5cdFx0aWYoc2NyaXB0cy5sZW5ndGgpIHNjcmlwdFVybCA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5zcmNcblx0fVxufVxuLy8gV2hlbiBzdXBwb3J0aW5nIGJyb3dzZXJzIHdoZXJlIGFuIGF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgeW91IG11c3Qgc3BlY2lmeSBhbiBvdXRwdXQucHVibGljUGF0aCBtYW51YWxseSB2aWEgY29uZmlndXJhdGlvblxuLy8gb3IgcGFzcyBhbiBlbXB0eSBzdHJpbmcgKFwiXCIpIGFuZCBzZXQgdGhlIF9fd2VicGFja19wdWJsaWNfcGF0aF9fIHZhcmlhYmxlIGZyb20geW91ciBjb2RlIHRvIHVzZSB5b3VyIG93biBsb2dpYy5cbmlmICghc2NyaXB0VXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbnNjcmlwdFVybCA9IHNjcmlwdFVybC5yZXBsYWNlKC8jLiokLywgXCJcIikucmVwbGFjZSgvXFw/LiokLywgXCJcIikucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIi9cIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBzY3JpcHRVcmw7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5iID0gZG9jdW1lbnQuYmFzZVVSSSB8fCBzZWxmLmxvY2F0aW9uLmhyZWY7XG5cbi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4vLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbi8vIFtyZXNvbHZlLCByZWplY3QsIFByb21pc2VdID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxudmFyIGluc3RhbGxlZENodW5rcyA9IHtcblx0XCJtYWluXCI6IDBcbn07XG5cbi8vIG5vIGNodW5rIG9uIGRlbWFuZCBsb2FkaW5nXG5cbi8vIG5vIHByZWZldGNoaW5nXG5cbi8vIG5vIHByZWxvYWRlZFxuXG4vLyBubyBITVJcblxuLy8gbm8gSE1SIG1hbmlmZXN0XG5cbi8vIG5vIG9uIGNodW5rcyBsb2FkZWRcblxuLy8gbm8ganNvbnAgZnVuY3Rpb24iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5jID0gdW5kZWZpbmVkOyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2JsaXR6Ym9hcmQuanNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=