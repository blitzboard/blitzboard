<!DOCTYPE html>
<html>
<head>
<title>Hello Graph</title>
<!-- <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script> -->
<link crossorigin='anonymous' href='https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css' integrity='sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css' rel='stylesheet'>
<script src='./axios.min.js'></script>
<script src='./vis-network.min.js'></script>
<script src='./lib/dat.gui.min.js'></script>
<script src='./lib/pg_parser_browserified.js' type='text/javascript'></script>
<script src='./lib/json2pg_browserified.js' type='text/javascript'></script>
<style>
  #network-popUp {
      display: none;
      position: absolute;
      top: 350px;
      left: 170px;
      z-index: 299;
      width: 250px;
      background-color: #f9f9f9;
      border-style: solid;
      border-width: 3px;
      border-color: #5394ed;
      padding: 10px;
      text-align: center;
  }
</style>
</head>
<body>
<div id='network-popUp'>
<span id='operation'>node</span>
<br>
<table style='margin: auto'>
<tbody id='popup-table'></tbody>
</table>
<input id='saveButton' type='button' value='save'>
<input id='cancelButton' type='button' value='cancel'>
</div>
<div class='row'>
<div class='col-6 pr-0 pl-4'>
<input aria-label='' class='form-control' id='search-input' placeholder='Free Search' type='text'>
</div>
<div class='col-2 mx-0 px-0'>
<button class='mx-0 btn btn-info' id='search-button' type='button'>
<span class='fa fa-search' id='search-icon'></span>
Search
</button>
</div>
</div>
<div class='row'>
<div class='col-12'>
<div class='vh-100 bg-light' id='graph'></div>
</div>
</div>
<div id='input-area'>
<input id='pgfile' type='file'>
<input id='url-input'>
<textarea id='graph-input' style='resize: none; width: 100%; height: 80px;'></textarea>
</div>
<script>
  'use strict';
      const q = document.querySelector.bind(document);
      const qa = document.querySelectorAll.bind(document);
      const nodeSize = 25;
      let timerId = 0;
      let localMode = true;
      let data, nodes, nodeDataSet, edgeDataSet, expandedNodes = [], network;
      let clickedPosition;
      let graph, nodeMap = new Map(), edgeMap = new Map();
      let edgeColorMap;
      let domain;
      let searchedNodeIds = [];
      let displayedTimeProp = "submittedDate"; 
      let nodeProps, edgeProps;
      let minTime =  new Date(8640000000000000), maxTime = new Date(-8640000000000000);
      let timeInterval = 1;
      let timeScale = 100.0;
  
      
      const gui = new dat.GUI();
      const nodeFolder = gui.addFolder('Node');
      const edgeFolder = gui.addFolder('Edge');
      
      nodeFolder.open();
      edgeFolder.open();
      
      const physicsController = gui.add({physics: false}, 'physics');
      physicsController.onChange(() => 
        network.setOptions({physics: {enabled:physicsController.getValue()}})
      );
      const hopController = gui.add({hop: 1}, 'hop', 1, 10, 1);
  
      function toVisNode(pgNode, group, props, data = null) {
          let x, fixed;
          if(displayedTimeProp && pgNode.properties[displayedTimeProp] && timeInterval > 0) {
            x = timeScale * ((new Date(pgNode.properties[displayedTimeProp]).getTime()) - minTime.getTime()) * 1.0 / timeInterval - timeScale * 0.5;
            fixed = true;
          } else {
            x = (data ? data.x : 0);
            fixed = false;
          }
          return {
              id: pgNode.id,
              group: group,
              label: createLabelText(pgNode, props),
              shape: searchedNodeIds.includes(pgNode.id) ? 'square' : 'dot',
              title: createTitleText(pgNode),
              fixed: {
                x: fixed,
                y: false
              },
              x: x,
              y: (data ? data.y : 0)
          };
      }
      
      function toVisEdge(pgEdge, group, props) {
          return {
              id: pgEdge.properties.id[0],
              from: pgEdge.from,
              to: pgEdge.to,
              color: edgeColorMap[group],
              label: createLabelText(pgEdge, props),
              title: createTitleText(pgEdge),
              remoteId: pgEdge.properties.id[0]
          }
      }
  
      function createLabelText(elem, props = null) {
          if(props != null) {
              // Use whitespace instead of empty string if no props are specified because Vis.js cannot update label with empty string)
            return props.length ? props.map((prop) => prop == 'label' ? elem.labels : elem.properties[prop]).filter((val) => val).join('\n') : ' ';
          }
          else if (elem.id) // for nodes
              return elem.id;
          else // for edges
              return elem.labels.join("\n");
      }
  
      function createTitleText(elem) {
          let flattend_props = Object.entries(elem.properties).reduce((acc, prop) =>
              acc.concat(`<tr><td>${prop[0]}</td><td>${prop[1]}</td></tr>`), []);
          if (elem.id) // for nodes
              flattend_props.push(`<tr><td>label</td><td>${elem.labels.join(':')}</td></tr>`);
          return `<table>${flattend_props.join('')}</table>`;
      }
  
      function getRandomColor() {
          let letters = '0123456789ABCDEF';
          let color = '#';
          for (let i = 0; i < 6; i++) {
              color += letters[Math.floor(Math.random() * 16)];
          }
          return color;
      }
  
      function retrieveGraph(node_id, add = false) {
          node_id = node_id || 1;
          domain = q('#url-input').value;
          if (!domain.endsWith('/'))
              domain += '/';
          domain = 'http://' + domain;
          axios.get(domain + `node_match?node_ids=${node_id}&directed=false`).then((response) => {
              if (add) {
                  addGraph(response.data.pg);
                  expandedNodes.push(node_id.toString());
              } else {
                  expandedNodes = [node_id.toString()];
                  updateGraph(response.data.pg);
              }
          });
      }
      
      function setSearchState(searching) {
        const icon =  q('#search-icon');
        if(searching) {
          icon.classList.remove("fa-search");
          icon.classList.add("fa-spinner");
          icon.classList.add("fa-spin");
        } else {
          icon.classList.add("fa-search");
          icon.classList.remove("fa-spinner");
          icon.classList.remove("fa-spin");
        }
      }
  
      function searchGraph() {  
          setSearchState(true);
          const keyword = q('#search-input').value;
          domain = q('#url-input').value;
          if (!domain.endsWith('/'))
              domain += '/';
          domain = 'http://' + domain;
          const hop = Math.floor(hopController.getValue());
          const keywordPart = encodeURI(keyword.split(" ").map((word) => `\\"${word}\\"`).join(' AND '));
          const query = `CALL db.index.fulltext.queryNodes("allProperties", "${keywordPart}") YIELD node RETURN node`;
          console.log(query);
          axios.get(domain + `query?q=${query}`).then((response) => {
              searchedNodeIds = response.data.pg.nodes.map((node) => node.id);
              const subquery = `MATCH p=((n)-[r*..${hop}]-(another)) WHERE id(n) in [${searchedNodeIds.join(',')}] RETURN p`;
              axios.get(domain + `query?q=${subquery}`).then((subresponse) => {
                updateGraph(subresponse.data.pg);
                setSearchState(false);
              });
          });
      }
      
      function inputLabel() {
        return q('#label-input').value.trim();
      }
      
      function inputProperties() {
        return Array.from(qa('.popup-input')).filter((input) => input.name != 'label' && input.value.trim().length > 0);
      }
  
      function saveNode(data, callback) {             
          clearPopUp();
          callback(null); // manually add nodes
          const propText = inputProperties().map((input) => `${input.name}: '${input.value.trim()}'` ).join(','); 
          let query = `CREATE (a:${inputLabel()} {${propText}}) RETURN a`;
          axios.get(domain + `query?q=${query}`).then((response) => {
              const node = response.data.pg.nodes[0];
              nodeDataSet.add(toVisNode(node, "", displayedNodeProps(), data));
              graph.nodes.push(node);
              nodeMap[node.id] = node;
              q('#graph-input').value = json2pg.translate(JSON.stringify(graph));
          });
      }
  
      function saveEdge(data) {
          const pgProperties = {};
          inputProperties().forEach((prop) => pgProperties[prop.name] = [prop.value]);
          let newEdge = {
              from: data.from,
              to: data.to,
              undirected: false,
              labels: inputLabel().split(':'),
              properties: pgProperties
          };    
          clearPopUp();
          const propText = inputProperties().map((input) => `${input.name}: '${input.value.trim()}'` ).join(','); 
          graph.edges.push(newEdge);
          console.log(data);
          q('#graph-input').value = json2pg.translate(JSON.stringify(graph));
          let query = `MATCH (a),(b) WHERE id(a) = ${data.from} and id(b) = ${data.to} CREATE (a)-[r2:${inputLabel()} {${propText}}]->(b) RETURN r2`;
          axios.get(domain + `query?q=${query}`).then((response) => { 
            // TODO: add new edge to edgeMap
            edgeDataSet.add(toVisEdge(response.data.pg.edges[0]))
          });
      }
  
  
      function editNode(data, callback) {
          const label = document.getElementById("label-input").value.trim();
          let updateText = `a:${label}`;
          const propInputs = Array.from(qa('.popup-input')).filter((input) => input.name != 'label' && input.value.trim().length > 0);
          if(propInputs.length > 0)
            updateText += ', ' + propInputs.map((input) => `a.${input.name} = '${input.value.trim()}'` ).join(','); 
          clearPopUp();
          callback(null); // edit node without vis.js default behavior
          let query = `MATCH (a) WHERE id(a) = ${data.id} SET ${updateText} RETURN a`;
          axios.get(domain + `query?q=${query}`).then((response) => {
              // TODO: edit label in PG
              // TODO: support removal of existing pg
              nodeDataSet.update(toVisNode(response.data.pg.nodes[0], "", displayedNodeProps(), data));
              // graph.nodes.push(node);
              // q('#graph-input').value = json2pg.translate(JSON.stringify(graph));
          });
      }
  
      function deleteNode(data) {
          let query = `MATCH (n) WHERE id(n) IN [${data.nodes.    join(',')}] DETACH DELETE n`;
          axios.get(domain + `query?q=${query}`).then((response) => {
              console.log(response);
          });
      }
  
  
      function deleteEdge(data) {
          const edgeId = edgeDataSet.get(data.edges[0]).remoteId;
          let query = `MATCH (n)-[e]-(n2) WHERE id(e) = ${edgeId} DELETE e`;
          console.log(query);
          axios.get(domain + `query?q=${query}`).then((response) => {
              console.log(response);
          });
      }
      
      function displayedNodeProps() {
        return nodeFolder.__controllers.map((con) =>
              con.__checkbox.checked ? con.property : null).filter((prop) => prop);
      }
      
      function displayedEdgeProps() {
        return edgeFolder.__controllers.map((con) =>
              con.__checkbox.checked ? con.property : null).filter((prop) => prop);
      }
      
      function updatePopupForNodes(node=null) {
        const table = q('#popup-table');
        table.innerHTML = '';
        nodeProps.forEach((prop) => {
          if(prop != 'id') {
            table.insertAdjacentHTML('beforeend', `
            <tr>
            <td>${prop}</td>
            <td><input type="text" id='${prop}-input' class='popup-input' name='${prop}' value='${node ? (prop == 'label' ? node.labels.join(':') : node.properties[prop]) : ''}'></td>
            </tr>
            `)
          }
        });
      }
      
      
      function updatePopupForEdges(edge=null) {
        const table = q('#popup-table');
        table.innerHTML = '';
        edgeProps.forEach((prop) => {
          if(prop != 'id') {
            table.insertAdjacentHTML('beforeend', `
            <tr>
            <td>${prop}</td>
            <td><input type="text" id='${prop}-input' class='popup-input' name='${prop}' value='${edge ? (prop == 'label' ? edge.labels.join(':') : edge.properties[prop]) : ''}'></td>
            </tr>
            `)
          }
        });
      }
      
      function showPopup() {
        document.getElementById("network-popUp").style.display = "block";
        const popup = document.getElementById("network-popUp");
        popup.style.left = `${clickedPosition.x}px`;
        popup.style.top = `${clickedPosition.y}px`;
        popup.style.display = "block";
        q('.popup-input').focus();
      }
  
  
      function updateGraph(input) {
          let groups = new Set();
          edgeColorMap = {};
  
          input = input || q('#graph-input').value;
          if (typeof input === 'string' || input instanceof String) {
              try {
                  graph = JSON.parse(input);
              } catch (err) {
                  if (err instanceof SyntaxError)
                      graph = pgParser.parse(input);
                  else
                      throw err;
              }
          } else {
              graph = input;
          }
          
          minTime =  new Date(8640000000000000), maxTime = new Date(-8640000000000000);
          
          let nodeCountWithTime = 0;
          
          graph.nodes.forEach(node => { 
            nodeMap[node.id] = node;
            if(displayedTimeProp) {
              let time = node.properties[displayedTimeProp];
              if(time) {
                ++nodeCountWithTime;
                time = new Date(time);
                minTime = time < minTime ? time : minTime;
                maxTime = time > maxTime ? time : maxTime;
              }
            };
          });
          timeInterval = maxTime.getTime() - minTime.getTime();
          timeScale = nodeCountWithTime * 50;
          
          graph.edges.forEach(edge => edgeMap[edge.id] = edge);
          
          nodeProps = new Set(['label']);
          edgeProps = new Set(['label']);
          graph.nodes.forEach((node) => {
              Object.keys(node.properties).forEach(nodeProps.add, nodeProps);
          });
          graph.edges.forEach((edge) => {
              Object.keys(edge.properties).forEach(edgeProps.add, edgeProps);
          });
          
          const defaultPropsFilter = new RegExp('name|title', 'i');
          let defaultNodeProps = displayedNodeProps();
          let defaultEdgeProps = displayedEdgeProps();
          
          if(defaultNodeProps.length == 0) { // Initial value
            defaultNodeProps = Array.from(nodeProps).filter((prop) => defaultPropsFilter.test(prop));
            defaultEdgeProps = Array.from(edgeProps).filter((prop) => defaultPropsFilter.test(prop));
          }
  
          
          if(defaultNodeProps.length == 0) defaultNodeProps = ['id'];
          
  
          nodeDataSet = new vis.DataSet();
          nodeDataSet.add(graph.nodes.map((node) => {
              const groupName = node.labels.join('_');
              groups.add(groupName);
              return toVisNode(node, groupName, defaultNodeProps)
          }));
          
          if(timeInterval > 0) {
            nodeDataSet.add([
              {
                id:"hellograph-min",
                label: minTime.toString(),
                shape: 'star',
                physics: false,
                x: -timeScale / 2,
                y: 15,
                color: 'green',
              },
              {
                id:"hellograph-max",
                label: maxTime.toString(),
                shape: 'star',
                physics: false,
                x: timeScale / 2,
                y: -15,
                color: 'green',
              },
            ])
          }
          
  
          edgeDataSet = new vis.DataSet(graph.edges.map((edge) => {
              const edgeLabel = edge.labels.join('_');
              if (!edgeColorMap[edgeLabel]) {
                  edgeColorMap[edgeLabel] = getRandomColor();
              }
              return toVisEdge(edge, edgeLabel, defaultEdgeProps);                   
          }));
          // create a network
          let container = document.getElementById('graph');
          data = {
              nodes: nodeDataSet,
              edges: edgeDataSet
          };
          
          const onNodeControllerChange = () => {
            let displayedProps = displayedNodeProps();
            nodeDataSet.update(graph.nodes.map((node) => {
                return {
                  id: node.id,
                  label: createLabelText(node, displayedProps)
                };
              })
            );
          };
          
          while(nodeFolder.__controllers.length > 0) nodeFolder.__controllers[0].remove();
          while(edgeFolder.__controllers.length > 0) edgeFolder.__controllers[0].remove();
          
          nodeProps.forEach(prop => {
              const controller = nodeFolder.add({[prop]: defaultNodeProps.includes(prop)}, prop)
              controller.onChange(onNodeControllerChange);
            }
          );
          
          const onEdgeControllerChange = () => {
            let displayedProps = displayedEdgeProps();
            edgeDataSet.update(graph.edges.map((edge) => {
                return { id:edge.properties.id[0],
                 label: createLabelText(edge, displayedProps) };
              }
            ));
          }
          
          edgeProps.forEach(prop => {
              const controller = edgeFolder.add({[prop]: defaultEdgeProps.includes(prop)}, prop)
              controller.onChange(onEdgeControllerChange);
            }
          );
          
          
          let options = {
              groups: Object.keys(groups).reduce((acc, group) => {
                  acc[group] = {color: getRandomColor()}
              }, {}),
              layout: {
                  // randomSeed: 1,
              },
              interaction: {
                  hover: true
              },
              physics: {
                stabilization: {
                    enabled: false,
                    iterations: 200,
                    updateInterval: 25
                }
              },
              manipulation: {
                  addNode: (data, callback) => {
                      // filling in the popup DOM elements
                      document.getElementById("operation").innerHTML = "Add Node";
                      updatePopupForNodes();
                      document.getElementById("saveButton").onclick = saveNode.bind(
                          this,
                          data,
                          callback
                      );
                      document.getElementById("cancelButton").onclick = clearPopUp.bind();
                      showPopup();
                  },
                  editNode: function (data, callback) {
                      // filling in the popup DOM elements
                      document.getElementById("operation").innerHTML = "Edit Node";
                      updatePopupForNodes(nodeMap[data.id]);
                      document.getElementById("saveButton").onclick = editNode.bind(
                          this,
                          data,
                          callback
                      );
                      document.getElementById("cancelButton").onclick = cancelEdit.bind(
                          this,
                          callback
                      );
                      document.getElementById("network-popUp").style.display = "block";
                      showPopup();
                  },
                  addEdge: function (data, callback) {
                      if (data.from != data.to || confirm("Do you want to connect the node to itself?")) {
                          callback(null);
                          document.getElementById("operation").innerHTML = "Add Edge";
                          updatePopupForEdges();
                          
                          document.getElementById("saveButton").onclick = saveEdge.bind(
                              this,
                              data,
                              callback
                          );
                          document.getElementById("cancelButton").onclick = cancelEdit.bind(
                              this,
                              callback
                          );
                          showPopup();
                      }
                  },
                  deleteNode: (data, callback) => {
                      deleteNode(data);
                      callback(data);
                  },
                  deleteEdge: (data, callback) => {
                      deleteEdge(data);
                      callback(data);
                  },
              },
              edges: {
                  arrows: {
                      to: {
                          enabled: true,
                          scaleFactor: 0.3,
                          type: "arrow"
                      },
                  }
              }
          };
          network = new vis.Network(container, data, options);
          
          
          network.on('zoom', (opt) => {
            nodeDataSet.update([
              {
                id: 'hellograph-min',
                size: 15 / opt.scale,
              },
              {
                id: 'hellograph-max',
                size: 15 / opt.scale,
              }
            ]);
          })
          
          if (!localMode) {
              let selectTimer = null;
              network.on('selectNode', (e) => {
                  if (e.nodes.length > 0)
                      selectTimer = setTimeout(() => retrieveGraph(e.nodes[0], true), 300);
              });
              network.on('doubleClick', (e) => {
                  if (e.nodes.length > 0)
                      retrieveGraph(e.nodes[0]);
              });
              network.on('dragStart', (e) => {
                  clearTimeout(selectTimer);
              });
              network.on("hoverNode", (params) => {
                  network.canvas.body.container.style.cursor = 'pointer'
              });
              network.on("blurNode", (params) => {
                  network.canvas.body.container.style.cursor = 'default'
              });
          }
          network.on("click", (e) => {
             network.stopSimulation();
          });
          network.on("stabilizationIterationsDone", function () {
              console.log('stabilized');
              network.setOptions({physics: {enabled:physicsController.getValue()}});
          });
      }
  
      function addGraph(input) {
          let groups = new Set();
          edgeColorMap = {};
  
          input = input || q('#graph-input').value;
          if (typeof input === 'string' || input instanceof String) {
              try {
                  graph = JSON.parse(input);
              } catch (err) {
                  if (err instanceof SyntaxError)
                      graph = pgParser.parse(input);
                  else
                      throw err;
              }
          } else {
              graph = input;
          }
  
  
          const newEdges = graph.edges.filter((e) => !(expandedNodes.includes(e.from) || expandedNodes.includes(e.to))).map((edge) => {
              const edgeLabel = edge.labels.join('_');
              if (!edgeColorMap[edgeLabel]) {
                  edgeColorMap[edgeLabel] = getRandomColor();
              }
              return {
                  from: edge.from,
                  to: edge.to,
                  color: edgeColorMap[edgeLabel],
                  label: createLabelText(edge),
                  title: createTitleText(edge)
              }
          })
  
          nodeDataSet.add(graph.nodes.filter((n) => !nodes._data.has(n.id)).map((node) => {
              const groupName = node.labels.join('_');
              groups.add(groupName);
              return {
                  id: node.id,
                  group: groupName,
                  label: createLabelText(node),
                  shape: 'dot',
                  size: nodeSize,
                  title: createTitleText(node)
              };
          }));
  
          edgeDataSet.add(newEdges);
          network.stabilize(5);
      }
  
  
      function handleFileSelect(evt) {
          let files = evt.target.files; // FileList object
          // use the 1st file from the list
          const f = files[0];
          let reader = new FileReader();
  
  
          // Closure to capture the file information.
          reader.onload = (function (theFile) {
              return function (e) {
                  q('#graph-input').value = e.target.result;
                  updateGraph();
              };
          })(f);
          // Read in the image file as a data URL.
          reader.readAsText(f);
      };
  
      document.addEventListener('mousemove', (e) => { 
        clickedPosition = {x: e.clientX, y: e.clientY}; 
      });
      q('#pgfile').addEventListener('change', handleFileSelect, false);
      q('#graph-input').value =
          `node1 :You name:"your name"
  node2 :Graph type:"graph"
  node1 -> node2 :Hello! on:"today"`;
      q('#url-input').value = 'localhost:3000';
      // retrieveGraph();
      /*  updateGraph(); */
      
      q('#graph-input').addEventListener('input', () => {
          clearTimeout(timerId);
          localMode = true;
          timerId = setTimeout(updateGraph, 1000);
      });
      
      q('#search-input').addEventListener('keyup', () => {
        if (event.keyCode == 13) // Enter
          q('#search-button').click(); 
      });
  
      q('#search-button').addEventListener('click', () => {
        searchGraph();
      });
  
      q('#url-input').addEventListener('change', () => {
          clearTimeout(timerId);
          localMode = false;
          timerId = setTimeout(retrieveGraph, 1000);
      });
      
      function destroy() {
          if (network !== null) {
              network.destroy();
              network = null;
          }
      }
  
      function clearPopUp() {
          document.getElementById("saveButton").onclick = null;
          document.getElementById("cancelButton").onclick = null;
          document.getElementById("network-popUp").style.display = "none";
      }
  
      function cancelEdit(callback) {
          clearPopUp();
      }
      
      
      q('#search-input').value = '情報通信';
      searchGraph();
</script>
</body>
</html>
