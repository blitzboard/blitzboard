(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Blitzboard"] = factory();
	else
		root["Blitzboard"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@iconify/iconify/dist/iconify.min.js":
/*!***********************************************************!*\
  !*** ./node_modules/@iconify/iconify/dist/iconify.min.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
* (c) Iconify
*
* For the full copyright and license information, please view the license.txt or license.gpl.txt
* files at https://github.com/iconify/iconify
*
* Licensed under Apache 2.0 or GPL 2.0 at your option.
* If derivative product is not compatible with one of licenses, you can pick one of licenses.
*
* @license Apache 2.0
* @license GPL 2.0
*/
var Iconify=function(){"use strict";function e(e,n,t){return e(t={path:n,exports:{},require:function(e,n){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}(null==n&&t.path)}},t.exports),t.exports}var n=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.fullIcon=n.iconDefaults=n.minifyProps=n.matchName=void 0,n.matchName=/^[a-z0-9]+(-[a-z0-9]+)*$/,n.minifyProps=["width","height","top","left"],n.iconDefaults=Object.freeze({left:0,top:0,width:16,height:16,rotate:0,vFlip:!1,hFlip:!1}),n.fullIcon=function(e){return Object.assign({},n.iconDefaults,e)}})),t=e((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.mergeIconData=void 0,t.mergeIconData=function(e,t){var r=Object.assign({},e);for(var o in n.iconDefaults){var i=o;if(void 0!==t[i]){var a=t[i];if(void 0===r[i]){r[i]=a;continue}switch(i){case"rotate":r[i]=(r[i]+a)%4;break;case"hFlip":case"vFlip":r[i]=a!==r[i];break;default:r[i]=a}}}return r}})),r=e((function(e,r){Object.defineProperty(r,"__esModule",{value:!0}),r.parseIconSet=void 0;var o=Object.keys(n.iconDefaults);function i(e,n,r,o){void 0===o&&(o=0);var a=e.parent;if(void 0!==n[a])return t.mergeIconData(n[a],e);if(void 0!==r[a]){if(o>2)return null;var c=i(r[a],n,r,o+1);if(c)return t.mergeIconData(c,e)}return null}r.parseIconSet=function(e,t,r){void 0===r&&(r="none");var a=[];if("object"!=typeof e)return"none"!==r&&a;if(e.not_found instanceof Array&&e.not_found.forEach((function(e){t(e,null),"all"===r&&a.push(e)})),"object"!=typeof e.icons)return"none"!==r&&a;var c=Object.create(null);o.forEach((function(n){void 0!==e[n]&&"object"!=typeof e[n]&&(c[n]=e[n])}));var u=e.icons;if(Object.keys(u).forEach((function(e){var r=u[e];"string"==typeof r.body&&(t(e,Object.freeze(Object.assign({},n.iconDefaults,c,r))),a.push(e))})),"object"==typeof e.aliases){var f=e.aliases;Object.keys(f).forEach((function(e){var r=i(f[e],u,f,1);r&&(t(e,Object.freeze(Object.assign({},n.iconDefaults,c,r))),a.push(e))}))}return"none"===r?a.length>0:a}})),o=e((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.validateIcon=t.stringToIcon=void 0;t.stringToIcon=function(e,n,r,o){void 0===o&&(o="");var i=e.split(":");if("@"===e.slice(0,1)){if(i.length<2||i.length>3)return null;o=i.shift().slice(1)}if(i.length>3||!i.length)return null;if(i.length>1){var a=i.pop(),c=i.pop(),u={provider:i.length>0?i[0]:o,prefix:c,name:a};return n&&!t.validateIcon(u)?null:u}var f=i[0],l=f.split("-");if(l.length>1){var s={provider:o,prefix:l.shift(),name:l.join("-")};return n&&!t.validateIcon(s)?null:s}if(r&&""===o){var d={provider:o,prefix:"",name:f};return n&&!t.validateIcon(d,r)?null:d}return null};t.validateIcon=function(e,t){return!!e&&!(""!==e.provider&&!e.provider.match(n.matchName)||!(t&&""===e.prefix||e.prefix.match(n.matchName))||!e.name.match(n.matchName))}})),i=e((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.listIcons=t.getIcon=t.iconExists=t.addIcon=t.addIconSet=t.getStorage=t.newStorage=void 0;var o=Object.create(null);function i(e,n){return{provider:e,prefix:n,icons:Object.create(null),missing:Object.create(null)}}function a(e,n){void 0===o[e]&&(o[e]=Object.create(null));var t=o[e];return void 0===t[n]&&(t[n]=i(e,n)),t[n]}t.newStorage=i,t.getStorage=a,t.addIconSet=function(e,n,t){void 0===t&&(t="none");var o=Date.now();return r.parseIconSet(n,(function(n,t){null===t?e.missing[n]=o:e.icons[n]=t}),t)},t.addIcon=function(e,t,r){try{if("string"==typeof r.body)return e.icons[t]=Object.freeze(n.fullIcon(r)),!0}catch(e){}return!1},t.iconExists=function(e,n){return void 0!==e.icons[n]},t.getIcon=function(e,n){var t=e.icons[n];return void 0===t?null:t},t.listIcons=function(e,n){var t=[];return("string"==typeof e?[e]:Object.keys(o)).forEach((function(e){("string"==typeof e&&"string"==typeof n?[n]:void 0===o[e]?[]:Object.keys(o[e])).forEach((function(n){var r=a(e,n),o=Object.keys(r.icons).map((function(t){return(""!==e?"@"+e+":":"")+n+":"+t}));t=t.concat(o)}))})),t}})),a=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.storageFunctions=n.addCollection=n.addIcon=n.getIconData=n.allowSimpleNames=void 0;var t=!1;function a(e){var n="string"==typeof e?o.stringToIcon(e,!0,t):e;return n?i.getIcon(i.getStorage(n.provider,n.prefix),n.name):null}function c(e,n){var r=o.stringToIcon(e,!0,t);if(!r)return!1;var a=i.getStorage(r.provider,r.prefix);return i.addIcon(a,r.name,n)}function u(e,n){if("object"!=typeof e)return!1;if("string"!=typeof n&&(n="string"==typeof e.provider?e.provider:""),t&&""===n&&("string"!=typeof e.prefix||""===e.prefix)){var a=!1;return r.parseIconSet(e,(function(e,n){null!==n&&c(e,n)&&(a=!0)})),a}if("string"!=typeof e.prefix||!o.validateIcon({provider:n,prefix:e.prefix,name:"a"}))return!1;var u=i.getStorage(n,e.prefix);return!!i.addIconSet(u,e)}n.allowSimpleNames=function(e){return"boolean"==typeof e&&(t=e),t},n.getIconData=a,n.addIcon=c,n.addCollection=u,n.storageFunctions={iconExists:function(e){return null!==a(e)},getIcon:function(e){var n=a(e);return n?Object.assign({},n):null},listIcons:i.listIcons,addIcon:c,addCollection:u}})),c=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.replaceIDs=void 0;var t=/\sid="(\S+)"/g,r="([^A-Za-z0-9_-])";var o="IconifyId-"+Date.now().toString(16)+"-"+(16777216*Math.random()|0).toString(16)+"-",i=0;n.replaceIDs=function(e,n){void 0===n&&(n=o);for(var a,c=[];a=t.exec(e);)c.push(a[1]);return c.length?(c.forEach((function(t){var o="function"==typeof n?n():n+i++;e=e.replace(new RegExp(r+"("+(t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")+")")+r,"g"),"$1"+o+"$3")})),e):e}})),u=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.calculateSize=void 0;var t=/(-?[0-9.]*[0-9]+[0-9.]*)/g,r=/^-?[0-9.]*[0-9]+[0-9.]*$/g;n.calculateSize=function(e,n,o){if(1===n)return e;if(o=void 0===o?100:o,"number"==typeof e)return Math.ceil(e*n*o)/o;if("string"!=typeof e)return e;var i=e.split(t);if(null===i||!i.length)return e;for(var a=[],c=i.shift(),u=r.test(c);;){if(u){var f=parseFloat(c);isNaN(f)?a.push(c):a.push(Math.ceil(f*n*o)/o)}else a.push(c);if(void 0===(c=i.shift()))return a.join("");u=!u}}})),f=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.mergeCustomisations=n.defaults=void 0,n.defaults=Object.freeze({inline:!1,width:null,height:null,hAlign:"center",vAlign:"middle",slice:!1,hFlip:!1,vFlip:!1,rotate:0}),n.mergeCustomisations=function(e,n){var t={};for(var r in e){var o=r;if(t[o]=e[o],void 0!==n[o]){var i=n[o];switch(o){case"inline":case"slice":"boolean"==typeof i&&(t[o]=i);break;case"hFlip":case"vFlip":!0===i&&(t[o]=!t[o]);break;case"hAlign":case"vAlign":"string"==typeof i&&""!==i&&(t[o]=i);break;case"width":case"height":("string"==typeof i&&""!==i||"number"==typeof i&&i||null===i)&&(t[o]=i);break;case"rotate":"number"==typeof i&&(t[o]+=i)}}}return t}})),l=e((function(e,n){function t(e){var n="";switch(e.hAlign){case"left":n+="xMin";break;case"right":n+="xMax";break;default:n+="xMid"}switch(e.vAlign){case"top":n+="YMin";break;case"bottom":n+="YMax";break;default:n+="YMid"}return n+=e.slice?" slice":" meet"}Object.defineProperty(n,"__esModule",{value:!0}),n.iconToSVG=void 0,n.iconToSVG=function(e,n){var r,o,i={left:e.left,top:e.top,width:e.width,height:e.height},a=e.body;[e,n].forEach((function(e){var n,t=[],r=e.hFlip,o=e.vFlip,c=e.rotate;switch(r?o?c+=2:(t.push("translate("+(i.width+i.left)+" "+(0-i.top)+")"),t.push("scale(-1 1)"),i.top=i.left=0):o&&(t.push("translate("+(0-i.left)+" "+(i.height+i.top)+")"),t.push("scale(1 -1)"),i.top=i.left=0),c<0&&(c-=4*Math.floor(c/4)),c%=4){case 1:n=i.height/2+i.top,t.unshift("rotate(90 "+n+" "+n+")");break;case 2:t.unshift("rotate(180 "+(i.width/2+i.left)+" "+(i.height/2+i.top)+")");break;case 3:n=i.width/2+i.left,t.unshift("rotate(-90 "+n+" "+n+")")}c%2==1&&(0===i.left&&0===i.top||(n=i.left,i.left=i.top,i.top=n),i.width!==i.height&&(n=i.width,i.width=i.height,i.height=n)),t.length&&(a='<g transform="'+t.join(" ")+'">'+a+"</g>")})),null===n.width&&null===n.height?(o="1em",r=u.calculateSize(o,i.width/i.height)):null!==n.width&&null!==n.height?(r=n.width,o=n.height):null!==n.height?(o=n.height,r=u.calculateSize(o,i.width/i.height)):(r=n.width,o=u.calculateSize(r,i.height/i.width)),"auto"===r&&(r=i.width),"auto"===o&&(o=i.height);var c={attributes:{width:r="string"==typeof r?r:r+"",height:o="string"==typeof o?o:o+"",preserveAspectRatio:t(n),viewBox:i.left+" "+i.top+" "+i.width+" "+i.height},body:a};return n.inline&&(c.inline=!0),c}})),s=e((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.builderFunctions=void 0,t.builderFunctions={replaceIDs:c.replaceIDs,calculateSize:u.calculateSize,buildIcon:function(e,t){return l.iconToSVG(n.fullIcon(e),f.mergeCustomisations(f.defaults,t))}}})),d=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.coreModules=void 0,n.coreModules={}})),v=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.storeCache=n.loadCache=n.mock=n.emptyList=n.count=n.config=void 0;var t="iconify2",r="iconify",o="iconify-count",a="iconify-version",c=36e5;n.config={local:!0,session:!0};var u=!1;n.count={local:0,session:0},n.emptyList={local:[],session:[]};var f="undefined"==typeof window?{}:window;function l(e){var t=e+"Storage";try{if(f&&f[t]&&"number"==typeof f[t].length)return f[t]}catch(e){}return n.config[e]=!1,null}function s(e,t,r){try{return e.setItem(o,r+""),n.count[t]=r,!0}catch(e){return!1}}function d(e){var n=e.getItem(o);if(n){var t=parseInt(n);return t||0}return 0}n.mock=function(e){u=!1,f=e};n.loadCache=function(){if(!u){u=!0;var e=Math.floor(Date.now()/c)-168;for(var o in n.config)f(o)}function f(o){var c=l(o);if(c){var u=function(n){var t=r+n,o=c.getItem(t);if("string"!=typeof o)return!1;var a=!0;try{var u=JSON.parse(o);if("object"!=typeof u||"number"!=typeof u.cached||u.cached<e||"string"!=typeof u.provider||"object"!=typeof u.data||"string"!=typeof u.data.prefix)a=!1;else{var f=u.provider,l=u.data.prefix,s=i.getStorage(f,l);a=i.addIconSet(s,u.data)}}catch(e){a=!1}return a||c.removeItem(t),a};try{var f=c.getItem(a);if(f!==t)return f&&function(e){try{for(var n=d(e),t=0;t<n;t++)e.removeItem(r+t)}catch(e){}}(c),void function(e,n){try{e.setItem(a,t)}catch(e){}s(e,n,0)}(c,o);for(var v=d(c),p=v-1;p>=0;p--)u(p)||(p===v-1?v--:n.emptyList[o].push(p));s(c,o,v)}catch(e){}}}};n.storeCache=function(e,t){function o(o){if(!n.config[o])return!1;var i=l(o);if(!i)return!1;var a=n.emptyList[o].shift();if(void 0===a&&!s(i,o,(a=n.count[o])+1))return!1;try{var u={cached:Math.floor(Date.now()/c),provider:e,data:t};i.setItem(r+a,JSON.stringify(u))}catch(e){return!1}return!0}u||n.loadCache(),o("local")||o("session")}})),p=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.toggleBrowserCache=void 0,n.toggleBrowserCache=function(e,n){switch(e){case"local":case"session":v.config[e]=n;break;case"all":for(var t in v.config)v.config[t]=n}}})),h=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.defaultConfig=void 0,n.defaultConfig={resources:[],index:0,timeout:2e3,rotate:750,random:!1,dataAfterTimeout:!1}})),g=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.sendQuery=void 0,n.sendQuery=function(e,n,t,r,o){var i,a=e.resources.length,c=e.random?Math.floor(Math.random()*a):e.index;if(e.random){var u=e.resources.slice(0);for(i=[];u.length>1;){var f=Math.floor(Math.random()*u.length);i.push(u[f]),u=u.slice(0,f).concat(u.slice(f+1))}i=i.concat(u)}else i=e.resources.slice(c).concat(e.resources.slice(0,c));var l=Date.now(),s="pending",d=0,v=void 0,p=null,h=[],g=[];function m(){p&&(clearTimeout(p),p=null)}function b(){"pending"===s&&(s="aborted"),m(),h.forEach((function(e){e.abort&&e.abort(),"pending"===e.status&&(e.status="aborted")})),h=[]}function y(e,n){n&&(g=[]),"function"==typeof e&&g.push(e)}function I(){return{startTime:l,payload:n,status:s,queriesSent:d,queriesPending:h.length,subscribe:y,abort:b}}function j(){s="failed",g.forEach((function(e){e(void 0,v)}))}function x(){h=h.filter((function(e){return"pending"===e.status&&(e.status="aborted"),e.abort&&e.abort(),!1}))}function O(){if("pending"===s){m();var r=i.shift();if(void 0!==r){var a={getQueryStatus:I,status:"pending",resource:r,done:function(n,t){!function(n,t,r){var a=void 0===t;switch(h=h.filter((function(e){return e!==n})),s){case"pending":break;case"failed":if(a||!e.dataAfterTimeout)return;break;default:return}if(a)return void 0!==r&&(v=r),void(h.length||(i.length?O():j()));if(m(),x(),o&&!e.random){var c=e.resources.indexOf(n.resource);-1!==c&&c!==e.index&&o(c)}s="completed",g.forEach((function(e){e(t)}))}(a,n,t)}};h.push(a),d++;var c="function"==typeof e.rotate?e.rotate(d,l):e.rotate;p=setTimeout(O,c),t(r,n,a)}else{if(h.length){var u="function"==typeof e.timeout?e.timeout(l):e.timeout;if(u)return void(p=setTimeout((function(){m(),"pending"===s&&(x(),j())}),u))}j()}}}return"function"==typeof r&&g.push(r),setTimeout(O),I}})),m=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.initRedundancy=void 0,n.initRedundancy=function(e){var n=function(e){if(!("object"==typeof e&&"object"==typeof e.resources&&e.resources instanceof Array&&e.resources.length))throw new Error("Invalid Reduncancy configuration");var n,t=Object.create(null);for(n in h.defaultConfig)void 0!==e[n]?t[n]=e[n]:t[n]=h.defaultConfig[n];return t}(e),t=[];function r(){t=t.filter((function(e){return"pending"===e().status}))}return{query:function(e,o,i){var a=g.sendQuery(n,e,o,(function(e,n){r(),i&&i(e,n)}),(function(e){n.index=e}));return t.push(a),a},find:function(e){var n=t.find((function(n){return e(n)}));return void 0!==n?n:null},setIndex:function(e){n.index=e},getIndex:function(){return n.index},cleanup:r}}})),b=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.sortIcons=void 0,n.sortIcons=function(e){var n={loaded:[],missing:[],pending:[]},t=Object.create(null);e.sort((function(e,n){return e.provider!==n.provider?e.provider.localeCompare(n.provider):e.prefix!==n.prefix?e.prefix.localeCompare(n.prefix):e.name.localeCompare(n.name)}));var r={provider:"",prefix:"",name:""};return e.forEach((function(e){if(r.name!==e.name||r.prefix!==e.prefix||r.provider!==e.provider){r=e;var o=e.provider,a=e.prefix,c=e.name;void 0===t[o]&&(t[o]=Object.create(null));var u=t[o];void 0===u[a]&&(u[a]=i.getStorage(o,a));var f=u[a],l={provider:o,prefix:a,name:c};(void 0!==f.icons[c]?n.loaded:""===a||void 0!==f.missing[c]?n.missing:n.pending).push(l)}})),n}})),y=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.storeCallback=n.updateCallbacks=n.callbacks=void 0,n.callbacks=Object.create(null);var t=Object.create(null);function r(e,t){e.forEach((function(e){var r=e.provider;if(void 0!==n.callbacks[r]){var o=n.callbacks[r],i=e.prefix,a=o[i];a&&(o[i]=a.filter((function(e){return e.id!==t})))}}))}n.updateCallbacks=function(e,o){void 0===t[e]&&(t[e]=Object.create(null));var a=t[e];a[o]||(a[o]=!0,setTimeout((function(){if(a[o]=!1,void 0!==n.callbacks[e]&&void 0!==n.callbacks[e][o]){var t=n.callbacks[e][o].slice(0);if(t.length){var c=i.getStorage(e,o),u=!1;t.forEach((function(n){var t=n.icons,i=t.pending.length;t.pending=t.pending.filter((function(n){if(n.prefix!==o)return!0;var r=n.name;if(void 0!==c.icons[r])t.loaded.push({provider:e,prefix:o,name:r});else{if(void 0===c.missing[r])return u=!0,!0;t.missing.push({provider:e,prefix:o,name:r})}return!1})),t.pending.length!==i&&(u||r([{provider:e,prefix:o}],n.id),n.callback(t.loaded.slice(0),t.missing.slice(0),t.pending.slice(0),n.abort))}))}}})))};var o=0;n.storeCallback=function(e,t,i){var a=o++,c=r.bind(null,i,a);if(!t.pending.length)return c;var u={id:a,icons:t,callback:e,abort:c};return i.forEach((function(e){var t=e.provider,r=e.prefix;void 0===n.callbacks[t]&&(n.callbacks[t]=Object.create(null));var o=n.callbacks[t];void 0===o[r]&&(o[r]=[]),o[r].push(u)})),c}})),I=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.getAPIModule=n.setAPIModule=void 0;var t=Object.create(null);n.setAPIModule=function(e,n){t[e]=n},n.getAPIModule=function(e){return void 0===t[e]?t[""]:t[e]}})),j=e((function(e,n){function t(e){var n;if("string"==typeof e.resources)n=[e.resources];else if(!((n=e.resources)instanceof Array&&n.length))return null;return{resources:n,path:void 0===e.path?"/":e.path,maxURL:e.maxURL?e.maxURL:500,rotate:e.rotate?e.rotate:750,timeout:e.timeout?e.timeout:5e3,random:!0===e.random,index:e.index?e.index:0,dataAfterTimeout:!1!==e.dataAfterTimeout}}Object.defineProperty(n,"__esModule",{value:!0}),n.getAPIConfig=n.setAPIConfig=void 0;for(var r=Object.create(null),o=["https://api.simplesvg.com","https://api.unisvg.com"],i=[];o.length>0;)1===o.length||Math.random()>.5?i.push(o.shift()):i.push(o.pop());r[""]=t({resources:["https://api.iconify.design"].concat(i)}),n.setAPIConfig=function(e,n){var o=t(n);return null!==o&&(r[e]=o,!0)};n.getAPIConfig=function(e){return r[e]}})),x=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.getProviders=n.listToIcons=void 0,n.listToIcons=function(e,n,t){void 0===n&&(n=!0),void 0===t&&(t=!1);var r=[];return e.forEach((function(e){var i="string"==typeof e?o.stringToIcon(e,!1,t):e;n&&!o.validateIcon(i,t)||r.push({provider:i.provider,prefix:i.prefix,name:i.name})})),r},n.getProviders=function(e){var n=Object.create(null);return e.forEach((function(e){n[e.provider]=!0})),Object.keys(n)}})),O=e((function(e,n){function t(){}Object.defineProperty(n,"__esModule",{value:!0}),n.API=n.getRedundancyCache=void 0;var r=Object.create(null),o=Object.create(null),c=Object.create(null),u=Object.create(null),f=Object.create(null);function l(e){if(void 0===f[e]){var n=j.getAPIConfig(e);if(!n)return;var t={config:n,redundancy:m.initRedundancy(n)};f[e]=t}return f[e]}n.getRedundancyCache=l;var s=Object.create(null);function v(e,n,t){function a(){var t=(""===e?"":"@"+e+":")+n,r=Math.floor(Date.now()/6e4);s[t]<r&&(s[t]=r,console.error('Unable to retrieve icons for "'+t+'" because API is not configured properly.'))}void 0===o[e]&&(o[e]=Object.create(null));var f=o[e];void 0===u[e]&&(u[e]=Object.create(null));var v=u[e];void 0===r[e]&&(r[e]=Object.create(null));var p,h=r[e];void 0===f[n]?f[n]=t:f[n]=f[n].concat(t).sort(),v[n]||(v[n]=!0,setTimeout((function(){v[n]=!1;var t=f[n];delete f[n];var r=I.getAPIModule(e);if(r){if(void 0===p){var o=l(e);if(void 0===o)return void a();p=o}r.prepare(e,n,t).forEach((function(t){p.redundancy.query(t,r.send,(function(r,o){var a=i.getStorage(e,n);if("object"!=typeof r){if(404!==o)return;var u=Date.now();t.icons.forEach((function(e){a.missing[e]=u}))}else try{var f=i.addIconSet(a,r,"all");if("boolean"==typeof f)return;var l=h[n];f.forEach((function(e){delete l[e]})),d.coreModules.cache&&d.coreModules.cache(e,r)}catch(e){console.error(e)}!function(e,n){void 0===c[e]&&(c[e]=Object.create(null));var t=c[e];t[n]||(t[n]=!0,setTimeout((function(){t[n]=!1,y.updateCallbacks(e,n)})))}(e,n)}))}))}else a()})))}n.API={isPending:function(e){return void 0!==r[e.provider]&&void 0!==r[e.provider][e.prefix]&&void 0!==r[e.provider][e.prefix][e.name]},loadIcons:function(e,n){var o=x.listToIcons(e,!0,a.allowSimpleNames()),i=b.sortIcons(o);if(!i.pending.length){var c=!0;return n&&setTimeout((function(){c&&n(i.loaded,i.missing,i.pending,t)})),function(){c=!1}}var u,f,l=Object.create(null),s=[];i.pending.forEach((function(e){var n=e.provider,t=e.prefix;if(t!==f||n!==u){u=n,f=t,s.push({provider:n,prefix:t}),void 0===r[n]&&(r[n]=Object.create(null));var o=r[n];void 0===o[t]&&(o[t]=Object.create(null)),void 0===l[n]&&(l[n]=Object.create(null));var i=l[n];void 0===i[t]&&(i[t]=[])}}));var d=Date.now();return i.pending.forEach((function(e){var n=e.provider,t=e.prefix,o=e.name,i=r[n][t];void 0===i[o]&&(i[o]=d,l[n][t].push(o))})),s.forEach((function(e){var n=e.provider,t=e.prefix;l[n][t].length&&v(n,t,l[n][t])})),n?y.storeCallback(n,i,s):t}}})),P=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.APIInternalFunctions=n.APIFunctions=void 0,n.APIFunctions={loadIcons:O.API.loadIcons,addAPIProvider:j.setAPIConfig},n.APIInternalFunctions={getAPI:O.getRedundancyCache,getAPIConfig:j.getAPIConfig,setAPIModule:I.setAPIModule}})),w=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.getAPIModule=void 0;var t=null,r="{prefix}.js?icons={icons}&callback={callback}",o=Object.create(null),i=Object.create(null);function a(){if(null===t){var e=self,n="Iconify",o=".cb";if(void 0===e[n])o="",void 0===e[n="IconifyJSONP"]&&(e[n]=Object.create(null)),t=e[n];else{var i=e[n];void 0===i.cb&&(i.cb=Object.create(null)),t=i.cb}r=r.replace("{callback}",n+o+".{cb}")}return t}n.getAPIModule=function(e){return{prepare:function(n,t,c){var u=[],f=o[n+":"+t];void 0===f&&(f=function(n,t){var c,u=e(n);if(!u)return 0;if(u.maxURL){var f=0;u.resources.forEach((function(e){var n=e;f=Math.max(f,n.length)})),a(),c=u.maxURL-f-u.path.length-r.replace("{provider}",n).replace("{prefix}",t).replace("{icons}","").length-3}else c=0;var l=n+":"+t;return i[l]=u.path,o[l]=c,c}(n,t));var l={provider:n,prefix:t,icons:[]},s=0;return c.forEach((function(e,r){(s+=e.length+1)>=f&&r>0&&(u.push(l),l={provider:n,prefix:t,icons:[]},s=e.length),l.icons.push(e)})),u.push(l),u},send:function(e,n,t){for(var o=n.provider,c=n.prefix,u=n.icons.join(","),f=o+":"+c,l=c.split("-").shift().slice(0,3),s=a(),d=function(e){var n,t=0;for(n=e.length-1;n>=0;n--)t+=e.charCodeAt(n);return t%999}(o+":"+e+":"+c+":"+u);void 0!==s[l+d];)d++;var v=l+d,p=i[f]+r.replace("{provider}",o).replace("{prefix}",c).replace("{icons}",u).replace("{cb}",v);s[v]=function(e){delete s[v],t.done(e)};var h=e+p,g=document.createElement("script");g.type="text/javascript",g.async=!0,g.src=h,document.head.appendChild(g)}}}})),M=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.getAPIModule=n.setFetch=void 0;var t="{prefix}.json?icons={icons}",r=Object.create(null),o=Object.create(null),i=null;try{i=fetch}catch(e){}n.setFetch=function(e){i=e};n.getAPIModule=function(e){return{prepare:function(n,i,a){var c=[],u=r[i];void 0===u&&(u=function(n,i){var a,c=e(n);if(!c)return 0;if(c.maxURL){var u=0;c.resources.forEach((function(e){var n=e;u=Math.max(u,n.length)})),a=c.maxURL-u-c.path.length-t.replace("{provider}",n).replace("{prefix}",i).replace("{icons}","").length}else a=0;var f=n+":"+i;return o[f]=c.path,r[f]=a,a}(n,i));var f={provider:n,prefix:i,icons:[]},l=0;return a.forEach((function(e,t){(l+=e.length+1)>=u&&t>0&&(c.push(f),f={provider:n,prefix:i,icons:[]},l=e.length),f.icons.push(e)})),c.push(f),c},send:function(e,n,r){var a=n.provider,c=n.prefix,u=n.icons.join(","),f=o[a+":"+c]+t.replace("{provider}",a).replace("{prefix}",c).replace("{icons}",u);i?i(e+f).then((function(e){if(200===e.status)return e.json();r.done(void 0,e.status)})).then((function(e){"object"==typeof e&&null!==e&&r.done(e)})).catch((function(e){r.done(void 0,e.errno)})):r.done(void 0,424)}}}})),A="iconifyFinder"+Date.now(),S="iconifyData"+Date.now();function _(e,n,t,r){var o;try{o=document.createElement("span")}catch(e){return r?"":null}var i=l.iconToSVG(t,f.mergeCustomisations(f.defaults,n)),a=e.element,u=e.finder,s=e.name,d=a?a.getAttribute("class"):"",v=u?u.classFilter(d?d.split(/\s+/):[]):[],p='<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="'+("iconify iconify--"+s.prefix+(""===s.provider?"":" iconify--"+s.provider)+(v.length?" "+v.join(" "):""))+'">'+c.replaceIDs(i.body)+"</svg>";o.innerHTML=p;var h=o.childNodes[0],g=h.style,m=i.attributes;if(Object.keys(m).forEach((function(e){h.setAttribute(e,m[e])})),i.inline&&(g.verticalAlign="-0.125em"),a){for(var b=a.attributes,y=0;y<b.length;y++){var I=b.item(y);if(I){var j=I.name;if("class"!==j&&"style"!==j&&void 0===m[j])try{h.setAttribute(j,I.value)}catch(e){}}}for(var x=a.style,O=0;O<x.length;O++){var P=x[O];g[P]=x[P]}}if(u){var w={name:s,status:"loaded",customisations:n};h[S]=w,h[A]=u}var M=r?o.innerHTML:h;return a&&a.parentNode?a.parentNode.replaceChild(h,a):o.removeChild(h),M}var E=[];function k(e){for(var n=0;n<E.length;n++){var t=E[n];if(("function"==typeof t.node?t.node():t.node)===e)return t}}function C(e,n){void 0===n&&(n=!1);var t=k(e);return t?(t.temporary&&(t.temporary=n),t):(t={node:e,temporary:n},E.push(t),t)}function F(){return E}var T=null,D={childList:!0,subtree:!0,attributes:!0};function N(e){if(e.observer){var n=e.observer;n.pendingScan||(n.pendingScan=setTimeout((function(){delete n.pendingScan,T&&T(e)})))}}function L(e,n){if(e.observer){var t=e.observer;if(!t.pendingScan)for(var r=0;r<n.length;r++){var o=n[r];if(o.addedNodes&&o.addedNodes.length>0||"attributes"===o.type&&void 0!==o.target[A])return void(t.paused||N(e))}}}function z(e,n){e.observer.instance.observe(n,D)}function R(e){var n=e.observer;if(!n||!n.instance){var t="function"==typeof e.node?e.node():e.node;t&&(n||(n={paused:0},e.observer=n),n.instance=new MutationObserver(L.bind(null,e)),z(e,t),n.paused||N(e))}}function q(){F().forEach(R)}function U(e){if(e.observer){var n=e.observer;n.pendingScan&&(clearTimeout(n.pendingScan),delete n.pendingScan),n.instance&&(n.instance.disconnect(),delete n.instance)}}function V(e){var n=null!==T;T!==e&&(T=e,n&&F().forEach(U)),n?q():function(e){var n=document;"complete"===n.readyState||"loading"!==n.readyState&&!n.documentElement.doScroll?e():(n.addEventListener("DOMContentLoaded",e),window.addEventListener("load",e))}(q)}function G(e){(e?[e]:F()).forEach((function(e){if(e.observer){var n=e.observer;if(n.paused++,!(n.paused>1)&&n.instance)n.instance.disconnect()}else e.observer={paused:1}}))}function $(e){(e?[e]:F()).forEach((function(e){if(e.observer){var n=e.observer;if(n.paused&&(n.paused--,!n.paused)){var t="function"==typeof e.node?e.node():e.node;if(!t)return;n.instance?z(e,t):R(e)}}else R(e)}))}function B(e,n){void 0===n&&(n=!1);var t=C(e,n);return R(t),t}function Q(e){var n=k(e);n&&(U(n),function(e){E=E.filter((function(n){var t="function"==typeof n.node?n.node():n.node;return e!==t}))}(e))}var H=[];function J(e){return"string"==typeof e&&(e=o.stringToIcon(e)),null!==e&&o.validateIcon(e)?e:null}function Y(e){var n=[];H.forEach((function(t){var r=t.find(e);Array.prototype.forEach.call(r,(function(e){var r=e;if(void 0===r[A]||r[A]===t){var o=J(t.name(r));if(null!==o){r[A]=t;var i={element:r,finder:t,name:o};n.push(i)}}}))}));var t=e.querySelectorAll("svg.iconify");return Array.prototype.forEach.call(t,(function(e){var t=e,r=t[A],o=t[S];if(r&&o){var i=J(r.name(t));if(null!==i){var a,c=!1;if(i.prefix!==o.name.prefix||i.name!==o.name.name?c=!0:(a=r.customisations(t),function(e,n){var t=Object.keys(e),r=Object.keys(n);if(t.length!==r.length)return!1;for(var o=0;o<t.length;o++){var i=t[o];if(n[i]!==e[i])return!1}return!0}(o.customisations,a)||(c=!0)),c){var u={element:t,finder:r,name:i,customisations:a};n.push(u)}}}})),n}var Z=!1;function K(){Z||(Z=!0,setTimeout((function(){Z&&(Z=!1,W())})))}function W(e,n){void 0===n&&(n=!1),Z=!1;var t=Object.create(null);if((e?[e]:F()).forEach((function(e){var r="function"==typeof e.node?e.node():e.node;if(r&&r.querySelectorAll){var o=!1,a=!1;Y(r).forEach((function(n){var r,c,u=n.element,f=n.name,l=f.provider,s=f.prefix,v=f.name,p=u[S];if(void 0!==p&&(r=p.name,c=f,null!==r&&null!==c&&r.name===c.name&&r.prefix===c.prefix))switch(p.status){case"missing":return;case"loading":if(d.coreModules.api&&d.coreModules.api.isPending({provider:l,prefix:s,name:v}))return void(o=!0)}var h=i.getStorage(l,s);if(void 0===h.icons[v]){if(h.missing[v])return p={name:f,status:"missing",customisations:{}},void(u[S]=p);if(d.coreModules.api&&!d.coreModules.api.isPending({provider:l,prefix:s,name:v})){void 0===t[l]&&(t[l]=Object.create(null));var g=t[l];void 0===g[s]&&(g[s]=Object.create(null)),g[s][v]=!0}p={name:f,status:"loading",customisations:{}},u[S]=p,o=!0}else{!a&&e.observer&&(G(e),a=!0);var m=void 0!==n.customisations?n.customisations:n.finder.customisations(u);_(n,m,i.getIcon(h,v))}})),e.temporary&&!o?Q(r):n&&o?B(r,!0):a&&e.observer&&$(e)}})),d.coreModules.api){var r=d.coreModules.api;Object.keys(t).forEach((function(e){var n=t[e];Object.keys(n).forEach((function(t){r.loadIcons(Object.keys(n[t]).map((function(n){return{provider:e,prefix:t,name:n}})),K)}))}))}}var X=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.rotateFromString=void 0,n.rotateFromString=function(e){var n=e.replace(/^-?[0-9.]*/,"");function t(e){for(;e<0;)e+=4;return e%4}if(""===n){var r=parseInt(e);return isNaN(r)?0:t(r)}if(n!==e){var o=0;switch(n){case"%":o=25;break;case"deg":o=90}if(o){var i=parseFloat(e.slice(0,e.length-n.length));return isNaN(i)?0:(i/=o)%1==0?t(i):0}}return 0}})),ee=e((function(e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.alignmentFromString=n.flipFromString=void 0;var t=/[\s,]+/;n.flipFromString=function(e,n){n.split(t).forEach((function(n){switch(n.trim()){case"horizontal":e.hFlip=!0;break;case"vertical":e.vFlip=!0}}))},n.alignmentFromString=function(e,n){n.split(t).forEach((function(n){var t=n.trim();switch(t){case"left":case"center":case"right":e.hAlign=t;break;case"top":case"middle":case"bottom":e.vAlign=t;break;case"slice":case"crop":e.slice=!0;break;case"meet":e.slice=!1}}))}}));function ne(e,n){return e.hasAttribute(n)}function te(e,n){return e.getAttribute(n)}var re=["inline","hFlip","vFlip"],oe=["width","height"],ie="iconify-inline",ae={find:function(e){return e.querySelectorAll("i.iconify, span.iconify, i.iconify-inline, span.iconify-inline")},name:function(e){return ne(e,"data-icon")?te(e,"data-icon"):null},customisations:function(e,n){void 0===n&&(n={inline:!1});var t=n,r=e.getAttribute("class");if(-1!==(r?r.split(/\s+/):[]).indexOf(ie)&&(t.inline=!0),ne(e,"data-rotate")){var o=X.rotateFromString(te(e,"data-rotate"));o&&(t.rotate=o)}return ne(e,"data-flip")&&ee.flipFromString(t,te(e,"data-flip")),ne(e,"data-align")&&ee.alignmentFromString(t,te(e,"data-align")),re.forEach((function(n){if(ne(e,"data-"+n)){var r=function(e,n){var t=e.getAttribute(n);return t===n||"true"===t||""!==t&&"false"!==t&&null}(e,"data-"+n);"boolean"==typeof r&&(t[n]=r)}})),oe.forEach((function(n){if(ne(e,"data-"+n)){var r=te(e,"data-"+n);""!==r&&(t[n]=r)}})),t},classFilter:function(e){var n=[];return e.forEach((function(e){"iconify"!==e&&""!==e&&"iconify--"!==e.slice(0,9)&&n.push(e)})),n}};function ce(e,n,t){var r=a.getIconData(e);return r?_({name:o.stringToIcon(e)},f.mergeCustomisations(f.defaults,"object"==typeof n?n:{}),r,t):null}var ue={getVersion:function(){return"2.0.4"},renderSVG:function(e,n){return ce(e,n,!1)},renderHTML:function(e,n){return ce(e,n,!0)},renderIcon:function(e,n){var t=a.getIconData(e);if(!t)return null;var r=f.mergeCustomisations(f.defaults,"object"==typeof n?n:{});return l.iconToSVG(t,r)},scan:function(e){e?function(e){var n=k(e);n?W(n):W({node:e,temporary:!0},!0)}(e):W()},observe:function(e){B(e)},stopObserving:function(e){Q(e)},pauseObserver:function(e){if(e){var n=k(e);n&&G(n)}else G()},resumeObserver:function(e){if(e){var n=k(e);n&&$(n)}else $()}};if("undefined"!=typeof document&&"undefined"!=typeof window){!function(){if(document.documentElement)return C(document.documentElement);E.push({node:function(){return document.documentElement}})}(),function(e){-1===H.indexOf(e)&&H.push(e)}(ae);var fe=window;if(void 0!==fe.IconifyPreload){var le=fe.IconifyPreload,se="Invalid IconifyPreload syntax.";"object"==typeof le&&null!==le&&(le instanceof Array?le:[le]).forEach((function(e){try{("object"!=typeof e||null===e||e instanceof Array||"object"!=typeof e.icons||"string"!=typeof e.prefix||!a.storageFunctions.addCollection(e))&&console.error(se)}catch(e){console.error(se)}}))}setTimeout((function(){V(W),W()}))}var de={enableCache:function(e,n){return p.toggleBrowserCache(e,!1!==n)},disableCache:function(e){return p.toggleBrowserCache(e,!0)}},ve={_api:P.APIInternalFunctions};[a.storageFunctions,s.builderFunctions,ue,de,P.APIFunctions].forEach((function(e){for(var n in e)ve[n]=e[n]})),d.coreModules.api=O.API;var pe=M.getAPIModule;try{"undefined"!=typeof document&&"undefined"!=typeof window&&(pe="function"==typeof fetch&&"function"==typeof Promise?M.getAPIModule:w.getAPIModule)}catch(se){}if(I.setAPIModule("",pe(j.getAPIConfig)),ve._api.setFetch=function(e){M.setFetch(e),pe!==M.getAPIModule&&(pe=M.getAPIModule,I.setAPIModule("",pe(j.getAPIConfig)))},"undefined"!=typeof document&&"undefined"!=typeof window){d.coreModules.cache=v.storeCache,v.loadCache();var he=window;if(void 0!==he.IconifyProviders){var ge=he.IconifyProviders;if("object"==typeof ge&&null!==ge)for(var me in ge){var be="IconifyProviders["+me+"] is invalid.";try{var ye=ge[me];if("object"!=typeof ye||!ye||void 0===ye.resources)continue;j.setAPIConfig(me,ye)||console.error(be)}catch(e){console.error(be)}}}}return ve}();try{void 0===self.Iconify&&(self.Iconify=Iconify)}catch(e){}if(true)try{exports.__esModule=!0,exports["default"]=Iconify}catch(e){}


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/leaflet/dist/leaflet.css":
/*!*************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/leaflet/dist/leaflet.css ***!
  \*************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! images/layers.png */ "./node_modules/leaflet/dist/images/layers.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! images/layers-2x.png */ "./node_modules/leaflet/dist/images/layers-2x.png"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(/*! images/marker-icon.png */ "./node_modules/leaflet/dist/images/marker-icon.png"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* required styles */\r\n\r\n.leaflet-pane,\r\n.leaflet-tile,\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow,\r\n.leaflet-tile-container,\r\n.leaflet-pane > svg,\r\n.leaflet-pane > canvas,\r\n.leaflet-zoom-box,\r\n.leaflet-image-layer,\r\n.leaflet-layer {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\t}\r\n.leaflet-container {\r\n\toverflow: hidden;\r\n\t}\r\n.leaflet-tile,\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow {\r\n\t-webkit-user-select: none;\r\n\t   -moz-user-select: none;\r\n\t        user-select: none;\r\n\t  -webkit-user-drag: none;\r\n\t}\r\n/* Prevents IE11 from highlighting tiles in blue */\r\n.leaflet-tile::selection {\r\n\tbackground: transparent;\r\n}\r\n/* Safari renders non-retina tile on retina better with this, but Chrome is worse */\r\n.leaflet-safari .leaflet-tile {\r\n\timage-rendering: -webkit-optimize-contrast;\r\n\t}\r\n/* hack that prevents hw layers \"stretching\" when loading new tiles */\r\n.leaflet-safari .leaflet-tile-container {\r\n\twidth: 1600px;\r\n\theight: 1600px;\r\n\t-webkit-transform-origin: 0 0;\r\n\t}\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow {\r\n\tdisplay: block;\r\n\t}\r\n/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */\r\n/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */\r\n.leaflet-container .leaflet-overlay-pane svg,\r\n.leaflet-container .leaflet-marker-pane img,\r\n.leaflet-container .leaflet-shadow-pane img,\r\n.leaflet-container .leaflet-tile-pane img,\r\n.leaflet-container img.leaflet-image-layer,\r\n.leaflet-container .leaflet-tile {\r\n\tmax-width: none !important;\r\n\tmax-height: none !important;\r\n\t}\r\n\r\n.leaflet-container.leaflet-touch-zoom {\r\n\t-ms-touch-action: pan-x pan-y;\r\n\ttouch-action: pan-x pan-y;\r\n\t}\r\n.leaflet-container.leaflet-touch-drag {\r\n\t-ms-touch-action: pinch-zoom;\r\n\t/* Fallback for FF which doesn't support pinch-zoom */\r\n\ttouch-action: none;\r\n\ttouch-action: pinch-zoom;\r\n}\r\n.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {\r\n\t-ms-touch-action: none;\r\n\ttouch-action: none;\r\n}\r\n.leaflet-container {\r\n\t-webkit-tap-highlight-color: transparent;\r\n}\r\n.leaflet-container a {\r\n\t-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);\r\n}\r\n.leaflet-tile {\r\n\tfilter: inherit;\r\n\tvisibility: hidden;\r\n\t}\r\n.leaflet-tile-loaded {\r\n\tvisibility: inherit;\r\n\t}\r\n.leaflet-zoom-box {\r\n\twidth: 0;\r\n\theight: 0;\r\n\t-moz-box-sizing: border-box;\r\n\t     box-sizing: border-box;\r\n\tz-index: 800;\r\n\t}\r\n/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */\r\n.leaflet-overlay-pane svg {\r\n\t-moz-user-select: none;\r\n\t}\r\n\r\n.leaflet-pane         { z-index: 400; }\r\n\r\n.leaflet-tile-pane    { z-index: 200; }\r\n.leaflet-overlay-pane { z-index: 400; }\r\n.leaflet-shadow-pane  { z-index: 500; }\r\n.leaflet-marker-pane  { z-index: 600; }\r\n.leaflet-tooltip-pane   { z-index: 650; }\r\n.leaflet-popup-pane   { z-index: 700; }\r\n\r\n.leaflet-map-pane canvas { z-index: 100; }\r\n.leaflet-map-pane svg    { z-index: 200; }\r\n\r\n.leaflet-vml-shape {\r\n\twidth: 1px;\r\n\theight: 1px;\r\n\t}\r\n.lvml {\r\n\tbehavior: url(#default#VML);\r\n\tdisplay: inline-block;\r\n\tposition: absolute;\r\n\t}\r\n\r\n\r\n/* control positioning */\r\n\r\n.leaflet-control {\r\n\tposition: relative;\r\n\tz-index: 800;\r\n\tpointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\r\n\tpointer-events: auto;\r\n\t}\r\n.leaflet-top,\r\n.leaflet-bottom {\r\n\tposition: absolute;\r\n\tz-index: 1000;\r\n\tpointer-events: none;\r\n\t}\r\n.leaflet-top {\r\n\ttop: 0;\r\n\t}\r\n.leaflet-right {\r\n\tright: 0;\r\n\t}\r\n.leaflet-bottom {\r\n\tbottom: 0;\r\n\t}\r\n.leaflet-left {\r\n\tleft: 0;\r\n\t}\r\n.leaflet-control {\r\n\tfloat: left;\r\n\tclear: both;\r\n\t}\r\n.leaflet-right .leaflet-control {\r\n\tfloat: right;\r\n\t}\r\n.leaflet-top .leaflet-control {\r\n\tmargin-top: 10px;\r\n\t}\r\n.leaflet-bottom .leaflet-control {\r\n\tmargin-bottom: 10px;\r\n\t}\r\n.leaflet-left .leaflet-control {\r\n\tmargin-left: 10px;\r\n\t}\r\n.leaflet-right .leaflet-control {\r\n\tmargin-right: 10px;\r\n\t}\r\n\r\n\r\n/* zoom and fade animations */\r\n\r\n.leaflet-fade-anim .leaflet-tile {\r\n\twill-change: opacity;\r\n\t}\r\n.leaflet-fade-anim .leaflet-popup {\r\n\topacity: 0;\r\n\t-webkit-transition: opacity 0.2s linear;\r\n\t   -moz-transition: opacity 0.2s linear;\r\n\t        transition: opacity 0.2s linear;\r\n\t}\r\n.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {\r\n\topacity: 1;\r\n\t}\r\n.leaflet-zoom-animated {\r\n\t-webkit-transform-origin: 0 0;\r\n\t    -ms-transform-origin: 0 0;\r\n\t        transform-origin: 0 0;\r\n\t}\r\n.leaflet-zoom-anim .leaflet-zoom-animated {\r\n\twill-change: transform;\r\n\t}\r\n.leaflet-zoom-anim .leaflet-zoom-animated {\r\n\t-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);\r\n\t   -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);\r\n\t        transition:         transform 0.25s cubic-bezier(0,0,0.25,1);\r\n\t}\r\n.leaflet-zoom-anim .leaflet-tile,\r\n.leaflet-pan-anim .leaflet-tile {\r\n\t-webkit-transition: none;\r\n\t   -moz-transition: none;\r\n\t        transition: none;\r\n\t}\r\n\r\n.leaflet-zoom-anim .leaflet-zoom-hide {\r\n\tvisibility: hidden;\r\n\t}\r\n\r\n\r\n/* cursors */\r\n\r\n.leaflet-interactive {\r\n\tcursor: pointer;\r\n\t}\r\n.leaflet-grab {\r\n\tcursor: -webkit-grab;\r\n\tcursor:    -moz-grab;\r\n\tcursor:         grab;\r\n\t}\r\n.leaflet-crosshair,\r\n.leaflet-crosshair .leaflet-interactive {\r\n\tcursor: crosshair;\r\n\t}\r\n.leaflet-popup-pane,\r\n.leaflet-control {\r\n\tcursor: auto;\r\n\t}\r\n.leaflet-dragging .leaflet-grab,\r\n.leaflet-dragging .leaflet-grab .leaflet-interactive,\r\n.leaflet-dragging .leaflet-marker-draggable {\r\n\tcursor: move;\r\n\tcursor: -webkit-grabbing;\r\n\tcursor:    -moz-grabbing;\r\n\tcursor:         grabbing;\r\n\t}\r\n\r\n/* marker & overlays interactivity */\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow,\r\n.leaflet-image-layer,\r\n.leaflet-pane > svg path,\r\n.leaflet-tile-container {\r\n\tpointer-events: none;\r\n\t}\r\n\r\n.leaflet-marker-icon.leaflet-interactive,\r\n.leaflet-image-layer.leaflet-interactive,\r\n.leaflet-pane > svg path.leaflet-interactive,\r\nsvg.leaflet-image-layer.leaflet-interactive path {\r\n\tpointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\r\n\tpointer-events: auto;\r\n\t}\r\n\r\n/* visual tweaks */\r\n\r\n.leaflet-container {\r\n\tbackground: #ddd;\r\n\toutline: 0;\r\n\t}\r\n.leaflet-container a {\r\n\tcolor: #0078A8;\r\n\t}\r\n.leaflet-container a.leaflet-active {\r\n\toutline: 2px solid orange;\r\n\t}\r\n.leaflet-zoom-box {\r\n\tborder: 2px dotted #38f;\r\n\tbackground: rgba(255,255,255,0.5);\r\n\t}\r\n\r\n\r\n/* general typography */\r\n.leaflet-container {\r\n\tfont: 12px/1.5 \"Helvetica Neue\", Arial, Helvetica, sans-serif;\r\n\t}\r\n\r\n\r\n/* general toolbar styles */\r\n\r\n.leaflet-bar {\r\n\tbox-shadow: 0 1px 5px rgba(0,0,0,0.65);\r\n\tborder-radius: 4px;\r\n\t}\r\n.leaflet-bar a,\r\n.leaflet-bar a:hover {\r\n\tbackground-color: #fff;\r\n\tborder-bottom: 1px solid #ccc;\r\n\twidth: 26px;\r\n\theight: 26px;\r\n\tline-height: 26px;\r\n\tdisplay: block;\r\n\ttext-align: center;\r\n\ttext-decoration: none;\r\n\tcolor: black;\r\n\t}\r\n.leaflet-bar a,\r\n.leaflet-control-layers-toggle {\r\n\tbackground-position: 50% 50%;\r\n\tbackground-repeat: no-repeat;\r\n\tdisplay: block;\r\n\t}\r\n.leaflet-bar a:hover {\r\n\tbackground-color: #f4f4f4;\r\n\t}\r\n.leaflet-bar a:first-child {\r\n\tborder-top-left-radius: 4px;\r\n\tborder-top-right-radius: 4px;\r\n\t}\r\n.leaflet-bar a:last-child {\r\n\tborder-bottom-left-radius: 4px;\r\n\tborder-bottom-right-radius: 4px;\r\n\tborder-bottom: none;\r\n\t}\r\n.leaflet-bar a.leaflet-disabled {\r\n\tcursor: default;\r\n\tbackground-color: #f4f4f4;\r\n\tcolor: #bbb;\r\n\t}\r\n\r\n.leaflet-touch .leaflet-bar a {\r\n\twidth: 30px;\r\n\theight: 30px;\r\n\tline-height: 30px;\r\n\t}\r\n.leaflet-touch .leaflet-bar a:first-child {\r\n\tborder-top-left-radius: 2px;\r\n\tborder-top-right-radius: 2px;\r\n\t}\r\n.leaflet-touch .leaflet-bar a:last-child {\r\n\tborder-bottom-left-radius: 2px;\r\n\tborder-bottom-right-radius: 2px;\r\n\t}\r\n\r\n/* zoom control */\r\n\r\n.leaflet-control-zoom-in,\r\n.leaflet-control-zoom-out {\r\n\tfont: bold 18px 'Lucida Console', Monaco, monospace;\r\n\ttext-indent: 1px;\r\n\t}\r\n\r\n.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {\r\n\tfont-size: 22px;\r\n\t}\r\n\r\n\r\n/* layers control */\r\n\r\n.leaflet-control-layers {\r\n\tbox-shadow: 0 1px 5px rgba(0,0,0,0.4);\r\n\tbackground: #fff;\r\n\tborder-radius: 5px;\r\n\t}\r\n.leaflet-control-layers-toggle {\r\n\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\r\n\twidth: 36px;\r\n\theight: 36px;\r\n\t}\r\n.leaflet-retina .leaflet-control-layers-toggle {\r\n\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ");\r\n\tbackground-size: 26px 26px;\r\n\t}\r\n.leaflet-touch .leaflet-control-layers-toggle {\r\n\twidth: 44px;\r\n\theight: 44px;\r\n\t}\r\n.leaflet-control-layers .leaflet-control-layers-list,\r\n.leaflet-control-layers-expanded .leaflet-control-layers-toggle {\r\n\tdisplay: none;\r\n\t}\r\n.leaflet-control-layers-expanded .leaflet-control-layers-list {\r\n\tdisplay: block;\r\n\tposition: relative;\r\n\t}\r\n.leaflet-control-layers-expanded {\r\n\tpadding: 6px 10px 6px 6px;\r\n\tcolor: #333;\r\n\tbackground: #fff;\r\n\t}\r\n.leaflet-control-layers-scrollbar {\r\n\toverflow-y: scroll;\r\n\toverflow-x: hidden;\r\n\tpadding-right: 5px;\r\n\t}\r\n.leaflet-control-layers-selector {\r\n\tmargin-top: 2px;\r\n\tposition: relative;\r\n\ttop: 1px;\r\n\t}\r\n.leaflet-control-layers label {\r\n\tdisplay: block;\r\n\t}\r\n.leaflet-control-layers-separator {\r\n\theight: 0;\r\n\tborder-top: 1px solid #ddd;\r\n\tmargin: 5px -10px 5px -6px;\r\n\t}\r\n\r\n/* Default icon URLs */\r\n.leaflet-default-icon-path {\r\n\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ");\r\n\t}\r\n\r\n\r\n/* attribution and scale controls */\r\n\r\n.leaflet-container .leaflet-control-attribution {\r\n\tbackground: #fff;\r\n\tbackground: rgba(255, 255, 255, 0.7);\r\n\tmargin: 0;\r\n\t}\r\n.leaflet-control-attribution,\r\n.leaflet-control-scale-line {\r\n\tpadding: 0 5px;\r\n\tcolor: #333;\r\n\t}\r\n.leaflet-control-attribution a {\r\n\ttext-decoration: none;\r\n\t}\r\n.leaflet-control-attribution a:hover {\r\n\ttext-decoration: underline;\r\n\t}\r\n.leaflet-container .leaflet-control-attribution,\r\n.leaflet-container .leaflet-control-scale {\r\n\tfont-size: 11px;\r\n\t}\r\n.leaflet-left .leaflet-control-scale {\r\n\tmargin-left: 5px;\r\n\t}\r\n.leaflet-bottom .leaflet-control-scale {\r\n\tmargin-bottom: 5px;\r\n\t}\r\n.leaflet-control-scale-line {\r\n\tborder: 2px solid #777;\r\n\tborder-top: none;\r\n\tline-height: 1.1;\r\n\tpadding: 2px 5px 1px;\r\n\tfont-size: 11px;\r\n\twhite-space: nowrap;\r\n\toverflow: hidden;\r\n\t-moz-box-sizing: border-box;\r\n\t     box-sizing: border-box;\r\n\r\n\tbackground: #fff;\r\n\tbackground: rgba(255, 255, 255, 0.5);\r\n\t}\r\n.leaflet-control-scale-line:not(:first-child) {\r\n\tborder-top: 2px solid #777;\r\n\tborder-bottom: none;\r\n\tmargin-top: -2px;\r\n\t}\r\n.leaflet-control-scale-line:not(:first-child):not(:last-child) {\r\n\tborder-bottom: 2px solid #777;\r\n\t}\r\n\r\n.leaflet-touch .leaflet-control-attribution,\r\n.leaflet-touch .leaflet-control-layers,\r\n.leaflet-touch .leaflet-bar {\r\n\tbox-shadow: none;\r\n\t}\r\n.leaflet-touch .leaflet-control-layers,\r\n.leaflet-touch .leaflet-bar {\r\n\tborder: 2px solid rgba(0,0,0,0.2);\r\n\tbackground-clip: padding-box;\r\n\t}\r\n\r\n\r\n/* popup */\r\n\r\n.leaflet-popup {\r\n\tposition: absolute;\r\n\ttext-align: center;\r\n\tmargin-bottom: 20px;\r\n\t}\r\n.leaflet-popup-content-wrapper {\r\n\tpadding: 1px;\r\n\ttext-align: left;\r\n\tborder-radius: 12px;\r\n\t}\r\n.leaflet-popup-content {\r\n\tmargin: 13px 19px;\r\n\tline-height: 1.4;\r\n\t}\r\n.leaflet-popup-content p {\r\n\tmargin: 18px 0;\r\n\t}\r\n.leaflet-popup-tip-container {\r\n\twidth: 40px;\r\n\theight: 20px;\r\n\tposition: absolute;\r\n\tleft: 50%;\r\n\tmargin-left: -20px;\r\n\toverflow: hidden;\r\n\tpointer-events: none;\r\n\t}\r\n.leaflet-popup-tip {\r\n\twidth: 17px;\r\n\theight: 17px;\r\n\tpadding: 1px;\r\n\r\n\tmargin: -10px auto 0;\r\n\r\n\t-webkit-transform: rotate(45deg);\r\n\t   -moz-transform: rotate(45deg);\r\n\t    -ms-transform: rotate(45deg);\r\n\t        transform: rotate(45deg);\r\n\t}\r\n.leaflet-popup-content-wrapper,\r\n.leaflet-popup-tip {\r\n\tbackground: white;\r\n\tcolor: #333;\r\n\tbox-shadow: 0 3px 14px rgba(0,0,0,0.4);\r\n\t}\r\n.leaflet-container a.leaflet-popup-close-button {\r\n\tposition: absolute;\r\n\ttop: 0;\r\n\tright: 0;\r\n\tpadding: 4px 4px 0 0;\r\n\tborder: none;\r\n\ttext-align: center;\r\n\twidth: 18px;\r\n\theight: 14px;\r\n\tfont: 16px/14px Tahoma, Verdana, sans-serif;\r\n\tcolor: #c3c3c3;\r\n\ttext-decoration: none;\r\n\tfont-weight: bold;\r\n\tbackground: transparent;\r\n\t}\r\n.leaflet-container a.leaflet-popup-close-button:hover {\r\n\tcolor: #999;\r\n\t}\r\n.leaflet-popup-scrolled {\r\n\toverflow: auto;\r\n\tborder-bottom: 1px solid #ddd;\r\n\tborder-top: 1px solid #ddd;\r\n\t}\r\n\r\n.leaflet-oldie .leaflet-popup-content-wrapper {\r\n\tzoom: 1;\r\n\t}\r\n.leaflet-oldie .leaflet-popup-tip {\r\n\twidth: 24px;\r\n\tmargin: 0 auto;\r\n\r\n\t-ms-filter: \"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)\";\r\n\tfilter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);\r\n\t}\r\n.leaflet-oldie .leaflet-popup-tip-container {\r\n\tmargin-top: -1px;\r\n\t}\r\n\r\n.leaflet-oldie .leaflet-control-zoom,\r\n.leaflet-oldie .leaflet-control-layers,\r\n.leaflet-oldie .leaflet-popup-content-wrapper,\r\n.leaflet-oldie .leaflet-popup-tip {\r\n\tborder: 1px solid #999;\r\n\t}\r\n\r\n\r\n/* div icon */\r\n\r\n.leaflet-div-icon {\r\n\tbackground: #fff;\r\n\tborder: 1px solid #666;\r\n\t}\r\n\r\n\r\n/* Tooltip */\r\n/* Base styles for the element that has a tooltip */\r\n.leaflet-tooltip {\r\n\tposition: absolute;\r\n\tpadding: 6px;\r\n\tbackground-color: #fff;\r\n\tborder: 1px solid #fff;\r\n\tborder-radius: 3px;\r\n\tcolor: #222;\r\n\twhite-space: nowrap;\r\n\t-webkit-user-select: none;\r\n\t-moz-user-select: none;\r\n\t-ms-user-select: none;\r\n\tuser-select: none;\r\n\tpointer-events: none;\r\n\tbox-shadow: 0 1px 3px rgba(0,0,0,0.4);\r\n\t}\r\n.leaflet-tooltip.leaflet-clickable {\r\n\tcursor: pointer;\r\n\tpointer-events: auto;\r\n\t}\r\n.leaflet-tooltip-top:before,\r\n.leaflet-tooltip-bottom:before,\r\n.leaflet-tooltip-left:before,\r\n.leaflet-tooltip-right:before {\r\n\tposition: absolute;\r\n\tpointer-events: none;\r\n\tborder: 6px solid transparent;\r\n\tbackground: transparent;\r\n\tcontent: \"\";\r\n\t}\r\n\r\n/* Directions */\r\n\r\n.leaflet-tooltip-bottom {\r\n\tmargin-top: 6px;\r\n}\r\n.leaflet-tooltip-top {\r\n\tmargin-top: -6px;\r\n}\r\n.leaflet-tooltip-bottom:before,\r\n.leaflet-tooltip-top:before {\r\n\tleft: 50%;\r\n\tmargin-left: -6px;\r\n\t}\r\n.leaflet-tooltip-top:before {\r\n\tbottom: 0;\r\n\tmargin-bottom: -12px;\r\n\tborder-top-color: #fff;\r\n\t}\r\n.leaflet-tooltip-bottom:before {\r\n\ttop: 0;\r\n\tmargin-top: -12px;\r\n\tmargin-left: -6px;\r\n\tborder-bottom-color: #fff;\r\n\t}\r\n.leaflet-tooltip-left {\r\n\tmargin-left: -6px;\r\n}\r\n.leaflet-tooltip-right {\r\n\tmargin-left: 6px;\r\n}\r\n.leaflet-tooltip-left:before,\r\n.leaflet-tooltip-right:before {\r\n\ttop: 50%;\r\n\tmargin-top: -6px;\r\n\t}\r\n.leaflet-tooltip-left:before {\r\n\tright: 0;\r\n\tmargin-right: -12px;\r\n\tborder-left-color: #fff;\r\n\t}\r\n.leaflet-tooltip-right:before {\r\n\tleft: 0;\r\n\tmargin-left: -12px;\r\n\tborder-right-color: #fff;\r\n\t}\r\n", "",{"version":3,"sources":["webpack://./node_modules/leaflet/dist/leaflet.css"],"names":[],"mappings":"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","sourcesContent":["/* required styles */\r\n\r\n.leaflet-pane,\r\n.leaflet-tile,\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow,\r\n.leaflet-tile-container,\r\n.leaflet-pane > svg,\r\n.leaflet-pane > canvas,\r\n.leaflet-zoom-box,\r\n.leaflet-image-layer,\r\n.leaflet-layer {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\t}\r\n.leaflet-container {\r\n\toverflow: hidden;\r\n\t}\r\n.leaflet-tile,\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow {\r\n\t-webkit-user-select: none;\r\n\t   -moz-user-select: none;\r\n\t        user-select: none;\r\n\t  -webkit-user-drag: none;\r\n\t}\r\n/* Prevents IE11 from highlighting tiles in blue */\r\n.leaflet-tile::selection {\r\n\tbackground: transparent;\r\n}\r\n/* Safari renders non-retina tile on retina better with this, but Chrome is worse */\r\n.leaflet-safari .leaflet-tile {\r\n\timage-rendering: -webkit-optimize-contrast;\r\n\t}\r\n/* hack that prevents hw layers \"stretching\" when loading new tiles */\r\n.leaflet-safari .leaflet-tile-container {\r\n\twidth: 1600px;\r\n\theight: 1600px;\r\n\t-webkit-transform-origin: 0 0;\r\n\t}\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow {\r\n\tdisplay: block;\r\n\t}\r\n/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */\r\n/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */\r\n.leaflet-container .leaflet-overlay-pane svg,\r\n.leaflet-container .leaflet-marker-pane img,\r\n.leaflet-container .leaflet-shadow-pane img,\r\n.leaflet-container .leaflet-tile-pane img,\r\n.leaflet-container img.leaflet-image-layer,\r\n.leaflet-container .leaflet-tile {\r\n\tmax-width: none !important;\r\n\tmax-height: none !important;\r\n\t}\r\n\r\n.leaflet-container.leaflet-touch-zoom {\r\n\t-ms-touch-action: pan-x pan-y;\r\n\ttouch-action: pan-x pan-y;\r\n\t}\r\n.leaflet-container.leaflet-touch-drag {\r\n\t-ms-touch-action: pinch-zoom;\r\n\t/* Fallback for FF which doesn't support pinch-zoom */\r\n\ttouch-action: none;\r\n\ttouch-action: pinch-zoom;\r\n}\r\n.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {\r\n\t-ms-touch-action: none;\r\n\ttouch-action: none;\r\n}\r\n.leaflet-container {\r\n\t-webkit-tap-highlight-color: transparent;\r\n}\r\n.leaflet-container a {\r\n\t-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);\r\n}\r\n.leaflet-tile {\r\n\tfilter: inherit;\r\n\tvisibility: hidden;\r\n\t}\r\n.leaflet-tile-loaded {\r\n\tvisibility: inherit;\r\n\t}\r\n.leaflet-zoom-box {\r\n\twidth: 0;\r\n\theight: 0;\r\n\t-moz-box-sizing: border-box;\r\n\t     box-sizing: border-box;\r\n\tz-index: 800;\r\n\t}\r\n/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */\r\n.leaflet-overlay-pane svg {\r\n\t-moz-user-select: none;\r\n\t}\r\n\r\n.leaflet-pane         { z-index: 400; }\r\n\r\n.leaflet-tile-pane    { z-index: 200; }\r\n.leaflet-overlay-pane { z-index: 400; }\r\n.leaflet-shadow-pane  { z-index: 500; }\r\n.leaflet-marker-pane  { z-index: 600; }\r\n.leaflet-tooltip-pane   { z-index: 650; }\r\n.leaflet-popup-pane   { z-index: 700; }\r\n\r\n.leaflet-map-pane canvas { z-index: 100; }\r\n.leaflet-map-pane svg    { z-index: 200; }\r\n\r\n.leaflet-vml-shape {\r\n\twidth: 1px;\r\n\theight: 1px;\r\n\t}\r\n.lvml {\r\n\tbehavior: url(#default#VML);\r\n\tdisplay: inline-block;\r\n\tposition: absolute;\r\n\t}\r\n\r\n\r\n/* control positioning */\r\n\r\n.leaflet-control {\r\n\tposition: relative;\r\n\tz-index: 800;\r\n\tpointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\r\n\tpointer-events: auto;\r\n\t}\r\n.leaflet-top,\r\n.leaflet-bottom {\r\n\tposition: absolute;\r\n\tz-index: 1000;\r\n\tpointer-events: none;\r\n\t}\r\n.leaflet-top {\r\n\ttop: 0;\r\n\t}\r\n.leaflet-right {\r\n\tright: 0;\r\n\t}\r\n.leaflet-bottom {\r\n\tbottom: 0;\r\n\t}\r\n.leaflet-left {\r\n\tleft: 0;\r\n\t}\r\n.leaflet-control {\r\n\tfloat: left;\r\n\tclear: both;\r\n\t}\r\n.leaflet-right .leaflet-control {\r\n\tfloat: right;\r\n\t}\r\n.leaflet-top .leaflet-control {\r\n\tmargin-top: 10px;\r\n\t}\r\n.leaflet-bottom .leaflet-control {\r\n\tmargin-bottom: 10px;\r\n\t}\r\n.leaflet-left .leaflet-control {\r\n\tmargin-left: 10px;\r\n\t}\r\n.leaflet-right .leaflet-control {\r\n\tmargin-right: 10px;\r\n\t}\r\n\r\n\r\n/* zoom and fade animations */\r\n\r\n.leaflet-fade-anim .leaflet-tile {\r\n\twill-change: opacity;\r\n\t}\r\n.leaflet-fade-anim .leaflet-popup {\r\n\topacity: 0;\r\n\t-webkit-transition: opacity 0.2s linear;\r\n\t   -moz-transition: opacity 0.2s linear;\r\n\t        transition: opacity 0.2s linear;\r\n\t}\r\n.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {\r\n\topacity: 1;\r\n\t}\r\n.leaflet-zoom-animated {\r\n\t-webkit-transform-origin: 0 0;\r\n\t    -ms-transform-origin: 0 0;\r\n\t        transform-origin: 0 0;\r\n\t}\r\n.leaflet-zoom-anim .leaflet-zoom-animated {\r\n\twill-change: transform;\r\n\t}\r\n.leaflet-zoom-anim .leaflet-zoom-animated {\r\n\t-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);\r\n\t   -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);\r\n\t        transition:         transform 0.25s cubic-bezier(0,0,0.25,1);\r\n\t}\r\n.leaflet-zoom-anim .leaflet-tile,\r\n.leaflet-pan-anim .leaflet-tile {\r\n\t-webkit-transition: none;\r\n\t   -moz-transition: none;\r\n\t        transition: none;\r\n\t}\r\n\r\n.leaflet-zoom-anim .leaflet-zoom-hide {\r\n\tvisibility: hidden;\r\n\t}\r\n\r\n\r\n/* cursors */\r\n\r\n.leaflet-interactive {\r\n\tcursor: pointer;\r\n\t}\r\n.leaflet-grab {\r\n\tcursor: -webkit-grab;\r\n\tcursor:    -moz-grab;\r\n\tcursor:         grab;\r\n\t}\r\n.leaflet-crosshair,\r\n.leaflet-crosshair .leaflet-interactive {\r\n\tcursor: crosshair;\r\n\t}\r\n.leaflet-popup-pane,\r\n.leaflet-control {\r\n\tcursor: auto;\r\n\t}\r\n.leaflet-dragging .leaflet-grab,\r\n.leaflet-dragging .leaflet-grab .leaflet-interactive,\r\n.leaflet-dragging .leaflet-marker-draggable {\r\n\tcursor: move;\r\n\tcursor: -webkit-grabbing;\r\n\tcursor:    -moz-grabbing;\r\n\tcursor:         grabbing;\r\n\t}\r\n\r\n/* marker & overlays interactivity */\r\n.leaflet-marker-icon,\r\n.leaflet-marker-shadow,\r\n.leaflet-image-layer,\r\n.leaflet-pane > svg path,\r\n.leaflet-tile-container {\r\n\tpointer-events: none;\r\n\t}\r\n\r\n.leaflet-marker-icon.leaflet-interactive,\r\n.leaflet-image-layer.leaflet-interactive,\r\n.leaflet-pane > svg path.leaflet-interactive,\r\nsvg.leaflet-image-layer.leaflet-interactive path {\r\n\tpointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\r\n\tpointer-events: auto;\r\n\t}\r\n\r\n/* visual tweaks */\r\n\r\n.leaflet-container {\r\n\tbackground: #ddd;\r\n\toutline: 0;\r\n\t}\r\n.leaflet-container a {\r\n\tcolor: #0078A8;\r\n\t}\r\n.leaflet-container a.leaflet-active {\r\n\toutline: 2px solid orange;\r\n\t}\r\n.leaflet-zoom-box {\r\n\tborder: 2px dotted #38f;\r\n\tbackground: rgba(255,255,255,0.5);\r\n\t}\r\n\r\n\r\n/* general typography */\r\n.leaflet-container {\r\n\tfont: 12px/1.5 \"Helvetica Neue\", Arial, Helvetica, sans-serif;\r\n\t}\r\n\r\n\r\n/* general toolbar styles */\r\n\r\n.leaflet-bar {\r\n\tbox-shadow: 0 1px 5px rgba(0,0,0,0.65);\r\n\tborder-radius: 4px;\r\n\t}\r\n.leaflet-bar a,\r\n.leaflet-bar a:hover {\r\n\tbackground-color: #fff;\r\n\tborder-bottom: 1px solid #ccc;\r\n\twidth: 26px;\r\n\theight: 26px;\r\n\tline-height: 26px;\r\n\tdisplay: block;\r\n\ttext-align: center;\r\n\ttext-decoration: none;\r\n\tcolor: black;\r\n\t}\r\n.leaflet-bar a,\r\n.leaflet-control-layers-toggle {\r\n\tbackground-position: 50% 50%;\r\n\tbackground-repeat: no-repeat;\r\n\tdisplay: block;\r\n\t}\r\n.leaflet-bar a:hover {\r\n\tbackground-color: #f4f4f4;\r\n\t}\r\n.leaflet-bar a:first-child {\r\n\tborder-top-left-radius: 4px;\r\n\tborder-top-right-radius: 4px;\r\n\t}\r\n.leaflet-bar a:last-child {\r\n\tborder-bottom-left-radius: 4px;\r\n\tborder-bottom-right-radius: 4px;\r\n\tborder-bottom: none;\r\n\t}\r\n.leaflet-bar a.leaflet-disabled {\r\n\tcursor: default;\r\n\tbackground-color: #f4f4f4;\r\n\tcolor: #bbb;\r\n\t}\r\n\r\n.leaflet-touch .leaflet-bar a {\r\n\twidth: 30px;\r\n\theight: 30px;\r\n\tline-height: 30px;\r\n\t}\r\n.leaflet-touch .leaflet-bar a:first-child {\r\n\tborder-top-left-radius: 2px;\r\n\tborder-top-right-radius: 2px;\r\n\t}\r\n.leaflet-touch .leaflet-bar a:last-child {\r\n\tborder-bottom-left-radius: 2px;\r\n\tborder-bottom-right-radius: 2px;\r\n\t}\r\n\r\n/* zoom control */\r\n\r\n.leaflet-control-zoom-in,\r\n.leaflet-control-zoom-out {\r\n\tfont: bold 18px 'Lucida Console', Monaco, monospace;\r\n\ttext-indent: 1px;\r\n\t}\r\n\r\n.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {\r\n\tfont-size: 22px;\r\n\t}\r\n\r\n\r\n/* layers control */\r\n\r\n.leaflet-control-layers {\r\n\tbox-shadow: 0 1px 5px rgba(0,0,0,0.4);\r\n\tbackground: #fff;\r\n\tborder-radius: 5px;\r\n\t}\r\n.leaflet-control-layers-toggle {\r\n\tbackground-image: url(images/layers.png);\r\n\twidth: 36px;\r\n\theight: 36px;\r\n\t}\r\n.leaflet-retina .leaflet-control-layers-toggle {\r\n\tbackground-image: url(images/layers-2x.png);\r\n\tbackground-size: 26px 26px;\r\n\t}\r\n.leaflet-touch .leaflet-control-layers-toggle {\r\n\twidth: 44px;\r\n\theight: 44px;\r\n\t}\r\n.leaflet-control-layers .leaflet-control-layers-list,\r\n.leaflet-control-layers-expanded .leaflet-control-layers-toggle {\r\n\tdisplay: none;\r\n\t}\r\n.leaflet-control-layers-expanded .leaflet-control-layers-list {\r\n\tdisplay: block;\r\n\tposition: relative;\r\n\t}\r\n.leaflet-control-layers-expanded {\r\n\tpadding: 6px 10px 6px 6px;\r\n\tcolor: #333;\r\n\tbackground: #fff;\r\n\t}\r\n.leaflet-control-layers-scrollbar {\r\n\toverflow-y: scroll;\r\n\toverflow-x: hidden;\r\n\tpadding-right: 5px;\r\n\t}\r\n.leaflet-control-layers-selector {\r\n\tmargin-top: 2px;\r\n\tposition: relative;\r\n\ttop: 1px;\r\n\t}\r\n.leaflet-control-layers label {\r\n\tdisplay: block;\r\n\t}\r\n.leaflet-control-layers-separator {\r\n\theight: 0;\r\n\tborder-top: 1px solid #ddd;\r\n\tmargin: 5px -10px 5px -6px;\r\n\t}\r\n\r\n/* Default icon URLs */\r\n.leaflet-default-icon-path {\r\n\tbackground-image: url(images/marker-icon.png);\r\n\t}\r\n\r\n\r\n/* attribution and scale controls */\r\n\r\n.leaflet-container .leaflet-control-attribution {\r\n\tbackground: #fff;\r\n\tbackground: rgba(255, 255, 255, 0.7);\r\n\tmargin: 0;\r\n\t}\r\n.leaflet-control-attribution,\r\n.leaflet-control-scale-line {\r\n\tpadding: 0 5px;\r\n\tcolor: #333;\r\n\t}\r\n.leaflet-control-attribution a {\r\n\ttext-decoration: none;\r\n\t}\r\n.leaflet-control-attribution a:hover {\r\n\ttext-decoration: underline;\r\n\t}\r\n.leaflet-container .leaflet-control-attribution,\r\n.leaflet-container .leaflet-control-scale {\r\n\tfont-size: 11px;\r\n\t}\r\n.leaflet-left .leaflet-control-scale {\r\n\tmargin-left: 5px;\r\n\t}\r\n.leaflet-bottom .leaflet-control-scale {\r\n\tmargin-bottom: 5px;\r\n\t}\r\n.leaflet-control-scale-line {\r\n\tborder: 2px solid #777;\r\n\tborder-top: none;\r\n\tline-height: 1.1;\r\n\tpadding: 2px 5px 1px;\r\n\tfont-size: 11px;\r\n\twhite-space: nowrap;\r\n\toverflow: hidden;\r\n\t-moz-box-sizing: border-box;\r\n\t     box-sizing: border-box;\r\n\r\n\tbackground: #fff;\r\n\tbackground: rgba(255, 255, 255, 0.5);\r\n\t}\r\n.leaflet-control-scale-line:not(:first-child) {\r\n\tborder-top: 2px solid #777;\r\n\tborder-bottom: none;\r\n\tmargin-top: -2px;\r\n\t}\r\n.leaflet-control-scale-line:not(:first-child):not(:last-child) {\r\n\tborder-bottom: 2px solid #777;\r\n\t}\r\n\r\n.leaflet-touch .leaflet-control-attribution,\r\n.leaflet-touch .leaflet-control-layers,\r\n.leaflet-touch .leaflet-bar {\r\n\tbox-shadow: none;\r\n\t}\r\n.leaflet-touch .leaflet-control-layers,\r\n.leaflet-touch .leaflet-bar {\r\n\tborder: 2px solid rgba(0,0,0,0.2);\r\n\tbackground-clip: padding-box;\r\n\t}\r\n\r\n\r\n/* popup */\r\n\r\n.leaflet-popup {\r\n\tposition: absolute;\r\n\ttext-align: center;\r\n\tmargin-bottom: 20px;\r\n\t}\r\n.leaflet-popup-content-wrapper {\r\n\tpadding: 1px;\r\n\ttext-align: left;\r\n\tborder-radius: 12px;\r\n\t}\r\n.leaflet-popup-content {\r\n\tmargin: 13px 19px;\r\n\tline-height: 1.4;\r\n\t}\r\n.leaflet-popup-content p {\r\n\tmargin: 18px 0;\r\n\t}\r\n.leaflet-popup-tip-container {\r\n\twidth: 40px;\r\n\theight: 20px;\r\n\tposition: absolute;\r\n\tleft: 50%;\r\n\tmargin-left: -20px;\r\n\toverflow: hidden;\r\n\tpointer-events: none;\r\n\t}\r\n.leaflet-popup-tip {\r\n\twidth: 17px;\r\n\theight: 17px;\r\n\tpadding: 1px;\r\n\r\n\tmargin: -10px auto 0;\r\n\r\n\t-webkit-transform: rotate(45deg);\r\n\t   -moz-transform: rotate(45deg);\r\n\t    -ms-transform: rotate(45deg);\r\n\t        transform: rotate(45deg);\r\n\t}\r\n.leaflet-popup-content-wrapper,\r\n.leaflet-popup-tip {\r\n\tbackground: white;\r\n\tcolor: #333;\r\n\tbox-shadow: 0 3px 14px rgba(0,0,0,0.4);\r\n\t}\r\n.leaflet-container a.leaflet-popup-close-button {\r\n\tposition: absolute;\r\n\ttop: 0;\r\n\tright: 0;\r\n\tpadding: 4px 4px 0 0;\r\n\tborder: none;\r\n\ttext-align: center;\r\n\twidth: 18px;\r\n\theight: 14px;\r\n\tfont: 16px/14px Tahoma, Verdana, sans-serif;\r\n\tcolor: #c3c3c3;\r\n\ttext-decoration: none;\r\n\tfont-weight: bold;\r\n\tbackground: transparent;\r\n\t}\r\n.leaflet-container a.leaflet-popup-close-button:hover {\r\n\tcolor: #999;\r\n\t}\r\n.leaflet-popup-scrolled {\r\n\toverflow: auto;\r\n\tborder-bottom: 1px solid #ddd;\r\n\tborder-top: 1px solid #ddd;\r\n\t}\r\n\r\n.leaflet-oldie .leaflet-popup-content-wrapper {\r\n\tzoom: 1;\r\n\t}\r\n.leaflet-oldie .leaflet-popup-tip {\r\n\twidth: 24px;\r\n\tmargin: 0 auto;\r\n\r\n\t-ms-filter: \"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)\";\r\n\tfilter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);\r\n\t}\r\n.leaflet-oldie .leaflet-popup-tip-container {\r\n\tmargin-top: -1px;\r\n\t}\r\n\r\n.leaflet-oldie .leaflet-control-zoom,\r\n.leaflet-oldie .leaflet-control-layers,\r\n.leaflet-oldie .leaflet-popup-content-wrapper,\r\n.leaflet-oldie .leaflet-popup-tip {\r\n\tborder: 1px solid #999;\r\n\t}\r\n\r\n\r\n/* div icon */\r\n\r\n.leaflet-div-icon {\r\n\tbackground: #fff;\r\n\tborder: 1px solid #666;\r\n\t}\r\n\r\n\r\n/* Tooltip */\r\n/* Base styles for the element that has a tooltip */\r\n.leaflet-tooltip {\r\n\tposition: absolute;\r\n\tpadding: 6px;\r\n\tbackground-color: #fff;\r\n\tborder: 1px solid #fff;\r\n\tborder-radius: 3px;\r\n\tcolor: #222;\r\n\twhite-space: nowrap;\r\n\t-webkit-user-select: none;\r\n\t-moz-user-select: none;\r\n\t-ms-user-select: none;\r\n\tuser-select: none;\r\n\tpointer-events: none;\r\n\tbox-shadow: 0 1px 3px rgba(0,0,0,0.4);\r\n\t}\r\n.leaflet-tooltip.leaflet-clickable {\r\n\tcursor: pointer;\r\n\tpointer-events: auto;\r\n\t}\r\n.leaflet-tooltip-top:before,\r\n.leaflet-tooltip-bottom:before,\r\n.leaflet-tooltip-left:before,\r\n.leaflet-tooltip-right:before {\r\n\tposition: absolute;\r\n\tpointer-events: none;\r\n\tborder: 6px solid transparent;\r\n\tbackground: transparent;\r\n\tcontent: \"\";\r\n\t}\r\n\r\n/* Directions */\r\n\r\n.leaflet-tooltip-bottom {\r\n\tmargin-top: 6px;\r\n}\r\n.leaflet-tooltip-top {\r\n\tmargin-top: -6px;\r\n}\r\n.leaflet-tooltip-bottom:before,\r\n.leaflet-tooltip-top:before {\r\n\tleft: 50%;\r\n\tmargin-left: -6px;\r\n\t}\r\n.leaflet-tooltip-top:before {\r\n\tbottom: 0;\r\n\tmargin-bottom: -12px;\r\n\tborder-top-color: #fff;\r\n\t}\r\n.leaflet-tooltip-bottom:before {\r\n\ttop: 0;\r\n\tmargin-top: -12px;\r\n\tmargin-left: -6px;\r\n\tborder-bottom-color: #fff;\r\n\t}\r\n.leaflet-tooltip-left {\r\n\tmargin-left: -6px;\r\n}\r\n.leaflet-tooltip-right {\r\n\tmargin-left: 6px;\r\n}\r\n.leaflet-tooltip-left:before,\r\n.leaflet-tooltip-right:before {\r\n\ttop: 50%;\r\n\tmargin-top: -6px;\r\n\t}\r\n.leaflet-tooltip-left:before {\r\n\tright: 0;\r\n\tmargin-right: -12px;\r\n\tborder-left-color: #fff;\r\n\t}\r\n.leaflet-tooltip-right:before {\r\n\tleft: 0;\r\n\tmargin-left: -12px;\r\n\tborder-right-color: #fff;\r\n\t}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }

  if (!url) {
    return url;
  }

  url = String(url.__esModule ? url.default : url); // If url is already wrapped in quotes, remove them

  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }

  if (options.hash) {
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }

  return url;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/leaflet/dist/leaflet-src.js":
/*!**************************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet-src.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

/* @preserve
 * Leaflet 1.6.0, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */

(function (global, factory) {
	 true ? factory(exports) :
	0;
}(this, (function (exports) { 'use strict';

var version = "1.6.0";

/*
 * @namespace Util
 *
 * Various utility functions, used by Leaflet internally.
 */

var freeze = Object.freeze;
Object.freeze = function (obj) { return obj; };

// @function extend(dest: Object, src?: Object): Object
// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
function extend(dest) {
	var i, j, len, src;

	for (j = 1, len = arguments.length; j < len; j++) {
		src = arguments[j];
		for (i in src) {
			dest[i] = src[i];
		}
	}
	return dest;
}

// @function create(proto: Object, properties?: Object): Object
// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
var create = Object.create || (function () {
	function F() {}
	return function (proto) {
		F.prototype = proto;
		return new F();
	};
})();

// @function bind(fn: Function, ): Function
// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
// Has a `L.bind()` shortcut.
function bind(fn, obj) {
	var slice = Array.prototype.slice;

	if (fn.bind) {
		return fn.bind.apply(fn, slice.call(arguments, 1));
	}

	var args = slice.call(arguments, 2);

	return function () {
		return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
	};
}

// @property lastId: Number
// Last unique ID used by [`stamp()`](#util-stamp)
var lastId = 0;

// @function stamp(obj: Object): Number
// Returns the unique ID of an object, assigning it one if it doesn't have it.
function stamp(obj) {
	/*eslint-disable */
	obj._leaflet_id = obj._leaflet_id || ++lastId;
	return obj._leaflet_id;
	/* eslint-enable */
}

// @function throttle(fn: Function, time: Number, context: Object): Function
// Returns a function which executes function `fn` with the given scope `context`
// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
// `fn` will be called no more than one time per given amount of `time`. The arguments
// received by the bound function will be any arguments passed when binding the
// function, followed by any arguments passed when invoking the bound function.
// Has an `L.throttle` shortcut.
function throttle(fn, time, context) {
	var lock, args, wrapperFn, later;

	later = function () {
		// reset lock and call if queued
		lock = false;
		if (args) {
			wrapperFn.apply(context, args);
			args = false;
		}
	};

	wrapperFn = function () {
		if (lock) {
			// called too soon, queue to call later
			args = arguments;

		} else {
			// call and lock until later
			fn.apply(context, arguments);
			setTimeout(later, time);
			lock = true;
		}
	};

	return wrapperFn;
}

// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
// Returns the number `num` modulo `range` in such a way so it lies within
// `range[0]` and `range[1]`. The returned value will be always smaller than
// `range[1]` unless `includeMax` is set to `true`.
function wrapNum(x, range, includeMax) {
	var max = range[1],
	    min = range[0],
	    d = max - min;
	return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
}

// @function falseFn(): Function
// Returns a function which always returns `false`.
function falseFn() { return false; }

// @function formatNum(num: Number, digits?: Number): Number
// Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.
function formatNum(num, digits) {
	var pow = Math.pow(10, (digits === undefined ? 6 : digits));
	return Math.round(num * pow) / pow;
}

// @function trim(str: String): String
// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
function trim(str) {
	return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

// @function splitWords(str: String): String[]
// Trims and splits the string on whitespace and returns the array of parts.
function splitWords(str) {
	return trim(str).split(/\s+/);
}

// @function setOptions(obj: Object, options: Object): Object
// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
function setOptions(obj, options) {
	if (!obj.hasOwnProperty('options')) {
		obj.options = obj.options ? create(obj.options) : {};
	}
	for (var i in options) {
		obj.options[i] = options[i];
	}
	return obj.options;
}

// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
// be appended at the end. If `uppercase` is `true`, the parameter names will
// be uppercased (e.g. `'?A=foo&B=bar'`)
function getParamString(obj, existingUrl, uppercase) {
	var params = [];
	for (var i in obj) {
		params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
	}
	return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
}

var templateRe = /\{ *([\w_-]+) *\}/g;

// @function template(str: String, data: Object): String
// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
// `('Hello foo, bar')`. You can also specify functions instead of strings for
// data values  they will be evaluated passing `data` as an argument.
function template(str, data) {
	return str.replace(templateRe, function (str, key) {
		var value = data[key];

		if (value === undefined) {
			throw new Error('No value provided for variable ' + str);

		} else if (typeof value === 'function') {
			value = value(data);
		}
		return value;
	});
}

// @function isArray(obj): Boolean
// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
var isArray = Array.isArray || function (obj) {
	return (Object.prototype.toString.call(obj) === '[object Array]');
};

// @function indexOf(array: Array, el: Object): Number
// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
function indexOf(array, el) {
	for (var i = 0; i < array.length; i++) {
		if (array[i] === el) { return i; }
	}
	return -1;
}

// @property emptyImageUrl: String
// Data URI string containing a base64-encoded empty GIF image.
// Used as a hack to free memory from unused images on WebKit-powered
// mobile devices (by setting image `src` to this string).
var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

function getPrefixed(name) {
	return window['webkit' + name] || window['moz' + name] || window['ms' + name];
}

var lastTime = 0;

// fallback for IE 7-8
function timeoutDefer(fn) {
	var time = +new Date(),
	    timeToCall = Math.max(0, 16 - (time - lastTime));

	lastTime = time + timeToCall;
	return window.setTimeout(fn, timeToCall);
}

var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
		getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };

// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
// `context` if given. When `immediate` is set, `fn` is called immediately if
// the browser doesn't have native support for
// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
function requestAnimFrame(fn, context, immediate) {
	if (immediate && requestFn === timeoutDefer) {
		fn.call(context);
	} else {
		return requestFn.call(window, bind(fn, context));
	}
}

// @function cancelAnimFrame(id: Number): undefined
// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
function cancelAnimFrame(id) {
	if (id) {
		cancelFn.call(window, id);
	}
}


var Util = (Object.freeze || Object)({
	freeze: freeze,
	extend: extend,
	create: create,
	bind: bind,
	lastId: lastId,
	stamp: stamp,
	throttle: throttle,
	wrapNum: wrapNum,
	falseFn: falseFn,
	formatNum: formatNum,
	trim: trim,
	splitWords: splitWords,
	setOptions: setOptions,
	getParamString: getParamString,
	template: template,
	isArray: isArray,
	indexOf: indexOf,
	emptyImageUrl: emptyImageUrl,
	requestFn: requestFn,
	cancelFn: cancelFn,
	requestAnimFrame: requestAnimFrame,
	cancelAnimFrame: cancelAnimFrame
});

// @class Class
// @aka L.Class

// @section
// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

function Class() {}

Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		checkDeprecatedMixinEvents(props.includes);
		extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = extend(create(proto.options), props.options);
	}

	// mix given properties into the prototype
	extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// @function include(properties: Object): this
// [Includes a mixin](#class-includes) into the current class.
Class.include = function (props) {
	extend(this.prototype, props);
	return this;
};

// @function mergeOptions(options: Object): this
// [Merges `options`](#class-options) into the defaults of the class.
Class.mergeOptions = function (options) {
	extend(this.prototype.options, options);
	return this;
};

// @function addInitHook(fn: Function): this
// Adds a [constructor hook](#class-constructor-hooks) to the class.
Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
	return this;
};

function checkDeprecatedMixinEvents(includes) {
	if (typeof L === 'undefined' || !L || !L.Mixin) { return; }

	includes = isArray(includes) ? includes : [includes];

	for (var i = 0; i < includes.length; i++) {
		if (includes[i] === L.Mixin.Events) {
			console.warn('Deprecated include of L.Mixin.Events: ' +
				'this property will be removed in future releases, ' +
				'please inherit from L.Evented instead.', new Error().stack);
		}
	}
}

/*
 * @class Evented
 * @aka L.Evented
 * @inherits Class
 *
 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
 *
 * @example
 *
 * ```js
 * map.on('click', function(e) {
 * 	alert(e.latlng);
 * } );
 * ```
 *
 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
 *
 * ```js
 * function onClick(e) { ... }
 *
 * map.on('click', onClick);
 * map.off('click', onClick);
 * ```
 */

var Events = {
	/* @method on(type: String, fn: Function, context?: Object): this
	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
	 *
	 * @alternative
	 * @method on(eventMap: Object): this
	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	 */
	on: function (types, fn, context) {

		// types can be a map of types/handlers
		if (typeof types === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}

		} else {
			// types can be a string of space-separated words
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	/* @method off(type: String, fn?: Function, context?: Object): this
	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
	 *
	 * @alternative
	 * @method off(eventMap: Object): this
	 * Removes a set of type/listener pairs.
	 *
	 * @alternative
	 * @method off: this
	 * Removes all listeners to all events on the object. This includes implicitly attached events.
	 */
	off: function (types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;

		} else if (typeof types === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}

		} else {
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function (type, fn, context) {
		this._events = this._events || {};

		/* get/init listeners for type */
		var typeListeners = this._events[type];
		if (!typeListeners) {
			typeListeners = [];
			this._events[type] = typeListeners;
		}

		if (context === this) {
			// Less memory footprint.
			context = undefined;
		}
		var newListener = {fn: fn, ctx: context},
		    listeners = typeListeners;

		// check if fn already there
		for (var i = 0, len = listeners.length; i < len; i++) {
			if (listeners[i].fn === fn && listeners[i].ctx === context) {
				return;
			}
		}

		listeners.push(newListener);
	},

	_off: function (type, fn, context) {
		var listeners,
		    i,
		    len;

		if (!this._events) { return; }

		listeners = this._events[type];

		if (!listeners) {
			return;
		}

		if (!fn) {
			// Set all removed listeners to noop so they are not called if remove happens in fire
			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].fn = falseFn;
			}
			// clear all listeners for a type if function isn't specified
			delete this._events[type];
			return;
		}

		if (context === this) {
			context = undefined;
		}

		if (listeners) {

			// find fn and remove it
			for (i = 0, len = listeners.length; i < len; i++) {
				var l = listeners[i];
				if (l.ctx !== context) { continue; }
				if (l.fn === fn) {

					// set the removed listener to noop so that's not called if remove happens in fire
					l.fn = falseFn;

					if (this._firingCount) {
						/* copy array in case events are being fired */
						this._events[type] = listeners = listeners.slice();
					}
					listeners.splice(i, 1);

					return;
				}
			}
		}
	},

	// @method fire(type: String, data?: Object, propagate?: Boolean): this
	// Fires an event of the specified type. You can optionally provide an data
	// object  the first argument of the listener function will contain its
	// properties. The event can optionally be propagated to event parents.
	fire: function (type, data, propagate) {
		if (!this.listens(type, propagate)) { return this; }

		var event = extend({}, data, {
			type: type,
			target: this,
			sourceTarget: data && data.sourceTarget || this
		});

		if (this._events) {
			var listeners = this._events[type];

			if (listeners) {
				this._firingCount = (this._firingCount + 1) || 1;
				for (var i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					l.fn.call(l.ctx || this, event);
				}

				this._firingCount--;
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	// @method listens(type: String): Boolean
	// Returns `true` if a particular event type has any listeners attached to it.
	listens: function (type, propagate) {
		var listeners = this._events && this._events[type];
		if (listeners && listeners.length) { return true; }

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) { return true; }
			}
		}
		return false;
	},

	// @method once(): this
	// Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
	once: function (types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = bind(function () {
			this
			    .off(types, fn, context)
			    .off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this
		    .on(types, fn, context)
		    .on(types, handler, context);
	},

	// @method addEventParent(obj: Evented): this
	// Adds an event parent - an `Evented` that will receive propagated events
	addEventParent: function (obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[stamp(obj)] = obj;
		return this;
	},

	// @method removeEventParent(obj: Evented): this
	// Removes an event parent, so it will stop receiving propagated events
	removeEventParent: function (obj) {
		if (this._eventParents) {
			delete this._eventParents[stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function (e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, extend({
				layer: e.target,
				propagatedFrom: e.target
			}, e), true);
		}
	}
};

// aliases; we should ditch those eventually

// @method addEventListener(): this
// Alias to [`on()`](#evented-on)
Events.addEventListener = Events.on;

// @method removeEventListener(): this
// Alias to [`off()`](#evented-off)

// @method clearAllEventListeners(): this
// Alias to [`off()`](#evented-off)
Events.removeEventListener = Events.clearAllEventListeners = Events.off;

// @method addOneTimeEventListener(): this
// Alias to [`once()`](#evented-once)
Events.addOneTimeEventListener = Events.once;

// @method fireEvent(): this
// Alias to [`fire()`](#evented-fire)
Events.fireEvent = Events.fire;

// @method hasEventListeners(): Boolean
// Alias to [`listens()`](#evented-listens)
Events.hasEventListeners = Events.listens;

var Evented = Class.extend(Events);

/*
 * @class Point
 * @aka L.Point
 *
 * Represents a point with `x` and `y` coordinates in pixels.
 *
 * @example
 *
 * ```js
 * var point = L.point(200, 300);
 * ```
 *
 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
 *
 * ```js
 * map.panBy([200, 300]);
 * map.panBy(L.point(200, 300));
 * ```
 *
 * Note that `Point` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function Point(x, y, round) {
	// @property x: Number; The `x` coordinate of the point
	this.x = (round ? Math.round(x) : x);
	// @property y: Number; The `y` coordinate of the point
	this.y = (round ? Math.round(y) : y);
}

var trunc = Math.trunc || function (v) {
	return v > 0 ? Math.floor(v) : Math.ceil(v);
};

Point.prototype = {

	// @method clone(): Point
	// Returns a copy of the current point.
	clone: function () {
		return new Point(this.x, this.y);
	},

	// @method add(otherPoint: Point): Point
	// Returns the result of addition of the current and the given points.
	add: function (point) {
		// non-destructive, returns a new point
		return this.clone()._add(toPoint(point));
	},

	_add: function (point) {
		// destructive, used directly for performance in situations where it's safe to modify existing point
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	// @method subtract(otherPoint: Point): Point
	// Returns the result of subtraction of the given point from the current.
	subtract: function (point) {
		return this.clone()._subtract(toPoint(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	// @method divideBy(num: Number): Point
	// Returns the result of division of the current point by the given number.
	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	// @method multiplyBy(num: Number): Point
	// Returns the result of multiplication of the current point by the given number.
	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	// @method scaleBy(scale: Point): Point
	// Multiply each coordinate of the current point by each coordinate of
	// `scale`. In linear algebra terms, multiply the point by the
	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
	// defined by `scale`.
	scaleBy: function (point) {
		return new Point(this.x * point.x, this.y * point.y);
	},

	// @method unscaleBy(scale: Point): Point
	// Inverse of `scaleBy`. Divide each coordinate of the current point by
	// each coordinate of `scale`.
	unscaleBy: function (point) {
		return new Point(this.x / point.x, this.y / point.y);
	},

	// @method round(): Point
	// Returns a copy of the current point with rounded coordinates.
	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	// @method floor(): Point
	// Returns a copy of the current point with floored coordinates (rounded down).
	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	// @method ceil(): Point
	// Returns a copy of the current point with ceiled coordinates (rounded up).
	ceil: function () {
		return this.clone()._ceil();
	},

	_ceil: function () {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	// @method trunc(): Point
	// Returns a copy of the current point with truncated coordinates (rounded towards zero).
	trunc: function () {
		return this.clone()._trunc();
	},

	_trunc: function () {
		this.x = trunc(this.x);
		this.y = trunc(this.y);
		return this;
	},

	// @method distanceTo(otherPoint: Point): Number
	// Returns the cartesian distance between the current and the given points.
	distanceTo: function (point) {
		point = toPoint(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	// @method equals(otherPoint: Point): Boolean
	// Returns `true` if the given point has the same coordinates.
	equals: function (point) {
		point = toPoint(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	// @method contains(otherPoint: Point): Boolean
	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
	contains: function (point) {
		point = toPoint(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	// @method toString(): String
	// Returns a string representation of the point for debugging purposes.
	toString: function () {
		return 'Point(' +
		        formatNum(this.x) + ', ' +
		        formatNum(this.y) + ')';
	}
};

// @factory L.point(x: Number, y: Number, round?: Boolean)
// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative
// @factory L.point(coords: Number[])
// Expects an array of the form `[x, y]` instead.

// @alternative
// @factory L.point(coords: Object)
// Expects a plain object of the form `{x: Number, y: Number}` instead.
function toPoint(x, y, round) {
	if (x instanceof Point) {
		return x;
	}
	if (isArray(x)) {
		return new Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	if (typeof x === 'object' && 'x' in x && 'y' in x) {
		return new Point(x.x, x.y);
	}
	return new Point(x, y, round);
}

/*
 * @class Bounds
 * @aka L.Bounds
 *
 * Represents a rectangular area in pixel coordinates.
 *
 * @example
 *
 * ```js
 * var p1 = L.point(10, 10),
 * p2 = L.point(40, 60),
 * bounds = L.bounds(p1, p2);
 * ```
 *
 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * otherBounds.intersects([[10, 10], [40, 60]]);
 * ```
 *
 * Note that `Bounds` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function Bounds(a, b) {
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
}

Bounds.prototype = {
	// @method extend(point: Point): this
	// Extends the bounds to contain the given point.
	extend: function (point) { // (Point)
		point = toPoint(point);

		// @property min: Point
		// The top left corner of the rectangle.
		// @property max: Point
		// The bottom right corner of the rectangle.
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	// @method getCenter(round?: Boolean): Point
	// Returns the center point of the bounds.
	getCenter: function (round) {
		return new Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	// @method getBottomLeft(): Point
	// Returns the bottom-left point of the bounds.
	getBottomLeft: function () {
		return new Point(this.min.x, this.max.y);
	},

	// @method getTopRight(): Point
	// Returns the top-right point of the bounds.
	getTopRight: function () { // -> Point
		return new Point(this.max.x, this.min.y);
	},

	// @method getTopLeft(): Point
	// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
	getTopLeft: function () {
		return this.min; // left, top
	},

	// @method getBottomRight(): Point
	// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
	getBottomRight: function () {
		return this.max; // right, bottom
	},

	// @method getSize(): Point
	// Returns the size of the given bounds
	getSize: function () {
		return this.max.subtract(this.min);
	},

	// @method contains(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle contains the given one.
	// @alternative
	// @method contains(point: Point): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) {
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof Point) {
			obj = toPoint(obj);
		} else {
			obj = toBounds(obj);
		}

		if (obj instanceof Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	// @method intersects(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds
	// intersect if they have at least one point in common.
	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
	// overlap if their intersection is an area.
	overlaps: function (bounds) { // (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
		    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

		return xOverlaps && yOverlaps;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};


// @factory L.bounds(corner1: Point, corner2: Point)
// Creates a Bounds object from two corners coordinate pairs.
// @alternative
// @factory L.bounds(points: Point[])
// Creates a Bounds object from the given array of points.
function toBounds(a, b) {
	if (!a || a instanceof Bounds) {
		return a;
	}
	return new Bounds(a, b);
}

/*
 * @class LatLngBounds
 * @aka L.LatLngBounds
 *
 * Represents a rectangular geographical area on a map.
 *
 * @example
 *
 * ```js
 * var corner1 = L.latLng(40.712, -74.227),
 * corner2 = L.latLng(40.774, -74.125),
 * bounds = L.latLngBounds(corner1, corner2);
 * ```
 *
 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * map.fitBounds([
 * 	[40.712, -74.227],
 * 	[40.774, -74.125]
 * ]);
 * ```
 *
 * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
 *
 * Note that `LatLngBounds` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
	if (!corner1) { return; }

	var latlngs = corner2 ? [corner1, corner2] : corner1;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
}

LatLngBounds.prototype = {

	// @method extend(latlng: LatLng): this
	// Extend the bounds to contain the given point

	// @alternative
	// @method extend(otherBounds: LatLngBounds): this
	// Extend the bounds to contain the given bounds
	extend: function (obj) {
		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof LatLng) {
			sw2 = obj;
			ne2 = obj;

		} else if (obj instanceof LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) { return this; }

		} else {
			return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new LatLng(sw2.lat, sw2.lng);
			this._northEast = new LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// @method pad(bufferRatio: Number): LatLngBounds
	// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
	// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
	// Negative values will retract the bounds.
	pad: function (bufferRatio) {
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new LatLngBounds(
		        new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	// @method getCenter(): LatLng
	// Returns the center point of the bounds.
	getCenter: function () {
		return new LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	// @method getSouthWest(): LatLng
	// Returns the south-west point of the bounds.
	getSouthWest: function () {
		return this._southWest;
	},

	// @method getNorthEast(): LatLng
	// Returns the north-east point of the bounds.
	getNorthEast: function () {
		return this._northEast;
	},

	// @method getNorthWest(): LatLng
	// Returns the north-west point of the bounds.
	getNorthWest: function () {
		return new LatLng(this.getNorth(), this.getWest());
	},

	// @method getSouthEast(): LatLng
	// Returns the south-east point of the bounds.
	getSouthEast: function () {
		return new LatLng(this.getSouth(), this.getEast());
	},

	// @method getWest(): Number
	// Returns the west longitude of the bounds
	getWest: function () {
		return this._southWest.lng;
	},

	// @method getSouth(): Number
	// Returns the south latitude of the bounds
	getSouth: function () {
		return this._southWest.lat;
	},

	// @method getEast(): Number
	// Returns the east longitude of the bounds
	getEast: function () {
		return this._northEast.lng;
	},

	// @method getNorth(): Number
	// Returns the north latitude of the bounds
	getNorth: function () {
		return this._northEast.lat;
	},

	// @method contains(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle contains the given one.

	// @alternative
	// @method contains (latlng: LatLng): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
			obj = toLatLng(obj);
		} else {
			obj = toLatLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	// @method intersects(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
	intersects: function (bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
	overlaps: function (bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
		    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

		return latOverlaps && lngOverlaps;
	},

	// @method toBBoxString(): String
	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
	equals: function (bounds, maxMargin) {
		if (!bounds) { return false; }

		bounds = toLatLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest(), maxMargin) &&
		       this._northEast.equals(bounds.getNorthEast(), maxMargin);
	},

	// @method isValid(): Boolean
	// Returns `true` if the bounds are properly initialized.
	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

// TODO International date line?

// @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
// Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

// @alternative
// @factory L.latLngBounds(latlngs: LatLng[])
// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
function toLatLngBounds(a, b) {
	if (a instanceof LatLngBounds) {
		return a;
	}
	return new LatLngBounds(a, b);
}

/* @class LatLng
 * @aka L.LatLng
 *
 * Represents a geographical point with a certain latitude and longitude.
 *
 * @example
 *
 * ```
 * var latlng = L.latLng(50.5, 30.5);
 * ```
 *
 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
 *
 * ```
 * map.panTo([50, 30]);
 * map.panTo({lon: 30, lat: 50});
 * map.panTo({lat: 50, lng: 30});
 * map.panTo(L.latLng(50, 30));
 * ```
 *
 * Note that `LatLng` does not inherit from Leaflet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function LatLng(lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	// @property lat: Number
	// Latitude in degrees
	this.lat = +lat;

	// @property lng: Number
	// Longitude in degrees
	this.lng = +lng;

	// @property alt: Number
	// Altitude in meters (optional)
	if (alt !== undefined) {
		this.alt = +alt;
	}
}

LatLng.prototype = {
	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
	equals: function (obj, maxMargin) {
		if (!obj) { return false; }

		obj = toLatLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	// @method toString(): String
	// Returns a string representation of the point (for debugging purposes).
	toString: function (precision) {
		return 'LatLng(' +
		        formatNum(this.lat, precision) + ', ' +
		        formatNum(this.lng, precision) + ')';
	},

	// @method distanceTo(otherLatLng: LatLng): Number
	// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
	distanceTo: function (other) {
		return Earth.distance(this, toLatLng(other));
	},

	// @method wrap(): LatLng
	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
	wrap: function () {
		return Earth.wrapLatLng(this);
	},

	// @method toBounds(sizeInMeters: Number): LatLngBounds
	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
	toBounds: function (sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
		    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

		return toLatLngBounds(
		        [this.lat - latAccuracy, this.lng - lngAccuracy],
		        [this.lat + latAccuracy, this.lng + lngAccuracy]);
	},

	clone: function () {
		return new LatLng(this.lat, this.lng, this.alt);
	}
};



// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative
// @factory L.latLng(coords: Array): LatLng
// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative
// @factory L.latLng(coords: Object): LatLng
// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

function toLatLng(a, b, c) {
	if (a instanceof LatLng) {
		return a;
	}
	if (isArray(a) && typeof a[0] !== 'object') {
		if (a.length === 3) {
			return new LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new LatLng(a, b, c);
}

/*
 * @namespace CRS
 * @crs L.CRS.Base
 * Object that defines coordinate reference systems for projecting
 * geographical points into pixel (screen) coordinates and back (and to
 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
 *
 * Leaflet defines the most usual CRSs by default. If you want to use a
 * CRS not defined by default, take a look at the
 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
 *
 * Note that the CRS instances do not inherit from Leafet's `Class` object,
 * and can't be instantiated. Also, new classes can't inherit from them,
 * and methods can't be added to them with the `include` function.
 */

var CRS = {
	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
	// Projects geographical coordinates into pixel coordinates for a given zoom.
	latLngToPoint: function (latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// @method pointToLatLng(point: Point, zoom: Number): LatLng
	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
	// zoom into geographical coordinates.
	pointToLatLng: function (point, zoom) {
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// @method project(latlng: LatLng): Point
	// Projects geographical coordinates into coordinates in units accepted for
	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
	project: function (latlng) {
		return this.projection.project(latlng);
	},

	// @method unproject(point: Point): LatLng
	// Given a projected coordinate returns the corresponding LatLng.
	// The inverse of `project`.
	unproject: function (point) {
		return this.projection.unproject(point);
	},

	// @method scale(zoom: Number): Number
	// Returns the scale used when transforming projected coordinates into
	// pixel coordinates for a particular zoom. For example, it returns
	// `256 * 2^zoom` for Mercator-based CRS.
	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// @method zoom(scale: Number): Number
	// Inverse of `scale()`, returns the zoom level corresponding to a scale
	// factor of `scale`.
	zoom: function (scale) {
		return Math.log(scale / 256) / Math.LN2;
	},

	// @method getProjectedBounds(zoom: Number): Bounds
	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
	getProjectedBounds: function (zoom) {
		if (this.infinite) { return null; }

		var b = this.projection.bounds,
		    s = this.scale(zoom),
		    min = this.transformation.transform(b.min, s),
		    max = this.transformation.transform(b.max, s);

		return new Bounds(min, max);
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates.

	// @property code: String
	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
	//
	// @property wrapLng: Number[]
	// An array of two numbers defining whether the longitude (horizontal) coordinate
	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
	//
	// @property wrapLat: Number[]
	// Like `wrapLng`, but for the latitude (vertical) axis.

	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// @property infinite: Boolean
	// If true, the coordinate space will be unbounded (infinite in both axes)
	infinite: false,

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where lat and lng has been wrapped according to the
	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
	wrapLatLng: function (latlng) {
		var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
		    lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
		    alt = latlng.alt;

		return new LatLng(lat, lng, alt);
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring
	// that its center is within the CRS's bounds.
	// Only accepts actual `L.LatLngBounds` instances, not arrays.
	wrapLatLngBounds: function (bounds) {
		var center = bounds.getCenter(),
		    newCenter = this.wrapLatLng(center),
		    latShift = center.lat - newCenter.lat,
		    lngShift = center.lng - newCenter.lng;

		if (latShift === 0 && lngShift === 0) {
			return bounds;
		}

		var sw = bounds.getSouthWest(),
		    ne = bounds.getNorthEast(),
		    newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
		    newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);

		return new LatLngBounds(newSw, newNe);
	}
};

/*
 * @namespace CRS
 * @crs L.CRS.Earth
 *
 * Serves as the base for CRS that are global such that they cover the earth.
 * Can only be used as the base for other CRS and cannot be used directly,
 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
 * meters.
 */

var Earth = extend({}, CRS, {
	wrapLng: [-180, 180],

	// Mean Earth Radius, as recommended for use by
	// the International Union of Geodesy and Geophysics,
	// see http://rosettacode.org/wiki/Haversine_formula
	R: 6371000,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function (latlng1, latlng2) {
		var rad = Math.PI / 180,
		    lat1 = latlng1.lat * rad,
		    lat2 = latlng2.lat * rad,
		    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
		    sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
		    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
		    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
		return this.R * c;
	}
});

/*
 * @namespace Projection
 * @projection L.Projection.SphericalMercator
 *
 * Spherical Mercator projection  the most common projection for online maps,
 * used by almost all free and commercial tile providers. Assumes that Earth is
 * a sphere. Used by the `EPSG:3857` CRS.
 */

var earthRadius = 6378137;

var SphericalMercator = {

	R: earthRadius,
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) {
		var d = Math.PI / 180,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    sin = Math.sin(lat * d);

		return new Point(
			this.R * latlng.lng * d,
			this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function (point) {
		var d = 180 / Math.PI;

		return new LatLng(
			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
			point.x * d / this.R);
	},

	bounds: (function () {
		var d = earthRadius * Math.PI;
		return new Bounds([-d, -d], [d, d]);
	})()
};

/*
 * @class Transformation
 * @aka L.Transformation
 *
 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
 * the reverse. Used by Leaflet in its projections code.
 *
 * @example
 *
 * ```js
 * var transformation = L.transformation(2, 5, -1, 10),
 * 	p = L.point(1, 2),
 * 	p2 = transformation.transform(p), //  L.point(7, 8)
 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
 * ```
 */


// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
// Creates a `Transformation` object with the given coefficients.
function Transformation(a, b, c, d) {
	if (isArray(a)) {
		// use array properties
		this._a = a[0];
		this._b = a[1];
		this._c = a[2];
		this._d = a[3];
		return;
	}
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
}

Transformation.prototype = {
	// @method transform(point: Point, scale?: Number): Point
	// Returns a transformed point, optionally multiplied by the given scale.
	// Only accepts actual `L.Point` instances, not arrays.
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	// @method untransform(point: Point, scale?: Number): Point
	// Returns the reverse transformation of the given point, optionally divided
	// by the given scale. Only accepts actual `L.Point` instances, not arrays.
	untransform: function (point, scale) {
		scale = scale || 1;
		return new Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};

// factory L.transformation(a: Number, b: Number, c: Number, d: Number)

// @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
// Instantiates a Transformation object with the given coefficients.

// @alternative
// @factory L.transformation(coefficients: Array): Transformation
// Expects an coefficients array of the form
// `[a: Number, b: Number, c: Number, d: Number]`.

function toTransformation(a, b, c, d) {
	return new Transformation(a, b, c, d);
}

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3857
 *
 * The most common CRS for online maps, used by almost all free and commercial
 * tile providers. Uses Spherical Mercator projection. Set in by default in
 * Map's `crs` option.
 */

var EPSG3857 = extend({}, Earth, {
	code: 'EPSG:3857',
	projection: SphericalMercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * SphericalMercator.R);
		return toTransformation(scale, 0.5, -scale, 0.5);
	}())
});

var EPSG900913 = extend({}, EPSG3857, {
	code: 'EPSG:900913'
});

// @namespace SVG; @section
// There are several static functions which can be called without instantiating L.SVG:

// @function create(name: String): SVGElement
// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
// corresponding to the class name passed. For example, using 'line' will return
// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
function svgCreate(name) {
	return document.createElementNS('http://www.w3.org/2000/svg', name);
}

// @function pointsToPath(rings: Point[], closed: Boolean): String
// Generates a SVG path string for multiple rings, with each ring turning
// into "M..L..L.." instructions
function pointsToPath(rings, closed) {
	var str = '',
	i, j, len, len2, points, p;

	for (i = 0, len = rings.length; i < len; i++) {
		points = rings[i];

		for (j = 0, len2 = points.length; j < len2; j++) {
			p = points[j];
			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
		}

		// closes the ring for polygons; "x" is VML syntax
		str += closed ? (svg ? 'z' : 'x') : '';
	}

	// SVG complains about empty path strings
	return str || 'M0 0';
}

/*
 * @namespace Browser
 * @aka L.Browser
 *
 * A namespace with static properties for browser/feature detection used by Leaflet internally.
 *
 * @example
 *
 * ```js
 * if (L.Browser.ielt9) {
 *   alert('Upgrade your browser, dude!');
 * }
 * ```
 */

var style$1 = document.documentElement.style;

// @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
var ie = 'ActiveXObject' in window;

// @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
var ielt9 = ie && !document.addEventListener;

// @property edge: Boolean; `true` for the Edge web browser.
var edge = 'msLaunchUri' in navigator && !('documentMode' in document);

// @property webkit: Boolean;
// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
var webkit = userAgentContains('webkit');

// @property android: Boolean
// `true` for any browser running on an Android platform.
var android = userAgentContains('android');

// @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.
var android23 = userAgentContains('android 2') || userAgentContains('android 3');

/* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
// @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)
var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);

// @property opera: Boolean; `true` for the Opera browser
var opera = !!window.opera;

// @property chrome: Boolean; `true` for the Chrome browser.
var chrome = userAgentContains('chrome');

// @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

// @property safari: Boolean; `true` for the Safari browser.
var safari = !chrome && userAgentContains('safari');

var phantom = userAgentContains('phantom');

// @property opera12: Boolean
// `true` for the Opera browser supporting CSS transforms (version 12 or later).
var opera12 = 'OTransition' in style$1;

// @property win: Boolean; `true` when the browser is running in a Windows platform
var win = navigator.platform.indexOf('Win') === 0;

// @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
var ie3d = ie && ('transition' in style$1);

// @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;

// @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
var gecko3d = 'MozPerspective' in style$1;

// @property any3d: Boolean
// `true` for all browsers supporting CSS transforms.
var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

// @property mobile: Boolean; `true` for all browsers running in a mobile device.
var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

// @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
var mobileWebkit = mobile && webkit;

// @property mobileWebkit3d: Boolean
// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
var mobileWebkit3d = mobile && webkit3d;

// @property msPointer: Boolean
// `true` for browsers implementing the Microsoft touch events model (notably IE10).
var msPointer = !window.PointerEvent && window.MSPointerEvent;

// @property pointer: Boolean
// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
var pointer = !webkit && !!(window.PointerEvent || msPointer);

// @property touch: Boolean
// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
// This does not necessarily mean that the browser is running in a computer with
// a touchscreen, it only means that the browser is capable of understanding
// touch events.
var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
		(window.DocumentTouch && document instanceof window.DocumentTouch));

// @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
var mobileOpera = mobile && opera;

// @property mobileGecko: Boolean
// `true` for gecko-based browsers running in a mobile device.
var mobileGecko = mobile && gecko;

// @property retina: Boolean
// `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.
var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;

// @property passiveEvents: Boolean
// `true` for browsers that support passive events.
var passiveEvents = (function () {
	var supportsPassiveOption = false;
	try {
		var opts = Object.defineProperty({}, 'passive', {
			get: function () {
				supportsPassiveOption = true;
			}
		});
		window.addEventListener('testPassiveEventSupport', falseFn, opts);
		window.removeEventListener('testPassiveEventSupport', falseFn, opts);
	} catch (e) {
		// Errors can safely be ignored since this is only a browser support test.
	}
	return supportsPassiveOption;
});

// @property canvas: Boolean
// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
var canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

// @property svg: Boolean
// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect);

// @property vml: Boolean
// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
var vml = !svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());


function userAgentContains(str) {
	return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
}


var Browser = (Object.freeze || Object)({
	ie: ie,
	ielt9: ielt9,
	edge: edge,
	webkit: webkit,
	android: android,
	android23: android23,
	androidStock: androidStock,
	opera: opera,
	chrome: chrome,
	gecko: gecko,
	safari: safari,
	phantom: phantom,
	opera12: opera12,
	win: win,
	ie3d: ie3d,
	webkit3d: webkit3d,
	gecko3d: gecko3d,
	any3d: any3d,
	mobile: mobile,
	mobileWebkit: mobileWebkit,
	mobileWebkit3d: mobileWebkit3d,
	msPointer: msPointer,
	pointer: pointer,
	touch: touch,
	mobileOpera: mobileOpera,
	mobileGecko: mobileGecko,
	retina: retina,
	passiveEvents: passiveEvents,
	canvas: canvas,
	svg: svg,
	vml: vml
});

/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */


var POINTER_DOWN =   msPointer ? 'MSPointerDown'   : 'pointerdown';
var POINTER_MOVE =   msPointer ? 'MSPointerMove'   : 'pointermove';
var POINTER_UP =     msPointer ? 'MSPointerUp'     : 'pointerup';
var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';
var TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'];

var _pointers = {};
var _pointerDocListener = false;

// DomEvent.DoubleTap needs to know about this
var _pointersCount = 0;

// Provides a touch events wrapper for (ms)pointer events.
// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

function addPointerListener(obj, type, handler, id) {
	if (type === 'touchstart') {
		_addPointerStart(obj, handler, id);

	} else if (type === 'touchmove') {
		_addPointerMove(obj, handler, id);

	} else if (type === 'touchend') {
		_addPointerEnd(obj, handler, id);
	}

	return this;
}

function removePointerListener(obj, type, id) {
	var handler = obj['_leaflet_' + type + id];

	if (type === 'touchstart') {
		obj.removeEventListener(POINTER_DOWN, handler, false);

	} else if (type === 'touchmove') {
		obj.removeEventListener(POINTER_MOVE, handler, false);

	} else if (type === 'touchend') {
		obj.removeEventListener(POINTER_UP, handler, false);
		obj.removeEventListener(POINTER_CANCEL, handler, false);
	}

	return this;
}

function _addPointerStart(obj, handler, id) {
	var onDown = bind(function (e) {
		if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
			// In IE11, some touch events needs to fire for form controls, or
			// the controls will stop working. We keep a whitelist of tag names that
			// need these events. For other target tags, we prevent default on the event.
			if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
				preventDefault(e);
			} else {
				return;
			}
		}

		_handlePointer(e, handler);
	});

	obj['_leaflet_touchstart' + id] = onDown;
	obj.addEventListener(POINTER_DOWN, onDown, false);

	// need to keep track of what pointers and how many are active to provide e.touches emulation
	if (!_pointerDocListener) {
		// we listen documentElement as any drags that end by moving the touch off the screen get fired there
		document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);
		document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);
		document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);
		document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

		_pointerDocListener = true;
	}
}

function _globalPointerDown(e) {
	_pointers[e.pointerId] = e;
	_pointersCount++;
}

function _globalPointerMove(e) {
	if (_pointers[e.pointerId]) {
		_pointers[e.pointerId] = e;
	}
}

function _globalPointerUp(e) {
	delete _pointers[e.pointerId];
	_pointersCount--;
}

function _handlePointer(e, handler) {
	e.touches = [];
	for (var i in _pointers) {
		e.touches.push(_pointers[i]);
	}
	e.changedTouches = [e];

	handler(e);
}

function _addPointerMove(obj, handler, id) {
	var onMove = function (e) {
		// don't fire touch moves when mouse isn't down
		if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

		_handlePointer(e, handler);
	};

	obj['_leaflet_touchmove' + id] = onMove;
	obj.addEventListener(POINTER_MOVE, onMove, false);
}

function _addPointerEnd(obj, handler, id) {
	var onUp = function (e) {
		_handlePointer(e, handler);
	};

	obj['_leaflet_touchend' + id] = onUp;
	obj.addEventListener(POINTER_UP, onUp, false);
	obj.addEventListener(POINTER_CANCEL, onUp, false);
}

/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';
var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';
var _pre = '_leaflet_';

// inspired by Zepto touch code by Thomas Fuchs
function addDoubleTapListener(obj, handler, id) {
	var last, touch$$1,
	    doubleTap = false,
	    delay = 250;

	function onTouchStart(e) {
		var count;

		if (pointer) {
			if ((!edge) || e.pointerType === 'mouse') { return; }
			count = _pointersCount;
		} else {
			count = e.touches.length;
		}

		if (count > 1) { return; }

		var now = Date.now(),
		    delta = now - (last || now);

		touch$$1 = e.touches ? e.touches[0] : e;
		doubleTap = (delta > 0 && delta <= delay);
		last = now;
	}

	function onTouchEnd(e) {
		if (doubleTap && !touch$$1.cancelBubble) {
			if (pointer) {
				if ((!edge) || e.pointerType === 'mouse') { return; }
				// work around .type being readonly with MSPointer* events
				var newTouch = {},
				    prop, i;

				for (i in touch$$1) {
					prop = touch$$1[i];
					newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
				}
				touch$$1 = newTouch;
			}
			touch$$1.type = 'dblclick';
			touch$$1.button = 0;
			handler(touch$$1);
			last = null;
		}
	}

	obj[_pre + _touchstart + id] = onTouchStart;
	obj[_pre + _touchend + id] = onTouchEnd;
	obj[_pre + 'dblclick' + id] = handler;

	obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? {passive: false} : false);
	obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? {passive: false} : false);

	// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
	// the browser doesn't fire touchend/pointerup events but does fire
	// native dblclicks. See #4127.
	// Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.
	obj.addEventListener('dblclick', handler, false);

	return this;
}

function removeDoubleTapListener(obj, id) {
	var touchstart = obj[_pre + _touchstart + id],
	    touchend = obj[_pre + _touchend + id],
	    dblclick = obj[_pre + 'dblclick' + id];

	obj.removeEventListener(_touchstart, touchstart, passiveEvents ? {passive: false} : false);
	obj.removeEventListener(_touchend, touchend, passiveEvents ? {passive: false} : false);
	if (!edge) {
		obj.removeEventListener('dblclick', dblclick, false);
	}

	return this;
}

/*
 * @namespace DomUtil
 *
 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
 * tree, used by Leaflet internally.
 *
 * Most functions expecting or returning a `HTMLElement` also work for
 * SVG elements. The only difference is that classes refer to CSS classes
 * in HTML and SVG classes in SVG.
 */


// @property TRANSFORM: String
// Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
var TRANSFORM = testProp(
	['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

// @property TRANSITION: String
// Vendor-prefixed transition style name.
var TRANSITION = testProp(
	['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

// @property TRANSITION_END: String
// Vendor-prefixed transitionend event name.
var TRANSITION_END =
	TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';


// @function get(id: String|HTMLElement): HTMLElement
// Returns an element given its DOM id, or returns the element itself
// if it was passed directly.
function get(id) {
	return typeof id === 'string' ? document.getElementById(id) : id;
}

// @function getStyle(el: HTMLElement, styleAttrib: String): String
// Returns the value for a certain style attribute on an element,
// including computed values or values set through CSS.
function getStyle(el, style) {
	var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

	if ((!value || value === 'auto') && document.defaultView) {
		var css = document.defaultView.getComputedStyle(el, null);
		value = css ? css[style] : null;
	}
	return value === 'auto' ? null : value;
}

// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
function create$1(tagName, className, container) {
	var el = document.createElement(tagName);
	el.className = className || '';

	if (container) {
		container.appendChild(el);
	}
	return el;
}

// @function remove(el: HTMLElement)
// Removes `el` from its parent element
function remove(el) {
	var parent = el.parentNode;
	if (parent) {
		parent.removeChild(el);
	}
}

// @function empty(el: HTMLElement)
// Removes all of `el`'s children elements from `el`
function empty(el) {
	while (el.firstChild) {
		el.removeChild(el.firstChild);
	}
}

// @function toFront(el: HTMLElement)
// Makes `el` the last child of its parent, so it renders in front of the other children.
function toFront(el) {
	var parent = el.parentNode;
	if (parent && parent.lastChild !== el) {
		parent.appendChild(el);
	}
}

// @function toBack(el: HTMLElement)
// Makes `el` the first child of its parent, so it renders behind the other children.
function toBack(el) {
	var parent = el.parentNode;
	if (parent && parent.firstChild !== el) {
		parent.insertBefore(el, parent.firstChild);
	}
}

// @function hasClass(el: HTMLElement, name: String): Boolean
// Returns `true` if the element's class attribute contains `name`.
function hasClass(el, name) {
	if (el.classList !== undefined) {
		return el.classList.contains(name);
	}
	var className = getClass(el);
	return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
}

// @function addClass(el: HTMLElement, name: String)
// Adds `name` to the element's class attribute.
function addClass(el, name) {
	if (el.classList !== undefined) {
		var classes = splitWords(name);
		for (var i = 0, len = classes.length; i < len; i++) {
			el.classList.add(classes[i]);
		}
	} else if (!hasClass(el, name)) {
		var className = getClass(el);
		setClass(el, (className ? className + ' ' : '') + name);
	}
}

// @function removeClass(el: HTMLElement, name: String)
// Removes `name` from the element's class attribute.
function removeClass(el, name) {
	if (el.classList !== undefined) {
		el.classList.remove(name);
	} else {
		setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
	}
}

// @function setClass(el: HTMLElement, name: String)
// Sets the element's class.
function setClass(el, name) {
	if (el.className.baseVal === undefined) {
		el.className = name;
	} else {
		// in case of SVG element
		el.className.baseVal = name;
	}
}

// @function getClass(el: HTMLElement): String
// Returns the element's class.
function getClass(el) {
	// Check if the element is an SVGElementInstance and use the correspondingElement instead
	// (Required for linked SVG elements in IE11.)
	if (el.correspondingElement) {
		el = el.correspondingElement;
	}
	return el.className.baseVal === undefined ? el.className : el.className.baseVal;
}

// @function setOpacity(el: HTMLElement, opacity: Number)
// Set the opacity of an element (including old IE support).
// `opacity` must be a number from `0` to `1`.
function setOpacity(el, value) {
	if ('opacity' in el.style) {
		el.style.opacity = value;
	} else if ('filter' in el.style) {
		_setOpacityIE(el, value);
	}
}

function _setOpacityIE(el, value) {
	var filter = false,
	    filterName = 'DXImageTransform.Microsoft.Alpha';

	// filters collection throws an error if we try to retrieve a filter that doesn't exist
	try {
		filter = el.filters.item(filterName);
	} catch (e) {
		// don't set opacity to 1 if we haven't already set an opacity,
		// it isn't needed and breaks transparent pngs.
		if (value === 1) { return; }
	}

	value = Math.round(value * 100);

	if (filter) {
		filter.Enabled = (value !== 100);
		filter.Opacity = value;
	} else {
		el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
	}
}

// @function testProp(props: String[]): String|false
// Goes through the array of style names and returns the first name
// that is a valid style name for an element. If no such name is found,
// it returns false. Useful for vendor-prefixed styles like `transform`.
function testProp(props) {
	var style = document.documentElement.style;

	for (var i = 0; i < props.length; i++) {
		if (props[i] in style) {
			return props[i];
		}
	}
	return false;
}

// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
// and optionally scaled by `scale`. Does not have an effect if the
// browser doesn't support 3D CSS transforms.
function setTransform(el, offset, scale) {
	var pos = offset || new Point(0, 0);

	el.style[TRANSFORM] =
		(ie3d ?
			'translate(' + pos.x + 'px,' + pos.y + 'px)' :
			'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
		(scale ? ' scale(' + scale + ')' : '');
}

// @function setPosition(el: HTMLElement, position: Point)
// Sets the position of `el` to coordinates specified by `position`,
// using CSS translate or top/left positioning depending on the browser
// (used by Leaflet internally to position its layers).
function setPosition(el, point) {

	/*eslint-disable */
	el._leaflet_pos = point;
	/* eslint-enable */

	if (any3d) {
		setTransform(el, point);
	} else {
		el.style.left = point.x + 'px';
		el.style.top = point.y + 'px';
	}
}

// @function getPosition(el: HTMLElement): Point
// Returns the coordinates of an element previously positioned with setPosition.
function getPosition(el) {
	// this method is only used for elements previously positioned using setPosition,
	// so it's safe to cache the position for performance

	return el._leaflet_pos || new Point(0, 0);
}

// @function disableTextSelection()
// Prevents the user from generating `selectstart` DOM events, usually generated
// when the user drags the mouse through a page with text. Used internally
// by Leaflet to override the behaviour of any click-and-drag interaction on
// the map. Affects drag interactions on the whole document.

// @function enableTextSelection()
// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
var disableTextSelection;
var enableTextSelection;
var _userSelect;
if ('onselectstart' in document) {
	disableTextSelection = function () {
		on(window, 'selectstart', preventDefault);
	};
	enableTextSelection = function () {
		off(window, 'selectstart', preventDefault);
	};
} else {
	var userSelectProperty = testProp(
		['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

	disableTextSelection = function () {
		if (userSelectProperty) {
			var style = document.documentElement.style;
			_userSelect = style[userSelectProperty];
			style[userSelectProperty] = 'none';
		}
	};
	enableTextSelection = function () {
		if (userSelectProperty) {
			document.documentElement.style[userSelectProperty] = _userSelect;
			_userSelect = undefined;
		}
	};
}

// @function disableImageDrag()
// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
// for `dragstart` DOM events, usually generated when the user drags an image.
function disableImageDrag() {
	on(window, 'dragstart', preventDefault);
}

// @function enableImageDrag()
// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
function enableImageDrag() {
	off(window, 'dragstart', preventDefault);
}

var _outlineElement;
var _outlineStyle;
// @function preventOutline(el: HTMLElement)
// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
// of the element `el` invisible. Used internally by Leaflet to prevent
// focusable elements from displaying an outline when the user performs a
// drag interaction on them.
function preventOutline(element) {
	while (element.tabIndex === -1) {
		element = element.parentNode;
	}
	if (!element.style) { return; }
	restoreOutline();
	_outlineElement = element;
	_outlineStyle = element.style.outline;
	element.style.outline = 'none';
	on(window, 'keydown', restoreOutline);
}

// @function restoreOutline()
// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
function restoreOutline() {
	if (!_outlineElement) { return; }
	_outlineElement.style.outline = _outlineStyle;
	_outlineElement = undefined;
	_outlineStyle = undefined;
	off(window, 'keydown', restoreOutline);
}

// @function getSizedParentNode(el: HTMLElement): HTMLElement
// Finds the closest parent node which size (width and height) is not null.
function getSizedParentNode(element) {
	do {
		element = element.parentNode;
	} while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
	return element;
}

// @function getScale(el: HTMLElement): Object
// Computes the CSS scale currently applied on the element.
// Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
// and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
function getScale(element) {
	var rect = element.getBoundingClientRect(); // Read-only in old browsers.

	return {
		x: rect.width / element.offsetWidth || 1,
		y: rect.height / element.offsetHeight || 1,
		boundingClientRect: rect
	};
}


var DomUtil = (Object.freeze || Object)({
	TRANSFORM: TRANSFORM,
	TRANSITION: TRANSITION,
	TRANSITION_END: TRANSITION_END,
	get: get,
	getStyle: getStyle,
	create: create$1,
	remove: remove,
	empty: empty,
	toFront: toFront,
	toBack: toBack,
	hasClass: hasClass,
	addClass: addClass,
	removeClass: removeClass,
	setClass: setClass,
	getClass: getClass,
	setOpacity: setOpacity,
	testProp: testProp,
	setTransform: setTransform,
	setPosition: setPosition,
	getPosition: getPosition,
	disableTextSelection: disableTextSelection,
	enableTextSelection: enableTextSelection,
	disableImageDrag: disableImageDrag,
	enableImageDrag: enableImageDrag,
	preventOutline: preventOutline,
	restoreOutline: restoreOutline,
	getSizedParentNode: getSizedParentNode,
	getScale: getScale
});

/*
 * @namespace DomEvent
 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
 */

// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Adds a listener function (`fn`) to a particular DOM event type of the
// element `el`. You can optionally specify the context of the listener
// (object the `this` keyword will point to). You can also pass several
// space-separated types (e.g. `'click dblclick'`).

// @alternative
// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
function on(obj, types, fn, context) {

	if (typeof types === 'object') {
		for (var type in types) {
			addOne(obj, type, types[type], fn);
		}
	} else {
		types = splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			addOne(obj, types[i], fn, context);
		}
	}

	return this;
}

var eventsKey = '_leaflet_events';

// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Removes a previously added listener function.
// Note that if you passed a custom context to on, you must pass the same
// context to `off` in order to remove the listener.

// @alternative
// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
function off(obj, types, fn, context) {

	if (typeof types === 'object') {
		for (var type in types) {
			removeOne(obj, type, types[type], fn);
		}
	} else if (types) {
		types = splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			removeOne(obj, types[i], fn, context);
		}
	} else {
		for (var j in obj[eventsKey]) {
			removeOne(obj, j, obj[eventsKey][j]);
		}
		delete obj[eventsKey];
	}

	return this;
}

function addOne(obj, type, fn, context) {
	var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

	if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

	var handler = function (e) {
		return fn.call(context || obj, e || window.event);
	};

	var originalHandler = handler;

	if (pointer && type.indexOf('touch') === 0) {
		// Needs DomEvent.Pointer.js
		addPointerListener(obj, type, handler, id);

	} else if (touch && (type === 'dblclick') && addDoubleTapListener &&
	           !(pointer && chrome)) {
		// Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener
		// See #5180
		addDoubleTapListener(obj, handler, id);

	} else if ('addEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, passiveEvents ? {passive: false} : false);

		} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
			handler = function (e) {
				e = e || window.event;
				if (isExternalTarget(obj, e)) {
					originalHandler(e);
				}
			};
			obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

		} else {
			if (type === 'click' && android) {
				handler = function (e) {
					filterClick(e, originalHandler);
				};
			}
			obj.addEventListener(type, handler, false);
		}

	} else if ('attachEvent' in obj) {
		obj.attachEvent('on' + type, handler);
	}

	obj[eventsKey] = obj[eventsKey] || {};
	obj[eventsKey][id] = handler;
}

function removeOne(obj, type, fn, context) {

	var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),
	    handler = obj[eventsKey] && obj[eventsKey][id];

	if (!handler) { return this; }

	if (pointer && type.indexOf('touch') === 0) {
		removePointerListener(obj, type, id);

	} else if (touch && (type === 'dblclick') && removeDoubleTapListener &&
	           !(pointer && chrome)) {
		removeDoubleTapListener(obj, id);

	} else if ('removeEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, passiveEvents ? {passive: false} : false);

		} else {
			obj.removeEventListener(
				type === 'mouseenter' ? 'mouseover' :
				type === 'mouseleave' ? 'mouseout' : type, handler, false);
		}

	} else if ('detachEvent' in obj) {
		obj.detachEvent('on' + type, handler);
	}

	obj[eventsKey][id] = null;
}

// @function stopPropagation(ev: DOMEvent): this
// Stop the given event from propagation to parent elements. Used inside the listener functions:
// ```js
// L.DomEvent.on(div, 'click', function (ev) {
// 	L.DomEvent.stopPropagation(ev);
// });
// ```
function stopPropagation(e) {

	if (e.stopPropagation) {
		e.stopPropagation();
	} else if (e.originalEvent) {  // In case of Leaflet event.
		e.originalEvent._stopped = true;
	} else {
		e.cancelBubble = true;
	}
	skipped(e);

	return this;
}

// @function disableScrollPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
function disableScrollPropagation(el) {
	addOne(el, 'mousewheel', stopPropagation);
	return this;
}

// @function disableClickPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
// `'mousedown'` and `'touchstart'` events (plus browser variants).
function disableClickPropagation(el) {
	on(el, 'mousedown touchstart dblclick', stopPropagation);
	addOne(el, 'click', fakeStop);
	return this;
}

// @function preventDefault(ev: DOMEvent): this
// Prevents the default action of the DOM Event `ev` from happening (such as
// following a link in the href of the a element, or doing a POST request
// with page reload when a `<form>` is submitted).
// Use it inside listener functions.
function preventDefault(e) {
	if (e.preventDefault) {
		e.preventDefault();
	} else {
		e.returnValue = false;
	}
	return this;
}

// @function stop(ev: DOMEvent): this
// Does `stopPropagation` and `preventDefault` at the same time.
function stop(e) {
	preventDefault(e);
	stopPropagation(e);
	return this;
}

// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
// Gets normalized mouse position from a DOM event relative to the
// `container` (border excluded) or to the whole page if not specified.
function getMousePosition(e, container) {
	if (!container) {
		return new Point(e.clientX, e.clientY);
	}

	var scale = getScale(container),
	    offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

	return new Point(
		// offset.left/top values are in page scale (like clientX/Y),
		// whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
		(e.clientX - offset.left) / scale.x - container.clientLeft,
		(e.clientY - offset.top) / scale.y - container.clientTop
	);
}

// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
// and Firefox scrolls device pixels, not CSS pixels
var wheelPxFactor =
	(win && chrome) ? 2 * window.devicePixelRatio :
	gecko ? window.devicePixelRatio : 1;

// @function getWheelDelta(ev: DOMEvent): Number
// Gets normalized wheel delta from a mousewheel DOM event, in vertical
// pixels scrolled (negative if scrolling down).
// Events from pointing devices without precise scrolling are mapped to
// a best guess of 60 pixels.
function getWheelDelta(e) {
	return (edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
	       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels
	       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
	       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
	       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
	       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
	       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
	       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
	       0;
}

var skipEvents = {};

function fakeStop(e) {
	// fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
	skipEvents[e.type] = true;
}

function skipped(e) {
	var events = skipEvents[e.type];
	// reset when checking, as it's only used in map container and propagates outside of the map
	skipEvents[e.type] = false;
	return events;
}

// check if element really left/entered the event target (for mouseenter/mouseleave)
function isExternalTarget(el, e) {

	var related = e.relatedTarget;

	if (!related) { return true; }

	try {
		while (related && (related !== el)) {
			related = related.parentNode;
		}
	} catch (err) {
		return false;
	}
	return (related !== el);
}

var lastClick;

// this is a horrible workaround for a bug in Android where a single touch triggers two click events
function filterClick(e, handler) {
	var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
	    elapsed = lastClick && (timeStamp - lastClick);

	// are they closer together than 500ms yet more than 100ms?
	// Android typically triggers them ~300ms apart while multiple listeners
	// on the same event should be triggered far faster;
	// or check if click is simulated on the element, and if it is, reject any non-simulated events

	if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
		stop(e);
		return;
	}
	lastClick = timeStamp;

	handler(e);
}




var DomEvent = (Object.freeze || Object)({
	on: on,
	off: off,
	stopPropagation: stopPropagation,
	disableScrollPropagation: disableScrollPropagation,
	disableClickPropagation: disableClickPropagation,
	preventDefault: preventDefault,
	stop: stop,
	getMousePosition: getMousePosition,
	getWheelDelta: getWheelDelta,
	fakeStop: fakeStop,
	skipped: skipped,
	isExternalTarget: isExternalTarget,
	addListener: on,
	removeListener: off
});

/*
 * @class PosAnimation
 * @aka L.PosAnimation
 * @inherits Evented
 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
 *
 * @example
 * ```js
 * var fx = new L.PosAnimation();
 * fx.run(el, [300, 500], 0.5);
 * ```
 *
 * @constructor L.PosAnimation()
 * Creates a `PosAnimation` object.
 *
 */

var PosAnimation = Evented.extend({

	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
	// Run an animation of a given element to a new position, optionally setting
	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
	// `0.5` by default).
	run: function (el, newPos, duration, easeLinearity) {
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		// @event start: Event
		// Fired when the animation starts
		this.fire('start');

		this._animate();
	},

	// @method stop()
	// Stops the animation (if currently running).
	stop: function () {
		if (!this._inProgress) { return; }

		this._step(true);
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function (round) {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		setPosition(this._el, pos);

		// @event step: Event
		// Fired continuously during the animation.
		this.fire('step');
	},

	_complete: function () {
		cancelAnimFrame(this._animId);

		this._inProgress = false;
		// @event end: Event
		// Fired when the animation ends.
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});

/*
 * @class Map
 * @aka L.Map
 * @inherits Evented
 *
 * The central class of the API  it is used to create a map on a page and manipulate it.
 *
 * @example
 *
 * ```js
 * // initialize the map on the "map" div with a given center and zoom
 * var map = L.map('map', {
 * 	center: [51.505, -0.09],
 * 	zoom: 13
 * });
 * ```
 *
 */

var Map = Evented.extend({

	options: {
		// @section Map State Options
		// @option crs: CRS = L.CRS.EPSG3857
		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
		// sure what it means.
		crs: EPSG3857,

		// @option center: LatLng = undefined
		// Initial geographic center of the map
		center: undefined,

		// @option zoom: Number = undefined
		// Initial map zoom level
		zoom: undefined,

		// @option minZoom: Number = *
		// Minimum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the lowest of their `minZoom` options will be used instead.
		minZoom: undefined,

		// @option maxZoom: Number = *
		// Maximum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the highest of their `maxZoom` options will be used instead.
		maxZoom: undefined,

		// @option layers: Layer[] = []
		// Array of layers that will be added to the map initially
		layers: [],

		// @option maxBounds: LatLngBounds = null
		// When this option is set, the map restricts the view to the given
		// geographical bounds, bouncing the user back if the user tries to pan
		// outside the view. To set the restriction dynamically, use
		// [`setMaxBounds`](#map-setmaxbounds) method.
		maxBounds: undefined,

		// @option renderer: Renderer = *
		// The default method for drawing vector layers on the map. `L.SVG`
		// or `L.Canvas` by default depending on browser support.
		renderer: undefined,


		// @section Animation Options
		// @option zoomAnimation: Boolean = true
		// Whether the map zoom animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		zoomAnimation: true,

		// @option zoomAnimationThreshold: Number = 4
		// Won't animate zoom if the zoom difference exceeds this value.
		zoomAnimationThreshold: 4,

		// @option fadeAnimation: Boolean = true
		// Whether the tile fade animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		fadeAnimation: true,

		// @option markerZoomAnimation: Boolean = true
		// Whether markers animate their zoom with the zoom animation, if disabled
		// they will disappear for the length of the animation. By default it's
		// enabled in all browsers that support CSS3 Transitions except Android.
		markerZoomAnimation: true,

		// @option transform3DLimit: Number = 2^23
		// Defines the maximum size of a CSS translation transform. The default
		// value should not be changed unless a web browser positions layers in
		// the wrong place after doing a large `panBy`.
		transform3DLimit: 8388608, // Precision limit of a 32-bit float

		// @section Interaction Options
		// @option zoomSnap: Number = 1
		// Forces the map's zoom level to always be a multiple of this, particularly
		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
		// By default, the zoom level snaps to the nearest integer; lower values
		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
		zoomSnap: 1,

		// @option zoomDelta: Number = 1
		// Controls how much the map's zoom level will change after a
		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
		zoomDelta: 1,

		// @option trackResize: Boolean = true
		// Whether the map automatically handles browser window resize to update itself.
		trackResize: true
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = setOptions(this, options);

		// Make sure to assign internal flags at the beginning,
		// to avoid inconsistent state in some edge cases.
		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(toLatLng(options.center), options.zoom, {reset: true});
		}

		this.callInitHooks();

		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = TRANSITION && any3d && !mobileOpera &&
				this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			this._createAnimProxy();
			on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
		}

		this._addLayers(this.options.layers);
	},


	// @section Methods for modifying map state

	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) with the given
	// animation options.
	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
		options = options || {};

		this._stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = extend({animate: options.animate}, options.zoom);
				options.pan = extend({animate: options.animate, duration: options.duration}, options.pan);
			}

			// try animating pan or zoom
			var moved = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (moved) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	// @method setZoom(zoom: Number, options?: Zoom/pan options): this
	// Sets the zoom of the map.
	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = zoom;
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	// @method zoomIn(delta?: Number, options?: Zoom options): this
	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomIn: function (delta, options) {
		delta = delta || (any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom + delta, options);
	},

	// @method zoomOut(delta?: Number, options?: Zoom options): this
	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomOut: function (delta, options) {
		delta = delta || (any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom - delta, options);
	},

	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified geographical point on the map
	// stationary (e.g. used internally for scroll zoom and double-click zoom).
	// @alternative
	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	_getBoundsCenterZoom: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);

		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

		if (zoom === Infinity) {
			return {
				center: bounds.getCenter(),
				zoom: zoom
			};
		}

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets a map view that contains the given geographical bounds with the
	// maximum zoom level possible.
	fitBounds: function (bounds, options) {

		bounds = toLatLngBounds(bounds);

		if (!bounds.isValid()) {
			throw new Error('Bounds are not valid.');
		}

		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	// @method fitWorld(options?: fitBounds options): this
	// Sets a map view that mostly contains the whole world with the maximum
	// zoom level possible.
	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	// @method panTo(latlng: LatLng, options?: Pan options): this
	// Pans the map to a given center.
	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	// @method panBy(offset: Point, options?: Pan options): this
	// Pans the map by a given number of pixels (animated).
	panBy: function (offset, options) {
		offset = toPoint(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this.fire('moveend');
		}
		// If we pan too far, Chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset).round();
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) performing a smooth
	// pan-zoom animation.
	flyTo: function (targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false || !any3d) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this._stop();

		var from = this.project(this.getCenter()),
		    to = this.project(targetCenter),
		    size = this.getSize(),
		    startZoom = this._zoom;

		targetCenter = toLatLng(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
		    u1 = (to.distanceTo(from)) || 1,
		    rho = 1.42,
		    rho2 = rho * rho;

		function r(i) {
			var s1 = i ? -1 : 1,
			    s2 = i ? w1 : w0,
			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
			    b1 = 2 * s2 * rho2 * u1,
			    b = t1 / b1,
			    sq = Math.sqrt(b * b + 1) - b;

			    // workaround for floating point precision bug when sq = 0, log = -Infinite,
			    // thus triggering an infinite loop in flyTo
			    var log = sq < 0.000000001 ? -18 : Math.log(sq);

			return log;
		}

		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
		function tanh(n) { return sinh(n) / cosh(n); }

		var r0 = r(0);

		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

		var start = Date.now(),
		    S = (r(1) - r0) / rho,
		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
			    s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = requestAnimFrame(frame, this);

				this._move(
					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
					this.getScaleZoom(w0 / w(s), startZoom),
					{flyTo: true});

			} else {
				this
					._move(targetCenter, targetZoom)
					._moveEnd(true);
			}
		}

		this._moveStart(true, options.noMoveStart);

		frame.call(this);
		return this;
	},

	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
	flyToBounds: function (bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	},

	// @method setMaxBounds(bounds: Bounds): this
	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
	setMaxBounds: function (bounds) {
		bounds = toLatLngBounds(bounds);

		if (!bounds.isValid()) {
			this.options.maxBounds = null;
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	// @method setMinZoom(zoom: Number): this
	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
	setMinZoom: function (zoom) {
		var oldZoom = this.options.minZoom;
		this.options.minZoom = zoom;

		if (this._loaded && oldZoom !== zoom) {
			this.fire('zoomlevelschange');

			if (this.getZoom() < this.options.minZoom) {
				return this.setZoom(zoom);
			}
		}

		return this;
	},

	// @method setMaxZoom(zoom: Number): this
	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
	setMaxZoom: function (zoom) {
		var oldZoom = this.options.maxZoom;
		this.options.maxZoom = zoom;

		if (this._loaded && oldZoom !== zoom) {
			this.fire('zoomlevelschange');

			if (this.getZoom() > this.options.maxZoom) {
				return this.setZoom(zoom);
			}
		}

		return this;
	},

	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
	panInsideBounds: function (bounds, options) {
		this._enforcingBounds = true;
		var center = this.getCenter(),
		    newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

		if (!center.equals(newCenter)) {
			this.panTo(newCenter, options);
		}

		this._enforcingBounds = false;
		return this;
	},

	// @method panInside(latlng: LatLng, options?: options): this
	// Pans the map the minimum amount to make the `latlng` visible. Use
	// `padding`, `paddingTopLeft` and `paddingTopRight` options to fit
	// the display to more restricted bounds, like [`fitBounds`](#map-fitbounds).
	// If `latlng` is already within the (optionally padded) display bounds,
	// the map will not be panned.
	panInside: function (latlng, options) {
		options = options || {};

		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
		    center = this.getCenter(),
		    pixelCenter = this.project(center),
		    pixelPoint = this.project(latlng),
		    pixelBounds = this.getPixelBounds(),
		    halfPixelBounds = pixelBounds.getSize().divideBy(2),
		    paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);

		if (!paddedBounds.contains(pixelPoint)) {
			this._enforcingBounds = true;
			var diff = pixelCenter.subtract(pixelPoint),
			    newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);

			if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {
				newCenter.x = pixelCenter.x - diff.x;
				if (diff.x > 0) {
					newCenter.x += halfPixelBounds.x - paddingTL.x;
				} else {
					newCenter.x -= halfPixelBounds.x - paddingBR.x;
				}
			}
			if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {
				newCenter.y = pixelCenter.y - diff.y;
				if (diff.y > 0) {
					newCenter.y += halfPixelBounds.y - paddingTL.y;
				} else {
					newCenter.y -= halfPixelBounds.y - paddingBR.y;
				}
			}
			this.panTo(this.unproject(newCenter), options);
			this._enforcingBounds = false;
		}
		return this;
	},

	// @method invalidateSize(options: Zoom/pan options): this
	// Checks if the map container size changed and updates the map if so 
	// call it after you've changed the map size dynamically, also animating
	// pan by default. If `options.pan` is `false`, panning will not occur.
	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
	// that it doesn't happen often even if the method is called many
	// times in a row.

	// @alternative
	// @method invalidateSize(animate: Boolean): this
	// Checks if the map container size changed and updates the map if so 
	// call it after you've changed the map size dynamically, also animating
	// pan by default.
	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._lastCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		// @section Map state change events
		// @event resize: ResizeEvent
		// Fired when the map is resized.
		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// @section Methods for modifying map state
	// @method stop(): this
	// Stops the currently running `panTo` or `flyTo` animation, if any.
	stop: function () {
		this.setZoom(this._limitZoom(this._zoom));
		if (!this.options.zoomSnap) {
			this.fire('viewreset');
		}
		return this._stop();
	},

	// @section Geolocation methods
	// @method locate(options?: Locate options): this
	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
	// and optionally sets the map view to the user's location with respect to
	// detection accuracy (or to the world view if geolocation failed).
	// Note that, if your page doesn't use HTTPS, this method will fail in
	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
	// See `Locate options` for more details.
	locate: function (options) {

		options = this._locateOptions = extend({
			timeout: 10000,
			watch: false
			// setView: false
			// maxZoom: <Number>
			// maximumAge: 0
			// enableHighAccuracy: false
		}, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = bind(this._handleGeolocationResponse, this),
		    onError = bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	// @method stopLocate(): this
	// Stops watching location previously initiated by `map.locate({watch: true})`
	// and aborts resetting the map view if map.locate was called with
	// `{setView: true}`.
	stopLocate: function () {
		if (navigator.geolocation && navigator.geolocation.clearWatch) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		// @section Location events
		// @event locationerror: ErrorEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new LatLng(lat, lng),
		    bounds = latlng.toBounds(pos.coords.accuracy * 2),
		    options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		// @event locationfound: LocationEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method)
		// went successfully.
		this.fire('locationfound', data);
	},

	// TODO Appropriate docs section?
	// @section Other Methods
	// @method addHandler(name: String, HandlerClass: Function): this
	// Adds a new `Handler` to the map, given its name and constructor function.
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	// @method remove(): this
	// Destroys the map and clears all related event listeners.
	remove: function () {

		this._initEvents(true);

		if (this._containerId !== this._container._leaflet_id) {
			throw new Error('Map container is being reused by another instance');
		}

		try {
			// throws error in IE6-8
			delete this._container._leaflet_id;
			delete this._containerId;
		} catch (e) {
			/*eslint-disable */
			this._container._leaflet_id = undefined;
			/* eslint-enable */
			this._containerId = undefined;
		}

		if (this._locationWatchId !== undefined) {
			this.stopLocate();
		}

		this._stop();

		remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}
		if (this._resizeRequest) {
			cancelAnimFrame(this._resizeRequest);
			this._resizeRequest = null;
		}

		this._clearHandlers();

		if (this._loaded) {
			// @section Map state change events
			// @event unload: Event
			// Fired when the map is destroyed with [remove](#map-remove) method.
			this.fire('unload');
		}

		var i;
		for (i in this._layers) {
			this._layers[i].remove();
		}
		for (i in this._panes) {
			remove(this._panes[i]);
		}

		this._layers = [];
		this._panes = [];
		delete this._mapPane;
		delete this._renderer;

		return this;
	},

	// @section Other Methods
	// @method createPane(name: String, container?: HTMLElement): HTMLElement
	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
	// then returns it. The pane is created as a child of `container`, or
	// as a child of the main map pane if not set.
	createPane: function (name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
		    pane = create$1('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},

	// @section Methods for Getting Map State

	// @method getCenter(): LatLng
	// Returns the geographical center of the map view
	getCenter: function () {
		this._checkIfLoaded();

		if (this._lastCenter && !this._moved()) {
			return this._lastCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	// @method getZoom(): Number
	// Returns the current zoom level of the map view
	getZoom: function () {
		return this._zoom;
	},

	// @method getBounds(): LatLngBounds
	// Returns the geographical bounds visible in the current map view
	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new LatLngBounds(sw, ne);
	},

	// @method getMinZoom(): Number
	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
	getMinZoom: function () {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	// @method getMaxZoom(): Number
	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
	// Returns the maximum zoom level on which the given bounds fit to the map
	// view in its entirety. If `inside` (optional) is set to `true`, the method
	// instead returns the minimum zoom level on which the map view fits into
	// the given bounds in its entirety.
	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = toLatLngBounds(bounds);
		padding = toPoint(padding || [0, 0]);

		var zoom = this.getZoom() || 0,
		    min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),
		    size = this.getSize().subtract(padding),
		    boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
		    snap = any3d ? this.options.zoomSnap : 1,
		    scalex = size.x / boundsSize.x,
		    scaley = size.y / boundsSize.y,
		    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

		zoom = this.getScaleZoom(scale, zoom);

		if (snap) {
			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
		}

		return Math.max(min, Math.min(max, zoom));
	},

	// @method getSize(): Point
	// Returns the current size of the map container (in pixels).
	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new Point(
				this._container.clientWidth || 0,
				this._container.clientHeight || 0);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	// @method getPixelBounds(): Bounds
	// Returns the bounds of the current map view in projected pixel
	// coordinates (sometimes useful in layer and overlay implementations).
	getPixelBounds: function (center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
	// the map pane? "left point of the map layer" can be confusing, specially
	// since there can be negative offsets.
	// @method getPixelOrigin(): Point
	// Returns the projected pixel coordinates of the top left point of
	// the map layer (useful in custom layer and overlay implementations).
	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	// @method getPixelWorldBounds(zoom?: Number): Bounds
	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
	// If `zoom` is omitted, the map's current zoom level is used.
	getPixelWorldBounds: function (zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	// @section Other Methods

	// @method getPane(pane: String|HTMLElement): HTMLElement
	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
	getPane: function (pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	// @method getPanes(): Object
	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
	// the panes as values.
	getPanes: function () {
		return this._panes;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the map.
	getContainer: function () {
		return this._container;
	},


	// @section Conversion Methods

	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
	// Returns the scale factor to be applied to a map transition from zoom level
	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
	getZoomScale: function (toZoom, fromZoom) {
		// TODO replace with universal implementation after refactoring projections
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
	// level and everything is scaled by a factor of `scale`. Inverse of
	// [`getZoomScale`](#map-getZoomScale).
	getScaleZoom: function (scale, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		var zoom = crs.zoom(scale * crs.scale(fromZoom));
		return isNaN(zoom) ? Infinity : zoom;
	},

	// @method project(latlng: LatLng, zoom: Number): Point
	// Projects a geographical coordinate `LatLng` according to the projection
	// of the map's CRS, then scales it according to `zoom` and the CRS's
	// `Transformation`. The result is pixel coordinate relative to
	// the CRS origin.
	project: function (latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
	},

	// @method unproject(point: Point, zoom: Number): LatLng
	// Inverse of [`project`](#map-project).
	unproject: function (point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(toPoint(point), zoom);
	},

	// @method layerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding geographical coordinate (for the current zoom level).
	layerPointToLatLng: function (point) {
		var projectedPoint = toPoint(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	// @method latLngToLayerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the [origin pixel](#map-getpixelorigin).
	latLngToLayerPoint: function (latlng) {
		var projectedPoint = this.project(toLatLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
	// CRS's bounds.
	// By default this means longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees.
	wrapLatLng: function (latlng) {
		return this.options.crs.wrapLatLng(toLatLng(latlng));
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring that
	// its center is within the CRS's bounds.
	// By default this means the center longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees, and the majority of the bounds
	// overlaps the CRS's bounds.
	wrapLatLngBounds: function (latlng) {
		return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates according to
	// the map's CRS. By default this measures distance in meters.
	distance: function (latlng1, latlng2) {
		return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
	},

	// @method containerPointToLayerPoint(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns the corresponding
	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
	containerPointToLayerPoint: function (point) { // (Point)
		return toPoint(point).subtract(this._getMapPanePos());
	},

	// @method layerPointToContainerPoint(point: Point): Point
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding pixel coordinate relative to the map container.
	layerPointToContainerPoint: function (point) { // (Point)
		return toPoint(point).add(this._getMapPanePos());
	},

	// @method containerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the map container, returns
	// the corresponding geographical coordinate (for the current zoom level).
	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(toPoint(point));
		return this.layerPointToLatLng(layerPoint);
	},

	// @method latLngToContainerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the map container.
	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
	},

	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to the
	// map container where the event took place.
	mouseEventToContainerPoint: function (e) {
		return getMousePosition(e, this._container);
	},

	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to
	// the [origin pixel](#map-getpixelorigin) where the event took place.
	mouseEventToLayerPoint: function (e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
	// Given a MouseEvent object, returns geographical coordinate where the
	// event took place.
	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet_id) {
			throw new Error('Map container is already initialized.');
		}

		on(container, 'scroll', this._onScroll, this);
		this._containerId = stamp(container);
	},

	_initLayout: function () {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && any3d;

		addClass(container, 'leaflet-container' +
			(touch ? ' leaflet-touch' : '') +
			(retina ? ' leaflet-retina' : '') +
			(ielt9 ? ' leaflet-oldie' : '') +
			(safari ? ' leaflet-safari' : '') +
			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};
		this._paneRenderers = {};

		// @section
		//
		// Panes are DOM elements used to control the ordering of layers on the map. You
		// can access panes with [`map.getPane`](#map-getpane) or
		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
		// [`map.createPane`](#map-createpane) method.
		//
		// Every map has the following default panes that differ only in zIndex.
		//
		// @pane mapPane: HTMLElement = 'auto'
		// Pane that contains all other map panes

		this._mapPane = this.createPane('mapPane', this._container);
		setPosition(this._mapPane, new Point(0, 0));

		// @pane tilePane: HTMLElement = 200
		// Pane for `GridLayer`s and `TileLayer`s
		this.createPane('tilePane');
		// @pane overlayPane: HTMLElement = 400
		// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
		this.createPane('shadowPane');
		// @pane shadowPane: HTMLElement = 500
		// Pane for overlay shadows (e.g. `Marker` shadows)
		this.createPane('overlayPane');
		// @pane markerPane: HTMLElement = 600
		// Pane for `Icon`s of `Marker`s
		this.createPane('markerPane');
		// @pane tooltipPane: HTMLElement = 650
		// Pane for `Tooltip`s.
		this.createPane('tooltipPane');
		// @pane popupPane: HTMLElement = 700
		// Pane for `Popup`s.
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			addClass(panes.markerPane, 'leaflet-zoom-hide');
			addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},


	// private methods that modify map state

	// @section Map state change events
	_resetView: function (center, zoom) {
		setPosition(this._mapPane, new Point(0, 0));

		var loading = !this._loaded;
		this._loaded = true;
		zoom = this._limitZoom(zoom);

		this.fire('viewprereset');

		var zoomChanged = this._zoom !== zoom;
		this
			._moveStart(zoomChanged, false)
			._move(center, zoom)
			._moveEnd(zoomChanged);

		// @event viewreset: Event
		// Fired when the map needs to redraw its content (this usually happens
		// on map zoom or load). Very useful for creating custom overlays.
		this.fire('viewreset');

		// @event load: Event
		// Fired when the map is initialized (when its center and zoom are set
		// for the first time).
		if (loading) {
			this.fire('load');
		}
	},

	_moveStart: function (zoomChanged, noMoveStart) {
		// @event zoomstart: Event
		// Fired when the map zoom is about to change (e.g. before zoom animation).
		// @event movestart: Event
		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
		if (zoomChanged) {
			this.fire('zoomstart');
		}
		if (!noMoveStart) {
			this.fire('movestart');
		}
		return this;
	},

	_move: function (center, zoom, data) {
		if (zoom === undefined) {
			zoom = this._zoom;
		}
		var zoomChanged = this._zoom !== zoom;

		this._zoom = zoom;
		this._lastCenter = center;
		this._pixelOrigin = this._getNewPixelOrigin(center);

		// @event zoom: Event
		// Fired repeatedly during any change in zoom level, including zoom
		// and fly animations.
		if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
			this.fire('zoom', data);
		}

		// @event move: Event
		// Fired repeatedly during any movement of the map, including pan and
		// fly animations.
		return this.fire('move', data);
	},

	_moveEnd: function (zoomChanged) {
		// @event zoomend: Event
		// Fired when the map has changed, after any animations.
		if (zoomChanged) {
			this.fire('zoomend');
		}

		// @event moveend: Event
		// Fired when the center of the map stops changing (e.g. user stopped
		// dragging the map).
		return this.fire('moveend');
	},

	_stop: function () {
		cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	_rawPanBy: function (offset) {
		setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function () {
		if (!this._enforcingBounds) {
			this.panInsideBounds(this.options.maxBounds);
		}
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	// @section Interaction events
	_initEvents: function (remove$$1) {
		this._targets = {};
		this._targets[stamp(this._container)] = this;

		var onOff = remove$$1 ? off : on;

		// @event click: MouseEvent
		// Fired when the user clicks (or taps) the map.
		// @event dblclick: MouseEvent
		// Fired when the user double-clicks (or double-taps) the map.
		// @event mousedown: MouseEvent
		// Fired when the user pushes the mouse button on the map.
		// @event mouseup: MouseEvent
		// Fired when the user releases the mouse button on the map.
		// @event mouseover: MouseEvent
		// Fired when the mouse enters the map.
		// @event mouseout: MouseEvent
		// Fired when the mouse leaves the map.
		// @event mousemove: MouseEvent
		// Fired while the mouse moves over the map.
		// @event contextmenu: MouseEvent
		// Fired when the user pushes the right mouse button on the map, prevents
		// default browser context menu from showing if there are listeners on
		// this event. Also fired on mobile when the user holds a single touch
		// for a second (also called long press).
		// @event keypress: KeyboardEvent
		// Fired when the user presses a key from the keyboard that produces a character value while the map is focused.
		// @event keydown: KeyboardEvent
		// Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,
		// the `keydown` event is fired for keys that produce a character value and for keys
		// that do not produce a character value.
		// @event keyup: KeyboardEvent
		// Fired when the user releases a key from the keyboard while the map is focused.
		onOff(this._container, 'click dblclick mousedown mouseup ' +
			'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			onOff(window, 'resize', this._onResize, this);
		}

		if (any3d && this.options.transform3DLimit) {
			(remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
		}
	},

	_onResize: function () {
		cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this);
	},

	_onScroll: function () {
		this._container.scrollTop  = 0;
		this._container.scrollLeft = 0;
	},

	_onMoveEnd: function () {
		var pos = this._getMapPanePos();
		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
			this._resetView(this.getCenter(), this.getZoom());
		}
	},

	_findEventTargets: function (e, type) {
		var targets = [],
		    target,
		    isHover = type === 'mouseout' || type === 'mouseover',
		    src = e.target || e.srcElement,
		    dragging = false;

		while (src) {
			target = this._targets[stamp(src)];
			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
				// Prevent firing click after you just dragged an object.
				dragging = true;
				break;
			}
			if (target && target.listens(type, true)) {
				if (isHover && !isExternalTarget(src, e)) { break; }
				targets.push(target);
				if (isHover) { break; }
			}
			if (src === this._container) { break; }
			src = src.parentNode;
		}
		if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
			targets = [this];
		}
		return targets;
	},

	_handleDOMEvent: function (e) {
		if (!this._loaded || skipped(e)) { return; }

		var type = e.type;

		if (type === 'mousedown' || type === 'keypress' || type === 'keyup' || type === 'keydown') {
			// prevents outline when clicking on keyboard-focusable element
			preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(e, type);
	},

	_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

	_fireDOMEvent: function (e, type, targets) {

		if (e.type === 'click') {
			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
			// @event preclick: MouseEvent
			// Fired before mouse click on the map (sometimes useful when you
			// want something to happen on click before any existing click
			// handlers start running).
			var synth = extend({}, e);
			synth.type = 'preclick';
			this._fireDOMEvent(synth, synth.type, targets);
		}

		if (e._stopped) { return; }

		// Find the layer the event is propagating from and its parents.
		targets = (targets || []).concat(this._findEventTargets(e, type));

		if (!targets.length) { return; }

		var target = targets[0];
		if (type === 'contextmenu' && target.listens(type, true)) {
			preventDefault(e);
		}

		var data = {
			originalEvent: e
		};

		if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {
			var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
			data.containerPoint = isMarker ?
				this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
		}

		for (var i = 0; i < targets.length; i++) {
			targets[i].fire(type, data, true);
			if (data.originalEvent._stopped ||
				(targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1)) { return; }
		}
	},

	_draggableMoved: function (obj) {
		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	// @section Other Methods

	// @method whenReady(fn: Function, context?: Object): this
	// Runs the given function `fn` when the map gets initialized with
	// a view (center and zoom) and at least one layer, or immediately
	// if it's already initialized, optionally passing a function context.
	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, {target: this});
		} else {
			this.on('load', callback, context);
		}
		return this;
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return getPosition(this._mapPane) || new Point(0, 0);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function (center, zoom) {
		var pixelOrigin = center && zoom !== undefined ?
			this._getNewPixelOrigin(center, zoom) :
			this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function (latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return toBounds([
			this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
		]);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		// If offset is less than a pixel, ignore.
		// This prevents unstable projections from getting into
		// an infinite loop of tiny offsets.
		if (offset.round().equals([0, 0])) {
			return center;
		}

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var projectedMaxBounds = toBounds(
		        this.project(maxBounds.getNorthEast(), zoom),
		        this.project(maxBounds.getSouthWest(), zoom)
		    ),
		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

		    dx = this._rebound(minOffset.x, -maxOffset.x),
		    dy = this._rebound(minOffset.y, -maxOffset.y);

		return new Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    snap = any3d ? this.options.zoomSnap : 1;
		if (snap) {
			zoom = Math.round(zoom / snap) * snap;
		}
		return Math.max(min, Math.min(max, zoom));
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._trunc();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	},

	_createAnimProxy: function () {

		var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = TRANSFORM,
			    transform = this._proxy.style[prop];

			setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === this._proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', this._animMoveEnd, this);

		this._on('unload', this._destroyAnimProxy, this);
	},

	_destroyAnimProxy: function () {
		remove(this._proxy);
		this.off('load moveend', this._animMoveEnd, this);
		delete this._proxy;
	},

	_animMoveEnd: function () {
		var c = this.getCenter(),
		    z = this.getZoom();
		setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
	},

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		requestAnimFrame(function () {
			this
			    ._moveStart(true, false)
			    ._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function (center, zoom, startAnim, noUpdate) {
		if (!this._mapPane) { return; }

		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		// @section Other Events
		// @event zoomanim: ZoomAnimEvent
		// Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.
		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			noUpdate: noUpdate
		});

		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
		setTimeout(bind(this._onZoomTransitionEnd, this), 250);
	},

	_onZoomTransitionEnd: function () {
		if (!this._animatingZoom) { return; }

		if (this._mapPane) {
			removeClass(this._mapPane, 'leaflet-zoom-anim');
		}

		this._animatingZoom = false;

		this._move(this._animateToCenter, this._animateToZoom);

		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
		requestAnimFrame(function () {
			this._moveEnd(true);
		}, this);
	}
});

// @section

// @factory L.map(id: String, options?: Map options)
// Instantiates a map object given the DOM ID of a `<div>` element
// and optionally an object literal with `Map options`.
//
// @alternative
// @factory L.map(el: HTMLElement, options?: Map options)
// Instantiates a map object given an instance of a `<div>` HTML element
// and optionally an object literal with `Map options`.
function createMap(id, options) {
	return new Map(id, options);
}

/*
 * @class Control
 * @aka L.Control
 * @inherits Class
 *
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

var Control = Class.extend({
	// @section
	// @aka Control options
	options: {
		// @option position: String = 'topright'
		// The position of the control (one of the map corners). Possible values are `'topleft'`,
		// `'topright'`, `'bottomleft'` or `'bottomright'`
		position: 'topright'
	},

	initialize: function (options) {
		setOptions(this, options);
	},

	/* @section
	 * Classes extending L.Control will inherit the following methods:
	 *
	 * @method getPosition: string
	 * Returns the position of the control.
	 */
	getPosition: function () {
		return this.options.position;
	},

	// @method setPosition(position: string): this
	// Sets the position of the control.
	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTMLElement that contains the control.
	getContainer: function () {
		return this._container;
	},

	// @method addTo(map: Map): this
	// Adds the control to the given map.
	addTo: function (map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		this._map.on('unload', this.remove, this);

		return this;
	},

	// @method remove: this
	// Removes the control from the map it is currently active on.
	remove: function () {
		if (!this._map) {
			return this;
		}

		remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map.off('unload', this.remove, this);
		this._map = null;

		return this;
	},

	_refocusOnMap: function (e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

var control = function (options) {
	return new Control(options);
};

/* @section Extension methods
 * @uninheritable
 *
 * Every control should extend from `L.Control` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): HTMLElement
 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
 *
 * @method onRemove(map: Map)
 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
 */

/* @namespace Map
 * @section Methods for Layers and Controls
 */
Map.include({
	// @method addControl(control: Control): this
	// Adds the given control to the map
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	// @method removeControl(control: Control): this
	// Removes the given control from the map
	removeControl: function (control) {
		control.remove();
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            create$1('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = create$1('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		for (var i in this._controlCorners) {
			remove(this._controlCorners[i]);
		}
		remove(this._controlContainer);
		delete this._controlCorners;
		delete this._controlContainer;
	}
});

/*
 * @class Control.Layers
 * @aka L.Control.Layers
 * @inherits Control
 *
 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
 *
 * @example
 *
 * ```js
 * var baseLayers = {
 * 	"Mapbox": mapbox,
 * 	"OpenStreetMap": osm
 * };
 *
 * var overlays = {
 * 	"Marker": marker,
 * 	"Roads": roadsLayer
 * };
 *
 * L.control.layers(baseLayers, overlays).addTo(map);
 * ```
 *
 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
 *
 * ```js
 * {
 *     "<someName1>": layer1,
 *     "<someName2>": layer2
 * }
 * ```
 *
 * The layer names can contain HTML, which allows you to add additional styling to the items:
 *
 * ```js
 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
 * ```
 */

var Layers = Control.extend({
	// @section
	// @aka Control.Layers options
	options: {
		// @option collapsed: Boolean = true
		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
		collapsed: true,
		position: 'topright',

		// @option autoZIndex: Boolean = true
		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
		autoZIndex: true,

		// @option hideSingleBase: Boolean = false
		// If `true`, the base layers in the control will be hidden when there is only one.
		hideSingleBase: false,

		// @option sortLayers: Boolean = false
		// Whether to sort the layers. When `false`, layers will keep the order
		// in which they were added to the control.
		sortLayers: false,

		// @option sortFunction: Function = *
		// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
		// that will be used for sorting the layers, when `sortLayers` is `true`.
		// The function receives both the `L.Layer` instances and their names, as in
		// `sortFunction(layerA, layerB, nameA, nameB)`.
		// By default, it sorts layers alphabetically by their name.
		sortFunction: function (layerA, layerB, nameA, nameB) {
			return nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);
		}
	},

	initialize: function (baseLayers, overlays, options) {
		setOptions(this, options);

		this._layerControlInputs = [];
		this._layers = [];
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		this._map = map;
		map.on('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.on('add remove', this._onLayerChange, this);
		}

		return this._container;
	},

	addTo: function (map) {
		Control.prototype.addTo.call(this, map);
		// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
		return this._expandIfNotCollapsed();
	},

	onRemove: function () {
		this._map.off('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.off('add remove', this._onLayerChange, this);
		}
	},

	// @method addBaseLayer(layer: Layer, name: String): this
	// Adds a base layer (radio button entry) with the given name to the control.
	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		return (this._map) ? this._update() : this;
	},

	// @method addOverlay(layer: Layer, name: String): this
	// Adds an overlay (checkbox entry) with the given name to the control.
	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		return (this._map) ? this._update() : this;
	},

	// @method removeLayer(layer: Layer): this
	// Remove the given layer from the control.
	removeLayer: function (layer) {
		layer.off('add remove', this._onLayerChange, this);

		var obj = this._getLayer(stamp(layer));
		if (obj) {
			this._layers.splice(this._layers.indexOf(obj), 1);
		}
		return (this._map) ? this._update() : this;
	},

	// @method expand(): this
	// Expand the control container if collapsed.
	expand: function () {
		addClass(this._container, 'leaflet-control-layers-expanded');
		this._section.style.height = null;
		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
		if (acceptableHeight < this._section.clientHeight) {
			addClass(this._section, 'leaflet-control-layers-scrollbar');
			this._section.style.height = acceptableHeight + 'px';
		} else {
			removeClass(this._section, 'leaflet-control-layers-scrollbar');
		}
		this._checkDisabledLayers();
		return this;
	},

	// @method collapse(): this
	// Collapse the control container if expanded.
	collapse: function () {
		removeClass(this._container, 'leaflet-control-layers-expanded');
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = create$1('div', className),
		    collapsed = this.options.collapsed;

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		disableClickPropagation(container);
		disableScrollPropagation(container);

		var section = this._section = create$1('section', className + '-list');

		if (collapsed) {
			this._map.on('click', this.collapse, this);

			if (!android) {
				on(container, {
					mouseenter: this.expand,
					mouseleave: this.collapse
				}, this);
			}
		}

		var link = this._layersLink = create$1('a', className + '-toggle', container);
		link.href = '#';
		link.title = 'Layers';

		if (touch) {
			on(link, 'click', stop);
			on(link, 'click', this.expand, this);
		} else {
			on(link, 'focus', this.expand, this);
		}

		if (!collapsed) {
			this.expand();
		}

		this._baseLayersList = create$1('div', className + '-base', section);
		this._separator = create$1('div', className + '-separator', section);
		this._overlaysList = create$1('div', className + '-overlays', section);

		container.appendChild(section);
	},

	_getLayer: function (id) {
		for (var i = 0; i < this._layers.length; i++) {

			if (this._layers[i] && stamp(this._layers[i].layer) === id) {
				return this._layers[i];
			}
		}
	},

	_addLayer: function (layer, name, overlay) {
		if (this._map) {
			layer.on('add remove', this._onLayerChange, this);
		}

		this._layers.push({
			layer: layer,
			name: name,
			overlay: overlay
		});

		if (this.options.sortLayers) {
			this._layers.sort(bind(function (a, b) {
				return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
			}, this));
		}

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}

		this._expandIfNotCollapsed();
	},

	_update: function () {
		if (!this._container) { return this; }

		empty(this._baseLayersList);
		empty(this._overlaysList);

		this._layerControlInputs = [];
		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

		for (i = 0; i < this._layers.length; i++) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function (e) {
		if (!this._handlingClick) {
			this._update();
		}

		var obj = this._getLayer(stamp(e.target));

		// @namespace Map
		// @section Layer events
		// @event baselayerchange: LayersControlEvent
		// Fired when the base layer is changed through the [layer control](#control-layers).
		// @event overlayadd: LayersControlEvent
		// Fired when an overlay is selected through the [layer control](#control-layers).
		// @event overlayremove: LayersControlEvent
		// Fired when an overlay is deselected through the [layer control](#control-layers).
		// @namespace Control.Layers
		var type = obj.overlay ?
			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'add' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    checked = this._map.hasLayer(obj.layer),
		    input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);
		}

		this._layerControlInputs.push(input);
		input.layerId = stamp(obj.layer);

		on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		// Helps from preventing layer control flicker when checkboxes are disabled
		// https://github.com/Leaflet/Leaflet/issues/2771
		var holder = document.createElement('div');

		label.appendChild(holder);
		holder.appendChild(input);
		holder.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		this._checkDisabledLayers();
		return label;
	},

	_onInputClick: function () {
		var inputs = this._layerControlInputs,
		    input, layer;
		var addedLayers = [],
		    removedLayers = [];

		this._handlingClick = true;

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;

			if (input.checked) {
				addedLayers.push(layer);
			} else if (!input.checked) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			if (this._map.hasLayer(removedLayers[i])) {
				this._map.removeLayer(removedLayers[i]);
			}
		}
		for (i = 0; i < addedLayers.length; i++) {
			if (!this._map.hasLayer(addedLayers[i])) {
				this._map.addLayer(addedLayers[i]);
			}
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_checkDisabledLayers: function () {
		var inputs = this._layerControlInputs,
		    input,
		    layer,
		    zoom = this._map.getZoom();

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
			                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

		}
	},

	_expandIfNotCollapsed: function () {
		if (this._map && !this.options.collapsed) {
			this.expand();
		}
		return this;
	},

	_expand: function () {
		// Backward compatibility, remove me in 1.1.
		return this.expand();
	},

	_collapse: function () {
		// Backward compatibility, remove me in 1.1.
		return this.collapse();
	}

});


// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
var layers = function (baseLayers, overlays, options) {
	return new Layers(baseLayers, overlays, options);
};

/*
 * @class Control.Zoom
 * @aka L.Control.Zoom
 * @inherits Control
 *
 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
 */

var Zoom = Control.extend({
	// @section
	// @aka Control.Zoom options
	options: {
		position: 'topleft',

		// @option zoomInText: String = '+'
		// The text set on the 'zoom in' button.
		zoomInText: '+',

		// @option zoomInTitle: String = 'Zoom in'
		// The title set on the 'zoom in' button.
		zoomInTitle: 'Zoom in',

		// @option zoomOutText: String = '&#x2212;'
		// The text set on the 'zoom out' button.
		zoomOutText: '&#x2212;',

		// @option zoomOutTitle: String = 'Zoom out'
		// The title set on the 'zoom out' button.
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = create$1('div', zoomName + ' leaflet-bar'),
		    options = this.options;

		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function () {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function () {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function (e) {
		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_zoomOut: function (e) {
		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_createButton: function (html, title, className, container, fn) {
		var link = create$1('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		/*
		 * Will force screen readers like VoiceOver to read this as "Zoom in - button"
		 */
		link.setAttribute('role', 'button');
		link.setAttribute('aria-label', title);

		disableClickPropagation(link);
		on(link, 'click', stop);
		on(link, 'click', fn, this);
		on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
		    className = 'leaflet-disabled';

		removeClass(this._zoomInButton, className);
		removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			addClass(this._zoomInButton, className);
		}
	}
});

// @namespace Map
// @section Control options
// @option zoomControl: Boolean = true
// Whether a [zoom control](#control-zoom) is added to the map by default.
Map.mergeOptions({
	zoomControl: true
});

Map.addInitHook(function () {
	if (this.options.zoomControl) {
		// @section Controls
		// @property zoomControl: Control.Zoom
		// The default zoom control (only available if the
		// [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
		this.zoomControl = new Zoom();
		this.addControl(this.zoomControl);
	}
});

// @namespace Control.Zoom
// @factory L.control.zoom(options: Control.Zoom options)
// Creates a zoom control
var zoom = function (options) {
	return new Zoom(options);
};

/*
 * @class Control.Scale
 * @aka L.Control.Scale
 * @inherits Control
 *
 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
 *
 * @example
 *
 * ```js
 * L.control.scale().addTo(map);
 * ```
 */

var Scale = Control.extend({
	// @section
	// @aka Control.Scale options
	options: {
		position: 'bottomleft',

		// @option maxWidth: Number = 100
		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
		maxWidth: 100,

		// @option metric: Boolean = True
		// Whether to show the metric scale line (m/km).
		metric: true,

		// @option imperial: Boolean = True
		// Whether to show the imperial scale line (mi/ft).
		imperial: true

		// @option updateWhenIdle: Boolean = false
		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
	},

	onAdd: function (map) {
		var className = 'leaflet-control-scale',
		    container = create$1('div', className),
		    options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = create$1('div', className, container);
		}
		if (options.imperial) {
			this._iScale = create$1('div', className, container);
		}
	},

	_update: function () {
		var map = this._map,
		    y = map.getSize().y / 2;

		var maxMeters = map.distance(
			map.containerPointToLatLng([0, y]),
			map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function (maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters),
		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function (scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 :
		    d >= 5 ? 5 :
		    d >= 3 ? 3 :
		    d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});


// @factory L.control.scale(options?: Control.Scale options)
// Creates an scale control with the given options.
var scale = function (options) {
	return new Scale(options);
};

/*
 * @class Control.Attribution
 * @aka L.Control.Attribution
 * @inherits Control
 *
 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
 */

var Attribution = Control.extend({
	// @section
	// @aka Control.Attribution options
	options: {
		position: 'bottomright',

		// @option prefix: String = 'Leaflet'
		// The HTML text shown before the attributions. Pass `false` to disable.
		prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		map.attributionControl = this;
		this._container = create$1('div', 'leaflet-control-attribution');
		disableClickPropagation(this._container);

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	// @method setPrefix(prefix: String): this
	// Sets the text before the attributions.
	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	// @method addAttribution(text: String): this
	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
	addAttribution: function (text) {
		if (!text) { return this; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	// @method removeAttribution(text: String): this
	// Removes an attribution text.
	removeAttribution: function (text) {
		if (!text) { return this; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

// @namespace Map
// @section Control options
// @option attributionControl: Boolean = true
// Whether a [attribution control](#control-attribution) is added to the map by default.
Map.mergeOptions({
	attributionControl: true
});

Map.addInitHook(function () {
	if (this.options.attributionControl) {
		new Attribution().addTo(this);
	}
});

// @namespace Control.Attribution
// @factory L.control.attribution(options: Control.Attribution options)
// Creates an attribution control.
var attribution = function (options) {
	return new Attribution(options);
};

Control.Layers = Layers;
Control.Zoom = Zoom;
Control.Scale = Scale;
Control.Attribution = Attribution;

control.layers = layers;
control.zoom = zoom;
control.scale = scale;
control.attribution = attribution;

/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

// @class Handler
// @aka L.Handler
// Abstract class for map interaction handlers

var Handler = Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	// @method enable(): this
	// Enables the handler
	enable: function () {
		if (this._enabled) { return this; }

		this._enabled = true;
		this.addHooks();
		return this;
	},

	// @method disable(): this
	// Disables the handler
	disable: function () {
		if (!this._enabled) { return this; }

		this._enabled = false;
		this.removeHooks();
		return this;
	},

	// @method enabled(): Boolean
	// Returns `true` if the handler is enabled
	enabled: function () {
		return !!this._enabled;
	}

	// @section Extension methods
	// Classes inheriting from `Handler` must implement the two following methods:
	// @method addHooks()
	// Called when the handler is enabled, should add event hooks.
	// @method removeHooks()
	// Called when the handler is disabled, should remove the event hooks added previously.
});

// @section There is static function which can be called without instantiating L.Handler:
// @function addTo(map: Map, name: String): this
// Adds a new Handler to the given map with the given name.
Handler.addTo = function (map, name) {
	map.addHandler(name, this);
	return this;
};

var Mixin = {Events: Events};

/*
 * @class Draggable
 * @aka L.Draggable
 * @inherits Evented
 *
 * A class for making DOM elements draggable (including touch support).
 * Used internally for map and marker dragging. Only works for elements
 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
 *
 * @example
 * ```js
 * var draggable = new L.Draggable(elementToDrag);
 * draggable.enable();
 * ```
 */

var START = touch ? 'touchstart mousedown' : 'mousedown';
var END = {
	mousedown: 'mouseup',
	touchstart: 'touchend',
	pointerdown: 'touchend',
	MSPointerDown: 'touchend'
};
var MOVE = {
	mousedown: 'mousemove',
	touchstart: 'touchmove',
	pointerdown: 'touchmove',
	MSPointerDown: 'touchmove'
};


var Draggable = Evented.extend({

	options: {
		// @section
		// @aka Draggable options
		// @option clickTolerance: Number = 3
		// The max number of pixels a user can shift the mouse pointer during a click
		// for it to be considered a valid click (as opposed to a mouse drag).
		clickTolerance: 3
	},

	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
	initialize: function (element, dragStartTarget, preventOutline$$1, options) {
		setOptions(this, options);

		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline$$1;
	},

	// @method enable()
	// Enables the dragging ability
	enable: function () {
		if (this._enabled) { return; }

		on(this._dragStartTarget, START, this._onDown, this);

		this._enabled = true;
	},

	// @method disable()
	// Disables the dragging ability
	disable: function () {
		if (!this._enabled) { return; }

		// If we're currently dragging this draggable,
		// disabling it counts as first ending the drag.
		if (Draggable._dragging === this) {
			this.finishDrag();
		}

		off(this._dragStartTarget, START, this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		this._moved = false;

		if (hasClass(this._element, 'leaflet-zoom-anim')) { return; }

		if (Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }
		Draggable._dragging = this;  // Prevent dragging multiple objects at once.

		if (this._preventOutline) {
			preventOutline(this._element);
		}

		disableImageDrag();
		disableTextSelection();

		if (this._moving) { return; }

		// @event down: Event
		// Fired when a drag is about to start.
		this.fire('down');

		var first = e.touches ? e.touches[0] : e,
		    sizedParent = getSizedParentNode(this._element);

		this._startPoint = new Point(first.clientX, first.clientY);

		// Cache the scale, so that we can continuously compensate for it during drag (_onMove).
		this._parentScale = getScale(sizedParent);

		on(document, MOVE[e.type], this._onMove, this);
		on(document, END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

		// We assume that the parent container's position, border and scale do not change for the duration of the drag.
		// Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
		// and we can use the cached value for the scale.
		offset.x /= this._parentScale.x;
		offset.y /= this._parentScale.y;

		preventDefault(e);

		if (!this._moved) {
			// @event dragstart: Event
			// Fired when a drag starts
			this.fire('dragstart');

			this._moved = true;
			this._startPos = getPosition(this._element).subtract(offset);

			addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			// IE and Edge do not give the <use> element, so fetch it
			// if necessary
			if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
				this._lastTarget = this._lastTarget.correspondingUseElement;
			}
			addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = requestAnimFrame(this._updatePosition, this, true);
	},

	_updatePosition: function () {
		var e = {originalEvent: this._lastEvent};

		// @event predrag: Event
		// Fired continuously during dragging *before* each corresponding
		// update of the element's position.
		this.fire('predrag', e);
		setPosition(this._element, this._newPos);

		// @event drag: Event
		// Fired continuously during dragging.
		this.fire('drag', e);
	},

	_onUp: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }
		this.finishDrag();
	},

	finishDrag: function () {
		removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in MOVE) {
			off(document, MOVE[i], this._onMove, this);
			off(document, END[i], this._onUp, this);
		}

		enableImageDrag();
		enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			cancelAnimFrame(this._animRequest);

			// @event dragend: DragEndEvent
			// Fired when the drag ends.
			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
		Draggable._dragging = false;
	}

});

/*
 * @namespace LineUtil
 *
 * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
 */

// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
// Improves rendering performance dramatically by lessening the number of points to draw.

// @function simplify(points: Point[], tolerance: Number): Point[]
// Dramatically reduces the number of points in a polyline while retaining
// its shape and returns a new array of simplified points, using the
// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
// Used for a huge performance boost when processing/displaying Leaflet polylines for
// each zoom level and also reducing visual noise. tolerance affects the amount of
// simplification (lesser value means higher quality but slower and with more points).
// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
function simplify(points, tolerance) {
	if (!tolerance || !points.length) {
		return points.slice();
	}

	var sqTolerance = tolerance * tolerance;

	    // stage 1: vertex reduction
	    points = _reducePoints(points, sqTolerance);

	    // stage 2: Douglas-Peucker simplification
	    points = _simplifyDP(points, sqTolerance);

	return points;
}

// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
// Returns the distance between point `p` and segment `p1` to `p2`.
function pointToSegmentDistance(p, p1, p2) {
	return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
}

// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
// Returns the closest point from a point `p` on a segment `p1` to `p2`.
function closestPointOnSegment(p, p1, p2) {
	return _sqClosestPointOnSegment(p, p1, p2);
}

// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
function _simplifyDP(points, sqTolerance) {

	var len = points.length,
	    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
	    markers = new ArrayConstructor(len);

	    markers[0] = markers[len - 1] = 1;

	_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

	var i,
	    newPoints = [];

	for (i = 0; i < len; i++) {
		if (markers[i]) {
			newPoints.push(points[i]);
		}
	}

	return newPoints;
}

function _simplifyDPStep(points, markers, sqTolerance, first, last) {

	var maxSqDist = 0,
	index, i, sqDist;

	for (i = first + 1; i <= last - 1; i++) {
		sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

		if (sqDist > maxSqDist) {
			index = i;
			maxSqDist = sqDist;
		}
	}

	if (maxSqDist > sqTolerance) {
		markers[index] = 1;

		_simplifyDPStep(points, markers, sqTolerance, first, index);
		_simplifyDPStep(points, markers, sqTolerance, index, last);
	}
}

// reduce points that are too close to each other to a single point
function _reducePoints(points, sqTolerance) {
	var reducedPoints = [points[0]];

	for (var i = 1, prev = 0, len = points.length; i < len; i++) {
		if (_sqDist(points[i], points[prev]) > sqTolerance) {
			reducedPoints.push(points[i]);
			prev = i;
		}
	}
	if (prev < len - 1) {
		reducedPoints.push(points[len - 1]);
	}
	return reducedPoints;
}

var _lastCode;

// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
// Clips the segment a to b by rectangular bounds with the
// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
// (modifying the segment points directly!). Used by Leaflet to only show polyline
// points that are on the screen or near, increasing performance.
function clipSegment(a, b, bounds, useLastCode, round) {
	var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
	    codeB = _getBitCode(b, bounds),

	    codeOut, p, newCode;

	    // save 2nd code to avoid calculating it on the next segment
	    _lastCode = codeB;

	while (true) {
		// if a,b is inside the clip window (trivial accept)
		if (!(codeA | codeB)) {
			return [a, b];
		}

		// if a,b is outside the clip window (trivial reject)
		if (codeA & codeB) {
			return false;
		}

		// other cases
		codeOut = codeA || codeB;
		p = _getEdgeIntersection(a, b, codeOut, bounds, round);
		newCode = _getBitCode(p, bounds);

		if (codeOut === codeA) {
			a = p;
			codeA = newCode;
		} else {
			b = p;
			codeB = newCode;
		}
	}
}

function _getEdgeIntersection(a, b, code, bounds, round) {
	var dx = b.x - a.x,
	    dy = b.y - a.y,
	    min = bounds.min,
	    max = bounds.max,
	    x, y;

	if (code & 8) { // top
		x = a.x + dx * (max.y - a.y) / dy;
		y = max.y;

	} else if (code & 4) { // bottom
		x = a.x + dx * (min.y - a.y) / dy;
		y = min.y;

	} else if (code & 2) { // right
		x = max.x;
		y = a.y + dy * (max.x - a.x) / dx;

	} else if (code & 1) { // left
		x = min.x;
		y = a.y + dy * (min.x - a.x) / dx;
	}

	return new Point(x, y, round);
}

function _getBitCode(p, bounds) {
	var code = 0;

	if (p.x < bounds.min.x) { // left
		code |= 1;
	} else if (p.x > bounds.max.x) { // right
		code |= 2;
	}

	if (p.y < bounds.min.y) { // bottom
		code |= 4;
	} else if (p.y > bounds.max.y) { // top
		code |= 8;
	}

	return code;
}

// square distance (to avoid unnecessary Math.sqrt calls)
function _sqDist(p1, p2) {
	var dx = p2.x - p1.x,
	    dy = p2.y - p1.y;
	return dx * dx + dy * dy;
}

// return closest point on segment or distance to that point
function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
	var x = p1.x,
	    y = p1.y,
	    dx = p2.x - x,
	    dy = p2.y - y,
	    dot = dx * dx + dy * dy,
	    t;

	if (dot > 0) {
		t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

		if (t > 1) {
			x = p2.x;
			y = p2.y;
		} else if (t > 0) {
			x += dx * t;
			y += dy * t;
		}
	}

	dx = p.x - x;
	dy = p.y - y;

	return sqDist ? dx * dx + dy * dy : new Point(x, y);
}


// @function isFlat(latlngs: LatLng[]): Boolean
// Returns true if `latlngs` is a flat array, false is nested.
function isFlat(latlngs) {
	return !isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
}

function _flat(latlngs) {
	console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
	return isFlat(latlngs);
}


var LineUtil = (Object.freeze || Object)({
	simplify: simplify,
	pointToSegmentDistance: pointToSegmentDistance,
	closestPointOnSegment: closestPointOnSegment,
	clipSegment: clipSegment,
	_getEdgeIntersection: _getEdgeIntersection,
	_getBitCode: _getBitCode,
	_sqClosestPointOnSegment: _sqClosestPointOnSegment,
	isFlat: isFlat,
	_flat: _flat
});

/*
 * @namespace PolyUtil
 * Various utility functions for polygon geometries.
 */

/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
 * performance. Note that polygon points needs different algorithm for clipping
 * than polyline, so there's a separate method for it.
 */
function clipPolygon(points, bounds, round) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = _getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = _getEdgeIntersection(b, a, edge, bounds, round);
					p._code = _getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = _getEdgeIntersection(b, a, edge, bounds, round);
				p._code = _getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
}


var PolyUtil = (Object.freeze || Object)({
	clipPolygon: clipPolygon
});

/*
 * @namespace Projection
 * @section
 * Leaflet comes with a set of already defined Projections out of the box:
 *
 * @projection L.Projection.LonLat
 *
 * Equirectangular, or Plate Carree projection  the most simple projection,
 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
 * `EPSG:4326` and `Simple` CRS.
 */

var LonLat = {
	project: function (latlng) {
		return new Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new LatLng(point.y, point.x);
	},

	bounds: new Bounds([-180, -90], [180, 90])
};

/*
 * @namespace Projection
 * @projection L.Projection.Mercator
 *
 * Elliptical Mercator projection  more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.
 */

var Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function (latlng) {
		var d = Math.PI / 180,
		    r = this.R,
		    y = latlng.lat * d,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new Point(latlng.lng * d * r, y);
	},

	unproject: function (point) {
		var d = 180 / Math.PI,
		    r = this.R,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    ts = Math.exp(-point.y / r),
		    phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new LatLng(phi * d, point.x * d / r);
	}
};

/*
 * @class Projection

 * An object with methods for projecting geographical coordinates of the world onto
 * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).

 * @property bounds: Bounds
 * The bounds (specified in CRS units) where the projection is valid

 * @method project(latlng: LatLng): Point
 * Projects geographical coordinates into a 2D point.
 * Only accepts actual `L.LatLng` instances, not arrays.

 * @method unproject(point: Point): LatLng
 * The inverse of `project`. Projects a 2D point into a geographical location.
 * Only accepts actual `L.Point` instances, not arrays.

 * Note that the projection instances do not inherit from Leafet's `Class` object,
 * and can't be instantiated. Also, new classes can't inherit from them,
 * and methods can't be added to them with the `include` function.

 */




var index = (Object.freeze || Object)({
	LonLat: LonLat,
	Mercator: Mercator,
	SphericalMercator: SphericalMercator
});

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3395
 *
 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
 */
var EPSG3395 = extend({}, Earth, {
	code: 'EPSG:3395',
	projection: Mercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * Mercator.R);
		return toTransformation(scale, 0.5, -scale, 0.5);
	}())
});

/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 *
 * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
 * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
 * with this CRS, ensure that there are two 256x256 pixel tiles covering the
 * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
 * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
 */

var EPSG4326 = extend({}, Earth, {
	code: 'EPSG:4326',
	projection: LonLat,
	transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
});

/*
 * @namespace CRS
 * @crs L.CRS.Simple
 *
 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
 * axis should still be inverted (going from bottom to top). `distance()` returns
 * simple euclidean distance.
 */

var Simple = extend({}, CRS, {
	projection: LonLat,
	transformation: toTransformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	},

	zoom: function (scale) {
		return Math.log(scale) / Math.LN2;
	},

	distance: function (latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
		    dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});

CRS.Earth = Earth;
CRS.EPSG3395 = EPSG3395;
CRS.EPSG3857 = EPSG3857;
CRS.EPSG900913 = EPSG900913;
CRS.EPSG4326 = EPSG4326;
CRS.Simple = Simple;

/*
 * @class Layer
 * @inherits Evented
 * @aka L.Layer
 * @aka ILayer
 *
 * A set of methods from the Layer base class that all Leaflet layers use.
 * Inherits all methods, options and events from `L.Evented`.
 *
 * @example
 *
 * ```js
 * var layer = L.marker(latlng).addTo(map);
 * layer.addTo(map);
 * layer.remove();
 * ```
 *
 * @event add: Event
 * Fired after the layer is added to a map
 *
 * @event remove: Event
 * Fired after the layer is removed from a map
 */


var Layer = Evented.extend({

	// Classes extending `L.Layer` will inherit the following options:
	options: {
		// @option pane: String = 'overlayPane'
		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
		pane: 'overlayPane',

		// @option attribution: String = null
		// String to be shown in the attribution control, e.g. " OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
		attribution: null,

		bubblingMouseEvents: true
	},

	/* @section
	 * Classes extending `L.Layer` will inherit the following methods:
	 *
	 * @method addTo(map: Map|LayerGroup): this
	 * Adds the layer to the given map or layer group.
	 */
	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	// @method remove: this
	// Removes the layer from the map it is currently active on.
	remove: function () {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	// @method removeFrom(map: Map): this
	// Removes the layer from the given map
	removeFrom: function (obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	// @method getPane(name? : String): HTMLElement
	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
	getPane: function (name) {
		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
	},

	addInteractiveTarget: function (targetEl) {
		this._map._targets[stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function (targetEl) {
		delete this._map._targets[stamp(targetEl)];
		return this;
	},

	// @method getAttribution: String
	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
	getAttribution: function () {
		return this.options.attribution;
	},

	_layerAdd: function (e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) { return; }

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		if (this.getEvents) {
			var events = this.getEvents();
			map.on(events, this);
			this.once('remove', function () {
				map.off(events, this);
			}, this);
		}

		this.onAdd(map);

		if (this.getAttribution && map.attributionControl) {
			map.attributionControl.addAttribution(this.getAttribution());
		}

		this.fire('add');
		map.fire('layeradd', {layer: this});
	}
});

/* @section Extension methods
 * @uninheritable
 *
 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): this
 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
 *
 * @method onRemove(map: Map): this
 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
 *
 * @method getEvents(): Object
 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
 *
 * @method getAttribution(): String
 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
 *
 * @method beforeAdd(map: Map): this
 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
 */


/* @namespace Map
 * @section Layer events
 *
 * @event layeradd: LayerEvent
 * Fired when a new layer is added to the map.
 *
 * @event layerremove: LayerEvent
 * Fired when some layer is removed from the map
 *
 * @section Methods for Layers and Controls
 */
Map.include({
	// @method addLayer(layer: Layer): this
	// Adds the given layer to the map
	addLayer: function (layer) {
		if (!layer._layerAdd) {
			throw new Error('The provided object is not a Layer.');
		}

		var id = stamp(layer);
		if (this._layers[id]) { return this; }
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the map.
	removeLayer: function (layer) {
		var id = stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the map
	hasLayer: function (layer) {
		return !!layer && (stamp(layer) in this._layers);
	},

	/* @method eachLayer(fn: Function, context?: Object): this
	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
	 * ```
	 * map.eachLayer(function(layer){
	 *     layer.bindPopup('Hello');
	 * });
	 * ```
	 */
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function (layers) {
		layers = layers ? (isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function (layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function (layer) {
		var id = stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function () {
		var minZoom = Infinity,
		    maxZoom = -Infinity,
		    oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		// @section Map state change events
		// @event zoomlevelschange: Event
		// Fired when the number of zoomlevels on the map is changed due
		// to adding or removing a layer.
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}

		if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
			this.setZoom(this._layersMaxZoom);
		}
		if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
			this.setZoom(this._layersMinZoom);
		}
	}
});

/*
 * @class LayerGroup
 * @aka L.LayerGroup
 * @inherits Layer
 *
 * Used to group several layers and handle them as one. If you add it to the map,
 * any layers added or removed from the group will be added/removed on the map as
 * well. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.layerGroup([marker1, marker2])
 * 	.addLayer(polyline)
 * 	.addTo(map);
 * ```
 */

var LayerGroup = Layer.extend({

	initialize: function (layers, options) {
		setOptions(this, options);

		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	// @method addLayer(layer: Layer): this
	// Adds the given layer to the group.
	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the group.
	// @alternative
	// @method removeLayer(id: Number): this
	// Removes the layer with the given internal ID from the group.
	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the group.
	// @alternative
	// @method hasLayer(id: Number): Boolean
	// Returns `true` if the given internal ID is currently added to the group.
	hasLayer: function (layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	// @method clearLayers(): this
	// Removes all the layers from the group.
	clearLayers: function () {
		return this.eachLayer(this.removeLayer, this);
	},

	// @method invoke(methodName: String, ): this
	// Calls `methodName` on every layer contained in this group, passing any
	// additional parameters. Has no effect if the layers contained do not
	// implement `methodName`.
	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		this.eachLayer(map.addLayer, map);
	},

	onRemove: function (map) {
		this.eachLayer(map.removeLayer, map);
	},

	// @method eachLayer(fn: Function, context?: Object): this
	// Iterates over the layers of the group, optionally specifying context of the iterator function.
	// ```js
	// group.eachLayer(function (layer) {
	// 	layer.bindPopup('Hello');
	// });
	// ```
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	// @method getLayer(id: Number): Layer
	// Returns the layer with the given internal ID.
	getLayer: function (id) {
		return this._layers[id];
	},

	// @method getLayers(): Layer[]
	// Returns an array of all the layers added to the group.
	getLayers: function () {
		var layers = [];
		this.eachLayer(layers.push, layers);
		return layers;
	},

	// @method setZIndex(zIndex: Number): this
	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	// @method getLayerId(layer: Layer): Number
	// Returns the internal ID for a layer
	getLayerId: function (layer) {
		return stamp(layer);
	}
});


// @factory L.layerGroup(layers?: Layer[], options?: Object)
// Create a layer group, optionally given an initial set of layers and an `options` object.
var layerGroup = function (layers, options) {
	return new LayerGroup(layers, options);
};

/*
 * @class FeatureGroup
 * @aka L.FeatureGroup
 * @inherits LayerGroup
 *
 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
 * handler, it will handle events from any of the layers. This includes mouse events
 * and custom events.
 *  * Has `layeradd` and `layerremove` events
 *
 * @example
 *
 * ```js
 * L.featureGroup([marker1, marker2, polyline])
 * 	.bindPopup('Hello world!')
 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
 * 	.addTo(map);
 * ```
 */

var FeatureGroup = LayerGroup.extend({

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		LayerGroup.prototype.addLayer.call(this, layer);

		// @event layeradd: LayerEvent
		// Fired when a layer is added to this `FeatureGroup`
		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		LayerGroup.prototype.removeLayer.call(this, layer);

		// @event layerremove: LayerEvent
		// Fired when a layer is removed from this `FeatureGroup`
		return this.fire('layerremove', {layer: layer});
	},

	// @method setStyle(style: Path options): this
	// Sets the given path options to each layer of the group that has a `setStyle` method.
	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	// @method bringToFront(): this
	// Brings the layer group to the top of all other layers
	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	// @method bringToBack(): this
	// Brings the layer group to the back of all other layers
	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	// @method getBounds(): LatLngBounds
	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
	getBounds: function () {
		var bounds = new LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

// @factory L.featureGroup(layers: Layer[])
// Create a feature group, optionally given an initial set of layers.
var featureGroup = function (layers) {
	return new FeatureGroup(layers);
};

/*
 * @class Icon
 * @aka L.Icon
 *
 * Represents an icon to provide when creating a marker.
 *
 * @example
 *
 * ```js
 * var myIcon = L.icon({
 *     iconUrl: 'my-icon.png',
 *     iconRetinaUrl: 'my-icon@2x.png',
 *     iconSize: [38, 95],
 *     iconAnchor: [22, 94],
 *     popupAnchor: [-3, -76],
 *     shadowUrl: 'my-icon-shadow.png',
 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
 *     shadowSize: [68, 95],
 *     shadowAnchor: [22, 94]
 * });
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
 *
 */

var Icon = Class.extend({

	/* @section
	 * @aka Icon options
	 *
	 * @option iconUrl: String = null
	 * **(required)** The URL to the icon image (absolute or relative to your script path).
	 *
	 * @option iconRetinaUrl: String = null
	 * The URL to a retina sized version of the icon image (absolute or relative to your
	 * script path). Used for Retina screen devices.
	 *
	 * @option iconSize: Point = null
	 * Size of the icon image in pixels.
	 *
	 * @option iconAnchor: Point = null
	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
	 * will be aligned so that this point is at the marker's geographical location. Centered
	 * by default if size is specified, also can be set in CSS with negative margins.
	 *
	 * @option popupAnchor: Point = [0, 0]
	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
	 *
	 * @option tooltipAnchor: Point = [0, 0]
	 * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
	 *
	 * @option shadowUrl: String = null
	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
	 *
	 * @option shadowRetinaUrl: String = null
	 *
	 * @option shadowSize: Point = null
	 * Size of the shadow image in pixels.
	 *
	 * @option shadowAnchor: Point = null
	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
	 * as iconAnchor if not specified).
	 *
	 * @option className: String = ''
	 * A custom class name to assign to both icon and shadow images. Empty by default.
	 */

	options: {
		popupAnchor: [0, 0],
		tooltipAnchor: [0, 0]
	},

	initialize: function (options) {
		setOptions(this, options);
	},

	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
	// Called internally when the icon has to be shown, returns a `<img>` HTML element
	// styled according to the options.
	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
	// As `createIcon`, but for the shadow beneath it.
	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options;
		var sizeOption = options[name + 'Size'];

		if (typeof sizeOption === 'number') {
			sizeOption = [sizeOption, sizeOption];
		}

		var size = toPoint(sizeOption),
		    anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
		            size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});


// @factory L.icon(options: Icon options)
// Creates an icon instance with the given options.
function icon(options) {
	return new Icon(options);
}

/*
 * @miniclass Icon.Default (Icon)
 * @aka L.Icon.Default
 * @section
 *
 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
 * no icon is specified. Points to the blue marker image distributed with Leaflet
 * releases.
 *
 * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
 * (which is a set of `Icon options`).
 *
 * If you want to _completely_ replace the default icon, override the
 * `L.Marker.prototype.options.icon` with your own icon instead.
 */

var IconDefault = Icon.extend({

	options: {
		iconUrl:       'marker-icon.png',
		iconRetinaUrl: 'marker-icon-2x.png',
		shadowUrl:     'marker-shadow.png',
		iconSize:    [25, 41],
		iconAnchor:  [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [16, -28],
		shadowSize:  [41, 41]
	},

	_getIconUrl: function (name) {
		if (!IconDefault.imagePath) {	// Deprecated, backwards-compatibility only
			IconDefault.imagePath = this._detectIconPath();
		}

		// @option imagePath: String
		// `Icon.Default` will try to auto-detect the location of the
		// blue icon images. If you are placing these images in a non-standard
		// way, set this option to point to the right path.
		return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
	},

	_detectIconPath: function () {
		var el = create$1('div',  'leaflet-default-icon-path', document.body);
		var path = getStyle(el, 'background-image') ||
		           getStyle(el, 'backgroundImage');	// IE8

		document.body.removeChild(el);

		if (path === null || path.indexOf('url') !== 0) {
			path = '';
		} else {
			path = path.replace(/^url\(["']?/, '').replace(/marker-icon\.png["']?\)$/, '');
		}

		return path;
	}
});

/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */


/* @namespace Marker
 * @section Interaction handlers
 *
 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
 *
 * ```js
 * marker.dragging.disable();
 * ```
 *
 * @property dragging: Handler
 * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
 */

var MarkerDrag = Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			predrag: this._onPreDrag,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable.off({
			dragstart: this._onDragStart,
			predrag: this._onPreDrag,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_adjustPan: function (e) {
		var marker = this._marker,
		    map = marker._map,
		    speed = this._marker.options.autoPanSpeed,
		    padding = this._marker.options.autoPanPadding,
		    iconPos = getPosition(marker._icon),
		    bounds = map.getPixelBounds(),
		    origin = map.getPixelOrigin();

		var panBounds = toBounds(
			bounds.min._subtract(origin).add(padding),
			bounds.max._subtract(origin).subtract(padding)
		);

		if (!panBounds.contains(iconPos)) {
			// Compute incremental movement
			var movement = toPoint(
				(Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) -
				(Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),

				(Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) -
				(Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
			).multiplyBy(speed);

			map.panBy(movement, {animate: false});

			this._draggable._newPos._add(movement);
			this._draggable._startPos._add(movement);

			setPosition(marker._icon, this._draggable._newPos);
			this._onDrag(e);

			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
		}
	},

	_onDragStart: function () {
		// @section Dragging events
		// @event dragstart: Event
		// Fired when the user starts dragging the marker.

		// @event movestart: Event
		// Fired when the marker starts moving (because of dragging).

		this._oldLatLng = this._marker.getLatLng();
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onPreDrag: function (e) {
		if (this._marker.options.autoPan) {
			cancelAnimFrame(this._panRequest);
			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
		}
	},

	_onDrag: function (e) {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;
		e.oldLatLng = this._oldLatLng;

		// @event drag: Event
		// Fired repeatedly while the user drags the marker.
		marker
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onDragEnd: function (e) {
		// @event dragend: DragEndEvent
		// Fired when the user stops dragging the marker.

		 cancelAnimFrame(this._panRequest);

		// @event moveend: Event
		// Fired when the marker stops moving (because of dragging).
		delete this._oldLatLng;
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});

/*
 * @class Marker
 * @inherits Interactive layer
 * @aka L.Marker
 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.marker([50.5, 30.5]).addTo(map);
 * ```
 */

var Marker = Layer.extend({

	// @section
	// @aka Marker options
	options: {
		// @option icon: Icon = *
		// Icon instance to use for rendering the marker.
		// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
		// If not specified, a common instance of `L.Icon.Default` is used.
		icon: new IconDefault(),

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option keyboard: Boolean = true
		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
		keyboard: true,

		// @option title: String = ''
		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
		title: '',

		// @option alt: String = ''
		// Text for the `alt` attribute of the icon image (useful for accessibility).
		alt: '',

		// @option zIndexOffset: Number = 0
		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
		zIndexOffset: 0,

		// @option opacity: Number = 1.0
		// The opacity of the marker.
		opacity: 1,

		// @option riseOnHover: Boolean = false
		// If `true`, the marker will get on top of others when you hover the mouse over it.
		riseOnHover: false,

		// @option riseOffset: Number = 250
		// The z-index offset used for the `riseOnHover` feature.
		riseOffset: 250,

		// @option pane: String = 'markerPane'
		// `Map pane` where the markers icon will be added.
		pane: 'markerPane',

		// @option pane: String = 'shadowPane'
		// `Map pane` where the markers shadow will be added.
		shadowPane: 'shadowPane',

		// @option bubblingMouseEvents: Boolean = false
		// When `true`, a mouse event on this marker will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: false,

		// @section Draggable marker options
		// @option draggable: Boolean = false
		// Whether the marker is draggable with mouse/touch or not.
		draggable: false,

		// @option autoPan: Boolean = false
		// Whether to pan the map when dragging this marker near its edge or not.
		autoPan: false,

		// @option autoPanPadding: Point = Point(50, 50)
		// Distance (in pixels to the left/right and to the top/bottom) of the
		// map edge to start panning the map.
		autoPanPadding: [50, 50],

		// @option autoPanSpeed: Number = 10
		// Number of pixels the map should pan by.
		autoPanSpeed: 10
	},

	/* @section
	 *
	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
	 */

	initialize: function (latlng, options) {
		setOptions(this, options);
		this._latlng = toLatLng(latlng);
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		if (this._zoomAnimated) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._initIcon();
		this.update();
	},

	onRemove: function (map) {
		if (this.dragging && this.dragging.enabled()) {
			this.options.draggable = true;
			this.dragging.removeHooks();
		}
		delete this.dragging;

		if (this._zoomAnimated) {
			map.off('zoomanim', this._animateZoom, this);
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function () {
		return {
			zoom: this.update,
			viewreset: this.update
		};
	},

	// @method getLatLng: LatLng
	// Returns the current geographical position of the marker.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Changes the marker position to the given point.
	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = toLatLng(latlng);
		this.update();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
	},

	// @method setZIndexOffset(offset: Number): this
	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	// @method getIcon: Icon
	// Returns the current icon used by the marker
	getIcon: function () {
		return this.options.icon;
	},

	// @method setIcon(icon: Icon): this
	// Changes the marker icon.
	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	getElement: function () {
		return this._icon;
	},

	update: function () {

		if (this._icon && this._map) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
		    addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}

			if (icon.tagName === 'IMG') {
				icon.alt = options.alt || '';
			}
		}

		addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
		    addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			addClass(newShadow, classToAdd);
			newShadow.alt = '';
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		this._initInteraction();
		if (newShadow && addShadow) {
			this.getPane(options.shadowPane).appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {

		if (this._icon) {
			setPosition(this._icon, pos);
		}

		if (this._shadow) {
			setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		if (this._icon) {
			this._icon.style.zIndex = this._zIndex + offset;
		}
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.interactive) { return; }

		addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	// @method setOpacity(opacity: Number): this
	// Changes the opacity of the marker.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		var opacity = this.options.opacity;

		if (this._icon) {
			setOpacity(this._icon, opacity);
		}

		if (this._shadow) {
			setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	},

	_getPopupAnchor: function () {
		return this.options.icon.options.popupAnchor;
	},

	_getTooltipAnchor: function () {
		return this.options.icon.options.tooltipAnchor;
	}
});


// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options)
// Instantiates a Marker object given a geographical point and optionally an options object.
function marker(latlng, options) {
	return new Marker(latlng, options);
}

/*
 * @class Path
 * @aka L.Path
 * @inherits Interactive layer
 *
 * An abstract class that contains options and constants shared between vector
 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
 */

var Path = Layer.extend({

	// @section
	// @aka Path options
	options: {
		// @option stroke: Boolean = true
		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
		stroke: true,

		// @option color: String = '#3388ff'
		// Stroke color
		color: '#3388ff',

		// @option weight: Number = 3
		// Stroke width in pixels
		weight: 3,

		// @option opacity: Number = 1.0
		// Stroke opacity
		opacity: 1,

		// @option lineCap: String= 'round'
		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
		lineCap: 'round',

		// @option lineJoin: String = 'round'
		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
		lineJoin: 'round',

		// @option dashArray: String = null
		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashArray: null,

		// @option dashOffset: String = null
		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashOffset: null,

		// @option fill: Boolean = depends
		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
		fill: false,

		// @option fillColor: String = *
		// Fill color. Defaults to the value of the [`color`](#path-color) option
		fillColor: null,

		// @option fillOpacity: Number = 0.2
		// Fill opacity.
		fillOpacity: 0.2,

		// @option fillRule: String = 'evenodd'
		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
		fillRule: 'evenodd',

		// className: '',

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option bubblingMouseEvents: Boolean = true
		// When `true`, a mouse event on this path will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: true
	},

	beforeAdd: function (map) {
		// Renderer is set here because we need to call renderer.getEvents
		// before this.getEvents.
		this._renderer = map.getRenderer(this);
	},

	onAdd: function () {
		this._renderer._initPath(this);
		this._reset();
		this._renderer._addPath(this);
	},

	onRemove: function () {
		this._renderer._removePath(this);
	},

	// @method redraw(): this
	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
	redraw: function () {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	// @method setStyle(style: Path options): this
	// Changes the appearance of a Path based on the options in the `Path options` object.
	setStyle: function (style) {
		setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
			if (this.options.stroke && style && style.hasOwnProperty('weight')) {
				this._updateBounds();
			}
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all path layers.
	bringToFront: function () {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all path layers.
	bringToBack: function () {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	getElement: function () {
		return this._path;
	},

	_reset: function () {
		// defined in child classes
		this._project();
		this._update();
	},

	_clickTolerance: function () {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
	}
});

/*
 * @class CircleMarker
 * @aka L.CircleMarker
 * @inherits Path
 *
 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
 */

var CircleMarker = Path.extend({

	// @section
	// @aka CircleMarker options
	options: {
		fill: true,

		// @option radius: Number = 10
		// Radius of the circle marker, in pixels
		radius: 10
	},

	initialize: function (latlng, options) {
		setOptions(this, options);
		this._latlng = toLatLng(latlng);
		this._radius = this.options.radius;
	},

	// @method setLatLng(latLng: LatLng): this
	// Sets the position of a circle marker to a new location.
	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = toLatLng(latlng);
		this.redraw();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
	},

	// @method getLatLng(): LatLng
	// Returns the current geographical position of the circle marker
	getLatLng: function () {
		return this._latlng;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle marker. Units are in pixels.
	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of the circle
	getRadius: function () {
		return this._radius;
	},

	setStyle : function (options) {
		var radius = options && options.radius || this._radius;
		Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function () {
		var r = this._radius,
		    r2 = this._radiusY || r,
		    w = this._clickTolerance(),
		    p = [r + w, r2 + w];
		this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function () {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function () {
		this._renderer._updateCircle(this);
	},

	_empty: function () {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function (p) {
		return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
	}
});


// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
// Instantiates a circle marker object given a geographical point, and an optional options object.
function circleMarker(latlng, options) {
	return new CircleMarker(latlng, options);
}

/*
 * @class Circle
 * @aka L.Circle
 * @inherits CircleMarker
 *
 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
 *
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
 *
 * @example
 *
 * ```js
 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
 * ```
 */

var Circle = CircleMarker.extend({

	initialize: function (latlng, options, legacyOptions) {
		if (typeof options === 'number') {
			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
			options = extend({}, legacyOptions, {radius: options});
		}
		setOptions(this, options);
		this._latlng = toLatLng(latlng);

		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

		// @section
		// @aka Circle options
		// @option radius: Number; Radius of the circle, in meters.
		this._mRadius = this.options.radius;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle. Units are in meters.
	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of a circle. Units are in meters.
	getRadius: function () {
		return this._mRadius;
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		var half = [this._radius, this._radiusY || this._radius];

		return new LatLngBounds(
			this._map.layerPointToLatLng(this._point.subtract(half)),
			this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: Path.prototype.setStyle,

	_project: function () {

		var lng = this._latlng.lng,
		    lat = this._latlng.lat,
		    map = this._map,
		    crs = map.options.crs;

		if (crs.distance === Earth.distance) {
			var d = Math.PI / 180,
			    latR = (this._mRadius / Earth.R) / d,
			    top = map.project([lat + latR, lng]),
			    bottom = map.project([lat - latR, lng]),
			    p = top.add(bottom).divideBy(2),
			    lat2 = map.unproject(p).lat,
			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			if (isNaN(lngR) || lngR === 0) {
				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
			}

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
			this._radiusY = p.y - top.y;

		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

// @factory L.circle(latlng: LatLng, options?: Circle options)
// Instantiates a circle object given a geographical point, and an options object
// which contains the circle radius.
// @alternative
// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
// Do not use in new applications or plugins.
function circle(latlng, options, legacyOptions) {
	return new Circle(latlng, options, legacyOptions);
}

/*
 * @class Polyline
 * @aka L.Polyline
 * @inherits Path
 *
 * A class for drawing polyline overlays on a map. Extends `Path`.
 *
 * @example
 *
 * ```js
 * // create a red polyline from an array of LatLng points
 * var latlngs = [
 * 	[45.51, -122.68],
 * 	[37.77, -122.43],
 * 	[34.04, -118.2]
 * ];
 *
 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polyline
 * map.fitBounds(polyline.getBounds());
 * ```
 *
 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
 *
 * ```js
 * // create a red polyline from an array of arrays of LatLng points
 * var latlngs = [
 * 	[[45.51, -122.68],
 * 	 [37.77, -122.43],
 * 	 [34.04, -118.2]],
 * 	[[40.78, -73.91],
 * 	 [41.83, -87.62],
 * 	 [32.76, -96.72]]
 * ];
 * ```
 */


var Polyline = Path.extend({

	// @section
	// @aka Polyline options
	options: {
		// @option smoothFactor: Number = 1.0
		// How much to simplify the polyline on each zoom level. More means
		// better performance and smoother look, and less means more accurate representation.
		smoothFactor: 1.0,

		// @option noClip: Boolean = false
		// Disable polyline clipping.
		noClip: false
	},

	initialize: function (latlngs, options) {
		setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	// @method getLatLngs(): LatLng[]
	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	getLatLngs: function () {
		return this._latlngs;
	},

	// @method setLatLngs(latlngs: LatLng[]): this
	// Replaces all the points in the polyline with the given array of geographical points.
	setLatLngs: function (latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	// @method isEmpty(): Boolean
	// Returns `true` if the Polyline has no LatLngs.
	isEmpty: function () {
		return !this._latlngs.length;
	},

	// @method closestLayerPoint(p: Point): Point
	// Returns the point closest to `p` on the Polyline.
	closestLayerPoint: function (p) {
		var minDistance = Infinity,
		    minPoint = null,
		    closest = _sqClosestPointOnSegment,
		    p1, p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	// @method getCenter(): LatLng
	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, halfDist, segDist, dist, p1, p2, ratio,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([
					p2.x - ratio * (p2.x - p1.x),
					p2.y - ratio * (p2.y - p1.y)
				]);
			}
		}
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		return this._bounds;
	},

	// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
	// Adds a given point to the polyline. By default, adds to the first ring of
	// the polyline in case of a multi-polyline, but can be overridden by passing
	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
	addLatLng: function (latlng, latlngs) {
		latlngs = latlngs || this._defaultShape();
		latlng = toLatLng(latlng);
		latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	_setLatLngs: function (latlngs) {
		this._bounds = new LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	_defaultShape: function () {
		return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function (latlngs) {
		var result = [],
		    flat = isFlat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = toLatLng(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_project: function () {
		var pxBounds = new Bounds();
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

		if (this._bounds.isValid() && pxBounds.isValid()) {
			this._rawPxBounds = pxBounds;
			this._updateBounds();
		}
	},

	_updateBounds: function () {
		var w = this._clickTolerance(),
		    p = new Point(w, w);
		this._pxBounds = new Bounds([
			this._rawPxBounds.min.subtract(p),
			this._rawPxBounds.max.add(p)
		]);
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function (latlngs, result, projectedBounds) {
		var flat = latlngs[0] instanceof LatLng,
		    len = latlngs.length,
		    i, ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
				projectedBounds.extend(ring[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result, projectedBounds);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function () {
		var bounds = this._renderer._bounds;

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		var parts = this._parts,
		    i, j, k, len, len2, segment, points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) { continue; }

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function () {
		var parts = this._parts,
		    tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = simplify(parts[i], tolerance);
		}
	},

	_update: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function () {
		this._renderer._updatePoly(this);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function (p, closed) {
		var i, j, k, len, len2, part,
		    w = this._clickTolerance();

		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

		// hit detection for polylines
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				if (!closed && (j === 0)) { continue; }

				if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
					return true;
				}
			}
		}
		return false;
	}
});

// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
// Instantiates a polyline object given an array of geographical points and
// optionally an options object. You can create a `Polyline` object with
// multiple separate lines (`MultiPolyline`) by passing an array of arrays
// of geographic points.
function polyline(latlngs, options) {
	return new Polyline(latlngs, options);
}

// Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
Polyline._flat = _flat;

/*
 * @class Polygon
 * @aka L.Polygon
 * @inherits Polyline
 *
 * A class for drawing polygon overlays on a map. Extends `Polyline`.
 *
 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one  it's better to filter out such points.
 *
 *
 * @example
 *
 * ```js
 * // create a red polygon from an array of LatLng points
 * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
 *
 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polygon
 * map.fitBounds(polygon.getBounds());
 * ```
 *
 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
 *
 * ```js
 * var latlngs = [
 *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 * ];
 * ```
 *
 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
 *
 * ```js
 * var latlngs = [
 *   [ // first polygon
 *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 *   ],
 *   [ // second polygon
 *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
 *   ]
 * ];
 * ```
 */

var Polygon = Polyline.extend({

	options: {
		fill: true
	},

	isEmpty: function () {
		return !this._latlngs.length || !this._latlngs[0].length;
	},

	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, j, p1, p2, f, area, x, y, center,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function (latlngs) {
		var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
		    len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_setLatLngs: function (latlngs) {
		Polyline.prototype._setLatLngs.call(this, latlngs);
		if (isFlat(this._latlngs)) {
			this._latlngs = [this._latlngs];
		}
	},

	_defaultShape: function () {
		return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
	},

	_clipPoints: function () {
		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
		    w = this.options.weight,
		    p = new Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function () {
		this._renderer._updatePoly(this, true);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function (p) {
		var inside = false,
		    part, p1, p2, i, j, k, len, len2;

		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

		// ray casting algorithm for detecting if point is in polygon
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				p1 = part[j];
				p2 = part[k];

				if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
					inside = !inside;
				}
			}
		}

		// also check if it's on polygon stroke
		return inside || Polyline.prototype._containsPoint.call(this, p, true);
	}

});


// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
function polygon(latlngs, options) {
	return new Polygon(latlngs, options);
}

/*
 * @class GeoJSON
 * @aka L.GeoJSON
 * @inherits FeatureGroup
 *
 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
 *
 * @example
 *
 * ```js
 * L.geoJSON(data, {
 * 	style: function (feature) {
 * 		return {color: feature.properties.color};
 * 	}
 * }).bindPopup(function (layer) {
 * 	return layer.feature.properties.description;
 * }).addTo(map);
 * ```
 */

var GeoJSON = FeatureGroup.extend({

	/* @section
	 * @aka GeoJSON options
	 *
	 * @option pointToLayer: Function = *
	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
	 * The default is to spawn a default `Marker`:
	 * ```js
	 * function(geoJsonPoint, latlng) {
	 * 	return L.marker(latlng);
	 * }
	 * ```
	 *
	 * @option style: Function = *
	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
	 * called internally when data is added.
	 * The default value is to not override any defaults:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return {}
	 * }
	 * ```
	 *
	 * @option onEachFeature: Function = *
	 * A `Function` that will be called once for each created `Feature`, after it has
	 * been created and styled. Useful for attaching events and popups to features.
	 * The default is to do nothing with the newly created layers:
	 * ```js
	 * function (feature, layer) {}
	 * ```
	 *
	 * @option filter: Function = *
	 * A `Function` that will be used to decide whether to include a feature or not.
	 * The default is to include all features:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return true;
	 * }
	 * ```
	 * Note: dynamically changing the `filter` option will have effect only on newly
	 * added data. It will _not_ re-evaluate already included features.
	 *
	 * @option coordsToLatLng: Function = *
	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
	 * The default is the `coordsToLatLng` static method.
	 *
	 * @option markersInheritOptions: Boolean = false
	 * Whether default Markers for "Point" type Features inherit from group options.
	 */

	initialize: function (geojson, options) {
		setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	// @method addData( <GeoJSON> data ): this
	// Adds a GeoJSON object to the layer.
	addData: function (geojson) {
		var features = isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return this; }

		var layer = geometryToLayer(geojson, options);
		if (!layer) {
			return this;
		}
		layer.feature = asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	// @method resetStyle( <Path> layer? ): this
	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
	// If `layer` is omitted, the style of all features in the current layer is reset.
	resetStyle: function (layer) {
		if (layer === undefined) {
			return this.eachLayer(this.resetStyle, this);
		}
		// reset any custom styles
		layer.options = extend({}, layer.defaultOptions);
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	// @method setStyle( <Function> style ): this
	// Changes styles of GeoJSON vector layers with the given style function.
	setStyle: function (style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (layer.setStyle) {
			if (typeof style === 'function') {
				style = style(layer.feature);
			}
			layer.setStyle(style);
		}
	}
});

// @section
// There are several static functions which can be called without instantiating L.GeoJSON:

// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
// Creates a `Layer` from a given GeoJSON feature. Can use a custom
// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
// functions if provided as options.
function geometryToLayer(geojson, options) {

	var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
	    coords = geometry ? geometry.coordinates : null,
	    layers = [],
	    pointToLayer = options && options.pointToLayer,
	    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
	    latlng, latlngs, i, len;

	if (!coords && !geometry) {
		return null;
	}

	switch (geometry.type) {
	case 'Point':
		latlng = _coordsToLatLng(coords);
		return _pointToLayer(pointToLayer, geojson, latlng, options);

	case 'MultiPoint':
		for (i = 0, len = coords.length; i < len; i++) {
			latlng = _coordsToLatLng(coords[i]);
			layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));
		}
		return new FeatureGroup(layers);

	case 'LineString':
	case 'MultiLineString':
		latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
		return new Polyline(latlngs, options);

	case 'Polygon':
	case 'MultiPolygon':
		latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
		return new Polygon(latlngs, options);

	case 'GeometryCollection':
		for (i = 0, len = geometry.geometries.length; i < len; i++) {
			var layer = geometryToLayer({
				geometry: geometry.geometries[i],
				type: 'Feature',
				properties: geojson.properties
			}, options);

			if (layer) {
				layers.push(layer);
			}
		}
		return new FeatureGroup(layers);

	default:
		throw new Error('Invalid GeoJSON object.');
	}
}

function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
	return pointToLayerFn ?
		pointToLayerFn(geojson, latlng) :
		new Marker(latlng, options && options.markersInheritOptions && options);
}

// @function coordsToLatLng(coords: Array): LatLng
// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
function coordsToLatLng(coords) {
	return new LatLng(coords[1], coords[0], coords[2]);
}

// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
	var latlngs = [];

	for (var i = 0, len = coords.length, latlng; i < len; i++) {
		latlng = levelsDeep ?
			coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) :
			(_coordsToLatLng || coordsToLatLng)(coords[i]);

		latlngs.push(latlng);
	}

	return latlngs;
}

// @function latLngToCoords(latlng: LatLng, precision?: Number): Array
// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
function latLngToCoords(latlng, precision) {
	precision = typeof precision === 'number' ? precision : 6;
	return latlng.alt !== undefined ?
		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] :
		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
}

// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
	var coords = [];

	for (var i = 0, len = latlngs.length; i < len; i++) {
		coords.push(levelsDeep ?
			latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) :
			latLngToCoords(latlngs[i], precision));
	}

	if (!levelsDeep && closed) {
		coords.push(coords[0]);
	}

	return coords;
}

function getFeature(layer, newGeometry) {
	return layer.feature ?
		extend({}, layer.feature, {geometry: newGeometry}) :
		asFeature(newGeometry);
}

// @function asFeature(geojson: Object): Object
// Normalize GeoJSON geometries/features into GeoJSON features.
function asFeature(geojson) {
	if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
		return geojson;
	}

	return {
		type: 'Feature',
		properties: {},
		geometry: geojson
	};
}

var PointToGeoJSON = {
	toGeoJSON: function (precision) {
		return getFeature(this, {
			type: 'Point',
			coordinates: latLngToCoords(this.getLatLng(), precision)
		});
	}
};

// @namespace Marker
// @section Other methods
// @method toGeoJSON(precision?: Number): Object
// `precision` is the number of decimal places for coordinates.
// The default value is 6 places.
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
Marker.include(PointToGeoJSON);

// @namespace CircleMarker
// @method toGeoJSON(precision?: Number): Object
// `precision` is the number of decimal places for coordinates.
// The default value is 6 places.
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
Circle.include(PointToGeoJSON);
CircleMarker.include(PointToGeoJSON);


// @namespace Polyline
// @method toGeoJSON(precision?: Number): Object
// `precision` is the number of decimal places for coordinates.
// The default value is 6 places.
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
Polyline.include({
	toGeoJSON: function (precision) {
		var multi = !isFlat(this._latlngs);

		var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'LineString',
			coordinates: coords
		});
	}
});

// @namespace Polygon
// @method toGeoJSON(precision?: Number): Object
// `precision` is the number of decimal places for coordinates.
// The default value is 6 places.
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
Polygon.include({
	toGeoJSON: function (precision) {
		var holes = !isFlat(this._latlngs),
		    multi = holes && !isFlat(this._latlngs[0]);

		var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

		if (!holes) {
			coords = [coords];
		}

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'Polygon',
			coordinates: coords
		});
	}
});


// @namespace LayerGroup
LayerGroup.include({
	toMultiPoint: function (precision) {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON(precision).geometry.coordinates);
		});

		return getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	// @method toGeoJSON(precision?: Number): Object
	// `precision` is the number of decimal places for coordinates.
	// The default value is 6 places.
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
	toGeoJSON: function (precision) {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint(precision);
		}

		var isGeometryCollection = type === 'GeometryCollection',
		    jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON(precision);
				if (isGeometryCollection) {
					jsons.push(json.geometry);
				} else {
					var feature = asFeature(json);
					// Squash nested feature collections
					if (feature.type === 'FeatureCollection') {
						jsons.push.apply(jsons, feature.features);
					} else {
						jsons.push(feature);
					}
				}
			}
		});

		if (isGeometryCollection) {
			return getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

// @namespace GeoJSON
// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
// Creates a GeoJSON layer. Optionally accepts an object in
// [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
// (you can alternatively add it later with `addData` method) and an `options` object.
function geoJSON(geojson, options) {
	return new GeoJSON(geojson, options);
}

// Backward compatibility.
var geoJson = geoJSON;

/*
 * @class ImageOverlay
 * @aka L.ImageOverlay
 * @inherits Interactive layer
 *
 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
 * ```
 */

var ImageOverlay = Layer.extend({

	// @section
	// @aka ImageOverlay options
	options: {
		// @option opacity: Number = 1.0
		// The opacity of the image overlay.
		opacity: 1,

		// @option alt: String = ''
		// Text for the `alt` attribute of the image (useful for accessibility).
		alt: '',

		// @option interactive: Boolean = false
		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
		interactive: false,

		// @option crossOrigin: Boolean|String = false
		// Whether the crossOrigin attribute will be added to the image.
		// If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
		crossOrigin: false,

		// @option errorOverlayUrl: String = ''
		// URL to the overlay image to show in place of the overlay that failed to load.
		errorOverlayUrl: '',

		// @option zIndex: Number = 1
		// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
		zIndex: 1,

		// @option className: String = ''
		// A custom class name to assign to the image. Empty by default.
		className: ''
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = toLatLngBounds(bounds);

		setOptions(this, options);
	},

	onAdd: function () {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function () {
		remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	// @method setOpacity(opacity: Number): this
	// Sets the opacity of the overlay.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function (styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all overlays.
	bringToFront: function () {
		if (this._map) {
			toFront(this._image);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all overlays.
	bringToBack: function () {
		if (this._map) {
			toBack(this._image);
		}
		return this;
	},

	// @method setUrl(url: String): this
	// Changes the URL of the image.
	setUrl: function (url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	// @method setBounds(bounds: LatLngBounds): this
	// Update the bounds that this ImageOverlay covers
	setBounds: function (bounds) {
		this._bounds = toLatLngBounds(bounds);

		if (this._map) {
			this._reset();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			zoom: this._reset,
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @method setZIndex(value: Number): this
	// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
	setZIndex: function (value) {
		this.options.zIndex = value;
		this._updateZIndex();
		return this;
	},

	// @method getBounds(): LatLngBounds
	// Get the bounds that this ImageOverlay covers
	getBounds: function () {
		return this._bounds;
	},

	// @method getElement(): HTMLElement
	// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
	// used by this overlay.
	getElement: function () {
		return this._image;
	},

	_initImage: function () {
		var wasElementSupplied = this._url.tagName === 'IMG';
		var img = this._image = wasElementSupplied ? this._url : create$1('img');

		addClass(img, 'leaflet-image-layer');
		if (this._zoomAnimated) { addClass(img, 'leaflet-zoom-animated'); }
		if (this.options.className) { addClass(img, this.options.className); }

		img.onselectstart = falseFn;
		img.onmousemove = falseFn;

		// @event load: Event
		// Fired when the ImageOverlay layer has loaded its image
		img.onload = bind(this.fire, this, 'load');
		img.onerror = bind(this._overlayOnError, this, 'error');

		if (this.options.crossOrigin || this.options.crossOrigin === '') {
			img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
		}

		if (this.options.zIndex) {
			this._updateZIndex();
		}

		if (wasElementSupplied) {
			this._url = img.src;
			return;
		}

		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function (e) {
		var scale = this._map.getZoomScale(e.zoom),
		    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

		setTransform(this._image, offset, scale);
	},

	_reset: function () {
		var image = this._image,
		    bounds = new Bounds(
		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
		    size = bounds.getSize();

		setPosition(image, bounds.min);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function () {
		setOpacity(this._image, this.options.opacity);
	},

	_updateZIndex: function () {
		if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._image.style.zIndex = this.options.zIndex;
		}
	},

	_overlayOnError: function () {
		// @event error: Event
		// Fired when the ImageOverlay layer fails to load its image
		this.fire('error');

		var errorUrl = this.options.errorOverlayUrl;
		if (errorUrl && this._url !== errorUrl) {
			this._url = errorUrl;
			this._image.src = errorUrl;
		}
	}
});

// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
// Instantiates an image overlay object given the URL of the image and the
// geographical bounds it is tied to.
var imageOverlay = function (url, bounds, options) {
	return new ImageOverlay(url, bounds, options);
};

/*
 * @class VideoOverlay
 * @aka L.VideoOverlay
 * @inherits ImageOverlay
 *
 * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
 *
 * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
 * HTML5 element.
 *
 * @example
 *
 * ```js
 * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
 * 	videoBounds = [[ 32, -130], [ 13, -100]];
 * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
 * ```
 */

var VideoOverlay = ImageOverlay.extend({

	// @section
	// @aka VideoOverlay options
	options: {
		// @option autoplay: Boolean = true
		// Whether the video starts playing automatically when loaded.
		autoplay: true,

		// @option loop: Boolean = true
		// Whether the video will loop back to the beginning when played.
		loop: true,

		// @option keepAspectRatio: Boolean = true
		// Whether the video will save aspect ratio after the projection.
		// Relevant for supported browsers. Browser compatibility- https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit
		keepAspectRatio: true
	},

	_initImage: function () {
		var wasElementSupplied = this._url.tagName === 'VIDEO';
		var vid = this._image = wasElementSupplied ? this._url : create$1('video');

		addClass(vid, 'leaflet-image-layer');
		if (this._zoomAnimated) { addClass(vid, 'leaflet-zoom-animated'); }
		if (this.options.className) { addClass(vid, this.options.className); }

		vid.onselectstart = falseFn;
		vid.onmousemove = falseFn;

		// @event load: Event
		// Fired when the video has finished loading the first frame
		vid.onloadeddata = bind(this.fire, this, 'load');

		if (wasElementSupplied) {
			var sourceElements = vid.getElementsByTagName('source');
			var sources = [];
			for (var j = 0; j < sourceElements.length; j++) {
				sources.push(sourceElements[j].src);
			}

			this._url = (sourceElements.length > 0) ? sources : [vid.src];
			return;
		}

		if (!isArray(this._url)) { this._url = [this._url]; }

		if (!this.options.keepAspectRatio && vid.style.hasOwnProperty('objectFit')) { vid.style['objectFit'] = 'fill'; }
		vid.autoplay = !!this.options.autoplay;
		vid.loop = !!this.options.loop;
		for (var i = 0; i < this._url.length; i++) {
			var source = create$1('source');
			source.src = this._url[i];
			vid.appendChild(source);
		}
	}

	// @method getElement(): HTMLVideoElement
	// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
	// used by this overlay.
});


// @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
// Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
// geographical bounds it is tied to.

function videoOverlay(video, bounds, options) {
	return new VideoOverlay(video, bounds, options);
}

/*
 * @class SVGOverlay
 * @aka L.SVGOverlay
 * @inherits ImageOverlay
 *
 * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.
 *
 * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.
 *
 * @example
 *
 * ```js
 * var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
 * svgElement.setAttribute('xmlns', "http://www.w3.org/2000/svg");
 * svgElement.setAttribute('viewBox', "0 0 200 200");
 * svgElement.innerHTML = '<rect width="200" height="200"/><rect x="75" y="23" width="50" height="50" style="fill:red"/><rect x="75" y="123" width="50" height="50" style="fill:#0013ff"/>';
 * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];
 * L.svgOverlay(svgElement, svgElementBounds).addTo(map);
 * ```
 */

var SVGOverlay = ImageOverlay.extend({
	_initImage: function () {
		var el = this._image = this._url;

		addClass(el, 'leaflet-image-layer');
		if (this._zoomAnimated) { addClass(el, 'leaflet-zoom-animated'); }
		if (this.options.className) { addClass(el, this.options.className); }

		el.onselectstart = falseFn;
		el.onmousemove = falseFn;
	}

	// @method getElement(): SVGElement
	// Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
	// used by this overlay.
});


// @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)
// Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.
// A viewBox attribute is required on the SVG element to zoom in and out properly.

function svgOverlay(el, bounds, options) {
	return new SVGOverlay(el, bounds, options);
}

/*
 * @class DivOverlay
 * @inherits Layer
 * @aka L.DivOverlay
 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
 */

// @namespace DivOverlay
var DivOverlay = Layer.extend({

	// @section
	// @aka DivOverlay options
	options: {
		// @option offset: Point = Point(0, 7)
		// The offset of the popup position. Useful to control the anchor
		// of the popup when opening it on some overlays.
		offset: [0, 7],

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: '',

		// @option pane: String = 'popupPane'
		// `Map pane` where the popup will be added.
		pane: 'popupPane'
	},

	initialize: function (options, source) {
		setOptions(this, options);

		this._source = source;
	},

	onAdd: function (map) {
		this._zoomAnimated = map._zoomAnimated;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			setOpacity(this._container, 1);
		}

		this.bringToFront();
	},

	onRemove: function (map) {
		if (map._fadeAnimated) {
			setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
		} else {
			remove(this._container);
		}
	},

	// @namespace Popup
	// @method getLatLng: LatLng
	// Returns the geographical point of popup.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Sets the geographical point where the popup will open.
	setLatLng: function (latlng) {
		this._latlng = toLatLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	// @method getContent: String|HTMLElement
	// Returns the content of the popup.
	getContent: function () {
		return this._content;
	},

	// @method setContent(htmlContent: String|HTMLElement|Function): this
	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	// @method getElement: String|HTMLElement
	// Alias for [getContent()](#popup-getcontent)
	getElement: function () {
		return this._container;
	},

	// @method update: null
	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function () {
		var events = {
			zoom: this._updatePosition,
			viewreset: this._updatePosition
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	// @method isOpen: Boolean
	// Returns `true` when the popup is visible on the map.
	isOpen: function () {
		return !!this._map && this._map.hasLayer(this);
	},

	// @method bringToFront: this
	// Brings this popup in front of other popups (in the same map pane).
	bringToFront: function () {
		if (this._map) {
			toFront(this._container);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings this popup to the back of other popups (in the same map pane).
	bringToBack: function () {
		if (this._map) {
			toBack(this._container);
		}
		return this;
	},

	_prepareOpen: function (parent, layer, latlng) {
		if (!(layer instanceof Layer)) {
			latlng = layer;
			layer = parent;
		}

		if (layer instanceof FeatureGroup) {
			for (var id in parent._layers) {
				layer = parent._layers[id];
				break;
			}
		}

		if (!latlng) {
			if (layer.getCenter) {
				latlng = layer.getCenter();
			} else if (layer.getLatLng) {
				latlng = layer.getLatLng();
			} else {
				throw new Error('Unable to get source layer LatLng.');
			}
		}

		// set overlay source to this layer
		this._source = layer;

		// update the overlay (content, layout, ect...)
		this.update();

		return latlng;
	},

	_updateContent: function () {
		if (!this._content) { return; }

		var node = this._contentNode;
		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    offset = toPoint(this.options.offset),
		    anchor = this._getAnchor();

		if (this._zoomAnimated) {
			setPosition(this._container, pos.add(anchor));
		} else {
			offset = offset.add(pos).add(anchor);
		}

		var bottom = this._containerBottom = -offset.y,
		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_getAnchor: function () {
		return [0, 0];
	}

});

/*
 * @class Popup
 * @inherits DivOverlay
 * @aka L.Popup
 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
 * open popups while making sure that only one popup is open at one time
 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
 *
 * @example
 *
 * If you want to just bind a popup to marker click and then open it, it's really easy:
 *
 * ```js
 * marker.bindPopup(popupContent).openPopup();
 * ```
 * Path overlays like polylines also have a `bindPopup` method.
 * Here's a more complicated way to open a popup on a map:
 *
 * ```js
 * var popup = L.popup()
 * 	.setLatLng(latlng)
 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
 * 	.openOn(map);
 * ```
 */


// @namespace Popup
var Popup = DivOverlay.extend({

	// @section
	// @aka Popup options
	options: {
		// @option maxWidth: Number = 300
		// Max width of the popup, in pixels.
		maxWidth: 300,

		// @option minWidth: Number = 50
		// Min width of the popup, in pixels.
		minWidth: 50,

		// @option maxHeight: Number = null
		// If set, creates a scrollable container of the given height
		// inside a popup if its content exceeds it.
		maxHeight: null,

		// @option autoPan: Boolean = true
		// Set it to `false` if you don't want the map to do panning animation
		// to fit the opened popup.
		autoPan: true,

		// @option autoPanPaddingTopLeft: Point = null
		// The margin between the popup and the top left corner of the map
		// view after autopanning was performed.
		autoPanPaddingTopLeft: null,

		// @option autoPanPaddingBottomRight: Point = null
		// The margin between the popup and the bottom right corner of the map
		// view after autopanning was performed.
		autoPanPaddingBottomRight: null,

		// @option autoPanPadding: Point = Point(5, 5)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [5, 5],

		// @option keepInView: Boolean = false
		// Set it to `true` if you want to prevent users from panning the popup
		// off of the screen while it is open.
		keepInView: false,

		// @option closeButton: Boolean = true
		// Controls the presence of a close button in the popup.
		closeButton: true,

		// @option autoClose: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the popup closing when another popup is opened.
		autoClose: true,

		// @option closeOnEscapeKey: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the ESC key for closing of the popup.
		closeOnEscapeKey: true,

		// @option closeOnClick: Boolean = *
		// Set it if you want to override the default behavior of the popup closing when user clicks
		// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: ''
	},

	// @namespace Popup
	// @method openOn(map: Map): this
	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onAdd: function (map) {
		DivOverlay.prototype.onAdd.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupopen: PopupEvent
		// Fired when a popup is opened in the map
		map.fire('popupopen', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup bound to this layer is opened
			this._source.fire('popupopen', {popup: this}, true);
			// For non-path layers, we toggle the popup when clicking
			// again the layer, so prevent the map to reopen it.
			if (!(this._source instanceof Path)) {
				this._source.on('preclick', stopPropagation);
			}
		}
	},

	onRemove: function (map) {
		DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupclose: PopupEvent
		// Fired when a popup in the map is closed
		map.fire('popupclose', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup bound to this layer is closed
			this._source.fire('popupclose', {popup: this}, true);
			if (!(this._source instanceof Path)) {
				this._source.off('preclick', stopPropagation);
			}
		}
	},

	getEvents: function () {
		var events = DivOverlay.prototype.getEvents.call(this);

		if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}

		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
		    container = this._container = create$1('div',
			prefix + ' ' + (this.options.className || '') +
			' leaflet-zoom-animated');

		var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
		this._contentNode = create$1('div', prefix + '-content', wrapper);

		disableClickPropagation(wrapper);
		disableScrollPropagation(this._contentNode);
		on(wrapper, 'contextmenu', stopPropagation);

		this._tipContainer = create$1('div', prefix + '-tip-container', container);
		this._tip = create$1('div', prefix + '-tip', this._tipContainer);

		if (this.options.closeButton) {
			var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			on(closeButton, 'click', this._onCloseButtonClick, this);
		}
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			addClass(container, scrolledClass);
		} else {
			removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
		    anchor = this._getAnchor();
		setPosition(this._container, pos.add(anchor));
	},

	_adjustPan: function () {
		if (!this.options.autoPan) { return; }
		if (this._map._panAnim) { this._map._panAnim.stop(); }

		var map = this._map,
		    marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
		    containerHeight = this._container.offsetHeight + marginBottom,
		    containerWidth = this._containerWidth,
		    layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);

		layerPos._add(getPosition(this._container));

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = toPoint(this.options.autoPanPadding),
		    paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		// @namespace Map
		// @section Popup events
		// @event autopanstart: Event
		// Fired when the map starts autopanning when opening a popup.
		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		stop(e);
	},

	_getAnchor: function () {
		// Where should we anchor the popup on the source layer?
		return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
	}

});

// @namespace Popup
// @factory L.popup(options?: Popup options, source?: Layer)
// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
var popup = function (options, source) {
	return new Popup(options, source);
};


/* @namespace Map
 * @section Interaction Options
 * @option closePopupOnClick: Boolean = true
 * Set it to `false` if you don't want popups to close when user clicks the map.
 */
Map.mergeOptions({
	closePopupOnClick: true
});


// @namespace Map
// @section Methods for Layers and Controls
Map.include({
	// @method openPopup(popup: Popup): this
	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
	// @alternative
	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
	// Creates a popup with the specified content and options and opens it in the given point on a map.
	openPopup: function (popup, latlng, options) {
		if (!(popup instanceof Popup)) {
			popup = new Popup(options).setContent(popup);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	// @method closePopup(popup?: Popup): this
	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});

/*
 * @namespace Layer
 * @section Popup methods example
 *
 * All layers share a set of methods convenient for binding popups to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
 * layer.openPopup();
 * layer.closePopup();
 * ```
 *
 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
 */

// @section Popup methods
Layer.include({

	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
	// Binds a popup to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindPopup: function (content, options) {

		if (content instanceof Popup) {
			setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	// @method unbindPopup(): this
	// Removes the popup previously bound with `bindPopup`.
	unbindPopup: function () {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	// @method openPopup(latlng?: LatLng): this
	// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
	openPopup: function (layer, latlng) {
		if (this._popup && this._map) {
			latlng = this._popup._prepareOpen(this, layer, latlng);

			// open the popup on the map
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	// @method closePopup(): this
	// Closes the popup bound to this layer if it is open.
	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	// @method togglePopup(): this
	// Opens or closes the popup bound to this layer depending on its current state.
	togglePopup: function (target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	// @method isPopupOpen(): boolean
	// Returns `true` if the popup bound to this layer is currently open.
	isPopupOpen: function () {
		return (this._popup ? this._popup.isOpen() : false);
	},

	// @method setPopupContent(content: String|HTMLElement|Popup): this
	// Sets the content of the popup bound to this layer.
	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	// @method getPopup(): Popup
	// Returns the popup bound to this layer.
	getPopup: function () {
		return this._popup;
	},

	_openPopup: function (e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// prevent map click
		stop(e);

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	},

	_onKeyPress: function (e) {
		if (e.originalEvent.keyCode === 13) {
			this._openPopup(e);
		}
	}
});

/*
 * @class Tooltip
 * @inherits DivOverlay
 * @aka L.Tooltip
 * Used to display small texts on top of map layers.
 *
 * @example
 *
 * ```js
 * marker.bindTooltip("my tooltip text").openTooltip();
 * ```
 * Note about tooltip offset. Leaflet takes two options in consideration
 * for computing tooltip offsetting:
 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
 *   move it to the bottom. Negatives will move to the left and top.
 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
 *   should adapt this value if you use a custom icon.
 */


// @namespace Tooltip
var Tooltip = DivOverlay.extend({

	// @section
	// @aka Tooltip options
	options: {
		// @option pane: String = 'tooltipPane'
		// `Map pane` where the tooltip will be added.
		pane: 'tooltipPane',

		// @option offset: Point = Point(0, 0)
		// Optional offset of the tooltip position.
		offset: [0, 0],

		// @option direction: String = 'auto'
		// Direction where to open the tooltip. Possible values are: `right`, `left`,
		// `top`, `bottom`, `center`, `auto`.
		// `auto` will dynamically switch between `right` and `left` according to the tooltip
		// position on the map.
		direction: 'auto',

		// @option permanent: Boolean = false
		// Whether to open the tooltip permanently or only on mouseover.
		permanent: false,

		// @option sticky: Boolean = false
		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
		sticky: false,

		// @option interactive: Boolean = false
		// If true, the tooltip will listen to the feature events.
		interactive: false,

		// @option opacity: Number = 0.9
		// Tooltip container opacity.
		opacity: 0.9
	},

	onAdd: function (map) {
		DivOverlay.prototype.onAdd.call(this, map);
		this.setOpacity(this.options.opacity);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipopen: TooltipEvent
		// Fired when a tooltip is opened in the map.
		map.fire('tooltipopen', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip bound to this layer is opened.
			this._source.fire('tooltipopen', {tooltip: this}, true);
		}
	},

	onRemove: function (map) {
		DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipclose: TooltipEvent
		// Fired when a tooltip in the map is closed.
		map.fire('tooltipclose', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip bound to this layer is closed.
			this._source.fire('tooltipclose', {tooltip: this}, true);
		}
	},

	getEvents: function () {
		var events = DivOverlay.prototype.getEvents.call(this);

		if (touch && !this.options.permanent) {
			events.preclick = this._close;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closeTooltip(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-tooltip',
		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		this._contentNode = this._container = create$1('div', className);
	},

	_updateLayout: function () {},

	_adjustPan: function () {},

	_setPosition: function (pos) {
		var map = this._map,
		    container = this._container,
		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
		    tooltipPoint = map.layerPointToContainerPoint(pos),
		    direction = this.options.direction,
		    tooltipWidth = container.offsetWidth,
		    tooltipHeight = container.offsetHeight,
		    offset = toPoint(this.options.offset),
		    anchor = this._getAnchor();

		if (direction === 'top') {
			pos = pos.add(toPoint(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));
		} else if (direction === 'bottom') {
			pos = pos.subtract(toPoint(tooltipWidth / 2 - offset.x, -offset.y, true));
		} else if (direction === 'center') {
			pos = pos.subtract(toPoint(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));
		} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
			direction = 'right';
			pos = pos.add(toPoint(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));
		} else {
			direction = 'left';
			pos = pos.subtract(toPoint(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));
		}

		removeClass(container, 'leaflet-tooltip-right');
		removeClass(container, 'leaflet-tooltip-left');
		removeClass(container, 'leaflet-tooltip-top');
		removeClass(container, 'leaflet-tooltip-bottom');
		addClass(container, 'leaflet-tooltip-' + direction);
		setPosition(container, pos);
	},

	_updatePosition: function () {
		var pos = this._map.latLngToLayerPoint(this._latlng);
		this._setPosition(pos);
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._container) {
			setOpacity(this._container, opacity);
		}
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		this._setPosition(pos);
	},

	_getAnchor: function () {
		// Where should we anchor the tooltip on the source layer?
		return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
	}

});

// @namespace Tooltip
// @factory L.tooltip(options?: Tooltip options, source?: Layer)
// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
var tooltip = function (options, source) {
	return new Tooltip(options, source);
};

// @namespace Map
// @section Methods for Layers and Controls
Map.include({

	// @method openTooltip(tooltip: Tooltip): this
	// Opens the specified tooltip.
	// @alternative
	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
	// Creates a tooltip with the specified content and options and open it.
	openTooltip: function (tooltip, latlng, options) {
		if (!(tooltip instanceof Tooltip)) {
			tooltip = new Tooltip(options).setContent(tooltip);
		}

		if (latlng) {
			tooltip.setLatLng(latlng);
		}

		if (this.hasLayer(tooltip)) {
			return this;
		}

		return this.addLayer(tooltip);
	},

	// @method closeTooltip(tooltip?: Tooltip): this
	// Closes the tooltip given as parameter.
	closeTooltip: function (tooltip) {
		if (tooltip) {
			this.removeLayer(tooltip);
		}
		return this;
	}

});

/*
 * @namespace Layer
 * @section Tooltip methods example
 *
 * All layers share a set of methods convenient for binding tooltips to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
 * layer.openTooltip();
 * layer.closeTooltip();
 * ```
 */

// @section Tooltip methods
Layer.include({

	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
	// Binds a tooltip to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindTooltip: function (content, options) {

		if (content instanceof Tooltip) {
			setOptions(content, options);
			this._tooltip = content;
			content._source = this;
		} else {
			if (!this._tooltip || options) {
				this._tooltip = new Tooltip(options, this);
			}
			this._tooltip.setContent(content);

		}

		this._initTooltipInteractions();

		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
			this.openTooltip();
		}

		return this;
	},

	// @method unbindTooltip(): this
	// Removes the tooltip previously bound with `bindTooltip`.
	unbindTooltip: function () {
		if (this._tooltip) {
			this._initTooltipInteractions(true);
			this.closeTooltip();
			this._tooltip = null;
		}
		return this;
	},

	_initTooltipInteractions: function (remove$$1) {
		if (!remove$$1 && this._tooltipHandlersAdded) { return; }
		var onOff = remove$$1 ? 'off' : 'on',
		    events = {
			remove: this.closeTooltip,
			move: this._moveTooltip
		    };
		if (!this._tooltip.options.permanent) {
			events.mouseover = this._openTooltip;
			events.mouseout = this.closeTooltip;
			if (this._tooltip.options.sticky) {
				events.mousemove = this._moveTooltip;
			}
			if (touch) {
				events.click = this._openTooltip;
			}
		} else {
			events.add = this._openTooltip;
		}
		this[onOff](events);
		this._tooltipHandlersAdded = !remove$$1;
	},

	// @method openTooltip(latlng?: LatLng): this
	// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
	openTooltip: function (layer, latlng) {
		if (this._tooltip && this._map) {
			latlng = this._tooltip._prepareOpen(this, layer, latlng);

			// open the tooltip on the map
			this._map.openTooltip(this._tooltip, latlng);

			// Tooltip container may not be defined if not permanent and never
			// opened.
			if (this._tooltip.options.interactive && this._tooltip._container) {
				addClass(this._tooltip._container, 'leaflet-clickable');
				this.addInteractiveTarget(this._tooltip._container);
			}
		}

		return this;
	},

	// @method closeTooltip(): this
	// Closes the tooltip bound to this layer if it is open.
	closeTooltip: function () {
		if (this._tooltip) {
			this._tooltip._close();
			if (this._tooltip.options.interactive && this._tooltip._container) {
				removeClass(this._tooltip._container, 'leaflet-clickable');
				this.removeInteractiveTarget(this._tooltip._container);
			}
		}
		return this;
	},

	// @method toggleTooltip(): this
	// Opens or closes the tooltip bound to this layer depending on its current state.
	toggleTooltip: function (target) {
		if (this._tooltip) {
			if (this._tooltip._map) {
				this.closeTooltip();
			} else {
				this.openTooltip(target);
			}
		}
		return this;
	},

	// @method isTooltipOpen(): boolean
	// Returns `true` if the tooltip bound to this layer is currently open.
	isTooltipOpen: function () {
		return this._tooltip.isOpen();
	},

	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
	// Sets the content of the tooltip bound to this layer.
	setTooltipContent: function (content) {
		if (this._tooltip) {
			this._tooltip.setContent(content);
		}
		return this;
	},

	// @method getTooltip(): Tooltip
	// Returns the tooltip bound to this layer.
	getTooltip: function () {
		return this._tooltip;
	},

	_openTooltip: function (e) {
		var layer = e.layer || e.target;

		if (!this._tooltip || !this._map) {
			return;
		}
		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
	},

	_moveTooltip: function (e) {
		var latlng = e.latlng, containerPoint, layerPoint;
		if (this._tooltip.options.sticky && e.originalEvent) {
			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
			latlng = this._map.layerPointToLatLng(layerPoint);
		}
		this._tooltip.setLatLng(latlng);
	}
});

/*
 * @class DivIcon
 * @aka L.DivIcon
 * @inherits Icon
 *
 * Represents a lightweight icon for markers that uses a simple `<div>`
 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
 *
 * @example
 * ```js
 * var myIcon = L.divIcon({className: 'my-div-icon'});
 * // you can set .my-div-icon styles in CSS
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
 */

var DivIcon = Icon.extend({
	options: {
		// @section
		// @aka DivIcon options
		iconSize: [12, 12], // also can be set through CSS

		// iconAnchor: (Point),
		// popupAnchor: (Point),

		// @option html: String|HTMLElement = ''
		// Custom HTML code to put inside the div element, empty by default. Alternatively,
		// an instance of `HTMLElement`.
		html: false,

		// @option bgPos: Point = [0, 0]
		// Optional relative position of the background, in pixels
		bgPos: null,

		className: 'leaflet-div-icon'
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		if (options.html instanceof Element) {
			empty(div);
			div.appendChild(options.html);
		} else {
			div.innerHTML = options.html !== false ? options.html : '';
		}

		if (options.bgPos) {
			var bgPos = toPoint(options.bgPos);
			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function () {
		return null;
	}
});

// @factory L.divIcon(options: DivIcon options)
// Creates a `DivIcon` instance with the given options.
function divIcon(options) {
	return new DivIcon(options);
}

Icon.Default = IconDefault;

/*
 * @class GridLayer
 * @inherits Layer
 * @aka L.GridLayer
 *
 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
 *
 *
 * @section Synchronous usage
 * @example
 *
 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords){
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
 *         var ctx = tile.getContext('2d');
 *
 *         // return the tile so it can be rendered on screen
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section Asynchronous usage
 * @example
 *
 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords, done){
 *         var error;
 *
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // draw something asynchronously and pass the tile to the done() callback
 *         setTimeout(function() {
 *             done(error, tile);
 *         }, 1000);
 *
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section
 */


var GridLayer = Layer.extend({

	// @section
	// @aka GridLayer options
	options: {
		// @option tileSize: Number|Point = 256
		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
		tileSize: 256,

		// @option opacity: Number = 1.0
		// Opacity of the tiles. Can be used in the `createTile()` function.
		opacity: 1,

		// @option updateWhenIdle: Boolean = (depends)
		// Load new tiles only when panning ends.
		// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
		// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
		// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
		updateWhenIdle: mobile,

		// @option updateWhenZooming: Boolean = true
		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
		updateWhenZooming: true,

		// @option updateInterval: Number = 200
		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
		updateInterval: 200,

		// @option zIndex: Number = 1
		// The explicit zIndex of the tile layer.
		zIndex: 1,

		// @option bounds: LatLngBounds = undefined
		// If set, tiles will only be loaded inside the set `LatLngBounds`.
		bounds: null,

		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = undefined
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: undefined,

		// @option maxNativeZoom: Number = undefined
		// Maximum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
		// from `maxNativeZoom` level and auto-scaled.
		maxNativeZoom: undefined,

		// @option minNativeZoom: Number = undefined
		// Minimum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
		// from `minNativeZoom` level and auto-scaled.
		minNativeZoom: undefined,

		// @option noWrap: Boolean = false
		// Whether the layer is wrapped around the antimeridian. If `true`, the
		// GridLayer will only be displayed once at low zoom levels. Has no
		// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
		// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
		// tiles outside the CRS limits.
		noWrap: false,

		// @option pane: String = 'tilePane'
		// `Map pane` where the grid layer will be added.
		pane: 'tilePane',

		// @option className: String = ''
		// A custom class name to assign to the tile layer. Empty by default.
		className: '',

		// @option keepBuffer: Number = 2
		// When panning the map, keep this many rows and columns of tiles before unloading them.
		keepBuffer: 2
	},

	initialize: function (options) {
		setOptions(this, options);
	},

	onAdd: function () {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._resetView();
		this._update();
	},

	beforeAdd: function (map) {
		map._addZoomLimit(this);
	},

	onRemove: function (map) {
		this._removeAllTiles();
		remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = undefined;
	},

	// @method bringToFront: this
	// Brings the tile layer to the top of all tile layers.
	bringToFront: function () {
		if (this._map) {
			toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings the tile layer to the bottom of all tile layers.
	bringToBack: function () {
		if (this._map) {
			toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the tiles for this layer.
	getContainer: function () {
		return this._container;
	},

	// @method setOpacity(opacity: Number): this
	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// @method setZIndex(zIndex: Number): this
	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	// @method isLoading: Boolean
	// Returns `true` if any tile in the grid layer has not finished loading.
	isLoading: function () {
		return this._loading;
	},

	// @method redraw: this
	// Causes the layer to clear all the tiles and request them again.
	redraw: function () {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			viewprereset: this._invalidateAll,
			viewreset: this._resetView,
			zoom: this._resetView,
			moveend: this._onMoveEnd
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			if (!this._onMove) {
				this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
			}

			events.move = this._onMove;
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @section Extension methods
	// Layers extending `GridLayer` shall reimplement the following method.
	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, must be overridden by classes extending `GridLayer`.
	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
	// is specified, it must be called when the tile has finished loading and drawing.
	createTile: function () {
		return document.createElement('div');
	},

	// @section
	// @method getTileSize: Point
	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
	getTileSize: function () {
		var s = this.options.tileSize;
		return s instanceof Point ? s : new Point(s, s);
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function () {
		if (!this._map) { return; }

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (ielt9) { return; }

		setOpacity(this._container, this.options.opacity);

		var now = +new Date(),
		    nextFrame = false,
		    willPrune = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded) { continue; }

			var fade = Math.min(1, (now - tile.loaded) / 200);

			setOpacity(tile.el, fade);
			if (fade < 1) {
				nextFrame = true;
			} else {
				if (tile.active) {
					willPrune = true;
				} else {
					this._onOpaqueTile(tile);
				}
				tile.active = true;
			}
		}

		if (willPrune && !this._noPrune) { this._pruneTiles(); }

		if (nextFrame) {
			cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
		}
	},

	_onOpaqueTile: falseFn,

	_initContainer: function () {
		if (this._container) { return; }

		this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function () {

		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom;

		if (zoom === undefined) { return undefined; }

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
				this._onUpdateLevel(z);
			} else {
				remove(this._levels[z].el);
				this._removeTilesAtZoom(z);
				this._onRemoveLevel(z);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
		    map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			falseFn(level.el.offsetWidth);

			this._onCreateLevel(level);
		}

		this._level = level;

		return level;
	},

	_onUpdateLevel: falseFn,

	_onRemoveLevel: falseFn,

	_onCreateLevel: falseFn,

	_pruneTiles: function () {
		if (!this._map) {
			return;
		}

		var key, tile;

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom ||
			zoom < this.options.minZoom) {
			this._removeAllTiles();
			return;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeTilesAtZoom: function (zoom) {
		for (var key in this._tiles) {
			if (this._tiles[key].coords.z !== zoom) {
				continue;
			}
			this._removeTile(key);
		}
	},

	_removeAllTiles: function () {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_invalidateAll: function () {
		for (var z in this._levels) {
			remove(this._levels[z].el);
			this._onRemoveLevel(z);
			delete this._levels[z];
		}
		this._removeAllTiles();

		this._tileZoom = undefined;
	},

	_retainParent: function (x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
		    y2 = Math.floor(y / 2),
		    z2 = z - 1,
		    coords2 = new Point(+x2, +y2);
		coords2.z = +z2;

		var key = this._tileCoordsToKey(coords2),
		    tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;

		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function (x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var coords = new Point(i, j);
				coords.z = z + 1;

				var key = this._tileCoordsToKey(coords),
				    tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;

				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_resetView: function (e) {
		var animating = e && (e.pinch || e.flyTo);
		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
	},

	_animateZoom: function (e) {
		this._setView(e.center, e.zoom, true, e.noUpdate);
	},

	_clampZoom: function (zoom) {
		var options = this.options;

		if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
			return options.minNativeZoom;
		}

		if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
			return options.maxNativeZoom;
		}

		return zoom;
	},

	_setView: function (center, zoom, noPrune, noUpdate) {
		var tileZoom = this._clampZoom(Math.round(zoom));
		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
		    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
			tileZoom = undefined;
		}

		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

		if (!noUpdate || tileZoomChanged) {

			this._tileZoom = tileZoom;

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._updateLevels();
			this._resetGrid();

			if (tileZoom !== undefined) {
				this._update(center);
			}

			if (!noPrune) {
				this._pruneTiles();
			}

			// Flag to prevent _updateOpacity from pruning tiles during
			// a zoom anim or a pinch gesture
			this._noPrune = !!noPrune;
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function (center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function (level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
		    translate = level.origin.multiplyBy(scale)
		        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		if (any3d) {
			setTransform(level.el, translate, scale);
		} else {
			setPosition(level.el, translate);
		}
	},

	_resetGrid: function () {
		var map = this._map,
		    crs = map.options.crs,
		    tileSize = this._tileSize = this.getTileSize(),
		    tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && !this.options.noWrap && [
			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
		];
		this._wrapY = crs.wrapLat && !this.options.noWrap && [
			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
		];
	},

	_onMoveEnd: function () {
		if (!this._map || this._map._animatingZoom) { return; }

		this._update();
	},

	_getTiledPixelBounds: function (center) {
		var map = this._map,
		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
		    scale = map.getZoomScale(mapZoom, this._tileZoom),
		    pixelCenter = map.project(center, this._tileZoom).floor(),
		    halfSize = map.getSize().divideBy(scale * 2);

		return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
	},

	// Private method to load tiles in the grid's active zoom level according to map bounds
	_update: function (center) {
		var map = this._map;
		if (!map) { return; }
		var zoom = this._clampZoom(map.getZoom());

		if (center === undefined) { center = map.getCenter(); }
		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

		var pixelBounds = this._getTiledPixelBounds(center),
		    tileRange = this._pxBoundsToTileRange(pixelBounds),
		    tileCenter = tileRange.getCenter(),
		    queue = [],
		    margin = this.options.keepBuffer,
		    noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
		                              tileRange.getTopRight().add([margin, -margin]));

		// Sanity check: panic if the tile range contains Infinity somewhere.
		if (!(isFinite(tileRange.min.x) &&
		      isFinite(tileRange.min.y) &&
		      isFinite(tileRange.max.x) &&
		      isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }

		for (var key in this._tiles) {
			var c = this._tiles[key].coords;
			if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
				this._tiles[key].current = false;
			}
		}

		// _update just loads more tiles. If the tile zoom level differs too much
		// from the map's, let _setView reset levels and prune old tiles.
		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new Point(i, j);
				coords.z = this._tileZoom;

				if (!this._isValidTile(coords)) { continue; }

				var tile = this._tiles[this._tileCoordsToKey(coords)];
				if (tile) {
					tile.current = true;
				} else {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if it's the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				// @event loading: Event
				// Fired when the grid layer starts loading tiles.
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function (coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
		}

		if (!this.options.bounds) { return true; }

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
	},

	_keyToBounds: function (key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	_tileCoordsToNwSe: function (coords) {
		var map = this._map,
		    tileSize = this.getTileSize(),
		    nwPoint = coords.scaleBy(tileSize),
		    sePoint = nwPoint.add(tileSize),
		    nw = map.unproject(nwPoint, coords.z),
		    se = map.unproject(sePoint, coords.z);
		return [nw, se];
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function (coords) {
		var bp = this._tileCoordsToNwSe(coords),
		    bounds = new LatLngBounds(bp[0], bp[1]);

		if (!this.options.noWrap) {
			bounds = this._map.wrapLatLngBounds(bounds);
		}
		return bounds;
	},
	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function (coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function (key) {
		var k = key.split(':'),
		    coords = new Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		remove(tile.el);

		delete this._tiles[key];

		// @event tileunload: TileEvent
		// Fired when a tile is removed (e.g. when a tile goes off the screen).
		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function (tile) {
		addClass(tile, 'leaflet-tile');

		var tileSize = this.getTileSize();
		tile.style.width = tileSize.x + 'px';
		tile.style.height = tileSize.y + 'px';

		tile.onselectstart = falseFn;
		tile.onmousemove = falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (ielt9 && this.options.opacity < 1) {
			setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (android && !android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function (coords, container) {
		var tilePos = this._getTilePos(coords),
		    key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
		}

		setPosition(tile, tilePos);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		// @event tileloadstart: TileEvent
		// Fired when a tile is requested and starts loading.
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function (coords, err, tile) {
		if (err) {
			// @event tileerror: TileErrorEvent
			// Fired when there is an error loading a tile.
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) { return; }

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			setOpacity(tile.el, 0);
			cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		if (!err) {
			addClass(tile.el, 'leaflet-tile-loaded');

			// @event tileload: TileEvent
			// Fired when a tile loads.
			this.fire('tileload', {
				tile: tile.el,
				coords: coords
			});
		}

		if (this._noTilesToLoad()) {
			this._loading = false;
			// @event load: Event
			// Fired when the grid layer loaded all visible tiles.
			this.fire('load');

			if (ielt9 || !this._map._fadeAnimated) {
				requestAnimFrame(this._pruneTiles, this);
			} else {
				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
				// to trigger a pruning.
				setTimeout(bind(this._pruneTiles, this), 250);
			}
		}
	},

	_getTilePos: function (coords) {
		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
	},

	_wrapCoords: function (coords) {
		var newCoords = new Point(
			this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
			this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function (bounds) {
		var tileSize = this.getTileSize();
		return new Bounds(
			bounds.min.unscaleBy(tileSize).floor(),
			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function () {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) { return false; }
		}
		return true;
	}
});

// @factory L.gridLayer(options?: GridLayer options)
// Creates a new instance of GridLayer with the supplied options.
function gridLayer(options) {
	return new GridLayer(options);
}

/*
 * @class TileLayer
 * @inherits GridLayer
 * @aka L.TileLayer
 * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
 *
 * @example
 *
 * ```js
 * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'}).addTo(map);
 * ```
 *
 * @section URL template
 * @example
 *
 * A string of the following form:
 *
 * ```
 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
 * ```
 *
 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}`  zoom level, `{x}` and `{y}`  tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
 *
 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
 *
 * ```
 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
 * ```
 */


var TileLayer = GridLayer.extend({

	// @section
	// @aka TileLayer options
	options: {
		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = 18
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: 18,

		// @option subdomains: String|String[] = 'abc'
		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		subdomains: 'abc',

		// @option errorTileUrl: String = ''
		// URL to the tile image to show in place of the tile that failed to load.
		errorTileUrl: '',

		// @option zoomOffset: Number = 0
		// The zoom number used in tile URLs will be offset with this value.
		zoomOffset: 0,

		// @option tms: Boolean = false
		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
		tms: false,

		// @option zoomReverse: Boolean = false
		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
		zoomReverse: false,

		// @option detectRetina: Boolean = false
		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
		detectRetina: false,

		// @option crossOrigin: Boolean|String = false
		// Whether the crossOrigin attribute will be added to the tiles.
		// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
		crossOrigin: false
	},

	initialize: function (url, options) {

		this._url = url;

		options = setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	// If the URL does not change, the layer will not be redrawn unless
	// the noRedraw parameter is set to false.
	setUrl: function (url, noRedraw) {
		if (this._url === url && noRedraw === undefined) {
			noRedraw = true;
		}

		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function (coords, done) {
		var tile = document.createElement('img');

		on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
		on(tile, 'error', bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin || this.options.crossOrigin === '') {
			tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
		}

		/*
		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
		 http://www.w3.org/TR/WCAG20-TECHS/H67
		*/
		tile.alt = '';

		/*
		 Set role="presentation" to force screen readers to ignore this
		 https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
		*/
		tile.setAttribute('role', 'presentation');

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	// @section Extension methods
	// @uninheritable
	// Layers extending `TileLayer` might reimplement the following method.
	// @method getTileUrl(coords: Object): String
	// Called only internally, returns the URL for a tile given its coordinates.
	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
	getTileUrl: function (coords) {
		var data = {
			r: retina ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: this._getZoomForUrl()
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) {
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		return template(this._url, extend(data, this.options));
	},

	_tileOnLoad: function (done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (ielt9) {
			setTimeout(bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function (done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl && tile.getAttribute('src') !== errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	_onTileRemove: function (e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function () {
		var zoom = this._tileZoom,
		maxZoom = this.options.maxZoom,
		zoomReverse = this.options.zoomReverse,
		zoomOffset = this.options.zoomOffset;

		if (zoomReverse) {
			zoom = maxZoom - zoom;
		}

		return zoom + zoomOffset;
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function () {
		var i, tile;
		for (i in this._tiles) {
			if (this._tiles[i].coords.z !== this._tileZoom) {
				tile = this._tiles[i].el;

				tile.onload = falseFn;
				tile.onerror = falseFn;

				if (!tile.complete) {
					tile.src = emptyImageUrl;
					remove(tile);
					delete this._tiles[i];
				}
			}
		}
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		// Cancels any pending http requests associated with the tile
		// unless we're on Android's stock browser,
		// see https://github.com/Leaflet/Leaflet/issues/137
		if (!androidStock) {
			tile.el.setAttribute('src', emptyImageUrl);
		}

		return GridLayer.prototype._removeTile.call(this, key);
	},

	_tileReady: function (coords, err, tile) {
		if (!this._map || (tile && tile.getAttribute('src') === emptyImageUrl)) {
			return;
		}

		return GridLayer.prototype._tileReady.call(this, coords, err, tile);
	}
});


// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
// Instantiates a tile layer object given a `URL template` and optionally an options object.

function tileLayer(url, options) {
	return new TileLayer(url, options);
}

/*
 * @class TileLayer.WMS
 * @inherits TileLayer
 * @aka L.TileLayer.WMS
 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
 *
 * @example
 *
 * ```js
 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
 * 	layers: 'nexrad-n0r-900913',
 * 	format: 'image/png',
 * 	transparent: true,
 * 	attribution: "Weather data  2012 IEM Nexrad"
 * });
 * ```
 */

var TileLayerWMS = TileLayer.extend({

	// @section
	// @aka TileLayer.WMS options
	// If any custom options not documented here are used, they will be sent to the
	// WMS server as extra parameters in each request URL. This can be useful for
	// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',

		// @option layers: String = ''
		// **(required)** Comma-separated list of WMS layers to show.
		layers: '',

		// @option styles: String = ''
		// Comma-separated list of WMS styles.
		styles: '',

		// @option format: String = 'image/jpeg'
		// WMS image format (use `'image/png'` for layers with transparency).
		format: 'image/jpeg',

		// @option transparent: Boolean = false
		// If `true`, the WMS service will return images with transparency.
		transparent: false,

		// @option version: String = '1.1.1'
		// Version of the WMS service to use
		version: '1.1.1'
	},

	options: {
		// @option crs: CRS = null
		// Coordinate Reference System to use for the WMS requests, defaults to
		// map CRS. Don't change this if you're not sure what it means.
		crs: null,

		// @option uppercase: Boolean = false
		// If `true`, WMS request parameter keys will be uppercase.
		uppercase: false
	},

	initialize: function (url, options) {

		this._url = url;

		var wmsParams = extend({}, this.defaultWmsParams);

		// all keys that are not TileLayer options go to WMS params
		for (var i in options) {
			if (!(i in this.options)) {
				wmsParams[i] = options[i];
			}
		}

		options = setOptions(this, options);

		var realRetina = options.detectRetina && retina ? 2 : 1;
		var tileSize = this.getTileSize();
		wmsParams.width = tileSize.x * realRetina;
		wmsParams.height = tileSize.y * realRetina;

		this.wmsParams = wmsParams;
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;
		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (coords) {

		var tileBounds = this._tileCoordsToNwSe(coords),
		    crs = this._crs,
		    bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
		    min = bounds.min,
		    max = bounds.max,
		    bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ?
		    [min.y, min.x, max.y, max.x] :
		    [min.x, min.y, max.x, max.y]).join(','),
		    url = TileLayer.prototype.getTileUrl.call(this, coords);
		return url +
			getParamString(this.wmsParams, url, this.options.uppercase) +
			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
	},

	// @method setParams(params: Object, noRedraw?: Boolean): this
	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
	setParams: function (params, noRedraw) {

		extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});


// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
function tileLayerWMS(url, options) {
	return new TileLayerWMS(url, options);
}

TileLayer.WMS = TileLayerWMS;
tileLayer.wms = tileLayerWMS;

/*
 * @class Renderer
 * @inherits Layer
 * @aka L.Renderer
 *
 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
 * DOM container of the renderer, its bounds, and its zoom animation.
 *
 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
 * itself can be added or removed to the map. All paths use a renderer, which can
 * be implicit (the map will decide the type of renderer and use it automatically)
 * or explicit (using the [`renderer`](#path-renderer) option of the path).
 *
 * Do not use this class directly, use `SVG` and `Canvas` instead.
 *
 * @event update: Event
 * Fired when the renderer updates its bounds, center and zoom, for example when
 * its map has moved
 */

var Renderer = Layer.extend({

	// @section
	// @aka Renderer options
	options: {
		// @option padding: Number = 0.1
		// How much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction
		padding: 0.1,

		// @option tolerance: Number = 0
		// How much to extend click tolerance round a path/object on the map
		tolerance : 0
	},

	initialize: function (options) {
		setOptions(this, options);
		stamp(this);
		this._layers = this._layers || {};
	},

	onAdd: function () {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
		this.on('update', this._updatePaths, this);
	},

	onRemove: function () {
		this.off('update', this._updatePaths, this);
		this._destroyContainer();
	},

	getEvents: function () {
		var events = {
			viewreset: this._reset,
			zoom: this._onZoom,
			moveend: this._update,
			zoomend: this._onZoomEnd
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._onAnimZoom;
		}
		return events;
	},

	_onAnimZoom: function (ev) {
		this._updateTransform(ev.center, ev.zoom);
	},

	_onZoom: function () {
		this._updateTransform(this._map.getCenter(), this._map.getZoom());
	},

	_updateTransform: function (center, zoom) {
		var scale = this._map.getZoomScale(zoom, this._zoom),
		    position = getPosition(this._container),
		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
		    currentCenterPoint = this._map.project(this._center, zoom),
		    destCenterPoint = this._map.project(center, zoom),
		    centerOffset = destCenterPoint.subtract(currentCenterPoint),

		    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

		if (any3d) {
			setTransform(this._container, topLeftOffset, scale);
		} else {
			setPosition(this._container, topLeftOffset);
		}
	},

	_reset: function () {
		this._update();
		this._updateTransform(this._center, this._zoom);

		for (var id in this._layers) {
			this._layers[id]._reset();
		}
	},

	_onZoomEnd: function () {
		for (var id in this._layers) {
			this._layers[id]._project();
		}
	},

	_updatePaths: function () {
		for (var id in this._layers) {
			this._layers[id]._update();
		}
	},

	_update: function () {
		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
		// Subclasses are responsible of firing the 'update' event.
		var p = this.options.padding,
		    size = this._map.getSize(),
		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

		this._center = this._map.getCenter();
		this._zoom = this._map.getZoom();
	}
});

/*
 * @class Canvas
 * @inherits Renderer
 * @aka L.Canvas
 *
 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
 * available in all web browsers, notably IE8, and overlapping geometries might
 * not display properly in some edge cases.
 *
 * @example
 *
 * Use Canvas by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.canvas()
 * });
 * ```
 *
 * Use a Canvas renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.canvas({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var Canvas = Renderer.extend({
	getEvents: function () {
		var events = Renderer.prototype.getEvents.call(this);
		events.viewprereset = this._onViewPreReset;
		return events;
	},

	_onViewPreReset: function () {
		// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
		this._postponeUpdatePaths = true;
	},

	onAdd: function () {
		Renderer.prototype.onAdd.call(this);

		// Redraw vectors since canvas is cleared upon removal,
		// in case of removing the renderer itself from the map.
		this._draw();
	},

	_initContainer: function () {
		var container = this._container = document.createElement('canvas');

		on(container, 'mousemove', this._onMouseMove, this);
		on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
		on(container, 'mouseout', this._handleMouseOut, this);

		this._ctx = container.getContext('2d');
	},

	_destroyContainer: function () {
		cancelAnimFrame(this._redrawRequest);
		delete this._ctx;
		remove(this._container);
		off(this._container);
		delete this._container;
	},

	_updatePaths: function () {
		if (this._postponeUpdatePaths) { return; }

		var layer;
		this._redrawBounds = null;
		for (var id in this._layers) {
			layer = this._layers[id];
			layer._update();
		}
		this._redraw();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		Renderer.prototype._update.call(this);

		var b = this._bounds,
		    container = this._container,
		    size = b.getSize(),
		    m = retina ? 2 : 1;

		setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);

		// Tell paths to redraw themselves
		this.fire('update');
	},

	_reset: function () {
		Renderer.prototype._reset.call(this);

		if (this._postponeUpdatePaths) {
			this._postponeUpdatePaths = false;
			this._updatePaths();
		}
	},

	_initPath: function (layer) {
		this._updateDashArray(layer);
		this._layers[stamp(layer)] = layer;

		var order = layer._order = {
			layer: layer,
			prev: this._drawLast,
			next: null
		};
		if (this._drawLast) { this._drawLast.next = order; }
		this._drawLast = order;
		this._drawFirst = this._drawFirst || this._drawLast;
	},

	_addPath: function (layer) {
		this._requestRedraw(layer);
	},

	_removePath: function (layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			this._drawLast = prev;
		}
		if (prev) {
			prev.next = next;
		} else {
			this._drawFirst = next;
		}

		delete layer._order;

		delete this._layers[stamp(layer)];

		this._requestRedraw(layer);
	},

	_updatePath: function (layer) {
		// Redraw the union of the layer's old pixel
		// bounds and the new pixel bounds.
		this._extendRedrawBounds(layer);
		layer._project();
		layer._update();
		// The redraw will extend the redraw bounds
		// with the new pixel bounds.
		this._requestRedraw(layer);
	},

	_updateStyle: function (layer) {
		this._updateDashArray(layer);
		this._requestRedraw(layer);
	},

	_updateDashArray: function (layer) {
		if (typeof layer.options.dashArray === 'string') {
			var parts = layer.options.dashArray.split(/[, ]+/),
			    dashArray = [],
			    dashValue,
			    i;
			for (i = 0; i < parts.length; i++) {
				dashValue = Number(parts[i]);
				// Ignore dash array containing invalid lengths
				if (isNaN(dashValue)) { return; }
				dashArray.push(dashValue);
			}
			layer.options._dashArray = dashArray;
		} else {
			layer.options._dashArray = layer.options.dashArray;
		}
	},

	_requestRedraw: function (layer) {
		if (!this._map) { return; }

		this._extendRedrawBounds(layer);
		this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
	},

	_extendRedrawBounds: function (layer) {
		if (layer._pxBounds) {
			var padding = (layer.options.weight || 0) + 1;
			this._redrawBounds = this._redrawBounds || new Bounds();
			this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
			this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
		}
	},

	_redraw: function () {
		this._redrawRequest = null;

		if (this._redrawBounds) {
			this._redrawBounds.min._floor();
			this._redrawBounds.max._ceil();
		}

		this._clear(); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_clear: function () {
		var bounds = this._redrawBounds;
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
		} else {
			this._ctx.clearRect(0, 0, this._container.width, this._container.height);
		}
	},

	_draw: function () {
		var layer, bounds = this._redrawBounds;
		this._ctx.save();
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.beginPath();
			this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
			this._ctx.clip();
		}

		this._drawing = true;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
				layer._updatePath();
			}
		}

		this._drawing = false;

		this._ctx.restore();  // Restore state before clipping.
	},

	_updatePoly: function (layer, closed) {
		if (!this._drawing) { return; }

		var i, j, len2, p,
		    parts = layer._parts,
		    len = parts.length,
		    ctx = this._ctx;

		if (!len) { return; }

		ctx.beginPath();

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function (layer) {

		if (!this._drawing || layer._empty()) { return; }

		var p = layer._point,
		    ctx = this._ctx,
		    r = Math.max(Math.round(layer._radius), 1),
		    s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function (ctx, layer) {
		var options = layer.options;

		if (options.fill) {
			ctx.globalAlpha = options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			if (ctx.setLineDash) {
				ctx.setLineDash(layer.options && layer.options._dashArray || []);
			}
			ctx.globalAlpha = options.opacity;
			ctx.lineWidth = options.weight;
			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				clickedLayer = layer;
			}
		}
		if (clickedLayer)  {
			fakeStop(e);
			this._fireEvent([clickedLayer], e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e);
		this._handleMouseHover(e, point);
	},


	_handleMouseOut: function (e) {
		var layer = this._hoveredLayer;
		if (layer) {
			// if we're leaving the layer, fire mouseout
			removeClass(this._container, 'leaflet-interactive');
			this._fireEvent([layer], e, 'mouseout');
			this._hoveredLayer = null;
			this._mouseHoverThrottled = false;
		}
	},

	_handleMouseHover: function (e, point) {
		if (this._mouseHoverThrottled) {
			return;
		}

		var layer, candidateHoveredLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point)) {
				candidateHoveredLayer = layer;
			}
		}

		if (candidateHoveredLayer !== this._hoveredLayer) {
			this._handleMouseOut(e);

			if (candidateHoveredLayer) {
				addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent([candidateHoveredLayer], e, 'mouseover');
				this._hoveredLayer = candidateHoveredLayer;
			}
		}

		if (this._hoveredLayer) {
			this._fireEvent([this._hoveredLayer], e);
		}

		this._mouseHoverThrottled = true;
		setTimeout(L.bind(function () {
			this._mouseHoverThrottled = false;
		}, this), 32);
	},

	_fireEvent: function (layers, e, type) {
		this._map._fireDOMEvent(e, type || e.type, layers);
	},

	_bringToFront: function (layer) {
		var order = layer._order;

		if (!order) { return; }

		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			// Already last
			return;
		}
		if (prev) {
			prev.next = next;
		} else if (next) {
			// Update first entry unless this is the
			// single entry
			this._drawFirst = next;
		}

		order.prev = this._drawLast;
		this._drawLast.next = order;

		order.next = null;
		this._drawLast = order;

		this._requestRedraw(layer);
	},

	_bringToBack: function (layer) {
		var order = layer._order;

		if (!order) { return; }

		var next = order.next;
		var prev = order.prev;

		if (prev) {
			prev.next = next;
		} else {
			// Already first
			return;
		}
		if (next) {
			next.prev = prev;
		} else if (prev) {
			// Update last entry unless this is the
			// single entry
			this._drawLast = prev;
		}

		order.prev = null;

		order.next = this._drawFirst;
		this._drawFirst.prev = order;
		this._drawFirst = order;

		this._requestRedraw(layer);
	}
});

// @factory L.canvas(options?: Renderer options)
// Creates a Canvas renderer with the given options.
function canvas$1(options) {
	return canvas ? new Canvas(options) : null;
}

/*
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */


var vmlCreate = (function () {
	try {
		document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
		return function (name) {
			return document.createElement('<lvml:' + name + ' class="lvml">');
		};
	} catch (e) {
		return function (name) {
			return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
		};
	}
})();


/*
 * @class SVG
 *
 *
 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
 * with old versions of Internet Explorer.
 */

// mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
var vmlMixin = {

	_initContainer: function () {
		this._container = create$1('div', 'leaflet-vml-container');
	},

	_update: function () {
		if (this._map._animatingZoom) { return; }
		Renderer.prototype._update.call(this);
		this.fire('update');
	},

	_initPath: function (layer) {
		var container = layer._container = vmlCreate('shape');

		addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = vmlCreate('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
		this._layers[stamp(layer)] = layer;
	},

	_addPath: function (layer) {
		var container = layer._container;
		this._container.appendChild(container);

		if (layer.options.interactive) {
			layer.addInteractiveTarget(container);
		}
	},

	_removePath: function (layer) {
		var container = layer._container;
		remove(container);
		layer.removeInteractiveTarget(container);
		delete this._layers[stamp(layer)];
	},

	_updateStyle: function (layer) {
		var stroke = layer._stroke,
		    fill = layer._fill,
		    options = layer.options,
		    container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = vmlCreate('stroke');
			}
			container.appendChild(stroke);
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;

		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = vmlCreate('fill');
			}
			container.appendChild(fill);
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function (layer) {
		var p = layer._point.round(),
		    r = Math.round(layer._radius),
		    r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' :
			'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
	},

	_setPath: function (layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function (layer) {
		toFront(layer._container);
	},

	_bringToBack: function (layer) {
		toBack(layer._container);
	}
};

var create$2 = vml ? vmlCreate : svgCreate;

/*
 * @class SVG
 * @inherits Renderer
 * @aka L.SVG
 *
 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
 * available in all web browsers, notably Android 2.x and 3.x.
 *
 * Although SVG is not available on IE7 and IE8, these browsers support
 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
 * (a now deprecated technology), and the SVG renderer will fall back to VML in
 * this case.
 *
 * @example
 *
 * Use SVG by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.svg()
 * });
 * ```
 *
 * Use a SVG renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.svg({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var SVG = Renderer.extend({

	getEvents: function () {
		var events = Renderer.prototype.getEvents.call(this);
		events.zoomstart = this._onZoomStart;
		return events;
	},

	_initContainer: function () {
		this._container = create$2('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');

		this._rootGroup = create$2('g');
		this._container.appendChild(this._rootGroup);
	},

	_destroyContainer: function () {
		remove(this._container);
		off(this._container);
		delete this._container;
		delete this._rootGroup;
		delete this._svgSize;
	},

	_onZoomStart: function () {
		// Drag-then-pinch interactions might mess up the center and zoom.
		// In this case, the easiest way to prevent this is re-do the renderer
		//   bounds and padding when the zooming starts.
		this._update();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		Renderer.prototype._update.call(this);

		var b = this._bounds,
		    size = b.getSize(),
		    container = this._container;

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

		this.fire('update');
	},

	// methods below are called by vector layers implementations

	_initPath: function (layer) {
		var path = layer._path = create$2('path');

		// @namespace Path
		// @option className: String = null
		// Custom class name set on an element. Only for SVG renderer.
		if (layer.options.className) {
			addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
		this._layers[stamp(layer)] = layer;
	},

	_addPath: function (layer) {
		if (!this._rootGroup) { this._initContainer(); }
		this._rootGroup.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function (layer) {
		remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
		delete this._layers[stamp(layer)];
	},

	_updatePath: function (layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function (layer) {
		var path = layer._path,
		    options = layer.options;

		if (!path) { return; }

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}
	},

	_updatePoly: function (layer, closed) {
		this._setPath(layer, pointsToPath(layer._parts, closed));
	},

	_updateCircle: function (layer) {
		var p = layer._point,
		    r = Math.max(Math.round(layer._radius), 1),
		    r2 = Math.max(Math.round(layer._radiusY), 1) || r,
		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' :
			'M' + (p.x - r) + ',' + p.y +
			arc + (r * 2) + ',0 ' +
			arc + (-r * 2) + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function (layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function (layer) {
		toFront(layer._path);
	},

	_bringToBack: function (layer) {
		toBack(layer._path);
	}
});

if (vml) {
	SVG.include(vmlMixin);
}

// @namespace SVG
// @factory L.svg(options?: Renderer options)
// Creates a SVG renderer with the given options.
function svg$1(options) {
	return svg || vml ? new SVG(options) : null;
}

Map.include({
	// @namespace Map; @method getRenderer(layer: Path): Renderer
	// Returns the instance of `Renderer` that should be used to render the given
	// `Path`. It will ensure that the `renderer` options of the map and paths
	// are respected, and that the renderers do exist on the map.
	getRenderer: function (layer) {
		// @namespace Path; @option renderer: Renderer
		// Use this specific instance of `Renderer` for this path. Takes
		// precedence over the map's [default renderer](#map-renderer).
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			renderer = this._renderer = this._createRenderer();
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function (name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = this._createRenderer({pane: name});
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	},

	_createRenderer: function (options) {
		// @namespace Map; @option preferCanvas: Boolean = false
		// Whether `Path`s should be rendered on a `Canvas` renderer.
		// By default, all `Path`s are rendered in a `SVG` renderer.
		return (this.options.preferCanvas && canvas$1(options)) || svg$1(options);
	}
});

/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

/*
 * @class Rectangle
 * @aka L.Rectangle
 * @inherits Polygon
 *
 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
 *
 * @example
 *
 * ```js
 * // define rectangle geographical bounds
 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
 *
 * // create an orange rectangle
 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
 *
 * // zoom the map to the rectangle bounds
 * map.fitBounds(bounds);
 * ```
 *
 */


var Rectangle = Polygon.extend({
	initialize: function (latLngBounds, options) {
		Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	// @method setBounds(latLngBounds: LatLngBounds): this
	// Redraws the rectangle with the passed bounds.
	setBounds: function (latLngBounds) {
		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = toLatLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});


// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
function rectangle(latLngBounds, options) {
	return new Rectangle(latLngBounds, options);
}

SVG.create = create$2;
SVG.pointsToPath = pointsToPath;

GeoJSON.geometryToLayer = geometryToLayer;
GeoJSON.coordsToLatLng = coordsToLatLng;
GeoJSON.coordsToLatLngs = coordsToLatLngs;
GeoJSON.latLngToCoords = latLngToCoords;
GeoJSON.latLngsToCoords = latLngsToCoords;
GeoJSON.getFeature = getFeature;
GeoJSON.asFeature = asFeature;

/*
 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
 * (zoom to a selected bounding box), enabled by default.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @option boxZoom: Boolean = true
	// Whether the map can be zoomed to a rectangular area specified by
	// dragging the mouse while pressing the shift key.
	boxZoom: true
});

var BoxZoom = Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
		this._resetStateTimeout = 0;
		map.on('unload', this._destroy, this);
	},

	addHooks: function () {
		on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function () {
		return this._moved;
	},

	_destroy: function () {
		remove(this._pane);
		delete this._pane;
	},

	_resetState: function () {
		this._resetStateTimeout = 0;
		this._moved = false;
	},

	_clearDeferredResetState: function () {
		if (this._resetStateTimeout !== 0) {
			clearTimeout(this._resetStateTimeout);
			this._resetStateTimeout = 0;
		}
	},

	_onMouseDown: function (e) {
		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		// Clear the deferred resetState if it hasn't executed yet, otherwise it
		// will interrupt the interaction and orphan a box element in the container.
		this._clearDeferredResetState();
		this._resetState();

		disableTextSelection();
		disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		on(document, {
			contextmenu: stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._moved = true;

			this._box = create$1('div', 'leaflet-zoom-box', this._container);
			addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new Bounds(this._point, this._startPoint),
		    size = bounds.getSize();

		setPosition(this._box, bounds.min);

		this._box.style.width  = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function () {
		if (this._moved) {
			remove(this._box);
			removeClass(this._container, 'leaflet-crosshair');
		}

		enableTextSelection();
		enableImageDrag();

		off(document, {
			contextmenu: stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function (e) {
		if ((e.which !== 1) && (e.button !== 1)) { return; }

		this._finish();

		if (!this._moved) { return; }
		// Postpone to next JS tick so internal click event handling
		// still see it as "moved".
		this._clearDeferredResetState();
		this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);

		var bounds = new LatLngBounds(
		        this._map.containerPointToLatLng(this._startPoint),
		        this._map.containerPointToLatLng(this._point));

		this._map
			.fitBounds(bounds)
			.fire('boxzoomend', {boxZoomBounds: bounds});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

// @section Handlers
// @property boxZoom: Handler
// Box (shift-drag with mouse) zoom handler.
Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

// @namespace Map
// @section Interaction Options

Map.mergeOptions({
	// @option doubleClickZoom: Boolean|String = true
	// Whether the map can be zoomed in by double clicking on it and
	// zoomed out by double clicking while holding shift. If passed
	// `'center'`, double-click zoom will zoom to the center of the
	//  view regardless of where the mouse was.
	doubleClickZoom: true
});

var DoubleClickZoom = Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    oldZoom = map.getZoom(),
		    delta = map.options.zoomDelta,
		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

// @section Handlers
//
// Map properties include interaction handlers that allow you to control
// interaction behavior in runtime, enabling or disabling certain features such
// as dragging or touch zoom (see `Handler` methods). For example:
//
// ```js
// map.doubleClickZoom.disable();
// ```
//
// @property doubleClickZoom: Handler
// Double click zoom handler.
Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @option dragging: Boolean = true
	// Whether the map be draggable with mouse/touch or not.
	dragging: true,

	// @section Panning Inertia Options
	// @option inertia: Boolean = *
	// If enabled, panning of the map will have an inertia effect where
	// the map builds momentum while dragging and continues moving in
	// the same direction for some time. Feels especially nice on touch
	// devices. Enabled by default unless running on old Android devices.
	inertia: !android23,

	// @option inertiaDeceleration: Number = 3000
	// The rate with which the inertial movement slows down, in pixels/second.
	inertiaDeceleration: 3400, // px/s^2

	// @option inertiaMaxSpeed: Number = Infinity
	// Max speed of the inertial movement, in pixels/second.
	inertiaMaxSpeed: Infinity, // px/s

	// @option easeLinearity: Number = 0.2
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	// @option worldCopyJump: Boolean = false
	// With this option enabled, the map tracks when you pan to another "copy"
	// of the world and seamlessly jumps to the original one so that all overlays
	// like markers and vector layers are still visible.
	worldCopyJump: false,

	// @option maxBoundsViscosity: Number = 0.0
	// If `maxBounds` is set, this option will control how solid the bounds
	// are when dragging the map around. The default value of `0.0` allows the
	// user to drag outside the bounds at normal speed, higher values will
	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
	// solid, preventing the user from dragging outside the bounds.
	maxBoundsViscosity: 0.0
});

var Drag = Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new Draggable(map._mapPane, map._container);

			this._draggable.on({
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			this._draggable.on('predrag', this._onPreDragLimit, this);
			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDragWrap, this);
				map.on('zoomend', this._onZoomEnd, this);

				map.whenReady(this._onZoomEnd, this);
			}
		}
		addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
		this._draggable.enable();
		this._positions = [];
		this._times = [];
	},

	removeHooks: function () {
		removeClass(this._map._container, 'leaflet-grab');
		removeClass(this._map._container, 'leaflet-touch-drag');
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	moving: function () {
		return this._draggable && this._draggable._moving;
	},

	_onDragStart: function () {
		var map = this._map;

		map._stop();
		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
			var bounds = toLatLngBounds(this._map.options.maxBounds);

			this._offsetLimit = toBounds(
				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
					.add(this._map.getSize()));

			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
		} else {
			this._offsetLimit = null;
		}

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function (e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			this._prunePositions(time);
		}

		this._map
		    .fire('move', e)
		    .fire('drag', e);
	},

	_prunePositions: function (time) {
		while (this._positions.length > 1 && time - this._times[0] > 50) {
			this._positions.shift();
			this._times.shift();
		}
	},

	_onZoomEnd: function () {
		var pxCenter = this._map.getSize().divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_viscousLimit: function (value, threshold) {
		return value - (value - threshold) * this._viscosity;
	},

	_onPreDragLimit: function () {
		if (!this._viscosity || !this._offsetLimit) { return; }

		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

		var limit = this._offsetLimit;
		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

		this._draggable._newPos = this._draggable._startPos.add(offset);
	},

	_onPreDragWrap: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,

		    noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {
			this._prunePositions(+new Date());

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x && !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

// @section Handlers
// @property dragging: Handler
// Map dragging handler (by both mouse and touch).
Map.addInitHook('addHandler', 'dragging', Drag);

/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

// @namespace Map
// @section Keyboard Navigation Options
Map.mergeOptions({
	// @option keyboard: Boolean = true
	// Makes the map focusable and allows users to navigate the map with keyboard
	// arrows and `+`/`-` keys.
	keyboard: true,

	// @option keyboardPanDelta: Number = 80
	// Amount of pixels to pan when pressing an arrow key.
	keyboardPanDelta: 80
});

var Keyboard = Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanDelta(map.options.keyboardPanDelta);
		this._setZoomDelta(map.options.zoomDelta);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex <= 0) {
			container.tabIndex = '0';
		}

		on(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function () {
		this._removeHooks();

		off(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanDelta: function (panDelta) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * panDelta, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [panDelta, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, panDelta];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * panDelta];
		}
	},

	_setZoomDelta: function (zoomDelta) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoomDelta;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoomDelta;
		}
	},

	_addHooks: function () {
		on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

		var key = e.keyCode,
		    map = this._map,
		    offset;

		if (key in this._panKeys) {
			if (!map._panAnim || !map._panAnim._inProgress) {
				offset = this._panKeys[key];
				if (e.shiftKey) {
					offset = toPoint(offset).multiplyBy(3);
				}

				map.panBy(offset);

				if (map.options.maxBounds) {
					map.panInsideBounds(map.options.maxBounds);
				}
			}
		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

		} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
			map.closePopup();

		} else {
			return;
		}

		stop(e);
	}
});

// @section Handlers
// @section Handlers
// @property keyboard: Handler
// Keyboard navigation handler.
Map.addInitHook('addHandler', 'keyboard', Keyboard);

/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @section Mousewheel options
	// @option scrollWheelZoom: Boolean|String = true
	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
	// it will zoom to the center of the view regardless of where the mouse was.
	scrollWheelZoom: true,

	// @option wheelDebounceTime: Number = 40
	// Limits the rate at which a wheel can fire (in milliseconds). By default
	// user can't zoom via wheel more often than once per 40 ms.
	wheelDebounceTime: 40,

	// @option wheelPxPerZoomLevel: Number = 60
	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
	// mean a change of one full zoom level. Smaller values will make wheel-zooming
	// faster (and vice versa).
	wheelPxPerZoomLevel: 60
});

var ScrollWheelZoom = Handler.extend({
	addHooks: function () {
		on(this._map._container, 'mousewheel', this._onWheelScroll, this);

		this._delta = 0;
	},

	removeHooks: function () {
		off(this._map._container, 'mousewheel', this._onWheelScroll, this);
	},

	_onWheelScroll: function (e) {
		var delta = getWheelDelta(e);

		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(bind(this._performZoom, this), left);

		stop(e);
	},

	_performZoom: function () {
		var map = this._map,
		    zoom = map.getZoom(),
		    snap = this._map.options.zoomSnap || 0;

		map._stop(); // stop panning and fly animations if any

		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

// @section Handlers
// @property scrollWheelZoom: Handler
// Scroll wheel zoom handler.
Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @section Touch interaction options
	// @option tap: Boolean = true
	// Enables mobile hacks for supporting instant taps (fixing 200ms click
	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
	tap: true,

	// @option tapTolerance: Number = 15
	// The max number of pixels a user can shift his finger during touch
	// for it to be considered a valid tap.
	tapTolerance: 15
});

var Tap = Handler.extend({
	addHooks: function () {
		on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new Point(first.clientX, first.clientY);
		this._simulateEvent('mousemove', first);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

// @section Handlers
// @property tap: Handler
// Mobile touch hacks (quick tap and touch hold) handler.
if (touch && !pointer) {
	Map.addInitHook('addHandler', 'tap', Tap);
}

/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @section Touch interaction options
	// @option touchZoom: Boolean|String = *
	// Whether the map can be zoomed by touch-dragging with two fingers. If
	// passed `'center'`, it will zoom to the center of the view regardless of
	// where the touch events (fingers) were. Enabled for touch-capable web
	// browsers except for old Androids.
	touchZoom: touch && !android23,

	// @option bounceAtZoomLimits: Boolean = true
	// Set it to false if you don't want the map to zoom beyond min/max zoom
	// and then bounce back when pinch-zooming.
	bounceAtZoomLimits: true
});

var TouchZoom = Handler.extend({
	addHooks: function () {
		addClass(this._map._container, 'leaflet-touch-zoom');
		on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		removeClass(this._map._container, 'leaflet-touch-zoom');
		off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

		this._centerPoint = map.getSize()._divideBy(2);
		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
		if (map.options.touchZoom !== 'center') {
			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
		}

		this._startDist = p1.distanceTo(p2);
		this._startZoom = map.getZoom();

		this._moved = false;
		this._zooming = true;

		map._stop();

		on(document, 'touchmove', this._onTouchMove, this);
		on(document, 'touchend', this._onTouchEnd, this);

		preventDefault(e);
	},

	_onTouchMove: function (e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var map = this._map,
		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
		    scale = p1.distanceTo(p2) / this._startDist;

		this._zoom = map.getScaleZoom(scale, this._startZoom);

		if (!map.options.bounceAtZoomLimits && (
			(this._zoom < map.getMinZoom() && scale < 1) ||
			(this._zoom > map.getMaxZoom() && scale > 1))) {
			this._zoom = map._limitZoom(this._zoom);
		}

		if (map.options.touchZoom === 'center') {
			this._center = this._startLatLng;
			if (scale === 1) { return; }
		} else {
			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
		}

		if (!this._moved) {
			map._moveStart(true, false);
			this._moved = true;
		}

		cancelAnimFrame(this._animRequest);

		var moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
		this._animRequest = requestAnimFrame(moveFn, this, true);

		preventDefault(e);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		cancelAnimFrame(this._animRequest);

		off(document, 'touchmove', this._onTouchMove);
		off(document, 'touchend', this._onTouchEnd);

		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
		if (this._map.options.zoomAnimation) {
			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
		} else {
			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
		}
	}
});

// @section Handlers
// @property touchZoom: Handler
// Touch zoom handler.
Map.addInitHook('addHandler', 'touchZoom', TouchZoom);

Map.BoxZoom = BoxZoom;
Map.DoubleClickZoom = DoubleClickZoom;
Map.Drag = Drag;
Map.Keyboard = Keyboard;
Map.ScrollWheelZoom = ScrollWheelZoom;
Map.Tap = Tap;
Map.TouchZoom = TouchZoom;

Object.freeze = freeze;

exports.version = version;
exports.Control = Control;
exports.control = control;
exports.Browser = Browser;
exports.Evented = Evented;
exports.Mixin = Mixin;
exports.Util = Util;
exports.Class = Class;
exports.Handler = Handler;
exports.extend = extend;
exports.bind = bind;
exports.stamp = stamp;
exports.setOptions = setOptions;
exports.DomEvent = DomEvent;
exports.DomUtil = DomUtil;
exports.PosAnimation = PosAnimation;
exports.Draggable = Draggable;
exports.LineUtil = LineUtil;
exports.PolyUtil = PolyUtil;
exports.Point = Point;
exports.point = toPoint;
exports.Bounds = Bounds;
exports.bounds = toBounds;
exports.Transformation = Transformation;
exports.transformation = toTransformation;
exports.Projection = index;
exports.LatLng = LatLng;
exports.latLng = toLatLng;
exports.LatLngBounds = LatLngBounds;
exports.latLngBounds = toLatLngBounds;
exports.CRS = CRS;
exports.GeoJSON = GeoJSON;
exports.geoJSON = geoJSON;
exports.geoJson = geoJson;
exports.Layer = Layer;
exports.LayerGroup = LayerGroup;
exports.layerGroup = layerGroup;
exports.FeatureGroup = FeatureGroup;
exports.featureGroup = featureGroup;
exports.ImageOverlay = ImageOverlay;
exports.imageOverlay = imageOverlay;
exports.VideoOverlay = VideoOverlay;
exports.videoOverlay = videoOverlay;
exports.SVGOverlay = SVGOverlay;
exports.svgOverlay = svgOverlay;
exports.DivOverlay = DivOverlay;
exports.Popup = Popup;
exports.popup = popup;
exports.Tooltip = Tooltip;
exports.tooltip = tooltip;
exports.Icon = Icon;
exports.icon = icon;
exports.DivIcon = DivIcon;
exports.divIcon = divIcon;
exports.Marker = Marker;
exports.marker = marker;
exports.TileLayer = TileLayer;
exports.tileLayer = tileLayer;
exports.GridLayer = GridLayer;
exports.gridLayer = gridLayer;
exports.SVG = SVG;
exports.svg = svg$1;
exports.Renderer = Renderer;
exports.Canvas = Canvas;
exports.canvas = canvas$1;
exports.Path = Path;
exports.CircleMarker = CircleMarker;
exports.circleMarker = circleMarker;
exports.Circle = Circle;
exports.circle = circle;
exports.Polyline = Polyline;
exports.polyline = polyline;
exports.Polygon = Polygon;
exports.polygon = polygon;
exports.Rectangle = Rectangle;
exports.rectangle = rectangle;
exports.Map = Map;
exports.map = createMap;

var oldL = window.L;
exports.noConflict = function() {
	window.L = oldL;
	return this;
}

// Always export us to window global (see #2364)
window.L = exports;

})));
//# sourceMappingURL=leaflet-src.js.map


/***/ }),

/***/ "./node_modules/leaflet/dist/leaflet.css":
/*!***********************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet.css ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_leaflet_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js!./leaflet.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/leaflet/dist/leaflet.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_leaflet_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_leaflet_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_leaflet_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_leaflet_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/vis-data/peer/umd/vis-data.js":
/*!****************************************************!*\
  !*** ./node_modules/vis-data/peer/umd/vis-data.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/**
 * vis-data
 * http://visjs.org/
 *
 * Manage unstructured data using DataSet. Add, update, and remove data, and listen for changes in the data.
 *
 * @version 7.1.4
 * @date    2022-03-15T15:23:59.245Z
 *
 * @copyright (c) 2011-2017 Almende B.V, http://almende.com
 * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs
 *
 * @license
 * vis.js is dual licensed under both
 *
 *   1. The Apache 2.0 License
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   and
 *
 *   2. The MIT License
 *      http://opensource.org/licenses/MIT
 *
 * vis.js may be distributed under either license.
 */

(function (global, factory) {
   true ? factory(exports) :
  0;
})(this, (function (exports) {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

  var defineProperty$e = {exports: {}};

  var check = function (it) {
    return it && it.Math == Math && it;
  }; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


  var global$M = // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
  function () {
    return this;
  }() || Function('return this')();

  var fails$r = function (exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };

  var fails$q = fails$r;
  var functionBindNative = !fails$q(function () {
    var test = function () {
      /* empty */
    }.bind(); // eslint-disable-next-line no-prototype-builtins -- safe


    return typeof test != 'function' || test.hasOwnProperty('prototype');
  });

  var NATIVE_BIND$4 = functionBindNative;
  var FunctionPrototype$3 = Function.prototype;
  var apply$6 = FunctionPrototype$3.apply;
  var call$c = FunctionPrototype$3.call; // eslint-disable-next-line es/no-reflect -- safe

  var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$4 ? call$c.bind(apply$6) : function () {
    return call$c.apply(apply$6, arguments);
  });

  var NATIVE_BIND$3 = functionBindNative;
  var FunctionPrototype$2 = Function.prototype;
  var bind$d = FunctionPrototype$2.bind;
  var call$b = FunctionPrototype$2.call;
  var uncurryThis$t = NATIVE_BIND$3 && bind$d.bind(call$b, call$b);
  var functionUncurryThis = NATIVE_BIND$3 ? function (fn) {
    return fn && uncurryThis$t(fn);
  } : function (fn) {
    return fn && function () {
      return call$b.apply(fn, arguments);
    };
  };

  // https://tc39.es/ecma262/#sec-iscallable

  var isCallable$h = function (argument) {
    return typeof argument == 'function';
  };

  var objectGetOwnPropertyDescriptor = {};

  var fails$p = fails$r; // Detect IE8's incomplete defineProperty implementation

  var descriptors = !fails$p(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty({}, 1, {
      get: function () {
        return 7;
      }
    })[1] != 7;
  });

  var NATIVE_BIND$2 = functionBindNative;
  var call$a = Function.prototype.call;
  var functionCall = NATIVE_BIND$2 ? call$a.bind(call$a) : function () {
    return call$a.apply(call$a, arguments);
  };

  var objectPropertyIsEnumerable = {};

  var $propertyIsEnumerable$2 = {}.propertyIsEnumerable; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

  var getOwnPropertyDescriptor$5 = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

  var NASHORN_BUG = getOwnPropertyDescriptor$5 && !$propertyIsEnumerable$2.call({
    1: 2
  }, 1); // `Object.prototype.propertyIsEnumerable` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable

  objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor$5(this, V);
    return !!descriptor && descriptor.enumerable;
  } : $propertyIsEnumerable$2;

  var createPropertyDescriptor$5 = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var uncurryThis$s = functionUncurryThis;
  var toString$9 = uncurryThis$s({}.toString);
  var stringSlice$1 = uncurryThis$s(''.slice);

  var classofRaw$1 = function (it) {
    return stringSlice$1(toString$9(it), 8, -1);
  };

  var global$L = global$M;
  var uncurryThis$r = functionUncurryThis;
  var fails$o = fails$r;
  var classof$f = classofRaw$1;
  var Object$9 = global$L.Object;
  var split = uncurryThis$r(''.split); // fallback for non-array-like ES3 and non-enumerable old V8 strings

  var indexedObject = fails$o(function () {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins -- safe
    return !Object$9('z').propertyIsEnumerable(0);
  }) ? function (it) {
    return classof$f(it) == 'String' ? split(it, '') : Object$9(it);
  } : Object$9;

  var global$K = global$M;
  var TypeError$j = global$K.TypeError; // `RequireObjectCoercible` abstract operation
  // https://tc39.es/ecma262/#sec-requireobjectcoercible

  var requireObjectCoercible$5 = function (it) {
    if (it == undefined) throw TypeError$j("Can't call method on " + it);
    return it;
  };

  var IndexedObject$3 = indexedObject;
  var requireObjectCoercible$4 = requireObjectCoercible$5;

  var toIndexedObject$b = function (it) {
    return IndexedObject$3(requireObjectCoercible$4(it));
  };

  var isCallable$g = isCallable$h;

  var isObject$f = function (it) {
    return typeof it == 'object' ? it !== null : isCallable$g(it);
  };

  var path$q = {};

  var path$p = path$q;
  var global$J = global$M;
  var isCallable$f = isCallable$h;

  var aFunction = function (variable) {
    return isCallable$f(variable) ? variable : undefined;
  };

  var getBuiltIn$9 = function (namespace, method) {
    return arguments.length < 2 ? aFunction(path$p[namespace]) || aFunction(global$J[namespace]) : path$p[namespace] && path$p[namespace][method] || global$J[namespace] && global$J[namespace][method];
  };

  var uncurryThis$q = functionUncurryThis;
  var objectIsPrototypeOf = uncurryThis$q({}.isPrototypeOf);

  var getBuiltIn$8 = getBuiltIn$9;
  var engineUserAgent = getBuiltIn$8('navigator', 'userAgent') || '';

  var global$I = global$M;
  var userAgent$3 = engineUserAgent;
  var process = global$I.process;
  var Deno = global$I.Deno;
  var versions = process && process.versions || Deno && Deno.version;
  var v8 = versions && versions.v8;
  var match, version;

  if (v8) {
    match = v8.split('.'); // in old Chrome, versions of V8 isn't V8 = Chrome / 10
    // but their correct versions are not interesting for us

    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  } // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
  // so check `userAgent` even if `.v8` exists, but 0


  if (!version && userAgent$3) {
    match = userAgent$3.match(/Edge\/(\d+)/);

    if (!match || match[1] >= 74) {
      match = userAgent$3.match(/Chrome\/(\d+)/);
      if (match) version = +match[1];
    }
  }

  var engineV8Version = version;

  /* eslint-disable es/no-symbol -- required for testing */
  var V8_VERSION$2 = engineV8Version;
  var fails$n = fails$r; // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing

  var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$n(function () {
    var symbol = Symbol(); // Chrome 38 Symbol has incorrect toString conversion
    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances

    return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION$2 && V8_VERSION$2 < 41;
  });

  /* eslint-disable es/no-symbol -- required for testing */
  var NATIVE_SYMBOL$2 = nativeSymbol;
  var useSymbolAsUid = NATIVE_SYMBOL$2 && !Symbol.sham && typeof Symbol.iterator == 'symbol';

  var global$H = global$M;
  var getBuiltIn$7 = getBuiltIn$9;
  var isCallable$e = isCallable$h;
  var isPrototypeOf$i = objectIsPrototypeOf;
  var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
  var Object$8 = global$H.Object;
  var isSymbol$3 = USE_SYMBOL_AS_UID$1 ? function (it) {
    return typeof it == 'symbol';
  } : function (it) {
    var $Symbol = getBuiltIn$7('Symbol');
    return isCallable$e($Symbol) && isPrototypeOf$i($Symbol.prototype, Object$8(it));
  };

  var global$G = global$M;
  var String$4 = global$G.String;

  var tryToString$4 = function (argument) {
    try {
      return String$4(argument);
    } catch (error) {
      return 'Object';
    }
  };

  var global$F = global$M;
  var isCallable$d = isCallable$h;
  var tryToString$3 = tryToString$4;
  var TypeError$i = global$F.TypeError; // `Assert: IsCallable(argument) is true`

  var aCallable$7 = function (argument) {
    if (isCallable$d(argument)) return argument;
    throw TypeError$i(tryToString$3(argument) + ' is not a function');
  };

  var aCallable$6 = aCallable$7; // `GetMethod` abstract operation
  // https://tc39.es/ecma262/#sec-getmethod

  var getMethod$3 = function (V, P) {
    var func = V[P];
    return func == null ? undefined : aCallable$6(func);
  };

  var global$E = global$M;
  var call$9 = functionCall;
  var isCallable$c = isCallable$h;
  var isObject$e = isObject$f;
  var TypeError$h = global$E.TypeError; // `OrdinaryToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-ordinarytoprimitive

  var ordinaryToPrimitive$1 = function (input, pref) {
    var fn, val;
    if (pref === 'string' && isCallable$c(fn = input.toString) && !isObject$e(val = call$9(fn, input))) return val;
    if (isCallable$c(fn = input.valueOf) && !isObject$e(val = call$9(fn, input))) return val;
    if (pref !== 'string' && isCallable$c(fn = input.toString) && !isObject$e(val = call$9(fn, input))) return val;
    throw TypeError$h("Can't convert object to primitive value");
  };

  var shared$4 = {exports: {}};

  var global$D = global$M; // eslint-disable-next-line es/no-object-defineproperty -- safe

  var defineProperty$d = Object.defineProperty;

  var setGlobal$1 = function (key, value) {
    try {
      defineProperty$d(global$D, key, {
        value: value,
        configurable: true,
        writable: true
      });
    } catch (error) {
      global$D[key] = value;
    }

    return value;
  };

  var global$C = global$M;
  var setGlobal = setGlobal$1;
  var SHARED = '__core-js_shared__';
  var store$3 = global$C[SHARED] || setGlobal(SHARED, {});
  var sharedStore = store$3;

  var store$2 = sharedStore;
  (shared$4.exports = function (key, value) {
    return store$2[key] || (store$2[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: '3.21.1',
    mode: 'pure' ,
    copyright: ' 2014-2022 Denis Pushkarev (zloirock.ru)',
    license: 'https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE',
    source: 'https://github.com/zloirock/core-js'
  });

  var global$B = global$M;
  var requireObjectCoercible$3 = requireObjectCoercible$5;
  var Object$7 = global$B.Object; // `ToObject` abstract operation
  // https://tc39.es/ecma262/#sec-toobject

  var toObject$e = function (argument) {
    return Object$7(requireObjectCoercible$3(argument));
  };

  var uncurryThis$p = functionUncurryThis;
  var toObject$d = toObject$e;
  var hasOwnProperty = uncurryThis$p({}.hasOwnProperty); // `HasOwnProperty` abstract operation
  // https://tc39.es/ecma262/#sec-hasownproperty

  var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
    return hasOwnProperty(toObject$d(it), key);
  };

  var uncurryThis$o = functionUncurryThis;
  var id$1 = 0;
  var postfix = Math.random();
  var toString$8 = uncurryThis$o(1.0.toString);

  var uid$4 = function (key) {
    return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$8(++id$1 + postfix, 36);
  };

  var global$A = global$M;
  var shared$3 = shared$4.exports;
  var hasOwn$f = hasOwnProperty_1;
  var uid$3 = uid$4;
  var NATIVE_SYMBOL$1 = nativeSymbol;
  var USE_SYMBOL_AS_UID = useSymbolAsUid;
  var WellKnownSymbolsStore$1 = shared$3('wks');
  var Symbol$2 = global$A.Symbol;
  var symbolFor = Symbol$2 && Symbol$2['for'];
  var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$2 : Symbol$2 && Symbol$2.withoutSetter || uid$3;

  var wellKnownSymbol$j = function (name) {
    if (!hasOwn$f(WellKnownSymbolsStore$1, name) || !(NATIVE_SYMBOL$1 || typeof WellKnownSymbolsStore$1[name] == 'string')) {
      var description = 'Symbol.' + name;

      if (NATIVE_SYMBOL$1 && hasOwn$f(Symbol$2, name)) {
        WellKnownSymbolsStore$1[name] = Symbol$2[name];
      } else if (USE_SYMBOL_AS_UID && symbolFor) {
        WellKnownSymbolsStore$1[name] = symbolFor(description);
      } else {
        WellKnownSymbolsStore$1[name] = createWellKnownSymbol(description);
      }
    }

    return WellKnownSymbolsStore$1[name];
  };

  var global$z = global$M;
  var call$8 = functionCall;
  var isObject$d = isObject$f;
  var isSymbol$2 = isSymbol$3;
  var getMethod$2 = getMethod$3;
  var ordinaryToPrimitive = ordinaryToPrimitive$1;
  var wellKnownSymbol$i = wellKnownSymbol$j;
  var TypeError$g = global$z.TypeError;
  var TO_PRIMITIVE$1 = wellKnownSymbol$i('toPrimitive'); // `ToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-toprimitive

  var toPrimitive$1 = function (input, pref) {
    if (!isObject$d(input) || isSymbol$2(input)) return input;
    var exoticToPrim = getMethod$2(input, TO_PRIMITIVE$1);
    var result;

    if (exoticToPrim) {
      if (pref === undefined) pref = 'default';
      result = call$8(exoticToPrim, input, pref);
      if (!isObject$d(result) || isSymbol$2(result)) return result;
      throw TypeError$g("Can't convert object to primitive value");
    }

    if (pref === undefined) pref = 'number';
    return ordinaryToPrimitive(input, pref);
  };

  var toPrimitive = toPrimitive$1;
  var isSymbol$1 = isSymbol$3; // `ToPropertyKey` abstract operation
  // https://tc39.es/ecma262/#sec-topropertykey

  var toPropertyKey$4 = function (argument) {
    var key = toPrimitive(argument, 'string');
    return isSymbol$1(key) ? key : key + '';
  };

  var global$y = global$M;
  var isObject$c = isObject$f;
  var document$1 = global$y.document; // typeof document.createElement is 'object' in old IE

  var EXISTS$1 = isObject$c(document$1) && isObject$c(document$1.createElement);

  var documentCreateElement$1 = function (it) {
    return EXISTS$1 ? document$1.createElement(it) : {};
  };

  var DESCRIPTORS$h = descriptors;
  var fails$m = fails$r;
  var createElement = documentCreateElement$1; // Thanks to IE8 for its funny defineProperty

  var ie8DomDefine = !DESCRIPTORS$h && !fails$m(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(createElement('div'), 'a', {
      get: function () {
        return 7;
      }
    }).a != 7;
  });

  var DESCRIPTORS$g = descriptors;
  var call$7 = functionCall;
  var propertyIsEnumerableModule$2 = objectPropertyIsEnumerable;
  var createPropertyDescriptor$4 = createPropertyDescriptor$5;
  var toIndexedObject$a = toIndexedObject$b;
  var toPropertyKey$3 = toPropertyKey$4;
  var hasOwn$e = hasOwnProperty_1;
  var IE8_DOM_DEFINE$1 = ie8DomDefine; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

  var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

  objectGetOwnPropertyDescriptor.f = DESCRIPTORS$g ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject$a(O);
    P = toPropertyKey$3(P);
    if (IE8_DOM_DEFINE$1) try {
      return $getOwnPropertyDescriptor$2(O, P);
    } catch (error) {
      /* empty */
    }
    if (hasOwn$e(O, P)) return createPropertyDescriptor$4(!call$7(propertyIsEnumerableModule$2.f, O, P), O[P]);
  };

  var fails$l = fails$r;
  var isCallable$b = isCallable$h;
  var replacement = /#|\.prototype\./;

  var isForced$1 = function (feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true : value == NATIVE ? false : isCallable$b(detection) ? fails$l(detection) : !!detection;
  };

  var normalize = isForced$1.normalize = function (string) {
    return String(string).replace(replacement, '.').toLowerCase();
  };

  var data = isForced$1.data = {};
  var NATIVE = isForced$1.NATIVE = 'N';
  var POLYFILL = isForced$1.POLYFILL = 'P';
  var isForced_1 = isForced$1;

  var uncurryThis$n = functionUncurryThis;
  var aCallable$5 = aCallable$7;
  var NATIVE_BIND$1 = functionBindNative;
  var bind$c = uncurryThis$n(uncurryThis$n.bind); // optional / simple context binding

  var functionBindContext = function (fn, that) {
    aCallable$5(fn);
    return that === undefined ? fn : NATIVE_BIND$1 ? bind$c(fn, that) : function
      /* ...args */
    () {
      return fn.apply(that, arguments);
    };
  };

  var objectDefineProperty = {};

  var DESCRIPTORS$f = descriptors;
  var fails$k = fails$r; // V8 ~ Chrome 36-
  // https://bugs.chromium.org/p/v8/issues/detail?id=3334

  var v8PrototypeDefineBug = DESCRIPTORS$f && fails$k(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(function () {
      /* empty */
    }, 'prototype', {
      value: 42,
      writable: false
    }).prototype != 42;
  });

  var global$x = global$M;
  var isObject$b = isObject$f;
  var String$3 = global$x.String;
  var TypeError$f = global$x.TypeError; // `Assert: Type(argument) is Object`

  var anObject$b = function (argument) {
    if (isObject$b(argument)) return argument;
    throw TypeError$f(String$3(argument) + ' is not an object');
  };

  var global$w = global$M;
  var DESCRIPTORS$e = descriptors;
  var IE8_DOM_DEFINE = ie8DomDefine;
  var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
  var anObject$a = anObject$b;
  var toPropertyKey$2 = toPropertyKey$4;
  var TypeError$e = global$w.TypeError; // eslint-disable-next-line es/no-object-defineproperty -- safe

  var $defineProperty$1 = Object.defineProperty; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

  var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
  var ENUMERABLE = 'enumerable';
  var CONFIGURABLE$1 = 'configurable';
  var WRITABLE = 'writable'; // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty

  objectDefineProperty.f = DESCRIPTORS$e ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
    anObject$a(O);
    P = toPropertyKey$2(P);
    anObject$a(Attributes);

    if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
      var current = $getOwnPropertyDescriptor$1(O, P);

      if (current && current[WRITABLE]) {
        O[P] = Attributes.value;
        Attributes = {
          configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
          enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
          writable: false
        };
      }
    }

    return $defineProperty$1(O, P, Attributes);
  } : $defineProperty$1 : function defineProperty(O, P, Attributes) {
    anObject$a(O);
    P = toPropertyKey$2(P);
    anObject$a(Attributes);
    if (IE8_DOM_DEFINE) try {
      return $defineProperty$1(O, P, Attributes);
    } catch (error) {
      /* empty */
    }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError$e('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };

  var DESCRIPTORS$d = descriptors;
  var definePropertyModule$4 = objectDefineProperty;
  var createPropertyDescriptor$3 = createPropertyDescriptor$5;
  var createNonEnumerableProperty$6 = DESCRIPTORS$d ? function (object, key, value) {
    return definePropertyModule$4.f(object, key, createPropertyDescriptor$3(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var global$v = global$M;
  var apply$5 = functionApply;
  var uncurryThis$m = functionUncurryThis;
  var isCallable$a = isCallable$h;
  var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f;
  var isForced = isForced_1;
  var path$o = path$q;
  var bind$b = functionBindContext;
  var createNonEnumerableProperty$5 = createNonEnumerableProperty$6;
  var hasOwn$d = hasOwnProperty_1;

  var wrapConstructor = function (NativeConstructor) {
    var Wrapper = function (a, b, c) {
      if (this instanceof Wrapper) {
        switch (arguments.length) {
          case 0:
            return new NativeConstructor();

          case 1:
            return new NativeConstructor(a);

          case 2:
            return new NativeConstructor(a, b);
        }

        return new NativeConstructor(a, b, c);
      }

      return apply$5(NativeConstructor, this, arguments);
    };

    Wrapper.prototype = NativeConstructor.prototype;
    return Wrapper;
  };
  /*
    options.target      - name of the target object
    options.global      - target is the global object
    options.stat        - export as static methods of target
    options.proto       - export as prototype methods of target
    options.real        - real prototype method for the `pure` version
    options.forced      - export even if the native feature is available
    options.bind        - bind methods to the target, required for the `pure` version
    options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
    options.unsafe      - use the simple assignment of property instead of delete + defineProperty
    options.sham        - add a flag to not completely full polyfills
    options.enumerable  - export as enumerable property
    options.noTargetGet - prevent calling a getter on target
    options.name        - the .name of the function if it does not match the key
  */


  var _export = function (options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var PROTO = options.proto;
    var nativeSource = GLOBAL ? global$v : STATIC ? global$v[TARGET] : (global$v[TARGET] || {}).prototype;
    var target = GLOBAL ? path$o : path$o[TARGET] || createNonEnumerableProperty$5(path$o, TARGET, {})[TARGET];
    var targetPrototype = target.prototype;
    var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
    var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

    for (key in source) {
      FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contains in native

      USE_NATIVE = !FORCED && nativeSource && hasOwn$d(nativeSource, key);
      targetProperty = target[key];
      if (USE_NATIVE) if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$4(nativeSource, key);
        nativeProperty = descriptor && descriptor.value;
      } else nativeProperty = nativeSource[key]; // export native or implementation

      sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
      if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue; // bind timers to global for call from export context

      if (options.bind && USE_NATIVE) resultProperty = bind$b(sourceProperty, global$v); // wrap global constructors for prevent changs in this version
      else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty); // make static versions for prototype methods
      else if (PROTO && isCallable$a(sourceProperty)) resultProperty = uncurryThis$m(sourceProperty); // default case
      else resultProperty = sourceProperty; // add a flag to not completely full polyfills

      if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty$5(resultProperty, 'sham', true);
      }

      createNonEnumerableProperty$5(target, key, resultProperty);

      if (PROTO) {
        VIRTUAL_PROTOTYPE = TARGET + 'Prototype';

        if (!hasOwn$d(path$o, VIRTUAL_PROTOTYPE)) {
          createNonEnumerableProperty$5(path$o, VIRTUAL_PROTOTYPE, {});
        } // export virtual prototype methods


        createNonEnumerableProperty$5(path$o[VIRTUAL_PROTOTYPE], key, sourceProperty); // export real prototype methods

        if (options.real && targetPrototype && !targetPrototype[key]) {
          createNonEnumerableProperty$5(targetPrototype, key, sourceProperty);
        }
      }
    }
  };

  var $$C = _export;
  var DESCRIPTORS$c = descriptors;
  var defineProperty$c = objectDefineProperty.f; // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  // eslint-disable-next-line es/no-object-defineproperty -- safe

  $$C({
    target: 'Object',
    stat: true,
    forced: Object.defineProperty !== defineProperty$c,
    sham: !DESCRIPTORS$c
  }, {
    defineProperty: defineProperty$c
  });

  var path$n = path$q;
  var Object$6 = path$n.Object;

  var defineProperty$b = defineProperty$e.exports = function defineProperty(it, key, desc) {
    return Object$6.defineProperty(it, key, desc);
  };

  if (Object$6.defineProperty.sham) defineProperty$b.sham = true;

  var parent$V = defineProperty$e.exports;
  var defineProperty$a = parent$V;

  var parent$U = defineProperty$a;
  var defineProperty$9 = parent$U;

  var parent$T = defineProperty$9;
  var defineProperty$8 = parent$T;

  var defineProperty$7 = defineProperty$8;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;

      defineProperty$7(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    defineProperty$7(Constructor, "prototype", {
      writable: false
    });

    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      defineProperty$7(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var uncurryThis$l = functionUncurryThis;
  var arraySlice$5 = uncurryThis$l([].slice);

  var global$u = global$M;
  var uncurryThis$k = functionUncurryThis;
  var aCallable$4 = aCallable$7;
  var isObject$a = isObject$f;
  var hasOwn$c = hasOwnProperty_1;
  var arraySlice$4 = arraySlice$5;
  var NATIVE_BIND = functionBindNative;
  var Function$2 = global$u.Function;
  var concat$6 = uncurryThis$k([].concat);
  var join = uncurryThis$k([].join);
  var factories = {};

  var construct$4 = function (C, argsLength, args) {
    if (!hasOwn$c(factories, argsLength)) {
      for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';

      factories[argsLength] = Function$2('C,a', 'return new C(' + join(list, ',') + ')');
    }

    return factories[argsLength](C, args);
  }; // `Function.prototype.bind` method implementation
  // https://tc39.es/ecma262/#sec-function.prototype.bind


  var functionBind = NATIVE_BIND ? Function$2.bind : function bind(that
  /* , ...args */
  ) {
    var F = aCallable$4(this);
    var Prototype = F.prototype;
    var partArgs = arraySlice$4(arguments, 1);

    var boundFunction = function
      /* args... */
    bound() {
      var args = concat$6(partArgs, arraySlice$4(arguments));
      return this instanceof boundFunction ? construct$4(F, args.length, args) : F.apply(that, args);
    };

    if (isObject$a(Prototype)) boundFunction.prototype = Prototype;
    return boundFunction;
  };

  var $$B = _export;
  var bind$a = functionBind; // `Function.prototype.bind` method
  // https://tc39.es/ecma262/#sec-function.prototype.bind

  $$B({
    target: 'Function',
    proto: true,
    forced: Function.bind !== bind$a
  }, {
    bind: bind$a
  });

  var path$m = path$q;

  var entryVirtual$k = function (CONSTRUCTOR) {
    return path$m[CONSTRUCTOR + 'Prototype'];
  };

  var entryVirtual$j = entryVirtual$k;
  var bind$9 = entryVirtual$j('Function').bind;

  var isPrototypeOf$h = objectIsPrototypeOf;
  var method$e = bind$9;
  var FunctionPrototype$1 = Function.prototype;

  var bind$8 = function (it) {
    var own = it.bind;
    return it === FunctionPrototype$1 || isPrototypeOf$h(FunctionPrototype$1, it) && own === FunctionPrototype$1.bind ? method$e : own;
  };

  var parent$S = bind$8;
  var bind$7 = parent$S;

  var bind$6 = bind$7;

  var ceil = Math.ceil;
  var floor$1 = Math.floor; // `ToIntegerOrInfinity` abstract operation
  // https://tc39.es/ecma262/#sec-tointegerorinfinity

  var toIntegerOrInfinity$4 = function (argument) {
    var number = +argument; // eslint-disable-next-line no-self-compare -- safe

    return number !== number || number === 0 ? 0 : (number > 0 ? floor$1 : ceil)(number);
  };

  var toIntegerOrInfinity$3 = toIntegerOrInfinity$4;
  var min$2 = Math.min; // `ToLength` abstract operation
  // https://tc39.es/ecma262/#sec-tolength

  var toLength$1 = function (argument) {
    return argument > 0 ? min$2(toIntegerOrInfinity$3(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
  };

  var toLength = toLength$1; // `LengthOfArrayLike` abstract operation
  // https://tc39.es/ecma262/#sec-lengthofarraylike

  var lengthOfArrayLike$d = function (obj) {
    return toLength(obj.length);
  };

  var global$t = global$M;
  var aCallable$3 = aCallable$7;
  var toObject$c = toObject$e;
  var IndexedObject$2 = indexedObject;
  var lengthOfArrayLike$c = lengthOfArrayLike$d;
  var TypeError$d = global$t.TypeError; // `Array.prototype.{ reduce, reduceRight }` methods implementation

  var createMethod$5 = function (IS_RIGHT) {
    return function (that, callbackfn, argumentsLength, memo) {
      aCallable$3(callbackfn);
      var O = toObject$c(that);
      var self = IndexedObject$2(O);
      var length = lengthOfArrayLike$c(O);
      var index = IS_RIGHT ? length - 1 : 0;
      var i = IS_RIGHT ? -1 : 1;
      if (argumentsLength < 2) while (true) {
        if (index in self) {
          memo = self[index];
          index += i;
          break;
        }

        index += i;

        if (IS_RIGHT ? index < 0 : length <= index) {
          throw TypeError$d('Reduce of empty array with no initial value');
        }
      }

      for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
        memo = callbackfn(memo, self[index], index, O);
      }

      return memo;
    };
  };

  var arrayReduce = {
    // `Array.prototype.reduce` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduce
    left: createMethod$5(false),
    // `Array.prototype.reduceRight` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduceright
    right: createMethod$5(true)
  };

  var fails$j = fails$r;

  var arrayMethodIsStrict$5 = function (METHOD_NAME, argument) {
    var method = [][METHOD_NAME];
    return !!method && fails$j(function () {
      // eslint-disable-next-line no-useless-call -- required for testing
      method.call(null, argument || function () {
        return 1;
      }, 1);
    });
  };

  var classof$e = classofRaw$1;
  var global$s = global$M;
  var engineIsNode = classof$e(global$s.process) == 'process';

  var $$A = _export;
  var $reduce = arrayReduce.left;
  var arrayMethodIsStrict$4 = arrayMethodIsStrict$5;
  var CHROME_VERSION = engineV8Version;
  var IS_NODE = engineIsNode;
  var STRICT_METHOD$4 = arrayMethodIsStrict$4('reduce'); // Chrome 80-82 has a critical bug
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982

  var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83; // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce

  $$A({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD$4 || CHROME_BUG
  }, {
    reduce: function reduce(callbackfn
    /* , initialValue */
    ) {
      var length = arguments.length;
      return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
    }
  });

  var entryVirtual$i = entryVirtual$k;
  var reduce$3 = entryVirtual$i('Array').reduce;

  var isPrototypeOf$g = objectIsPrototypeOf;
  var method$d = reduce$3;
  var ArrayPrototype$e = Array.prototype;

  var reduce$2 = function (it) {
    var own = it.reduce;
    return it === ArrayPrototype$e || isPrototypeOf$g(ArrayPrototype$e, it) && own === ArrayPrototype$e.reduce ? method$d : own;
  };

  var parent$R = reduce$2;
  var reduce$1 = parent$R;

  var reduce = reduce$1;

  var classof$d = classofRaw$1; // `IsArray` abstract operation
  // https://tc39.es/ecma262/#sec-isarray
  // eslint-disable-next-line es/no-array-isarray -- safe

  var isArray$d = Array.isArray || function isArray(argument) {
    return classof$d(argument) == 'Array';
  };

  var wellKnownSymbol$h = wellKnownSymbol$j;
  var TO_STRING_TAG$3 = wellKnownSymbol$h('toStringTag');
  var test$2 = {};
  test$2[TO_STRING_TAG$3] = 'z';
  var toStringTagSupport = String(test$2) === '[object z]';

  var global$r = global$M;
  var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
  var isCallable$9 = isCallable$h;
  var classofRaw = classofRaw$1;
  var wellKnownSymbol$g = wellKnownSymbol$j;
  var TO_STRING_TAG$2 = wellKnownSymbol$g('toStringTag');
  var Object$5 = global$r.Object; // ES3 wrong here

  var CORRECT_ARGUMENTS = classofRaw(function () {
    return arguments;
  }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (error) {
      /* empty */
    }
  }; // getting tag from ES6+ `Object.prototype.toString`


  var classof$c = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function (it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
    : typeof (tag = tryGet(O = Object$5(it), TO_STRING_TAG$2)) == 'string' ? tag // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable$9(O.callee) ? 'Arguments' : result;
  };

  var uncurryThis$j = functionUncurryThis;
  var isCallable$8 = isCallable$h;
  var store$1 = sharedStore;
  var functionToString = uncurryThis$j(Function.toString); // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper

  if (!isCallable$8(store$1.inspectSource)) {
    store$1.inspectSource = function (it) {
      return functionToString(it);
    };
  }

  var inspectSource$2 = store$1.inspectSource;

  var uncurryThis$i = functionUncurryThis;
  var fails$i = fails$r;
  var isCallable$7 = isCallable$h;
  var classof$b = classof$c;
  var getBuiltIn$6 = getBuiltIn$9;
  var inspectSource$1 = inspectSource$2;

  var noop = function () {
    /* empty */
  };

  var empty = [];
  var construct$3 = getBuiltIn$6('Reflect', 'construct');
  var constructorRegExp = /^\s*(?:class|function)\b/;
  var exec$2 = uncurryThis$i(constructorRegExp.exec);
  var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

  var isConstructorModern = function isConstructor(argument) {
    if (!isCallable$7(argument)) return false;

    try {
      construct$3(noop, empty, argument);
      return true;
    } catch (error) {
      return false;
    }
  };

  var isConstructorLegacy = function isConstructor(argument) {
    if (!isCallable$7(argument)) return false;

    switch (classof$b(argument)) {
      case 'AsyncFunction':
      case 'GeneratorFunction':
      case 'AsyncGeneratorFunction':
        return false;
    }

    try {
      // we can't check .prototype since constructors produced by .bind haven't it
      // `Function#toString` throws on some built-it function in some legacy engines
      // (for example, `DOMQuad` and similar in FF41-)
      return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$1(argument));
    } catch (error) {
      return true;
    }
  };

  isConstructorLegacy.sham = true; // `IsConstructor` abstract operation
  // https://tc39.es/ecma262/#sec-isconstructor

  var isConstructor$4 = !construct$3 || fails$i(function () {
    var called;
    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {
      called = true;
    }) || called;
  }) ? isConstructorLegacy : isConstructorModern;

  var global$q = global$M;
  var isArray$c = isArray$d;
  var isConstructor$3 = isConstructor$4;
  var isObject$9 = isObject$f;
  var wellKnownSymbol$f = wellKnownSymbol$j;
  var SPECIES$3 = wellKnownSymbol$f('species');
  var Array$5 = global$q.Array; // a part of `ArraySpeciesCreate` abstract operation
  // https://tc39.es/ecma262/#sec-arrayspeciescreate

  var arraySpeciesConstructor$1 = function (originalArray) {
    var C;

    if (isArray$c(originalArray)) {
      C = originalArray.constructor; // cross-realm fallback

      if (isConstructor$3(C) && (C === Array$5 || isArray$c(C.prototype))) C = undefined;else if (isObject$9(C)) {
        C = C[SPECIES$3];
        if (C === null) C = undefined;
      }
    }

    return C === undefined ? Array$5 : C;
  };

  var arraySpeciesConstructor = arraySpeciesConstructor$1; // `ArraySpeciesCreate` abstract operation
  // https://tc39.es/ecma262/#sec-arrayspeciescreate

  var arraySpeciesCreate$4 = function (originalArray, length) {
    return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
  };

  var bind$5 = functionBindContext;
  var uncurryThis$h = functionUncurryThis;
  var IndexedObject$1 = indexedObject;
  var toObject$b = toObject$e;
  var lengthOfArrayLike$b = lengthOfArrayLike$d;
  var arraySpeciesCreate$3 = arraySpeciesCreate$4;
  var push$5 = uncurryThis$h([].push); // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation

  var createMethod$4 = function (TYPE) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var IS_FILTER_REJECT = TYPE == 7;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function ($this, callbackfn, that, specificCreate) {
      var O = toObject$b($this);
      var self = IndexedObject$1(O);
      var boundFunction = bind$5(callbackfn, that);
      var length = lengthOfArrayLike$b(self);
      var index = 0;
      var create = specificCreate || arraySpeciesCreate$3;
      var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
      var value, result;

      for (; length > index; index++) if (NO_HOLES || index in self) {
        value = self[index];
        result = boundFunction(value, index, O);

        if (TYPE) {
          if (IS_MAP) target[index] = result; // map
          else if (result) switch (TYPE) {
            case 3:
              return true;
            // some

            case 5:
              return value;
            // find

            case 6:
              return index;
            // findIndex

            case 2:
              push$5(target, value);
            // filter
          } else switch (TYPE) {
            case 4:
              return false;
            // every

            case 7:
              push$5(target, value);
            // filterReject
          }
        }
      }

      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
  };

  var arrayIteration = {
    // `Array.prototype.forEach` method
    // https://tc39.es/ecma262/#sec-array.prototype.foreach
    forEach: createMethod$4(0),
    // `Array.prototype.map` method
    // https://tc39.es/ecma262/#sec-array.prototype.map
    map: createMethod$4(1),
    // `Array.prototype.filter` method
    // https://tc39.es/ecma262/#sec-array.prototype.filter
    filter: createMethod$4(2),
    // `Array.prototype.some` method
    // https://tc39.es/ecma262/#sec-array.prototype.some
    some: createMethod$4(3),
    // `Array.prototype.every` method
    // https://tc39.es/ecma262/#sec-array.prototype.every
    every: createMethod$4(4),
    // `Array.prototype.find` method
    // https://tc39.es/ecma262/#sec-array.prototype.find
    find: createMethod$4(5),
    // `Array.prototype.findIndex` method
    // https://tc39.es/ecma262/#sec-array.prototype.findIndex
    findIndex: createMethod$4(6),
    // `Array.prototype.filterReject` method
    // https://github.com/tc39/proposal-array-filtering
    filterReject: createMethod$4(7)
  };

  var fails$h = fails$r;
  var wellKnownSymbol$e = wellKnownSymbol$j;
  var V8_VERSION$1 = engineV8Version;
  var SPECIES$2 = wellKnownSymbol$e('species');

  var arrayMethodHasSpeciesSupport$5 = function (METHOD_NAME) {
    // We can't use this feature detection in V8 since it causes
    // deoptimization and serious performance degradation
    // https://github.com/zloirock/core-js/issues/677
    return V8_VERSION$1 >= 51 || !fails$h(function () {
      var array = [];
      var constructor = array.constructor = {};

      constructor[SPECIES$2] = function () {
        return {
          foo: 1
        };
      };

      return array[METHOD_NAME](Boolean).foo !== 1;
    });
  };

  var $$z = _export;
  var $filter = arrayIteration.filter;
  var arrayMethodHasSpeciesSupport$4 = arrayMethodHasSpeciesSupport$5;
  var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport$4('filter'); // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  // with adding support of @@species

  $$z({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT$3
  }, {
    filter: function filter(callbackfn
    /* , thisArg */
    ) {
      return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var entryVirtual$h = entryVirtual$k;
  var filter$3 = entryVirtual$h('Array').filter;

  var isPrototypeOf$f = objectIsPrototypeOf;
  var method$c = filter$3;
  var ArrayPrototype$d = Array.prototype;

  var filter$2 = function (it) {
    var own = it.filter;
    return it === ArrayPrototype$d || isPrototypeOf$f(ArrayPrototype$d, it) && own === ArrayPrototype$d.filter ? method$c : own;
  };

  var parent$Q = filter$2;
  var filter$1 = parent$Q;

  var filter = filter$1;

  var $$y = _export;
  var $map = arrayIteration.map;
  var arrayMethodHasSpeciesSupport$3 = arrayMethodHasSpeciesSupport$5;
  var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$3('map'); // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  // with adding support of @@species

  $$y({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT$2
  }, {
    map: function map(callbackfn
    /* , thisArg */
    ) {
      return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var entryVirtual$g = entryVirtual$k;
  var map$6 = entryVirtual$g('Array').map;

  var isPrototypeOf$e = objectIsPrototypeOf;
  var method$b = map$6;
  var ArrayPrototype$c = Array.prototype;

  var map$5 = function (it) {
    var own = it.map;
    return it === ArrayPrototype$c || isPrototypeOf$e(ArrayPrototype$c, it) && own === ArrayPrototype$c.map ? method$b : own;
  };

  var parent$P = map$5;
  var map$4 = parent$P;

  var map$3 = map$4;

  var global$p = global$M;
  var isArray$b = isArray$d;
  var lengthOfArrayLike$a = lengthOfArrayLike$d;
  var bind$4 = functionBindContext;
  var TypeError$c = global$p.TypeError; // `FlattenIntoArray` abstract operation
  // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

  var flattenIntoArray$1 = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
    var targetIndex = start;
    var sourceIndex = 0;
    var mapFn = mapper ? bind$4(mapper, thisArg) : false;
    var element, elementLen;

    while (sourceIndex < sourceLen) {
      if (sourceIndex in source) {
        element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

        if (depth > 0 && isArray$b(element)) {
          elementLen = lengthOfArrayLike$a(element);
          targetIndex = flattenIntoArray$1(target, original, element, elementLen, targetIndex, depth - 1) - 1;
        } else {
          if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError$c('Exceed the acceptable array length');
          target[targetIndex] = element;
        }

        targetIndex++;
      }

      sourceIndex++;
    }

    return targetIndex;
  };

  var flattenIntoArray_1 = flattenIntoArray$1;

  var $$x = _export;
  var flattenIntoArray = flattenIntoArray_1;
  var aCallable$2 = aCallable$7;
  var toObject$a = toObject$e;
  var lengthOfArrayLike$9 = lengthOfArrayLike$d;
  var arraySpeciesCreate$2 = arraySpeciesCreate$4; // `Array.prototype.flatMap` method
  // https://tc39.es/ecma262/#sec-array.prototype.flatmap

  $$x({
    target: 'Array',
    proto: true
  }, {
    flatMap: function flatMap(callbackfn
    /* , thisArg */
    ) {
      var O = toObject$a(this);
      var sourceLen = lengthOfArrayLike$9(O);
      var A;
      aCallable$2(callbackfn);
      A = arraySpeciesCreate$2(O, 0);
      A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      return A;
    }
  });

  var entryVirtual$f = entryVirtual$k;
  var flatMap$3 = entryVirtual$f('Array').flatMap;

  var isPrototypeOf$d = objectIsPrototypeOf;
  var method$a = flatMap$3;
  var ArrayPrototype$b = Array.prototype;

  var flatMap$2 = function (it) {
    var own = it.flatMap;
    return it === ArrayPrototype$b || isPrototypeOf$d(ArrayPrototype$b, it) && own === ArrayPrototype$b.flatMap ? method$a : own;
  };

  var parent$O = flatMap$2;
  var flatMap$1 = parent$O;

  var flatMap = flatMap$1;

  /**
   * Create new data pipe.
   *
   * @param from - The source data set or data view.
   * @remarks
   * Example usage:
   * ```typescript
   * interface AppItem {
   *   whoami: string;
   *   appData: unknown;
   *   visData: VisItem;
   * }
   * interface VisItem {
   *   id: number;
   *   label: string;
   *   color: string;
   *   x: number;
   *   y: number;
   * }
   *
   * const ds1 = new DataSet<AppItem, "whoami">([], { fieldId: "whoami" });
   * const ds2 = new DataSet<VisItem, "id">();
   *
   * const pipe = createNewDataPipeFrom(ds1)
   *   .filter((item): boolean => item.enabled === true)
   *   .map<VisItem, "id">((item): VisItem => item.visData)
   *   .to(ds2);
   *
   * pipe.start();
   * ```
   * @returns A factory whose methods can be used to configure the pipe.
   */
  function createNewDataPipeFrom(from) {
    return new DataPipeUnderConstruction(from);
  }
  /**
   * Internal implementation of the pipe. This should be accessible only through
   * `createNewDataPipeFrom` from the outside.
   *
   * @typeParam SI - Source item type.
   * @typeParam SP - Source item type's id property name.
   * @typeParam TI - Target item type.
   * @typeParam TP - Target item type's id property name.
   */

  var SimpleDataPipe = /*#__PURE__*/function () {
    /**
     * Bound listeners for use with `DataInterface['on' | 'off']`.
     */

    /**
     * Create a new data pipe.
     *
     * @param _source - The data set or data view that will be observed.
     * @param _transformers - An array of transforming functions to be used to
     * filter or transform the items in the pipe.
     * @param _target - The data set or data view that will receive the items.
     */
    function SimpleDataPipe(_source, _transformers, _target) {
      var _context, _context2, _context3;

      _classCallCheck(this, SimpleDataPipe);

      _defineProperty(this, "_source", void 0);

      _defineProperty(this, "_transformers", void 0);

      _defineProperty(this, "_target", void 0);

      _defineProperty(this, "_listeners", {
        add: bind$6(_context = this._add).call(_context, this),
        remove: bind$6(_context2 = this._remove).call(_context2, this),
        update: bind$6(_context3 = this._update).call(_context3, this)
      });

      this._source = _source;
      this._transformers = _transformers;
      this._target = _target;
    }
    /** @inheritDoc */


    _createClass(SimpleDataPipe, [{
      key: "all",
      value: function all() {
        this._target.update(this._transformItems(this._source.get()));

        return this;
      }
      /** @inheritDoc */

    }, {
      key: "start",
      value: function start() {
        this._source.on("add", this._listeners.add);

        this._source.on("remove", this._listeners.remove);

        this._source.on("update", this._listeners.update);

        return this;
      }
      /** @inheritDoc */

    }, {
      key: "stop",
      value: function stop() {
        this._source.off("add", this._listeners.add);

        this._source.off("remove", this._listeners.remove);

        this._source.off("update", this._listeners.update);

        return this;
      }
      /**
       * Apply the transformers to the items.
       *
       * @param items - The items to be transformed.
       * @returns The transformed items.
       */

    }, {
      key: "_transformItems",
      value: function _transformItems(items) {
        var _context4;

        return reduce(_context4 = this._transformers).call(_context4, function (items, transform) {
          return transform(items);
        }, items);
      }
      /**
       * Handle an add event.
       *
       * @param _name - Ignored.
       * @param payload - The payload containing the ids of the added items.
       */

    }, {
      key: "_add",
      value: function _add(_name, payload) {
        if (payload == null) {
          return;
        }

        this._target.add(this._transformItems(this._source.get(payload.items)));
      }
      /**
       * Handle an update event.
       *
       * @param _name - Ignored.
       * @param payload - The payload containing the ids of the updated items.
       */

    }, {
      key: "_update",
      value: function _update(_name, payload) {
        if (payload == null) {
          return;
        }

        this._target.update(this._transformItems(this._source.get(payload.items)));
      }
      /**
       * Handle a remove event.
       *
       * @param _name - Ignored.
       * @param payload - The payload containing the data of the removed items.
       */

    }, {
      key: "_remove",
      value: function _remove(_name, payload) {
        if (payload == null) {
          return;
        }

        this._target.remove(this._transformItems(payload.oldData));
      }
    }]);

    return SimpleDataPipe;
  }();
  /**
   * Internal implementation of the pipe factory. This should be accessible
   * only through `createNewDataPipeFrom` from the outside.
   *
   * @typeParam TI - Target item type.
   * @typeParam TP - Target item type's id property name.
   */


  var DataPipeUnderConstruction = /*#__PURE__*/function () {
    /**
     * Array transformers used to transform items within the pipe. This is typed
     * as any for the sake of simplicity.
     */

    /**
     * Create a new data pipe factory. This is an internal constructor that
     * should never be called from outside of this file.
     *
     * @param _source - The source data set or data view for this pipe.
     */
    function DataPipeUnderConstruction(_source) {
      _classCallCheck(this, DataPipeUnderConstruction);

      _defineProperty(this, "_source", void 0);

      _defineProperty(this, "_transformers", []);

      this._source = _source;
    }
    /**
     * Filter the items.
     *
     * @param callback - A filtering function that returns true if given item
     * should be piped and false if not.
     * @returns This factory for further configuration.
     */


    _createClass(DataPipeUnderConstruction, [{
      key: "filter",
      value: function filter$1(callback) {
        this._transformers.push(function (input) {
          return filter(input).call(input, callback);
        });

        return this;
      }
      /**
       * Map each source item to a new type.
       *
       * @param callback - A mapping function that takes a source item and returns
       * corresponding mapped item.
       * @typeParam TI - Target item type.
       * @typeParam TP - Target item type's id property name.
       * @returns This factory for further configuration.
       */

    }, {
      key: "map",
      value: function map(callback) {
        this._transformers.push(function (input) {
          return map$3(input).call(input, callback);
        });

        return this;
      }
      /**
       * Map each source item to zero or more items of a new type.
       *
       * @param callback - A mapping function that takes a source item and returns
       * an array of corresponding mapped items.
       * @typeParam TI - Target item type.
       * @typeParam TP - Target item type's id property name.
       * @returns This factory for further configuration.
       */

    }, {
      key: "flatMap",
      value: function flatMap$1(callback) {
        this._transformers.push(function (input) {
          return flatMap(input).call(input, callback);
        });

        return this;
      }
      /**
       * Connect this pipe to given data set.
       *
       * @param target - The data set that will receive the items from this pipe.
       * @returns The pipe connected between given data sets and performing
       * configured transformation on the processed items.
       */

    }, {
      key: "to",
      value: function to(target) {
        return new SimpleDataPipe(this._source, this._transformers, target);
      }
    }]);

    return DataPipeUnderConstruction;
  }();

  var global$o = global$M;
  var classof$a = classof$c;
  var String$2 = global$o.String;

  var toString$7 = function (argument) {
    if (classof$a(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
    return String$2(argument);
  };

  var uncurryThis$g = functionUncurryThis;
  var toIntegerOrInfinity$2 = toIntegerOrInfinity$4;
  var toString$6 = toString$7;
  var requireObjectCoercible$2 = requireObjectCoercible$5;
  var charAt$2 = uncurryThis$g(''.charAt);
  var charCodeAt$1 = uncurryThis$g(''.charCodeAt);
  var stringSlice = uncurryThis$g(''.slice);

  var createMethod$3 = function (CONVERT_TO_STRING) {
    return function ($this, pos) {
      var S = toString$6(requireObjectCoercible$2($this));
      var position = toIntegerOrInfinity$2(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
      first = charCodeAt$1(S, position);
      return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt$1(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt$2(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
    };
  };

  var stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod$3(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod$3(true)
  };

  var global$n = global$M;
  var isCallable$6 = isCallable$h;
  var inspectSource = inspectSource$2;
  var WeakMap$1 = global$n.WeakMap;
  var nativeWeakMap = isCallable$6(WeakMap$1) && /native code/.test(inspectSource(WeakMap$1));

  var shared$2 = shared$4.exports;
  var uid$2 = uid$4;
  var keys$7 = shared$2('keys');

  var sharedKey$4 = function (key) {
    return keys$7[key] || (keys$7[key] = uid$2(key));
  };

  var hiddenKeys$6 = {};

  var NATIVE_WEAK_MAP = nativeWeakMap;
  var global$m = global$M;
  var uncurryThis$f = functionUncurryThis;
  var isObject$8 = isObject$f;
  var createNonEnumerableProperty$4 = createNonEnumerableProperty$6;
  var hasOwn$b = hasOwnProperty_1;
  var shared$1 = sharedStore;
  var sharedKey$3 = sharedKey$4;
  var hiddenKeys$5 = hiddenKeys$6;
  var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
  var TypeError$b = global$m.TypeError;
  var WeakMap = global$m.WeakMap;
  var set$3, get, has;

  var enforce = function (it) {
    return has(it) ? get(it) : set$3(it, {});
  };

  var getterFor = function (TYPE) {
    return function (it) {
      var state;

      if (!isObject$8(it) || (state = get(it)).type !== TYPE) {
        throw TypeError$b('Incompatible receiver, ' + TYPE + ' required');
      }

      return state;
    };
  };

  if (NATIVE_WEAK_MAP || shared$1.state) {
    var store = shared$1.state || (shared$1.state = new WeakMap());
    var wmget = uncurryThis$f(store.get);
    var wmhas = uncurryThis$f(store.has);
    var wmset = uncurryThis$f(store.set);

    set$3 = function (it, metadata) {
      if (wmhas(store, it)) throw new TypeError$b(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      wmset(store, it, metadata);
      return metadata;
    };

    get = function (it) {
      return wmget(store, it) || {};
    };

    has = function (it) {
      return wmhas(store, it);
    };
  } else {
    var STATE = sharedKey$3('state');
    hiddenKeys$5[STATE] = true;

    set$3 = function (it, metadata) {
      if (hasOwn$b(it, STATE)) throw new TypeError$b(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      createNonEnumerableProperty$4(it, STATE, metadata);
      return metadata;
    };

    get = function (it) {
      return hasOwn$b(it, STATE) ? it[STATE] : {};
    };

    has = function (it) {
      return hasOwn$b(it, STATE);
    };
  }

  var internalState = {
    set: set$3,
    get: get,
    has: has,
    enforce: enforce,
    getterFor: getterFor
  };

  var DESCRIPTORS$b = descriptors;
  var hasOwn$a = hasOwnProperty_1;
  var FunctionPrototype = Function.prototype; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

  var getDescriptor = DESCRIPTORS$b && Object.getOwnPropertyDescriptor;
  var EXISTS = hasOwn$a(FunctionPrototype, 'name'); // additional protection from minified / mangled / dropped function names

  var PROPER = EXISTS && function something() {
    /* empty */
  }.name === 'something';

  var CONFIGURABLE = EXISTS && (!DESCRIPTORS$b || DESCRIPTORS$b && getDescriptor(FunctionPrototype, 'name').configurable);
  var functionName = {
    EXISTS: EXISTS,
    PROPER: PROPER,
    CONFIGURABLE: CONFIGURABLE
  };

  var objectDefineProperties = {};

  var toIntegerOrInfinity$1 = toIntegerOrInfinity$4;
  var max$3 = Math.max;
  var min$1 = Math.min; // Helper for a popular repeating case of the spec:
  // Let integer be ? ToInteger(index).
  // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

  var toAbsoluteIndex$5 = function (index, length) {
    var integer = toIntegerOrInfinity$1(index);
    return integer < 0 ? max$3(integer + length, 0) : min$1(integer, length);
  };

  var toIndexedObject$9 = toIndexedObject$b;
  var toAbsoluteIndex$4 = toAbsoluteIndex$5;
  var lengthOfArrayLike$8 = lengthOfArrayLike$d; // `Array.prototype.{ indexOf, includes }` methods implementation

  var createMethod$2 = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIndexedObject$9($this);
      var length = lengthOfArrayLike$8(O);
      var index = toAbsoluteIndex$4(fromIndex, length);
      var value; // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare -- NaN check

      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++]; // eslint-disable-next-line no-self-compare -- NaN check

        if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
      } else for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };

  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod$2(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod$2(false)
  };

  var uncurryThis$e = functionUncurryThis;
  var hasOwn$9 = hasOwnProperty_1;
  var toIndexedObject$8 = toIndexedObject$b;
  var indexOf = arrayIncludes.indexOf;
  var hiddenKeys$4 = hiddenKeys$6;
  var push$4 = uncurryThis$e([].push);

  var objectKeysInternal = function (object, names) {
    var O = toIndexedObject$8(object);
    var i = 0;
    var result = [];
    var key;

    for (key in O) !hasOwn$9(hiddenKeys$4, key) && hasOwn$9(O, key) && push$4(result, key); // Don't enum bug & hidden keys


    while (names.length > i) if (hasOwn$9(O, key = names[i++])) {
      ~indexOf(result, key) || push$4(result, key);
    }

    return result;
  };

  var enumBugKeys$3 = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

  var internalObjectKeys$1 = objectKeysInternal;
  var enumBugKeys$2 = enumBugKeys$3; // `Object.keys` method
  // https://tc39.es/ecma262/#sec-object.keys
  // eslint-disable-next-line es/no-object-keys -- safe

  var objectKeys$4 = Object.keys || function keys(O) {
    return internalObjectKeys$1(O, enumBugKeys$2);
  };

  var DESCRIPTORS$a = descriptors;
  var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
  var definePropertyModule$3 = objectDefineProperty;
  var anObject$9 = anObject$b;
  var toIndexedObject$7 = toIndexedObject$b;
  var objectKeys$3 = objectKeys$4; // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  // eslint-disable-next-line es/no-object-defineproperties -- safe

  objectDefineProperties.f = DESCRIPTORS$a && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject$9(O);
    var props = toIndexedObject$7(Properties);
    var keys = objectKeys$3(Properties);
    var length = keys.length;
    var index = 0;
    var key;

    while (length > index) definePropertyModule$3.f(O, key = keys[index++], props[key]);

    return O;
  };

  var getBuiltIn$5 = getBuiltIn$9;
  var html$1 = getBuiltIn$5('document', 'documentElement');

  /* global ActiveXObject -- old IE, WSH */
  var anObject$8 = anObject$b;
  var definePropertiesModule$1 = objectDefineProperties;
  var enumBugKeys$1 = enumBugKeys$3;
  var hiddenKeys$3 = hiddenKeys$6;
  var html = html$1;
  var documentCreateElement = documentCreateElement$1;
  var sharedKey$2 = sharedKey$4;
  var GT = '>';
  var LT = '<';
  var PROTOTYPE$1 = 'prototype';
  var SCRIPT = 'script';
  var IE_PROTO$1 = sharedKey$2('IE_PROTO');

  var EmptyConstructor = function () {
    /* empty */
  };

  var scriptTag = function (content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
  }; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


  var NullProtoObjectViaActiveX = function (activeXDocument) {
    activeXDocument.write(scriptTag(''));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak

    return temp;
  }; // Create object with fake `null` prototype: use iframe Object with cleared prototype


  var NullProtoObjectViaIFrame = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag('document.F=Object'));
    iframeDocument.close();
    return iframeDocument.F;
  }; // Check for document.domain and active x support
  // No need to use active x approach when document.domain is not set
  // see https://github.com/es-shims/es5-shim/issues/150
  // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
  // avoid IE GC bug


  var activeXDocument;

  var NullProtoObject = function () {
    try {
      activeXDocument = new ActiveXObject('htmlfile');
    } catch (error) {
      /* ignore */
    }

    NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE
    : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH

    var length = enumBugKeys$1.length;

    while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys$1[length]];

    return NullProtoObject();
  };

  hiddenKeys$3[IE_PROTO$1] = true; // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create

  var objectCreate = Object.create || function create(O, Properties) {
    var result;

    if (O !== null) {
      EmptyConstructor[PROTOTYPE$1] = anObject$8(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE$1] = null; // add "__proto__" for Object.getPrototypeOf polyfill

      result[IE_PROTO$1] = O;
    } else result = NullProtoObject();

    return Properties === undefined ? result : definePropertiesModule$1.f(result, Properties);
  };

  var fails$g = fails$r;
  var correctPrototypeGetter = !fails$g(function () {
    function F() {
      /* empty */
    }

    F.prototype.constructor = null; // eslint-disable-next-line es/no-object-getprototypeof -- required for testing

    return Object.getPrototypeOf(new F()) !== F.prototype;
  });

  var global$l = global$M;
  var hasOwn$8 = hasOwnProperty_1;
  var isCallable$5 = isCallable$h;
  var toObject$9 = toObject$e;
  var sharedKey$1 = sharedKey$4;
  var CORRECT_PROTOTYPE_GETTER$1 = correctPrototypeGetter;
  var IE_PROTO = sharedKey$1('IE_PROTO');
  var Object$4 = global$l.Object;
  var ObjectPrototype$2 = Object$4.prototype; // `Object.getPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.getprototypeof

  var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER$1 ? Object$4.getPrototypeOf : function (O) {
    var object = toObject$9(O);
    if (hasOwn$8(object, IE_PROTO)) return object[IE_PROTO];
    var constructor = object.constructor;

    if (isCallable$5(constructor) && object instanceof constructor) {
      return constructor.prototype;
    }

    return object instanceof Object$4 ? ObjectPrototype$2 : null;
  };

  var createNonEnumerableProperty$3 = createNonEnumerableProperty$6;

  var redefine$4 = function (target, key, value, options) {
    if (options && options.enumerable) target[key] = value;else createNonEnumerableProperty$3(target, key, value);
  };

  var fails$f = fails$r;
  var isCallable$4 = isCallable$h;
  var create$a = objectCreate;
  var getPrototypeOf$6 = objectGetPrototypeOf;
  var redefine$3 = redefine$4;
  var wellKnownSymbol$d = wellKnownSymbol$j;
  var ITERATOR$5 = wellKnownSymbol$d('iterator');
  var BUGGY_SAFARI_ITERATORS$1 = false; // `%IteratorPrototype%` object
  // https://tc39.es/ecma262/#sec-%iteratorprototype%-object

  var IteratorPrototype$1, PrototypeOfArrayIteratorPrototype, arrayIterator;
  /* eslint-disable es/no-array-prototype-keys -- safe */

  if ([].keys) {
    arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;else {
      PrototypeOfArrayIteratorPrototype = getPrototypeOf$6(getPrototypeOf$6(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;
    }
  }

  var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$1 == undefined || fails$f(function () {
    var test = {}; // FF44- legacy iterators case

    return IteratorPrototype$1[ITERATOR$5].call(test) !== test;
  });
  if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$1 = {};else IteratorPrototype$1 = create$a(IteratorPrototype$1); // `%IteratorPrototype%[@@iterator]()` method
  // https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator

  if (!isCallable$4(IteratorPrototype$1[ITERATOR$5])) {
    redefine$3(IteratorPrototype$1, ITERATOR$5, function () {
      return this;
    });
  }

  var iteratorsCore = {
    IteratorPrototype: IteratorPrototype$1,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
  };

  var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
  var classof$9 = classof$c; // `Object.prototype.toString` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.tostring

  var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {
    return '[object ' + classof$9(this) + ']';
  };

  var TO_STRING_TAG_SUPPORT = toStringTagSupport;
  var defineProperty$6 = objectDefineProperty.f;
  var createNonEnumerableProperty$2 = createNonEnumerableProperty$6;
  var hasOwn$7 = hasOwnProperty_1;
  var toString$5 = objectToString;
  var wellKnownSymbol$c = wellKnownSymbol$j;
  var TO_STRING_TAG$1 = wellKnownSymbol$c('toStringTag');

  var setToStringTag$5 = function (it, TAG, STATIC, SET_METHOD) {
    if (it) {
      var target = STATIC ? it : it.prototype;

      if (!hasOwn$7(target, TO_STRING_TAG$1)) {
        defineProperty$6(target, TO_STRING_TAG$1, {
          configurable: true,
          value: TAG
        });
      }

      if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
        createNonEnumerableProperty$2(target, 'toString', toString$5);
      }
    }
  };

  var iterators = {};

  var IteratorPrototype = iteratorsCore.IteratorPrototype;
  var create$9 = objectCreate;
  var createPropertyDescriptor$2 = createPropertyDescriptor$5;
  var setToStringTag$4 = setToStringTag$5;
  var Iterators$5 = iterators;

  var returnThis$1 = function () {
    return this;
  };

  var createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
    var TO_STRING_TAG = NAME + ' Iterator';
    IteratorConstructor.prototype = create$9(IteratorPrototype, {
      next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next)
    });
    setToStringTag$4(IteratorConstructor, TO_STRING_TAG, false, true);
    Iterators$5[TO_STRING_TAG] = returnThis$1;
    return IteratorConstructor;
  };

  var global$k = global$M;
  var isCallable$3 = isCallable$h;
  var String$1 = global$k.String;
  var TypeError$a = global$k.TypeError;

  var aPossiblePrototype$1 = function (argument) {
    if (typeof argument == 'object' || isCallable$3(argument)) return argument;
    throw TypeError$a("Can't set " + String$1(argument) + ' as a prototype');
  };

  /* eslint-disable no-proto -- safe */
  var uncurryThis$d = functionUncurryThis;
  var anObject$7 = anObject$b;
  var aPossiblePrototype = aPossiblePrototype$1; // `Object.setPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.setprototypeof
  // Works with __proto__ only. Old v8 can't work with null proto objects.
  // eslint-disable-next-line es/no-object-setprototypeof -- safe

  var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;

    try {
      // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
      setter = uncurryThis$d(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
      setter(test, []);
      CORRECT_SETTER = test instanceof Array;
    } catch (error) {
      /* empty */
    }

    return function setPrototypeOf(O, proto) {
      anObject$7(O);
      aPossiblePrototype(proto);
      if (CORRECT_SETTER) setter(O, proto);else O.__proto__ = proto;
      return O;
    };
  }() : undefined);

  var $$w = _export;
  var call$6 = functionCall;
  var FunctionName = functionName;
  var createIteratorConstructor = createIteratorConstructor$1;
  var getPrototypeOf$5 = objectGetPrototypeOf;
  var setToStringTag$3 = setToStringTag$5;
  var redefine$2 = redefine$4;
  var wellKnownSymbol$b = wellKnownSymbol$j;
  var Iterators$4 = iterators;
  var IteratorsCore = iteratorsCore;
  var PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;
  var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$4 = wellKnownSymbol$b('iterator');
  var KEYS = 'keys';
  var VALUES = 'values';
  var ENTRIES = 'entries';

  var returnThis = function () {
    return this;
  };

  var defineIterator$3 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);

    var getIterationMethod = function (KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];

      switch (KIND) {
        case KEYS:
          return function keys() {
            return new IteratorConstructor(this, KIND);
          };

        case VALUES:
          return function values() {
            return new IteratorConstructor(this, KIND);
          };

        case ENTRIES:
          return function entries() {
            return new IteratorConstructor(this, KIND);
          };
      }

      return function () {
        return new IteratorConstructor(this);
      };
    };

    var TO_STRING_TAG = NAME + ' Iterator';
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$4] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY; // fix native

    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf$5(anyNativeIterator.call(new Iterable()));

      if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {


        setToStringTag$3(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
        Iterators$4[TO_STRING_TAG] = returnThis;
      }
    } // fix Array.prototype.{ values, @@iterator }.name in V8 / FF


    if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      {
        INCORRECT_VALUES_NAME = true;

        defaultIterator = function values() {
          return call$6(nativeIterator, this);
        };
      }
    } // export additional methods


    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine$2(IterablePrototype, KEY, methods[KEY]);
        }
      } else $$w({
        target: NAME,
        proto: true,
        forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
      }, methods);
    } // define iterator


    if ((FORCED) && IterablePrototype[ITERATOR$4] !== defaultIterator) {
      redefine$2(IterablePrototype, ITERATOR$4, defaultIterator, {
        name: DEFAULT
      });
    }

    Iterators$4[NAME] = defaultIterator;
    return methods;
  };

  var charAt$1 = stringMultibyte.charAt;
  var toString$4 = toString$7;
  var InternalStateModule$4 = internalState;
  var defineIterator$2 = defineIterator$3;
  var STRING_ITERATOR = 'String Iterator';
  var setInternalState$4 = InternalStateModule$4.set;
  var getInternalState$2 = InternalStateModule$4.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-string.prototype-@@iterator

  defineIterator$2(String, 'String', function (iterated) {
    setInternalState$4(this, {
      type: STRING_ITERATOR,
      string: toString$4(iterated),
      index: 0
    }); // `%StringIteratorPrototype%.next` method
    // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
  }, function next() {
    var state = getInternalState$2(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return {
      value: undefined,
      done: true
    };
    point = charAt$1(string, index);
    state.index += point.length;
    return {
      value: point,
      done: false
    };
  });

  var call$5 = functionCall;
  var anObject$6 = anObject$b;
  var getMethod$1 = getMethod$3;

  var iteratorClose$2 = function (iterator, kind, value) {
    var innerResult, innerError;
    anObject$6(iterator);

    try {
      innerResult = getMethod$1(iterator, 'return');

      if (!innerResult) {
        if (kind === 'throw') throw value;
        return value;
      }

      innerResult = call$5(innerResult, iterator);
    } catch (error) {
      innerError = true;
      innerResult = error;
    }

    if (kind === 'throw') throw value;
    if (innerError) throw innerResult;
    anObject$6(innerResult);
    return value;
  };

  var anObject$5 = anObject$b;
  var iteratorClose$1 = iteratorClose$2; // call something on iterator step with safe closing on error

  var callWithSafeIterationClosing$1 = function (iterator, fn, value, ENTRIES) {
    try {
      return ENTRIES ? fn(anObject$5(value)[0], value[1]) : fn(value);
    } catch (error) {
      iteratorClose$1(iterator, 'throw', error);
    }
  };

  var wellKnownSymbol$a = wellKnownSymbol$j;
  var Iterators$3 = iterators;
  var ITERATOR$3 = wellKnownSymbol$a('iterator');
  var ArrayPrototype$a = Array.prototype; // check on default Array iterator

  var isArrayIteratorMethod$2 = function (it) {
    return it !== undefined && (Iterators$3.Array === it || ArrayPrototype$a[ITERATOR$3] === it);
  };

  var toPropertyKey$1 = toPropertyKey$4;
  var definePropertyModule$2 = objectDefineProperty;
  var createPropertyDescriptor$1 = createPropertyDescriptor$5;

  var createProperty$6 = function (object, key, value) {
    var propertyKey = toPropertyKey$1(key);
    if (propertyKey in object) definePropertyModule$2.f(object, propertyKey, createPropertyDescriptor$1(0, value));else object[propertyKey] = value;
  };

  var classof$8 = classof$c;
  var getMethod = getMethod$3;
  var Iterators$2 = iterators;
  var wellKnownSymbol$9 = wellKnownSymbol$j;
  var ITERATOR$2 = wellKnownSymbol$9('iterator');

  var getIteratorMethod$8 = function (it) {
    if (it != undefined) return getMethod(it, ITERATOR$2) || getMethod(it, '@@iterator') || Iterators$2[classof$8(it)];
  };

  var global$j = global$M;
  var call$4 = functionCall;
  var aCallable$1 = aCallable$7;
  var anObject$4 = anObject$b;
  var tryToString$2 = tryToString$4;
  var getIteratorMethod$7 = getIteratorMethod$8;
  var TypeError$9 = global$j.TypeError;

  var getIterator$7 = function (argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod$7(argument) : usingIterator;
    if (aCallable$1(iteratorMethod)) return anObject$4(call$4(iteratorMethod, argument));
    throw TypeError$9(tryToString$2(argument) + ' is not iterable');
  };

  var global$i = global$M;
  var bind$3 = functionBindContext;
  var call$3 = functionCall;
  var toObject$8 = toObject$e;
  var callWithSafeIterationClosing = callWithSafeIterationClosing$1;
  var isArrayIteratorMethod$1 = isArrayIteratorMethod$2;
  var isConstructor$2 = isConstructor$4;
  var lengthOfArrayLike$7 = lengthOfArrayLike$d;
  var createProperty$5 = createProperty$6;
  var getIterator$6 = getIterator$7;
  var getIteratorMethod$6 = getIteratorMethod$8;
  var Array$4 = global$i.Array; // `Array.from` method implementation
  // https://tc39.es/ecma262/#sec-array.from

  var arrayFrom = function from(arrayLike
  /* , mapfn = undefined, thisArg = undefined */
  ) {
    var O = toObject$8(arrayLike);
    var IS_CONSTRUCTOR = isConstructor$2(this);
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    if (mapping) mapfn = bind$3(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
    var iteratorMethod = getIteratorMethod$6(O);
    var index = 0;
    var length, result, step, iterator, next, value; // if the target is not iterable or it's an array with the default iterator - use a simple case

    if (iteratorMethod && !(this == Array$4 && isArrayIteratorMethod$1(iteratorMethod))) {
      iterator = getIterator$6(O, iteratorMethod);
      next = iterator.next;
      result = IS_CONSTRUCTOR ? new this() : [];

      for (; !(step = call$3(next, iterator)).done; index++) {
        value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
        createProperty$5(result, index, value);
      }
    } else {
      length = lengthOfArrayLike$7(O);
      result = IS_CONSTRUCTOR ? new this(length) : Array$4(length);

      for (; length > index; index++) {
        value = mapping ? mapfn(O[index], index) : O[index];
        createProperty$5(result, index, value);
      }
    }

    result.length = index;
    return result;
  };

  var wellKnownSymbol$8 = wellKnownSymbol$j;
  var ITERATOR$1 = wellKnownSymbol$8('iterator');
  var SAFE_CLOSING = false;

  try {
    var called = 0;
    var iteratorWithReturn = {
      next: function () {
        return {
          done: !!called++
        };
      },
      'return': function () {
        SAFE_CLOSING = true;
      }
    };

    iteratorWithReturn[ITERATOR$1] = function () {
      return this;
    }; // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing


    Array.from(iteratorWithReturn, function () {
      throw 2;
    });
  } catch (error) {
    /* empty */
  }

  var checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;

    try {
      var object = {};

      object[ITERATOR$1] = function () {
        return {
          next: function () {
            return {
              done: ITERATION_SUPPORT = true
            };
          }
        };
      };

      exec(object);
    } catch (error) {
      /* empty */
    }

    return ITERATION_SUPPORT;
  };

  var $$v = _export;
  var from$6 = arrayFrom;
  var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
  var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
    // eslint-disable-next-line es/no-array-from -- required for testing
    Array.from(iterable);
  }); // `Array.from` method
  // https://tc39.es/ecma262/#sec-array.from

  $$v({
    target: 'Array',
    stat: true,
    forced: INCORRECT_ITERATION
  }, {
    from: from$6
  });

  var path$l = path$q;
  var from$5 = path$l.Array.from;

  var parent$N = from$5;
  var from$4 = parent$N;

  var from$3 = from$4;

  var toIndexedObject$6 = toIndexedObject$b;
  var Iterators$1 = iterators;
  var InternalStateModule$3 = internalState;
  objectDefineProperty.f;
  var defineIterator$1 = defineIterator$3;
  var ARRAY_ITERATOR = 'Array Iterator';
  var setInternalState$3 = InternalStateModule$3.set;
  var getInternalState$1 = InternalStateModule$3.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
  // https://tc39.es/ecma262/#sec-array.prototype.entries
  // `Array.prototype.keys` method
  // https://tc39.es/ecma262/#sec-array.prototype.keys
  // `Array.prototype.values` method
  // https://tc39.es/ecma262/#sec-array.prototype.values
  // `Array.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
  // `CreateArrayIterator` internal method
  // https://tc39.es/ecma262/#sec-createarrayiterator

  defineIterator$1(Array, 'Array', function (iterated, kind) {
    setInternalState$3(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject$6(iterated),
      // target
      index: 0,
      // next index
      kind: kind // kind

    }); // `%ArrayIteratorPrototype%.next` method
    // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
  }, function () {
    var state = getInternalState$1(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;

    if (!target || index >= target.length) {
      state.target = undefined;
      return {
        value: undefined,
        done: true
      };
    }

    if (kind == 'keys') return {
      value: index,
      done: false
    };
    if (kind == 'values') return {
      value: target[index],
      done: false
    };
    return {
      value: [index, target[index]],
      done: false
    };
  }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
  // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
  // https://tc39.es/ecma262/#sec-createmappedargumentsobject

  Iterators$1.Arguments = Iterators$1.Array; // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

  var getIteratorMethod$5 = getIteratorMethod$8;
  var getIteratorMethod_1 = getIteratorMethod$5;

  // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods

  var domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };

  var DOMIterables$4 = domIterables;
  var global$h = global$M;
  var classof$7 = classof$c;
  var createNonEnumerableProperty$1 = createNonEnumerableProperty$6;
  var Iterators = iterators;
  var wellKnownSymbol$7 = wellKnownSymbol$j;
  var TO_STRING_TAG = wellKnownSymbol$7('toStringTag');

  for (var COLLECTION_NAME in DOMIterables$4) {
    var Collection = global$h[COLLECTION_NAME];
    var CollectionPrototype = Collection && Collection.prototype;

    if (CollectionPrototype && classof$7(CollectionPrototype) !== TO_STRING_TAG) {
      createNonEnumerableProperty$1(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }

    Iterators[COLLECTION_NAME] = Iterators.Array;
  }

  var parent$M = getIteratorMethod_1;
  var getIteratorMethod$4 = parent$M;

  var parent$L = getIteratorMethod$4;
  var getIteratorMethod$3 = parent$L;

  var parent$K = getIteratorMethod$3;
  var getIteratorMethod$2 = parent$K;

  var getIteratorMethod$1 = getIteratorMethod$2;

  var objectGetOwnPropertyNames = {};

  var internalObjectKeys = objectKeysInternal;
  var enumBugKeys = enumBugKeys$3;
  var hiddenKeys$2 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  // eslint-disable-next-line es/no-object-getownpropertynames -- safe

  objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys$2);
  };

  var objectGetOwnPropertyNamesExternal = {};

  var global$g = global$M;
  var toAbsoluteIndex$3 = toAbsoluteIndex$5;
  var lengthOfArrayLike$6 = lengthOfArrayLike$d;
  var createProperty$4 = createProperty$6;
  var Array$3 = global$g.Array;
  var max$2 = Math.max;

  var arraySliceSimple = function (O, start, end) {
    var length = lengthOfArrayLike$6(O);
    var k = toAbsoluteIndex$3(start, length);
    var fin = toAbsoluteIndex$3(end === undefined ? length : end, length);
    var result = Array$3(max$2(fin - k, 0));

    for (var n = 0; k < fin; k++, n++) createProperty$4(result, n, O[k]);

    result.length = n;
    return result;
  };

  /* eslint-disable es/no-object-getownpropertynames -- safe */
  var classof$6 = classofRaw$1;
  var toIndexedObject$5 = toIndexedObject$b;
  var $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
  var arraySlice$3 = arraySliceSimple;
  var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

  var getWindowNames = function (it) {
    try {
      return $getOwnPropertyNames$1(it);
    } catch (error) {
      return arraySlice$3(windowNames);
    }
  }; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


  objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
    return windowNames && classof$6(it) == 'Window' ? getWindowNames(it) : $getOwnPropertyNames$1(toIndexedObject$5(it));
  };

  var objectGetOwnPropertySymbols = {};

  objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

  var wellKnownSymbolWrapped = {};

  var wellKnownSymbol$6 = wellKnownSymbol$j;
  wellKnownSymbolWrapped.f = wellKnownSymbol$6;

  var path$k = path$q;
  var hasOwn$6 = hasOwnProperty_1;
  var wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;
  var defineProperty$5 = objectDefineProperty.f;

  var defineWellKnownSymbol$l = function (NAME) {
    var Symbol = path$k.Symbol || (path$k.Symbol = {});
    if (!hasOwn$6(Symbol, NAME)) defineProperty$5(Symbol, NAME, {
      value: wrappedWellKnownSymbolModule$1.f(NAME)
    });
  };

  var $$u = _export;
  var global$f = global$M;
  var getBuiltIn$4 = getBuiltIn$9;
  var apply$4 = functionApply;
  var call$2 = functionCall;
  var uncurryThis$c = functionUncurryThis;
  var DESCRIPTORS$9 = descriptors;
  var NATIVE_SYMBOL = nativeSymbol;
  var fails$e = fails$r;
  var hasOwn$5 = hasOwnProperty_1;
  var isArray$a = isArray$d;
  var isCallable$2 = isCallable$h;
  var isObject$7 = isObject$f;
  var isPrototypeOf$c = objectIsPrototypeOf;
  var isSymbol = isSymbol$3;
  var anObject$3 = anObject$b;
  var toObject$7 = toObject$e;
  var toIndexedObject$4 = toIndexedObject$b;
  var toPropertyKey = toPropertyKey$4;
  var $toString = toString$7;
  var createPropertyDescriptor = createPropertyDescriptor$5;
  var nativeObjectCreate = objectCreate;
  var objectKeys$2 = objectKeys$4;
  var getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames;
  var getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;
  var getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;
  var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
  var definePropertyModule$1 = objectDefineProperty;
  var definePropertiesModule = objectDefineProperties;
  var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
  var arraySlice$2 = arraySlice$5;
  var redefine$1 = redefine$4;
  var shared = shared$4.exports;
  var sharedKey = sharedKey$4;
  var hiddenKeys$1 = hiddenKeys$6;
  var uid$1 = uid$4;
  var wellKnownSymbol$5 = wellKnownSymbol$j;
  var wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
  var defineWellKnownSymbol$k = defineWellKnownSymbol$l;
  var setToStringTag$2 = setToStringTag$5;
  var InternalStateModule$2 = internalState;
  var $forEach$1 = arrayIteration.forEach;
  var HIDDEN = sharedKey('hidden');
  var SYMBOL = 'Symbol';
  var PROTOTYPE = 'prototype';
  var TO_PRIMITIVE = wellKnownSymbol$5('toPrimitive');
  var setInternalState$2 = InternalStateModule$2.set;
  var getInternalState = InternalStateModule$2.getterFor(SYMBOL);
  var ObjectPrototype$1 = Object[PROTOTYPE];
  var $Symbol = global$f.Symbol;
  var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
  var TypeError$8 = global$f.TypeError;
  var QObject = global$f.QObject;
  var $stringify$1 = getBuiltIn$4('JSON', 'stringify');
  var nativeGetOwnPropertyDescriptor$1 = getOwnPropertyDescriptorModule$1.f;
  var nativeDefineProperty = definePropertyModule$1.f;
  var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
  var nativePropertyIsEnumerable = propertyIsEnumerableModule$1.f;
  var push$3 = uncurryThis$c([].push);
  var AllSymbols = shared('symbols');
  var ObjectPrototypeSymbols = shared('op-symbols');
  var StringToSymbolRegistry = shared('string-to-symbol-registry');
  var SymbolToStringRegistry = shared('symbol-to-string-registry');
  var WellKnownSymbolsStore = shared('wks'); // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

  var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

  var setSymbolDescriptor = DESCRIPTORS$9 && fails$e(function () {
    return nativeObjectCreate(nativeDefineProperty({}, 'a', {
      get: function () {
        return nativeDefineProperty(this, 'a', {
          value: 7
        }).a;
      }
    })).a != 7;
  }) ? function (O, P, Attributes) {
    var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype$1, P);
    if (ObjectPrototypeDescriptor) delete ObjectPrototype$1[P];
    nativeDefineProperty(O, P, Attributes);

    if (ObjectPrototypeDescriptor && O !== ObjectPrototype$1) {
      nativeDefineProperty(ObjectPrototype$1, P, ObjectPrototypeDescriptor);
    }
  } : nativeDefineProperty;

  var wrap$1 = function (tag, description) {
    var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
    setInternalState$2(symbol, {
      type: SYMBOL,
      tag: tag,
      description: description
    });
    if (!DESCRIPTORS$9) symbol.description = description;
    return symbol;
  };

  var $defineProperty = function defineProperty(O, P, Attributes) {
    if (O === ObjectPrototype$1) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
    anObject$3(O);
    var key = toPropertyKey(P);
    anObject$3(Attributes);

    if (hasOwn$5(AllSymbols, key)) {
      if (!Attributes.enumerable) {
        if (!hasOwn$5(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
        O[HIDDEN][key] = true;
      } else {
        if (hasOwn$5(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
        Attributes = nativeObjectCreate(Attributes, {
          enumerable: createPropertyDescriptor(0, false)
        });
      }

      return setSymbolDescriptor(O, key, Attributes);
    }

    return nativeDefineProperty(O, key, Attributes);
  };

  var $defineProperties = function defineProperties(O, Properties) {
    anObject$3(O);
    var properties = toIndexedObject$4(Properties);
    var keys = objectKeys$2(properties).concat($getOwnPropertySymbols(properties));
    $forEach$1(keys, function (key) {
      if (!DESCRIPTORS$9 || call$2($propertyIsEnumerable$1, properties, key)) $defineProperty(O, key, properties[key]);
    });
    return O;
  };

  var $create = function create(O, Properties) {
    return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
  };

  var $propertyIsEnumerable$1 = function propertyIsEnumerable(V) {
    var P = toPropertyKey(V);
    var enumerable = call$2(nativePropertyIsEnumerable, this, P);
    if (this === ObjectPrototype$1 && hasOwn$5(AllSymbols, P) && !hasOwn$5(ObjectPrototypeSymbols, P)) return false;
    return enumerable || !hasOwn$5(this, P) || !hasOwn$5(AllSymbols, P) || hasOwn$5(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
  };

  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
    var it = toIndexedObject$4(O);
    var key = toPropertyKey(P);
    if (it === ObjectPrototype$1 && hasOwn$5(AllSymbols, key) && !hasOwn$5(ObjectPrototypeSymbols, key)) return;
    var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);

    if (descriptor && hasOwn$5(AllSymbols, key) && !(hasOwn$5(it, HIDDEN) && it[HIDDEN][key])) {
      descriptor.enumerable = true;
    }

    return descriptor;
  };

  var $getOwnPropertyNames = function getOwnPropertyNames(O) {
    var names = nativeGetOwnPropertyNames(toIndexedObject$4(O));
    var result = [];
    $forEach$1(names, function (key) {
      if (!hasOwn$5(AllSymbols, key) && !hasOwn$5(hiddenKeys$1, key)) push$3(result, key);
    });
    return result;
  };

  var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
    var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$1;
    var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject$4(O));
    var result = [];
    $forEach$1(names, function (key) {
      if (hasOwn$5(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$5(ObjectPrototype$1, key))) {
        push$3(result, AllSymbols[key]);
      }
    });
    return result;
  }; // `Symbol` constructor
  // https://tc39.es/ecma262/#sec-symbol-constructor


  if (!NATIVE_SYMBOL) {
    $Symbol = function Symbol() {
      if (isPrototypeOf$c(SymbolPrototype, this)) throw TypeError$8('Symbol is not a constructor');
      var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
      var tag = uid$1(description);

      var setter = function (value) {
        if (this === ObjectPrototype$1) call$2(setter, ObjectPrototypeSymbols, value);
        if (hasOwn$5(this, HIDDEN) && hasOwn$5(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
        setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
      };

      if (DESCRIPTORS$9 && USE_SETTER) setSymbolDescriptor(ObjectPrototype$1, tag, {
        configurable: true,
        set: setter
      });
      return wrap$1(tag, description);
    };

    SymbolPrototype = $Symbol[PROTOTYPE];
    redefine$1(SymbolPrototype, 'toString', function toString() {
      return getInternalState(this).tag;
    });
    redefine$1($Symbol, 'withoutSetter', function (description) {
      return wrap$1(uid$1(description), description);
    });
    propertyIsEnumerableModule$1.f = $propertyIsEnumerable$1;
    definePropertyModule$1.f = $defineProperty;
    definePropertiesModule.f = $defineProperties;
    getOwnPropertyDescriptorModule$1.f = $getOwnPropertyDescriptor;
    getOwnPropertyNamesModule$2.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
    getOwnPropertySymbolsModule$2.f = $getOwnPropertySymbols;

    wrappedWellKnownSymbolModule.f = function (name) {
      return wrap$1(wellKnownSymbol$5(name), name);
    };

    if (DESCRIPTORS$9) {
      // https://github.com/tc39/proposal-Symbol-description
      nativeDefineProperty(SymbolPrototype, 'description', {
        configurable: true,
        get: function description() {
          return getInternalState(this).description;
        }
      });
    }
  }

  $$u({
    global: true,
    wrap: true,
    forced: !NATIVE_SYMBOL,
    sham: !NATIVE_SYMBOL
  }, {
    Symbol: $Symbol
  });
  $forEach$1(objectKeys$2(WellKnownSymbolsStore), function (name) {
    defineWellKnownSymbol$k(name);
  });
  $$u({
    target: SYMBOL,
    stat: true,
    forced: !NATIVE_SYMBOL
  }, {
    // `Symbol.for` method
    // https://tc39.es/ecma262/#sec-symbol.for
    'for': function (key) {
      var string = $toString(key);
      if (hasOwn$5(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
      var symbol = $Symbol(string);
      StringToSymbolRegistry[string] = symbol;
      SymbolToStringRegistry[symbol] = string;
      return symbol;
    },
    // `Symbol.keyFor` method
    // https://tc39.es/ecma262/#sec-symbol.keyfor
    keyFor: function keyFor(sym) {
      if (!isSymbol(sym)) throw TypeError$8(sym + ' is not a symbol');
      if (hasOwn$5(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
    },
    useSetter: function () {
      USE_SETTER = true;
    },
    useSimple: function () {
      USE_SETTER = false;
    }
  });
  $$u({
    target: 'Object',
    stat: true,
    forced: !NATIVE_SYMBOL,
    sham: !DESCRIPTORS$9
  }, {
    // `Object.create` method
    // https://tc39.es/ecma262/#sec-object.create
    create: $create,
    // `Object.defineProperty` method
    // https://tc39.es/ecma262/#sec-object.defineproperty
    defineProperty: $defineProperty,
    // `Object.defineProperties` method
    // https://tc39.es/ecma262/#sec-object.defineproperties
    defineProperties: $defineProperties,
    // `Object.getOwnPropertyDescriptor` method
    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor
  });
  $$u({
    target: 'Object',
    stat: true,
    forced: !NATIVE_SYMBOL
  }, {
    // `Object.getOwnPropertyNames` method
    // https://tc39.es/ecma262/#sec-object.getownpropertynames
    getOwnPropertyNames: $getOwnPropertyNames,
    // `Object.getOwnPropertySymbols` method
    // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
    getOwnPropertySymbols: $getOwnPropertySymbols
  }); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
  // https://bugs.chromium.org/p/v8/issues/detail?id=3443

  $$u({
    target: 'Object',
    stat: true,
    forced: fails$e(function () {
      getOwnPropertySymbolsModule$2.f(1);
    })
  }, {
    getOwnPropertySymbols: function getOwnPropertySymbols(it) {
      return getOwnPropertySymbolsModule$2.f(toObject$7(it));
    }
  }); // `JSON.stringify` method behavior with symbols
  // https://tc39.es/ecma262/#sec-json.stringify

  if ($stringify$1) {
    var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails$e(function () {
      var symbol = $Symbol(); // MS Edge converts symbol values to JSON as {}

      return $stringify$1([symbol]) != '[null]' // WebKit converts symbol values to JSON as null
      || $stringify$1({
        a: symbol
      }) != '{}' // V8 throws on boxed symbols
      || $stringify$1(Object(symbol)) != '{}';
    });
    $$u({
      target: 'JSON',
      stat: true,
      forced: FORCED_JSON_STRINGIFY
    }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      stringify: function stringify(it, replacer, space) {
        var args = arraySlice$2(arguments);
        var $replacer = replacer;
        if (!isObject$7(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

        if (!isArray$a(replacer)) replacer = function (key, value) {
          if (isCallable$2($replacer)) value = call$2($replacer, this, key, value);
          if (!isSymbol(value)) return value;
        };
        args[1] = replacer;
        return apply$4($stringify$1, null, args);
      }
    });
  } // `Symbol.prototype[@@toPrimitive]` method
  // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive


  if (!SymbolPrototype[TO_PRIMITIVE]) {
    var valueOf = SymbolPrototype.valueOf; // eslint-disable-next-line no-unused-vars -- required for .length

    redefine$1(SymbolPrototype, TO_PRIMITIVE, function (hint) {
      // TODO: improve hint logic
      return call$2(valueOf, this);
    });
  } // `Symbol.prototype[@@toStringTag]` property
  // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag


  setToStringTag$2($Symbol, SYMBOL);
  hiddenKeys$1[HIDDEN] = true;

  var path$j = path$q;
  var getOwnPropertySymbols$2 = path$j.Object.getOwnPropertySymbols;

  var parent$J = getOwnPropertySymbols$2;
  var getOwnPropertySymbols$1 = parent$J;

  var getOwnPropertySymbols = getOwnPropertySymbols$1;

  var getOwnPropertyDescriptor$3 = {exports: {}};

  var $$t = _export;
  var fails$d = fails$r;
  var toIndexedObject$3 = toIndexedObject$b;
  var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  var DESCRIPTORS$8 = descriptors;
  var FAILS_ON_PRIMITIVES$3 = fails$d(function () {
    nativeGetOwnPropertyDescriptor(1);
  });
  var FORCED$5 = !DESCRIPTORS$8 || FAILS_ON_PRIMITIVES$3; // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

  $$t({
    target: 'Object',
    stat: true,
    forced: FORCED$5,
    sham: !DESCRIPTORS$8
  }, {
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
      return nativeGetOwnPropertyDescriptor(toIndexedObject$3(it), key);
    }
  });

  var path$i = path$q;
  var Object$3 = path$i.Object;

  var getOwnPropertyDescriptor$2 = getOwnPropertyDescriptor$3.exports = function getOwnPropertyDescriptor(it, key) {
    return Object$3.getOwnPropertyDescriptor(it, key);
  };

  if (Object$3.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor$2.sham = true;

  var parent$I = getOwnPropertyDescriptor$3.exports;
  var getOwnPropertyDescriptor$1 = parent$I;

  var getOwnPropertyDescriptor = getOwnPropertyDescriptor$1;

  var getBuiltIn$3 = getBuiltIn$9;
  var uncurryThis$b = functionUncurryThis;
  var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
  var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
  var anObject$2 = anObject$b;
  var concat$5 = uncurryThis$b([].concat); // all object keys, includes non-enumerable and symbols

  var ownKeys$6 = getBuiltIn$3('Reflect', 'ownKeys') || function ownKeys(it) {
    var keys = getOwnPropertyNamesModule$1.f(anObject$2(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;
    return getOwnPropertySymbols ? concat$5(keys, getOwnPropertySymbols(it)) : keys;
  };

  var $$s = _export;
  var DESCRIPTORS$7 = descriptors;
  var ownKeys$5 = ownKeys$6;
  var toIndexedObject$2 = toIndexedObject$b;
  var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
  var createProperty$3 = createProperty$6; // `Object.getOwnPropertyDescriptors` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors

  $$s({
    target: 'Object',
    stat: true,
    sham: !DESCRIPTORS$7
  }, {
    getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
      var O = toIndexedObject$2(object);
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      var keys = ownKeys$5(O);
      var result = {};
      var index = 0;
      var key, descriptor;

      while (keys.length > index) {
        descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
        if (descriptor !== undefined) createProperty$3(result, key, descriptor);
      }

      return result;
    }
  });

  var path$h = path$q;
  var getOwnPropertyDescriptors$2 = path$h.Object.getOwnPropertyDescriptors;

  var parent$H = getOwnPropertyDescriptors$2;
  var getOwnPropertyDescriptors$1 = parent$H;

  var getOwnPropertyDescriptors = getOwnPropertyDescriptors$1;

  var defineProperties$4 = {exports: {}};

  var $$r = _export;
  var DESCRIPTORS$6 = descriptors;
  var defineProperties$3 = objectDefineProperties.f; // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  // eslint-disable-next-line es/no-object-defineproperties -- safe

  $$r({
    target: 'Object',
    stat: true,
    forced: Object.defineProperties !== defineProperties$3,
    sham: !DESCRIPTORS$6
  }, {
    defineProperties: defineProperties$3
  });

  var path$g = path$q;
  var Object$2 = path$g.Object;

  var defineProperties$2 = defineProperties$4.exports = function defineProperties(T, D) {
    return Object$2.defineProperties(T, D);
  };

  if (Object$2.defineProperties.sham) defineProperties$2.sham = true;

  var parent$G = defineProperties$4.exports;
  var defineProperties$1 = parent$G;

  var defineProperties = defineProperties$1;

  var defineProperty$4 = defineProperty$a;

  var $$q = _export;
  var isArray$9 = isArray$d; // `Array.isArray` method
  // https://tc39.es/ecma262/#sec-array.isarray

  $$q({
    target: 'Array',
    stat: true
  }, {
    isArray: isArray$9
  });

  var path$f = path$q;
  var isArray$8 = path$f.Array.isArray;

  var parent$F = isArray$8;
  var isArray$7 = parent$F;

  var parent$E = isArray$7;
  var isArray$6 = parent$E;

  var parent$D = isArray$6;
  var isArray$5 = parent$D;

  var isArray$4 = isArray$5;

  function _arrayWithHoles(arr) {
    if (isArray$4(arr)) return arr;
  }

  var $$p = _export;
  var global$e = global$M;
  var fails$c = fails$r;
  var isArray$3 = isArray$d;
  var isObject$6 = isObject$f;
  var toObject$6 = toObject$e;
  var lengthOfArrayLike$5 = lengthOfArrayLike$d;
  var createProperty$2 = createProperty$6;
  var arraySpeciesCreate$1 = arraySpeciesCreate$4;
  var arrayMethodHasSpeciesSupport$2 = arrayMethodHasSpeciesSupport$5;
  var wellKnownSymbol$4 = wellKnownSymbol$j;
  var V8_VERSION = engineV8Version;
  var IS_CONCAT_SPREADABLE = wellKnownSymbol$4('isConcatSpreadable');
  var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
  var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';
  var TypeError$7 = global$e.TypeError; // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/679

  var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails$c(function () {
    var array = [];
    array[IS_CONCAT_SPREADABLE] = false;
    return array.concat()[0] !== array;
  });
  var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport$2('concat');

  var isConcatSpreadable = function (O) {
    if (!isObject$6(O)) return false;
    var spreadable = O[IS_CONCAT_SPREADABLE];
    return spreadable !== undefined ? !!spreadable : isArray$3(O);
  };

  var FORCED$4 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method
  // https://tc39.es/ecma262/#sec-array.prototype.concat
  // with adding support of @@isConcatSpreadable and @@species

  $$p({
    target: 'Array',
    proto: true,
    forced: FORCED$4
  }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    concat: function concat(arg) {
      var O = toObject$6(this);
      var A = arraySpeciesCreate$1(O, 0);
      var n = 0;
      var i, k, length, len, E;

      for (i = -1, length = arguments.length; i < length; i++) {
        E = i === -1 ? O : arguments[i];

        if (isConcatSpreadable(E)) {
          len = lengthOfArrayLike$5(E);
          if (n + len > MAX_SAFE_INTEGER$1) throw TypeError$7(MAXIMUM_ALLOWED_INDEX_EXCEEDED);

          for (k = 0; k < len; k++, n++) if (k in E) createProperty$2(A, n, E[k]);
        } else {
          if (n >= MAX_SAFE_INTEGER$1) throw TypeError$7(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
          createProperty$2(A, n++, E);
        }
      }

      A.length = n;
      return A;
    }
  });

  var defineWellKnownSymbol$j = defineWellKnownSymbol$l; // `Symbol.asyncIterator` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.asynciterator

  defineWellKnownSymbol$j('asyncIterator');

  var defineWellKnownSymbol$i = defineWellKnownSymbol$l; // `Symbol.hasInstance` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.hasinstance

  defineWellKnownSymbol$i('hasInstance');

  var defineWellKnownSymbol$h = defineWellKnownSymbol$l; // `Symbol.isConcatSpreadable` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.isconcatspreadable

  defineWellKnownSymbol$h('isConcatSpreadable');

  var defineWellKnownSymbol$g = defineWellKnownSymbol$l; // `Symbol.iterator` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.iterator

  defineWellKnownSymbol$g('iterator');

  var defineWellKnownSymbol$f = defineWellKnownSymbol$l; // `Symbol.match` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.match

  defineWellKnownSymbol$f('match');

  var defineWellKnownSymbol$e = defineWellKnownSymbol$l; // `Symbol.matchAll` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.matchall

  defineWellKnownSymbol$e('matchAll');

  var defineWellKnownSymbol$d = defineWellKnownSymbol$l; // `Symbol.replace` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.replace

  defineWellKnownSymbol$d('replace');

  var defineWellKnownSymbol$c = defineWellKnownSymbol$l; // `Symbol.search` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.search

  defineWellKnownSymbol$c('search');

  var defineWellKnownSymbol$b = defineWellKnownSymbol$l; // `Symbol.species` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.species

  defineWellKnownSymbol$b('species');

  var defineWellKnownSymbol$a = defineWellKnownSymbol$l; // `Symbol.split` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.split

  defineWellKnownSymbol$a('split');

  var defineWellKnownSymbol$9 = defineWellKnownSymbol$l; // `Symbol.toPrimitive` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.toprimitive

  defineWellKnownSymbol$9('toPrimitive');

  var defineWellKnownSymbol$8 = defineWellKnownSymbol$l; // `Symbol.toStringTag` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.tostringtag

  defineWellKnownSymbol$8('toStringTag');

  var defineWellKnownSymbol$7 = defineWellKnownSymbol$l; // `Symbol.unscopables` well-known symbol
  // https://tc39.es/ecma262/#sec-symbol.unscopables

  defineWellKnownSymbol$7('unscopables');

  var global$d = global$M;
  var setToStringTag$1 = setToStringTag$5; // JSON[@@toStringTag] property
  // https://tc39.es/ecma262/#sec-json-@@tostringtag

  setToStringTag$1(global$d.JSON, 'JSON', true);

  var path$e = path$q;
  var symbol$5 = path$e.Symbol;

  var parent$C = symbol$5;
  var symbol$4 = parent$C;

  var parent$B = symbol$4;
  var symbol$3 = parent$B;

  var defineWellKnownSymbol$6 = defineWellKnownSymbol$l; // `Symbol.asyncDispose` well-known symbol
  // https://github.com/tc39/proposal-using-statement

  defineWellKnownSymbol$6('asyncDispose');

  var defineWellKnownSymbol$5 = defineWellKnownSymbol$l; // `Symbol.dispose` well-known symbol
  // https://github.com/tc39/proposal-using-statement

  defineWellKnownSymbol$5('dispose');

  var defineWellKnownSymbol$4 = defineWellKnownSymbol$l; // `Symbol.matcher` well-known symbol
  // https://github.com/tc39/proposal-pattern-matching

  defineWellKnownSymbol$4('matcher');

  var defineWellKnownSymbol$3 = defineWellKnownSymbol$l; // `Symbol.metadata` well-known symbol
  // https://github.com/tc39/proposal-decorators

  defineWellKnownSymbol$3('metadata');

  var defineWellKnownSymbol$2 = defineWellKnownSymbol$l; // `Symbol.observable` well-known symbol
  // https://github.com/tc39/proposal-observable

  defineWellKnownSymbol$2('observable');

  var defineWellKnownSymbol$1 = defineWellKnownSymbol$l; // `Symbol.patternMatch` well-known symbol
  // https://github.com/tc39/proposal-pattern-matching

  defineWellKnownSymbol$1('patternMatch');

  var defineWellKnownSymbol = defineWellKnownSymbol$l;
  defineWellKnownSymbol('replaceAll');

  var parent$A = symbol$3; // TODO: Remove from `core-js@4`
  // TODO: Remove from `core-js@4`

  var symbol$2 = parent$A;

  var symbol$1 = symbol$2;

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof symbol$1 !== "undefined" && getIteratorMethod$1(arr) || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  var $$o = _export;
  var global$c = global$M;
  var isArray$2 = isArray$d;
  var isConstructor$1 = isConstructor$4;
  var isObject$5 = isObject$f;
  var toAbsoluteIndex$2 = toAbsoluteIndex$5;
  var lengthOfArrayLike$4 = lengthOfArrayLike$d;
  var toIndexedObject$1 = toIndexedObject$b;
  var createProperty$1 = createProperty$6;
  var wellKnownSymbol$3 = wellKnownSymbol$j;
  var arrayMethodHasSpeciesSupport$1 = arrayMethodHasSpeciesSupport$5;
  var un$Slice = arraySlice$5;
  var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$1('slice');
  var SPECIES$1 = wellKnownSymbol$3('species');
  var Array$2 = global$c.Array;
  var max$1 = Math.max; // `Array.prototype.slice` method
  // https://tc39.es/ecma262/#sec-array.prototype.slice
  // fallback for not array-like ES3 strings and DOM objects

  $$o({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT$1
  }, {
    slice: function slice(start, end) {
      var O = toIndexedObject$1(this);
      var length = lengthOfArrayLike$4(O);
      var k = toAbsoluteIndex$2(start, length);
      var fin = toAbsoluteIndex$2(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible

      var Constructor, result, n;

      if (isArray$2(O)) {
        Constructor = O.constructor; // cross-realm fallback

        if (isConstructor$1(Constructor) && (Constructor === Array$2 || isArray$2(Constructor.prototype))) {
          Constructor = undefined;
        } else if (isObject$5(Constructor)) {
          Constructor = Constructor[SPECIES$1];
          if (Constructor === null) Constructor = undefined;
        }

        if (Constructor === Array$2 || Constructor === undefined) {
          return un$Slice(O, k, fin);
        }
      }

      result = new (Constructor === undefined ? Array$2 : Constructor)(max$1(fin - k, 0));

      for (n = 0; k < fin; k++, n++) if (k in O) createProperty$1(result, n, O[k]);

      result.length = n;
      return result;
    }
  });

  var entryVirtual$e = entryVirtual$k;
  var slice$6 = entryVirtual$e('Array').slice;

  var isPrototypeOf$b = objectIsPrototypeOf;
  var method$9 = slice$6;
  var ArrayPrototype$9 = Array.prototype;

  var slice$5 = function (it) {
    var own = it.slice;
    return it === ArrayPrototype$9 || isPrototypeOf$b(ArrayPrototype$9, it) && own === ArrayPrototype$9.slice ? method$9 : own;
  };

  var parent$z = slice$5;
  var slice$4 = parent$z;

  var parent$y = slice$4;
  var slice$3 = parent$y;

  var parent$x = slice$3;
  var slice$2 = parent$x;

  var slice$1 = slice$2;

  var parent$w = from$4;
  var from$2 = parent$w;

  var parent$v = from$2;
  var from$1 = parent$v;

  var from = from$1;

  function _arrayLikeToArray$4(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _unsupportedIterableToArray$4(o, minLen) {
    var _context;

    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);

    var n = slice$1(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);

    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$4(arr, i) || _nonIterableRest();
  }

  var WrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
  var iterator$5 = WrappedWellKnownSymbolModule.f('iterator');

  var parent$u = iterator$5;
  var iterator$4 = parent$u;

  var parent$t = iterator$4;
  var iterator$3 = parent$t;

  var parent$s = iterator$3;
  var iterator$2 = parent$s;

  var iterator$1 = iterator$2;

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof symbol$1 && "symbol" == typeof iterator$1 ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof symbol$1 && obj.constructor === symbol$1 && obj !== symbol$1.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function _arrayWithoutHoles(arr) {
    if (isArray$4(arr)) return _arrayLikeToArray$4(arr);
  }

  function _iterableToArray(iter) {
    if (typeof symbol$1 !== "undefined" && getIteratorMethod$1(iter) != null || iter["@@iterator"] != null) return from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread();
  }

  var symbol = symbol$4;

  var entryVirtual$d = entryVirtual$k;
  var concat$4 = entryVirtual$d('Array').concat;

  var isPrototypeOf$a = objectIsPrototypeOf;
  var method$8 = concat$4;
  var ArrayPrototype$8 = Array.prototype;

  var concat$3 = function (it) {
    var own = it.concat;
    return it === ArrayPrototype$8 || isPrototypeOf$a(ArrayPrototype$8, it) && own === ArrayPrototype$8.concat ? method$8 : own;
  };

  var parent$r = concat$3;
  var concat$2 = parent$r;

  var concat$1 = concat$2;

  var slice = slice$4;

  var $$n = _export;
  var ownKeys$4 = ownKeys$6; // `Reflect.ownKeys` method
  // https://tc39.es/ecma262/#sec-reflect.ownkeys

  $$n({
    target: 'Reflect',
    stat: true
  }, {
    ownKeys: ownKeys$4
  });

  var path$d = path$q;
  var ownKeys$3 = path$d.Reflect.ownKeys;

  var parent$q = ownKeys$3;
  var ownKeys$2 = parent$q;

  var ownKeys$1 = ownKeys$2;

  var isArray$1 = isArray$7;

  var $$m = _export;
  var toObject$5 = toObject$e;
  var nativeKeys = objectKeys$4;
  var fails$b = fails$r;
  var FAILS_ON_PRIMITIVES$2 = fails$b(function () {
    nativeKeys(1);
  }); // `Object.keys` method
  // https://tc39.es/ecma262/#sec-object.keys

  $$m({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES$2
  }, {
    keys: function keys(it) {
      return nativeKeys(toObject$5(it));
    }
  });

  var path$c = path$q;
  var keys$6 = path$c.Object.keys;

  var parent$p = keys$6;
  var keys$5 = parent$p;

  var keys$4 = keys$5;

  var $$l = _export;
  var global$b = global$M;
  var uncurryThis$a = functionUncurryThis;
  var Date$1 = global$b.Date;
  var getTime = uncurryThis$a(Date$1.prototype.getTime); // `Date.now` method
  // https://tc39.es/ecma262/#sec-date.now

  $$l({
    target: 'Date',
    stat: true
  }, {
    now: function now() {
      return getTime(new Date$1());
    }
  });

  var path$b = path$q;
  path$b.Date.now;

  var $forEach = arrayIteration.forEach;
  var arrayMethodIsStrict$3 = arrayMethodIsStrict$5;
  var STRICT_METHOD$3 = arrayMethodIsStrict$3('forEach'); // `Array.prototype.forEach` method implementation
  // https://tc39.es/ecma262/#sec-array.prototype.foreach

  var arrayForEach = !STRICT_METHOD$3 ? function forEach(callbackfn
  /* , thisArg */
  ) {
    return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); // eslint-disable-next-line es/no-array-prototype-foreach -- safe
  } : [].forEach;

  var $$k = _export;
  var forEach$5 = arrayForEach; // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  // eslint-disable-next-line es/no-array-prototype-foreach -- safe

  $$k({
    target: 'Array',
    proto: true,
    forced: [].forEach != forEach$5
  }, {
    forEach: forEach$5
  });

  var entryVirtual$c = entryVirtual$k;
  var forEach$4 = entryVirtual$c('Array').forEach;

  var parent$o = forEach$4;
  var forEach$3 = parent$o;

  var classof$5 = classof$c;
  var hasOwn$4 = hasOwnProperty_1;
  var isPrototypeOf$9 = objectIsPrototypeOf;
  var method$7 = forEach$3;
  var ArrayPrototype$7 = Array.prototype;
  var DOMIterables$3 = {
    DOMTokenList: true,
    NodeList: true
  };

  var forEach$2 = function (it) {
    var own = it.forEach;
    return it === ArrayPrototype$7 || isPrototypeOf$9(ArrayPrototype$7, it) && own === ArrayPrototype$7.forEach || hasOwn$4(DOMIterables$3, classof$5(it)) ? method$7 : own;
  };

  var forEach$1 = forEach$2;

  var $$j = _export;
  var uncurryThis$9 = functionUncurryThis;
  var isArray = isArray$d;
  var un$Reverse = uncurryThis$9([].reverse);
  var test$1 = [1, 2]; // `Array.prototype.reverse` method
  // https://tc39.es/ecma262/#sec-array.prototype.reverse
  // fix for Safari 12.0 bug
  // https://bugs.webkit.org/show_bug.cgi?id=188794

  $$j({
    target: 'Array',
    proto: true,
    forced: String(test$1) === String(test$1.reverse())
  }, {
    reverse: function reverse() {
      // eslint-disable-next-line no-self-assign -- dirty hack
      if (isArray(this)) this.length = this.length;
      return un$Reverse(this);
    }
  });

  var entryVirtual$b = entryVirtual$k;
  var reverse$3 = entryVirtual$b('Array').reverse;

  var isPrototypeOf$8 = objectIsPrototypeOf;
  var method$6 = reverse$3;
  var ArrayPrototype$6 = Array.prototype;

  var reverse$2 = function (it) {
    var own = it.reverse;
    return it === ArrayPrototype$6 || isPrototypeOf$8(ArrayPrototype$6, it) && own === ArrayPrototype$6.reverse ? method$6 : own;
  };

  var parent$n = reverse$2;
  var reverse$1 = parent$n;

  var reverse = reverse$1;

  var $$i = _export;
  var global$a = global$M;
  var toAbsoluteIndex$1 = toAbsoluteIndex$5;
  var toIntegerOrInfinity = toIntegerOrInfinity$4;
  var lengthOfArrayLike$3 = lengthOfArrayLike$d;
  var toObject$4 = toObject$e;
  var arraySpeciesCreate = arraySpeciesCreate$4;
  var createProperty = createProperty$6;
  var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$5;
  var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
  var TypeError$6 = global$a.TypeError;
  var max = Math.max;
  var min = Math.min;
  var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
  var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method
  // https://tc39.es/ecma262/#sec-array.prototype.splice
  // with adding support of @@species

  $$i({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT
  }, {
    splice: function splice(start, deleteCount
    /* , ...items */
    ) {
      var O = toObject$4(this);
      var len = lengthOfArrayLike$3(O);
      var actualStart = toAbsoluteIndex$1(start, len);
      var argumentsLength = arguments.length;
      var insertCount, actualDeleteCount, A, k, from, to;

      if (argumentsLength === 0) {
        insertCount = actualDeleteCount = 0;
      } else if (argumentsLength === 1) {
        insertCount = 0;
        actualDeleteCount = len - actualStart;
      } else {
        insertCount = argumentsLength - 2;
        actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
      }

      if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
        throw TypeError$6(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
      }

      A = arraySpeciesCreate(O, actualDeleteCount);

      for (k = 0; k < actualDeleteCount; k++) {
        from = actualStart + k;
        if (from in O) createProperty(A, k, O[from]);
      }

      A.length = actualDeleteCount;

      if (insertCount < actualDeleteCount) {
        for (k = actualStart; k < len - actualDeleteCount; k++) {
          from = k + actualDeleteCount;
          to = k + insertCount;
          if (from in O) O[to] = O[from];else delete O[to];
        }

        for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
      } else if (insertCount > actualDeleteCount) {
        for (k = len - actualDeleteCount; k > actualStart; k--) {
          from = k + actualDeleteCount - 1;
          to = k + insertCount - 1;
          if (from in O) O[to] = O[from];else delete O[to];
        }
      }

      for (k = 0; k < insertCount; k++) {
        O[k + actualStart] = arguments[k + 2];
      }

      O.length = len - actualDeleteCount + insertCount;
      return A;
    }
  });

  var entryVirtual$a = entryVirtual$k;
  var splice$3 = entryVirtual$a('Array').splice;

  var isPrototypeOf$7 = objectIsPrototypeOf;
  var method$5 = splice$3;
  var ArrayPrototype$5 = Array.prototype;

  var splice$2 = function (it) {
    var own = it.splice;
    return it === ArrayPrototype$5 || isPrototypeOf$7(ArrayPrototype$5, it) && own === ArrayPrototype$5.splice ? method$5 : own;
  };

  var parent$m = splice$2;
  var splice$1 = parent$m;

  var splice = splice$1;

  var DESCRIPTORS$5 = descriptors;
  var uncurryThis$8 = functionUncurryThis;
  var call$1 = functionCall;
  var fails$a = fails$r;
  var objectKeys$1 = objectKeys$4;
  var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
  var propertyIsEnumerableModule = objectPropertyIsEnumerable;
  var toObject$3 = toObject$e;
  var IndexedObject = indexedObject; // eslint-disable-next-line es/no-object-assign -- safe

  var $assign = Object.assign; // eslint-disable-next-line es/no-object-defineproperty -- required for testing

  var defineProperty$3 = Object.defineProperty;
  var concat = uncurryThis$8([].concat); // `Object.assign` method
  // https://tc39.es/ecma262/#sec-object.assign

  var objectAssign = !$assign || fails$a(function () {
    // should have correct order of operations (Edge bug)
    if (DESCRIPTORS$5 && $assign({
      b: 1
    }, $assign(defineProperty$3({}, 'a', {
      enumerable: true,
      get: function () {
        defineProperty$3(this, 'b', {
          value: 3,
          enumerable: false
        });
      }
    }), {
      b: 2
    })).b !== 1) return true; // should work with symbols and should have deterministic property order (V8 bug)

    var A = {};
    var B = {}; // eslint-disable-next-line es/no-symbol -- safe

    var symbol = Symbol();
    var alphabet = 'abcdefghijklmnopqrst';
    A[symbol] = 7;
    alphabet.split('').forEach(function (chr) {
      B[chr] = chr;
    });
    return $assign({}, A)[symbol] != 7 || objectKeys$1($assign({}, B)).join('') != alphabet;
  }) ? function assign(target, source) {
    // eslint-disable-line no-unused-vars -- required for `.length`
    var T = toObject$3(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    var propertyIsEnumerable = propertyIsEnumerableModule.f;

    while (argumentsLength > index) {
      var S = IndexedObject(arguments[index++]);
      var keys = getOwnPropertySymbols ? concat(objectKeys$1(S), getOwnPropertySymbols(S)) : objectKeys$1(S);
      var length = keys.length;
      var j = 0;
      var key;

      while (length > j) {
        key = keys[j++];
        if (!DESCRIPTORS$5 || call$1(propertyIsEnumerable, S, key)) T[key] = S[key];
      }
    }

    return T;
  } : $assign;

  var $$h = _export;
  var assign$5 = objectAssign; // `Object.assign` method
  // https://tc39.es/ecma262/#sec-object.assign
  // eslint-disable-next-line es/no-object-assign -- required for testing

  $$h({
    target: 'Object',
    stat: true,
    forced: Object.assign !== assign$5
  }, {
    assign: assign$5
  });

  var path$a = path$q;
  var assign$4 = path$a.Object.assign;

  var parent$l = assign$4;
  var assign$3 = parent$l;

  var assign$2 = assign$3;

  var $$g = _export;
  var $includes = arrayIncludes.includes;
  // https://tc39.es/ecma262/#sec-array.prototype.includes

  $$g({
    target: 'Array',
    proto: true
  }, {
    includes: function includes(el
    /* , fromIndex = 0 */
    ) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }
  }); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

  var entryVirtual$9 = entryVirtual$k;
  entryVirtual$9('Array').includes;

  var isObject$4 = isObject$f;
  var classof$4 = classofRaw$1;
  var wellKnownSymbol$2 = wellKnownSymbol$j;
  var MATCH$1 = wellKnownSymbol$2('match'); // `IsRegExp` abstract operation
  // https://tc39.es/ecma262/#sec-isregexp

  var isRegexp = function (it) {
    var isRegExp;
    return isObject$4(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$4(it) == 'RegExp');
  };

  var global$9 = global$M;
  var isRegExp = isRegexp;
  var TypeError$5 = global$9.TypeError;

  var notARegexp = function (it) {
    if (isRegExp(it)) {
      throw TypeError$5("The method doesn't accept regular expressions");
    }

    return it;
  };

  var wellKnownSymbol$1 = wellKnownSymbol$j;
  var MATCH = wellKnownSymbol$1('match');

  var correctIsRegexpLogic = function (METHOD_NAME) {
    var regexp = /./;

    try {
      '/./'[METHOD_NAME](regexp);
    } catch (error1) {
      try {
        regexp[MATCH] = false;
        return '/./'[METHOD_NAME](regexp);
      } catch (error2) {
        /* empty */
      }
    }

    return false;
  };

  var $$f = _export;
  var uncurryThis$7 = functionUncurryThis;
  var notARegExp = notARegexp;
  var requireObjectCoercible$1 = requireObjectCoercible$5;
  var toString$3 = toString$7;
  var correctIsRegExpLogic = correctIsRegexpLogic;
  var stringIndexOf = uncurryThis$7(''.indexOf); // `String.prototype.includes` method
  // https://tc39.es/ecma262/#sec-string.prototype.includes

  $$f({
    target: 'String',
    proto: true,
    forced: !correctIsRegExpLogic('includes')
  }, {
    includes: function includes(searchString
    /* , position = 0 */
    ) {
      return !!~stringIndexOf(toString$3(requireObjectCoercible$1(this)), toString$3(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var entryVirtual$8 = entryVirtual$k;
  entryVirtual$8('String').includes;

  var $$e = _export;
  var fails$9 = fails$r;
  var toObject$2 = toObject$e;
  var nativeGetPrototypeOf = objectGetPrototypeOf;
  var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
  var FAILS_ON_PRIMITIVES$1 = fails$9(function () {
    nativeGetPrototypeOf(1);
  }); // `Object.getPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.getprototypeof

  $$e({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES$1,
    sham: !CORRECT_PROTOTYPE_GETTER
  }, {
    getPrototypeOf: function getPrototypeOf(it) {
      return nativeGetPrototypeOf(toObject$2(it));
    }
  });

  var path$9 = path$q;
  var getPrototypeOf$4 = path$9.Object.getPrototypeOf;

  var parent$k = getPrototypeOf$4;
  var getPrototypeOf$3 = parent$k;

  var DESCRIPTORS$4 = descriptors;
  var uncurryThis$6 = functionUncurryThis;
  var objectKeys = objectKeys$4;
  var toIndexedObject = toIndexedObject$b;
  var $propertyIsEnumerable = objectPropertyIsEnumerable.f;
  var propertyIsEnumerable = uncurryThis$6($propertyIsEnumerable);
  var push$2 = uncurryThis$6([].push); // `Object.{ entries, values }` methods implementation

  var createMethod$1 = function (TO_ENTRIES) {
    return function (it) {
      var O = toIndexedObject(it);
      var keys = objectKeys(O);
      var length = keys.length;
      var i = 0;
      var result = [];
      var key;

      while (length > i) {
        key = keys[i++];

        if (!DESCRIPTORS$4 || propertyIsEnumerable(O, key)) {
          push$2(result, TO_ENTRIES ? [key, O[key]] : O[key]);
        }
      }

      return result;
    };
  };

  var objectToArray = {
    // `Object.entries` method
    // https://tc39.es/ecma262/#sec-object.entries
    entries: createMethod$1(true),
    // `Object.values` method
    // https://tc39.es/ecma262/#sec-object.values
    values: createMethod$1(false)
  };

  var $$d = _export;
  var $values = objectToArray.values; // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values

  $$d({
    target: 'Object',
    stat: true
  }, {
    values: function values(O) {
      return $values(O);
    }
  });

  var path$8 = path$q;
  path$8.Object.values;

  var whitespaces$3 = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' + '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

  var uncurryThis$5 = functionUncurryThis;
  var requireObjectCoercible = requireObjectCoercible$5;
  var toString$2 = toString$7;
  var whitespaces$2 = whitespaces$3;
  var replace$1 = uncurryThis$5(''.replace);
  var whitespace = '[' + whitespaces$2 + ']';
  var ltrim = RegExp('^' + whitespace + whitespace + '*');
  var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

  var createMethod = function (TYPE) {
    return function ($this) {
      var string = toString$2(requireObjectCoercible($this));
      if (TYPE & 1) string = replace$1(string, ltrim, '');
      if (TYPE & 2) string = replace$1(string, rtrim, '');
      return string;
    };
  };

  var stringTrim = {
    // `String.prototype.{ trimLeft, trimStart }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimstart
    start: createMethod(1),
    // `String.prototype.{ trimRight, trimEnd }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimend
    end: createMethod(2),
    // `String.prototype.trim` method
    // https://tc39.es/ecma262/#sec-string.prototype.trim
    trim: createMethod(3)
  };

  var global$8 = global$M;
  var fails$8 = fails$r;
  var uncurryThis$4 = functionUncurryThis;
  var toString$1 = toString$7;
  var trim = stringTrim.trim;
  var whitespaces$1 = whitespaces$3;
  var $parseInt$1 = global$8.parseInt;
  var Symbol$1 = global$8.Symbol;
  var ITERATOR = Symbol$1 && Symbol$1.iterator;
  var hex = /^[+-]?0x/i;
  var exec$1 = uncurryThis$4(hex.exec);
  var FORCED$3 = $parseInt$1(whitespaces$1 + '08') !== 8 || $parseInt$1(whitespaces$1 + '0x16') !== 22 // MS Edge 18- broken with boxed symbols
  || ITERATOR && !fails$8(function () {
    $parseInt$1(Object(ITERATOR));
  }); // `parseInt` method
  // https://tc39.es/ecma262/#sec-parseint-string-radix

  var numberParseInt = FORCED$3 ? function parseInt(string, radix) {
    var S = trim(toString$1(string));
    return $parseInt$1(S, radix >>> 0 || (exec$1(hex, S) ? 16 : 10));
  } : $parseInt$1;

  var $$c = _export;
  var $parseInt = numberParseInt; // `parseInt` method
  // https://tc39.es/ecma262/#sec-parseint-string-radix

  $$c({
    global: true,
    forced: parseInt != $parseInt
  }, {
    parseInt: $parseInt
  });

  var path$7 = path$q;
  path$7.parseInt;

  /* eslint-disable es/no-array-prototype-indexof -- required for testing */


  var $$b = _export;
  var uncurryThis$3 = functionUncurryThis;
  var $IndexOf = arrayIncludes.indexOf;
  var arrayMethodIsStrict$2 = arrayMethodIsStrict$5;
  var un$IndexOf = uncurryThis$3([].indexOf);
  var NEGATIVE_ZERO = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;
  var STRICT_METHOD$2 = arrayMethodIsStrict$2('indexOf'); // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof

  $$b({
    target: 'Array',
    proto: true,
    forced: NEGATIVE_ZERO || !STRICT_METHOD$2
  }, {
    indexOf: function indexOf(searchElement
    /* , fromIndex = 0 */
    ) {
      var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
      return NEGATIVE_ZERO // convert -0 to +0
      ? un$IndexOf(this, searchElement, fromIndex) || 0 : $IndexOf(this, searchElement, fromIndex);
    }
  });

  var entryVirtual$7 = entryVirtual$k;
  entryVirtual$7('Array').indexOf;

  var PROPER_FUNCTION_NAME = functionName.PROPER;
  var fails$7 = fails$r;
  var whitespaces = whitespaces$3;
  var non = '\u200B\u0085\u180E'; // check that a method works with the correct list
  // of whitespaces and has a correct name

  var stringTrimForced = function (METHOD_NAME) {
    return fails$7(function () {
      return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
    });
  };

  var $$a = _export;
  var $trim = stringTrim.trim;
  var forcedStringTrimMethod = stringTrimForced; // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim

  $$a({
    target: 'String',
    proto: true,
    forced: forcedStringTrimMethod('trim')
  }, {
    trim: function trim() {
      return $trim(this);
    }
  });

  var entryVirtual$6 = entryVirtual$k;
  entryVirtual$6('String').trim;

  var $$9 = _export;
  var DESCRIPTORS$3 = descriptors;
  var create$8 = objectCreate; // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create

  $$9({
    target: 'Object',
    stat: true,
    sham: !DESCRIPTORS$3
  }, {
    create: create$8
  });

  var path$6 = path$q;
  var Object$1 = path$6.Object;

  var create$7 = function create(P, D) {
    return Object$1.create(P, D);
  };

  var parent$j = create$7;
  var create$6 = parent$j;

  var create$5 = create$6;

  var $$8 = _export;
  var global$7 = global$M;
  var getBuiltIn$2 = getBuiltIn$9;
  var apply$3 = functionApply;
  var uncurryThis$2 = functionUncurryThis;
  var fails$6 = fails$r;
  var Array$1 = global$7.Array;
  var $stringify = getBuiltIn$2('JSON', 'stringify');
  var exec = uncurryThis$2(/./.exec);
  var charAt = uncurryThis$2(''.charAt);
  var charCodeAt = uncurryThis$2(''.charCodeAt);
  var replace = uncurryThis$2(''.replace);
  var numberToString = uncurryThis$2(1.0.toString);
  var tester = /[\uD800-\uDFFF]/g;
  var low = /^[\uD800-\uDBFF]$/;
  var hi = /^[\uDC00-\uDFFF]$/;

  var fix = function (match, offset, string) {
    var prev = charAt(string, offset - 1);
    var next = charAt(string, offset + 1);

    if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
      return '\\u' + numberToString(charCodeAt(match, 0), 16);
    }

    return match;
  };

  var FORCED$2 = fails$6(function () {
    return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"' || $stringify('\uDEAD') !== '"\\udead"';
  });

  if ($stringify) {
    // `JSON.stringify` method
    // https://tc39.es/ecma262/#sec-json.stringify
    // https://github.com/tc39/proposal-well-formed-stringify
    $$8({
      target: 'JSON',
      stat: true,
      forced: FORCED$2
    }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      stringify: function stringify(it, replacer, space) {
        for (var i = 0, l = arguments.length, args = Array$1(l); i < l; i++) args[i] = arguments[i];

        var result = apply$3($stringify, null, args);
        return typeof result == 'string' ? replace(result, tester, fix) : result;
      }
    });
  }

  var path$5 = path$q;
  var apply$2 = functionApply; // eslint-disable-next-line es/no-json -- safe

  if (!path$5.JSON) path$5.JSON = {
    stringify: JSON.stringify
  }; // eslint-disable-next-line no-unused-vars -- required for `.length`

  var stringify$3 = function stringify(it, replacer, space) {
    return apply$2(path$5.JSON.stringify, null, arguments);
  };

  var parent$i = stringify$3;
  var stringify$2 = parent$i;

  var stringify$1 = stringify$2;

  var global$6 = global$M;
  var TypeError$4 = global$6.TypeError;

  var validateArgumentsLength$1 = function (passed, required) {
    if (passed < required) throw TypeError$4('Not enough arguments');
    return passed;
  };

  var $$7 = _export;
  var global$5 = global$M;
  var apply$1 = functionApply;
  var isCallable$1 = isCallable$h;
  var userAgent$2 = engineUserAgent;
  var arraySlice$1 = arraySlice$5;
  var validateArgumentsLength = validateArgumentsLength$1;
  var MSIE = /MSIE .\./.test(userAgent$2); // <- dirty ie9- check

  var Function$1 = global$5.Function;

  var wrap = function (scheduler) {
    return function (handler, timeout
    /* , ...arguments */
    ) {
      var boundArgs = validateArgumentsLength(arguments.length, 1) > 2;
      var fn = isCallable$1(handler) ? handler : Function$1(handler);
      var args = boundArgs ? arraySlice$1(arguments, 2) : undefined;
      return scheduler(boundArgs ? function () {
        apply$1(fn, this, args);
      } : fn, timeout);
    };
  }; // ie9- setTimeout & setInterval additional parameters fix
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers


  $$7({
    global: true,
    bind: true,
    forced: MSIE
  }, {
    // `setTimeout` method
    // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
    setTimeout: wrap(global$5.setTimeout),
    // `setInterval` method
    // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
    setInterval: wrap(global$5.setInterval)
  });

  var path$4 = path$q;
  var setTimeout$2 = path$4.setTimeout;

  var setTimeout$1 = setTimeout$2;

  var toObject$1 = toObject$e;
  var toAbsoluteIndex = toAbsoluteIndex$5;
  var lengthOfArrayLike$2 = lengthOfArrayLike$d; // `Array.prototype.fill` method implementation
  // https://tc39.es/ecma262/#sec-array.prototype.fill

  var arrayFill = function fill(value
  /* , start = 0, end = @length */
  ) {
    var O = toObject$1(this);
    var length = lengthOfArrayLike$2(O);
    var argumentsLength = arguments.length;
    var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
    var end = argumentsLength > 2 ? arguments[2] : undefined;
    var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

    while (endPos > index) O[index++] = value;

    return O;
  };

  var $$6 = _export;
  var fill = arrayFill;
  // https://tc39.es/ecma262/#sec-array.prototype.fill

  $$6({
    target: 'Array',
    proto: true
  }, {
    fill: fill
  }); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

  var entryVirtual$5 = entryVirtual$k;
  entryVirtual$5('Array').fill;

  var componentEmitter = {exports: {}};

  (function (module) {
    /**
     * Expose `Emitter`.
     */
    {
      module.exports = Emitter;
    }
    /**
     * Initialize a new `Emitter`.
     *
     * @api public
     */


    function Emitter(obj) {
      if (obj) return mixin(obj);
    }
    /**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */

    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }

      return obj;
    }
    /**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */


    Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
      return this;
    };
    /**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */


    Emitter.prototype.once = function (event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }

      on.fn = fn;
      this.on(event, on);
      return this;
    };
    /**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */


    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
      this._callbacks = this._callbacks || {}; // all

      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      } // specific event


      var callbacks = this._callbacks['$' + event];
      if (!callbacks) return this; // remove all handlers

      if (1 == arguments.length) {
        delete this._callbacks['$' + event];
        return this;
      } // remove specific handler


      var cb;

      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];

        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      } // Remove event specific arrays for event types that no
      // one is subscribed for to avoid memory leak.


      if (callbacks.length === 0) {
        delete this._callbacks['$' + event];
      }

      return this;
    };
    /**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */


    Emitter.prototype.emit = function (event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1),
          callbacks = this._callbacks['$' + event];

      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }

      if (callbacks) {
        callbacks = callbacks.slice(0);

        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }

      return this;
    };
    /**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */


    Emitter.prototype.listeners = function (event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks['$' + event] || [];
    };
    /**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */


    Emitter.prototype.hasListeners = function (event) {
      return !!this.listeners(event).length;
    };
  })(componentEmitter);

  var Emitter = componentEmitter.exports;

  /*! Hammer.JS - v2.0.17-rc - 2019-12-16
   * http://naver.github.io/egjs
   *
   * Forked By Naver egjs
   * Copyright (c) hammerjs
   * Licensed under the MIT license */
  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _assertThisInitialized$1(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }
  /**
   * @private
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} target
   * @param {...Object} objects_to_assign
   * @returns {Object} target
   */


  var assign;

  if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var output = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];

        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (source.hasOwnProperty(nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }

      return output;
    };
  } else {
    assign = Object.assign;
  }

  var assign$1 = assign;
  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = typeof document === "undefined" ? {
    style: {}
  } : document.createElement('div');
  var TYPE_FUNCTION = 'function';
  var round = Math.round,
      abs = Math.abs;
  var now = Date.now;
  /**
   * @private
   * get the prefixed property
   * @param {Object} obj
   * @param {String} property
   * @returns {String|Undefined} prefixed
   */

  function prefixed(obj, property) {
    var prefix;
    var prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);
    var i = 0;

    while (i < VENDOR_PREFIXES.length) {
      prefix = VENDOR_PREFIXES[i];
      prop = prefix ? prefix + camelProp : property;

      if (prop in obj) {
        return prop;
      }

      i++;
    }

    return undefined;
  }
  /* eslint-disable no-new-func, no-nested-ternary */


  var win;

  if (typeof window === "undefined") {
    // window is undefined in node.js
    win = {};
  } else {
    win = window;
  }

  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

  function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
      return false;
    }

    var touchMap = {};
    var cssSupports = win.CSS && win.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
      // If css.supports is not supported but there is native touch-action assume it supports
      // all values. This is the case for IE 10 and 11.
      return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
  }

  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented

  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';
  var TOUCH_ACTION_MAP = getTouchActionProps();
  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
  var SUPPORT_TOUCH = ('ontouchstart' in win);
  var SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';
  var COMPUTE_INTERVAL = 25;
  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;
  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;
  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];
  /**
   * @private
   * walk objects and arrays
   * @param {Object} obj
   * @param {Function} iterator
   * @param {Object} context
   */

  function each(obj, iterator, context) {
    var i;

    if (!obj) {
      return;
    }

    if (obj.forEach) {
      obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
      i = 0;

      while (i < obj.length) {
        iterator.call(context, obj[i], i, obj);
        i++;
      }
    } else {
      for (i in obj) {
        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
      }
    }
  }
  /**
   * @private
   * let a boolean value also be a function that must return a boolean
   * this first item in args will be used as the context
   * @param {Boolean|Function} val
   * @param {Array} [args]
   * @returns {Boolean}
   */


  function boolOrFn(val, args) {
    if (typeof val === TYPE_FUNCTION) {
      return val.apply(args ? args[0] || undefined : undefined, args);
    }

    return val;
  }
  /**
   * @private
   * small indexOf wrapper
   * @param {String} str
   * @param {String} find
   * @returns {Boolean} found
   */


  function inStr(str, find) {
    return str.indexOf(find) > -1;
  }
  /**
   * @private
   * when the touchActions are collected they are not a valid value, so we need to clean things up. *
   * @param {String} actions
   * @returns {*}
   */


  function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
      return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning

    if (hasPanX && hasPanY) {
      return TOUCH_ACTION_NONE;
    } // pan-x OR pan-y


    if (hasPanX || hasPanY) {
      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    } // manipulation


    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
      return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
  }
  /**
   * @private
   * Touch Action
   * sets the touchAction property or uses the js alternative
   * @param {Manager} manager
   * @param {String} value
   * @constructor
   */


  var TouchAction = /*#__PURE__*/function () {
    function TouchAction(manager, value) {
      this.manager = manager;
      this.set(value);
    }
    /**
     * @private
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */


    var _proto = TouchAction.prototype;

    _proto.set = function set(value) {
      // find out the touch-action by the event handlers
      if (value === TOUCH_ACTION_COMPUTE) {
        value = this.compute();
      }

      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
      }

      this.actions = value.toLowerCase().trim();
    };
    /**
     * @private
     * just re-set the touchAction value
     */


    _proto.update = function update() {
      this.set(this.manager.options.touchAction);
    };
    /**
     * @private
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */


    _proto.compute = function compute() {
      var actions = [];
      each(this.manager.recognizers, function (recognizer) {
        if (boolOrFn(recognizer.options.enable, [recognizer])) {
          actions = actions.concat(recognizer.getTouchAction());
        }
      });
      return cleanTouchActions(actions.join(' '));
    };
    /**
     * @private
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */


    _proto.preventDefaults = function preventDefaults(input) {
      var srcEvent = input.srcEvent;
      var direction = input.offsetDirection; // if the touch action did prevented once this session

      if (this.manager.session.prevented) {
        srcEvent.preventDefault();
        return;
      }

      var actions = this.actions;
      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

      if (hasNone) {
        // do not prevent defaults if this is a tap gesture
        var isTapPointer = input.pointers.length === 1;
        var isTapMovement = input.distance < 2;
        var isTapTouchTime = input.deltaTime < 250;

        if (isTapPointer && isTapMovement && isTapTouchTime) {
          return;
        }
      }

      if (hasPanX && hasPanY) {
        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
        return;
      }

      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
        return this.preventSrc(srcEvent);
      }
    };
    /**
     * @private
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */


    _proto.preventSrc = function preventSrc(srcEvent) {
      this.manager.session.prevented = true;
      srcEvent.preventDefault();
    };

    return TouchAction;
  }();
  /**
   * @private
   * find if a node is in the given parent
   * @method hasParent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */


  function hasParent(node, parent) {
    while (node) {
      if (node === parent) {
        return true;
      }

      node = node.parentNode;
    }

    return false;
  }
  /**
   * @private
   * get the center of all the pointers
   * @param {Array} pointers
   * @return {Object} center contains `x` and `y` properties
   */


  function getCenter(pointers) {
    var pointersLength = pointers.length; // no need to loop when only one touch

    if (pointersLength === 1) {
      return {
        x: round(pointers[0].clientX),
        y: round(pointers[0].clientY)
      };
    }

    var x = 0;
    var y = 0;
    var i = 0;

    while (i < pointersLength) {
      x += pointers[i].clientX;
      y += pointers[i].clientY;
      i++;
    }

    return {
      x: round(x / pointersLength),
      y: round(y / pointersLength)
    };
  }
  /**
   * @private
   * create a simple clone from the input used for storage of firstInput and firstMultiple
   * @param {Object} input
   * @returns {Object} clonedInputData
   */


  function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;

    while (i < input.pointers.length) {
      pointers[i] = {
        clientX: round(input.pointers[i].clientX),
        clientY: round(input.pointers[i].clientY)
      };
      i++;
    }

    return {
      timeStamp: now(),
      pointers: pointers,
      center: getCenter(pointers),
      deltaX: input.deltaX,
      deltaY: input.deltaY
    };
  }
  /**
   * @private
   * calculate the absolute distance between two points
   * @param {Object} p1 {x, y}
   * @param {Object} p2 {x, y}
   * @param {Array} [props] containing x and y keys
   * @return {Number} distance
   */


  function getDistance(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }

    var x = p2[props[0]] - p1[props[0]];
    var y = p2[props[1]] - p1[props[1]];
    return Math.sqrt(x * x + y * y);
  }
  /**
   * @private
   * calculate the angle between two coordinates
   * @param {Object} p1
   * @param {Object} p2
   * @param {Array} [props] containing x and y keys
   * @return {Number} angle
   */


  function getAngle(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }

    var x = p2[props[0]] - p1[props[0]];
    var y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
  }
  /**
   * @private
   * get the direction between two points
   * @param {Number} x
   * @param {Number} y
   * @return {Number} direction
   */


  function getDirection(x, y) {
    if (x === y) {
      return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }

    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }

  function computeDeltaXY(session, input) {
    var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;
    // jscs throwing error on defalut destructured values and without defaults tests fail

    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
      prevDelta = session.prevDelta = {
        x: prevInput.deltaX || 0,
        y: prevInput.deltaY || 0
      };
      offset = session.offsetDelta = {
        x: center.x,
        y: center.y
      };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
  }
  /**
   * @private
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} x
   * @param {Number} y
   * @return {Object} velocity `x` and `y`
   */


  function getVelocity(deltaTime, x, y) {
    return {
      x: x / deltaTime || 0,
      y: y / deltaTime || 0
    };
  }
  /**
   * @private
   * calculate the scale factor between two pointersets
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} scale
   */


  function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }
  /**
   * @private
   * calculate the rotation degrees between two pointersets
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} rotation
   */


  function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }
  /**
   * @private
   * velocity is calculated every x ms
   * @param {Object} session
   * @param {Object} input
   */


  function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input;
    var deltaTime = input.timeStamp - last.timeStamp;
    var velocity;
    var velocityX;
    var velocityY;
    var direction;

    if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
      var deltaX = input.deltaX - last.deltaX;
      var deltaY = input.deltaY - last.deltaY;
      var v = getVelocity(deltaTime, deltaX, deltaY);
      velocityX = v.x;
      velocityY = v.y;
      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
      direction = getDirection(deltaX, deltaY);
      session.lastInterval = input;
    } else {
      // use latest velocity info if it doesn't overtake a minimum period
      velocity = last.velocity;
      velocityX = last.velocityX;
      velocityY = last.velocityY;
      direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
  }
  /**
  * @private
   * extend the data with some usable properties like scale, rotate, velocity etc
   * @param {Object} manager
   * @param {Object} input
   */


  function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length; // store the first input to calculate the distance and direction

    if (!session.firstInput) {
      session.firstInput = simpleCloneInputData(input);
    } // to compute scale and rotation we need to store the multiple touches


    if (pointersLength > 1 && !session.firstMultiple) {
      session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
      session.firstMultiple = false;
    }

    var firstInput = session.firstInput,
        firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;
    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);
    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);
    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
    computeIntervalInputData(session, input); // find the correct target

    var target = manager.element;
    var srcEvent = input.srcEvent;
    var srcEventTarget;

    if (srcEvent.composedPath) {
      srcEventTarget = srcEvent.composedPath()[0];
    } else if (srcEvent.path) {
      srcEventTarget = srcEvent.path[0];
    } else {
      srcEventTarget = srcEvent.target;
    }

    if (hasParent(srcEventTarget, target)) {
      target = srcEventTarget;
    }

    input.target = target;
  }
  /**
   * @private
   * handle input events
   * @param {Manager} manager
   * @param {String} eventType
   * @param {Object} input
   */


  function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
      manager.session = {};
    } // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'


    input.eventType = eventType; // compute scale, rotation etc

    computeInputData(manager, input); // emit secret event

    manager.emit('hammer.input', input);
    manager.recognize(input);
    manager.session.prevInput = input;
  }
  /**
   * @private
   * split string on whitespace
   * @param {String} str
   * @returns {Array} words
   */


  function splitStr(str) {
    return str.trim().split(/\s+/g);
  }
  /**
   * @private
   * addEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */


  function addEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.addEventListener(type, handler, false);
    });
  }
  /**
   * @private
   * removeEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */


  function removeEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.removeEventListener(type, handler, false);
    });
  }
  /**
   * @private
   * get the window object of an element
   * @param {HTMLElement} element
   * @returns {DocumentView|Window}
   */


  function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return doc.defaultView || doc.parentWindow || window;
  }
  /**
   * @private
   * create new input type manager
   * @param {Manager} manager
   * @param {Function} callback
   * @returns {Input}
   * @constructor
   */


  var Input = /*#__PURE__*/function () {
    function Input(manager, callback) {
      var self = this;
      this.manager = manager;
      this.callback = callback;
      this.element = manager.element;
      this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,
      // so when disabled the input events are completely bypassed.

      this.domHandler = function (ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
          self.handler(ev);
        }
      };

      this.init();
    }
    /**
     * @private
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */


    var _proto = Input.prototype;

    _proto.handler = function handler() {};
    /**
     * @private
     * bind the events
     */


    _proto.init = function init() {
      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    };
    /**
     * @private
     * unbind the events
     */


    _proto.destroy = function destroy() {
      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    };

    return Input;
  }();
  /**
   * @private
   * find if a array contains the object using indexOf or a simple polyFill
   * @param {Array} src
   * @param {String} find
   * @param {String} [findByKey]
   * @return {Boolean|Number} false when not found, or the index
   */


  function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
      return src.indexOf(find);
    } else {
      var i = 0;

      while (i < src.length) {
        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
          // do not use === here, test fails
          return i;
        }

        i++;
      }

      return -1;
    }
  }

  var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
  }; // in IE10 the pointer types is defined as an enum

  var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816

  };
  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive

  if (win.MSPointerEvent && !win.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }
  /**
   * @private
   * Pointer events input
   * @constructor
   * @extends Input
   */


  var PointerEventInput = /*#__PURE__*/function (_Input) {
    _inheritsLoose(PointerEventInput, _Input);

    function PointerEventInput() {
      var _this;

      var proto = PointerEventInput.prototype;
      proto.evEl = POINTER_ELEMENT_EVENTS;
      proto.evWin = POINTER_WINDOW_EVENTS;
      _this = _Input.apply(this, arguments) || this;
      _this.store = _this.manager.session.pointerEvents = [];
      return _this;
    }
    /**
     * @private
     * handle mouse events
     * @param {Object} ev
     */


    var _proto = PointerEventInput.prototype;

    _proto.handler = function handler(ev) {
      var store = this.store;
      var removePointer = false;
      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
      var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store

      var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down

      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
        if (storeIndex < 0) {
          store.push(ev);
          storeIndex = store.length - 1;
        }
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        removePointer = true;
      } // it not found, so the pointer hasn't been down (so it's probably a hover)


      if (storeIndex < 0) {
        return;
      } // update the event in the store


      store[storeIndex] = ev;
      this.callback(this.manager, eventType, {
        pointers: store,
        changedPointers: [ev],
        pointerType: pointerType,
        srcEvent: ev
      });

      if (removePointer) {
        // remove from the store
        store.splice(storeIndex, 1);
      }
    };

    return PointerEventInput;
  }(Input);
  /**
   * @private
   * convert array-like objects to real arrays
   * @param {Object} obj
   * @returns {Array}
   */


  function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  }
  /**
   * @private
   * unique array with objects based on a key (like 'id') or just by the array's value
   * @param {Array} src [{id:1},{id:2},{id:1}]
   * @param {String} [key]
   * @param {Boolean} [sort=False]
   * @returns {Array} [{id:1},{id:2}]
   */


  function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
      var val = key ? src[i][key] : src[i];

      if (inArray(values, val) < 0) {
        results.push(src[i]);
      }

      values[i] = val;
      i++;
    }

    if (sort) {
      if (!key) {
        results = results.sort();
      } else {
        results = results.sort(function (a, b) {
          return a[key] > b[key];
        });
      }
    }

    return results;
  }

  var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
  /**
   * @private
   * Multi-user touch events input
   * @constructor
   * @extends Input
   */

  var TouchInput = /*#__PURE__*/function (_Input) {
    _inheritsLoose(TouchInput, _Input);

    function TouchInput() {
      var _this;

      TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;
      _this = _Input.apply(this, arguments) || this;
      _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;

      return _this;
    }

    var _proto = TouchInput.prototype;

    _proto.handler = function handler(ev) {
      var type = TOUCH_INPUT_MAP[ev.type];
      var touches = getTouches.call(this, ev, type);

      if (!touches) {
        return;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    };

    return TouchInput;
  }(Input);

  function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds; // when there is only one touch, the process can be simplified

    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
      targetIds[allTouches[0].identifier] = true;
      return [allTouches, allTouches];
    }

    var i;
    var targetTouches;
    var changedTouches = toArray(ev.changedTouches);
    var changedTargetTouches = [];
    var target = this.target; // get target touches from touches

    targetTouches = allTouches.filter(function (touch) {
      return hasParent(touch.target, target);
    }); // collect touches

    if (type === INPUT_START) {
      i = 0;

      while (i < targetTouches.length) {
        targetIds[targetTouches[i].identifier] = true;
        i++;
      }
    } // filter changed touches to only contain touches that exist in the collected target ids


    i = 0;

    while (i < changedTouches.length) {
      if (targetIds[changedTouches[i].identifier]) {
        changedTargetTouches.push(changedTouches[i]);
      } // cleanup removed touches


      if (type & (INPUT_END | INPUT_CANCEL)) {
        delete targetIds[changedTouches[i].identifier];
      }

      i++;
    }

    if (!changedTargetTouches.length) {
      return;
    }

    return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
  }

  var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
  };
  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
  /**
   * @private
   * Mouse events input
   * @constructor
   * @extends Input
   */

  var MouseInput = /*#__PURE__*/function (_Input) {
    _inheritsLoose(MouseInput, _Input);

    function MouseInput() {
      var _this;

      var proto = MouseInput.prototype;
      proto.evEl = MOUSE_ELEMENT_EVENTS;
      proto.evWin = MOUSE_WINDOW_EVENTS;
      _this = _Input.apply(this, arguments) || this;
      _this.pressed = false; // mousedown state

      return _this;
    }
    /**
     * @private
     * handle mouse events
     * @param {Object} ev
     */


    var _proto = MouseInput.prototype;

    _proto.handler = function handler(ev) {
      var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down

      if (eventType & INPUT_START && ev.button === 0) {
        this.pressed = true;
      }

      if (eventType & INPUT_MOVE && ev.which !== 1) {
        eventType = INPUT_END;
      } // mouse must be down


      if (!this.pressed) {
        return;
      }

      if (eventType & INPUT_END) {
        this.pressed = false;
      }

      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: INPUT_TYPE_MOUSE,
        srcEvent: ev
      });
    };

    return MouseInput;
  }(Input);
  /**
   * @private
   * Combined touch and mouse input
   *
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
   * This because touch devices also emit mouse events while doing a touch.
   *
   * @constructor
   * @extends Input
   */


  var DEDUP_TIMEOUT = 2500;
  var DEDUP_DISTANCE = 25;

  function setLastTouch(eventData) {
    var _eventData$changedPoi = eventData.changedPointers,
        touch = _eventData$changedPoi[0];

    if (touch.identifier === this.primaryTouch) {
      var lastTouch = {
        x: touch.clientX,
        y: touch.clientY
      };
      var lts = this.lastTouches;
      this.lastTouches.push(lastTouch);

      var removeLastTouch = function removeLastTouch() {
        var i = lts.indexOf(lastTouch);

        if (i > -1) {
          lts.splice(i, 1);
        }
      };

      setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
  }

  function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
      this.primaryTouch = eventData.changedPointers[0].identifier;
      setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
      setLastTouch.call(this, eventData);
    }
  }

  function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX;
    var y = eventData.srcEvent.clientY;

    for (var i = 0; i < this.lastTouches.length; i++) {
      var t = this.lastTouches[i];
      var dx = Math.abs(x - t.x);
      var dy = Math.abs(y - t.y);

      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
        return true;
      }
    }

    return false;
  }

  var TouchMouseInput = /*#__PURE__*/function () {
    var TouchMouseInput = /*#__PURE__*/function (_Input) {
      _inheritsLoose(TouchMouseInput, _Input);

      function TouchMouseInput(_manager, callback) {
        var _this;

        _this = _Input.call(this, _manager, callback) || this;

        _this.handler = function (manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;
          var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;

          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          } // when we're in a touch event, record touches to  de-dupe synthetic mouse event


          if (isTouch) {
            recordTouches.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputData)) {
            return;
          }

          _this.callback(manager, inputEvent, inputData);
        };

        _this.touch = new TouchInput(_this.manager, _this.handler);
        _this.mouse = new MouseInput(_this.manager, _this.handler);
        _this.primaryTouch = null;
        _this.lastTouches = [];
        return _this;
      }
      /**
       * @private
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */


      var _proto = TouchMouseInput.prototype;
      /**
       * @private
       * remove the event listeners
       */

      _proto.destroy = function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
      };

      return TouchMouseInput;
    }(Input);

    return TouchMouseInput;
  }();
  /**
   * @private
   * create new input type manager
   * called by the Manager constructor
   * @param {Hammer} manager
   * @returns {Input}
   */


  function createInputInstance(manager) {
    var Type; // let inputClass = manager.options.inputClass;

    var inputClass = manager.options.inputClass;

    if (inputClass) {
      Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
      Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
      Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
      Type = MouseInput;
    } else {
      Type = TouchMouseInput;
    }

    return new Type(manager, inputHandler);
  }
  /**
   * @private
   * if the argument is an array, we want to execute the fn on each entry
   * if it aint an array we don't want to do a thing.
   * this is used by all the methods that accept a single and array argument.
   * @param {*|Array} arg
   * @param {String} fn
   * @param {Object} [context]
   * @returns {Boolean}
   */


  function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
      each(arg, context[fn], context);
      return true;
    }

    return false;
  }

  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;
  /**
   * @private
   * get a unique id
   * @returns {number} uniqueId
   */

  var _uniqueId = 1;

  function uniqueId() {
    return _uniqueId++;
  }
  /**
   * @private
   * get a recognizer by name if it is bound to a manager
   * @param {Recognizer|String} otherRecognizer
   * @param {Recognizer} recognizer
   * @returns {Recognizer}
   */


  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;

    if (manager) {
      return manager.get(otherRecognizer);
    }

    return otherRecognizer;
  }
  /**
   * @private
   * get a usable string, used as event postfix
   * @param {constant} state
   * @returns {String} state
   */


  function stateStr(state) {
    if (state & STATE_CANCELLED) {
      return 'cancel';
    } else if (state & STATE_ENDED) {
      return 'end';
    } else if (state & STATE_CHANGED) {
      return 'move';
    } else if (state & STATE_BEGAN) {
      return 'start';
    }

    return '';
  }
  /**
   * @private
   * Recognizer flow explained; *
   * All recognizers have the initial state of POSSIBLE when a input session starts.
   * The definition of a input session is from the first input until the last input, with all it's movement in it. *
   * Example session for mouse-input: mousedown -> mousemove -> mouseup
   *
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
   * which determines with state it should be.
   *
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
   * POSSIBLE to give it another change on the next cycle.
   *
   *               Possible
   *                  |
   *            +-----+---------------+
   *            |                     |
   *      +-----+-----+               |
   *      |           |               |
   *   Failed      Cancelled          |
   *                          +-------+------+
   *                          |              |
   *                      Recognized       Began
   *                                         |
   *                                      Changed
   *                                         |
   *                                  Ended/Recognized
   */

  /**
   * @private
   * Recognizer
   * Every recognizer needs to extend from this class.
   * @constructor
   * @param {Object} options
   */


  var Recognizer = /*#__PURE__*/function () {
    function Recognizer(options) {
      if (options === void 0) {
        options = {};
      }

      this.options = _extends({
        enable: true
      }, options);
      this.id = uniqueId();
      this.manager = null; // default is enable true

      this.state = STATE_POSSIBLE;
      this.simultaneous = {};
      this.requireFail = [];
    }
    /**
     * @private
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */


    var _proto = Recognizer.prototype;

    _proto.set = function set(options) {
      assign$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state

      this.manager && this.manager.touchAction.update();
      return this;
    };
    /**
     * @private
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */


    _proto.recognizeWith = function recognizeWith(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
        return this;
      }

      var simultaneous = this.simultaneous;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

      if (!simultaneous[otherRecognizer.id]) {
        simultaneous[otherRecognizer.id] = otherRecognizer;
        otherRecognizer.recognizeWith(this);
      }

      return this;
    };
    /**
     * @private
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */


    _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      delete this.simultaneous[otherRecognizer.id];
      return this;
    };
    /**
     * @private
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */


    _proto.requireFailure = function requireFailure(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
        return this;
      }

      var requireFail = this.requireFail;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

      if (inArray(requireFail, otherRecognizer) === -1) {
        requireFail.push(otherRecognizer);
        otherRecognizer.requireFailure(this);
      }

      return this;
    };
    /**
     * @private
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */


    _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      var index = inArray(this.requireFail, otherRecognizer);

      if (index > -1) {
        this.requireFail.splice(index, 1);
      }

      return this;
    };
    /**
     * @private
     * has require failures boolean
     * @returns {boolean}
     */


    _proto.hasRequireFailures = function hasRequireFailures() {
      return this.requireFail.length > 0;
    };
    /**
     * @private
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */


    _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {
      return !!this.simultaneous[otherRecognizer.id];
    };
    /**
     * @private
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */


    _proto.emit = function emit(input) {
      var self = this;
      var state = this.state;

      function emit(event) {
        self.manager.emit(event, input);
      } // 'panstart' and 'panmove'


      if (state < STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }

      emit(self.options.event); // simple 'eventName' events

      if (input.additionalEvent) {
        // additional event(panleft, panright, pinchin, pinchout...)
        emit(input.additionalEvent);
      } // panend and pancancel


      if (state >= STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }
    };
    /**
     * @private
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */


    _proto.tryEmit = function tryEmit(input) {
      if (this.canEmit()) {
        return this.emit(input);
      } // it's failing anyway


      this.state = STATE_FAILED;
    };
    /**
     * @private
     * can we emit?
     * @returns {boolean}
     */


    _proto.canEmit = function canEmit() {
      var i = 0;

      while (i < this.requireFail.length) {
        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
          return false;
        }

        i++;
      }

      return true;
    };
    /**
     * @private
     * update the recognizer
     * @param {Object} inputData
     */


    _proto.recognize = function recognize(inputData) {
      // make a new copy of the inputData
      // so we can change the inputData without messing up the other recognizers
      var inputDataClone = assign$1({}, inputData); // is is enabled and allow recognizing?

      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
        this.reset();
        this.state = STATE_FAILED;
        return;
      } // reset when we've reached the end


      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
        this.state = STATE_POSSIBLE;
      }

      this.state = this.process(inputDataClone); // the recognizer has recognized a gesture
      // so trigger an event

      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
        this.tryEmit(inputDataClone);
      }
    };
    /**
     * @private
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {constant} STATE
     */

    /* jshint ignore:start */


    _proto.process = function process(inputData) {};
    /* jshint ignore:end */

    /**
     * @private
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */


    _proto.getTouchAction = function getTouchAction() {};
    /**
     * @private
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */


    _proto.reset = function reset() {};

    return Recognizer;
  }();
  /**
   * @private
   * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing
   * a single tap.
   *
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
   * multi-taps being recognized.
   * @constructor
   * @extends Recognizer
   */


  var TapRecognizer = /*#__PURE__*/function (_Recognizer) {
    _inheritsLoose(TapRecognizer, _Recognizer);

    function TapRecognizer(options) {
      var _this;

      if (options === void 0) {
        options = {};
      }

      _this = _Recognizer.call(this, _extends({
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300,
        // max time between the multi-tap taps
        time: 250,
        // max time of the pointer to be down (like finger on the screen)
        threshold: 9,
        // a minimal movement is ok, but keep it low
        posThreshold: 10
      }, options)) || this; // previous time and center,
      // used for tap counting

      _this.pTime = false;
      _this.pCenter = false;
      _this._timer = null;
      _this._input = null;
      _this.count = 0;
      return _this;
    }

    var _proto = TapRecognizer.prototype;

    _proto.getTouchAction = function getTouchAction() {
      return [TOUCH_ACTION_MANIPULATION];
    };

    _proto.process = function process(input) {
      var _this2 = this;

      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTouchTime = input.deltaTime < options.time;
      this.reset();

      if (input.eventType & INPUT_START && this.count === 0) {
        return this.failTimeout();
      } // we only allow little movement
      // and we've reached an end event, so a tap is possible


      if (validMovement && validTouchTime && validPointers) {
        if (input.eventType !== INPUT_END) {
          return this.failTimeout();
        }

        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
        this.pTime = input.timeStamp;
        this.pCenter = input.center;

        if (!validMultiTap || !validInterval) {
          this.count = 1;
        } else {
          this.count += 1;
        }

        this._input = input; // if tap count matches we have recognized it,
        // else it has began recognizing...

        var tapCount = this.count % options.taps;

        if (tapCount === 0) {
          // no failing requirements, immediately trigger the tap event
          // or wait as long as the multitap interval to trigger
          if (!this.hasRequireFailures()) {
            return STATE_RECOGNIZED;
          } else {
            this._timer = setTimeout(function () {
              _this2.state = STATE_RECOGNIZED;

              _this2.tryEmit();
            }, options.interval);
            return STATE_BEGAN;
          }
        }
      }

      return STATE_FAILED;
    };

    _proto.failTimeout = function failTimeout() {
      var _this3 = this;

      this._timer = setTimeout(function () {
        _this3.state = STATE_FAILED;
      }, this.options.interval);
      return STATE_FAILED;
    };

    _proto.reset = function reset() {
      clearTimeout(this._timer);
    };

    _proto.emit = function emit() {
      if (this.state === STATE_RECOGNIZED) {
        this._input.tapCount = this.count;
        this.manager.emit(this.options.event, this._input);
      }
    };

    return TapRecognizer;
  }(Recognizer);
  /**
   * @private
   * This recognizer is just used as a base for the simple attribute recognizers.
   * @constructor
   * @extends Recognizer
   */


  var AttrRecognizer = /*#__PURE__*/function (_Recognizer) {
    _inheritsLoose(AttrRecognizer, _Recognizer);

    function AttrRecognizer(options) {
      if (options === void 0) {
        options = {};
      }

      return _Recognizer.call(this, _extends({
        pointers: 1
      }, options)) || this;
    }
    /**
     * @private
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */


    var _proto = AttrRecognizer.prototype;

    _proto.attrTest = function attrTest(input) {
      var optionPointers = this.options.pointers;
      return optionPointers === 0 || input.pointers.length === optionPointers;
    };
    /**
     * @private
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */


    _proto.process = function process(input) {
      var state = this.state;
      var eventType = input.eventType;
      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
      var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED

      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
        return state | STATE_CANCELLED;
      } else if (isRecognized || isValid) {
        if (eventType & INPUT_END) {
          return state | STATE_ENDED;
        } else if (!(state & STATE_BEGAN)) {
          return STATE_BEGAN;
        }

        return state | STATE_CHANGED;
      }

      return STATE_FAILED;
    };

    return AttrRecognizer;
  }(Recognizer);
  /**
   * @private
   * direction cons to string
   * @param {constant} direction
   * @returns {String}
   */


  function directionStr(direction) {
    if (direction === DIRECTION_DOWN) {
      return 'down';
    } else if (direction === DIRECTION_UP) {
      return 'up';
    } else if (direction === DIRECTION_LEFT) {
      return 'left';
    } else if (direction === DIRECTION_RIGHT) {
      return 'right';
    }

    return '';
  }
  /**
   * @private
   * Pan
   * Recognized when the pointer is down and moved in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */


  var PanRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
    _inheritsLoose(PanRecognizer, _AttrRecognizer);

    function PanRecognizer(options) {
      var _this;

      if (options === void 0) {
        options = {};
      }

      _this = _AttrRecognizer.call(this, _extends({
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
      }, options)) || this;
      _this.pX = null;
      _this.pY = null;
      return _this;
    }

    var _proto = PanRecognizer.prototype;

    _proto.getTouchAction = function getTouchAction() {
      var direction = this.options.direction;
      var actions = [];

      if (direction & DIRECTION_HORIZONTAL) {
        actions.push(TOUCH_ACTION_PAN_Y);
      }

      if (direction & DIRECTION_VERTICAL) {
        actions.push(TOUCH_ACTION_PAN_X);
      }

      return actions;
    };

    _proto.directionTest = function directionTest(input) {
      var options = this.options;
      var hasMoved = true;
      var distance = input.distance;
      var direction = input.direction;
      var x = input.deltaX;
      var y = input.deltaY; // lock to axis?

      if (!(direction & options.direction)) {
        if (options.direction & DIRECTION_HORIZONTAL) {
          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          hasMoved = x !== this.pX;
          distance = Math.abs(input.deltaX);
        } else {
          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          hasMoved = y !== this.pY;
          distance = Math.abs(input.deltaY);
        }
      }

      input.direction = direction;
      return hasMoved && distance > options.threshold && direction & options.direction;
    };

    _proto.attrTest = function attrTest(input) {
      return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call
      this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
    };

    _proto.emit = function emit(input) {
      this.pX = input.deltaX;
      this.pY = input.deltaY;
      var direction = directionStr(input.direction);

      if (direction) {
        input.additionalEvent = this.options.event + direction;
      }

      _AttrRecognizer.prototype.emit.call(this, input);
    };

    return PanRecognizer;
  }(AttrRecognizer);
  /**
   * @private
   * Swipe
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */


  var SwipeRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
    _inheritsLoose(SwipeRecognizer, _AttrRecognizer);

    function SwipeRecognizer(options) {
      if (options === void 0) {
        options = {};
      }

      return _AttrRecognizer.call(this, _extends({
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
      }, options)) || this;
    }

    var _proto = SwipeRecognizer.prototype;

    _proto.getTouchAction = function getTouchAction() {
      return PanRecognizer.prototype.getTouchAction.call(this);
    };

    _proto.attrTest = function attrTest(input) {
      var direction = this.options.direction;
      var velocity;

      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
        velocity = input.overallVelocity;
      } else if (direction & DIRECTION_HORIZONTAL) {
        velocity = input.overallVelocityX;
      } else if (direction & DIRECTION_VERTICAL) {
        velocity = input.overallVelocityY;
      }

      return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    };

    _proto.emit = function emit(input) {
      var direction = directionStr(input.offsetDirection);

      if (direction) {
        this.manager.emit(this.options.event + direction, input);
      }

      this.manager.emit(this.options.event, input);
    };

    return SwipeRecognizer;
  }(AttrRecognizer);
  /**
   * @private
   * Pinch
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
   * @constructor
   * @extends AttrRecognizer
   */


  var PinchRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
    _inheritsLoose(PinchRecognizer, _AttrRecognizer);

    function PinchRecognizer(options) {
      if (options === void 0) {
        options = {};
      }

      return _AttrRecognizer.call(this, _extends({
        event: 'pinch',
        threshold: 0,
        pointers: 2
      }, options)) || this;
    }

    var _proto = PinchRecognizer.prototype;

    _proto.getTouchAction = function getTouchAction() {
      return [TOUCH_ACTION_NONE];
    };

    _proto.attrTest = function attrTest(input) {
      return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    };

    _proto.emit = function emit(input) {
      if (input.scale !== 1) {
        var inOut = input.scale < 1 ? 'in' : 'out';
        input.additionalEvent = this.options.event + inOut;
      }

      _AttrRecognizer.prototype.emit.call(this, input);
    };

    return PinchRecognizer;
  }(AttrRecognizer);
  /**
   * @private
   * Rotate
   * Recognized when two or more pointer are moving in a circular motion.
   * @constructor
   * @extends AttrRecognizer
   */


  var RotateRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
    _inheritsLoose(RotateRecognizer, _AttrRecognizer);

    function RotateRecognizer(options) {
      if (options === void 0) {
        options = {};
      }

      return _AttrRecognizer.call(this, _extends({
        event: 'rotate',
        threshold: 0,
        pointers: 2
      }, options)) || this;
    }

    var _proto = RotateRecognizer.prototype;

    _proto.getTouchAction = function getTouchAction() {
      return [TOUCH_ACTION_NONE];
    };

    _proto.attrTest = function attrTest(input) {
      return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    };

    return RotateRecognizer;
  }(AttrRecognizer);
  /**
   * @private
   * Press
   * Recognized when the pointer is down for x ms without any movement.
   * @constructor
   * @extends Recognizer
   */


  var PressRecognizer = /*#__PURE__*/function (_Recognizer) {
    _inheritsLoose(PressRecognizer, _Recognizer);

    function PressRecognizer(options) {
      var _this;

      if (options === void 0) {
        options = {};
      }

      _this = _Recognizer.call(this, _extends({
        event: 'press',
        pointers: 1,
        time: 251,
        // minimal time of the pointer to be pressed
        threshold: 9
      }, options)) || this;
      _this._timer = null;
      _this._input = null;
      return _this;
    }

    var _proto = PressRecognizer.prototype;

    _proto.getTouchAction = function getTouchAction() {
      return [TOUCH_ACTION_AUTO];
    };

    _proto.process = function process(input) {
      var _this2 = this;

      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTime = input.deltaTime > options.time;
      this._input = input; // we only allow little movement
      // and we've reached an end event, so a tap is possible

      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
        this.reset();
      } else if (input.eventType & INPUT_START) {
        this.reset();
        this._timer = setTimeout(function () {
          _this2.state = STATE_RECOGNIZED;

          _this2.tryEmit();
        }, options.time);
      } else if (input.eventType & INPUT_END) {
        return STATE_RECOGNIZED;
      }

      return STATE_FAILED;
    };

    _proto.reset = function reset() {
      clearTimeout(this._timer);
    };

    _proto.emit = function emit(input) {
      if (this.state !== STATE_RECOGNIZED) {
        return;
      }

      if (input && input.eventType & INPUT_END) {
        this.manager.emit(this.options.event + "up", input);
      } else {
        this._input.timeStamp = now();
        this.manager.emit(this.options.event, this._input);
      }
    };

    return PressRecognizer;
  }(Recognizer);

  var defaults = {
    /**
     * @private
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * @private
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @private
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * @private
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * @private
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * @private
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
      /**
       * @private
       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userSelect: "none",

      /**
       * @private
       * Disable the Windows Phone grippers when pressing an element.
       * @type {String}
       * @default 'none'
       */
      touchSelect: "none",

      /**
       * @private
       * Disables the default callout shown when you touch and hold a touch target.
       * On iOS, when you touch and hold a touch target such as a link, Safari displays
       * a callout containing information about the link. This property allows you to disable that callout.
       * @type {String}
       * @default 'none'
       */
      touchCallout: "none",

      /**
       * @private
       * Specifies whether zooming is enabled. Used by IE10>
       * @type {String}
       * @default 'none'
       */
      contentZooming: "none",

      /**
       * @private
       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userDrag: "none",

      /**
       * @private
       * Overrides the highlight color shown when the user taps a link or a JavaScript
       * clickable element in iOS. This property obeys the alpha value, if specified.
       * @type {String}
       * @default 'rgba(0,0,0,0)'
       */
      tapHighlightColor: "rgba(0,0,0,0)"
    }
  };
  /**
   * @private
   * Default recognizer setup when calling `Hammer()`
   * When creating a new Manager these will be skipped.
   * This is separated with other defaults because of tree-shaking.
   * @type {Array}
   */

  var preset = [[RotateRecognizer, {
    enable: false
  }], [PinchRecognizer, {
    enable: false
  }, ['rotate']], [SwipeRecognizer, {
    direction: DIRECTION_HORIZONTAL
  }], [PanRecognizer, {
    direction: DIRECTION_HORIZONTAL
  }, ['swipe']], [TapRecognizer], [TapRecognizer, {
    event: 'doubletap',
    taps: 2
  }, ['tap']], [PressRecognizer]];
  var STOP = 1;
  var FORCED_STOP = 2;
  /**
   * @private
   * add/remove the css properties as defined in manager.options.cssProps
   * @param {Manager} manager
   * @param {Boolean} add
   */

  function toggleCssProps(manager, add) {
    var element = manager.element;

    if (!element.style) {
      return;
    }

    var prop;
    each(manager.options.cssProps, function (value, name) {
      prop = prefixed(element.style, name);

      if (add) {
        manager.oldCssProps[prop] = element.style[prop];
        element.style[prop] = value;
      } else {
        element.style[prop] = manager.oldCssProps[prop] || "";
      }
    });

    if (!add) {
      manager.oldCssProps = {};
    }
  }
  /**
   * @private
   * trigger dom event
   * @param {String} event
   * @param {Object} data
   */


  function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent("Event");
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
  }
  /**
  * @private
   * Manager
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */


  var Manager = /*#__PURE__*/function () {
    function Manager(element, options) {
      var _this = this;

      this.options = assign$1({}, defaults, options || {});
      this.options.inputTarget = this.options.inputTarget || element;
      this.handlers = {};
      this.session = {};
      this.recognizers = [];
      this.oldCssProps = {};
      this.element = element;
      this.input = createInputInstance(this);
      this.touchAction = new TouchAction(this, this.options.touchAction);
      toggleCssProps(this, true);
      each(this.options.recognizers, function (item) {
        var recognizer = _this.add(new item[0](item[1]));

        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
      }, this);
    }
    /**
     * @private
     * set options
     * @param {Object} options
     * @returns {Manager}
     */


    var _proto = Manager.prototype;

    _proto.set = function set(options) {
      assign$1(this.options, options); // Options that need a little more setup

      if (options.touchAction) {
        this.touchAction.update();
      }

      if (options.inputTarget) {
        // Clean up existing event listeners and reinitialize
        this.input.destroy();
        this.input.target = options.inputTarget;
        this.input.init();
      }

      return this;
    };
    /**
     * @private
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */


    _proto.stop = function stop(force) {
      this.session.stopped = force ? FORCED_STOP : STOP;
    };
    /**
     * @private
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */


    _proto.recognize = function recognize(inputData) {
      var session = this.session;

      if (session.stopped) {
        return;
      } // run the touch-action polyfill


      this.touchAction.preventDefaults(inputData);
      var recognizer;
      var recognizers = this.recognizers; // this holds the recognizer that is being recognized.
      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
      // if no recognizer is detecting a thing, it is set to `null`

      var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized
      // or when we're in a new session

      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
        session.curRecognizer = null;
        curRecognizer = null;
      }

      var i = 0;

      while (i < recognizers.length) {
        recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.
        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
        //      that is being recognized.
        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
        //      this can be setup with the `recognizeWith()` method on the recognizer.

        if (session.stopped !== FORCED_STOP && ( // 1
        !curRecognizer || recognizer === curRecognizer || // 2
        recognizer.canRecognizeWith(curRecognizer))) {
          // 3
          recognizer.recognize(inputData);
        } else {
          recognizer.reset();
        } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
        // current active recognizer. but only if we don't already have an active recognizer


        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
          session.curRecognizer = recognizer;
          curRecognizer = recognizer;
        }

        i++;
      }
    };
    /**
     * @private
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */


    _proto.get = function get(recognizer) {
      if (recognizer instanceof Recognizer) {
        return recognizer;
      }

      var recognizers = this.recognizers;

      for (var i = 0; i < recognizers.length; i++) {
        if (recognizers[i].options.event === recognizer) {
          return recognizers[i];
        }
      }

      return null;
    };
    /**
     * @private add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */


    _proto.add = function add(recognizer) {
      if (invokeArrayArg(recognizer, "add", this)) {
        return this;
      } // remove existing


      var existing = this.get(recognizer.options.event);

      if (existing) {
        this.remove(existing);
      }

      this.recognizers.push(recognizer);
      recognizer.manager = this;
      this.touchAction.update();
      return recognizer;
    };
    /**
     * @private
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */


    _proto.remove = function remove(recognizer) {
      if (invokeArrayArg(recognizer, "remove", this)) {
        return this;
      }

      var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists

      if (recognizer) {
        var recognizers = this.recognizers;
        var index = inArray(recognizers, targetRecognizer);

        if (index !== -1) {
          recognizers.splice(index, 1);
          this.touchAction.update();
        }
      }

      return this;
    };
    /**
     * @private
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */


    _proto.on = function on(events, handler) {
      if (events === undefined || handler === undefined) {
        return this;
      }

      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        handlers[event] = handlers[event] || [];
        handlers[event].push(handler);
      });
      return this;
    };
    /**
     * @private unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */


    _proto.off = function off(events, handler) {
      if (events === undefined) {
        return this;
      }

      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        if (!handler) {
          delete handlers[event];
        } else {
          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
        }
      });
      return this;
    };
    /**
     * @private emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */


    _proto.emit = function emit(event, data) {
      // we also want to trigger dom events
      if (this.options.domEvents) {
        triggerDomEvent(event, data);
      } // no handlers, so skip it all


      var handlers = this.handlers[event] && this.handlers[event].slice();

      if (!handlers || !handlers.length) {
        return;
      }

      data.type = event;

      data.preventDefault = function () {
        data.srcEvent.preventDefault();
      };

      var i = 0;

      while (i < handlers.length) {
        handlers[i](data);
        i++;
      }
    };
    /**
     * @private
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */


    _proto.destroy = function destroy() {
      this.element && toggleCssProps(this, false);
      this.handlers = {};
      this.session = {};
      this.input.destroy();
      this.element = null;
    };

    return Manager;
  }();

  var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
  /**
   * @private
   * Touch events input
   * @constructor
   * @extends Input
   */

  var SingleTouchInput = /*#__PURE__*/function (_Input) {
    _inheritsLoose(SingleTouchInput, _Input);

    function SingleTouchInput() {
      var _this;

      var proto = SingleTouchInput.prototype;
      proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
      proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
      _this = _Input.apply(this, arguments) || this;
      _this.started = false;
      return _this;
    }

    var _proto = SingleTouchInput.prototype;

    _proto.handler = function handler(ev) {
      var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?

      if (type === INPUT_START) {
        this.started = true;
      }

      if (!this.started) {
        return;
      }

      var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state

      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
        this.started = false;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    };

    return SingleTouchInput;
  }(Input);

  function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
      all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
  }
  /**
   * @private
   * wrap a method with a deprecation warning and stack trace
   * @param {Function} method
   * @param {String} name
   * @param {String} message
   * @returns {Function} A new function wrapping the supplied method.
   */


  function deprecate(method, name, message) {
    var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
    return function () {
      var e = new Error('get-stack-trace');
      var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
      var log = window.console && (window.console.warn || window.console.log);

      if (log) {
        log.call(window.console, deprecationMessage, stack);
      }

      return method.apply(this, arguments);
    };
  }
  /**
   * @private
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]
   * @returns {Object} dest
   */


  var extend = deprecate(function (dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;

    while (i < keys.length) {
      if (!merge || merge && dest[keys[i]] === undefined) {
        dest[keys[i]] = src[keys[i]];
      }

      i++;
    }

    return dest;
  }, 'extend', 'Use `assign`.');
  /**
   * @private
   * merge the values from src in the dest.
   * means that properties that exist in dest will not be overwritten by src
   * @param {Object} dest
   * @param {Object} src
   * @returns {Object} dest
   */

  var merge$1 = deprecate(function (dest, src) {
    return extend(dest, src, true);
  }, 'merge', 'Use `assign`.');
  /**
   * @private
   * simple class inheritance
   * @param {Function} child
   * @param {Function} base
   * @param {Object} [properties]
   */

  function inherit(child, base, properties) {
    var baseP = base.prototype;
    var childP;
    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
      assign$1(childP, properties);
    }
  }
  /**
   * @private
   * simple function bind
   * @param {Function} fn
   * @param {Object} context
   * @returns {Function}
   */


  function bindFn(fn, context) {
    return function boundFn() {
      return fn.apply(context, arguments);
    };
  }
  /**
   * @private
   * Simple way to create a manager with a default set of recognizers.
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */


  var Hammer = /*#__PURE__*/function () {
    var Hammer =
    /**
      * @private
      * @const {string}
      */
    function Hammer(element, options) {
      if (options === void 0) {
        options = {};
      }

      return new Manager(element, _extends({
        recognizers: preset.concat()
      }, options));
    };

    Hammer.VERSION = "2.0.17-rc";
    Hammer.DIRECTION_ALL = DIRECTION_ALL;
    Hammer.DIRECTION_DOWN = DIRECTION_DOWN;
    Hammer.DIRECTION_LEFT = DIRECTION_LEFT;
    Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;
    Hammer.DIRECTION_UP = DIRECTION_UP;
    Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
    Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;
    Hammer.DIRECTION_NONE = DIRECTION_NONE;
    Hammer.DIRECTION_DOWN = DIRECTION_DOWN;
    Hammer.INPUT_START = INPUT_START;
    Hammer.INPUT_MOVE = INPUT_MOVE;
    Hammer.INPUT_END = INPUT_END;
    Hammer.INPUT_CANCEL = INPUT_CANCEL;
    Hammer.STATE_POSSIBLE = STATE_POSSIBLE;
    Hammer.STATE_BEGAN = STATE_BEGAN;
    Hammer.STATE_CHANGED = STATE_CHANGED;
    Hammer.STATE_ENDED = STATE_ENDED;
    Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;
    Hammer.STATE_CANCELLED = STATE_CANCELLED;
    Hammer.STATE_FAILED = STATE_FAILED;
    Hammer.Manager = Manager;
    Hammer.Input = Input;
    Hammer.TouchAction = TouchAction;
    Hammer.TouchInput = TouchInput;
    Hammer.MouseInput = MouseInput;
    Hammer.PointerEventInput = PointerEventInput;
    Hammer.TouchMouseInput = TouchMouseInput;
    Hammer.SingleTouchInput = SingleTouchInput;
    Hammer.Recognizer = Recognizer;
    Hammer.AttrRecognizer = AttrRecognizer;
    Hammer.Tap = TapRecognizer;
    Hammer.Pan = PanRecognizer;
    Hammer.Swipe = SwipeRecognizer;
    Hammer.Pinch = PinchRecognizer;
    Hammer.Rotate = RotateRecognizer;
    Hammer.Press = PressRecognizer;
    Hammer.on = addEventListeners;
    Hammer.off = removeEventListeners;
    Hammer.each = each;
    Hammer.merge = merge$1;
    Hammer.extend = extend;
    Hammer.bindFn = bindFn;
    Hammer.assign = assign$1;
    Hammer.inherit = inherit;
    Hammer.bindFn = bindFn;
    Hammer.prefixed = prefixed;
    Hammer.toArray = toArray;
    Hammer.inArray = inArray;
    Hammer.uniqueArray = uniqueArray;
    Hammer.splitStr = splitStr;
    Hammer.boolOrFn = boolOrFn;
    Hammer.hasParent = hasParent;
    Hammer.addEventListeners = addEventListeners;
    Hammer.removeEventListeners = removeEventListeners;
    Hammer.defaults = assign$1({}, defaults, {
      preset: preset
    });
    return Hammer;
  }(); //  style loader but by script tag, not by the loader.
  var RealHammer = Hammer;

  function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$1(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$3(o, minLen) { var _context21; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = slice(_context21 = Object.prototype.toString.call(o)).call(_context21, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

  function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  /**
   * Use this symbol to delete properies in deepObjectAssign.
   */

  var DELETE = symbol("DELETE");
  /**
   * Pure version of deepObjectAssign, it doesn't modify any of it's arguments.
   *
   * @param base - The base object that fullfils the whole interface T.
   * @param updates - Updates that may change or delete props.
   * @returns A brand new instance with all the supplied objects deeply merged.
   */


  function pureDeepObjectAssign(base) {
    var _context;

    for (var _len = arguments.length, updates = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      updates[_key - 1] = arguments[_key];
    }

    return deepObjectAssign.apply(void 0, concat$1(_context = [{}, base]).call(_context, updates));
  }
  /**
   * Deep version of object assign with additional deleting by the DELETE symbol.
   *
   * @param values - Objects to be deeply merged.
   * @returns The first object from values.
   */


  function deepObjectAssign() {
    var merged = deepObjectAssignNonentry.apply(void 0, arguments);
    stripDelete(merged);
    return merged;
  }
  /**
   * Deep version of object assign with additional deleting by the DELETE symbol.
   *
   * @remarks
   * This doesn't strip the DELETE symbols so they may end up in the final object.
   * @param values - Objects to be deeply merged.
   * @returns The first object from values.
   */


  function deepObjectAssignNonentry() {
    for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      values[_key2] = arguments[_key2];
    }

    if (values.length < 2) {
      return values[0];
    } else if (values.length > 2) {
      var _context2;

      return deepObjectAssignNonentry.apply(void 0, concat$1(_context2 = [deepObjectAssign(values[0], values[1])]).call(_context2, _toConsumableArray(slice(values).call(values, 2))));
    }

    var a = values[0];
    var b = values[1];

    var _iterator = _createForOfIteratorHelper$3(ownKeys$1(b)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var prop = _step.value;
        if (!Object.prototype.propertyIsEnumerable.call(b, prop)) ;else if (b[prop] === DELETE) {
          delete a[prop];
        } else if (a[prop] !== null && b[prop] !== null && _typeof(a[prop]) === "object" && _typeof(b[prop]) === "object" && !isArray$1(a[prop]) && !isArray$1(b[prop])) {
          a[prop] = deepObjectAssignNonentry(a[prop], b[prop]);
        } else {
          a[prop] = clone(b[prop]);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return a;
  }
  /**
   * Deep clone given object or array. In case of primitive simply return.
   *
   * @param a - Anything.
   * @returns Deep cloned object/array or unchanged a.
   */


  function clone(a) {
    if (isArray$1(a)) {
      return map$3(a).call(a, function (value) {
        return clone(value);
      });
    } else if (_typeof(a) === "object" && a !== null) {
      return deepObjectAssignNonentry({}, a);
    } else {
      return a;
    }
  }
  /**
   * Strip DELETE from given object.
   *
   * @param a - Object which may contain DELETE but won't after this is executed.
   */


  function stripDelete(a) {
    for (var _i = 0, _Object$keys = keys$4(a); _i < _Object$keys.length; _i++) {
      var prop = _Object$keys[_i];

      if (a[prop] === DELETE) {
        delete a[prop];
      } else if (_typeof(a[prop]) === "object" && a[prop] !== null) {
        stripDelete(a[prop]);
      }
    }
  }
  /**
   * Setup a mock hammer.js object, for unit testing.
   *
   * Inspiration: https://github.com/uber/deck.gl/pull/658
   *
   * @returns {{on: noop, off: noop, destroy: noop, emit: noop, get: get}}
   */


  function hammerMock() {
    var noop = function noop() {};

    return {
      on: noop,
      off: noop,
      destroy: noop,
      emit: noop,
      get: function get() {
        return {
          set: noop
        };
      }
    };
  }

  var Hammer$1 = typeof window !== "undefined" ? window.Hammer || RealHammer : function () {
    // hammer.js is only available in a browser, not in node.js. Replacing it with a mock object.
    return hammerMock();
  };
  /**
   * Turn an element into an clickToUse element.
   * When not active, the element has a transparent overlay. When the overlay is
   * clicked, the mode is changed to active.
   * When active, the element is displayed with a blue border around it, and
   * the interactive contents of the element can be used. When clicked outside
   * the element, the elements mode is changed to inactive.
   *
   * @param {Element} container
   * @class Activator
   */

  function Activator$1(container) {
    var _this = this,
        _context3;

    this._cleanupQueue = [];
    this.active = false;
    this._dom = {
      container: container,
      overlay: document.createElement("div")
    };

    this._dom.overlay.classList.add("vis-overlay");

    this._dom.container.appendChild(this._dom.overlay);

    this._cleanupQueue.push(function () {
      _this._dom.overlay.parentNode.removeChild(_this._dom.overlay);
    });

    var hammer = Hammer$1(this._dom.overlay);
    hammer.on("tap", bind$6(_context3 = this._onTapOverlay).call(_context3, this));

    this._cleanupQueue.push(function () {
      hammer.destroy(); // FIXME: cleaning up hammer instances doesn't work (Timeline not removed
      // from memory)
    }); // block all touch events (except tap)


    var events = ["tap", "doubletap", "press", "pinch", "pan", "panstart", "panmove", "panend"];

    forEach$1(events).call(events, function (event) {
      hammer.on(event, function (event) {
        event.srcEvent.stopPropagation();
      });
    }); // attach a click event to the window, in order to deactivate when clicking outside the timeline


    if (document && document.body) {
      this._onClick = function (event) {
        if (!_hasParent(event.target, container)) {
          _this.deactivate();
        }
      };

      document.body.addEventListener("click", this._onClick);

      this._cleanupQueue.push(function () {
        document.body.removeEventListener("click", _this._onClick);
      });
    } // prepare escape key listener for deactivating when active


    this._escListener = function (event) {
      if ("key" in event ? event.key === "Escape" : event.keyCode === 27
      /* the keyCode is for IE11 */
      ) {
        _this.deactivate();
      }
    };
  } // turn into an event emitter


  Emitter(Activator$1.prototype); // The currently active activator

  Activator$1.current = null;
  /**
   * Destroy the activator. Cleans up all created DOM and event listeners
   */

  Activator$1.prototype.destroy = function () {
    var _context4, _context5;

    this.deactivate();

    var _iterator2 = _createForOfIteratorHelper$3(reverse(_context4 = splice(_context5 = this._cleanupQueue).call(_context5, 0)).call(_context4)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var callback = _step2.value;
        callback();
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  };
  /**
   * Activate the element
   * Overlay is hidden, element is decorated with a blue shadow border
   */


  Activator$1.prototype.activate = function () {
    // we allow only one active activator at a time
    if (Activator$1.current) {
      Activator$1.current.deactivate();
    }

    Activator$1.current = this;
    this.active = true;
    this._dom.overlay.style.display = "none";

    this._dom.container.classList.add("vis-active");

    this.emit("change");
    this.emit("activate"); // ugly hack: bind ESC after emitting the events, as the Network rebinds all
    // keyboard events on a 'change' event

    document.body.addEventListener("keydown", this._escListener);
  };
  /**
   * Deactivate the element
   * Overlay is displayed on top of the element
   */


  Activator$1.prototype.deactivate = function () {
    this.active = false;
    this._dom.overlay.style.display = "block";

    this._dom.container.classList.remove("vis-active");

    document.body.removeEventListener("keydown", this._escListener);
    this.emit("change");
    this.emit("deactivate");
  };
  /**
   * Handle a tap event: activate the container
   *
   * @param {Event}  event   The event
   * @private
   */


  Activator$1.prototype._onTapOverlay = function (event) {
    // activate the container
    this.activate();
    event.srcEvent.stopPropagation();
  };
  /**
   * Test whether the element has the requested parent element somewhere in
   * its chain of parent nodes.
   *
   * @param {HTMLElement} element
   * @param {HTMLElement} parent
   * @returns {boolean} Returns true when the parent is found somewhere in the
   *                    chain of parent nodes.
   * @private
   */


  function _hasParent(element, parent) {
    while (element) {
      if (element === parent) {
        return true;
      }

      element = element.parentNode;
    }

    return false;
  } // utility functions

  var global$4 = global$M;
  var isConstructor = isConstructor$4;
  var tryToString$1 = tryToString$4;
  var TypeError$3 = global$4.TypeError; // `Assert: IsConstructor(argument) is true`

  var aConstructor$1 = function (argument) {
    if (isConstructor(argument)) return argument;
    throw TypeError$3(tryToString$1(argument) + ' is not a constructor');
  };

  var $$5 = _export;
  var getBuiltIn$1 = getBuiltIn$9;
  var apply = functionApply;
  var bind$2 = functionBind;
  var aConstructor = aConstructor$1;
  var anObject$1 = anObject$b;
  var isObject$3 = isObject$f;
  var create$4 = objectCreate;
  var fails$5 = fails$r;
  var nativeConstruct = getBuiltIn$1('Reflect', 'construct');
  var ObjectPrototype = Object.prototype;
  var push$1 = [].push; // `Reflect.construct` method
  // https://tc39.es/ecma262/#sec-reflect.construct
  // MS Edge supports only 2 arguments and argumentsList argument is optional
  // FF Nightly sets third argument as `new.target`, but does not create `this` from it

  var NEW_TARGET_BUG = fails$5(function () {
    function F() {
      /* empty */
    }

    return !(nativeConstruct(function () {
      /* empty */
    }, [], F) instanceof F);
  });
  var ARGS_BUG = !fails$5(function () {
    nativeConstruct(function () {
      /* empty */
    });
  });
  var FORCED$1 = NEW_TARGET_BUG || ARGS_BUG;
  $$5({
    target: 'Reflect',
    stat: true,
    forced: FORCED$1,
    sham: FORCED$1
  }, {
    construct: function construct(Target, args
    /* , newTarget */
    ) {
      aConstructor(Target);
      anObject$1(args);
      var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
      if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);

      if (Target == newTarget) {
        // w/o altered newTarget, optimization for 0-4 arguments
        switch (args.length) {
          case 0:
            return new Target();

          case 1:
            return new Target(args[0]);

          case 2:
            return new Target(args[0], args[1]);

          case 3:
            return new Target(args[0], args[1], args[2]);

          case 4:
            return new Target(args[0], args[1], args[2], args[3]);
        } // w/o altered newTarget, lot of arguments case


        var $args = [null];
        apply(push$1, $args, args);
        return new (apply(bind$2, Target, $args))();
      } // with altered newTarget, not support built-in constructors


      var proto = newTarget.prototype;
      var instance = create$4(isObject$3(proto) ? proto : ObjectPrototype);
      var result = apply(Target, instance, args);
      return isObject$3(result) ? result : instance;
    }
  });

  var path$3 = path$q;
  var construct$2 = path$3.Reflect.construct;

  var parent$h = construct$2;
  var construct$1 = parent$h;

  var construct = construct$1;

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  var parent$g = create$6;
  var create$3 = parent$g;

  var parent$f = create$3;
  var create$2 = parent$f;

  var create$1 = create$2;

  var $$4 = _export;
  var setPrototypeOf$5 = objectSetPrototypeOf; // `Object.setPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.setprototypeof

  $$4({
    target: 'Object',
    stat: true
  }, {
    setPrototypeOf: setPrototypeOf$5
  });

  var path$2 = path$q;
  var setPrototypeOf$4 = path$2.Object.setPrototypeOf;

  var parent$e = setPrototypeOf$4;
  var setPrototypeOf$3 = parent$e;

  var parent$d = setPrototypeOf$3;
  var setPrototypeOf$2 = parent$d;

  var parent$c = setPrototypeOf$2;
  var setPrototypeOf$1 = parent$c;

  var setPrototypeOf = setPrototypeOf$1;

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = create$1(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });

    defineProperty$7(subClass, "prototype", {
      writable: false
    });

    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  var parent$b = getPrototypeOf$3;
  var getPrototypeOf$2 = parent$b;

  var parent$a = getPrototypeOf$2;
  var getPrototypeOf$1 = parent$a;

  var getPrototypeOf = getPrototypeOf$1;

  function _getPrototypeOf(o) {
    _getPrototypeOf = setPrototypeOf ? getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  var runtime = {exports: {}};

  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  (function (module) {
    var runtime = function (exports) {

      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined$1; // More compressible than void 0.

      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      function define(obj, key, value) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }

      try {
        // IE 8 has a broken Object.defineProperty that only works on DOM objects.
        define({}, "");
      } catch (err) {
        define = function (obj, key, value) {
          return obj[key] = value;
        };
      }

      function wrap(innerFn, outerFn, self, tryLocsList) {
        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
        // .throw, and .return methods.

        generator._invoke = makeInvokeMethod(innerFn, self, context);
        return generator;
      }

      exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
      // record like context.tryEntries[i].completion. This interface could
      // have been (and was previously) designed to take a closure to be
      // invoked without arguments, but in all the cases we care about we
      // already have an existing method we want to call, so there's no need
      // to create a new function object. We can even get away with assuming
      // the method takes exactly one argument, since that happens to be true
      // in every case, so we don't have to touch the arguments object. The
      // only additional allocation required is the completion record, which
      // has a stable shape and so hopefully should be cheap to allocate.

      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }

      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
      // breaking out of the dispatch switch statement.

      var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
      // .constructor.prototype properties for functions that return Generator
      // objects. For full spec compliance, you may wish to configure your
      // minifier not to mangle the names of these two functions.

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
      // don't natively support it.


      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function () {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        // This environment has a native %IteratorPrototype%; use it instead
        // of the polyfill.
        IteratorPrototype = NativeIteratorPrototype;
      }

      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      define(Gp, "constructor", GeneratorFunctionPrototype);
      define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
      GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
      // Iterator interface in terms of a single ._invoke method.

      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }

      exports.isGeneratorFunction = function (genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };

      exports.mark = function (genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define(genFun, toStringTagSymbol, "GeneratorFunction");
        }

        genFun.prototype = Object.create(Gp);
        return genFun;
      }; // Within the body of any async function, `await x` is transformed to
      // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
      // `hasOwn.call(value, "__await")` to determine if the yielded value is
      // meant to be awaited.


      exports.awrap = function (arg) {
        return {
          __await: arg
        };
      };

      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);

          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;

            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              });
            }

            return PromiseImpl.resolve(value).then(function (unwrapped) {
              // When a yielded Promise is resolved, its final value becomes
              // the .value of the Promise<{value,done}> result for the
              // current iteration.
              result.value = unwrapped;
              resolve(result);
            }, function (error) {
              // If a rejected Promise was yielded, throw the rejection back
              // into the async generator function so it can be handled there.
              return invoke("throw", error, resolve, reject);
            });
          }
        }

        var previousPromise;

        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } // Define the unified helper method that is used to implement .next,
        // .throw, and .return (see defineIteratorMethods).


        this._invoke = enqueue;
      }

      defineIteratorMethods(AsyncIterator.prototype);
      define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
        return this;
      });
      exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
      // AsyncIterator objects; they just return a Promise for the value of
      // the final result produced by the iterator.

      exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0) PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      };

      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }

          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            } // Be forgiving, per 25.3.3.3.3 of the spec:
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


            return doneResult();
          }

          context.method = method;
          context.arg = arg;

          while (true) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if (context.method === "next") {
              // Setting context._sent for legacy support of Babel's
              // function.sent implementation.
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }

              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }

            state = GenStateExecuting;
            var record = tryCatch(innerFn, self, context);

            if (record.type === "normal") {
              // If an exception is thrown from innerFn, we leave state ===
              // GenStateExecuting and loop back for another invocation.
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;

              if (record.arg === ContinueSentinel) {
                continue;
              }

              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted; // Dispatch the exception by looping back around to the
              // context.dispatchException(context.arg) call above.

              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      } // Call delegate.iterator[context.method](context.arg) and handle the
      // result, either by returning a { value, done } result from the
      // delegate iterator, or by modifying context.method and context.arg,
      // setting context.delegate to null, and returning the ContinueSentinel.


      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];

        if (method === undefined$1) {
          // A .throw or .return when the delegate iterator has no .throw
          // method always terminates the yield* loop.
          context.delegate = null;

          if (context.method === "throw") {
            // Note: ["return"] must be used for ES3 parsing compatibility.
            if (delegate.iterator["return"]) {
              // If the delegate iterator has a return method, give it a
              // chance to clean up.
              context.method = "return";
              context.arg = undefined$1;
              maybeInvokeDelegate(delegate, context);

              if (context.method === "throw") {
                // If maybeInvokeDelegate(context) changed context.method from
                // "return" to "throw", let that override the TypeError below.
                return ContinueSentinel;
              }
            }

            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return ContinueSentinel;
        }

        var record = tryCatch(method, delegate.iterator, context.arg);

        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }

        var info = record.arg;

        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }

        if (info.done) {
          // Assign the result of the finished delegate to the temporary
          // variable specified by delegate.resultName (see delegateYield).
          context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

          context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
          // exception, let the outer generator proceed normally. If
          // context.method was "next", forget context.arg since it has been
          // "consumed" by the delegate iterator. If context.method was
          // "return", allow the original .return call to continue in the
          // outer generator.

          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined$1;
          }
        } else {
          // Re-yield the result returned by the delegate method.
          return info;
        } // The delegate iterator is finished, so forget it and continue with
        // the outer generator.


        context.delegate = null;
        return ContinueSentinel;
      } // Define Generator.prototype.{next,throw,return} in terms of the
      // unified ._invoke helper method.


      defineIteratorMethods(Gp);
      define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
      // @@iterator function is called on it. Some browsers' implementations of the
      // iterator prototype chain incorrectly implement this, causing the Generator
      // object to not be returned from this call. This ensures that doesn't happen.
      // See https://github.com/facebook/regenerator/issues/274 for more details.

      define(Gp, iteratorSymbol, function () {
        return this;
      });
      define(Gp, "toString", function () {
        return "[object Generator]";
      });

      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };

        if (1 in locs) {
          entry.catchLoc = locs[1];
        }

        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }

        this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }

      function Context(tryLocsList) {
        // The root entry object (effectively a try statement without a catch
        // or a finally block) gives us a place to store values thrown from
        // locations where there is no enclosing try statement.
        this.tryEntries = [{
          tryLoc: "root"
        }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }

      exports.keys = function (object) {
        var keys = [];

        for (var key in object) {
          keys.push(key);
        }

        keys.reverse(); // Rather than returning an object with a next method, we keep
        // things simple and return the next function itself.

        return function next() {
          while (keys.length) {
            var key = keys.pop();

            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          } // To avoid creating an additional object, we just hang the .value
          // and .done properties off the next function object itself. This
          // also ensures that the minifier will not anonymize the function.


          next.done = true;
          return next;
        };
      };

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];

          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }

          if (typeof iterable.next === "function") {
            return iterable;
          }

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }

              next.value = undefined$1;
              next.done = true;
              return next;
            };

            return next.next = next;
          }
        } // Return an iterator with no values.


        return {
          next: doneResult
        };
      }

      exports.values = values;

      function doneResult() {
        return {
          value: undefined$1,
          done: true
        };
      }

      Context.prototype = {
        constructor: Context,
        reset: function (skipTempReset) {
          this.prev = 0;
          this.next = 0; // Resetting context._sent for legacy support of Babel's
          // function.sent implementation.

          this.sent = this._sent = undefined$1;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined$1;
          this.tryEntries.forEach(resetTryEntry);

          if (!skipTempReset) {
            for (var name in this) {
              // Not sure about the optimal order of these conditions:
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined$1;
              }
            }
          }
        },
        stop: function () {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;

          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }

          return this.rval;
        },
        dispatchException: function (exception) {
          if (this.done) {
            throw exception;
          }

          var context = this;

          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;

            if (caught) {
              // If the dispatched exception was caught by a catch block,
              // then let that catch block handle the exception normally.
              context.method = "next";
              context.arg = undefined$1;
            }

            return !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;

            if (entry.tryLoc === "root") {
              // Exception thrown outside of any try block that could handle
              // it, so set the completion value of the entire function to
              // throw the exception.
              return handle("end");
            }

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function (type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            // Ignore the finally entry if control is not jumping to a
            // location outside the try/catch block.
            finallyEntry = null;
          }

          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;

          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }

          return this.complete(record);
        },
        complete: function (record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }

          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }

          return ContinueSentinel;
        },
        finish: function (finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function (tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;

              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }

              return thrown;
            }
          } // The context.catch method must only be called with a location
          // argument that corresponds to a known catch block.


          throw new Error("illegal catch attempt");
        },
        delegateYield: function (iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };

          if (this.method === "next") {
            // Deliberately forget the last sent value so that we don't
            // accidentally pass it on to the delegate.
            this.arg = undefined$1;
          }

          return ContinueSentinel;
        }
      }; // Regardless of whether this script is executing as a CommonJS module
      // or not, return the runtime object so that we can declare the variable
      // regeneratorRuntime in the outer scope, which allows this module to be
      // injected easily by `bin/regenerator --include-runtime script.js`.

      return exports;
    }( // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
    module.exports );

    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      // This module should not be running in strict mode, so the above
      // assignment should always work unless something is misconfigured. Just
      // in case runtime.js accidentally runs in strict mode, in modern engines
      // we can explicitly access globalThis. In older engines we can escape
      // strict mode using a global Function call. This could conceivably fail
      // if a Content Security Policy forbids using Function, but in that case
      // the proper solution is to fix the accidental strict mode problem. If
      // you've misconfigured your bundler to force strict mode and applied a
      // CSP to forbid Function, and you're not willing to fix either of those
      // problems, please detail your unique predicament in a GitHub issue.
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  })(runtime);

  var regenerator = runtime.exports;

  var internalMetadata = {exports: {}};

  var fails$4 = fails$r;
  var arrayBufferNonExtensible = fails$4(function () {
    if (typeof ArrayBuffer == 'function') {
      var buffer = new ArrayBuffer(8); // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe

      if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', {
        value: 8
      });
    }
  });

  var fails$3 = fails$r;
  var isObject$2 = isObject$f;
  var classof$3 = classofRaw$1;
  var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible; // eslint-disable-next-line es/no-object-isextensible -- safe

  var $isExtensible = Object.isExtensible;
  var FAILS_ON_PRIMITIVES = fails$3(function () {
    $isExtensible(1);
  }); // `Object.isExtensible` method
  // https://tc39.es/ecma262/#sec-object.isextensible

  var objectIsExtensible = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
    if (!isObject$2(it)) return false;
    if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$3(it) == 'ArrayBuffer') return false;
    return $isExtensible ? $isExtensible(it) : true;
  } : $isExtensible;

  var fails$2 = fails$r;
  var freezing = !fails$2(function () {
    // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
    return Object.isExtensible(Object.preventExtensions({}));
  });

  var $$3 = _export;
  var uncurryThis$1 = functionUncurryThis;
  var hiddenKeys = hiddenKeys$6;
  var isObject$1 = isObject$f;
  var hasOwn$3 = hasOwnProperty_1;
  var defineProperty$2 = objectDefineProperty.f;
  var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
  var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
  var isExtensible = objectIsExtensible;
  var uid = uid$4;
  var FREEZING = freezing;
  var REQUIRED = false;
  var METADATA = uid('meta');
  var id = 0;

  var setMetadata = function (it) {
    defineProperty$2(it, METADATA, {
      value: {
        objectID: 'O' + id++,
        // object ID
        weakData: {} // weak collections IDs

      }
    });
  };

  var fastKey$1 = function (it, create) {
    // return a primitive with prefix
    if (!isObject$1(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

    if (!hasOwn$3(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F'; // not necessary to add metadata

      if (!create) return 'E'; // add missing metadata

      setMetadata(it); // return object ID
    }

    return it[METADATA].objectID;
  };

  var getWeakData = function (it, create) {
    if (!hasOwn$3(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true; // not necessary to add metadata

      if (!create) return false; // add missing metadata

      setMetadata(it); // return the store of weak collections IDs
    }

    return it[METADATA].weakData;
  }; // add metadata on freeze-family methods calling


  var onFreeze = function (it) {
    if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn$3(it, METADATA)) setMetadata(it);
    return it;
  };

  var enable = function () {
    meta.enable = function () {
      /* empty */
    };

    REQUIRED = true;
    var getOwnPropertyNames = getOwnPropertyNamesModule.f;
    var splice = uncurryThis$1([].splice);
    var test = {};
    test[METADATA] = 1; // prevent exposing of metadata key

    if (getOwnPropertyNames(test).length) {
      getOwnPropertyNamesModule.f = function (it) {
        var result = getOwnPropertyNames(it);

        for (var i = 0, length = result.length; i < length; i++) {
          if (result[i] === METADATA) {
            splice(result, i, 1);
            break;
          }
        }

        return result;
      };

      $$3({
        target: 'Object',
        stat: true,
        forced: true
      }, {
        getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
      });
    }
  };

  var meta = internalMetadata.exports = {
    enable: enable,
    fastKey: fastKey$1,
    getWeakData: getWeakData,
    onFreeze: onFreeze
  };
  hiddenKeys[METADATA] = true;

  var global$3 = global$M;
  var bind$1 = functionBindContext;
  var call = functionCall;
  var anObject = anObject$b;
  var tryToString = tryToString$4;
  var isArrayIteratorMethod = isArrayIteratorMethod$2;
  var lengthOfArrayLike$1 = lengthOfArrayLike$d;
  var isPrototypeOf$6 = objectIsPrototypeOf;
  var getIterator$5 = getIterator$7;
  var getIteratorMethod = getIteratorMethod$8;
  var iteratorClose = iteratorClose$2;
  var TypeError$2 = global$3.TypeError;

  var Result = function (stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };

  var ResultPrototype = Result.prototype;

  var iterate$2 = function (iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = bind$1(unboundFunction, that);
    var iterator, iterFn, index, length, result, next, step;

    var stop = function (condition) {
      if (iterator) iteratorClose(iterator, 'normal', condition);
      return new Result(true, condition);
    };

    var callFn = function (value) {
      if (AS_ENTRIES) {
        anObject(value);
        return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
      }

      return INTERRUPTED ? fn(value, stop) : fn(value);
    };

    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (!iterFn) throw TypeError$2(tryToString(iterable) + ' is not iterable'); // optimisation for array iterators

      if (isArrayIteratorMethod(iterFn)) {
        for (index = 0, length = lengthOfArrayLike$1(iterable); length > index; index++) {
          result = callFn(iterable[index]);
          if (result && isPrototypeOf$6(ResultPrototype, result)) return result;
        }

        return new Result(false);
      }

      iterator = getIterator$5(iterable, iterFn);
    }

    next = iterator.next;

    while (!(step = call(next, iterator)).done) {
      try {
        result = callFn(step.value);
      } catch (error) {
        iteratorClose(iterator, 'throw', error);
      }

      if (typeof result == 'object' && result && isPrototypeOf$6(ResultPrototype, result)) return result;
    }

    return new Result(false);
  };

  var global$2 = global$M;
  var isPrototypeOf$5 = objectIsPrototypeOf;
  var TypeError$1 = global$2.TypeError;

  var anInstance$2 = function (it, Prototype) {
    if (isPrototypeOf$5(Prototype, it)) return it;
    throw TypeError$1('Incorrect invocation');
  };

  var $$2 = _export;
  var global$1 = global$M;
  var InternalMetadataModule = internalMetadata.exports;
  var fails$1 = fails$r;
  var createNonEnumerableProperty = createNonEnumerableProperty$6;
  var iterate$1 = iterate$2;
  var anInstance$1 = anInstance$2;
  var isCallable = isCallable$h;
  var isObject = isObject$f;
  var setToStringTag = setToStringTag$5;
  var defineProperty$1 = objectDefineProperty.f;
  var forEach = arrayIteration.forEach;
  var DESCRIPTORS$2 = descriptors;
  var InternalStateModule$1 = internalState;
  var setInternalState$1 = InternalStateModule$1.set;
  var internalStateGetterFor$1 = InternalStateModule$1.getterFor;

  var collection$2 = function (CONSTRUCTOR_NAME, wrapper, common) {
    var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
    var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
    var ADDER = IS_MAP ? 'set' : 'add';
    var NativeConstructor = global$1[CONSTRUCTOR_NAME];
    var NativePrototype = NativeConstructor && NativeConstructor.prototype;
    var exported = {};
    var Constructor;

    if (!DESCRIPTORS$2 || !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$1(function () {
      new NativeConstructor().entries().next();
    }))) {
      // create collection constructor
      Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
      InternalMetadataModule.enable();
    } else {
      Constructor = wrapper(function (target, iterable) {
        setInternalState$1(anInstance$1(target, Prototype), {
          type: CONSTRUCTOR_NAME,
          collection: new NativeConstructor()
        });
        if (iterable != undefined) iterate$1(iterable, target[ADDER], {
          that: target,
          AS_ENTRIES: IS_MAP
        });
      });
      var Prototype = Constructor.prototype;
      var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
      forEach(['add', 'clear', 'delete', 'forEach', 'get', 'has', 'set', 'keys', 'values', 'entries'], function (KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';

        if (KEY in NativePrototype && !(IS_WEAK && KEY == 'clear')) {
          createNonEnumerableProperty(Prototype, KEY, function (a, b) {
            var collection = getInternalState(this).collection;
            if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
            var result = collection[KEY](a === 0 ? 0 : a, b);
            return IS_ADDER ? this : result;
          });
        }
      });
      IS_WEAK || defineProperty$1(Prototype, 'size', {
        configurable: true,
        get: function () {
          return getInternalState(this).collection.size;
        }
      });
    }

    setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);
    exported[CONSTRUCTOR_NAME] = Constructor;
    $$2({
      global: true,
      forced: true
    }, exported);
    if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
    return Constructor;
  };

  var redefine = redefine$4;

  var redefineAll$1 = function (target, src, options) {
    for (var key in src) {
      if (options && options.unsafe && target[key]) target[key] = src[key];else redefine(target, key, src[key], options);
    }

    return target;
  };

  var getBuiltIn = getBuiltIn$9;
  var definePropertyModule = objectDefineProperty;
  var wellKnownSymbol = wellKnownSymbol$j;
  var DESCRIPTORS$1 = descriptors;
  var SPECIES = wellKnownSymbol('species');

  var setSpecies$1 = function (CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
    var defineProperty = definePropertyModule.f;

    if (DESCRIPTORS$1 && Constructor && !Constructor[SPECIES]) {
      defineProperty(Constructor, SPECIES, {
        configurable: true,
        get: function () {
          return this;
        }
      });
    }
  };

  var defineProperty = objectDefineProperty.f;
  var create = objectCreate;
  var redefineAll = redefineAll$1;
  var bind = functionBindContext;
  var anInstance = anInstance$2;
  var iterate = iterate$2;
  var defineIterator = defineIterator$3;
  var setSpecies = setSpecies$1;
  var DESCRIPTORS = descriptors;
  var fastKey = internalMetadata.exports.fastKey;
  var InternalStateModule = internalState;
  var setInternalState = InternalStateModule.set;
  var internalStateGetterFor = InternalStateModule.getterFor;
  var collectionStrong$2 = {
    getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
      var Constructor = wrapper(function (that, iterable) {
        anInstance(that, Prototype);
        setInternalState(that, {
          type: CONSTRUCTOR_NAME,
          index: create(null),
          first: undefined,
          last: undefined,
          size: 0
        });
        if (!DESCRIPTORS) that.size = 0;
        if (iterable != undefined) iterate(iterable, that[ADDER], {
          that: that,
          AS_ENTRIES: IS_MAP
        });
      });
      var Prototype = Constructor.prototype;
      var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

      var define = function (that, key, value) {
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        var previous, index; // change existing entry

        if (entry) {
          entry.value = value; // create new entry
        } else {
          state.last = entry = {
            index: index = fastKey(key, true),
            key: key,
            value: value,
            previous: previous = state.last,
            next: undefined,
            removed: false
          };
          if (!state.first) state.first = entry;
          if (previous) previous.next = entry;
          if (DESCRIPTORS) state.size++;else that.size++; // add to index

          if (index !== 'F') state.index[index] = entry;
        }

        return that;
      };

      var getEntry = function (that, key) {
        var state = getInternalState(that); // fast case

        var index = fastKey(key);
        var entry;
        if (index !== 'F') return state.index[index]; // frozen object case

        for (entry = state.first; entry; entry = entry.next) {
          if (entry.key == key) return entry;
        }
      };

      redefineAll(Prototype, {
        // `{ Map, Set }.prototype.clear()` methods
        // https://tc39.es/ecma262/#sec-map.prototype.clear
        // https://tc39.es/ecma262/#sec-set.prototype.clear
        clear: function clear() {
          var that = this;
          var state = getInternalState(that);
          var data = state.index;
          var entry = state.first;

          while (entry) {
            entry.removed = true;
            if (entry.previous) entry.previous = entry.previous.next = undefined;
            delete data[entry.index];
            entry = entry.next;
          }

          state.first = state.last = undefined;
          if (DESCRIPTORS) state.size = 0;else that.size = 0;
        },
        // `{ Map, Set }.prototype.delete(key)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.delete
        // https://tc39.es/ecma262/#sec-set.prototype.delete
        'delete': function (key) {
          var that = this;
          var state = getInternalState(that);
          var entry = getEntry(that, key);

          if (entry) {
            var next = entry.next;
            var prev = entry.previous;
            delete state.index[entry.index];
            entry.removed = true;
            if (prev) prev.next = next;
            if (next) next.previous = prev;
            if (state.first == entry) state.first = next;
            if (state.last == entry) state.last = prev;
            if (DESCRIPTORS) state.size--;else that.size--;
          }

          return !!entry;
        },
        // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.foreach
        // https://tc39.es/ecma262/#sec-set.prototype.foreach
        forEach: function forEach(callbackfn
        /* , that = undefined */
        ) {
          var state = getInternalState(this);
          var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
          var entry;

          while (entry = entry ? entry.next : state.first) {
            boundFunction(entry.value, entry.key, this); // revert to the last existing entry

            while (entry && entry.removed) entry = entry.previous;
          }
        },
        // `{ Map, Set}.prototype.has(key)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.has
        // https://tc39.es/ecma262/#sec-set.prototype.has
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      redefineAll(Prototype, IS_MAP ? {
        // `Map.prototype.get(key)` method
        // https://tc39.es/ecma262/#sec-map.prototype.get
        get: function get(key) {
          var entry = getEntry(this, key);
          return entry && entry.value;
        },
        // `Map.prototype.set(key, value)` method
        // https://tc39.es/ecma262/#sec-map.prototype.set
        set: function set(key, value) {
          return define(this, key === 0 ? 0 : key, value);
        }
      } : {
        // `Set.prototype.add(value)` method
        // https://tc39.es/ecma262/#sec-set.prototype.add
        add: function add(value) {
          return define(this, value = value === 0 ? 0 : value, value);
        }
      });
      if (DESCRIPTORS) defineProperty(Prototype, 'size', {
        get: function () {
          return getInternalState(this).size;
        }
      });
      return Constructor;
    },
    setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
      var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
      var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
      var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME); // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.entries
      // https://tc39.es/ecma262/#sec-map.prototype.keys
      // https://tc39.es/ecma262/#sec-map.prototype.values
      // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
      // https://tc39.es/ecma262/#sec-set.prototype.entries
      // https://tc39.es/ecma262/#sec-set.prototype.keys
      // https://tc39.es/ecma262/#sec-set.prototype.values
      // https://tc39.es/ecma262/#sec-set.prototype-@@iterator

      defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
        setInternalState(this, {
          type: ITERATOR_NAME,
          target: iterated,
          state: getInternalCollectionState(iterated),
          kind: kind,
          last: undefined
        });
      }, function () {
        var state = getInternalIteratorState(this);
        var kind = state.kind;
        var entry = state.last; // revert to the last existing entry

        while (entry && entry.removed) entry = entry.previous; // get next entry


        if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
          // or finish the iteration
          state.target = undefined;
          return {
            value: undefined,
            done: true
          };
        } // return step by kind


        if (kind == 'keys') return {
          value: entry.key,
          done: false
        };
        if (kind == 'values') return {
          value: entry.value,
          done: false
        };
        return {
          value: [entry.key, entry.value],
          done: false
        };
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // `{ Map, Set }.prototype[@@species]` accessors
      // https://tc39.es/ecma262/#sec-get-map-@@species
      // https://tc39.es/ecma262/#sec-get-set-@@species

      setSpecies(CONSTRUCTOR_NAME);
    }
  };

  var collection$1 = collection$2;
  var collectionStrong$1 = collectionStrong$2; // `Map` constructor
  // https://tc39.es/ecma262/#sec-map-objects

  collection$1('Map', function (init) {
    return function Map() {
      return init(this, arguments.length ? arguments[0] : undefined);
    };
  }, collectionStrong$1);

  var path$1 = path$q;
  var map$2 = path$1.Map;

  var parent$9 = map$2;
  var map$1 = parent$9;

  var map = map$1;

  var $$1 = _export;
  var $some = arrayIteration.some;
  var arrayMethodIsStrict$1 = arrayMethodIsStrict$5;
  var STRICT_METHOD$1 = arrayMethodIsStrict$1('some'); // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some

  $$1({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD$1
  }, {
    some: function some(callbackfn
    /* , thisArg */
    ) {
      return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var entryVirtual$4 = entryVirtual$k;
  var some$3 = entryVirtual$4('Array').some;

  var isPrototypeOf$4 = objectIsPrototypeOf;
  var method$4 = some$3;
  var ArrayPrototype$4 = Array.prototype;

  var some$2 = function (it) {
    var own = it.some;
    return it === ArrayPrototype$4 || isPrototypeOf$4(ArrayPrototype$4, it) && own === ArrayPrototype$4.some ? method$4 : own;
  };

  var parent$8 = some$2;
  var some$1 = parent$8;

  var some = some$1;

  var entryVirtual$3 = entryVirtual$k;
  var keys$3 = entryVirtual$3('Array').keys;

  var parent$7 = keys$3;
  var keys$2 = parent$7;

  var classof$2 = classof$c;
  var hasOwn$2 = hasOwnProperty_1;
  var isPrototypeOf$3 = objectIsPrototypeOf;
  var method$3 = keys$2;
  var ArrayPrototype$3 = Array.prototype;
  var DOMIterables$2 = {
    DOMTokenList: true,
    NodeList: true
  };

  var keys$1 = function (it) {
    var own = it.keys;
    return it === ArrayPrototype$3 || isPrototypeOf$3(ArrayPrototype$3, it) && own === ArrayPrototype$3.keys || hasOwn$2(DOMIterables$2, classof$2(it)) ? method$3 : own;
  };

  var keys = keys$1;

  var arraySlice = arraySliceSimple;
  var floor = Math.floor;

  var mergeSort = function (array, comparefn) {
    var length = array.length;
    var middle = floor(length / 2);
    return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySlice(array, 0, middle), comparefn), mergeSort(arraySlice(array, middle), comparefn), comparefn);
  };

  var insertionSort = function (array, comparefn) {
    var length = array.length;
    var i = 1;
    var element, j;

    while (i < length) {
      j = i;
      element = array[i];

      while (j && comparefn(array[j - 1], element) > 0) {
        array[j] = array[--j];
      }

      if (j !== i++) array[j] = element;
    }

    return array;
  };

  var merge = function (array, left, right, comparefn) {
    var llength = left.length;
    var rlength = right.length;
    var lindex = 0;
    var rindex = 0;

    while (lindex < llength || rindex < rlength) {
      array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
    }

    return array;
  };

  var arraySort = mergeSort;

  var userAgent$1 = engineUserAgent;
  var firefox = userAgent$1.match(/firefox\/(\d+)/i);
  var engineFfVersion = !!firefox && +firefox[1];

  var UA = engineUserAgent;
  var engineIsIeOrEdge = /MSIE|Trident/.test(UA);

  var userAgent = engineUserAgent;
  var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
  var engineWebkitVersion = !!webkit && +webkit[1];

  var $ = _export;
  var uncurryThis = functionUncurryThis;
  var aCallable = aCallable$7;
  var toObject = toObject$e;
  var lengthOfArrayLike = lengthOfArrayLike$d;
  var toString = toString$7;
  var fails = fails$r;
  var internalSort = arraySort;
  var arrayMethodIsStrict = arrayMethodIsStrict$5;
  var FF = engineFfVersion;
  var IE_OR_EDGE = engineIsIeOrEdge;
  var V8 = engineV8Version;
  var WEBKIT = engineWebkitVersion;
  var test = [];
  var un$Sort = uncurryThis(test.sort);
  var push = uncurryThis(test.push); // IE8-

  var FAILS_ON_UNDEFINED = fails(function () {
    test.sort(undefined);
  }); // V8 bug

  var FAILS_ON_NULL = fails(function () {
    test.sort(null);
  }); // Old WebKit

  var STRICT_METHOD = arrayMethodIsStrict('sort');
  var STABLE_SORT = !fails(function () {
    // feature detection can be too slow, so check engines versions
    if (V8) return V8 < 70;
    if (FF && FF > 3) return;
    if (IE_OR_EDGE) return true;
    if (WEBKIT) return WEBKIT < 603;
    var result = '';
    var code, chr, value, index; // generate an array with more 512 elements (Chakra and old V8 fails only in this case)

    for (code = 65; code < 76; code++) {
      chr = String.fromCharCode(code);

      switch (code) {
        case 66:
        case 69:
        case 70:
        case 72:
          value = 3;
          break;

        case 68:
        case 71:
          value = 4;
          break;

        default:
          value = 2;
      }

      for (index = 0; index < 47; index++) {
        test.push({
          k: chr + index,
          v: value
        });
      }
    }

    test.sort(function (a, b) {
      return b.v - a.v;
    });

    for (index = 0; index < test.length; index++) {
      chr = test[index].k.charAt(0);
      if (result.charAt(result.length - 1) !== chr) result += chr;
    }

    return result !== 'DGBEFHACIJK';
  });
  var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;

  var getSortCompare = function (comparefn) {
    return function (x, y) {
      if (y === undefined) return -1;
      if (x === undefined) return 1;
      if (comparefn !== undefined) return +comparefn(x, y) || 0;
      return toString(x) > toString(y) ? 1 : -1;
    };
  }; // `Array.prototype.sort` method
  // https://tc39.es/ecma262/#sec-array.prototype.sort


  $({
    target: 'Array',
    proto: true,
    forced: FORCED
  }, {
    sort: function sort(comparefn) {
      if (comparefn !== undefined) aCallable(comparefn);
      var array = toObject(this);
      if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);
      var items = [];
      var arrayLength = lengthOfArrayLike(array);
      var itemsLength, index;

      for (index = 0; index < arrayLength; index++) {
        if (index in array) push(items, array[index]);
      }

      internalSort(items, getSortCompare(comparefn));
      itemsLength = items.length;
      index = 0;

      while (index < itemsLength) array[index] = items[index++];

      while (index < arrayLength) delete array[index++];

      return array;
    }
  });

  var entryVirtual$2 = entryVirtual$k;
  var sort$3 = entryVirtual$2('Array').sort;

  var isPrototypeOf$2 = objectIsPrototypeOf;
  var method$2 = sort$3;
  var ArrayPrototype$2 = Array.prototype;

  var sort$2 = function (it) {
    var own = it.sort;
    return it === ArrayPrototype$2 || isPrototypeOf$2(ArrayPrototype$2, it) && own === ArrayPrototype$2.sort ? method$2 : own;
  };

  var parent$6 = sort$2;
  var sort$1 = parent$6;

  var sort = sort$1;

  var entryVirtual$1 = entryVirtual$k;
  var values$3 = entryVirtual$1('Array').values;

  var parent$5 = values$3;
  var values$2 = parent$5;

  var classof$1 = classof$c;
  var hasOwn$1 = hasOwnProperty_1;
  var isPrototypeOf$1 = objectIsPrototypeOf;
  var method$1 = values$2;
  var ArrayPrototype$1 = Array.prototype;
  var DOMIterables$1 = {
    DOMTokenList: true,
    NodeList: true
  };

  var values$1 = function (it) {
    var own = it.values;
    return it === ArrayPrototype$1 || isPrototypeOf$1(ArrayPrototype$1, it) && own === ArrayPrototype$1.values || hasOwn$1(DOMIterables$1, classof$1(it)) ? method$1 : own;
  };

  var values = values$1;

  var iterator = iterator$4;

  var entryVirtual = entryVirtual$k;
  var entries$3 = entryVirtual('Array').entries;

  var parent$4 = entries$3;
  var entries$2 = parent$4;

  var classof = classof$c;
  var hasOwn = hasOwnProperty_1;
  var isPrototypeOf = objectIsPrototypeOf;
  var method = entries$2;
  var ArrayPrototype = Array.prototype;
  var DOMIterables = {
    DOMTokenList: true,
    NodeList: true
  };

  var entries$1 = function (it) {
    var own = it.entries;
    return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.entries || hasOwn(DOMIterables, classof(it)) ? method : own;
  };

  var entries = entries$1;

  // Unique ID creation requires a high quality random # generator. In the browser we therefore
  // require the crypto API and do not support built-in fallback to lower quality random number
  // generators (like Math.random()).
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
      // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
      // find the complete implementation of crypto (msCrypto) on IE11.
      getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

      if (!getRandomValues) {
        throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
      }
    }

    return getRandomValues(rnds8);
  }

  var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

  function validate(uuid) {
    return typeof uuid === 'string' && REGEX.test(uuid);
  }

  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */

  var byteToHex = [];

  for (var i = 0; i < 256; ++i) {
    byteToHex.push((i + 0x100).toString(16).substr(1));
  }

  function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields

    if (!validate(uuid)) {
      throw TypeError('Stringified UUID is invalid');
    }

    return uuid;
  }

  function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }

      return buf;
    }

    return stringify(rnds);
  }

  /**
   * Determine whether a value can be used as an id.
   *
   * @param value - Input value of unknown type.
   * @returns True if the value is valid id, false otherwise.
   */
  function isId(value) {
    return typeof value === "string" || typeof value === "number";
  }

  /**
   * A queue.
   *
   * @typeParam T - The type of method names to be replaced by queued versions.
   */
  var Queue = /*#__PURE__*/function () {
    /** Delay in milliseconds. If defined the queue will be periodically flushed. */

    /** Maximum number of entries in the queue before it will be flushed. */

    /**
     * Construct a new Queue.
     *
     * @param options - Queue configuration.
     */
    function Queue(options) {
      _classCallCheck(this, Queue);

      _defineProperty(this, "delay", void 0);

      _defineProperty(this, "max", void 0);

      _defineProperty(this, "_queue", []);

      _defineProperty(this, "_timeout", null);

      _defineProperty(this, "_extended", null);

      // options
      this.delay = null;
      this.max = Infinity;
      this.setOptions(options);
    }
    /**
     * Update the configuration of the queue.
     *
     * @param options - Queue configuration.
     */


    _createClass(Queue, [{
      key: "setOptions",
      value: function setOptions(options) {
        if (options && typeof options.delay !== "undefined") {
          this.delay = options.delay;
        }

        if (options && typeof options.max !== "undefined") {
          this.max = options.max;
        }

        this._flushIfNeeded();
      }
      /**
       * Extend an object with queuing functionality.
       * The object will be extended with a function flush, and the methods provided in options.replace will be replaced with queued ones.
       *
       * @param object - The object to be extended.
       * @param options - Additional options.
       * @returns The created queue.
       */

    }, {
      key: "destroy",
      value:
      /**
       * Destroy the queue. The queue will first flush all queued actions, and in case it has extended an object, will restore the original object.
       */
      function destroy() {
        this.flush();

        if (this._extended) {
          var object = this._extended.object;
          var methods = this._extended.methods;

          for (var i = 0; i < methods.length; i++) {
            var method = methods[i];

            if (method.original) {
              // @TODO: better solution?
              object[method.name] = method.original;
            } else {
              // @TODO: better solution?
              delete object[method.name];
            }
          }

          this._extended = null;
        }
      }
      /**
       * Replace a method on an object with a queued version.
       *
       * @param object - Object having the method.
       * @param method - The method name.
       */

    }, {
      key: "replace",
      value: function replace(object, method) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias -- Function this is necessary in the function bellow, so class this has to be saved into a variable here. */
        var me = this;
        var original = object[method];

        if (!original) {
          throw new Error("Method " + method + " undefined");
        }

        object[method] = function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          // add this call to the queue
          me.queue({
            args: args,
            fn: original,
            context: this
          });
        };
      }
      /**
       * Queue a call.
       *
       * @param entry - The function or entry to be queued.
       */

    }, {
      key: "queue",
      value: function queue(entry) {
        if (typeof entry === "function") {
          this._queue.push({
            fn: entry
          });
        } else {
          this._queue.push(entry);
        }

        this._flushIfNeeded();
      }
      /**
       * Check whether the queue needs to be flushed.
       */

    }, {
      key: "_flushIfNeeded",
      value: function _flushIfNeeded() {
        var _this = this;

        // flush when the maximum is exceeded.
        if (this._queue.length > this.max) {
          this.flush();
        } // flush after a period of inactivity when a delay is configured


        if (this._timeout != null) {
          clearTimeout(this._timeout);
          this._timeout = null;
        }

        if (this.queue.length > 0 && typeof this.delay === "number") {
          this._timeout = setTimeout$1(function () {
            _this.flush();
          }, this.delay);
        }
      }
      /**
       * Flush all queued calls
       */

    }, {
      key: "flush",
      value: function flush() {
        var _context, _context2;

        forEach$1(_context = splice(_context2 = this._queue).call(_context2, 0)).call(_context, function (entry) {
          entry.fn.apply(entry.context || entry.fn, entry.args || []);
        });
      }
    }], [{
      key: "extend",
      value: function extend(object, options) {
        var queue = new Queue(options);

        if (object.flush !== undefined) {
          throw new Error("Target object already has a property flush");
        }

        object.flush = function () {
          queue.flush();
        };

        var methods = [{
          name: "flush",
          original: undefined
        }];

        if (options && options.replace) {
          for (var i = 0; i < options.replace.length; i++) {
            var name = options.replace[i];
            methods.push({
              name: name,
              // @TODO: better solution?
              original: object[name]
            }); // @TODO: better solution?

            queue.replace(object, name);
          }
        }

        queue._extended = {
          object: object,
          methods: methods
        };
        return queue;
      }
    }]);

    return Queue;
  }();

  /**
   * [[DataSet]] code that can be reused in [[DataView]] or other similar implementations of [[DataInterface]].
   *
   * @typeParam Item - Item type that may or may not have an id.
   * @typeParam IdProp - Name of the property that contains the id.
   */
  var DataSetPart = /*#__PURE__*/function () {
    function DataSetPart() {
      _classCallCheck(this, DataSetPart);

      _defineProperty(this, "_subscribers", {
        "*": [],
        add: [],
        remove: [],
        update: []
      });

      _defineProperty(this, "subscribe", DataSetPart.prototype.on);

      _defineProperty(this, "unsubscribe", DataSetPart.prototype.off);
    }

    _createClass(DataSetPart, [{
      key: "_trigger",
      value:
      /**
       * Trigger an event
       *
       * @param event - Event name.
       * @param payload - Event payload.
       * @param senderId - Id of the sender.
       */
      function _trigger(event, payload, senderId) {
        var _context, _context2;

        if (event === "*") {
          throw new Error("Cannot trigger event *");
        }

        forEach$1(_context = concat$1(_context2 = []).call(_context2, _toConsumableArray(this._subscribers[event]), _toConsumableArray(this._subscribers["*"]))).call(_context, function (subscriber) {
          subscriber(event, payload, senderId != null ? senderId : null);
        });
      }
      /**
       * Subscribe to an event, add an event listener.
       *
       * @remarks Non-function callbacks are ignored.
       * @param event - Event name.
       * @param callback - Callback method.
       */

    }, {
      key: "on",
      value: function on(event, callback) {
        if (typeof callback === "function") {
          this._subscribers[event].push(callback);
        } // @TODO: Maybe throw for invalid callbacks?

      }
      /**
       * Unsubscribe from an event, remove an event listener.
       *
       * @remarks If the same callback was subscribed more than once **all** occurences will be removed.
       * @param event - Event name.
       * @param callback - Callback method.
       */

    }, {
      key: "off",
      value: function off(event, callback) {
        var _context3;

        this._subscribers[event] = filter(_context3 = this._subscribers[event]).call(_context3, function (subscriber) {
          return subscriber !== callback;
        });
      }
      /**
       * @deprecated Use on instead (PS: DataView.subscribe === DataView.on).
       */

    }]);

    return DataSetPart;
  }();

  var collection = collection$2;
  var collectionStrong = collectionStrong$2; // `Set` constructor
  // https://tc39.es/ecma262/#sec-set-objects

  collection('Set', function (init) {
    return function Set() {
      return init(this, arguments.length ? arguments[0] : undefined);
    };
  }, collectionStrong);

  var path = path$q;
  var set$2 = path.Set;

  var parent$3 = set$2;
  var set$1 = parent$3;

  var set = set$1;

  var getIterator$4 = getIterator$7;
  var getIterator_1 = getIterator$4;

  var parent$2 = getIterator_1;
  var getIterator$3 = parent$2;

  var parent$1 = getIterator$3;
  var getIterator$2 = parent$1;

  var parent = getIterator$2;
  var getIterator$1 = parent;

  var getIterator = getIterator$1;

  var _Symbol$iterator;

  function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$1(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$2(o, minLen) { var _context10; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = slice(_context10 = Object.prototype.toString.call(o)).call(_context10, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

  function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  _Symbol$iterator = iterator;

  /**
   * Data stream
   *
   * @remarks
   * [[DataStream]] offers an always up to date stream of items from a [[DataSet]] or [[DataView]].
   * That means that the stream is evaluated at the time of iteration, conversion to another data type or when [[cache]] is called, not when the [[DataStream]] was created.
   * Multiple invocations of for example [[toItemArray]] may yield different results (if the data source like for example [[DataSet]] gets modified).
   * @typeParam Item - The item type this stream is going to work with.
   */
  var DataStream = /*#__PURE__*/function () {
    /**
     * Create a new data stream.
     *
     * @param pairs - The id, item pairs.
     */
    function DataStream(pairs) {
      _classCallCheck(this, DataStream);

      _defineProperty(this, "_pairs", void 0);

      this._pairs = pairs;
    }
    /**
     * Return an iterable of key, value pairs for every entry in the stream.
     */


    _createClass(DataStream, [{
      key: _Symbol$iterator,
      value:
      /*#__PURE__*/
      regenerator.mark(function value() {
        var _iterator, _step, _step$value, id, item;

        return regenerator.wrap(function value$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _iterator = _createForOfIteratorHelper$2(this._pairs);
                _context.prev = 1;

                _iterator.s();

              case 3:
                if ((_step = _iterator.n()).done) {
                  _context.next = 9;
                  break;
                }

                _step$value = _slicedToArray(_step.value, 2), id = _step$value[0], item = _step$value[1];
                _context.next = 7;
                return [id, item];

              case 7:
                _context.next = 3;
                break;

              case 9:
                _context.next = 14;
                break;

              case 11:
                _context.prev = 11;
                _context.t0 = _context["catch"](1);

                _iterator.e(_context.t0);

              case 14:
                _context.prev = 14;

                _iterator.f();

                return _context.finish(14);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, value, this, [[1, 11, 14, 17]]);
      })
      /**
       * Return an iterable of key, value pairs for every entry in the stream.
       */

    }, {
      key: "entries",
      value:
      /*#__PURE__*/
      regenerator.mark(function entries() {
        var _iterator2, _step2, _step2$value, id, item;

        return regenerator.wrap(function entries$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _iterator2 = _createForOfIteratorHelper$2(this._pairs);
                _context2.prev = 1;

                _iterator2.s();

              case 3:
                if ((_step2 = _iterator2.n()).done) {
                  _context2.next = 9;
                  break;
                }

                _step2$value = _slicedToArray(_step2.value, 2), id = _step2$value[0], item = _step2$value[1];
                _context2.next = 7;
                return [id, item];

              case 7:
                _context2.next = 3;
                break;

              case 9:
                _context2.next = 14;
                break;

              case 11:
                _context2.prev = 11;
                _context2.t0 = _context2["catch"](1);

                _iterator2.e(_context2.t0);

              case 14:
                _context2.prev = 14;

                _iterator2.f();

                return _context2.finish(14);

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, entries, this, [[1, 11, 14, 17]]);
      })
      /**
       * Return an iterable of keys in the stream.
       */

    }, {
      key: "keys",
      value:
      /*#__PURE__*/
      regenerator.mark(function keys() {
        var _iterator3, _step3, _step3$value, id;

        return regenerator.wrap(function keys$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _iterator3 = _createForOfIteratorHelper$2(this._pairs);
                _context3.prev = 1;

                _iterator3.s();

              case 3:
                if ((_step3 = _iterator3.n()).done) {
                  _context3.next = 9;
                  break;
                }

                _step3$value = _slicedToArray(_step3.value, 1), id = _step3$value[0];
                _context3.next = 7;
                return id;

              case 7:
                _context3.next = 3;
                break;

              case 9:
                _context3.next = 14;
                break;

              case 11:
                _context3.prev = 11;
                _context3.t0 = _context3["catch"](1);

                _iterator3.e(_context3.t0);

              case 14:
                _context3.prev = 14;

                _iterator3.f();

                return _context3.finish(14);

              case 17:
              case "end":
                return _context3.stop();
            }
          }
        }, keys, this, [[1, 11, 14, 17]]);
      })
      /**
       * Return an iterable of values in the stream.
       */

    }, {
      key: "values",
      value:
      /*#__PURE__*/
      regenerator.mark(function values() {
        var _iterator4, _step4, _step4$value, item;

        return regenerator.wrap(function values$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _iterator4 = _createForOfIteratorHelper$2(this._pairs);
                _context4.prev = 1;

                _iterator4.s();

              case 3:
                if ((_step4 = _iterator4.n()).done) {
                  _context4.next = 9;
                  break;
                }

                _step4$value = _slicedToArray(_step4.value, 2), item = _step4$value[1];
                _context4.next = 7;
                return item;

              case 7:
                _context4.next = 3;
                break;

              case 9:
                _context4.next = 14;
                break;

              case 11:
                _context4.prev = 11;
                _context4.t0 = _context4["catch"](1);

                _iterator4.e(_context4.t0);

              case 14:
                _context4.prev = 14;

                _iterator4.f();

                return _context4.finish(14);

              case 17:
              case "end":
                return _context4.stop();
            }
          }
        }, values, this, [[1, 11, 14, 17]]);
      })
      /**
       * Return an array containing all the ids in this stream.
       *
       * @remarks
       * The array may contain duplicities.
       * @returns The array with all ids from this stream.
       */

    }, {
      key: "toIdArray",
      value: function toIdArray() {
        var _context5;

        return map$3(_context5 = _toConsumableArray(this._pairs)).call(_context5, function (pair) {
          return pair[0];
        });
      }
      /**
       * Return an array containing all the items in this stream.
       *
       * @remarks
       * The array may contain duplicities.
       * @returns The array with all items from this stream.
       */

    }, {
      key: "toItemArray",
      value: function toItemArray() {
        var _context6;

        return map$3(_context6 = _toConsumableArray(this._pairs)).call(_context6, function (pair) {
          return pair[1];
        });
      }
      /**
       * Return an array containing all the entries in this stream.
       *
       * @remarks
       * The array may contain duplicities.
       * @returns The array with all entries from this stream.
       */

    }, {
      key: "toEntryArray",
      value: function toEntryArray() {
        return _toConsumableArray(this._pairs);
      }
      /**
       * Return an object map containing all the items in this stream accessible by ids.
       *
       * @remarks
       * In case of duplicate ids (coerced to string so `7 == '7'`) the last encoutered appears in the returned object.
       * @returns The object map of all id  item pairs from this stream.
       */

    }, {
      key: "toObjectMap",
      value: function toObjectMap() {
        var map = create$5(null);

        var _iterator5 = _createForOfIteratorHelper$2(this._pairs),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = _slicedToArray(_step5.value, 2),
                id = _step5$value[0],
                item = _step5$value[1];

            map[id] = item;
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        return map;
      }
      /**
       * Return a map containing all the items in this stream accessible by ids.
       *
       * @returns The map of all id  item pairs from this stream.
       */

    }, {
      key: "toMap",
      value: function toMap() {
        return new map(this._pairs);
      }
      /**
       * Return a set containing all the (unique) ids in this stream.
       *
       * @returns The set of all ids from this stream.
       */

    }, {
      key: "toIdSet",
      value: function toIdSet() {
        return new set(this.toIdArray());
      }
      /**
       * Return a set containing all the (unique) items in this stream.
       *
       * @returns The set of all items from this stream.
       */

    }, {
      key: "toItemSet",
      value: function toItemSet() {
        return new set(this.toItemArray());
      }
      /**
       * Cache the items from this stream.
       *
       * @remarks
       * This method allows for items to be fetched immediatelly and used (possibly multiple times) later.
       * It can also be used to optimize performance as [[DataStream]] would otherwise reevaluate everything upon each iteration.
       *
       * ## Example
       * ```javascript
       * const ds = new DataSet([])
       *
       * const cachedStream = ds.stream()
       *   .filter()
       *   .sort()
       *   .map()
       *   .cached() // Data are fetched, processed and cached here.
       *
       * ds.clear()
       * chachedStream // Still has all the items.
       * ```
       * @returns A new [[DataStream]] with cached items (detached from the original [[DataSet]]).
       */

    }, {
      key: "cache",
      value: function cache() {
        return new DataStream(_toConsumableArray(this._pairs));
      }
      /**
       * Get the distinct values of given property.
       *
       * @param callback - The function that picks and possibly converts the property.
       * @typeParam T - The type of the distinct value.
       * @returns A set of all distinct properties.
       */

    }, {
      key: "distinct",
      value: function distinct(callback) {
        var set$1 = new set();

        var _iterator6 = _createForOfIteratorHelper$2(this._pairs),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var _step6$value = _slicedToArray(_step6.value, 2),
                id = _step6$value[0],
                item = _step6$value[1];

            set$1.add(callback(item, id));
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        return set$1;
      }
      /**
       * Filter the items of the stream.
       *
       * @param callback - The function that decides whether an item will be included.
       * @returns A new data stream with the filtered items.
       */

    }, {
      key: "filter",
      value: function filter(callback) {
        var pairs = this._pairs;
        return new DataStream(_defineProperty({}, iterator, /*#__PURE__*/regenerator.mark(function _callee() {
          var _iterator7, _step7, _step7$value, id, item;

          return regenerator.wrap(function _callee$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _iterator7 = _createForOfIteratorHelper$2(pairs);
                  _context7.prev = 1;

                  _iterator7.s();

                case 3:
                  if ((_step7 = _iterator7.n()).done) {
                    _context7.next = 10;
                    break;
                  }

                  _step7$value = _slicedToArray(_step7.value, 2), id = _step7$value[0], item = _step7$value[1];

                  if (!callback(item, id)) {
                    _context7.next = 8;
                    break;
                  }

                  _context7.next = 8;
                  return [id, item];

                case 8:
                  _context7.next = 3;
                  break;

                case 10:
                  _context7.next = 15;
                  break;

                case 12:
                  _context7.prev = 12;
                  _context7.t0 = _context7["catch"](1);

                  _iterator7.e(_context7.t0);

                case 15:
                  _context7.prev = 15;

                  _iterator7.f();

                  return _context7.finish(15);

                case 18:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee, null, [[1, 12, 15, 18]]);
        })));
      }
      /**
       * Execute a callback for each item of the stream.
       *
       * @param callback - The function that will be invoked for each item.
       */

    }, {
      key: "forEach",
      value: function forEach(callback) {
        var _iterator8 = _createForOfIteratorHelper$2(this._pairs),
            _step8;

        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var _step8$value = _slicedToArray(_step8.value, 2),
                id = _step8$value[0],
                item = _step8$value[1];

            callback(item, id);
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
      }
      /**
       * Map the items into a different type.
       *
       * @param callback - The function that does the conversion.
       * @typeParam Mapped - The type of the item after mapping.
       * @returns A new data stream with the mapped items.
       */

    }, {
      key: "map",
      value: function map(callback) {
        var pairs = this._pairs;
        return new DataStream(_defineProperty({}, iterator, /*#__PURE__*/regenerator.mark(function _callee2() {
          var _iterator9, _step9, _step9$value, id, item;

          return regenerator.wrap(function _callee2$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  _iterator9 = _createForOfIteratorHelper$2(pairs);
                  _context8.prev = 1;

                  _iterator9.s();

                case 3:
                  if ((_step9 = _iterator9.n()).done) {
                    _context8.next = 9;
                    break;
                  }

                  _step9$value = _slicedToArray(_step9.value, 2), id = _step9$value[0], item = _step9$value[1];
                  _context8.next = 7;
                  return [id, callback(item, id)];

                case 7:
                  _context8.next = 3;
                  break;

                case 9:
                  _context8.next = 14;
                  break;

                case 11:
                  _context8.prev = 11;
                  _context8.t0 = _context8["catch"](1);

                  _iterator9.e(_context8.t0);

                case 14:
                  _context8.prev = 14;

                  _iterator9.f();

                  return _context8.finish(14);

                case 17:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee2, null, [[1, 11, 14, 17]]);
        })));
      }
      /**
       * Get the item with the maximum value of given property.
       *
       * @param callback - The function that picks and possibly converts the property.
       * @returns The item with the maximum if found otherwise null.
       */

    }, {
      key: "max",
      value: function max(callback) {
        var iter = getIterator(this._pairs);

        var curr = iter.next();

        if (curr.done) {
          return null;
        }

        var maxItem = curr.value[1];
        var maxValue = callback(curr.value[1], curr.value[0]);

        while (!(curr = iter.next()).done) {
          var _curr$value = _slicedToArray(curr.value, 2),
              id = _curr$value[0],
              item = _curr$value[1];

          var _value = callback(item, id);

          if (_value > maxValue) {
            maxValue = _value;
            maxItem = item;
          }
        }

        return maxItem;
      }
      /**
       * Get the item with the minimum value of given property.
       *
       * @param callback - The function that picks and possibly converts the property.
       * @returns The item with the minimum if found otherwise null.
       */

    }, {
      key: "min",
      value: function min(callback) {
        var iter = getIterator(this._pairs);

        var curr = iter.next();

        if (curr.done) {
          return null;
        }

        var minItem = curr.value[1];
        var minValue = callback(curr.value[1], curr.value[0]);

        while (!(curr = iter.next()).done) {
          var _curr$value2 = _slicedToArray(curr.value, 2),
              id = _curr$value2[0],
              item = _curr$value2[1];

          var _value2 = callback(item, id);

          if (_value2 < minValue) {
            minValue = _value2;
            minItem = item;
          }
        }

        return minItem;
      }
      /**
       * Reduce the items into a single value.
       *
       * @param callback - The function that does the reduction.
       * @param accumulator - The initial value of the accumulator.
       * @typeParam T - The type of the accumulated value.
       * @returns The reduced value.
       */

    }, {
      key: "reduce",
      value: function reduce(callback, accumulator) {
        var _iterator10 = _createForOfIteratorHelper$2(this._pairs),
            _step10;

        try {
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            var _step10$value = _slicedToArray(_step10.value, 2),
                id = _step10$value[0],
                item = _step10$value[1];

            accumulator = callback(accumulator, item, id);
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }

        return accumulator;
      }
      /**
       * Sort the items.
       *
       * @param callback - Item comparator.
       * @returns A new stream with sorted items.
       */

    }, {
      key: "sort",
      value: function sort$1(callback) {
        var _this = this;

        return new DataStream(_defineProperty({}, iterator, function () {
          var _context9;

          return getIterator(sort(_context9 = _toConsumableArray(_this._pairs)).call(_context9, function (_ref, _ref2) {
            var _ref3 = _slicedToArray(_ref, 2),
                idA = _ref3[0],
                itemA = _ref3[1];

            var _ref4 = _slicedToArray(_ref2, 2),
                idB = _ref4[0],
                itemB = _ref4[1];

            return callback(itemA, itemB, idA, idB);
          }));
        }));
      }
    }]);

    return DataStream;
  }();

  function ownKeys(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context10, _context11; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$1(_context10 = ownKeys(Object(source), !0)).call(_context10, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$1(_context11 = ownKeys(Object(source))).call(_context11, function (key) { defineProperty$4(target, key, getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$1(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$1(o, minLen) { var _context9; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = slice(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

  function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Add an id to given item if it doesn't have one already.
   *
   * @remarks
   * The item will be modified.
   * @param item - The item that will have an id after a call to this function.
   * @param idProp - The key of the id property.
   * @typeParam Item - Item type that may or may not have an id.
   * @typeParam IdProp - Name of the property that contains the id.
   * @returns true
   */

  function ensureFullItem(item, idProp) {
    if (item[idProp] == null) {
      // generate an id
      item[idProp] = v4();
    }

    return item;
  }
  /**
   * # DataSet
   *
   * Vis.js comes with a flexible DataSet, which can be used to hold and
   * manipulate unstructured data and listen for changes in the data. The DataSet
   * is key/value based. Data items can be added, updated and removed from the
   * DataSet, and one can subscribe to changes in the DataSet. The data in the
   * DataSet can be filtered and ordered. Data can be normalized when appending it
   * to the DataSet as well.
   *
   * ## Example
   *
   * The following example shows how to use a DataSet.
   *
   * ```javascript
   * // create a DataSet
   * var options = {};
   * var data = new vis.DataSet(options);
   *
   * // add items
   * // note that the data items can contain different properties and data formats
   * data.add([
   *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},
   *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},
   *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},
   *   {id: 4, text: 'item 4'}
   * ]);
   *
   * // subscribe to any change in the DataSet
   * data.on('*', function (event, properties, senderId) {
   *   console.log('event', event, properties);
   * });
   *
   * // update an existing item
   * data.update({id: 2, group: 1});
   *
   * // remove an item
   * data.remove(4);
   *
   * // get all ids
   * var ids = data.getIds();
   * console.log('ids', ids);
   *
   * // get a specific item
   * var item1 = data.get(1);
   * console.log('item1', item1);
   *
   * // retrieve a filtered subset of the data
   * var items = data.get({
   *   filter: function (item) {
   *     return item.group == 1;
   *   }
   * });
   * console.log('filtered items', items);
   * ```
   *
   * @typeParam Item - Item type that may or may not have an id.
   * @typeParam IdProp - Name of the property that contains the id.
   */


  var DataSet = /*#__PURE__*/function (_DataSetPart) {
    _inherits(DataSet, _DataSetPart);

    var _super = _createSuper$1(DataSet);

    /**
     * Construct a new DataSet.
     *
     * @param data - Initial data or options.
     * @param options - Options (type error if data is also options).
     */
    function DataSet(data, options) {
      var _this;

      _classCallCheck(this, DataSet);

      _this = _super.call(this); // correctly read optional arguments

      _defineProperty(_assertThisInitialized(_this), "flush", void 0);

      _defineProperty(_assertThisInitialized(_this), "length", void 0);

      _defineProperty(_assertThisInitialized(_this), "_options", void 0);

      _defineProperty(_assertThisInitialized(_this), "_data", void 0);

      _defineProperty(_assertThisInitialized(_this), "_idProp", void 0);

      _defineProperty(_assertThisInitialized(_this), "_queue", null);

      if (data && !isArray$1(data)) {
        options = data;
        data = [];
      }

      _this._options = options || {};
      _this._data = new map(); // map with data indexed by id

      _this.length = 0; // number of items in the DataSet

      _this._idProp = _this._options.fieldId || "id"; // name of the field containing id
      // add initial data when provided

      if (data && data.length) {
        _this.add(data);
      }

      _this.setOptions(options);

      return _this;
    }
    /**
     * Set new options.
     *
     * @param options - The new options.
     */


    _createClass(DataSet, [{
      key: "idProp",
      get:
      /** Flush all queued calls. */

      /** @inheritDoc */

      /** @inheritDoc */
      function get() {
        return this._idProp;
      }
    }, {
      key: "setOptions",
      value: function setOptions(options) {
        if (options && options.queue !== undefined) {
          if (options.queue === false) {
            // delete queue if loaded
            if (this._queue) {
              this._queue.destroy();

              this._queue = null;
            }
          } else {
            // create queue and update its options
            if (!this._queue) {
              this._queue = Queue.extend(this, {
                replace: ["add", "update", "remove"]
              });
            }

            if (options.queue && _typeof(options.queue) === "object") {
              this._queue.setOptions(options.queue);
            }
          }
        }
      }
      /**
       * Add a data item or an array with items.
       *
       * After the items are added to the DataSet, the DataSet will trigger an event `add`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
       *
       * ## Example
       *
       * ```javascript
       * // create a DataSet
       * const data = new vis.DataSet()
       *
       * // add items
       * const ids = data.add([
       *   { id: 1, text: 'item 1' },
       *   { id: 2, text: 'item 2' },
       *   { text: 'item without an id' }
       * ])
       *
       * console.log(ids) // [1, 2, '<UUIDv4>']
       * ```
       *
       * @param data - Items to be added (ids will be generated if missing).
       * @param senderId - Sender id.
       * @returns addedIds - Array with the ids (generated if not present) of the added items.
       * @throws When an item with the same id as any of the added items already exists.
       */

    }, {
      key: "add",
      value: function add(data, senderId) {
        var _this2 = this;

        var addedIds = [];
        var id;

        if (isArray$1(data)) {
          // Array
          var idsToAdd = map$3(data).call(data, function (d) {
            return d[_this2._idProp];
          });

          if (some(idsToAdd).call(idsToAdd, function (id) {
            return _this2._data.has(id);
          })) {
            throw new Error("A duplicate id was found in the parameter array.");
          }

          for (var i = 0, len = data.length; i < len; i++) {
            id = this._addItem(data[i]);
            addedIds.push(id);
          }
        } else if (data && _typeof(data) === "object") {
          // Single item
          id = this._addItem(data);
          addedIds.push(id);
        } else {
          throw new Error("Unknown dataType");
        }

        if (addedIds.length) {
          this._trigger("add", {
            items: addedIds
          }, senderId);
        }

        return addedIds;
      }
      /**
       * Update existing items. When an item does not exist, it will be created.
       *
       * @remarks
       * The provided properties will be merged in the existing item. When an item does not exist, it will be created.
       *
       * After the items are updated, the DataSet will trigger an event `add` for the added items, and an event `update`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
       *
       * ## Example
       *
       * ```javascript
       * // create a DataSet
       * const data = new vis.DataSet([
       *   { id: 1, text: 'item 1' },
       *   { id: 2, text: 'item 2' },
       *   { id: 3, text: 'item 3' }
       * ])
       *
       * // update items
       * const ids = data.update([
       *   { id: 2, text: 'item 2 (updated)' },
       *   { id: 4, text: 'item 4 (new)' }
       * ])
       *
       * console.log(ids) // [2, 4]
       * ```
       *
       * ## Warning for TypeScript users
       * This method may introduce partial items into the data set. Use add or updateOnly instead for better type safety.
       * @param data - Items to be updated (if the id is already present) or added (if the id is missing).
       * @param senderId - Sender id.
       * @returns updatedIds - The ids of the added (these may be newly generated if there was no id in the item from the data) or updated items.
       * @throws When the supplied data is neither an item nor an array of items.
       */

    }, {
      key: "update",
      value: function update(data, senderId) {
        var _this3 = this;

        var addedIds = [];
        var updatedIds = [];
        var oldData = [];
        var updatedData = [];
        var idProp = this._idProp;

        var addOrUpdate = function addOrUpdate(item) {
          var origId = item[idProp];

          if (origId != null && _this3._data.has(origId)) {
            var fullItem = item; // it has an id, therefore it is a fullitem

            var oldItem = assign$2({}, _this3._data.get(origId)); // update item


            var id = _this3._updateItem(fullItem);

            updatedIds.push(id);
            updatedData.push(fullItem);
            oldData.push(oldItem);
          } else {
            // add new item
            var _id = _this3._addItem(item);

            addedIds.push(_id);
          }
        };

        if (isArray$1(data)) {
          // Array
          for (var i = 0, len = data.length; i < len; i++) {
            if (data[i] && _typeof(data[i]) === "object") {
              addOrUpdate(data[i]);
            } else {
              console.warn("Ignoring input item, which is not an object at index " + i);
            }
          }
        } else if (data && _typeof(data) === "object") {
          // Single item
          addOrUpdate(data);
        } else {
          throw new Error("Unknown dataType");
        }

        if (addedIds.length) {
          this._trigger("add", {
            items: addedIds
          }, senderId);
        }

        if (updatedIds.length) {
          var props = {
            items: updatedIds,
            oldData: oldData,
            data: updatedData
          }; // TODO: remove deprecated property 'data' some day
          //Object.defineProperty(props, 'data', {
          //  'get': (function() {
          //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
          //    return updatedData;
          //  }).bind(this)
          //});

          this._trigger("update", props, senderId);
        }

        return concat$1(addedIds).call(addedIds, updatedIds);
      }
      /**
       * Update existing items. When an item does not exist, an error will be thrown.
       *
       * @remarks
       * The provided properties will be deeply merged into the existing item.
       * When an item does not exist (id not present in the data set or absent), an error will be thrown and nothing will be changed.
       *
       * After the items are updated, the DataSet will trigger an event `update`.
       * When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
       *
       * ## Example
       *
       * ```javascript
       * // create a DataSet
       * const data = new vis.DataSet([
       *   { id: 1, text: 'item 1' },
       *   { id: 2, text: 'item 2' },
       *   { id: 3, text: 'item 3' },
       * ])
       *
       * // update items
       * const ids = data.update([
       *   { id: 2, text: 'item 2 (updated)' }, // works
       *   // { id: 4, text: 'item 4 (new)' }, // would throw
       *   // { text: 'item 4 (new)' }, // would also throw
       * ])
       *
       * console.log(ids) // [2]
       * ```
       * @param data - Updates (the id and optionally other props) to the items in this data set.
       * @param senderId - Sender id.
       * @returns updatedIds - The ids of the updated items.
       * @throws When the supplied data is neither an item nor an array of items, when the ids are missing.
       */

    }, {
      key: "updateOnly",
      value: function updateOnly(data, senderId) {
        var _context,
            _this4 = this;

        if (!isArray$1(data)) {
          data = [data];
        }

        var updateEventData = map$3(_context = map$3(data).call(data, function (update) {
          var oldData = _this4._data.get(update[_this4._idProp]);

          if (oldData == null) {
            throw new Error("Updating non-existent items is not allowed.");
          }

          return {
            oldData: oldData,
            update: update
          };
        })).call(_context, function (_ref) {
          var oldData = _ref.oldData,
              update = _ref.update;
          var id = oldData[_this4._idProp];
          var updatedData = pureDeepObjectAssign(oldData, update);

          _this4._data.set(id, updatedData);

          return {
            id: id,
            oldData: oldData,
            updatedData: updatedData
          };
        });

        if (updateEventData.length) {
          var props = {
            items: map$3(updateEventData).call(updateEventData, function (value) {
              return value.id;
            }),
            oldData: map$3(updateEventData).call(updateEventData, function (value) {
              return value.oldData;
            }),
            data: map$3(updateEventData).call(updateEventData, function (value) {
              return value.updatedData;
            })
          }; // TODO: remove deprecated property 'data' some day
          //Object.defineProperty(props, 'data', {
          //  'get': (function() {
          //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
          //    return updatedData;
          //  }).bind(this)
          //});

          this._trigger("update", props, senderId);

          return props.items;
        } else {
          return [];
        }
      }
      /** @inheritDoc */

    }, {
      key: "get",
      value: function get(first, second) {
        // @TODO: Woudn't it be better to split this into multiple methods?
        // parse the arguments
        var id = undefined;
        var ids = undefined;
        var options = undefined;

        if (isId(first)) {
          // get(id [, options])
          id = first;
          options = second;
        } else if (isArray$1(first)) {
          // get(ids [, options])
          ids = first;
          options = second;
        } else {
          // get([, options])
          options = first;
        } // determine the return type


        var returnType = options && options.returnType === "Object" ? "Object" : "Array"; // @TODO: WTF is this? Or am I missing something?
        // var returnType
        // if (options && options.returnType) {
        //   var allowedValues = ['Array', 'Object']
        //   returnType =
        //     allowedValues.indexOf(options.returnType) == -1
        //       ? 'Array'
        //       : options.returnType
        // } else {
        //   returnType = 'Array'
        // }
        // build options

        var filter$1 = options && filter(options);

        var items = [];
        var item = undefined;
        var itemIds = undefined;
        var itemId = undefined; // convert items

        if (id != null) {
          // return a single item
          item = this._data.get(id);

          if (item && filter$1 && !filter$1(item)) {
            item = undefined;
          }
        } else if (ids != null) {
          // return a subset of items
          for (var i = 0, len = ids.length; i < len; i++) {
            item = this._data.get(ids[i]);

            if (item != null && (!filter$1 || filter$1(item))) {
              items.push(item);
            }
          }
        } else {
          var _context2;

          // return all items
          itemIds = _toConsumableArray(keys(_context2 = this._data).call(_context2));

          for (var _i = 0, _len = itemIds.length; _i < _len; _i++) {
            itemId = itemIds[_i];
            item = this._data.get(itemId);

            if (item != null && (!filter$1 || filter$1(item))) {
              items.push(item);
            }
          }
        } // order the results


        if (options && options.order && id == undefined) {
          this._sort(items, options.order);
        } // filter fields of the items


        if (options && options.fields) {
          var fields = options.fields;

          if (id != undefined && item != null) {
            item = this._filterFields(item, fields);
          } else {
            for (var _i2 = 0, _len2 = items.length; _i2 < _len2; _i2++) {
              items[_i2] = this._filterFields(items[_i2], fields);
            }
          }
        } // return the results


        if (returnType == "Object") {
          var result = {};

          for (var _i3 = 0, _len3 = items.length; _i3 < _len3; _i3++) {
            var resultant = items[_i3]; // @TODO: Shoudn't this be this._fieldId?
            // result[resultant.id] = resultant

            var _id2 = resultant[this._idProp];
            result[_id2] = resultant;
          }

          return result;
        } else {
          if (id != null) {
            var _item;

            // a single item
            return (_item = item) !== null && _item !== void 0 ? _item : null;
          } else {
            // just return our array
            return items;
          }
        }
      }
      /** @inheritDoc */

    }, {
      key: "getIds",
      value: function getIds(options) {
        var data = this._data;

        var filter$1 = options && filter(options);

        var order = options && options.order;

        var itemIds = _toConsumableArray(keys(data).call(data));

        var ids = [];

        if (filter$1) {
          // get filtered items
          if (order) {
            // create ordered list
            var items = [];

            for (var i = 0, len = itemIds.length; i < len; i++) {
              var id = itemIds[i];

              var item = this._data.get(id);

              if (item != null && filter$1(item)) {
                items.push(item);
              }
            }

            this._sort(items, order);

            for (var _i4 = 0, _len4 = items.length; _i4 < _len4; _i4++) {
              ids.push(items[_i4][this._idProp]);
            }
          } else {
            // create unordered list
            for (var _i5 = 0, _len5 = itemIds.length; _i5 < _len5; _i5++) {
              var _id3 = itemIds[_i5];

              var _item2 = this._data.get(_id3);

              if (_item2 != null && filter$1(_item2)) {
                ids.push(_item2[this._idProp]);
              }
            }
          }
        } else {
          // get all items
          if (order) {
            // create an ordered list
            var _items = [];

            for (var _i6 = 0, _len6 = itemIds.length; _i6 < _len6; _i6++) {
              var _id4 = itemIds[_i6];

              _items.push(data.get(_id4));
            }

            this._sort(_items, order);

            for (var _i7 = 0, _len7 = _items.length; _i7 < _len7; _i7++) {
              ids.push(_items[_i7][this._idProp]);
            }
          } else {
            // create unordered list
            for (var _i8 = 0, _len8 = itemIds.length; _i8 < _len8; _i8++) {
              var _id5 = itemIds[_i8];

              var _item3 = data.get(_id5);

              if (_item3 != null) {
                ids.push(_item3[this._idProp]);
              }
            }
          }
        }

        return ids;
      }
      /** @inheritDoc */

    }, {
      key: "getDataSet",
      value: function getDataSet() {
        return this;
      }
      /** @inheritDoc */

    }, {
      key: "forEach",
      value: function forEach(callback, options) {
        var filter$1 = options && filter(options);

        var data = this._data;

        var itemIds = _toConsumableArray(keys(data).call(data));

        if (options && options.order) {
          // execute forEach on ordered list
          var items = this.get(options);

          for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            var id = item[this._idProp];
            callback(item, id);
          }
        } else {
          // unordered
          for (var _i9 = 0, _len9 = itemIds.length; _i9 < _len9; _i9++) {
            var _id6 = itemIds[_i9];

            var _item4 = this._data.get(_id6);

            if (_item4 != null && (!filter$1 || filter$1(_item4))) {
              callback(_item4, _id6);
            }
          }
        }
      }
      /** @inheritDoc */

    }, {
      key: "map",
      value: function map(callback, options) {
        var filter$1 = options && filter(options);

        var mappedItems = [];
        var data = this._data;

        var itemIds = _toConsumableArray(keys(data).call(data)); // convert and filter items


        for (var i = 0, len = itemIds.length; i < len; i++) {
          var id = itemIds[i];

          var item = this._data.get(id);

          if (item != null && (!filter$1 || filter$1(item))) {
            mappedItems.push(callback(item, id));
          }
        } // order items


        if (options && options.order) {
          this._sort(mappedItems, options.order);
        }

        return mappedItems;
      }
      /**
       * Filter the fields of an item.
       *
       * @param item - The item whose fields should be filtered.
       * @param fields - The names of the fields that will be kept.
       * @typeParam K - Field name type.
       * @returns The item without any additional fields.
       */

    }, {
      key: "_filterFields",
      value: function _filterFields(item, fields) {
        var _context3;

        if (!item) {
          // item is null
          return item;
        }

        return reduce(_context3 = isArray$1(fields) ? // Use the supplied array
        fields : // Use the keys of the supplied object
        keys$4(fields)).call(_context3, function (filteredItem, field) {
          filteredItem[field] = item[field];
          return filteredItem;
        }, {});
      }
      /**
       * Sort the provided array with items.
       *
       * @param items - Items to be sorted in place.
       * @param order - A field name or custom sort function.
       * @typeParam T - The type of the items in the items array.
       */

    }, {
      key: "_sort",
      value: function _sort(items, order) {
        if (typeof order === "string") {
          // order by provided field name
          var name = order; // field name

          sort(items).call(items, function (a, b) {
            // @TODO: How to treat missing properties?
            var av = a[name];
            var bv = b[name];
            return av > bv ? 1 : av < bv ? -1 : 0;
          });
        } else if (typeof order === "function") {
          // order by sort function
          sort(items).call(items, order);
        } else {
          // TODO: extend order by an Object {field:string, direction:string}
          //       where direction can be 'asc' or 'desc'
          throw new TypeError("Order must be a function or a string");
        }
      }
      /**
       * Remove an item or multiple items by reference (only the id is used) or by id.
       *
       * The method ignores removal of non-existing items, and returns an array containing the ids of the items which are actually removed from the DataSet.
       *
       * After the items are removed, the DataSet will trigger an event `remove` for the removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
       *
       * ## Example
       * ```javascript
       * // create a DataSet
       * const data = new vis.DataSet([
       *   { id: 1, text: 'item 1' },
       *   { id: 2, text: 'item 2' },
       *   { id: 3, text: 'item 3' }
       * ])
       *
       * // remove items
       * const ids = data.remove([2, { id: 3 }, 4])
       *
       * console.log(ids) // [2, 3]
       * ```
       *
       * @param id - One or more items or ids of items to be removed.
       * @param senderId - Sender id.
       * @returns The ids of the removed items.
       */

    }, {
      key: "remove",
      value: function remove(id, senderId) {
        var removedIds = [];
        var removedItems = []; // force everything to be an array for simplicity

        var ids = isArray$1(id) ? id : [id];

        for (var i = 0, len = ids.length; i < len; i++) {
          var item = this._remove(ids[i]);

          if (item) {
            var itemId = item[this._idProp];

            if (itemId != null) {
              removedIds.push(itemId);
              removedItems.push(item);
            }
          }
        }

        if (removedIds.length) {
          this._trigger("remove", {
            items: removedIds,
            oldData: removedItems
          }, senderId);
        }

        return removedIds;
      }
      /**
       * Remove an item by its id or reference.
       *
       * @param id - Id of an item or the item itself.
       * @returns The removed item if removed, null otherwise.
       */

    }, {
      key: "_remove",
      value: function _remove(id) {
        // @TODO: It origianlly returned the item although the docs say id.
        // The code expects the item, so probably an error in the docs.
        var ident; // confirm the id to use based on the args type

        if (isId(id)) {
          ident = id;
        } else if (id && _typeof(id) === "object") {
          ident = id[this._idProp]; // look for the identifier field using ._idProp
        } // do the removing if the item is found


        if (ident != null && this._data.has(ident)) {
          var item = this._data.get(ident) || null;

          this._data.delete(ident);

          --this.length;
          return item;
        }

        return null;
      }
      /**
       * Clear the entire data set.
       *
       * After the items are removed, the [[DataSet]] will trigger an event `remove` for all removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
       *
       * @param senderId - Sender id.
       * @returns removedIds - The ids of all removed items.
       */

    }, {
      key: "clear",
      value: function clear(senderId) {
        var _context4;

        var ids = _toConsumableArray(keys(_context4 = this._data).call(_context4));

        var items = [];

        for (var i = 0, len = ids.length; i < len; i++) {
          items.push(this._data.get(ids[i]));
        }

        this._data.clear();

        this.length = 0;

        this._trigger("remove", {
          items: ids,
          oldData: items
        }, senderId);

        return ids;
      }
      /**
       * Find the item with maximum value of a specified field.
       *
       * @param field - Name of the property that should be searched for max value.
       * @returns Item containing max value, or null if no items.
       */

    }, {
      key: "max",
      value: function max(field) {
        var _context5;

        var max = null;
        var maxField = null;

        var _iterator = _createForOfIteratorHelper$1(values(_context5 = this._data).call(_context5)),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var item = _step.value;
            var itemField = item[field];

            if (typeof itemField === "number" && (maxField == null || itemField > maxField)) {
              max = item;
              maxField = itemField;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return max || null;
      }
      /**
       * Find the item with minimum value of a specified field.
       *
       * @param field - Name of the property that should be searched for min value.
       * @returns Item containing min value, or null if no items.
       */

    }, {
      key: "min",
      value: function min(field) {
        var _context6;

        var min = null;
        var minField = null;

        var _iterator2 = _createForOfIteratorHelper$1(values(_context6 = this._data).call(_context6)),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var item = _step2.value;
            var itemField = item[field];

            if (typeof itemField === "number" && (minField == null || itemField < minField)) {
              min = item;
              minField = itemField;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return min || null;
      }
      /**
       * Find all distinct values of a specified field
       *
       * @param prop - The property name whose distinct values should be returned.
       * @returns Unordered array containing all distinct values. Items without specified property are ignored.
       */

    }, {
      key: "distinct",
      value: function distinct(prop) {
        var data = this._data;

        var itemIds = _toConsumableArray(keys(data).call(data));

        var values = [];
        var count = 0;

        for (var i = 0, len = itemIds.length; i < len; i++) {
          var id = itemIds[i];
          var item = data.get(id);
          var value = item[prop];
          var exists = false;

          for (var j = 0; j < count; j++) {
            if (values[j] == value) {
              exists = true;
              break;
            }
          }

          if (!exists && value !== undefined) {
            values[count] = value;
            count++;
          }
        }

        return values;
      }
      /**
       * Add a single item. Will fail when an item with the same id already exists.
       *
       * @param item - A new item to be added.
       * @returns Added item's id. An id is generated when it is not present in the item.
       */

    }, {
      key: "_addItem",
      value: function _addItem(item) {
        var fullItem = ensureFullItem(item, this._idProp);
        var id = fullItem[this._idProp]; // check whether this id is already taken

        if (this._data.has(id)) {
          // item already exists
          throw new Error("Cannot add item: item with id " + id + " already exists");
        }

        this._data.set(id, fullItem);

        ++this.length;
        return id;
      }
      /**
       * Update a single item: merge with existing item.
       * Will fail when the item has no id, or when there does not exist an item with the same id.
       *
       * @param update - The new item
       * @returns The id of the updated item.
       */

    }, {
      key: "_updateItem",
      value: function _updateItem(update) {
        var id = update[this._idProp];

        if (id == null) {
          throw new Error("Cannot update item: item has no id (item: " + stringify$1(update) + ")");
        }

        var item = this._data.get(id);

        if (!item) {
          // item doesn't exist
          throw new Error("Cannot update item: no item with id " + id + " found");
        }

        this._data.set(id, _objectSpread(_objectSpread({}, item), update));

        return id;
      }
      /** @inheritDoc */

    }, {
      key: "stream",
      value: function stream(ids) {
        if (ids) {
          var data = this._data;
          return new DataStream(_defineProperty({}, iterator, /*#__PURE__*/regenerator.mark(function _callee() {
            var _iterator3, _step3, id, item;

            return regenerator.wrap(function _callee$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _iterator3 = _createForOfIteratorHelper$1(ids);
                    _context7.prev = 1;

                    _iterator3.s();

                  case 3:
                    if ((_step3 = _iterator3.n()).done) {
                      _context7.next = 11;
                      break;
                    }

                    id = _step3.value;
                    item = data.get(id);

                    if (!(item != null)) {
                      _context7.next = 9;
                      break;
                    }

                    _context7.next = 9;
                    return [id, item];

                  case 9:
                    _context7.next = 3;
                    break;

                  case 11:
                    _context7.next = 16;
                    break;

                  case 13:
                    _context7.prev = 13;
                    _context7.t0 = _context7["catch"](1);

                    _iterator3.e(_context7.t0);

                  case 16:
                    _context7.prev = 16;

                    _iterator3.f();

                    return _context7.finish(16);

                  case 19:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee, null, [[1, 13, 16, 19]]);
          })));
        } else {
          var _context8;

          return new DataStream(_defineProperty({}, iterator, bind$6(_context8 = entries(this._data)).call(_context8, this._data)));
        }
      }
    }]);

    return DataSet;
  }(DataSetPart);

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$1(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { var _context5; if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = slice(_context5 = Object.prototype.toString.call(o)).call(_context5, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * DataView
   *
   * A DataView offers a filtered and/or formatted view on a DataSet. One can subscribe to changes in a DataView, and easily get filtered or formatted data without having to specify filters and field types all the time.
   *
   * ## Example
   * ```javascript
   * // create a DataSet
   * var data = new vis.DataSet();
   * data.add([
   *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},
   *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},
   *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},
   *   {id: 4, text: 'item 4'}
   * ]);
   *
   * // create a DataView
   * // the view will only contain items having a property group with value 1,
   * // and will only output fields id, text, and date.
   * var view = new vis.DataView(data, {
   *   filter: function (item) {
   *     return (item.group == 1);
   *   },
   *   fields: ['id', 'text', 'date']
   * });
   *
   * // subscribe to any change in the DataView
   * view.on('*', function (event, properties, senderId) {
   *   console.log('event', event, properties);
   * });
   *
   * // update an item in the data set
   * data.update({id: 2, group: 1});
   *
   * // get all ids in the view
   * var ids = view.getIds();
   * console.log('ids', ids); // will output [1, 2]
   *
   * // get all items in the view
   * var items = view.get();
   * ```
   *
   * @typeParam Item - Item type that may or may not have an id.
   * @typeParam IdProp - Name of the property that contains the id.
   */

  var DataView = /*#__PURE__*/function (_DataSetPart) {
    _inherits(DataView, _DataSetPart);

    var _super = _createSuper(DataView);

    /**
     * Create a DataView.
     *
     * @param data - The instance containing data (directly or indirectly).
     * @param options - Options to configure this data view.
     */
    function DataView(data, options) {
      var _context;

      var _this;

      _classCallCheck(this, DataView);

      _this = _super.call(this);

      _defineProperty(_assertThisInitialized(_this), "length", 0);

      _defineProperty(_assertThisInitialized(_this), "_listener", void 0);

      _defineProperty(_assertThisInitialized(_this), "_data", void 0);

      _defineProperty(_assertThisInitialized(_this), "_ids", new set());

      _defineProperty(_assertThisInitialized(_this), "_options", void 0);

      _this._options = options || {};
      _this._listener = bind$6(_context = _this._onEvent).call(_context, _assertThisInitialized(_this));

      _this.setData(data);

      return _this;
    } // TODO: implement a function .config() to dynamically update things like configured filter
    // and trigger changes accordingly

    /**
     * Set a data source for the view.
     *
     * @param data - The instance containing data (directly or indirectly).
     * @remarks
     * Note that when the data view is bound to a data set it won't be garbage
     * collected unless the data set is too. Use `dataView.setData(null)` or
     * `dataView.dispose()` to enable garbage collection before you lose the last
     * reference.
     */


    _createClass(DataView, [{
      key: "idProp",
      get:
      /** @inheritDoc */

      /** @inheritDoc */
      function get() {
        return this.getDataSet().idProp;
      }
    }, {
      key: "setData",
      value: function setData(data) {
        if (this._data) {
          // unsubscribe from current dataset
          if (this._data.off) {
            this._data.off("*", this._listener);
          } // trigger a remove of all items in memory


          var ids = this._data.getIds({
            filter: filter(this._options)
          });

          var items = this._data.get(ids);

          this._ids.clear();

          this.length = 0;

          this._trigger("remove", {
            items: ids,
            oldData: items
          });
        }

        if (data != null) {
          this._data = data; // trigger an add of all added items

          var _ids = this._data.getIds({
            filter: filter(this._options)
          });

          for (var i = 0, len = _ids.length; i < len; i++) {
            var id = _ids[i];

            this._ids.add(id);
          }

          this.length = _ids.length;

          this._trigger("add", {
            items: _ids
          });
        } else {
          this._data = new DataSet();
        } // subscribe to new dataset


        if (this._data.on) {
          this._data.on("*", this._listener);
        }
      }
      /**
       * Refresh the DataView.
       * Useful when the DataView has a filter function containing a variable parameter.
       */

    }, {
      key: "refresh",
      value: function refresh() {
        var ids = this._data.getIds({
          filter: filter(this._options)
        });

        var oldIds = _toConsumableArray(this._ids);

        var newIds = {};
        var addedIds = [];
        var removedIds = [];
        var removedItems = []; // check for additions

        for (var i = 0, len = ids.length; i < len; i++) {
          var id = ids[i];
          newIds[id] = true;

          if (!this._ids.has(id)) {
            addedIds.push(id);

            this._ids.add(id);
          }
        } // check for removals


        for (var _i = 0, _len = oldIds.length; _i < _len; _i++) {
          var _id = oldIds[_i];

          var item = this._data.get(_id);

          if (item == null) {
            // @TODO: Investigate.
            // Doesn't happen during tests or examples.
            // Is it really impossible or could it eventually happen?
            // How to handle it if it does? The types guarantee non-nullable items.
            console.error("If you see this, report it please.");
          } else if (!newIds[_id]) {
            removedIds.push(_id);
            removedItems.push(item);

            this._ids.delete(_id);
          }
        }

        this.length += addedIds.length - removedIds.length; // trigger events

        if (addedIds.length) {
          this._trigger("add", {
            items: addedIds
          });
        }

        if (removedIds.length) {
          this._trigger("remove", {
            items: removedIds,
            oldData: removedItems
          });
        }
      }
      /** @inheritDoc */

    }, {
      key: "get",
      value: function get(first, second) {
        if (this._data == null) {
          return null;
        } // parse the arguments


        var ids = null;
        var options;

        if (isId(first) || isArray$1(first)) {
          ids = first;
          options = second;
        } else {
          options = first;
        } // extend the options with the default options and provided options


        var viewOptions = assign$2({}, this._options, options); // create a combined filter method when needed


        var thisFilter = filter(this._options);

        var optionsFilter = options && filter(options);

        if (thisFilter && optionsFilter) {
          viewOptions.filter = function (item) {
            return thisFilter(item) && optionsFilter(item);
          };
        }

        if (ids == null) {
          return this._data.get(viewOptions);
        } else {
          return this._data.get(ids, viewOptions);
        }
      }
      /** @inheritDoc */

    }, {
      key: "getIds",
      value: function getIds(options) {
        if (this._data.length) {
          var defaultFilter = filter(this._options);

          var optionsFilter = options != null ? filter(options) : null;
          var filter$1;

          if (optionsFilter) {
            if (defaultFilter) {
              filter$1 = function filter(item) {
                return defaultFilter(item) && optionsFilter(item);
              };
            } else {
              filter$1 = optionsFilter;
            }
          } else {
            filter$1 = defaultFilter;
          }

          return this._data.getIds({
            filter: filter$1,
            order: options && options.order
          });
        } else {
          return [];
        }
      }
      /** @inheritDoc */

    }, {
      key: "forEach",
      value: function forEach(callback, options) {
        if (this._data) {
          var _context2;

          var defaultFilter = filter(this._options);

          var optionsFilter = options && filter(options);

          var filter$1;

          if (optionsFilter) {
            if (defaultFilter) {
              filter$1 = function filter(item) {
                return defaultFilter(item) && optionsFilter(item);
              };
            } else {
              filter$1 = optionsFilter;
            }
          } else {
            filter$1 = defaultFilter;
          }

          forEach$1(_context2 = this._data).call(_context2, callback, {
            filter: filter$1,
            order: options && options.order
          });
        }
      }
      /** @inheritDoc */

    }, {
      key: "map",
      value: function map(callback, options) {
        if (this._data) {
          var _context3;

          var defaultFilter = filter(this._options);

          var optionsFilter = options && filter(options);

          var filter$1;

          if (optionsFilter) {
            if (defaultFilter) {
              filter$1 = function filter(item) {
                return defaultFilter(item) && optionsFilter(item);
              };
            } else {
              filter$1 = optionsFilter;
            }
          } else {
            filter$1 = defaultFilter;
          }

          return map$3(_context3 = this._data).call(_context3, callback, {
            filter: filter$1,
            order: options && options.order
          });
        } else {
          return [];
        }
      }
      /** @inheritDoc */

    }, {
      key: "getDataSet",
      value: function getDataSet() {
        return this._data.getDataSet();
      }
      /** @inheritDoc */

    }, {
      key: "stream",
      value: function stream(ids) {
        var _context4;

        return this._data.stream(ids || _defineProperty({}, iterator, bind$6(_context4 = keys(this._ids)).call(_context4, this._ids)));
      }
      /**
       * Render the instance unusable prior to garbage collection.
       *
       * @remarks
       * The intention of this method is to help discover scenarios where the data
       * view is being used when the programmer thinks it has been garbage collected
       * already. It's stricter version of `dataView.setData(null)`.
       */

    }, {
      key: "dispose",
      value: function dispose() {
        var _this$_data;

        if ((_this$_data = this._data) !== null && _this$_data !== void 0 && _this$_data.off) {
          this._data.off("*", this._listener);
        }

        var message = "This data view has already been disposed of.";
        var replacement = {
          get: function get() {
            throw new Error(message);
          },
          set: function set() {
            throw new Error(message);
          },
          configurable: false
        };

        var _iterator = _createForOfIteratorHelper(ownKeys$1(DataView.prototype)),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var key = _step.value;

            defineProperty$4(this, key, replacement);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      /**
       * Event listener. Will propagate all events from the connected data set to the subscribers of the DataView, but will filter the items and only trigger when there are changes in the filtered data set.
       *
       * @param event - The name of the event.
       * @param params - Parameters of the event.
       * @param senderId - Id supplied by the sender.
       */

    }, {
      key: "_onEvent",
      value: function _onEvent(event, params, senderId) {
        if (!params || !params.items || !this._data) {
          return;
        }

        var ids = params.items;
        var addedIds = [];
        var updatedIds = [];
        var removedIds = [];
        var oldItems = [];
        var updatedItems = [];
        var removedItems = [];

        switch (event) {
          case "add":
            // filter the ids of the added items
            for (var i = 0, len = ids.length; i < len; i++) {
              var id = ids[i];
              var item = this.get(id);

              if (item) {
                this._ids.add(id);

                addedIds.push(id);
              }
            }

            break;

          case "update":
            // determine the event from the views viewpoint: an updated
            // item can be added, updated, or removed from this view.
            for (var _i2 = 0, _len2 = ids.length; _i2 < _len2; _i2++) {
              var _id2 = ids[_i2];

              var _item = this.get(_id2);

              if (_item) {
                if (this._ids.has(_id2)) {
                  updatedIds.push(_id2);
                  updatedItems.push(params.data[_i2]);
                  oldItems.push(params.oldData[_i2]);
                } else {
                  this._ids.add(_id2);

                  addedIds.push(_id2);
                }
              } else {
                if (this._ids.has(_id2)) {
                  this._ids.delete(_id2);

                  removedIds.push(_id2);
                  removedItems.push(params.oldData[_i2]);
                }
              }
            }

            break;

          case "remove":
            // filter the ids of the removed items
            for (var _i3 = 0, _len3 = ids.length; _i3 < _len3; _i3++) {
              var _id3 = ids[_i3];

              if (this._ids.has(_id3)) {
                this._ids.delete(_id3);

                removedIds.push(_id3);
                removedItems.push(params.oldData[_i3]);
              }
            }

            break;
        }

        this.length += addedIds.length - removedIds.length;

        if (addedIds.length) {
          this._trigger("add", {
            items: addedIds
          }, senderId);
        }

        if (updatedIds.length) {
          this._trigger("update", {
            items: updatedIds,
            oldData: oldItems,
            data: updatedItems
          }, senderId);
        }

        if (removedIds.length) {
          this._trigger("remove", {
            items: removedIds,
            oldData: removedItems
          }, senderId);
        }
      }
    }]);

    return DataView;
  }(DataSetPart);

  /**
   * Check that given value is compatible with Vis Data Set interface.
   *
   * @param idProp - The expected property to contain item id.
   * @param v - The value to be tested.
   * @returns True if all expected values and methods match, false otherwise.
   */
  function isDataSetLike(idProp, v) {
    return _typeof(v) === "object" && v !== null && idProp === v.idProp && typeof v.add === "function" && typeof v.clear === "function" && typeof v.distinct === "function" && typeof forEach$1(v) === "function" && typeof v.get === "function" && typeof v.getDataSet === "function" && typeof v.getIds === "function" && typeof v.length === "number" && typeof map$3(v) === "function" && typeof v.max === "function" && typeof v.min === "function" && typeof v.off === "function" && typeof v.on === "function" && typeof v.remove === "function" && typeof v.setOptions === "function" && typeof v.stream === "function" && typeof v.update === "function" && typeof v.updateOnly === "function";
  }

  /**
   * Check that given value is compatible with Vis Data View interface.
   *
   * @param idProp - The expected property to contain item id.
   * @param v - The value to be tested.
   * @returns True if all expected values and methods match, false otherwise.
   */

  function isDataViewLike(idProp, v) {
    return _typeof(v) === "object" && v !== null && idProp === v.idProp && typeof forEach$1(v) === "function" && typeof v.get === "function" && typeof v.getDataSet === "function" && typeof v.getIds === "function" && typeof v.length === "number" && typeof map$3(v) === "function" && typeof v.off === "function" && typeof v.on === "function" && typeof v.stream === "function" && isDataSetLike(idProp, v.getDataSet());
  }

  exports.DELETE = DELETE;
  exports.DataSet = DataSet;
  exports.DataStream = DataStream;
  exports.DataView = DataView;
  exports.Queue = Queue;
  exports.createNewDataPipeFrom = createNewDataPipeFrom;
  exports.isDataSetLike = isDataSetLike;
  exports.isDataViewLike = isDataViewLike;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=vis-data.js.map


/***/ }),

/***/ "./node_modules/vis-data/peer/umd/vis-data.min.js":
/*!********************************************************!*\
  !*** ./node_modules/vis-data/peer/umd/vis-data.min.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/**
 * vis-data
 * http://visjs.org/
 *
 * Manage unstructured data using DataSet. Add, update, and remove data, and listen for changes in the data.
 *
 * @version 7.1.4
 * @date    2022-03-15T15:23:59.245Z
 *
 * @copyright (c) 2011-2017 Almende B.V, http://almende.com
 * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs
 *
 * @license
 * vis.js is dual licensed under both
 *
 *   1. The Apache 2.0 License
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   and
 *
 *   2. The MIT License
 *      http://opensource.org/licenses/MIT
 *
 * vis.js may be distributed under either license.
 */
!function(t,e){ true?e(exports):0}(this,(function(t){function e(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var r="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self?self:{},n={exports:{}},i=function(t){return t&&t.Math==Math&&t},o=i("object"==typeof globalThis&&globalThis)||i("object"==typeof window&&window)||i("object"==typeof self&&self)||i("object"==typeof r&&r)||function(){return this}()||Function("return this")(),a=function(t){try{return!!t()}catch(t){return!0}},u=!a((function(){var t=function(){}.bind();return"function"!=typeof t||t.hasOwnProperty("prototype")})),s=u,c=Function.prototype,f=c.apply,l=c.call,h="object"==typeof Reflect&&Reflect.apply||(s?l.bind(f):function(){return l.apply(f,arguments)}),p=u,v=Function.prototype,d=v.bind,y=v.call,g=p&&d.bind(y,y),m=p?function(t){return t&&g(t)}:function(t){return t&&function(){return y.apply(t,arguments)}},b=function(t){return"function"==typeof t},_={},w=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),O=u,E=Function.prototype.call,T=O?E.bind(E):function(){return E.apply(E,arguments)},x={},k={}.propertyIsEnumerable,S=Object.getOwnPropertyDescriptor,A=S&&!k.call({1:2},1);x.f=A?function(t){var e=S(this,t);return!!e&&e.enumerable}:k;var j,P,I=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}},D=m,L=D({}.toString),C=D("".slice),R=function(t){return C(L(t),8,-1)},M=m,F=a,N=R,z=o.Object,q=M("".split),Y=F((function(){return!z("z").propertyIsEnumerable(0)}))?function(t){return"String"==N(t)?q(t,""):z(t)}:z,G=o.TypeError,X=function(t){if(null==t)throw G("Can't call method on "+t);return t},U=Y,W=X,V=function(t){return U(W(t))},H=b,$=function(t){return"object"==typeof t?null!==t:H(t)},B={},J=B,K=o,Q=b,Z=function(t){return Q(t)?t:void 0},tt=function(t,e){return arguments.length<2?Z(J[t])||Z(K[t]):J[t]&&J[t][e]||K[t]&&K[t][e]},et=m({}.isPrototypeOf),rt=tt("navigator","userAgent")||"",nt=o,it=rt,ot=nt.process,at=nt.Deno,ut=ot&&ot.versions||at&&at.version,st=ut&&ut.v8;st&&(P=(j=st.split("."))[0]>0&&j[0]<4?1:+(j[0]+j[1])),!P&&it&&(!(j=it.match(/Edge\/(\d+)/))||j[1]>=74)&&(j=it.match(/Chrome\/(\d+)/))&&(P=+j[1]);var ct=P,ft=ct,lt=a,ht=!!Object.getOwnPropertySymbols&&!lt((function(){var t=Symbol();return!String(t)||!(Object(t)instanceof Symbol)||!Symbol.sham&&ft&&ft<41})),pt=ht&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,vt=tt,dt=b,yt=et,gt=pt,mt=o.Object,bt=gt?function(t){return"symbol"==typeof t}:function(t){var e=vt("Symbol");return dt(e)&&yt(e.prototype,mt(t))},_t=o.String,wt=function(t){try{return _t(t)}catch(t){return"Object"}},Ot=b,Et=wt,Tt=o.TypeError,xt=function(t){if(Ot(t))return t;throw Tt(Et(t)+" is not a function")},kt=xt,St=function(t,e){var r=t[e];return null==r?void 0:kt(r)},At=T,jt=b,Pt=$,It=o.TypeError,Dt={exports:{}},Lt=o,Ct=Object.defineProperty,Rt=function(t,e){try{Ct(Lt,t,{value:e,configurable:!0,writable:!0})}catch(r){Lt[t]=e}return e},Mt="__core-js_shared__",Ft=o[Mt]||Rt(Mt,{}),Nt=Ft;(Dt.exports=function(t,e){return Nt[t]||(Nt[t]=void 0!==e?e:{})})("versions",[]).push({version:"3.21.1",mode:"pure",copyright:" 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE",source:"https://github.com/zloirock/core-js"});var zt=X,qt=o.Object,Yt=function(t){return qt(zt(t))},Gt=Yt,Xt=m({}.hasOwnProperty),Ut=Object.hasOwn||function(t,e){return Xt(Gt(t),e)},Wt=m,Vt=0,Ht=Math.random(),$t=Wt(1..toString),Bt=function(t){return"Symbol("+(void 0===t?"":t)+")_"+$t(++Vt+Ht,36)},Jt=o,Kt=Dt.exports,Qt=Ut,Zt=Bt,te=ht,ee=pt,re=Kt("wks"),ne=Jt.Symbol,ie=ne&&ne.for,oe=ee?ne:ne&&ne.withoutSetter||Zt,ae=function(t){if(!Qt(re,t)||!te&&"string"!=typeof re[t]){var e="Symbol."+t;te&&Qt(ne,t)?re[t]=ne[t]:re[t]=ee&&ie?ie(e):oe(e)}return re[t]},ue=T,se=$,ce=bt,fe=St,le=function(t,e){var r,n;if("string"===e&&jt(r=t.toString)&&!Pt(n=At(r,t)))return n;if(jt(r=t.valueOf)&&!Pt(n=At(r,t)))return n;if("string"!==e&&jt(r=t.toString)&&!Pt(n=At(r,t)))return n;throw It("Can't convert object to primitive value")},he=ae,pe=o.TypeError,ve=he("toPrimitive"),de=function(t,e){if(!se(t)||ce(t))return t;var r,n=fe(t,ve);if(n){if(void 0===e&&(e="default"),r=ue(n,t,e),!se(r)||ce(r))return r;throw pe("Can't convert object to primitive value")}return void 0===e&&(e="number"),le(t,e)},ye=bt,ge=function(t){var e=de(t,"string");return ye(e)?e:e+""},me=$,be=o.document,_e=me(be)&&me(be.createElement),we=function(t){return _e?be.createElement(t):{}},Oe=we,Ee=!w&&!a((function(){return 7!=Object.defineProperty(Oe("div"),"a",{get:function(){return 7}}).a})),Te=w,xe=T,ke=x,Se=I,Ae=V,je=ge,Pe=Ut,Ie=Ee,De=Object.getOwnPropertyDescriptor;_.f=Te?De:function(t,e){if(t=Ae(t),e=je(e),Ie)try{return De(t,e)}catch(t){}if(Pe(t,e))return Se(!xe(ke.f,t,e),t[e])};var Le=a,Ce=b,Re=/#|\.prototype\./,Me=function(t,e){var r=Ne[Fe(t)];return r==qe||r!=ze&&(Ce(e)?Le(e):!!e)},Fe=Me.normalize=function(t){return String(t).replace(Re,".").toLowerCase()},Ne=Me.data={},ze=Me.NATIVE="N",qe=Me.POLYFILL="P",Ye=Me,Ge=xt,Xe=u,Ue=m(m.bind),We=function(t,e){return Ge(t),void 0===e?t:Xe?Ue(t,e):function(){return t.apply(e,arguments)}},Ve={},He=w&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype})),$e=o,Be=$,Je=$e.String,Ke=$e.TypeError,Qe=function(t){if(Be(t))return t;throw Ke(Je(t)+" is not an object")},Ze=w,tr=Ee,er=He,rr=Qe,nr=ge,ir=o.TypeError,or=Object.defineProperty,ar=Object.getOwnPropertyDescriptor,ur="enumerable",sr="configurable",cr="writable";Ve.f=Ze?er?function(t,e,r){if(rr(t),e=nr(e),rr(r),"function"==typeof t&&"prototype"===e&&"value"in r&&cr in r&&!r.writable){var n=ar(t,e);n&&n.writable&&(t[e]=r.value,r={configurable:sr in r?r.configurable:n.configurable,enumerable:ur in r?r.enumerable:n.enumerable,writable:!1})}return or(t,e,r)}:or:function(t,e,r){if(rr(t),e=nr(e),rr(r),tr)try{return or(t,e,r)}catch(t){}if("get"in r||"set"in r)throw ir("Accessors not supported");return"value"in r&&(t[e]=r.value),t};var fr=Ve,lr=I,hr=w?function(t,e,r){return fr.f(t,e,lr(1,r))}:function(t,e,r){return t[e]=r,t},pr=o,vr=h,dr=m,yr=b,gr=_.f,mr=Ye,br=B,_r=We,wr=hr,Or=Ut,Er=function(t){var e=function(r,n,i){if(this instanceof e){switch(arguments.length){case 0:return new t;case 1:return new t(r);case 2:return new t(r,n)}return new t(r,n,i)}return vr(t,this,arguments)};return e.prototype=t.prototype,e},Tr=function(t,e){var r,n,i,o,a,u,s,c,f=t.target,l=t.global,h=t.stat,p=t.proto,v=l?pr:h?pr[f]:(pr[f]||{}).prototype,d=l?br:br[f]||wr(br,f,{})[f],y=d.prototype;for(i in e)r=!mr(l?i:f+(h?".":"#")+i,t.forced)&&v&&Or(v,i),a=d[i],r&&(u=t.noTargetGet?(c=gr(v,i))&&c.value:v[i]),o=r&&u?u:e[i],r&&typeof a==typeof o||(s=t.bind&&r?_r(o,pr):t.wrap&&r?Er(o):p&&yr(o)?dr(o):o,(t.sham||o&&o.sham||a&&a.sham)&&wr(s,"sham",!0),wr(d,i,s),p&&(Or(br,n=f+"Prototype")||wr(br,n,{}),wr(br[n],i,o),t.real&&y&&!y[i]&&wr(y,i,o)))},xr=Tr,kr=w,Sr=Ve.f;xr({target:"Object",stat:!0,forced:Object.defineProperty!==Sr,sham:!kr},{defineProperty:Sr});var Ar=B.Object,jr=n.exports=function(t,e,r){return Ar.defineProperty(t,e,r)};Ar.defineProperty.sham&&(jr.sham=!0);var Pr=n.exports,Ir=Pr;function Dr(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Ir(t,n.key,n)}}function Lr(t,e,r){return e&&Dr(t.prototype,e),r&&Dr(t,r),Ir(t,"prototype",{writable:!1}),t}function Cr(t,e,r){return e in t?Ir(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var Rr=m([].slice),Mr=m,Fr=xt,Nr=$,zr=Ut,qr=Rr,Yr=u,Gr=o.Function,Xr=Mr([].concat),Ur=Mr([].join),Wr={},Vr=function(t,e,r){if(!zr(Wr,e)){for(var n=[],i=0;i<e;i++)n[i]="a["+i+"]";Wr[e]=Gr("C,a","return new C("+Ur(n,",")+")")}return Wr[e](t,r)},Hr=Yr?Gr.bind:function(t){var e=Fr(this),r=e.prototype,n=qr(arguments,1),i=function(){var r=Xr(n,qr(arguments));return this instanceof i?Vr(e,r.length,r):e.apply(t,r)};return Nr(r)&&(i.prototype=r),i},$r=Hr;Tr({target:"Function",proto:!0,forced:Function.bind!==$r},{bind:$r});var Br=B,Jr=function(t){return Br[t+"Prototype"]},Kr=Jr("Function").bind,Qr=et,Zr=Kr,tn=Function.prototype,en=function(t){var e=t.bind;return t===tn||Qr(tn,t)&&e===tn.bind?Zr:e},rn=Math.ceil,nn=Math.floor,on=function(t){var e=+t;return e!=e||0===e?0:(e>0?nn:rn)(e)},an=on,un=Math.min,sn=function(t){return t>0?un(an(t),9007199254740991):0},cn=function(t){return sn(t.length)},fn=xt,ln=Yt,hn=Y,pn=cn,vn=o.TypeError,dn=function(t){return function(e,r,n,i){fn(r);var o=ln(e),a=hn(o),u=pn(o),s=t?u-1:0,c=t?-1:1;if(n<2)for(;;){if(s in a){i=a[s],s+=c;break}if(s+=c,t?s<0:u<=s)throw vn("Reduce of empty array with no initial value")}for(;t?s>=0:u>s;s+=c)s in a&&(i=r(i,a[s],s,o));return i}},yn={left:dn(!1),right:dn(!0)},gn=a,mn=function(t,e){var r=[][t];return!!r&&gn((function(){r.call(null,e||function(){return 1},1)}))},bn="process"==R(o.process),_n=yn.left,wn=ct,On=bn;Tr({target:"Array",proto:!0,forced:!mn("reduce")||!On&&wn>79&&wn<83},{reduce:function(t){var e=arguments.length;return _n(this,t,e,e>1?arguments[1]:void 0)}});var En=Jr("Array").reduce,Tn=et,xn=En,kn=Array.prototype,Sn=function(t){var e=t.reduce;return t===kn||Tn(kn,t)&&e===kn.reduce?xn:e},An=R,jn=Array.isArray||function(t){return"Array"==An(t)},Pn={};Pn[ae("toStringTag")]="z";var In="[object z]"===String(Pn),Dn=o,Ln=In,Cn=b,Rn=R,Mn=ae("toStringTag"),Fn=Dn.Object,Nn="Arguments"==Rn(function(){return arguments}()),zn=Ln?Rn:function(t){var e,r,n;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=function(t,e){try{return t[e]}catch(t){}}(e=Fn(t),Mn))?r:Nn?Rn(e):"Object"==(n=Rn(e))&&Cn(e.callee)?"Arguments":n},qn=b,Yn=Ft,Gn=m(Function.toString);qn(Yn.inspectSource)||(Yn.inspectSource=function(t){return Gn(t)});var Xn=Yn.inspectSource,Un=m,Wn=a,Vn=b,Hn=zn,$n=Xn,Bn=function(){},Jn=[],Kn=tt("Reflect","construct"),Qn=/^\s*(?:class|function)\b/,Zn=Un(Qn.exec),ti=!Qn.exec(Bn),ei=function(t){if(!Vn(t))return!1;try{return Kn(Bn,Jn,t),!0}catch(t){return!1}},ri=function(t){if(!Vn(t))return!1;switch(Hn(t)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return ti||!!Zn(Qn,$n(t))}catch(t){return!0}};ri.sham=!0;var ni=!Kn||Wn((function(){var t;return ei(ei.call)||!ei(Object)||!ei((function(){t=!0}))||t}))?ri:ei,ii=o,oi=jn,ai=ni,ui=$,si=ae("species"),ci=ii.Array,fi=function(t){var e;return oi(t)&&(e=t.constructor,(ai(e)&&(e===ci||oi(e.prototype))||ui(e)&&null===(e=e[si]))&&(e=void 0)),void 0===e?ci:e},li=function(t,e){return new(fi(t))(0===e?0:e)},hi=We,pi=Y,vi=Yt,di=cn,yi=li,gi=m([].push),mi=function(t){var e=1==t,r=2==t,n=3==t,i=4==t,o=6==t,a=7==t,u=5==t||o;return function(s,c,f,l){for(var h,p,v=vi(s),d=pi(v),y=hi(c,f),g=di(d),m=0,b=l||yi,_=e?b(s,g):r||a?b(s,0):void 0;g>m;m++)if((u||m in d)&&(p=y(h=d[m],m,v),t))if(e)_[m]=p;else if(p)switch(t){case 3:return!0;case 5:return h;case 6:return m;case 2:gi(_,h)}else switch(t){case 4:return!1;case 7:gi(_,h)}return o?-1:n||i?i:_}},bi={forEach:mi(0),map:mi(1),filter:mi(2),some:mi(3),every:mi(4),find:mi(5),findIndex:mi(6),filterReject:mi(7)},_i=a,wi=ct,Oi=ae("species"),Ei=function(t){return wi>=51||!_i((function(){var e=[];return(e.constructor={})[Oi]=function(){return{foo:1}},1!==e[t](Boolean).foo}))},Ti=bi.filter;Tr({target:"Array",proto:!0,forced:!Ei("filter")},{filter:function(t){return Ti(this,t,arguments.length>1?arguments[1]:void 0)}});var xi=Jr("Array").filter,ki=et,Si=xi,Ai=Array.prototype,ji=function(t){var e=t.filter;return t===Ai||ki(Ai,t)&&e===Ai.filter?Si:e},Pi=bi.map;Tr({target:"Array",proto:!0,forced:!Ei("map")},{map:function(t){return Pi(this,t,arguments.length>1?arguments[1]:void 0)}});var Ii=Jr("Array").map,Di=et,Li=Ii,Ci=Array.prototype,Ri=function(t){var e=t.map;return t===Ci||Di(Ci,t)&&e===Ci.map?Li:e},Mi=jn,Fi=cn,Ni=We,zi=o.TypeError,qi=function(t,e,r,n,i,o,a,u){for(var s,c,f=i,l=0,h=!!a&&Ni(a,u);l<n;){if(l in r){if(s=h?h(r[l],l,e):r[l],o>0&&Mi(s))c=Fi(s),f=qi(t,e,s,c,f,o-1)-1;else{if(f>=9007199254740991)throw zi("Exceed the acceptable array length");t[f]=s}f++}l++}return f},Yi=qi,Gi=xt,Xi=Yt,Ui=cn,Wi=li;Tr({target:"Array",proto:!0},{flatMap:function(t){var e,r=Xi(this),n=Ui(r);return Gi(t),(e=Wi(r,0)).length=Yi(e,r,r,n,0,1,t,arguments.length>1?arguments[1]:void 0),e}});var Vi=Jr("Array").flatMap,Hi=et,$i=Vi,Bi=Array.prototype,Ji=function(t){var e=t.flatMap;return t===Bi||Hi(Bi,t)&&e===Bi.flatMap?$i:e};var Ki,Qi,Zi,to=function(){function t(r,n,i){var o,a,u;e(this,t),Cr(this,"_source",void 0),Cr(this,"_transformers",void 0),Cr(this,"_target",void 0),Cr(this,"_listeners",{add:en(o=this._add).call(o,this),remove:en(a=this._remove).call(a,this),update:en(u=this._update).call(u,this)}),this._source=r,this._transformers=n,this._target=i}return Lr(t,[{key:"all",value:function(){return this._target.update(this._transformItems(this._source.get())),this}},{key:"start",value:function(){return this._source.on("add",this._listeners.add),this._source.on("remove",this._listeners.remove),this._source.on("update",this._listeners.update),this}},{key:"stop",value:function(){return this._source.off("add",this._listeners.add),this._source.off("remove",this._listeners.remove),this._source.off("update",this._listeners.update),this}},{key:"_transformItems",value:function(t){var e;return Sn(e=this._transformers).call(e,(function(t,e){return e(t)}),t)}},{key:"_add",value:function(t,e){null!=e&&this._target.add(this._transformItems(this._source.get(e.items)))}},{key:"_update",value:function(t,e){null!=e&&this._target.update(this._transformItems(this._source.get(e.items)))}},{key:"_remove",value:function(t,e){null!=e&&this._target.remove(this._transformItems(e.oldData))}}]),t}(),eo=function(){function t(r){e(this,t),Cr(this,"_source",void 0),Cr(this,"_transformers",[]),this._source=r}return Lr(t,[{key:"filter",value:function(t){return this._transformers.push((function(e){return ji(e).call(e,t)})),this}},{key:"map",value:function(t){return this._transformers.push((function(e){return Ri(e).call(e,t)})),this}},{key:"flatMap",value:function(t){return this._transformers.push((function(e){return Ji(e).call(e,t)})),this}},{key:"to",value:function(t){return new to(this._source,this._transformers,t)}}]),t}(),ro=zn,no=o.String,io=function(t){if("Symbol"===ro(t))throw TypeError("Cannot convert a Symbol value to a string");return no(t)},oo=m,ao=on,uo=io,so=X,co=oo("".charAt),fo=oo("".charCodeAt),lo=oo("".slice),ho=function(t){return function(e,r){var n,i,o=uo(so(e)),a=ao(r),u=o.length;return a<0||a>=u?t?"":void 0:(n=fo(o,a))<55296||n>56319||a+1===u||(i=fo(o,a+1))<56320||i>57343?t?co(o,a):n:t?lo(o,a,a+2):i-56320+(n-55296<<10)+65536}},po={codeAt:ho(!1),charAt:ho(!0)},vo=b,yo=Xn,go=o.WeakMap,mo=vo(go)&&/native code/.test(yo(go)),bo=Dt.exports,_o=Bt,wo=bo("keys"),Oo=function(t){return wo[t]||(wo[t]=_o(t))},Eo={},To=mo,xo=o,ko=m,So=$,Ao=hr,jo=Ut,Po=Ft,Io=Oo,Do=Eo,Lo="Object already initialized",Co=xo.TypeError,Ro=xo.WeakMap;if(To||Po.state){var Mo=Po.state||(Po.state=new Ro),Fo=ko(Mo.get),No=ko(Mo.has),zo=ko(Mo.set);Ki=function(t,e){if(No(Mo,t))throw new Co(Lo);return e.facade=t,zo(Mo,t,e),e},Qi=function(t){return Fo(Mo,t)||{}},Zi=function(t){return No(Mo,t)}}else{var qo=Io("state");Do[qo]=!0,Ki=function(t,e){if(jo(t,qo))throw new Co(Lo);return e.facade=t,Ao(t,qo,e),e},Qi=function(t){return jo(t,qo)?t[qo]:{}},Zi=function(t){return jo(t,qo)}}var Yo={set:Ki,get:Qi,has:Zi,enforce:function(t){return Zi(t)?Qi(t):Ki(t,{})},getterFor:function(t){return function(e){var r;if(!So(e)||(r=Qi(e)).type!==t)throw Co("Incompatible receiver, "+t+" required");return r}}},Go=w,Xo=Ut,Uo=Function.prototype,Wo=Go&&Object.getOwnPropertyDescriptor,Vo=Xo(Uo,"name"),Ho={EXISTS:Vo,PROPER:Vo&&"something"===function(){}.name,CONFIGURABLE:Vo&&(!Go||Go&&Wo(Uo,"name").configurable)},$o={},Bo=on,Jo=Math.max,Ko=Math.min,Qo=function(t,e){var r=Bo(t);return r<0?Jo(r+e,0):Ko(r,e)},Zo=V,ta=Qo,ea=cn,ra=function(t){return function(e,r,n){var i,o=Zo(e),a=ea(o),u=ta(n,a);if(t&&r!=r){for(;a>u;)if((i=o[u++])!=i)return!0}else for(;a>u;u++)if((t||u in o)&&o[u]===r)return t||u||0;return!t&&-1}},na={includes:ra(!0),indexOf:ra(!1)},ia=Ut,oa=V,aa=na.indexOf,ua=Eo,sa=m([].push),ca=function(t,e){var r,n=oa(t),i=0,o=[];for(r in n)!ia(ua,r)&&ia(n,r)&&sa(o,r);for(;e.length>i;)ia(n,r=e[i++])&&(~aa(o,r)||sa(o,r));return o},fa=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],la=ca,ha=fa,pa=Object.keys||function(t){return la(t,ha)},va=w,da=He,ya=Ve,ga=Qe,ma=V,ba=pa;$o.f=va&&!da?Object.defineProperties:function(t,e){ga(t);for(var r,n=ma(e),i=ba(e),o=i.length,a=0;o>a;)ya.f(t,r=i[a++],n[r]);return t};var _a,wa=tt("document","documentElement"),Oa=Qe,Ea=$o,Ta=fa,xa=Eo,ka=wa,Sa=we,Aa=Oo("IE_PROTO"),ja=function(){},Pa=function(t){return"<script>"+t+"</"+"script>"},Ia=function(t){t.write(Pa("")),t.close();var e=t.parentWindow.Object;return t=null,e},Da=function(){try{_a=new ActiveXObject("htmlfile")}catch(t){}var t,e;Da="undefined"!=typeof document?document.domain&&_a?Ia(_a):((e=Sa("iframe")).style.display="none",ka.appendChild(e),e.src=String("javascript:"),(t=e.contentWindow.document).open(),t.write(Pa("document.F=Object")),t.close(),t.F):Ia(_a);for(var r=Ta.length;r--;)delete Da.prototype[Ta[r]];return Da()};xa[Aa]=!0;var La,Ca,Ra,Ma=Object.create||function(t,e){var r;return null!==t?(ja.prototype=Oa(t),r=new ja,ja.prototype=null,r[Aa]=t):r=Da(),void 0===e?r:Ea.f(r,e)},Fa=!a((function(){function t(){}return t.prototype.constructor=null,Object.getPrototypeOf(new t)!==t.prototype})),Na=o,za=Ut,qa=b,Ya=Yt,Ga=Fa,Xa=Oo("IE_PROTO"),Ua=Na.Object,Wa=Ua.prototype,Va=Ga?Ua.getPrototypeOf:function(t){var e=Ya(t);if(za(e,Xa))return e[Xa];var r=e.constructor;return qa(r)&&e instanceof r?r.prototype:e instanceof Ua?Wa:null},Ha=hr,$a=function(t,e,r,n){n&&n.enumerable?t[e]=r:Ha(t,e,r)},Ba=a,Ja=b,Ka=Ma,Qa=Va,Za=$a,tu=ae("iterator"),eu=!1;[].keys&&("next"in(Ra=[].keys())?(Ca=Qa(Qa(Ra)))!==Object.prototype&&(La=Ca):eu=!0);var ru=null==La||Ba((function(){var t={};return La[tu].call(t)!==t}));Ja((La=ru?{}:Ka(La))[tu])||Za(La,tu,(function(){return this}));var nu={IteratorPrototype:La,BUGGY_SAFARI_ITERATORS:eu},iu=zn,ou=In?{}.toString:function(){return"[object "+iu(this)+"]"},au=In,uu=Ve.f,su=hr,cu=Ut,fu=ou,lu=ae("toStringTag"),hu=function(t,e,r,n){if(t){var i=r?t:t.prototype;cu(i,lu)||uu(i,lu,{configurable:!0,value:e}),n&&!au&&su(i,"toString",fu)}},pu={},vu=nu.IteratorPrototype,du=Ma,yu=I,gu=hu,mu=pu,bu=function(){return this},_u=o,wu=b,Ou=_u.String,Eu=_u.TypeError,Tu=m,xu=Qe,ku=function(t){if("object"==typeof t||wu(t))return t;throw Eu("Can't set "+Ou(t)+" as a prototype")},Su=Object.setPrototypeOf||("__proto__"in{}?function(){var t,e=!1,r={};try{(t=Tu(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(r,[]),e=r instanceof Array}catch(t){}return function(r,n){return xu(r),ku(n),e?t(r,n):r.__proto__=n,r}}():void 0),Au=Tr,ju=T,Pu=function(t,e,r,n){var i=e+" Iterator";return t.prototype=du(vu,{next:yu(+!n,r)}),gu(t,i,!1,!0),mu[i]=bu,t},Iu=Va,Du=hu,Lu=$a,Cu=pu,Ru=Ho.PROPER,Mu=nu.BUGGY_SAFARI_ITERATORS,Fu=ae("iterator"),Nu="keys",zu="values",qu="entries",Yu=function(){return this},Gu=function(t,e,r,n,i,o,a){Pu(r,e,n);var u,s,c,f=function(t){if(t===i&&d)return d;if(!Mu&&t in p)return p[t];switch(t){case Nu:case zu:case qu:return function(){return new r(this,t)}}return function(){return new r(this)}},l=e+" Iterator",h=!1,p=t.prototype,v=p[Fu]||p["@@iterator"]||i&&p[i],d=!Mu&&v||f(i),y="Array"==e&&p.entries||v;if(y&&(u=Iu(y.call(new t)))!==Object.prototype&&u.next&&(Du(u,l,!0,!0),Cu[l]=Yu),Ru&&i==zu&&v&&v.name!==zu&&(h=!0,d=function(){return ju(v,this)}),i)if(s={values:f(zu),keys:o?d:f(Nu),entries:f(qu)},a)for(c in s)(Mu||h||!(c in p))&&Lu(p,c,s[c]);else Au({target:e,proto:!0,forced:Mu||h},s);return a&&p[Fu]!==d&&Lu(p,Fu,d,{name:i}),Cu[e]=d,s},Xu=po.charAt,Uu=io,Wu=Yo,Vu=Gu,Hu="String Iterator",$u=Wu.set,Bu=Wu.getterFor(Hu);Vu(String,"String",(function(t){$u(this,{type:Hu,string:Uu(t),index:0})}),(function(){var t,e=Bu(this),r=e.string,n=e.index;return n>=r.length?{value:void 0,done:!0}:(t=Xu(r,n),e.index+=t.length,{value:t,done:!1})}));var Ju=T,Ku=Qe,Qu=St,Zu=function(t,e,r){var n,i;Ku(t);try{if(!(n=Qu(t,"return"))){if("throw"===e)throw r;return r}n=Ju(n,t)}catch(t){i=!0,n=t}if("throw"===e)throw r;if(i)throw n;return Ku(n),r},ts=Qe,es=Zu,rs=pu,ns=ae("iterator"),is=Array.prototype,os=function(t){return void 0!==t&&(rs.Array===t||is[ns]===t)},as=ge,us=Ve,ss=I,cs=function(t,e,r){var n=as(e);n in t?us.f(t,n,ss(0,r)):t[n]=r},fs=zn,ls=St,hs=pu,ps=ae("iterator"),vs=function(t){if(null!=t)return ls(t,ps)||ls(t,"@@iterator")||hs[fs(t)]},ds=T,ys=xt,gs=Qe,ms=wt,bs=vs,_s=o.TypeError,ws=function(t,e){var r=arguments.length<2?bs(t):e;if(ys(r))return gs(ds(r,t));throw _s(ms(t)+" is not iterable")},Os=We,Es=T,Ts=Yt,xs=function(t,e,r,n){try{return n?e(ts(r)[0],r[1]):e(r)}catch(e){es(t,"throw",e)}},ks=os,Ss=ni,As=cn,js=cs,Ps=ws,Is=vs,Ds=o.Array,Ls=ae("iterator"),Cs=!1;try{var Rs=0,Ms={next:function(){return{done:!!Rs++}},return:function(){Cs=!0}};Ms[Ls]=function(){return this},Array.from(Ms,(function(){throw 2}))}catch(t){}var Fs=function(t){var e=Ts(t),r=Ss(this),n=arguments.length,i=n>1?arguments[1]:void 0,o=void 0!==i;o&&(i=Os(i,n>2?arguments[2]:void 0));var a,u,s,c,f,l,h=Is(e),p=0;if(!h||this==Ds&&ks(h))for(a=As(e),u=r?new this(a):Ds(a);a>p;p++)l=o?i(e[p],p):e[p],js(u,p,l);else for(f=(c=Ps(e,h)).next,u=r?new this:[];!(s=Es(f,c)).done;p++)l=o?xs(c,i,[s.value,p],!0):s.value,js(u,p,l);return u.length=p,u},Ns=function(t,e){if(!e&&!Cs)return!1;var r=!1;try{var n={};n[Ls]=function(){return{next:function(){return{done:r=!0}}}},t(n)}catch(t){}return r};Tr({target:"Array",stat:!0,forced:!Ns((function(t){Array.from(t)}))},{from:Fs});var zs=B.Array.from,qs=zs,Ys=V,Gs=pu,Xs=Yo;Ve.f;var Us=Gu,Ws="Array Iterator",Vs=Xs.set,Hs=Xs.getterFor(Ws);Us(Array,"Array",(function(t,e){Vs(this,{type:Ws,target:Ys(t),index:0,kind:e})}),(function(){var t=Hs(this),e=t.target,r=t.kind,n=t.index++;return!e||n>=e.length?(t.target=void 0,{value:void 0,done:!0}):"keys"==r?{value:n,done:!1}:"values"==r?{value:e[n],done:!1}:{value:[n,e[n]],done:!1}}),"values"),Gs.Arguments=Gs.Array;var $s=vs,Bs={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0},Js=o,Ks=zn,Qs=hr,Zs=pu,tc=ae("toStringTag");for(var ec in Bs){var rc=Js[ec],nc=rc&&rc.prototype;nc&&Ks(nc)!==tc&&Qs(nc,tc,ec),Zs[ec]=Zs.Array}var ic=$s,oc={},ac=ca,uc=fa.concat("length","prototype");oc.f=Object.getOwnPropertyNames||function(t){return ac(t,uc)};var sc={},cc=Qo,fc=cn,lc=cs,hc=o.Array,pc=Math.max,vc=function(t,e,r){for(var n=fc(t),i=cc(e,n),o=cc(void 0===r?n:r,n),a=hc(pc(o-i,0)),u=0;i<o;i++,u++)lc(a,u,t[i]);return a.length=u,a},dc=R,yc=V,gc=oc.f,mc=vc,bc="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];sc.f=function(t){return bc&&"Window"==dc(t)?function(t){try{return gc(t)}catch(t){return mc(bc)}}(t):gc(yc(t))};var _c={};_c.f=Object.getOwnPropertySymbols;var wc={},Oc=ae;wc.f=Oc;var Ec=B,Tc=Ut,xc=wc,kc=Ve.f,Sc=function(t){var e=Ec.Symbol||(Ec.Symbol={});Tc(e,t)||kc(e,t,{value:xc.f(t)})},Ac=Tr,jc=o,Pc=tt,Ic=h,Dc=T,Lc=m,Cc=w,Rc=ht,Mc=a,Fc=Ut,Nc=jn,zc=b,qc=$,Yc=et,Gc=bt,Xc=Qe,Uc=Yt,Wc=V,Vc=ge,Hc=io,$c=I,Bc=Ma,Jc=pa,Kc=oc,Qc=sc,Zc=_c,tf=_,ef=Ve,rf=$o,nf=x,of=Rr,af=$a,uf=Dt.exports,sf=Eo,cf=Bt,ff=ae,lf=wc,hf=Sc,pf=hu,vf=Yo,df=bi.forEach,yf=Oo("hidden"),gf="Symbol",mf=ff("toPrimitive"),bf=vf.set,_f=vf.getterFor(gf),wf=Object.prototype,Of=jc.Symbol,Ef=Of&&Of.prototype,Tf=jc.TypeError,xf=jc.QObject,kf=Pc("JSON","stringify"),Sf=tf.f,Af=ef.f,jf=Qc.f,Pf=nf.f,If=Lc([].push),Df=uf("symbols"),Lf=uf("op-symbols"),Cf=uf("string-to-symbol-registry"),Rf=uf("symbol-to-string-registry"),Mf=uf("wks"),Ff=!xf||!xf.prototype||!xf.prototype.findChild,Nf=Cc&&Mc((function(){return 7!=Bc(Af({},"a",{get:function(){return Af(this,"a",{value:7}).a}})).a}))?function(t,e,r){var n=Sf(wf,e);n&&delete wf[e],Af(t,e,r),n&&t!==wf&&Af(wf,e,n)}:Af,zf=function(t,e){var r=Df[t]=Bc(Ef);return bf(r,{type:gf,tag:t,description:e}),Cc||(r.description=e),r},qf=function(t,e,r){t===wf&&qf(Lf,e,r),Xc(t);var n=Vc(e);return Xc(r),Fc(Df,n)?(r.enumerable?(Fc(t,yf)&&t[yf][n]&&(t[yf][n]=!1),r=Bc(r,{enumerable:$c(0,!1)})):(Fc(t,yf)||Af(t,yf,$c(1,{})),t[yf][n]=!0),Nf(t,n,r)):Af(t,n,r)},Yf=function(t,e){Xc(t);var r=Wc(e),n=Jc(r).concat(Wf(r));return df(n,(function(e){Cc&&!Dc(Gf,r,e)||qf(t,e,r[e])})),t},Gf=function(t){var e=Vc(t),r=Dc(Pf,this,e);return!(this===wf&&Fc(Df,e)&&!Fc(Lf,e))&&(!(r||!Fc(this,e)||!Fc(Df,e)||Fc(this,yf)&&this[yf][e])||r)},Xf=function(t,e){var r=Wc(t),n=Vc(e);if(r!==wf||!Fc(Df,n)||Fc(Lf,n)){var i=Sf(r,n);return!i||!Fc(Df,n)||Fc(r,yf)&&r[yf][n]||(i.enumerable=!0),i}},Uf=function(t){var e=jf(Wc(t)),r=[];return df(e,(function(t){Fc(Df,t)||Fc(sf,t)||If(r,t)})),r},Wf=function(t){var e=t===wf,r=jf(e?Lf:Wc(t)),n=[];return df(r,(function(t){!Fc(Df,t)||e&&!Fc(wf,t)||If(n,Df[t])})),n};if(Rc||(Of=function(){if(Yc(Ef,this))throw Tf("Symbol is not a constructor");var t=arguments.length&&void 0!==arguments[0]?Hc(arguments[0]):void 0,e=cf(t),r=function(t){this===wf&&Dc(r,Lf,t),Fc(this,yf)&&Fc(this[yf],e)&&(this[yf][e]=!1),Nf(this,e,$c(1,t))};return Cc&&Ff&&Nf(wf,e,{configurable:!0,set:r}),zf(e,t)},af(Ef=Of.prototype,"toString",(function(){return _f(this).tag})),af(Of,"withoutSetter",(function(t){return zf(cf(t),t)})),nf.f=Gf,ef.f=qf,rf.f=Yf,tf.f=Xf,Kc.f=Qc.f=Uf,Zc.f=Wf,lf.f=function(t){return zf(ff(t),t)},Cc&&Af(Ef,"description",{configurable:!0,get:function(){return _f(this).description}})),Ac({global:!0,wrap:!0,forced:!Rc,sham:!Rc},{Symbol:Of}),df(Jc(Mf),(function(t){hf(t)})),Ac({target:gf,stat:!0,forced:!Rc},{for:function(t){var e=Hc(t);if(Fc(Cf,e))return Cf[e];var r=Of(e);return Cf[e]=r,Rf[r]=e,r},keyFor:function(t){if(!Gc(t))throw Tf(t+" is not a symbol");if(Fc(Rf,t))return Rf[t]},useSetter:function(){Ff=!0},useSimple:function(){Ff=!1}}),Ac({target:"Object",stat:!0,forced:!Rc,sham:!Cc},{create:function(t,e){return void 0===e?Bc(t):Yf(Bc(t),e)},defineProperty:qf,defineProperties:Yf,getOwnPropertyDescriptor:Xf}),Ac({target:"Object",stat:!0,forced:!Rc},{getOwnPropertyNames:Uf,getOwnPropertySymbols:Wf}),Ac({target:"Object",stat:!0,forced:Mc((function(){Zc.f(1)}))},{getOwnPropertySymbols:function(t){return Zc.f(Uc(t))}}),kf){var Vf=!Rc||Mc((function(){var t=Of();return"[null]"!=kf([t])||"{}"!=kf({a:t})||"{}"!=kf(Object(t))}));Ac({target:"JSON",stat:!0,forced:Vf},{stringify:function(t,e,r){var n=of(arguments),i=e;if((qc(e)||void 0!==t)&&!Gc(t))return Nc(e)||(e=function(t,e){if(zc(i)&&(e=Dc(i,this,t,e)),!Gc(e))return e}),n[1]=e,Ic(kf,null,n)}})}if(!Ef[mf]){var Hf=Ef.valueOf;af(Ef,mf,(function(t){return Dc(Hf,this)}))}pf(Of,gf),sf[yf]=!0;var $f=B.Object.getOwnPropertySymbols,Bf={exports:{}},Jf=Tr,Kf=a,Qf=V,Zf=_.f,tl=w,el=Kf((function(){Zf(1)}));Jf({target:"Object",stat:!0,forced:!tl||el,sham:!tl},{getOwnPropertyDescriptor:function(t,e){return Zf(Qf(t),e)}});var rl=B.Object,nl=Bf.exports=function(t,e){return rl.getOwnPropertyDescriptor(t,e)};rl.getOwnPropertyDescriptor.sham&&(nl.sham=!0);var il=Bf.exports,ol=tt,al=oc,ul=_c,sl=Qe,cl=m([].concat),fl=ol("Reflect","ownKeys")||function(t){var e=al.f(sl(t)),r=ul.f;return r?cl(e,r(t)):e},ll=fl,hl=V,pl=_,vl=cs;Tr({target:"Object",stat:!0,sham:!w},{getOwnPropertyDescriptors:function(t){for(var e,r,n=hl(t),i=pl.f,o=ll(n),a={},u=0;o.length>u;)void 0!==(r=i(n,e=o[u++]))&&vl(a,e,r);return a}});var dl=B.Object.getOwnPropertyDescriptors,yl={exports:{}},gl=Tr,ml=w,bl=$o.f;gl({target:"Object",stat:!0,forced:Object.defineProperties!==bl,sham:!ml},{defineProperties:bl});var _l=B.Object,wl=yl.exports=function(t,e){return _l.defineProperties(t,e)};_l.defineProperties.sham&&(wl.sham=!0);var Ol=yl.exports,El=Pr;Tr({target:"Array",stat:!0},{isArray:jn});var Tl=B.Array.isArray,xl=Tl;var kl=Tr,Sl=o,Al=a,jl=jn,Pl=$,Il=Yt,Dl=cn,Ll=cs,Cl=li,Rl=Ei,Ml=ct,Fl=ae("isConcatSpreadable"),Nl=9007199254740991,zl="Maximum allowed index exceeded",ql=Sl.TypeError,Yl=Ml>=51||!Al((function(){var t=[];return t[Fl]=!1,t.concat()[0]!==t})),Gl=Rl("concat"),Xl=function(t){if(!Pl(t))return!1;var e=t[Fl];return void 0!==e?!!e:jl(t)};kl({target:"Array",proto:!0,forced:!Yl||!Gl},{concat:function(t){var e,r,n,i,o,a=Il(this),u=Cl(a,0),s=0;for(e=-1,n=arguments.length;e<n;e++)if(Xl(o=-1===e?a:arguments[e])){if(s+(i=Dl(o))>Nl)throw ql(zl);for(r=0;r<i;r++,s++)r in o&&Ll(u,s,o[r])}else{if(s>=Nl)throw ql(zl);Ll(u,s++,o)}return u.length=s,u}}),Sc("asyncIterator"),Sc("hasInstance"),Sc("isConcatSpreadable"),Sc("iterator"),Sc("match"),Sc("matchAll"),Sc("replace"),Sc("search"),Sc("species"),Sc("split"),Sc("toPrimitive"),Sc("toStringTag"),Sc("unscopables"),hu(o.JSON,"JSON",!0);var Ul=B.Symbol,Wl=Ul;Sc("asyncDispose"),Sc("dispose"),Sc("matcher"),Sc("metadata"),Sc("observable"),Sc("patternMatch"),Sc("replaceAll");var Vl=Wl;var Hl=Tr,$l=o,Bl=jn,Jl=ni,Kl=$,Ql=Qo,Zl=cn,th=V,eh=cs,rh=ae,nh=Rr,ih=Ei("slice"),oh=rh("species"),ah=$l.Array,uh=Math.max;Hl({target:"Array",proto:!0,forced:!ih},{slice:function(t,e){var r,n,i,o=th(this),a=Zl(o),u=Ql(t,a),s=Ql(void 0===e?a:e,a);if(Bl(o)&&(r=o.constructor,(Jl(r)&&(r===ah||Bl(r.prototype))||Kl(r)&&null===(r=r[oh]))&&(r=void 0),r===ah||void 0===r))return nh(o,u,s);for(n=new(void 0===r?ah:r)(uh(s-u,0)),i=0;u<s;u++,i++)u in o&&eh(n,i,o[u]);return n.length=i,n}});var sh=Jr("Array").slice,ch=et,fh=sh,lh=Array.prototype,hh=function(t){var e=t.slice;return t===lh||ch(lh,t)&&e===lh.slice?fh:e},ph=hh,vh=zs;function dh(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function yh(t,e){var r;if(t){if("string"==typeof t)return dh(t,e);var n=ph(r=Object.prototype.toString.call(t)).call(r,8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?vh(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?dh(t,e):void 0}}function gh(t,e){return function(t){if(xl(t))return t}(t)||function(t,e){var r=null==t?null:void 0!==Vl&&ic(t)||t["@@iterator"];if(null!=r){var n,i,o=[],a=!0,u=!1;try{for(r=r.call(t);!(a=(n=r.next()).done)&&(o.push(n.value),!e||o.length!==e);a=!0);}catch(t){u=!0,i=t}finally{try{a||null==r.return||r.return()}finally{if(u)throw i}}return o}}(t,e)||yh(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var mh=wc.f("iterator"),bh=mh;function _h(t){return _h="function"==typeof Vl&&"symbol"==typeof bh?function(t){return typeof t}:function(t){return t&&"function"==typeof Vl&&t.constructor===Vl&&t!==Vl.prototype?"symbol":typeof t},_h(t)}function wh(t){return function(t){if(xl(t))return dh(t)}(t)||function(t){if(void 0!==Vl&&null!=ic(t)||null!=t["@@iterator"])return vh(t)}(t)||yh(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var Oh=Ul,Eh=Jr("Array").concat,Th=et,xh=Eh,kh=Array.prototype,Sh=function(t){var e=t.concat;return t===kh||Th(kh,t)&&e===kh.concat?xh:e},Ah=hh;Tr({target:"Reflect",stat:!0},{ownKeys:fl});var jh=B.Reflect.ownKeys,Ph=Tl,Ih=Yt,Dh=pa;Tr({target:"Object",stat:!0,forced:a((function(){Dh(1)}))},{keys:function(t){return Dh(Ih(t))}});var Lh=B.Object.keys,Ch=Tr,Rh=m,Mh=o.Date,Fh=Rh(Mh.prototype.getTime);Ch({target:"Date",stat:!0},{now:function(){return Fh(new Mh)}}),B.Date.now;var Nh=bi.forEach,zh=mn("forEach")?[].forEach:function(t){return Nh(this,t,arguments.length>1?arguments[1]:void 0)};Tr({target:"Array",proto:!0,forced:[].forEach!=zh},{forEach:zh});var qh=Jr("Array").forEach,Yh=zn,Gh=Ut,Xh=et,Uh=qh,Wh=Array.prototype,Vh={DOMTokenList:!0,NodeList:!0},Hh=function(t){var e=t.forEach;return t===Wh||Xh(Wh,t)&&e===Wh.forEach||Gh(Vh,Yh(t))?Uh:e},$h=Tr,Bh=jn,Jh=m([].reverse),Kh=[1,2];$h({target:"Array",proto:!0,forced:String(Kh)===String(Kh.reverse())},{reverse:function(){return Bh(this)&&(this.length=this.length),Jh(this)}});var Qh=Jr("Array").reverse,Zh=et,tp=Qh,ep=Array.prototype,rp=function(t){var e=t.reverse;return t===ep||Zh(ep,t)&&e===ep.reverse?tp:e},np=Tr,ip=o,op=Qo,ap=on,up=cn,sp=Yt,cp=li,fp=cs,lp=Ei("splice"),hp=ip.TypeError,pp=Math.max,vp=Math.min,dp=9007199254740991,yp="Maximum allowed length exceeded";np({target:"Array",proto:!0,forced:!lp},{splice:function(t,e){var r,n,i,o,a,u,s=sp(this),c=up(s),f=op(t,c),l=arguments.length;if(0===l?r=n=0:1===l?(r=0,n=c-f):(r=l-2,n=vp(pp(ap(e),0),c-f)),c+r-n>dp)throw hp(yp);for(i=cp(s,n),o=0;o<n;o++)(a=f+o)in s&&fp(i,o,s[a]);if(i.length=n,r<n){for(o=f;o<c-n;o++)u=o+r,(a=o+n)in s?s[u]=s[a]:delete s[u];for(o=c;o>c-n+r;o--)delete s[o-1]}else if(r>n)for(o=c-n;o>f;o--)u=o+r-1,(a=o+n-1)in s?s[u]=s[a]:delete s[u];for(o=0;o<r;o++)s[o+f]=arguments[o+2];return s.length=c-n+r,i}});var gp=Jr("Array").splice,mp=et,bp=gp,_p=Array.prototype,wp=function(t){var e=t.splice;return t===_p||mp(_p,t)&&e===_p.splice?bp:e},Op=w,Ep=m,Tp=T,xp=a,kp=pa,Sp=_c,Ap=x,jp=Yt,Pp=Y,Ip=Object.assign,Dp=Object.defineProperty,Lp=Ep([].concat),Cp=!Ip||xp((function(){if(Op&&1!==Ip({b:1},Ip(Dp({},"a",{enumerable:!0,get:function(){Dp(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var t={},e={},r=Symbol(),n="abcdefghijklmnopqrst";return t[r]=7,n.split("").forEach((function(t){e[t]=t})),7!=Ip({},t)[r]||kp(Ip({},e)).join("")!=n}))?function(t,e){for(var r=jp(t),n=arguments.length,i=1,o=Sp.f,a=Ap.f;n>i;)for(var u,s=Pp(arguments[i++]),c=o?Lp(kp(s),o(s)):kp(s),f=c.length,l=0;f>l;)u=c[l++],Op&&!Tp(a,s,u)||(r[u]=s[u]);return r}:Ip,Rp=Cp;Tr({target:"Object",stat:!0,forced:Object.assign!==Rp},{assign:Rp});var Mp=B.Object.assign,Fp=na.includes;Tr({target:"Array",proto:!0},{includes:function(t){return Fp(this,t,arguments.length>1?arguments[1]:void 0)}}),Jr("Array").includes;var Np=$,zp=R,qp=ae("match"),Yp=function(t){var e;return Np(t)&&(void 0!==(e=t[qp])?!!e:"RegExp"==zp(t))},Gp=o.TypeError,Xp=ae("match"),Up=Tr,Wp=function(t){if(Yp(t))throw Gp("The method doesn't accept regular expressions");return t},Vp=X,Hp=io,$p=function(t){var e=/./;try{"/./"[t](e)}catch(r){try{return e[Xp]=!1,"/./"[t](e)}catch(t){}}return!1},Bp=m("".indexOf);Up({target:"String",proto:!0,forced:!$p("includes")},{includes:function(t){return!!~Bp(Hp(Vp(this)),Hp(Wp(t)),arguments.length>1?arguments[1]:void 0)}}),Jr("String").includes;var Jp=Yt,Kp=Va,Qp=Fa;Tr({target:"Object",stat:!0,forced:a((function(){Kp(1)})),sham:!Qp},{getPrototypeOf:function(t){return Kp(Jp(t))}});var Zp=B.Object.getPrototypeOf,tv=w,ev=m,rv=pa,nv=V,iv=ev(x.f),ov=ev([].push),av=function(t){return function(e){for(var r,n=nv(e),i=rv(n),o=i.length,a=0,u=[];o>a;)r=i[a++],tv&&!iv(n,r)||ov(u,t?[r,n[r]]:n[r]);return u}},uv={entries:av(!0),values:av(!1)}.values;Tr({target:"Object",stat:!0},{values:function(t){return uv(t)}}),B.Object.values;var sv="\t\n\v\f\r \u2028\u2029\ufeff",cv=X,fv=io,lv=m("".replace),hv="[\t\n\v\f\r \u2028\u2029\ufeff]",pv=RegExp("^"+hv+hv+"*"),vv=RegExp(hv+hv+"*$"),dv=function(t){return function(e){var r=fv(cv(e));return 1&t&&(r=lv(r,pv,"")),2&t&&(r=lv(r,vv,"")),r}},yv={start:dv(1),end:dv(2),trim:dv(3)},gv=o,mv=a,bv=m,_v=io,wv=yv.trim,Ov=sv,Ev=gv.parseInt,Tv=gv.Symbol,xv=Tv&&Tv.iterator,kv=/^[+-]?0x/i,Sv=bv(kv.exec),Av=8!==Ev(Ov+"08")||22!==Ev(Ov+"0x16")||xv&&!mv((function(){Ev(Object(xv))}))?function(t,e){var r=wv(_v(t));return Ev(r,e>>>0||(Sv(kv,r)?16:10))}:Ev;Tr({global:!0,forced:parseInt!=Av},{parseInt:Av});var jv=Tr,Pv=na.indexOf,Iv=mn,Dv=m([].indexOf),Lv=!!Dv&&1/Dv([1],1,-0)<0,Cv=Iv("indexOf");jv({target:"Array",proto:!0,forced:Lv||!Cv},{indexOf:function(t){var e=arguments.length>1?arguments[1]:void 0;return Lv?Dv(this,t,e)||0:Pv(this,t,e)}}),Jr("Array").indexOf;var Rv=Ho.PROPER,Mv=a,Fv=sv,Nv=yv.trim;Tr({target:"String",proto:!0,forced:function(t){return Mv((function(){return!!Fv[t]()||""!==""[t]()||Rv&&Fv[t].name!==t}))}("trim")},{trim:function(){return Nv(this)}}),Jr("String").trim,Tr({target:"Object",stat:!0,sham:!w},{create:Ma});var zv=B.Object,qv=function(t,e){return zv.create(t,e)},Yv=qv,Gv=Tr,Xv=tt,Uv=h,Wv=m,Vv=a,Hv=o.Array,$v=Xv("JSON","stringify"),Bv=Wv(/./.exec),Jv=Wv("".charAt),Kv=Wv("".charCodeAt),Qv=Wv("".replace),Zv=Wv(1..toString),td=/[\uD800-\uDFFF]/g,ed=/^[\uD800-\uDBFF]$/,rd=/^[\uDC00-\uDFFF]$/,nd=function(t,e,r){var n=Jv(r,e-1),i=Jv(r,e+1);return Bv(ed,t)&&!Bv(rd,i)||Bv(rd,t)&&!Bv(ed,n)?"\\u"+Zv(Kv(t,0),16):t},id=Vv((function(){return'"\\udf06\\ud834"'!==$v("\udf06\ud834")||'"\\udead"'!==$v("\udead")}));$v&&Gv({target:"JSON",stat:!0,forced:id},{stringify:function(t,e,r){for(var n=0,i=arguments.length,o=Hv(i);n<i;n++)o[n]=arguments[n];var a=Uv($v,null,o);return"string"==typeof a?Qv(a,td,nd):a}});var od=B,ad=h;od.JSON||(od.JSON={stringify:JSON.stringify});var ud=function(t,e,r){return ad(od.JSON.stringify,null,arguments)},sd=ud,cd=o.TypeError,fd=Tr,ld=o,hd=h,pd=b,vd=Rr,dd=function(t,e){if(t<e)throw cd("Not enough arguments");return t},yd=/MSIE .\./.test(rt),gd=ld.Function,md=function(t){return function(e,r){var n=dd(arguments.length,1)>2,i=pd(e)?e:gd(e),o=n?vd(arguments,2):void 0;return t(n?function(){hd(i,this,o)}:i,r)}};fd({global:!0,bind:!0,forced:yd},{setTimeout:md(ld.setTimeout),setInterval:md(ld.setInterval)});var bd=B.setTimeout,_d=Yt,wd=Qo,Od=cn,Ed=function(t){for(var e=_d(this),r=Od(e),n=arguments.length,i=wd(n>1?arguments[1]:void 0,r),o=n>2?arguments[2]:void 0,a=void 0===o?r:wd(o,r);a>i;)e[i++]=t;return e};Tr({target:"Array",proto:!0},{fill:Ed}),Jr("Array").fill;var Td={exports:{}};!function(t){function e(t){if(t)return function(t){for(var r in e.prototype)t[r]=e.prototype[r];return t}(t)}t.exports=e,e.prototype.on=e.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},e.prototype.once=function(t,e){function r(){this.off(t,r),e.apply(this,arguments)}return r.fn=e,this.on(t,r),this},e.prototype.off=e.prototype.removeListener=e.prototype.removeAllListeners=e.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var r,n=this._callbacks["$"+t];if(!n)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var i=0;i<n.length;i++)if((r=n[i])===e||r.fn===e){n.splice(i,1);break}return 0===n.length&&delete this._callbacks["$"+t],this},e.prototype.emit=function(t){this._callbacks=this._callbacks||{};for(var e=new Array(arguments.length-1),r=this._callbacks["$"+t],n=1;n<arguments.length;n++)e[n-1]=arguments[n];if(r){n=0;for(var i=(r=r.slice(0)).length;n<i;++n)r[n].apply(this,e)}return this},e.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},e.prototype.hasListeners=function(t){return!!this.listeners(t).length}}(Td);var xd,kd=Td.exports;
/*! Hammer.JS - v2.0.17-rc - 2019-12-16
   * http://naver.github.io/egjs
   *
   * Forked By Naver egjs
   * Copyright (c) hammerjs
   * Licensed under the MIT license */function Sd(){return Sd=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(t[n]=r[n])}return t},Sd.apply(this,arguments)}function Ad(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t.__proto__=e}function jd(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}xd="function"!=typeof Object.assign?function(t){if(null==t)throw new TypeError("Cannot convert undefined or null to object");for(var e=Object(t),r=1;r<arguments.length;r++){var n=arguments[r];if(null!=n)for(var i in n)n.hasOwnProperty(i)&&(e[i]=n[i])}return e}:Object.assign;var Pd,Id=xd,Dd=["","webkit","Moz","MS","ms","o"],Ld="undefined"==typeof document?{style:{}}:document.createElement("div"),Cd=Math.round,Rd=Math.abs,Md=Date.now;function Fd(t,e){for(var r,n,i=e[0].toUpperCase()+e.slice(1),o=0;o<Dd.length;){if((n=(r=Dd[o])?r+i:e)in t)return n;o++}}Pd="undefined"==typeof window?{}:window;var Nd=Fd(Ld.style,"touchAction"),zd=void 0!==Nd;var qd="compute",Yd="auto",Gd="manipulation",Xd="none",Ud="pan-x",Wd="pan-y",Vd=function(){if(!zd)return!1;var t={},e=Pd.CSS&&Pd.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach((function(r){return t[r]=!e||Pd.CSS.supports("touch-action",r)})),t}(),Hd="ontouchstart"in Pd,$d=void 0!==Fd(Pd,"PointerEvent"),Bd=Hd&&/mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent),Jd="touch",Kd="mouse",Qd=16,Zd=24,ty=["x","y"],ey=["clientX","clientY"];function ry(t,e,r){var n;if(t)if(t.forEach)t.forEach(e,r);else if(void 0!==t.length)for(n=0;n<t.length;)e.call(r,t[n],n,t),n++;else for(n in t)t.hasOwnProperty(n)&&e.call(r,t[n],n,t)}function ny(t,e){return"function"==typeof t?t.apply(e&&e[0]||void 0,e):t}function iy(t,e){return t.indexOf(e)>-1}var oy=function(){function t(t,e){this.manager=t,this.set(e)}var e=t.prototype;return e.set=function(t){t===qd&&(t=this.compute()),zd&&this.manager.element.style&&Vd[t]&&(this.manager.element.style[Nd]=t),this.actions=t.toLowerCase().trim()},e.update=function(){this.set(this.manager.options.touchAction)},e.compute=function(){var t=[];return ry(this.manager.recognizers,(function(e){ny(e.options.enable,[e])&&(t=t.concat(e.getTouchAction()))})),function(t){if(iy(t,Xd))return Xd;var e=iy(t,Ud),r=iy(t,Wd);return e&&r?Xd:e||r?e?Ud:Wd:iy(t,Gd)?Gd:Yd}(t.join(" "))},e.preventDefaults=function(t){var e=t.srcEvent,r=t.offsetDirection;if(this.manager.session.prevented)e.preventDefault();else{var n=this.actions,i=iy(n,Xd)&&!Vd.none,o=iy(n,Wd)&&!Vd["pan-y"],a=iy(n,Ud)&&!Vd["pan-x"];if(i){var u=1===t.pointers.length,s=t.distance<2,c=t.deltaTime<250;if(u&&s&&c)return}if(!a||!o)return i||o&&6&r||a&&r&Zd?this.preventSrc(e):void 0}},e.preventSrc=function(t){this.manager.session.prevented=!0,t.preventDefault()},t}();function ay(t,e){for(;t;){if(t===e)return!0;t=t.parentNode}return!1}function uy(t){var e=t.length;if(1===e)return{x:Cd(t[0].clientX),y:Cd(t[0].clientY)};for(var r=0,n=0,i=0;i<e;)r+=t[i].clientX,n+=t[i].clientY,i++;return{x:Cd(r/e),y:Cd(n/e)}}function sy(t){for(var e=[],r=0;r<t.pointers.length;)e[r]={clientX:Cd(t.pointers[r].clientX),clientY:Cd(t.pointers[r].clientY)},r++;return{timeStamp:Md(),pointers:e,center:uy(e),deltaX:t.deltaX,deltaY:t.deltaY}}function cy(t,e,r){r||(r=ty);var n=e[r[0]]-t[r[0]],i=e[r[1]]-t[r[1]];return Math.sqrt(n*n+i*i)}function fy(t,e,r){r||(r=ty);var n=e[r[0]]-t[r[0]],i=e[r[1]]-t[r[1]];return 180*Math.atan2(i,n)/Math.PI}function ly(t,e){return t===e?1:Rd(t)>=Rd(e)?t<0?2:4:e<0?8:Qd}function hy(t,e,r){return{x:e/t||0,y:r/t||0}}function py(t,e){var r=t.session,n=e.pointers,i=n.length;r.firstInput||(r.firstInput=sy(e)),i>1&&!r.firstMultiple?r.firstMultiple=sy(e):1===i&&(r.firstMultiple=!1);var o=r.firstInput,a=r.firstMultiple,u=a?a.center:o.center,s=e.center=uy(n);e.timeStamp=Md(),e.deltaTime=e.timeStamp-o.timeStamp,e.angle=fy(u,s),e.distance=cy(u,s),function(t,e){var r=e.center,n=t.offsetDelta||{},i=t.prevDelta||{},o=t.prevInput||{};1!==e.eventType&&4!==o.eventType||(i=t.prevDelta={x:o.deltaX||0,y:o.deltaY||0},n=t.offsetDelta={x:r.x,y:r.y}),e.deltaX=i.x+(r.x-n.x),e.deltaY=i.y+(r.y-n.y)}(r,e),e.offsetDirection=ly(e.deltaX,e.deltaY);var c,f,l=hy(e.deltaTime,e.deltaX,e.deltaY);e.overallVelocityX=l.x,e.overallVelocityY=l.y,e.overallVelocity=Rd(l.x)>Rd(l.y)?l.x:l.y,e.scale=a?(c=a.pointers,cy((f=n)[0],f[1],ey)/cy(c[0],c[1],ey)):1,e.rotation=a?function(t,e){return fy(e[1],e[0],ey)+fy(t[1],t[0],ey)}(a.pointers,n):0,e.maxPointers=r.prevInput?e.pointers.length>r.prevInput.maxPointers?e.pointers.length:r.prevInput.maxPointers:e.pointers.length,function(t,e){var r,n,i,o,a=t.lastInterval||e,u=e.timeStamp-a.timeStamp;if(8!==e.eventType&&(u>25||void 0===a.velocity)){var s=e.deltaX-a.deltaX,c=e.deltaY-a.deltaY,f=hy(u,s,c);n=f.x,i=f.y,r=Rd(f.x)>Rd(f.y)?f.x:f.y,o=ly(s,c),t.lastInterval=e}else r=a.velocity,n=a.velocityX,i=a.velocityY,o=a.direction;e.velocity=r,e.velocityX=n,e.velocityY=i,e.direction=o}(r,e);var h,p=t.element,v=e.srcEvent;ay(h=v.composedPath?v.composedPath()[0]:v.path?v.path[0]:v.target,p)&&(p=h),e.target=p}function vy(t,e,r){var n=r.pointers.length,i=r.changedPointers.length,o=1&e&&n-i==0,a=12&e&&n-i==0;r.isFirst=!!o,r.isFinal=!!a,o&&(t.session={}),r.eventType=e,py(t,r),t.emit("hammer.input",r),t.recognize(r),t.session.prevInput=r}function dy(t){return t.trim().split(/\s+/g)}function yy(t,e,r){ry(dy(e),(function(e){t.addEventListener(e,r,!1)}))}function gy(t,e,r){ry(dy(e),(function(e){t.removeEventListener(e,r,!1)}))}function my(t){var e=t.ownerDocument||t;return e.defaultView||e.parentWindow||window}var by=function(){function t(t,e){var r=this;this.manager=t,this.callback=e,this.element=t.element,this.target=t.options.inputTarget,this.domHandler=function(e){ny(t.options.enable,[t])&&r.handler(e)},this.init()}var e=t.prototype;return e.handler=function(){},e.init=function(){this.evEl&&yy(this.element,this.evEl,this.domHandler),this.evTarget&&yy(this.target,this.evTarget,this.domHandler),this.evWin&&yy(my(this.element),this.evWin,this.domHandler)},e.destroy=function(){this.evEl&&gy(this.element,this.evEl,this.domHandler),this.evTarget&&gy(this.target,this.evTarget,this.domHandler),this.evWin&&gy(my(this.element),this.evWin,this.domHandler)},t}();function _y(t,e,r){if(t.indexOf&&!r)return t.indexOf(e);for(var n=0;n<t.length;){if(r&&t[n][r]==e||!r&&t[n]===e)return n;n++}return-1}var wy={pointerdown:1,pointermove:2,pointerup:4,pointercancel:8,pointerout:8},Oy={2:Jd,3:"pen",4:Kd,5:"kinect"},Ey="pointerdown",Ty="pointermove pointerup pointercancel";Pd.MSPointerEvent&&!Pd.PointerEvent&&(Ey="MSPointerDown",Ty="MSPointerMove MSPointerUp MSPointerCancel");var xy=function(t){function e(){var r,n=e.prototype;return n.evEl=Ey,n.evWin=Ty,(r=t.apply(this,arguments)||this).store=r.manager.session.pointerEvents=[],r}return Ad(e,t),e.prototype.handler=function(t){var e=this.store,r=!1,n=t.type.toLowerCase().replace("ms",""),i=wy[n],o=Oy[t.pointerType]||t.pointerType,a=o===Jd,u=_y(e,t.pointerId,"pointerId");1&i&&(0===t.button||a)?u<0&&(e.push(t),u=e.length-1):12&i&&(r=!0),u<0||(e[u]=t,this.callback(this.manager,i,{pointers:e,changedPointers:[t],pointerType:o,srcEvent:t}),r&&e.splice(u,1))},e}(by);function ky(t){return Array.prototype.slice.call(t,0)}function Sy(t,e,r){for(var n=[],i=[],o=0;o<t.length;){var a=e?t[o][e]:t[o];_y(i,a)<0&&n.push(t[o]),i[o]=a,o++}return r&&(n=e?n.sort((function(t,r){return t[e]>r[e]})):n.sort()),n}var Ay={touchstart:1,touchmove:2,touchend:4,touchcancel:8},jy="touchstart touchmove touchend touchcancel",Py=function(t){function e(){var r;return e.prototype.evTarget=jy,(r=t.apply(this,arguments)||this).targetIds={},r}return Ad(e,t),e.prototype.handler=function(t){var e=Ay[t.type],r=Iy.call(this,t,e);r&&this.callback(this.manager,e,{pointers:r[0],changedPointers:r[1],pointerType:Jd,srcEvent:t})},e}(by);function Iy(t,e){var r,n,i=ky(t.touches),o=this.targetIds;if(3&e&&1===i.length)return o[i[0].identifier]=!0,[i,i];var a=ky(t.changedTouches),u=[],s=this.target;if(n=i.filter((function(t){return ay(t.target,s)})),1===e)for(r=0;r<n.length;)o[n[r].identifier]=!0,r++;for(r=0;r<a.length;)o[a[r].identifier]&&u.push(a[r]),12&e&&delete o[a[r].identifier],r++;return u.length?[Sy(n.concat(u),"identifier",!0),u]:void 0}var Dy={mousedown:1,mousemove:2,mouseup:4},Ly="mousedown",Cy="mousemove mouseup",Ry=function(t){function e(){var r,n=e.prototype;return n.evEl=Ly,n.evWin=Cy,(r=t.apply(this,arguments)||this).pressed=!1,r}return Ad(e,t),e.prototype.handler=function(t){var e=Dy[t.type];1&e&&0===t.button&&(this.pressed=!0),2&e&&1!==t.which&&(e=4),this.pressed&&(4&e&&(this.pressed=!1),this.callback(this.manager,e,{pointers:[t],changedPointers:[t],pointerType:Kd,srcEvent:t}))},e}(by);function My(t){var e=t.changedPointers[0];if(e.identifier===this.primaryTouch){var r={x:e.clientX,y:e.clientY},n=this.lastTouches;this.lastTouches.push(r);setTimeout((function(){var t=n.indexOf(r);t>-1&&n.splice(t,1)}),2500)}}function Fy(t,e){1&t?(this.primaryTouch=e.changedPointers[0].identifier,My.call(this,e)):12&t&&My.call(this,e)}function Ny(t){for(var e=t.srcEvent.clientX,r=t.srcEvent.clientY,n=0;n<this.lastTouches.length;n++){var i=this.lastTouches[n],o=Math.abs(e-i.x),a=Math.abs(r-i.y);if(o<=25&&a<=25)return!0}return!1}var zy=function(){return function(t){function e(e,r){var n;return(n=t.call(this,e,r)||this).handler=function(t,e,r){var i=r.pointerType===Jd,o=r.pointerType===Kd;if(!(o&&r.sourceCapabilities&&r.sourceCapabilities.firesTouchEvents)){if(i)Fy.call(jd(jd(n)),e,r);else if(o&&Ny.call(jd(jd(n)),r))return;n.callback(t,e,r)}},n.touch=new Py(n.manager,n.handler),n.mouse=new Ry(n.manager,n.handler),n.primaryTouch=null,n.lastTouches=[],n}return Ad(e,t),e.prototype.destroy=function(){this.touch.destroy(),this.mouse.destroy()},e}(by)}();function qy(t,e,r){return!!Array.isArray(t)&&(ry(t,r[e],r),!0)}var Yy=32,Gy=1;function Xy(t,e){var r=e.manager;return r?r.get(t):t}function Uy(t){return 16&t?"cancel":8&t?"end":4&t?"move":2&t?"start":""}var Wy=function(){function t(t){void 0===t&&(t={}),this.options=Sd({enable:!0},t),this.id=Gy++,this.manager=null,this.state=1,this.simultaneous={},this.requireFail=[]}var e=t.prototype;return e.set=function(t){return Id(this.options,t),this.manager&&this.manager.touchAction.update(),this},e.recognizeWith=function(t){if(qy(t,"recognizeWith",this))return this;var e=this.simultaneous;return e[(t=Xy(t,this)).id]||(e[t.id]=t,t.recognizeWith(this)),this},e.dropRecognizeWith=function(t){return qy(t,"dropRecognizeWith",this)||(t=Xy(t,this),delete this.simultaneous[t.id]),this},e.requireFailure=function(t){if(qy(t,"requireFailure",this))return this;var e=this.requireFail;return-1===_y(e,t=Xy(t,this))&&(e.push(t),t.requireFailure(this)),this},e.dropRequireFailure=function(t){if(qy(t,"dropRequireFailure",this))return this;t=Xy(t,this);var e=_y(this.requireFail,t);return e>-1&&this.requireFail.splice(e,1),this},e.hasRequireFailures=function(){return this.requireFail.length>0},e.canRecognizeWith=function(t){return!!this.simultaneous[t.id]},e.emit=function(t){var e=this,r=this.state;function n(r){e.manager.emit(r,t)}r<8&&n(e.options.event+Uy(r)),n(e.options.event),t.additionalEvent&&n(t.additionalEvent),r>=8&&n(e.options.event+Uy(r))},e.tryEmit=function(t){if(this.canEmit())return this.emit(t);this.state=Yy},e.canEmit=function(){for(var t=0;t<this.requireFail.length;){if(!(33&this.requireFail[t].state))return!1;t++}return!0},e.recognize=function(t){var e=Id({},t);if(!ny(this.options.enable,[this,e]))return this.reset(),void(this.state=Yy);56&this.state&&(this.state=1),this.state=this.process(e),30&this.state&&this.tryEmit(e)},e.process=function(t){},e.getTouchAction=function(){},e.reset=function(){},t}(),Vy=function(t){function e(e){var r;return void 0===e&&(e={}),(r=t.call(this,Sd({event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},e))||this).pTime=!1,r.pCenter=!1,r._timer=null,r._input=null,r.count=0,r}Ad(e,t);var r=e.prototype;return r.getTouchAction=function(){return[Gd]},r.process=function(t){var e=this,r=this.options,n=t.pointers.length===r.pointers,i=t.distance<r.threshold,o=t.deltaTime<r.time;if(this.reset(),1&t.eventType&&0===this.count)return this.failTimeout();if(i&&o&&n){if(4!==t.eventType)return this.failTimeout();var a=!this.pTime||t.timeStamp-this.pTime<r.interval,u=!this.pCenter||cy(this.pCenter,t.center)<r.posThreshold;if(this.pTime=t.timeStamp,this.pCenter=t.center,u&&a?this.count+=1:this.count=1,this._input=t,0===this.count%r.taps)return this.hasRequireFailures()?(this._timer=setTimeout((function(){e.state=8,e.tryEmit()}),r.interval),2):8}return Yy},r.failTimeout=function(){var t=this;return this._timer=setTimeout((function(){t.state=Yy}),this.options.interval),Yy},r.reset=function(){clearTimeout(this._timer)},r.emit=function(){8===this.state&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))},e}(Wy),Hy=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Sd({pointers:1},e))||this}Ad(e,t);var r=e.prototype;return r.attrTest=function(t){var e=this.options.pointers;return 0===e||t.pointers.length===e},r.process=function(t){var e=this.state,r=t.eventType,n=6&e,i=this.attrTest(t);return n&&(8&r||!i)?16|e:n||i?4&r?8|e:2&e?4|e:2:Yy},e}(Wy);function $y(t){return t===Qd?"down":8===t?"up":2===t?"left":4===t?"right":""}var By=function(t){function e(e){var r;return void 0===e&&(e={}),(r=t.call(this,Sd({event:"pan",threshold:10,pointers:1,direction:30},e))||this).pX=null,r.pY=null,r}Ad(e,t);var r=e.prototype;return r.getTouchAction=function(){var t=this.options.direction,e=[];return 6&t&&e.push(Wd),t&Zd&&e.push(Ud),e},r.directionTest=function(t){var e=this.options,r=!0,n=t.distance,i=t.direction,o=t.deltaX,a=t.deltaY;return i&e.direction||(6&e.direction?(i=0===o?1:o<0?2:4,r=o!==this.pX,n=Math.abs(t.deltaX)):(i=0===a?1:a<0?8:Qd,r=a!==this.pY,n=Math.abs(t.deltaY))),t.direction=i,r&&n>e.threshold&&i&e.direction},r.attrTest=function(t){return Hy.prototype.attrTest.call(this,t)&&(2&this.state||!(2&this.state)&&this.directionTest(t))},r.emit=function(e){this.pX=e.deltaX,this.pY=e.deltaY;var r=$y(e.direction);r&&(e.additionalEvent=this.options.event+r),t.prototype.emit.call(this,e)},e}(Hy),Jy=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Sd({event:"swipe",threshold:10,velocity:.3,direction:30,pointers:1},e))||this}Ad(e,t);var r=e.prototype;return r.getTouchAction=function(){return By.prototype.getTouchAction.call(this)},r.attrTest=function(e){var r,n=this.options.direction;return 30&n?r=e.overallVelocity:6&n?r=e.overallVelocityX:n&Zd&&(r=e.overallVelocityY),t.prototype.attrTest.call(this,e)&&n&e.offsetDirection&&e.distance>this.options.threshold&&e.maxPointers===this.options.pointers&&Rd(r)>this.options.velocity&&4&e.eventType},r.emit=function(t){var e=$y(t.offsetDirection);e&&this.manager.emit(this.options.event+e,t),this.manager.emit(this.options.event,t)},e}(Hy),Ky=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Sd({event:"pinch",threshold:0,pointers:2},e))||this}Ad(e,t);var r=e.prototype;return r.getTouchAction=function(){return[Xd]},r.attrTest=function(e){return t.prototype.attrTest.call(this,e)&&(Math.abs(e.scale-1)>this.options.threshold||2&this.state)},r.emit=function(e){if(1!==e.scale){var r=e.scale<1?"in":"out";e.additionalEvent=this.options.event+r}t.prototype.emit.call(this,e)},e}(Hy),Qy=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Sd({event:"rotate",threshold:0,pointers:2},e))||this}Ad(e,t);var r=e.prototype;return r.getTouchAction=function(){return[Xd]},r.attrTest=function(e){return t.prototype.attrTest.call(this,e)&&(Math.abs(e.rotation)>this.options.threshold||2&this.state)},e}(Hy),Zy=function(t){function e(e){var r;return void 0===e&&(e={}),(r=t.call(this,Sd({event:"press",pointers:1,time:251,threshold:9},e))||this)._timer=null,r._input=null,r}Ad(e,t);var r=e.prototype;return r.getTouchAction=function(){return[Yd]},r.process=function(t){var e=this,r=this.options,n=t.pointers.length===r.pointers,i=t.distance<r.threshold,o=t.deltaTime>r.time;if(this._input=t,!i||!n||12&t.eventType&&!o)this.reset();else if(1&t.eventType)this.reset(),this._timer=setTimeout((function(){e.state=8,e.tryEmit()}),r.time);else if(4&t.eventType)return 8;return Yy},r.reset=function(){clearTimeout(this._timer)},r.emit=function(t){8===this.state&&(t&&4&t.eventType?this.manager.emit(this.options.event+"up",t):(this._input.timeStamp=Md(),this.manager.emit(this.options.event,this._input)))},e}(Wy),tg={domEvents:!1,touchAction:qd,enable:!0,inputTarget:null,inputClass:null,cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}},eg=[[Qy,{enable:!1}],[Ky,{enable:!1},["rotate"]],[Jy,{direction:6}],[By,{direction:6},["swipe"]],[Vy],[Vy,{event:"doubletap",taps:2},["tap"]],[Zy]];function rg(t,e){var r,n=t.element;n.style&&(ry(t.options.cssProps,(function(i,o){r=Fd(n.style,o),e?(t.oldCssProps[r]=n.style[r],n.style[r]=i):n.style[r]=t.oldCssProps[r]||""})),e||(t.oldCssProps={}))}var ng=function(){function t(t,e){var r,n=this;this.options=Id({},tg,e||{}),this.options.inputTarget=this.options.inputTarget||t,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=t,this.input=new((r=this).options.inputClass||($d?xy:Bd?Py:Hd?zy:Ry))(r,vy),this.touchAction=new oy(this,this.options.touchAction),rg(this,!0),ry(this.options.recognizers,(function(t){var e=n.add(new t[0](t[1]));t[2]&&e.recognizeWith(t[2]),t[3]&&e.requireFailure(t[3])}),this)}var e=t.prototype;return e.set=function(t){return Id(this.options,t),t.touchAction&&this.touchAction.update(),t.inputTarget&&(this.input.destroy(),this.input.target=t.inputTarget,this.input.init()),this},e.stop=function(t){this.session.stopped=t?2:1},e.recognize=function(t){var e=this.session;if(!e.stopped){var r;this.touchAction.preventDefaults(t);var n=this.recognizers,i=e.curRecognizer;(!i||i&&8&i.state)&&(e.curRecognizer=null,i=null);for(var o=0;o<n.length;)r=n[o],2===e.stopped||i&&r!==i&&!r.canRecognizeWith(i)?r.reset():r.recognize(t),!i&&14&r.state&&(e.curRecognizer=r,i=r),o++}},e.get=function(t){if(t instanceof Wy)return t;for(var e=this.recognizers,r=0;r<e.length;r++)if(e[r].options.event===t)return e[r];return null},e.add=function(t){if(qy(t,"add",this))return this;var e=this.get(t.options.event);return e&&this.remove(e),this.recognizers.push(t),t.manager=this,this.touchAction.update(),t},e.remove=function(t){if(qy(t,"remove",this))return this;var e=this.get(t);if(t){var r=this.recognizers,n=_y(r,e);-1!==n&&(r.splice(n,1),this.touchAction.update())}return this},e.on=function(t,e){if(void 0===t||void 0===e)return this;var r=this.handlers;return ry(dy(t),(function(t){r[t]=r[t]||[],r[t].push(e)})),this},e.off=function(t,e){if(void 0===t)return this;var r=this.handlers;return ry(dy(t),(function(t){e?r[t]&&r[t].splice(_y(r[t],e),1):delete r[t]})),this},e.emit=function(t,e){this.options.domEvents&&function(t,e){var r=document.createEvent("Event");r.initEvent(t,!0,!0),r.gesture=e,e.target.dispatchEvent(r)}(t,e);var r=this.handlers[t]&&this.handlers[t].slice();if(r&&r.length){e.type=t,e.preventDefault=function(){e.srcEvent.preventDefault()};for(var n=0;n<r.length;)r[n](e),n++}},e.destroy=function(){this.element&&rg(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null},t}(),ig={touchstart:1,touchmove:2,touchend:4,touchcancel:8},og="touchstart",ag="touchstart touchmove touchend touchcancel",ug=function(t){function e(){var r,n=e.prototype;return n.evTarget=og,n.evWin=ag,(r=t.apply(this,arguments)||this).started=!1,r}return Ad(e,t),e.prototype.handler=function(t){var e=ig[t.type];if(1===e&&(this.started=!0),this.started){var r=sg.call(this,t,e);12&e&&r[0].length-r[1].length==0&&(this.started=!1),this.callback(this.manager,e,{pointers:r[0],changedPointers:r[1],pointerType:Jd,srcEvent:t})}},e}(by);function sg(t,e){var r=ky(t.touches),n=ky(t.changedTouches);return 12&e&&(r=Sy(r.concat(n),"identifier",!0)),[r,n]}function cg(t,e,r){var n="DEPRECATED METHOD: "+e+"\n"+r+" AT \n";return function(){var e=new Error("get-stack-trace"),r=e&&e.stack?e.stack.replace(/^[^\(]+?[\n$]/gm,"").replace(/^\s+at\s+/gm,"").replace(/^Object.<anonymous>\s*\(/gm,"{anonymous}()@"):"Unknown Stack Trace",i=window.console&&(window.console.warn||window.console.log);return i&&i.call(window.console,n,r),t.apply(this,arguments)}}var fg=cg((function(t,e,r){for(var n=Object.keys(e),i=0;i<n.length;)(!r||r&&void 0===t[n[i]])&&(t[n[i]]=e[n[i]]),i++;return t}),"extend","Use `assign`."),lg=cg((function(t,e){return fg(t,e,!0)}),"merge","Use `assign`.");function hg(t,e,r){var n,i=e.prototype;(n=t.prototype=Object.create(i)).constructor=t,n._super=i,r&&Id(n,r)}function pg(t,e){return function(){return t.apply(e,arguments)}}var vg=function(){var t=function(t,e){return void 0===e&&(e={}),new ng(t,Sd({recognizers:eg.concat()},e))};return t.VERSION="2.0.17-rc",t.DIRECTION_ALL=30,t.DIRECTION_DOWN=Qd,t.DIRECTION_LEFT=2,t.DIRECTION_RIGHT=4,t.DIRECTION_UP=8,t.DIRECTION_HORIZONTAL=6,t.DIRECTION_VERTICAL=Zd,t.DIRECTION_NONE=1,t.DIRECTION_DOWN=Qd,t.INPUT_START=1,t.INPUT_MOVE=2,t.INPUT_END=4,t.INPUT_CANCEL=8,t.STATE_POSSIBLE=1,t.STATE_BEGAN=2,t.STATE_CHANGED=4,t.STATE_ENDED=8,t.STATE_RECOGNIZED=8,t.STATE_CANCELLED=16,t.STATE_FAILED=Yy,t.Manager=ng,t.Input=by,t.TouchAction=oy,t.TouchInput=Py,t.MouseInput=Ry,t.PointerEventInput=xy,t.TouchMouseInput=zy,t.SingleTouchInput=ug,t.Recognizer=Wy,t.AttrRecognizer=Hy,t.Tap=Vy,t.Pan=By,t.Swipe=Jy,t.Pinch=Ky,t.Rotate=Qy,t.Press=Zy,t.on=yy,t.off=gy,t.each=ry,t.merge=lg,t.extend=fg,t.bindFn=pg,t.assign=Id,t.inherit=hg,t.bindFn=pg,t.prefixed=Fd,t.toArray=ky,t.inArray=_y,t.uniqueArray=Sy,t.splitStr=dy,t.boolOrFn=ny,t.hasParent=ay,t.addEventListeners=yy,t.removeEventListeners=gy,t.defaults=Id({},tg,{preset:eg}),t}();function dg(t,e){var r=void 0!==Oh&&ic(t)||t["@@iterator"];if(!r){if(Ph(t)||(r=function(t,e){var r;if(!t)return;if("string"==typeof t)return yg(t,e);var n=Ah(r=Object.prototype.toString.call(t)).call(r,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return qs(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return yg(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,i=function(){};return{s:i,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){r=r.call(t)},n:function(){var t=r.next();return a=t.done,t},e:function(t){u=!0,o=t},f:function(){try{a||null==r.return||r.return()}finally{if(u)throw o}}}}function yg(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var gg=Oh("DELETE");function mg(){var t=bg.apply(void 0,arguments);return wg(t),t}function bg(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];if(e.length<2)return e[0];var n;if(e.length>2)return bg.apply(void 0,Sh(n=[mg(e[0],e[1])]).call(n,wh(Ah(e).call(e,2))));var i,o=e[0],a=e[1],u=dg(jh(a));try{for(u.s();!(i=u.n()).done;){var s=i.value;Object.prototype.propertyIsEnumerable.call(a,s)&&(a[s]===gg?delete o[s]:null===o[s]||null===a[s]||"object"!==_h(o[s])||"object"!==_h(a[s])||Ph(o[s])||Ph(a[s])?o[s]=_g(a[s]):o[s]=bg(o[s],a[s]))}}catch(t){u.e(t)}finally{u.f()}return o}function _g(t){return Ph(t)?Ri(t).call(t,(function(t){return _g(t)})):"object"===_h(t)&&null!==t?bg({},t):t}function wg(t){for(var e=0,r=Lh(t);e<r.length;e++){var n=r[e];t[n]===gg?delete t[n]:"object"===_h(t[n])&&null!==t[n]&&wg(t[n])}}var Og="undefined"!=typeof window?window.Hammer||vg:function(){return function(){var t=function(){};return{on:t,off:t,destroy:t,emit:t,get:function(){return{set:t}}}}()};function Eg(t){var e,r=this;this._cleanupQueue=[],this.active=!1,this._dom={container:t,overlay:document.createElement("div")},this._dom.overlay.classList.add("vis-overlay"),this._dom.container.appendChild(this._dom.overlay),this._cleanupQueue.push((function(){r._dom.overlay.parentNode.removeChild(r._dom.overlay)}));var n=Og(this._dom.overlay);n.on("tap",en(e=this._onTapOverlay).call(e,this)),this._cleanupQueue.push((function(){n.destroy()}));var i=["tap","doubletap","press","pinch","pan","panstart","panmove","panend"];Hh(i).call(i,(function(t){n.on(t,(function(t){t.srcEvent.stopPropagation()}))})),document&&document.body&&(this._onClick=function(e){(function(t,e){for(;t;){if(t===e)return!0;t=t.parentNode}return!1})(e.target,t)||r.deactivate()},document.body.addEventListener("click",this._onClick),this._cleanupQueue.push((function(){document.body.removeEventListener("click",r._onClick)}))),this._escListener=function(t){("key"in t?"Escape"===t.key:27===t.keyCode)&&r.deactivate()}}kd(Eg.prototype),Eg.current=null,Eg.prototype.destroy=function(){var t,e;this.deactivate();var r,n=dg(rp(t=wp(e=this._cleanupQueue).call(e,0)).call(t));try{for(n.s();!(r=n.n()).done;){(0,r.value)()}}catch(t){n.e(t)}finally{n.f()}},Eg.prototype.activate=function(){Eg.current&&Eg.current.deactivate(),Eg.current=this,this.active=!0,this._dom.overlay.style.display="none",this._dom.container.classList.add("vis-active"),this.emit("change"),this.emit("activate"),document.body.addEventListener("keydown",this._escListener)},Eg.prototype.deactivate=function(){this.active=!1,this._dom.overlay.style.display="block",this._dom.container.classList.remove("vis-active"),document.body.removeEventListener("keydown",this._escListener),this.emit("change"),this.emit("deactivate")},Eg.prototype._onTapOverlay=function(t){this.activate(),t.srcEvent.stopPropagation()};var Tg=ni,xg=wt,kg=o.TypeError,Sg=Tr,Ag=h,jg=Hr,Pg=function(t){if(Tg(t))return t;throw kg(xg(t)+" is not a constructor")},Ig=Qe,Dg=$,Lg=Ma,Cg=a,Rg=tt("Reflect","construct"),Mg=Object.prototype,Fg=[].push,Ng=Cg((function(){function t(){}return!(Rg((function(){}),[],t)instanceof t)})),zg=!Cg((function(){Rg((function(){}))})),qg=Ng||zg;Sg({target:"Reflect",stat:!0,forced:qg,sham:qg},{construct:function(t,e){Pg(t),Ig(e);var r=arguments.length<3?t:Pg(arguments[2]);if(zg&&!Ng)return Rg(t,e,r);if(t==r){switch(e.length){case 0:return new t;case 1:return new t(e[0]);case 2:return new t(e[0],e[1]);case 3:return new t(e[0],e[1],e[2]);case 4:return new t(e[0],e[1],e[2],e[3])}var n=[null];return Ag(Fg,n,e),new(Ag(jg,t,n))}var i=r.prototype,o=Lg(Dg(i)?i:Mg),a=Ag(t,o,e);return Dg(a)?a:o}});var Yg=B.Reflect.construct;function Gg(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}var Xg=qv;Tr({target:"Object",stat:!0},{setPrototypeOf:Su});var Ug=B.Object.setPrototypeOf;function Wg(t,e){return Wg=Ug||function(t,e){return t.__proto__=e,t},Wg(t,e)}function Vg(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Xg(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Ir(t,"prototype",{writable:!1}),e&&Wg(t,e)}function Hg(t,e){if(e&&("object"===_h(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return Gg(t)}var $g=Zp;function Bg(t){return Bg=Ug?$g:function(t){return t.__proto__||$g(t)},Bg(t)}var Jg={exports:{}};!function(t){var e=function(t){var e,r=Object.prototype,n=r.hasOwnProperty,i="function"==typeof Symbol?Symbol:{},o=i.iterator||"@@iterator",a=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function s(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{s({},"")}catch(t){s=function(t,e,r){return t[e]=r}}function c(t,e,r,n){var i=e&&e.prototype instanceof y?e:y,o=Object.create(i.prototype),a=new A(n||[]);return o._invoke=function(t,e,r){var n=l;return function(i,o){if(n===p)throw new Error("Generator is already running");if(n===v){if("throw"===i)throw o;return P()}for(r.method=i,r.arg=o;;){var a=r.delegate;if(a){var u=x(a,r);if(u){if(u===d)continue;return u}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===l)throw n=v,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=p;var s=f(t,e,r);if("normal"===s.type){if(n=r.done?v:h,s.arg===d)continue;return{value:s.arg,done:r.done}}"throw"===s.type&&(n=v,r.method="throw",r.arg=s.arg)}}}(t,r,a),o}function f(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}t.wrap=c;var l="suspendedStart",h="suspendedYield",p="executing",v="completed",d={};function y(){}function g(){}function m(){}var b={};s(b,o,(function(){return this}));var _=Object.getPrototypeOf,w=_&&_(_(j([])));w&&w!==r&&n.call(w,o)&&(b=w);var O=m.prototype=y.prototype=Object.create(b);function E(t){["next","throw","return"].forEach((function(e){s(t,e,(function(t){return this._invoke(e,t)}))}))}function T(t,e){function r(i,o,a,u){var s=f(t[i],t,o);if("throw"!==s.type){var c=s.arg,l=c.value;return l&&"object"==typeof l&&n.call(l,"__await")?e.resolve(l.__await).then((function(t){r("next",t,a,u)}),(function(t){r("throw",t,a,u)})):e.resolve(l).then((function(t){c.value=t,a(c)}),(function(t){return r("throw",t,a,u)}))}u(s.arg)}var i;this._invoke=function(t,n){function o(){return new e((function(e,i){r(t,n,e,i)}))}return i=i?i.then(o,o):o()}}function x(t,r){var n=t.iterator[r.method];if(n===e){if(r.delegate=null,"throw"===r.method){if(t.iterator.return&&(r.method="return",r.arg=e,x(t,r),"throw"===r.method))return d;r.method="throw",r.arg=new TypeError("The iterator does not provide a 'throw' method")}return d}var i=f(n,t.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,d;var o=i.arg;return o?o.done?(r[t.resultName]=o.value,r.next=t.nextLoc,"return"!==r.method&&(r.method="next",r.arg=e),r.delegate=null,d):o:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,d)}function k(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function S(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function A(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(k,this),this.reset(!0)}function j(t){if(t){var r=t[o];if(r)return r.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var i=-1,a=function r(){for(;++i<t.length;)if(n.call(t,i))return r.value=t[i],r.done=!1,r;return r.value=e,r.done=!0,r};return a.next=a}}return{next:P}}function P(){return{value:e,done:!0}}return g.prototype=m,s(O,"constructor",m),s(m,"constructor",g),g.displayName=s(m,u,"GeneratorFunction"),t.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===g||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,m):(t.__proto__=m,s(t,u,"GeneratorFunction")),t.prototype=Object.create(O),t},t.awrap=function(t){return{__await:t}},E(T.prototype),s(T.prototype,a,(function(){return this})),t.AsyncIterator=T,t.async=function(e,r,n,i,o){void 0===o&&(o=Promise);var a=new T(c(e,r,n,i),o);return t.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},E(O),s(O,u,"Generator"),s(O,o,(function(){return this})),s(O,"toString",(function(){return"[object Generator]"})),t.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},t.values=j,A.prototype={constructor:A,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(S),!t)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=e)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var r=this;function i(n,i){return u.type="throw",u.arg=t,r.next=n,i&&(r.method="next",r.arg=e),!!i}for(var o=this.tryEntries.length-1;o>=0;--o){var a=this.tryEntries[o],u=a.completion;if("root"===a.tryLoc)return i("end");if(a.tryLoc<=this.prev){var s=n.call(a,"catchLoc"),c=n.call(a,"finallyLoc");if(s&&c){if(this.prev<a.catchLoc)return i(a.catchLoc,!0);if(this.prev<a.finallyLoc)return i(a.finallyLoc)}else if(s){if(this.prev<a.catchLoc)return i(a.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return i(a.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r];if(i.tryLoc<=this.prev&&n.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var o=i;break}}o&&("break"===t||"continue"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var a=o?o.completion:{};return a.type=t,a.arg=e,o?(this.method="next",this.next=o.finallyLoc,d):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),d},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),S(r),d}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var i=n.arg;S(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,r,n){return this.delegate={iterator:j(t),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=e),d}},t}(t.exports);try{regeneratorRuntime=e}catch(t){"object"==typeof globalThis?globalThis.regeneratorRuntime=e:Function("r","regeneratorRuntime = r")(e)}}(Jg);var Kg=Jg.exports,Qg={exports:{}},Zg=a((function(){if("function"==typeof ArrayBuffer){var t=new ArrayBuffer(8);Object.isExtensible(t)&&Object.defineProperty(t,"a",{value:8})}})),tm=a,em=$,rm=R,nm=Zg,im=Object.isExtensible,om=tm((function(){im(1)}))||nm?function(t){return!!em(t)&&((!nm||"ArrayBuffer"!=rm(t))&&(!im||im(t)))}:im,am=!a((function(){return Object.isExtensible(Object.preventExtensions({}))})),um=Tr,sm=m,cm=Eo,fm=$,lm=Ut,hm=Ve.f,pm=oc,vm=sc,dm=om,ym=am,gm=!1,mm=Bt("meta"),bm=0,_m=function(t){hm(t,mm,{value:{objectID:"O"+bm++,weakData:{}}})},wm=Qg.exports={enable:function(){wm.enable=function(){},gm=!0;var t=pm.f,e=sm([].splice),r={};r[mm]=1,t(r).length&&(pm.f=function(r){for(var n=t(r),i=0,o=n.length;i<o;i++)if(n[i]===mm){e(n,i,1);break}return n},um({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:vm.f}))},fastKey:function(t,e){if(!fm(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!lm(t,mm)){if(!dm(t))return"F";if(!e)return"E";_m(t)}return t[mm].objectID},getWeakData:function(t,e){if(!lm(t,mm)){if(!dm(t))return!0;if(!e)return!1;_m(t)}return t[mm].weakData},onFreeze:function(t){return ym&&gm&&dm(t)&&!lm(t,mm)&&_m(t),t}};cm[mm]=!0;var Om=We,Em=T,Tm=Qe,xm=wt,km=os,Sm=cn,Am=et,jm=ws,Pm=vs,Im=Zu,Dm=o.TypeError,Lm=function(t,e){this.stopped=t,this.result=e},Cm=Lm.prototype,Rm=function(t,e,r){var n,i,o,a,u,s,c,f=r&&r.that,l=!(!r||!r.AS_ENTRIES),h=!(!r||!r.IS_ITERATOR),p=!(!r||!r.INTERRUPTED),v=Om(e,f),d=function(t){return n&&Im(n,"normal",t),new Lm(!0,t)},y=function(t){return l?(Tm(t),p?v(t[0],t[1],d):v(t[0],t[1])):p?v(t,d):v(t)};if(h)n=t;else{if(!(i=Pm(t)))throw Dm(xm(t)+" is not iterable");if(km(i)){for(o=0,a=Sm(t);a>o;o++)if((u=y(t[o]))&&Am(Cm,u))return u;return new Lm(!1)}n=jm(t,i)}for(s=n.next;!(c=Em(s,n)).done;){try{u=y(c.value)}catch(t){Im(n,"throw",t)}if("object"==typeof u&&u&&Am(Cm,u))return u}return new Lm(!1)},Mm=et,Fm=o.TypeError,Nm=function(t,e){if(Mm(e,t))return t;throw Fm("Incorrect invocation")},zm=Tr,qm=o,Ym=Qg.exports,Gm=a,Xm=hr,Um=Rm,Wm=Nm,Vm=b,Hm=$,$m=hu,Bm=Ve.f,Jm=bi.forEach,Km=w,Qm=Yo.set,Zm=Yo.getterFor,tb=function(t,e,r){var n,i=-1!==t.indexOf("Map"),o=-1!==t.indexOf("Weak"),a=i?"set":"add",u=qm[t],s=u&&u.prototype,c={};if(Km&&Vm(u)&&(o||s.forEach&&!Gm((function(){(new u).entries().next()})))){var f=(n=e((function(e,r){Qm(Wm(e,f),{type:t,collection:new u}),null!=r&&Um(r,e[a],{that:e,AS_ENTRIES:i})}))).prototype,l=Zm(t);Jm(["add","clear","delete","forEach","get","has","set","keys","values","entries"],(function(t){var e="add"==t||"set"==t;!(t in s)||o&&"clear"==t||Xm(f,t,(function(r,n){var i=l(this).collection;if(!e&&o&&!Hm(r))return"get"==t&&void 0;var a=i[t](0===r?0:r,n);return e?this:a}))})),o||Bm(f,"size",{configurable:!0,get:function(){return l(this).collection.size}})}else n=r.getConstructor(e,t,i,a),Ym.enable();return $m(n,t,!1,!0),c[t]=n,zm({global:!0,forced:!0},c),o||r.setStrong(n,t,i),n},eb=$a,rb=tt,nb=Ve,ib=w,ob=ae("species"),ab=Ve.f,ub=Ma,sb=function(t,e,r){for(var n in e)r&&r.unsafe&&t[n]?t[n]=e[n]:eb(t,n,e[n],r);return t},cb=We,fb=Nm,lb=Rm,hb=Gu,pb=function(t){var e=rb(t),r=nb.f;ib&&e&&!e[ob]&&r(e,ob,{configurable:!0,get:function(){return this}})},vb=w,db=Qg.exports.fastKey,yb=Yo.set,gb=Yo.getterFor,mb={getConstructor:function(t,e,r,n){var i=t((function(t,i){fb(t,o),yb(t,{type:e,index:ub(null),first:void 0,last:void 0,size:0}),vb||(t.size=0),null!=i&&lb(i,t[n],{that:t,AS_ENTRIES:r})})),o=i.prototype,a=gb(e),u=function(t,e,r){var n,i,o=a(t),u=s(t,e);return u?u.value=r:(o.last=u={index:i=db(e,!0),key:e,value:r,previous:n=o.last,next:void 0,removed:!1},o.first||(o.first=u),n&&(n.next=u),vb?o.size++:t.size++,"F"!==i&&(o.index[i]=u)),t},s=function(t,e){var r,n=a(t),i=db(e);if("F"!==i)return n.index[i];for(r=n.first;r;r=r.next)if(r.key==e)return r};return sb(o,{clear:function(){for(var t=a(this),e=t.index,r=t.first;r;)r.removed=!0,r.previous&&(r.previous=r.previous.next=void 0),delete e[r.index],r=r.next;t.first=t.last=void 0,vb?t.size=0:this.size=0},delete:function(t){var e=this,r=a(e),n=s(e,t);if(n){var i=n.next,o=n.previous;delete r.index[n.index],n.removed=!0,o&&(o.next=i),i&&(i.previous=o),r.first==n&&(r.first=i),r.last==n&&(r.last=o),vb?r.size--:e.size--}return!!n},forEach:function(t){for(var e,r=a(this),n=cb(t,arguments.length>1?arguments[1]:void 0);e=e?e.next:r.first;)for(n(e.value,e.key,this);e&&e.removed;)e=e.previous},has:function(t){return!!s(this,t)}}),sb(o,r?{get:function(t){var e=s(this,t);return e&&e.value},set:function(t,e){return u(this,0===t?0:t,e)}}:{add:function(t){return u(this,t=0===t?0:t,t)}}),vb&&ab(o,"size",{get:function(){return a(this).size}}),i},setStrong:function(t,e,r){var n=e+" Iterator",i=gb(e),o=gb(n);hb(t,e,(function(t,e){yb(this,{type:n,target:t,state:i(t),kind:e,last:void 0})}),(function(){for(var t=o(this),e=t.kind,r=t.last;r&&r.removed;)r=r.previous;return t.target&&(t.last=r=r?r.next:t.state.first)?"keys"==e?{value:r.key,done:!1}:"values"==e?{value:r.value,done:!1}:{value:[r.key,r.value],done:!1}:(t.target=void 0,{value:void 0,done:!0})}),r?"entries":"values",!r,!0),pb(e)}};tb("Map",(function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}}),mb);var bb=B.Map,_b=bi.some;Tr({target:"Array",proto:!0,forced:!mn("some")},{some:function(t){return _b(this,t,arguments.length>1?arguments[1]:void 0)}});var wb=Jr("Array").some,Ob=et,Eb=wb,Tb=Array.prototype,xb=function(t){var e=t.some;return t===Tb||Ob(Tb,t)&&e===Tb.some?Eb:e},kb=Jr("Array").keys,Sb=zn,Ab=Ut,jb=et,Pb=kb,Ib=Array.prototype,Db={DOMTokenList:!0,NodeList:!0},Lb=function(t){var e=t.keys;return t===Ib||jb(Ib,t)&&e===Ib.keys||Ab(Db,Sb(t))?Pb:e},Cb=vc,Rb=Math.floor,Mb=function(t,e){var r=t.length,n=Rb(r/2);return r<8?Fb(t,e):Nb(t,Mb(Cb(t,0,n),e),Mb(Cb(t,n),e),e)},Fb=function(t,e){for(var r,n,i=t.length,o=1;o<i;){for(n=o,r=t[o];n&&e(t[n-1],r)>0;)t[n]=t[--n];n!==o++&&(t[n]=r)}return t},Nb=function(t,e,r,n){for(var i=e.length,o=r.length,a=0,u=0;a<i||u<o;)t[a+u]=a<i&&u<o?n(e[a],r[u])<=0?e[a++]:r[u++]:a<i?e[a++]:r[u++];return t},zb=Mb,qb=rt.match(/firefox\/(\d+)/i),Yb=!!qb&&+qb[1],Gb=/MSIE|Trident/.test(rt),Xb=rt.match(/AppleWebKit\/(\d+)\./),Ub=!!Xb&&+Xb[1],Wb=Tr,Vb=m,Hb=xt,$b=Yt,Bb=cn,Jb=io,Kb=a,Qb=zb,Zb=mn,t_=Yb,e_=Gb,r_=ct,n_=Ub,i_=[],o_=Vb(i_.sort),a_=Vb(i_.push),u_=Kb((function(){i_.sort(void 0)})),s_=Kb((function(){i_.sort(null)})),c_=Zb("sort"),f_=!Kb((function(){if(r_)return r_<70;if(!(t_&&t_>3)){if(e_)return!0;if(n_)return n_<603;var t,e,r,n,i="";for(t=65;t<76;t++){switch(e=String.fromCharCode(t),t){case 66:case 69:case 70:case 72:r=3;break;case 68:case 71:r=4;break;default:r=2}for(n=0;n<47;n++)i_.push({k:e+n,v:r})}for(i_.sort((function(t,e){return e.v-t.v})),n=0;n<i_.length;n++)e=i_[n].k.charAt(0),i.charAt(i.length-1)!==e&&(i+=e);return"DGBEFHACIJK"!==i}}));Wb({target:"Array",proto:!0,forced:u_||!s_||!c_||!f_},{sort:function(t){void 0!==t&&Hb(t);var e=$b(this);if(f_)return void 0===t?o_(e):o_(e,t);var r,n,i=[],o=Bb(e);for(n=0;n<o;n++)n in e&&a_(i,e[n]);for(Qb(i,function(t){return function(e,r){return void 0===r?-1:void 0===e?1:void 0!==t?+t(e,r)||0:Jb(e)>Jb(r)?1:-1}}(t)),r=i.length,n=0;n<r;)e[n]=i[n++];for(;n<o;)delete e[n++];return e}});var l_,h_=Jr("Array").sort,p_=et,v_=h_,d_=Array.prototype,y_=function(t){var e=t.sort;return t===d_||p_(d_,t)&&e===d_.sort?v_:e},g_=Jr("Array").values,m_=zn,b_=Ut,__=et,w_=g_,O_=Array.prototype,E_={DOMTokenList:!0,NodeList:!0},T_=function(t){var e=t.values;return t===O_||__(O_,t)&&e===O_.values||b_(E_,m_(t))?w_:e},x_=mh,k_=Jr("Array").entries,S_=zn,A_=Ut,j_=et,P_=k_,I_=Array.prototype,D_={DOMTokenList:!0,NodeList:!0},L_=function(t){var e=t.entries;return t===I_||j_(I_,t)&&e===I_.entries||A_(D_,S_(t))?P_:e},C_=new Uint8Array(16);function R_(){if(!l_&&!(l_="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return l_(C_)}var M_=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function F_(t){return"string"==typeof t&&M_.test(t)}for(var N_=[],z_=0;z_<256;++z_)N_.push((z_+256).toString(16).substr(1));function q_(t,e,r){var n=(t=t||{}).random||(t.rng||R_)();if(n[6]=15&n[6]|64,n[8]=63&n[8]|128,e){r=r||0;for(var i=0;i<16;++i)e[r+i]=n[i];return e}return function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=(N_[t[e+0]]+N_[t[e+1]]+N_[t[e+2]]+N_[t[e+3]]+"-"+N_[t[e+4]]+N_[t[e+5]]+"-"+N_[t[e+6]]+N_[t[e+7]]+"-"+N_[t[e+8]]+N_[t[e+9]]+"-"+N_[t[e+10]]+N_[t[e+11]]+N_[t[e+12]]+N_[t[e+13]]+N_[t[e+14]]+N_[t[e+15]]).toLowerCase();if(!F_(r))throw TypeError("Stringified UUID is invalid");return r}(n)}function Y_(t){return"string"==typeof t||"number"==typeof t}var G_=function(){function t(r){e(this,t),Cr(this,"delay",void 0),Cr(this,"max",void 0),Cr(this,"_queue",[]),Cr(this,"_timeout",null),Cr(this,"_extended",null),this.delay=null,this.max=1/0,this.setOptions(r)}return Lr(t,[{key:"setOptions",value:function(t){t&&void 0!==t.delay&&(this.delay=t.delay),t&&void 0!==t.max&&(this.max=t.max),this._flushIfNeeded()}},{key:"destroy",value:function(){if(this.flush(),this._extended){for(var t=this._extended.object,e=this._extended.methods,r=0;r<e.length;r++){var n=e[r];n.original?t[n.name]=n.original:delete t[n.name]}this._extended=null}}},{key:"replace",value:function(t,e){var r=this,n=t[e];if(!n)throw new Error("Method "+e+" undefined");t[e]=function(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];r.queue({args:e,fn:n,context:this})}}},{key:"queue",value:function(t){"function"==typeof t?this._queue.push({fn:t}):this._queue.push(t),this._flushIfNeeded()}},{key:"_flushIfNeeded",value:function(){var t=this;this._queue.length>this.max&&this.flush(),null!=this._timeout&&(clearTimeout(this._timeout),this._timeout=null),this.queue.length>0&&"number"==typeof this.delay&&(this._timeout=bd((function(){t.flush()}),this.delay))}},{key:"flush",value:function(){var t,e;Hh(t=wp(e=this._queue).call(e,0)).call(t,(function(t){t.fn.apply(t.context||t.fn,t.args||[])}))}}],[{key:"extend",value:function(e,r){var n=new t(r);if(void 0!==e.flush)throw new Error("Target object already has a property flush");e.flush=function(){n.flush()};var i=[{name:"flush",original:void 0}];if(r&&r.replace)for(var o=0;o<r.replace.length;o++){var a=r.replace[o];i.push({name:a,original:e[a]}),n.replace(e,a)}return n._extended={object:e,methods:i},n}}]),t}(),X_=function(){function t(){e(this,t),Cr(this,"_subscribers",{"*":[],add:[],remove:[],update:[]}),Cr(this,"subscribe",t.prototype.on),Cr(this,"unsubscribe",t.prototype.off)}return Lr(t,[{key:"_trigger",value:function(t,e,r){var n,i;if("*"===t)throw new Error("Cannot trigger event *");Hh(n=Sh(i=[]).call(i,wh(this._subscribers[t]),wh(this._subscribers["*"]))).call(n,(function(n){n(t,e,null!=r?r:null)}))}},{key:"on",value:function(t,e){"function"==typeof e&&this._subscribers[t].push(e)}},{key:"off",value:function(t,e){var r;this._subscribers[t]=ji(r=this._subscribers[t]).call(r,(function(t){return t!==e}))}}]),t}();tb("Set",(function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}}),mb);var U_,W_=B.Set,V_=ws;function H_(t,e){var r=void 0!==Oh&&ic(t)||t["@@iterator"];if(!r){if(Ph(t)||(r=function(t,e){var r;if(!t)return;if("string"==typeof t)return $_(t,e);var n=Ah(r=Object.prototype.toString.call(t)).call(r,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return qs(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return $_(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,i=function(){};return{s:i,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){r=r.call(t)},n:function(){var t=r.next();return a=t.done,t},e:function(t){u=!0,o=t},f:function(){try{a||null==r.return||r.return()}finally{if(u)throw o}}}}function $_(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}U_=x_;var B_=function(){function t(r){e(this,t),Cr(this,"_pairs",void 0),this._pairs=r}return Lr(t,[{key:U_,value:Kg.mark((function t(){var e,r,n,i,o;return Kg.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:e=H_(this._pairs),t.prev=1,e.s();case 3:if((r=e.n()).done){t.next=9;break}return n=gh(r.value,2),i=n[0],o=n[1],t.next=7,[i,o];case 7:t.next=3;break;case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),e.e(t.t0);case 14:return t.prev=14,e.f(),t.finish(14);case 17:case"end":return t.stop()}}),t,this,[[1,11,14,17]])}))},{key:"entries",value:Kg.mark((function t(){var e,r,n,i,o;return Kg.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:e=H_(this._pairs),t.prev=1,e.s();case 3:if((r=e.n()).done){t.next=9;break}return n=gh(r.value,2),i=n[0],o=n[1],t.next=7,[i,o];case 7:t.next=3;break;case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),e.e(t.t0);case 14:return t.prev=14,e.f(),t.finish(14);case 17:case"end":return t.stop()}}),t,this,[[1,11,14,17]])}))},{key:"keys",value:Kg.mark((function t(){var e,r,n,i;return Kg.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:e=H_(this._pairs),t.prev=1,e.s();case 3:if((r=e.n()).done){t.next=9;break}return n=gh(r.value,1),i=n[0],t.next=7,i;case 7:t.next=3;break;case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),e.e(t.t0);case 14:return t.prev=14,e.f(),t.finish(14);case 17:case"end":return t.stop()}}),t,this,[[1,11,14,17]])}))},{key:"values",value:Kg.mark((function t(){var e,r,n,i;return Kg.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:e=H_(this._pairs),t.prev=1,e.s();case 3:if((r=e.n()).done){t.next=9;break}return n=gh(r.value,2),i=n[1],t.next=7,i;case 7:t.next=3;break;case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),e.e(t.t0);case 14:return t.prev=14,e.f(),t.finish(14);case 17:case"end":return t.stop()}}),t,this,[[1,11,14,17]])}))},{key:"toIdArray",value:function(){var t;return Ri(t=wh(this._pairs)).call(t,(function(t){return t[0]}))}},{key:"toItemArray",value:function(){var t;return Ri(t=wh(this._pairs)).call(t,(function(t){return t[1]}))}},{key:"toEntryArray",value:function(){return wh(this._pairs)}},{key:"toObjectMap",value:function(){var t,e=Yv(null),r=H_(this._pairs);try{for(r.s();!(t=r.n()).done;){var n=gh(t.value,2),i=n[0],o=n[1];e[i]=o}}catch(t){r.e(t)}finally{r.f()}return e}},{key:"toMap",value:function(){return new bb(this._pairs)}},{key:"toIdSet",value:function(){return new W_(this.toIdArray())}},{key:"toItemSet",value:function(){return new W_(this.toItemArray())}},{key:"cache",value:function(){return new t(wh(this._pairs))}},{key:"distinct",value:function(t){var e,r=new W_,n=H_(this._pairs);try{for(n.s();!(e=n.n()).done;){var i=gh(e.value,2),o=i[0],a=i[1];r.add(t(a,o))}}catch(t){n.e(t)}finally{n.f()}return r}},{key:"filter",value:function(e){var r=this._pairs;return new t(Cr({},x_,Kg.mark((function t(){var n,i,o,a,u;return Kg.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:n=H_(r),t.prev=1,n.s();case 3:if((i=n.n()).done){t.next=10;break}if(o=gh(i.value,2),a=o[0],u=o[1],!e(u,a)){t.next=8;break}return t.next=8,[a,u];case 8:t.next=3;break;case 10:t.next=15;break;case 12:t.prev=12,t.t0=t.catch(1),n.e(t.t0);case 15:return t.prev=15,n.f(),t.finish(15);case 18:case"end":return t.stop()}}),t,null,[[1,12,15,18]])}))))}},{key:"forEach",value:function(t){var e,r=H_(this._pairs);try{for(r.s();!(e=r.n()).done;){var n=gh(e.value,2),i=n[0];t(n[1],i)}}catch(t){r.e(t)}finally{r.f()}}},{key:"map",value:function(e){var r=this._pairs;return new t(Cr({},x_,Kg.mark((function t(){var n,i,o,a,u;return Kg.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:n=H_(r),t.prev=1,n.s();case 3:if((i=n.n()).done){t.next=9;break}return o=gh(i.value,2),a=o[0],u=o[1],t.next=7,[a,e(u,a)];case 7:t.next=3;break;case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),n.e(t.t0);case 14:return t.prev=14,n.f(),t.finish(14);case 17:case"end":return t.stop()}}),t,null,[[1,11,14,17]])}))))}},{key:"max",value:function(t){var e=V_(this._pairs),r=e.next();if(r.done)return null;for(var n=r.value[1],i=t(r.value[1],r.value[0]);!(r=e.next()).done;){var o=gh(r.value,2),a=o[0],u=o[1],s=t(u,a);s>i&&(i=s,n=u)}return n}},{key:"min",value:function(t){var e=V_(this._pairs),r=e.next();if(r.done)return null;for(var n=r.value[1],i=t(r.value[1],r.value[0]);!(r=e.next()).done;){var o=gh(r.value,2),a=o[0],u=o[1],s=t(u,a);s<i&&(i=s,n=u)}return n}},{key:"reduce",value:function(t,e){var r,n=H_(this._pairs);try{for(n.s();!(r=n.n()).done;){var i=gh(r.value,2),o=i[0];e=t(e,i[1],o)}}catch(t){n.e(t)}finally{n.f()}return e}},{key:"sort",value:function(e){var r=this;return new t(Cr({},x_,(function(){var t;return V_(y_(t=wh(r._pairs)).call(t,(function(t,r){var n=gh(t,2),i=n[0],o=n[1],a=gh(r,2),u=a[0],s=a[1];return e(o,s,i,u)})))})))}}]),t}();function J_(t,e){var r=Lh(t);if($f){var n=$f(t);e&&(n=ji(n).call(n,(function(e){return il(t,e).enumerable}))),r.push.apply(r,n)}return r}function K_(t){for(var e=1;e<arguments.length;e++){var r,n,i=null!=arguments[e]?arguments[e]:{};e%2?Hh(r=J_(Object(i),!0)).call(r,(function(e){Cr(t,e,i[e])})):dl?Ol(t,dl(i)):Hh(n=J_(Object(i))).call(n,(function(e){El(t,e,il(i,e))}))}return t}function Q_(t,e){var r=void 0!==Oh&&ic(t)||t["@@iterator"];if(!r){if(Ph(t)||(r=function(t,e){var r;if(!t)return;if("string"==typeof t)return Z_(t,e);var n=Ah(r=Object.prototype.toString.call(t)).call(r,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return qs(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return Z_(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,i=function(){};return{s:i,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){r=r.call(t)},n:function(){var t=r.next();return a=t.done,t},e:function(t){u=!0,o=t},f:function(){try{a||null==r.return||r.return()}finally{if(u)throw o}}}}function Z_(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function tw(t){var e=function(){if("undefined"==typeof Reflect||!Yg)return!1;if(Yg.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Yg(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=Bg(t);if(e){var i=Bg(this).constructor;r=Yg(n,arguments,i)}else r=n.apply(this,arguments);return Hg(this,r)}}var ew=function(t){Vg(n,t);var r=tw(n);function n(t,i){var o;return e(this,n),Cr(Gg(o=r.call(this)),"flush",void 0),Cr(Gg(o),"length",void 0),Cr(Gg(o),"_options",void 0),Cr(Gg(o),"_data",void 0),Cr(Gg(o),"_idProp",void 0),Cr(Gg(o),"_queue",null),t&&!Ph(t)&&(i=t,t=[]),o._options=i||{},o._data=new bb,o.length=0,o._idProp=o._options.fieldId||"id",t&&t.length&&o.add(t),o.setOptions(i),o}return Lr(n,[{key:"idProp",get:function(){return this._idProp}},{key:"setOptions",value:function(t){t&&void 0!==t.queue&&(!1===t.queue?this._queue&&(this._queue.destroy(),this._queue=null):(this._queue||(this._queue=G_.extend(this,{replace:["add","update","remove"]})),t.queue&&"object"===_h(t.queue)&&this._queue.setOptions(t.queue)))}},{key:"add",value:function(t,e){var r,n=this,i=[];if(Ph(t)){var o=Ri(t).call(t,(function(t){return t[n._idProp]}));if(xb(o).call(o,(function(t){return n._data.has(t)})))throw new Error("A duplicate id was found in the parameter array.");for(var a=0,u=t.length;a<u;a++)r=this._addItem(t[a]),i.push(r)}else{if(!t||"object"!==_h(t))throw new Error("Unknown dataType");r=this._addItem(t),i.push(r)}return i.length&&this._trigger("add",{items:i},e),i}},{key:"update",value:function(t,e){var r=this,n=[],i=[],o=[],a=[],u=this._idProp,s=function(t){var e=t[u];if(null!=e&&r._data.has(e)){var s=t,c=Mp({},r._data.get(e)),f=r._updateItem(s);i.push(f),a.push(s),o.push(c)}else{var l=r._addItem(t);n.push(l)}};if(Ph(t))for(var c=0,f=t.length;c<f;c++)t[c]&&"object"===_h(t[c])?s(t[c]):console.warn("Ignoring input item, which is not an object at index "+c);else{if(!t||"object"!==_h(t))throw new Error("Unknown dataType");s(t)}if(n.length&&this._trigger("add",{items:n},e),i.length){var l={items:i,oldData:o,data:a};this._trigger("update",l,e)}return Sh(n).call(n,i)}},{key:"updateOnly",value:function(t,e){var r,n=this;Ph(t)||(t=[t]);var i=Ri(r=Ri(t).call(t,(function(t){var e=n._data.get(t[n._idProp]);if(null==e)throw new Error("Updating non-existent items is not allowed.");return{oldData:e,update:t}}))).call(r,(function(t){var e=t.oldData,r=t.update,i=e[n._idProp],o=function(t){for(var e,r=arguments.length,n=new Array(r>1?r-1:0),i=1;i<r;i++)n[i-1]=arguments[i];return mg.apply(void 0,Sh(e=[{},t]).call(e,n))}(e,r);return n._data.set(i,o),{id:i,oldData:e,updatedData:o}}));if(i.length){var o={items:Ri(i).call(i,(function(t){return t.id})),oldData:Ri(i).call(i,(function(t){return t.oldData})),data:Ri(i).call(i,(function(t){return t.updatedData}))};return this._trigger("update",o,e),o.items}return[]}},{key:"get",value:function(t,e){var r=void 0,n=void 0,i=void 0;Y_(t)?(r=t,i=e):Ph(t)?(n=t,i=e):i=t;var o,a=i&&"Object"===i.returnType?"Object":"Array",u=i&&ji(i),s=[],c=void 0,f=void 0,l=void 0;if(null!=r)(c=this._data.get(r))&&u&&!u(c)&&(c=void 0);else if(null!=n)for(var h=0,p=n.length;h<p;h++)null==(c=this._data.get(n[h]))||u&&!u(c)||s.push(c);else for(var v,d=0,y=(f=wh(Lb(v=this._data).call(v))).length;d<y;d++)l=f[d],null==(c=this._data.get(l))||u&&!u(c)||s.push(c);if(i&&i.order&&null==r&&this._sort(s,i.order),i&&i.fields){var g=i.fields;if(null!=r&&null!=c)c=this._filterFields(c,g);else for(var m=0,b=s.length;m<b;m++)s[m]=this._filterFields(s[m],g)}if("Object"==a){for(var _={},w=0,O=s.length;w<O;w++){var E=s[w];_[E[this._idProp]]=E}return _}return null!=r?null!==(o=c)&&void 0!==o?o:null:s}},{key:"getIds",value:function(t){var e=this._data,r=t&&ji(t),n=t&&t.order,i=wh(Lb(e).call(e)),o=[];if(r)if(n){for(var a=[],u=0,s=i.length;u<s;u++){var c=i[u],f=this._data.get(c);null!=f&&r(f)&&a.push(f)}this._sort(a,n);for(var l=0,h=a.length;l<h;l++)o.push(a[l][this._idProp])}else for(var p=0,v=i.length;p<v;p++){var d=i[p],y=this._data.get(d);null!=y&&r(y)&&o.push(y[this._idProp])}else if(n){for(var g=[],m=0,b=i.length;m<b;m++){var _=i[m];g.push(e.get(_))}this._sort(g,n);for(var w=0,O=g.length;w<O;w++)o.push(g[w][this._idProp])}else for(var E=0,T=i.length;E<T;E++){var x=i[E],k=e.get(x);null!=k&&o.push(k[this._idProp])}return o}},{key:"getDataSet",value:function(){return this}},{key:"forEach",value:function(t,e){var r=e&&ji(e),n=this._data,i=wh(Lb(n).call(n));if(e&&e.order)for(var o=this.get(e),a=0,u=o.length;a<u;a++){var s=o[a];t(s,s[this._idProp])}else for(var c=0,f=i.length;c<f;c++){var l=i[c],h=this._data.get(l);null==h||r&&!r(h)||t(h,l)}}},{key:"map",value:function(t,e){for(var r=e&&ji(e),n=[],i=this._data,o=wh(Lb(i).call(i)),a=0,u=o.length;a<u;a++){var s=o[a],c=this._data.get(s);null==c||r&&!r(c)||n.push(t(c,s))}return e&&e.order&&this._sort(n,e.order),n}},{key:"_filterFields",value:function(t,e){var r;return t?Sn(r=Ph(e)?e:Lh(e)).call(r,(function(e,r){return e[r]=t[r],e}),{}):t}},{key:"_sort",value:function(t,e){if("string"==typeof e){var r=e;y_(t).call(t,(function(t,e){var n=t[r],i=e[r];return n>i?1:n<i?-1:0}))}else{if("function"!=typeof e)throw new TypeError("Order must be a function or a string");y_(t).call(t,e)}}},{key:"remove",value:function(t,e){for(var r=[],n=[],i=Ph(t)?t:[t],o=0,a=i.length;o<a;o++){var u=this._remove(i[o]);if(u){var s=u[this._idProp];null!=s&&(r.push(s),n.push(u))}}return r.length&&this._trigger("remove",{items:r,oldData:n},e),r}},{key:"_remove",value:function(t){var e;if(Y_(t)?e=t:t&&"object"===_h(t)&&(e=t[this._idProp]),null!=e&&this._data.has(e)){var r=this._data.get(e)||null;return this._data.delete(e),--this.length,r}return null}},{key:"clear",value:function(t){for(var e,r=wh(Lb(e=this._data).call(e)),n=[],i=0,o=r.length;i<o;i++)n.push(this._data.get(r[i]));return this._data.clear(),this.length=0,this._trigger("remove",{items:r,oldData:n},t),r}},{key:"max",value:function(t){var e,r,n=null,i=null,o=Q_(T_(e=this._data).call(e));try{for(o.s();!(r=o.n()).done;){var a=r.value,u=a[t];"number"==typeof u&&(null==i||u>i)&&(n=a,i=u)}}catch(t){o.e(t)}finally{o.f()}return n||null}},{key:"min",value:function(t){var e,r,n=null,i=null,o=Q_(T_(e=this._data).call(e));try{for(o.s();!(r=o.n()).done;){var a=r.value,u=a[t];"number"==typeof u&&(null==i||u<i)&&(n=a,i=u)}}catch(t){o.e(t)}finally{o.f()}return n||null}},{key:"distinct",value:function(t){for(var e=this._data,r=wh(Lb(e).call(e)),n=[],i=0,o=0,a=r.length;o<a;o++){for(var u=r[o],s=e.get(u)[t],c=!1,f=0;f<i;f++)if(n[f]==s){c=!0;break}c||void 0===s||(n[i]=s,i++)}return n}},{key:"_addItem",value:function(t){var e=function(t,e){return null==t[e]&&(t[e]=q_()),t}(t,this._idProp),r=e[this._idProp];if(this._data.has(r))throw new Error("Cannot add item: item with id "+r+" already exists");return this._data.set(r,e),++this.length,r}},{key:"_updateItem",value:function(t){var e=t[this._idProp];if(null==e)throw new Error("Cannot update item: item has no id (item: "+sd(t)+")");var r=this._data.get(e);if(!r)throw new Error("Cannot update item: no item with id "+e+" found");return this._data.set(e,K_(K_({},r),t)),e}},{key:"stream",value:function(t){if(t){var e=this._data;return new B_(Cr({},x_,Kg.mark((function r(){var n,i,o,a;return Kg.wrap((function(r){for(;;)switch(r.prev=r.next){case 0:n=Q_(t),r.prev=1,n.s();case 3:if((i=n.n()).done){r.next=11;break}if(o=i.value,null==(a=e.get(o))){r.next=9;break}return r.next=9,[o,a];case 9:r.next=3;break;case 11:r.next=16;break;case 13:r.prev=13,r.t0=r.catch(1),n.e(r.t0);case 16:return r.prev=16,n.f(),r.finish(16);case 19:case"end":return r.stop()}}),r,null,[[1,13,16,19]])}))))}var r;return new B_(Cr({},x_,en(r=L_(this._data)).call(r,this._data)))}}]),n}(X_);function rw(t,e){var r=void 0!==Oh&&ic(t)||t["@@iterator"];if(!r){if(Ph(t)||(r=function(t,e){var r;if(!t)return;if("string"==typeof t)return nw(t,e);var n=Ah(r=Object.prototype.toString.call(t)).call(r,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return qs(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return nw(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,i=function(){};return{s:i,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){r=r.call(t)},n:function(){var t=r.next();return a=t.done,t},e:function(t){u=!0,o=t},f:function(){try{a||null==r.return||r.return()}finally{if(u)throw o}}}}function nw(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function iw(t){var e=function(){if("undefined"==typeof Reflect||!Yg)return!1;if(Yg.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Yg(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=Bg(t);if(e){var i=Bg(this).constructor;r=Yg(n,arguments,i)}else r=n.apply(this,arguments);return Hg(this,r)}}var ow=function(t){Vg(n,t);var r=iw(n);function n(t,i){var o,a;return e(this,n),Cr(Gg(a=r.call(this)),"length",0),Cr(Gg(a),"_listener",void 0),Cr(Gg(a),"_data",void 0),Cr(Gg(a),"_ids",new W_),Cr(Gg(a),"_options",void 0),a._options=i||{},a._listener=en(o=a._onEvent).call(o,Gg(a)),a.setData(t),a}return Lr(n,[{key:"idProp",get:function(){return this.getDataSet().idProp}},{key:"setData",value:function(t){if(this._data){this._data.off&&this._data.off("*",this._listener);var e=this._data.getIds({filter:ji(this._options)}),r=this._data.get(e);this._ids.clear(),this.length=0,this._trigger("remove",{items:e,oldData:r})}if(null!=t){this._data=t;for(var n=this._data.getIds({filter:ji(this._options)}),i=0,o=n.length;i<o;i++){var a=n[i];this._ids.add(a)}this.length=n.length,this._trigger("add",{items:n})}else this._data=new ew;this._data.on&&this._data.on("*",this._listener)}},{key:"refresh",value:function(){for(var t=this._data.getIds({filter:ji(this._options)}),e=wh(this._ids),r={},n=[],i=[],o=[],a=0,u=t.length;a<u;a++){var s=t[a];r[s]=!0,this._ids.has(s)||(n.push(s),this._ids.add(s))}for(var c=0,f=e.length;c<f;c++){var l=e[c],h=this._data.get(l);null==h?console.error("If you see this, report it please."):r[l]||(i.push(l),o.push(h),this._ids.delete(l))}this.length+=n.length-i.length,n.length&&this._trigger("add",{items:n}),i.length&&this._trigger("remove",{items:i,oldData:o})}},{key:"get",value:function(t,e){if(null==this._data)return null;var r,n=null;Y_(t)||Ph(t)?(n=t,r=e):r=t;var i=Mp({},this._options,r),o=ji(this._options),a=r&&ji(r);return o&&a&&(i.filter=function(t){return o(t)&&a(t)}),null==n?this._data.get(i):this._data.get(n,i)}},{key:"getIds",value:function(t){if(this._data.length){var e,r=ji(this._options),n=null!=t?ji(t):null;return e=n?r?function(t){return r(t)&&n(t)}:n:r,this._data.getIds({filter:e,order:t&&t.order})}return[]}},{key:"forEach",value:function(t,e){if(this._data){var r,n,i=ji(this._options),o=e&&ji(e);n=o?i?function(t){return i(t)&&o(t)}:o:i,Hh(r=this._data).call(r,t,{filter:n,order:e&&e.order})}}},{key:"map",value:function(t,e){if(this._data){var r,n,i=ji(this._options),o=e&&ji(e);return n=o?i?function(t){return i(t)&&o(t)}:o:i,Ri(r=this._data).call(r,t,{filter:n,order:e&&e.order})}return[]}},{key:"getDataSet",value:function(){return this._data.getDataSet()}},{key:"stream",value:function(t){var e;return this._data.stream(t||Cr({},x_,en(e=Lb(this._ids)).call(e,this._ids)))}},{key:"dispose",value:function(){var t;null!==(t=this._data)&&void 0!==t&&t.off&&this._data.off("*",this._listener);var e,r="This data view has already been disposed of.",i={get:function(){throw new Error(r)},set:function(){throw new Error(r)},configurable:!1},o=rw(jh(n.prototype));try{for(o.s();!(e=o.n()).done;){var a=e.value;El(this,a,i)}}catch(t){o.e(t)}finally{o.f()}}},{key:"_onEvent",value:function(t,e,r){if(e&&e.items&&this._data){var n=e.items,i=[],o=[],a=[],u=[],s=[],c=[];switch(t){case"add":for(var f=0,l=n.length;f<l;f++){var h=n[f];this.get(h)&&(this._ids.add(h),i.push(h))}break;case"update":for(var p=0,v=n.length;p<v;p++){var d=n[p];this.get(d)?this._ids.has(d)?(o.push(d),s.push(e.data[p]),u.push(e.oldData[p])):(this._ids.add(d),i.push(d)):this._ids.has(d)&&(this._ids.delete(d),a.push(d),c.push(e.oldData[p]))}break;case"remove":for(var y=0,g=n.length;y<g;y++){var m=n[y];this._ids.has(m)&&(this._ids.delete(m),a.push(m),c.push(e.oldData[y]))}}this.length+=i.length-a.length,i.length&&this._trigger("add",{items:i},r),o.length&&this._trigger("update",{items:o,oldData:u,data:s},r),a.length&&this._trigger("remove",{items:a,oldData:c},r)}}}]),n}(X_);function aw(t,e){return"object"===_h(e)&&null!==e&&t===e.idProp&&"function"==typeof e.add&&"function"==typeof e.clear&&"function"==typeof e.distinct&&"function"==typeof Hh(e)&&"function"==typeof e.get&&"function"==typeof e.getDataSet&&"function"==typeof e.getIds&&"number"==typeof e.length&&"function"==typeof Ri(e)&&"function"==typeof e.max&&"function"==typeof e.min&&"function"==typeof e.off&&"function"==typeof e.on&&"function"==typeof e.remove&&"function"==typeof e.setOptions&&"function"==typeof e.stream&&"function"==typeof e.update&&"function"==typeof e.updateOnly}t.DELETE=gg,t.DataSet=ew,t.DataStream=B_,t.DataView=ow,t.Queue=G_,t.createNewDataPipeFrom=function(t){return new eo(t)},t.isDataSetLike=aw,t.isDataViewLike=function(t,e){return"object"===_h(e)&&null!==e&&t===e.idProp&&"function"==typeof Hh(e)&&"function"==typeof e.get&&"function"==typeof e.getDataSet&&"function"==typeof e.getIds&&"number"==typeof e.length&&"function"==typeof Ri(e)&&"function"==typeof e.off&&"function"==typeof e.on&&"function"==typeof e.stream&&aw(t,e.getDataSet())},Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=vis-data.min.js.map


/***/ }),

/***/ "./node_modules/vis-network/peer/umd/vis-network.min.js":
/*!**************************************************************!*\
  !*** ./node_modules/vis-network/peer/umd/vis-network.min.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/**
 * vis-network
 * https://visjs.github.io/vis-network/
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 9.0.4
 * @date    2021-03-16T05:41:40.818Z
 *
 * @copyright (c) 2011-2017 Almende B.V, http://almende.com
 * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs
 *
 * @license
 * vis.js is dual licensed under both
 *
 *   1. The Apache 2.0 License
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   and
 *
 *   2. The MIT License
 *      http://opensource.org/licenses/MIT
 *
 * vis.js may be distributed under either license.
 */
!function(t,e){ true?e(exports,__webpack_require__(/*! vis-data/peer/umd/vis-data.js */ "./node_modules/vis-data/peer/umd/vis-data.js")):0}(this,(function(t,e){var i="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self?self:{};function o(t){var e={exports:{}};return t(e,e.exports),e.exports}var n=function(t){return t&&t.Math==Math&&t},r=n("object"==typeof globalThis&&globalThis)||n("object"==typeof window&&window)||n("object"==typeof self&&self)||n("object"==typeof i&&i)||function(){return this}()||Function("return this")(),s=function(t){try{return!!t()}catch(t){return!0}},a=!s((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),h={}.propertyIsEnumerable,d=Object.getOwnPropertyDescriptor,l={f:d&&!h.call({1:2},1)?function(t){var e=d(this,t);return!!e&&e.enumerable}:h},c=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}},u={}.toString,f=function(t){return u.call(t).slice(8,-1)},p="".split,v=s((function(){return!Object("z").propertyIsEnumerable(0)}))?function(t){return"String"==f(t)?p.call(t,""):Object(t)}:Object,g=function(t){if(null==t)throw TypeError("Can't call method on "+t);return t},y=function(t){return v(g(t))},m=function(t){return"object"==typeof t?null!==t:"function"==typeof t},b=function(t,e){if(!m(t))return t;var i,o;if(e&&"function"==typeof(i=t.toString)&&!m(o=i.call(t)))return o;if("function"==typeof(i=t.valueOf)&&!m(o=i.call(t)))return o;if(!e&&"function"==typeof(i=t.toString)&&!m(o=i.call(t)))return o;throw TypeError("Can't convert object to primitive value")},w={}.hasOwnProperty,k=function(t,e){return w.call(t,e)},_=r.document,x=m(_)&&m(_.createElement),E=function(t){return x?_.createElement(t):{}},O=!a&&!s((function(){return 7!=Object.defineProperty(E("div"),"a",{get:function(){return 7}}).a})),C=Object.getOwnPropertyDescriptor,S={f:a?C:function(t,e){if(t=y(t),e=b(e,!0),O)try{return C(t,e)}catch(t){}if(k(t,e))return c(!l.f.call(t,e),t[e])}},T=/#|\.prototype\./,M=function(t,e){var i=D[P(t)];return i==I||i!=B&&("function"==typeof e?s(e):!!e)},P=M.normalize=function(t){return String(t).replace(T,".").toLowerCase()},D=M.data={},B=M.NATIVE="N",I=M.POLYFILL="P",z=M,F={},N=function(t){if("function"!=typeof t)throw TypeError(String(t)+" is not a function");return t},A=function(t,e,i){if(N(t),void 0===e)return t;switch(i){case 0:return function(){return t.call(e)};case 1:return function(i){return t.call(e,i)};case 2:return function(i,o){return t.call(e,i,o)};case 3:return function(i,o,n){return t.call(e,i,o,n)}}return function(){return t.apply(e,arguments)}},R=function(t){if(!m(t))throw TypeError(String(t)+" is not an object");return t},j=Object.defineProperty,L={f:a?j:function(t,e,i){if(R(t),e=b(e,!0),R(i),O)try{return j(t,e,i)}catch(t){}if("get"in i||"set"in i)throw TypeError("Accessors not supported");return"value"in i&&(t[e]=i.value),t}},H=a?function(t,e,i){return L.f(t,e,c(1,i))}:function(t,e,i){return t[e]=i,t},W=S.f,V=function(t){var e=function(e,i,o){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(e);case 2:return new t(e,i)}return new t(e,i,o)}return t.apply(this,arguments)};return e.prototype=t.prototype,e},q=function(t,e){var i,o,n,s,a,h,d,l,c=t.target,u=t.global,f=t.stat,p=t.proto,v=u?r:f?r[c]:(r[c]||{}).prototype,g=u?F:F[c]||(F[c]={}),y=g.prototype;for(n in e)i=!z(u?n:c+(f?".":"#")+n,t.forced)&&v&&k(v,n),a=g[n],i&&(h=t.noTargetGet?(l=W(v,n))&&l.value:v[n]),s=i&&h?h:e[n],i&&typeof a==typeof s||(d=t.bind&&i?A(s,r):t.wrap&&i?V(s):p&&"function"==typeof s?A(Function.call,s):s,(t.sham||s&&s.sham||a&&a.sham)&&H(d,"sham",!0),g[n]=d,p&&(k(F,o=c+"Prototype")||H(F,o,{}),F[o][n]=s,t.real&&y&&!y[n]&&H(y,n,s)))},U=Math.ceil,Y=Math.floor,X=function(t){return isNaN(t=+t)?0:(t>0?Y:U)(t)},G=Math.min,K=function(t){return t>0?G(X(t),9007199254740991):0},$=Math.max,Q=Math.min,Z=function(t,e){var i=X(t);return i<0?$(i+e,0):Q(i,e)},J=function(t){return function(e,i,o){var n,r=y(e),s=K(r.length),a=Z(o,s);if(t&&i!=i){for(;s>a;)if((n=r[a++])!=n)return!0}else for(;s>a;a++)if((t||a in r)&&r[a]===i)return t||a||0;return!t&&-1}},tt={includes:J(!0),indexOf:J(!1)},et={},it=tt.indexOf,ot=function(t,e){var i,o=y(t),n=0,r=[];for(i in o)!k(et,i)&&k(o,i)&&r.push(i);for(;e.length>n;)k(o,i=e[n++])&&(~it(r,i)||r.push(i));return r},nt=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],rt=Object.keys||function(t){return ot(t,nt)},st={f:Object.getOwnPropertySymbols},at=function(t){return Object(g(t))},ht=Object.assign,dt=Object.defineProperty,lt=!ht||s((function(){if(a&&1!==ht({b:1},ht(dt({},"a",{enumerable:!0,get:function(){dt(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var t={},e={},i=Symbol(),o="abcdefghijklmnopqrst";return t[i]=7,o.split("").forEach((function(t){e[t]=t})),7!=ht({},t)[i]||rt(ht({},e)).join("")!=o}))?function(t,e){for(var i=at(t),o=arguments.length,n=1,r=st.f,s=l.f;o>n;)for(var h,d=v(arguments[n++]),c=r?rt(d).concat(r(d)):rt(d),u=c.length,f=0;u>f;)h=c[f++],a&&!s.call(d,h)||(i[h]=d[h]);return i}:ht;q({target:"Object",stat:!0,forced:Object.assign!==lt},{assign:lt});var ct=F.Object.assign,ut=[].slice,ft={},pt=function(t,e,i){if(!(e in ft)){for(var o=[],n=0;n<e;n++)o[n]="a["+n+"]";ft[e]=Function("C,a","return new C("+o.join(",")+")")}return ft[e](t,i)},vt=Function.bind||function(t){var e=N(this),i=ut.call(arguments,1),o=function(){var n=i.concat(ut.call(arguments));return this instanceof o?pt(e,n.length,n):e.apply(t,n)};return m(e.prototype)&&(o.prototype=e.prototype),o};q({target:"Function",proto:!0},{bind:vt});var gt=function(t){return F[t+"Prototype"]},yt=gt("Function").bind,mt=Function.prototype,bt=function(t){var e=t.bind;return t===mt||t instanceof Function&&e===mt.bind?yt:e};function wt(t,e,i,o){t.beginPath(),t.arc(e,i,o,0,2*Math.PI,!1),t.closePath()}function kt(t,e,i,o,n,r){var s=Math.PI/180;o-2*r<0&&(r=o/2),n-2*r<0&&(r=n/2),t.beginPath(),t.moveTo(e+r,i),t.lineTo(e+o-r,i),t.arc(e+o-r,i+r,r,270*s,360*s,!1),t.lineTo(e+o,i+n-r),t.arc(e+o-r,i+n-r,r,0,90*s,!1),t.lineTo(e+r,i+n),t.arc(e+r,i+n-r,r,90*s,180*s,!1),t.lineTo(e,i+r),t.arc(e+r,i+r,r,180*s,270*s,!1),t.closePath()}function _t(t,e,i,o,n){var r=.5522848,s=o/2*r,a=n/2*r,h=e+o,d=i+n,l=e+o/2,c=i+n/2;t.beginPath(),t.moveTo(e,c),t.bezierCurveTo(e,c-a,l-s,i,l,i),t.bezierCurveTo(l+s,i,h,c-a,h,c),t.bezierCurveTo(h,c+a,l+s,d,l,d),t.bezierCurveTo(l-s,d,e,c+a,e,c),t.closePath()}function xt(t,e,i,o,n){var r=n*(1/3),s=.5522848,a=o/2*s,h=r/2*s,d=e+o,l=i+r,c=e+o/2,u=i+r/2,f=i+(n-r/2),p=i+n;t.beginPath(),t.moveTo(d,u),t.bezierCurveTo(d,u+h,c+a,l,c,l),t.bezierCurveTo(c-a,l,e,u+h,e,u),t.bezierCurveTo(e,u-h,c-a,i,c,i),t.bezierCurveTo(c+a,i,d,u-h,d,u),t.lineTo(d,f),t.bezierCurveTo(d,f+h,c+a,p,c,p),t.bezierCurveTo(c-a,p,e,f+h,e,f),t.lineTo(e,u)}function Et(t,e,i,o,n,r){t.beginPath(),t.moveTo(e,i);for(var s=r.length,a=o-e,h=n-i,d=h/a,l=Math.sqrt(a*a+h*h),c=0,u=!0,f=0,p=+r[0];l>=.1;)(p=+r[c++%s])>l&&(p=l),f=Math.sqrt(p*p/(1+d*d)),e+=f=a<0?-f:f,i+=d*f,!0===u?t.lineTo(e,i):t.moveTo(e,i),l-=p,u=!u}var Ot={circle:wt,dashedLine:Et,database:xt,diamond:function(t,e,i,o){t.beginPath(),t.lineTo(e,i+o),t.lineTo(e+o,i),t.lineTo(e,i-o),t.lineTo(e-o,i),t.closePath()},ellipse:_t,ellipse_vis:_t,hexagon:function(t,e,i,o){t.beginPath();var n=2*Math.PI/6;t.moveTo(e+o,i);for(var r=1;r<6;r++)t.lineTo(e+o*Math.cos(n*r),i+o*Math.sin(n*r));t.closePath()},roundRect:kt,square:function(t,e,i,o){t.beginPath(),t.rect(e-o,i-o,2*o,2*o),t.closePath()},star:function(t,e,i,o){t.beginPath(),i+=.1*(o*=.82);for(var n=0;n<10;n++){var r=n%2==0?1.3*o:.5*o;t.lineTo(e+r*Math.sin(2*n*Math.PI/10),i-r*Math.cos(2*n*Math.PI/10))}t.closePath()},triangle:function(t,e,i,o){t.beginPath(),i+=.275*(o*=1.15);var n=2*o,r=n/2,s=Math.sqrt(3)/6*n,a=Math.sqrt(n*n-r*r);t.moveTo(e,i-(a-s)),t.lineTo(e+r,i+s),t.lineTo(e-r,i+s),t.lineTo(e,i-(a-s)),t.closePath()},triangleDown:function(t,e,i,o){t.beginPath(),i-=.275*(o*=1.15);var n=2*o,r=n/2,s=Math.sqrt(3)/6*n,a=Math.sqrt(n*n-r*r);t.moveTo(e,i+(a-s)),t.lineTo(e+r,i-s),t.lineTo(e-r,i-s),t.lineTo(e,i+(a-s)),t.closePath()}};var Ct=o((function(t){function e(t){if(t)return function(t){for(var i in e.prototype)t[i]=e.prototype[i];return t}(t)}t.exports=e,e.prototype.on=e.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},e.prototype.once=function(t,e){function i(){this.off(t,i),e.apply(this,arguments)}return i.fn=e,this.on(t,i),this},e.prototype.off=e.prototype.removeListener=e.prototype.removeAllListeners=e.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var i,o=this._callbacks["$"+t];if(!o)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var n=0;n<o.length;n++)if((i=o[n])===e||i.fn===e){o.splice(n,1);break}return 0===o.length&&delete this._callbacks["$"+t],this},e.prototype.emit=function(t){this._callbacks=this._callbacks||{};for(var e=new Array(arguments.length-1),i=this._callbacks["$"+t],o=1;o<arguments.length;o++)e[o-1]=arguments[o];if(i){o=0;for(var n=(i=i.slice(0)).length;o<n;++o)i[o].apply(this,e)}return this},e.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},e.prototype.hasListeners=function(t){return!!this.listeners(t).length}})),St=function(t){return function(e,i){var o,n,r=String(g(e)),s=X(i),a=r.length;return s<0||s>=a?t?"":void 0:(o=r.charCodeAt(s))<55296||o>56319||s+1===a||(n=r.charCodeAt(s+1))<56320||n>57343?t?r.charAt(s):o:t?r.slice(s,s+2):n-56320+(o-55296<<10)+65536}},Tt={codeAt:St(!1),charAt:St(!0)},Mt="__core-js_shared__",Pt=r[Mt]||function(t,e){try{H(r,t,e)}catch(i){r[t]=e}return e}(Mt,{}),Dt=Function.toString;"function"!=typeof Pt.inspectSource&&(Pt.inspectSource=function(t){return Dt.call(t)});var Bt,It,zt,Ft=Pt.inspectSource,Nt=r.WeakMap,At="function"==typeof Nt&&/native code/.test(Ft(Nt)),Rt=o((function(t){(t.exports=function(t,e){return Pt[t]||(Pt[t]=void 0!==e?e:{})})("versions",[]).push({version:"3.9.1",mode:"pure",copyright:" 2021 Denis Pushkarev (zloirock.ru)"})})),jt=0,Lt=Math.random(),Ht=function(t){return"Symbol("+String(void 0===t?"":t)+")_"+(++jt+Lt).toString(36)},Wt=Rt("keys"),Vt=function(t){return Wt[t]||(Wt[t]=Ht(t))},qt=r.WeakMap;if(At){var Ut=Pt.state||(Pt.state=new qt),Yt=Ut.get,Xt=Ut.has,Gt=Ut.set;Bt=function(t,e){return e.facade=t,Gt.call(Ut,t,e),e},It=function(t){return Yt.call(Ut,t)||{}},zt=function(t){return Xt.call(Ut,t)}}else{var Kt=Vt("state");et[Kt]=!0,Bt=function(t,e){return e.facade=t,H(t,Kt,e),e},It=function(t){return k(t,Kt)?t[Kt]:{}},zt=function(t){return k(t,Kt)}}var $t,Qt,Zt={set:Bt,get:It,has:zt,enforce:function(t){return zt(t)?It(t):Bt(t,{})},getterFor:function(t){return function(e){var i;if(!m(e)||(i=It(e)).type!==t)throw TypeError("Incompatible receiver, "+t+" required");return i}}},Jt=!s((function(){function t(){}return t.prototype.constructor=null,Object.getPrototypeOf(new t)!==t.prototype})),te=Vt("IE_PROTO"),ee=Object.prototype,ie=Jt?Object.getPrototypeOf:function(t){return t=at(t),k(t,te)?t[te]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?ee:null},oe="process"==f(r.process),ne=function(t){return"function"==typeof t?t:void 0},re=function(t,e){return arguments.length<2?ne(F[t])||ne(r[t]):F[t]&&F[t][e]||r[t]&&r[t][e]},se=re("navigator","userAgent")||"",ae=r.process,he=ae&&ae.versions,de=he&&he.v8;de?Qt=($t=de.split("."))[0]+$t[1]:se&&(!($t=se.match(/Edge\/(\d+)/))||$t[1]>=74)&&($t=se.match(/Chrome\/(\d+)/))&&(Qt=$t[1]);var le,ce,ue,fe=Qt&&+Qt,pe=!!Object.getOwnPropertySymbols&&!s((function(){return!Symbol.sham&&(oe?38===fe:fe>37&&fe<41)})),ve=pe&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,ge=Rt("wks"),ye=r.Symbol,me=ve?ye:ye&&ye.withoutSetter||Ht,be=function(t){return k(ge,t)&&(pe||"string"==typeof ge[t])||(pe&&k(ye,t)?ge[t]=ye[t]:ge[t]=me("Symbol."+t)),ge[t]},we=be("iterator"),ke=!1;[].keys&&("next"in(ue=[].keys())?(ce=ie(ie(ue)))!==Object.prototype&&(le=ce):ke=!0);var _e=null==le||s((function(){var t={};return le[we].call(t)!==t}));_e&&(le={}),_e&&!k(le,we)&&H(le,we,(function(){return this}));var xe,Ee={IteratorPrototype:le,BUGGY_SAFARI_ITERATORS:ke},Oe=a?Object.defineProperties:function(t,e){R(t);for(var i,o=rt(e),n=o.length,r=0;n>r;)L.f(t,i=o[r++],e[i]);return t},Ce=re("document","documentElement"),Se=Vt("IE_PROTO"),Te=function(){},Me=function(t){return"<script>"+t+"</"+"script>"},Pe=function(){try{xe=document.domain&&new ActiveXObject("htmlfile")}catch(t){}var t,e;Pe=xe?function(t){t.write(Me("")),t.close();var e=t.parentWindow.Object;return t=null,e}(xe):((e=E("iframe")).style.display="none",Ce.appendChild(e),e.src=String("javascript:"),(t=e.contentWindow.document).open(),t.write(Me("document.F=Object")),t.close(),t.F);for(var i=nt.length;i--;)delete Pe.prototype[nt[i]];return Pe()};et[Se]=!0;var De=Object.create||function(t,e){var i;return null!==t?(Te.prototype=R(t),i=new Te,Te.prototype=null,i[Se]=t):i=Pe(),void 0===e?i:Oe(i,e)},Be={};Be[be("toStringTag")]="z";var Ie="[object z]"===String(Be),ze=be("toStringTag"),Fe="Arguments"==f(function(){return arguments}()),Ne=Ie?f:function(t){var e,i,o;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(i=function(t,e){try{return t[e]}catch(t){}}(e=Object(t),ze))?i:Fe?f(e):"Object"==(o=f(e))&&"function"==typeof e.callee?"Arguments":o},Ae=Ie?{}.toString:function(){return"[object "+Ne(this)+"]"},Re=L.f,je=be("toStringTag"),Le=function(t,e,i,o){if(t){var n=i?t:t.prototype;k(n,je)||Re(n,je,{configurable:!0,value:e}),o&&!Ie&&H(n,"toString",Ae)}},He={},We=Ee.IteratorPrototype,Ve=function(){return this},qe=Object.setPrototypeOf||("__proto__"in{}?function(){var t,e=!1,i={};try{(t=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set).call(i,[]),e=i instanceof Array}catch(t){}return function(i,o){return R(i),function(t){if(!m(t)&&null!==t)throw TypeError("Can't set "+String(t)+" as a prototype")}(o),e?t.call(i,o):i.__proto__=o,i}}():void 0),Ue=function(t,e,i,o){o&&o.enumerable?t[e]=i:H(t,e,i)},Ye=Ee.IteratorPrototype,Xe=Ee.BUGGY_SAFARI_ITERATORS,Ge=be("iterator"),Ke="keys",$e="values",Qe="entries",Ze=function(){return this},Je=function(t,e,i,o,n,r,s){!function(t,e,i){var o=e+" Iterator";t.prototype=De(We,{next:c(1,i)}),Le(t,o,!1,!0),He[o]=Ve}(i,e,o);var a,h,d,l=function(t){if(t===n&&g)return g;if(!Xe&&t in p)return p[t];switch(t){case Ke:case $e:case Qe:return function(){return new i(this,t)}}return function(){return new i(this)}},u=e+" Iterator",f=!1,p=t.prototype,v=p[Ge]||p["@@iterator"]||n&&p[n],g=!Xe&&v||l(n),y="Array"==e&&p.entries||v;if(y&&(a=ie(y.call(new t)),Ye!==Object.prototype&&a.next&&(Le(a,u,!0,!0),He[u]=Ze)),n==$e&&v&&v.name!==$e&&(f=!0,g=function(){return v.call(this)}),s&&p[Ge]!==g&&H(p,Ge,g),He[e]=g,n)if(h={values:l($e),keys:r?g:l(Ke),entries:l(Qe)},s)for(d in h)(Xe||f||!(d in p))&&Ue(p,d,h[d]);else q({target:e,proto:!0,forced:Xe||f},h);return h},ti=Tt.charAt,ei="String Iterator",ii=Zt.set,oi=Zt.getterFor(ei);Je(String,"String",(function(t){ii(this,{type:ei,string:String(t),index:0})}),(function(){var t,e=oi(this),i=e.string,o=e.index;return o>=i.length?{value:void 0,done:!0}:(t=ti(i,o),e.index+=t.length,{value:t,done:!1})}));var ni=function(t){var e=t.return;if(void 0!==e)return R(e.call(t)).value},ri=function(t,e,i,o){try{return o?e(R(i)[0],i[1]):e(i)}catch(e){throw ni(t),e}},si=be("iterator"),ai=Array.prototype,hi=function(t){return void 0!==t&&(He.Array===t||ai[si]===t)},di=function(t,e,i){var o=b(e);o in t?L.f(t,o,c(0,i)):t[o]=i},li=be("iterator"),ci=function(t){if(null!=t)return t[li]||t["@@iterator"]||He[Ne(t)]},ui=be("iterator"),fi=!1;try{var pi=0,vi={next:function(){return{done:!!pi++}},return:function(){fi=!0}};vi[ui]=function(){return this},Array.from(vi,(function(){throw 2}))}catch(t){}var gi=!function(t,e){if(!e&&!fi)return!1;var i=!1;try{var o={};o[ui]=function(){return{next:function(){return{done:i=!0}}}},t(o)}catch(t){}return i}((function(t){Array.from(t)}));q({target:"Array",stat:!0,forced:gi},{from:function(t){var e,i,o,n,r,s,a=at(t),h="function"==typeof this?this:Array,d=arguments.length,l=d>1?arguments[1]:void 0,c=void 0!==l,u=ci(a),f=0;if(c&&(l=A(l,d>2?arguments[2]:void 0,2)),null==u||h==Array&&hi(u))for(i=new h(e=K(a.length));e>f;f++)s=c?l(a[f],f):a[f],di(i,f,s);else for(r=(n=u.call(a)).next,i=new h;!(o=r.call(n)).done;f++)s=c?ri(n,l,[o.value,f],!0):o.value,di(i,f,s);return i.length=f,i}});var yi=F.Array.from,mi=yi,bi="Array Iterator",wi=Zt.set,ki=Zt.getterFor(bi);Je(Array,"Array",(function(t,e){wi(this,{type:bi,target:y(t),index:0,kind:e})}),(function(){var t=ki(this),e=t.target,i=t.kind,o=t.index++;return!e||o>=e.length?(t.target=void 0,{value:void 0,done:!0}):"keys"==i?{value:o,done:!1}:"values"==i?{value:e[o],done:!1}:{value:[o,e[o]],done:!1}}),"values"),He.Arguments=He.Array;var _i=be("toStringTag");for(var xi in{CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}){var Ei=r[xi],Oi=Ei&&Ei.prototype;Oi&&Ne(Oi)!==_i&&H(Oi,_i,xi),He[xi]=He.Array}var Ci=ci,Si=function(t){var e=ci(t);if("function"!=typeof e)throw TypeError(String(t)+" is not iterable");return R(e.call(t))},Ti=Array.isArray||function(t){return"Array"==f(t)},Mi=nt.concat("length","prototype"),Pi={f:Object.getOwnPropertyNames||function(t){return ot(t,Mi)}},Di=Pi.f,Bi={}.toString,Ii="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],zi={f:function(t){return Ii&&"[object Window]"==Bi.call(t)?function(t){try{return Di(t)}catch(t){return Ii.slice()}}(t):Di(y(t))}},Fi={f:be},Ni=L.f,Ai=function(t){var e=F.Symbol||(F.Symbol={});k(e,t)||Ni(e,t,{value:Fi.f(t)})},Ri=be("species"),ji=function(t,e){var i;return Ti(t)&&("function"!=typeof(i=t.constructor)||i!==Array&&!Ti(i.prototype)?m(i)&&null===(i=i[Ri])&&(i=void 0):i=void 0),new(void 0===i?Array:i)(0===e?0:e)},Li=[].push,Hi=function(t){var e=1==t,i=2==t,o=3==t,n=4==t,r=6==t,s=7==t,a=5==t||r;return function(h,d,l,c){for(var u,f,p=at(h),g=v(p),y=A(d,l,3),m=K(g.length),b=0,w=c||ji,k=e?w(h,m):i||s?w(h,0):void 0;m>b;b++)if((a||b in g)&&(f=y(u=g[b],b,p),t))if(e)k[b]=f;else if(f)switch(t){case 3:return!0;case 5:return u;case 6:return b;case 2:Li.call(k,u)}else switch(t){case 4:return!1;case 7:Li.call(k,u)}return r?-1:o||n?n:k}},Wi={forEach:Hi(0),map:Hi(1),filter:Hi(2),some:Hi(3),every:Hi(4),find:Hi(5),findIndex:Hi(6),filterOut:Hi(7)},Vi=Wi.forEach,qi=Vt("hidden"),Ui="Symbol",Yi=be("toPrimitive"),Xi=Zt.set,Gi=Zt.getterFor(Ui),Ki=Object.prototype,$i=r.Symbol,Qi=re("JSON","stringify"),Zi=S.f,Ji=L.f,to=zi.f,eo=l.f,io=Rt("symbols"),oo=Rt("op-symbols"),no=Rt("string-to-symbol-registry"),ro=Rt("symbol-to-string-registry"),so=Rt("wks"),ao=r.QObject,ho=!ao||!ao.prototype||!ao.prototype.findChild,lo=a&&s((function(){return 7!=De(Ji({},"a",{get:function(){return Ji(this,"a",{value:7}).a}})).a}))?function(t,e,i){var o=Zi(Ki,e);o&&delete Ki[e],Ji(t,e,i),o&&t!==Ki&&Ji(Ki,e,o)}:Ji,co=function(t,e){var i=io[t]=De($i.prototype);return Xi(i,{type:Ui,tag:t,description:e}),a||(i.description=e),i},uo=ve?function(t){return"symbol"==typeof t}:function(t){return Object(t)instanceof $i},fo=function(t,e,i){t===Ki&&fo(oo,e,i),R(t);var o=b(e,!0);return R(i),k(io,o)?(i.enumerable?(k(t,qi)&&t[qi][o]&&(t[qi][o]=!1),i=De(i,{enumerable:c(0,!1)})):(k(t,qi)||Ji(t,qi,c(1,{})),t[qi][o]=!0),lo(t,o,i)):Ji(t,o,i)},po=function(t,e){R(t);var i=y(e),o=rt(i).concat(mo(i));return Vi(o,(function(e){a&&!vo.call(i,e)||fo(t,e,i[e])})),t},vo=function(t){var e=b(t,!0),i=eo.call(this,e);return!(this===Ki&&k(io,e)&&!k(oo,e))&&(!(i||!k(this,e)||!k(io,e)||k(this,qi)&&this[qi][e])||i)},go=function(t,e){var i=y(t),o=b(e,!0);if(i!==Ki||!k(io,o)||k(oo,o)){var n=Zi(i,o);return!n||!k(io,o)||k(i,qi)&&i[qi][o]||(n.enumerable=!0),n}},yo=function(t){var e=to(y(t)),i=[];return Vi(e,(function(t){k(io,t)||k(et,t)||i.push(t)})),i},mo=function(t){var e=t===Ki,i=to(e?oo:y(t)),o=[];return Vi(i,(function(t){!k(io,t)||e&&!k(Ki,t)||o.push(io[t])})),o};if(pe||(Ue(($i=function(){if(this instanceof $i)throw TypeError("Symbol is not a constructor");var t=arguments.length&&void 0!==arguments[0]?String(arguments[0]):void 0,e=Ht(t),i=function(t){this===Ki&&i.call(oo,t),k(this,qi)&&k(this[qi],e)&&(this[qi][e]=!1),lo(this,e,c(1,t))};return a&&ho&&lo(Ki,e,{configurable:!0,set:i}),co(e,t)}).prototype,"toString",(function(){return Gi(this).tag})),Ue($i,"withoutSetter",(function(t){return co(Ht(t),t)})),l.f=vo,L.f=fo,S.f=go,Pi.f=zi.f=yo,st.f=mo,Fi.f=function(t){return co(be(t),t)},a&&Ji($i.prototype,"description",{configurable:!0,get:function(){return Gi(this).description}})),q({global:!0,wrap:!0,forced:!pe,sham:!pe},{Symbol:$i}),Vi(rt(so),(function(t){Ai(t)})),q({target:Ui,stat:!0,forced:!pe},{for:function(t){var e=String(t);if(k(no,e))return no[e];var i=$i(e);return no[e]=i,ro[i]=e,i},keyFor:function(t){if(!uo(t))throw TypeError(t+" is not a symbol");if(k(ro,t))return ro[t]},useSetter:function(){ho=!0},useSimple:function(){ho=!1}}),q({target:"Object",stat:!0,forced:!pe,sham:!a},{create:function(t,e){return void 0===e?De(t):po(De(t),e)},defineProperty:fo,defineProperties:po,getOwnPropertyDescriptor:go}),q({target:"Object",stat:!0,forced:!pe},{getOwnPropertyNames:yo,getOwnPropertySymbols:mo}),q({target:"Object",stat:!0,forced:s((function(){st.f(1)}))},{getOwnPropertySymbols:function(t){return st.f(at(t))}}),Qi){var bo=!pe||s((function(){var t=$i();return"[null]"!=Qi([t])||"{}"!=Qi({a:t})||"{}"!=Qi(Object(t))}));q({target:"JSON",stat:!0,forced:bo},{stringify:function(t,e,i){for(var o,n=[t],r=1;arguments.length>r;)n.push(arguments[r++]);if(o=e,(m(e)||void 0!==t)&&!uo(t))return Ti(e)||(e=function(t,e){if("function"==typeof o&&(e=o.call(this,t,e)),!uo(e))return e}),n[1]=e,Qi.apply(null,n)}})}$i.prototype[Yi]||H($i.prototype,Yi,$i.prototype.valueOf),Le($i,Ui),et[qi]=!0;var wo=F.Object.getOwnPropertySymbols,ko=S.f,_o=s((function(){ko(1)}));q({target:"Object",stat:!0,forced:!a||_o,sham:!a},{getOwnPropertyDescriptor:function(t,e){return ko(y(t),e)}});var xo=o((function(t){var e=F.Object,i=t.exports=function(t,i){return e.getOwnPropertyDescriptor(t,i)};e.getOwnPropertyDescriptor.sham&&(i.sham=!0)})),Eo=xo,Oo=re("Reflect","ownKeys")||function(t){var e=Pi.f(R(t)),i=st.f;return i?e.concat(i(t)):e};q({target:"Object",stat:!0,sham:!a},{getOwnPropertyDescriptors:function(t){for(var e,i,o=y(t),n=S.f,r=Oo(o),s={},a=0;r.length>a;)void 0!==(i=n(o,e=r[a++]))&&di(s,e,i);return s}});var Co=F.Object.getOwnPropertyDescriptors;q({target:"Object",stat:!0,forced:!a,sham:!a},{defineProperties:Oe});var So=o((function(t){var e=F.Object,i=t.exports=function(t,i){return e.defineProperties(t,i)};e.defineProperties.sham&&(i.sham=!0)}));q({target:"Object",stat:!0,forced:!a,sham:!a},{defineProperty:L.f});var To=o((function(t){var e=F.Object,i=t.exports=function(t,i,o){return e.defineProperty(t,i,o)};e.defineProperty.sham&&(i.sham=!0)})),Mo=To;function Po(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var Do=To;function Bo(t,e){for(var i=0;i<e.length;i++){var o=e[i];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Do(t,o.key,o)}}function Io(t,e,i){return e&&Bo(t.prototype,e),i&&Bo(t,i),t}function zo(t,e,i){return e in t?Do(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}q({target:"Array",stat:!0},{isArray:Ti});var Fo=F.Array.isArray,No=Fo;var Ao=be("species"),Ro=function(t){return fe>=51||!s((function(){var e=[];return(e.constructor={})[Ao]=function(){return{foo:1}},1!==e[t](Boolean).foo}))},jo=be("isConcatSpreadable"),Lo=9007199254740991,Ho="Maximum allowed index exceeded",Wo=fe>=51||!s((function(){var t=[];return t[jo]=!1,t.concat()[0]!==t})),Vo=Ro("concat"),qo=function(t){if(!m(t))return!1;var e=t[jo];return void 0!==e?!!e:Ti(t)};q({target:"Array",proto:!0,forced:!Wo||!Vo},{concat:function(t){var e,i,o,n,r,s=at(this),a=ji(s,0),h=0;for(e=-1,o=arguments.length;e<o;e++)if(qo(r=-1===e?s:arguments[e])){if(h+(n=K(r.length))>Lo)throw TypeError(Ho);for(i=0;i<n;i++,h++)i in r&&di(a,h,r[i])}else{if(h>=Lo)throw TypeError(Ho);di(a,h++,r)}return a.length=h,a}}),Ai("asyncIterator"),Ai("hasInstance"),Ai("isConcatSpreadable"),Ai("iterator"),Ai("match"),Ai("matchAll"),Ai("replace"),Ai("search"),Ai("species"),Ai("split"),Ai("toPrimitive"),Ai("toStringTag"),Ai("unscopables"),Le(r.JSON,"JSON",!0);var Uo=F.Symbol;Ai("asyncDispose"),Ai("dispose"),Ai("observable"),Ai("patternMatch"),Ai("replaceAll");var Yo=Uo,Xo=be("iterator"),Go=function(t){var e=Object(t);return void 0!==e[Xo]||"@@iterator"in e||He.hasOwnProperty(Ne(e))};var Ko=Ro("slice"),$o=be("species"),Qo=[].slice,Zo=Math.max;q({target:"Array",proto:!0,forced:!Ko},{slice:function(t,e){var i,o,n,r=y(this),s=K(r.length),a=Z(t,s),h=Z(void 0===e?s:e,s);if(Ti(r)&&("function"!=typeof(i=r.constructor)||i!==Array&&!Ti(i.prototype)?m(i)&&null===(i=i[$o])&&(i=void 0):i=void 0,i===Array||void 0===i))return Qo.call(r,a,h);for(o=new(void 0===i?Array:i)(Zo(h-a,0)),n=0;a<h;a++,n++)a in r&&di(o,n,r[a]);return o.length=n,o}});var Jo=gt("Array").slice,tn=Array.prototype,en=function(t){var e=t.slice;return t===tn||t instanceof Array&&e===tn.slice?Jo:e},on=en,nn=yi;function rn(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}function sn(t,e){var i;if(t){if("string"==typeof t)return rn(t,e);var o=on(i=Object.prototype.toString.call(t)).call(i,8,-1);return"Object"===o&&t.constructor&&(o=t.constructor.name),"Map"===o||"Set"===o?nn(t):"Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)?rn(t,e):void 0}}function an(t,e){return function(t){if(No(t))return t}(t)||function(t,e){if(void 0!==Yo&&Go(Object(t))){var i=[],o=!0,n=!1,r=void 0;try{for(var s,a=Si(t);!(o=(s=a.next()).done)&&(i.push(s.value),!e||i.length!==e);o=!0);}catch(t){n=!0,r=t}finally{try{o||null==a.return||a.return()}finally{if(n)throw r}}return i}}(t,e)||sn(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var hn=Fi.f("iterator");function dn(t){return(dn="function"==typeof Yo&&"symbol"==typeof hn?function(t){return typeof t}:function(t){return t&&"function"==typeof Yo&&t.constructor===Yo&&t!==Yo.prototype?"symbol":typeof t})(t)}function ln(t){return function(t){if(No(t))return rn(t)}(t)||function(t){if(void 0!==Yo&&Go(Object(t)))return nn(t)}(t)||sn(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var cn=Uo,un=gt("Array").concat,fn=Array.prototype,pn=function(t){var e=t.concat;return t===fn||t instanceof Array&&e===fn.concat?un:e},vn=en;q({target:"Reflect",stat:!0},{ownKeys:Oo}),F.Reflect.ownKeys;var gn=Fo,yn=Wi.map,mn=Ro("map");q({target:"Array",proto:!0,forced:!mn},{map:function(t){return yn(this,t,arguments.length>1?arguments[1]:void 0)}});var bn=gt("Array").map,wn=Array.prototype,kn=function(t){var e=t.map;return t===wn||t instanceof Array&&e===wn.map?bn:e},_n=s((function(){rt(1)}));q({target:"Object",stat:!0,forced:_n},{keys:function(t){return rt(at(t))}});var xn=F.Object.keys;q({target:"Date",stat:!0},{now:function(){return(new Date).getTime()}});var En=F.Date.now,On=function(t,e){var i=[][t];return!!i&&s((function(){i.call(null,e||function(){throw 1},1)}))},Cn=Wi.forEach,Sn=On("forEach")?[].forEach:function(t){return Cn(this,t,arguments.length>1?arguments[1]:void 0)};q({target:"Array",proto:!0,forced:[].forEach!=Sn},{forEach:Sn});var Tn=gt("Array").forEach,Mn=Array.prototype,Pn={DOMTokenList:!0,NodeList:!0},Dn=function(t){var e=t.forEach;return t===Mn||t instanceof Array&&e===Mn.forEach||Pn.hasOwnProperty(Ne(t))?Tn:e},Bn=[].reverse,In=[1,2];q({target:"Array",proto:!0,forced:String(In)===String(In.reverse())},{reverse:function(){return Ti(this)&&(this.length=this.length),Bn.call(this)}});var zn=gt("Array").reverse,Fn=Array.prototype,Nn=function(t){var e=t.reverse;return t===Fn||t instanceof Array&&e===Fn.reverse?zn:e},An=Ro("splice"),Rn=Math.max,jn=Math.min,Ln=9007199254740991,Hn="Maximum allowed length exceeded";q({target:"Array",proto:!0,forced:!An},{splice:function(t,e){var i,o,n,r,s,a,h=at(this),d=K(h.length),l=Z(t,d),c=arguments.length;if(0===c?i=o=0:1===c?(i=0,o=d-l):(i=c-2,o=jn(Rn(X(e),0),d-l)),d+i-o>Ln)throw TypeError(Hn);for(n=ji(h,o),r=0;r<o;r++)(s=l+r)in h&&di(n,r,h[s]);if(n.length=o,i<o){for(r=l;r<d-o;r++)a=r+i,(s=r+o)in h?h[a]=h[s]:delete h[a];for(r=d;r>d-o+i;r--)delete h[r-1]}else if(i>o)for(r=d-o;r>l;r--)a=r+i-1,(s=r+o-1)in h?h[a]=h[s]:delete h[a];for(r=0;r<i;r++)h[r+l]=arguments[r+2];return h.length=d-o+i,n}});var Wn=gt("Array").splice,Vn=Array.prototype,qn=function(t){var e=t.splice;return t===Vn||t instanceof Array&&e===Vn.splice?Wn:e},Un=tt.includes;q({target:"Array",proto:!0},{includes:function(t){return Un(this,t,arguments.length>1?arguments[1]:void 0)}});var Yn=gt("Array").includes,Xn=be("match"),Gn=function(t){if(function(t){var e;return m(t)&&(void 0!==(e=t[Xn])?!!e:"RegExp"==f(t))}(t))throw TypeError("The method doesn't accept regular expressions");return t},Kn=be("match");q({target:"String",proto:!0,forced:!function(t){var e=/./;try{"/./"[t](e)}catch(i){try{return e[Kn]=!1,"/./"[t](e)}catch(t){}}return!1}("includes")},{includes:function(t){return!!~String(g(this)).indexOf(Gn(t),arguments.length>1?arguments[1]:void 0)}});var $n=gt("String").includes,Qn=Array.prototype,Zn=String.prototype,Jn=function(t){var e=t.includes;return t===Qn||t instanceof Array&&e===Qn.includes?Yn:"string"==typeof t||t===Zn||t instanceof String&&e===Zn.includes?$n:e},tr=s((function(){ie(1)}));q({target:"Object",stat:!0,forced:tr,sham:!Jt},{getPrototypeOf:function(t){return ie(at(t))}});var er=F.Object.getPrototypeOf,ir=er,or=Wi.filter,nr=Ro("filter");q({target:"Array",proto:!0,forced:!nr},{filter:function(t){return or(this,t,arguments.length>1?arguments[1]:void 0)}});var rr=gt("Array").filter,sr=Array.prototype,ar=function(t){var e=t.filter;return t===sr||t instanceof Array&&e===sr.filter?rr:e},hr=l.f,dr=function(t){return function(e){for(var i,o=y(e),n=rt(o),r=n.length,s=0,h=[];r>s;)i=n[s++],a&&!hr.call(o,i)||h.push(t?[i,o[i]]:o[i]);return h}},lr={entries:dr(!0),values:dr(!1)}.values;q({target:"Object",stat:!0},{values:function(t){return lr(t)}}),F.Object.values;var cr="\t\n\v\f\r \u2028\u2029\ufeff",ur="["+cr+"]",fr=RegExp("^"+ur+ur+"*"),pr=RegExp(ur+ur+"*$"),vr=function(t){return function(e){var i=String(g(e));return 1&t&&(i=i.replace(fr,"")),2&t&&(i=i.replace(pr,"")),i}},gr={start:vr(1),end:vr(2),trim:vr(3)},yr=gr.trim,mr=r.parseInt,br=/^[+-]?0[Xx]/,wr=8!==mr(cr+"08")||22!==mr(cr+"0x16")?function(t,e){var i=yr(String(t));return mr(i,e>>>0||(br.test(i)?16:10))}:mr;q({global:!0,forced:parseInt!=wr},{parseInt:wr});var kr=F.parseInt,_r=tt.indexOf,xr=[].indexOf,Er=!!xr&&1/[1].indexOf(1,-0)<0,Or=On("indexOf");q({target:"Array",proto:!0,forced:Er||!Or},{indexOf:function(t){return Er?xr.apply(this,arguments)||0:_r(this,t,arguments.length>1?arguments[1]:void 0)}});var Cr,Sr=gt("Array").indexOf,Tr=Array.prototype,Mr=function(t){var e=t.indexOf;return t===Tr||t instanceof Array&&e===Tr.indexOf?Sr:e},Pr=gr.trim;q({target:"String",proto:!0,forced:(Cr="trim",s((function(){return!!cr[Cr]()||""!=""[Cr]()||cr[Cr].name!==Cr})))},{trim:function(){return Pr(this)}}),gt("String").trim,q({target:"Object",stat:!0,sham:!a},{create:De});var Dr=F.Object,Br=function(t,e){return Dr.create(t,e)},Ir=Br,zr=re("JSON","stringify"),Fr=/[\uD800-\uDFFF]/g,Nr=/^[\uD800-\uDBFF]$/,Ar=/^[\uDC00-\uDFFF]$/,Rr=function(t,e,i){var o=i.charAt(e-1),n=i.charAt(e+1);return Nr.test(t)&&!Ar.test(n)||Ar.test(t)&&!Nr.test(o)?"\\u"+t.charCodeAt(0).toString(16):t},jr=s((function(){return'"\\udf06\\ud834"'!==zr("\udf06\ud834")||'"\\udead"'!==zr("\udead")}));zr&&q({target:"JSON",stat:!0,forced:jr},{stringify:function(t,e,i){var o=zr.apply(null,arguments);return"string"==typeof o?o.replace(Fr,Rr):o}}),F.JSON||(F.JSON={stringify:JSON.stringify});var Lr=function(t,e,i){return F.JSON.stringify.apply(null,arguments)},Hr=[].slice,Wr=/MSIE .\./.test(se),Vr=function(t){return function(e,i){var o=arguments.length>2,n=o?Hr.call(arguments,2):void 0;return t(o?function(){("function"==typeof e?e:Function(e)).apply(this,n)}:e,i)}};q({global:!0,bind:!0,forced:Wr},{setTimeout:Vr(r.setTimeout),setInterval:Vr(r.setInterval)});var qr=F.setTimeout;q({target:"Array",proto:!0},{fill:function(t){for(var e=at(this),i=K(e.length),o=arguments.length,n=Z(o>1?arguments[1]:void 0,i),r=o>2?arguments[2]:void 0,s=void 0===r?i:Z(r,i);s>n;)e[n++]=t;return e}});var Ur=gt("Array").fill,Yr=Array.prototype,Xr=function(t){var e=t.fill;return t===Yr||t instanceof Array&&e===Yr.fill?Ur:e};
/*! Hammer.JS - v2.0.17-rc - 2019-12-16
	 * http://naver.github.io/egjs
	 *
	 * Forked By Naver egjs
	 * Copyright (c) hammerjs
	 * Licensed under the MIT license */
function Gr(){return(Gr=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var o in i)Object.prototype.hasOwnProperty.call(i,o)&&(t[o]=i[o])}return t}).apply(this,arguments)}function Kr(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t.__proto__=e}function $r(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}var Qr,Zr="function"!=typeof Object.assign?function(t){if(null==t)throw new TypeError("Cannot convert undefined or null to object");for(var e=Object(t),i=1;i<arguments.length;i++){var o=arguments[i];if(null!=o)for(var n in o)o.hasOwnProperty(n)&&(e[n]=o[n])}return e}:Object.assign,Jr=["","webkit","Moz","MS","ms","o"],ts="undefined"==typeof document?{style:{}}:document.createElement("div"),es=Math.round,is=Math.abs,os=Date.now;function ns(t,e){for(var i,o,n=e[0].toUpperCase()+e.slice(1),r=0;r<Jr.length;){if((o=(i=Jr[r])?i+n:e)in t)return o;r++}}Qr="undefined"==typeof window?{}:window;var rs=ns(ts.style,"touchAction"),ss=void 0!==rs;var as="compute",hs="auto",ds="manipulation",ls="none",cs="pan-x",us="pan-y",fs=function(){if(!ss)return!1;var t={},e=Qr.CSS&&Qr.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach((function(i){return t[i]=!e||Qr.CSS.supports("touch-action",i)})),t}(),ps="ontouchstart"in Qr,vs=void 0!==ns(Qr,"PointerEvent"),gs=ps&&/mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent),ys="touch",ms="mouse",bs=16,ws=24,ks=["x","y"],_s=["clientX","clientY"];function xs(t,e,i){var o;if(t)if(t.forEach)t.forEach(e,i);else if(void 0!==t.length)for(o=0;o<t.length;)e.call(i,t[o],o,t),o++;else for(o in t)t.hasOwnProperty(o)&&e.call(i,t[o],o,t)}function Es(t,e){return"function"==typeof t?t.apply(e&&e[0]||void 0,e):t}function Os(t,e){return t.indexOf(e)>-1}var Cs=function(){function t(t,e){this.manager=t,this.set(e)}var e=t.prototype;return e.set=function(t){t===as&&(t=this.compute()),ss&&this.manager.element.style&&fs[t]&&(this.manager.element.style[rs]=t),this.actions=t.toLowerCase().trim()},e.update=function(){this.set(this.manager.options.touchAction)},e.compute=function(){var t=[];return xs(this.manager.recognizers,(function(e){Es(e.options.enable,[e])&&(t=t.concat(e.getTouchAction()))})),function(t){if(Os(t,ls))return ls;var e=Os(t,cs),i=Os(t,us);return e&&i?ls:e||i?e?cs:us:Os(t,ds)?ds:hs}(t.join(" "))},e.preventDefaults=function(t){var e=t.srcEvent,i=t.offsetDirection;if(this.manager.session.prevented)e.preventDefault();else{var o=this.actions,n=Os(o,ls)&&!fs.none,r=Os(o,us)&&!fs["pan-y"],s=Os(o,cs)&&!fs["pan-x"];if(n){var a=1===t.pointers.length,h=t.distance<2,d=t.deltaTime<250;if(a&&h&&d)return}if(!s||!r)return n||r&&6&i||s&&i&ws?this.preventSrc(e):void 0}},e.preventSrc=function(t){this.manager.session.prevented=!0,t.preventDefault()},t}();function Ss(t,e){for(;t;){if(t===e)return!0;t=t.parentNode}return!1}function Ts(t){var e=t.length;if(1===e)return{x:es(t[0].clientX),y:es(t[0].clientY)};for(var i=0,o=0,n=0;n<e;)i+=t[n].clientX,o+=t[n].clientY,n++;return{x:es(i/e),y:es(o/e)}}function Ms(t){for(var e=[],i=0;i<t.pointers.length;)e[i]={clientX:es(t.pointers[i].clientX),clientY:es(t.pointers[i].clientY)},i++;return{timeStamp:os(),pointers:e,center:Ts(e),deltaX:t.deltaX,deltaY:t.deltaY}}function Ps(t,e,i){i||(i=ks);var o=e[i[0]]-t[i[0]],n=e[i[1]]-t[i[1]];return Math.sqrt(o*o+n*n)}function Ds(t,e,i){i||(i=ks);var o=e[i[0]]-t[i[0]],n=e[i[1]]-t[i[1]];return 180*Math.atan2(n,o)/Math.PI}function Bs(t,e){return t===e?1:is(t)>=is(e)?t<0?2:4:e<0?8:bs}function Is(t,e,i){return{x:e/t||0,y:i/t||0}}function zs(t,e){var i=t.session,o=e.pointers,n=o.length;i.firstInput||(i.firstInput=Ms(e)),n>1&&!i.firstMultiple?i.firstMultiple=Ms(e):1===n&&(i.firstMultiple=!1);var r=i.firstInput,s=i.firstMultiple,a=s?s.center:r.center,h=e.center=Ts(o);e.timeStamp=os(),e.deltaTime=e.timeStamp-r.timeStamp,e.angle=Ds(a,h),e.distance=Ps(a,h),function(t,e){var i=e.center,o=t.offsetDelta||{},n=t.prevDelta||{},r=t.prevInput||{};1!==e.eventType&&4!==r.eventType||(n=t.prevDelta={x:r.deltaX||0,y:r.deltaY||0},o=t.offsetDelta={x:i.x,y:i.y}),e.deltaX=n.x+(i.x-o.x),e.deltaY=n.y+(i.y-o.y)}(i,e),e.offsetDirection=Bs(e.deltaX,e.deltaY);var d,l,c=Is(e.deltaTime,e.deltaX,e.deltaY);e.overallVelocityX=c.x,e.overallVelocityY=c.y,e.overallVelocity=is(c.x)>is(c.y)?c.x:c.y,e.scale=s?(d=s.pointers,Ps((l=o)[0],l[1],_s)/Ps(d[0],d[1],_s)):1,e.rotation=s?function(t,e){return Ds(e[1],e[0],_s)+Ds(t[1],t[0],_s)}(s.pointers,o):0,e.maxPointers=i.prevInput?e.pointers.length>i.prevInput.maxPointers?e.pointers.length:i.prevInput.maxPointers:e.pointers.length,function(t,e){var i,o,n,r,s=t.lastInterval||e,a=e.timeStamp-s.timeStamp;if(8!==e.eventType&&(a>25||void 0===s.velocity)){var h=e.deltaX-s.deltaX,d=e.deltaY-s.deltaY,l=Is(a,h,d);o=l.x,n=l.y,i=is(l.x)>is(l.y)?l.x:l.y,r=Bs(h,d),t.lastInterval=e}else i=s.velocity,o=s.velocityX,n=s.velocityY,r=s.direction;e.velocity=i,e.velocityX=o,e.velocityY=n,e.direction=r}(i,e);var u,f=t.element,p=e.srcEvent;Ss(u=p.composedPath?p.composedPath()[0]:p.path?p.path[0]:p.target,f)&&(f=u),e.target=f}function Fs(t,e,i){var o=i.pointers.length,n=i.changedPointers.length,r=1&e&&o-n==0,s=12&e&&o-n==0;i.isFirst=!!r,i.isFinal=!!s,r&&(t.session={}),i.eventType=e,zs(t,i),t.emit("hammer.input",i),t.recognize(i),t.session.prevInput=i}function Ns(t){return t.trim().split(/\s+/g)}function As(t,e,i){xs(Ns(e),(function(e){t.addEventListener(e,i,!1)}))}function Rs(t,e,i){xs(Ns(e),(function(e){t.removeEventListener(e,i,!1)}))}function js(t){var e=t.ownerDocument||t;return e.defaultView||e.parentWindow||window}var Ls=function(){function t(t,e){var i=this;this.manager=t,this.callback=e,this.element=t.element,this.target=t.options.inputTarget,this.domHandler=function(e){Es(t.options.enable,[t])&&i.handler(e)},this.init()}var e=t.prototype;return e.handler=function(){},e.init=function(){this.evEl&&As(this.element,this.evEl,this.domHandler),this.evTarget&&As(this.target,this.evTarget,this.domHandler),this.evWin&&As(js(this.element),this.evWin,this.domHandler)},e.destroy=function(){this.evEl&&Rs(this.element,this.evEl,this.domHandler),this.evTarget&&Rs(this.target,this.evTarget,this.domHandler),this.evWin&&Rs(js(this.element),this.evWin,this.domHandler)},t}();function Hs(t,e,i){if(t.indexOf&&!i)return t.indexOf(e);for(var o=0;o<t.length;){if(i&&t[o][i]==e||!i&&t[o]===e)return o;o++}return-1}var Ws={pointerdown:1,pointermove:2,pointerup:4,pointercancel:8,pointerout:8},Vs={2:ys,3:"pen",4:ms,5:"kinect"},qs="pointerdown",Us="pointermove pointerup pointercancel";Qr.MSPointerEvent&&!Qr.PointerEvent&&(qs="MSPointerDown",Us="MSPointerMove MSPointerUp MSPointerCancel");var Ys=function(t){function e(){var i,o=e.prototype;return o.evEl=qs,o.evWin=Us,(i=t.apply(this,arguments)||this).store=i.manager.session.pointerEvents=[],i}return Kr(e,t),e.prototype.handler=function(t){var e=this.store,i=!1,o=t.type.toLowerCase().replace("ms",""),n=Ws[o],r=Vs[t.pointerType]||t.pointerType,s=r===ys,a=Hs(e,t.pointerId,"pointerId");1&n&&(0===t.button||s)?a<0&&(e.push(t),a=e.length-1):12&n&&(i=!0),a<0||(e[a]=t,this.callback(this.manager,n,{pointers:e,changedPointers:[t],pointerType:r,srcEvent:t}),i&&e.splice(a,1))},e}(Ls);function Xs(t){return Array.prototype.slice.call(t,0)}function Gs(t,e,i){for(var o=[],n=[],r=0;r<t.length;){var s=e?t[r][e]:t[r];Hs(n,s)<0&&o.push(t[r]),n[r]=s,r++}return i&&(o=e?o.sort((function(t,i){return t[e]>i[e]})):o.sort()),o}var Ks={touchstart:1,touchmove:2,touchend:4,touchcancel:8},$s="touchstart touchmove touchend touchcancel",Qs=function(t){function e(){var i;return e.prototype.evTarget=$s,(i=t.apply(this,arguments)||this).targetIds={},i}return Kr(e,t),e.prototype.handler=function(t){var e=Ks[t.type],i=Zs.call(this,t,e);i&&this.callback(this.manager,e,{pointers:i[0],changedPointers:i[1],pointerType:ys,srcEvent:t})},e}(Ls);function Zs(t,e){var i,o,n=Xs(t.touches),r=this.targetIds;if(3&e&&1===n.length)return r[n[0].identifier]=!0,[n,n];var s=Xs(t.changedTouches),a=[],h=this.target;if(o=n.filter((function(t){return Ss(t.target,h)})),1===e)for(i=0;i<o.length;)r[o[i].identifier]=!0,i++;for(i=0;i<s.length;)r[s[i].identifier]&&a.push(s[i]),12&e&&delete r[s[i].identifier],i++;return a.length?[Gs(o.concat(a),"identifier",!0),a]:void 0}var Js={mousedown:1,mousemove:2,mouseup:4},ta="mousedown",ea="mousemove mouseup",ia=function(t){function e(){var i,o=e.prototype;return o.evEl=ta,o.evWin=ea,(i=t.apply(this,arguments)||this).pressed=!1,i}return Kr(e,t),e.prototype.handler=function(t){var e=Js[t.type];1&e&&0===t.button&&(this.pressed=!0),2&e&&1!==t.which&&(e=4),this.pressed&&(4&e&&(this.pressed=!1),this.callback(this.manager,e,{pointers:[t],changedPointers:[t],pointerType:ms,srcEvent:t}))},e}(Ls);function oa(t){var e=t.changedPointers[0];if(e.identifier===this.primaryTouch){var i={x:e.clientX,y:e.clientY},o=this.lastTouches;this.lastTouches.push(i);setTimeout((function(){var t=o.indexOf(i);t>-1&&o.splice(t,1)}),2500)}}function na(t,e){1&t?(this.primaryTouch=e.changedPointers[0].identifier,oa.call(this,e)):12&t&&oa.call(this,e)}function ra(t){for(var e=t.srcEvent.clientX,i=t.srcEvent.clientY,o=0;o<this.lastTouches.length;o++){var n=this.lastTouches[o],r=Math.abs(e-n.x),s=Math.abs(i-n.y);if(r<=25&&s<=25)return!0}return!1}var sa=function(){return function(t){function e(e,i){var o;return(o=t.call(this,e,i)||this).handler=function(t,e,i){var n=i.pointerType===ys,r=i.pointerType===ms;if(!(r&&i.sourceCapabilities&&i.sourceCapabilities.firesTouchEvents)){if(n)na.call($r($r(o)),e,i);else if(r&&ra.call($r($r(o)),i))return;o.callback(t,e,i)}},o.touch=new Qs(o.manager,o.handler),o.mouse=new ia(o.manager,o.handler),o.primaryTouch=null,o.lastTouches=[],o}return Kr(e,t),e.prototype.destroy=function(){this.touch.destroy(),this.mouse.destroy()},e}(Ls)}();function aa(t,e,i){return!!Array.isArray(t)&&(xs(t,i[e],i),!0)}var ha=32,da=1;function la(t,e){var i=e.manager;return i?i.get(t):t}function ca(t){return 16&t?"cancel":8&t?"end":4&t?"move":2&t?"start":""}var ua=function(){function t(t){void 0===t&&(t={}),this.options=Gr({enable:!0},t),this.id=da++,this.manager=null,this.state=1,this.simultaneous={},this.requireFail=[]}var e=t.prototype;return e.set=function(t){return Zr(this.options,t),this.manager&&this.manager.touchAction.update(),this},e.recognizeWith=function(t){if(aa(t,"recognizeWith",this))return this;var e=this.simultaneous;return e[(t=la(t,this)).id]||(e[t.id]=t,t.recognizeWith(this)),this},e.dropRecognizeWith=function(t){return aa(t,"dropRecognizeWith",this)||(t=la(t,this),delete this.simultaneous[t.id]),this},e.requireFailure=function(t){if(aa(t,"requireFailure",this))return this;var e=this.requireFail;return-1===Hs(e,t=la(t,this))&&(e.push(t),t.requireFailure(this)),this},e.dropRequireFailure=function(t){if(aa(t,"dropRequireFailure",this))return this;t=la(t,this);var e=Hs(this.requireFail,t);return e>-1&&this.requireFail.splice(e,1),this},e.hasRequireFailures=function(){return this.requireFail.length>0},e.canRecognizeWith=function(t){return!!this.simultaneous[t.id]},e.emit=function(t){var e=this,i=this.state;function o(i){e.manager.emit(i,t)}i<8&&o(e.options.event+ca(i)),o(e.options.event),t.additionalEvent&&o(t.additionalEvent),i>=8&&o(e.options.event+ca(i))},e.tryEmit=function(t){if(this.canEmit())return this.emit(t);this.state=ha},e.canEmit=function(){for(var t=0;t<this.requireFail.length;){if(!(33&this.requireFail[t].state))return!1;t++}return!0},e.recognize=function(t){var e=Zr({},t);if(!Es(this.options.enable,[this,e]))return this.reset(),void(this.state=ha);56&this.state&&(this.state=1),this.state=this.process(e),30&this.state&&this.tryEmit(e)},e.process=function(t){},e.getTouchAction=function(){},e.reset=function(){},t}(),fa=function(t){function e(e){var i;return void 0===e&&(e={}),(i=t.call(this,Gr({event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},e))||this).pTime=!1,i.pCenter=!1,i._timer=null,i._input=null,i.count=0,i}Kr(e,t);var i=e.prototype;return i.getTouchAction=function(){return[ds]},i.process=function(t){var e=this,i=this.options,o=t.pointers.length===i.pointers,n=t.distance<i.threshold,r=t.deltaTime<i.time;if(this.reset(),1&t.eventType&&0===this.count)return this.failTimeout();if(n&&r&&o){if(4!==t.eventType)return this.failTimeout();var s=!this.pTime||t.timeStamp-this.pTime<i.interval,a=!this.pCenter||Ps(this.pCenter,t.center)<i.posThreshold;if(this.pTime=t.timeStamp,this.pCenter=t.center,a&&s?this.count+=1:this.count=1,this._input=t,0===this.count%i.taps)return this.hasRequireFailures()?(this._timer=setTimeout((function(){e.state=8,e.tryEmit()}),i.interval),2):8}return ha},i.failTimeout=function(){var t=this;return this._timer=setTimeout((function(){t.state=ha}),this.options.interval),ha},i.reset=function(){clearTimeout(this._timer)},i.emit=function(){8===this.state&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))},e}(ua),pa=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Gr({pointers:1},e))||this}Kr(e,t);var i=e.prototype;return i.attrTest=function(t){var e=this.options.pointers;return 0===e||t.pointers.length===e},i.process=function(t){var e=this.state,i=t.eventType,o=6&e,n=this.attrTest(t);return o&&(8&i||!n)?16|e:o||n?4&i?8|e:2&e?4|e:2:ha},e}(ua);function va(t){return t===bs?"down":8===t?"up":2===t?"left":4===t?"right":""}var ga=function(t){function e(e){var i;return void 0===e&&(e={}),(i=t.call(this,Gr({event:"pan",threshold:10,pointers:1,direction:30},e))||this).pX=null,i.pY=null,i}Kr(e,t);var i=e.prototype;return i.getTouchAction=function(){var t=this.options.direction,e=[];return 6&t&&e.push(us),t&ws&&e.push(cs),e},i.directionTest=function(t){var e=this.options,i=!0,o=t.distance,n=t.direction,r=t.deltaX,s=t.deltaY;return n&e.direction||(6&e.direction?(n=0===r?1:r<0?2:4,i=r!==this.pX,o=Math.abs(t.deltaX)):(n=0===s?1:s<0?8:bs,i=s!==this.pY,o=Math.abs(t.deltaY))),t.direction=n,i&&o>e.threshold&&n&e.direction},i.attrTest=function(t){return pa.prototype.attrTest.call(this,t)&&(2&this.state||!(2&this.state)&&this.directionTest(t))},i.emit=function(e){this.pX=e.deltaX,this.pY=e.deltaY;var i=va(e.direction);i&&(e.additionalEvent=this.options.event+i),t.prototype.emit.call(this,e)},e}(pa),ya=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Gr({event:"swipe",threshold:10,velocity:.3,direction:30,pointers:1},e))||this}Kr(e,t);var i=e.prototype;return i.getTouchAction=function(){return ga.prototype.getTouchAction.call(this)},i.attrTest=function(e){var i,o=this.options.direction;return 30&o?i=e.overallVelocity:6&o?i=e.overallVelocityX:o&ws&&(i=e.overallVelocityY),t.prototype.attrTest.call(this,e)&&o&e.offsetDirection&&e.distance>this.options.threshold&&e.maxPointers===this.options.pointers&&is(i)>this.options.velocity&&4&e.eventType},i.emit=function(t){var e=va(t.offsetDirection);e&&this.manager.emit(this.options.event+e,t),this.manager.emit(this.options.event,t)},e}(pa),ma=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Gr({event:"pinch",threshold:0,pointers:2},e))||this}Kr(e,t);var i=e.prototype;return i.getTouchAction=function(){return[ls]},i.attrTest=function(e){return t.prototype.attrTest.call(this,e)&&(Math.abs(e.scale-1)>this.options.threshold||2&this.state)},i.emit=function(e){if(1!==e.scale){var i=e.scale<1?"in":"out";e.additionalEvent=this.options.event+i}t.prototype.emit.call(this,e)},e}(pa),ba=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Gr({event:"rotate",threshold:0,pointers:2},e))||this}Kr(e,t);var i=e.prototype;return i.getTouchAction=function(){return[ls]},i.attrTest=function(e){return t.prototype.attrTest.call(this,e)&&(Math.abs(e.rotation)>this.options.threshold||2&this.state)},e}(pa),wa=function(t){function e(e){var i;return void 0===e&&(e={}),(i=t.call(this,Gr({event:"press",pointers:1,time:251,threshold:9},e))||this)._timer=null,i._input=null,i}Kr(e,t);var i=e.prototype;return i.getTouchAction=function(){return[hs]},i.process=function(t){var e=this,i=this.options,o=t.pointers.length===i.pointers,n=t.distance<i.threshold,r=t.deltaTime>i.time;if(this._input=t,!n||!o||12&t.eventType&&!r)this.reset();else if(1&t.eventType)this.reset(),this._timer=setTimeout((function(){e.state=8,e.tryEmit()}),i.time);else if(4&t.eventType)return 8;return ha},i.reset=function(){clearTimeout(this._timer)},i.emit=function(t){8===this.state&&(t&&4&t.eventType?this.manager.emit(this.options.event+"up",t):(this._input.timeStamp=os(),this.manager.emit(this.options.event,this._input)))},e}(ua),ka={domEvents:!1,touchAction:as,enable:!0,inputTarget:null,inputClass:null,cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}},_a=[[ba,{enable:!1}],[ma,{enable:!1},["rotate"]],[ya,{direction:6}],[ga,{direction:6},["swipe"]],[fa],[fa,{event:"doubletap",taps:2},["tap"]],[wa]];function xa(t,e){var i,o=t.element;o.style&&(xs(t.options.cssProps,(function(n,r){i=ns(o.style,r),e?(t.oldCssProps[i]=o.style[i],o.style[i]=n):o.style[i]=t.oldCssProps[i]||""})),e||(t.oldCssProps={}))}var Ea=function(){function t(t,e){var i,o=this;this.options=Zr({},ka,e||{}),this.options.inputTarget=this.options.inputTarget||t,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=t,this.input=new((i=this).options.inputClass||(vs?Ys:gs?Qs:ps?sa:ia))(i,Fs),this.touchAction=new Cs(this,this.options.touchAction),xa(this,!0),xs(this.options.recognizers,(function(t){var e=o.add(new t[0](t[1]));t[2]&&e.recognizeWith(t[2]),t[3]&&e.requireFailure(t[3])}),this)}var e=t.prototype;return e.set=function(t){return Zr(this.options,t),t.touchAction&&this.touchAction.update(),t.inputTarget&&(this.input.destroy(),this.input.target=t.inputTarget,this.input.init()),this},e.stop=function(t){this.session.stopped=t?2:1},e.recognize=function(t){var e=this.session;if(!e.stopped){var i;this.touchAction.preventDefaults(t);var o=this.recognizers,n=e.curRecognizer;(!n||n&&8&n.state)&&(e.curRecognizer=null,n=null);for(var r=0;r<o.length;)i=o[r],2===e.stopped||n&&i!==n&&!i.canRecognizeWith(n)?i.reset():i.recognize(t),!n&&14&i.state&&(e.curRecognizer=i,n=i),r++}},e.get=function(t){if(t instanceof ua)return t;for(var e=this.recognizers,i=0;i<e.length;i++)if(e[i].options.event===t)return e[i];return null},e.add=function(t){if(aa(t,"add",this))return this;var e=this.get(t.options.event);return e&&this.remove(e),this.recognizers.push(t),t.manager=this,this.touchAction.update(),t},e.remove=function(t){if(aa(t,"remove",this))return this;var e=this.get(t);if(t){var i=this.recognizers,o=Hs(i,e);-1!==o&&(i.splice(o,1),this.touchAction.update())}return this},e.on=function(t,e){if(void 0===t||void 0===e)return this;var i=this.handlers;return xs(Ns(t),(function(t){i[t]=i[t]||[],i[t].push(e)})),this},e.off=function(t,e){if(void 0===t)return this;var i=this.handlers;return xs(Ns(t),(function(t){e?i[t]&&i[t].splice(Hs(i[t],e),1):delete i[t]})),this},e.emit=function(t,e){this.options.domEvents&&function(t,e){var i=document.createEvent("Event");i.initEvent(t,!0,!0),i.gesture=e,e.target.dispatchEvent(i)}(t,e);var i=this.handlers[t]&&this.handlers[t].slice();if(i&&i.length){e.type=t,e.preventDefault=function(){e.srcEvent.preventDefault()};for(var o=0;o<i.length;)i[o](e),o++}},e.destroy=function(){this.element&&xa(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null},t}(),Oa={touchstart:1,touchmove:2,touchend:4,touchcancel:8},Ca="touchstart",Sa="touchstart touchmove touchend touchcancel",Ta=function(t){function e(){var i,o=e.prototype;return o.evTarget=Ca,o.evWin=Sa,(i=t.apply(this,arguments)||this).started=!1,i}return Kr(e,t),e.prototype.handler=function(t){var e=Oa[t.type];if(1===e&&(this.started=!0),this.started){var i=Ma.call(this,t,e);12&e&&i[0].length-i[1].length==0&&(this.started=!1),this.callback(this.manager,e,{pointers:i[0],changedPointers:i[1],pointerType:ys,srcEvent:t})}},e}(Ls);function Ma(t,e){var i=Xs(t.touches),o=Xs(t.changedTouches);return 12&e&&(i=Gs(i.concat(o),"identifier",!0)),[i,o]}function Pa(t,e,i){var o="DEPRECATED METHOD: "+e+"\n"+i+" AT \n";return function(){var e=new Error("get-stack-trace"),i=e&&e.stack?e.stack.replace(/^[^\(]+?[\n$]/gm,"").replace(/^\s+at\s+/gm,"").replace(/^Object.<anonymous>\s*\(/gm,"{anonymous}()@"):"Unknown Stack Trace",n=window.console&&(window.console.warn||window.console.log);return n&&n.call(window.console,o,i),t.apply(this,arguments)}}var Da=Pa((function(t,e,i){for(var o=Object.keys(e),n=0;n<o.length;)(!i||i&&void 0===t[o[n]])&&(t[o[n]]=e[o[n]]),n++;return t}),"extend","Use `assign`."),Ba=Pa((function(t,e){return Da(t,e,!0)}),"merge","Use `assign`.");function Ia(t,e,i){var o,n=e.prototype;(o=t.prototype=Object.create(n)).constructor=t,o._super=n,i&&Zr(o,i)}function za(t,e){return function(){return t.apply(e,arguments)}}var Fa=function(){var t=function(t,e){return void 0===e&&(e={}),new Ea(t,Gr({recognizers:_a.concat()},e))};return t.VERSION="2.0.17-rc",t.DIRECTION_ALL=30,t.DIRECTION_DOWN=bs,t.DIRECTION_LEFT=2,t.DIRECTION_RIGHT=4,t.DIRECTION_UP=8,t.DIRECTION_HORIZONTAL=6,t.DIRECTION_VERTICAL=ws,t.DIRECTION_NONE=1,t.DIRECTION_DOWN=bs,t.INPUT_START=1,t.INPUT_MOVE=2,t.INPUT_END=4,t.INPUT_CANCEL=8,t.STATE_POSSIBLE=1,t.STATE_BEGAN=2,t.STATE_CHANGED=4,t.STATE_ENDED=8,t.STATE_RECOGNIZED=8,t.STATE_CANCELLED=16,t.STATE_FAILED=ha,t.Manager=Ea,t.Input=Ls,t.TouchAction=Cs,t.TouchInput=Qs,t.MouseInput=ia,t.PointerEventInput=Ys,t.TouchMouseInput=sa,t.SingleTouchInput=Ta,t.Recognizer=ua,t.AttrRecognizer=pa,t.Tap=fa,t.Pan=ga,t.Swipe=ya,t.Pinch=ma,t.Rotate=ba,t.Press=wa,t.on=As,t.off=Rs,t.each=xs,t.merge=Ba,t.extend=Da,t.bindFn=za,t.assign=Zr,t.inherit=Ia,t.bindFn=za,t.prefixed=ns,t.toArray=Xs,t.inArray=Hs,t.uniqueArray=Gs,t.splitStr=Ns,t.boolOrFn=Es,t.hasParent=Ss,t.addEventListeners=As,t.removeEventListeners=Rs,t.defaults=Zr({},ka,{preset:_a}),t}();function Na(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return Aa(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return Aa(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function Aa(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}function Ra(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];return ja(e.length?e:[En()])}function ja(t){var e=an(function(){for(var t=La(),e=t(" "),i=t(" "),o=t(" "),n=0;n<arguments.length;n++)(e-=t(n<0||arguments.length<=n?void 0:arguments[n]))<0&&(e+=1),(i-=t(n<0||arguments.length<=n?void 0:arguments[n]))<0&&(i+=1),(o-=t(n<0||arguments.length<=n?void 0:arguments[n]))<0&&(o+=1);return[e,i,o]}(t),3),i=e[0],o=e[1],n=e[2],r=1,s=function(){var t=2091639*i+2.3283064365386963e-10*r;return i=o,o=n,n=t-(r=0|t)};return s.uint32=function(){return 4294967296*s()},s.fract53=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.algorithm="Alea",s.seed=t,s.version="0.9",s}function La(){var t=4022871197;return function(e){for(var i=e.toString(),o=0;o<i.length;o++){var n=.02519603282416938*(t+=i.charCodeAt(o));n-=t=n>>>0,t=(n*=t)>>>0,t+=4294967296*(n-=t)}return 2.3283064365386963e-10*(t>>>0)}}cn("DELETE");var Ha="undefined"!=typeof window?window.Hammer||Fa:function(){return{on:t=function(){},off:t,destroy:t,emit:t,get:function(){return{set:t}}};var t};function Wa(t){var e,i=this;this._cleanupQueue=[],this.active=!1,this._dom={container:t,overlay:document.createElement("div")},this._dom.overlay.classList.add("vis-overlay"),this._dom.container.appendChild(this._dom.overlay),this._cleanupQueue.push((function(){i._dom.overlay.parentNode.removeChild(i._dom.overlay)}));var o=Ha(this._dom.overlay);o.on("tap",bt(e=this._onTapOverlay).call(e,this)),this._cleanupQueue.push((function(){o.destroy()}));var n=["tap","doubletap","press","pinch","pan","panstart","panmove","panend"];Dn(n).call(n,(function(t){o.on(t,(function(t){t.srcEvent.stopPropagation()}))})),document&&document.body&&(this._onClick=function(e){(function(t,e){for(;t;){if(t===e)return!0;t=t.parentNode}return!1})(e.target,t)||i.deactivate()},document.body.addEventListener("click",this._onClick),this._cleanupQueue.push((function(){document.body.removeEventListener("click",i._onClick)}))),this._escListener=function(t){("key"in t?"Escape"===t.key:27===t.keyCode)&&i.deactivate()}}Ct(Wa.prototype),Wa.current=null,Wa.prototype.destroy=function(){var t,e;this.deactivate();var i,o=Na(Nn(t=qn(e=this._cleanupQueue).call(e,0)).call(t));try{for(o.s();!(i=o.n()).done;){(0,i.value)()}}catch(t){o.e(t)}finally{o.f()}},Wa.prototype.activate=function(){Wa.current&&Wa.current.deactivate(),Wa.current=this,this.active=!0,this._dom.overlay.style.display="none",this._dom.container.classList.add("vis-active"),this.emit("change"),this.emit("activate"),document.body.addEventListener("keydown",this._escListener)},Wa.prototype.deactivate=function(){this.active=!1,this._dom.overlay.style.display="block",this._dom.container.classList.remove("vis-active"),document.body.removeEventListener("keydown",this._escListener),this.emit("change"),this.emit("deactivate")},Wa.prototype._onTapOverlay=function(t){this.activate(),t.srcEvent.stopPropagation()};var Va=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,qa=/^#?([a-f\d])([a-f\d])([a-f\d])$/i,Ua=/^rgb\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *\)$/i,Ya=/^rgba\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *([01]|0?\.\d+) *\)$/i;function Xa(t){if(t)for(;!0===t.hasChildNodes();){var e=t.firstChild;e&&(Xa(e),t.removeChild(e))}}function Ga(t){return t instanceof String||"string"==typeof t}function Ka(t){return"object"===dn(t)&&null!==t}function $a(t,e,i,o){var n=!1;!0===o&&(n=null===e[i]&&void 0!==t[i]),n?delete t[i]:t[i]=e[i]}function Qa(t,e){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];for(var o in t)if(void 0!==e[o])if(null===e[o]||"object"!==dn(e[o]))$a(t,e,o,i);else{var n=t[o],r=e[o];Ka(n)&&Ka(r)&&Qa(n,r,i)}}function Za(t,e,i){var o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(gn(i))throw new TypeError("Arrays are not supported by deepExtend");for(var n=0;n<t.length;n++){var r=t[n];if(Object.prototype.hasOwnProperty.call(i,r))if(i[r]&&i[r].constructor===Object)void 0===e[r]&&(e[r]={}),e[r].constructor===Object?th(e[r],i[r],!1,o):$a(e,i,r,o);else{if(gn(i[r]))throw new TypeError("Arrays are not supported by deepExtend");$a(e,i,r,o)}}return e}function Ja(t,e,i){var o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(gn(i))throw new TypeError("Arrays are not supported by deepExtend");for(var n in i)if(Object.prototype.hasOwnProperty.call(i,n)&&!Jn(t).call(t,n))if(i[n]&&i[n].constructor===Object)void 0===e[n]&&(e[n]={}),e[n].constructor===Object?th(e[n],i[n]):$a(e,i,n,o);else if(gn(i[n])){e[n]=[];for(var r=0;r<i[n].length;r++)e[n].push(i[n][r])}else $a(e,i,n,o);return e}function th(t,e){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];for(var n in e)if(Object.prototype.hasOwnProperty.call(e,n)||!0===i)if("object"===dn(e[n])&&null!==e[n]&&ir(e[n])===Object.prototype)void 0===t[n]?t[n]=th({},e[n],i):"object"===dn(t[n])&&null!==t[n]&&ir(t[n])===Object.prototype?th(t[n],e[n],i):$a(t,e,n,o);else if(gn(e[n])){var r;t[n]=vn(r=e[n]).call(r)}else $a(t,e,n,o);return t}function eh(t,e){var i;return pn(i=[]).call(i,ln(t),[e])}function ih(t){return vn(t).call(t)}function oh(t){return t.getBoundingClientRect().top}function nh(t,e){if(gn(t))for(var i=t.length,o=0;o<i;o++)e(t[o],o,t);else for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&e(t[n],n,t)}function rh(t){var e;switch(t.length){case 3:case 4:return(e=qa.exec(t))?{r:kr(e[1]+e[1],16),g:kr(e[2]+e[2],16),b:kr(e[3]+e[3],16)}:null;case 6:case 7:return(e=Va.exec(t))?{r:kr(e[1],16),g:kr(e[2],16),b:kr(e[3],16)}:null;default:return null}}function sh(t,e){if(Jn(t).call(t,"rgba"))return t;if(Jn(t).call(t,"rgb")){var i=t.substr(Mr(t).call(t,"(")+1).replace(")","").split(",");return"rgba("+i[0]+","+i[1]+","+i[2]+","+e+")"}var o=rh(t);return null==o?t:"rgba("+o.r+","+o.g+","+o.b+","+e+")"}function ah(t,e,i){var o;return"#"+vn(o=((1<<24)+(t<<16)+(e<<8)+i).toString(16)).call(o,1)}function hh(t,e){if(Ga(t)){var i=t;if(fh(i)){var o,n=kn(o=i.substr(4).substr(0,i.length-5).split(",")).call(o,(function(t){return kr(t)}));i=ah(n[0],n[1],n[2])}if(!0===uh(i)){var r=function(t){var e=rh(t);if(!e)throw new TypeError("'".concat(t,"' is not a valid color."));return dh(e.r,e.g,e.b)}(i),s={h:r.h,s:.8*r.s,v:Math.min(1,1.02*r.v)},a={h:r.h,s:Math.min(1,1.25*r.s),v:.8*r.v},h=ch(a.h,a.s,a.v),d=ch(s.h,s.s,s.v);return{background:i,border:h,highlight:{background:d,border:h},hover:{background:d,border:h}}}return{background:i,border:i,highlight:{background:i,border:i},hover:{background:i,border:i}}}return e?{background:t.background||e.background,border:t.border||e.border,highlight:Ga(t.highlight)?{border:t.highlight,background:t.highlight}:{background:t.highlight&&t.highlight.background||e.highlight.background,border:t.highlight&&t.highlight.border||e.highlight.border},hover:Ga(t.hover)?{border:t.hover,background:t.hover}:{border:t.hover&&t.hover.border||e.hover.border,background:t.hover&&t.hover.background||e.hover.background}}:{background:t.background||void 0,border:t.border||void 0,highlight:Ga(t.highlight)?{border:t.highlight,background:t.highlight}:{background:t.highlight&&t.highlight.background||void 0,border:t.highlight&&t.highlight.border||void 0},hover:Ga(t.hover)?{border:t.hover,background:t.hover}:{border:t.hover&&t.hover.border||void 0,background:t.hover&&t.hover.background||void 0}}}function dh(t,e,i){t/=255,e/=255,i/=255;var o=Math.min(t,Math.min(e,i)),n=Math.max(t,Math.max(e,i));return o===n?{h:0,s:0,v:o}:{h:60*((t===o?3:i===o?1:5)-(t===o?e-i:i===o?t-e:i-t)/(n-o))/360,s:(n-o)/n,v:n}}function lh(t,e,i){var o,n,r,s=Math.floor(6*t),a=6*t-s,h=i*(1-e),d=i*(1-a*e),l=i*(1-(1-a)*e);switch(s%6){case 0:o=i,n=l,r=h;break;case 1:o=d,n=i,r=h;break;case 2:o=h,n=i,r=l;break;case 3:o=h,n=d,r=i;break;case 4:o=l,n=h,r=i;break;case 5:o=i,n=h,r=d}return{r:Math.floor(255*o),g:Math.floor(255*n),b:Math.floor(255*r)}}function ch(t,e,i){var o=lh(t,e,i);return ah(o.r,o.g,o.b)}function uh(t){return/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t)}function fh(t){return Ua.test(t)}function ph(t){return Ya.test(t)}function vh(t){if(null===t||"object"!==dn(t))return null;if(t instanceof Element)return t;var e=Ir(t);for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&"object"==dn(t[i])&&(e[i]=vh(t[i]));return e}function gh(t,e,i){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},n=function(t){return null!=t},r=function(t){return null!==t&&"object"===dn(t)},s=function(t){for(var e in t)if(Object.prototype.hasOwnProperty.call(t,e))return!1;return!0};if(!r(t))throw new Error("Parameter mergeTarget must be an object");if(!r(e))throw new Error("Parameter options must be an object");if(!n(i))throw new Error("Parameter option must have a value");if(!r(o))throw new Error("Parameter globalOptions must be an object");var a=function(t,e,i){r(t[i])||(t[i]={});var o=e[i],n=t[i];for(var s in o)Object.prototype.hasOwnProperty.call(o,s)&&(n[s]=o[s])},h=e[i],d=r(o)&&!s(o),l=d?o[i]:void 0,c=l?l.enabled:void 0;if(void 0!==h){if("boolean"==typeof h)return r(t[i])||(t[i]={}),void(t[i].enabled=h);if(null===h&&!r(t[i])){if(!n(l))return;t[i]=Ir(l)}if(r(h)){var u=!0;void 0!==h.enabled?u=h.enabled:void 0!==c&&(u=l.enabled),a(t,e,i),t[i].enabled=u}}}var yh={linear:function(t){return t},easeInQuad:function(t){return t*t},easeOutQuad:function(t){return t*(2-t)},easeInOutQuad:function(t){return t<.5?2*t*t:(4-2*t)*t-1},easeInCubic:function(t){return t*t*t},easeOutCubic:function(t){return--t*t*t+1},easeInOutCubic:function(t){return t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1},easeInQuart:function(t){return t*t*t*t},easeOutQuart:function(t){return 1- --t*t*t*t},easeInOutQuart:function(t){return t<.5?8*t*t*t*t:1-8*--t*t*t*t},easeInQuint:function(t){return t*t*t*t*t},easeOutQuint:function(t){return 1+--t*t*t*t*t},easeInOutQuint:function(t){return t<.5?16*t*t*t*t*t:1+16*--t*t*t*t*t}};function mh(t,e){var i;gn(e)||(e=[e]);var o,n=Na(t);try{for(n.s();!(o=n.n()).done;){var r=o.value;if(r){i=r[e[0]];for(var s=1;s<e.length;s++)i&&(i=i[e[s]]);if(void 0!==i)break}}}catch(t){n.e(t)}finally{n.f()}return i}var bh={black:"#000000",navy:"#000080",darkblue:"#00008B",mediumblue:"#0000CD",blue:"#0000FF",darkgreen:"#006400",green:"#008000",teal:"#008080",darkcyan:"#008B8B",deepskyblue:"#00BFFF",darkturquoise:"#00CED1",mediumspringgreen:"#00FA9A",lime:"#00FF00",springgreen:"#00FF7F",aqua:"#00FFFF",cyan:"#00FFFF",midnightblue:"#191970",dodgerblue:"#1E90FF",lightseagreen:"#20B2AA",forestgreen:"#228B22",seagreen:"#2E8B57",darkslategray:"#2F4F4F",limegreen:"#32CD32",mediumseagreen:"#3CB371",turquoise:"#40E0D0",royalblue:"#4169E1",steelblue:"#4682B4",darkslateblue:"#483D8B",mediumturquoise:"#48D1CC",indigo:"#4B0082",darkolivegreen:"#556B2F",cadetblue:"#5F9EA0",cornflowerblue:"#6495ED",mediumaquamarine:"#66CDAA",dimgray:"#696969",slateblue:"#6A5ACD",olivedrab:"#6B8E23",slategray:"#708090",lightslategray:"#778899",mediumslateblue:"#7B68EE",lawngreen:"#7CFC00",chartreuse:"#7FFF00",aquamarine:"#7FFFD4",maroon:"#800000",purple:"#800080",olive:"#808000",gray:"#808080",skyblue:"#87CEEB",lightskyblue:"#87CEFA",blueviolet:"#8A2BE2",darkred:"#8B0000",darkmagenta:"#8B008B",saddlebrown:"#8B4513",darkseagreen:"#8FBC8F",lightgreen:"#90EE90",mediumpurple:"#9370D8",darkviolet:"#9400D3",palegreen:"#98FB98",darkorchid:"#9932CC",yellowgreen:"#9ACD32",sienna:"#A0522D",brown:"#A52A2A",darkgray:"#A9A9A9",lightblue:"#ADD8E6",greenyellow:"#ADFF2F",paleturquoise:"#AFEEEE",lightsteelblue:"#B0C4DE",powderblue:"#B0E0E6",firebrick:"#B22222",darkgoldenrod:"#B8860B",mediumorchid:"#BA55D3",rosybrown:"#BC8F8F",darkkhaki:"#BDB76B",silver:"#C0C0C0",mediumvioletred:"#C71585",indianred:"#CD5C5C",peru:"#CD853F",chocolate:"#D2691E",tan:"#D2B48C",lightgrey:"#D3D3D3",palevioletred:"#D87093",thistle:"#D8BFD8",orchid:"#DA70D6",goldenrod:"#DAA520",crimson:"#DC143C",gainsboro:"#DCDCDC",plum:"#DDA0DD",burlywood:"#DEB887",lightcyan:"#E0FFFF",lavender:"#E6E6FA",darksalmon:"#E9967A",violet:"#EE82EE",palegoldenrod:"#EEE8AA",lightcoral:"#F08080",khaki:"#F0E68C",aliceblue:"#F0F8FF",honeydew:"#F0FFF0",azure:"#F0FFFF",sandybrown:"#F4A460",wheat:"#F5DEB3",beige:"#F5F5DC",whitesmoke:"#F5F5F5",mintcream:"#F5FFFA",ghostwhite:"#F8F8FF",salmon:"#FA8072",antiquewhite:"#FAEBD7",linen:"#FAF0E6",lightgoldenrodyellow:"#FAFAD2",oldlace:"#FDF5E6",red:"#FF0000",fuchsia:"#FF00FF",magenta:"#FF00FF",deeppink:"#FF1493",orangered:"#FF4500",tomato:"#FF6347",hotpink:"#FF69B4",coral:"#FF7F50",darkorange:"#FF8C00",lightsalmon:"#FFA07A",orange:"#FFA500",lightpink:"#FFB6C1",pink:"#FFC0CB",gold:"#FFD700",peachpuff:"#FFDAB9",navajowhite:"#FFDEAD",moccasin:"#FFE4B5",bisque:"#FFE4C4",mistyrose:"#FFE4E1",blanchedalmond:"#FFEBCD",papayawhip:"#FFEFD5",lavenderblush:"#FFF0F5",seashell:"#FFF5EE",cornsilk:"#FFF8DC",lemonchiffon:"#FFFACD",floralwhite:"#FFFAF0",snow:"#FFFAFA",yellow:"#FFFF00",lightyellow:"#FFFFE0",ivory:"#FFFFF0",white:"#FFFFFF"},wh=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;Po(this,t),this.pixelRatio=e,this.generated=!1,this.centerCoordinates={x:144.5,y:144.5},this.r=289*.49,this.color={r:255,g:255,b:255,a:1},this.hueCircle=void 0,this.initialColor={r:255,g:255,b:255,a:1},this.previousColor=void 0,this.applied=!1,this.updateCallback=function(){},this.closeCallback=function(){},this._create()}return Io(t,[{key:"insertTo",value:function(t){void 0!==this.hammer&&(this.hammer.destroy(),this.hammer=void 0),this.container=t,this.container.appendChild(this.frame),this._bindHammer(),this._setSize()}},{key:"setUpdateCallback",value:function(t){if("function"!=typeof t)throw new Error("Function attempted to set as colorPicker update callback is not a function.");this.updateCallback=t}},{key:"setCloseCallback",value:function(t){if("function"!=typeof t)throw new Error("Function attempted to set as colorPicker closing callback is not a function.");this.closeCallback=t}},{key:"_isColorString",value:function(t){if("string"==typeof t)return bh[t]}},{key:"setColor",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if("none"!==t){var i,o=this._isColorString(t);if(void 0!==o&&(t=o),!0===Ga(t)){if(!0===fh(t)){var n=t.substr(4).substr(0,t.length-5).split(",");i={r:n[0],g:n[1],b:n[2],a:1}}else if(!0===ph(t)){var r=t.substr(5).substr(0,t.length-6).split(",");i={r:r[0],g:r[1],b:r[2],a:r[3]}}else if(!0===uh(t)){var s=rh(t);i={r:s.r,g:s.g,b:s.b,a:1}}}else if(t instanceof Object&&void 0!==t.r&&void 0!==t.g&&void 0!==t.b){var a=void 0!==t.a?t.a:"1.0";i={r:t.r,g:t.g,b:t.b,a:a}}if(void 0===i)throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: "+Lr(t));this._setColor(i,e)}}},{key:"show",value:function(){void 0!==this.closeCallback&&(this.closeCallback(),this.closeCallback=void 0),this.applied=!1,this.frame.style.display="block",this._generateHueCircle()}},{key:"_hide",value:function(){var t=this,e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];!0===e&&(this.previousColor=ct({},this.color)),!0===this.applied&&this.updateCallback(this.initialColor),this.frame.style.display="none",qr((function(){void 0!==t.closeCallback&&(t.closeCallback(),t.closeCallback=void 0)}),0)}},{key:"_save",value:function(){this.updateCallback(this.color),this.applied=!1,this._hide()}},{key:"_apply",value:function(){this.applied=!0,this.updateCallback(this.color),this._updatePicker(this.color)}},{key:"_loadLast",value:function(){void 0!==this.previousColor?this.setColor(this.previousColor,!1):alert("There is no last color to load...")}},{key:"_setColor",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];!0===e&&(this.initialColor=ct({},t)),this.color=t;var i=dh(t.r,t.g,t.b),o=2*Math.PI,n=this.r*i.s,r=this.centerCoordinates.x+n*Math.sin(o*i.h),s=this.centerCoordinates.y+n*Math.cos(o*i.h);this.colorPickerSelector.style.left=r-.5*this.colorPickerSelector.clientWidth+"px",this.colorPickerSelector.style.top=s-.5*this.colorPickerSelector.clientHeight+"px",this._updatePicker(t)}},{key:"_setOpacity",value:function(t){this.color.a=t/100,this._updatePicker(this.color)}},{key:"_setBrightness",value:function(t){var e=dh(this.color.r,this.color.g,this.color.b);e.v=t/100;var i=lh(e.h,e.s,e.v);i.a=this.color.a,this.color=i,this._updatePicker()}},{key:"_updatePicker",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.color,e=dh(t.r,t.g,t.b),i=this.colorPickerCanvas.getContext("2d");void 0===this.pixelRation&&(this.pixelRatio=(window.devicePixelRatio||1)/(i.webkitBackingStorePixelRatio||i.mozBackingStorePixelRatio||i.msBackingStorePixelRatio||i.oBackingStorePixelRatio||i.backingStorePixelRatio||1)),i.setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0);var o=this.colorPickerCanvas.clientWidth,n=this.colorPickerCanvas.clientHeight;i.clearRect(0,0,o,n),i.putImageData(this.hueCircle,0,0),i.fillStyle="rgba(0,0,0,"+(1-e.v)+")",i.circle(this.centerCoordinates.x,this.centerCoordinates.y,this.r),Xr(i).call(i),this.brightnessRange.value=100*e.v,this.opacityRange.value=100*t.a,this.initialColorDiv.style.backgroundColor="rgba("+this.initialColor.r+","+this.initialColor.g+","+this.initialColor.b+","+this.initialColor.a+")",this.newColorDiv.style.backgroundColor="rgba("+this.color.r+","+this.color.g+","+this.color.b+","+this.color.a+")"}},{key:"_setSize",value:function(){this.colorPickerCanvas.style.width="100%",this.colorPickerCanvas.style.height="100%",this.colorPickerCanvas.width=289*this.pixelRatio,this.colorPickerCanvas.height=289*this.pixelRatio}},{key:"_create",value:function(){var t,e,i,o;if(this.frame=document.createElement("div"),this.frame.className="vis-color-picker",this.colorPickerDiv=document.createElement("div"),this.colorPickerSelector=document.createElement("div"),this.colorPickerSelector.className="vis-selector",this.colorPickerDiv.appendChild(this.colorPickerSelector),this.colorPickerCanvas=document.createElement("canvas"),this.colorPickerDiv.appendChild(this.colorPickerCanvas),this.colorPickerCanvas.getContext){var n=this.colorPickerCanvas.getContext("2d");this.pixelRatio=(window.devicePixelRatio||1)/(n.webkitBackingStorePixelRatio||n.mozBackingStorePixelRatio||n.msBackingStorePixelRatio||n.oBackingStorePixelRatio||n.backingStorePixelRatio||1),this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0)}else{var r=document.createElement("DIV");r.style.color="red",r.style.fontWeight="bold",r.style.padding="10px",r.innerText="Error: your browser does not support HTML canvas",this.colorPickerCanvas.appendChild(r)}this.colorPickerDiv.className="vis-color",this.opacityDiv=document.createElement("div"),this.opacityDiv.className="vis-opacity",this.brightnessDiv=document.createElement("div"),this.brightnessDiv.className="vis-brightness",this.arrowDiv=document.createElement("div"),this.arrowDiv.className="vis-arrow",this.opacityRange=document.createElement("input");try{this.opacityRange.type="range",this.opacityRange.min="0",this.opacityRange.max="100"}catch(t){}this.opacityRange.value="100",this.opacityRange.className="vis-range",this.brightnessRange=document.createElement("input");try{this.brightnessRange.type="range",this.brightnessRange.min="0",this.brightnessRange.max="100"}catch(t){}this.brightnessRange.value="100",this.brightnessRange.className="vis-range",this.opacityDiv.appendChild(this.opacityRange),this.brightnessDiv.appendChild(this.brightnessRange);var s=this;this.opacityRange.onchange=function(){s._setOpacity(this.value)},this.opacityRange.oninput=function(){s._setOpacity(this.value)},this.brightnessRange.onchange=function(){s._setBrightness(this.value)},this.brightnessRange.oninput=function(){s._setBrightness(this.value)},this.brightnessLabel=document.createElement("div"),this.brightnessLabel.className="vis-label vis-brightness",this.brightnessLabel.innerText="brightness:",this.opacityLabel=document.createElement("div"),this.opacityLabel.className="vis-label vis-opacity",this.opacityLabel.innerText="opacity:",this.newColorDiv=document.createElement("div"),this.newColorDiv.className="vis-new-color",this.newColorDiv.innerText="new",this.initialColorDiv=document.createElement("div"),this.initialColorDiv.className="vis-initial-color",this.initialColorDiv.innerText="initial",this.cancelButton=document.createElement("div"),this.cancelButton.className="vis-button vis-cancel",this.cancelButton.innerText="cancel",this.cancelButton.onclick=bt(t=this._hide).call(t,this,!1),this.applyButton=document.createElement("div"),this.applyButton.className="vis-button vis-apply",this.applyButton.innerText="apply",this.applyButton.onclick=bt(e=this._apply).call(e,this),this.saveButton=document.createElement("div"),this.saveButton.className="vis-button vis-save",this.saveButton.innerText="save",this.saveButton.onclick=bt(i=this._save).call(i,this),this.loadButton=document.createElement("div"),this.loadButton.className="vis-button vis-load",this.loadButton.innerText="load last",this.loadButton.onclick=bt(o=this._loadLast).call(o,this),this.frame.appendChild(this.colorPickerDiv),this.frame.appendChild(this.arrowDiv),this.frame.appendChild(this.brightnessLabel),this.frame.appendChild(this.brightnessDiv),this.frame.appendChild(this.opacityLabel),this.frame.appendChild(this.opacityDiv),this.frame.appendChild(this.newColorDiv),this.frame.appendChild(this.initialColorDiv),this.frame.appendChild(this.cancelButton),this.frame.appendChild(this.applyButton),this.frame.appendChild(this.saveButton),this.frame.appendChild(this.loadButton)}},{key:"_bindHammer",value:function(){var t=this;this.drag={},this.pinch={},this.hammer=new Ha(this.colorPickerCanvas),this.hammer.get("pinch").set({enable:!0}),this.hammer.on("hammer.input",(function(e){e.isFirst&&t._moveSelector(e)})),this.hammer.on("tap",(function(e){t._moveSelector(e)})),this.hammer.on("panstart",(function(e){t._moveSelector(e)})),this.hammer.on("panmove",(function(e){t._moveSelector(e)})),this.hammer.on("panend",(function(e){t._moveSelector(e)}))}},{key:"_generateHueCircle",value:function(){if(!1===this.generated){var t=this.colorPickerCanvas.getContext("2d");void 0===this.pixelRation&&(this.pixelRatio=(window.devicePixelRatio||1)/(t.webkitBackingStorePixelRatio||t.mozBackingStorePixelRatio||t.msBackingStorePixelRatio||t.oBackingStorePixelRatio||t.backingStorePixelRatio||1)),t.setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0);var e,i,o,n,r=this.colorPickerCanvas.clientWidth,s=this.colorPickerCanvas.clientHeight;t.clearRect(0,0,r,s),this.centerCoordinates={x:.5*r,y:.5*s},this.r=.49*r;var a,h=2*Math.PI/360,d=1/this.r;for(o=0;o<360;o++)for(n=0;n<this.r;n++)e=this.centerCoordinates.x+n*Math.sin(h*o),i=this.centerCoordinates.y+n*Math.cos(h*o),a=lh(.002777777777777778*o,n*d,1),t.fillStyle="rgb("+a.r+","+a.g+","+a.b+")",t.fillRect(e-.5,i-.5,2,2);t.strokeStyle="rgba(0,0,0,1)",t.circle(this.centerCoordinates.x,this.centerCoordinates.y,this.r),t.stroke(),this.hueCircle=t.getImageData(0,0,r,s)}this.generated=!0}},{key:"_moveSelector",value:function(t){var e=this.colorPickerDiv.getBoundingClientRect(),i=t.center.x-e.left,o=t.center.y-e.top,n=.5*this.colorPickerDiv.clientHeight,r=.5*this.colorPickerDiv.clientWidth,s=i-r,a=o-n,h=Math.atan2(s,a),d=.98*Math.min(Math.sqrt(s*s+a*a),r),l=Math.cos(h)*d+n,c=Math.sin(h)*d+r;this.colorPickerSelector.style.top=l-.5*this.colorPickerSelector.clientHeight+"px",this.colorPickerSelector.style.left=c-.5*this.colorPickerSelector.clientWidth+"px";var u=h/(2*Math.PI);u=u<0?u+1:u;var f=d/this.r,p=dh(this.color.r,this.color.g,this.color.b);p.h=u,p.s=f;var v=lh(p.h,p.s,p.v);v.a=this.color.a,this.color=v,this.initialColorDiv.style.backgroundColor="rgba("+this.initialColor.r+","+this.initialColor.g+","+this.initialColor.b+","+this.initialColor.a+")",this.newColorDiv.style.backgroundColor="rgba("+this.color.r+","+this.color.g+","+this.color.b+","+this.color.a+")"}}]),t}();function kh(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];if(e.length<1)throw new TypeError("Invalid arguments.");if(1===e.length)return document.createTextNode(e[0]);var o=document.createElement(e[0]);return o.appendChild(kh.apply(void 0,ln(vn(e).call(e,1)))),o}var _h,xh=!1,Eh="background: #FFeeee; color: #dd0000",Oh=Wa,Ch=function(){function t(e,i,o){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:function(){return!1};Po(this,t),this.parent=e,this.changedOptions=[],this.container=i,this.allowCreation=!1,this.hideOption=r,this.options={},this.initialized=!1,this.popupCounter=0,this.defaultOptions={enabled:!1,filter:!0,container:void 0,showButton:!0},ct(this.options,this.defaultOptions),this.configureOptions=o,this.moduleOptions={},this.domElements=[],this.popupDiv={},this.popupLimit=5,this.popupHistory={},this.colorPicker=new wh(n),this.wrapper=void 0}return Io(t,[{key:"setOptions",value:function(t){if(void 0!==t){this.popupHistory={},this._removePopup();var e=!0;if("string"==typeof t)this.options.filter=t;else if(gn(t))this.options.filter=t.join();else if("object"===dn(t)){if(null==t)throw new TypeError("options cannot be null");void 0!==t.container&&(this.options.container=t.container),void 0!==ar(t)&&(this.options.filter=ar(t)),void 0!==t.showButton&&(this.options.showButton=t.showButton),void 0!==t.enabled&&(e=t.enabled)}else"boolean"==typeof t?(this.options.filter=!0,e=t):"function"==typeof t&&(this.options.filter=t,e=!0);!1===ar(this.options)&&(e=!1),this.options.enabled=e}this._clean()}},{key:"setModuleOptions",value:function(t){this.moduleOptions=t,!0===this.options.enabled&&(this._clean(),void 0!==this.options.container&&(this.container=this.options.container),this._create())}},{key:"_create",value:function(){this._clean(),this.changedOptions=[];var t=ar(this.options),e=0,i=!1;for(var o in this.configureOptions)Object.prototype.hasOwnProperty.call(this.configureOptions,o)&&(this.allowCreation=!1,i=!1,"function"==typeof t?i=(i=t(o,[]))||this._handleObject(this.configureOptions[o],[o],!0):!0!==t&&-1===Mr(t).call(t,o)||(i=!0),!1!==i&&(this.allowCreation=!0,e>0&&this._makeItem([]),this._makeHeader(o),this._handleObject(this.configureOptions[o],[o])),e++);this._makeButton(),this._push()}},{key:"_push",value:function(){this.wrapper=document.createElement("div"),this.wrapper.className="vis-configuration-wrapper",this.container.appendChild(this.wrapper);for(var t=0;t<this.domElements.length;t++)this.wrapper.appendChild(this.domElements[t]);this._showPopupIfNeeded()}},{key:"_clean",value:function(){for(var t=0;t<this.domElements.length;t++)this.wrapper.removeChild(this.domElements[t]);void 0!==this.wrapper&&(this.container.removeChild(this.wrapper),this.wrapper=void 0),this.domElements=[],this._removePopup()}},{key:"_getValue",value:function(t){for(var e=this.moduleOptions,i=0;i<t.length;i++){if(void 0===e[t[i]]){e=void 0;break}e=e[t[i]]}return e}},{key:"_makeItem",value:function(t){if(!0===this.allowCreation){var e=document.createElement("div");e.className="vis-configuration vis-config-item vis-config-s"+t.length;for(var i=arguments.length,o=new Array(i>1?i-1:0),n=1;n<i;n++)o[n-1]=arguments[n];return Dn(o).call(o,(function(t){e.appendChild(t)})),this.domElements.push(e),this.domElements.length}return 0}},{key:"_makeHeader",value:function(t){var e=document.createElement("div");e.className="vis-configuration vis-config-header",e.innerText=t,this._makeItem([],e)}},{key:"_makeLabel",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=document.createElement("div");if(o.className="vis-configuration vis-config-label vis-config-s"+e.length,!0===i){for(;o.firstChild;)o.removeChild(o.firstChild);o.appendChild(kh("i","b",t))}else o.innerText=t+":";return o}},{key:"_makeDropdown",value:function(t,e,i){var o=document.createElement("select");o.className="vis-configuration vis-config-select";var n=0;void 0!==e&&-1!==Mr(t).call(t,e)&&(n=Mr(t).call(t,e));for(var r=0;r<t.length;r++){var s=document.createElement("option");s.value=t[r],r===n&&(s.selected="selected"),s.innerText=t[r],o.appendChild(s)}var a=this;o.onchange=function(){a._update(this.value,i)};var h=this._makeLabel(i[i.length-1],i);this._makeItem(i,h,o)}},{key:"_makeRange",value:function(t,e,i){var o=t[0],n=t[1],r=t[2],s=t[3],a=document.createElement("input");a.className="vis-configuration vis-config-range";try{a.type="range",a.min=n,a.max=r}catch(t){}a.step=s;var h="",d=0;if(void 0!==e){var l=1.2;e<0&&e*l<n?(a.min=Math.ceil(e*l),d=a.min,h="range increased"):e/l<n&&(a.min=Math.ceil(e/l),d=a.min,h="range increased"),e*l>r&&1!==r&&(a.max=Math.ceil(e*l),d=a.max,h="range increased"),a.value=e}else a.value=o;var c=document.createElement("input");c.className="vis-configuration vis-config-rangeinput",c.value=a.value;var u=this;a.onchange=function(){c.value=this.value,u._update(Number(this.value),i)},a.oninput=function(){c.value=this.value};var f=this._makeLabel(i[i.length-1],i),p=this._makeItem(i,f,a,c);""!==h&&this.popupHistory[p]!==d&&(this.popupHistory[p]=d,this._setupPopup(h,p))}},{key:"_makeButton",value:function(){var t=this;if(!0===this.options.showButton){var e=document.createElement("div");e.className="vis-configuration vis-config-button",e.innerText="generate options",e.onclick=function(){t._printOptions()},e.onmouseover=function(){e.className="vis-configuration vis-config-button hover"},e.onmouseout=function(){e.className="vis-configuration vis-config-button"},this.optionsContainer=document.createElement("div"),this.optionsContainer.className="vis-configuration vis-config-option-container",this.domElements.push(this.optionsContainer),this.domElements.push(e)}}},{key:"_setupPopup",value:function(t,e){var i=this;if(!0===this.initialized&&!0===this.allowCreation&&this.popupCounter<this.popupLimit){var o=document.createElement("div");o.id="vis-configuration-popup",o.className="vis-configuration-popup",o.innerText=t,o.onclick=function(){i._removePopup()},this.popupCounter+=1,this.popupDiv={html:o,index:e}}}},{key:"_removePopup",value:function(){void 0!==this.popupDiv.html&&(this.popupDiv.html.parentNode.removeChild(this.popupDiv.html),clearTimeout(this.popupDiv.hideTimeout),clearTimeout(this.popupDiv.deleteTimeout),this.popupDiv={})}},{key:"_showPopupIfNeeded",value:function(){var t=this;if(void 0!==this.popupDiv.html){var e=this.domElements[this.popupDiv.index].getBoundingClientRect();this.popupDiv.html.style.left=e.left+"px",this.popupDiv.html.style.top=e.top-30+"px",document.body.appendChild(this.popupDiv.html),this.popupDiv.hideTimeout=qr((function(){t.popupDiv.html.style.opacity=0}),1500),this.popupDiv.deleteTimeout=qr((function(){t._removePopup()}),1800)}}},{key:"_makeCheckbox",value:function(t,e,i){var o=document.createElement("input");o.type="checkbox",o.className="vis-configuration vis-config-checkbox",o.checked=t,void 0!==e&&(o.checked=e,e!==t&&("object"===dn(t)?e!==t.enabled&&this.changedOptions.push({path:i,value:e}):this.changedOptions.push({path:i,value:e})));var n=this;o.onchange=function(){n._update(this.checked,i)};var r=this._makeLabel(i[i.length-1],i);this._makeItem(i,r,o)}},{key:"_makeTextInput",value:function(t,e,i){var o=document.createElement("input");o.type="text",o.className="vis-configuration vis-config-text",o.value=e,e!==t&&this.changedOptions.push({path:i,value:e});var n=this;o.onchange=function(){n._update(this.value,i)};var r=this._makeLabel(i[i.length-1],i);this._makeItem(i,r,o)}},{key:"_makeColorField",value:function(t,e,i){var o=this,n=t[1],r=document.createElement("div");"none"!==(e=void 0===e?n:e)?(r.className="vis-configuration vis-config-colorBlock",r.style.backgroundColor=e):r.className="vis-configuration vis-config-colorBlock none",e=void 0===e?n:e,r.onclick=function(){o._showColorPicker(e,r,i)};var s=this._makeLabel(i[i.length-1],i);this._makeItem(i,s,r)}},{key:"_showColorPicker",value:function(t,e,i){var o=this;e.onclick=function(){},this.colorPicker.insertTo(e),this.colorPicker.show(),this.colorPicker.setColor(t),this.colorPicker.setUpdateCallback((function(t){var n="rgba("+t.r+","+t.g+","+t.b+","+t.a+")";e.style.backgroundColor=n,o._update(n,i)})),this.colorPicker.setCloseCallback((function(){e.onclick=function(){o._showColorPicker(t,e,i)}}))}},{key:"_handleObject",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=!1,n=ar(this.options),r=!1;for(var s in t)if(Object.prototype.hasOwnProperty.call(t,s)){o=!0;var a=t[s],h=eh(e,s);if("function"==typeof n&&!1===(o=n(s,e))&&!gn(a)&&"string"!=typeof a&&"boolean"!=typeof a&&a instanceof Object&&(this.allowCreation=!1,o=this._handleObject(a,h,!0),this.allowCreation=!1===i),!1!==o){r=!0;var d=this._getValue(h);if(gn(a))this._handleArray(a,d,h);else if("string"==typeof a)this._makeTextInput(a,d,h);else if("boolean"==typeof a)this._makeCheckbox(a,d,h);else if(a instanceof Object){if(!this.hideOption(e,s,this.moduleOptions))if(void 0!==a.enabled){var l=eh(h,"enabled"),c=this._getValue(l);if(!0===c){var u=this._makeLabel(s,h,!0);this._makeItem(h,u),r=this._handleObject(a,h)||r}else this._makeCheckbox(a,c,h)}else{var f=this._makeLabel(s,h,!0);this._makeItem(h,f),r=this._handleObject(a,h)||r}}else console.error("dont know how to handle",a,s,h)}}return r}},{key:"_handleArray",value:function(t,e,i){"string"==typeof t[0]&&"color"===t[0]?(this._makeColorField(t,e,i),t[1]!==e&&this.changedOptions.push({path:i,value:e})):"string"==typeof t[0]?(this._makeDropdown(t,e,i),t[0]!==e&&this.changedOptions.push({path:i,value:e})):"number"==typeof t[0]&&(this._makeRange(t,e,i),t[0]!==e&&this.changedOptions.push({path:i,value:Number(e)}))}},{key:"_update",value:function(t,e){var i=this._constructOptions(t,e);this.parent.body&&this.parent.body.emitter&&this.parent.body.emitter.emit&&this.parent.body.emitter.emit("configChange",i),this.initialized=!0,this.parent.setOptions(i)}},{key:"_constructOptions",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=i;t="false"!==(t="true"===t||t)&&t;for(var n=0;n<e.length;n++)"global"!==e[n]&&(void 0===o[e[n]]&&(o[e[n]]={}),n!==e.length-1?o=o[e[n]]:o[e[n]]=t);return i}},{key:"_printOptions",value:function(){for(var t=this.getOptions();this.optionsContainer.firstChild;)this.optionsContainer.removeChild(this.optionsContainer.firstChild);this.optionsContainer.appendChild(kh("pre","const options = "+Lr(t,null,2)))}},{key:"getOptions",value:function(){for(var t={},e=0;e<this.changedOptions.length;e++)this._constructOptions(this.changedOptions[e].value,this.changedOptions[e].path,t);return t}}]),t}(),Sh=Ha,Th=function(){function t(e,i){Po(this,t),this.container=e,this.overflowMethod=i||"cap",this.x=0,this.y=0,this.padding=5,this.hidden=!1,this.frame=document.createElement("div"),this.frame.className="vis-tooltip",this.container.appendChild(this.frame)}return Io(t,[{key:"setPosition",value:function(t,e){this.x=kr(t),this.y=kr(e)}},{key:"setText",value:function(t){if(t instanceof Element){for(;this.frame.firstChild;)this.frame.removeChild(this.frame.firstChild);this.frame.appendChild(t)}else this.frame.innerText=t}},{key:"show",value:function(t){if(void 0===t&&(t=!0),!0===t){var e=this.frame.clientHeight,i=this.frame.clientWidth,o=this.frame.parentNode.clientHeight,n=this.frame.parentNode.clientWidth,r=0,s=0;if("flip"==this.overflowMethod){var a=!1,h=!0;this.y-e<this.padding&&(h=!1),this.x+i>n-this.padding&&(a=!0),r=a?this.x-i:this.x,s=h?this.y-e:this.y}else(s=this.y-e)+e+this.padding>o&&(s=o-e-this.padding),s<this.padding&&(s=this.padding),(r=this.x)+i+this.padding>n&&(r=n-i-this.padding),r<this.padding&&(r=this.padding);this.frame.style.left=r+"px",this.frame.style.top=s+"px",this.frame.style.visibility="visible",this.hidden=!1}else this.hide()}},{key:"hide",value:function(){this.hidden=!0,this.frame.style.left="0",this.frame.style.top="0",this.frame.style.visibility="hidden"}},{key:"destroy",value:function(){this.frame.parentNode.removeChild(this.frame)}}]),t}(),Mh=Eh,Ph=function(){function t(){Po(this,t)}return Io(t,null,[{key:"validate",value:function(e,i,o){xh=!1,_h=i;var n=i;return void 0!==o&&(n=i[o]),t.parse(e,n,[]),xh}},{key:"parse",value:function(e,i,o){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.check(n,e,i,o)}},{key:"check",value:function(e,i,o,n){if(void 0!==o[e]||void 0!==o.__any__){var r=e,s=!0;void 0===o[e]&&void 0!==o.__any__&&(r="__any__",s="object"===t.getType(i[e]));var a=o[r];s&&void 0!==a.__type__&&(a=a.__type__),t.checkFields(e,i,o,r,a,n)}else t.getSuggestion(e,o,n)}},{key:"checkFields",value:function(e,i,o,n,r,s){var a=function(i){console.error("%c"+i+t.printLocation(s,e),Eh)},h=t.getType(i[e]),d=r[h];void 0!==d?"array"===t.getType(d)&&-1===Mr(d).call(d,i[e])?(a('Invalid option detected in "'+e+'". Allowed values are:'+t.print(d)+' not "'+i[e]+'". '),xh=!0):"object"===h&&"__any__"!==n&&(s=eh(s,e),t.parse(i[e],o[n],s)):void 0===r.any&&(a('Invalid type received for "'+e+'". Expected: '+t.print(xn(r))+". Received ["+h+'] "'+i[e]+'"'),xh=!0)}},{key:"getType",value:function(t){var e=dn(t);return"object"===e?null===t?"null":t instanceof Boolean?"boolean":t instanceof Number?"number":t instanceof String?"string":gn(t)?"array":t instanceof Date?"date":void 0!==t.nodeType?"dom":!0===t._isAMomentObject?"moment":"object":"number"===e?"number":"boolean"===e?"boolean":"string"===e?"string":void 0===e?"undefined":e}},{key:"getSuggestion",value:function(e,i,o){var n,r=t.findInOptions(e,i,o,!1),s=t.findInOptions(e,_h,[],!0);n=void 0!==r.indexMatch?" in "+t.printLocation(r.path,e,"")+'Perhaps it was incomplete? Did you mean: "'+r.indexMatch+'"?\n\n':s.distance<=4&&r.distance>s.distance?" in "+t.printLocation(r.path,e,"")+"Perhaps it was misplaced? Matching option found at: "+t.printLocation(s.path,s.closestMatch,""):r.distance<=8?'. Did you mean "'+r.closestMatch+'"?'+t.printLocation(r.path,e):". Did you mean one of these: "+t.print(xn(i))+t.printLocation(o,e),console.error('%cUnknown option detected: "'+e+'"'+n,Eh),xh=!0}},{key:"findInOptions",value:function(e,i,o){var n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=1e9,s="",a=[],h=e.toLowerCase(),d=void 0;for(var l in i){var c=void 0;if(void 0!==i[l].__type__&&!0===n){var u=t.findInOptions(e,i[l],eh(o,l));r>u.distance&&(s=u.closestMatch,a=u.path,r=u.distance,d=u.indexMatch)}else{var f;-1!==Mr(f=l.toLowerCase()).call(f,h)&&(d=l),r>(c=t.levenshteinDistance(e,l))&&(s=l,a=ih(o),r=c)}}return{closestMatch:s,path:a,distance:r,indexMatch:d}}},{key:"printLocation",value:function(t,e){for(var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Problem value found at: \n",o="\n\n"+i+"options = {\n",n=0;n<t.length;n++){for(var r=0;r<n+1;r++)o+="  ";o+=t[n]+": {\n"}for(var s=0;s<t.length+1;s++)o+="  ";o+=e+"\n";for(var a=0;a<t.length+1;a++){for(var h=0;h<t.length-a;h++)o+="  ";o+="}\n"}return o+"\n\n"}},{key:"print",value:function(t){return Lr(t).replace(/(")|(\[)|(\])|(,"__type__")/g,"").replace(/(,)/g,", ")}},{key:"levenshteinDistance",value:function(t,e){if(0===t.length)return e.length;if(0===e.length)return t.length;var i,o,n=[];for(i=0;i<=e.length;i++)n[i]=[i];for(o=0;o<=t.length;o++)n[0][o]=o;for(i=1;i<=e.length;i++)for(o=1;o<=t.length;o++)e.charAt(i-1)==t.charAt(o-1)?n[i][o]=n[i-1][o-1]:n[i][o]=Math.min(n[i-1][o-1]+1,Math.min(n[i][o-1]+1,n[i-1][o]+1));return n[e.length][t.length]}}]),t}();function Dh(t){return jh=t,function(){var t={};Lh=0,void(Hh=jh.charAt(0)),Zh(),"strict"===Wh&&(t.strict=!0,Zh());"graph"!==Wh&&"digraph"!==Wh||(t.type=Wh,Zh());Vh===Nh&&(t.id=Wh,Zh());if("{"!=Wh)throw nd("Angle bracket { expected");if(Zh(),Jh(t),"}"!=Wh)throw nd("Angle bracket } expected");if(Zh(),""!==Wh)throw nd("End of file expected");return Zh(),delete t.node,delete t.edge,delete t.graph,t}()}var Bh={fontsize:"font.size",fontcolor:"font.color",labelfontcolor:"font.color",fontname:"font.face",color:["color.border","color.background"],fillcolor:"color.background",tooltip:"title",labeltooltip:"title"},Ih=Ir(Bh);Ih.color="color.color",Ih.style="dashes";var zh=0,Fh=1,Nh=2,Ah=3,Rh={"{":!0,"}":!0,"[":!0,"]":!0,";":!0,"=":!0,",":!0,"->":!0,"--":!0},jh="",Lh=0,Hh="",Wh="",Vh=zh;function qh(){Lh++,Hh=jh.charAt(Lh)}function Uh(){return jh.charAt(Lh+1)}function Yh(t){var e=t.charCodeAt(0);return e<47?35===e||46===e:e<59?e>47:e<91?e>64:e<96?95===e:e<123&&e>96}function Xh(t,e){if(t||(t={}),e)for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);return t}function Gh(t,e,i){for(var o=e.split("."),n=t;o.length;){var r=o.shift();o.length?(n[r]||(n[r]={}),n=n[r]):n[r]=i}}function Kh(t,e){for(var i,o,n=null,r=[t],s=t;s.parent;)r.push(s.parent),s=s.parent;if(s.nodes)for(i=0,o=s.nodes.length;i<o;i++)if(e.id===s.nodes[i].id){n=s.nodes[i];break}for(n||(n={id:e.id},t.node&&(n.attr=Xh(n.attr,t.node))),i=r.length-1;i>=0;i--){var a,h=r[i];h.nodes||(h.nodes=[]),-1===Mr(a=h.nodes).call(a,n)&&h.nodes.push(n)}e.attr&&(n.attr=Xh(n.attr,e.attr))}function $h(t,e){if(t.edges||(t.edges=[]),t.edges.push(e),t.edge){var i=Xh({},t.edge);e.attr=Xh(i,e.attr)}}function Qh(t,e,i,o,n){var r={from:e,to:i,type:o};return t.edge&&(r.attr=Xh({},t.edge)),r.attr=Xh(r.attr||{},n),null!=n&&n.hasOwnProperty("arrows")&&null!=n.arrows&&(r.arrows={to:{enabled:!0,type:n.arrows.type}},n.arrows=null),r}function Zh(){for(Vh=zh,Wh="";" "===Hh||"\t"===Hh||"\n"===Hh||"\r"===Hh;)qh();do{var t=!1;if("#"===Hh){for(var e=Lh-1;" "===jh.charAt(e)||"\t"===jh.charAt(e);)e--;if("\n"===jh.charAt(e)||""===jh.charAt(e)){for(;""!=Hh&&"\n"!=Hh;)qh();t=!0}}if("/"===Hh&&"/"===Uh()){for(;""!=Hh&&"\n"!=Hh;)qh();t=!0}if("/"===Hh&&"*"===Uh()){for(;""!=Hh;){if("*"===Hh&&"/"===Uh()){qh(),qh();break}qh()}t=!0}for(;" "===Hh||"\t"===Hh||"\n"===Hh||"\r"===Hh;)qh()}while(t);if(""!==Hh){var i=Hh+Uh();if(Rh[i])return Vh=Fh,Wh=i,qh(),void qh();if(Rh[Hh])return Vh=Fh,Wh=Hh,void qh();if(Yh(Hh)||"-"===Hh){for(Wh+=Hh,qh();Yh(Hh);)Wh+=Hh,qh();return"false"===Wh?Wh=!1:"true"===Wh?Wh=!0:isNaN(Number(Wh))||(Wh=Number(Wh)),void(Vh=Nh)}if('"'===Hh){for(qh();""!=Hh&&('"'!=Hh||'"'===Hh&&'"'===Uh());)'"'===Hh?(Wh+=Hh,qh()):"\\"===Hh&&"n"===Uh()?(Wh+="\n",qh()):Wh+=Hh,qh();if('"'!=Hh)throw nd('End of string " expected');return qh(),void(Vh=Nh)}for(Vh=Ah;""!=Hh;)Wh+=Hh,qh();throw new SyntaxError('Syntax error in part "'+rd(Wh,30)+'"')}Vh=Fh}function Jh(t){for(;""!==Wh&&"}"!=Wh;)td(t),";"===Wh&&Zh()}function td(t){var e=ed(t);if(e)id(t,e);else if(!function(t){if("node"===Wh)return Zh(),t.node=od(),"node";if("edge"===Wh)return Zh(),t.edge=od(),"edge";if("graph"===Wh)return Zh(),t.graph=od(),"graph";return null}(t)){if(Vh!=Nh)throw nd("Identifier expected");var i=Wh;if(Zh(),"="===Wh){if(Zh(),Vh!=Nh)throw nd("Identifier expected");t[i]=Wh,Zh()}else!function(t,e){var i={id:e},o=od();o&&(i.attr=o);Kh(t,i),id(t,e)}(t,i)}}function ed(t){var e=null;if("subgraph"===Wh&&((e={}).type="subgraph",Zh(),Vh===Nh&&(e.id=Wh,Zh())),"{"===Wh){if(Zh(),e||(e={}),e.parent=t,e.node=t.node,e.edge=t.edge,e.graph=t.graph,Jh(e),"}"!=Wh)throw nd("Angle bracket } expected");Zh(),delete e.node,delete e.edge,delete e.graph,delete e.parent,t.subgraphs||(t.subgraphs=[]),t.subgraphs.push(e)}return e}function id(t,e){for(;"->"===Wh||"--"===Wh;){var i,o=Wh;Zh();var n=ed(t);if(n)i=n;else{if(Vh!=Nh)throw nd("Identifier or subgraph expected");Kh(t,{id:i=Wh}),Zh()}$h(t,Qh(t,e,i,o,od())),e=i}}function od(){for(var t,e,i=null,o={dashed:!0,solid:!1,dotted:[1,5]},n={dot:"circle",box:"box",crow:"crow",curve:"curve",icurve:"inv_curve",normal:"triangle",inv:"inv_triangle",diamond:"diamond",tee:"bar",vee:"vee"},r=new Array,s=new Array;"["===Wh;){for(Zh(),i={};""!==Wh&&"]"!=Wh;){if(Vh!=Nh)throw nd("Attribute name expected");var a=Wh;if(Zh(),"="!=Wh)throw nd("Equal sign = expected");if(Zh(),Vh!=Nh)throw nd("Attribute value expected");var h=Wh;"style"===a&&(h=o[h]),"arrowhead"===a&&(a="arrows",h={to:{enabled:!0,type:n[h]}}),"arrowtail"===a&&(a="arrows",h={from:{enabled:!0,type:n[h]}}),r.push({attr:i,name:a,value:h}),s.push(a),Zh(),","==Wh&&Zh()}if("]"!=Wh)throw nd("Bracket ] expected");Zh()}if(Jn(s).call(s,"dir")){var d={arrows:{}};for(t=0;t<r.length;t++)if("arrows"===r[t].name)if(null!=r[t].value.to)d.arrows.to=t;else{if(null==r[t].value.from)throw nd("Invalid value of arrows");d.arrows.from=t}else"dir"===r[t].name&&(d.dir=t);var l,c,u=r[d.dir].value;if(!Jn(s).call(s,"arrows"))if("both"===u)r.push({attr:r[d.dir].attr,name:"arrows",value:{to:{enabled:!0}}}),d.arrows.to=r.length-1,r.push({attr:r[d.dir].attr,name:"arrows",value:{from:{enabled:!0}}}),d.arrows.from=r.length-1;else if("forward"===u)r.push({attr:r[d.dir].attr,name:"arrows",value:{to:{enabled:!0}}}),d.arrows.to=r.length-1;else if("back"===u)r.push({attr:r[d.dir].attr,name:"arrows",value:{from:{enabled:!0}}}),d.arrows.from=r.length-1;else{if("none"!==u)throw nd('Invalid dir type "'+u+'"');r.push({attr:r[d.dir].attr,name:"arrows",value:""}),d.arrows.to=r.length-1}if("both"===u)d.arrows.to&&d.arrows.from?(c=r[d.arrows.to].value.to.type,l=r[d.arrows.from].value.from.type,r[d.arrows.to]={attr:r[d.arrows.to].attr,name:r[d.arrows.to].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}},qn(r).call(r,d.arrows.from,1)):d.arrows.to?(c=r[d.arrows.to].value.to.type,l="arrow",r[d.arrows.to]={attr:r[d.arrows.to].attr,name:r[d.arrows.to].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}}):d.arrows.from&&(c="arrow",l=r[d.arrows.from].value.from.type,r[d.arrows.from]={attr:r[d.arrows.from].attr,name:r[d.arrows.from].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}});else if("back"===u)d.arrows.to&&d.arrows.from?(c="",l=r[d.arrows.from].value.from.type,r[d.arrows.from]={attr:r[d.arrows.from].attr,name:r[d.arrows.from].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}}):d.arrows.to?(c="",l="arrow",d.arrows.from=d.arrows.to,r[d.arrows.from]={attr:r[d.arrows.from].attr,name:r[d.arrows.from].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}}):d.arrows.from&&(c="",l=r[d.arrows.from].value.from.type,r[d.arrows.to]={attr:r[d.arrows.from].attr,name:r[d.arrows.from].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}}),r[d.arrows.from]={attr:r[d.arrows.from].attr,name:r[d.arrows.from].name,value:{from:{enabled:!0,type:r[d.arrows.from].value.from.type}}};else if("none"===u){var f;r[f=d.arrows.to?d.arrows.to:d.arrows.from]={attr:r[f].attr,name:r[f].name,value:""}}else{if("forward"!==u)throw nd('Invalid dir type "'+u+'"');d.arrows.to&&d.arrows.from||d.arrows.to?(c=r[d.arrows.to].value.to.type,l="",r[d.arrows.to]={attr:r[d.arrows.to].attr,name:r[d.arrows.to].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}}):d.arrows.from&&(c="arrow",l="",d.arrows.to=d.arrows.from,r[d.arrows.to]={attr:r[d.arrows.to].attr,name:r[d.arrows.to].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:l}}}),r[d.arrows.to]={attr:r[d.arrows.to].attr,name:r[d.arrows.to].name,value:{to:{enabled:!0,type:r[d.arrows.to].value.to.type}}}}qn(r).call(r,d.dir,1)}if(Jn(s).call(s,"penwidth")){var p=[];for(e=r.length,t=0;t<e;t++)"width"!==r[t].name&&("penwidth"===r[t].name&&(r[t].name="width"),p.push(r[t]));r=p}for(e=r.length,t=0;t<e;t++)Gh(r[t].attr,r[t].name,r[t].value);return i}function nd(t){return new SyntaxError(t+', got "'+rd(Wh,30)+'" (char '+Lh+")")}function rd(t,e){return t.length<=e?t:t.substr(0,27)+"..."}function sd(t,e,i){for(var o=e.split("."),n=o.pop(),r=t,s=0;s<o.length;s++){var a=o[s];a in r||(r[a]={}),r=r[a]}return r[n]=i,t}function ad(t,e){var i={};for(var o in t)if(t.hasOwnProperty(o)){var n=e[o];gn(n)?Dn(n).call(n,(function(e){sd(i,e,t[o])})):sd(i,"string"==typeof n?n:o,t[o])}return i}function hd(t){var e,i=Dh(t),o={nodes:[],edges:[],options:{}};i.nodes&&Dn(e=i.nodes).call(e,(function(t){var e={id:t.id,label:String(t.label||t.id)};Xh(e,ad(t.attr,Bh)),e.image&&(e.shape="image"),o.nodes.push(e)}));if(i.edges){var n,r=function(t){var e={from:t.from,to:t.to};return Xh(e,ad(t.attr,Ih)),null==e.arrows&&"->"===t.type&&(e.arrows="to"),e};Dn(n=i.edges).call(n,(function(t){var e,i,n,s,a,h,d;(e=t.from instanceof Object?t.from.nodes:{id:t.from},i=t.to instanceof Object?t.to.nodes:{id:t.to},t.from instanceof Object&&t.from.edges)&&Dn(n=t.from.edges).call(n,(function(t){var e=r(t);o.edges.push(e)}));(a=i,h=function(e,i){var n=Qh(o,e.id,i.id,t.type,t.attr),s=r(n);o.edges.push(s)},gn(s=e)?Dn(s).call(s,(function(t){gn(a)?Dn(a).call(a,(function(e){h(t,e)})):h(t,a)})):gn(a)?Dn(a).call(a,(function(t){h(s,t)})):h(s,a),t.to instanceof Object&&t.to.edges)&&Dn(d=t.to.edges).call(d,(function(t){var e=r(t);o.edges.push(e)}))}))}return i.attr&&(o.options=i.attr),o}var dd=Object.freeze({__proto__:null,parseDOT:Dh,DOTToGraph:hd});function ld(t,e){var i,o={edges:{inheritColor:!1},nodes:{fixed:!1,parseColor:!1}};null!=e&&(null!=e.fixed&&(o.nodes.fixed=e.fixed),null!=e.parseColor&&(o.nodes.parseColor=e.parseColor),null!=e.inheritColor&&(o.edges.inheritColor=e.inheritColor));var n=t.edges,r=kn(n).call(n,(function(t){var e={from:t.source,id:t.id,to:t.target};return null!=t.attributes&&(e.attributes=t.attributes),null!=t.label&&(e.label=t.label),null!=t.attributes&&null!=t.attributes.title&&(e.title=t.attributes.title),"Directed"===t.type&&(e.arrows="to"),t.color&&!1===o.edges.inheritColor&&(e.color=t.color),e}));return{nodes:kn(i=t.nodes).call(i,(function(t){var e={id:t.id,fixed:o.nodes.fixed&&null!=t.x&&null!=t.y};return null!=t.attributes&&(e.attributes=t.attributes),null!=t.label&&(e.label=t.label),null!=t.size&&(e.size=t.size),null!=t.attributes&&null!=t.attributes.title&&(e.title=t.attributes.title),null!=t.title&&(e.title=t.title),null!=t.x&&(e.x=t.x),null!=t.y&&(e.y=t.y),null!=t.color&&(!0===o.nodes.parseColor?e.color=t.color:e.color={background:t.color,border:t.color,highlight:{background:t.color,border:t.color},hover:{background:t.color,border:t.color}}),e})),edges:r}}var cd=Object.freeze({__proto__:null,parseGephi:ld}),ud=Object.freeze({__proto__:null,en:{addDescription:"Click in an empty space to place a new node.",addEdge:"Add Edge",addNode:"Add Node",back:"Back",close:"Close",createEdgeError:"Cannot link edges to a cluster.",del:"Delete selected",deleteClusterError:"Clusters cannot be deleted.",edgeDescription:"Click on a node and drag the edge to another node to connect them.",edit:"Edit",editClusterError:"Clusters cannot be edited.",editEdge:"Edit Edge",editEdgeDescription:"Click on the control points and drag them to a node to connect to it.",editNode:"Edit Node"},de:{addDescription:"Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.",addEdge:"Kante hinzufgen",addNode:"Knoten hinzufgen",back:"Zurck",close:"Schlieen",createEdgeError:"Es ist nicht mglich, Kanten mit Clustern zu verbinden.",del:"Lsche Auswahl",deleteClusterError:"Cluster knnen nicht gelscht werden.",edgeDescription:"Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.",edit:"Editieren",editClusterError:"Cluster knnen nicht editiert werden.",editEdge:"Kante editieren",editEdgeDescription:"Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.",editNode:"Knoten editieren"},es:{addDescription:"Haga clic en un lugar vaco para colocar un nuevo nodo.",addEdge:"Aadir arista",addNode:"Aadir nodo",back:"Atrs",close:"Cerrar",createEdgeError:"No se puede conectar una arista a un grupo.",del:"Eliminar seleccin",deleteClusterError:"No es posible eliminar grupos.",edgeDescription:"Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.",edit:"Editar",editClusterError:"No es posible editar grupos.",editEdge:"Editar arista",editEdgeDescription:"Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.",editNode:"Editar nodo"},it:{addDescription:"Clicca per aggiungere un nuovo nodo",addEdge:"Aggiungi un vertice",addNode:"Aggiungi un nodo",back:"Indietro",close:"Chiudere",createEdgeError:"Non si possono collegare vertici ad un cluster",del:"Cancella la selezione",deleteClusterError:"I cluster non possono essere cancellati",edgeDescription:"Clicca su un nodo e trascinalo ad un altro nodo per connetterli.",edit:"Modifica",editClusterError:"I clusters non possono essere modificati.",editEdge:"Modifica il vertice",editEdgeDescription:"Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.",editNode:"Modifica il nodo"},nl:{addDescription:"Klik op een leeg gebied om een nieuwe node te maken.",addEdge:"Link toevoegen",addNode:"Node toevoegen",back:"Terug",close:"Sluiten",createEdgeError:"Kan geen link maken naar een cluster.",del:"Selectie verwijderen",deleteClusterError:"Clusters kunnen niet worden verwijderd.",edgeDescription:"Klik op een node en sleep de link naar een andere node om ze te verbinden.",edit:"Wijzigen",editClusterError:"Clusters kunnen niet worden aangepast.",editEdge:"Link wijzigen",editEdgeDescription:"Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.",editNode:"Node wijzigen"},pt:{addDescription:"Clique em um espao em branco para adicionar um novo n",addEdge:"Adicionar aresta",addNode:"Adicionar n",back:"Voltar",close:"Fechar",createEdgeError:"No foi possvel linkar arestas a um cluster.",del:"Remover selecionado",deleteClusterError:"Clusters no puderam ser removidos.",edgeDescription:"Clique em um n e arraste a aresta at outro n para conect-los",edit:"Editar",editClusterError:"Clusters no puderam ser editados.",editEdge:"Editar aresta",editEdgeDescription:"Clique nos pontos de controle e os arraste para um n para conect-los",editNode:"Editar n"},ru:{addDescription:"   ,    .",addEdge:" ",addNode:" ",back:"",close:"",createEdgeError:"    .",del:" ",deleteClusterError:"    ",edgeDescription:"        ,   .",edit:"",editClusterError:"   .",editEdge:" ",editEdgeDescription:"        ,    .",editNode:" "},cn:{addDescription:"",addEdge:"",addNode:"",back:"",close:"",createEdgeError:"",del:"",deleteClusterError:"",edgeDescription:"",edit:"",editClusterError:"",editEdge:"",editEdgeDescription:"",editNode:""},uk:{addDescription:"K   ,    .",addEdge:" ",addNode:" ",back:"",close:"",createEdgeError:"  '   .",del:" ",deleteClusterError:"    .",edgeDescription:"        ,   '.",edit:"",editClusterError:"   .",editEdge:" ",editEdgeDescription:"        ,    .",editNode:" "},fr:{addDescription:"Cliquez dans un endroit vide pour placer un nud.",addEdge:"Ajouter un lien",addNode:"Ajouter un nud",back:"Retour",close:"Fermer",createEdgeError:"Impossible de crer un lien vers un cluster.",del:"Effacer la slection",deleteClusterError:"Les clusters ne peuvent pas tre effacs.",edgeDescription:"Cliquez sur un nud et glissez le lien vers un autre nud pour les connecter.",edit:"diter",editClusterError:"Les clusters ne peuvent pas tre dits.",editEdge:"diter le lien",editEdgeDescription:"Cliquez sur les points de contrle et glissez-les pour connecter un nud.",editNode:"diter le nud"},cs:{addDescription:"Kluknutm do przdnho prostoru mete pidat nov vrchol.",addEdge:"Pidat hranu",addNode:"Pidat vrchol",back:"Zpt",close:"Zavt",createEdgeError:"Nelze pipojit hranu ke shluku.",del:"Smazat vbr",deleteClusterError:"Nelze mazat shluky.",edgeDescription:"Petaenm z jednoho vrcholu do druhho mete spojit tyto vrcholy novou hranou.",edit:"Upravit",editClusterError:"Nelze upravovat shluky.",editEdge:"Upravit hranu",editEdgeDescription:"Petaenm kontrolnho vrcholu hrany ji mete pipojit k jinmu vrcholu.",editNode:"Upravit vrchol"}});var fd=function(){function t(){Po(this,t),this.NUM_ITERATIONS=4,this.image=new Image,this.canvas=document.createElement("canvas")}return Io(t,[{key:"init",value:function(){if(!this.initialized()){this.src=this.image.src;var t=this.image.width,e=this.image.height;this.width=t,this.height=e;var i=Math.floor(e/2),o=Math.floor(e/4),n=Math.floor(e/8),r=Math.floor(e/16),s=Math.floor(t/2),a=Math.floor(t/4),h=Math.floor(t/8),d=Math.floor(t/16);this.canvas.width=3*a,this.canvas.height=i,this.coordinates=[[0,0,s,i],[s,0,a,o],[s,o,h,n],[5*h,o,d,r]],this._fillMipMap()}}},{key:"initialized",value:function(){return void 0!==this.coordinates}},{key:"_fillMipMap",value:function(){var t=this.canvas.getContext("2d"),e=this.coordinates[0];t.drawImage(this.image,e[0],e[1],e[2],e[3]);for(var i=1;i<this.NUM_ITERATIONS;i++){var o=this.coordinates[i-1],n=this.coordinates[i];t.drawImage(this.canvas,o[0],o[1],o[2],o[3],n[0],n[1],n[2],n[3])}}},{key:"drawImageAtPosition",value:function(t,e,i,o,n,r){if(this.initialized())if(e>2){e*=.5;for(var s=0;e>2&&s<this.NUM_ITERATIONS;)e*=.5,s+=1;s>=this.NUM_ITERATIONS&&(s=this.NUM_ITERATIONS-1);var a=this.coordinates[s];t.drawImage(this.canvas,a[0],a[1],a[2],a[3],i,o,n,r)}else t.drawImage(this.image,i,o,n,r)}}]),t}(),pd=function(){function t(e){Po(this,t),this.images={},this.imageBroken={},this.callback=e}return Io(t,[{key:"_tryloadBrokenUrl",value:function(t,e,i){void 0!==t&&void 0!==i&&(void 0!==e?(i.image.onerror=function(){console.error("Could not load brokenImage:",e)},i.image.src=e):console.warn("No broken url image defined"))}},{key:"_redrawWithImage",value:function(t){this.callback&&this.callback(t)}},{key:"load",value:function(t,e){var i=this,o=this.images[t];if(o)return o;var n=new fd;return this.images[t]=n,n.image.onload=function(){i._fixImageCoordinates(n.image),n.init(),i._redrawWithImage(n)},n.image.onerror=function(){console.error("Could not load image:",t),i._tryloadBrokenUrl(t,e,n)},n.image.src=t,n}},{key:"_fixImageCoordinates",value:function(t){0===t.width&&(document.body.appendChild(t),t.width=t.offsetWidth,t.height=t.offsetHeight,document.body.removeChild(t))}}]),t}(),vd=!s((function(){return Object.isExtensible(Object.preventExtensions({}))})),gd=o((function(t){var e=L.f,i=Ht("meta"),o=0,n=Object.isExtensible||function(){return!0},r=function(t){e(t,i,{value:{objectID:"O"+ ++o,weakData:{}}})},s=t.exports={REQUIRED:!1,fastKey:function(t,e){if(!m(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!k(t,i)){if(!n(t))return"F";if(!e)return"E";r(t)}return t[i].objectID},getWeakData:function(t,e){if(!k(t,i)){if(!n(t))return!0;if(!e)return!1;r(t)}return t[i].weakData},onFreeze:function(t){return vd&&s.REQUIRED&&n(t)&&!k(t,i)&&r(t),t}};et[i]=!0})),yd=function(t,e){this.stopped=t,this.result=e},md=function(t,e,i){var o,n,r,s,a,h,d,l=i&&i.that,c=!(!i||!i.AS_ENTRIES),u=!(!i||!i.IS_ITERATOR),f=!(!i||!i.INTERRUPTED),p=A(e,l,1+c+f),v=function(t){return o&&ni(o),new yd(!0,t)},g=function(t){return c?(R(t),f?p(t[0],t[1],v):p(t[0],t[1])):f?p(t,v):p(t)};if(u)o=t;else{if("function"!=typeof(n=ci(t)))throw TypeError("Target is not iterable");if(hi(n)){for(r=0,s=K(t.length);s>r;r++)if((a=g(t[r]))&&a instanceof yd)return a;return new yd(!1)}o=n.call(t)}for(h=o.next;!(d=h.call(o)).done;){try{a=g(d.value)}catch(t){throw ni(o),t}if("object"==typeof a&&a&&a instanceof yd)return a}return new yd(!1)},bd=function(t,e,i){if(!(t instanceof e))throw TypeError("Incorrect "+(i?i+" ":"")+"invocation");return t},wd=L.f,kd=Wi.forEach,_d=Zt.set,xd=Zt.getterFor,Ed=function(t,e,i){var o,n=-1!==t.indexOf("Map"),h=-1!==t.indexOf("Weak"),d=n?"set":"add",l=r[t],c=l&&l.prototype,u={};if(a&&"function"==typeof l&&(h||c.forEach&&!s((function(){(new l).entries().next()})))){o=e((function(e,i){_d(bd(e,o,t),{type:t,collection:new l}),null!=i&&md(i,e[d],{that:e,AS_ENTRIES:n})}));var f=xd(t);kd(["add","clear","delete","forEach","get","has","set","keys","values","entries"],(function(t){var e="add"==t||"set"==t;!(t in c)||h&&"clear"==t||H(o.prototype,t,(function(i,o){var n=f(this).collection;if(!e&&h&&!m(i))return"get"==t&&void 0;var r=n[t](0===i?0:i,o);return e?this:r}))})),h||wd(o.prototype,"size",{configurable:!0,get:function(){return f(this).collection.size}})}else o=i.getConstructor(e,t,n,d),gd.REQUIRED=!0;return Le(o,t,!1,!0),u[t]=o,q({global:!0,forced:!0},u),h||i.setStrong(o,t,n),o},Od=function(t,e,i){for(var o in e)i&&i.unsafe&&t[o]?t[o]=e[o]:Ue(t,o,e[o],i);return t},Cd=be("species"),Sd=L.f,Td=gd.fastKey,Md=Zt.set,Pd=Zt.getterFor,Dd={getConstructor:function(t,e,i,o){var n=t((function(t,r){bd(t,n,e),Md(t,{type:e,index:De(null),first:void 0,last:void 0,size:0}),a||(t.size=0),null!=r&&md(r,t[o],{that:t,AS_ENTRIES:i})})),r=Pd(e),s=function(t,e,i){var o,n,s=r(t),d=h(t,e);return d?d.value=i:(s.last=d={index:n=Td(e,!0),key:e,value:i,previous:o=s.last,next:void 0,removed:!1},s.first||(s.first=d),o&&(o.next=d),a?s.size++:t.size++,"F"!==n&&(s.index[n]=d)),t},h=function(t,e){var i,o=r(t),n=Td(e);if("F"!==n)return o.index[n];for(i=o.first;i;i=i.next)if(i.key==e)return i};return Od(n.prototype,{clear:function(){for(var t=r(this),e=t.index,i=t.first;i;)i.removed=!0,i.previous&&(i.previous=i.previous.next=void 0),delete e[i.index],i=i.next;t.first=t.last=void 0,a?t.size=0:this.size=0},delete:function(t){var e=this,i=r(e),o=h(e,t);if(o){var n=o.next,s=o.previous;delete i.index[o.index],o.removed=!0,s&&(s.next=n),n&&(n.previous=s),i.first==o&&(i.first=n),i.last==o&&(i.last=s),a?i.size--:e.size--}return!!o},forEach:function(t){for(var e,i=r(this),o=A(t,arguments.length>1?arguments[1]:void 0,3);e=e?e.next:i.first;)for(o(e.value,e.key,this);e&&e.removed;)e=e.previous},has:function(t){return!!h(this,t)}}),Od(n.prototype,i?{get:function(t){var e=h(this,t);return e&&e.value},set:function(t,e){return s(this,0===t?0:t,e)}}:{add:function(t){return s(this,t=0===t?0:t,t)}}),a&&Sd(n.prototype,"size",{get:function(){return r(this).size}}),n},setStrong:function(t,e,i){var o=e+" Iterator",n=Pd(e),r=Pd(o);Je(t,e,(function(t,e){Md(this,{type:o,target:t,state:n(t),kind:e,last:void 0})}),(function(){for(var t=r(this),e=t.kind,i=t.last;i&&i.removed;)i=i.previous;return t.target&&(t.last=i=i?i.next:t.state.first)?"keys"==e?{value:i.key,done:!1}:"values"==e?{value:i.value,done:!1}:{value:[i.key,i.value],done:!1}:(t.target=void 0,{value:void 0,done:!0})}),i?"entries":"values",!i,!0),function(t){var e=re(t),i=L.f;a&&e&&!e[Cd]&&i(e,Cd,{configurable:!0,get:function(){return this}})}(e)}};Ed("Map",(function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}}),Dd);var Bd=F.Map,Id=function(){function t(){Po(this,t),this.clear(),this._defaultIndex=0,this._groupIndex=0,this._defaultGroups=[{border:"#2B7CE9",background:"#97C2FC",highlight:{border:"#2B7CE9",background:"#D2E5FF"},hover:{border:"#2B7CE9",background:"#D2E5FF"}},{border:"#FFA500",background:"#FFFF00",highlight:{border:"#FFA500",background:"#FFFFA3"},hover:{border:"#FFA500",background:"#FFFFA3"}},{border:"#FA0A10",background:"#FB7E81",highlight:{border:"#FA0A10",background:"#FFAFB1"},hover:{border:"#FA0A10",background:"#FFAFB1"}},{border:"#41A906",background:"#7BE141",highlight:{border:"#41A906",background:"#A1EC76"},hover:{border:"#41A906",background:"#A1EC76"}},{border:"#E129F0",background:"#EB7DF4",highlight:{border:"#E129F0",background:"#F0B3F5"},hover:{border:"#E129F0",background:"#F0B3F5"}},{border:"#7C29F0",background:"#AD85E4",highlight:{border:"#7C29F0",background:"#D3BDF0"},hover:{border:"#7C29F0",background:"#D3BDF0"}},{border:"#C37F00",background:"#FFA807",highlight:{border:"#C37F00",background:"#FFCA66"},hover:{border:"#C37F00",background:"#FFCA66"}},{border:"#4220FB",background:"#6E6EFD",highlight:{border:"#4220FB",background:"#9B9BFD"},hover:{border:"#4220FB",background:"#9B9BFD"}},{border:"#FD5A77",background:"#FFC0CB",highlight:{border:"#FD5A77",background:"#FFD1D9"},hover:{border:"#FD5A77",background:"#FFD1D9"}},{border:"#4AD63A",background:"#C2FABC",highlight:{border:"#4AD63A",background:"#E6FFE3"},hover:{border:"#4AD63A",background:"#E6FFE3"}},{border:"#990000",background:"#EE0000",highlight:{border:"#BB0000",background:"#FF3333"},hover:{border:"#BB0000",background:"#FF3333"}},{border:"#FF6000",background:"#FF6000",highlight:{border:"#FF6000",background:"#FF6000"},hover:{border:"#FF6000",background:"#FF6000"}},{border:"#97C2FC",background:"#2B7CE9",highlight:{border:"#D2E5FF",background:"#2B7CE9"},hover:{border:"#D2E5FF",background:"#2B7CE9"}},{border:"#399605",background:"#255C03",highlight:{border:"#399605",background:"#255C03"},hover:{border:"#399605",background:"#255C03"}},{border:"#B70054",background:"#FF007E",highlight:{border:"#B70054",background:"#FF007E"},hover:{border:"#B70054",background:"#FF007E"}},{border:"#AD85E4",background:"#7C29F0",highlight:{border:"#D3BDF0",background:"#7C29F0"},hover:{border:"#D3BDF0",background:"#7C29F0"}},{border:"#4557FA",background:"#000EA1",highlight:{border:"#6E6EFD",background:"#000EA1"},hover:{border:"#6E6EFD",background:"#000EA1"}},{border:"#FFC0CB",background:"#FD5A77",highlight:{border:"#FFD1D9",background:"#FD5A77"},hover:{border:"#FFD1D9",background:"#FD5A77"}},{border:"#C2FABC",background:"#74D66A",highlight:{border:"#E6FFE3",background:"#74D66A"},hover:{border:"#E6FFE3",background:"#74D66A"}},{border:"#EE0000",background:"#990000",highlight:{border:"#FF3333",background:"#BB0000"},hover:{border:"#FF3333",background:"#BB0000"}}],this.options={},this.defaultOptions={useDefaultGroups:!0},ct(this.options,this.defaultOptions)}return Io(t,[{key:"setOptions",value:function(t){var e=["useDefaultGroups"];if(void 0!==t)for(var i in t)if(Object.prototype.hasOwnProperty.call(t,i)&&-1===Mr(e).call(e,i)){var o=t[i];this.add(i,o)}}},{key:"clear",value:function(){this._groups=new Bd,this._groupNames=[]}},{key:"get",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this._groups.get(t);if(void 0===i&&e)if(!1===this.options.useDefaultGroups&&this._groupNames.length>0){var o=this._groupIndex%this._groupNames.length;++this._groupIndex,(i={}).color=this._groups.get(this._groupNames[o]),this._groups.set(t,i)}else{var n=this._defaultIndex%this._defaultGroups.length;this._defaultIndex++,(i={}).color=this._defaultGroups[n],this._groups.set(t,i)}return i}},{key:"add",value:function(t,e){return this._groups.has(t)||this._groupNames.push(t),this._groups.set(t,e),e}}]),t}();q({target:"Number",stat:!0},{isNaN:function(t){return t!=t}});var zd=F.Number.isNaN,Fd=r.isFinite,Nd=Number.isFinite||function(t){return"number"==typeof t&&Fd(t)};q({target:"Number",stat:!0},{isFinite:Nd});var Ad=F.Number.isFinite,Rd=Wi.some,jd=On("some");q({target:"Array",proto:!0,forced:!jd},{some:function(t){return Rd(this,t,arguments.length>1?arguments[1]:void 0)}});var Ld=gt("Array").some,Hd=Array.prototype,Wd=function(t){var e=t.some;return t===Hd||t instanceof Array&&e===Hd.some?Ld:e},Vd=gr.trim,qd=r.parseFloat,Ud=1/qd(cr+"-0")!=-1/0?function(t){var e=Vd(String(t)),i=qd(e);return 0===i&&"-"==e.charAt(0)?-0:i}:qd;q({global:!0,forced:parseFloat!=Ud},{parseFloat:Ud});var Yd=F.parseFloat,Xd=zi.f,Gd=s((function(){return!Object.getOwnPropertyNames(1)}));q({target:"Object",stat:!0,forced:Gd},{getOwnPropertyNames:Xd});var Kd=F.Object,$d=function(t){return Kd.getOwnPropertyNames(t)};function Qd(t,e){var i=["node","edge","label"],o=!0,n=mh(e,"chosen");if("boolean"==typeof n)o=n;else if("object"===dn(n)){if(-1===Mr(i).call(i,t))throw new Error("choosify: subOption '"+t+"' should be one of '"+i.join("', '")+"'");var r=mh(e,["chosen",t]);"boolean"!=typeof r&&"function"!=typeof r||(o=r)}return o}function Zd(t,e,i){if(t.width<=0||t.height<=0)return!1;if(void 0!==i){var o={x:e.x-i.x,y:e.y-i.y};if(0!==i.angle){var n=-i.angle;e={x:Math.cos(n)*o.x-Math.sin(n)*o.y,y:Math.sin(n)*o.x+Math.cos(n)*o.y}}else e=o}var r=t.x+t.width,s=t.y+t.width;return t.left<e.x&&r>e.x&&t.top<e.y&&s>e.y}function Jd(t){return"string"==typeof t&&""!==t}function tl(t,e,i,o){var n=o.x,r=o.y;if("function"==typeof o.distanceToBorder){var s=o.distanceToBorder(t,e),a=Math.sin(e)*s,h=Math.cos(e)*s;h===s?(n+=s,r=o.y):a===s?(n=o.x,r-=s):(n+=h,r-=a)}else o.shape.width>o.shape.height?(n=o.x+.5*o.shape.width,r=o.y-i):(n=o.x+i,r=o.y-.5*o.shape.height);return{x:n,y:r}}var el=gt("Array").values,il=Array.prototype,ol={DOMTokenList:!0,NodeList:!0},nl=function(t){var e=t.values;return t===il||t instanceof Array&&e===il.values||ol.hasOwnProperty(Ne(t))?el:e},rl=function(){function t(e){Po(this,t),this.measureText=e,this.current=0,this.width=0,this.height=0,this.lines=[]}return Io(t,[{key:"_add",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"normal";void 0===this.lines[t]&&(this.lines[t]={width:0,height:0,blocks:[]});var o=e;void 0!==e&&""!==e||(o=" ");var n=this.measureText(o,i),r=ct({},nl(n));r.text=e,r.width=n.width,r.mod=i,void 0!==e&&""!==e||(r.width=0),this.lines[t].blocks.push(r),this.lines[t].width+=r.width}},{key:"curWidth",value:function(){var t=this.lines[this.current];return void 0===t?0:t.width}},{key:"append",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"normal";this._add(this.current,t,e)}},{key:"newLine",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"normal";this._add(this.current,t,e),this.current++}},{key:"determineLineHeights",value:function(){for(var t=0;t<this.lines.length;t++){var e=this.lines[t],i=0;if(void 0!==e.blocks)for(var o=0;o<e.blocks.length;o++){var n=e.blocks[o];i<n.height&&(i=n.height)}e.height=i}}},{key:"determineLabelSize",value:function(){for(var t=0,e=0,i=0;i<this.lines.length;i++){var o=this.lines[i];o.width>t&&(t=o.width),e+=o.height}this.width=t,this.height=e}},{key:"removeEmptyBlocks",value:function(){for(var t=[],e=0;e<this.lines.length;e++){var i=this.lines[e];if(0!==i.blocks.length&&(e!==this.lines.length-1||0!==i.width)){var o={};ct(o,i),o.blocks=[];for(var n=void 0,r=[],s=0;s<i.blocks.length;s++){var a=i.blocks[s];0!==a.width?r.push(a):void 0===n&&(n=a)}0===r.length&&void 0!==n&&r.push(n),o.blocks=r,t.push(o)}}return t}},{key:"finalize",value:function(){this.determineLineHeights(),this.determineLabelSize();var t=this.removeEmptyBlocks();return{width:this.width,height:this.height,lines:t}}}]),t}(),sl={"<b>":/<b>/,"<i>":/<i>/,"<code>":/<code>/,"</b>":/<\/b>/,"</i>":/<\/i>/,"</code>":/<\/code>/,"*":/\*/,_:/_/,"`":/`/,afterBold:/[^*]/,afterItal:/[^_]/,afterMono:/[^`]/},al=function(){function t(e){Po(this,t),this.text=e,this.bold=!1,this.ital=!1,this.mono=!1,this.spacing=!1,this.position=0,this.buffer="",this.modStack=[],this.blocks=[]}return Io(t,[{key:"mod",value:function(){return 0===this.modStack.length?"normal":this.modStack[0]}},{key:"modName",value:function(){return 0===this.modStack.length?"normal":"mono"===this.modStack[0]?"mono":this.bold&&this.ital?"boldital":this.bold?"bold":this.ital?"ital":void 0}},{key:"emitBlock",value:function(){this.spacing&&(this.add(" "),this.spacing=!1),this.buffer.length>0&&(this.blocks.push({text:this.buffer,mod:this.modName()}),this.buffer="")}},{key:"add",value:function(t){" "===t&&(this.spacing=!0),this.spacing&&(this.buffer+=" ",this.spacing=!1)," "!=t&&(this.buffer+=t)}},{key:"parseWS",value:function(t){return!!/[ \t]/.test(t)&&(this.mono?this.add(t):this.spacing=!0,!0)}},{key:"setTag",value:function(t){this.emitBlock(),this[t]=!0,this.modStack.unshift(t)}},{key:"unsetTag",value:function(t){this.emitBlock(),this[t]=!1,this.modStack.shift()}},{key:"parseStartTag",value:function(t,e){return!(this.mono||this[t]||!this.match(e))&&(this.setTag(t),!0)}},{key:"match",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this.prepareRegExp(t),o=an(i,2),n=o[0],r=o[1],s=n.test(this.text.substr(this.position,r));return s&&e&&(this.position+=r-1),s}},{key:"parseEndTag",value:function(t,e,i){var o=this.mod()===t;return!(!(o="mono"===t?o&&this.mono:o&&!this.mono)||!this.match(e))&&(void 0!==i?(this.position===this.text.length-1||this.match(i,!1))&&this.unsetTag(t):this.unsetTag(t),!0)}},{key:"replace",value:function(t,e){return!!this.match(t)&&(this.add(e),this.position+=length-1,!0)}},{key:"prepareRegExp",value:function(t){var e,i;if(t instanceof RegExp)i=t,e=1;else{var o=sl[t];i=void 0!==o?o:new RegExp(t),e=t.length}return[i,e]}}]),t}(),hl=function(){function t(e,i,o,n){var r=this;Po(this,t),this.ctx=e,this.parent=i,this.selected=o,this.hover=n;this.lines=new rl((function(t,i){if(void 0===t)return 0;var s=r.parent.getFormattingValues(e,o,n,i),a=0;""!==t&&(a=r.ctx.measureText(t).width);return{width:a,values:s}}))}return Io(t,[{key:"process",value:function(t){if(!Jd(t))return this.lines.finalize();var e=this.parent.fontOptions;t=(t=t.replace(/\r\n/g,"\n")).replace(/\r/g,"\n");var i=String(t).split("\n"),o=i.length;if(e.multi)for(var n=0;n<o;n++){var r=this.splitBlocks(i[n],e.multi);if(void 0!==r)if(0!==r.length){if(e.maxWdt>0)for(var s=0;s<r.length;s++){var a=r[s].mod,h=r[s].text;this.splitStringIntoLines(h,a,!0)}else for(var d=0;d<r.length;d++){var l=r[d].mod,c=r[d].text;this.lines.append(c,l)}this.lines.newLine()}else this.lines.newLine("")}else if(e.maxWdt>0)for(var u=0;u<o;u++)this.splitStringIntoLines(i[u]);else for(var f=0;f<o;f++)this.lines.newLine(i[f]);return this.lines.finalize()}},{key:"decodeMarkupSystem",value:function(t){var e="none";return"markdown"===t||"md"===t?e="markdown":!0!==t&&"html"!==t||(e="html"),e}},{key:"splitHtmlBlocks",value:function(t){for(var e=new al(t),i=function(t){return!!/&/.test(t)&&(e.replace(e.text,"&lt;","<")||e.replace(e.text,"&amp;","&")||e.add("&"),!0)};e.position<e.text.length;){var o=e.text.charAt(e.position);e.parseWS(o)||/</.test(o)&&(e.parseStartTag("bold","<b>")||e.parseStartTag("ital","<i>")||e.parseStartTag("mono","<code>")||e.parseEndTag("bold","</b>")||e.parseEndTag("ital","</i>")||e.parseEndTag("mono","</code>"))||i(o)||e.add(o),e.position++}return e.emitBlock(),e.blocks}},{key:"splitMarkdownBlocks",value:function(t){for(var e=this,i=new al(t),o=!0,n=function(t){return!!/\\/.test(t)&&(i.position<e.text.length+1&&(i.position++,t=e.text.charAt(i.position),/ \t/.test(t)?i.spacing=!0:(i.add(t),o=!1)),!0)};i.position<i.text.length;){var r=i.text.charAt(i.position);i.parseWS(r)||n(r)||(o||i.spacing)&&(i.parseStartTag("bold","*")||i.parseStartTag("ital","_")||i.parseStartTag("mono","`"))||i.parseEndTag("bold","*","afterBold")||i.parseEndTag("ital","_","afterItal")||i.parseEndTag("mono","`","afterMono")||(i.add(r),o=!1),i.position++}return i.emitBlock(),i.blocks}},{key:"splitBlocks",value:function(t,e){var i=this.decodeMarkupSystem(e);return"none"===i?[{text:t,mod:"normal"}]:"markdown"===i?this.splitMarkdownBlocks(t):"html"===i?this.splitHtmlBlocks(t):void 0}},{key:"overMaxWidth",value:function(t){var e=this.ctx.measureText(t).width;return this.lines.curWidth()+e>this.parent.fontOptions.maxWdt}},{key:"getLongestFit",value:function(t){for(var e="",i=0;i<t.length;){var o=e+(""===e?"":" ")+t[i];if(this.overMaxWidth(o))break;e=o,i++}return i}},{key:"getLongestFitWord",value:function(t){for(var e=0;e<t.length&&!this.overMaxWidth(vn(t).call(t,0,e));)e++;return e}},{key:"splitStringIntoLines",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"normal",i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.parent.getFormattingValues(this.ctx,this.selected,this.hover,e);for(var o=(t=(t=t.replace(/^( +)/g,"$1\r")).replace(/([^\r][^ ]*)( +)/g,"$1\r$2\r")).split("\r");o.length>0;){var n=this.getLongestFit(o);if(0===n){var r=o[0],s=this.getLongestFitWord(r);this.lines.newLine(vn(r).call(r,0,s),e),o[0]=vn(r).call(r,s)}else{var a=n;" "===o[n-1]?n--:" "===o[a]&&a++;var h=vn(o).call(o,0,n).join("");n==o.length&&i?this.lines.append(h,e):this.lines.newLine(h,e),o=vn(o).call(o,a)}}}}]),t}(),dl=["bold","ital","boldital","mono"],ll=function(){function t(e,i){var o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];Po(this,t),this.body=e,this.pointToSelf=!1,this.baseSize=void 0,this.fontOptions={},this.setOptions(i),this.size={top:0,left:0,width:0,height:0,yLine:0},this.isEdgeLabel=o}return Io(t,[{key:"setOptions",value:function(t){if(this.elementOptions=t,this.initFontOptions(t.font),Jd(t.label)?this.labelDirty=!0:t.label=void 0,void 0!==t.font&&null!==t.font)if("string"==typeof t.font)this.baseSize=this.fontOptions.size;else if("object"===dn(t.font)){var e=t.font.size;void 0!==e&&(this.baseSize=e)}}},{key:"initFontOptions",value:function(e){var i=this;nh(dl,(function(t){i.fontOptions[t]={}})),t.parseFontString(this.fontOptions,e)?this.fontOptions.vadjust=0:nh(e,(function(t,e){null!=t&&"object"!==dn(t)&&(i.fontOptions[e]=t)}))}},{key:"constrain",value:function(t){var e={constrainWidth:!1,maxWdt:-1,minWdt:-1,constrainHeight:!1,minHgt:-1,valign:"middle"},i=mh(t,"widthConstraint");if("number"==typeof i)e.maxWdt=Number(i),e.minWdt=Number(i);else if("object"===dn(i)){var o=mh(t,["widthConstraint","maximum"]);"number"==typeof o&&(e.maxWdt=Number(o));var n=mh(t,["widthConstraint","minimum"]);"number"==typeof n&&(e.minWdt=Number(n))}var r=mh(t,"heightConstraint");if("number"==typeof r)e.minHgt=Number(r);else if("object"===dn(r)){var s=mh(t,["heightConstraint","minimum"]);"number"==typeof s&&(e.minHgt=Number(s));var a=mh(t,["heightConstraint","valign"]);"string"==typeof a&&("top"!==a&&"bottom"!==a||(e.valign=a))}return e}},{key:"update",value:function(t,e){this.setOptions(t,!0),this.propagateFonts(e),th(this.fontOptions,this.constrain(e)),this.fontOptions.chooser=Qd("label",e)}},{key:"adjustSizes",value:function(t){var e=t?t.right+t.left:0;this.fontOptions.constrainWidth&&(this.fontOptions.maxWdt-=e,this.fontOptions.minWdt-=e);var i=t?t.top+t.bottom:0;this.fontOptions.constrainHeight&&(this.fontOptions.minHgt-=i)}},{key:"addFontOptionsToPile",value:function(t,e){for(var i=0;i<e.length;++i)this.addFontToPile(t,e[i])}},{key:"addFontToPile",value:function(t,e){if(void 0!==e&&void 0!==e.font&&null!==e.font){var i=e.font;t.push(i)}}},{key:"getBasicOptions",value:function(e){for(var i={},o=0;o<e.length;++o){var n=e[o],r={};t.parseFontString(r,n)&&(n=r),nh(n,(function(t,e){void 0!==t&&(Object.prototype.hasOwnProperty.call(i,e)||(-1!==Mr(dl).call(dl,e)?i[e]={}:i[e]=t))}))}return i}},{key:"getFontOption",value:function(e,i,o){for(var n,r=0;r<e.length;++r){var s=e[r];if(Object.prototype.hasOwnProperty.call(s,i)){if(null==(n=s[i]))continue;var a={};if(t.parseFontString(a,n)&&(n=a),Object.prototype.hasOwnProperty.call(n,o))return n[o]}}if(Object.prototype.hasOwnProperty.call(this.fontOptions,o))return this.fontOptions[o];throw new Error("Did not find value for multi-font for property: '"+o+"'")}},{key:"getFontOptions",value:function(t,e){for(var i={},o=["color","size","face","mod","vadjust"],n=0;n<o.length;++n){var r=o[n];i[r]=this.getFontOption(t,e,r)}return i}},{key:"propagateFonts",value:function(t){var e=this,i=[];this.addFontOptionsToPile(i,t),this.fontOptions=this.getBasicOptions(i);for(var o=function(t){var o=dl[t],n=e.fontOptions[o];nh(e.getFontOptions(i,o),(function(t,e){n[e]=t})),n.size=Number(n.size),n.vadjust=Number(n.vadjust)},n=0;n<dl.length;++n)o(n)}},{key:"draw",value:function(t,e,i,o,n){var r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"middle";if(void 0!==this.elementOptions.label){var s=this.fontOptions.size*this.body.view.scale;this.elementOptions.label&&s<this.elementOptions.scaling.label.drawThreshold-1||(s>=this.elementOptions.scaling.label.maxVisible&&(s=Number(this.elementOptions.scaling.label.maxVisible)/this.body.view.scale),this.calculateLabelSize(t,o,n,e,i,r),this._drawBackground(t),this._drawText(t,e,this.size.yLine,r,s))}}},{key:"_drawBackground",value:function(t){if(void 0!==this.fontOptions.background&&"none"!==this.fontOptions.background){t.fillStyle=this.fontOptions.background;var e=this.getSize();t.fillRect(e.left,e.top,e.width,e.height)}}},{key:"_drawText",value:function(t,e,i){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"middle",n=arguments.length>4?arguments[4]:void 0,r=this._setAlignment(t,e,i,o),s=an(r,2);e=s[0],i=s[1],t.textAlign="left",e-=this.size.width/2,this.fontOptions.valign&&this.size.height>this.size.labelHeight&&("top"===this.fontOptions.valign&&(i-=(this.size.height-this.size.labelHeight)/2),"bottom"===this.fontOptions.valign&&(i+=(this.size.height-this.size.labelHeight)/2));for(var a=0;a<this.lineCount;a++){var h=this.lines[a];if(h&&h.blocks){var d=0;this.isEdgeLabel||"center"===this.fontOptions.align?d+=(this.size.width-h.width)/2:"right"===this.fontOptions.align&&(d+=this.size.width-h.width);for(var l=0;l<h.blocks.length;l++){var c=h.blocks[l];t.font=c.font;var u=this._getColor(c.color,n,c.strokeColor),f=an(u,2),p=f[0],v=f[1];c.strokeWidth>0&&(t.lineWidth=c.strokeWidth,t.strokeStyle=v,t.lineJoin="round"),t.fillStyle=p,c.strokeWidth>0&&t.strokeText(c.text,e+d,i+c.vadjust),t.fillText(c.text,e+d,i+c.vadjust),d+=c.width}i+=h.height}}}},{key:"_setAlignment",value:function(t,e,i,o){if(this.isEdgeLabel&&"horizontal"!==this.fontOptions.align&&!1===this.pointToSelf){e=0,i=0;"top"===this.fontOptions.align?(t.textBaseline="alphabetic",i-=4):"bottom"===this.fontOptions.align?(t.textBaseline="hanging",i+=4):t.textBaseline="middle"}else t.textBaseline=o;return[e,i]}},{key:"_getColor",value:function(t,e,i){var o=t||"#000000",n=i||"#ffffff";if(e<=this.elementOptions.scaling.label.drawThreshold){var r=Math.max(0,Math.min(1,1-(this.elementOptions.scaling.label.drawThreshold-e)));o=sh(o,r),n=sh(n,r)}return[o,n]}},{key:"getTextSize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return this._processLabel(t,e,i),{width:this.size.width,height:this.size.height,lineCount:this.lineCount}}},{key:"getSize",value:function(){var t=this.size.left,e=this.size.top-1;if(this.isEdgeLabel){var i=.5*-this.size.width;switch(this.fontOptions.align){case"middle":t=i,e=.5*-this.size.height;break;case"top":t=i,e=-(this.size.height+2);break;case"bottom":t=i,e=2}}return{left:t,top:e,width:this.size.width,height:this.size.height}}},{key:"calculateLabelSize",value:function(t,e,i){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"middle";this._processLabel(t,e,i),this.size.left=o-.5*this.size.width,this.size.top=n-.5*this.size.height,this.size.yLine=n+.5*(1-this.lineCount)*this.fontOptions.size,"hanging"===r&&(this.size.top+=.5*this.fontOptions.size,this.size.top+=4,this.size.yLine+=4)}},{key:"getFormattingValues",value:function(t,e,i,o){var n=function(t,e,i){return"normal"===e?"mod"===i?"":t[i]:void 0!==t[e][i]?t[e][i]:t[i]},r={color:n(this.fontOptions,o,"color"),size:n(this.fontOptions,o,"size"),face:n(this.fontOptions,o,"face"),mod:n(this.fontOptions,o,"mod"),vadjust:n(this.fontOptions,o,"vadjust"),strokeWidth:this.fontOptions.strokeWidth,strokeColor:this.fontOptions.strokeColor};(e||i)&&("normal"===o&&!0===this.fontOptions.chooser&&this.elementOptions.labelHighlightBold?r.mod="bold":"function"==typeof this.fontOptions.chooser&&this.fontOptions.chooser(r,this.elementOptions.id,e,i));var s="";return void 0!==r.mod&&""!==r.mod&&(s+=r.mod+" "),s+=r.size+"px "+r.face,t.font=s.replace(/"/g,""),r.font=t.font,r.height=r.size,r}},{key:"differentState",value:function(t,e){return t!==this.selectedState||e!==this.hoverState}},{key:"_processLabelText",value:function(t,e,i,o){return new hl(t,this,e,i).process(o)}},{key:"_processLabel",value:function(t,e,i){if(!1!==this.labelDirty||this.differentState(e,i)){var o=this._processLabelText(t,e,i,this.elementOptions.label);this.fontOptions.minWdt>0&&o.width<this.fontOptions.minWdt&&(o.width=this.fontOptions.minWdt),this.size.labelHeight=o.height,this.fontOptions.minHgt>0&&o.height<this.fontOptions.minHgt&&(o.height=this.fontOptions.minHgt),this.lines=o.lines,this.lineCount=o.lines.length,this.size.width=o.width,this.size.height=o.height,this.selectedState=e,this.hoverState=i,this.labelDirty=!1}}},{key:"visible",value:function(){return 0!==this.size.width&&0!==this.size.height&&void 0!==this.elementOptions.label&&!(this.fontOptions.size*this.body.view.scale<this.elementOptions.scaling.label.drawThreshold-1)}}],[{key:"parseFontString",value:function(t,e){if(!e||"string"!=typeof e)return!1;var i=e.split(" ");return t.size=+i[0].replace("px",""),t.face=i[1],t.color=i[2],!0}}]),t}(),cl=re("Reflect","construct"),ul=s((function(){function t(){}return!(cl((function(){}),[],t)instanceof t)})),fl=!s((function(){cl((function(){}))})),pl=ul||fl;q({target:"Reflect",stat:!0,forced:pl,sham:pl},{construct:function(t,e){N(t),R(e);var i=arguments.length<3?t:N(arguments[2]);if(fl&&!ul)return cl(t,e,i);if(t==i){switch(e.length){case 0:return new t;case 1:return new t(e[0]);case 2:return new t(e[0],e[1]);case 3:return new t(e[0],e[1],e[2]);case 4:return new t(e[0],e[1],e[2],e[3])}var o=[null];return o.push.apply(o,e),new(vt.apply(t,o))}var n=i.prototype,r=De(m(n)?n:Object.prototype),s=Function.apply.call(t,r,e);return m(s)?s:r}});var vl=F.Reflect.construct,gl=Br;q({target:"Object",stat:!0},{setPrototypeOf:qe});var yl=F.Object.setPrototypeOf;function ml(t,e){return(ml=yl||function(t,e){return t.__proto__=e,t})(t,e)}function bl(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=gl(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&ml(t,e)}function wl(t,e){return!e||"object"!==dn(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}var kl=er;function _l(t){return(_l=yl?kl:function(t){return t.__proto__||kl(t)})(t)}var xl=function(){function t(e,i,o){Po(this,t),this.body=i,this.labelModule=o,this.setOptions(e),this.top=void 0,this.left=void 0,this.height=void 0,this.width=void 0,this.radius=void 0,this.margin=void 0,this.refreshNeeded=!0,this.boundingBox={top:0,left:0,right:0,bottom:0}}return Io(t,[{key:"setOptions",value:function(t){this.options=t}},{key:"_setMargins",value:function(t){this.margin={},this.options.margin&&("object"==dn(this.options.margin)?(this.margin.top=this.options.margin.top,this.margin.right=this.options.margin.right,this.margin.bottom=this.options.margin.bottom,this.margin.left=this.options.margin.left):(this.margin.top=this.options.margin,this.margin.right=this.options.margin,this.margin.bottom=this.options.margin,this.margin.left=this.options.margin)),t.adjustSizes(this.margin)}},{key:"_distanceToBorder",value:function(t,e){var i=this.options.borderWidth;return t&&this.resize(t),Math.min(Math.abs(this.width/2/Math.cos(e)),Math.abs(this.height/2/Math.sin(e)))+i}},{key:"enableShadow",value:function(t,e){e.shadow&&(t.shadowColor=e.shadowColor,t.shadowBlur=e.shadowSize,t.shadowOffsetX=e.shadowX,t.shadowOffsetY=e.shadowY)}},{key:"disableShadow",value:function(t,e){e.shadow&&(t.shadowColor="rgba(0,0,0,0)",t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0)}},{key:"enableBorderDashes",value:function(t,e){if(!1!==e.borderDashes)if(void 0!==t.setLineDash){var i=e.borderDashes;!0===i&&(i=[5,15]),t.setLineDash(i)}else console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used."),this.options.shapeProperties.borderDashes=!1,e.borderDashes=!1}},{key:"disableBorderDashes",value:function(t,e){!1!==e.borderDashes&&(void 0!==t.setLineDash?t.setLineDash([0]):(console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used."),this.options.shapeProperties.borderDashes=!1,e.borderDashes=!1))}},{key:"needsRefresh",value:function(t,e){return!0===this.refreshNeeded?(this.refreshNeeded=!1,!0):void 0===this.width||this.labelModule.differentState(t,e)}},{key:"initContextForDraw",value:function(t,e){var i=e.borderWidth/this.body.view.scale;t.lineWidth=Math.min(this.width,i),t.strokeStyle=e.borderColor,t.fillStyle=e.color}},{key:"performStroke",value:function(t,e){var i=e.borderWidth/this.body.view.scale;t.save(),i>0&&(this.enableBorderDashes(t,e),t.stroke(),this.disableBorderDashes(t,e)),t.restore()}},{key:"performFill",value:function(t,e){t.save(),t.fillStyle=e.color,this.enableShadow(t,e),Xr(t).call(t),this.disableShadow(t,e),t.restore(),this.performStroke(t,e)}},{key:"_addBoundingBoxMargin",value:function(t){this.boundingBox.left-=t,this.boundingBox.top-=t,this.boundingBox.bottom+=t,this.boundingBox.right+=t}},{key:"_updateBoundingBox",value:function(t,e,i,o,n){void 0!==i&&this.resize(i,o,n),this.left=t-this.width/2,this.top=e-this.height/2,this.boundingBox.left=this.left,this.boundingBox.top=this.top,this.boundingBox.bottom=this.top+this.height,this.boundingBox.right=this.left+this.width}},{key:"updateBoundingBox",value:function(t,e,i,o,n){this._updateBoundingBox(t,e,i,o,n)}},{key:"getDimensionsFromLabel",value:function(t,e,i){this.textSize=this.labelModule.getTextSize(t,e,i);var o=this.textSize.width,n=this.textSize.height;return 0===o&&(o=14,n=14),{width:o,height:n}}}]),t}();function El(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Ol=function(t){bl(i,t);var e=El(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n))._setMargins(n),r}return Io(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover;if(this.needsRefresh(e,i)){var o=this.getDimensionsFromLabel(t,e,i);this.width=o.width+this.margin.right+this.margin.left,this.height=o.height+this.margin.top+this.margin.bottom,this.radius=this.width/2}}},{key:"draw",value:function(t,e,i,o,n,r){this.resize(t,o,n),this.left=e-this.width/2,this.top=i-this.height/2,this.initContextForDraw(t,r),kt(t,this.left,this.top,this.width,this.height,r.borderRadius),this.performFill(t,r),this.updateBoundingBox(e,i,t,o,n),this.labelModule.draw(t,this.left+this.textSize.width/2+this.margin.left,this.top+this.textSize.height/2+this.margin.top,o,n)}},{key:"updateBoundingBox",value:function(t,e,i,o,n){this._updateBoundingBox(t,e,i,o,n);var r=this.options.shapeProperties.borderRadius;this._addBoundingBoxMargin(r)}},{key:"distanceToBorder",value:function(t,e){t&&this.resize(t);var i=this.options.borderWidth;return Math.min(Math.abs(this.width/2/Math.cos(e)),Math.abs(this.height/2/Math.sin(e)))+i}}]),i}(xl);function Cl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Sl=function(t){bl(i,t);var e=Cl(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n)).labelOffset=0,r.selected=!1,r}return Io(i,[{key:"setOptions",value:function(t,e,i){this.options=t,void 0===e&&void 0===i||this.setImages(e,i)}},{key:"setImages",value:function(t,e){e&&this.selected?(this.imageObj=e,this.imageObjAlt=t):(this.imageObj=t,this.imageObjAlt=e)}},{key:"switchImages",value:function(t){var e=t&&!this.selected||!t&&this.selected;if(this.selected=t,void 0!==this.imageObjAlt&&e){var i=this.imageObj;this.imageObj=this.imageObjAlt,this.imageObjAlt=i}}},{key:"_getImagePadding",value:function(){var t={top:0,right:0,bottom:0,left:0};if(this.options.imagePadding){var e=this.options.imagePadding;"object"==dn(e)?(t.top=e.top,t.right=e.right,t.bottom=e.bottom,t.left=e.left):(t.top=e,t.right=e,t.bottom=e,t.left=e)}return t}},{key:"_resizeImage",value:function(){var t,e;if(!1===this.options.shapeProperties.useImageSize){var i=1,o=1;this.imageObj.width&&this.imageObj.height&&(this.imageObj.width>this.imageObj.height?i=this.imageObj.width/this.imageObj.height:o=this.imageObj.height/this.imageObj.width),t=2*this.options.size*i,e=2*this.options.size*o}else{var n=this._getImagePadding();t=this.imageObj.width+n.left+n.right,e=this.imageObj.height+n.top+n.bottom}this.width=t,this.height=e,this.radius=.5*this.width}},{key:"_drawRawCircle",value:function(t,e,i,o){this.initContextForDraw(t,o),wt(t,e,i,o.size),this.performFill(t,o)}},{key:"_drawImageAtPosition",value:function(t,e){if(0!=this.imageObj.width){t.globalAlpha=void 0!==e.opacity?e.opacity:1,this.enableShadow(t,e);var i=1;!0===this.options.shapeProperties.interpolation&&(i=this.imageObj.width/this.width/this.body.view.scale);var o=this._getImagePadding(),n=this.left+o.left,r=this.top+o.top,s=this.width-o.left-o.right,a=this.height-o.top-o.bottom;this.imageObj.drawImageAtPosition(t,i,n,r,s,a),this.disableShadow(t,e)}}},{key:"_drawImageLabel",value:function(t,e,i,o,n){var r=0;if(void 0!==this.height){r=.5*this.height;var s=this.labelModule.getTextSize(t,o,n);s.lineCount>=1&&(r+=s.height/2)}var a=i+r;this.options.label&&(this.labelOffset=r),this.labelModule.draw(t,e,a,o,n,"hanging")}}]),i}(xl);function Tl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Ml=function(t){bl(i,t);var e=Tl(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n))._setMargins(n),r}return Io(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover;if(this.needsRefresh(e,i)){var o=this.getDimensionsFromLabel(t,e,i),n=Math.max(o.width+this.margin.right+this.margin.left,o.height+this.margin.top+this.margin.bottom);this.options.size=n/2,this.width=n,this.height=n,this.radius=this.width/2}}},{key:"draw",value:function(t,e,i,o,n,r){this.resize(t,o,n),this.left=e-this.width/2,this.top=i-this.height/2,this._drawRawCircle(t,e,i,r),this.updateBoundingBox(e,i),this.labelModule.draw(t,this.left+this.textSize.width/2+this.margin.left,i,o,n)}},{key:"updateBoundingBox",value:function(t,e){this.boundingBox.top=e-this.options.size,this.boundingBox.left=t-this.options.size,this.boundingBox.right=t+this.options.size,this.boundingBox.bottom=e+this.options.size}},{key:"distanceToBorder",value:function(t){return t&&this.resize(t),.5*this.width}}]),i}(Sl);function Pl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Dl=function(t){bl(i,t);var e=Pl(i);function i(t,o,n,r,s){var a;return Po(this,i),(a=e.call(this,t,o,n)).setImages(r,s),a}return Io(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover,o=void 0===this.imageObj.src||void 0===this.imageObj.width||void 0===this.imageObj.height;if(o){var n=2*this.options.size;return this.width=n,this.height=n,void(this.radius=.5*this.width)}this.needsRefresh(e,i)&&this._resizeImage()}},{key:"draw",value:function(t,e,i,o,n,r){this.switchImages(o),this.resize();var s=e,a=i;"top-left"===this.options.shapeProperties.coordinateOrigin?(this.left=e,this.top=i,s+=this.width/2,a+=this.height/2):(this.left=e-this.width/2,this.top=i-this.height/2),this._drawRawCircle(t,s,a,r),t.save(),t.clip(),this._drawImageAtPosition(t,r),t.restore(),this._drawImageLabel(t,s,a,o,n),this.updateBoundingBox(e,i)}},{key:"updateBoundingBox",value:function(t,e){"top-left"===this.options.shapeProperties.coordinateOrigin?(this.boundingBox.top=e,this.boundingBox.left=t,this.boundingBox.right=t+2*this.options.size,this.boundingBox.bottom=e+2*this.options.size):(this.boundingBox.top=e-this.options.size,this.boundingBox.left=t-this.options.size,this.boundingBox.right=t+this.options.size,this.boundingBox.bottom=e+this.options.size),this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left),this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width),this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelOffset)}},{key:"distanceToBorder",value:function(t){return t&&this.resize(t),.5*this.width}}]),i}(Sl);function Bl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Il=function(t){bl(i,t);var e=Bl(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{size:this.options.size};if(this.needsRefresh(e,i)){var n,r;this.labelModule.getTextSize(t,e,i);var s=2*o.size;this.width=null!==(n=this.customSizeWidth)&&void 0!==n?n:s,this.height=null!==(r=this.customSizeHeight)&&void 0!==r?r:s,this.radius=.5*this.width}}},{key:"_drawShape",value:function(t,e,i,o,n,r,s,a){var h,d=this;return this.resize(t,r,s,a),this.left=o-this.width/2,this.top=n-this.height/2,this.initContextForDraw(t,a),(h=e,Object.prototype.hasOwnProperty.call(Ot,h)?Ot[h]:function(t){for(var e=arguments.length,i=new Array(e>1?e-1:0),o=1;o<e;o++)i[o-1]=arguments[o];CanvasRenderingContext2D.prototype[h].call(t,i)})(t,o,n,a.size),this.performFill(t,a),void 0!==this.options.icon&&void 0!==this.options.icon.code&&(t.font=(r?"bold ":"")+this.height/2+"px "+(this.options.icon.face||"FontAwesome"),t.fillStyle=this.options.icon.color||"black",t.textAlign="center",t.textBaseline="middle",t.fillText(this.options.icon.code,o,n)),{drawExternalLabel:function(){if(void 0!==d.options.label){d.labelModule.calculateLabelSize(t,r,s,o,n,"hanging");var e=n+.5*d.height+.5*d.labelModule.size.height;d.labelModule.draw(t,o,e,r,s,"hanging")}d.updateBoundingBox(o,n)}}}},{key:"updateBoundingBox",value:function(t,e){this.boundingBox.top=e-this.options.size,this.boundingBox.left=t-this.options.size,this.boundingBox.right=t+this.options.size,this.boundingBox.bottom=e+this.options.size,void 0!==this.options.label&&this.labelModule.size.width>0&&(this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left),this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width),this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelModule.size.height))}}]),i}(xl);function zl(t,e){var i=xn(t);if(wo){var o=wo(t);e&&(o=ar(o).call(o,(function(e){return Eo(t,e).enumerable}))),i.push.apply(i,o)}return i}function Fl(t){for(var e=1;e<arguments.length;e++){var i,o=null!=arguments[e]?arguments[e]:{};if(e%2)Dn(i=zl(Object(o),!0)).call(i,(function(e){zo(t,e,o[e])}));else if(Co)So(t,Co(o));else{var n;Dn(n=zl(Object(o))).call(n,(function(e){Mo(t,e,Eo(o,e))}))}}return t}function Nl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Al=function(t){bl(i,t);var e=Nl(i);function i(t,o,n,r){var s;return Po(this,i),(s=e.call(this,t,o,n,r)).ctxRenderer=r,s}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){this.resize(t,o,n,r),this.left=e-this.width/2,this.top=i-this.height/2,t.save();var s=this.ctxRenderer({ctx:t,id:this.options.id,x:e,y:i,state:{selected:o,hover:n},style:Fl({},r),label:this.options.label});if(null!=s.drawNode&&s.drawNode(),t.restore(),s.drawExternalLabel){var a=s.drawExternalLabel;s.drawExternalLabel=function(){t.save(),a(),t.restore()}}return s.nodeDimensions&&(this.customSizeWidth=s.nodeDimensions.width,this.customSizeHeight=s.nodeDimensions.height),s}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Il);function Rl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var jl=function(t){bl(i,t);var e=Rl(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n))._setMargins(n),r}return Io(i,[{key:"resize",value:function(t,e,i){if(this.needsRefresh(e,i)){var o=this.getDimensionsFromLabel(t,e,i).width+this.margin.right+this.margin.left;this.width=o,this.height=o,this.radius=this.width/2}}},{key:"draw",value:function(t,e,i,o,n,r){this.resize(t,o,n),this.left=e-this.width/2,this.top=i-this.height/2,this.initContextForDraw(t,r),xt(t,e-this.width/2,i-this.height/2,this.width,this.height),this.performFill(t,r),this.updateBoundingBox(e,i,t,o,n),this.labelModule.draw(t,this.left+this.textSize.width/2+this.margin.left,this.top+this.textSize.height/2+this.margin.top,o,n)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(xl);function Ll(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Hl=function(t){bl(i,t);var e=Ll(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){return this._drawShape(t,"diamond",4,e,i,o,n,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Il);function Wl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Vl=function(t){bl(i,t);var e=Wl(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){return this._drawShape(t,"circle",2,e,i,o,n,r)}},{key:"distanceToBorder",value:function(t){return t&&this.resize(t),this.options.size}}]),i}(Il);function ql(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Ul=function(t){bl(i,t);var e=ql(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover;if(this.needsRefresh(e,i)){var o=this.getDimensionsFromLabel(t,e,i);this.height=2*o.height,this.width=o.width+o.height,this.radius=.5*this.width}}},{key:"draw",value:function(t,e,i,o,n,r){this.resize(t,o,n),this.left=e-.5*this.width,this.top=i-.5*this.height,this.initContextForDraw(t,r),_t(t,this.left,this.top,this.width,this.height),this.performFill(t,r),this.updateBoundingBox(e,i,t,o,n),this.labelModule.draw(t,e,i,o,n)}},{key:"distanceToBorder",value:function(t,e){t&&this.resize(t);var i=.5*this.width,o=.5*this.height,n=Math.sin(e)*i,r=Math.cos(e)*o;return i*o/Math.sqrt(n*n+r*r)}}]),i}(xl);function Yl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Xl=function(t){bl(i,t);var e=Yl(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n))._setMargins(n),r}return Io(i,[{key:"resize",value:function(t,e,i){this.needsRefresh(e,i)&&(this.iconSize={width:Number(this.options.icon.size),height:Number(this.options.icon.size)},this.width=this.iconSize.width+this.margin.right+this.margin.left,this.height=this.iconSize.height+this.margin.top+this.margin.bottom,this.radius=.5*this.width)}},{key:"draw",value:function(t,e,i,o,n,r){var s=this;return this.resize(t,o,n),this.options.icon.size=this.options.icon.size||50,this.left=e-this.width/2,this.top=i-this.height/2,this._icon(t,e,i,o,n,r),{drawExternalLabel:function(){if(void 0!==s.options.label){s.labelModule.draw(t,s.left+s.iconSize.width/2+s.margin.left,i+s.height/2+5,o)}s.updateBoundingBox(e,i)}}}},{key:"updateBoundingBox",value:function(t,e){if(this.boundingBox.top=e-.5*this.options.icon.size,this.boundingBox.left=t-.5*this.options.icon.size,this.boundingBox.right=t+.5*this.options.icon.size,this.boundingBox.bottom=e+.5*this.options.icon.size,void 0!==this.options.label&&this.labelModule.size.width>0){this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left),this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width),this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelModule.size.height+5)}}},{key:"_icon",value:function(t,e,i,o,n,r){var s=Number(this.options.icon.size);void 0!==this.options.icon.code?(t.font=[null!=this.options.icon.weight?this.options.icon.weight:o?"bold":"",(null!=this.options.icon.weight&&o?5:0)+s+"px",this.options.icon.face].join(" "),t.fillStyle=this.options.icon.color||"black",t.textAlign="center",t.textBaseline="middle",this.enableShadow(t,r),t.fillText(this.options.icon.code,e,i),this.disableShadow(t,r)):console.error("When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.")}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(xl);function Gl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Kl=function(t){bl(i,t);var e=Gl(i);function i(t,o,n,r,s){var a;return Po(this,i),(a=e.call(this,t,o,n)).setImages(r,s),a}return Io(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover,o=void 0===this.imageObj.src||void 0===this.imageObj.width||void 0===this.imageObj.height;if(o){var n=2*this.options.size;return this.width=n,void(this.height=n)}this.needsRefresh(e,i)&&this._resizeImage()}},{key:"draw",value:function(t,e,i,o,n,r){t.save(),this.switchImages(o),this.resize();var s=e,a=i;if("top-left"===this.options.shapeProperties.coordinateOrigin?(this.left=e,this.top=i,s+=this.width/2,a+=this.height/2):(this.left=e-this.width/2,this.top=i-this.height/2),!0===this.options.shapeProperties.useBorderWithImage){var h=this.options.borderWidth,d=this.options.borderWidthSelected||2*this.options.borderWidth,l=(o?d:h)/this.body.view.scale;t.lineWidth=Math.min(this.width,l),t.beginPath();var c=o?this.options.color.highlight.border:n?this.options.color.hover.border:this.options.color.border,u=o?this.options.color.highlight.background:n?this.options.color.hover.background:this.options.color.background;void 0!==r.opacity&&(c=sh(c,r.opacity),u=sh(u,r.opacity)),t.strokeStyle=c,t.fillStyle=u,t.rect(this.left-.5*t.lineWidth,this.top-.5*t.lineWidth,this.width+t.lineWidth,this.height+t.lineWidth),Xr(t).call(t),this.performStroke(t,r),t.closePath()}this._drawImageAtPosition(t,r),this._drawImageLabel(t,s,a,o,n),this.updateBoundingBox(e,i),t.restore()}},{key:"updateBoundingBox",value:function(t,e){this.resize(),"top-left"===this.options.shapeProperties.coordinateOrigin?(this.left=t,this.top=e):(this.left=t-this.width/2,this.top=e-this.height/2),this.boundingBox.left=this.left,this.boundingBox.top=this.top,this.boundingBox.bottom=this.top+this.height,this.boundingBox.right=this.left+this.width,void 0!==this.options.label&&this.labelModule.size.width>0&&(this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left),this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width),this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelOffset))}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Sl);function $l(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Ql=function(t){bl(i,t);var e=$l(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){return this._drawShape(t,"square",2,e,i,o,n,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Il);function Zl(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Jl=function(t){bl(i,t);var e=Zl(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){return this._drawShape(t,"hexagon",4,e,i,o,n,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Il);function tc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var ec=function(t){bl(i,t);var e=tc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){return this._drawShape(t,"star",4,e,i,o,n,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Il);function ic(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var oc=function(t){bl(i,t);var e=ic(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n))._setMargins(n),r}return Io(i,[{key:"resize",value:function(t,e,i){this.needsRefresh(e,i)&&(this.textSize=this.labelModule.getTextSize(t,e,i),this.width=this.textSize.width+this.margin.right+this.margin.left,this.height=this.textSize.height+this.margin.top+this.margin.bottom,this.radius=.5*this.width)}},{key:"draw",value:function(t,e,i,o,n,r){this.resize(t,o,n),this.left=e-this.width/2,this.top=i-this.height/2,this.enableShadow(t,r),this.labelModule.draw(t,this.left+this.textSize.width/2+this.margin.left,this.top+this.textSize.height/2+this.margin.top,o,n),this.disableShadow(t,r),this.updateBoundingBox(e,i,t,o,n)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(xl);function nc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var rc=function(t){bl(i,t);var e=nc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){return this._drawShape(t,"triangle",3,e,i,o,n,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Il);function sc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var ac=function(t){bl(i,t);var e=sc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"draw",value:function(t,e,i,o,n,r){return this._drawShape(t,"triangleDown",3,e,i,o,n,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(Il);function hc(t,e){var i=xn(t);if(wo){var o=wo(t);e&&(o=ar(o).call(o,(function(e){return Eo(t,e).enumerable}))),i.push.apply(i,o)}return i}function dc(t){for(var e=1;e<arguments.length;e++){var i,o=null!=arguments[e]?arguments[e]:{};if(e%2)Dn(i=hc(Object(o),!0)).call(i,(function(e){zo(t,e,o[e])}));else if(Co)So(t,Co(o));else{var n;Dn(n=hc(Object(o))).call(n,(function(e){Mo(t,e,Eo(o,e))}))}}return t}var lc=function(){function t(e,i,o,n,r,s){Po(this,t),this.options=vh(r),this.globalOptions=r,this.defaultOptions=s,this.body=i,this.edges=[],this.id=void 0,this.imagelist=o,this.grouplist=n,this.x=void 0,this.y=void 0,this.baseSize=this.options.size,this.baseFontSize=this.options.font.size,this.predefinedPosition=!1,this.selected=!1,this.hover=!1,this.labelModule=new ll(this.body,this.options,!1),this.setOptions(e)}return Io(t,[{key:"attachEdge",value:function(t){var e;-1===Mr(e=this.edges).call(e,t)&&this.edges.push(t)}},{key:"detachEdge",value:function(t){var e,i,o=Mr(e=this.edges).call(e,t);-1!=o&&qn(i=this.edges).call(i,o,1)}},{key:"setOptions",value:function(e){var i=this.options.shape;if(e){if(void 0!==e.color&&(this._localColor=e.color),void 0!==e.id&&(this.id=e.id),void 0===this.id)throw new Error("Node must have an id");t.checkMass(e,this.id),void 0!==e.x&&(null===e.x?(this.x=void 0,this.predefinedPosition=!1):(this.x=kr(e.x),this.predefinedPosition=!0)),void 0!==e.y&&(null===e.y?(this.y=void 0,this.predefinedPosition=!1):(this.y=kr(e.y),this.predefinedPosition=!0)),void 0!==e.size&&(this.baseSize=e.size),void 0!==e.value&&(e.value=Yd(e.value)),t.parseOptions(this.options,e,!0,this.globalOptions,this.grouplist);var o=[e,this.options,this.defaultOptions];return this.chooser=Qd("node",o),this._load_images(),this.updateLabelModule(e),void 0!==e.opacity&&t.checkOpacity(e.opacity)&&(this.options.opacity=e.opacity),this.updateShape(i),void 0!==e.hidden||void 0!==e.physics}}},{key:"_load_images",value:function(){if(("circularImage"===this.options.shape||"image"===this.options.shape)&&void 0===this.options.image)throw new Error("Option image must be defined for node type '"+this.options.shape+"'");if(void 0!==this.options.image){if(void 0===this.imagelist)throw new Error("Internal Error: No images provided");if("string"==typeof this.options.image)this.imageObj=this.imagelist.load(this.options.image,this.options.brokenImage,this.id);else{if(void 0===this.options.image.unselected)throw new Error("No unselected image provided");this.imageObj=this.imagelist.load(this.options.image.unselected,this.options.brokenImage,this.id),void 0!==this.options.image.selected?this.imageObjAlt=this.imagelist.load(this.options.image.selected,this.options.brokenImage,this.id):this.imageObjAlt=void 0}}}},{key:"getFormattingValues",value:function(){var t={color:this.options.color.background,opacity:this.options.opacity,borderWidth:this.options.borderWidth,borderColor:this.options.color.border,size:this.options.size,borderDashes:this.options.shapeProperties.borderDashes,borderRadius:this.options.shapeProperties.borderRadius,shadow:this.options.shadow.enabled,shadowColor:this.options.shadow.color,shadowSize:this.options.shadow.size,shadowX:this.options.shadow.x,shadowY:this.options.shadow.y};if(this.selected||this.hover?!0===this.chooser?this.selected?(null!=this.options.borderWidthSelected?t.borderWidth=this.options.borderWidthSelected:t.borderWidth*=2,t.color=this.options.color.highlight.background,t.borderColor=this.options.color.highlight.border,t.shadow=this.options.shadow.enabled):this.hover&&(t.color=this.options.color.hover.background,t.borderColor=this.options.color.hover.border,t.shadow=this.options.shadow.enabled):"function"==typeof this.chooser&&(this.chooser(t,this.options.id,this.selected,this.hover),!1===t.shadow&&(t.shadowColor===this.options.shadow.color&&t.shadowSize===this.options.shadow.size&&t.shadowX===this.options.shadow.x&&t.shadowY===this.options.shadow.y||(t.shadow=!0))):t.shadow=this.options.shadow.enabled,void 0!==this.options.opacity){var e=this.options.opacity;t.borderColor=sh(t.borderColor,e),t.color=sh(t.color,e),t.shadowColor=sh(t.shadowColor,e)}return t}},{key:"updateLabelModule",value:function(e){void 0!==this.options.label&&null!==this.options.label||(this.options.label=""),t.updateGroupOptions(this.options,dc(dc({},e),{},{color:e&&e.color||this._localColor||void 0}),this.grouplist);var i=this.grouplist.get(this.options.group,!1),o=[e,this.options,i,this.globalOptions,this.defaultOptions];this.labelModule.update(this.options,o),void 0!==this.labelModule.baseSize&&(this.baseFontSize=this.labelModule.baseSize)}},{key:"updateShape",value:function(t){if(t===this.options.shape&&this.shape)this.shape.setOptions(this.options,this.imageObj,this.imageObjAlt);else switch(this.options.shape){case"box":this.shape=new Ol(this.options,this.body,this.labelModule);break;case"circle":this.shape=new Ml(this.options,this.body,this.labelModule);break;case"circularImage":this.shape=new Dl(this.options,this.body,this.labelModule,this.imageObj,this.imageObjAlt);break;case"custom":this.shape=new Al(this.options,this.body,this.labelModule,this.options.ctxRenderer);break;case"database":this.shape=new jl(this.options,this.body,this.labelModule);break;case"diamond":this.shape=new Hl(this.options,this.body,this.labelModule);break;case"dot":this.shape=new Vl(this.options,this.body,this.labelModule);break;case"ellipse":this.shape=new Ul(this.options,this.body,this.labelModule);break;case"icon":this.shape=new Xl(this.options,this.body,this.labelModule);break;case"image":this.shape=new Kl(this.options,this.body,this.labelModule,this.imageObj,this.imageObjAlt);break;case"square":this.shape=new Ql(this.options,this.body,this.labelModule);break;case"hexagon":this.shape=new Jl(this.options,this.body,this.labelModule);break;case"star":this.shape=new ec(this.options,this.body,this.labelModule);break;case"text":this.shape=new oc(this.options,this.body,this.labelModule);break;case"triangle":this.shape=new rc(this.options,this.body,this.labelModule);break;case"triangleDown":this.shape=new ac(this.options,this.body,this.labelModule);break;default:this.shape=new Ul(this.options,this.body,this.labelModule)}this.needsRefresh()}},{key:"select",value:function(){this.selected=!0,this.needsRefresh()}},{key:"unselect",value:function(){this.selected=!1,this.needsRefresh()}},{key:"needsRefresh",value:function(){this.shape.refreshNeeded=!0}},{key:"getTitle",value:function(){return this.options.title}},{key:"distanceToBorder",value:function(t,e){return this.shape.distanceToBorder(t,e)}},{key:"isFixed",value:function(){return this.options.fixed.x&&this.options.fixed.y}},{key:"isSelected",value:function(){return this.selected}},{key:"getValue",value:function(){return this.options.value}},{key:"getLabelSize",value:function(){return this.labelModule.size()}},{key:"setValueRange",value:function(t,e,i){if(void 0!==this.options.value){var o=this.options.scaling.customScalingFunction(t,e,i,this.options.value),n=this.options.scaling.max-this.options.scaling.min;if(!0===this.options.scaling.label.enabled){var r=this.options.scaling.label.max-this.options.scaling.label.min;this.options.font.size=this.options.scaling.label.min+o*r}this.options.size=this.options.scaling.min+o*n}else this.options.size=this.baseSize,this.options.font.size=this.baseFontSize;this.updateLabelModule()}},{key:"draw",value:function(t){var e=this.getFormattingValues();return this.shape.draw(t,this.x,this.y,this.selected,this.hover,e)||{}}},{key:"updateBoundingBox",value:function(t){this.shape.updateBoundingBox(this.x,this.y,t)}},{key:"resize",value:function(t){var e=this.getFormattingValues();this.shape.resize(t,this.selected,this.hover,e)}},{key:"getItemsOnPoint",value:function(t){var e=[];return this.labelModule.visible()&&Zd(this.labelModule.getSize(),t)&&e.push({nodeId:this.id,labelId:0}),Zd(this.shape.boundingBox,t)&&e.push({nodeId:this.id}),e}},{key:"isOverlappingWith",value:function(t){return this.shape.left<t.right&&this.shape.left+this.shape.width>t.left&&this.shape.top<t.bottom&&this.shape.top+this.shape.height>t.top}},{key:"isBoundingBoxOverlappingWith",value:function(t){return this.shape.boundingBox.left<t.right&&this.shape.boundingBox.right>t.left&&this.shape.boundingBox.top<t.bottom&&this.shape.boundingBox.bottom>t.top}}],[{key:"checkOpacity",value:function(t){return 0<=t&&t<=1}},{key:"checkCoordinateOrigin",value:function(t){return void 0===t||"center"===t||"top-left"===t}},{key:"updateGroupOptions",value:function(e,i,o){var n;if(void 0!==o){var r=e.group;if(void 0!==i&&void 0!==i.group&&r!==i.group)throw new Error("updateGroupOptions: group values in options don't match.");if("number"==typeof r||"string"==typeof r&&""!=r){var s=o.get(r);void 0!==s.opacity&&void 0===i.opacity&&(t.checkOpacity(s.opacity)||(console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+s.opacity),s.opacity=void 0));var a=ar(n=$d(i)).call(n,(function(t){return null!=i[t]}));a.push("font"),Ja(a,e,s),e.color=hh(e.color)}}}},{key:"parseOptions",value:function(e,i){var o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=arguments.length>4?arguments[4]:void 0,s=["color","fixed","shadow"];if(Ja(s,e,i,o),t.checkMass(i),void 0!==e.opacity&&(t.checkOpacity(e.opacity)||(console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+e.opacity),e.opacity=void 0)),void 0!==i.opacity&&(t.checkOpacity(i.opacity)||(console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+i.opacity),i.opacity=void 0)),i.shapeProperties&&!t.checkCoordinateOrigin(i.shapeProperties.coordinateOrigin)&&console.error("Invalid option for node coordinateOrigin, found: "+i.shapeProperties.coordinateOrigin),gh(e,i,"shadow",n),void 0!==i.color&&null!==i.color){var a=hh(i.color);Qa(e.color,a)}else!0===o&&null===i.color&&(e.color=vh(n.color));void 0!==i.fixed&&null!==i.fixed&&("boolean"==typeof i.fixed?(e.fixed.x=i.fixed,e.fixed.y=i.fixed):(void 0!==i.fixed.x&&"boolean"==typeof i.fixed.x&&(e.fixed.x=i.fixed.x),void 0!==i.fixed.y&&"boolean"==typeof i.fixed.y&&(e.fixed.y=i.fixed.y))),!0===o&&null===i.font&&(e.font=vh(n.font)),t.updateGroupOptions(e,i,r),void 0!==i.scaling&&gh(e.scaling,i.scaling,"label",n.scaling)}},{key:"checkMass",value:function(t,e){if(void 0!==t.mass&&t.mass<=0){var i="";void 0!==e&&(i=" in node id: "+e),console.error("%cNegative or zero mass disallowed"+i+", setting mass to 1.",Mh),t.mass=1}}}]),t}();function cc(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return uc(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return uc(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function uc(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}var fc=function(){function t(e,i,o,n){var r,s=this;if(Po(this,t),this.body=e,this.images=i,this.groups=o,this.layoutEngine=n,this.body.functions.createNode=bt(r=this.create).call(r,this),this.nodesListeners={add:function(t,e){s.add(e.items)},update:function(t,e){s.update(e.items,e.data,e.oldData)},remove:function(t,e){s.remove(e.items)}},this.defaultOptions={borderWidth:1,borderWidthSelected:void 0,brokenImage:void 0,color:{border:"#2B7CE9",background:"#97C2FC",highlight:{border:"#2B7CE9",background:"#D2E5FF"},hover:{border:"#2B7CE9",background:"#D2E5FF"}},opacity:void 0,fixed:{x:!1,y:!1},font:{color:"#343434",size:14,face:"arial",background:"none",strokeWidth:0,strokeColor:"#ffffff",align:"center",vadjust:0,multi:!1,bold:{mod:"bold"},boldital:{mod:"bold italic"},ital:{mod:"italic"},mono:{mod:"",size:15,face:"monospace",vadjust:2}},group:void 0,hidden:!1,icon:{face:"FontAwesome",code:void 0,size:50,color:"#2B7CE9"},image:void 0,imagePadding:{top:0,right:0,bottom:0,left:0},label:void 0,labelHighlightBold:!0,level:void 0,margin:{top:5,right:5,bottom:5,left:5},mass:1,physics:!0,scaling:{min:10,max:30,label:{enabled:!1,min:14,max:30,maxVisible:30,drawThreshold:5},customScalingFunction:function(t,e,i,o){if(e===t)return.5;var n=1/(e-t);return Math.max(0,(o-t)*n)}},shadow:{enabled:!1,color:"rgba(0,0,0,0.5)",size:10,x:5,y:5},shape:"ellipse",shapeProperties:{borderDashes:!1,borderRadius:6,interpolation:!0,useImageSize:!1,useBorderWithImage:!1,coordinateOrigin:"center"},size:25,title:void 0,value:void 0,x:void 0,y:void 0},this.defaultOptions.mass<=0)throw"Internal error: mass in defaultOptions of NodesHandler may not be zero or negative";this.options=vh(this.defaultOptions),this.bindEventListeners()}return Io(t,[{key:"bindEventListeners",value:function(){var t,e,i=this;this.body.emitter.on("refreshNodes",bt(t=this.refresh).call(t,this)),this.body.emitter.on("refresh",bt(e=this.refresh).call(e,this)),this.body.emitter.on("destroy",(function(){nh(i.nodesListeners,(function(t,e){i.body.data.nodes&&i.body.data.nodes.off(e,t)})),delete i.body.functions.createNode,delete i.nodesListeners.add,delete i.nodesListeners.update,delete i.nodesListeners.remove,delete i.nodesListeners}))}},{key:"setOptions",value:function(t){if(void 0!==t){if(lc.parseOptions(this.options,t),void 0!==t.opacity&&(zd(t.opacity)||!Ad(t.opacity)||t.opacity<0||t.opacity>1?console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+t.opacity):this.options.opacity=t.opacity),void 0!==t.shape)for(var e in this.body.nodes)Object.prototype.hasOwnProperty.call(this.body.nodes,e)&&this.body.nodes[e].updateShape();if(void 0!==t.font||void 0!==t.widthConstraint||void 0!==t.heightConstraint)for(var i=0,o=xn(this.body.nodes);i<o.length;i++){var n=o[i];this.body.nodes[n].updateLabelModule(),this.body.nodes[n].needsRefresh()}if(void 0!==t.size)for(var r in this.body.nodes)Object.prototype.hasOwnProperty.call(this.body.nodes,r)&&this.body.nodes[r].needsRefresh();void 0===t.hidden&&void 0===t.physics||this.body.emitter.emit("_dataChanged")}}},{key:"setData",value:function(t){var i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=this.body.data.nodes;if(e.isDataViewLike("id",t))this.body.data.nodes=t;else if(gn(t))this.body.data.nodes=new e.DataSet,this.body.data.nodes.add(t);else{if(t)throw new TypeError("Array or DataSet expected");this.body.data.nodes=new e.DataSet}if(o&&nh(this.nodesListeners,(function(t,e){o.off(e,t)})),this.body.nodes={},this.body.data.nodes){var n=this;nh(this.nodesListeners,(function(t,e){n.body.data.nodes.on(e,t)}));var r=this.body.data.nodes.getIds();this.add(r,!0)}!1===i&&this.body.emitter.emit("_dataChanged")}},{key:"add",value:function(t){for(var e,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=[],n=0;n<t.length;n++){e=t[n];var r=this.body.data.nodes.get(e),s=this.create(r);o.push(s),this.body.nodes[e]=s}this.layoutEngine.positionInitially(o),!1===i&&this.body.emitter.emit("_dataChanged")}},{key:"update",value:function(t,e,i){for(var o=this.body.nodes,n=!1,r=0;r<t.length;r++){var s=t[r],a=o[s],h=e[r];void 0!==a?a.setOptions(h)&&(n=!0):(n=!0,a=this.create(h),o[s]=a)}n||void 0===i||(n=Wd(e).call(e,(function(t,e){var o=i[e];return o&&o.level!==t.level}))),!0===n?this.body.emitter.emit("_dataChanged"):this.body.emitter.emit("_dataUpdated")}},{key:"remove",value:function(t){for(var e=this.body.nodes,i=0;i<t.length;i++){delete e[t[i]]}this.body.emitter.emit("_dataChanged")}},{key:"create",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:lc;return new e(t,this.body,this.images,this.groups,this.options,this.defaultOptions)}},{key:"refresh",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];nh(this.body.nodes,(function(i,o){var n=t.body.data.nodes.get(o);void 0!==n&&(!0===e&&i.setOptions({x:null,y:null}),i.setOptions({fixed:!1}),i.setOptions(n))}))}},{key:"getPositions",value:function(t){var e={};if(void 0!==t){if(!0===gn(t)){for(var i=0;i<t.length;i++)if(void 0!==this.body.nodes[t[i]]){var o=this.body.nodes[t[i]];e[t[i]]={x:Math.round(o.x),y:Math.round(o.y)}}}else if(void 0!==this.body.nodes[t]){var n=this.body.nodes[t];e[t]={x:Math.round(n.x),y:Math.round(n.y)}}}else for(var r=0;r<this.body.nodeIndices.length;r++){var s=this.body.nodes[this.body.nodeIndices[r]];e[this.body.nodeIndices[r]]={x:Math.round(s.x),y:Math.round(s.y)}}return e}},{key:"getPosition",value:function(t){if(null==t)throw new TypeError("No id was specified for getPosition method.");if(null==this.body.nodes[t])throw new ReferenceError("NodeId provided for getPosition does not exist. Provided: ".concat(t));return{x:Math.round(this.body.nodes[t].x),y:Math.round(this.body.nodes[t].y)}}},{key:"storePositions",value:function(){var t,e=[],i=this.body.data.nodes.getDataSet(),o=cc(i.get());try{for(o.s();!(t=o.n()).done;){var n=t.value,r=n.id,s=this.body.nodes[r],a=Math.round(s.x),h=Math.round(s.y);n.x===a&&n.y===h||e.push({id:r,x:a,y:h})}}catch(t){o.e(t)}finally{o.f()}i.update(e)}},{key:"getBoundingBox",value:function(t){if(void 0!==this.body.nodes[t])return this.body.nodes[t].shape.boundingBox}},{key:"getConnectedNodes",value:function(t,e){var i=[];if(void 0!==this.body.nodes[t])for(var o=this.body.nodes[t],n={},r=0;r<o.edges.length;r++){var s=o.edges[r];"to"!==e&&s.toId==o.id?void 0===n[s.fromId]&&(i.push(s.fromId),n[s.fromId]=!0):"from"!==e&&s.fromId==o.id&&void 0===n[s.toId]&&(i.push(s.toId),n[s.toId]=!0)}return i}},{key:"getConnectedEdges",value:function(t){var e=[];if(void 0!==this.body.nodes[t])for(var i=this.body.nodes[t],o=0;o<i.edges.length;o++)e.push(i.edges[o].id);else console.error("NodeId provided for getConnectedEdges does not exist. Provided: ",t);return e}},{key:"moveNode",value:function(t,e,i){var o=this;void 0!==this.body.nodes[t]?(this.body.nodes[t].x=Number(e),this.body.nodes[t].y=Number(i),qr((function(){o.body.emitter.emit("startSimulation")}),0)):console.error("Node id supplied to moveNode does not exist. Provided: ",t)}}]),t}();q({target:"Reflect",stat:!0},{get:function t(e,i){var o,n,r=arguments.length<3?e:arguments[2];return R(e)===r?e[i]:(o=S.f(e,i))?k(o,"value")?o.value:void 0===o.get?void 0:o.get.call(r):m(n=ie(e))?t(n,i,r):void 0}});var pc=F.Reflect.get,vc=xo;function gc(t,e,i){return(gc="undefined"!=typeof Reflect&&pc?pc:function(t,e,i){var o=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=_l(t)););return t}(t,e);if(o){var n=vc(o,e);return n.get?n.get.call(i):n.value}})(t,e,i||t)}var yc=Math.hypot,mc=Math.abs,bc=Math.sqrt,wc=!!yc&&yc(1/0,NaN)!==1/0;q({target:"Math",stat:!0,forced:wc},{hypot:function(t,e){for(var i,o,n=0,r=0,s=arguments.length,a=0;r<s;)a<(i=mc(arguments[r++]))?(n=n*(o=a/i)*o+1,a=i):n+=i>0?(o=i/a)*o:i;return a===1/0?1/0:a*bc(n)}});var kc=F.Math.hypot;function _c(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var xc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"transform",value:function(t,e){gn(t)||(t=[t]);for(var i=e.point.x,o=e.point.y,n=e.angle,r=e.length,s=0;s<t.length;++s){var a=t[s],h=a.x*Math.cos(n)-a.y*Math.sin(n),d=a.x*Math.sin(n)+a.y*Math.cos(n);a.x=i+r*h,a.y=o+r*d}}},{key:"drawPath",value:function(t,e){t.beginPath(),t.moveTo(e[0].x,e[0].y);for(var i=1;i<e.length;++i)t.lineTo(e[i].x,e[i].y);t.closePath()}}]),t}(),Ec=function(t){bl(i,t);var e=_c(i);function i(){return Po(this,i),e.apply(this,arguments)}return Io(i,null,[{key:"draw",value:function(t,e){if(e.image){t.save(),t.translate(e.point.x,e.point.y),t.rotate(Math.PI/2+e.angle);var i=null!=e.imageWidth?e.imageWidth:e.image.width,o=null!=e.imageHeight?e.imageHeight:e.image.height;e.image.drawImageAtPosition(t,1,-i/2,0,i,o),t.restore()}return!1}}]),i}(xc),Oc=function(t){bl(i,t);var e=_c(i);function i(){return Po(this,i),e.apply(this,arguments)}return Io(i,null,[{key:"draw",value:function(t,e){var i=[{x:0,y:0},{x:-1,y:.3},{x:-.9,y:0},{x:-1,y:-.3}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),i}(xc),Cc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i=[{x:-1,y:0},{x:0,y:.3},{x:-.4,y:0},{x:0,y:-.3}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),t}(),Sc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i={x:-.4,y:0};xc.transform(i,e),t.strokeStyle=t.fillStyle,t.fillStyle="rgba(0, 0, 0, 0)";var o=Math.PI,n=e.angle-o/2,r=e.angle+o/2;return t.beginPath(),t.arc(i.x,i.y,.4*e.length,n,r,!1),t.stroke(),!0}}]),t}(),Tc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i={x:-.3,y:0};xc.transform(i,e),t.strokeStyle=t.fillStyle,t.fillStyle="rgba(0, 0, 0, 0)";var o=Math.PI,n=e.angle+o/2,r=e.angle+3*o/2;return t.beginPath(),t.arc(i.x,i.y,.4*e.length,n,r,!1),t.stroke(),!0}}]),t}(),Mc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i=[{x:.02,y:0},{x:-1,y:.3},{x:-1,y:-.3}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),t}(),Pc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i=[{x:0,y:.3},{x:0,y:-.3},{x:-1,y:0}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),t}(),Dc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i={x:-.4,y:0};return xc.transform(i,e),wt(t,i.x,i.y,.4*e.length),!0}}]),t}(),Bc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i=[{x:0,y:.5},{x:0,y:-.5},{x:-.15,y:-.5},{x:-.15,y:.5}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),t}(),Ic=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i=[{x:0,y:.3},{x:0,y:-.3},{x:-.6,y:-.3},{x:-.6,y:.3}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),t}(),zc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i=[{x:0,y:0},{x:-.5,y:-.3},{x:-1,y:0},{x:-.5,y:.3}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),t}(),Fc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i=[{x:-1,y:.3},{x:-.5,y:0},{x:-1,y:-.3},{x:0,y:0}];return xc.transform(i,e),xc.drawPath(t,i),!0}}]),t}(),Nc=function(){function t(){Po(this,t)}return Io(t,null,[{key:"draw",value:function(t,e){var i;switch(e.type&&(i=e.type.toLowerCase()),i){case"image":return Ec.draw(t,e);case"circle":return Dc.draw(t,e);case"box":return Ic.draw(t,e);case"crow":return Cc.draw(t,e);case"curve":return Sc.draw(t,e);case"diamond":return zc.draw(t,e);case"inv_curve":return Tc.draw(t,e);case"triangle":return Mc.draw(t,e);case"inv_triangle":return Pc.draw(t,e);case"bar":return Bc.draw(t,e);case"vee":return Fc.draw(t,e);case"arrow":default:return Oc.draw(t,e)}}}]),t}();function Ac(t,e){var i=xn(t);if(wo){var o=wo(t);e&&(o=ar(o).call(o,(function(e){return Eo(t,e).enumerable}))),i.push.apply(i,o)}return i}function Rc(t){for(var e=1;e<arguments.length;e++){var i,o=null!=arguments[e]?arguments[e]:{};if(e%2)Dn(i=Ac(Object(o),!0)).call(i,(function(e){zo(t,e,o[e])}));else if(Co)So(t,Co(o));else{var n;Dn(n=Ac(Object(o))).call(n,(function(e){Mo(t,e,Eo(o,e))}))}}return t}var jc=function(){function t(e,i,o){Po(this,t),this._body=i,this._labelModule=o,this.color={},this.colorDirty=!0,this.hoverWidth=1.5,this.selectionWidth=2,this.setOptions(e),this.fromPoint=this.from,this.toPoint=this.to}return Io(t,[{key:"connect",value:function(){this.from=this._body.nodes[this.options.from],this.to=this._body.nodes[this.options.to]}},{key:"cleanup",value:function(){return!1}},{key:"setOptions",value:function(t){this.options=t,this.from=this._body.nodes[this.options.from],this.to=this._body.nodes[this.options.to],this.id=this.options.id}},{key:"drawLine",value:function(t,e,i,o){var n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:this.getViaNode();t.strokeStyle=this.getColor(t,e),t.lineWidth=e.width,!1!==e.dashes?this._drawDashedLine(t,e,n):this._drawLine(t,e,n)}},{key:"_drawLine",value:function(t,e,i,o,n){if(this.from!=this.to)this._line(t,e,i,o,n);else{var r=an(this._getCircleData(t),3),s=r[0],a=r[1],h=r[2];this._circle(t,e,s,a,h)}}},{key:"_drawDashedLine",value:function(t,e,i,o,n){t.lineCap="round";var r=gn(e.dashes)?e.dashes:[5,5];if(void 0!==t.setLineDash){if(t.save(),t.setLineDash(r),t.lineDashOffset=0,this.from!=this.to)this._line(t,e,i);else{var s=an(this._getCircleData(t),3),a=s[0],h=s[1],d=s[2];this._circle(t,e,a,h,d)}t.setLineDash([0]),t.lineDashOffset=0,t.restore()}else{if(this.from!=this.to)Et(t,this.from.x,this.from.y,this.to.x,this.to.y,r);else{var l=an(this._getCircleData(t),3),c=l[0],u=l[1],f=l[2];this._circle(t,e,c,u,f)}this.enableShadow(t,e),t.stroke(),this.disableShadow(t,e)}}},{key:"findBorderPosition",value:function(t,e,i){return this.from!=this.to?this._findBorderPosition(t,e,i):this._findBorderPositionCircle(t,e,i)}},{key:"findBorderPositions",value:function(t){if(this.from!=this.to)return{from:this._findBorderPosition(this.from,t),to:this._findBorderPosition(this.to,t)};var e,i=an(vn(e=this._getCircleData(t)).call(e,0,2),2),o=i[0],n=i[1];return{from:this._findBorderPositionCircle(this.from,t,{x:o,y:n,low:.25,high:.6,direction:-1}),to:this._findBorderPositionCircle(this.from,t,{x:o,y:n,low:.6,high:.8,direction:1})}}},{key:"_getCircleData",value:function(t){var e=this.options.selfReference.size;void 0!==t&&void 0===this.from.shape.width&&this.from.shape.resize(t);var i=tl(t,this.options.selfReference.angle,e,this.from);return[i.x,i.y,e]}},{key:"_pointOnCircle",value:function(t,e,i,o){var n=2*o*Math.PI;return{x:t+i*Math.cos(n),y:e-i*Math.sin(n)}}},{key:"_findBorderPositionCircle",value:function(t,e,i){var o,n=i.x,r=i.y,s=i.low,a=i.high,h=i.direction,d=this.options.selfReference.size,l=.5*(s+a),c=0;!0===this.options.arrowStrikethrough&&(-1===h?c=this.options.endPointOffset.from:1===h&&(c=this.options.endPointOffset.to));var u=0;do{l=.5*(s+a),o=this._pointOnCircle(n,r,d,l);var f=Math.atan2(t.y-o.y,t.x-o.x),p=t.distanceToBorder(e,f)+c-Math.sqrt(Math.pow(o.x-t.x,2)+Math.pow(o.y-t.y,2));if(Math.abs(p)<.05)break;p>0?h>0?s=l:a=l:h>0?a=l:s=l,++u}while(s<=a&&u<10);return Rc(Rc({},o),{},{t:l})}},{key:"getLineWidth",value:function(t,e){return!0===t?Math.max(this.selectionWidth,.3/this._body.view.scale):!0===e?Math.max(this.hoverWidth,.3/this._body.view.scale):Math.max(this.options.width,.3/this._body.view.scale)}},{key:"getColor",value:function(t,e){if(!1!==e.inheritsColor){if("both"===e.inheritsColor&&this.from.id!==this.to.id){var i=t.createLinearGradient(this.from.x,this.from.y,this.to.x,this.to.y),o=this.from.options.color.highlight.border,n=this.to.options.color.highlight.border;return!1===this.from.selected&&!1===this.to.selected?(o=sh(this.from.options.color.border,e.opacity),n=sh(this.to.options.color.border,e.opacity)):!0===this.from.selected&&!1===this.to.selected?n=this.to.options.color.border:!1===this.from.selected&&!0===this.to.selected&&(o=this.from.options.color.border),i.addColorStop(0,o),i.addColorStop(1,n),i}return"to"===e.inheritsColor?sh(this.to.options.color.border,e.opacity):sh(this.from.options.color.border,e.opacity)}return sh(e.color,e.opacity)}},{key:"_circle",value:function(t,e,i,o,n){this.enableShadow(t,e);var r=0,s=2*Math.PI;if(!this.options.selfReference.renderBehindTheNode){var a=this.options.selfReference.angle,h=this.options.selfReference.angle+Math.PI,d=this._findBorderPositionCircle(this.from,t,{x:i,y:o,low:a,high:h,direction:-1}),l=this._findBorderPositionCircle(this.from,t,{x:i,y:o,low:a,high:h,direction:1});r=Math.atan2(d.y-o,d.x-i),s=Math.atan2(l.y-o,l.x-i)}t.beginPath(),t.arc(i,o,n,r,s,!1),t.stroke(),this.disableShadow(t,e)}},{key:"getDistanceToEdge",value:function(t,e,i,o,n,r){if(this.from!=this.to)return this._getDistanceToEdge(t,e,i,o,n,r);var s=an(this._getCircleData(void 0),3),a=s[0],h=s[1],d=s[2],l=a-n,c=h-r;return Math.abs(Math.sqrt(l*l+c*c)-d)}},{key:"_getDistanceToLine",value:function(t,e,i,o,n,r){var s=i-t,a=o-e,h=((n-t)*s+(r-e)*a)/(s*s+a*a);h>1?h=1:h<0&&(h=0);var d=t+h*s-n,l=e+h*a-r;return Math.sqrt(d*d+l*l)}},{key:"getArrowData",value:function(t,e,i,o,n,r){var s,a,h,d,l,c,u,f=r.width;"from"===e?(h=this.from,d=this.to,l=r.fromArrowScale<0,c=Math.abs(r.fromArrowScale),u=r.fromArrowType):"to"===e?(h=this.to,d=this.from,l=r.toArrowScale<0,c=Math.abs(r.toArrowScale),u=r.toArrowType):(h=this.to,d=this.from,l=r.middleArrowScale<0,c=Math.abs(r.middleArrowScale),u=r.middleArrowType);var p=15*c+3*f;if(h!=d){var v=p/kc(h.x-d.x,h.y-d.y);if("middle"!==e)if(!0===this.options.smooth.enabled){var g=this._findBorderPosition(h,t,{via:i}),y=this.getPoint(g.t+v*("from"===e?1:-1),i);s=Math.atan2(g.y-y.y,g.x-y.x),a=g}else s=Math.atan2(h.y-d.y,h.x-d.x),a=this._findBorderPosition(h,t);else{var m=(l?-v:v)/2,b=this.getPoint(.5+m,i),w=this.getPoint(.5-m,i);s=Math.atan2(b.y-w.y,b.x-w.x),a=this.getPoint(.5,i)}}else{var k=an(this._getCircleData(t),3),_=k[0],x=k[1],E=k[2];if("from"===e){var O=this.options.selfReference.angle,C=this.options.selfReference.angle+Math.PI,S=this._findBorderPositionCircle(this.from,t,{x:_,y:x,low:O,high:C,direction:-1});s=-2*S.t*Math.PI+1.5*Math.PI+.1*Math.PI,a=S}else if("to"===e){var T=this.options.selfReference.angle,M=this.options.selfReference.angle+Math.PI,P=this._findBorderPositionCircle(this.from,t,{x:_,y:x,low:T,high:M,direction:1});s=-2*P.t*Math.PI+1.5*Math.PI-1.1*Math.PI,a=P}else{var D=this.options.selfReference.angle/(2*Math.PI);a=this._pointOnCircle(_,x,E,D),s=-2*D*Math.PI+1.5*Math.PI+.1*Math.PI}}return{point:a,core:{x:a.x-.9*p*Math.cos(s),y:a.y-.9*p*Math.sin(s)},angle:s,length:p,type:u}}},{key:"drawArrowHead",value:function(t,e,i,o,n){t.strokeStyle=this.getColor(t,e),t.fillStyle=t.strokeStyle,t.lineWidth=e.width,Nc.draw(t,n)&&(this.enableShadow(t,e),Xr(t).call(t),this.disableShadow(t,e))}},{key:"enableShadow",value:function(t,e){!0===e.shadow&&(t.shadowColor=e.shadowColor,t.shadowBlur=e.shadowSize,t.shadowOffsetX=e.shadowX,t.shadowOffsetY=e.shadowY)}},{key:"disableShadow",value:function(t,e){!0===e.shadow&&(t.shadowColor="rgba(0,0,0,0)",t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0)}},{key:"drawBackground",value:function(t,e){if(!1!==e.background){var i={strokeStyle:t.strokeStyle,lineWidth:t.lineWidth,dashes:t.dashes};t.strokeStyle=e.backgroundColor,t.lineWidth=e.backgroundSize,this.setStrokeDashed(t,e.backgroundDashes),t.stroke(),t.strokeStyle=i.strokeStyle,t.lineWidth=i.lineWidth,t.dashes=i.dashes,this.setStrokeDashed(t,e.dashes)}}},{key:"setStrokeDashed",value:function(t,e){if(!1!==e)if(void 0!==t.setLineDash){var i=gn(e)?e:[5,5];t.setLineDash(i)}else console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");else void 0!==t.setLineDash?t.setLineDash([]):console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.")}}]),t}();function Lc(t,e){var i=xn(t);if(wo){var o=wo(t);e&&(o=ar(o).call(o,(function(e){return Eo(t,e).enumerable}))),i.push.apply(i,o)}return i}function Hc(t){for(var e=1;e<arguments.length;e++){var i,o=null!=arguments[e]?arguments[e]:{};if(e%2)Dn(i=Lc(Object(o),!0)).call(i,(function(e){zo(t,e,o[e])}));else if(Co)So(t,Co(o));else{var n;Dn(n=Lc(Object(o))).call(n,(function(e){Mo(t,e,Eo(o,e))}))}}return t}function Wc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Vc=function(t){bl(i,t);var e=Wc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"_findBorderPositionBezier",value:function(t,e){var i,o,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this._getViaCoordinates(),r=10,s=.2,a=!1,h=1,d=0,l=this.to,c=this.options.endPointOffset?this.options.endPointOffset.to:0;t.id===this.from.id&&(l=this.from,a=!0,c=this.options.endPointOffset?this.options.endPointOffset.from:0),!1===this.options.arrowStrikethrough&&(c=0);var u=0;do{o=.5*(d+h),i=this.getPoint(o,n);var f=Math.atan2(l.y-i.y,l.x-i.x),p=l.distanceToBorder(e,f)+c,v=Math.sqrt(Math.pow(i.x-l.x,2)+Math.pow(i.y-l.y,2)),g=p-v;if(Math.abs(g)<s)break;g<0?!1===a?d=o:h=o:!1===a?h=o:d=o,++u}while(d<=h&&u<r);return Hc(Hc({},i),{},{t:o})}},{key:"_getDistanceToBezierEdge",value:function(t,e,i,o,n,r,s){var a,h,d,l,c,u=1e9,f=t,p=e;for(h=1;h<10;h++)d=.1*h,l=Math.pow(1-d,2)*t+2*d*(1-d)*s.x+Math.pow(d,2)*i,c=Math.pow(1-d,2)*e+2*d*(1-d)*s.y+Math.pow(d,2)*o,h>0&&(u=(a=this._getDistanceToLine(f,p,l,c,n,r))<u?a:u),f=l,p=c;return u}},{key:"_bezierCurve",value:function(t,e,i,o){t.beginPath(),t.moveTo(this.fromPoint.x,this.fromPoint.y),null!=i&&null!=i.x?null!=o&&null!=o.x?t.bezierCurveTo(i.x,i.y,o.x,o.y,this.toPoint.x,this.toPoint.y):t.quadraticCurveTo(i.x,i.y,this.toPoint.x,this.toPoint.y):t.lineTo(this.toPoint.x,this.toPoint.y),this.drawBackground(t,e),this.enableShadow(t,e),t.stroke(),this.disableShadow(t,e)}},{key:"getViaNode",value:function(){return this._getViaCoordinates()}}]),i}(jc);function qc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Uc=function(t){bl(i,t);var e=qc(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n)).via=r.via,r._boundFunction=function(){r.positionBezierNode()},r._body.emitter.on("_repositionBezierNodes",r._boundFunction),r}return Io(i,[{key:"setOptions",value:function(t){gc(_l(i.prototype),"setOptions",this).call(this,t);var e=!1;this.options.physics!==t.physics&&(e=!0),this.options=t,this.id=this.options.id,this.from=this._body.nodes[this.options.from],this.to=this._body.nodes[this.options.to],this.setupSupportNode(),this.connect(),!0===e&&(this.via.setOptions({physics:this.options.physics}),this.positionBezierNode())}},{key:"connect",value:function(){this.from=this._body.nodes[this.options.from],this.to=this._body.nodes[this.options.to],void 0===this.from||void 0===this.to||!1===this.options.physics||this.from.id===this.to.id?this.via.setOptions({physics:!1}):this.via.setOptions({physics:!0})}},{key:"cleanup",value:function(){return this._body.emitter.off("_repositionBezierNodes",this._boundFunction),void 0!==this.via&&(delete this._body.nodes[this.via.id],this.via=void 0,!0)}},{key:"setupSupportNode",value:function(){if(void 0===this.via){var t="edgeId:"+this.id,e=this._body.functions.createNode({id:t,shape:"circle",physics:!0,hidden:!0});this._body.nodes[t]=e,this.via=e,this.via.parentEdgeId=this.id,this.positionBezierNode()}}},{key:"positionBezierNode",value:function(){void 0!==this.via&&void 0!==this.from&&void 0!==this.to?(this.via.x=.5*(this.from.x+this.to.x),this.via.y=.5*(this.from.y+this.to.y)):void 0!==this.via&&(this.via.x=0,this.via.y=0)}},{key:"_line",value:function(t,e,i){this._bezierCurve(t,e,i)}},{key:"_getViaCoordinates",value:function(){return this.via}},{key:"getViaNode",value:function(){return this.via}},{key:"getPoint",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.via;if(this.from===this.to){var i=this._getCircleData(),o=an(i,3),n=o[0],r=o[1],s=o[2],a=2*Math.PI*(1-t);return{x:n+s*Math.sin(a),y:r+s-s*(1-Math.cos(a))}}return{x:Math.pow(1-t,2)*this.fromPoint.x+2*t*(1-t)*e.x+Math.pow(t,2)*this.toPoint.x,y:Math.pow(1-t,2)*this.fromPoint.y+2*t*(1-t)*e.y+Math.pow(t,2)*this.toPoint.y}}},{key:"_findBorderPosition",value:function(t,e){return this._findBorderPositionBezier(t,e,this.via)}},{key:"_getDistanceToEdge",value:function(t,e,i,o,n,r){return this._getDistanceToBezierEdge(t,e,i,o,n,r,this.via)}}]),i}(Vc);function Yc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Xc=function(t){bl(i,t);var e=Yc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"_line",value:function(t,e,i){this._bezierCurve(t,e,i)}},{key:"getViaNode",value:function(){return this._getViaCoordinates()}},{key:"_getViaCoordinates",value:function(){var t,e,i=this.options.smooth.roundness,o=this.options.smooth.type,n=Math.abs(this.from.x-this.to.x),r=Math.abs(this.from.y-this.to.y);if("discrete"===o||"diagonalCross"===o){var s,a;s=a=n<=r?i*r:i*n,this.from.x>this.to.x&&(s=-s),this.from.y>=this.to.y&&(a=-a);var h=this.from.x+s,d=this.from.y+a;return"discrete"===o&&(n<=r?h=n<i*r?this.from.x:h:d=r<i*n?this.from.y:d),{x:h,y:d}}if("straightCross"===o){var l=(1-i)*n,c=(1-i)*r;return n<=r?(l=0,this.from.y<this.to.y&&(c=-c)):(this.from.x<this.to.x&&(l=-l),c=0),{x:this.to.x+l,y:this.to.y+c}}if("horizontal"===o){var u=(1-i)*n;return this.from.x<this.to.x&&(u=-u),{x:this.to.x+u,y:this.from.y}}if("vertical"===o){var f=(1-i)*r;return this.from.y<this.to.y&&(f=-f),{x:this.from.x,y:this.to.y+f}}if("curvedCW"===o){n=this.to.x-this.from.x,r=this.from.y-this.to.y;var p=Math.sqrt(n*n+r*r),v=Math.PI,g=(Math.atan2(r,n)+(.5*i+.5)*v)%(2*v);return{x:this.from.x+(.5*i+.5)*p*Math.sin(g),y:this.from.y+(.5*i+.5)*p*Math.cos(g)}}if("curvedCCW"===o){n=this.to.x-this.from.x,r=this.from.y-this.to.y;var y=Math.sqrt(n*n+r*r),m=Math.PI,b=(Math.atan2(r,n)+(.5*-i+.5)*m)%(2*m);return{x:this.from.x+(.5*i+.5)*y*Math.sin(b),y:this.from.y+(.5*i+.5)*y*Math.cos(b)}}t=e=n<=r?i*r:i*n,this.from.x>this.to.x&&(t=-t),this.from.y>=this.to.y&&(e=-e);var w=this.from.x+t,k=this.from.y+e;return n<=r?w=this.from.x<=this.to.x?this.to.x<w?this.to.x:w:this.to.x>w?this.to.x:w:k=this.from.y>=this.to.y?this.to.y>k?this.to.y:k:this.to.y<k?this.to.y:k,{x:w,y:k}}},{key:"_findBorderPosition",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this._findBorderPositionBezier(t,e,i.via)}},{key:"_getDistanceToEdge",value:function(t,e,i,o,n,r){var s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:this._getViaCoordinates();return this._getDistanceToBezierEdge(t,e,i,o,n,r,s)}},{key:"getPoint",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this._getViaCoordinates(),i=t,o=Math.pow(1-i,2)*this.fromPoint.x+2*i*(1-i)*e.x+Math.pow(i,2)*this.toPoint.x,n=Math.pow(1-i,2)*this.fromPoint.y+2*i*(1-i)*e.y+Math.pow(i,2)*this.toPoint.y;return{x:o,y:n}}}]),i}(Vc);function Gc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}function Kc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var $c=function(t){bl(i,t);var e=Kc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"_line",value:function(t,e,i){var o=i[0],n=i[1];this._bezierCurve(t,e,o,n)}},{key:"_getViaCoordinates",value:function(){var t,e,i,o,n=this.from.x-this.to.x,r=this.from.y-this.to.y,s=this.options.smooth.roundness;return(Math.abs(n)>Math.abs(r)||!0===this.options.smooth.forceDirection||"horizontal"===this.options.smooth.forceDirection)&&"vertical"!==this.options.smooth.forceDirection?(e=this.from.y,o=this.to.y,t=this.from.x-s*n,i=this.to.x+s*n):(e=this.from.y-s*r,o=this.to.y+s*r,t=this.from.x,i=this.to.x),[{x:t,y:e},{x:i,y:o}]}},{key:"getViaNode",value:function(){return this._getViaCoordinates()}},{key:"_findBorderPosition",value:function(t,e){return this._findBorderPositionBezier(t,e)}},{key:"_getDistanceToEdge",value:function(t,e,i,o,n,r){var s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:this._getViaCoordinates(),a=an(s,2),h=a[0],d=a[1];return this._getDistanceToBezierEdge2(t,e,i,o,n,r,h,d)}},{key:"getPoint",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this._getViaCoordinates(),i=an(e,2),o=i[0],n=i[1],r=t,s=[Math.pow(1-r,3),3*r*Math.pow(1-r,2),3*Math.pow(r,2)*(1-r),Math.pow(r,3)],a=s[0]*this.fromPoint.x+s[1]*o.x+s[2]*n.x+s[3]*this.toPoint.x,h=s[0]*this.fromPoint.y+s[1]*o.y+s[2]*n.y+s[3]*this.toPoint.y;return{x:a,y:h}}}]),i}(function(t){bl(i,t);var e=Gc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"_getDistanceToBezierEdge2",value:function(t,e,i,o,n,r,s,a){for(var h=1e9,d=t,l=e,c=[0,0,0,0],u=1;u<10;u++){var f=.1*u;c[0]=Math.pow(1-f,3),c[1]=3*f*Math.pow(1-f,2),c[2]=3*Math.pow(f,2)*(1-f),c[3]=Math.pow(f,3);var p=c[0]*t+c[1]*s.x+c[2]*a.x+c[3]*i,v=c[0]*e+c[1]*s.y+c[2]*a.y+c[3]*o;if(u>0){var g=this._getDistanceToLine(d,l,p,v,n,r);h=g<h?g:h}d=p,l=v}return h}}]),i}(Vc));function Qc(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Zc=function(t){bl(i,t);var e=Qc(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"_line",value:function(t,e){t.beginPath(),t.moveTo(this.fromPoint.x,this.fromPoint.y),t.lineTo(this.toPoint.x,this.toPoint.y),this.enableShadow(t,e),t.stroke(),this.disableShadow(t,e)}},{key:"getViaNode",value:function(){}},{key:"getPoint",value:function(t){return{x:(1-t)*this.fromPoint.x+t*this.toPoint.x,y:(1-t)*this.fromPoint.y+t*this.toPoint.y}}},{key:"_findBorderPosition",value:function(t,e){var i=this.to,o=this.from;t.id===this.from.id&&(i=this.from,o=this.to);var n=Math.atan2(i.y-o.y,i.x-o.x),r=i.x-o.x,s=i.y-o.y,a=Math.sqrt(r*r+s*s),h=(a-t.distanceToBorder(e,n))/a;return{x:(1-h)*o.x+h*i.x,y:(1-h)*o.y+h*i.y,t:0}}},{key:"_getDistanceToEdge",value:function(t,e,i,o,n,r){return this._getDistanceToLine(t,e,i,o,n,r)}}]),i}(jc),Jc=function(){function t(e,i,o,n,r){if(Po(this,t),void 0===i)throw new Error("No body provided");this.options=vh(n),this.globalOptions=n,this.defaultOptions=r,this.body=i,this.imagelist=o,this.id=void 0,this.fromId=void 0,this.toId=void 0,this.selected=!1,this.hover=!1,this.labelDirty=!0,this.baseWidth=this.options.width,this.baseFontSize=this.options.font.size,this.from=void 0,this.to=void 0,this.edgeType=void 0,this.connected=!1,this.labelModule=new ll(this.body,this.options,!0),this.setOptions(e)}return Io(t,[{key:"setOptions",value:function(e){if(e){var i=void 0!==e.physics&&this.options.physics!==e.physics||void 0!==e.hidden&&(this.options.hidden||!1)!==(e.hidden||!1)||void 0!==e.from&&this.options.from!==e.from||void 0!==e.to&&this.options.to!==e.to;t.parseOptions(this.options,e,!0,this.globalOptions),void 0!==e.id&&(this.id=e.id),void 0!==e.from&&(this.fromId=e.from),void 0!==e.to&&(this.toId=e.to),void 0!==e.title&&(this.title=e.title),void 0!==e.value&&(e.value=Yd(e.value));var o=[e,this.options,this.defaultOptions];return this.chooser=Qd("edge",o),this.updateLabelModule(e),i=this.updateEdgeType()||i,this._setInteractionWidths(),this.connect(),i}}},{key:"getFormattingValues",value:function(){var t=!0===this.options.arrows.to||!0===this.options.arrows.to.enabled,e=!0===this.options.arrows.from||!0===this.options.arrows.from.enabled,i=!0===this.options.arrows.middle||!0===this.options.arrows.middle.enabled,o=this.options.color.inherit,n={toArrow:t,toArrowScale:this.options.arrows.to.scaleFactor,toArrowType:this.options.arrows.to.type,toArrowSrc:this.options.arrows.to.src,toArrowImageWidth:this.options.arrows.to.imageWidth,toArrowImageHeight:this.options.arrows.to.imageHeight,middleArrow:i,middleArrowScale:this.options.arrows.middle.scaleFactor,middleArrowType:this.options.arrows.middle.type,middleArrowSrc:this.options.arrows.middle.src,middleArrowImageWidth:this.options.arrows.middle.imageWidth,middleArrowImageHeight:this.options.arrows.middle.imageHeight,fromArrow:e,fromArrowScale:this.options.arrows.from.scaleFactor,fromArrowType:this.options.arrows.from.type,fromArrowSrc:this.options.arrows.from.src,fromArrowImageWidth:this.options.arrows.from.imageWidth,fromArrowImageHeight:this.options.arrows.from.imageHeight,arrowStrikethrough:this.options.arrowStrikethrough,color:o?void 0:this.options.color.color,inheritsColor:o,opacity:this.options.color.opacity,hidden:this.options.hidden,length:this.options.length,shadow:this.options.shadow.enabled,shadowColor:this.options.shadow.color,shadowSize:this.options.shadow.size,shadowX:this.options.shadow.x,shadowY:this.options.shadow.y,dashes:this.options.dashes,width:this.options.width,background:this.options.background.enabled,backgroundColor:this.options.background.color,backgroundSize:this.options.background.size,backgroundDashes:this.options.background.dashes};if(this.selected||this.hover)if(!0===this.chooser){if(this.selected){var r=this.options.selectionWidth;"function"==typeof r?n.width=r(n.width):"number"==typeof r&&(n.width+=r),n.width=Math.max(n.width,.3/this.body.view.scale),n.color=this.options.color.highlight,n.shadow=this.options.shadow.enabled}else if(this.hover){var s=this.options.hoverWidth;"function"==typeof s?n.width=s(n.width):"number"==typeof s&&(n.width+=s),n.width=Math.max(n.width,.3/this.body.view.scale),n.color=this.options.color.hover,n.shadow=this.options.shadow.enabled}}else"function"==typeof this.chooser&&(this.chooser(n,this.options.id,this.selected,this.hover),void 0!==n.color&&(n.inheritsColor=!1),!1===n.shadow&&(n.shadowColor===this.options.shadow.color&&n.shadowSize===this.options.shadow.size&&n.shadowX===this.options.shadow.x&&n.shadowY===this.options.shadow.y||(n.shadow=!0)));else n.shadow=this.options.shadow.enabled,n.width=Math.max(n.width,.3/this.body.view.scale);return n}},{key:"updateLabelModule",value:function(t){var e=[t,this.options,this.globalOptions,this.defaultOptions];this.labelModule.update(this.options,e),void 0!==this.labelModule.baseSize&&(this.baseFontSize=this.labelModule.baseSize)}},{key:"updateEdgeType",value:function(){var t=this.options.smooth,e=!1,i=!0;return void 0!==this.edgeType&&((this.edgeType instanceof Uc&&!0===t.enabled&&"dynamic"===t.type||this.edgeType instanceof $c&&!0===t.enabled&&"cubicBezier"===t.type||this.edgeType instanceof Xc&&!0===t.enabled&&"dynamic"!==t.type&&"cubicBezier"!==t.type||this.edgeType instanceof Zc&&!1===t.type.enabled)&&(i=!1),!0===i&&(e=this.cleanup())),!0===i?!0===t.enabled?"dynamic"===t.type?(e=!0,this.edgeType=new Uc(this.options,this.body,this.labelModule)):"cubicBezier"===t.type?this.edgeType=new $c(this.options,this.body,this.labelModule):this.edgeType=new Xc(this.options,this.body,this.labelModule):this.edgeType=new Zc(this.options,this.body,this.labelModule):this.edgeType.setOptions(this.options),e}},{key:"connect",value:function(){this.disconnect(),this.from=this.body.nodes[this.fromId]||void 0,this.to=this.body.nodes[this.toId]||void 0,this.connected=void 0!==this.from&&void 0!==this.to,!0===this.connected?(this.from.attachEdge(this),this.to.attachEdge(this)):(this.from&&this.from.detachEdge(this),this.to&&this.to.detachEdge(this)),this.edgeType.connect()}},{key:"disconnect",value:function(){this.from&&(this.from.detachEdge(this),this.from=void 0),this.to&&(this.to.detachEdge(this),this.to=void 0),this.connected=!1}},{key:"getTitle",value:function(){return this.title}},{key:"isSelected",value:function(){return this.selected}},{key:"getValue",value:function(){return this.options.value}},{key:"setValueRange",value:function(t,e,i){if(void 0!==this.options.value){var o=this.options.scaling.customScalingFunction(t,e,i,this.options.value),n=this.options.scaling.max-this.options.scaling.min;if(!0===this.options.scaling.label.enabled){var r=this.options.scaling.label.max-this.options.scaling.label.min;this.options.font.size=this.options.scaling.label.min+o*r}this.options.width=this.options.scaling.min+o*n}else this.options.width=this.baseWidth,this.options.font.size=this.baseFontSize;this._setInteractionWidths(),this.updateLabelModule()}},{key:"_setInteractionWidths",value:function(){"function"==typeof this.options.hoverWidth?this.edgeType.hoverWidth=this.options.hoverWidth(this.options.width):this.edgeType.hoverWidth=this.options.hoverWidth+this.options.width,"function"==typeof this.options.selectionWidth?this.edgeType.selectionWidth=this.options.selectionWidth(this.options.width):this.edgeType.selectionWidth=this.options.selectionWidth+this.options.width}},{key:"draw",value:function(t){var e=this.getFormattingValues();if(!e.hidden){var i=this.edgeType.getViaNode();this.edgeType.drawLine(t,e,this.selected,this.hover,i),this.drawLabel(t,i)}}},{key:"drawArrows",value:function(t){var e=this.getFormattingValues();if(!e.hidden){var i=this.edgeType.getViaNode(),o={};this.edgeType.fromPoint=this.edgeType.from,this.edgeType.toPoint=this.edgeType.to,e.fromArrow&&(o.from=this.edgeType.getArrowData(t,"from",i,this.selected,this.hover,e),!1===e.arrowStrikethrough&&(this.edgeType.fromPoint=o.from.core),e.fromArrowSrc&&(o.from.image=this.imagelist.load(e.fromArrowSrc)),e.fromArrowImageWidth&&(o.from.imageWidth=e.fromArrowImageWidth),e.fromArrowImageHeight&&(o.from.imageHeight=e.fromArrowImageHeight)),e.toArrow&&(o.to=this.edgeType.getArrowData(t,"to",i,this.selected,this.hover,e),!1===e.arrowStrikethrough&&(this.edgeType.toPoint=o.to.core),e.toArrowSrc&&(o.to.image=this.imagelist.load(e.toArrowSrc)),e.toArrowImageWidth&&(o.to.imageWidth=e.toArrowImageWidth),e.toArrowImageHeight&&(o.to.imageHeight=e.toArrowImageHeight)),e.middleArrow&&(o.middle=this.edgeType.getArrowData(t,"middle",i,this.selected,this.hover,e),e.middleArrowSrc&&(o.middle.image=this.imagelist.load(e.middleArrowSrc)),e.middleArrowImageWidth&&(o.middle.imageWidth=e.middleArrowImageWidth),e.middleArrowImageHeight&&(o.middle.imageHeight=e.middleArrowImageHeight)),e.fromArrow&&this.edgeType.drawArrowHead(t,e,this.selected,this.hover,o.from),e.middleArrow&&this.edgeType.drawArrowHead(t,e,this.selected,this.hover,o.middle),e.toArrow&&this.edgeType.drawArrowHead(t,e,this.selected,this.hover,o.to)}}},{key:"drawLabel",value:function(t,e){if(void 0!==this.options.label){var i,o=this.from,n=this.to;if(this.labelModule.differentState(this.selected,this.hover)&&this.labelModule.getTextSize(t,this.selected,this.hover),o.id!=n.id){this.labelModule.pointToSelf=!1,i=this.edgeType.getPoint(.5,e),t.save();var r=this._getRotation(t);0!=r.angle&&(t.translate(r.x,r.y),t.rotate(r.angle)),this.labelModule.draw(t,i.x,i.y,this.selected,this.hover),t.restore()}else{this.labelModule.pointToSelf=!0;var s=tl(t,this.options.selfReference.angle,this.options.selfReference.size,o);i=this._pointOnCircle(s.x,s.y,this.options.selfReference.size,this.options.selfReference.angle),this.labelModule.draw(t,i.x,i.y,this.selected,this.hover)}}}},{key:"getItemsOnPoint",value:function(t){var e=[];if(this.labelModule.visible()){var i=this._getRotation();Zd(this.labelModule.getSize(),t,i)&&e.push({edgeId:this.id,labelId:0})}var o={left:t.x,top:t.y};return this.isOverlappingWith(o)&&e.push({edgeId:this.id}),e}},{key:"isOverlappingWith",value:function(t){if(this.connected){var e=this.from.x,i=this.from.y,o=this.to.x,n=this.to.y,r=t.left,s=t.top;return this.edgeType.getDistanceToEdge(e,i,o,n,r,s)<10}return!1}},{key:"_getRotation",value:function(t){var e=this.edgeType.getViaNode(),i=this.edgeType.getPoint(.5,e);void 0!==t&&this.labelModule.calculateLabelSize(t,this.selected,this.hover,i.x,i.y);var o={x:i.x,y:this.labelModule.size.yLine,angle:0};if(!this.labelModule.visible())return o;if("horizontal"===this.options.font.align)return o;var n=this.from.y-this.to.y,r=this.from.x-this.to.x,s=Math.atan2(n,r);return(s<-1&&r<0||s>0&&r<0)&&(s+=Math.PI),o.angle=s,o}},{key:"_pointOnCircle",value:function(t,e,i,o){return{x:t+i*Math.cos(o),y:e-i*Math.sin(o)}}},{key:"select",value:function(){this.selected=!0}},{key:"unselect",value:function(){this.selected=!1}},{key:"cleanup",value:function(){return this.edgeType.cleanup()}},{key:"remove",value:function(){this.cleanup(),this.disconnect(),delete this.body.edges[this.id]}},{key:"endPointsValid",value:function(){return void 0!==this.body.nodes[this.fromId]&&void 0!==this.body.nodes[this.toId]}}],[{key:"parseOptions",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},n=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=["endPointOffset","arrowStrikethrough","id","from","hidden","hoverWidth","labelHighlightBold","length","line","opacity","physics","scaling","selectionWidth","selfReferenceSize","selfReference","to","title","value","width","font","chosen","widthConstraint"];if(Za(r,t,e,i),void 0!==e.endPointOffset&&void 0!==e.endPointOffset.from&&(Ad(e.endPointOffset.from)?t.endPointOffset.from=e.endPointOffset.from:(t.endPointOffset.from=void 0!==o.endPointOffset.from?o.endPointOffset.from:0,console.error("endPointOffset.from is not a valid number"))),void 0!==e.endPointOffset&&void 0!==e.endPointOffset.to&&(Ad(e.endPointOffset.to)?t.endPointOffset.to=e.endPointOffset.to:(t.endPointOffset.to=void 0!==o.endPointOffset.to?o.endPointOffset.to:0,console.error("endPointOffset.to is not a valid number"))),Jd(e.label)?t.label=e.label:Jd(t.label)||(t.label=void 0),gh(t,e,"smooth",o),gh(t,e,"shadow",o),gh(t,e,"background",o),void 0!==e.dashes&&null!==e.dashes?t.dashes=e.dashes:!0===i&&null===e.dashes&&(t.dashes=Ir(o.dashes)),void 0!==e.scaling&&null!==e.scaling?(void 0!==e.scaling.min&&(t.scaling.min=e.scaling.min),void 0!==e.scaling.max&&(t.scaling.max=e.scaling.max),gh(t.scaling,e.scaling,"label",o.scaling)):!0===i&&null===e.scaling&&(t.scaling=Ir(o.scaling)),void 0!==e.arrows&&null!==e.arrows)if("string"==typeof e.arrows){var s=e.arrows.toLowerCase();t.arrows.to.enabled=-1!=Mr(s).call(s,"to"),t.arrows.middle.enabled=-1!=Mr(s).call(s,"middle"),t.arrows.from.enabled=-1!=Mr(s).call(s,"from")}else{if("object"!==dn(e.arrows))throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:"+Lr(e.arrows));gh(t.arrows,e.arrows,"to",o.arrows),gh(t.arrows,e.arrows,"middle",o.arrows),gh(t.arrows,e.arrows,"from",o.arrows)}else!0===i&&null===e.arrows&&(t.arrows=Ir(o.arrows));if(void 0!==e.color&&null!==e.color){var a=Ga(e.color)?{color:e.color,highlight:e.color,hover:e.color,inherit:!1,opacity:1}:e.color,h=t.color;if(n)th(h,o.color,!1,i);else for(var d in h)Object.prototype.hasOwnProperty.call(h,d)&&delete h[d];if(Ga(h))h.color=h,h.highlight=h,h.hover=h,h.inherit=!1,void 0===a.opacity&&(h.opacity=1);else{var l=!1;void 0!==a.color&&(h.color=a.color,l=!0),void 0!==a.highlight&&(h.highlight=a.highlight,l=!0),void 0!==a.hover&&(h.hover=a.hover,l=!0),void 0!==a.inherit&&(h.inherit=a.inherit),void 0!==a.opacity&&(h.opacity=Math.min(1,Math.max(0,a.opacity))),!0===l?h.inherit=!1:void 0===h.inherit&&(h.inherit="from")}}else!0===i&&null===e.color&&(t.color=vh(o.color));!0===i&&null===e.font&&(t.font=vh(o.font)),Object.prototype.hasOwnProperty.call(e,"selfReferenceSize")&&(console.warn("The selfReferenceSize property has been deprecated. Please use selfReference property instead. The selfReference can be set like thise selfReference:{size:30, angle:Math.PI / 4}"),t.selfReference.size=e.selfReferenceSize)}}]),t}(),tu=function(){function t(e,i,o){var n,r=this;Po(this,t),this.body=e,this.images=i,this.groups=o,this.body.functions.createEdge=bt(n=this.create).call(n,this),this.edgesListeners={add:function(t,e){r.add(e.items)},update:function(t,e){r.update(e.items)},remove:function(t,e){r.remove(e.items)}},this.options={},this.defaultOptions={arrows:{to:{enabled:!1,scaleFactor:1,type:"arrow"},middle:{enabled:!1,scaleFactor:1,type:"arrow"},from:{enabled:!1,scaleFactor:1,type:"arrow"}},endPointOffset:{from:0,to:0},arrowStrikethrough:!0,color:{color:"#848484",highlight:"#848484",hover:"#848484",inherit:"from",opacity:1},dashes:!1,font:{color:"#343434",size:14,face:"arial",background:"none",strokeWidth:2,strokeColor:"#ffffff",align:"horizontal",multi:!1,vadjust:0,bold:{mod:"bold"},boldital:{mod:"bold italic"},ital:{mod:"italic"},mono:{mod:"",size:15,face:"courier new",vadjust:2}},hidden:!1,hoverWidth:1.5,label:void 0,labelHighlightBold:!0,length:void 0,physics:!0,scaling:{min:1,max:15,label:{enabled:!0,min:14,max:30,maxVisible:30,drawThreshold:5},customScalingFunction:function(t,e,i,o){if(e===t)return.5;var n=1/(e-t);return Math.max(0,(o-t)*n)}},selectionWidth:1.5,selfReference:{size:20,angle:Math.PI/4,renderBehindTheNode:!0},shadow:{enabled:!1,color:"rgba(0,0,0,0.5)",size:10,x:5,y:5},background:{enabled:!1,color:"rgba(111,111,111,1)",size:10,dashes:!1},smooth:{enabled:!0,type:"dynamic",forceDirection:"none",roundness:.5},title:void 0,width:1,value:void 0},th(this.options,this.defaultOptions),this.bindEventListeners()}return Io(t,[{key:"bindEventListeners",value:function(){var t,e,i=this;this.body.emitter.on("_forceDisableDynamicCurves",(function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];"dynamic"===t&&(t="continuous");var o=!1;for(var n in i.body.edges)if(Object.prototype.hasOwnProperty.call(i.body.edges,n)){var r=i.body.edges[n],s=i.body.data.edges.get(n);if(null!=s){var a=s.smooth;void 0!==a&&!0===a.enabled&&"dynamic"===a.type&&(void 0===t?r.setOptions({smooth:!1}):r.setOptions({smooth:{type:t}}),o=!0)}}!0===e&&!0===o&&i.body.emitter.emit("_dataChanged")})),this.body.emitter.on("_dataUpdated",(function(){i.reconnectEdges()})),this.body.emitter.on("refreshEdges",bt(t=this.refresh).call(t,this)),this.body.emitter.on("refresh",bt(e=this.refresh).call(e,this)),this.body.emitter.on("destroy",(function(){nh(i.edgesListeners,(function(t,e){i.body.data.edges&&i.body.data.edges.off(e,t)})),delete i.body.functions.createEdge,delete i.edgesListeners.add,delete i.edgesListeners.update,delete i.edgesListeners.remove,delete i.edgesListeners}))}},{key:"setOptions",value:function(t){if(void 0!==t){Jc.parseOptions(this.options,t,!0,this.defaultOptions,!0);var e=!1;if(void 0!==t.smooth)for(var i in this.body.edges)Object.prototype.hasOwnProperty.call(this.body.edges,i)&&(e=this.body.edges[i].updateEdgeType()||e);if(void 0!==t.font)for(var o in this.body.edges)Object.prototype.hasOwnProperty.call(this.body.edges,o)&&this.body.edges[o].updateLabelModule();void 0===t.hidden&&void 0===t.physics&&!0!==e||this.body.emitter.emit("_dataChanged")}}},{key:"setData",value:function(t){var i=this,o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=this.body.data.edges;if(e.isDataViewLike("id",t))this.body.data.edges=t;else if(gn(t))this.body.data.edges=new e.DataSet,this.body.data.edges.add(t);else{if(t)throw new TypeError("Array or DataSet expected");this.body.data.edges=new e.DataSet}if(n&&nh(this.edgesListeners,(function(t,e){n.off(e,t)})),this.body.edges={},this.body.data.edges){nh(this.edgesListeners,(function(t,e){i.body.data.edges.on(e,t)}));var r=this.body.data.edges.getIds();this.add(r,!0)}this.body.emitter.emit("_adjustEdgesForHierarchicalLayout"),!1===o&&this.body.emitter.emit("_dataChanged")}},{key:"add",value:function(t){for(var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=this.body.edges,o=this.body.data.edges,n=0;n<t.length;n++){var r=t[n],s=i[r];s&&s.disconnect();var a=o.get(r,{showInternalIds:!0});i[r]=this.create(a)}this.body.emitter.emit("_adjustEdgesForHierarchicalLayout"),!1===e&&this.body.emitter.emit("_dataChanged")}},{key:"update",value:function(t){for(var e=this.body.edges,i=this.body.data.edges,o=!1,n=0;n<t.length;n++){var r=t[n],s=i.get(r),a=e[r];void 0!==a?(a.disconnect(),o=a.setOptions(s)||o,a.connect()):(this.body.edges[r]=this.create(s),o=!0)}!0===o?(this.body.emitter.emit("_adjustEdgesForHierarchicalLayout"),this.body.emitter.emit("_dataChanged")):this.body.emitter.emit("_dataUpdated")}},{key:"remove",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(0!==t.length){var i=this.body.edges;nh(t,(function(t){var e=i[t];void 0!==e&&e.remove()})),e&&this.body.emitter.emit("_dataChanged")}}},{key:"refresh",value:function(){var t=this;nh(this.body.edges,(function(e,i){var o=t.body.data.edges.get(i);void 0!==o&&e.setOptions(o)}))}},{key:"create",value:function(t){return new Jc(t,this.body,this.images,this.options,this.defaultOptions)}},{key:"reconnectEdges",value:function(){var t,e=this.body.nodes,i=this.body.edges;for(t in e)Object.prototype.hasOwnProperty.call(e,t)&&(e[t].edges=[]);for(t in i)if(Object.prototype.hasOwnProperty.call(i,t)){var o=i[t];o.from=null,o.to=null,o.connect()}}},{key:"getConnectedNodes",value:function(t){var e=[];if(void 0!==this.body.edges[t]){var i=this.body.edges[t];void 0!==i.fromId&&e.push(i.fromId),void 0!==i.toId&&e.push(i.toId)}return e}},{key:"_updateState",value:function(){this._addMissingEdges(),this._removeInvalidEdges()}},{key:"_removeInvalidEdges",value:function(){var t=this,e=[];nh(this.body.edges,(function(i,o){var n=t.body.nodes[i.toId],r=t.body.nodes[i.fromId];void 0!==n&&!0===n.isCluster||void 0!==r&&!0===r.isCluster||void 0!==n&&void 0!==r||e.push(o)})),this.remove(e,!1)}},{key:"_addMissingEdges",value:function(){var t=this.body.data.edges;if(null!=t){var e=this.body.edges,i=[];Dn(t).call(t,(function(t,o){void 0===e[o]&&i.push(o)})),this.add(i,!0)}}}]),t}(),eu=function(){function t(e,i,o){Po(this,t),this.body=e,this.physicsBody=i,this.barnesHutTree,this.setOptions(o),this._rng=Ra("BARNES HUT SOLVER")}return Io(t,[{key:"setOptions",value:function(t){this.options=t,this.thetaInversed=1/this.options.theta,this.overlapAvoidanceFactor=1-Math.max(0,Math.min(1,this.options.avoidOverlap))}},{key:"solve",value:function(){if(0!==this.options.gravitationalConstant&&this.physicsBody.physicsNodeIndices.length>0){var t,e=this.body.nodes,i=this.physicsBody.physicsNodeIndices,o=i.length,n=this._formBarnesHutTree(e,i);this.barnesHutTree=n;for(var r=0;r<o;r++)(t=e[i[r]]).options.mass>0&&this._getForceContributions(n.root,t)}}},{key:"_getForceContributions",value:function(t,e){this._getForceContribution(t.children.NW,e),this._getForceContribution(t.children.NE,e),this._getForceContribution(t.children.SW,e),this._getForceContribution(t.children.SE,e)}},{key:"_getForceContribution",value:function(t,e){if(t.childrenCount>0){var i=t.centerOfMass.x-e.x,o=t.centerOfMass.y-e.y,n=Math.sqrt(i*i+o*o);n*t.calcSize>this.thetaInversed?this._calculateForces(n,i,o,e,t):4===t.childrenCount?this._getForceContributions(t,e):t.children.data.id!=e.id&&this._calculateForces(n,i,o,e,t)}}},{key:"_calculateForces",value:function(t,e,i,o,n){0===t&&(e=t=.1),this.overlapAvoidanceFactor<1&&o.shape.radius&&(t=Math.max(.1+this.overlapAvoidanceFactor*o.shape.radius,t-o.shape.radius));var r=this.options.gravitationalConstant*n.mass*o.options.mass/Math.pow(t,3),s=e*r,a=i*r;this.physicsBody.forces[o.id].x+=s,this.physicsBody.forces[o.id].y+=a}},{key:"_formBarnesHutTree",value:function(t,e){for(var i,o=e.length,n=t[e[0]].x,r=t[e[0]].y,s=t[e[0]].x,a=t[e[0]].y,h=1;h<o;h++){var d=t[e[h]],l=d.x,c=d.y;d.options.mass>0&&(l<n&&(n=l),l>s&&(s=l),c<r&&(r=c),c>a&&(a=c))}var u=Math.abs(s-n)-Math.abs(a-r);u>0?(r-=.5*u,a+=.5*u):(n+=.5*u,s-=.5*u);var f=Math.max(1e-5,Math.abs(s-n)),p=.5*f,v=.5*(n+s),g=.5*(r+a),y={root:{centerOfMass:{x:0,y:0},mass:0,range:{minX:v-p,maxX:v+p,minY:g-p,maxY:g+p},size:f,calcSize:1/f,children:{data:null},maxWidth:0,level:0,childrenCount:4}};this._splitBranch(y.root);for(var m=0;m<o;m++)(i=t[e[m]]).options.mass>0&&this._placeInTree(y.root,i);return y}},{key:"_updateBranchMass",value:function(t,e){var i=t.centerOfMass,o=t.mass+e.options.mass,n=1/o;i.x=i.x*t.mass+e.x*e.options.mass,i.x*=n,i.y=i.y*t.mass+e.y*e.options.mass,i.y*=n,t.mass=o;var r=Math.max(Math.max(e.height,e.radius),e.width);t.maxWidth=t.maxWidth<r?r:t.maxWidth}},{key:"_placeInTree",value:function(t,e,i){1==i&&void 0!==i||this._updateBranchMass(t,e);var o,n=t.children.NW.range;o=n.maxX>e.x?n.maxY>e.y?"NW":"SW":n.maxY>e.y?"NE":"SE",this._placeInRegion(t,e,o)}},{key:"_placeInRegion",value:function(t,e,i){var o=t.children[i];switch(o.childrenCount){case 0:o.children.data=e,o.childrenCount=1,this._updateBranchMass(o,e);break;case 1:o.children.data.x===e.x&&o.children.data.y===e.y?(e.x+=this._rng(),e.y+=this._rng()):(this._splitBranch(o),this._placeInTree(o,e));break;case 4:this._placeInTree(o,e)}}},{key:"_splitBranch",value:function(t){var e=null;1===t.childrenCount&&(e=t.children.data,t.mass=0,t.centerOfMass.x=0,t.centerOfMass.y=0),t.childrenCount=4,t.children.data=null,this._insertRegion(t,"NW"),this._insertRegion(t,"NE"),this._insertRegion(t,"SW"),this._insertRegion(t,"SE"),null!=e&&this._placeInTree(t,e)}},{key:"_insertRegion",value:function(t,e){var i,o,n,r,s=.5*t.size;switch(e){case"NW":i=t.range.minX,o=t.range.minX+s,n=t.range.minY,r=t.range.minY+s;break;case"NE":i=t.range.minX+s,o=t.range.maxX,n=t.range.minY,r=t.range.minY+s;break;case"SW":i=t.range.minX,o=t.range.minX+s,n=t.range.minY+s,r=t.range.maxY;break;case"SE":i=t.range.minX+s,o=t.range.maxX,n=t.range.minY+s,r=t.range.maxY}t.children[e]={centerOfMass:{x:0,y:0},mass:0,range:{minX:i,maxX:o,minY:n,maxY:r},size:.5*t.size,calcSize:2*t.calcSize,children:{data:null},maxWidth:0,level:t.level+1,childrenCount:0}}},{key:"_debug",value:function(t,e){void 0!==this.barnesHutTree&&(t.lineWidth=1,this._drawBranch(this.barnesHutTree.root,t,e))}},{key:"_drawBranch",value:function(t,e,i){void 0===i&&(i="#FF0000"),4===t.childrenCount&&(this._drawBranch(t.children.NW,e),this._drawBranch(t.children.NE,e),this._drawBranch(t.children.SE,e),this._drawBranch(t.children.SW,e)),e.strokeStyle=i,e.beginPath(),e.moveTo(t.range.minX,t.range.minY),e.lineTo(t.range.maxX,t.range.minY),e.stroke(),e.beginPath(),e.moveTo(t.range.maxX,t.range.minY),e.lineTo(t.range.maxX,t.range.maxY),e.stroke(),e.beginPath(),e.moveTo(t.range.maxX,t.range.maxY),e.lineTo(t.range.minX,t.range.maxY),e.stroke(),e.beginPath(),e.moveTo(t.range.minX,t.range.maxY),e.lineTo(t.range.minX,t.range.minY),e.stroke()}}]),t}(),iu=function(){function t(e,i,o){Po(this,t),this._rng=Ra("REPULSION SOLVER"),this.body=e,this.physicsBody=i,this.setOptions(o)}return Io(t,[{key:"setOptions",value:function(t){this.options=t}},{key:"solve",value:function(){for(var t,e,i,o,n,r,s,a,h=this.body.nodes,d=this.physicsBody.physicsNodeIndices,l=this.physicsBody.forces,c=this.options.nodeDistance,u=-2/3/c,f=0;f<d.length-1;f++){s=h[d[f]];for(var p=f+1;p<d.length;p++)t=(a=h[d[p]]).x-s.x,e=a.y-s.y,0===(i=Math.sqrt(t*t+e*e))&&(t=i=.1*this._rng()),i<2*c&&(r=i<.5*c?1:u*i+1.3333333333333333,o=t*(r/=i),n=e*r,l[s.id].x-=o,l[s.id].y-=n,l[a.id].x+=o,l[a.id].y+=n)}}}]),t}(),ou=function(){function t(e,i,o){Po(this,t),this.body=e,this.physicsBody=i,this.setOptions(o)}return Io(t,[{key:"setOptions",value:function(t){this.options=t,this.overlapAvoidanceFactor=Math.max(0,Math.min(1,this.options.avoidOverlap||0))}},{key:"solve",value:function(){for(var t=this.body.nodes,e=this.physicsBody.physicsNodeIndices,i=this.physicsBody.forces,o=this.options.nodeDistance,n=0;n<e.length-1;n++)for(var r=t[e[n]],s=n+1;s<e.length;s++){var a=t[e[s]];if(r.level===a.level){var h=o+this.overlapAvoidanceFactor*((r.shape.radius||0)/2+(a.shape.radius||0)/2),d=a.x-r.x,l=a.y-r.y,c=Math.sqrt(d*d+l*l),u=void 0;u=c<h?-Math.pow(.05*c,2)+Math.pow(.05*h,2):0,0!==c&&(u/=c);var f=d*u,p=l*u;i[r.id].x-=f,i[r.id].y-=p,i[a.id].x+=f,i[a.id].y+=p}}}}]),t}(),nu=function(){function t(e,i,o){Po(this,t),this.body=e,this.physicsBody=i,this.setOptions(o)}return Io(t,[{key:"setOptions",value:function(t){this.options=t}},{key:"solve",value:function(){for(var t,e,i,o,n,r=this.physicsBody.physicsEdgeIndices,s=this.body.edges,a=0;a<r.length;a++)!0===(e=s[r[a]]).connected&&e.toId!==e.fromId&&void 0!==this.body.nodes[e.toId]&&void 0!==this.body.nodes[e.fromId]&&(void 0!==e.edgeType.via?(t=void 0===e.options.length?this.options.springLength:e.options.length,i=e.to,o=e.edgeType.via,n=e.from,this._calculateSpringForce(i,o,.5*t),this._calculateSpringForce(o,n,.5*t)):(t=void 0===e.options.length?1.5*this.options.springLength:e.options.length,this._calculateSpringForce(e.from,e.to,t)))}},{key:"_calculateSpringForce",value:function(t,e,i){var o=t.x-e.x,n=t.y-e.y,r=Math.max(Math.sqrt(o*o+n*n),.01),s=this.options.springConstant*(i-r)/r,a=o*s,h=n*s;void 0!==this.physicsBody.forces[t.id]&&(this.physicsBody.forces[t.id].x+=a,this.physicsBody.forces[t.id].y+=h),void 0!==this.physicsBody.forces[e.id]&&(this.physicsBody.forces[e.id].x-=a,this.physicsBody.forces[e.id].y-=h)}}]),t}(),ru=function(){function t(e,i,o){Po(this,t),this.body=e,this.physicsBody=i,this.setOptions(o)}return Io(t,[{key:"setOptions",value:function(t){this.options=t}},{key:"solve",value:function(){for(var t,e,i,o,n,r,s,a,h,d,l=this.body.edges,c=.5,u=this.physicsBody.physicsEdgeIndices,f=this.physicsBody.physicsNodeIndices,p=this.physicsBody.forces,v=0;v<f.length;v++){var g=f[v];p[g].springFx=0,p[g].springFy=0}for(var y=0;y<u.length;y++)!0===(e=l[u[y]]).connected&&(t=void 0===e.options.length?this.options.springLength:e.options.length,i=e.from.x-e.to.x,o=e.from.y-e.to.y,a=0===(a=Math.sqrt(i*i+o*o))?.01:a,n=i*(s=this.options.springConstant*(t-a)/a),r=o*s,e.to.level!=e.from.level?(void 0!==p[e.toId]&&(p[e.toId].springFx-=n,p[e.toId].springFy-=r),void 0!==p[e.fromId]&&(p[e.fromId].springFx+=n,p[e.fromId].springFy+=r)):(void 0!==p[e.toId]&&(p[e.toId].x-=c*n,p[e.toId].y-=c*r),void 0!==p[e.fromId]&&(p[e.fromId].x+=c*n,p[e.fromId].y+=c*r)));s=1;for(var m=0;m<f.length;m++){var b=f[m];h=Math.min(s,Math.max(-s,p[b].springFx)),d=Math.min(s,Math.max(-s,p[b].springFy)),p[b].x+=h,p[b].y+=d}for(var w=0,k=0,_=0;_<f.length;_++){var x=f[_];w+=p[x].x,k+=p[x].y}for(var E=w/f.length,O=k/f.length,C=0;C<f.length;C++){var S=f[C];p[S].x-=E,p[S].y-=O}}}]),t}(),su=function(){function t(e,i,o){Po(this,t),this.body=e,this.physicsBody=i,this.setOptions(o)}return Io(t,[{key:"setOptions",value:function(t){this.options=t}},{key:"solve",value:function(){for(var t,e,i,o,n=this.body.nodes,r=this.physicsBody.physicsNodeIndices,s=this.physicsBody.forces,a=0;a<r.length;a++){t=-(o=n[r[a]]).x,e=-o.y,i=Math.sqrt(t*t+e*e),this._calculateForces(i,t,e,s,o)}}},{key:"_calculateForces",value:function(t,e,i,o,n){var r=0===t?0:this.options.centralGravity/t;o[n.id].x=e*r,o[n.id].y=i*r}}]),t}();function au(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var hu=function(t){bl(i,t);var e=au(i);function i(t,o,n){var r;return Po(this,i),(r=e.call(this,t,o,n))._rng=Ra("FORCE ATLAS 2 BASED REPULSION SOLVER"),r}return Io(i,[{key:"_calculateForces",value:function(t,e,i,o,n){0===t&&(e=t=.1*this._rng()),this.overlapAvoidanceFactor<1&&o.shape.radius&&(t=Math.max(.1+this.overlapAvoidanceFactor*o.shape.radius,t-o.shape.radius));var r=o.edges.length+1,s=this.options.gravitationalConstant*n.mass*o.options.mass*r/Math.pow(t,2),a=e*s,h=i*s;this.physicsBody.forces[o.id].x+=a,this.physicsBody.forces[o.id].y+=h}}]),i}(eu);function du(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var lu,cu=function(t){bl(i,t);var e=du(i);function i(t,o,n){return Po(this,i),e.call(this,t,o,n)}return Io(i,[{key:"_calculateForces",value:function(t,e,i,o,n){if(t>0){var r=n.edges.length+1,s=this.options.centralGravity*r*n.options.mass;o[n.id].x=e*s,o[n.id].y=i*s}}}]),i}(su),uu=function(){function t(e){Po(this,t),this.body=e,this.physicsBody={physicsNodeIndices:[],physicsEdgeIndices:[],forces:{},velocities:{}},this.physicsEnabled=!0,this.simulationInterval=1e3/60,this.requiresTimeout=!0,this.previousStates={},this.referenceState={},this.freezeCache={},this.renderTimer=void 0,this.adaptiveTimestep=!1,this.adaptiveTimestepEnabled=!1,this.adaptiveCounter=0,this.adaptiveInterval=3,this.stabilized=!1,this.startedStabilization=!1,this.stabilizationIterations=0,this.ready=!1,this.options={},this.defaultOptions={enabled:!0,barnesHut:{theta:.5,gravitationalConstant:-2e3,centralGravity:.3,springLength:95,springConstant:.04,damping:.09,avoidOverlap:0},forceAtlas2Based:{theta:.5,gravitationalConstant:-50,centralGravity:.01,springConstant:.08,springLength:100,damping:.4,avoidOverlap:0},repulsion:{centralGravity:.2,springLength:200,springConstant:.05,nodeDistance:100,damping:.09,avoidOverlap:0},hierarchicalRepulsion:{centralGravity:0,springLength:100,springConstant:.01,nodeDistance:120,damping:.09},maxVelocity:50,minVelocity:.75,solver:"barnesHut",stabilization:{enabled:!0,iterations:1e3,updateInterval:50,onlyDynamicEdges:!1,fit:!0},timestep:.5,adaptiveTimestep:!0,wind:{x:0,y:0}},ct(this.options,this.defaultOptions),this.timestep=.5,this.layoutFailed=!1,this.bindEventListeners()}return Io(t,[{key:"bindEventListeners",value:function(){var t=this;this.body.emitter.on("initPhysics",(function(){t.initPhysics()})),this.body.emitter.on("_layoutFailed",(function(){t.layoutFailed=!0})),this.body.emitter.on("resetPhysics",(function(){t.stopSimulation(),t.ready=!1})),this.body.emitter.on("disablePhysics",(function(){t.physicsEnabled=!1,t.stopSimulation()})),this.body.emitter.on("restorePhysics",(function(){t.setOptions(t.options),!0===t.ready&&t.startSimulation()})),this.body.emitter.on("startSimulation",(function(){!0===t.ready&&t.startSimulation()})),this.body.emitter.on("stopSimulation",(function(){t.stopSimulation()})),this.body.emitter.on("destroy",(function(){t.stopSimulation(!1),t.body.emitter.off()})),this.body.emitter.on("_dataChanged",(function(){t.updatePhysicsData()}))}},{key:"setOptions",value:function(t){if(void 0!==t)if(!1===t)this.options.enabled=!1,this.physicsEnabled=!1,this.stopSimulation();else if(!0===t)this.options.enabled=!0,this.physicsEnabled=!0,this.startSimulation();else{this.physicsEnabled=!0,Ja(["stabilization"],this.options,t),gh(this.options,t,"stabilization"),void 0===t.enabled&&(this.options.enabled=!0),!1===this.options.enabled&&(this.physicsEnabled=!1,this.stopSimulation());var e=this.options.wind;e&&(("number"!=typeof e.x||zd(e.x))&&(e.x=0),("number"!=typeof e.y||zd(e.y))&&(e.y=0)),this.timestep=this.options.timestep}this.init()}},{key:"init",value:function(){var t;"forceAtlas2Based"===this.options.solver?(t=this.options.forceAtlas2Based,this.nodesSolver=new hu(this.body,this.physicsBody,t),this.edgesSolver=new nu(this.body,this.physicsBody,t),this.gravitySolver=new cu(this.body,this.physicsBody,t)):"repulsion"===this.options.solver?(t=this.options.repulsion,this.nodesSolver=new iu(this.body,this.physicsBody,t),this.edgesSolver=new nu(this.body,this.physicsBody,t),this.gravitySolver=new su(this.body,this.physicsBody,t)):"hierarchicalRepulsion"===this.options.solver?(t=this.options.hierarchicalRepulsion,this.nodesSolver=new ou(this.body,this.physicsBody,t),this.edgesSolver=new ru(this.body,this.physicsBody,t),this.gravitySolver=new su(this.body,this.physicsBody,t)):(t=this.options.barnesHut,this.nodesSolver=new eu(this.body,this.physicsBody,t),this.edgesSolver=new nu(this.body,this.physicsBody,t),this.gravitySolver=new su(this.body,this.physicsBody,t)),this.modelOptions=t}},{key:"initPhysics",value:function(){!0===this.physicsEnabled&&!0===this.options.enabled?!0===this.options.stabilization.enabled?this.stabilize():(this.stabilized=!1,this.ready=!0,this.body.emitter.emit("fit",{},this.layoutFailed),this.startSimulation()):(this.ready=!0,this.body.emitter.emit("fit"))}},{key:"startSimulation",value:function(){var t;!0===this.physicsEnabled&&!0===this.options.enabled?(this.stabilized=!1,this.adaptiveTimestep=!1,this.body.emitter.emit("_resizeNodes"),void 0===this.viewFunction&&(this.viewFunction=bt(t=this.simulationStep).call(t,this),this.body.emitter.on("initRedraw",this.viewFunction),this.body.emitter.emit("_startRendering"))):this.body.emitter.emit("_redraw")}},{key:"stopSimulation",value:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.stabilized=!0,!0===t&&this._emitStabilized(),void 0!==this.viewFunction&&(this.body.emitter.off("initRedraw",this.viewFunction),this.viewFunction=void 0,!0===t&&this.body.emitter.emit("_stopRendering"))}},{key:"simulationStep",value:function(){var t=En();this.physicsTick(),(En()-t<.4*this.simulationInterval||!0===this.runDoubleSpeed)&&!1===this.stabilized&&(this.physicsTick(),this.runDoubleSpeed=!0),!0===this.stabilized&&this.stopSimulation()}},{key:"_emitStabilized",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.stabilizationIterations;(this.stabilizationIterations>1||!0===this.startedStabilization)&&qr((function(){t.body.emitter.emit("stabilized",{iterations:e}),t.startedStabilization=!1,t.stabilizationIterations=0}),0)}},{key:"physicsStep",value:function(){this.gravitySolver.solve(),this.nodesSolver.solve(),this.edgesSolver.solve(),this.moveNodes()}},{key:"adjustTimeStep",value:function(){!0===this._evaluateStepQuality()?this.timestep=1.2*this.timestep:this.timestep/1.2<this.options.timestep?this.timestep=this.options.timestep:(this.adaptiveCounter=-1,this.timestep=Math.max(this.options.timestep,this.timestep/1.2))}},{key:"physicsTick",value:function(){if(this._startStabilizing(),!0!==this.stabilized){if(!0===this.adaptiveTimestep&&!0===this.adaptiveTimestepEnabled)this.adaptiveCounter%this.adaptiveInterval==0?(this.timestep=2*this.timestep,this.physicsStep(),this.revert(),this.timestep=.5*this.timestep,this.physicsStep(),this.physicsStep(),this.adjustTimeStep()):this.physicsStep(),this.adaptiveCounter+=1;else this.timestep=this.options.timestep,this.physicsStep();!0===this.stabilized&&this.revert(),this.stabilizationIterations++}}},{key:"updatePhysicsData",value:function(){this.physicsBody.forces={},this.physicsBody.physicsNodeIndices=[],this.physicsBody.physicsEdgeIndices=[];var t=this.body.nodes,e=this.body.edges;for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&!0===t[i].options.physics&&this.physicsBody.physicsNodeIndices.push(t[i].id);for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&!0===e[o].options.physics&&this.physicsBody.physicsEdgeIndices.push(e[o].id);for(var n=0;n<this.physicsBody.physicsNodeIndices.length;n++){var r=this.physicsBody.physicsNodeIndices[n];this.physicsBody.forces[r]={x:0,y:0},void 0===this.physicsBody.velocities[r]&&(this.physicsBody.velocities[r]={x:0,y:0})}for(var s in this.physicsBody.velocities)void 0===t[s]&&delete this.physicsBody.velocities[s]}},{key:"revert",value:function(){var t=xn(this.previousStates),e=this.body.nodes,i=this.physicsBody.velocities;this.referenceState={};for(var o=0;o<t.length;o++){var n=t[o];void 0!==e[n]?!0===e[n].options.physics&&(this.referenceState[n]={positions:{x:e[n].x,y:e[n].y}},i[n].x=this.previousStates[n].vx,i[n].y=this.previousStates[n].vy,e[n].x=this.previousStates[n].x,e[n].y=this.previousStates[n].y):delete this.previousStates[n]}}},{key:"_evaluateStepQuality",value:function(){var t,e,i=this.body.nodes,o=this.referenceState;for(var n in this.referenceState)if(Object.prototype.hasOwnProperty.call(this.referenceState,n)&&void 0!==i[n]&&(t=i[n].x-o[n].positions.x,e=i[n].y-o[n].positions.y,Math.sqrt(Math.pow(t,2)+Math.pow(e,2))>.3))return!1;return!0}},{key:"moveNodes",value:function(){for(var t=this.physicsBody.physicsNodeIndices,e=0,i=0,o=0;o<t.length;o++){var n=t[o],r=this._performStep(n);e=Math.max(e,r),i+=r}this.adaptiveTimestepEnabled=i/t.length<5,this.stabilized=e<this.options.minVelocity}},{key:"calculateComponentVelocity",value:function(t,e,i){t+=(e-this.modelOptions.damping*t)/i*this.timestep;var o=this.options.maxVelocity||1e9;return Math.abs(t)>o&&(t=t>0?o:-o),t}},{key:"_performStep",value:function(t){var e=this.body.nodes[t],i=this.physicsBody.forces[t];this.options.wind&&(i.x+=this.options.wind.x,i.y+=this.options.wind.y);var o=this.physicsBody.velocities[t];return this.previousStates[t]={x:e.x,y:e.y,vx:o.x,vy:o.y},!1===e.options.fixed.x?(o.x=this.calculateComponentVelocity(o.x,i.x,e.options.mass),e.x+=o.x*this.timestep):(i.x=0,o.x=0),!1===e.options.fixed.y?(o.y=this.calculateComponentVelocity(o.y,i.y,e.options.mass),e.y+=o.y*this.timestep):(i.y=0,o.y=0),Math.sqrt(Math.pow(o.x,2)+Math.pow(o.y,2))}},{key:"_freezeNodes",value:function(){var t=this.body.nodes;for(var e in t)if(Object.prototype.hasOwnProperty.call(t,e)&&t[e].x&&t[e].y){var i=t[e].options.fixed;this.freezeCache[e]={x:i.x,y:i.y},i.x=!0,i.y=!0}}},{key:"_restoreFrozenNodes",value:function(){var t=this.body.nodes;for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&void 0!==this.freezeCache[e]&&(t[e].options.fixed.x=this.freezeCache[e].x,t[e].options.fixed.y=this.freezeCache[e].y);this.freezeCache={}}},{key:"stabilize",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.stabilization.iterations;"number"!=typeof e&&(e=this.options.stabilization.iterations,console.error("The stabilize method needs a numeric amount of iterations. Switching to default: ",e)),0!==this.physicsBody.physicsNodeIndices.length?(this.adaptiveTimestep=this.options.adaptiveTimestep,this.body.emitter.emit("_resizeNodes"),this.stopSimulation(),this.stabilized=!1,this.body.emitter.emit("_blockRedraw"),this.targetIterations=e,!0===this.options.stabilization.onlyDynamicEdges&&this._freezeNodes(),this.stabilizationIterations=0,qr((function(){return t._stabilizationBatch()}),0)):this.ready=!0}},{key:"_startStabilizing",value:function(){return!0!==this.startedStabilization&&(this.body.emitter.emit("startStabilizing"),this.startedStabilization=!0,!0)}},{key:"_stabilizationBatch",value:function(){var t=this,e=function(){return!1===t.stabilized&&t.stabilizationIterations<t.targetIterations},i=function(){t.body.emitter.emit("stabilizationProgress",{iterations:t.stabilizationIterations,total:t.targetIterations})};this._startStabilizing()&&i();for(var o,n=0;e()&&n<this.options.stabilization.updateInterval;)this.physicsTick(),n++;(i(),e())?qr(bt(o=this._stabilizationBatch).call(o,this),0):this._finalizeStabilization()}},{key:"_finalizeStabilization",value:function(){this.body.emitter.emit("_allowRedraw"),!0===this.options.stabilization.fit&&this.body.emitter.emit("fit"),!0===this.options.stabilization.onlyDynamicEdges&&this._restoreFrozenNodes(),this.body.emitter.emit("stabilizationIterationsDone"),this.body.emitter.emit("_requestRedraw"),!0===this.stabilized?this._emitStabilized():this.startSimulation(),this.ready=!0}},{key:"_drawForces",value:function(t){for(var e=0;e<this.physicsBody.physicsNodeIndices.length;e++){var i=this.physicsBody.physicsNodeIndices[e],o=this.body.nodes[i],n=this.physicsBody.forces[i],r=Math.sqrt(Math.pow(n.x,2)+Math.pow(n.x,2)),s=Math.min(Math.max(5,r),15),a=3*s,h=ch((180-180*Math.min(1,Math.max(0,.03*r)))/360,1,1),d={x:o.x+20*n.x,y:o.y+20*n.y};t.lineWidth=s,t.strokeStyle=h,t.beginPath(),t.moveTo(o.x,o.y),t.lineTo(d.x,d.y),t.stroke();var l=Math.atan2(n.y,n.x);t.fillStyle=h,Nc.draw(t,{type:"arrow",point:d,angle:l,length:a}),Xr(t).call(t)}}}]),t}(),fu=new Uint8Array(16);function pu(){if(!lu&&!(lu="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return lu(fu)}var vu=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function gu(t){return"string"==typeof t&&vu.test(t)}for(var yu=[],mu=0;mu<256;++mu)yu.push((mu+256).toString(16).substr(1));function bu(t,e,i){var o=(t=t||{}).random||(t.rng||pu)();if(o[6]=15&o[6]|64,o[8]=63&o[8]|128,e){i=i||0;for(var n=0;n<16;++n)e[i+n]=o[n];return e}return function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=(yu[t[e+0]]+yu[t[e+1]]+yu[t[e+2]]+yu[t[e+3]]+"-"+yu[t[e+4]]+yu[t[e+5]]+"-"+yu[t[e+6]]+yu[t[e+7]]+"-"+yu[t[e+8]]+yu[t[e+9]]+"-"+yu[t[e+10]]+yu[t[e+11]]+yu[t[e+12]]+yu[t[e+13]]+yu[t[e+14]]+yu[t[e+15]]).toLowerCase();if(!gu(i))throw TypeError("Stringified UUID is invalid");return i}(o)}var wu=function(){function t(){Po(this,t)}return Io(t,null,[{key:"getRange",value:function(t){var e,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],o=1e9,n=-1e9,r=1e9,s=-1e9;if(i.length>0)for(var a=0;a<i.length;a++)r>(e=t[i[a]]).shape.boundingBox.left&&(r=e.shape.boundingBox.left),s<e.shape.boundingBox.right&&(s=e.shape.boundingBox.right),o>e.shape.boundingBox.top&&(o=e.shape.boundingBox.top),n<e.shape.boundingBox.bottom&&(n=e.shape.boundingBox.bottom);return 1e9===r&&-1e9===s&&1e9===o&&-1e9===n&&(o=0,n=0,r=0,s=0),{minX:r,maxX:s,minY:o,maxY:n}}},{key:"getRangeCore",value:function(t){var e,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],o=1e9,n=-1e9,r=1e9,s=-1e9;if(i.length>0)for(var a=0;a<i.length;a++)r>(e=t[i[a]]).x&&(r=e.x),s<e.x&&(s=e.x),o>e.y&&(o=e.y),n<e.y&&(n=e.y);return 1e9===r&&-1e9===s&&1e9===o&&-1e9===n&&(o=0,n=0,r=0,s=0),{minX:r,maxX:s,minY:o,maxY:n}}},{key:"findCenter",value:function(t){return{x:.5*(t.maxX+t.minX),y:.5*(t.maxY+t.minY)}}},{key:"cloneOptions",value:function(t,e){var i={};return void 0===e||"node"===e?(th(i,t.options,!0),i.x=t.x,i.y=t.y,i.amountOfConnections=t.edges.length):th(i,t.options,!0),i}}]),t}();function ku(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var _u=function(t){bl(i,t);var e=ku(i);function i(t,o,n,r,s,a){var h;return Po(this,i),(h=e.call(this,t,o,n,r,s,a)).isCluster=!0,h.containedNodes={},h.containedEdges={},h}return Io(i,[{key:"_openChildCluster",value:function(t){var e=this,i=this.body.nodes[t];if(void 0===this.containedNodes[t])throw new Error("node with id: "+t+" not in current cluster");if(!i.isCluster)throw new Error("node with id: "+t+" is not a cluster");delete this.containedNodes[t],nh(i.edges,(function(t){delete e.containedEdges[t.id]})),nh(i.containedNodes,(function(t,i){e.containedNodes[i]=t})),i.containedNodes={},nh(i.containedEdges,(function(t,i){e.containedEdges[i]=t})),i.containedEdges={},nh(i.edges,(function(t){nh(e.edges,(function(i){var o,n,r=Mr(o=i.clusteringEdgeReplacingIds).call(o,t.id);-1!==r&&(nh(t.clusteringEdgeReplacingIds,(function(t){i.clusteringEdgeReplacingIds.push(t),e.body.edges[t].edgeReplacedById=i.id})),qn(n=i.clusteringEdgeReplacingIds).call(n,r,1))}))})),i.edges=[]}}]),i}(lc),xu=function(){function t(e){var i=this;Po(this,t),this.body=e,this.clusteredNodes={},this.clusteredEdges={},this.options={},this.defaultOptions={},ct(this.options,this.defaultOptions),this.body.emitter.on("_resetData",(function(){i.clusteredNodes={},i.clusteredEdges={}}))}return Io(t,[{key:"clusterByHubsize",value:function(t,e){void 0===t?t=this._getHubSize():"object"===dn(t)&&(e=this._checkOptions(t),t=this._getHubSize());for(var i=[],o=0;o<this.body.nodeIndices.length;o++){var n=this.body.nodes[this.body.nodeIndices[o]];n.edges.length>=t&&i.push(n.id)}for(var r=0;r<i.length;r++)this.clusterByConnection(i[r],e,!0);this.body.emitter.emit("_dataChanged")}},{key:"cluster",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(void 0===e.joinCondition)throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");e=this._checkOptions(e);var o={},n={};nh(this.body.nodes,(function(i,r){i.options&&!0===e.joinCondition(i.options)&&(o[r]=i,nh(i.edges,(function(e){void 0===t.clusteredEdges[e.id]&&(n[e.id]=e)})))})),this._cluster(o,n,e,i)}},{key:"clusterByEdgeCount",value:function(t,e){var i=this,o=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];e=this._checkOptions(e);for(var n,r,s,a=[],h={},d=function(o){var d={},l={},c=i.body.nodeIndices[o],u=i.body.nodes[c];if(void 0===h[c]){s=0,r=[];for(var f=0;f<u.edges.length;f++)n=u.edges[f],void 0===i.clusteredEdges[n.id]&&(n.toId!==n.fromId&&s++,r.push(n));if(s===t){for(var p=function(t){if(void 0===e.joinCondition||null===e.joinCondition)return!0;var i=wu.cloneOptions(t);return e.joinCondition(i)},v=!0,g=0;g<r.length;g++){n=r[g];var y=i._getConnectedId(n,c);if(!p(u)){v=!1;break}l[n.id]=n,d[c]=u,d[y]=i.body.nodes[y],h[c]=!0}if(xn(d).length>0&&xn(l).length>0&&!0===v){var m=function(){for(var t=0;t<a.length;++t)for(var e in d)if(void 0!==a[t].nodes[e])return a[t]}();if(void 0!==m){for(var b in d)void 0===m.nodes[b]&&(m.nodes[b]=d[b]);for(var w in l)void 0===m.edges[w]&&(m.edges[w]=l[w])}else a.push({nodes:d,edges:l})}}}},l=0;l<this.body.nodeIndices.length;l++)d(l);for(var c=0;c<a.length;c++)this._cluster(a[c].nodes,a[c].edges,e,!1);!0===o&&this.body.emitter.emit("_dataChanged")}},{key:"clusterOutliers",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this.clusterByEdgeCount(1,t,e)}},{key:"clusterBridges",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this.clusterByEdgeCount(2,t,e)}},{key:"clusterByConnection",value:function(t,e){var i,o=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(void 0===t)throw new Error("No nodeId supplied to clusterByConnection!");if(void 0===this.body.nodes[t])throw new Error("The nodeId given to clusterByConnection does not exist!");var n=this.body.nodes[t];void 0===(e=this._checkOptions(e,n)).clusterNodeProperties.x&&(e.clusterNodeProperties.x=n.x),void 0===e.clusterNodeProperties.y&&(e.clusterNodeProperties.y=n.y),void 0===e.clusterNodeProperties.fixed&&(e.clusterNodeProperties.fixed={},e.clusterNodeProperties.fixed.x=n.options.fixed.x,e.clusterNodeProperties.fixed.y=n.options.fixed.y);var r={},s={},a=n.id,h=wu.cloneOptions(n);r[a]=n;for(var d=0;d<n.edges.length;d++){var l=n.edges[d];if(void 0===this.clusteredEdges[l.id]){var c=this._getConnectedId(l,a);if(void 0===this.clusteredNodes[c])if(c!==a)if(void 0===e.joinCondition)s[l.id]=l,r[c]=this.body.nodes[c];else{var u=wu.cloneOptions(this.body.nodes[c]);!0===e.joinCondition(h,u)&&(s[l.id]=l,r[c]=this.body.nodes[c])}else s[l.id]=l}}var f=kn(i=xn(r)).call(i,(function(t){return r[t].id}));for(var p in r)if(Object.prototype.hasOwnProperty.call(r,p))for(var v=r[p],g=0;g<v.edges.length;g++){var y=v.edges[g];Mr(f).call(f,this._getConnectedId(y,v.id))>-1&&(s[y.id]=y)}this._cluster(r,s,e,o)}},{key:"_createClusterEdges",value:function(t,e,i,o){for(var n,r,s,a,h,d,l=xn(t),c=[],u=0;u<l.length;u++){s=t[r=l[u]];for(var f=0;f<s.edges.length;f++)n=s.edges[f],void 0===this.clusteredEdges[n.id]&&(n.toId==n.fromId?e[n.id]=n:n.toId==r?(a=i.id,d=h=n.fromId):(a=n.toId,h=i.id,d=a),void 0===t[d]&&c.push({edge:n,fromId:h,toId:a}))}for(var p=[],v=function(t){for(var e=0;e<p.length;e++){var i=p[e],o=t.fromId===i.fromId&&t.toId===i.toId,n=t.fromId===i.toId&&t.toId===i.fromId;if(o||n)return i}return null},g=0;g<c.length;g++){var y=c[g],m=y.edge,b=v(y);null===b?(b=this._createClusteredEdge(y.fromId,y.toId,m,o),p.push(b)):b.clusteringEdgeReplacingIds.push(m.id),this.body.edges[m.id].edgeReplacedById=b.id,this._backupEdgeOptions(m),m.setOptions({physics:!1})}}},{key:"_checkOptions",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return void 0===t.clusterEdgeProperties&&(t.clusterEdgeProperties={}),void 0===t.clusterNodeProperties&&(t.clusterNodeProperties={}),t}},{key:"_cluster",value:function(t,e,i){var o=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],n=[];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&void 0!==this.clusteredNodes[r]&&n.push(r);for(var s=0;s<n.length;++s)delete t[n[s]];if(0!=xn(t).length&&(1!=xn(t).length||1==i.clusterNodeProperties.allowSingleNodeCluster)){var a=th({},i.clusterNodeProperties);if(void 0!==i.processProperties){var h=[];for(var d in t)if(Object.prototype.hasOwnProperty.call(t,d)){var l=wu.cloneOptions(t[d]);h.push(l)}var c=[];for(var u in e)if(Object.prototype.hasOwnProperty.call(e,u)&&"clusterEdge:"!==u.substr(0,12)){var f=wu.cloneOptions(e[u],"edge");c.push(f)}if(!(a=i.processProperties(a,h,c)))throw new Error("The processProperties function does not return properties!")}void 0===a.id&&(a.id="cluster:"+bu());var p=a.id;void 0===a.label&&(a.label="cluster");var v=void 0;void 0===a.x&&(v=this._getClusterPosition(t),a.x=v.x),void 0===a.y&&(void 0===v&&(v=this._getClusterPosition(t)),a.y=v.y),a.id=p;var g=this.body.functions.createNode(a,_u);g.containedNodes=t,g.containedEdges=e,g.clusterEdgeProperties=i.clusterEdgeProperties,this.body.nodes[a.id]=g,this._clusterEdges(t,e,a,i.clusterEdgeProperties),a.id=void 0,!0===o&&this.body.emitter.emit("_dataChanged")}}},{key:"_backupEdgeOptions",value:function(t){void 0===this.clusteredEdges[t.id]&&(this.clusteredEdges[t.id]={physics:t.options.physics})}},{key:"_restoreEdge",value:function(t){var e=this.clusteredEdges[t.id];void 0!==e&&(t.setOptions({physics:e.physics}),delete this.clusteredEdges[t.id])}},{key:"isCluster",value:function(t){return void 0!==this.body.nodes[t]?!0===this.body.nodes[t].isCluster:(console.error("Node does not exist."),!1)}},{key:"_getClusterPosition",value:function(t){for(var e,i=xn(t),o=t[i[0]].x,n=t[i[0]].x,r=t[i[0]].y,s=t[i[0]].y,a=1;a<i.length;a++)o=(e=t[i[a]]).x<o?e.x:o,n=e.x>n?e.x:n,r=e.y<r?e.y:r,s=e.y>s?e.y:s;return{x:.5*(o+n),y:.5*(r+s)}}},{key:"openCluster",value:function(t,e){var i=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(void 0===t)throw new Error("No clusterNodeId supplied to openCluster.");var o=this.body.nodes[t];if(void 0===o)throw new Error("The clusterNodeId supplied to openCluster does not exist.");if(!0!==o.isCluster||void 0===o.containedNodes||void 0===o.containedEdges)throw new Error("The node:"+t+" is not a valid cluster.");var n=this.findNode(t),r=Mr(n).call(n,t)-1;if(r>=0){var s=n[r],a=this.body.nodes[s];return a._openChildCluster(t),delete this.body.nodes[t],void(!0===i&&this.body.emitter.emit("_dataChanged"))}var h=o.containedNodes,d=o.containedEdges;if(void 0!==e&&void 0!==e.releaseFunction&&"function"==typeof e.releaseFunction){var l={},c={x:o.x,y:o.y};for(var u in h)if(Object.prototype.hasOwnProperty.call(h,u)){var f=this.body.nodes[u];l[u]={x:f.x,y:f.y}}var p=e.releaseFunction(c,l);for(var v in h)if(Object.prototype.hasOwnProperty.call(h,v)){var g=this.body.nodes[v];void 0!==p[v]&&(g.x=void 0===p[v].x?o.x:p[v].x,g.y=void 0===p[v].y?o.y:p[v].y)}}else nh(h,(function(t){!1===t.options.fixed.x&&(t.x=o.x),!1===t.options.fixed.y&&(t.y=o.y)}));for(var y in h)if(Object.prototype.hasOwnProperty.call(h,y)){var m=this.body.nodes[y];m.vx=o.vx,m.vy=o.vy,m.setOptions({physics:!0}),delete this.clusteredNodes[y]}for(var b=[],w=0;w<o.edges.length;w++)b.push(o.edges[w]);for(var k=0;k<b.length;k++){for(var _=b[k],x=this._getConnectedId(_,t),E=this.clusteredNodes[x],O=0;O<_.clusteringEdgeReplacingIds.length;O++){var C=_.clusteringEdgeReplacingIds[O],S=this.body.edges[C];if(void 0!==S)if(void 0!==E){var T=this.body.nodes[E.clusterId];T.containedEdges[S.id]=S,delete d[S.id];var M=S.fromId,P=S.toId;S.toId==x?P=E.clusterId:M=E.clusterId,this._createClusteredEdge(M,P,S,T.clusterEdgeProperties,{hidden:!1,physics:!0})}else this._restoreEdge(S)}_.remove()}for(var D in d)Object.prototype.hasOwnProperty.call(d,D)&&this._restoreEdge(d[D]);delete this.body.nodes[t],!0===i&&this.body.emitter.emit("_dataChanged")}},{key:"getNodesInCluster",value:function(t){var e=[];if(!0===this.isCluster(t)){var i=this.body.nodes[t].containedNodes;for(var o in i)Object.prototype.hasOwnProperty.call(i,o)&&e.push(this.body.nodes[o].id)}return e}},{key:"findNode",value:function(t){for(var e,i=[],o=0;void 0!==this.clusteredNodes[t]&&o<100;){if(void 0===(e=this.body.nodes[t]))return[];i.push(e.id),t=this.clusteredNodes[t].clusterId,o++}return void 0===(e=this.body.nodes[t])?[]:(i.push(e.id),Nn(i).call(i),i)}},{key:"updateClusteredNode",value:function(t,e){if(void 0===t)throw new Error("No clusteredNodeId supplied to updateClusteredNode.");if(void 0===e)throw new Error("No newOptions supplied to updateClusteredNode.");if(void 0===this.body.nodes[t])throw new Error("The clusteredNodeId supplied to updateClusteredNode does not exist.");this.body.nodes[t].setOptions(e),this.body.emitter.emit("_dataChanged")}},{key:"updateEdge",value:function(t,e){if(void 0===t)throw new Error("No startEdgeId supplied to updateEdge.");if(void 0===e)throw new Error("No newOptions supplied to updateEdge.");if(void 0===this.body.edges[t])throw new Error("The startEdgeId supplied to updateEdge does not exist.");for(var i=this.getClusteredEdges(t),o=0;o<i.length;o++){this.body.edges[i[o]].setOptions(e)}this.body.emitter.emit("_dataChanged")}},{key:"getClusteredEdges",value:function(t){for(var e=[],i=0;void 0!==t&&void 0!==this.body.edges[t]&&i<100;)e.push(this.body.edges[t].id),t=this.body.edges[t].edgeReplacedById,i++;return Nn(e).call(e),e}},{key:"getBaseEdge",value:function(t){return this.getBaseEdges(t)[0]}},{key:"getBaseEdges",value:function(t){for(var e=[t],i=[],o=[],n=0;e.length>0&&n<100;){var r=e.pop();if(void 0!==r){var s=this.body.edges[r];if(void 0!==s){n++;var a=s.clusteringEdgeReplacingIds;if(void 0===a)o.push(r);else for(var h=0;h<a.length;++h){var d=a[h];-1===Mr(e).call(e,a)&&-1===Mr(i).call(i,a)&&e.push(d)}i.push(r)}}}return o}},{key:"_getConnectedId",value:function(t,e){return t.toId!=e?t.toId:(t.fromId,t.fromId)}},{key:"_getHubSize",value:function(){for(var t=0,e=0,i=0,o=0,n=0;n<this.body.nodeIndices.length;n++){var r=this.body.nodes[this.body.nodeIndices[n]];r.edges.length>o&&(o=r.edges.length),t+=r.edges.length,e+=Math.pow(r.edges.length,2),i+=1}t/=i;var s=(e/=i)-Math.pow(t,2),a=Math.sqrt(s),h=Math.floor(t+2*a);return h>o&&(h=o),h}},{key:"_createClusteredEdge",value:function(t,e,i,o,n){var r=wu.cloneOptions(i,"edge");th(r,o),r.from=t,r.to=e,r.id="clusterEdge:"+bu(),void 0!==n&&th(r,n);var s=this.body.functions.createEdge(r);return s.clusteringEdgeReplacingIds=[i.id],s.connect(),this.body.edges[s.id]=s,s}},{key:"_clusterEdges",value:function(t,e,i,o){if(e instanceof Jc){var n=e,r={};r[n.id]=n,e=r}if(t instanceof lc){var s=t,a={};a[s.id]=s,t=a}if(null==i)throw new Error("_clusterEdges: parameter clusterNode required");for(var h in void 0===o&&(o=i.clusterEdgeProperties),this._createClusterEdges(t,e,i,o),e)if(Object.prototype.hasOwnProperty.call(e,h)&&void 0!==this.body.edges[h]){var d=this.body.edges[h];this._backupEdgeOptions(d),d.setOptions({physics:!1})}for(var l in t)Object.prototype.hasOwnProperty.call(t,l)&&(this.clusteredNodes[l]={clusterId:i.id,node:this.body.nodes[l]},this.body.nodes[l].setOptions({physics:!1}))}},{key:"_getClusterNodeForNode",value:function(t){if(void 0!==t){var e=this.clusteredNodes[t];if(void 0!==e){var i=e.clusterId;if(void 0!==i)return this.body.nodes[i]}}}},{key:"_filter",value:function(t,e){var i=[];return nh(t,(function(t){e(t)&&i.push(t)})),i}},{key:"_updateState",value:function(){var t,e=this,i=[],o={},n=function(t){nh(e.body.nodes,(function(e){!0===e.isCluster&&t(e)}))};for(t in this.clusteredNodes){if(Object.prototype.hasOwnProperty.call(this.clusteredNodes,t))void 0===this.body.nodes[t]&&i.push(t)}n((function(t){for(var e=0;e<i.length;e++)delete t.containedNodes[i[e]]}));for(var r=0;r<i.length;r++)delete this.clusteredNodes[i[r]];nh(this.clusteredEdges,(function(t){var i=e.body.edges[t];void 0!==i&&i.endPointsValid()||(o[t]=t)})),n((function(t){nh(t.containedEdges,(function(t,e){t.endPointsValid()||o[e]||(o[e]=e)}))})),nh(this.body.edges,(function(t,i){var n=!0,r=t.clusteringEdgeReplacingIds;if(void 0!==r){var s=0;nh(r,(function(t){var i=e.body.edges[t];void 0!==i&&i.endPointsValid()&&(s+=1)})),n=s>0}t.endPointsValid()&&n||(o[i]=i)})),n((function(t){nh(o,(function(i){delete t.containedEdges[i],nh(t.edges,(function(n,r){n.id!==i?n.clusteringEdgeReplacingIds=e._filter(n.clusteringEdgeReplacingIds,(function(t){return!o[t]})):t.edges[r]=null})),t.edges=e._filter(t.edges,(function(t){return null!==t}))}))})),nh(o,(function(t){delete e.clusteredEdges[t]})),nh(o,(function(t){delete e.body.edges[t]})),nh(xn(this.body.edges),(function(t){var i=e.body.edges[t],o=e._isClusteredNode(i.fromId)||e._isClusteredNode(i.toId);if(o!==e._isClusteredEdge(i.id))if(o){var n=e._getClusterNodeForNode(i.fromId);void 0!==n&&e._clusterEdges(e.body.nodes[i.fromId],i,n);var r=e._getClusterNodeForNode(i.toId);void 0!==r&&e._clusterEdges(e.body.nodes[i.toId],i,r)}else delete e._clusterEdges[t],e._restoreEdge(i)}));for(var s=!1,a=!0,h=function(){var t=[];n((function(e){var i=xn(e.containedNodes).length,o=!0===e.options.allowSingleNodeCluster;(o&&i<1||!o&&i<2)&&t.push(e.id)}));for(var i=0;i<t.length;++i)e.openCluster(t[i],{},!1);a=t.length>0,s=s||a};a;)h();s&&this._updateState()}},{key:"_isClusteredNode",value:function(t){return void 0!==this.clusteredNodes[t]}},{key:"_isClusteredEdge",value:function(t){return void 0!==this.clusteredEdges[t]}}]),t}();function Eu(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return Ou(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return Ou(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function Ou(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}var Cu=function(){function t(e,i){var o;Po(this,t),void 0!==window&&(o=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame),window.requestAnimationFrame=void 0===o?function(t){t()}:o,this.body=e,this.canvas=i,this.redrawRequested=!1,this.renderTimer=void 0,this.requiresTimeout=!0,this.renderingActive=!1,this.renderRequests=0,this.allowRedraw=!0,this.dragging=!1,this.zooming=!1,this.options={},this.defaultOptions={hideEdgesOnDrag:!1,hideEdgesOnZoom:!1,hideNodesOnDrag:!1},ct(this.options,this.defaultOptions),this._determineBrowserMethod(),this.bindEventListeners()}return Io(t,[{key:"bindEventListeners",value:function(){var t,e=this;this.body.emitter.on("dragStart",(function(){e.dragging=!0})),this.body.emitter.on("dragEnd",(function(){e.dragging=!1})),this.body.emitter.on("zoom",(function(){e.zooming=!0,window.clearTimeout(e.zoomTimeoutId),e.zoomTimeoutId=qr((function(){var t;e.zooming=!1,bt(t=e._requestRedraw).call(t,e)()}),250)})),this.body.emitter.on("_resizeNodes",(function(){e._resizeNodes()})),this.body.emitter.on("_redraw",(function(){!1===e.renderingActive&&e._redraw()})),this.body.emitter.on("_blockRedraw",(function(){e.allowRedraw=!1})),this.body.emitter.on("_allowRedraw",(function(){e.allowRedraw=!0,e.redrawRequested=!1})),this.body.emitter.on("_requestRedraw",bt(t=this._requestRedraw).call(t,this)),this.body.emitter.on("_startRendering",(function(){e.renderRequests+=1,e.renderingActive=!0,e._startRendering()})),this.body.emitter.on("_stopRendering",(function(){e.renderRequests-=1,e.renderingActive=e.renderRequests>0,e.renderTimer=void 0})),this.body.emitter.on("destroy",(function(){e.renderRequests=0,e.allowRedraw=!1,e.renderingActive=!1,!0===e.requiresTimeout?clearTimeout(e.renderTimer):window.cancelAnimationFrame(e.renderTimer),e.body.emitter.off()}))}},{key:"setOptions",value:function(t){if(void 0!==t){Za(["hideEdgesOnDrag","hideEdgesOnZoom","hideNodesOnDrag"],this.options,t)}}},{key:"_requestNextFrame",value:function(t,e){if("undefined"!=typeof window){var i,o=window;return!0===this.requiresTimeout?i=qr(t,e):o.requestAnimationFrame&&(i=o.requestAnimationFrame(t)),i}}},{key:"_startRendering",value:function(){var t;!0===this.renderingActive&&(void 0===this.renderTimer&&(this.renderTimer=this._requestNextFrame(bt(t=this._renderStep).call(t,this),this.simulationInterval)))}},{key:"_renderStep",value:function(){!0===this.renderingActive&&(this.renderTimer=void 0,!0===this.requiresTimeout&&this._startRendering(),this._redraw(),!1===this.requiresTimeout&&this._startRendering())}},{key:"redraw",value:function(){this.body.emitter.emit("setSize"),this._redraw()}},{key:"_requestRedraw",value:function(){var t=this;!0!==this.redrawRequested&&!1===this.renderingActive&&!0===this.allowRedraw&&(this.redrawRequested=!0,this._requestNextFrame((function(){t._redraw(!1)}),0))}},{key:"_redraw",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!0===this.allowRedraw){this.body.emitter.emit("initRedraw"),this.redrawRequested=!1;var e={drawExternalLabels:null};0!==this.canvas.frame.canvas.width&&0!==this.canvas.frame.canvas.height||this.canvas.setSize(),this.canvas.setTransform();var i=this.canvas.getContext(),o=this.canvas.frame.canvas.clientWidth,n=this.canvas.frame.canvas.clientHeight;if(i.clearRect(0,0,o,n),0===this.canvas.frame.clientWidth)return;if(i.save(),i.translate(this.body.view.translation.x,this.body.view.translation.y),i.scale(this.body.view.scale,this.body.view.scale),i.beginPath(),this.body.emitter.emit("beforeDrawing",i),i.closePath(),!1===t&&(!1===this.dragging||!0===this.dragging&&!1===this.options.hideEdgesOnDrag)&&(!1===this.zooming||!0===this.zooming&&!1===this.options.hideEdgesOnZoom)&&this._drawEdges(i),!1===this.dragging||!0===this.dragging&&!1===this.options.hideNodesOnDrag){var r=this._drawNodes(i,t),s=r.drawExternalLabels;e.drawExternalLabels=s}!1===t&&(!1===this.dragging||!0===this.dragging&&!1===this.options.hideEdgesOnDrag)&&(!1===this.zooming||!0===this.zooming&&!1===this.options.hideEdgesOnZoom)&&this._drawArrows(i),null!=e.drawExternalLabels&&e.drawExternalLabels(),!1===t&&this._drawSelectionBox(i),i.beginPath(),this.body.emitter.emit("afterDrawing",i),i.closePath(),i.restore(),!0===t&&i.clearRect(0,0,o,n)}}},{key:"_resizeNodes",value:function(){this.canvas.setTransform();var t=this.canvas.getContext();t.save(),t.translate(this.body.view.translation.x,this.body.view.translation.y),t.scale(this.body.view.scale,this.body.view.scale);var e,i=this.body.nodes;for(var o in i)Object.prototype.hasOwnProperty.call(i,o)&&((e=i[o]).resize(t),e.updateBoundingBox(t,e.selected));t.restore()}},{key:"_drawNodes",value:function(t){for(var e,i,o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=this.body.nodes,r=this.body.nodeIndices,s=[],a=[],h=20,d=this.canvas.DOMtoCanvas({x:-h,y:-h}),l=this.canvas.DOMtoCanvas({x:this.canvas.frame.canvas.clientWidth+h,y:this.canvas.frame.canvas.clientHeight+h}),c={top:d.y,left:d.x,bottom:l.y,right:l.x},u=[],f=0;f<r.length;f++)if((e=n[r[f]]).hover)a.push(r[f]);else if(e.isSelected())s.push(r[f]);else if(!0===o){var p=e.draw(t);null!=p.drawExternalLabel&&u.push(p.drawExternalLabel)}else if(!0===e.isBoundingBoxOverlappingWith(c)){var v=e.draw(t);null!=v.drawExternalLabel&&u.push(v.drawExternalLabel)}else e.updateBoundingBox(t,e.selected);var g=s.length,y=a.length;for(i=0;i<g;i++){var m=(e=n[s[i]]).draw(t);null!=m.drawExternalLabel&&u.push(m.drawExternalLabel)}for(i=0;i<y;i++){var b=(e=n[a[i]]).draw(t);null!=b.drawExternalLabel&&u.push(b.drawExternalLabel)}return{drawExternalLabels:function(){var t,e=Eu(u);try{for(e.s();!(t=e.n()).done;){(0,t.value)()}}catch(t){e.e(t)}finally{e.f()}}}}},{key:"_drawEdges",value:function(t){for(var e=this.body.edges,i=this.body.edgeIndices,o=0;o<i.length;o++){var n=e[i[o]];!0===n.connected&&n.draw(t)}}},{key:"_drawArrows",value:function(t){for(var e=this.body.edges,i=this.body.edgeIndices,o=0;o<i.length;o++){var n=e[i[o]];!0===n.connected&&n.drawArrows(t)}}},{key:"_determineBrowserMethod",value:function(){if("undefined"!=typeof window){var t=navigator.userAgent.toLowerCase();this.requiresTimeout=!1,(-1!=Mr(t).call(t,"msie 9.0")||-1!=Mr(t).call(t,"safari")&&Mr(t).call(t,"chrome")<=-1)&&(this.requiresTimeout=!0)}else this.requiresTimeout=!0}},{key:"_drawSelectionBox",value:function(t){if(this.body.selectionBox.show){t.beginPath();var e=this.body.selectionBox.position.end.x-this.body.selectionBox.position.start.x,i=this.body.selectionBox.position.end.y-this.body.selectionBox.position.start.y;t.rect(this.body.selectionBox.position.start.x,this.body.selectionBox.position.start.y,e,i),t.fillStyle="rgba(151, 194, 252, 0.2)",t.fillRect(this.body.selectionBox.position.start.x,this.body.selectionBox.position.start.y,e,i),t.strokeStyle="rgba(151, 194, 252, 1)",t.stroke()}else t.closePath()}}]),t}(),Su=F.setInterval;function Tu(t,e){e.inputHandler=function(t){t.isFirst&&e(t)},t.on("hammer.input",e.inputHandler)}function Mu(t,e){return e.inputHandler=function(t){t.isFinal&&e(t)},t.on("hammer.input",e.inputHandler)}var Pu=function(){function t(e){Po(this,t),this.body=e,this.pixelRatio=1,this.cameraState={},this.initialized=!1,this.canvasViewCenter={},this._cleanupCallbacks=[],this.options={},this.defaultOptions={autoResize:!0,height:"100%",width:"100%"},ct(this.options,this.defaultOptions),this.bindEventListeners()}return Io(t,[{key:"bindEventListeners",value:function(){var t,e=this;this.body.emitter.once("resize",(function(t){0!==t.width&&(e.body.view.translation.x=.5*t.width),0!==t.height&&(e.body.view.translation.y=.5*t.height)})),this.body.emitter.on("setSize",bt(t=this.setSize).call(t,this)),this.body.emitter.on("destroy",(function(){e.hammerFrame.destroy(),e.hammer.destroy(),e._cleanUp()}))}},{key:"setOptions",value:function(t){var e,i,o,n,r,s=this;if(void 0!==t){Za(["width","height","autoResize"],this.options,t)}if(this._cleanUp(),!0===this.options.autoResize){var a;if(window.ResizeObserver){var h=new ResizeObserver((function(){!0===s.setSize()&&s.body.emitter.emit("_requestRedraw")})),d=this.frame;h.observe(d),this._cleanupCallbacks.push((function(){h.unobserve(d)}))}else{var l=Su((function(){!0===s.setSize()&&s.body.emitter.emit("_requestRedraw")}),1e3);this._cleanupCallbacks.push((function(){clearInterval(l)}))}var c=bt(a=this._onResize).call(a,this);e=window,i="resize",o=c,e.addEventListener?(void 0===n&&(n=!1),"mousewheel"===i&&Jn(r=navigator.userAgent).call(r,"Firefox")&&(i="DOMMouseScroll"),e.addEventListener(i,o,n)):e.attachEvent("on"+i,o),this._cleanupCallbacks.push((function(){!function(t,e,i,o){var n;t.removeEventListener?(void 0===o&&(o=!1),"mousewheel"===e&&Jn(n=navigator.userAgent).call(n,"Firefox")&&(e="DOMMouseScroll"),t.removeEventListener(e,i,o)):t.detachEvent("on"+e,i)}(window,"resize",c)}))}}},{key:"_cleanUp",value:function(){var t,e,i;Dn(t=Nn(e=qn(i=this._cleanupCallbacks).call(i,0)).call(e)).call(t,(function(t){try{t()}catch(t){console.error(t)}}))}},{key:"_onResize",value:function(){this.setSize(),this.body.emitter.emit("_redraw")}},{key:"_getCameraState",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.pixelRatio;!0===this.initialized&&(this.cameraState.previousWidth=this.frame.canvas.width/t,this.cameraState.previousHeight=this.frame.canvas.height/t,this.cameraState.scale=this.body.view.scale,this.cameraState.position=this.DOMtoCanvas({x:.5*this.frame.canvas.width/t,y:.5*this.frame.canvas.height/t}))}},{key:"_setCameraState",value:function(){if(void 0!==this.cameraState.scale&&0!==this.frame.canvas.clientWidth&&0!==this.frame.canvas.clientHeight&&0!==this.pixelRatio&&this.cameraState.previousWidth>0&&this.cameraState.previousHeight>0){var t=this.frame.canvas.width/this.pixelRatio/this.cameraState.previousWidth,e=this.frame.canvas.height/this.pixelRatio/this.cameraState.previousHeight,i=this.cameraState.scale;1!=t&&1!=e?i=.5*this.cameraState.scale*(t+e):1!=t?i=this.cameraState.scale*t:1!=e&&(i=this.cameraState.scale*e),this.body.view.scale=i;var o=this.DOMtoCanvas({x:.5*this.frame.canvas.clientWidth,y:.5*this.frame.canvas.clientHeight}),n={x:o.x-this.cameraState.position.x,y:o.y-this.cameraState.position.y};this.body.view.translation.x+=n.x*this.body.view.scale,this.body.view.translation.y+=n.y*this.body.view.scale}}},{key:"_prepareValue",value:function(t){if("number"==typeof t)return t+"px";if("string"==typeof t){if(-1!==Mr(t).call(t,"%")||-1!==Mr(t).call(t,"px"))return t;if(-1===Mr(t).call(t,"%"))return t+"px"}throw new Error("Could not use the value supplied for width or height:"+t)}},{key:"_create",value:function(){for(;this.body.container.hasChildNodes();)this.body.container.removeChild(this.body.container.firstChild);if(this.frame=document.createElement("div"),this.frame.className="vis-network",this.frame.style.position="relative",this.frame.style.overflow="hidden",this.frame.tabIndex=0,this.frame.canvas=document.createElement("canvas"),this.frame.canvas.style.position="relative",this.frame.appendChild(this.frame.canvas),this.frame.canvas.getContext)this._setPixelRatio(),this.setTransform();else{var t=document.createElement("DIV");t.style.color="red",t.style.fontWeight="bold",t.style.padding="10px",t.innerText="Error: your browser does not support HTML canvas",this.frame.canvas.appendChild(t)}this.body.container.appendChild(this.frame),this.body.view.scale=1,this.body.view.translation={x:.5*this.frame.canvas.clientWidth,y:.5*this.frame.canvas.clientHeight},this._bindHammer()}},{key:"_bindHammer",value:function(){var t=this;void 0!==this.hammer&&this.hammer.destroy(),this.drag={},this.pinch={},this.hammer=new Sh(this.frame.canvas),this.hammer.get("pinch").set({enable:!0}),this.hammer.get("pan").set({threshold:5,direction:Sh.DIRECTION_ALL}),Tu(this.hammer,(function(e){t.body.eventListeners.onTouch(e)})),this.hammer.on("tap",(function(e){t.body.eventListeners.onTap(e)})),this.hammer.on("doubletap",(function(e){t.body.eventListeners.onDoubleTap(e)})),this.hammer.on("press",(function(e){t.body.eventListeners.onHold(e)})),this.hammer.on("panstart",(function(e){t.body.eventListeners.onDragStart(e)})),this.hammer.on("panmove",(function(e){t.body.eventListeners.onDrag(e)})),this.hammer.on("panend",(function(e){t.body.eventListeners.onDragEnd(e)})),this.hammer.on("pinch",(function(e){t.body.eventListeners.onPinch(e)})),this.frame.canvas.addEventListener("wheel",(function(e){t.body.eventListeners.onMouseWheel(e)})),this.frame.canvas.addEventListener("mousemove",(function(e){t.body.eventListeners.onMouseMove(e)})),this.frame.canvas.addEventListener("contextmenu",(function(e){t.body.eventListeners.onContext(e)})),this.hammerFrame=new Sh(this.frame),Mu(this.hammerFrame,(function(e){t.body.eventListeners.onRelease(e)}))}},{key:"setSize",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.width,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.height;t=this._prepareValue(t),e=this._prepareValue(e);var i=!1,o=this.frame.canvas.width,n=this.frame.canvas.height,r=this.pixelRatio;if(this._setPixelRatio(),t!=this.options.width||e!=this.options.height||this.frame.style.width!=t||this.frame.style.height!=e)this._getCameraState(r),this.frame.style.width=t,this.frame.style.height=e,this.frame.canvas.style.width="100%",this.frame.canvas.style.height="100%",this.frame.canvas.width=Math.round(this.frame.canvas.clientWidth*this.pixelRatio),this.frame.canvas.height=Math.round(this.frame.canvas.clientHeight*this.pixelRatio),this.options.width=t,this.options.height=e,this.canvasViewCenter={x:.5*this.frame.clientWidth,y:.5*this.frame.clientHeight},i=!0;else{var s=Math.round(this.frame.canvas.clientWidth*this.pixelRatio),a=Math.round(this.frame.canvas.clientHeight*this.pixelRatio);this.frame.canvas.width===s&&this.frame.canvas.height===a||this._getCameraState(r),this.frame.canvas.width!==s&&(this.frame.canvas.width=s,i=!0),this.frame.canvas.height!==a&&(this.frame.canvas.height=a,i=!0)}return!0===i&&(this.body.emitter.emit("resize",{width:Math.round(this.frame.canvas.width/this.pixelRatio),height:Math.round(this.frame.canvas.height/this.pixelRatio),oldWidth:Math.round(o/this.pixelRatio),oldHeight:Math.round(n/this.pixelRatio)}),this._setCameraState()),this.initialized=!0,i}},{key:"getContext",value:function(){return this.frame.canvas.getContext("2d")}},{key:"_determinePixelRatio",value:function(){var t=this.getContext();if(void 0===t)throw new Error("Could not get canvax context");var e=1;return"undefined"!=typeof window&&(e=window.devicePixelRatio||1),e/(t.webkitBackingStorePixelRatio||t.mozBackingStorePixelRatio||t.msBackingStorePixelRatio||t.oBackingStorePixelRatio||t.backingStorePixelRatio||1)}},{key:"_setPixelRatio",value:function(){this.pixelRatio=this._determinePixelRatio()}},{key:"setTransform",value:function(){var t=this.getContext();if(void 0===t)throw new Error("Could not get canvax context");t.setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0)}},{key:"_XconvertDOMtoCanvas",value:function(t){return(t-this.body.view.translation.x)/this.body.view.scale}},{key:"_XconvertCanvasToDOM",value:function(t){return t*this.body.view.scale+this.body.view.translation.x}},{key:"_YconvertDOMtoCanvas",value:function(t){return(t-this.body.view.translation.y)/this.body.view.scale}},{key:"_YconvertCanvasToDOM",value:function(t){return t*this.body.view.scale+this.body.view.translation.y}},{key:"canvasToDOM",value:function(t){return{x:this._XconvertCanvasToDOM(t.x),y:this._YconvertCanvasToDOM(t.y)}}},{key:"DOMtoCanvas",value:function(t){return{x:this._XconvertDOMtoCanvas(t.x),y:this._YconvertDOMtoCanvas(t.y)}}}]),t}();function Du(t,e){var i=ct({nodes:e,minZoomLevel:Number.MIN_VALUE,maxZoomLevel:1},null!=t?t:{});if(!gn(i.nodes))throw new TypeError("Nodes has to be an array of ids.");if(0===i.nodes.length&&(i.nodes=e),!("number"==typeof i.minZoomLevel&&i.minZoomLevel>0))throw new TypeError("Min zoom level has to be a number higher than zero.");if(!("number"==typeof i.maxZoomLevel&&i.minZoomLevel<=i.maxZoomLevel))throw new TypeError("Max zoom level has to be a number higher than min zoom level.");return i}var Bu=function(){function t(e,i){var o,n,r=this;Po(this,t),this.body=e,this.canvas=i,this.animationSpeed=1/this.renderRefreshRate,this.animationEasingFunction="easeInOutQuint",this.easingTime=0,this.sourceScale=0,this.targetScale=0,this.sourceTranslation=0,this.targetTranslation=0,this.lockedOnNodeId=void 0,this.lockedOnNodeOffset=void 0,this.touchTime=0,this.viewFunction=void 0,this.body.emitter.on("fit",bt(o=this.fit).call(o,this)),this.body.emitter.on("animationFinished",(function(){r.body.emitter.emit("_stopRendering")})),this.body.emitter.on("unlockNode",bt(n=this.releaseNode).call(n,this))}return Io(t,[{key:"setOptions",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.options=t}},{key:"fit",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t=Du(t,this.body.nodeIndices);var i,o,n=this.canvas.frame.canvas.clientWidth,r=this.canvas.frame.canvas.clientHeight;if(0===n||0===r)o=1,i=wu.getRange(this.body.nodes,t.nodes);else if(!0===e){var s=0;for(var a in this.body.nodes)if(Object.prototype.hasOwnProperty.call(this.body.nodes,a)){var h=this.body.nodes[a];!0===h.predefinedPosition&&(s+=1)}if(s>.5*this.body.nodeIndices.length)return void this.fit(t,!1);i=wu.getRange(this.body.nodes,t.nodes);var d=this.body.nodeIndices.length;o=12.662/(d+7.4147)+.0964822;var l=Math.min(n/600,r/600);o*=l}else{this.body.emitter.emit("_resizeNodes"),i=wu.getRange(this.body.nodes,t.nodes);var c=1.1*Math.abs(i.maxX-i.minX),u=1.1*Math.abs(i.maxY-i.minY),f=n/c,p=r/u;o=f<=p?f:p}o>t.maxZoomLevel?o=t.maxZoomLevel:o<t.minZoomLevel&&(o=t.minZoomLevel);var v=wu.findCenter(i),g={position:v,scale:o,animation:t.animation};this.moveTo(g)}},{key:"focus",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(void 0!==this.body.nodes[t]){var i={x:this.body.nodes[t].x,y:this.body.nodes[t].y};e.position=i,e.lockedOnNode=t,this.moveTo(e)}else console.error("Node: "+t+" cannot be found.")}},{key:"moveTo",value:function(t){if(void 0!==t){if(null!=t.offset){if(null!=t.offset.x){if(t.offset.x=+t.offset.x,!Ad(t.offset.x))throw new TypeError('The option "offset.x" has to be a finite number.')}else t.offset.x=0;if(null!=t.offset.y){if(t.offset.y=+t.offset.y,!Ad(t.offset.y))throw new TypeError('The option "offset.y" has to be a finite number.')}else t.offset.x=0}else t.offset={x:0,y:0};if(null!=t.position){if(null!=t.position.x){if(t.position.x=+t.position.x,!Ad(t.position.x))throw new TypeError('The option "position.x" has to be a finite number.')}else t.position.x=0;if(null!=t.position.y){if(t.position.y=+t.position.y,!Ad(t.position.y))throw new TypeError('The option "position.y" has to be a finite number.')}else t.position.x=0}else t.position=this.getViewPosition();if(null!=t.scale){if(t.scale=+t.scale,!(t.scale>0))throw new TypeError('The option "scale" has to be a number greater than zero.')}else t.scale=this.body.view.scale;void 0===t.animation&&(t.animation={duration:0}),!1===t.animation&&(t.animation={duration:0}),!0===t.animation&&(t.animation={}),void 0===t.animation.duration&&(t.animation.duration=1e3),void 0===t.animation.easingFunction&&(t.animation.easingFunction="easeInOutQuad"),this.animateView(t)}else t={}}},{key:"animateView",value:function(t){if(void 0!==t){this.animationEasingFunction=t.animation.easingFunction,this.releaseNode(),!0===t.locked&&(this.lockedOnNodeId=t.lockedOnNode,this.lockedOnNodeOffset=t.offset),0!=this.easingTime&&this._transitionRedraw(!0),this.sourceScale=this.body.view.scale,this.sourceTranslation=this.body.view.translation,this.targetScale=t.scale,this.body.view.scale=this.targetScale;var e,i,o=this.canvas.DOMtoCanvas({x:.5*this.canvas.frame.canvas.clientWidth,y:.5*this.canvas.frame.canvas.clientHeight}),n=o.x-t.position.x,r=o.y-t.position.y;if(this.targetTranslation={x:this.sourceTranslation.x+n*this.targetScale+t.offset.x,y:this.sourceTranslation.y+r*this.targetScale+t.offset.y},0===t.animation.duration)if(null!=this.lockedOnNodeId)this.viewFunction=bt(e=this._lockedRedraw).call(e,this),this.body.emitter.on("initRedraw",this.viewFunction);else this.body.view.scale=this.targetScale,this.body.view.translation=this.targetTranslation,this.body.emitter.emit("_requestRedraw");else this.animationSpeed=1/(60*t.animation.duration*.001)||1/60,this.animationEasingFunction=t.animation.easingFunction,this.viewFunction=bt(i=this._transitionRedraw).call(i,this),this.body.emitter.on("initRedraw",this.viewFunction),this.body.emitter.emit("_startRendering")}}},{key:"_lockedRedraw",value:function(){var t=this.body.nodes[this.lockedOnNodeId].x,e=this.body.nodes[this.lockedOnNodeId].y,i=this.canvas.DOMtoCanvas({x:.5*this.canvas.frame.canvas.clientWidth,y:.5*this.canvas.frame.canvas.clientHeight}),o=i.x-t,n=i.y-e,r=this.body.view.translation,s={x:r.x+o*this.body.view.scale+this.lockedOnNodeOffset.x,y:r.y+n*this.body.view.scale+this.lockedOnNodeOffset.y};this.body.view.translation=s}},{key:"releaseNode",value:function(){void 0!==this.lockedOnNodeId&&void 0!==this.viewFunction&&(this.body.emitter.off("initRedraw",this.viewFunction),this.lockedOnNodeId=void 0,this.lockedOnNodeOffset=void 0)}},{key:"_transitionRedraw",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.easingTime+=this.animationSpeed,this.easingTime=!0===t?1:this.easingTime;var e=yh[this.animationEasingFunction](this.easingTime);if(this.body.view.scale=this.sourceScale+(this.targetScale-this.sourceScale)*e,this.body.view.translation={x:this.sourceTranslation.x+(this.targetTranslation.x-this.sourceTranslation.x)*e,y:this.sourceTranslation.y+(this.targetTranslation.y-this.sourceTranslation.y)*e},this.easingTime>=1){var i;if(this.body.emitter.off("initRedraw",this.viewFunction),this.easingTime=0,null!=this.lockedOnNodeId)this.viewFunction=bt(i=this._lockedRedraw).call(i,this),this.body.emitter.on("initRedraw",this.viewFunction);this.body.emitter.emit("animationFinished")}}},{key:"getScale",value:function(){return this.body.view.scale}},{key:"getViewPosition",value:function(){return this.canvas.DOMtoCanvas({x:.5*this.canvas.frame.canvas.clientWidth,y:.5*this.canvas.frame.canvas.clientHeight})}}]),t}();function Iu(t){var e,i=t&&t.preventDefault||!1,o=t&&t.container||window,n={},r={keydown:{},keyup:{}},s={};for(e=97;e<=122;e++)s[String.fromCharCode(e)]={code:e-97+65,shift:!1};for(e=65;e<=90;e++)s[String.fromCharCode(e)]={code:e,shift:!0};for(e=0;e<=9;e++)s[""+e]={code:48+e,shift:!1};for(e=1;e<=12;e++)s["F"+e]={code:111+e,shift:!1};for(e=0;e<=9;e++)s["num"+e]={code:96+e,shift:!1};s["num*"]={code:106,shift:!1},s["num+"]={code:107,shift:!1},s["num-"]={code:109,shift:!1},s["num/"]={code:111,shift:!1},s["num."]={code:110,shift:!1},s.left={code:37,shift:!1},s.up={code:38,shift:!1},s.right={code:39,shift:!1},s.down={code:40,shift:!1},s.space={code:32,shift:!1},s.enter={code:13,shift:!1},s.shift={code:16,shift:void 0},s.esc={code:27,shift:!1},s.backspace={code:8,shift:!1},s.tab={code:9,shift:!1},s.ctrl={code:17,shift:!1},s.alt={code:18,shift:!1},s.delete={code:46,shift:!1},s.pageup={code:33,shift:!1},s.pagedown={code:34,shift:!1},s["="]={code:187,shift:!1},s["-"]={code:189,shift:!1},s["]"]={code:221,shift:!1},s["["]={code:219,shift:!1};var a=function(t){d(t,"keydown")},h=function(t){d(t,"keyup")},d=function(t,e){if(void 0!==r[e][t.keyCode]){for(var o=r[e][t.keyCode],n=0;n<o.length;n++)(void 0===o[n].shift||1==o[n].shift&&1==t.shiftKey||0==o[n].shift&&0==t.shiftKey)&&o[n].fn(t);1==i&&t.preventDefault()}};return n.bind=function(t,e,i){if(void 0===i&&(i="keydown"),void 0===s[t])throw new Error("unsupported key: "+t);void 0===r[i][s[t].code]&&(r[i][s[t].code]=[]),r[i][s[t].code].push({fn:e,shift:s[t].shift})},n.bindAll=function(t,e){for(var i in void 0===e&&(e="keydown"),s)s.hasOwnProperty(i)&&n.bind(i,t,e)},n.getKey=function(t){for(var e in s)if(s.hasOwnProperty(e)){if(1==t.shiftKey&&1==s[e].shift&&t.keyCode==s[e].code)return e;if(0==t.shiftKey&&0==s[e].shift&&t.keyCode==s[e].code)return e;if(t.keyCode==s[e].code&&"shift"==e)return e}return"unknown key, currently not supported"},n.unbind=function(t,e,i){if(void 0===i&&(i="keydown"),void 0===s[t])throw new Error("unsupported key: "+t);if(void 0!==e){var o=[],n=r[i][s[t].code];if(void 0!==n)for(var a=0;a<n.length;a++)n[a].fn==e&&n[a].shift==s[t].shift||o.push(r[i][s[t].code][a]);r[i][s[t].code]=o}else r[i][s[t].code]=[]},n.reset=function(){r={keydown:{},keyup:{}}},n.destroy=function(){r={keydown:{},keyup:{}},o.removeEventListener("keydown",a,!0),o.removeEventListener("keyup",h,!0)},o.addEventListener("keydown",a,!0),o.addEventListener("keyup",h,!0),n}var zu=function(){function t(e,i){var o=this;Po(this,t),this.body=e,this.canvas=i,this.iconsCreated=!1,this.navigationHammers=[],this.boundFunctions={},this.touchTime=0,this.activated=!1,this.body.emitter.on("activate",(function(){o.activated=!0,o.configureKeyboardBindings()})),this.body.emitter.on("deactivate",(function(){o.activated=!1,o.configureKeyboardBindings()})),this.body.emitter.on("destroy",(function(){void 0!==o.keycharm&&o.keycharm.destroy()})),this.options={}}return Io(t,[{key:"setOptions",value:function(t){void 0!==t&&(this.options=t,this.create())}},{key:"create",value:function(){!0===this.options.navigationButtons?!1===this.iconsCreated&&this.loadNavigationElements():!0===this.iconsCreated&&this.cleanNavigation(),this.configureKeyboardBindings()}},{key:"cleanNavigation",value:function(){if(0!=this.navigationHammers.length){for(var t=0;t<this.navigationHammers.length;t++)this.navigationHammers[t].destroy();this.navigationHammers=[]}this.navigationDOM&&this.navigationDOM.wrapper&&this.navigationDOM.wrapper.parentNode&&this.navigationDOM.wrapper.parentNode.removeChild(this.navigationDOM.wrapper),this.iconsCreated=!1}},{key:"loadNavigationElements",value:function(){var t=this;this.cleanNavigation(),this.navigationDOM={};var e=["up","down","left","right","zoomIn","zoomOut","zoomExtends"],i=["_moveUp","_moveDown","_moveLeft","_moveRight","_zoomIn","_zoomOut","_fit"];this.navigationDOM.wrapper=document.createElement("div"),this.navigationDOM.wrapper.className="vis-navigation",this.canvas.frame.appendChild(this.navigationDOM.wrapper);for(var o=0;o<e.length;o++){this.navigationDOM[e[o]]=document.createElement("div"),this.navigationDOM[e[o]].className="vis-button vis-"+e[o],this.navigationDOM.wrapper.appendChild(this.navigationDOM[e[o]]);var n,r,s=new Sh(this.navigationDOM[e[o]]);if("_fit"===i[o])Tu(s,bt(n=this._fit).call(n,this));else Tu(s,bt(r=this.bindToRedraw).call(r,this,i[o]));this.navigationHammers.push(s)}var a=new Sh(this.canvas.frame);Mu(a,(function(){t._stopMovement()})),this.navigationHammers.push(a),this.iconsCreated=!0}},{key:"bindToRedraw",value:function(t){var e;void 0===this.boundFunctions[t]&&(this.boundFunctions[t]=bt(e=this[t]).call(e,this),this.body.emitter.on("initRedraw",this.boundFunctions[t]),this.body.emitter.emit("_startRendering"))}},{key:"unbindFromRedraw",value:function(t){void 0!==this.boundFunctions[t]&&(this.body.emitter.off("initRedraw",this.boundFunctions[t]),this.body.emitter.emit("_stopRendering"),delete this.boundFunctions[t])}},{key:"_fit",value:function(){(new Date).valueOf()-this.touchTime>700&&(this.body.emitter.emit("fit",{duration:700}),this.touchTime=(new Date).valueOf())}},{key:"_stopMovement",value:function(){for(var t in this.boundFunctions)Object.prototype.hasOwnProperty.call(this.boundFunctions,t)&&(this.body.emitter.off("initRedraw",this.boundFunctions[t]),this.body.emitter.emit("_stopRendering"));this.boundFunctions={}}},{key:"_moveUp",value:function(){this.body.view.translation.y+=this.options.keyboard.speed.y}},{key:"_moveDown",value:function(){this.body.view.translation.y-=this.options.keyboard.speed.y}},{key:"_moveLeft",value:function(){this.body.view.translation.x+=this.options.keyboard.speed.x}},{key:"_moveRight",value:function(){this.body.view.translation.x-=this.options.keyboard.speed.x}},{key:"_zoomIn",value:function(){var t=this.body.view.scale,e=this.body.view.scale*(1+this.options.keyboard.speed.zoom),i=this.body.view.translation,o=e/t,n=(1-o)*this.canvas.canvasViewCenter.x+i.x*o,r=(1-o)*this.canvas.canvasViewCenter.y+i.y*o;this.body.view.scale=e,this.body.view.translation={x:n,y:r},this.body.emitter.emit("zoom",{direction:"+",scale:this.body.view.scale,pointer:null})}},{key:"_zoomOut",value:function(){var t=this.body.view.scale,e=this.body.view.scale/(1+this.options.keyboard.speed.zoom),i=this.body.view.translation,o=e/t,n=(1-o)*this.canvas.canvasViewCenter.x+i.x*o,r=(1-o)*this.canvas.canvasViewCenter.y+i.y*o;this.body.view.scale=e,this.body.view.translation={x:n,y:r},this.body.emitter.emit("zoom",{direction:"-",scale:this.body.view.scale,pointer:null})}},{key:"configureKeyboardBindings",value:function(){var t,e,i,o,n,r,s,a,h,d,l,c,u,f,p,v,g,y,m,b,w,k,_,x,E=this;(void 0!==this.keycharm&&this.keycharm.destroy(),!0===this.options.keyboard.enabled)&&(!0===this.options.keyboard.bindToWindow?this.keycharm=Iu({container:window,preventDefault:!0}):this.keycharm=Iu({container:this.canvas.frame,preventDefault:!0}),this.keycharm.reset(),!0===this.activated&&(bt(t=this.keycharm).call(t,"up",(function(){E.bindToRedraw("_moveUp")}),"keydown"),bt(e=this.keycharm).call(e,"down",(function(){E.bindToRedraw("_moveDown")}),"keydown"),bt(i=this.keycharm).call(i,"left",(function(){E.bindToRedraw("_moveLeft")}),"keydown"),bt(o=this.keycharm).call(o,"right",(function(){E.bindToRedraw("_moveRight")}),"keydown"),bt(n=this.keycharm).call(n,"=",(function(){E.bindToRedraw("_zoomIn")}),"keydown"),bt(r=this.keycharm).call(r,"num+",(function(){E.bindToRedraw("_zoomIn")}),"keydown"),bt(s=this.keycharm).call(s,"num-",(function(){E.bindToRedraw("_zoomOut")}),"keydown"),bt(a=this.keycharm).call(a,"-",(function(){E.bindToRedraw("_zoomOut")}),"keydown"),bt(h=this.keycharm).call(h,"[",(function(){E.bindToRedraw("_zoomOut")}),"keydown"),bt(d=this.keycharm).call(d,"]",(function(){E.bindToRedraw("_zoomIn")}),"keydown"),bt(l=this.keycharm).call(l,"pageup",(function(){E.bindToRedraw("_zoomIn")}),"keydown"),bt(c=this.keycharm).call(c,"pagedown",(function(){E.bindToRedraw("_zoomOut")}),"keydown"),bt(u=this.keycharm).call(u,"up",(function(){E.unbindFromRedraw("_moveUp")}),"keyup"),bt(f=this.keycharm).call(f,"down",(function(){E.unbindFromRedraw("_moveDown")}),"keyup"),bt(p=this.keycharm).call(p,"left",(function(){E.unbindFromRedraw("_moveLeft")}),"keyup"),bt(v=this.keycharm).call(v,"right",(function(){E.unbindFromRedraw("_moveRight")}),"keyup"),bt(g=this.keycharm).call(g,"=",(function(){E.unbindFromRedraw("_zoomIn")}),"keyup"),bt(y=this.keycharm).call(y,"num+",(function(){E.unbindFromRedraw("_zoomIn")}),"keyup"),bt(m=this.keycharm).call(m,"num-",(function(){E.unbindFromRedraw("_zoomOut")}),"keyup"),bt(b=this.keycharm).call(b,"-",(function(){E.unbindFromRedraw("_zoomOut")}),"keyup"),bt(w=this.keycharm).call(w,"[",(function(){E.unbindFromRedraw("_zoomOut")}),"keyup"),bt(k=this.keycharm).call(k,"]",(function(){E.unbindFromRedraw("_zoomIn")}),"keyup"),bt(_=this.keycharm).call(_,"pageup",(function(){E.unbindFromRedraw("_zoomIn")}),"keyup"),bt(x=this.keycharm).call(x,"pagedown",(function(){E.unbindFromRedraw("_zoomOut")}),"keyup")))}}]),t}();function Fu(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return Nu(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return Nu(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function Nu(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}var Au=function(){function t(e,i,o){var n,r,s,a,h,d,l,c,u,f,p,v,g;Po(this,t),this.body=e,this.canvas=i,this.selectionHandler=o,this.navigationHandler=new zu(e,i),this.body.eventListeners.onTap=bt(n=this.onTap).call(n,this),this.body.eventListeners.onTouch=bt(r=this.onTouch).call(r,this),this.body.eventListeners.onDoubleTap=bt(s=this.onDoubleTap).call(s,this),this.body.eventListeners.onHold=bt(a=this.onHold).call(a,this),this.body.eventListeners.onDragStart=bt(h=this.onDragStart).call(h,this),this.body.eventListeners.onDrag=bt(d=this.onDrag).call(d,this),this.body.eventListeners.onDragEnd=bt(l=this.onDragEnd).call(l,this),this.body.eventListeners.onMouseWheel=bt(c=this.onMouseWheel).call(c,this),this.body.eventListeners.onPinch=bt(u=this.onPinch).call(u,this),this.body.eventListeners.onMouseMove=bt(f=this.onMouseMove).call(f,this),this.body.eventListeners.onRelease=bt(p=this.onRelease).call(p,this),this.body.eventListeners.onContext=bt(v=this.onContext).call(v,this),this.touchTime=0,this.drag={},this.pinch={},this.popup=void 0,this.popupObj=void 0,this.popupTimer=void 0,this.body.functions.getPointer=bt(g=this.getPointer).call(g,this),this.options={},this.defaultOptions={dragNodes:!0,dragView:!0,hover:!1,keyboard:{enabled:!1,speed:{x:10,y:10,zoom:.02},bindToWindow:!0},navigationButtons:!1,tooltipDelay:300,zoomView:!0,zoomSpeed:1},ct(this.options,this.defaultOptions),this.bindEventListeners()}return Io(t,[{key:"bindEventListeners",value:function(){var t=this;this.body.emitter.on("destroy",(function(){clearTimeout(t.popupTimer),delete t.body.functions.getPointer}))}},{key:"setOptions",value:function(t){if(void 0!==t){Ja(["hideEdgesOnDrag","hideEdgesOnZoom","hideNodesOnDrag","keyboard","multiselect","selectable","selectConnectedEdges"],this.options,t),gh(this.options,t,"keyboard"),t.tooltip&&(ct(this.options.tooltip,t.tooltip),t.tooltip.color&&(this.options.tooltip.color=hh(t.tooltip.color)))}this.navigationHandler.setOptions(this.options)}},{key:"getPointer",value:function(t){return{x:t.x-(e=this.canvas.frame.canvas,e.getBoundingClientRect().left),y:t.y-oh(this.canvas.frame.canvas)};var e}},{key:"onTouch",value:function(t){(new Date).valueOf()-this.touchTime>50&&(this.drag.pointer=this.getPointer(t.center),this.drag.pinched=!1,this.pinch.scale=this.body.view.scale,this.touchTime=(new Date).valueOf())}},{key:"onTap",value:function(t){var e=this.getPointer(t.center),i=this.selectionHandler.options.multiselect&&(t.changedPointers[0].ctrlKey||t.changedPointers[0].metaKey);this.checkSelectionChanges(e,i),this.selectionHandler.commitAndEmit(e,t),this.selectionHandler.generateClickEvent("click",t,e)}},{key:"onDoubleTap",value:function(t){var e=this.getPointer(t.center);this.selectionHandler.generateClickEvent("doubleClick",t,e)}},{key:"onHold",value:function(t){var e=this.getPointer(t.center),i=this.selectionHandler.options.multiselect;this.checkSelectionChanges(e,i),this.selectionHandler.commitAndEmit(e,t),this.selectionHandler.generateClickEvent("click",t,e),this.selectionHandler.generateClickEvent("hold",t,e)}},{key:"onRelease",value:function(t){if((new Date).valueOf()-this.touchTime>10){var e=this.getPointer(t.center);this.selectionHandler.generateClickEvent("release",t,e),this.touchTime=(new Date).valueOf()}}},{key:"onContext",value:function(t){var e=this.getPointer({x:t.clientX,y:t.clientY});this.selectionHandler.generateClickEvent("oncontext",t,e)}},{key:"checkSelectionChanges",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];!0===e?this.selectionHandler.selectAdditionalOnPoint(t):this.selectionHandler.selectOnPoint(t)}},{key:"_determineDifference",value:function(t,e){var i=function(t,e){for(var i=[],o=0;o<t.length;o++){var n=t[o];-1===Mr(e).call(e,n)&&i.push(n)}return i};return{nodes:i(t.nodes,e.nodes),edges:i(t.edges,e.edges)}}},{key:"onDragStart",value:function(t){if(!this.drag.dragging){void 0===this.drag.pointer&&this.onTouch(t);var e=this.selectionHandler.getNodeAt(this.drag.pointer);if(this.drag.dragging=!0,this.drag.selection=[],this.drag.translation=ct({},this.body.view.translation),this.drag.nodeId=void 0,t.srcEvent.shiftKey){this.body.selectionBox.show=!0;var i=this.getPointer(t.center);this.body.selectionBox.position.start={x:this.canvas._XconvertDOMtoCanvas(i.x),y:this.canvas._YconvertDOMtoCanvas(i.y)},this.body.selectionBox.position.end={x:this.canvas._XconvertDOMtoCanvas(i.x),y:this.canvas._YconvertDOMtoCanvas(i.y)}}if(void 0!==e&&!0===this.options.dragNodes){this.drag.nodeId=e.id,!1===e.isSelected()&&(this.selectionHandler.unselectAll(),this.selectionHandler.selectObject(e)),this.selectionHandler.generateClickEvent("dragStart",t,this.drag.pointer);var o,n=Fu(this.selectionHandler.getSelectedNodes());try{for(n.s();!(o=n.n()).done;){var r=o.value,s={id:r.id,node:r,x:r.x,y:r.y,xFixed:r.options.fixed.x,yFixed:r.options.fixed.y};r.options.fixed.x=!0,r.options.fixed.y=!0,this.drag.selection.push(s)}}catch(t){n.e(t)}finally{n.f()}}else this.selectionHandler.generateClickEvent("dragStart",t,this.drag.pointer,void 0,!0)}}},{key:"onDrag",value:function(t){var e=this;if(!0!==this.drag.pinched){this.body.emitter.emit("unlockNode");var i=this.getPointer(t.center),o=this.drag.selection;if(o&&o.length&&!0===this.options.dragNodes){this.selectionHandler.generateClickEvent("dragging",t,i);var n=i.x-this.drag.pointer.x,r=i.y-this.drag.pointer.y;Dn(o).call(o,(function(t){var i=t.node;!1===t.xFixed&&(i.x=e.canvas._XconvertDOMtoCanvas(e.canvas._XconvertCanvasToDOM(t.x)+n)),!1===t.yFixed&&(i.y=e.canvas._YconvertDOMtoCanvas(e.canvas._YconvertCanvasToDOM(t.y)+r))})),this.body.emitter.emit("startSimulation")}else{if(t.srcEvent.shiftKey){if(this.selectionHandler.generateClickEvent("dragging",t,i,void 0,!0),void 0===this.drag.pointer)return void this.onDragStart(t);this.body.selectionBox.position.end={x:this.canvas._XconvertDOMtoCanvas(i.x),y:this.canvas._YconvertDOMtoCanvas(i.y)},this.body.emitter.emit("_requestRedraw")}if(!0===this.options.dragView&&!t.srcEvent.shiftKey){if(this.selectionHandler.generateClickEvent("dragging",t,i,void 0,!0),void 0===this.drag.pointer)return void this.onDragStart(t);var s=i.x-this.drag.pointer.x,a=i.y-this.drag.pointer.y;this.body.view.translation={x:this.drag.translation.x+s,y:this.drag.translation.y+a},this.body.emitter.emit("_requestRedraw")}}}}},{key:"onDragEnd",value:function(t){var e=this;if(this.drag.dragging=!1,this.body.selectionBox.show){var i;this.body.selectionBox.show=!1;var o=this.body.selectionBox.position,n={minX:Math.min(o.start.x,o.end.x),minY:Math.min(o.start.y,o.end.y),maxX:Math.max(o.start.x,o.end.x),maxY:Math.max(o.start.y,o.end.y)},r=ar(i=this.body.nodeIndices).call(i,(function(t){var i=e.body.nodes[t];return i.x>=n.minX&&i.x<=n.maxX&&i.y>=n.minY&&i.y<=n.maxY}));Dn(r).call(r,(function(t){return e.selectionHandler.selectObject(e.body.nodes[t])}));var s=this.getPointer(t.center);this.selectionHandler.commitAndEmit(s,t),this.selectionHandler.generateClickEvent("dragEnd",t,this.getPointer(t.center),void 0,!0),this.body.emitter.emit("_requestRedraw")}else{var a=this.drag.selection;a&&a.length?(Dn(a).call(a,(function(t){t.node.options.fixed.x=t.xFixed,t.node.options.fixed.y=t.yFixed})),this.selectionHandler.generateClickEvent("dragEnd",t,this.getPointer(t.center)),this.body.emitter.emit("startSimulation")):(this.selectionHandler.generateClickEvent("dragEnd",t,this.getPointer(t.center),void 0,!0),this.body.emitter.emit("_requestRedraw"))}}},{key:"onPinch",value:function(t){var e=this.getPointer(t.center);this.drag.pinched=!0,void 0===this.pinch.scale&&(this.pinch.scale=1);var i=this.pinch.scale*t.scale;this.zoom(i,e)}},{key:"zoom",value:function(t,e){if(!0===this.options.zoomView){var i=this.body.view.scale;t<1e-5&&(t=1e-5),t>10&&(t=10);var o=void 0;void 0!==this.drag&&!0===this.drag.dragging&&(o=this.canvas.DOMtoCanvas(this.drag.pointer));var n=this.body.view.translation,r=t/i,s=(1-r)*e.x+n.x*r,a=(1-r)*e.y+n.y*r;if(this.body.view.scale=t,this.body.view.translation={x:s,y:a},null!=o){var h=this.canvas.canvasToDOM(o);this.drag.pointer.x=h.x,this.drag.pointer.y=h.y}this.body.emitter.emit("_requestRedraw"),i<t?this.body.emitter.emit("zoom",{direction:"+",scale:this.body.view.scale,pointer:e}):this.body.emitter.emit("zoom",{direction:"-",scale:this.body.view.scale,pointer:e})}}},{key:"onMouseWheel",value:function(t){if(!0===this.options.zoomView){if(0!==t.deltaY){var e=this.body.view.scale;e*=1+(t.deltaY<0?1:-1)*(.1*this.options.zoomSpeed);var i=this.getPointer({x:t.clientX,y:t.clientY});this.zoom(e,i)}t.preventDefault()}}},{key:"onMouseMove",value:function(t){var e=this,i=this.getPointer({x:t.clientX,y:t.clientY}),o=!1;void 0!==this.popup&&(!1===this.popup.hidden&&this._checkHidePopup(i),!1===this.popup.hidden&&(o=!0,this.popup.setPosition(i.x+3,i.y-5),this.popup.show())),!1===this.options.keyboard.bindToWindow&&!0===this.options.keyboard.enabled&&this.canvas.frame.focus(),!1===o&&(void 0!==this.popupTimer&&(clearInterval(this.popupTimer),this.popupTimer=void 0),this.drag.dragging||(this.popupTimer=qr((function(){return e._checkShowPopup(i)}),this.options.tooltipDelay))),!0===this.options.hover&&this.selectionHandler.hoverObject(t,i)}},{key:"_checkShowPopup",value:function(t){var e=this.canvas._XconvertDOMtoCanvas(t.x),i=this.canvas._YconvertDOMtoCanvas(t.y),o={left:e,top:i,right:e,bottom:i},n=void 0===this.popupObj?void 0:this.popupObj.id,r=!1,s="node";if(void 0===this.popupObj){for(var a,h=this.body.nodeIndices,d=this.body.nodes,l=[],c=0;c<h.length;c++)!0===(a=d[h[c]]).isOverlappingWith(o)&&(r=!0,void 0!==a.getTitle()&&l.push(h[c]));l.length>0&&(this.popupObj=d[l[l.length-1]],r=!0)}if(void 0===this.popupObj&&!1===r){for(var u,f=this.body.edgeIndices,p=this.body.edges,v=[],g=0;g<f.length;g++)!0===(u=p[f[g]]).isOverlappingWith(o)&&!0===u.connected&&void 0!==u.getTitle()&&v.push(f[g]);v.length>0&&(this.popupObj=p[v[v.length-1]],s="edge")}void 0!==this.popupObj?this.popupObj.id!==n&&(void 0===this.popup&&(this.popup=new Th(this.canvas.frame)),this.popup.popupTargetType=s,this.popup.popupTargetId=this.popupObj.id,this.popup.setPosition(t.x+3,t.y-5),this.popup.setText(this.popupObj.getTitle()),this.popup.show(),this.body.emitter.emit("showPopup",this.popupObj.id)):void 0!==this.popup&&(this.popup.hide(),this.body.emitter.emit("hidePopup"))}},{key:"_checkHidePopup",value:function(t){var e=this.selectionHandler._pointerToPositionObject(t),i=!1;if("node"===this.popup.popupTargetType){if(void 0!==this.body.nodes[this.popup.popupTargetId]&&!0===(i=this.body.nodes[this.popup.popupTargetId].isOverlappingWith(e))){var o=this.selectionHandler.getNodeAt(t);i=void 0!==o&&o.id===this.popup.popupTargetId}}else void 0===this.selectionHandler.getNodeAt(t)&&void 0!==this.body.edges[this.popup.popupTargetId]&&(i=this.body.edges[this.popup.popupTargetId].isOverlappingWith(e));!1===i&&(this.popupObj=void 0,this.popup.hide(),this.body.emitter.emit("hidePopup"))}}]),t}();Ed("Set",(function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}}),Dd);var Ru=F.Set,ju=gd.getWeakData,Lu=Zt.set,Hu=Zt.getterFor,Wu=Wi.find,Vu=Wi.findIndex,qu=0,Uu=function(t){return t.frozen||(t.frozen=new Yu)},Yu=function(){this.entries=[]},Xu=function(t,e){return Wu(t.entries,(function(t){return t[0]===e}))};Yu.prototype={get:function(t){var e=Xu(this,t);if(e)return e[1]},has:function(t){return!!Xu(this,t)},set:function(t,e){var i=Xu(this,t);i?i[1]=e:this.entries.push([t,e])},delete:function(t){var e=Vu(this.entries,(function(e){return e[0]===t}));return~e&&this.entries.splice(e,1),!!~e}};var Gu={getConstructor:function(t,e,i,o){var n=t((function(t,r){bd(t,n,e),Lu(t,{type:e,id:qu++,frozen:void 0}),null!=r&&md(r,t[o],{that:t,AS_ENTRIES:i})})),r=Hu(e),s=function(t,e,i){var o=r(t),n=ju(R(e),!0);return!0===n?Uu(o).set(e,i):n[o.id]=i,t};return Od(n.prototype,{delete:function(t){var e=r(this);if(!m(t))return!1;var i=ju(t);return!0===i?Uu(e).delete(t):i&&k(i,e.id)&&delete i[e.id]},has:function(t){var e=r(this);if(!m(t))return!1;var i=ju(t);return!0===i?Uu(e).has(t):i&&k(i,e.id)}}),Od(n.prototype,i?{get:function(t){var e=r(this);if(m(t)){var i=ju(t);return!0===i?Uu(e).get(t):i?i[e.id]:void 0}},set:function(t,e){return s(this,t,e)}}:{add:function(t){return s(this,t,!0)}}),n}};o((function(t){var e,i=Zt.enforce,o=!r.ActiveXObject&&"ActiveXObject"in r,n=Object.isExtensible,s=function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}},a=t.exports=Ed("WeakMap",s,Gu);if(At&&o){e=Gu.getConstructor(s,"WeakMap",!0),gd.REQUIRED=!0;var h=a.prototype,d=h.delete,l=h.has,c=h.get,u=h.set;Od(h,{delete:function(t){if(m(t)&&!n(t)){var o=i(this);return o.frozen||(o.frozen=new e),d.call(this,t)||o.frozen.delete(t)}return d.call(this,t)},has:function(t){if(m(t)&&!n(t)){var o=i(this);return o.frozen||(o.frozen=new e),l.call(this,t)||o.frozen.has(t)}return l.call(this,t)},get:function(t){if(m(t)&&!n(t)){var o=i(this);return o.frozen||(o.frozen=new e),l.call(this,t)?c.call(this,t):o.frozen.get(t)}return c.call(this,t)},set:function(t,o){if(m(t)&&!n(t)){var r=i(this);r.frozen||(r.frozen=new e),l.call(this,t)?u.call(this,t,o):r.frozen.set(t,o)}else u.call(this,t,o);return this}})}}));var Ku,$u,Qu,Zu,Ju,tf=F.WeakMap;
/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
function ef(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)}function of(t,e,i){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");return e.set(t,i),i}function nf(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return rf(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return rf(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function rf(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}function sf(t,e){var i,o=new Ru,n=nf(e);try{for(n.s();!(i=n.n()).done;){var r=i.value;t.has(r)||o.add(r)}}catch(t){n.e(t)}finally{n.f()}return o}var af=function(){function t(){Po(this,t),Ku.set(this,new Ru),$u.set(this,new Ru)}return Io(t,[{key:"size",get:function(){return ef(this,$u).size}},{key:"add",value:function(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];for(var o=0,n=e;o<n.length;o++){var r=n[o];ef(this,$u).add(r)}}},{key:"delete",value:function(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];for(var o=0,n=e;o<n.length;o++){var r=n[o];ef(this,$u).delete(r)}}},{key:"clear",value:function(){ef(this,$u).clear()}},{key:"getSelection",value:function(){return ln(ef(this,$u))}},{key:"getChanges",value:function(){return{added:ln(sf(ef(this,Ku),ef(this,$u))),deleted:ln(sf(ef(this,$u),ef(this,Ku))),previous:ln(new Ru(ef(this,Ku))),current:ln(new Ru(ef(this,$u)))}}},{key:"commit",value:function(){var t=this.getChanges();of(this,Ku,ef(this,$u)),of(this,$u,new Ru(ef(this,Ku)));var e,i=nf(t.added);try{for(i.s();!(e=i.n()).done;){e.value.select()}}catch(t){i.e(t)}finally{i.f()}var o,n=nf(t.deleted);try{for(n.s();!(o=n.n()).done;){o.value.unselect()}}catch(t){n.e(t)}finally{n.f()}return t}}]),t}();Ku=new tf,$u=new tf;var hf=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){};Po(this,t),Qu.set(this,new af),Zu.set(this,new af),Ju.set(this,void 0),of(this,Ju,e)}return Io(t,[{key:"sizeNodes",get:function(){return ef(this,Qu).size}},{key:"sizeEdges",get:function(){return ef(this,Zu).size}},{key:"getNodes",value:function(){return ef(this,Qu).getSelection()}},{key:"getEdges",value:function(){return ef(this,Zu).getSelection()}},{key:"addNodes",value:function(){var t;(t=ef(this,Qu)).add.apply(t,arguments)}},{key:"addEdges",value:function(){var t;(t=ef(this,Zu)).add.apply(t,arguments)}},{key:"deleteNodes",value:function(t){ef(this,Qu).delete(t)}},{key:"deleteEdges",value:function(t){ef(this,Zu).delete(t)}},{key:"clear",value:function(){ef(this,Qu).clear(),ef(this,Zu).clear()}},{key:"commit",value:function(){for(var t,e,i={nodes:ef(this,Qu).commit(),edges:ef(this,Zu).commit()},o=arguments.length,n=new Array(o),r=0;r<o;r++)n[r]=arguments[r];return(t=ef(this,Ju)).call.apply(t,pn(e=[this,i]).call(e,n)),i}}]),t}();function df(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return lf(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return lf(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function lf(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}Qu=new tf,Zu=new tf,Ju=new tf;var cf=function(){function t(e,i){var o=this;Po(this,t),this.body=e,this.canvas=i,this._selectionAccumulator=new hf,this.hoverObj={nodes:{},edges:{}},this.options={},this.defaultOptions={multiselect:!1,selectable:!0,selectConnectedEdges:!0,hoverConnectedEdges:!0},ct(this.options,this.defaultOptions),this.body.emitter.on("_dataChanged",(function(){o.updateSelection()}))}return Io(t,[{key:"setOptions",value:function(t){if(void 0!==t){Za(["multiselect","hoverConnectedEdges","selectable","selectConnectedEdges"],this.options,t)}}},{key:"selectOnPoint",value:function(t){var e=!1;if(!0===this.options.selectable){var i=this.getNodeAt(t)||this.getEdgeAt(t);this.unselectAll(),void 0!==i&&(e=this.selectObject(i)),this.body.emitter.emit("_requestRedraw")}return e}},{key:"selectAdditionalOnPoint",value:function(t){var e=!1;if(!0===this.options.selectable){var i=this.getNodeAt(t)||this.getEdgeAt(t);void 0!==i&&(e=!0,!0===i.isSelected()?this.deselectObject(i):this.selectObject(i),this.body.emitter.emit("_requestRedraw"))}return e}},{key:"_initBaseEvent",value:function(t,e){var i={};return i.pointer={DOM:{x:e.x,y:e.y},canvas:this.canvas.DOMtoCanvas(e)},i.event=t,i}},{key:"generateClickEvent",value:function(t,e,i,o){var n=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=this._initBaseEvent(e,i);if(!0===n)r.nodes=[],r.edges=[];else{var s=this.getSelection();r.nodes=s.nodes,r.edges=s.edges}void 0!==o&&(r.previousSelection=o),"click"==t&&(r.items=this.getClickedItems(i)),void 0!==e.controlEdge&&(r.controlEdge=e.controlEdge),this.body.emitter.emit(t,r)}},{key:"selectObject",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.selectConnectedEdges;if(void 0!==t){if(t instanceof lc){var i;if(!0===e)(i=this._selectionAccumulator).addEdges.apply(i,ln(t.edges));this._selectionAccumulator.addNodes(t)}else this._selectionAccumulator.addEdges(t);return!0}return!1}},{key:"deselectObject",value:function(t){!0===t.isSelected()&&(t.selected=!1,this._removeFromSelection(t))}},{key:"_getAllNodesOverlappingWith",value:function(t){for(var e=[],i=this.body.nodes,o=0;o<this.body.nodeIndices.length;o++){var n=this.body.nodeIndices[o];i[n].isOverlappingWith(t)&&e.push(n)}return e}},{key:"_pointerToPositionObject",value:function(t){var e=this.canvas.DOMtoCanvas(t);return{left:e.x-1,top:e.y+1,right:e.x+1,bottom:e.y-1}}},{key:"getNodeAt",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this._pointerToPositionObject(t),o=this._getAllNodesOverlappingWith(i);return o.length>0?!0===e?this.body.nodes[o[o.length-1]]:o[o.length-1]:void 0}},{key:"_getEdgesOverlappingWith",value:function(t,e){for(var i=this.body.edges,o=0;o<this.body.edgeIndices.length;o++){var n=this.body.edgeIndices[o];i[n].isOverlappingWith(t)&&e.push(n)}}},{key:"_getAllEdgesOverlappingWith",value:function(t){var e=[];return this._getEdgesOverlappingWith(t,e),e}},{key:"getEdgeAt",value:function(t){for(var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this.canvas.DOMtoCanvas(t),o=10,n=null,r=this.body.edges,s=0;s<this.body.edgeIndices.length;s++){var a=this.body.edgeIndices[s],h=r[a];if(h.connected){var d=h.from.x,l=h.from.y,c=h.to.x,u=h.to.y,f=h.edgeType.getDistanceToEdge(d,l,c,u,i.x,i.y);f<o&&(n=a,o=f)}}return null!==n?!0===e?this.body.edges[n]:n:void 0}},{key:"_addToHover",value:function(t){t instanceof lc?this.hoverObj.nodes[t.id]=t:this.hoverObj.edges[t.id]=t}},{key:"_removeFromSelection",value:function(t){var e;t instanceof lc?(this._selectionAccumulator.deleteNodes(t),(e=this._selectionAccumulator).deleteEdges.apply(e,ln(t.edges))):this._selectionAccumulator.deleteEdges(t)}},{key:"unselectAll",value:function(){this._selectionAccumulator.clear()}},{key:"getSelectedNodeCount",value:function(){return this._selectionAccumulator.sizeNodes}},{key:"getSelectedEdgeCount",value:function(){return this._selectionAccumulator.sizeEdges}},{key:"_hoverConnectedEdges",value:function(t){for(var e=0;e<t.edges.length;e++){var i=t.edges[e];i.hover=!0,this._addToHover(i)}}},{key:"emitBlurEvent",value:function(t,e,i){var o=this._initBaseEvent(t,e);!0===i.hover&&(i.hover=!1,i instanceof lc?(o.node=i.id,this.body.emitter.emit("blurNode",o)):(o.edge=i.id,this.body.emitter.emit("blurEdge",o)))}},{key:"emitHoverEvent",value:function(t,e,i){var o=this._initBaseEvent(t,e),n=!1;return!1===i.hover&&(i.hover=!0,this._addToHover(i),n=!0,i instanceof lc?(o.node=i.id,this.body.emitter.emit("hoverNode",o)):(o.edge=i.id,this.body.emitter.emit("hoverEdge",o))),n}},{key:"hoverObject",value:function(t,e){var i=this.getNodeAt(e);void 0===i&&(i=this.getEdgeAt(e));var o=!1;for(var n in this.hoverObj.nodes)Object.prototype.hasOwnProperty.call(this.hoverObj.nodes,n)&&(void 0===i||i instanceof lc&&i.id!=n||i instanceof Jc)&&(this.emitBlurEvent(t,e,this.hoverObj.nodes[n]),delete this.hoverObj.nodes[n],o=!0);for(var r in this.hoverObj.edges)Object.prototype.hasOwnProperty.call(this.hoverObj.edges,r)&&(!0===o?(this.hoverObj.edges[r].hover=!1,delete this.hoverObj.edges[r]):(void 0===i||i instanceof Jc&&i.id!=r||i instanceof lc&&!i.hover)&&(this.emitBlurEvent(t,e,this.hoverObj.edges[r]),delete this.hoverObj.edges[r],o=!0));if(void 0!==i){var s=xn(this.hoverObj.edges).length,a=xn(this.hoverObj.nodes).length;(o||i instanceof Jc&&0===s&&0===a||i instanceof lc&&0===s&&0===a)&&(o=this.emitHoverEvent(t,e,i)),i instanceof lc&&!0===this.options.hoverConnectedEdges&&this._hoverConnectedEdges(i)}!0===o&&this.body.emitter.emit("_requestRedraw")}},{key:"commitWithoutEmitting",value:function(){this._selectionAccumulator.commit()}},{key:"commitAndEmit",value:function(t,e){var i=!1,o=this._selectionAccumulator.commit(),n={nodes:o.nodes.previous,edges:o.edges.previous};o.edges.deleted.length>0&&(this.generateClickEvent("deselectEdge",e,t,n),i=!0),o.nodes.deleted.length>0&&(this.generateClickEvent("deselectNode",e,t,n),i=!0),o.nodes.added.length>0&&(this.generateClickEvent("selectNode",e,t),i=!0),o.edges.added.length>0&&(this.generateClickEvent("selectEdge",e,t),i=!0),!0===i&&this.generateClickEvent("select",e,t)}},{key:"getSelection",value:function(){return{nodes:this.getSelectedNodeIds(),edges:this.getSelectedEdgeIds()}}},{key:"getSelectedNodes",value:function(){return this._selectionAccumulator.getNodes()}},{key:"getSelectedEdges",value:function(){return this._selectionAccumulator.getEdges()}},{key:"getSelectedNodeIds",value:function(){var t;return kn(t=this._selectionAccumulator.getNodes()).call(t,(function(t){return t.id}))}},{key:"getSelectedEdgeIds",value:function(){var t;return kn(t=this._selectionAccumulator.getEdges()).call(t,(function(t){return t.id}))}},{key:"setSelection",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t||!t.nodes&&!t.edges)throw new TypeError("Selection must be an object with nodes and/or edges properties");if((e.unselectAll||void 0===e.unselectAll)&&this.unselectAll(),t.nodes){var i,o=df(t.nodes);try{for(o.s();!(i=o.n()).done;){var n=i.value,r=this.body.nodes[n];if(!r)throw new RangeError('Node with id "'+n+'" not found');this.selectObject(r,e.highlightEdges)}}catch(t){o.e(t)}finally{o.f()}}if(t.edges){var s,a=df(t.edges);try{for(a.s();!(s=a.n()).done;){var h=s.value,d=this.body.edges[h];if(!d)throw new RangeError('Edge with id "'+h+'" not found');this.selectObject(d)}}catch(t){a.e(t)}finally{a.f()}}this.body.emitter.emit("_requestRedraw"),this._selectionAccumulator.commit()}},{key:"selectNodes",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!t||void 0===t.length)throw"Selection must be an array with ids";this.setSelection({nodes:t},{highlightEdges:e})}},{key:"selectEdges",value:function(t){if(!t||void 0===t.length)throw"Selection must be an array with ids";this.setSelection({edges:t})}},{key:"updateSelection",value:function(){for(var t in this._selectionAccumulator.getNodes())Object.prototype.hasOwnProperty.call(this.body.nodes,t.id)||this._selectionAccumulator.deleteNodes(t);for(var e in this._selectionAccumulator.getEdges())Object.prototype.hasOwnProperty.call(this.body.edges,e.id)||this._selectionAccumulator.deleteEdges(e)}},{key:"getClickedItems",value:function(t){for(var e=this.canvas.DOMtoCanvas(t),i=[],o=this.body.nodeIndices,n=this.body.nodes,r=o.length-1;r>=0;r--){var s=n[o[r]].getItemsOnPoint(e);i.push.apply(i,s)}for(var a=this.body.edgeIndices,h=this.body.edges,d=a.length-1;d>=0;d--){var l=h[a[d]].getItemsOnPoint(e);i.push.apply(i,l)}return i}}]),t}(),uf=[],ff=uf.sort,pf=s((function(){uf.sort(void 0)})),vf=s((function(){uf.sort(null)})),gf=On("sort");q({target:"Array",proto:!0,forced:pf||!vf||!gf},{sort:function(t){return void 0===t?ff.call(at(this)):ff.call(at(this),N(t))}});var yf=gt("Array").sort,mf=Array.prototype,bf=function(t){var e=t.sort;return t===mf||t instanceof Array&&e===mf.sort?yf:e},wf=function(t){return function(e,i,o,n){N(i);var r=at(e),s=v(r),a=K(r.length),h=t?a-1:0,d=t?-1:1;if(o<2)for(;;){if(h in s){n=s[h],h+=d;break}if(h+=d,t?h<0:a<=h)throw TypeError("Reduce of empty array with no initial value")}for(;t?h>=0:a>h;h+=d)h in s&&(n=i(n,s[h],h,r));return n}},kf={left:wf(!1),right:wf(!0)}.left,_f=On("reduce");q({target:"Array",proto:!0,forced:!_f||!oe&&fe>79&&fe<83},{reduce:function(t){return kf(this,t,arguments.length,arguments.length>1?arguments[1]:void 0)}});var xf=gt("Array").reduce,Ef=Array.prototype,Of=function(t){var e=t.reduce;return t===Ef||t instanceof Array&&e===Ef.reduce?xf:e},Cf=o((function(t,e){!function(t){function e(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0,t.sort=v;var i=32,o=7,n=256,r=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9];function s(t){return t<1e5?t<100?t<10?0:1:t<1e4?t<1e3?2:3:4:t<1e7?t<1e6?5:6:t<1e9?t<1e8?7:8:9}function a(t,e){if(t===e)return 0;if(~~t===t&&~~e===e){if(0===t||0===e)return t<e?-1:1;if(t<0||e<0){if(e>=0)return-1;if(t>=0)return 1;t=-t,e=-e}var i=s(t),o=s(e),n=0;return i<o?(t*=r[o-i-1],e/=10,n=-1):i>o&&(e*=r[i-o-1],t/=10,n=1),t===e?n:t<e?-1:1}var a=String(t),h=String(e);return a===h?0:a<h?-1:1}function h(t){for(var e=0;t>=i;)e|=1&t,t>>=1;return t+e}function d(t,e,i,o){var n=e+1;if(n===i)return 1;if(o(t[n++],t[e])<0){for(;n<i&&o(t[n],t[n-1])<0;)n++;l(t,e,n)}else for(;n<i&&o(t[n],t[n-1])>=0;)n++;return n-e}function l(t,e,i){for(i--;e<i;){var o=t[e];t[e++]=t[i],t[i--]=o}}function c(t,e,i,o,n){for(o===e&&o++;o<i;o++){for(var r=t[o],s=e,a=o;s<a;){var h=s+a>>>1;n(r,t[h])<0?a=h:s=h+1}var d=o-s;switch(d){case 3:t[s+3]=t[s+2];case 2:t[s+2]=t[s+1];case 1:t[s+1]=t[s];break;default:for(;d>0;)t[s+d]=t[s+d-1],d--}t[s]=r}}function u(t,e,i,o,n,r){var s=0,a=0,h=1;if(r(t,e[i+n])>0){for(a=o-n;h<a&&r(t,e[i+n+h])>0;)s=h,(h=1+(h<<1))<=0&&(h=a);h>a&&(h=a),s+=n,h+=n}else{for(a=n+1;h<a&&r(t,e[i+n-h])<=0;)s=h,(h=1+(h<<1))<=0&&(h=a);h>a&&(h=a);var d=s;s=n-h,h=n-d}for(s++;s<h;){var l=s+(h-s>>>1);r(t,e[i+l])>0?s=l+1:h=l}return h}function f(t,e,i,o,n,r){var s=0,a=0,h=1;if(r(t,e[i+n])<0){for(a=n+1;h<a&&r(t,e[i+n-h])<0;)s=h,(h=1+(h<<1))<=0&&(h=a);h>a&&(h=a);var d=s;s=n-h,h=n-d}else{for(a=o-n;h<a&&r(t,e[i+n+h])>=0;)s=h,(h=1+(h<<1))<=0&&(h=a);h>a&&(h=a),s+=n,h+=n}for(s++;s<h;){var l=s+(h-s>>>1);r(t,e[i+l])<0?h=l:s=l+1}return h}var p=function(){function t(i,r){e(this,t),this.array=null,this.compare=null,this.minGallop=o,this.length=0,this.tmpStorageLength=n,this.stackLength=0,this.runStart=null,this.runLength=null,this.stackSize=0,this.array=i,this.compare=r,this.length=i.length,this.length<2*n&&(this.tmpStorageLength=this.length>>>1),this.tmp=new Array(this.tmpStorageLength),this.stackLength=this.length<120?5:this.length<1542?10:this.length<119151?19:40,this.runStart=new Array(this.stackLength),this.runLength=new Array(this.stackLength)}return t.prototype.pushRun=function(t,e){this.runStart[this.stackSize]=t,this.runLength[this.stackSize]=e,this.stackSize+=1},t.prototype.mergeRuns=function(){for(;this.stackSize>1;){var t=this.stackSize-2;if(t>=1&&this.runLength[t-1]<=this.runLength[t]+this.runLength[t+1]||t>=2&&this.runLength[t-2]<=this.runLength[t]+this.runLength[t-1])this.runLength[t-1]<this.runLength[t+1]&&t--;else if(this.runLength[t]>this.runLength[t+1])break;this.mergeAt(t)}},t.prototype.forceMergeRuns=function(){for(;this.stackSize>1;){var t=this.stackSize-2;t>0&&this.runLength[t-1]<this.runLength[t+1]&&t--,this.mergeAt(t)}},t.prototype.mergeAt=function(t){var e=this.compare,i=this.array,o=this.runStart[t],n=this.runLength[t],r=this.runStart[t+1],s=this.runLength[t+1];this.runLength[t]=n+s,t===this.stackSize-3&&(this.runStart[t+1]=this.runStart[t+2],this.runLength[t+1]=this.runLength[t+2]),this.stackSize--;var a=f(i[r],i,o,n,0,e);o+=a,0!=(n-=a)&&0!==(s=u(i[o+n-1],i,r,s,s-1,e))&&(n<=s?this.mergeLow(o,n,r,s):this.mergeHigh(o,n,r,s))},t.prototype.mergeLow=function(t,e,i,n){var r=this.compare,s=this.array,a=this.tmp,h=0;for(h=0;h<e;h++)a[h]=s[t+h];var d=0,l=i,c=t;if(s[c++]=s[l++],0!=--n)if(1!==e){for(var p=this.minGallop;;){var v=0,g=0,y=!1;do{if(r(s[l],a[d])<0){if(s[c++]=s[l++],g++,v=0,0==--n){y=!0;break}}else if(s[c++]=a[d++],v++,g=0,1==--e){y=!0;break}}while((v|g)<p);if(y)break;do{if(0!==(v=f(s[l],a,d,e,0,r))){for(h=0;h<v;h++)s[c+h]=a[d+h];if(c+=v,d+=v,(e-=v)<=1){y=!0;break}}if(s[c++]=s[l++],0==--n){y=!0;break}if(0!==(g=u(a[d],s,l,n,0,r))){for(h=0;h<g;h++)s[c+h]=s[l+h];if(c+=g,l+=g,0==(n-=g)){y=!0;break}}if(s[c++]=a[d++],1==--e){y=!0;break}p--}while(v>=o||g>=o);if(y)break;p<0&&(p=0),p+=2}if(this.minGallop=p,p<1&&(this.minGallop=1),1===e){for(h=0;h<n;h++)s[c+h]=s[l+h];s[c+n]=a[d]}else{if(0===e)throw new Error("mergeLow preconditions were not respected");for(h=0;h<e;h++)s[c+h]=a[d+h]}}else{for(h=0;h<n;h++)s[c+h]=s[l+h];s[c+n]=a[d]}else for(h=0;h<e;h++)s[c+h]=a[d+h]},t.prototype.mergeHigh=function(t,e,i,n){var r=this.compare,s=this.array,a=this.tmp,h=0;for(h=0;h<n;h++)a[h]=s[i+h];var d=t+e-1,l=n-1,c=i+n-1,p=0,v=0;if(s[c--]=s[d--],0!=--e)if(1!==n){for(var g=this.minGallop;;){var y=0,m=0,b=!1;do{if(r(a[l],s[d])<0){if(s[c--]=s[d--],y++,m=0,0==--e){b=!0;break}}else if(s[c--]=a[l--],m++,y=0,1==--n){b=!0;break}}while((y|m)<g);if(b)break;do{if(0!=(y=e-f(a[l],s,t,e,e-1,r))){for(e-=y,v=1+(c-=y),p=1+(d-=y),h=y-1;h>=0;h--)s[v+h]=s[p+h];if(0===e){b=!0;break}}if(s[c--]=a[l--],1==--n){b=!0;break}if(0!=(m=n-u(s[d],a,0,n,n-1,r))){for(n-=m,v=1+(c-=m),p=1+(l-=m),h=0;h<m;h++)s[v+h]=a[p+h];if(n<=1){b=!0;break}}if(s[c--]=s[d--],0==--e){b=!0;break}g--}while(y>=o||m>=o);if(b)break;g<0&&(g=0),g+=2}if(this.minGallop=g,g<1&&(this.minGallop=1),1===n){for(v=1+(c-=e),p=1+(d-=e),h=e-1;h>=0;h--)s[v+h]=s[p+h];s[c]=a[l]}else{if(0===n)throw new Error("mergeHigh preconditions were not respected");for(p=c-(n-1),h=0;h<n;h++)s[p+h]=a[h]}}else{for(v=1+(c-=e),p=1+(d-=e),h=e-1;h>=0;h--)s[v+h]=s[p+h];s[c]=a[l]}else for(p=c-(n-1),h=0;h<n;h++)s[p+h]=a[h]},t}();function v(t,e,o,n){if(!Array.isArray(t))throw new TypeError("Can only sort arrays");e?"function"!=typeof e&&(n=o,o=e,e=a):e=a,o||(o=0),n||(n=t.length);var r=n-o;if(!(r<2)){var s=0;if(r<i)c(t,o,n,o+(s=d(t,o,n,e)),e);else{var l=new p(t,e),u=h(r);do{if((s=d(t,o,n,e))<u){var f=r;f>u&&(f=u),c(t,o,o+f,o+s,e),s=f}l.pushRun(o,s),l.mergeRuns(),r-=s,o+=s}while(0!==r);l.forceMergeRuns()}}}}(e)}));function Sf(t){var e=function(){if("undefined"==typeof Reflect||!vl)return!1;if(vl.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(vl(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,o=_l(t);if(e){var n=_l(this).constructor;i=vl(o,arguments,n)}else i=o.apply(this,arguments);return wl(this,i)}}var Tf=function(){function t(){Po(this,t)}return Io(t,[{key:"abstract",value:function(){throw new Error("Can't instantiate abstract class!")}},{key:"fake_use",value:function(){}},{key:"curveType",value:function(){return this.abstract()}},{key:"getPosition",value:function(t){return this.fake_use(t),this.abstract()}},{key:"setPosition",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;this.fake_use(t,e,i),this.abstract()}},{key:"getTreeSize",value:function(t){return this.fake_use(t),this.abstract()}},{key:"sort",value:function(t){this.fake_use(t),this.abstract()}},{key:"fix",value:function(t,e){this.fake_use(t,e),this.abstract()}},{key:"shift",value:function(t,e){this.fake_use(t,e),this.abstract()}}]),t}(),Mf=function(t){bl(i,t);var e=Sf(i);function i(t){var o;return Po(this,i),(o=e.call(this)).layout=t,o}return Io(i,[{key:"curveType",value:function(){return"horizontal"}},{key:"getPosition",value:function(t){return t.x}},{key:"setPosition",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;void 0!==i&&this.layout.hierarchical.addToOrdering(t,i),t.x=e}},{key:"getTreeSize",value:function(t){var e=this.layout.hierarchical.getTreeSize(this.layout.body.nodes,t);return{min:e.min_x,max:e.max_x}}},{key:"sort",value:function(t){Cf.sort(t,(function(t,e){return t.x-e.x}))}},{key:"fix",value:function(t,e){t.y=this.layout.options.hierarchical.levelSeparation*e,t.options.fixed.y=!0}},{key:"shift",value:function(t,e){this.layout.body.nodes[t].x+=e}}]),i}(Tf),Pf=function(t){bl(i,t);var e=Sf(i);function i(t){var o;return Po(this,i),(o=e.call(this)).layout=t,o}return Io(i,[{key:"curveType",value:function(){return"vertical"}},{key:"getPosition",value:function(t){return t.y}},{key:"setPosition",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;void 0!==i&&this.layout.hierarchical.addToOrdering(t,i),t.y=e}},{key:"getTreeSize",value:function(t){var e=this.layout.hierarchical.getTreeSize(this.layout.body.nodes,t);return{min:e.min_y,max:e.max_y}}},{key:"sort",value:function(t){Cf.sort(t,(function(t,e){return t.y-e.y}))}},{key:"fix",value:function(t,e){t.x=this.layout.options.hierarchical.levelSeparation*e,t.options.fixed.x=!0}},{key:"shift",value:function(t,e){this.layout.body.nodes[t].y+=e}}]),i}(Tf),Df=Wi.every,Bf=On("every");q({target:"Array",proto:!0,forced:!Bf},{every:function(t){return Df(this,t,arguments.length>1?arguments[1]:void 0)}});var If=gt("Array").every,zf=Array.prototype,Ff=function(t){var e=t.every;return t===zf||t instanceof Array&&e===zf.every?If:e};function Nf(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return Af(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return Af(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function Af(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}function Rf(t,e){var i=new Ru;return Dn(t).call(t,(function(t){var e;Dn(e=t.edges).call(e,(function(t){t.connected&&i.add(t)}))})),Dn(i).call(i,(function(t){var i=t.from.id,o=t.to.id;null==e[i]&&(e[i]=0),(null==e[o]||e[i]>=e[o])&&(e[o]=e[i]+1)})),e}function jf(t,e,i,o){var n,r,s=Ir(null),a=Of(n=ln(nl(o).call(o))).call(n,(function(t,e){return t+1+e.edges.length}),0),h=i+"Id",d="to"===i?1:-1,l=Nf(o);try{var c=function(){var n=an(r.value,2),l=n[0],c=n[1];if(!o.has(l)||!t(c))return"continue";s[l]=0;for(var u=[c],f=0,p=void 0,v=function(){var t,n;if(!o.has(l))return"continue";var r=s[p.id]+d;if(Dn(t=ar(n=p.edges).call(n,(function(t){return t.connected&&t.to!==t.from&&t[i]!==p&&o.has(t.toId)&&o.has(t.fromId)}))).call(t,(function(t){var o=t[h],n=s[o];(null==n||e(r,n))&&(s[o]=r,u.push(t[i]))})),f>a)return{v:{v:Rf(o,s)}};++f};p=u.pop();){var g=v();if("continue"!==g&&"object"===dn(g))return g.v}};for(l.s();!(r=l.n()).done;){var u=c();if("continue"!==u&&"object"===dn(u))return u.v}}catch(t){l.e(t)}finally{l.f()}return s}var Lf=function(){function t(){Po(this,t),this.childrenReference={},this.parentReference={},this.trees={},this.distributionOrdering={},this.levels={},this.distributionIndex={},this.isTree=!1,this.treeIndex=-1}return Io(t,[{key:"addRelation",value:function(t,e){void 0===this.childrenReference[t]&&(this.childrenReference[t]=[]),this.childrenReference[t].push(e),void 0===this.parentReference[e]&&(this.parentReference[e]=[]),this.parentReference[e].push(t)}},{key:"checkIfTree",value:function(){for(var t in this.parentReference)if(this.parentReference[t].length>1)return void(this.isTree=!1);this.isTree=!0}},{key:"numTrees",value:function(){return this.treeIndex+1}},{key:"setTreeIndex",value:function(t,e){void 0!==e&&void 0===this.trees[t.id]&&(this.trees[t.id]=e,this.treeIndex=Math.max(e,this.treeIndex))}},{key:"ensureLevel",value:function(t){void 0===this.levels[t]&&(this.levels[t]=0)}},{key:"getMaxLevel",value:function(t){var e=this,i={};return function t(o){if(void 0!==i[o])return i[o];var n=e.levels[o];if(e.childrenReference[o]){var r=e.childrenReference[o];if(r.length>0)for(var s=0;s<r.length;s++)n=Math.max(n,t(r[s]))}return i[o]=n,n}(t)}},{key:"levelDownstream",value:function(t,e){void 0===this.levels[e.id]&&(void 0===this.levels[t.id]&&(this.levels[t.id]=0),this.levels[e.id]=this.levels[t.id]+1)}},{key:"setMinLevelToZero",value:function(t){var e=1e9;for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&void 0!==this.levels[i]&&(e=Math.min(this.levels[i],e));for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&void 0!==this.levels[o]&&(this.levels[o]-=e)}},{key:"getTreeSize",value:function(t,e){var i=1e9,o=-1e9,n=1e9,r=-1e9;for(var s in this.trees)if(Object.prototype.hasOwnProperty.call(this.trees,s)&&this.trees[s]===e){var a=t[s];i=Math.min(a.x,i),o=Math.max(a.x,o),n=Math.min(a.y,n),r=Math.max(a.y,r)}return{min_x:i,max_x:o,min_y:n,max_y:r}}},{key:"hasSameParent",value:function(t,e){var i=this.parentReference[t.id],o=this.parentReference[e.id];if(void 0===i||void 0===o)return!1;for(var n=0;n<i.length;n++)for(var r=0;r<o.length;r++)if(i[n]==o[r])return!0;return!1}},{key:"inSameSubNetwork",value:function(t,e){return this.trees[t.id]===this.trees[e.id]}},{key:"getLevels",value:function(){return xn(this.distributionOrdering)}},{key:"addToOrdering",value:function(t,e){void 0===this.distributionOrdering[e]&&(this.distributionOrdering[e]=[]);var i=!1,o=this.distributionOrdering[e];for(var n in o)if(o[n]===t){i=!0;break}i||(this.distributionOrdering[e].push(t),this.distributionIndex[t.id]=this.distributionOrdering[e].length-1)}}]),t}(),Hf=function(){function t(e){Po(this,t),this.body=e,this._resetRNG(Math.random()+":"+En()),this.setPhysics=!1,this.options={},this.optionsBackup={physics:{}},this.defaultOptions={randomSeed:void 0,improvedLayout:!0,clusterThreshold:150,hierarchical:{enabled:!1,levelSeparation:150,nodeSpacing:100,treeSpacing:200,blockShifting:!0,edgeMinimization:!0,parentCentralization:!0,direction:"UD",sortMethod:"hubsize"}},ct(this.options,this.defaultOptions),this.bindEventListeners()}return Io(t,[{key:"bindEventListeners",value:function(){var t=this;this.body.emitter.on("_dataChanged",(function(){t.setupHierarchicalLayout()})),this.body.emitter.on("_dataLoaded",(function(){t.layoutNetwork()})),this.body.emitter.on("_resetHierarchicalLayout",(function(){t.setupHierarchicalLayout()})),this.body.emitter.on("_adjustEdgesForHierarchicalLayout",(function(){if(!0===t.options.hierarchical.enabled){var e=t.direction.curveType();t.body.emitter.emit("_forceDisableDynamicCurves",e,!1)}}))}},{key:"setOptions",value:function(t,e){if(void 0!==t){var i=this.options.hierarchical,o=i.enabled;if(Za(["randomSeed","improvedLayout","clusterThreshold"],this.options,t),gh(this.options,t,"hierarchical"),void 0!==t.randomSeed&&this._resetRNG(t.randomSeed),!0===i.enabled)return!0===o&&this.body.emitter.emit("refresh",!0),"RL"===i.direction||"DU"===i.direction?i.levelSeparation>0&&(i.levelSeparation*=-1):i.levelSeparation<0&&(i.levelSeparation*=-1),this.setDirectionStrategy(),this.body.emitter.emit("_resetHierarchicalLayout"),this.adaptAllOptionsForHierarchicalLayout(e);if(!0===o)return this.body.emitter.emit("refresh"),th(e,this.optionsBackup)}return e}},{key:"_resetRNG",value:function(t){this.initialRandomSeed=t,this._rng=Ra(this.initialRandomSeed)}},{key:"adaptAllOptionsForHierarchicalLayout",value:function(t){if(!0===this.options.hierarchical.enabled){var e=this.optionsBackup.physics;void 0===t.physics||!0===t.physics?(t.physics={enabled:void 0===e.enabled||e.enabled,solver:"hierarchicalRepulsion"},e.enabled=void 0===e.enabled||e.enabled,e.solver=e.solver||"barnesHut"):"object"===dn(t.physics)?(e.enabled=void 0===t.physics.enabled||t.physics.enabled,e.solver=t.physics.solver||"barnesHut",t.physics.solver="hierarchicalRepulsion"):!1!==t.physics&&(e.solver="barnesHut",t.physics={solver:"hierarchicalRepulsion"});var i=this.direction.curveType();if(void 0===t.edges)this.optionsBackup.edges={smooth:{enabled:!0,type:"dynamic"}},t.edges={smooth:!1};else if(void 0===t.edges.smooth)this.optionsBackup.edges={smooth:{enabled:!0,type:"dynamic"}},t.edges.smooth=!1;else if("boolean"==typeof t.edges.smooth)this.optionsBackup.edges={smooth:t.edges.smooth},t.edges.smooth={enabled:t.edges.smooth,type:i};else{var o=t.edges.smooth;void 0!==o.type&&"dynamic"!==o.type&&(i=o.type),this.optionsBackup.edges={smooth:{enabled:void 0===o.enabled||o.enabled,type:void 0===o.type?"dynamic":o.type,roundness:void 0===o.roundness?.5:o.roundness,forceDirection:void 0!==o.forceDirection&&o.forceDirection}},t.edges.smooth={enabled:void 0===o.enabled||o.enabled,type:i,roundness:void 0===o.roundness?.5:o.roundness,forceDirection:void 0!==o.forceDirection&&o.forceDirection}}this.body.emitter.emit("_forceDisableDynamicCurves",i)}return t}},{key:"positionInitially",value:function(t){if(!0!==this.options.hierarchical.enabled){this._resetRNG(this.initialRandomSeed);for(var e=t.length+50,i=0;i<t.length;i++){var o=t[i],n=2*Math.PI*this._rng();void 0===o.x&&(o.x=e*Math.cos(n)),void 0===o.y&&(o.y=e*Math.sin(n))}}}},{key:"layoutNetwork",value:function(){if(!0!==this.options.hierarchical.enabled&&!0===this.options.improvedLayout){for(var t=this.body.nodeIndices,e=0,i=0;i<t.length;i++){!0===this.body.nodes[t[i]].predefinedPosition&&(e+=1)}if(e<.5*t.length){var o=0,n=this.options.clusterThreshold,r={clusterNodeProperties:{shape:"ellipse",label:"",group:"",font:{multi:!1}},clusterEdgeProperties:{label:"",font:{multi:!1},smooth:{enabled:!1}}};if(t.length>n){for(var s=t.length;t.length>n&&o<=10;){o+=1;var a=t.length;if(o%3==0?this.body.modules.clustering.clusterBridges(r):this.body.modules.clustering.clusterOutliers(r),a==t.length&&o%3!=0)return this._declusterAll(),this.body.emitter.emit("_layoutFailed"),void console.info("This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.")}this.body.modules.kamadaKawai.setOptions({springLength:Math.max(150,2*s)})}o>10&&console.info("The clustering didn't succeed within the amount of interations allowed, progressing with partial result."),this.body.modules.kamadaKawai.solve(t,this.body.edgeIndices,!0),this._shiftToCenter();for(var h=0;h<t.length;h++){var d=this.body.nodes[t[h]];!1===d.predefinedPosition&&(d.x+=70*(.5-this._rng()),d.y+=70*(.5-this._rng()))}this._declusterAll(),this.body.emitter.emit("_repositionBezierNodes")}}}},{key:"_shiftToCenter",value:function(){for(var t=wu.getRangeCore(this.body.nodes,this.body.nodeIndices),e=wu.findCenter(t),i=0;i<this.body.nodeIndices.length;i++){var o=this.body.nodes[this.body.nodeIndices[i]];o.x-=e.x,o.y-=e.y}}},{key:"_declusterAll",value:function(){for(var t=!0;!0===t;){t=!1;for(var e=0;e<this.body.nodeIndices.length;e++)!0===this.body.nodes[this.body.nodeIndices[e]].isCluster&&(t=!0,this.body.modules.clustering.openCluster(this.body.nodeIndices[e],{},!1));!0===t&&this.body.emitter.emit("_dataChanged")}}},{key:"getSeed",value:function(){return this.initialRandomSeed}},{key:"setupHierarchicalLayout",value:function(){if(!0===this.options.hierarchical.enabled&&this.body.nodeIndices.length>0){var t,e,i=!1,o=!1;for(e in this.lastNodeOnLevel={},this.hierarchical=new Lf,this.body.nodes)Object.prototype.hasOwnProperty.call(this.body.nodes,e)&&(void 0!==(t=this.body.nodes[e]).options.level?(i=!0,this.hierarchical.levels[e]=t.options.level):o=!0);if(!0===o&&!0===i)throw new Error("To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.");if(!0===o){var n=this.options.hierarchical.sortMethod;"hubsize"===n?this._determineLevelsByHubsize():"directed"===n?this._determineLevelsDirected():"custom"===n&&this._determineLevelsCustomCallback()}for(var r in this.body.nodes)Object.prototype.hasOwnProperty.call(this.body.nodes,r)&&this.hierarchical.ensureLevel(r);var s=this._getDistribution();this._generateMap(),this._placeNodesByHierarchy(s),this._condenseHierarchy(),this._shiftToCenter()}}},{key:"_condenseHierarchy",value:function(){var t=this,e=!1,i={},o=function(e,i){var o=t.hierarchical.trees;for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&o[n]===e&&t.direction.shift(n,i)},n=function(){for(var e=[],i=0;i<t.hierarchical.numTrees();i++)e.push(t.direction.getTreeSize(i));return e},r=function e(i,o){if(!o[i.id]&&(o[i.id]=!0,t.hierarchical.childrenReference[i.id])){var n=t.hierarchical.childrenReference[i.id];if(n.length>0)for(var r=0;r<n.length;r++)e(t.body.nodes[n[r]],o)}},s=function(e){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e9,o=1e9,n=1e9,r=1e9,s=-1e9;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var h=t.body.nodes[a],d=t.hierarchical.levels[h.id],l=t.direction.getPosition(h),c=t._getSpaceAroundNode(h,e),u=an(c,2),f=u[0],p=u[1];o=Math.min(f,o),n=Math.min(p,n),d<=i&&(r=Math.min(l,r),s=Math.max(l,s))}return[r,s,o,n]},a=function(e,i){var o=t.hierarchical.getMaxLevel(e.id),n=t.hierarchical.getMaxLevel(i.id);return Math.min(o,n)},h=function(e,i,o){for(var n=t.hierarchical,r=0;r<i.length;r++){var s=i[r],a=n.distributionOrdering[s];if(a.length>1)for(var h=0;h<a.length-1;h++){var d=a[h],l=a[h+1];n.hasSameParent(d,l)&&n.inSameSubNetwork(d,l)&&e(d,l,o)}}},d=function(i,o){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],h=t.direction.getPosition(i),d=t.direction.getPosition(o),l=Math.abs(d-h),c=t.options.hierarchical.nodeSpacing;if(l>c){var u={},f={};r(i,u),r(o,f);var p=a(i,o),v=s(u,p),g=s(f,p),y=v[1],m=g[0],b=g[2],w=Math.abs(y-m);if(w>c){var k=y-m+c;k<-b+c&&(k=-b+c),k<0&&(t._shiftBlock(o.id,k),e=!0,!0===n&&t._centerParent(o))}}},l=function(o,n){for(var a=n.id,h=n.edges,d=t.hierarchical.levels[n.id],l=t.options.hierarchical.levelSeparation*t.options.hierarchical.levelSeparation,c={},u=[],f=0;f<h.length;f++){var p=h[f];if(p.toId!=p.fromId){var v=p.toId==a?p.from:p.to;c[h[f].id]=v,t.hierarchical.levels[v.id]<d&&u.push(p)}}var g=function(e,i){for(var o=0,n=0;n<i.length;n++)if(void 0!==c[i[n].id]){var r=t.direction.getPosition(c[i[n].id])-e;o+=r/Math.sqrt(r*r+l)}return o},y=function(e,i){for(var o=0,n=0;n<i.length;n++)if(void 0!==c[i[n].id]){var r=t.direction.getPosition(c[i[n].id])-e;o-=l*Math.pow(r*r+l,-1.5)}return o},m=function(e,i){for(var o=t.direction.getPosition(n),r={},s=0;s<e;s++){var a=g(o,i),h=y(o,i);if(void 0!==r[o-=Math.max(-40,Math.min(40,Math.round(a/h)))])break;r[o]=s}return o},b=m(o,u);!function(o){var a=t.direction.getPosition(n);if(void 0===i[n.id]){var h={};r(n,h),i[n.id]=h}var d=s(i[n.id]),l=d[2],c=d[3],u=o-a,f=0;u>0?f=Math.min(u,c-t.options.hierarchical.nodeSpacing):u<0&&(f=-Math.min(-u,l-t.options.hierarchical.nodeSpacing)),0!=f&&(t._shiftBlock(n.id,f),e=!0)}(b),function(i){var o=t.direction.getPosition(n),r=an(t._getSpaceAroundNode(n),2),s=r[0],a=r[1],h=i-o,d=o;h>0?d=Math.min(o+(a-t.options.hierarchical.nodeSpacing),i):h<0&&(d=Math.max(o-(s-t.options.hierarchical.nodeSpacing),i)),d!==o&&(t.direction.setPosition(n,d),e=!0)}(b=m(o,h))};!0===this.options.hierarchical.blockShifting&&(function(i){var o=t.hierarchical.getLevels();o=Nn(o).call(o);for(var n=0;n<i&&(e=!1,h(d,o,!0),!0===e);n++);}(5),function(){for(var e in t.body.nodes)Object.prototype.hasOwnProperty.call(t.body.nodes,e)&&t._centerParent(t.body.nodes[e])}()),!0===this.options.hierarchical.edgeMinimization&&function(i){var o=t.hierarchical.getLevels();o=Nn(o).call(o);for(var n=0;n<i;n++){e=!1;for(var r=0;r<o.length;r++)for(var s=o[r],a=t.hierarchical.distributionOrdering[s],h=0;h<a.length;h++)l(1e3,a[h]);if(!0!==e)break}}(20),!0===this.options.hierarchical.parentCentralization&&function(){var e=t.hierarchical.getLevels();e=Nn(e).call(e);for(var i=0;i<e.length;i++)for(var o=e[i],n=t.hierarchical.distributionOrdering[o],r=0;r<n.length;r++)t._centerParent(n[r])}(),function(){for(var e=n(),i=0,r=0;r<e.length-1;r++){i+=e[r].max-e[r+1].min+t.options.hierarchical.treeSpacing,o(r+1,i)}}()}},{key:"_getSpaceAroundNode",value:function(t,e){var i=!0;void 0===e&&(i=!1);var o=this.hierarchical.levels[t.id];if(void 0!==o){var n=this.hierarchical.distributionIndex[t.id],r=this.direction.getPosition(t),s=this.hierarchical.distributionOrdering[o],a=1e9,h=1e9;if(0!==n){var d=s[n-1];if(!0===i&&void 0===e[d.id]||!1===i)a=r-this.direction.getPosition(d)}if(n!=s.length-1){var l=s[n+1];if(!0===i&&void 0===e[l.id]||!1===i){var c=this.direction.getPosition(l);h=Math.min(h,c-r)}}return[a,h]}return[0,0]}},{key:"_centerParent",value:function(t){if(this.hierarchical.parentReference[t.id])for(var e=this.hierarchical.parentReference[t.id],i=0;i<e.length;i++){var o=e[i],n=this.body.nodes[o],r=this.hierarchical.childrenReference[o];if(void 0!==r){var s=this._getCenterPosition(r),a=this.direction.getPosition(n),h=an(this._getSpaceAroundNode(n),2),d=h[0],l=h[1],c=a-s;(c<0&&Math.abs(c)<l-this.options.hierarchical.nodeSpacing||c>0&&Math.abs(c)<d-this.options.hierarchical.nodeSpacing)&&this.direction.setPosition(n,s)}}}},{key:"_placeNodesByHierarchy",value:function(t){for(var e in this.positionedNodes={},t)if(Object.prototype.hasOwnProperty.call(t,e)){var i,o=xn(t[e]);o=this._indexArrayToNodes(o),bf(i=this.direction).call(i,o);for(var n=0,r=0;r<o.length;r++){var s=o[r];if(void 0===this.positionedNodes[s.id]){var a=this.options.hierarchical.nodeSpacing,h=a*n;n>0&&(h=this.direction.getPosition(o[r-1])+a),this.direction.setPosition(s,h,e),this._validatePositionAndContinue(s,e,h),n++}}}}},{key:"_placeBranchNodes",value:function(t,e){var i,o=this.hierarchical.childrenReference[t];if(void 0!==o){for(var n=[],r=0;r<o.length;r++)n.push(this.body.nodes[o[r]]);bf(i=this.direction).call(i,n);for(var s=0;s<n.length;s++){var a=n[s],h=this.hierarchical.levels[a.id];if(!(h>e&&void 0===this.positionedNodes[a.id]))return;var d=this.options.hierarchical.nodeSpacing,l=void 0;l=0===s?this.direction.getPosition(this.body.nodes[t]):this.direction.getPosition(n[s-1])+d,this.direction.setPosition(a,l,h),this._validatePositionAndContinue(a,h,l)}var c=this._getCenterPosition(n);this.direction.setPosition(this.body.nodes[t],c,e)}}},{key:"_validatePositionAndContinue",value:function(t,e,i){if(this.hierarchical.isTree){if(void 0!==this.lastNodeOnLevel[e]){var o=this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[e]]);if(i-o<this.options.hierarchical.nodeSpacing){var n=o+this.options.hierarchical.nodeSpacing-i,r=this._findCommonParent(this.lastNodeOnLevel[e],t.id);this._shiftBlock(r.withChild,n)}}this.lastNodeOnLevel[e]=t.id,this.positionedNodes[t.id]=!0,this._placeBranchNodes(t.id,e)}}},{key:"_indexArrayToNodes",value:function(t){for(var e=[],i=0;i<t.length;i++)e.push(this.body.nodes[t[i]]);return e}},{key:"_getDistribution",value:function(){var t,e,i={};for(t in this.body.nodes)if(Object.prototype.hasOwnProperty.call(this.body.nodes,t)){e=this.body.nodes[t];var o=void 0===this.hierarchical.levels[t]?0:this.hierarchical.levels[t];this.direction.fix(e,o),void 0===i[o]&&(i[o]={}),i[o][t]=e}return i}},{key:"_getActiveEdges",value:function(t){var e=this,i=[];return nh(t.edges,(function(t){var o;-1!==Mr(o=e.body.edgeIndices).call(o,t.id)&&i.push(t)})),i}},{key:"_getHubSizes",value:function(){var t=this,e={};nh(this.body.nodeIndices,(function(i){var o=t.body.nodes[i],n=t._getActiveEdges(o).length;e[n]=!0}));var i=[];return nh(e,(function(t){i.push(Number(t))})),bf(Cf).call(Cf,i,(function(t,e){return e-t})),i}},{key:"_determineLevelsByHubsize",value:function(){for(var t=this,e=function(e,i){t.hierarchical.levelDownstream(e,i)},i=this._getHubSizes(),o=function(o){var n=i[o];if(0===n)return"break";nh(t.body.nodeIndices,(function(i){var o=t.body.nodes[i];n===t._getActiveEdges(o).length&&t._crawlNetwork(e,i)}))},n=0;n<i.length;++n){if("break"===o(n))break}}},{key:"_determineLevelsCustomCallback",value:function(){var t=this;this._crawlNetwork((function(e,i,o){var n=t.hierarchical.levels[e.id];void 0===n&&(n=t.hierarchical.levels[e.id]=1e5);var r=(wu.cloneOptions(e,"node"),wu.cloneOptions(i,"node"),void wu.cloneOptions(o,"edge"));t.hierarchical.levels[i.id]=n+r})),this.hierarchical.setMinLevelToZero(this.body.nodes)}},{key:"_determineLevelsDirected",value:function(){var t,e=this,i=Of(t=this.body.nodeIndices).call(t,(function(t,i){return t.set(i,e.body.nodes[i]),t}),new Bd);"roots"===this.options.hierarchical.shakeTowards?this.hierarchical.levels=function(t){return jf((function(e){var i,o;return Ff(i=ar(o=e.edges).call(o,(function(e){return t.has(e.toId)}))).call(i,(function(t){return t.from===e}))}),(function(t,e){return e<t}),"to",t)}(i):this.hierarchical.levels=function(t){return jf((function(e){var i,o;return Ff(i=ar(o=e.edges).call(o,(function(e){return t.has(e.toId)}))).call(i,(function(t){return t.to===e}))}),(function(t,e){return e>t}),"from",t)}(i),this.hierarchical.setMinLevelToZero(this.body.nodes)}},{key:"_generateMap",value:function(){var t=this;this._crawlNetwork((function(e,i){t.hierarchical.levels[i.id]>t.hierarchical.levels[e.id]&&t.hierarchical.addRelation(e.id,i.id)})),this.hierarchical.checkIfTree()}},{key:"_crawlNetwork",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){},i=arguments.length>1?arguments[1]:void 0,o={},n=function i(n,r){if(void 0===o[n.id]){var s;t.hierarchical.setTreeIndex(n,r),o[n.id]=!0;for(var a=t._getActiveEdges(n),h=0;h<a.length;h++){var d=a[h];!0===d.connected&&(s=d.toId==n.id?d.from:d.to,n.id!=s.id&&(e(n,s,d),i(s,r)))}}};if(void 0===i)for(var r=0,s=0;s<this.body.nodeIndices.length;s++){var a=this.body.nodeIndices[s];if(void 0===o[a]){var h=this.body.nodes[a];n(h,r),r+=1}}else{var d=this.body.nodes[i];if(void 0===d)return void console.error("Node not found:",i);n(d)}}},{key:"_shiftBlock",value:function(t,e){var i=this,o={};!function t(n){if(!o[n]){o[n]=!0,i.direction.shift(n,e);var r=i.hierarchical.childrenReference[n];if(void 0!==r)for(var s=0;s<r.length;s++)t(r[s])}}(t)}},{key:"_findCommonParent",value:function(t,e){var i=this,o={};return function t(e,o){var n=i.hierarchical.parentReference[o];if(void 0!==n)for(var r=0;r<n.length;r++){var s=n[r];e[s]=!0,t(e,s)}}(o,t),function t(e,o){var n=i.hierarchical.parentReference[o];if(void 0!==n)for(var r=0;r<n.length;r++){var s=n[r];if(void 0!==e[s])return{foundParent:s,withChild:o};var a=t(e,s);if(null!==a.foundParent)return a}return{foundParent:null,withChild:o}}(o,e)}},{key:"setDirectionStrategy",value:function(){var t="UD"===this.options.hierarchical.direction||"DU"===this.options.hierarchical.direction;this.direction=t?new Mf(this):new Pf(this)}},{key:"_getCenterPosition",value:function(t){for(var e=1e9,i=-1e9,o=0;o<t.length;o++){var n=void 0;if(void 0!==t[o].id)n=t[o];else{var r=t[o];n=this.body.nodes[r]}var s=this.direction.getPosition(n);e=Math.min(e,s),i=Math.max(i,s)}return.5*(e+i)}}]),t}();function Wf(t,e){var i;if(void 0===cn||null==Ci(t)){if(gn(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return Vf(t,e);var o=vn(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===o&&t.constructor&&(o=t.constructor.name);if("Map"===o||"Set"===o)return mi(t);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return Vf(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var o=0,n=function(){};return{s:n,n:function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}},e:function(t){throw t},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=Si(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function Vf(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,o=new Array(e);i<e;i++)o[i]=t[i];return o}var qf=function(){function t(e,i,o,n){var r,s,a=this;Po(this,t),this.body=e,this.canvas=i,this.selectionHandler=o,this.interactionHandler=n,this.editMode=!1,this.manipulationDiv=void 0,this.editModeDiv=void 0,this.closeDiv=void 0,this._domEventListenerCleanupQueue=[],this.temporaryUIFunctions={},this.temporaryEventFunctions=[],this.touchTime=0,this.temporaryIds={nodes:[],edges:[]},this.guiEnabled=!1,this.inMode=!1,this.selectedControlNode=void 0,this.options={},this.defaultOptions={enabled:!1,initiallyActive:!1,addNode:!0,addEdge:!0,editNode:void 0,editEdge:!0,deleteNode:!0,deleteEdge:!0,controlNodeStyle:{shape:"dot",size:6,color:{background:"#ff0000",border:"#3c3c3c",highlight:{background:"#07f968",border:"#3c3c3c"}},borderWidth:2,borderWidthSelected:2}},ct(this.options,this.defaultOptions),this.body.emitter.on("destroy",(function(){a._clean()})),this.body.emitter.on("_dataChanged",bt(r=this._restore).call(r,this)),this.body.emitter.on("_resetData",bt(s=this._restore).call(s,this))}return Io(t,[{key:"_restore",value:function(){!1!==this.inMode&&(!0===this.options.initiallyActive?this.enableEditMode():this.disableEditMode())}},{key:"setOptions",value:function(t,e,i){void 0!==e&&(void 0!==e.locale?this.options.locale=e.locale:this.options.locale=i.locale,void 0!==e.locales?this.options.locales=e.locales:this.options.locales=i.locales),void 0!==t&&("boolean"==typeof t?this.options.enabled=t:(this.options.enabled=!0,th(this.options,t)),!0===this.options.initiallyActive&&(this.editMode=!0),this._setup())}},{key:"toggleEditMode",value:function(){!0===this.editMode?this.disableEditMode():this.enableEditMode()}},{key:"enableEditMode",value:function(){this.editMode=!0,this._clean(),!0===this.guiEnabled&&(this.manipulationDiv.style.display="block",this.closeDiv.style.display="block",this.editModeDiv.style.display="none",this.showManipulatorToolbar())}},{key:"disableEditMode",value:function(){this.editMode=!1,this._clean(),!0===this.guiEnabled&&(this.manipulationDiv.style.display="none",this.closeDiv.style.display="none",this.editModeDiv.style.display="block",this._createEditButton())}},{key:"showManipulatorToolbar",value:function(){if(this._clean(),this.manipulationDOM={},!0===this.guiEnabled){var t,e;this.editMode=!0,this.manipulationDiv.style.display="block",this.closeDiv.style.display="block";var i=this.selectionHandler.getSelectedNodeCount(),o=this.selectionHandler.getSelectedEdgeCount(),n=i+o,r=this.options.locales[this.options.locale],s=!1;!1!==this.options.addNode&&(this._createAddNodeButton(r),s=!0),!1!==this.options.addEdge&&(!0===s?this._createSeperator(1):s=!0,this._createAddEdgeButton(r)),1===i&&"function"==typeof this.options.editNode?(!0===s?this._createSeperator(2):s=!0,this._createEditNodeButton(r)):1===o&&0===i&&!1!==this.options.editEdge&&(!0===s?this._createSeperator(3):s=!0,this._createEditEdgeButton(r)),0!==n&&(i>0&&!1!==this.options.deleteNode||0===i&&!1!==this.options.deleteEdge)&&(!0===s&&this._createSeperator(4),this._createDeleteButton(r)),this._bindElementEvents(this.closeDiv,bt(t=this.toggleEditMode).call(t,this)),this._temporaryBindEvent("select",bt(e=this.showManipulatorToolbar).call(e,this))}this.body.emitter.emit("_redraw")}},{key:"addNodeMode",value:function(){var t;if(!0!==this.editMode&&this.enableEditMode(),this._clean(),this.inMode="addNode",!0===this.guiEnabled){var e,i=this.options.locales[this.options.locale];this.manipulationDOM={},this._createBackButton(i),this._createSeperator(),this._createDescription(i.addDescription||this.options.locales.en.addDescription),this._bindElementEvents(this.closeDiv,bt(e=this.toggleEditMode).call(e,this))}this._temporaryBindEvent("click",bt(t=this._performAddNode).call(t,this))}},{key:"editNode",value:function(){var t=this;!0!==this.editMode&&this.enableEditMode(),this._clean();var e=this.selectionHandler.getSelectedNodes()[0];if(void 0!==e){if(this.inMode="editNode","function"!=typeof this.options.editNode)throw new Error("No function has been configured to handle the editing of nodes.");if(!0!==e.isCluster){var i=th({},e.options,!1);if(i.x=e.x,i.y=e.y,2!==this.options.editNode.length)throw new Error("The function for edit does not support two arguments (data, callback)");this.options.editNode(i,(function(e){null!=e&&"editNode"===t.inMode&&t.body.data.nodes.getDataSet().update(e),t.showManipulatorToolbar()}))}else alert(this.options.locales[this.options.locale].editClusterError||this.options.locales.en.editClusterError)}else this.showManipulatorToolbar()}},{key:"addEdgeMode",value:function(){var t,e,i,o,n;if(!0!==this.editMode&&this.enableEditMode(),this._clean(),this.inMode="addEdge",!0===this.guiEnabled){var r,s=this.options.locales[this.options.locale];this.manipulationDOM={},this._createBackButton(s),this._createSeperator(),this._createDescription(s.edgeDescription||this.options.locales.en.edgeDescription),this._bindElementEvents(this.closeDiv,bt(r=this.toggleEditMode).call(r,this))}this._temporaryBindUI("onTouch",bt(t=this._handleConnect).call(t,this)),this._temporaryBindUI("onDragEnd",bt(e=this._finishConnect).call(e,this)),this._temporaryBindUI("onDrag",bt(i=this._dragControlNode).call(i,this)),this._temporaryBindUI("onRelease",bt(o=this._finishConnect).call(o,this)),this._temporaryBindUI("onDragStart",bt(n=this._dragStartEdge).call(n,this)),this._temporaryBindUI("onHold",(function(){}))}},{key:"editEdgeMode",value:function(){if(!0!==this.editMode&&this.enableEditMode(),this._clean(),this.inMode="editEdge","object"!==dn(this.options.editEdge)||"function"!=typeof this.options.editEdge.editWithoutDrag||(this.edgeBeingEditedId=this.selectionHandler.getSelectedEdgeIds()[0],void 0===this.edgeBeingEditedId)){if(!0===this.guiEnabled){var t,e=this.options.locales[this.options.locale];this.manipulationDOM={},this._createBackButton(e),this._createSeperator(),this._createDescription(e.editEdgeDescription||this.options.locales.en.editEdgeDescription),this._bindElementEvents(this.closeDiv,bt(t=this.toggleEditMode).call(t,this))}if(this.edgeBeingEditedId=this.selectionHandler.getSelectedEdgeIds()[0],void 0!==this.edgeBeingEditedId){var i,o,n,r,s=this.body.edges[this.edgeBeingEditedId],a=this._getNewTargetNode(s.from.x,s.from.y),h=this._getNewTargetNode(s.to.x,s.to.y);this.temporaryIds.nodes.push(a.id),this.temporaryIds.nodes.push(h.id),this.body.nodes[a.id]=a,this.body.nodeIndices.push(a.id),this.body.nodes[h.id]=h,this.body.nodeIndices.push(h.id),this._temporaryBindUI("onTouch",bt(i=this._controlNodeTouch).call(i,this)),this._temporaryBindUI("onTap",(function(){})),this._temporaryBindUI("onHold",(function(){})),this._temporaryBindUI("onDragStart",bt(o=this._controlNodeDragStart).call(o,this)),this._temporaryBindUI("onDrag",bt(n=this._controlNodeDrag).call(n,this)),this._temporaryBindUI("onDragEnd",bt(r=this._controlNodeDragEnd).call(r,this)),this._temporaryBindUI("onMouseMove",(function(){})),this._temporaryBindEvent("beforeDrawing",(function(t){var e=s.edgeType.findBorderPositions(t);!1===a.selected&&(a.x=e.from.x,a.y=e.from.y),!1===h.selected&&(h.x=e.to.x,h.y=e.to.y)})),this.body.emitter.emit("_redraw")}else this.showManipulatorToolbar()}else{var d=this.body.edges[this.edgeBeingEditedId];this._performEditEdge(d.from.id,d.to.id)}}},{key:"deleteSelected",value:function(){var t=this;!0!==this.editMode&&this.enableEditMode(),this._clean(),this.inMode="delete";var e=this.selectionHandler.getSelectedNodeIds(),i=this.selectionHandler.getSelectedEdgeIds(),o=void 0;if(e.length>0){for(var n=0;n<e.length;n++)if(!0===this.body.nodes[e[n]].isCluster)return void alert(this.options.locales[this.options.locale].deleteClusterError||this.options.locales.en.deleteClusterError);"function"==typeof this.options.deleteNode&&(o=this.options.deleteNode)}else i.length>0&&"function"==typeof this.options.deleteEdge&&(o=this.options.deleteEdge);if("function"==typeof o){var r={nodes:e,edges:i};if(2!==o.length)throw new Error("The function for delete does not support two arguments (data, callback)");o(r,(function(e){null!=e&&"delete"===t.inMode?(t.body.data.edges.getDataSet().remove(e.edges),t.body.data.nodes.getDataSet().remove(e.nodes),t.body.emitter.emit("startSimulation"),t.showManipulatorToolbar()):(t.body.emitter.emit("startSimulation"),t.showManipulatorToolbar())}))}else this.body.data.edges.getDataSet().remove(i),this.body.data.nodes.getDataSet().remove(e),this.body.emitter.emit("startSimulation"),this.showManipulatorToolbar()}},{key:"_setup",value:function(){!0===this.options.enabled?(this.guiEnabled=!0,this._createWrappers(),!1===this.editMode?this._createEditButton():this.showManipulatorToolbar()):(this._removeManipulationDOM(),this.guiEnabled=!1)}},{key:"_createWrappers",value:function(){var t,e;(void 0===this.manipulationDiv&&(this.manipulationDiv=document.createElement("div"),this.manipulationDiv.className="vis-manipulation",!0===this.editMode?this.manipulationDiv.style.display="block":this.manipulationDiv.style.display="none",this.canvas.frame.appendChild(this.manipulationDiv)),void 0===this.editModeDiv&&(this.editModeDiv=document.createElement("div"),this.editModeDiv.className="vis-edit-mode",!0===this.editMode?this.editModeDiv.style.display="none":this.editModeDiv.style.display="block",this.canvas.frame.appendChild(this.editModeDiv)),void 0===this.closeDiv)&&(this.closeDiv=document.createElement("button"),this.closeDiv.className="vis-close",this.closeDiv.setAttribute("aria-label",null!==(t=null===(e=this.options.locales[this.options.locale])||void 0===e?void 0:e.close)&&void 0!==t?t:this.options.locales.en.close),this.closeDiv.style.display=this.manipulationDiv.style.display,this.canvas.frame.appendChild(this.closeDiv))}},{key:"_getNewTargetNode",value:function(t,e){var i=th({},this.options.controlNodeStyle);i.id="targetNode"+bu(),i.hidden=!1,i.physics=!1,i.x=t,i.y=e;var o=this.body.functions.createNode(i);return o.shape.boundingBox={left:t,right:t,top:e,bottom:e},o}},{key:"_createEditButton",value:function(){var t;this._clean(),this.manipulationDOM={},Xa(this.editModeDiv);var e=this.options.locales[this.options.locale],i=this._createButton("editMode","vis-edit vis-edit-mode",e.edit||this.options.locales.en.edit);this.editModeDiv.appendChild(i),this._bindElementEvents(i,bt(t=this.toggleEditMode).call(t,this))}},{key:"_clean",value:function(){this.inMode=!1,!0===this.guiEnabled&&(Xa(this.editModeDiv),Xa(this.manipulationDiv),this._cleanupDOMEventListeners()),this._cleanupTemporaryNodesAndEdges(),this._unbindTemporaryUIs(),this._unbindTemporaryEvents(),this.body.emitter.emit("restorePhysics")}},{key:"_cleanupDOMEventListeners",value:function(){var t,e,i=Wf(qn(t=this._domEventListenerCleanupQueue).call(t,0));try{for(i.s();!(e=i.n()).done;){(0,e.value)()}}catch(t){i.e(t)}finally{i.f()}}},{key:"_removeManipulationDOM",value:function(){this._clean(),Xa(this.manipulationDiv),Xa(this.editModeDiv),Xa(this.closeDiv),this.manipulationDiv&&this.canvas.frame.removeChild(this.manipulationDiv),this.editModeDiv&&this.canvas.frame.removeChild(this.editModeDiv),this.closeDiv&&this.canvas.frame.removeChild(this.closeDiv),this.manipulationDiv=void 0,this.editModeDiv=void 0,this.closeDiv=void 0}},{key:"_createSeperator",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;this.manipulationDOM["seperatorLineDiv"+t]=document.createElement("div"),this.manipulationDOM["seperatorLineDiv"+t].className="vis-separator-line",this.manipulationDiv.appendChild(this.manipulationDOM["seperatorLineDiv"+t])}},{key:"_createAddNodeButton",value:function(t){var e,i=this._createButton("addNode","vis-add",t.addNode||this.options.locales.en.addNode);this.manipulationDiv.appendChild(i),this._bindElementEvents(i,bt(e=this.addNodeMode).call(e,this))}},{key:"_createAddEdgeButton",value:function(t){var e,i=this._createButton("addEdge","vis-connect",t.addEdge||this.options.locales.en.addEdge);this.manipulationDiv.appendChild(i),this._bindElementEvents(i,bt(e=this.addEdgeMode).call(e,this))}},{key:"_createEditNodeButton",value:function(t){var e,i=this._createButton("editNode","vis-edit",t.editNode||this.options.locales.en.editNode);this.manipulationDiv.appendChild(i),this._bindElementEvents(i,bt(e=this.editNode).call(e,this))}},{key:"_createEditEdgeButton",value:function(t){var e,i=this._createButton("editEdge","vis-edit",t.editEdge||this.options.locales.en.editEdge);this.manipulationDiv.appendChild(i),this._bindElementEvents(i,bt(e=this.editEdgeMode).call(e,this))}},{key:"_createDeleteButton",value:function(t){var e,i;i=this.options.rtl?"vis-delete-rtl":"vis-delete";var o=this._createButton("delete",i,t.del||this.options.locales.en.del);this.manipulationDiv.appendChild(o),this._bindElementEvents(o,bt(e=this.deleteSelected).call(e,this))}},{key:"_createBackButton",value:function(t){var e,i=this._createButton("back","vis-back",t.back||this.options.locales.en.back);this.manipulationDiv.appendChild(i),this._bindElementEvents(i,bt(e=this.showManipulatorToolbar).call(e,this))}},{key:"_createButton",value:function(t,e,i){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"vis-label";return this.manipulationDOM[t+"Div"]=document.createElement("button"),this.manipulationDOM[t+"Div"].className="vis-button "+e,this.manipulationDOM[t+"Label"]=document.createElement("div"),this.manipulationDOM[t+"Label"].className=o,this.manipulationDOM[t+"Label"].innerText=i,this.manipulationDOM[t+"Div"].appendChild(this.manipulationDOM[t+"Label"]),this.manipulationDOM[t+"Div"]}},{key:"_createDescription",value:function(t){this.manipulationDOM.descriptionLabel=document.createElement("div"),this.manipulationDOM.descriptionLabel.className="vis-none",this.manipulationDOM.descriptionLabel.innerText=t,this.manipulationDiv.appendChild(this.manipulationDOM.descriptionLabel)}},{key:"_temporaryBindEvent",value:function(t,e){this.temporaryEventFunctions.push({event:t,boundFunction:e}),this.body.emitter.on(t,e)}},{key:"_temporaryBindUI",value:function(t,e){if(void 0===this.body.eventListeners[t])throw new Error("This UI function does not exist. Typo? You tried: "+t+" possible are: "+Lr(xn(this.body.eventListeners)));this.temporaryUIFunctions[t]=this.body.eventListeners[t],this.body.eventListeners[t]=e}},{key:"_unbindTemporaryUIs",value:function(){for(var t in this.temporaryUIFunctions)Object.prototype.hasOwnProperty.call(this.temporaryUIFunctions,t)&&(this.body.eventListeners[t]=this.temporaryUIFunctions[t],delete this.temporaryUIFunctions[t]);this.temporaryUIFunctions={}}},{key:"_unbindTemporaryEvents",value:function(){for(var t=0;t<this.temporaryEventFunctions.length;t++){var e=this.temporaryEventFunctions[t].event,i=this.temporaryEventFunctions[t].boundFunction;this.body.emitter.off(e,i)}this.temporaryEventFunctions=[]}},{key:"_bindElementEvents",value:function(t,e){var i=new Sh(t,{});Tu(i,e),this._domEventListenerCleanupQueue.push((function(){i.destroy()}));var o=function(t){var i=t.keyCode,o=t.key;"Enter"!==o&&" "!==o&&13!==i&&32!==i||e()};t.addEventListener("keyup",o,!1),this._domEventListenerCleanupQueue.push((function(){t.removeEventListener("keyup",o,!1)}))}},{key:"_cleanupTemporaryNodesAndEdges",value:function(){for(var t=0;t<this.temporaryIds.edges.length;t++){var e;this.body.edges[this.temporaryIds.edges[t]].disconnect(),delete this.body.edges[this.temporaryIds.edges[t]];var i,o=Mr(e=this.body.edgeIndices).call(e,this.temporaryIds.edges[t]);if(-1!==o)qn(i=this.body.edgeIndices).call(i,o,1)}for(var n=0;n<this.temporaryIds.nodes.length;n++){var r;delete this.body.nodes[this.temporaryIds.nodes[n]];var s,a=Mr(r=this.body.nodeIndices).call(r,this.temporaryIds.nodes[n]);if(-1!==a)qn(s=this.body.nodeIndices).call(s,a,1)}this.temporaryIds={nodes:[],edges:[]}}},{key:"_controlNodeTouch",value:function(t){this.selectionHandler.unselectAll(),this.lastTouch=this.body.functions.getPointer(t.center),this.lastTouch.translation=ct({},this.body.view.translation)}},{key:"_controlNodeDragStart",value:function(){var t=this.lastTouch,e=this.selectionHandler._pointerToPositionObject(t),i=this.body.nodes[this.temporaryIds.nodes[0]],o=this.body.nodes[this.temporaryIds.nodes[1]],n=this.body.edges[this.edgeBeingEditedId];this.selectedControlNode=void 0;var r=i.isOverlappingWith(e),s=o.isOverlappingWith(e);!0===r?(this.selectedControlNode=i,n.edgeType.from=i):!0===s&&(this.selectedControlNode=o,n.edgeType.to=o),void 0!==this.selectedControlNode&&this.selectionHandler.selectObject(this.selectedControlNode),this.body.emitter.emit("_redraw")}},{key:"_controlNodeDrag",value:function(t){this.body.emitter.emit("disablePhysics");var e=this.body.functions.getPointer(t.center),i=this.canvas.DOMtoCanvas(e);void 0!==this.selectedControlNode?(this.selectedControlNode.x=i.x,this.selectedControlNode.y=i.y):this.interactionHandler.onDrag(t),this.body.emitter.emit("_redraw")}},{key:"_controlNodeDragEnd",value:function(t){var e=this.body.functions.getPointer(t.center),i=this.selectionHandler._pointerToPositionObject(e),o=this.body.edges[this.edgeBeingEditedId];if(void 0!==this.selectedControlNode){this.selectionHandler.unselectAll();for(var n=this.selectionHandler._getAllNodesOverlappingWith(i),r=void 0,s=n.length-1;s>=0;s--)if(n[s]!==this.selectedControlNode.id){r=this.body.nodes[n[s]];break}if(void 0!==r&&void 0!==this.selectedControlNode)if(!0===r.isCluster)alert(this.options.locales[this.options.locale].createEdgeError||this.options.locales.en.createEdgeError);else{var a=this.body.nodes[this.temporaryIds.nodes[0]];this.selectedControlNode.id===a.id?this._performEditEdge(r.id,o.to.id):this._performEditEdge(o.from.id,r.id)}else o.updateEdgeType(),this.body.emitter.emit("restorePhysics");this.body.emitter.emit("_redraw")}}},{key:"_handleConnect",value:function(t){if((new Date).valueOf()-this.touchTime>100){this.lastTouch=this.body.functions.getPointer(t.center),this.lastTouch.translation=ct({},this.body.view.translation),this.interactionHandler.drag.pointer=this.lastTouch,this.interactionHandler.drag.translation=this.lastTouch.translation;var e=this.lastTouch,i=this.selectionHandler.getNodeAt(e);if(void 0!==i)if(!0===i.isCluster)alert(this.options.locales[this.options.locale].createEdgeError||this.options.locales.en.createEdgeError);else{var o=this._getNewTargetNode(i.x,i.y);this.body.nodes[o.id]=o,this.body.nodeIndices.push(o.id);var n=this.body.functions.createEdge({id:"connectionEdge"+bu(),from:i.id,to:o.id,physics:!1,smooth:{enabled:!0,type:"continuous",roundness:.5}});this.body.edges[n.id]=n,this.body.edgeIndices.push(n.id),this.temporaryIds.nodes.push(o.id),this.temporaryIds.edges.push(n.id)}this.touchTime=(new Date).valueOf()}}},{key:"_dragControlNode",value:function(t){var e=this.body.functions.getPointer(t.center),i=this.selectionHandler._pointerToPositionObject(e),o=void 0;void 0!==this.temporaryIds.edges[0]&&(o=this.body.edges[this.temporaryIds.edges[0]].fromId);for(var n=this.selectionHandler._getAllNodesOverlappingWith(i),r=void 0,s=n.length-1;s>=0;s--){var a;if(-1===Mr(a=this.temporaryIds.nodes).call(a,n[s])){r=this.body.nodes[n[s]];break}}if(t.controlEdge={from:o,to:r?r.id:void 0},this.selectionHandler.generateClickEvent("controlNodeDragging",t,e),void 0!==this.temporaryIds.nodes[0]){var h=this.body.nodes[this.temporaryIds.nodes[0]];h.x=this.canvas._XconvertDOMtoCanvas(e.x),h.y=this.canvas._YconvertDOMtoCanvas(e.y),this.body.emitter.emit("_redraw")}else this.interactionHandler.onDrag(t)}},{key:"_finishConnect",value:function(t){var e=this.body.functions.getPointer(t.center),i=this.selectionHandler._pointerToPositionObject(e),o=void 0;void 0!==this.temporaryIds.edges[0]&&(o=this.body.edges[this.temporaryIds.edges[0]].fromId);for(var n=this.selectionHandler._getAllNodesOverlappingWith(i),r=void 0,s=n.length-1;s>=0;s--){var a;if(-1===Mr(a=this.temporaryIds.nodes).call(a,n[s])){r=this.body.nodes[n[s]];break}}this._cleanupTemporaryNodesAndEdges(),void 0!==r&&(!0===r.isCluster?alert(this.options.locales[this.options.locale].createEdgeError||this.options.locales.en.createEdgeError):void 0!==this.body.nodes[o]&&void 0!==this.body.nodes[r.id]&&this._performAddEdge(o,r.id)),t.controlEdge={from:o,to:r?r.id:void 0},this.selectionHandler.generateClickEvent("controlNodeDragEnd",t,e),this.body.emitter.emit("_redraw")}},{key:"_dragStartEdge",value:function(t){var e=this.lastTouch;this.selectionHandler.generateClickEvent("dragStart",t,e,void 0,!0)}},{key:"_performAddNode",value:function(t){var e=this,i={id:bu(),x:t.pointer.canvas.x,y:t.pointer.canvas.y,label:"new"};if("function"==typeof this.options.addNode){if(2!==this.options.addNode.length)throw this.showManipulatorToolbar(),new Error("The function for add does not support two arguments (data,callback)");this.options.addNode(i,(function(t){null!=t&&"addNode"===e.inMode&&e.body.data.nodes.getDataSet().add(t),e.showManipulatorToolbar()}))}else this.body.data.nodes.getDataSet().add(i),this.showManipulatorToolbar()}},{key:"_performAddEdge",value:function(t,e){var i=this,o={from:t,to:e};if("function"==typeof this.options.addEdge){if(2!==this.options.addEdge.length)throw new Error("The function for connect does not support two arguments (data,callback)");this.options.addEdge(o,(function(t){null!=t&&"addEdge"===i.inMode&&(i.body.data.edges.getDataSet().add(t),i.selectionHandler.unselectAll(),i.showManipulatorToolbar())}))}else this.body.data.edges.getDataSet().add(o),this.selectionHandler.unselectAll(),this.showManipulatorToolbar()}},{key:"_performEditEdge",value:function(t,e){var i=this,o={id:this.edgeBeingEditedId,from:t,to:e,label:this.body.data.edges.get(this.edgeBeingEditedId).label},n=this.options.editEdge;if("object"===dn(n)&&(n=n.editWithoutDrag),"function"==typeof n){if(2!==n.length)throw new Error("The function for edit does not support two arguments (data, callback)");n(o,(function(t){null==t||"editEdge"!==i.inMode?(i.body.edges[o.id].updateEdgeType(),i.body.emitter.emit("_redraw"),i.showManipulatorToolbar()):(i.body.data.edges.getDataSet().update(t),i.selectionHandler.unselectAll(),i.showManipulatorToolbar())}))}else this.body.data.edges.getDataSet().update(o),this.selectionHandler.unselectAll(),this.showManipulatorToolbar()}}]),t}(),Uf="string",Yf="boolean",Xf="number",Gf="array",Kf="object",$f=["arrow","bar","box","circle","crow","curve","diamond","image","inv_curve","inv_triangle","triangle","vee"],Qf={borderWidth:{number:Xf},borderWidthSelected:{number:Xf,undefined:"undefined"},brokenImage:{string:Uf,undefined:"undefined"},chosen:{label:{boolean:Yf,function:"function"},node:{boolean:Yf,function:"function"},__type__:{object:Kf,boolean:Yf}},color:{border:{string:Uf},background:{string:Uf},highlight:{border:{string:Uf},background:{string:Uf},__type__:{object:Kf,string:Uf}},hover:{border:{string:Uf},background:{string:Uf},__type__:{object:Kf,string:Uf}},__type__:{object:Kf,string:Uf}},opacity:{number:Xf,undefined:"undefined"},fixed:{x:{boolean:Yf},y:{boolean:Yf},__type__:{object:Kf,boolean:Yf}},font:{align:{string:Uf},color:{string:Uf},size:{number:Xf},face:{string:Uf},background:{string:Uf},strokeWidth:{number:Xf},strokeColor:{string:Uf},vadjust:{number:Xf},multi:{boolean:Yf,string:Uf},bold:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},boldital:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},ital:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},mono:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},__type__:{object:Kf,string:Uf}},group:{string:Uf,number:Xf,undefined:"undefined"},heightConstraint:{minimum:{number:Xf},valign:{string:Uf},__type__:{object:Kf,boolean:Yf,number:Xf}},hidden:{boolean:Yf},icon:{face:{string:Uf},code:{string:Uf},size:{number:Xf},color:{string:Uf},weight:{string:Uf,number:Xf},__type__:{object:Kf}},id:{string:Uf,number:Xf},image:{selected:{string:Uf,undefined:"undefined"},unselected:{string:Uf,undefined:"undefined"},__type__:{object:Kf,string:Uf}},imagePadding:{top:{number:Xf},right:{number:Xf},bottom:{number:Xf},left:{number:Xf},__type__:{object:Kf,number:Xf}},label:{string:Uf,undefined:"undefined"},labelHighlightBold:{boolean:Yf},level:{number:Xf,undefined:"undefined"},margin:{top:{number:Xf},right:{number:Xf},bottom:{number:Xf},left:{number:Xf},__type__:{object:Kf,number:Xf}},mass:{number:Xf},physics:{boolean:Yf},scaling:{min:{number:Xf},max:{number:Xf},label:{enabled:{boolean:Yf},min:{number:Xf},max:{number:Xf},maxVisible:{number:Xf},drawThreshold:{number:Xf},__type__:{object:Kf,boolean:Yf}},customScalingFunction:{function:"function"},__type__:{object:Kf}},shadow:{enabled:{boolean:Yf},color:{string:Uf},size:{number:Xf},x:{number:Xf},y:{number:Xf},__type__:{object:Kf,boolean:Yf}},shape:{string:["custom","ellipse","circle","database","box","text","image","circularImage","diamond","dot","star","triangle","triangleDown","square","icon","hexagon"]},ctxRenderer:{function:"function"},shapeProperties:{borderDashes:{boolean:Yf,array:Gf},borderRadius:{number:Xf},interpolation:{boolean:Yf},useImageSize:{boolean:Yf},useBorderWithImage:{boolean:Yf},coordinateOrigin:{string:["center","top-left"]},__type__:{object:Kf}},size:{number:Xf},title:{string:Uf,dom:"dom",undefined:"undefined"},value:{number:Xf,undefined:"undefined"},widthConstraint:{minimum:{number:Xf},maximum:{number:Xf},__type__:{object:Kf,boolean:Yf,number:Xf}},x:{number:Xf},y:{number:Xf},__type__:{object:Kf}},Zf={configure:{enabled:{boolean:Yf},filter:{boolean:Yf,string:Uf,array:Gf,function:"function"},container:{dom:"dom"},showButton:{boolean:Yf},__type__:{object:Kf,boolean:Yf,string:Uf,array:Gf,function:"function"}},edges:{arrows:{to:{enabled:{boolean:Yf},scaleFactor:{number:Xf},type:{string:$f},imageHeight:{number:Xf},imageWidth:{number:Xf},src:{string:Uf},__type__:{object:Kf,boolean:Yf}},middle:{enabled:{boolean:Yf},scaleFactor:{number:Xf},type:{string:$f},imageWidth:{number:Xf},imageHeight:{number:Xf},src:{string:Uf},__type__:{object:Kf,boolean:Yf}},from:{enabled:{boolean:Yf},scaleFactor:{number:Xf},type:{string:$f},imageWidth:{number:Xf},imageHeight:{number:Xf},src:{string:Uf},__type__:{object:Kf,boolean:Yf}},__type__:{string:["from","to","middle"],object:Kf}},endPointOffset:{from:{number:Xf},to:{number:Xf},__type__:{object:Kf,number:Xf}},arrowStrikethrough:{boolean:Yf},background:{enabled:{boolean:Yf},color:{string:Uf},size:{number:Xf},dashes:{boolean:Yf,array:Gf},__type__:{object:Kf,boolean:Yf}},chosen:{label:{boolean:Yf,function:"function"},edge:{boolean:Yf,function:"function"},__type__:{object:Kf,boolean:Yf}},color:{color:{string:Uf},highlight:{string:Uf},hover:{string:Uf},inherit:{string:["from","to","both"],boolean:Yf},opacity:{number:Xf},__type__:{object:Kf,string:Uf}},dashes:{boolean:Yf,array:Gf},font:{color:{string:Uf},size:{number:Xf},face:{string:Uf},background:{string:Uf},strokeWidth:{number:Xf},strokeColor:{string:Uf},align:{string:["horizontal","top","middle","bottom"]},vadjust:{number:Xf},multi:{boolean:Yf,string:Uf},bold:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},boldital:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},ital:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},mono:{color:{string:Uf},size:{number:Xf},face:{string:Uf},mod:{string:Uf},vadjust:{number:Xf},__type__:{object:Kf,string:Uf}},__type__:{object:Kf,string:Uf}},hidden:{boolean:Yf},hoverWidth:{function:"function",number:Xf},label:{string:Uf,undefined:"undefined"},labelHighlightBold:{boolean:Yf},length:{number:Xf,undefined:"undefined"},physics:{boolean:Yf},scaling:{min:{number:Xf},max:{number:Xf},label:{enabled:{boolean:Yf},min:{number:Xf},max:{number:Xf},maxVisible:{number:Xf},drawThreshold:{number:Xf},__type__:{object:Kf,boolean:Yf}},customScalingFunction:{function:"function"},__type__:{object:Kf}},selectionWidth:{function:"function",number:Xf},selfReferenceSize:{number:Xf},selfReference:{size:{number:Xf},angle:{number:Xf},renderBehindTheNode:{boolean:Yf},__type__:{object:Kf}},shadow:{enabled:{boolean:Yf},color:{string:Uf},size:{number:Xf},x:{number:Xf},y:{number:Xf},__type__:{object:Kf,boolean:Yf}},smooth:{enabled:{boolean:Yf},type:{string:["dynamic","continuous","discrete","diagonalCross","straightCross","horizontal","vertical","curvedCW","curvedCCW","cubicBezier"]},roundness:{number:Xf},forceDirection:{string:["horizontal","vertical","none"],boolean:Yf},__type__:{object:Kf,boolean:Yf}},title:{string:Uf,undefined:"undefined"},width:{number:Xf},widthConstraint:{maximum:{number:Xf},__type__:{object:Kf,boolean:Yf,number:Xf}},value:{number:Xf,undefined:"undefined"},__type__:{object:Kf}},groups:{useDefaultGroups:{boolean:Yf},__any__:Qf,__type__:{object:Kf}},interaction:{dragNodes:{boolean:Yf},dragView:{boolean:Yf},hideEdgesOnDrag:{boolean:Yf},hideEdgesOnZoom:{boolean:Yf},hideNodesOnDrag:{boolean:Yf},hover:{boolean:Yf},keyboard:{enabled:{boolean:Yf},speed:{x:{number:Xf},y:{number:Xf},zoom:{number:Xf},__type__:{object:Kf}},bindToWindow:{boolean:Yf},__type__:{object:Kf,boolean:Yf}},multiselect:{boolean:Yf},navigationButtons:{boolean:Yf},selectable:{boolean:Yf},selectConnectedEdges:{boolean:Yf},hoverConnectedEdges:{boolean:Yf},tooltipDelay:{number:Xf},zoomView:{boolean:Yf},zoomSpeed:{number:Xf},__type__:{object:Kf}},layout:{randomSeed:{undefined:"undefined",number:Xf,string:Uf},improvedLayout:{boolean:Yf},clusterThreshold:{number:Xf},hierarchical:{enabled:{boolean:Yf},levelSeparation:{number:Xf},nodeSpacing:{number:Xf},treeSpacing:{number:Xf},blockShifting:{boolean:Yf},edgeMinimization:{boolean:Yf},parentCentralization:{boolean:Yf},direction:{string:["UD","DU","LR","RL"]},sortMethod:{string:["hubsize","directed"]},shakeTowards:{string:["leaves","roots"]},__type__:{object:Kf,boolean:Yf}},__type__:{object:Kf}},manipulation:{enabled:{boolean:Yf},initiallyActive:{boolean:Yf},addNode:{boolean:Yf,function:"function"},addEdge:{boolean:Yf,function:"function"},editNode:{function:"function"},editEdge:{editWithoutDrag:{function:"function"},__type__:{object:Kf,boolean:Yf,function:"function"}},deleteNode:{boolean:Yf,function:"function"},deleteEdge:{boolean:Yf,function:"function"},controlNodeStyle:Qf,__type__:{object:Kf,boolean:Yf}},nodes:Qf,physics:{enabled:{boolean:Yf},barnesHut:{theta:{number:Xf},gravitationalConstant:{number:Xf},centralGravity:{number:Xf},springLength:{number:Xf},springConstant:{number:Xf},damping:{number:Xf},avoidOverlap:{number:Xf},__type__:{object:Kf}},forceAtlas2Based:{theta:{number:Xf},gravitationalConstant:{number:Xf},centralGravity:{number:Xf},springLength:{number:Xf},springConstant:{number:Xf},damping:{number:Xf},avoidOverlap:{number:Xf},__type__:{object:Kf}},repulsion:{centralGravity:{number:Xf},springLength:{number:Xf},springConstant:{number:Xf},nodeDistance:{number:Xf},damping:{number:Xf},__type__:{object:Kf}},hierarchicalRepulsion:{centralGravity:{number:Xf},springLength:{number:Xf},springConstant:{number:Xf},nodeDistance:{number:Xf},damping:{number:Xf},avoidOverlap:{number:Xf},__type__:{object:Kf}},maxVelocity:{number:Xf},minVelocity:{number:Xf},solver:{string:["barnesHut","repulsion","hierarchicalRepulsion","forceAtlas2Based"]},stabilization:{enabled:{boolean:Yf},iterations:{number:Xf},updateInterval:{number:Xf},onlyDynamicEdges:{boolean:Yf},fit:{boolean:Yf},__type__:{object:Kf,boolean:Yf}},timestep:{number:Xf},adaptiveTimestep:{boolean:Yf},wind:{x:{number:Xf},y:{number:Xf},__type__:{object:Kf}},__type__:{object:Kf,boolean:Yf}},autoResize:{boolean:Yf},clickToUse:{boolean:Yf},locale:{string:Uf},locales:{__any__:{any:"any"},__type__:{object:Kf}},height:{string:Uf},width:{string:Uf},__type__:{object:Kf}},Jf={nodes:{borderWidth:[1,0,10,1],borderWidthSelected:[2,0,10,1],color:{border:["color","#2B7CE9"],background:["color","#97C2FC"],highlight:{border:["color","#2B7CE9"],background:["color","#D2E5FF"]},hover:{border:["color","#2B7CE9"],background:["color","#D2E5FF"]}},opacity:[0,0,1,.1],fixed:{x:!1,y:!1},font:{color:["color","#343434"],size:[14,0,100,1],face:["arial","verdana","tahoma"],background:["color","none"],strokeWidth:[0,0,50,1],strokeColor:["color","#ffffff"]},hidden:!1,labelHighlightBold:!0,physics:!0,scaling:{min:[10,0,200,1],max:[30,0,200,1],label:{enabled:!1,min:[14,0,200,1],max:[30,0,200,1],maxVisible:[30,0,200,1],drawThreshold:[5,0,20,1]}},shadow:{enabled:!1,color:"rgba(0,0,0,0.5)",size:[10,0,20,1],x:[5,-30,30,1],y:[5,-30,30,1]},shape:["ellipse","box","circle","database","diamond","dot","square","star","text","triangle","triangleDown","hexagon"],shapeProperties:{borderDashes:!1,borderRadius:[6,0,20,1],interpolation:!0,useImageSize:!1},size:[25,0,200,1]},edges:{arrows:{to:{enabled:!1,scaleFactor:[1,0,3,.05],type:"arrow"},middle:{enabled:!1,scaleFactor:[1,0,3,.05],type:"arrow"},from:{enabled:!1,scaleFactor:[1,0,3,.05],type:"arrow"}},endPointOffset:{from:[0,-10,10,1],to:[0,-10,10,1]},arrowStrikethrough:!0,color:{color:["color","#848484"],highlight:["color","#848484"],hover:["color","#848484"],inherit:["from","to","both",!0,!1],opacity:[1,0,1,.05]},dashes:!1,font:{color:["color","#343434"],size:[14,0,100,1],face:["arial","verdana","tahoma"],background:["color","none"],strokeWidth:[2,0,50,1],strokeColor:["color","#ffffff"],align:["horizontal","top","middle","bottom"]},hidden:!1,hoverWidth:[1.5,0,5,.1],labelHighlightBold:!0,physics:!0,scaling:{min:[1,0,100,1],max:[15,0,100,1],label:{enabled:!0,min:[14,0,200,1],max:[30,0,200,1],maxVisible:[30,0,200,1],drawThreshold:[5,0,20,1]}},selectionWidth:[1.5,0,5,.1],selfReferenceSize:[20,0,200,1],selfReference:{size:[20,0,200,1],angle:[Math.PI/2,-6*Math.PI,6*Math.PI,Math.PI/8],renderBehindTheNode:!0},shadow:{enabled:!1,color:"rgba(0,0,0,0.5)",size:[10,0,20,1],x:[5,-30,30,1],y:[5,-30,30,1]},smooth:{enabled:!0,type:["dynamic","continuous","discrete","diagonalCross","straightCross","horizontal","vertical","curvedCW","curvedCCW","cubicBezier"],forceDirection:["horizontal","vertical","none"],roundness:[.5,0,1,.05]},width:[1,0,30,1]},layout:{hierarchical:{enabled:!1,levelSeparation:[150,20,500,5],nodeSpacing:[100,20,500,5],treeSpacing:[200,20,500,5],blockShifting:!0,edgeMinimization:!0,parentCentralization:!0,direction:["UD","DU","LR","RL"],sortMethod:["hubsize","directed"],shakeTowards:["leaves","roots"]}},interaction:{dragNodes:!0,dragView:!0,hideEdgesOnDrag:!1,hideEdgesOnZoom:!1,hideNodesOnDrag:!1,hover:!1,keyboard:{enabled:!1,speed:{x:[10,0,40,1],y:[10,0,40,1],zoom:[.02,0,.1,.005]},bindToWindow:!0},multiselect:!1,navigationButtons:!1,selectable:!0,selectConnectedEdges:!0,hoverConnectedEdges:!0,tooltipDelay:[300,0,1e3,25],zoomView:!0,zoomSpeed:[1,.1,2,.1]},manipulation:{enabled:!1,initiallyActive:!1},physics:{enabled:!0,barnesHut:{theta:[.5,.1,1,.05],gravitationalConstant:[-2e3,-3e4,0,50],centralGravity:[.3,0,10,.05],springLength:[95,0,500,5],springConstant:[.04,0,1.2,.005],damping:[.09,0,1,.01],avoidOverlap:[0,0,1,.01]},forceAtlas2Based:{theta:[.5,.1,1,.05],gravitationalConstant:[-50,-500,0,1],centralGravity:[.01,0,1,.005],springLength:[95,0,500,5],springConstant:[.08,0,1.2,.005],damping:[.4,0,1,.01],avoidOverlap:[0,0,1,.01]},repulsion:{centralGravity:[.2,0,10,.05],springLength:[200,0,500,5],springConstant:[.05,0,1.2,.005],nodeDistance:[100,0,500,5],damping:[.09,0,1,.01]},hierarchicalRepulsion:{centralGravity:[.2,0,10,.05],springLength:[100,0,500,5],springConstant:[.01,0,1.2,.005],nodeDistance:[120,0,500,5],damping:[.09,0,1,.01],avoidOverlap:[0,0,1,.01]},maxVelocity:[50,0,150,1],minVelocity:[.1,.01,.5,.01],solver:["barnesHut","forceAtlas2Based","repulsion","hierarchicalRepulsion"],timestep:[.5,.01,1,.01],wind:{x:[0,-10,10,.1],y:[0,-10,10,.1]}}},tp=function(t,e,i){var o;return!(!Jn(t).call(t,"physics")||!Jn(o=Jf.physics.solver).call(o,e)||i.physics.solver===e||"wind"===e)},ep=Object.freeze({__proto__:null,configuratorHideOption:tp,allOptions:Zf,configureOptions:Jf}),ip=function(){function t(){Po(this,t)}return Io(t,[{key:"getDistances",value:function(t,e,i){for(var o={},n=t.edges,r=0;r<e.length;r++){var s={};o[e[r]]=s;for(var a=0;a<e.length;a++)s[e[a]]=r==a?0:1e9}for(var h=0;h<i.length;h++){var d=n[i[h]];!0===d.connected&&void 0!==o[d.fromId]&&void 0!==o[d.toId]&&(o[d.fromId][d.toId]=1,o[d.toId][d.fromId]=1)}for(var l=e.length,c=0;c<l;c++)for(var u=e[c],f=o[u],p=0;p<l-1;p++)for(var v=e[p],g=o[v],y=p+1;y<l;y++){var m=e[y],b=o[m],w=Math.min(g[m],g[u]+f[m]);g[m]=w,b[v]=w}return o}}]),t}(),op=function(){function t(e,i,o){Po(this,t),this.body=e,this.springLength=i,this.springConstant=o,this.distanceSolver=new ip}return Io(t,[{key:"setOptions",value:function(t){t&&(t.springLength&&(this.springLength=t.springLength),t.springConstant&&(this.springConstant=t.springConstant))}},{key:"solve",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=this.distanceSolver.getDistances(this.body,t,e);this._createL_matrix(o),this._createK_matrix(o),this._createE_matrix();for(var n=.01,r=1,s=0,a=Math.max(1e3,Math.min(10*this.body.nodeIndices.length,6e3)),h=5,d=1e9,l=0,c=0,u=0,f=0,p=0;d>n&&s<a;){s+=1;var v=this._getHighestEnergyNode(i),g=an(v,4);for(l=g[0],d=g[1],c=g[2],u=g[3],f=d,p=0;f>r&&p<h;){p+=1,this._moveNode(l,c,u);var y=this._getEnergy(l),m=an(y,3);f=m[0],c=m[1],u=m[2]}}}},{key:"_getHighestEnergyNode",value:function(t){for(var e=this.body.nodeIndices,i=this.body.nodes,o=0,n=e[0],r=0,s=0,a=0;a<e.length;a++){var h=e[a];if(!0!==i[h].predefinedPosition||!0===i[h].isCluster&&!0===t||!0!==i[h].options.fixed.x||!0!==i[h].options.fixed.y){var d=an(this._getEnergy(h),3),l=d[0],c=d[1],u=d[2];o<l&&(o=l,n=h,r=c,s=u)}}return[n,o,r,s]}},{key:"_getEnergy",value:function(t){var e=an(this.E_sums[t],2),i=e[0],o=e[1];return[Math.sqrt(Math.pow(i,2)+Math.pow(o,2)),i,o]}},{key:"_moveNode",value:function(t,e,i){for(var o=this.body.nodeIndices,n=this.body.nodes,r=0,s=0,a=0,h=n[t].x,d=n[t].y,l=this.K_matrix[t],c=this.L_matrix[t],u=0;u<o.length;u++){var f=o[u];if(f!==t){var p=n[f].x,v=n[f].y,g=l[f],y=c[f],m=1/Math.pow(Math.pow(h-p,2)+Math.pow(d-v,2),1.5);r+=g*(1-y*Math.pow(d-v,2)*m),s+=g*(y*(h-p)*(d-v)*m),a+=g*(1-y*Math.pow(h-p,2)*m)}}var b=(e/r+i/s)/(s/r-a/s),w=-(s*b+e)/r;n[t].x+=w,n[t].y+=b,this._updateE_matrix(t)}},{key:"_createL_matrix",value:function(t){var e=this.body.nodeIndices,i=this.springLength;this.L_matrix=[];for(var o=0;o<e.length;o++){this.L_matrix[e[o]]={};for(var n=0;n<e.length;n++)this.L_matrix[e[o]][e[n]]=i*t[e[o]][e[n]]}}},{key:"_createK_matrix",value:function(t){var e=this.body.nodeIndices,i=this.springConstant;this.K_matrix=[];for(var o=0;o<e.length;o++){this.K_matrix[e[o]]={};for(var n=0;n<e.length;n++)this.K_matrix[e[o]][e[n]]=i*Math.pow(t[e[o]][e[n]],-2)}}},{key:"_createE_matrix",value:function(){var t=this.body.nodeIndices,e=this.body.nodes;this.E_matrix={},this.E_sums={};for(var i=0;i<t.length;i++)this.E_matrix[t[i]]=[];for(var o=0;o<t.length;o++){for(var n=t[o],r=e[n].x,s=e[n].y,a=0,h=0,d=o;d<t.length;d++){var l=t[d];if(l!==n){var c=e[l].x,u=e[l].y,f=1/Math.sqrt(Math.pow(r-c,2)+Math.pow(s-u,2));this.E_matrix[n][d]=[this.K_matrix[n][l]*(r-c-this.L_matrix[n][l]*(r-c)*f),this.K_matrix[n][l]*(s-u-this.L_matrix[n][l]*(s-u)*f)],this.E_matrix[l][o]=this.E_matrix[n][d],a+=this.E_matrix[n][d][0],h+=this.E_matrix[n][d][1]}}this.E_sums[n]=[a,h]}}},{key:"_updateE_matrix",value:function(t){for(var e=this.body.nodeIndices,i=this.body.nodes,o=this.E_matrix[t],n=this.K_matrix[t],r=this.L_matrix[t],s=i[t].x,a=i[t].y,h=0,d=0,l=0;l<e.length;l++){var c=e[l];if(c!==t){var u=o[l],f=u[0],p=u[1],v=i[c].x,g=i[c].y,y=1/Math.sqrt(Math.pow(s-v,2)+Math.pow(a-g,2)),m=n[c]*(s-v-r[c]*(s-v)*y),b=n[c]*(a-g-r[c]*(a-g)*y);o[l]=[m,b],h+=m,d+=b;var w=this.E_sums[c];w[0]+=m-f,w[1]+=b-p}}this.E_sums[t]=[h,d]}}]),t}();function np(t,e,i){var o,n,r,s,a=this;if(!(this instanceof np))throw new SyntaxError("Constructor must be called with the new operator");this.options={},this.defaultOptions={locale:"en",locales:ud,clickToUse:!1},ct(this.options,this.defaultOptions),this.body={container:t,nodes:{},nodeIndices:[],edges:{},edgeIndices:[],emitter:{on:bt(o=this.on).call(o,this),off:bt(n=this.off).call(n,this),emit:bt(r=this.emit).call(r,this),once:bt(s=this.once).call(s,this)},eventListeners:{onTap:function(){},onTouch:function(){},onDoubleTap:function(){},onHold:function(){},onDragStart:function(){},onDrag:function(){},onDragEnd:function(){},onMouseWheel:function(){},onPinch:function(){},onMouseMove:function(){},onRelease:function(){},onContext:function(){}},data:{nodes:null,edges:null},functions:{createNode:function(){},createEdge:function(){},getPointer:function(){}},modules:{},view:{scale:1,translation:{x:0,y:0}},selectionBox:{show:!1,position:{start:{x:0,y:0},end:{x:0,y:0}}}},this.bindEventListeners(),this.images=new pd((function(){return a.body.emitter.emit("_requestRedraw")})),this.groups=new Id,this.canvas=new Pu(this.body),this.selectionHandler=new cf(this.body,this.canvas),this.interactionHandler=new Au(this.body,this.canvas,this.selectionHandler),this.view=new Bu(this.body,this.canvas),this.renderer=new Cu(this.body,this.canvas),this.physics=new uu(this.body),this.layoutEngine=new Hf(this.body),this.clustering=new xu(this.body),this.manipulation=new qf(this.body,this.canvas,this.selectionHandler,this.interactionHandler),this.nodesHandler=new fc(this.body,this.images,this.groups,this.layoutEngine),this.edgesHandler=new tu(this.body,this.images,this.groups),this.body.modules.kamadaKawai=new op(this.body,150,.05),this.body.modules.clustering=this.clustering,this.canvas._create(),this.setOptions(i),this.setData(e)}Ct(np.prototype),np.prototype.setOptions=function(t){var e=this;if(null===t&&(t=void 0),void 0!==t){!0===Ph.validate(t,Zf)&&console.error("%cErrors have been found in the supplied options object.",Mh);if(Za(["locale","locales","clickToUse"],this.options,t),void 0!==t.locale&&(t.locale=function(t,e){try{var i=an(e.split(/[-_ /]/,2),2),o=i[0],n=i[1],r=null!=o?o.toLowerCase():null,s=null!=n?n.toUpperCase():null;if(r&&s){var a,h=r+"-"+s;if(Object.prototype.hasOwnProperty.call(t,h))return h;console.warn(pn(a="Unknown variant ".concat(s," of language ")).call(a,r,"."))}if(r){var d=r;if(Object.prototype.hasOwnProperty.call(t,d))return d;console.warn("Unknown language ".concat(r))}return console.warn("Unknown locale ".concat(e,", falling back to English.")),"en"}catch(t){return console.error(t),console.warn("Unexpected error while normalizing locale ".concat(e,", falling back to English.")),"en"}}(t.locales||this.options.locales,t.locale)),t=this.layoutEngine.setOptions(t.layout,t),this.canvas.setOptions(t),this.groups.setOptions(t.groups),this.nodesHandler.setOptions(t.nodes),this.edgesHandler.setOptions(t.edges),this.physics.setOptions(t.physics),this.manipulation.setOptions(t.manipulation,t,this.options),this.interactionHandler.setOptions(t.interaction),this.renderer.setOptions(t.interaction),this.selectionHandler.setOptions(t.interaction),void 0!==t.groups&&this.body.emitter.emit("refreshNodes"),"configure"in t&&(this.configurator||(this.configurator=new Ch(this,this.body.container,Jf,this.canvas.pixelRatio,tp)),this.configurator.setOptions(t.configure)),this.configurator&&!0===this.configurator.options.enabled){var i={nodes:{},edges:{},layout:{},interaction:{},manipulation:{},physics:{},global:{}};th(i.nodes,this.nodesHandler.options),th(i.edges,this.edgesHandler.options),th(i.layout,this.layoutEngine.options),th(i.interaction,this.selectionHandler.options),th(i.interaction,this.renderer.options),th(i.interaction,this.interactionHandler.options),th(i.manipulation,this.manipulation.options),th(i.physics,this.physics.options),th(i.global,this.canvas.options),th(i.global,this.options),this.configurator.setModuleOptions(i)}void 0!==t.clickToUse?!0===t.clickToUse?void 0===this.activator&&(this.activator=new Oh(this.canvas.frame),this.activator.on("change",(function(){e.body.emitter.emit("activate")}))):(void 0!==this.activator&&(this.activator.destroy(),delete this.activator),this.body.emitter.emit("activate")):this.body.emitter.emit("activate"),this.canvas.setSize(),this.body.emitter.emit("startSimulation")}},np.prototype._updateVisibleIndices=function(){var t=this.body.nodes,e=this.body.edges;for(var i in this.body.nodeIndices=[],this.body.edgeIndices=[],t)Object.prototype.hasOwnProperty.call(t,i)&&(this.clustering._isClusteredNode(i)||!1!==t[i].options.hidden||this.body.nodeIndices.push(t[i].id));for(var o in e)if(Object.prototype.hasOwnProperty.call(e,o)){var n=e[o],r=t[n.fromId],s=t[n.toId],a=void 0!==r&&void 0!==s;!this.clustering._isClusteredEdge(o)&&!1===n.options.hidden&&a&&!1===r.options.hidden&&!1===s.options.hidden&&this.body.edgeIndices.push(n.id)}},np.prototype.bindEventListeners=function(){var t=this;this.body.emitter.on("_dataChanged",(function(){t.edgesHandler._updateState(),t.body.emitter.emit("_dataUpdated")})),this.body.emitter.on("_dataUpdated",(function(){t.clustering._updateState(),t._updateVisibleIndices(),t._updateValueRange(t.body.nodes),t._updateValueRange(t.body.edges),t.body.emitter.emit("startSimulation"),t.body.emitter.emit("_requestRedraw")}))},np.prototype.setData=function(t){if(this.body.emitter.emit("resetPhysics"),this.body.emitter.emit("_resetData"),this.selectionHandler.unselectAll(),t&&t.dot&&(t.nodes||t.edges))throw new SyntaxError('Data must contain either parameter "dot" or  parameter pair "nodes" and "edges", but not both.');if(this.setOptions(t&&t.options),t&&t.dot){console.warn("The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);");var e=hd(t.dot);this.setData(e)}else if(t&&t.gephi){console.warn("The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);");var i=ld(t.gephi);this.setData(i)}else this.nodesHandler.setData(t&&t.nodes,!0),this.edgesHandler.setData(t&&t.edges,!0),this.body.emitter.emit("_dataChanged"),this.body.emitter.emit("_dataLoaded"),this.body.emitter.emit("initPhysics")},np.prototype.destroy=function(){for(var t in this.body.emitter.emit("destroy"),this.body.emitter.off(),this.off(),delete this.groups,delete this.canvas,delete this.selectionHandler,delete this.interactionHandler,delete this.view,delete this.renderer,delete this.physics,delete this.layoutEngine,delete this.clustering,delete this.manipulation,delete this.nodesHandler,delete this.edgesHandler,delete this.configurator,delete this.images,this.body.nodes)Object.prototype.hasOwnProperty.call(this.body.nodes,t)&&delete this.body.nodes[t];for(var e in this.body.edges)Object.prototype.hasOwnProperty.call(this.body.edges,e)&&delete this.body.edges[e];Xa(this.body.container)},np.prototype._updateValueRange=function(t){var e,i=void 0,o=void 0,n=0;for(e in t)if(Object.prototype.hasOwnProperty.call(t,e)){var r=t[e].getValue();void 0!==r&&(i=void 0===i?r:Math.min(r,i),o=void 0===o?r:Math.max(r,o),n+=r)}if(void 0!==i&&void 0!==o)for(e in t)Object.prototype.hasOwnProperty.call(t,e)&&t[e].setValueRange(i,o,n)},np.prototype.isActive=function(){return!this.activator||this.activator.active},np.prototype.setSize=function(){return this.canvas.setSize.apply(this.canvas,arguments)},np.prototype.canvasToDOM=function(){return this.canvas.canvasToDOM.apply(this.canvas,arguments)},np.prototype.DOMtoCanvas=function(){return this.canvas.DOMtoCanvas.apply(this.canvas,arguments)},np.prototype.findNode=function(){return this.clustering.findNode.apply(this.clustering,arguments)},np.prototype.isCluster=function(){return this.clustering.isCluster.apply(this.clustering,arguments)},np.prototype.openCluster=function(){return this.clustering.openCluster.apply(this.clustering,arguments)},np.prototype.cluster=function(){return this.clustering.cluster.apply(this.clustering,arguments)},np.prototype.getNodesInCluster=function(){return this.clustering.getNodesInCluster.apply(this.clustering,arguments)},np.prototype.clusterByConnection=function(){return this.clustering.clusterByConnection.apply(this.clustering,arguments)},np.prototype.clusterByHubsize=function(){return this.clustering.clusterByHubsize.apply(this.clustering,arguments)},np.prototype.updateClusteredNode=function(){return this.clustering.updateClusteredNode.apply(this.clustering,arguments)},np.prototype.getClusteredEdges=function(){return this.clustering.getClusteredEdges.apply(this.clustering,arguments)},np.prototype.getBaseEdge=function(){return this.clustering.getBaseEdge.apply(this.clustering,arguments)},np.prototype.getBaseEdges=function(){return this.clustering.getBaseEdges.apply(this.clustering,arguments)},np.prototype.updateEdge=function(){return this.clustering.updateEdge.apply(this.clustering,arguments)},np.prototype.clusterOutliers=function(){return this.clustering.clusterOutliers.apply(this.clustering,arguments)},np.prototype.getSeed=function(){return this.layoutEngine.getSeed.apply(this.layoutEngine,arguments)},np.prototype.enableEditMode=function(){return this.manipulation.enableEditMode.apply(this.manipulation,arguments)},np.prototype.disableEditMode=function(){return this.manipulation.disableEditMode.apply(this.manipulation,arguments)},np.prototype.addNodeMode=function(){return this.manipulation.addNodeMode.apply(this.manipulation,arguments)},np.prototype.editNode=function(){return this.manipulation.editNode.apply(this.manipulation,arguments)},np.prototype.editNodeMode=function(){return console.warn("Deprecated: Please use editNode instead of editNodeMode."),this.manipulation.editNode.apply(this.manipulation,arguments)},np.prototype.addEdgeMode=function(){return this.manipulation.addEdgeMode.apply(this.manipulation,arguments)},np.prototype.editEdgeMode=function(){return this.manipulation.editEdgeMode.apply(this.manipulation,arguments)},np.prototype.deleteSelected=function(){return this.manipulation.deleteSelected.apply(this.manipulation,arguments)},np.prototype.getPositions=function(){return this.nodesHandler.getPositions.apply(this.nodesHandler,arguments)},np.prototype.getPosition=function(){return this.nodesHandler.getPosition.apply(this.nodesHandler,arguments)},np.prototype.storePositions=function(){return this.nodesHandler.storePositions.apply(this.nodesHandler,arguments)},np.prototype.moveNode=function(){return this.nodesHandler.moveNode.apply(this.nodesHandler,arguments)},np.prototype.getBoundingBox=function(){return this.nodesHandler.getBoundingBox.apply(this.nodesHandler,arguments)},np.prototype.getConnectedNodes=function(t){return void 0!==this.body.nodes[t]?this.nodesHandler.getConnectedNodes.apply(this.nodesHandler,arguments):this.edgesHandler.getConnectedNodes.apply(this.edgesHandler,arguments)},np.prototype.getConnectedEdges=function(){return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler,arguments)},np.prototype.startSimulation=function(){return this.physics.startSimulation.apply(this.physics,arguments)},np.prototype.stopSimulation=function(){return this.physics.stopSimulation.apply(this.physics,arguments)},np.prototype.stabilize=function(){return this.physics.stabilize.apply(this.physics,arguments)},np.prototype.getSelection=function(){return this.selectionHandler.getSelection.apply(this.selectionHandler,arguments)},np.prototype.setSelection=function(){return this.selectionHandler.setSelection.apply(this.selectionHandler,arguments)},np.prototype.getSelectedNodes=function(){return this.selectionHandler.getSelectedNodeIds.apply(this.selectionHandler,arguments)},np.prototype.getSelectedEdges=function(){return this.selectionHandler.getSelectedEdgeIds.apply(this.selectionHandler,arguments)},np.prototype.getNodeAt=function(){var t=this.selectionHandler.getNodeAt.apply(this.selectionHandler,arguments);return void 0!==t&&void 0!==t.id?t.id:t},np.prototype.getEdgeAt=function(){var t=this.selectionHandler.getEdgeAt.apply(this.selectionHandler,arguments);return void 0!==t&&void 0!==t.id?t.id:t},np.prototype.selectNodes=function(){return this.selectionHandler.selectNodes.apply(this.selectionHandler,arguments)},np.prototype.selectEdges=function(){return this.selectionHandler.selectEdges.apply(this.selectionHandler,arguments)},np.prototype.unselectAll=function(){this.selectionHandler.unselectAll.apply(this.selectionHandler,arguments),this.selectionHandler.commitWithoutEmitting.apply(this.selectionHandler),this.redraw()},np.prototype.redraw=function(){return this.renderer.redraw.apply(this.renderer,arguments)},np.prototype.getScale=function(){return this.view.getScale.apply(this.view,arguments)},np.prototype.getViewPosition=function(){return this.view.getViewPosition.apply(this.view,arguments)},np.prototype.fit=function(){return this.view.fit.apply(this.view,arguments)},np.prototype.moveTo=function(){return this.view.moveTo.apply(this.view,arguments)},np.prototype.focus=function(){return this.view.focus.apply(this.view,arguments)},np.prototype.releaseNode=function(){return this.view.releaseNode.apply(this.view,arguments)},np.prototype.getOptionsFromConfigurator=function(){var t={};return this.configurator&&(t=this.configurator.getOptions.apply(this.configurator)),t};var rp=hd;t.Network=np,t.NetworkImages=pd,t.networkDOTParser=dd,t.networkGephiParser=cd,t.networkOptions=ep,t.parseDOTNetwork=rp,t.parseGephiNetwork=ld,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=vis-network.min.js.map


/***/ }),

/***/ "./src/blitzboard.js":
/*!***************************!*\
  !*** ./src/blitzboard.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! leaflet/dist/leaflet.css */ "./node_modules/leaflet/dist/leaflet.css");
__webpack_require__(/*! @iconify/iconify */ "./node_modules/@iconify/iconify/dist/iconify.min.js");
__webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js");
__webpack_require__(/*! ./pg_parser_browserified.js */ "./src/pg_parser_browserified.js");

let visData = __webpack_require__(/*! vis-data */ "./node_modules/vis-data/peer/umd/vis-data.min.js");
let visNetwork = __webpack_require__(/*! vis-network */ "./node_modules/vis-network/peer/umd/vis-network.min.js");

const defaultWidth = 2;

module.exports = class Blitzboard {
  static fontLoaded = false;
  static defaultConfig = {
    doubleClickWait: 200,
    node: {
      caption: ['id'],
      defaultIcon: true,
      thumbnail: 'thumbnail',
      saturation: '100%',
      brightness: '37%',
      limit: 500
    },
    edge: {
      caption: ['label'],
      saturation: '0%',
      brightness: '62%',
      limit: 10000,
      width: defaultWidth
    },
    zoom: { 
      max: 3.0,
      min: 0.25,
    },
    layoutSettings: {
      time_from: 'from',
      time_to: 'to',
      lng: 'lng',
      lat: 'lat'
    },
    style: "border: solid 1px silver; background: radial-gradient(white, silver);",
    extraOptions: {
      interaction: {
        keyboard: true
      }
    }
  };
  static tooltipMaxWidth = 600;
  static iconPrefixes = ['fa-solid:', 'ion:', 'bx:bx-', 'gridicons:', 'akar-icons:'];
  static iconSizeCoef = 1.5;
  static minScaleOnMap = 0.3;
  static maxScaleOnMap = 1.0;
  static mapContainerId = 'map';
  static edgeDelimiter = '-';
  static nodeTemplate = {
    id: null,
    labels: [],
    properties: {}
  }
  static edgeTemplate = {
    from: null,
    to: null,
    direction: '->',
    labels: [],
    properties: {}
  }

  static loadedIcons = {};
  
  static renderedColors = {};
  
  constructor(container) {
    this.container = container;
    this.nodeColorMap = {};
    this.expandedNodes = [];
    this.nodeMap = {};
    this.config = { node: {}, edge: {}};
    this.nodeLineMap = {};
    this.edgeMap = {};
    this.edgeLineMap = {};
    this.prevZoomPosition = null;
    this.warnings = [];
    this.elementWithTooltip = null;
    
    this.container.style.position = 'absolute';
    
    this.networkContainer = document.createElement('div');
    this.networkContainer.style = this.networkContainerOriginalStyle = `
      height: 100%;
      width: 100%;
      top: 0;
      left: 0;
      position: absolute;
      z-index: 2;
    `;
    
    this.mapContainer = document.createElement('div');
    this.mapContainer.style = `
      height: 100%;
      width: 100%;
      top: 0;
      left: 0;
      position: absolute;
      z-index: 1;
    `;
    this.map = null;
    this.tooltipDummy = document.createElement('div');
    this.tooltipDummy.style.position = 'absolute';
    this.tooltipDummy.classList.add('blitzboard-tooltip');
    this.tooltipDummy.style['background-color'] = 'rgba(0, 0, 0, 0)';
    this.tooltipDummy.style['z-index'] = '998';

    this.tooltip = document.createElement('span');
    this.tooltip.style.display = 'none';
    this.tooltip.classList.add('blitzboard-tooltiptext');
    this.tooltip.classList.add('blitzboard-tooltiptext-top');
    this.tooltip.style['z-index'] = '999';


    this.minTime = new Date(8640000000000000);
    this.maxTime = new Date(-8640000000000000);
    
    this.prevMouseEvent= null;
    this.timeScale = 1000;
    this.dragging = false;
    this.currentLatLng = null;
    this.redrawTimer = null;
    this.onNodeAdded = [];
    this.onEdgeAdded = [];
    this.onNodeFocused = [];
    this.onEdgeFocused = [];
    this.onUpdated = [];
    this.beforeParse = [];
    this.onParseError = [];
    this.maxLine = 0;
    this.scrollAnimationTimerId = null;
    this.screen = document.createElement('div');
    this.screenText = document.createElement('div');
    this.screenText.style = `
      font-size: 2rem;
      background-color: rgba(255, 255, 255, 0.5);
      padding: 10px;
    `;
    this.screen.appendChild(this.screenText);
    this.screenText.innerText = "Now loading...";
    this.screen.style = `
      background-color: rgba(0, 0, 0, 0.3);
      z-index: 3;
      position: absolute;
      height: 100%;
      width: 100%;
      display: none;
      justify-content: center;
      align-items: center;
      font-size: 2rem;
    `;
    this.doubleClickTimer = null;
    
    let blitzboard = this;

    container.appendChild(this.screen);
    container.appendChild(this.networkContainer);
    container.appendChild(this.mapContainer);
    document.body.appendChild(this.tooltipDummy);
    this.tooltipDummy.appendChild(this.tooltip);
    this.tooltip.addEventListener('mouseleave', (e) => {
      if(e.relatedTarget !== blitzboard.network.canvas.getContext().canvas)
        blitzboard.hideTooltip();
    });

    this.container.addEventListener('wheel', (e) => {
      if(blitzboard.config.layout === 'map')
      {
        if((e.deltaY < 0 && blitzboard.map._zoom < blitzboard.map.getMaxZoom()) ||
          (e.deltaY > 0 && blitzboard.map._zoom > blitzboard.map.getMinZoom()) ) {
          if(!blitzboard.currentLatLng) {
            blitzboard.currentLatLng = blitzboard.map.mouseEventToLatLng(e);
          }
          blitzboard.map.setZoomAround(blitzboard.currentLatLng, blitzboard.map._zoom - e.deltaY * 0.03, {animate: false});
        }
        let newScale = blitzboard.map._zoom / 12 + 0.4;
        newScale = Math.min(Blitzboard.maxScaleOnMap, Math.max(newScale, Blitzboard.minScaleOnMap));
        setTimeout( () => {
          blitzboard.network.moveTo({scale: newScale});
          blitzboard.updateNodeLocationOnMap();
        }, 10);
        blitzboard.map.invalidateSize();
        e.preventDefault();
        e.stopPropagation(); // Inhibit zoom on vis-network
      }
    }, true);
    
    this.container.addEventListener('mouseout', (e) => {
      blitzboard.dragging = false;
    }, true);

    this.container.addEventListener('mouseup', (e) => {
      blitzboard.dragging = false;
    }, true);
    
    this.container.addEventListener('mousemove', (e) => {
      if(blitzboard.dragging && blitzboard.config.layout === 'map' && blitzboard.prevMouseEvent) {
        blitzboard.map.panBy([blitzboard.prevMouseEvent.x - e.x, blitzboard.prevMouseEvent.y - e.y], {animate: false});
      }
      if(blitzboard.elementWithTooltip?.edge) {
        this.updateTooltipLocation();
      }
      blitzboard.prevMouseEvent = e;
      blitzboard.currentLatLng = null;
    }, true);

    this.container.addEventListener('dblclick', (e) => {
      if(blitzboard.config.layout === 'map') {
        blitzboard.map.panTo(blitzboard.map.mouseEventToLatLng(e));
      }
    }, true);

    this.container.addEventListener('mousedown', (e) => {
      blitzboard.dragging = true;
      blitzboard.prevMouseEvent = e;
    }, true);
    
    this.applyDynamicStyle(`
      .blitzboard-tooltip {
        position: absolute;
        display: inline-block;
        border-bottom: 1px dotted black;
      }
      
      .blitzboard-tooltip .blitzboard-tooltiptext {
        max-width: ${Blitzboard.tooltipMaxWidth}px;
        min-width: 200px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        text-align: center;
        border-radius: 6px;
        padding: 5px;
        position: absolute;
        z-index: 1;
        opacity: 1;
        transition: opacity 0.3s;
      }
      
      .blitzboard-tooltip .blitzboard-tooltiptext-top {
        bottom: 125%;
        left: 50%;
        margin-left: -6px;
      }
      
      .blitzboard-tooltip .blitzboard-tooltiptext-bottom {
        bottom: 100%;
        left: 50%;
        margin-left: -6px;
      }
      
      
      .blitzboard-tooltip .blitzboard-tooltiptext-left {
        top: 50%;
        left: 0%;
      }
      
      .blitzboard-tooltip .blitzboard-tooltiptext-right {
        top: -50%;
        left: 100%;
      }
      
      
      .blitzboard-tooltip .blitzboard-tooltiptext::after {
        content: "";
        position: absolute;
        border-width: 6px;
        border-style: solid;
      }
      
      .blitzboard-tooltip .blitzboard-tooltiptext-bottom::after {
        top: -12px;
        left: 50%;
        border-color: transparent transparent #555 transparent;
      }
      
      .blitzboard-tooltip .blitzboard-tooltiptext-left::after {
        top: 50%;
        left: 100%;
        border-color: transparent transparent transparent #555;
      }
      
      .blitzboard-tooltip .blitzboard-tooltiptext-top::after {
        top: 100%;
        left: 50%;
        border-color: #555 transparent transparent transparent;
      }

      .blitzboard-tooltip .blitzboard-tooltiptext-right::after {
        top: 50%;
        left: -12px;
        border-color: transparent #555 transparent transparent;
      }
      
      .blitzboard-tooltiptext th, .blitzboard-tooltiptext td {
        text-align: left;
        padding-left: 10px;
      }
      
      .blitzboard-tooltip a {
        color: #88BBFF;
      }
    `);
  }

  static blitzProxy = {
    get: function(target, prop, receiver) {
      if (prop === 'label') {
        return target.labels[0];
      }
      if (!(prop in target) && prop in target.properties) {
        return target.properties[prop][0]; 
      }
      return Reflect.get(target, prop, receiver);
    }
  }

  applyDynamicStyle(css) {
    var styleTag = document.createElement('style');
    var dynamicStyleCss = document.createTextNode(css);
    styleTag.appendChild(dynamicStyleCss);
    var header = document.getElementsByTagName('head')[0];
    header.appendChild(styleTag);
  };

  getHexColors(colorStr) {
    let computed = Blitzboard.renderedColors[colorStr];
    if(computed) {
      return computed;
    }
    let a = document.createElement('div');
    a.style.color = colorStr;
    let colors = window.getComputedStyle( document.body.appendChild(a) ).color.match(/\d+/g).map(function(a){ return parseInt(a,10); });
    document.body.removeChild(a);
    Blitzboard.renderedColors[colorStr] = colors;
    return colors;
  }
  
  hasNode(node_id) {
    return !!this.nodeMap[node_id];
  }
  
  hasEdge(from, to, label = null) {
    for(let edge of this.graph.edges) {
      if(edge.from === from && edge.to === to && (!label || edge.labels.includes(label)))
        return true;
    }
    return false;
  }
  
  getAllNodes(label = null) {
    if(label)
      return this.graph.nodes.filter(node => node.labels.includes(label)).map(node => this.getNode(node.id));
    else
      return this.graph.nodes.map(node => this.getNode(node.id));
  }

  getNode(node_id) {
    return new Proxy(this.nodeMap[node_id], Blitzboard.blitzProxy);
  }
  
  getEdge(edge_id) {
    return new Proxy(this.edgeMap[edge_id], Blitzboard.blitzProxy);
  }
  
  calcNodePosition(pgNode) {
    let x, y, fixed, width;
    if(this.config.layout === 'timeline' && this.timeInterval > 0) {
      x = null;
      fixed = false;
      let fromProp = this.config.layoutSettings.time_from;
      let toProp = this.config.layoutSettings.time_to;
      let from = this.maxTime;
      let to = this.minTime;

      for (let prop of Object.keys(pgNode.properties)) {
        if (prop === fromProp || prop === toProp) {
          from = new Date(Math.min(from, new Date(pgNode.properties[prop][0])));
          to = new Date(Math.max(to, new Date(pgNode.properties[prop][0])));
        }
      }
    
      if(from <= to) {
        fixed = true;
        let fromPosition = this.timeScale * (from.getTime() - this.minTime.getTime()) * 1.0 / this.timeInterval - this.timeScale * 0.5;
        let toPosition = this.timeScale * (to.getTime() - this.minTime.getTime()) * 1.0 / this.timeInterval - this.timeScale * 0.5;
        x = (fromPosition + toPosition) / 2;
        if(from === to) {
          width = fromPosition - toPosition;
        } else {
          width = 25;
        }
      } else {
        x = 0;
      }
    }
    else {
      if(this.config.layout == 'custom') {
        if (pgNode.properties[this.config.layoutSettings.x] || pgNode.properties[this.config.layoutSettings.y]) {
          x = parseInt(pgNode.properties[this.config.layoutSettings.x][0]);
          y = parseInt(pgNode.properties[this.config.layoutSettings.y][0]);
          fixed = true;
        }
      } else {
        x = null;
        y = null;
        fixed = this.config.layout === 'hierarchical';
        width = null;
      }
    }
    
    return {x, y, fixed, width};
  }

  retrieveThumbnailUrl(node) {
    if(this.config.node.thumbnail) {
      return node.properties[this.config.node.thumbnail]?.[0];
    }
    return null;
  }
  
  tooltipPosition() {
    if(window.innerWidth < window.innerHeight) {
      return this.prevMouseEvent.clientY < window.innerHeight / 2 ? 'bottom' : 'top';
    }
    return this.prevMouseEvent.clientX < window.innerWidth / 2 ? 'right' : 'left';
  }
  
  updateTooltipLocation() {
    if(!this.elementWithTooltip)
      return;
    let position, offset = 10;
    if(this.elementWithTooltip.node) {
      position = this.network.canvasToDOM(this.network.getPosition(this.elementWithTooltip.node.id));
      let clientRect = this.container.getClientRects()[0];
      position.x += clientRect.x;
      position.y += clientRect.y;
      offset += this.elementWithTooltip.node.size * this.network.getScale();
    }
    else {
      position = {
        x: this.prevMouseEvent.clientX,
        y: this.prevMouseEvent.clientY
      };
    }
    position.x += window.scrollX;
    position.y += window.scrollY;
    
    switch(this.tooltipPosition()) {
      case 'left':
        this.tooltip.classList.add('blitzboard-tooltiptext-left');
        this.tooltip.classList.remove('blitzboard-tooltiptext-top');
        this.tooltip.classList.remove('blitzboard-tooltiptext-right');
        this.tooltip.classList.remove('blitzboard-tooltiptext-bottom');
        position.x -= offset;
        position.x -= this.tooltip.clientWidth;
        position.y -= this.tooltip.clientHeight / 2;
        break;
      case 'top':
        this.tooltip.classList.remove('blitzboard-tooltiptext-left');
        this.tooltip.classList.add('blitzboard-tooltiptext-top');
        this.tooltip.classList.remove('blitzboard-tooltiptext-right');
        this.tooltip.classList.remove('blitzboard-tooltiptext-bottom');
        position.x -= this.tooltip.clientWidth / 2;
        position.y -= offset;
        break;
      case 'right':
        this.tooltip.classList.remove('blitzboard-tooltiptext-left');
        this.tooltip.classList.remove('blitzboard-tooltiptext-top');
        this.tooltip.classList.add('blitzboard-tooltiptext-right');
        this.tooltip.classList.remove('blitzboard-tooltiptext-bottom');
        position.x += offset;
        position.y -= this.tooltip.clientHeight / 2;
        break;
      case 'bottom':
        this.tooltip.classList.remove('blitzboard-tooltiptext-left');
        this.tooltip.classList.remove('blitzboard-tooltiptext-top');
        this.tooltip.classList.remove('blitzboard-tooltiptext-right');
        this.tooltip.classList.add('blitzboard-tooltiptext-bottom');
        position.x -= this.tooltip.clientWidth / 2;
        position.y += this.tooltip.clientHeight;
        position.y += offset;
        break;
    }

    this.tooltipDummy.style.left = `${position.x}px`;
    this.tooltipDummy.style.top = `${position.y}px`;
  }
  
  showTooltip() {
    this.updateTooltipLocation();
    let title = this.elementWithTooltip.node ? this.elementWithTooltip.node._title : this.elementWithTooltip.edge._title;
    if(!title)
      return;
    
    this.tooltip.innerHTML = title;
    this.tooltip.style.display = 'block';
  }
  
  hideTooltip() {
    if(this.elementWithTooltip) {
      this.tooltip.style.display = 'none';
      this.elementWithTooltip = null;
    }
  }

  toVisNode(pgNode, props, extraOptions = null) {
    const group = [...pgNode.labels].sort().join('_');
    if(!this.nodeColorMap[group]) {
      this.nodeColorMap[group] = getRandomColor(group, this.config.node.saturation, this.config.node.brightness);
    }
    
    let x, y, fixed, width;
    ({x, y, fixed, width} = this.calcNodePosition(pgNode));

    let url = retrieveHttpUrl(pgNode);
    let thumbnailUrl = this.retrieveThumbnailUrl(pgNode);
    let expanded = this.expandedNodes.includes(pgNode.id);

    let degree =  pgNode.properties['degree'];
    let blitzboard = this;
    if(degree !== undefined) {
      degree = degree[0];
    } else {
      degree = 2; // assume degree to be two (default)
    }

    let color = this.retrieveConfigProp(pgNode, 'node', 'color');
    let opacity = parseFloat(this.retrieveConfigProp(pgNode, 'node', 'opacity'));
    let size  = parseFloat(this.retrieveConfigProp(pgNode, 'node', 'size'));
    let tooltip  = this.retrieveConfigProp(pgNode, 'node', 'title');

    color = color || this.nodeColorMap[group];
    
    if(opacity < 1) {
      let rgb = this.getHexColors(color);
      color = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${opacity})`;
    }

    let attrs = {
      id: pgNode.id,
      color: color,
      label: createLabelText(pgNode, props),
      shape: 'dot',
      size: size || 25,
      degree: degree,
      _title: tooltip != null ? tooltip : this.createTitle(pgNode),
      fixed: {
        x: fixed,
        y: this.config.layout === 'timeline' ? false : fixed
      },
      borderWidth: url ? 3 : 1,
      url: url,
      x: x,
      y: y,
      chosen: this.retrieveConfigProp(pgNode, 'node', 'chosen'),
      font: {
        color: url ? 'blue' : 'black',
        strokeWidth: 2,
      },
      fixedByTime: fixed
    };
    
    let otherProps = this.retrieveConfigPropAll(pgNode,
      'node', ['color', 'size', 'opacity', 'title']);
    
    for(let key of Object.keys(otherProps)) {
      attrs[key] = otherProps[key] || attrs[key];
    }
    
    function iconRegisterer(name) {
      return (icons) => {
        if (icons.length > 0) {
          let icon = null;
          if(icons.length > 1) {
            // Find icon with the highest priority 
            for (let prefix of Blitzboard.iconPrefixes) {
              for (let i of icons) {
                if (`${i.prefix}:${i.name}`.startsWith(prefix)) {
                  icon = i; 
                  break;
                }
              }
              if (icon) {
                break;
              }
            }
          }
          icon = icon || icons[0];
          let size = attrs.size * Blitzboard.iconSizeCoef;
          let svg = Iconify.renderSVG(`${icon.prefix}:${icon.name}`, {
            width: size,
            height: size
          });
          let img = new Image();
          svg.querySelectorAll("path,circle,ellipse,rect").forEach((path) => {
            path.style.fill = "white";
            path.style.stroke = "white";
          });
          img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg.outerHTML);
          Blitzboard.loadedIcons[name] = img;
          if(blitzboard) {
            if (blitzboard.redrawTimer) {
              clearTimeout(blitzboard.redrawTimer);
            }
            blitzboard.redrawTimer = setTimeout(() => {  // Add delay to avoid redraw too ofen
              blitzboard.network.redraw();
            }, 1000);
          }
        }
      };
    }

    for(let label of pgNode.labels) {
      let icon;
      if (icon = this.config.node.icon?.[label]) {
        if(icon.includes(':')) { // For icons in iconify
          Iconify.loadIcons([icon], iconRegisterer(icon));
          attrs['customIcon'] = {
            name: icon
          };
        } else { // For icon codes in Ionicons (to be backward compatible)
          let code = String.fromCharCode(parseInt(icon, 16));
          attrs['customIcon'] = {
            face: 'Ionicons',
            size: attrs.size * 1.5,
            code: code,
            color: 'white'
          };
          break;
        }
      }
    }


    if(!attrs['customIcon'] && this.config.node.defaultIcon) {
      for(let label of pgNode.labels) {
        let lowerLabel = label.toLowerCase();
        if (!Blitzboard.loadedIcons[lowerLabel]) {
          Blitzboard.loadedIcons[lowerLabel] = 'retrieving...'; // Just a placeholder to avoid duplicate fetching
          Iconify.loadIcons(
            Blitzboard.iconPrefixes.map((prefix) => prefix + lowerLabel),
            iconRegisterer(lowerLabel)
          );
        }
      }
    }
    
    if(thumbnailUrl) {
      attrs['shape'] = 'image';
      attrs['image'] = thumbnailUrl;
    }
    attrs = Object.assign(attrs, extraOptions);
    return attrs;
  }
  
  retrieveProp(pgElem, config, loadFunction = true) {
    if((typeof config) === 'function' && loadFunction) {
      return config(new Proxy(pgElem, Blitzboard.blitzProxy));
    } else if((typeof config) === 'string' && config.startsWith('@')) {
      return pgElem.properties[config.substr(1)]?.[0];
    }
    return config; // return as constant
  }
  
  retrieveConfigProp(pgElem, type, propName, loadFunction = true) {
    const labels = pgElem.labels.join('_');
    let propConfig = this.config?.[type][propName];
    if ((typeof propConfig) === 'object') {
      return this.retrieveProp(pgElem, propConfig[labels], loadFunction)
    }
    return this.retrieveProp(pgElem, propConfig, loadFunction);
  }

  retrieveConfigPropAll(pgElem, type, except) {
    let keys = Object.keys(this.config?.[type]);
    let props = {};
    for(let key of keys) {
      if(except.includes(key))
        continue;
      // TODO: How can we allow functions for arbitrary config?
      props[key] = this.retrieveConfigProp(pgElem, type, key, false);
    }
    return props;
  }
  
  toVisEdge(pgEdge, props = this.config.edge.caption, id) {
    const edgeLabel = pgEdge.labels.join('_');
    if (!this.edgeColorMap[edgeLabel]) {
      this.edgeColorMap[edgeLabel] = getRandomColor(edgeLabel, this.config.edge.saturation || '0%', this.config.edge.brightness || '30%');
    }
    let color = this.retrieveConfigProp(pgEdge, 'edge', 'color');
    let opacity = parseFloat(this.retrieveConfigProp(pgEdge, 'edge', 'opacity')) || 1;
    let width = parseFloat(this.retrieveConfigProp(pgEdge, 'edge','width'));
    let tooltip  = this.retrieveConfigProp(pgEdge, 'edge', 'title');

    color = color || this.edgeColorMap[edgeLabel];

    if(opacity < 1) {
      let rgb = this.getHexColors(color);
      color = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${opacity})`;
    }
    
    let attrs = {
      id: id,
      from: pgEdge.from,
      to: pgEdge.to,
      color: color,
      label: createLabelText(pgEdge, props),
      _title: tooltip != null ? tooltip : this.createTitle(pgEdge),
      remoteId: id,
      width: width || defaultWidth,
      hoverWidth: 0.5,
      smooth: this.map ? false : { roundness: 1 },
      chosen: this.retrieveConfigProp(pgEdge, 'edge', 'chosen'),
      arrows: {
        to: {
          enabled: pgEdge.direction == '->' || pgEdge.undirected === 'false'
        },
      }
    };

    let otherProps = this.retrieveConfigPropAll(pgEdge,
      'edge', ['color', 'opacity', 'width', 'title']);

    for(let key of Object.keys(otherProps)) {
      attrs[key] = otherProps[key] || attrs[key];
    }
    
    return attrs;
  }
  
  includesNode(node) {
    return this.graph.nodes.filter(e => e.id === node.id).length > 0;
  }
  
  addNode(node, update = true) {
    this.addNodes([node], update);
  }
  
  addNodes(nodes, update = true) {
    let newNodes;
    if (typeof nodes === 'string' || nodes instanceof String) {
      let pg = this.tryPgParse(nodes);
      newNodes = pg.nodes;
    } else {
      newNodes = nodes;
    }
    newNodes = newNodes.filter(node => !this.includesNode(node)).map((node) => {
      let mapped = deepMerge(Blitzboard.nodeTemplate, node);
      ++this.maxLine;
      mapped.location = {
        start: {
          line: this.maxLine,
          column: 0,
        },
        end: {
          line: this.maxLine + 1,
          column: 0,
        }
      }
      return mapped;
    });
    this.graph.nodes = this.graph.nodes.concat(newNodes);
    for(let callback of this.onNodeAdded) {
      // TODO: The argument should be proxy instead of plain objects
      callback(newNodes);
    }
    if(update)
      this.update();
  }
  
  addEdge(edge, update = true) {
    this.addEdges([edge], update);
  }
  
  highlightNodePath(nodes) {
    let nodeIds = nodes;
    if(nodes.length > 0 && typeof nodes[0] !== 'string') {
      nodeIds = nodes.map((n) => n.id);
    }
    let edgeIds = [];
    for(let i = 0; i < nodeIds.length - 1; ++i) {
      edgeIds.push(`${nodeIds[i]}${Blitzboard.edgeDelimiter}${nodeIds[i + 1]}`);
    }
    this.network.selectEdges(edgeIds);
  }

  addEdges(edges, update = true) {
    let newEdges;
    if (typeof edges === 'string' || edges instanceof String) {
      let pg = this.tryPgParse(edges);
      newEdges = pg.edges
    } else {
      newEdges = edges
    }
    newEdges = newEdges.map((edge) => {
      let mapped = deepMerge(Blitzboard.edgeTemplate, edge);
      ++this.maxLine;
      mapped.location = {
        start: {
          line: this.maxLine,
          column: 0, 
        },
        end: {
          line: this.maxLine + 1,
          column: 0,
        }
      }
      return mapped;
    });
    this.graph.edges = this.graph.edges.concat(newEdges);
    for(let callback of this.onEdgeAdded) {
      // TODO: The argument should be proxy instead of plain objects
      callback(newEdges);
    }
    if(update)
      this.update();
  }


  tryPgParse(pg) {
    for(let callback of this.beforeParse) {
      callback();
    }
    try {
      return pgParser.parse(pg);
    } catch(e) {
      for(let callback of this.onParseError) {
        callback(e);
      }
      console.log(e);
      return null;
    }
  }

  createTitle(elem) {
    let flattend_props = Object.entries(elem.properties).reduce((acc, prop) =>
      acc.concat(`<tr valign="top"><td>${prop[0]}</td><td> ${convertToHyperLinkIfURL(prop[1])}</td></tr>`), []);
    if (!elem.from) // for nodes
    {
      let idText = `<tr><td><b>${elem.id}</b></td><td> <b>${wrapText(elem.labels.map((l) => ':' + l).join(' '), true)}</b></td></tr>`;
      flattend_props.splice(0, 0, idText);
    } else if(elem.labels.length > 0) {
      let idText = `<tr><td><b>${wrapText(elem.labels.map((l) => ':' + l).join(' '), true)} </b></td><td></td></tr>`;
      flattend_props.splice(0, 0, idText);
    }
    if (flattend_props.length === 0) {
      return null;
    }
    return `<table style='fixed'>${flattend_props.join('')}</table>`;
  }



  setGraph(input, update = true) {
    this.nodeColorMap = {};
    this.edgeColorMap = {};
    this.prevMouseEvent = null;
    this.dragging = false;
    let newPg;
    if (!input) {
      newPg = this.tryPgParse(''); // Set empty pg
    }
    else if (typeof input === 'string' || input instanceof String) {
      try {
        newPg = JSON.parse(input);
      } catch (err) {
        if (err instanceof SyntaxError)
          newPg = this.tryPgParse(input);
        else
          throw err;
      }
    } else {
      newPg = input;
    }
    if (newPg === null || newPg === undefined)
      return;
    this.graph = newPg;

    if(update)
      this.update();
  }



  setConfig(config, update = true) {
    this.config = deepMerge(Blitzboard.defaultConfig, config);
    if(config.layout === 'hierarchical') {
      // Remove redundant settings when layout is hierarchical
      this.config.layoutSettings = config.layoutSettings;
    }
    if(update)
      this.update(false);
  }
  
  validateGraph() {
    // If duplication of nodes exist, raise error 
    function nonuniqueNodes(nodes) {
      let nonunique = new Set();
      let nodeMap = {} // id -> node
      for(let node of nodes) {
        if(nodeMap[node.id]) {
          nonunique.add(nodeMap[node.id]);
          nonunique.add(node);
        }
        nodeMap[node.id] = node;
      }
      return [...nonunique];
    }

    let nonunique = nonuniqueNodes(this.graph.nodes);
    if(nonunique.length > 0) {
      throw new DuplicateNodeError(nonunique);
    }
    
    if(this.graph.nodes.length >= this.config.node.limit) {
      throw new Error(`The number of nodes exceeds the current limit: ${this.config.node.limit}. ` +
        `You can change it via node.limit in your config.`);
    }

    if(this.graph.edges.length >= this.config.edge.limit) {
      throw new Error(`The number of edges exceeds the current limit: ${this.config.edge.limit}. ` +
        `You can change it via edge.limit in your config.`);
    }

    // If edge refers to undefined nodes, create warnings
    for(let edge of this.graph.edges) {
      if(!this.nodeMap[edge.from]) {
        this.warnings.push({
          location: edge.location,
          message: `Source node is undefined: ${edge.from}`
        });
      }
      if(!this.nodeMap[edge.to]) {
        this.warnings.push({
          location: edge.location,
          message: `Target node is undefined: ${edge.to}`
        });
      }
    }
  }
  
  update(applyDiff = true) {
    let blitzboard = this;
    this.warnings = [];
    applyDiff = applyDiff && this.nodeDataSet && this.edgeDataSet;
    
    if(this.config.style && this.config.layout !== 'map') {
      this.networkContainer.style = this.networkContainerOriginalStyle + ' ' + this.config.style;
    }

    if(applyDiff) {
      let nodesToDelete = new Set(Object.keys(this.nodeMap));
      let newEdgeMap = {};

      this.nodeLineMap = {};
      this.edgeLineMap = {};
      this.maxLine = 0;
      this.graph.nodes.forEach(node => {
        let existingNode = this.nodeMap[node.id];
        if(existingNode) {
          if(!nodeEquals(node, existingNode)) {
            this.nodeDataSet.remove(existingNode);
            let visNode = this.toVisNode(node, this.config.node.caption);
            this.nodeDataSet.update(visNode);
          }
        } else {
          let visNode = this.toVisNode(node, this.config.node.caption);
          this.nodeDataSet.add(visNode);
        }
        this.nodeMap[node.id] = node;
        nodesToDelete.delete(node.id);
        if(node.location) {
          for (let i = node.location.start.line; i <= node.location.end.line; i++) {
            if (i < node.location.end.line || node.location.end.column > 1)
              this.nodeLineMap[i] = node;
          }
          this.maxLine = Math.max(this.maxLine, node.location.end.line);
        }
      });

      this.graph.edges.forEach(edge => {
        let id = this.toNodePairString(edge);
        while(newEdgeMap[id]) {
          id += '_';
        }
        edge.id = id;
        newEdgeMap[id] = edge;
        let visEdge = this.toVisEdge(edge, this.config.edge.caption, id);
        this.edgeDataSet.update(visEdge);
        if(edge.location) {
          for (let i = edge.location.start.line; i <= edge.location.end.line; i++) {
            if (i < edge.location.end.line || edge.location.end.column > 1)
              this.edgeLineMap[i] = visEdge;
          }
          this.maxLine = Math.max(this.maxLine, edge.location.end.line);
        }
      });

      nodesToDelete.forEach((nodeId) => {
        delete this.nodeMap[nodeId];
      });
      this.nodeDataSet.remove([...nodesToDelete]);

      let edgesToDelete = [];
      for(let edgeId of Object.keys(this.edgeMap)) {
        if(!newEdgeMap[edgeId]) {
          edgesToDelete.push(edgeId);
        }
      }
      this.edgeDataSet.remove(edgesToDelete);
      this.edgeMap = newEdgeMap;
      if(this.map) {
        blitzboard.updateNodeLocationOnMap();
      }
      if(this.config.layout === 'timeline') {
        blitzboard.updateNodeLocationOnTimeLine();
      }
    }
    
    this.prevZoomPosition = null;
    
    this.minTime = new Date(8640000000000000);
    this.maxTime = new Date(-8640000000000000);
    
    if(this.config.layout === 'timeline') {
      let fromProp = this.config.layoutSettings.time_from;
      let toProp = this.config.layoutSettings.time_to;
      
      this.graph.nodes.forEach(node => {
        for (let prop of Object.keys(node.properties)) {
          if (prop === fromProp || prop === toProp) {
            this.minTime = new Date(Math.min(this.minTime, new Date(node.properties[prop][0])));
            this.maxTime = new Date(Math.max(this.maxTime, new Date(node.properties[prop][0])));
          }
        }
      });
      this.timeInterval = this.maxTime - this.minTime;
    }


    if(applyDiff) {
      this.validateGraph();

      for(let callback of this.onUpdated) {
        callback();
      }
      return;
    }

    this.nodeProps = new Set(['id', 'label']);
    this.edgeProps = new Set(['label']);
    this.graph.nodes.forEach((node) => {
      this.nodeMap[node.id] = node;
      if(node.location) {
        for (let i = node.location.start.line; i <= node.location.end.line; i++)
          if (i < node.location.end.line || node.location.end.column > 1)
            this.nodeLineMap[i] = node;
      }
      Object.keys(node.properties).filter((prop) => prop != 'degree').forEach(this.nodeProps.add, this.nodeProps);
    });
    this.graph.edges.forEach((edge) => {
      Object.keys(edge.properties).forEach(this.edgeProps.add, this.edgeProps);
    });

    this.validateGraph();


    let defaultNodeProps = this.config.node.caption;
    let defaultEdgeProps = this.config.edge.caption;

    this.nodeDataSet = new visData.DataSet();
    this.nodeDataSet.add(this.graph.nodes.map((node) => {
      return this.toVisNode(node, defaultNodeProps);
    }));
    
    this.edgeMap = {};
    this.edgeDataSet = new visData.DataSet(this.graph.edges.map((edge) => {
      let id = this.toNodePairString(edge);
      while(this.edgeMap[id]) {
        id += '_';
      }
      let visEdge = this.toVisEdge(edge, defaultEdgeProps, id);
      this.edgeMap[visEdge.id] = edge;
      if(edge.location) {
        for (let i = edge.location.start.line; i <= edge.location.end.line; i++)
          if (i < edge.location.end.line || edge.location.end.column > 1)
            this.edgeLineMap[i] = visEdge;
      }

      return visEdge;
    }));



    // create a network
    let data = {
      nodes: this.nodeDataSet,
      edges: this.edgeDataSet
    };

    let layout = {
      randomSeed: 1
    };

    if(this.config.layout === 'hierarchical') {
      layout.hierarchical = this.config.layoutSettings;
    } else {
      layout.hierarchical = false;
    }

    this.options = {
      layout:
        layout,
      interaction: {
        dragNodes: this.config.layout !== 'map',
        dragView: this.config.layout !== 'map',
        zoomView: this.config.layout !== 'map',
        hover: true,
      },
      physics: {
        enabled: this.config.layout !== 'map' && this.config.layout !== 'hierarchical',
        barnesHut: {
          springConstant:  this.config.layout === 'timeline' ? 0.004 : 0.016
        },
        stabilization: {
          enabled: false,
          iterations: 200,
          updateInterval: 25
        }
      },
      manipulation: false,

      edges: {
        arrows: {
          to: {
            enabled: true,
            scaleFactor: 0.3,
            type: "arrow"
          },
        },
      },
    };

    this.options = Object.assign(this.options, this.config.extraOptions);
    this.network = new visNetwork.Network(this.networkContainer, data, this.options);

    if(this.config.layout === 'map') {
      this.mapContainer.style.display = 'block';
      this.networkContainer.style.background = 'transparent';
      let statistics = statisticsOfMap();
      let center = this.config?.layoutSettings?.center || statistics.center;
      if(this.map) {
        this.map.panTo(center);
      } else {
        this.map = L.map(this.mapContainer, {
          center: center,
          zoom: statistics.scale,
          minZoom: 3,
          zoomSnap: 0.01,
          zoomControl: false,
        });
        var tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: ' <a href="http://osm.org/copyright">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>',
        });
        tileLayer.addTo(this.map);

        this.map.on('move', () => blitzboard.updateNodeLocationOnMap());
        this.map.on('zoom', () => blitzboard.updateNodeLocationOnMap());
      }
      blitzboard.network.moveTo({scale: 1.0});
    } else {
      this.mapContainer.style.display = 'none';
      if(this.map) {
        this.map.remove();
      }
      this.map = null;
    }

    this.network.canvas.body.container.addEventListener('keydown', (e) => {
      // Key 0
      if(e.keyCode === 48)
        blitzboard.network.fit({animation: true});
    });


    this.network.on('zoom', (e) => {
      blitzboard.updateTooltipLocation();
    });

    this.network.on('resize', (e) => {
      if(blitzboard.config.layout === 'map') {
        // Fix scale to 1.0 (delay is needed to override scale set by vis-network)  
        let newScale = Math.min(Blitzboard.maxScaleOnMap, Math.max(blitzboard.network.getScale(), Blitzboard.minScaleOnMap));
        setTimeout( () => {
          blitzboard.network.moveTo({scale: newScale});
          blitzboard.updateNodeLocationOnMap();
        }, 10); 
        blitzboard.map.invalidateSize();
      }
    });
    

    this.network.on('dragStart', (e) => {
      const node = this.nodeDataSet.get(e.nodes[0]);
      if(e.nodes.length > 0) {
        this.nodeDataSet.update({
          id: e.nodes[0],
          fixed: node.fixedByTime ? {x: true, y: true } : false
        });
      }
    });
    

    function statisticsOfMap() {
      let lngKey =  blitzboard.config.layoutSettings.lng;
      let latKey =  blitzboard.config.layoutSettings.lat;
      let lngSum = 0, latSum = 0, count = 0,
        lngMax = Number.MIN_VALUE, lngMin = Number.MAX_VALUE,
        latMax = Number.MIN_VALUE, latMin = Number.MAX_VALUE;
      blitzboard.graph.nodes.forEach(node => {
        if(node.properties[latKey] && node.properties[lngKey]) {
          let lng = parseFloat(node.properties[lngKey][0]);
          let lat = parseFloat(node.properties[latKey][0]);
          lngSum += lng;
          latSum += lat;
          lngMax = Math.max(lng, lngMax);
          lngMin = Math.min(lng, lngMin);
          latMax = Math.max(lat, latMax);
          latMin = Math.min(lat, latMin);
          ++count;
        }
      });
      if(count === 0)
        return [0, 0];
      return {
        center: [latSum / count, lngSum / count],
        scale: Math.max( -Math.log2(Math.max(Math.abs(lngMax - lngMin), Math.abs(latMax - latMin)) / 1000), 0)
      };
    }

    
    this.network.on("zoom", function(){
      let pos = blitzboard.network.getViewPosition();
      if(blitzboard.config.zoom?.min && blitzboard.network.getScale() < blitzboard.config.zoom.min)
      {
        blitzboard.network.moveTo({
          position: blitzboard.prevZoomPosition,
          scale: blitzboard.config.zoom?.min
        });
      }
      else if(blitzboard.config.zoom?.max && blitzboard.network.getScale() > blitzboard.config.zoom.max){
        blitzboard.network.moveTo({
          position: blitzboard.prevZoomPosition,
          scale: blitzboard.config.zoom.max,
        });
      } else {
        blitzboard.prevZoomPosition = pos;
      }
    });
    
    if(this.map) {
      this.updateNodeLocationOnMap();
    }
    
    this.network.on("hoverNode", (e) => {
      this.network.canvas.body.container.style.cursor = 'default';
      const node = this.nodeDataSet.get(e.node);
      if(node) {
        if (node.url) {
          this.network.canvas.body.container.style.cursor = 'pointer';
          this.nodeDataSet.update({
            id: e.node,
            color: '#8888ff',
          });
        }
        if (this.config.node.onHover) {
          this.config.node.onHover(this.getNode(e.node));
        }
        
        this.elementWithTooltip = {
          node: node
        };
        this.showTooltip();
      } else if(node && node.degree > 1 && !this.expandedNodes.includes(e.node)) {
        this.network.canvas.body.container.style.cursor = 'pointer';
      }
    });

    this.network.on("hoverEdge", (e) => {
      const edge = this.edgeDataSet.get(e.edge);
      if (edge) {
        this.elementWithTooltip = {
          edge: edge,
          position: {
            x: e.event.offsetX,
            y: e.event.offsetY,
          }
        };
        this.showTooltip();
      }
    });

    this.network.on("selectNode", (e) => {
      // TODO: Should we show fixed tooltip on selection?
      // if(!this.network.getSelectedNodes().length && !this.network.getSelectedEdges().length) {
      //   const node = this.nodeDataSet.get(e.nodes[0]);
      //   if (node) {
      //     this.elementWithTooltip = {
      //       node: node
      //     };
      //     this.showTooltip();
      //   }
      // }
    });

    this.network.on("selectEdge", (e) => {
      // TODO: Should we show fixed tooltip on selection?
      // if(!this.network.getSelectedNodes().length && !this.network.getSelectedEdges().length) {
      //   const edge = this.edgeDataSet.get(e.edges[0]);
      //   if (edge) {
      //     this.elementWithTooltip = {
      //       edge: edge,
      //       position: {
      //         x: e.x,
      //         y: e.y,
      //       }
      //     };
      //     this.showTooltip();
      //   }
      // }
    });
    

    function plotTimes(startTime, interval, intervalUnit, timeForOnePixel, offsetX, offsetY, rightMostX, context, scale) {
      let currentTime = new Date(startTime);
      switch(intervalUnit) {
        case 'year':
          currentTime = new Date(currentTime.getFullYear()  - currentTime.getFullYear() % interval, 0, 1);
          break;
        case 'month':
          currentTime = new Date(currentTime.getFullYear(), currentTime.getMonth() - currentTime.getMonth() % interval, 1);
          break;
        case 'day':
          currentTime = new Date(currentTime.getFullYear(), currentTime.getMonth(), currentTime.getDate());
          break;
        default:
          return;
      }
      let i = 0;
      while(++i < 100) {
        const nextPosition = -offsetX + (currentTime - startTime) / timeForOnePixel;
        if(nextPosition > rightMostX) break;
        if(intervalUnit === 'year')
          context.fillText(currentTime.getFullYear(), nextPosition, -offsetY);
        else
          context.fillText(currentTime.toLocaleDateString(), nextPosition, -offsetY);
        context.moveTo(nextPosition, -offsetY);
        context.lineTo(nextPosition, -offsetY + 25 / scale);
        context.stroke();
        switch(intervalUnit) {
          case 'year':
            currentTime.setFullYear(currentTime.getFullYear() + interval);
            break;
          case 'month':
            currentTime.setMonth(currentTime.getMonth() + interval);
            break;
          case 'day':
            currentTime.setDate(currentTime.getDate() + interval);
            break;
          default:
            return;
        }
      }
    }
    
    this.network.on("afterDrawing", (ctx) => {
      this.updateTooltipLocation();
      for(let node of this.graph.nodes) {
        node = this.nodeDataSet.get(node.id);
        if(node && node.shape !== 'image' && (node.customIcon || this.config.node.defaultIcon)) {
          let position = this.network.getPosition(node.id);
          let pgNode = this.nodeMap[node.id];
          if(node.customIcon) {
            if(node.customIcon.name && Blitzboard.loadedIcons[node.customIcon.name]) { // Iconiy
              ctx.drawImage(Blitzboard.loadedIcons[node.customIcon.name],
                position.x - node.size * Blitzboard.iconSizeCoef / 2, position.y - node.size * Blitzboard.iconSizeCoef / 2,
                node.size * Blitzboard.iconSizeCoef, 
                node.size * Blitzboard.iconSizeCoef);
            } else { // Ionicons
              ctx.font = `${node.customIcon.size}px Ionicons`;
              ctx.fillStyle = "white";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(node.customIcon.code, position.x, position.y);
            }
          } else {
            if(!pgNode) {
              continue;
            }
            for (let label of pgNode.labels) {
              let lowerLabel = label.toLowerCase();
              if (Blitzboard.loadedIcons[lowerLabel]) {
                if(Blitzboard.loadedIcons[lowerLabel] != 'retrieving...')
                  ctx.drawImage(Blitzboard.loadedIcons[lowerLabel], position.x - node.size * Blitzboard.iconSizeCoef / 2,
                    position.y - node.size * Blitzboard.iconSizeCoef / 2,
                    node.size * Blitzboard.iconSizeCoef,
                    node.size * Blitzboard.iconSizeCoef);
                break;
              }
            }
          }
        }
      }

     if(this.config.layout === 'timeline'){
        const context = this.network.canvas.getContext("2d");
        const view = this.network.canvas.body.view;
        const offsetY = (view.translation.y - 20) / view.scale;
        const offsetX = view.translation.x / view.scale;
        const timeForOnePixel = (this.maxTime - this.minTime) / this.timeScale;
        const timeOnLeftEdge = new Date(((this.maxTime.getTime() + this.minTime.getTime()) / 2) - timeForOnePixel * offsetX);
        const clientWidth = this.network.canvas.body.container.clientWidth;
        const rightMost = -offsetX + clientWidth / view.scale;
        const oneMonth = 31 * 24 * 60 * 60 * 1000;
        const oneDay = 24 * 60 * 60 * 1000;
        const twoMonth = oneMonth * 2;
        const fourMonth = twoMonth * 2;
        const oneYear = 365 * oneDay;
        const minDistance = 200;
        context.font = (20 / view.scale).toString() + "px Arial";
        context.fillStyle = "blue";
        const minimumInterval = timeForOnePixel * minDistance / view.scale;
        if(minimumInterval > oneYear ) {
          plotTimes(timeOnLeftEdge, minimumInterval / oneYear, 'year', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        }
        else if(minimumInterval > fourMonth ) {
          plotTimes(timeOnLeftEdge, 4, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        }
        else if(minimumInterval > twoMonth) {
          plotTimes(timeOnLeftEdge, 2, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        }
        else if(minimumInterval > oneMonth) {
          plotTimes(timeOnLeftEdge, 1, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        } else if(minimumInterval > oneDay * 16) {
          plotTimes(timeOnLeftEdge, 16, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        } else if(minimumInterval > oneDay * 8) {
          plotTimes(timeOnLeftEdge, 8, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        } else if(minimumInterval > oneDay * 4) {
          plotTimes(timeOnLeftEdge, 4, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        } else if(minimumInterval > oneDay * 2) {
          plotTimes(timeOnLeftEdge, 2, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        } else {
          plotTimes(timeOnLeftEdge, 1, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);
        }
      }
    });
    this.network.on("blurNode", (params) => {
      this.network.canvas.body.container.style.cursor = 'default';
      let node = this.nodeDataSet.get(params.node);
      if(node && node.url) {
        this.nodeDataSet.update({
          id: params.node,
          color: null,
        });
      }
      this.hideTooltip();
    });

    this.network.on("blurEdge", (params) => {
      this.hideTooltip();
    });

    if (!Blitzboard.fontLoaded && document.fonts) {
      Blitzboard.fontLoaded = true;
      let blitzboard = this;
      // Decent browsers: Make sure the fonts are loaded.
      document.fonts.load('normal normal 400 24px/1 "FontAwesome"')
        .catch(
          console.error.bind(console, "Failed to load Font Awesome 4.")
        ).then(function () {
        blitzboard.network.redraw();
      })
        .catch(
          console.error.bind(
            console,
            "Failed to render the network with Font Awesome 4."
          )
        );
    }

    function clickHandler(e) {
      blitzboard.doubleClickTimer = null;
      if (e.nodes.length > 0) {
        if (blitzboard.config.node.onClick) {
          blitzboard.config.node.onClick(blitzboard.getNode(e.nodes[0]));
        }
      } else if (e.edges.length > 0) {
        if (blitzboard.config.edge.onClick) {
          blitzboard.config.edge.onClick(blitzboard.getEdge(e.edges[0]));
        }
      }
    }

    this.network.on("click", (e) => {
      if(!this.doubleClickTimer) {
        if (this.config.doubleClickWait <= 0) {
          clickHandler(e);
        } else {
          this.doubleClickTimer = setTimeout(() => clickHandler(e), this.config.doubleClickWait);
        }
      }
    });

    
    this.network.on("doubleClick", (e) => {
      clearTimeout(this.doubleClickTimer);
      this.doubleClickTimer = null;
      if(e.nodes.length > 0) {
        if(this.config.node.onDoubleClick) {
          this.config.node.onDoubleClick(this.getNode(e.nodes[0]));
        }
      } else if(e.edges.length > 0) {
        if(this.config.edge.onDoubleClick) {
          this.config.edge.onDoubleClick(this.getEdge(e.edges[0]));
        }
      } else {
        blitzboard.network.fit({animation: true});
      }
    });

    for(let callback of this.onUpdated) {
      callback();
    }
  }


  scrollNodeIntoView(node, select = true) {
    if(typeof(node) === 'string')
      node = this.nodeMap[node];
    if(!node)
      return;

    if(this.config.layout === 'map') {
      this.scrollMapToNode(this.nodeMap[node.id]);
    } else {
      this.scrollNetworkToPosition(this.network.getPosition(node.id));
    }
    if(select)
      this.network.selectNodes([node.id]);

    for(let callback of this.onNodeFocused) {
      // TODO: The argument should be proxy instead of plain objects
      callback(node);
    }
  }
  
  scrollNetworkToPosition(position) {
    clearTimeout(this.scrollAnimationTimerId);
    this.scrollAnimationTimerId = setTimeout(() => {
      const animationOption = {
        scale: 1.0,
        animation:
          {
            duration: 500,
            easingFuntcion: "easeInOutQuad"
          }
      };
      this.network.moveTo({ ...{position: position}, ...animationOption });
    }, 200); // Set delay to avoid calling moveTo() too much (seem to cause some bug on animation)
  }
  
  updateNodeLocationOnMap() {
    let nodePositions = [];
    let lngKey =  this.config.layoutSettings.lng;
    let latKey =  this.config.layoutSettings.lat;
    this.graph.nodes.forEach(node => {
      if(node.properties[latKey] && node.properties[lngKey]) {
        let point = this.map.latLngToContainerPoint([node.properties[latKey][0], node.properties[lngKey][0]]);
        point = this.network.DOMtoCanvas(point);
        nodePositions.push({
          id: node.id,
          x: point.x, y: point.y, fixed: true
        });
      }
    });
    this.nodeDataSet.update(nodePositions);
  }


  updateNodeLocationOnTimeLine() {
    let nodePositions = [];
    this.graph.nodes.forEach(node => {
      let x, y, fixed, width;
      ({x, y, fixed, width} = this.calcNodePosition(node));
      nodePositions.push({
        id: node.id,
        x, y
      });
    });
    this.nodeDataSet.update(nodePositions);
  }
  
  scrollMapToNode(node) {
    let lngKey = this.config.layoutSettings.lng;
    let latKey = this.config.layoutSettings.lat;
    this.map.panTo([node.properties[latKey][0] ,node.properties[lngKey][0]]);
  }
  
  scrollEdgeIntoView(edge, select = true) {
    if(typeof(edge) === 'string') {
      edge = this.edgeMap[edge];
    }

    if(this.config.layout === 'map') {
      this.scrollMapToNode(this.nodeMap[edge.from]);
    } else {
      const from = this.network.getPosition(edge.from);
      const to = this.network.getPosition(edge.to);
      this.scrollNetworkToPosition({ x: (from.x + to.x) / 2, y: (from.y + to.y) /2 });
    }
    if(select) {
      this.network.selectEdges([edge.id]);
    }

    for(let callback of this.onEdgeFocused) {
      // TODO: The argument should be proxy instead of plain objects
      callback(edge);
    }
  }
  
  showLoader(text = "Now loading...") {
    this.screen.style.display = 'flex';
    this.screenText.innerText = text;
    this.screenText.style.display = text ? 'block' : 'none';
  }
  
  hideLoader() {
    this.screen.style.display = 'none';
  }

  toNodePairString(pgEdge) {
    return `${pgEdge.from}${Blitzboard.edgeDelimiter}${pgEdge.to}`;
  }
}



function arrayEquals(a, b) {
  return Array.isArray(a) &&
    Array.isArray(b) &&
    a.length === b.length &&
    a.every((val, index) => val === b[index]);
}

function nodeEquals(node1, node2) {
  if(node1.id != node2.id || !arrayEquals(node1.labels, node2.labels)) {
    return false;
  }
  let node1Keys = Object.keys(node1.properties);
  let node2Keys = Object.keys(node2.properties);
  if(node1Keys.length != node2Keys.length) {
    return false;
  }
  for(let key of node1Keys) {
    if(!arrayEquals(node1.properties[key], node2.properties[key]))
      return false;
  }
  return true;
}


class DuplicateNodeError extends Error {
  constructor(nodes) {
    super(`Duplicate node: ${nodes.map(n => n.id).join(', ')}`);
    this.name = "NodeDuplicationError";
    this.nodes = nodes;
  }
}

module.exports.DuplicateNodeError = DuplicateNodeError;


function deepMerge(target, source) {
  const isObject = obj => obj && typeof obj === 'object' && !Array.isArray(obj);
  let result = Object.assign({}, target);
  if (isObject(target) && isObject(source)) {
    for (const [sourceKey, sourceValue] of Object.entries(source)) {
      const targetValue = target[sourceKey];
      if (isObject(sourceValue) && target.hasOwnProperty(sourceKey)) {
        result[sourceKey] = deepMerge(targetValue, sourceValue);
      }
      else {
        Object.assign(result, {[sourceKey]: sourceValue});
      }
    }
  }
  return result;
}

function retrieveHttpUrl(node) {
  let candidates = [];
  for(let entry of Object.entries(node.properties)) {
    for(let prop of entry[1]) {
      if(typeof(prop) === 'string' && (prop.startsWith("https://") || prop.startsWith("http://"))) {
        if(entry[0].toLowerCase() == 'url')
          return prop;
        candidates.push([entry[0], prop]);
      }
    }
  }
  return candidates[0];
}




function wrapText(str, asHtml) {
  if(!str)
    return str;
  if(Array.isArray(str))
    str = str[0];
  const maxWidth = 40;
  let newLineStr = asHtml ? "<br>" : "\n", res = '';
  while (str.length > maxWidth) {
    res += str.slice(0, maxWidth) + newLineStr;
    str = str.slice(maxWidth);
  }
  return res + str;
}

function createLabelText(elem, props = null) {
  if (props != null) {
    // Use whitespace instead of empty string if no props are specified because Vis.js cannot update label with empty string)
    return props.length ? props.map((prop) => prop === 'id' ? elem.id : (prop === 'label' ? elem.labels : wrapText(elem.properties[prop]))).filter((val) => val).join('\n') : ' ';
  }
}

function convertToHyperLinkIfURL(text) {
  if(!text)
    return text;
  if(Array.isArray(text))
    text = text[0];
  if(text.startsWith('http://') || text.startsWith('https://') ) {
    return `<a target="_blank" href="${text}">${wrapText(text)}</a>`;
  }
  return wrapText(text);
}

// Create random colors, with str as seed, and with fixed saturation and lightness
function getRandomColor(str, saturation, brightness) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
    hash = hash & hash;
  }
  let hue = hash % 360;
  return 'hsl(' + hue + `, ${saturation}, ${brightness})`;
}

function isDateString(str) {
  return isNaN(str) && !isNaN(Date.parse(str))
}

function htmlTitle(html) {
  const container = document.createElement("div");
  container.innerHTML = html;
  return container;
}


/***/ }),

/***/ "./src/pg_parser_browserified.js":
/*!***************************************!*\
  !*** ./src/pg_parser_browserified.js ***!
  \***************************************/
/***/ (() => {

(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */

"use strict";

function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { PG: peg$parsePG },
      peg$startRuleFunction  = peg$parsePG,

      peg$c0 = function(lines) {
        return {
          nodes: lines.map(l => l.node).filter(v => v),
          edges: lines.map(l => l.edge).filter(v => v),
          nodeCount: nodeCount,
          edgeCount: edgeCount,
          nodeLabels: nodeLabelHash,
          edgeLabels: edgeLabelHash,
          nodeProperties: nodePropHash,
          edgeProperties: edgePropHash
        }
      },
      peg$c1 = function(n) {
        return {
          node: n
        }
      },
      peg$c2 = function(e) {
        return {
          edge: e
        }
      },
      peg$c3 = function(id, l, p) {
        let propObj = {};
        p.forEach(prop => {
          if (propObj[prop.key]) {
            propObj[prop.key].push(prop.value);
          } else {
            propObj[prop.key] = [prop.value];
          }
          // nodePropHash[prop.key] = true;
          if (nodePropHash[prop.key]) {
            nodePropHash[prop.key]++;
          } else {
            nodePropHash[prop.key] = 1;
          }
        });

        nodeCount++;

        l.forEach(label => {
          if (nodeLabelHash[label]) {
            nodeLabelHash[label]++;
          } else {
            nodeLabelHash[label] = 1;
          }
        });

        return {
          id: id,
          location: location(),
          labels: l,
          properties: propObj
        }
      },
      peg$c4 = function(f, d, t, l, p) {
        let propObj = {};
        p.forEach(prop => {
          if (propObj[prop.key]) {
            propObj[prop.key].push(prop.value);
          } else {
            propObj[prop.key] = [prop.value];
          }
          // edgePropHash[prop.key] = true;
          if (edgePropHash[prop.key]) {
            edgePropHash[prop.key]++;
          } else {
            edgePropHash[prop.key] = 1;
          }
        });

        edgeCount++;

        l.forEach(label => {
          if (edgeLabelHash[label]) {
            edgeLabelHash[label]++;
          } else {
            edgeLabelHash[label] = 1;
          }
        });

        return {
          from: f,
          to: t,
          location: location(),
          direction: d,
          labels: l,
          properties: propObj
        }
      },
      peg$c5 = ":",
      peg$c6 = peg$literalExpectation(":", false),
      peg$c7 = function(l) {
        return l
      },
      peg$c8 = function(k, v) {
        return {
          key: k,
          value: v
        }
      },
      peg$c9 = "--",
      peg$c10 = peg$literalExpectation("--", false),
      peg$c11 = "->",
      peg$c12 = peg$literalExpectation("->", false),
      peg$c13 = "-",
      peg$c14 = peg$literalExpectation("-", false),
      peg$c15 = ".",
      peg$c16 = peg$literalExpectation(".", false),
      peg$c17 = /^[0-9]/,
      peg$c18 = peg$classExpectation([["0", "9"]], false, false),
      peg$c19 = "0",
      peg$c20 = peg$literalExpectation("0", false),
      peg$c21 = /^[1-9]/,
      peg$c22 = peg$classExpectation([["1", "9"]], false, false),
      peg$c23 = /^[eE]/,
      peg$c24 = peg$classExpectation(["e", "E"], false, false),
      peg$c25 = "+",
      peg$c26 = peg$literalExpectation("+", false),
      peg$c27 = "'",
      peg$c28 = peg$literalExpectation("'", false),
      peg$c29 = "\"",
      peg$c30 = peg$literalExpectation("\"", false),
      peg$c31 = "\\",
      peg$c32 = peg$literalExpectation("\\", false),
      peg$c33 = "b",
      peg$c34 = peg$literalExpectation("b", false),
      peg$c35 = function() {
        return "\b";
      },
      peg$c36 = "f",
      peg$c37 = peg$literalExpectation("f", false),
      peg$c38 = function() {
        return "\f";
      },
      peg$c39 = "n",
      peg$c40 = peg$literalExpectation("n", false),
      peg$c41 = function() {
        return "\n";
      },
      peg$c42 = "r",
      peg$c43 = peg$literalExpectation("r", false),
      peg$c44 = function() {
        return "\r";
      },
      peg$c45 = "t",
      peg$c46 = peg$literalExpectation("t", false),
      peg$c47 = function() {
        return "\t";
      },
      peg$c48 = "v",
      peg$c49 = peg$literalExpectation("v", false),
      peg$c50 = function() {
        return "\x0B";
      },
      peg$c51 = peg$anyExpectation(),
      peg$c52 = function(char) {
        return char;
      },
      peg$c53 = function(esc) {
        return esc;
      },
      peg$c54 = function() {
        return text();
      },
      peg$c55 = function(chars) {
        return chars.join('');
      },
      peg$c56 = function(chars) { 
        return chars.join('');
      },
      peg$c57 = /^[ \t]/,
      peg$c58 = peg$classExpectation([" ", "\t"], false, false),
      peg$c59 = /^[: \t\r\n]/,
      peg$c60 = peg$classExpectation([":", " ", "\t", "\r", "\n"], false, false),
      peg$c61 = /^[^: \t\r\n]/,
      peg$c62 = peg$classExpectation([":", " ", "\t", "\r", "\n"], true, false),
      peg$c63 = /^[\r\n]/,
      peg$c64 = peg$classExpectation(["\r", "\n"], false, false),
      peg$c65 = /^[^\r\n]/,
      peg$c66 = peg$classExpectation(["\r", "\n"], true, false),

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parsePG() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseNodeOrEdge();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseNodeOrEdge();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseEOF();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c0(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseNodeOrEdge() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseNode();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c1(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseEdge();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$parseEmptyLine();
      }
    }

    return s0;
  }

  function peg$parseNode() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseKey();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseLabel();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseLabel();
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseProperty();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseProperty();
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseWS();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseWS();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseEndOfLine();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c3(s1, s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEdge() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    s0 = peg$currPos;
    s1 = peg$parseKey();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseWS();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseWS();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseDirection();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseWS();
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseWS();
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseKey();
            if (s5 !== peg$FAILED) {
              s6 = [];
              s7 = peg$parseLabel();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parseLabel();
              }
              if (s6 !== peg$FAILED) {
                s7 = [];
                s8 = peg$parseProperty();
                while (s8 !== peg$FAILED) {
                  s7.push(s8);
                  s8 = peg$parseProperty();
                }
                if (s7 !== peg$FAILED) {
                  s8 = [];
                  s9 = peg$parseWS();
                  while (s9 !== peg$FAILED) {
                    s8.push(s9);
                    s9 = peg$parseWS();
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseEndOfLine();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c4(s1, s3, s5, s6, s7);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseLabel() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseDelimiter();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseDelimiter();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 58) {
        s2 = peg$c5;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c6); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseWS();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseWS();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseKey();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c7(s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseProperty() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseDelimiter();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseDelimiter();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseKey();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseWS();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseWS();
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c5;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c6); }
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseWS();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseWS();
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseValue();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c8(s2, s6);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDirection() {
    var s0;

    if (input.substr(peg$currPos, 2) === peg$c9) {
      s0 = peg$c9;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c10); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c11) {
        s0 = peg$c11;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c12); }
      }
    }

    return s0;
  }

  function peg$parseNumber() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s1 = peg$c13;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c14); }
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseInteger();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s4 = peg$c15;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c16); }
        }
        if (s4 !== peg$FAILED) {
          s5 = [];
          if (peg$c17.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
          if (s6 !== peg$FAILED) {
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              if (peg$c17.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c18); }
              }
            }
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseExp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s1 = [s1, s2, s3, s4];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseInteger() {
    var s0, s1, s2, s3;

    if (input.charCodeAt(peg$currPos) === 48) {
      s0 = peg$c19;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c20); }
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (peg$c21.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c22); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c17.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c18); }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c17.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseExp() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    if (peg$c23.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c24); }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c13;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c14); }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 43) {
          s2 = peg$c25;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c26); }
        }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        if (peg$c17.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c18); }
        }
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (peg$c17.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c18); }
            }
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEscapedChar() {
    var s0, s1;

    if (input.charCodeAt(peg$currPos) === 39) {
      s0 = peg$c27;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c28); }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 34) {
        s0 = peg$c29;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c30); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 92) {
          s0 = peg$c31;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c32); }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 98) {
            s1 = peg$c33;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c35();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 102) {
              s1 = peg$c36;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c37); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c38();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 110) {
                s1 = peg$c39;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c40); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c41();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 114) {
                  s1 = peg$c42;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c43); }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c44();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 116) {
                    s1 = peg$c45;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c46); }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c47();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 118) {
                      s1 = peg$c48;
                      peg$currPos++;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c49); }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c50();
                    }
                    s0 = s1;
                  }
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseDoubleQuotedChar() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    if (input.charCodeAt(peg$currPos) === 34) {
      s2 = peg$c29;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c30); }
    }
    if (s2 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 92) {
        s2 = peg$c31;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
    }
    peg$silentFails--;
    if (s2 === peg$FAILED) {
      s1 = void 0;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c52(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s1 = peg$c31;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseEscapedChar();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c53(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseSingleQuotedChar() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    if (input.charCodeAt(peg$currPos) === 39) {
      s2 = peg$c27;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c28); }
    }
    if (s2 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 92) {
        s2 = peg$c31;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
    }
    peg$silentFails--;
    if (s2 === peg$FAILED) {
      s1 = void 0;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c52(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s1 = peg$c31;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseEscapedChar();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c53(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseKey() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseNumber();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseSPECIAL_CHAR();
      peg$silentFails--;
      if (s3 !== peg$FAILED) {
        peg$currPos = s2;
        s2 = void 0;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c54();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c29;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c30); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseDoubleQuotedChar();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseDoubleQuotedChar();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c29;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c30); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c55(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c27;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseSingleQuotedChar();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseSingleQuotedChar();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c27;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c28); }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c56(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseNON_SPECIAL_CHAR();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseNON_SPECIAL_CHAR();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c55(s1);
          }
          s0 = s1;
        }
      }
    }

    return s0;
  }

  function peg$parseValue() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c29;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c30); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseDoubleQuotedChar();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseDoubleQuotedChar();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s3 = peg$c29;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c30); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c55(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        s1 = peg$c27;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseSingleQuotedChar();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseSingleQuotedChar();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c27;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c28); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c56(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseNON_SPECIAL_CHAR();
        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c5;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c6); }
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseNON_SPECIAL_CHAR();
            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s2 = peg$c5;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c6); }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c55(s1);
        }
        s0 = s1;
      }
    }

    return s0;
  }

  function peg$parseWS() {
    var s0;

    if (peg$c57.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c58); }
    }

    return s0;
  }

  function peg$parseSPECIAL_CHAR() {
    var s0;

    if (peg$c59.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c60); }
    }

    return s0;
  }

  function peg$parseNON_SPECIAL_CHAR() {
    var s0;

    if (peg$c61.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c62); }
    }

    return s0;
  }

  function peg$parseNEWLINE() {
    var s0;

    if (peg$c63.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c64); }
    }

    return s0;
  }

  function peg$parseNON_NEWLINE() {
    var s0;

    if (peg$c65.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c66); }
    }

    return s0;
  }

  function peg$parseEOF() {
    var s0, s1;

    s0 = peg$currPos;
    peg$silentFails++;
    if (input.length > peg$currPos) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c51); }
    }
    peg$silentFails--;
    if (s1 === peg$FAILED) {
      s0 = void 0;
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEndOfLine() {
    var s0;

    s0 = peg$parseEOF();
    if (s0 === peg$FAILED) {
      s0 = peg$parseNEWLINE();
    }

    return s0;
  }

  function peg$parseDelimiter() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseWS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseWS();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseNEWLINE();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseWS();
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseWS();
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = [];
      s1 = peg$parseWS();
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parseWS();
        }
      } else {
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseEmptyLine() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseWS();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseWS();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseEOF();
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseWS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseWS();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNEWLINE();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }


    let nodeCount = 0;
    let edgeCount = 0;
    let nodeLabelHash = {};
    let edgeLabelHash = {};
    let nodePropHash = {};
    let edgePropHash = {};


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};

},{}],2:[function(require,module,exports){
pgParser = require('./pg_parser.js');

let coreParse = pgParser.parse;
function removeComment(text) {
  return text.replace(/^((("[^"\\]*(\\.[^"\\]*)*")|[^#"])*)(#.*)$/gm, '$1');
}
pgParser.parse = (text) => coreParse(removeComment(text));

},{"./pg_parser.js":1}]},{},[2]);


/***/ }),

/***/ "./node_modules/leaflet/dist/images/layers-2x.png":
/*!********************************************************!*\
  !*** ./node_modules/leaflet/dist/images/layers-2x.png ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "8f2c4d11474275fbc161.png";

/***/ }),

/***/ "./node_modules/leaflet/dist/images/layers.png":
/*!*****************************************************!*\
  !*** ./node_modules/leaflet/dist/images/layers.png ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "416d91365b44e4b4f477.png";

/***/ }),

/***/ "./node_modules/leaflet/dist/images/marker-icon.png":
/*!**********************************************************!*\
  !*** ./node_modules/leaflet/dist/images/marker-icon.png ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "2b3e1faf89f94a483539.png";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/blitzboard.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxVQUFVLFVBQVUsWUFBWSxhQUFhLFdBQVcsS0FBSyxZQUFZLE1BQU0sWUFBWSxPQUFPLHVCQUF1Qix1QkFBdUIsdUJBQXVCLHVCQUF1Qix1QkFBdUIsdUJBQXVCLHdCQUF3Qix1QkFBdUIsd0JBQXdCLE1BQU0sVUFBVSxVQUFVLEtBQUssS0FBSyxZQUFZLGFBQWEsYUFBYSxRQUFRLGFBQWEsTUFBTSxZQUFZLFdBQVcsd0JBQXdCLGFBQWEsTUFBTSxNQUFNLFlBQVksV0FBVyxZQUFZLE1BQU0sS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksUUFBUSxhQUFhLE1BQU0sWUFBWSxNQUFNLEtBQUssVUFBVSxZQUFZLGFBQWEsYUFBYSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssWUFBWSxhQUFhLGFBQWEsTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLE1BQU0sTUFBTSxZQUFZLGFBQWEsYUFBYSxPQUFPLEtBQUssWUFBWSxRQUFRLFdBQVcsS0FBSyxVQUFVLEtBQUssS0FBSyxZQUFZLGFBQWEsYUFBYSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sVUFBVSxLQUFLLE9BQU8sVUFBVSxZQUFZLGFBQWEsYUFBYSxPQUFPLFlBQVksVUFBVSxZQUFZLE9BQU8sUUFBUSx3QkFBd0IsYUFBYSxPQUFPLGFBQWEsTUFBTSxZQUFZLFdBQVcsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksYUFBYSxRQUFRLFlBQVksTUFBTSxZQUFZLFFBQVEsYUFBYSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sWUFBWSxhQUFhLFdBQVcsVUFBVSxZQUFZLFdBQVcsWUFBWSxhQUFhLFdBQVcsS0FBSyxNQUFNLFlBQVksYUFBYSxXQUFXLEtBQUssS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLGFBQWEsTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLE1BQU0sS0FBSyxVQUFVLFlBQVksV0FBVyxNQUFNLEtBQUssVUFBVSxVQUFVLFlBQVksTUFBTSxLQUFLLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxhQUFhLE9BQU8sYUFBYSxPQUFPLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxPQUFPLGFBQWEsTUFBTSxZQUFZLGFBQWEsYUFBYSxNQUFNLEtBQUssWUFBWSxXQUFXLFVBQVUsS0FBSyxLQUFLLFlBQVksYUFBYSxNQUFNLEtBQUssVUFBVSxVQUFVLEtBQUssTUFBTSxVQUFVLEtBQUssS0FBSyxVQUFVLFlBQVksTUFBTSxLQUFLLFlBQVksV0FBVyxZQUFZLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxNQUFNLEtBQUssVUFBVSxZQUFZLFdBQVcsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFVBQVUsWUFBWSxhQUFhLE9BQU8sWUFBWSxNQUFNLFlBQVksUUFBUSxhQUFhLE1BQU0sWUFBWSxhQUFhLFdBQVcsS0FBSyxNQUFNLFVBQVUsVUFBVSxLQUFLLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLE1BQU0sVUFBVSxLQUFLLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxhQUFhLGFBQWEsYUFBYSxXQUFXLFlBQVksYUFBYSxhQUFhLGNBQWMsYUFBYSxhQUFhLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxNQUFNLEtBQUssWUFBWSxPQUFPLE9BQU8sWUFBWSxNQUFNLE1BQU0sWUFBWSxhQUFhLFFBQVEsV0FBVyxLQUFLLFlBQVksYUFBYSxhQUFhLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxhQUFhLE1BQU0sS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsWUFBWSxXQUFXLFlBQVksYUFBYSxhQUFhLE1BQU0sS0FBSyxVQUFVLFVBQVUsV0FBVyxhQUFhLGFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUJBQXlCLE9BQU8sc0NBQXNDO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5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QUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUNBQXVDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdUNBQXVDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2RkFBNkYsZ0JBQWdCO0FBQzdHO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnR0FBZ0csZ0JBQWdCO0FBQ2hIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw2QkFBNkI7QUFDaEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsWUFBWTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCO0FBQ3BELDBCQUEwQixxREFBcUQ7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQywyQ0FBMkMsYUFBYTtBQUN4RCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLGlFQUFpRSxZQUFZO0FBQzdFO0FBQ0EsTUFBTSxjQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUIsc0JBQXNCLElBQUk7QUFDdkUsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLGtHQUFrRztBQUNsRywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsd0JBQXdCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkNBQTZDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixlQUFlOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJDQUEyQztBQUN2RSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsMkNBQTJDO0FBQ3ZFLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDs7QUFFeEQ7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDs7QUFFQSxpREFBaUQsVUFBVTtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0Isc0JBQXNCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUIsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGLDhCQUE4Qjs7QUFFOUIsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7O0FBRWxELCtDQUErQyxTQUFTOztBQUV4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0EsZUFBZTs7QUFFZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsc0JBQXNCLGVBQWU7QUFDckMsdUJBQXVCLGVBQWU7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsOEJBQThCO0FB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QUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFFBQVEsV0FBVztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7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Q0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsK0VBQStFOztBQUUvRTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsZ0JBQWdCOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsZ0JBQWdCOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQyx5Q0FBeUMsdUJBQXVCO0FBQ2hFLG9DQUFvQyx1QkFBdUI7QUFDM0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGtEQUFrRDs7QUFFbEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0EsNkNBQTZDOztBQUU3Qzs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLG9CQUFvQjs7QUFFcEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLHFGQUFxRjs7QUFFckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLElBQUk7QUFDSjtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0RBQStELDBCQUEwQjtBQUN6Rjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzl2YkEsTUFBcUY7QUFDckYsTUFBMkU7QUFDM0UsTUFBa0Y7QUFDbEYsTUFBcUc7QUFDckcsTUFBOEY7QUFDOUYsTUFBOEY7QUFDOUYsTUFBMkY7QUFDM0Y7QUFD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Q3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG1CQUFtQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxzQkFBc0IsbUJBQW1COztBQUUxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1Qix5Q0FBeUM7QUFDekMsUUFBUSxZQUFZLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEZBQTRGOzs7QUFHNUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLCtFQUErRTs7QUFFL0U7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCOztBQUUvQixvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0EsR0FBRztBQUNILHVEQUF1RCwwREFBMEQ7QUFDakg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7O0FBRUEseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlCQUF5QixvQkFBb0I7OztBQUduRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1IQUFtSDtBQUNuSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSx1Q0FBdUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsR0FBRztBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyxHQUFHO0FBQ1I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxhQUFhO0FBQ2hCO0FBQ0E7O0FBRUEsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUzs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7O0FBRTdFOztBQUVBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsU0FBUzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7OztBQUdBOztBQUVBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCLFlBQVk7QUFDN0I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUIsWUFBWTtBQUM3Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCLFlBQVk7QUFDN0I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUIsWUFBWTtBQUM3Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FB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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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O0FBRUE7QUFDQTs7QUFFQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7QUFHQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFD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VztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRzs7QUFFaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZEQUE2RCxxRkFBcUYsV0FBVyxzSEFBc0gsZ0JBQWdCLFdBQVcseUJBQXlCLFNBQVMsd0JBQXdCLDRCQUE0QixjQUFjLFNBQVMsK0JBQStCLHNCQUFzQixXQUFXLFlBQVksZ0tBQWdLLGtEQUFrRCxTQUFTLGtCQUFrQixrQkFBa0Isb0JBQW9CLHNCQUFzQiw4QkFBOEIsY0FBYyx1QkFBdUIsZUFBZSxZQUFZLG9CQUFvQixNQUFNLDJEQUEyRCxVQUFVOztBQUU3OEIsc0RBQXNELGdCQUFnQixnQkFBZ0Isa0VBQWtFLHVGQUF1Riw2REFBNkQsa0RBQWtEOztBQUU5ViwyQ0FBMkMsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sb0JBQW9COztBQUU3Szs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FB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QSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHLHdCQUF3QjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxXQUFXO0FBQ2pELHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0JBQW9COztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU8sSUFBSSxPQUFPLElBQUksT0FBTyxJQUFJLFFBQVE7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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S0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CO0FBQ3hELFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLElBQUksbUJBQW1CLHNCQUFzQjtBQUN6RSxLQUFLLFFBQVE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EscUNBQXFDLCtDQUErQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFlBQVksRUFBRSx5QkFBeUIsRUFBRSxVQUFVO0FBQ2pFO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7OztBQUdqQztBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlCQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSyxJQUFJLGVBQWU7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVyxJQUFJLFdBQVc7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNXVEQSxZQUFZLGtCQUFrQixnQkFBZ0IsVUFBVSxVQUFVLE1BQU0sU0FBbUMsQ0FBQyxnQkFBZ0IsT0FBQyxPQUFPLG9CQUFvQiw4Q0FBOEMsa0NBQWtDLFlBQVksWUFBWSxtQ0FBbUMsaUJBQWlCLGVBQWUsc0JBQXNCLG9CQUFvQixVQUFVLFNBQW1DLEtBQUssV0FBVyxZQUFZLFNBQVMsU0FBUyxLQUFLO0FBQzdjO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiw4QkFBOEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDBCQUEwQjtBQUNqRix1REFBdUQsMEJBQTBCO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDBCQUEwQjtBQUNqRix1REFBdUQsMEJBQTBCO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCLGlDQUFpQyxpQkFBaUI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsbUJBQW1CLEVBQUUsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztVQzd4RDNCO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7Ozs7V0N6QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGlDQUFpQyxXQUFXO1dBQzVDO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0EsQ0FBQzs7Ozs7V0NQRDs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7O1dDTkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7O1dDZkE7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBOztXQUVBOztXQUVBOztXQUVBOztXQUVBOztXQUVBOztXQUVBOzs7OztXQ3JCQTs7Ozs7VUVBQTtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0JsaXR6Ym9hcmQvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL0JsaXR6Ym9hcmQvLi9ub2RlX21vZHVsZXMvQGljb25pZnkvaWNvbmlmeS9kaXN0L2ljb25pZnkubWluLmpzIiwid2VicGFjazovL0JsaXR6Ym9hcmQvLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzIiwid2VicGFjazovL0JsaXR6Ym9hcmQvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL0JsaXR6Ym9hcmQvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzIiwid2VicGFjazovL0JsaXR6Ym9hcmQvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly9CbGl0emJvYXJkLy4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9sZWFmbGV0LXNyYy5qcyIsIndlYnBhY2s6Ly9CbGl0emJvYXJkLy4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9sZWFmbGV0LmNzcz9iOWEzIiwid2VicGFjazovL0JsaXR6Ym9hcmQvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly9CbGl0emJvYXJkLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL0JsaXR6Ym9hcmQvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly9CbGl0emJvYXJkLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC8uL25vZGVfbW9kdWxlcy92aXMtZGF0YS9wZWVyL3VtZC92aXMtZGF0YS5qcyIsIndlYnBhY2s6Ly9CbGl0emJvYXJkLy4vbm9kZV9tb2R1bGVzL3Zpcy1kYXRhL3BlZXIvdW1kL3Zpcy1kYXRhLm1pbi5qcyIsIndlYnBhY2s6Ly9CbGl0emJvYXJkLy4vbm9kZV9tb2R1bGVzL3Zpcy1uZXR3b3JrL3BlZXIvdW1kL3Zpcy1uZXR3b3JrLm1pbi5qcyIsIndlYnBhY2s6Ly9CbGl0emJvYXJkLy4vc3JjL2JsaXR6Ym9hcmQuanMiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC8uL3NyYy9wZ19wYXJzZXJfYnJvd3NlcmlmaWVkLmpzIiwid2VicGFjazovL0JsaXR6Ym9hcmQvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9CbGl0emJvYXJkL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9CbGl0emJvYXJkL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL0JsaXR6Ym9hcmQvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9CbGl0emJvYXJkL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL0JsaXR6Ym9hcmQvd2VicGFjay9ydW50aW1lL2pzb25wIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC93ZWJwYWNrL3J1bnRpbWUvbm9uY2UiLCJ3ZWJwYWNrOi8vQmxpdHpib2FyZC93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL0JsaXR6Ym9hcmQvd2VicGFjay9zdGFydHVwIiwid2VicGFjazovL0JsaXR6Ym9hcmQvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkJsaXR6Ym9hcmRcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiQmxpdHpib2FyZFwiXSA9IGZhY3RvcnkoKTtcbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAiLCIvKipcbiogKGMpIEljb25pZnlcbipcbiogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIGxpY2Vuc2UudHh0IG9yIGxpY2Vuc2UuZ3BsLnR4dFxuKiBmaWxlcyBhdCBodHRwczovL2dpdGh1Yi5jb20vaWNvbmlmeS9pY29uaWZ5XG4qXG4qIExpY2Vuc2VkIHVuZGVyIEFwYWNoZSAyLjAgb3IgR1BMIDIuMCBhdCB5b3VyIG9wdGlvbi5cbiogSWYgZGVyaXZhdGl2ZSBwcm9kdWN0IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggb25lIG9mIGxpY2Vuc2VzLCB5b3UgY2FuIHBpY2sgb25lIG9mIGxpY2Vuc2VzLlxuKlxuKiBAbGljZW5zZSBBcGFjaGUgMi4wXG4qIEBsaWNlbnNlIEdQTCAyLjBcbiovXG52YXIgSWNvbmlmeT1mdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUoZSxuLHQpe3JldHVybiBlKHQ9e3BhdGg6bixleHBvcnRzOnt9LHJlcXVpcmU6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJEeW5hbWljIHJlcXVpcmVzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSBAcm9sbHVwL3BsdWdpbi1jb21tb25qc1wiKX0obnVsbD09biYmdC5wYXRoKX19LHQuZXhwb3J0cyksdC5leHBvcnRzfXZhciBuPWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5mdWxsSWNvbj1uLmljb25EZWZhdWx0cz1uLm1pbmlmeVByb3BzPW4ubWF0Y2hOYW1lPXZvaWQgMCxuLm1hdGNoTmFtZT0vXlthLXowLTldKygtW2EtejAtOV0rKSokLyxuLm1pbmlmeVByb3BzPVtcIndpZHRoXCIsXCJoZWlnaHRcIixcInRvcFwiLFwibGVmdFwiXSxuLmljb25EZWZhdWx0cz1PYmplY3QuZnJlZXplKHtsZWZ0OjAsdG9wOjAsd2lkdGg6MTYsaGVpZ2h0OjE2LHJvdGF0ZTowLHZGbGlwOiExLGhGbGlwOiExfSksbi5mdWxsSWNvbj1mdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxuLmljb25EZWZhdWx0cyxlKX19KSksdD1lKChmdW5jdGlvbihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQubWVyZ2VJY29uRGF0YT12b2lkIDAsdC5tZXJnZUljb25EYXRhPWZ1bmN0aW9uKGUsdCl7dmFyIHI9T2JqZWN0LmFzc2lnbih7fSxlKTtmb3IodmFyIG8gaW4gbi5pY29uRGVmYXVsdHMpe3ZhciBpPW87aWYodm9pZCAwIT09dFtpXSl7dmFyIGE9dFtpXTtpZih2b2lkIDA9PT1yW2ldKXtyW2ldPWE7Y29udGludWV9c3dpdGNoKGkpe2Nhc2VcInJvdGF0ZVwiOnJbaV09KHJbaV0rYSklNDticmVhaztjYXNlXCJoRmxpcFwiOmNhc2VcInZGbGlwXCI6cltpXT1hIT09cltpXTticmVhaztkZWZhdWx0OnJbaV09YX19fXJldHVybiByfX0pKSxyPWUoKGZ1bmN0aW9uKGUscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksci5wYXJzZUljb25TZXQ9dm9pZCAwO3ZhciBvPU9iamVjdC5rZXlzKG4uaWNvbkRlZmF1bHRzKTtmdW5jdGlvbiBpKGUsbixyLG8pe3ZvaWQgMD09PW8mJihvPTApO3ZhciBhPWUucGFyZW50O2lmKHZvaWQgMCE9PW5bYV0pcmV0dXJuIHQubWVyZ2VJY29uRGF0YShuW2FdLGUpO2lmKHZvaWQgMCE9PXJbYV0pe2lmKG8+MilyZXR1cm4gbnVsbDt2YXIgYz1pKHJbYV0sbixyLG8rMSk7aWYoYylyZXR1cm4gdC5tZXJnZUljb25EYXRhKGMsZSl9cmV0dXJuIG51bGx9ci5wYXJzZUljb25TZXQ9ZnVuY3Rpb24oZSx0LHIpe3ZvaWQgMD09PXImJihyPVwibm9uZVwiKTt2YXIgYT1bXTtpZihcIm9iamVjdFwiIT10eXBlb2YgZSlyZXR1cm5cIm5vbmVcIiE9PXImJmE7aWYoZS5ub3RfZm91bmQgaW5zdGFuY2VvZiBBcnJheSYmZS5ub3RfZm91bmQuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dChlLG51bGwpLFwiYWxsXCI9PT1yJiZhLnB1c2goZSl9KSksXCJvYmplY3RcIiE9dHlwZW9mIGUuaWNvbnMpcmV0dXJuXCJub25lXCIhPT1yJiZhO3ZhciBjPU9iamVjdC5jcmVhdGUobnVsbCk7by5mb3JFYWNoKChmdW5jdGlvbihuKXt2b2lkIDAhPT1lW25dJiZcIm9iamVjdFwiIT10eXBlb2YgZVtuXSYmKGNbbl09ZVtuXSl9KSk7dmFyIHU9ZS5pY29ucztpZihPYmplY3Qua2V5cyh1KS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgcj11W2VdO1wic3RyaW5nXCI9PXR5cGVvZiByLmJvZHkmJih0KGUsT2JqZWN0LmZyZWV6ZShPYmplY3QuYXNzaWduKHt9LG4uaWNvbkRlZmF1bHRzLGMscikpKSxhLnB1c2goZSkpfSkpLFwib2JqZWN0XCI9PXR5cGVvZiBlLmFsaWFzZXMpe3ZhciBmPWUuYWxpYXNlcztPYmplY3Qua2V5cyhmKS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgcj1pKGZbZV0sdSxmLDEpO3ImJih0KGUsT2JqZWN0LmZyZWV6ZShPYmplY3QuYXNzaWduKHt9LG4uaWNvbkRlZmF1bHRzLGMscikpKSxhLnB1c2goZSkpfSkpfXJldHVyblwibm9uZVwiPT09cj9hLmxlbmd0aD4wOmF9fSkpLG89ZSgoZnVuY3Rpb24oZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnZhbGlkYXRlSWNvbj10LnN0cmluZ1RvSWNvbj12b2lkIDA7dC5zdHJpbmdUb0ljb249ZnVuY3Rpb24oZSxuLHIsbyl7dm9pZCAwPT09byYmKG89XCJcIik7dmFyIGk9ZS5zcGxpdChcIjpcIik7aWYoXCJAXCI9PT1lLnNsaWNlKDAsMSkpe2lmKGkubGVuZ3RoPDJ8fGkubGVuZ3RoPjMpcmV0dXJuIG51bGw7bz1pLnNoaWZ0KCkuc2xpY2UoMSl9aWYoaS5sZW5ndGg+M3x8IWkubGVuZ3RoKXJldHVybiBudWxsO2lmKGkubGVuZ3RoPjEpe3ZhciBhPWkucG9wKCksYz1pLnBvcCgpLHU9e3Byb3ZpZGVyOmkubGVuZ3RoPjA/aVswXTpvLHByZWZpeDpjLG5hbWU6YX07cmV0dXJuIG4mJiF0LnZhbGlkYXRlSWNvbih1KT9udWxsOnV9dmFyIGY9aVswXSxsPWYuc3BsaXQoXCItXCIpO2lmKGwubGVuZ3RoPjEpe3ZhciBzPXtwcm92aWRlcjpvLHByZWZpeDpsLnNoaWZ0KCksbmFtZTpsLmpvaW4oXCItXCIpfTtyZXR1cm4gbiYmIXQudmFsaWRhdGVJY29uKHMpP251bGw6c31pZihyJiZcIlwiPT09byl7dmFyIGQ9e3Byb3ZpZGVyOm8scHJlZml4OlwiXCIsbmFtZTpmfTtyZXR1cm4gbiYmIXQudmFsaWRhdGVJY29uKGQscik/bnVsbDpkfXJldHVybiBudWxsfTt0LnZhbGlkYXRlSWNvbj1mdW5jdGlvbihlLHQpe3JldHVybiEhZSYmIShcIlwiIT09ZS5wcm92aWRlciYmIWUucHJvdmlkZXIubWF0Y2gobi5tYXRjaE5hbWUpfHwhKHQmJlwiXCI9PT1lLnByZWZpeHx8ZS5wcmVmaXgubWF0Y2gobi5tYXRjaE5hbWUpKXx8IWUubmFtZS5tYXRjaChuLm1hdGNoTmFtZSkpfX0pKSxpPWUoKGZ1bmN0aW9uKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5saXN0SWNvbnM9dC5nZXRJY29uPXQuaWNvbkV4aXN0cz10LmFkZEljb249dC5hZGRJY29uU2V0PXQuZ2V0U3RvcmFnZT10Lm5ld1N0b3JhZ2U9dm9pZCAwO3ZhciBvPU9iamVjdC5jcmVhdGUobnVsbCk7ZnVuY3Rpb24gaShlLG4pe3JldHVybntwcm92aWRlcjplLHByZWZpeDpuLGljb25zOk9iamVjdC5jcmVhdGUobnVsbCksbWlzc2luZzpPYmplY3QuY3JlYXRlKG51bGwpfX1mdW5jdGlvbiBhKGUsbil7dm9pZCAwPT09b1tlXSYmKG9bZV09T2JqZWN0LmNyZWF0ZShudWxsKSk7dmFyIHQ9b1tlXTtyZXR1cm4gdm9pZCAwPT09dFtuXSYmKHRbbl09aShlLG4pKSx0W25dfXQubmV3U3RvcmFnZT1pLHQuZ2V0U3RvcmFnZT1hLHQuYWRkSWNvblNldD1mdW5jdGlvbihlLG4sdCl7dm9pZCAwPT09dCYmKHQ9XCJub25lXCIpO3ZhciBvPURhdGUubm93KCk7cmV0dXJuIHIucGFyc2VJY29uU2V0KG4sKGZ1bmN0aW9uKG4sdCl7bnVsbD09PXQ/ZS5taXNzaW5nW25dPW86ZS5pY29uc1tuXT10fSksdCl9LHQuYWRkSWNvbj1mdW5jdGlvbihlLHQscil7dHJ5e2lmKFwic3RyaW5nXCI9PXR5cGVvZiByLmJvZHkpcmV0dXJuIGUuaWNvbnNbdF09T2JqZWN0LmZyZWV6ZShuLmZ1bGxJY29uKHIpKSwhMH1jYXRjaChlKXt9cmV0dXJuITF9LHQuaWNvbkV4aXN0cz1mdW5jdGlvbihlLG4pe3JldHVybiB2b2lkIDAhPT1lLmljb25zW25dfSx0LmdldEljb249ZnVuY3Rpb24oZSxuKXt2YXIgdD1lLmljb25zW25dO3JldHVybiB2b2lkIDA9PT10P251bGw6dH0sdC5saXN0SWNvbnM9ZnVuY3Rpb24oZSxuKXt2YXIgdD1bXTtyZXR1cm4oXCJzdHJpbmdcIj09dHlwZW9mIGU/W2VdOk9iamVjdC5rZXlzKG8pKS5mb3JFYWNoKChmdW5jdGlvbihlKXsoXCJzdHJpbmdcIj09dHlwZW9mIGUmJlwic3RyaW5nXCI9PXR5cGVvZiBuP1tuXTp2b2lkIDA9PT1vW2VdP1tdOk9iamVjdC5rZXlzKG9bZV0pKS5mb3JFYWNoKChmdW5jdGlvbihuKXt2YXIgcj1hKGUsbiksbz1PYmplY3Qua2V5cyhyLmljb25zKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybihcIlwiIT09ZT9cIkBcIitlK1wiOlwiOlwiXCIpK24rXCI6XCIrdH0pKTt0PXQuY29uY2F0KG8pfSkpfSkpLHR9fSkpLGE9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnN0b3JhZ2VGdW5jdGlvbnM9bi5hZGRDb2xsZWN0aW9uPW4uYWRkSWNvbj1uLmdldEljb25EYXRhPW4uYWxsb3dTaW1wbGVOYW1lcz12b2lkIDA7dmFyIHQ9ITE7ZnVuY3Rpb24gYShlKXt2YXIgbj1cInN0cmluZ1wiPT10eXBlb2YgZT9vLnN0cmluZ1RvSWNvbihlLCEwLHQpOmU7cmV0dXJuIG4/aS5nZXRJY29uKGkuZ2V0U3RvcmFnZShuLnByb3ZpZGVyLG4ucHJlZml4KSxuLm5hbWUpOm51bGx9ZnVuY3Rpb24gYyhlLG4pe3ZhciByPW8uc3RyaW5nVG9JY29uKGUsITAsdCk7aWYoIXIpcmV0dXJuITE7dmFyIGE9aS5nZXRTdG9yYWdlKHIucHJvdmlkZXIsci5wcmVmaXgpO3JldHVybiBpLmFkZEljb24oYSxyLm5hbWUsbil9ZnVuY3Rpb24gdShlLG4pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlKXJldHVybiExO2lmKFwic3RyaW5nXCIhPXR5cGVvZiBuJiYobj1cInN0cmluZ1wiPT10eXBlb2YgZS5wcm92aWRlcj9lLnByb3ZpZGVyOlwiXCIpLHQmJlwiXCI9PT1uJiYoXCJzdHJpbmdcIiE9dHlwZW9mIGUucHJlZml4fHxcIlwiPT09ZS5wcmVmaXgpKXt2YXIgYT0hMTtyZXR1cm4gci5wYXJzZUljb25TZXQoZSwoZnVuY3Rpb24oZSxuKXtudWxsIT09biYmYyhlLG4pJiYoYT0hMCl9KSksYX1pZihcInN0cmluZ1wiIT10eXBlb2YgZS5wcmVmaXh8fCFvLnZhbGlkYXRlSWNvbih7cHJvdmlkZXI6bixwcmVmaXg6ZS5wcmVmaXgsbmFtZTpcImFcIn0pKXJldHVybiExO3ZhciB1PWkuZ2V0U3RvcmFnZShuLGUucHJlZml4KTtyZXR1cm4hIWkuYWRkSWNvblNldCh1LGUpfW4uYWxsb3dTaW1wbGVOYW1lcz1mdW5jdGlvbihlKXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIGUmJih0PWUpLHR9LG4uZ2V0SWNvbkRhdGE9YSxuLmFkZEljb249YyxuLmFkZENvbGxlY3Rpb249dSxuLnN0b3JhZ2VGdW5jdGlvbnM9e2ljb25FeGlzdHM6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPT1hKGUpfSxnZXRJY29uOmZ1bmN0aW9uKGUpe3ZhciBuPWEoZSk7cmV0dXJuIG4/T2JqZWN0LmFzc2lnbih7fSxuKTpudWxsfSxsaXN0SWNvbnM6aS5saXN0SWNvbnMsYWRkSWNvbjpjLGFkZENvbGxlY3Rpb246dX19KSksYz1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4ucmVwbGFjZUlEcz12b2lkIDA7dmFyIHQ9L1xcc2lkPVwiKFxcUyspXCIvZyxyPVwiKFteQS1aYS16MC05Xy1dKVwiO3ZhciBvPVwiSWNvbmlmeUlkLVwiK0RhdGUubm93KCkudG9TdHJpbmcoMTYpK1wiLVwiKygxNjc3NzIxNipNYXRoLnJhbmRvbSgpfDApLnRvU3RyaW5nKDE2KStcIi1cIixpPTA7bi5yZXBsYWNlSURzPWZ1bmN0aW9uKGUsbil7dm9pZCAwPT09biYmKG49byk7Zm9yKHZhciBhLGM9W107YT10LmV4ZWMoZSk7KWMucHVzaChhWzFdKTtyZXR1cm4gYy5sZW5ndGg/KGMuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIG89XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uKCk6bitpKys7ZT1lLnJlcGxhY2UobmV3IFJlZ0V4cChyK1wiKFwiKyh0LnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLFwiXFxcXCQmXCIpK1wiKVwiKStyLFwiZ1wiKSxcIiQxXCIrbytcIiQzXCIpfSkpLGUpOmV9fSkpLHU9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmNhbGN1bGF0ZVNpemU9dm9pZCAwO3ZhciB0PS8oLT9bMC05Ll0qWzAtOV0rWzAtOS5dKikvZyxyPS9eLT9bMC05Ll0qWzAtOV0rWzAtOS5dKiQvZztuLmNhbGN1bGF0ZVNpemU9ZnVuY3Rpb24oZSxuLG8pe2lmKDE9PT1uKXJldHVybiBlO2lmKG89dm9pZCAwPT09bz8xMDA6byxcIm51bWJlclwiPT10eXBlb2YgZSlyZXR1cm4gTWF0aC5jZWlsKGUqbipvKS9vO2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlKXJldHVybiBlO3ZhciBpPWUuc3BsaXQodCk7aWYobnVsbD09PWl8fCFpLmxlbmd0aClyZXR1cm4gZTtmb3IodmFyIGE9W10sYz1pLnNoaWZ0KCksdT1yLnRlc3QoYyk7Oyl7aWYodSl7dmFyIGY9cGFyc2VGbG9hdChjKTtpc05hTihmKT9hLnB1c2goYyk6YS5wdXNoKE1hdGguY2VpbChmKm4qbykvbyl9ZWxzZSBhLnB1c2goYyk7aWYodm9pZCAwPT09KGM9aS5zaGlmdCgpKSlyZXR1cm4gYS5qb2luKFwiXCIpO3U9IXV9fX0pKSxmPWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5tZXJnZUN1c3RvbWlzYXRpb25zPW4uZGVmYXVsdHM9dm9pZCAwLG4uZGVmYXVsdHM9T2JqZWN0LmZyZWV6ZSh7aW5saW5lOiExLHdpZHRoOm51bGwsaGVpZ2h0Om51bGwsaEFsaWduOlwiY2VudGVyXCIsdkFsaWduOlwibWlkZGxlXCIsc2xpY2U6ITEsaEZsaXA6ITEsdkZsaXA6ITEscm90YXRlOjB9KSxuLm1lcmdlQ3VzdG9taXNhdGlvbnM9ZnVuY3Rpb24oZSxuKXt2YXIgdD17fTtmb3IodmFyIHIgaW4gZSl7dmFyIG89cjtpZih0W29dPWVbb10sdm9pZCAwIT09bltvXSl7dmFyIGk9bltvXTtzd2l0Y2gobyl7Y2FzZVwiaW5saW5lXCI6Y2FzZVwic2xpY2VcIjpcImJvb2xlYW5cIj09dHlwZW9mIGkmJih0W29dPWkpO2JyZWFrO2Nhc2VcImhGbGlwXCI6Y2FzZVwidkZsaXBcIjohMD09PWkmJih0W29dPSF0W29dKTticmVhaztjYXNlXCJoQWxpZ25cIjpjYXNlXCJ2QWxpZ25cIjpcInN0cmluZ1wiPT10eXBlb2YgaSYmXCJcIiE9PWkmJih0W29dPWkpO2JyZWFrO2Nhc2VcIndpZHRoXCI6Y2FzZVwiaGVpZ2h0XCI6KFwic3RyaW5nXCI9PXR5cGVvZiBpJiZcIlwiIT09aXx8XCJudW1iZXJcIj09dHlwZW9mIGkmJml8fG51bGw9PT1pKSYmKHRbb109aSk7YnJlYWs7Y2FzZVwicm90YXRlXCI6XCJudW1iZXJcIj09dHlwZW9mIGkmJih0W29dKz1pKX19fXJldHVybiB0fX0pKSxsPWUoKGZ1bmN0aW9uKGUsbil7ZnVuY3Rpb24gdChlKXt2YXIgbj1cIlwiO3N3aXRjaChlLmhBbGlnbil7Y2FzZVwibGVmdFwiOm4rPVwieE1pblwiO2JyZWFrO2Nhc2VcInJpZ2h0XCI6bis9XCJ4TWF4XCI7YnJlYWs7ZGVmYXVsdDpuKz1cInhNaWRcIn1zd2l0Y2goZS52QWxpZ24pe2Nhc2VcInRvcFwiOm4rPVwiWU1pblwiO2JyZWFrO2Nhc2VcImJvdHRvbVwiOm4rPVwiWU1heFwiO2JyZWFrO2RlZmF1bHQ6bis9XCJZTWlkXCJ9cmV0dXJuIG4rPWUuc2xpY2U/XCIgc2xpY2VcIjpcIiBtZWV0XCJ9T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5pY29uVG9TVkc9dm9pZCAwLG4uaWNvblRvU1ZHPWZ1bmN0aW9uKGUsbil7dmFyIHIsbyxpPXtsZWZ0OmUubGVmdCx0b3A6ZS50b3Asd2lkdGg6ZS53aWR0aCxoZWlnaHQ6ZS5oZWlnaHR9LGE9ZS5ib2R5O1tlLG5dLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuLHQ9W10scj1lLmhGbGlwLG89ZS52RmxpcCxjPWUucm90YXRlO3N3aXRjaChyP28/Yys9MjoodC5wdXNoKFwidHJhbnNsYXRlKFwiKyhpLndpZHRoK2kubGVmdCkrXCIgXCIrKDAtaS50b3ApK1wiKVwiKSx0LnB1c2goXCJzY2FsZSgtMSAxKVwiKSxpLnRvcD1pLmxlZnQ9MCk6byYmKHQucHVzaChcInRyYW5zbGF0ZShcIisoMC1pLmxlZnQpK1wiIFwiKyhpLmhlaWdodCtpLnRvcCkrXCIpXCIpLHQucHVzaChcInNjYWxlKDEgLTEpXCIpLGkudG9wPWkubGVmdD0wKSxjPDAmJihjLT00Kk1hdGguZmxvb3IoYy80KSksYyU9NCl7Y2FzZSAxOm49aS5oZWlnaHQvMitpLnRvcCx0LnVuc2hpZnQoXCJyb3RhdGUoOTAgXCIrbitcIiBcIituK1wiKVwiKTticmVhaztjYXNlIDI6dC51bnNoaWZ0KFwicm90YXRlKDE4MCBcIisoaS53aWR0aC8yK2kubGVmdCkrXCIgXCIrKGkuaGVpZ2h0LzIraS50b3ApK1wiKVwiKTticmVhaztjYXNlIDM6bj1pLndpZHRoLzIraS5sZWZ0LHQudW5zaGlmdChcInJvdGF0ZSgtOTAgXCIrbitcIiBcIituK1wiKVwiKX1jJTI9PTEmJigwPT09aS5sZWZ0JiYwPT09aS50b3B8fChuPWkubGVmdCxpLmxlZnQ9aS50b3AsaS50b3A9biksaS53aWR0aCE9PWkuaGVpZ2h0JiYobj1pLndpZHRoLGkud2lkdGg9aS5oZWlnaHQsaS5oZWlnaHQ9bikpLHQubGVuZ3RoJiYoYT0nPGcgdHJhbnNmb3JtPVwiJyt0LmpvaW4oXCIgXCIpKydcIj4nK2ErXCI8L2c+XCIpfSkpLG51bGw9PT1uLndpZHRoJiZudWxsPT09bi5oZWlnaHQ/KG89XCIxZW1cIixyPXUuY2FsY3VsYXRlU2l6ZShvLGkud2lkdGgvaS5oZWlnaHQpKTpudWxsIT09bi53aWR0aCYmbnVsbCE9PW4uaGVpZ2h0PyhyPW4ud2lkdGgsbz1uLmhlaWdodCk6bnVsbCE9PW4uaGVpZ2h0PyhvPW4uaGVpZ2h0LHI9dS5jYWxjdWxhdGVTaXplKG8saS53aWR0aC9pLmhlaWdodCkpOihyPW4ud2lkdGgsbz11LmNhbGN1bGF0ZVNpemUocixpLmhlaWdodC9pLndpZHRoKSksXCJhdXRvXCI9PT1yJiYocj1pLndpZHRoKSxcImF1dG9cIj09PW8mJihvPWkuaGVpZ2h0KTt2YXIgYz17YXR0cmlidXRlczp7d2lkdGg6cj1cInN0cmluZ1wiPT10eXBlb2Ygcj9yOnIrXCJcIixoZWlnaHQ6bz1cInN0cmluZ1wiPT10eXBlb2Ygbz9vOm8rXCJcIixwcmVzZXJ2ZUFzcGVjdFJhdGlvOnQobiksdmlld0JveDppLmxlZnQrXCIgXCIraS50b3ArXCIgXCIraS53aWR0aCtcIiBcIitpLmhlaWdodH0sYm9keTphfTtyZXR1cm4gbi5pbmxpbmUmJihjLmlubGluZT0hMCksY319KSkscz1lKChmdW5jdGlvbihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuYnVpbGRlckZ1bmN0aW9ucz12b2lkIDAsdC5idWlsZGVyRnVuY3Rpb25zPXtyZXBsYWNlSURzOmMucmVwbGFjZUlEcyxjYWxjdWxhdGVTaXplOnUuY2FsY3VsYXRlU2l6ZSxidWlsZEljb246ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbC5pY29uVG9TVkcobi5mdWxsSWNvbihlKSxmLm1lcmdlQ3VzdG9taXNhdGlvbnMoZi5kZWZhdWx0cyx0KSl9fX0pKSxkPWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5jb3JlTW9kdWxlcz12b2lkIDAsbi5jb3JlTW9kdWxlcz17fX0pKSx2PWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5zdG9yZUNhY2hlPW4ubG9hZENhY2hlPW4ubW9jaz1uLmVtcHR5TGlzdD1uLmNvdW50PW4uY29uZmlnPXZvaWQgMDt2YXIgdD1cImljb25pZnkyXCIscj1cImljb25pZnlcIixvPVwiaWNvbmlmeS1jb3VudFwiLGE9XCJpY29uaWZ5LXZlcnNpb25cIixjPTM2ZTU7bi5jb25maWc9e2xvY2FsOiEwLHNlc3Npb246ITB9O3ZhciB1PSExO24uY291bnQ9e2xvY2FsOjAsc2Vzc2lvbjowfSxuLmVtcHR5TGlzdD17bG9jYWw6W10sc2Vzc2lvbjpbXX07dmFyIGY9XCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz97fTp3aW5kb3c7ZnVuY3Rpb24gbChlKXt2YXIgdD1lK1wiU3RvcmFnZVwiO3RyeXtpZihmJiZmW3RdJiZcIm51bWJlclwiPT10eXBlb2YgZlt0XS5sZW5ndGgpcmV0dXJuIGZbdF19Y2F0Y2goZSl7fXJldHVybiBuLmNvbmZpZ1tlXT0hMSxudWxsfWZ1bmN0aW9uIHMoZSx0LHIpe3RyeXtyZXR1cm4gZS5zZXRJdGVtKG8scitcIlwiKSxuLmNvdW50W3RdPXIsITB9Y2F0Y2goZSl7cmV0dXJuITF9fWZ1bmN0aW9uIGQoZSl7dmFyIG49ZS5nZXRJdGVtKG8pO2lmKG4pe3ZhciB0PXBhcnNlSW50KG4pO3JldHVybiB0fHwwfXJldHVybiAwfW4ubW9jaz1mdW5jdGlvbihlKXt1PSExLGY9ZX07bi5sb2FkQ2FjaGU9ZnVuY3Rpb24oKXtpZighdSl7dT0hMDt2YXIgZT1NYXRoLmZsb29yKERhdGUubm93KCkvYyktMTY4O2Zvcih2YXIgbyBpbiBuLmNvbmZpZylmKG8pfWZ1bmN0aW9uIGYobyl7dmFyIGM9bChvKTtpZihjKXt2YXIgdT1mdW5jdGlvbihuKXt2YXIgdD1yK24sbz1jLmdldEl0ZW0odCk7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIG8pcmV0dXJuITE7dmFyIGE9ITA7dHJ5e3ZhciB1PUpTT04ucGFyc2Uobyk7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHV8fFwibnVtYmVyXCIhPXR5cGVvZiB1LmNhY2hlZHx8dS5jYWNoZWQ8ZXx8XCJzdHJpbmdcIiE9dHlwZW9mIHUucHJvdmlkZXJ8fFwib2JqZWN0XCIhPXR5cGVvZiB1LmRhdGF8fFwic3RyaW5nXCIhPXR5cGVvZiB1LmRhdGEucHJlZml4KWE9ITE7ZWxzZXt2YXIgZj11LnByb3ZpZGVyLGw9dS5kYXRhLnByZWZpeCxzPWkuZ2V0U3RvcmFnZShmLGwpO2E9aS5hZGRJY29uU2V0KHMsdS5kYXRhKX19Y2F0Y2goZSl7YT0hMX1yZXR1cm4gYXx8Yy5yZW1vdmVJdGVtKHQpLGF9O3RyeXt2YXIgZj1jLmdldEl0ZW0oYSk7aWYoZiE9PXQpcmV0dXJuIGYmJmZ1bmN0aW9uKGUpe3RyeXtmb3IodmFyIG49ZChlKSx0PTA7dDxuO3QrKyllLnJlbW92ZUl0ZW0ocit0KX1jYXRjaChlKXt9fShjKSx2b2lkIGZ1bmN0aW9uKGUsbil7dHJ5e2Uuc2V0SXRlbShhLHQpfWNhdGNoKGUpe31zKGUsbiwwKX0oYyxvKTtmb3IodmFyIHY9ZChjKSxwPXYtMTtwPj0wO3AtLSl1KHApfHwocD09PXYtMT92LS06bi5lbXB0eUxpc3Rbb10ucHVzaChwKSk7cyhjLG8sdil9Y2F0Y2goZSl7fX19fTtuLnN0b3JlQ2FjaGU9ZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBvKG8pe2lmKCFuLmNvbmZpZ1tvXSlyZXR1cm4hMTt2YXIgaT1sKG8pO2lmKCFpKXJldHVybiExO3ZhciBhPW4uZW1wdHlMaXN0W29dLnNoaWZ0KCk7aWYodm9pZCAwPT09YSYmIXMoaSxvLChhPW4uY291bnRbb10pKzEpKXJldHVybiExO3RyeXt2YXIgdT17Y2FjaGVkOk1hdGguZmxvb3IoRGF0ZS5ub3coKS9jKSxwcm92aWRlcjplLGRhdGE6dH07aS5zZXRJdGVtKHIrYSxKU09OLnN0cmluZ2lmeSh1KSl9Y2F0Y2goZSl7cmV0dXJuITF9cmV0dXJuITB9dXx8bi5sb2FkQ2FjaGUoKSxvKFwibG9jYWxcIil8fG8oXCJzZXNzaW9uXCIpfX0pKSxwPWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi50b2dnbGVCcm93c2VyQ2FjaGU9dm9pZCAwLG4udG9nZ2xlQnJvd3NlckNhY2hlPWZ1bmN0aW9uKGUsbil7c3dpdGNoKGUpe2Nhc2VcImxvY2FsXCI6Y2FzZVwic2Vzc2lvblwiOnYuY29uZmlnW2VdPW47YnJlYWs7Y2FzZVwiYWxsXCI6Zm9yKHZhciB0IGluIHYuY29uZmlnKXYuY29uZmlnW3RdPW59fX0pKSxoPWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5kZWZhdWx0Q29uZmlnPXZvaWQgMCxuLmRlZmF1bHRDb25maWc9e3Jlc291cmNlczpbXSxpbmRleDowLHRpbWVvdXQ6MmUzLHJvdGF0ZTo3NTAscmFuZG9tOiExLGRhdGFBZnRlclRpbWVvdXQ6ITF9fSkpLGc9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnNlbmRRdWVyeT12b2lkIDAsbi5zZW5kUXVlcnk9ZnVuY3Rpb24oZSxuLHQscixvKXt2YXIgaSxhPWUucmVzb3VyY2VzLmxlbmd0aCxjPWUucmFuZG9tP01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSphKTplLmluZGV4O2lmKGUucmFuZG9tKXt2YXIgdT1lLnJlc291cmNlcy5zbGljZSgwKTtmb3IoaT1bXTt1Lmxlbmd0aD4xOyl7dmFyIGY9TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKnUubGVuZ3RoKTtpLnB1c2godVtmXSksdT11LnNsaWNlKDAsZikuY29uY2F0KHUuc2xpY2UoZisxKSl9aT1pLmNvbmNhdCh1KX1lbHNlIGk9ZS5yZXNvdXJjZXMuc2xpY2UoYykuY29uY2F0KGUucmVzb3VyY2VzLnNsaWNlKDAsYykpO3ZhciBsPURhdGUubm93KCkscz1cInBlbmRpbmdcIixkPTAsdj12b2lkIDAscD1udWxsLGg9W10sZz1bXTtmdW5jdGlvbiBtKCl7cCYmKGNsZWFyVGltZW91dChwKSxwPW51bGwpfWZ1bmN0aW9uIGIoKXtcInBlbmRpbmdcIj09PXMmJihzPVwiYWJvcnRlZFwiKSxtKCksaC5mb3JFYWNoKChmdW5jdGlvbihlKXtlLmFib3J0JiZlLmFib3J0KCksXCJwZW5kaW5nXCI9PT1lLnN0YXR1cyYmKGUuc3RhdHVzPVwiYWJvcnRlZFwiKX0pKSxoPVtdfWZ1bmN0aW9uIHkoZSxuKXtuJiYoZz1bXSksXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZy5wdXNoKGUpfWZ1bmN0aW9uIEkoKXtyZXR1cm57c3RhcnRUaW1lOmwscGF5bG9hZDpuLHN0YXR1czpzLHF1ZXJpZXNTZW50OmQscXVlcmllc1BlbmRpbmc6aC5sZW5ndGgsc3Vic2NyaWJlOnksYWJvcnQ6Yn19ZnVuY3Rpb24gaigpe3M9XCJmYWlsZWRcIixnLmZvckVhY2goKGZ1bmN0aW9uKGUpe2Uodm9pZCAwLHYpfSkpfWZ1bmN0aW9uIHgoKXtoPWguZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm5cInBlbmRpbmdcIj09PWUuc3RhdHVzJiYoZS5zdGF0dXM9XCJhYm9ydGVkXCIpLGUuYWJvcnQmJmUuYWJvcnQoKSwhMX0pKX1mdW5jdGlvbiBPKCl7aWYoXCJwZW5kaW5nXCI9PT1zKXttKCk7dmFyIHI9aS5zaGlmdCgpO2lmKHZvaWQgMCE9PXIpe3ZhciBhPXtnZXRRdWVyeVN0YXR1czpJLHN0YXR1czpcInBlbmRpbmdcIixyZXNvdXJjZTpyLGRvbmU6ZnVuY3Rpb24obix0KXshZnVuY3Rpb24obix0LHIpe3ZhciBhPXZvaWQgMD09PXQ7c3dpdGNoKGg9aC5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBlIT09bn0pKSxzKXtjYXNlXCJwZW5kaW5nXCI6YnJlYWs7Y2FzZVwiZmFpbGVkXCI6aWYoYXx8IWUuZGF0YUFmdGVyVGltZW91dClyZXR1cm47YnJlYWs7ZGVmYXVsdDpyZXR1cm59aWYoYSlyZXR1cm4gdm9pZCAwIT09ciYmKHY9ciksdm9pZChoLmxlbmd0aHx8KGkubGVuZ3RoP08oKTpqKCkpKTtpZihtKCkseCgpLG8mJiFlLnJhbmRvbSl7dmFyIGM9ZS5yZXNvdXJjZXMuaW5kZXhPZihuLnJlc291cmNlKTstMSE9PWMmJmMhPT1lLmluZGV4JiZvKGMpfXM9XCJjb21wbGV0ZWRcIixnLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UodCl9KSl9KGEsbix0KX19O2gucHVzaChhKSxkKys7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgZS5yb3RhdGU/ZS5yb3RhdGUoZCxsKTplLnJvdGF0ZTtwPXNldFRpbWVvdXQoTyxjKSx0KHIsbixhKX1lbHNle2lmKGgubGVuZ3RoKXt2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnRpbWVvdXQ/ZS50aW1lb3V0KGwpOmUudGltZW91dDtpZih1KXJldHVybiB2b2lkKHA9c2V0VGltZW91dCgoZnVuY3Rpb24oKXttKCksXCJwZW5kaW5nXCI9PT1zJiYoeCgpLGooKSl9KSx1KSl9aigpfX19cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgciYmZy5wdXNoKHIpLHNldFRpbWVvdXQoTyksSX19KSksbT1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uaW5pdFJlZHVuZGFuY3k9dm9pZCAwLG4uaW5pdFJlZHVuZGFuY3k9ZnVuY3Rpb24oZSl7dmFyIG49ZnVuY3Rpb24oZSl7aWYoIShcIm9iamVjdFwiPT10eXBlb2YgZSYmXCJvYmplY3RcIj09dHlwZW9mIGUucmVzb3VyY2VzJiZlLnJlc291cmNlcyBpbnN0YW5jZW9mIEFycmF5JiZlLnJlc291cmNlcy5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUmVkdW5jYW5jeSBjb25maWd1cmF0aW9uXCIpO3ZhciBuLHQ9T2JqZWN0LmNyZWF0ZShudWxsKTtmb3IobiBpbiBoLmRlZmF1bHRDb25maWcpdm9pZCAwIT09ZVtuXT90W25dPWVbbl06dFtuXT1oLmRlZmF1bHRDb25maWdbbl07cmV0dXJuIHR9KGUpLHQ9W107ZnVuY3Rpb24gcigpe3Q9dC5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVyblwicGVuZGluZ1wiPT09ZSgpLnN0YXR1c30pKX1yZXR1cm57cXVlcnk6ZnVuY3Rpb24oZSxvLGkpe3ZhciBhPWcuc2VuZFF1ZXJ5KG4sZSxvLChmdW5jdGlvbihlLG4pe3IoKSxpJiZpKGUsbil9KSwoZnVuY3Rpb24oZSl7bi5pbmRleD1lfSkpO3JldHVybiB0LnB1c2goYSksYX0sZmluZDpmdW5jdGlvbihlKXt2YXIgbj10LmZpbmQoKGZ1bmN0aW9uKG4pe3JldHVybiBlKG4pfSkpO3JldHVybiB2b2lkIDAhPT1uP246bnVsbH0sc2V0SW5kZXg6ZnVuY3Rpb24oZSl7bi5pbmRleD1lfSxnZXRJbmRleDpmdW5jdGlvbigpe3JldHVybiBuLmluZGV4fSxjbGVhbnVwOnJ9fX0pKSxiPWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5zb3J0SWNvbnM9dm9pZCAwLG4uc29ydEljb25zPWZ1bmN0aW9uKGUpe3ZhciBuPXtsb2FkZWQ6W10sbWlzc2luZzpbXSxwZW5kaW5nOltdfSx0PU9iamVjdC5jcmVhdGUobnVsbCk7ZS5zb3J0KChmdW5jdGlvbihlLG4pe3JldHVybiBlLnByb3ZpZGVyIT09bi5wcm92aWRlcj9lLnByb3ZpZGVyLmxvY2FsZUNvbXBhcmUobi5wcm92aWRlcik6ZS5wcmVmaXghPT1uLnByZWZpeD9lLnByZWZpeC5sb2NhbGVDb21wYXJlKG4ucHJlZml4KTplLm5hbWUubG9jYWxlQ29tcGFyZShuLm5hbWUpfSkpO3ZhciByPXtwcm92aWRlcjpcIlwiLHByZWZpeDpcIlwiLG5hbWU6XCJcIn07cmV0dXJuIGUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7aWYoci5uYW1lIT09ZS5uYW1lfHxyLnByZWZpeCE9PWUucHJlZml4fHxyLnByb3ZpZGVyIT09ZS5wcm92aWRlcil7cj1lO3ZhciBvPWUucHJvdmlkZXIsYT1lLnByZWZpeCxjPWUubmFtZTt2b2lkIDA9PT10W29dJiYodFtvXT1PYmplY3QuY3JlYXRlKG51bGwpKTt2YXIgdT10W29dO3ZvaWQgMD09PXVbYV0mJih1W2FdPWkuZ2V0U3RvcmFnZShvLGEpKTt2YXIgZj11W2FdLGw9e3Byb3ZpZGVyOm8scHJlZml4OmEsbmFtZTpjfTsodm9pZCAwIT09Zi5pY29uc1tjXT9uLmxvYWRlZDpcIlwiPT09YXx8dm9pZCAwIT09Zi5taXNzaW5nW2NdP24ubWlzc2luZzpuLnBlbmRpbmcpLnB1c2gobCl9fSkpLG59fSkpLHk9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnN0b3JlQ2FsbGJhY2s9bi51cGRhdGVDYWxsYmFja3M9bi5jYWxsYmFja3M9dm9pZCAwLG4uY2FsbGJhY2tzPU9iamVjdC5jcmVhdGUobnVsbCk7dmFyIHQ9T2JqZWN0LmNyZWF0ZShudWxsKTtmdW5jdGlvbiByKGUsdCl7ZS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgcj1lLnByb3ZpZGVyO2lmKHZvaWQgMCE9PW4uY2FsbGJhY2tzW3JdKXt2YXIgbz1uLmNhbGxiYWNrc1tyXSxpPWUucHJlZml4LGE9b1tpXTthJiYob1tpXT1hLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWQhPT10fSkpKX19KSl9bi51cGRhdGVDYWxsYmFja3M9ZnVuY3Rpb24oZSxvKXt2b2lkIDA9PT10W2VdJiYodFtlXT1PYmplY3QuY3JlYXRlKG51bGwpKTt2YXIgYT10W2VdO2Fbb118fChhW29dPSEwLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7aWYoYVtvXT0hMSx2b2lkIDAhPT1uLmNhbGxiYWNrc1tlXSYmdm9pZCAwIT09bi5jYWxsYmFja3NbZV1bb10pe3ZhciB0PW4uY2FsbGJhY2tzW2VdW29dLnNsaWNlKDApO2lmKHQubGVuZ3RoKXt2YXIgYz1pLmdldFN0b3JhZ2UoZSxvKSx1PSExO3QuZm9yRWFjaCgoZnVuY3Rpb24obil7dmFyIHQ9bi5pY29ucyxpPXQucGVuZGluZy5sZW5ndGg7dC5wZW5kaW5nPXQucGVuZGluZy5maWx0ZXIoKGZ1bmN0aW9uKG4pe2lmKG4ucHJlZml4IT09bylyZXR1cm4hMDt2YXIgcj1uLm5hbWU7aWYodm9pZCAwIT09Yy5pY29uc1tyXSl0LmxvYWRlZC5wdXNoKHtwcm92aWRlcjplLHByZWZpeDpvLG5hbWU6cn0pO2Vsc2V7aWYodm9pZCAwPT09Yy5taXNzaW5nW3JdKXJldHVybiB1PSEwLCEwO3QubWlzc2luZy5wdXNoKHtwcm92aWRlcjplLHByZWZpeDpvLG5hbWU6cn0pfXJldHVybiExfSkpLHQucGVuZGluZy5sZW5ndGghPT1pJiYodXx8cihbe3Byb3ZpZGVyOmUscHJlZml4Om99XSxuLmlkKSxuLmNhbGxiYWNrKHQubG9hZGVkLnNsaWNlKDApLHQubWlzc2luZy5zbGljZSgwKSx0LnBlbmRpbmcuc2xpY2UoMCksbi5hYm9ydCkpfSkpfX19KSkpfTt2YXIgbz0wO24uc3RvcmVDYWxsYmFjaz1mdW5jdGlvbihlLHQsaSl7dmFyIGE9bysrLGM9ci5iaW5kKG51bGwsaSxhKTtpZighdC5wZW5kaW5nLmxlbmd0aClyZXR1cm4gYzt2YXIgdT17aWQ6YSxpY29uczp0LGNhbGxiYWNrOmUsYWJvcnQ6Y307cmV0dXJuIGkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wcm92aWRlcixyPWUucHJlZml4O3ZvaWQgMD09PW4uY2FsbGJhY2tzW3RdJiYobi5jYWxsYmFja3NbdF09T2JqZWN0LmNyZWF0ZShudWxsKSk7dmFyIG89bi5jYWxsYmFja3NbdF07dm9pZCAwPT09b1tyXSYmKG9bcl09W10pLG9bcl0ucHVzaCh1KX0pKSxjfX0pKSxJPWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5nZXRBUElNb2R1bGU9bi5zZXRBUElNb2R1bGU9dm9pZCAwO3ZhciB0PU9iamVjdC5jcmVhdGUobnVsbCk7bi5zZXRBUElNb2R1bGU9ZnVuY3Rpb24oZSxuKXt0W2VdPW59LG4uZ2V0QVBJTW9kdWxlPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT10W2VdP3RbXCJcIl06dFtlXX19KSksaj1lKChmdW5jdGlvbihlLG4pe2Z1bmN0aW9uIHQoZSl7dmFyIG47aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUucmVzb3VyY2VzKW49W2UucmVzb3VyY2VzXTtlbHNlIGlmKCEoKG49ZS5yZXNvdXJjZXMpaW5zdGFuY2VvZiBBcnJheSYmbi5sZW5ndGgpKXJldHVybiBudWxsO3JldHVybntyZXNvdXJjZXM6bixwYXRoOnZvaWQgMD09PWUucGF0aD9cIi9cIjplLnBhdGgsbWF4VVJMOmUubWF4VVJMP2UubWF4VVJMOjUwMCxyb3RhdGU6ZS5yb3RhdGU/ZS5yb3RhdGU6NzUwLHRpbWVvdXQ6ZS50aW1lb3V0P2UudGltZW91dDo1ZTMscmFuZG9tOiEwPT09ZS5yYW5kb20saW5kZXg6ZS5pbmRleD9lLmluZGV4OjAsZGF0YUFmdGVyVGltZW91dDohMSE9PWUuZGF0YUFmdGVyVGltZW91dH19T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5nZXRBUElDb25maWc9bi5zZXRBUElDb25maWc9dm9pZCAwO2Zvcih2YXIgcj1PYmplY3QuY3JlYXRlKG51bGwpLG89W1wiaHR0cHM6Ly9hcGkuc2ltcGxlc3ZnLmNvbVwiLFwiaHR0cHM6Ly9hcGkudW5pc3ZnLmNvbVwiXSxpPVtdO28ubGVuZ3RoPjA7KTE9PT1vLmxlbmd0aHx8TWF0aC5yYW5kb20oKT4uNT9pLnB1c2goby5zaGlmdCgpKTppLnB1c2goby5wb3AoKSk7cltcIlwiXT10KHtyZXNvdXJjZXM6W1wiaHR0cHM6Ly9hcGkuaWNvbmlmeS5kZXNpZ25cIl0uY29uY2F0KGkpfSksbi5zZXRBUElDb25maWc9ZnVuY3Rpb24oZSxuKXt2YXIgbz10KG4pO3JldHVybiBudWxsIT09byYmKHJbZV09bywhMCl9O24uZ2V0QVBJQ29uZmlnPWZ1bmN0aW9uKGUpe3JldHVybiByW2VdfX0pKSx4PWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5nZXRQcm92aWRlcnM9bi5saXN0VG9JY29ucz12b2lkIDAsbi5saXN0VG9JY29ucz1mdW5jdGlvbihlLG4sdCl7dm9pZCAwPT09biYmKG49ITApLHZvaWQgMD09PXQmJih0PSExKTt2YXIgcj1bXTtyZXR1cm4gZS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgaT1cInN0cmluZ1wiPT10eXBlb2YgZT9vLnN0cmluZ1RvSWNvbihlLCExLHQpOmU7biYmIW8udmFsaWRhdGVJY29uKGksdCl8fHIucHVzaCh7cHJvdmlkZXI6aS5wcm92aWRlcixwcmVmaXg6aS5wcmVmaXgsbmFtZTppLm5hbWV9KX0pKSxyfSxuLmdldFByb3ZpZGVycz1mdW5jdGlvbihlKXt2YXIgbj1PYmplY3QuY3JlYXRlKG51bGwpO3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKGUpe25bZS5wcm92aWRlcl09ITB9KSksT2JqZWN0LmtleXMobil9fSkpLE89ZSgoZnVuY3Rpb24oZSxuKXtmdW5jdGlvbiB0KCl7fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uQVBJPW4uZ2V0UmVkdW5kYW5jeUNhY2hlPXZvaWQgMDt2YXIgcj1PYmplY3QuY3JlYXRlKG51bGwpLG89T2JqZWN0LmNyZWF0ZShudWxsKSxjPU9iamVjdC5jcmVhdGUobnVsbCksdT1PYmplY3QuY3JlYXRlKG51bGwpLGY9T2JqZWN0LmNyZWF0ZShudWxsKTtmdW5jdGlvbiBsKGUpe2lmKHZvaWQgMD09PWZbZV0pe3ZhciBuPWouZ2V0QVBJQ29uZmlnKGUpO2lmKCFuKXJldHVybjt2YXIgdD17Y29uZmlnOm4scmVkdW5kYW5jeTptLmluaXRSZWR1bmRhbmN5KG4pfTtmW2VdPXR9cmV0dXJuIGZbZV19bi5nZXRSZWR1bmRhbmN5Q2FjaGU9bDt2YXIgcz1PYmplY3QuY3JlYXRlKG51bGwpO2Z1bmN0aW9uIHYoZSxuLHQpe2Z1bmN0aW9uIGEoKXt2YXIgdD0oXCJcIj09PWU/XCJcIjpcIkBcIitlK1wiOlwiKStuLHI9TWF0aC5mbG9vcihEYXRlLm5vdygpLzZlNCk7c1t0XTxyJiYoc1t0XT1yLGNvbnNvbGUuZXJyb3IoJ1VuYWJsZSB0byByZXRyaWV2ZSBpY29ucyBmb3IgXCInK3QrJ1wiIGJlY2F1c2UgQVBJIGlzIG5vdCBjb25maWd1cmVkIHByb3Blcmx5LicpKX12b2lkIDA9PT1vW2VdJiYob1tlXT1PYmplY3QuY3JlYXRlKG51bGwpKTt2YXIgZj1vW2VdO3ZvaWQgMD09PXVbZV0mJih1W2VdPU9iamVjdC5jcmVhdGUobnVsbCkpO3ZhciB2PXVbZV07dm9pZCAwPT09cltlXSYmKHJbZV09T2JqZWN0LmNyZWF0ZShudWxsKSk7dmFyIHAsaD1yW2VdO3ZvaWQgMD09PWZbbl0/ZltuXT10OmZbbl09ZltuXS5jb25jYXQodCkuc29ydCgpLHZbbl18fCh2W25dPSEwLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7dltuXT0hMTt2YXIgdD1mW25dO2RlbGV0ZSBmW25dO3ZhciByPUkuZ2V0QVBJTW9kdWxlKGUpO2lmKHIpe2lmKHZvaWQgMD09PXApe3ZhciBvPWwoZSk7aWYodm9pZCAwPT09bylyZXR1cm4gdm9pZCBhKCk7cD1vfXIucHJlcGFyZShlLG4sdCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7cC5yZWR1bmRhbmN5LnF1ZXJ5KHQsci5zZW5kLChmdW5jdGlvbihyLG8pe3ZhciBhPWkuZ2V0U3RvcmFnZShlLG4pO2lmKFwib2JqZWN0XCIhPXR5cGVvZiByKXtpZig0MDQhPT1vKXJldHVybjt2YXIgdT1EYXRlLm5vdygpO3QuaWNvbnMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7YS5taXNzaW5nW2VdPXV9KSl9ZWxzZSB0cnl7dmFyIGY9aS5hZGRJY29uU2V0KGEscixcImFsbFwiKTtpZihcImJvb2xlYW5cIj09dHlwZW9mIGYpcmV0dXJuO3ZhciBsPWhbbl07Zi5mb3JFYWNoKChmdW5jdGlvbihlKXtkZWxldGUgbFtlXX0pKSxkLmNvcmVNb2R1bGVzLmNhY2hlJiZkLmNvcmVNb2R1bGVzLmNhY2hlKGUscil9Y2F0Y2goZSl7Y29uc29sZS5lcnJvcihlKX0hZnVuY3Rpb24oZSxuKXt2b2lkIDA9PT1jW2VdJiYoY1tlXT1PYmplY3QuY3JlYXRlKG51bGwpKTt2YXIgdD1jW2VdO3Rbbl18fCh0W25dPSEwLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7dFtuXT0hMSx5LnVwZGF0ZUNhbGxiYWNrcyhlLG4pfSkpKX0oZSxuKX0pKX0pKX1lbHNlIGEoKX0pKSl9bi5BUEk9e2lzUGVuZGluZzpmdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09cltlLnByb3ZpZGVyXSYmdm9pZCAwIT09cltlLnByb3ZpZGVyXVtlLnByZWZpeF0mJnZvaWQgMCE9PXJbZS5wcm92aWRlcl1bZS5wcmVmaXhdW2UubmFtZV19LGxvYWRJY29uczpmdW5jdGlvbihlLG4pe3ZhciBvPXgubGlzdFRvSWNvbnMoZSwhMCxhLmFsbG93U2ltcGxlTmFtZXMoKSksaT1iLnNvcnRJY29ucyhvKTtpZighaS5wZW5kaW5nLmxlbmd0aCl7dmFyIGM9ITA7cmV0dXJuIG4mJnNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7YyYmbihpLmxvYWRlZCxpLm1pc3NpbmcsaS5wZW5kaW5nLHQpfSkpLGZ1bmN0aW9uKCl7Yz0hMX19dmFyIHUsZixsPU9iamVjdC5jcmVhdGUobnVsbCkscz1bXTtpLnBlbmRpbmcuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG49ZS5wcm92aWRlcix0PWUucHJlZml4O2lmKHQhPT1mfHxuIT09dSl7dT1uLGY9dCxzLnB1c2goe3Byb3ZpZGVyOm4scHJlZml4OnR9KSx2b2lkIDA9PT1yW25dJiYocltuXT1PYmplY3QuY3JlYXRlKG51bGwpKTt2YXIgbz1yW25dO3ZvaWQgMD09PW9bdF0mJihvW3RdPU9iamVjdC5jcmVhdGUobnVsbCkpLHZvaWQgMD09PWxbbl0mJihsW25dPU9iamVjdC5jcmVhdGUobnVsbCkpO3ZhciBpPWxbbl07dm9pZCAwPT09aVt0XSYmKGlbdF09W10pfX0pKTt2YXIgZD1EYXRlLm5vdygpO3JldHVybiBpLnBlbmRpbmcuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG49ZS5wcm92aWRlcix0PWUucHJlZml4LG89ZS5uYW1lLGk9cltuXVt0XTt2b2lkIDA9PT1pW29dJiYoaVtvXT1kLGxbbl1bdF0ucHVzaChvKSl9KSkscy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj1lLnByb3ZpZGVyLHQ9ZS5wcmVmaXg7bFtuXVt0XS5sZW5ndGgmJnYobix0LGxbbl1bdF0pfSkpLG4/eS5zdG9yZUNhbGxiYWNrKG4saSxzKTp0fX19KSksUD1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uQVBJSW50ZXJuYWxGdW5jdGlvbnM9bi5BUElGdW5jdGlvbnM9dm9pZCAwLG4uQVBJRnVuY3Rpb25zPXtsb2FkSWNvbnM6Ty5BUEkubG9hZEljb25zLGFkZEFQSVByb3ZpZGVyOmouc2V0QVBJQ29uZmlnfSxuLkFQSUludGVybmFsRnVuY3Rpb25zPXtnZXRBUEk6Ty5nZXRSZWR1bmRhbmN5Q2FjaGUsZ2V0QVBJQ29uZmlnOmouZ2V0QVBJQ29uZmlnLHNldEFQSU1vZHVsZTpJLnNldEFQSU1vZHVsZX19KSksdz1lKChmdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uZ2V0QVBJTW9kdWxlPXZvaWQgMDt2YXIgdD1udWxsLHI9XCJ7cHJlZml4fS5qcz9pY29ucz17aWNvbnN9JmNhbGxiYWNrPXtjYWxsYmFja31cIixvPU9iamVjdC5jcmVhdGUobnVsbCksaT1PYmplY3QuY3JlYXRlKG51bGwpO2Z1bmN0aW9uIGEoKXtpZihudWxsPT09dCl7dmFyIGU9c2VsZixuPVwiSWNvbmlmeVwiLG89XCIuY2JcIjtpZih2b2lkIDA9PT1lW25dKW89XCJcIix2b2lkIDA9PT1lW249XCJJY29uaWZ5SlNPTlBcIl0mJihlW25dPU9iamVjdC5jcmVhdGUobnVsbCkpLHQ9ZVtuXTtlbHNle3ZhciBpPWVbbl07dm9pZCAwPT09aS5jYiYmKGkuY2I9T2JqZWN0LmNyZWF0ZShudWxsKSksdD1pLmNifXI9ci5yZXBsYWNlKFwie2NhbGxiYWNrfVwiLG4rbytcIi57Y2J9XCIpfXJldHVybiB0fW4uZ2V0QVBJTW9kdWxlPWZ1bmN0aW9uKGUpe3JldHVybntwcmVwYXJlOmZ1bmN0aW9uKG4sdCxjKXt2YXIgdT1bXSxmPW9bbitcIjpcIit0XTt2b2lkIDA9PT1mJiYoZj1mdW5jdGlvbihuLHQpe3ZhciBjLHU9ZShuKTtpZighdSlyZXR1cm4gMDtpZih1Lm1heFVSTCl7dmFyIGY9MDt1LnJlc291cmNlcy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj1lO2Y9TWF0aC5tYXgoZixuLmxlbmd0aCl9KSksYSgpLGM9dS5tYXhVUkwtZi11LnBhdGgubGVuZ3RoLXIucmVwbGFjZShcIntwcm92aWRlcn1cIixuKS5yZXBsYWNlKFwie3ByZWZpeH1cIix0KS5yZXBsYWNlKFwie2ljb25zfVwiLFwiXCIpLmxlbmd0aC0zfWVsc2UgYz0wO3ZhciBsPW4rXCI6XCIrdDtyZXR1cm4gaVtsXT11LnBhdGgsb1tsXT1jLGN9KG4sdCkpO3ZhciBsPXtwcm92aWRlcjpuLHByZWZpeDp0LGljb25zOltdfSxzPTA7cmV0dXJuIGMuZm9yRWFjaCgoZnVuY3Rpb24oZSxyKXsocys9ZS5sZW5ndGgrMSk+PWYmJnI+MCYmKHUucHVzaChsKSxsPXtwcm92aWRlcjpuLHByZWZpeDp0LGljb25zOltdfSxzPWUubGVuZ3RoKSxsLmljb25zLnB1c2goZSl9KSksdS5wdXNoKGwpLHV9LHNlbmQ6ZnVuY3Rpb24oZSxuLHQpe2Zvcih2YXIgbz1uLnByb3ZpZGVyLGM9bi5wcmVmaXgsdT1uLmljb25zLmpvaW4oXCIsXCIpLGY9bytcIjpcIitjLGw9Yy5zcGxpdChcIi1cIikuc2hpZnQoKS5zbGljZSgwLDMpLHM9YSgpLGQ9ZnVuY3Rpb24oZSl7dmFyIG4sdD0wO2ZvcihuPWUubGVuZ3RoLTE7bj49MDtuLS0pdCs9ZS5jaGFyQ29kZUF0KG4pO3JldHVybiB0JTk5OX0obytcIjpcIitlK1wiOlwiK2MrXCI6XCIrdSk7dm9pZCAwIT09c1tsK2RdOylkKys7dmFyIHY9bCtkLHA9aVtmXStyLnJlcGxhY2UoXCJ7cHJvdmlkZXJ9XCIsbykucmVwbGFjZShcIntwcmVmaXh9XCIsYykucmVwbGFjZShcIntpY29uc31cIix1KS5yZXBsYWNlKFwie2NifVwiLHYpO3Nbdl09ZnVuY3Rpb24oZSl7ZGVsZXRlIHNbdl0sdC5kb25lKGUpfTt2YXIgaD1lK3AsZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2cudHlwZT1cInRleHQvamF2YXNjcmlwdFwiLGcuYXN5bmM9ITAsZy5zcmM9aCxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGcpfX19fSkpLE09ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmdldEFQSU1vZHVsZT1uLnNldEZldGNoPXZvaWQgMDt2YXIgdD1cIntwcmVmaXh9Lmpzb24/aWNvbnM9e2ljb25zfVwiLHI9T2JqZWN0LmNyZWF0ZShudWxsKSxvPU9iamVjdC5jcmVhdGUobnVsbCksaT1udWxsO3RyeXtpPWZldGNofWNhdGNoKGUpe31uLnNldEZldGNoPWZ1bmN0aW9uKGUpe2k9ZX07bi5nZXRBUElNb2R1bGU9ZnVuY3Rpb24oZSl7cmV0dXJue3ByZXBhcmU6ZnVuY3Rpb24obixpLGEpe3ZhciBjPVtdLHU9cltpXTt2b2lkIDA9PT11JiYodT1mdW5jdGlvbihuLGkpe3ZhciBhLGM9ZShuKTtpZighYylyZXR1cm4gMDtpZihjLm1heFVSTCl7dmFyIHU9MDtjLnJlc291cmNlcy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj1lO3U9TWF0aC5tYXgodSxuLmxlbmd0aCl9KSksYT1jLm1heFVSTC11LWMucGF0aC5sZW5ndGgtdC5yZXBsYWNlKFwie3Byb3ZpZGVyfVwiLG4pLnJlcGxhY2UoXCJ7cHJlZml4fVwiLGkpLnJlcGxhY2UoXCJ7aWNvbnN9XCIsXCJcIikubGVuZ3RofWVsc2UgYT0wO3ZhciBmPW4rXCI6XCIraTtyZXR1cm4gb1tmXT1jLnBhdGgscltmXT1hLGF9KG4saSkpO3ZhciBmPXtwcm92aWRlcjpuLHByZWZpeDppLGljb25zOltdfSxsPTA7cmV0dXJuIGEuZm9yRWFjaCgoZnVuY3Rpb24oZSx0KXsobCs9ZS5sZW5ndGgrMSk+PXUmJnQ+MCYmKGMucHVzaChmKSxmPXtwcm92aWRlcjpuLHByZWZpeDppLGljb25zOltdfSxsPWUubGVuZ3RoKSxmLmljb25zLnB1c2goZSl9KSksYy5wdXNoKGYpLGN9LHNlbmQ6ZnVuY3Rpb24oZSxuLHIpe3ZhciBhPW4ucHJvdmlkZXIsYz1uLnByZWZpeCx1PW4uaWNvbnMuam9pbihcIixcIiksZj1vW2ErXCI6XCIrY10rdC5yZXBsYWNlKFwie3Byb3ZpZGVyfVwiLGEpLnJlcGxhY2UoXCJ7cHJlZml4fVwiLGMpLnJlcGxhY2UoXCJ7aWNvbnN9XCIsdSk7aT9pKGUrZikudGhlbigoZnVuY3Rpb24oZSl7aWYoMjAwPT09ZS5zdGF0dXMpcmV0dXJuIGUuanNvbigpO3IuZG9uZSh2b2lkIDAsZS5zdGF0dXMpfSkpLnRoZW4oKGZ1bmN0aW9uKGUpe1wib2JqZWN0XCI9PXR5cGVvZiBlJiZudWxsIT09ZSYmci5kb25lKGUpfSkpLmNhdGNoKChmdW5jdGlvbihlKXtyLmRvbmUodm9pZCAwLGUuZXJybm8pfSkpOnIuZG9uZSh2b2lkIDAsNDI0KX19fX0pKSxBPVwiaWNvbmlmeUZpbmRlclwiK0RhdGUubm93KCksUz1cImljb25pZnlEYXRhXCIrRGF0ZS5ub3coKTtmdW5jdGlvbiBfKGUsbix0LHIpe3ZhciBvO3RyeXtvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpfWNhdGNoKGUpe3JldHVybiByP1wiXCI6bnVsbH12YXIgaT1sLmljb25Ub1NWRyh0LGYubWVyZ2VDdXN0b21pc2F0aW9ucyhmLmRlZmF1bHRzLG4pKSxhPWUuZWxlbWVudCx1PWUuZmluZGVyLHM9ZS5uYW1lLGQ9YT9hLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpOlwiXCIsdj11P3UuY2xhc3NGaWx0ZXIoZD9kLnNwbGl0KC9cXHMrLyk6W10pOltdLHA9JzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHJvbGU9XCJpbWdcIiBjbGFzcz1cIicrKFwiaWNvbmlmeSBpY29uaWZ5LS1cIitzLnByZWZpeCsoXCJcIj09PXMucHJvdmlkZXI/XCJcIjpcIiBpY29uaWZ5LS1cIitzLnByb3ZpZGVyKSsodi5sZW5ndGg/XCIgXCIrdi5qb2luKFwiIFwiKTpcIlwiKSkrJ1wiPicrYy5yZXBsYWNlSURzKGkuYm9keSkrXCI8L3N2Zz5cIjtvLmlubmVySFRNTD1wO3ZhciBoPW8uY2hpbGROb2Rlc1swXSxnPWguc3R5bGUsbT1pLmF0dHJpYnV0ZXM7aWYoT2JqZWN0LmtleXMobSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7aC5zZXRBdHRyaWJ1dGUoZSxtW2VdKX0pKSxpLmlubGluZSYmKGcudmVydGljYWxBbGlnbj1cIi0wLjEyNWVtXCIpLGEpe2Zvcih2YXIgYj1hLmF0dHJpYnV0ZXMseT0wO3k8Yi5sZW5ndGg7eSsrKXt2YXIgST1iLml0ZW0oeSk7aWYoSSl7dmFyIGo9SS5uYW1lO2lmKFwiY2xhc3NcIiE9PWomJlwic3R5bGVcIiE9PWomJnZvaWQgMD09PW1bal0pdHJ5e2guc2V0QXR0cmlidXRlKGosSS52YWx1ZSl9Y2F0Y2goZSl7fX19Zm9yKHZhciB4PWEuc3R5bGUsTz0wO088eC5sZW5ndGg7TysrKXt2YXIgUD14W09dO2dbUF09eFtQXX19aWYodSl7dmFyIHc9e25hbWU6cyxzdGF0dXM6XCJsb2FkZWRcIixjdXN0b21pc2F0aW9uczpufTtoW1NdPXcsaFtBXT11fXZhciBNPXI/by5pbm5lckhUTUw6aDtyZXR1cm4gYSYmYS5wYXJlbnROb2RlP2EucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoaCxhKTpvLnJlbW92ZUNoaWxkKGgpLE19dmFyIEU9W107ZnVuY3Rpb24gayhlKXtmb3IodmFyIG49MDtuPEUubGVuZ3RoO24rKyl7dmFyIHQ9RVtuXTtpZigoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5ub2RlP3Qubm9kZSgpOnQubm9kZSk9PT1lKXJldHVybiB0fX1mdW5jdGlvbiBDKGUsbil7dm9pZCAwPT09biYmKG49ITEpO3ZhciB0PWsoZSk7cmV0dXJuIHQ/KHQudGVtcG9yYXJ5JiYodC50ZW1wb3Jhcnk9biksdCk6KHQ9e25vZGU6ZSx0ZW1wb3Jhcnk6bn0sRS5wdXNoKHQpLHQpfWZ1bmN0aW9uIEYoKXtyZXR1cm4gRX12YXIgVD1udWxsLEQ9e2NoaWxkTGlzdDohMCxzdWJ0cmVlOiEwLGF0dHJpYnV0ZXM6ITB9O2Z1bmN0aW9uIE4oZSl7aWYoZS5vYnNlcnZlcil7dmFyIG49ZS5vYnNlcnZlcjtuLnBlbmRpbmdTY2FufHwobi5wZW5kaW5nU2Nhbj1zZXRUaW1lb3V0KChmdW5jdGlvbigpe2RlbGV0ZSBuLnBlbmRpbmdTY2FuLFQmJlQoZSl9KSkpfX1mdW5jdGlvbiBMKGUsbil7aWYoZS5vYnNlcnZlcil7dmFyIHQ9ZS5vYnNlcnZlcjtpZighdC5wZW5kaW5nU2Nhbilmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIG89bltyXTtpZihvLmFkZGVkTm9kZXMmJm8uYWRkZWROb2Rlcy5sZW5ndGg+MHx8XCJhdHRyaWJ1dGVzXCI9PT1vLnR5cGUmJnZvaWQgMCE9PW8udGFyZ2V0W0FdKXJldHVybiB2b2lkKHQucGF1c2VkfHxOKGUpKX19fWZ1bmN0aW9uIHooZSxuKXtlLm9ic2VydmVyLmluc3RhbmNlLm9ic2VydmUobixEKX1mdW5jdGlvbiBSKGUpe3ZhciBuPWUub2JzZXJ2ZXI7aWYoIW58fCFuLmluc3RhbmNlKXt2YXIgdD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLm5vZGU/ZS5ub2RlKCk6ZS5ub2RlO3QmJihufHwobj17cGF1c2VkOjB9LGUub2JzZXJ2ZXI9biksbi5pbnN0YW5jZT1uZXcgTXV0YXRpb25PYnNlcnZlcihMLmJpbmQobnVsbCxlKSkseihlLHQpLG4ucGF1c2VkfHxOKGUpKX19ZnVuY3Rpb24gcSgpe0YoKS5mb3JFYWNoKFIpfWZ1bmN0aW9uIFUoZSl7aWYoZS5vYnNlcnZlcil7dmFyIG49ZS5vYnNlcnZlcjtuLnBlbmRpbmdTY2FuJiYoY2xlYXJUaW1lb3V0KG4ucGVuZGluZ1NjYW4pLGRlbGV0ZSBuLnBlbmRpbmdTY2FuKSxuLmluc3RhbmNlJiYobi5pbnN0YW5jZS5kaXNjb25uZWN0KCksZGVsZXRlIG4uaW5zdGFuY2UpfX1mdW5jdGlvbiBWKGUpe3ZhciBuPW51bGwhPT1UO1QhPT1lJiYoVD1lLG4mJkYoKS5mb3JFYWNoKFUpKSxuP3EoKTpmdW5jdGlvbihlKXt2YXIgbj1kb2N1bWVudDtcImNvbXBsZXRlXCI9PT1uLnJlYWR5U3RhdGV8fFwibG9hZGluZ1wiIT09bi5yZWFkeVN0YXRlJiYhbi5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGw/ZSgpOihuLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsZSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsZSkpfShxKX1mdW5jdGlvbiBHKGUpeyhlP1tlXTpGKCkpLmZvckVhY2goKGZ1bmN0aW9uKGUpe2lmKGUub2JzZXJ2ZXIpe3ZhciBuPWUub2JzZXJ2ZXI7aWYobi5wYXVzZWQrKywhKG4ucGF1c2VkPjEpJiZuLmluc3RhbmNlKW4uaW5zdGFuY2UuZGlzY29ubmVjdCgpfWVsc2UgZS5vYnNlcnZlcj17cGF1c2VkOjF9fSkpfWZ1bmN0aW9uICQoZSl7KGU/W2VdOkYoKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7aWYoZS5vYnNlcnZlcil7dmFyIG49ZS5vYnNlcnZlcjtpZihuLnBhdXNlZCYmKG4ucGF1c2VkLS0sIW4ucGF1c2VkKSl7dmFyIHQ9XCJmdW5jdGlvblwiPT10eXBlb2YgZS5ub2RlP2Uubm9kZSgpOmUubm9kZTtpZighdClyZXR1cm47bi5pbnN0YW5jZT96KGUsdCk6UihlKX19ZWxzZSBSKGUpfSkpfWZ1bmN0aW9uIEIoZSxuKXt2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHQ9QyhlLG4pO3JldHVybiBSKHQpLHR9ZnVuY3Rpb24gUShlKXt2YXIgbj1rKGUpO24mJihVKG4pLGZ1bmN0aW9uKGUpe0U9RS5maWx0ZXIoKGZ1bmN0aW9uKG4pe3ZhciB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIG4ubm9kZT9uLm5vZGUoKTpuLm5vZGU7cmV0dXJuIGUhPT10fSkpfShlKSl9dmFyIEg9W107ZnVuY3Rpb24gSihlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9by5zdHJpbmdUb0ljb24oZSkpLG51bGwhPT1lJiZvLnZhbGlkYXRlSWNvbihlKT9lOm51bGx9ZnVuY3Rpb24gWShlKXt2YXIgbj1bXTtILmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciByPXQuZmluZChlKTtBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHIsKGZ1bmN0aW9uKGUpe3ZhciByPWU7aWYodm9pZCAwPT09cltBXXx8cltBXT09PXQpe3ZhciBvPUoodC5uYW1lKHIpKTtpZihudWxsIT09byl7cltBXT10O3ZhciBpPXtlbGVtZW50OnIsZmluZGVyOnQsbmFtZTpvfTtuLnB1c2goaSl9fX0pKX0pKTt2YXIgdD1lLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzdmcuaWNvbmlmeVwiKTtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbCh0LChmdW5jdGlvbihlKXt2YXIgdD1lLHI9dFtBXSxvPXRbU107aWYociYmbyl7dmFyIGk9SihyLm5hbWUodCkpO2lmKG51bGwhPT1pKXt2YXIgYSxjPSExO2lmKGkucHJlZml4IT09by5uYW1lLnByZWZpeHx8aS5uYW1lIT09by5uYW1lLm5hbWU/Yz0hMDooYT1yLmN1c3RvbWlzYXRpb25zKHQpLGZ1bmN0aW9uKGUsbil7dmFyIHQ9T2JqZWN0LmtleXMoZSkscj1PYmplY3Qua2V5cyhuKTtpZih0Lmxlbmd0aCE9PXIubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgbz0wO288dC5sZW5ndGg7bysrKXt2YXIgaT10W29dO2lmKG5baV0hPT1lW2ldKXJldHVybiExfXJldHVybiEwfShvLmN1c3RvbWlzYXRpb25zLGEpfHwoYz0hMCkpLGMpe3ZhciB1PXtlbGVtZW50OnQsZmluZGVyOnIsbmFtZTppLGN1c3RvbWlzYXRpb25zOmF9O24ucHVzaCh1KX19fX0pKSxufXZhciBaPSExO2Z1bmN0aW9uIEsoKXtafHwoWj0hMCxzZXRUaW1lb3V0KChmdW5jdGlvbigpe1omJihaPSExLFcoKSl9KSkpfWZ1bmN0aW9uIFcoZSxuKXt2b2lkIDA9PT1uJiYobj0hMSksWj0hMTt2YXIgdD1PYmplY3QuY3JlYXRlKG51bGwpO2lmKChlP1tlXTpGKCkpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIGUubm9kZT9lLm5vZGUoKTplLm5vZGU7aWYociYmci5xdWVyeVNlbGVjdG9yQWxsKXt2YXIgbz0hMSxhPSExO1kocikuZm9yRWFjaCgoZnVuY3Rpb24obil7dmFyIHIsYyx1PW4uZWxlbWVudCxmPW4ubmFtZSxsPWYucHJvdmlkZXIscz1mLnByZWZpeCx2PWYubmFtZSxwPXVbU107aWYodm9pZCAwIT09cCYmKHI9cC5uYW1lLGM9ZixudWxsIT09ciYmbnVsbCE9PWMmJnIubmFtZT09PWMubmFtZSYmci5wcmVmaXg9PT1jLnByZWZpeCkpc3dpdGNoKHAuc3RhdHVzKXtjYXNlXCJtaXNzaW5nXCI6cmV0dXJuO2Nhc2VcImxvYWRpbmdcIjppZihkLmNvcmVNb2R1bGVzLmFwaSYmZC5jb3JlTW9kdWxlcy5hcGkuaXNQZW5kaW5nKHtwcm92aWRlcjpsLHByZWZpeDpzLG5hbWU6dn0pKXJldHVybiB2b2lkKG89ITApfXZhciBoPWkuZ2V0U3RvcmFnZShsLHMpO2lmKHZvaWQgMD09PWguaWNvbnNbdl0pe2lmKGgubWlzc2luZ1t2XSlyZXR1cm4gcD17bmFtZTpmLHN0YXR1czpcIm1pc3NpbmdcIixjdXN0b21pc2F0aW9uczp7fX0sdm9pZCh1W1NdPXApO2lmKGQuY29yZU1vZHVsZXMuYXBpJiYhZC5jb3JlTW9kdWxlcy5hcGkuaXNQZW5kaW5nKHtwcm92aWRlcjpsLHByZWZpeDpzLG5hbWU6dn0pKXt2b2lkIDA9PT10W2xdJiYodFtsXT1PYmplY3QuY3JlYXRlKG51bGwpKTt2YXIgZz10W2xdO3ZvaWQgMD09PWdbc10mJihnW3NdPU9iamVjdC5jcmVhdGUobnVsbCkpLGdbc11bdl09ITB9cD17bmFtZTpmLHN0YXR1czpcImxvYWRpbmdcIixjdXN0b21pc2F0aW9uczp7fX0sdVtTXT1wLG89ITB9ZWxzZXshYSYmZS5vYnNlcnZlciYmKEcoZSksYT0hMCk7dmFyIG09dm9pZCAwIT09bi5jdXN0b21pc2F0aW9ucz9uLmN1c3RvbWlzYXRpb25zOm4uZmluZGVyLmN1c3RvbWlzYXRpb25zKHUpO18obixtLGkuZ2V0SWNvbihoLHYpKX19KSksZS50ZW1wb3JhcnkmJiFvP1Eocik6biYmbz9CKHIsITApOmEmJmUub2JzZXJ2ZXImJiQoZSl9fSkpLGQuY29yZU1vZHVsZXMuYXBpKXt2YXIgcj1kLmNvcmVNb2R1bGVzLmFwaTtPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj10W2VdO09iamVjdC5rZXlzKG4pLmZvckVhY2goKGZ1bmN0aW9uKHQpe3IubG9hZEljb25zKE9iamVjdC5rZXlzKG5bdF0pLm1hcCgoZnVuY3Rpb24obil7cmV0dXJue3Byb3ZpZGVyOmUscHJlZml4OnQsbmFtZTpufX0pKSxLKX0pKX0pKX19dmFyIFg9ZSgoZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnJvdGF0ZUZyb21TdHJpbmc9dm9pZCAwLG4ucm90YXRlRnJvbVN0cmluZz1mdW5jdGlvbihlKXt2YXIgbj1lLnJlcGxhY2UoL14tP1swLTkuXSovLFwiXCIpO2Z1bmN0aW9uIHQoZSl7Zm9yKDtlPDA7KWUrPTQ7cmV0dXJuIGUlNH1pZihcIlwiPT09bil7dmFyIHI9cGFyc2VJbnQoZSk7cmV0dXJuIGlzTmFOKHIpPzA6dChyKX1pZihuIT09ZSl7dmFyIG89MDtzd2l0Y2gobil7Y2FzZVwiJVwiOm89MjU7YnJlYWs7Y2FzZVwiZGVnXCI6bz05MH1pZihvKXt2YXIgaT1wYXJzZUZsb2F0KGUuc2xpY2UoMCxlLmxlbmd0aC1uLmxlbmd0aCkpO3JldHVybiBpc05hTihpKT8wOihpLz1vKSUxPT0wP3QoaSk6MH19cmV0dXJuIDB9fSkpLGVlPWUoKGZ1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5hbGlnbm1lbnRGcm9tU3RyaW5nPW4uZmxpcEZyb21TdHJpbmc9dm9pZCAwO3ZhciB0PS9bXFxzLF0rLztuLmZsaXBGcm9tU3RyaW5nPWZ1bmN0aW9uKGUsbil7bi5zcGxpdCh0KS5mb3JFYWNoKChmdW5jdGlvbihuKXtzd2l0Y2gobi50cmltKCkpe2Nhc2VcImhvcml6b250YWxcIjplLmhGbGlwPSEwO2JyZWFrO2Nhc2VcInZlcnRpY2FsXCI6ZS52RmxpcD0hMH19KSl9LG4uYWxpZ25tZW50RnJvbVN0cmluZz1mdW5jdGlvbihlLG4pe24uc3BsaXQodCkuZm9yRWFjaCgoZnVuY3Rpb24obil7dmFyIHQ9bi50cmltKCk7c3dpdGNoKHQpe2Nhc2VcImxlZnRcIjpjYXNlXCJjZW50ZXJcIjpjYXNlXCJyaWdodFwiOmUuaEFsaWduPXQ7YnJlYWs7Y2FzZVwidG9wXCI6Y2FzZVwibWlkZGxlXCI6Y2FzZVwiYm90dG9tXCI6ZS52QWxpZ249dDticmVhaztjYXNlXCJzbGljZVwiOmNhc2VcImNyb3BcIjplLnNsaWNlPSEwO2JyZWFrO2Nhc2VcIm1lZXRcIjplLnNsaWNlPSExfX0pKX19KSk7ZnVuY3Rpb24gbmUoZSxuKXtyZXR1cm4gZS5oYXNBdHRyaWJ1dGUobil9ZnVuY3Rpb24gdGUoZSxuKXtyZXR1cm4gZS5nZXRBdHRyaWJ1dGUobil9dmFyIHJlPVtcImlubGluZVwiLFwiaEZsaXBcIixcInZGbGlwXCJdLG9lPVtcIndpZHRoXCIsXCJoZWlnaHRcIl0saWU9XCJpY29uaWZ5LWlubGluZVwiLGFlPXtmaW5kOmZ1bmN0aW9uKGUpe3JldHVybiBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpLmljb25pZnksIHNwYW4uaWNvbmlmeSwgaS5pY29uaWZ5LWlubGluZSwgc3Bhbi5pY29uaWZ5LWlubGluZVwiKX0sbmFtZTpmdW5jdGlvbihlKXtyZXR1cm4gbmUoZSxcImRhdGEtaWNvblwiKT90ZShlLFwiZGF0YS1pY29uXCIpOm51bGx9LGN1c3RvbWlzYXRpb25zOmZ1bmN0aW9uKGUsbil7dm9pZCAwPT09biYmKG49e2lubGluZTohMX0pO3ZhciB0PW4scj1lLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO2lmKC0xIT09KHI/ci5zcGxpdCgvXFxzKy8pOltdKS5pbmRleE9mKGllKSYmKHQuaW5saW5lPSEwKSxuZShlLFwiZGF0YS1yb3RhdGVcIikpe3ZhciBvPVgucm90YXRlRnJvbVN0cmluZyh0ZShlLFwiZGF0YS1yb3RhdGVcIikpO28mJih0LnJvdGF0ZT1vKX1yZXR1cm4gbmUoZSxcImRhdGEtZmxpcFwiKSYmZWUuZmxpcEZyb21TdHJpbmcodCx0ZShlLFwiZGF0YS1mbGlwXCIpKSxuZShlLFwiZGF0YS1hbGlnblwiKSYmZWUuYWxpZ25tZW50RnJvbVN0cmluZyh0LHRlKGUsXCJkYXRhLWFsaWduXCIpKSxyZS5mb3JFYWNoKChmdW5jdGlvbihuKXtpZihuZShlLFwiZGF0YS1cIituKSl7dmFyIHI9ZnVuY3Rpb24oZSxuKXt2YXIgdD1lLmdldEF0dHJpYnV0ZShuKTtyZXR1cm4gdD09PW58fFwidHJ1ZVwiPT09dHx8XCJcIiE9PXQmJlwiZmFsc2VcIiE9PXQmJm51bGx9KGUsXCJkYXRhLVwiK24pO1wiYm9vbGVhblwiPT10eXBlb2YgciYmKHRbbl09cil9fSkpLG9lLmZvckVhY2goKGZ1bmN0aW9uKG4pe2lmKG5lKGUsXCJkYXRhLVwiK24pKXt2YXIgcj10ZShlLFwiZGF0YS1cIituKTtcIlwiIT09ciYmKHRbbl09cil9fSkpLHR9LGNsYXNzRmlsdGVyOmZ1bmN0aW9uKGUpe3ZhciBuPVtdO3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKGUpe1wiaWNvbmlmeVwiIT09ZSYmXCJcIiE9PWUmJlwiaWNvbmlmeS0tXCIhPT1lLnNsaWNlKDAsOSkmJm4ucHVzaChlKX0pKSxufX07ZnVuY3Rpb24gY2UoZSxuLHQpe3ZhciByPWEuZ2V0SWNvbkRhdGEoZSk7cmV0dXJuIHI/Xyh7bmFtZTpvLnN0cmluZ1RvSWNvbihlKX0sZi5tZXJnZUN1c3RvbWlzYXRpb25zKGYuZGVmYXVsdHMsXCJvYmplY3RcIj09dHlwZW9mIG4/bjp7fSkscix0KTpudWxsfXZhciB1ZT17Z2V0VmVyc2lvbjpmdW5jdGlvbigpe3JldHVyblwiMi4wLjRcIn0scmVuZGVyU1ZHOmZ1bmN0aW9uKGUsbil7cmV0dXJuIGNlKGUsbiwhMSl9LHJlbmRlckhUTUw6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gY2UoZSxuLCEwKX0scmVuZGVySWNvbjpmdW5jdGlvbihlLG4pe3ZhciB0PWEuZ2V0SWNvbkRhdGEoZSk7aWYoIXQpcmV0dXJuIG51bGw7dmFyIHI9Zi5tZXJnZUN1c3RvbWlzYXRpb25zKGYuZGVmYXVsdHMsXCJvYmplY3RcIj09dHlwZW9mIG4/bjp7fSk7cmV0dXJuIGwuaWNvblRvU1ZHKHQscil9LHNjYW46ZnVuY3Rpb24oZSl7ZT9mdW5jdGlvbihlKXt2YXIgbj1rKGUpO24/VyhuKTpXKHtub2RlOmUsdGVtcG9yYXJ5OiEwfSwhMCl9KGUpOlcoKX0sb2JzZXJ2ZTpmdW5jdGlvbihlKXtCKGUpfSxzdG9wT2JzZXJ2aW5nOmZ1bmN0aW9uKGUpe1EoZSl9LHBhdXNlT2JzZXJ2ZXI6ZnVuY3Rpb24oZSl7aWYoZSl7dmFyIG49ayhlKTtuJiZHKG4pfWVsc2UgRygpfSxyZXN1bWVPYnNlcnZlcjpmdW5jdGlvbihlKXtpZihlKXt2YXIgbj1rKGUpO24mJiQobil9ZWxzZSAkKCl9fTtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cpeyFmdW5jdGlvbigpe2lmKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudClyZXR1cm4gQyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO0UucHVzaCh7bm9kZTpmdW5jdGlvbigpe3JldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnR9fSl9KCksZnVuY3Rpb24oZSl7LTE9PT1ILmluZGV4T2YoZSkmJkgucHVzaChlKX0oYWUpO3ZhciBmZT13aW5kb3c7aWYodm9pZCAwIT09ZmUuSWNvbmlmeVByZWxvYWQpe3ZhciBsZT1mZS5JY29uaWZ5UHJlbG9hZCxzZT1cIkludmFsaWQgSWNvbmlmeVByZWxvYWQgc3ludGF4LlwiO1wib2JqZWN0XCI9PXR5cGVvZiBsZSYmbnVsbCE9PWxlJiYobGUgaW5zdGFuY2VvZiBBcnJheT9sZTpbbGVdKS5mb3JFYWNoKChmdW5jdGlvbihlKXt0cnl7KFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZXx8ZSBpbnN0YW5jZW9mIEFycmF5fHxcIm9iamVjdFwiIT10eXBlb2YgZS5pY29uc3x8XCJzdHJpbmdcIiE9dHlwZW9mIGUucHJlZml4fHwhYS5zdG9yYWdlRnVuY3Rpb25zLmFkZENvbGxlY3Rpb24oZSkpJiZjb25zb2xlLmVycm9yKHNlKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKHNlKX19KSl9c2V0VGltZW91dCgoZnVuY3Rpb24oKXtWKFcpLFcoKX0pKX12YXIgZGU9e2VuYWJsZUNhY2hlOmZ1bmN0aW9uKGUsbil7cmV0dXJuIHAudG9nZ2xlQnJvd3NlckNhY2hlKGUsITEhPT1uKX0sZGlzYWJsZUNhY2hlOmZ1bmN0aW9uKGUpe3JldHVybiBwLnRvZ2dsZUJyb3dzZXJDYWNoZShlLCEwKX19LHZlPXtfYXBpOlAuQVBJSW50ZXJuYWxGdW5jdGlvbnN9O1thLnN0b3JhZ2VGdW5jdGlvbnMscy5idWlsZGVyRnVuY3Rpb25zLHVlLGRlLFAuQVBJRnVuY3Rpb25zXS5mb3JFYWNoKChmdW5jdGlvbihlKXtmb3IodmFyIG4gaW4gZSl2ZVtuXT1lW25dfSkpLGQuY29yZU1vZHVsZXMuYXBpPU8uQVBJO3ZhciBwZT1NLmdldEFQSU1vZHVsZTt0cnl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiYocGU9XCJmdW5jdGlvblwiPT10eXBlb2YgZmV0Y2gmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFByb21pc2U/TS5nZXRBUElNb2R1bGU6dy5nZXRBUElNb2R1bGUpfWNhdGNoKHNlKXt9aWYoSS5zZXRBUElNb2R1bGUoXCJcIixwZShqLmdldEFQSUNvbmZpZykpLHZlLl9hcGkuc2V0RmV0Y2g9ZnVuY3Rpb24oZSl7TS5zZXRGZXRjaChlKSxwZSE9PU0uZ2V0QVBJTW9kdWxlJiYocGU9TS5nZXRBUElNb2R1bGUsSS5zZXRBUElNb2R1bGUoXCJcIixwZShqLmdldEFQSUNvbmZpZykpKX0sXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93KXtkLmNvcmVNb2R1bGVzLmNhY2hlPXYuc3RvcmVDYWNoZSx2LmxvYWRDYWNoZSgpO3ZhciBoZT13aW5kb3c7aWYodm9pZCAwIT09aGUuSWNvbmlmeVByb3ZpZGVycyl7dmFyIGdlPWhlLkljb25pZnlQcm92aWRlcnM7aWYoXCJvYmplY3RcIj09dHlwZW9mIGdlJiZudWxsIT09Z2UpZm9yKHZhciBtZSBpbiBnZSl7dmFyIGJlPVwiSWNvbmlmeVByb3ZpZGVyc1tcIittZStcIl0gaXMgaW52YWxpZC5cIjt0cnl7dmFyIHllPWdlW21lXTtpZihcIm9iamVjdFwiIT10eXBlb2YgeWV8fCF5ZXx8dm9pZCAwPT09eWUucmVzb3VyY2VzKWNvbnRpbnVlO2ouc2V0QVBJQ29uZmlnKG1lLHllKXx8Y29uc29sZS5lcnJvcihiZSl9Y2F0Y2goZSl7Y29uc29sZS5lcnJvcihiZSl9fX19cmV0dXJuIHZlfSgpO3RyeXt2b2lkIDA9PT1zZWxmLkljb25pZnkmJihzZWxmLkljb25pZnk9SWNvbmlmeSl9Y2F0Y2goZSl7fWlmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzKXRyeXtleHBvcnRzLl9fZXNNb2R1bGU9ITAsZXhwb3J0cy5kZWZhdWx0PUljb25pZnl9Y2F0Y2goZSl7fVxuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2dldFVybC5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fID0gbmV3IFVSTChcImltYWdlcy9sYXllcnMucG5nXCIsIGltcG9ydC5tZXRhLnVybCk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzFfX18gPSBuZXcgVVJMKFwiaW1hZ2VzL2xheWVycy0yeC5wbmdcIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMl9fXyA9IG5ldyBVUkwoXCJpbWFnZXMvbWFya2VyLWljb24ucG5nXCIsIGltcG9ydC5tZXRhLnVybCk7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzFfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8xX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8yX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMl9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKiByZXF1aXJlZCBzdHlsZXMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1wYW5lLFxcclxcbi5sZWFmbGV0LXRpbGUsXFxyXFxuLmxlYWZsZXQtbWFya2VyLWljb24sXFxyXFxuLmxlYWZsZXQtbWFya2VyLXNoYWRvdyxcXHJcXG4ubGVhZmxldC10aWxlLWNvbnRhaW5lcixcXHJcXG4ubGVhZmxldC1wYW5lID4gc3ZnLFxcclxcbi5sZWFmbGV0LXBhbmUgPiBjYW52YXMsXFxyXFxuLmxlYWZsZXQtem9vbS1ib3gsXFxyXFxuLmxlYWZsZXQtaW1hZ2UtbGF5ZXIsXFxyXFxuLmxlYWZsZXQtbGF5ZXIge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHRsZWZ0OiAwO1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10aWxlLFxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3cge1xcclxcblxcdC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0ICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdCAgLXdlYmtpdC11c2VyLWRyYWc6IG5vbmU7XFxyXFxuXFx0fVxcclxcbi8qIFByZXZlbnRzIElFMTEgZnJvbSBoaWdobGlnaHRpbmcgdGlsZXMgaW4gYmx1ZSAqL1xcclxcbi5sZWFmbGV0LXRpbGU6OnNlbGVjdGlvbiB7XFxyXFxuXFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcbi8qIFNhZmFyaSByZW5kZXJzIG5vbi1yZXRpbmEgdGlsZSBvbiByZXRpbmEgYmV0dGVyIHdpdGggdGhpcywgYnV0IENocm9tZSBpcyB3b3JzZSAqL1xcclxcbi5sZWFmbGV0LXNhZmFyaSAubGVhZmxldC10aWxlIHtcXHJcXG5cXHRpbWFnZS1yZW5kZXJpbmc6IC13ZWJraXQtb3B0aW1pemUtY29udHJhc3Q7XFxyXFxuXFx0fVxcclxcbi8qIGhhY2sgdGhhdCBwcmV2ZW50cyBodyBsYXllcnMgXFxcInN0cmV0Y2hpbmdcXFwiIHdoZW4gbG9hZGluZyBuZXcgdGlsZXMgKi9cXHJcXG4ubGVhZmxldC1zYWZhcmkgLmxlYWZsZXQtdGlsZS1jb250YWluZXIge1xcclxcblxcdHdpZHRoOiAxNjAwcHg7XFxyXFxuXFx0aGVpZ2h0OiAxNjAwcHg7XFxyXFxuXFx0LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiAwIDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3cge1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdH1cXHJcXG4vKiAubGVhZmxldC1jb250YWluZXIgc3ZnOiByZXNldCBzdmcgbWF4LXdpZHRoIGRlY2xlcmF0aW9uIHNoaXBwZWQgaW4gSm9vbWxhISAoam9vbWxhLm9yZykgMy54ICovXFxyXFxuLyogLmxlYWZsZXQtY29udGFpbmVyIGltZzogbWFwIGlzIGJyb2tlbiBpbiBGRiBpZiB5b3UgaGF2ZSBtYXgtd2lkdGg6IDEwMCUgb24gdGlsZXMgKi9cXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2ZyxcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtbWFya2VyLXBhbmUgaW1nLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1zaGFkb3ctcGFuZSBpbWcsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LXRpbGUtcGFuZSBpbWcsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGltZy5sZWFmbGV0LWltYWdlLWxheWVyLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC10aWxlIHtcXHJcXG5cXHRtYXgtd2lkdGg6IG5vbmUgIWltcG9ydGFudDtcXHJcXG5cXHRtYXgtaGVpZ2h0OiBub25lICFpbXBvcnRhbnQ7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLXpvb20ge1xcclxcblxcdC1tcy10b3VjaC1hY3Rpb246IHBhbi14IHBhbi15O1xcclxcblxcdHRvdWNoLWFjdGlvbjogcGFuLXggcGFuLXk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLWRyYWcge1xcclxcblxcdC1tcy10b3VjaC1hY3Rpb246IHBpbmNoLXpvb207XFxyXFxuXFx0LyogRmFsbGJhY2sgZm9yIEZGIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwaW5jaC16b29tICovXFxyXFxuXFx0dG91Y2gtYWN0aW9uOiBub25lO1xcclxcblxcdHRvdWNoLWFjdGlvbjogcGluY2gtem9vbTtcXHJcXG59XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyLmxlYWZsZXQtdG91Y2gtZHJhZy5sZWFmbGV0LXRvdWNoLXpvb20ge1xcclxcblxcdC1tcy10b3VjaC1hY3Rpb246IG5vbmU7XFxyXFxuXFx0dG91Y2gtYWN0aW9uOiBub25lO1xcclxcbn1cXHJcXG4ubGVhZmxldC1jb250YWluZXIge1xcclxcblxcdC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhIHtcXHJcXG5cXHQtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoNTEsIDE4MSwgMjI5LCAwLjQpO1xcclxcbn1cXHJcXG4ubGVhZmxldC10aWxlIHtcXHJcXG5cXHRmaWx0ZXI6IGluaGVyaXQ7XFxyXFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10aWxlLWxvYWRlZCB7XFxyXFxuXFx0dmlzaWJpbGl0eTogaW5oZXJpdDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1ib3gge1xcclxcblxcdHdpZHRoOiAwO1xcclxcblxcdGhlaWdodDogMDtcXHJcXG5cXHQtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuXFx0ICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcdHotaW5kZXg6IDgwMDtcXHJcXG5cXHR9XFxyXFxuLyogd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg4MzE5ICovXFxyXFxuLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2ZyB7XFxyXFxuXFx0LW1vei11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtcGFuZSAgICAgICAgIHsgei1pbmRleDogNDAwOyB9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdGlsZS1wYW5lICAgIHsgei1pbmRleDogMjAwOyB9XFxyXFxuLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHsgei1pbmRleDogNDAwOyB9XFxyXFxuLmxlYWZsZXQtc2hhZG93LXBhbmUgIHsgei1pbmRleDogNTAwOyB9XFxyXFxuLmxlYWZsZXQtbWFya2VyLXBhbmUgIHsgei1pbmRleDogNjAwOyB9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1wYW5lICAgeyB6LWluZGV4OiA2NTA7IH1cXHJcXG4ubGVhZmxldC1wb3B1cC1wYW5lICAgeyB6LWluZGV4OiA3MDA7IH1cXHJcXG5cXHJcXG4ubGVhZmxldC1tYXAtcGFuZSBjYW52YXMgeyB6LWluZGV4OiAxMDA7IH1cXHJcXG4ubGVhZmxldC1tYXAtcGFuZSBzdmcgICAgeyB6LWluZGV4OiAyMDA7IH1cXHJcXG5cXHJcXG4ubGVhZmxldC12bWwtc2hhcGUge1xcclxcblxcdHdpZHRoOiAxcHg7XFxyXFxuXFx0aGVpZ2h0OiAxcHg7XFxyXFxuXFx0fVxcclxcbi5sdm1sIHtcXHJcXG5cXHRiZWhhdmlvcjogdXJsKCNkZWZhdWx0I1ZNTCk7XFxyXFxuXFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogY29udHJvbCBwb3NpdGlvbmluZyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG5cXHR6LWluZGV4OiA4MDA7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IHZpc2libGVQYWludGVkOyAvKiBJRSA5LTEwIGRvZXNuJ3QgaGF2ZSBhdXRvICovXFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvcCxcXHJcXG4ubGVhZmxldC1ib3R0b20ge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR6LWluZGV4OiAxMDAwO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3Age1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmlnaHQge1xcclxcblxcdHJpZ2h0OiAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1ib3R0b20ge1xcclxcblxcdGJvdHRvbTogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtbGVmdCB7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0ZmxvYXQ6IGxlZnQ7XFxyXFxuXFx0Y2xlYXI6IGJvdGg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJpZ2h0IC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGZsb2F0OiByaWdodDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9wIC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdG1hcmdpbi10b3A6IDEwcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJvdHRvbSAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1sZWZ0IC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdG1hcmdpbi1sZWZ0OiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1yaWdodCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tcmlnaHQ6IDEwcHg7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIHpvb20gYW5kIGZhZGUgYW5pbWF0aW9ucyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWZhZGUtYW5pbSAubGVhZmxldC10aWxlIHtcXHJcXG5cXHR3aWxsLWNoYW5nZTogb3BhY2l0eTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZmFkZS1hbmltIC5sZWFmbGV0LXBvcHVwIHtcXHJcXG5cXHRvcGFjaXR5OiAwO1xcclxcblxcdC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGxpbmVhcjtcXHJcXG5cXHQgICAtbW96LXRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBsaW5lYXI7XFxyXFxuXFx0ICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgbGluZWFyO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtbWFwLXBhbmUgLmxlYWZsZXQtcG9wdXAge1xcclxcblxcdG9wYWNpdHk6IDE7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYW5pbWF0ZWQge1xcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdCAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdCAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWFuaW0gLmxlYWZsZXQtem9vbS1hbmltYXRlZCB7XFxyXFxuXFx0d2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20tYW5pbWF0ZWQge1xcclxcblxcdC13ZWJraXQtdHJhbnNpdGlvbjogLXdlYmtpdC10cmFuc2Zvcm0gMC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwwLjI1LDEpO1xcclxcblxcdCAgIC1tb3otdHJhbnNpdGlvbjogICAgLW1vei10cmFuc2Zvcm0gMC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwwLjI1LDEpO1xcclxcblxcdCAgICAgICAgdHJhbnNpdGlvbjogICAgICAgICB0cmFuc2Zvcm0gMC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwwLjI1LDEpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWFuaW0gLmxlYWZsZXQtdGlsZSxcXHJcXG4ubGVhZmxldC1wYW4tYW5pbSAubGVhZmxldC10aWxlIHtcXHJcXG5cXHQtd2Via2l0LXRyYW5zaXRpb246IG5vbmU7XFxyXFxuXFx0ICAgLW1vei10cmFuc2l0aW9uOiBub25lO1xcclxcblxcdCAgICAgICAgdHJhbnNpdGlvbjogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20taGlkZSB7XFxyXFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBjdXJzb3JzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtaW50ZXJhY3RpdmUge1xcclxcblxcdGN1cnNvcjogcG9pbnRlcjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZ3JhYiB7XFxyXFxuXFx0Y3Vyc29yOiAtd2Via2l0LWdyYWI7XFxyXFxuXFx0Y3Vyc29yOiAgICAtbW96LWdyYWI7XFxyXFxuXFx0Y3Vyc29yOiAgICAgICAgIGdyYWI7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNyb3NzaGFpcixcXHJcXG4ubGVhZmxldC1jcm9zc2hhaXIgLmxlYWZsZXQtaW50ZXJhY3RpdmUge1xcclxcblxcdGN1cnNvcjogY3Jvc3NoYWlyO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1wYW5lLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGN1cnNvcjogYXV0bztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtZ3JhYixcXHJcXG4ubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1ncmFiIC5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbi5sZWFmbGV0LWRyYWdnaW5nIC5sZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUge1xcclxcblxcdGN1cnNvcjogbW92ZTtcXHJcXG5cXHRjdXJzb3I6IC13ZWJraXQtZ3JhYmJpbmc7XFxyXFxuXFx0Y3Vyc29yOiAgICAtbW96LWdyYWJiaW5nO1xcclxcblxcdGN1cnNvcjogICAgICAgICBncmFiYmluZztcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogbWFya2VyICYgb3ZlcmxheXMgaW50ZXJhY3Rpdml0eSAqL1xcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3csXFxyXFxuLmxlYWZsZXQtaW1hZ2UtbGF5ZXIsXFxyXFxuLmxlYWZsZXQtcGFuZSA+IHN2ZyBwYXRoLFxcclxcbi5sZWFmbGV0LXRpbGUtY29udGFpbmVyIHtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtbWFya2VyLWljb24ubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG4ubGVhZmxldC1pbWFnZS1sYXllci5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbi5sZWFmbGV0LXBhbmUgPiBzdmcgcGF0aC5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbnN2Zy5sZWFmbGV0LWltYWdlLWxheWVyLmxlYWZsZXQtaW50ZXJhY3RpdmUgcGF0aCB7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IHZpc2libGVQYWludGVkOyAvKiBJRSA5LTEwIGRvZXNuJ3QgaGF2ZSBhdXRvICovXFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIHZpc3VhbCB0d2Vha3MgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250YWluZXIge1xcclxcblxcdGJhY2tncm91bmQ6ICNkZGQ7XFxyXFxuXFx0b3V0bGluZTogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEge1xcclxcblxcdGNvbG9yOiAjMDA3OEE4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LWFjdGl2ZSB7XFxyXFxuXFx0b3V0bGluZTogMnB4IHNvbGlkIG9yYW5nZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1ib3gge1xcclxcblxcdGJvcmRlcjogMnB4IGRvdHRlZCAjMzhmO1xcclxcblxcdGJhY2tncm91bmQ6IHJnYmEoMjU1LDI1NSwyNTUsMC41KTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogZ2VuZXJhbCB0eXBvZ3JhcGh5ICovXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHRmb250OiAxMnB4LzEuNSBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBnZW5lcmFsIHRvb2xiYXIgc3R5bGVzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtYmFyIHtcXHJcXG5cXHRib3gtc2hhZG93OiAwIDFweCA1cHggcmdiYSgwLDAsMCwwLjY1KTtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiA0cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhLFxcclxcbi5sZWFmbGV0LWJhciBhOmhvdmVyIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcclxcblxcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjO1xcclxcblxcdHdpZHRoOiAyNnB4O1xcclxcblxcdGhlaWdodDogMjZweDtcXHJcXG5cXHRsaW5lLWhlaWdodDogMjZweDtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcblxcdGNvbG9yOiBibGFjaztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYmFyIGEsXFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiA1MCUgNTAlO1xcclxcblxcdGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhOmhvdmVyIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYTpmaXJzdC1jaGlsZCB7XFxyXFxuXFx0Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNHB4O1xcclxcblxcdGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhOmxhc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDRweDtcXHJcXG5cXHRib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNHB4O1xcclxcblxcdGJvcmRlci1ib3R0b206IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhLmxlYWZsZXQtZGlzYWJsZWQge1xcclxcblxcdGN1cnNvcjogZGVmYXVsdDtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xcclxcblxcdGNvbG9yOiAjYmJiO1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYSB7XFxyXFxuXFx0d2lkdGg6IDMwcHg7XFxyXFxuXFx0aGVpZ2h0OiAzMHB4O1xcclxcblxcdGxpbmUtaGVpZ2h0OiAzMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYTpmaXJzdC1jaGlsZCB7XFxyXFxuXFx0Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMnB4O1xcclxcblxcdGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAycHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciBhOmxhc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDJweDtcXHJcXG5cXHRib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMnB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiB6b29tIGNvbnRyb2wgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250cm9sLXpvb20taW4sXFxyXFxuLmxlYWZsZXQtY29udHJvbC16b29tLW91dCB7XFxyXFxuXFx0Zm9udDogYm9sZCAxOHB4ICdMdWNpZGEgQ29uc29sZScsIE1vbmFjbywgbW9ub3NwYWNlO1xcclxcblxcdHRleHQtaW5kZW50OiAxcHg7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtem9vbS1pbiwgLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC16b29tLW91dCAge1xcclxcblxcdGZvbnQtc2l6ZTogMjJweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogbGF5ZXJzIGNvbnRyb2wgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycyB7XFxyXFxuXFx0Ym94LXNoYWRvdzogMCAxcHggNXB4IHJnYmEoMCwwLDAsMC40KTtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdGJvcmRlci1yYWRpdXM6IDVweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8wX19fICsgXCIpO1xcclxcblxcdHdpZHRoOiAzNnB4O1xcclxcblxcdGhlaWdodDogMzZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmV0aW5hIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMV9fXyArIFwiKTtcXHJcXG5cXHRiYWNrZ3JvdW5kLXNpemU6IDI2cHggMjZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHR3aWR0aDogNDRweDtcXHJcXG5cXHRoZWlnaHQ6IDQ0cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWxpc3QsXFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRkaXNwbGF5OiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCAubGVhZmxldC1jb250cm9sLWxheWVycy1saXN0IHtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkIHtcXHJcXG5cXHRwYWRkaW5nOiA2cHggMTBweCA2cHggNnB4O1xcclxcblxcdGNvbG9yOiAjMzMzO1xcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhciB7XFxyXFxuXFx0b3ZlcmZsb3cteTogc2Nyb2xsO1xcclxcblxcdG92ZXJmbG93LXg6IGhpZGRlbjtcXHJcXG5cXHRwYWRkaW5nLXJpZ2h0OiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiAycHg7XFxyXFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcclxcblxcdHRvcDogMXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycyBsYWJlbCB7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlcGFyYXRvciB7XFxyXFxuXFx0aGVpZ2h0OiAwO1xcclxcblxcdGJvcmRlci10b3A6IDFweCBzb2xpZCAjZGRkO1xcclxcblxcdG1hcmdpbjogNXB4IC0xMHB4IDVweCAtNnB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiBEZWZhdWx0IGljb24gVVJMcyAqL1xcclxcbi5sZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8yX19fICsgXCIpO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBhdHRyaWJ1dGlvbiBhbmQgc2NhbGUgY29udHJvbHMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiB7XFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHRiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyk7XFxyXFxuXFx0bWFyZ2luOiAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZSB7XFxyXFxuXFx0cGFkZGluZzogMCA1cHg7XFxyXFxuXFx0Y29sb3I6ICMzMzM7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24gYSB7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uIGE6aG92ZXIge1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbixcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtY29udHJvbC1zY2FsZSB7XFxyXFxuXFx0Zm9udC1zaXplOiAxMXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1sZWZ0IC5sZWFmbGV0LWNvbnRyb2wtc2NhbGUge1xcclxcblxcdG1hcmdpbi1sZWZ0OiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJvdHRvbSAubGVhZmxldC1jb250cm9sLXNjYWxlIHtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZSB7XFxyXFxuXFx0Ym9yZGVyOiAycHggc29saWQgIzc3NztcXHJcXG5cXHRib3JkZXItdG9wOiBub25lO1xcclxcblxcdGxpbmUtaGVpZ2h0OiAxLjE7XFxyXFxuXFx0cGFkZGluZzogMnB4IDVweCAxcHg7XFxyXFxuXFx0Zm9udC1zaXplOiAxMXB4O1xcclxcblxcdHdoaXRlLXNwYWNlOiBub3dyYXA7XFxyXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG5cXHQtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuXFx0ICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0YmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmU6bm90KDpmaXJzdC1jaGlsZCkge1xcclxcblxcdGJvcmRlci10b3A6IDJweCBzb2xpZCAjNzc3O1xcclxcblxcdGJvcmRlci1ib3R0b206IG5vbmU7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTJweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1zY2FsZS1saW5lOm5vdCg6Zmlyc3QtY2hpbGQpOm5vdCg6bGFzdC1jaGlsZCkge1xcclxcblxcdGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAjNzc3O1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uLFxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLFxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciB7XFxyXFxuXFx0Ym94LXNoYWRvdzogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMsXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIHtcXHJcXG5cXHRib3JkZXI6IDJweCBzb2xpZCByZ2JhKDAsMCwwLDAuMik7XFxyXFxuXFx0YmFja2dyb3VuZC1jbGlwOiBwYWRkaW5nLWJveDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogcG9wdXAgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1wb3B1cCB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAyMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXIge1xcclxcblxcdHBhZGRpbmc6IDFweDtcXHJcXG5cXHR0ZXh0LWFsaWduOiBsZWZ0O1xcclxcblxcdGJvcmRlci1yYWRpdXM6IDEycHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQge1xcclxcblxcdG1hcmdpbjogMTNweCAxOXB4O1xcclxcblxcdGxpbmUtaGVpZ2h0OiAxLjQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQgcCB7XFxyXFxuXFx0bWFyZ2luOiAxOHB4IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXIge1xcclxcblxcdHdpZHRoOiA0MHB4O1xcclxcblxcdGhlaWdodDogMjBweDtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0bGVmdDogNTAlO1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtMjBweDtcXHJcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC10aXAge1xcclxcblxcdHdpZHRoOiAxN3B4O1xcclxcblxcdGhlaWdodDogMTdweDtcXHJcXG5cXHRwYWRkaW5nOiAxcHg7XFxyXFxuXFxyXFxuXFx0bWFyZ2luOiAtMTBweCBhdXRvIDA7XFxyXFxuXFxyXFxuXFx0LXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0ICAgLW1vei10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0ICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0ICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlcixcXHJcXG4ubGVhZmxldC1wb3B1cC10aXAge1xcclxcblxcdGJhY2tncm91bmQ6IHdoaXRlO1xcclxcblxcdGNvbG9yOiAjMzMzO1xcclxcblxcdGJveC1zaGFkb3c6IDAgM3B4IDE0cHggcmdiYSgwLDAsMCwwLjQpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LXBvcHVwLWNsb3NlLWJ1dHRvbiB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHRyaWdodDogMDtcXHJcXG5cXHRwYWRkaW5nOiA0cHggNHB4IDAgMDtcXHJcXG5cXHRib3JkZXI6IG5vbmU7XFxyXFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcclxcblxcdHdpZHRoOiAxOHB4O1xcclxcblxcdGhlaWdodDogMTRweDtcXHJcXG5cXHRmb250OiAxNnB4LzE0cHggVGFob21hLCBWZXJkYW5hLCBzYW5zLXNlcmlmO1xcclxcblxcdGNvbG9yOiAjYzNjM2MzO1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG5cXHRmb250LXdlaWdodDogYm9sZDtcXHJcXG5cXHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b246aG92ZXIge1xcclxcblxcdGNvbG9yOiAjOTk5O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1zY3JvbGxlZCB7XFxyXFxuXFx0b3ZlcmZsb3c6IGF1dG87XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkZGQ7XFxyXFxuXFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkICNkZGQ7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlciB7XFxyXFxuXFx0em9vbTogMTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtdGlwIHtcXHJcXG5cXHR3aWR0aDogMjRweDtcXHJcXG5cXHRtYXJnaW46IDAgYXV0bztcXHJcXG5cXHJcXG5cXHQtbXMtZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9MC43MDcxMDY3OCwgTTEyPTAuNzA3MTA2NzgsIE0yMT0tMC43MDcxMDY3OCwgTTIyPTAuNzA3MTA2NzgpXFxcIjtcXHJcXG5cXHRmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPTAuNzA3MTA2NzgsIE0xMj0wLjcwNzEwNjc4LCBNMjE9LTAuNzA3MTA2NzgsIE0yMj0wLjcwNzEwNjc4KTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtdGlwLWNvbnRhaW5lciB7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTFweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtY29udHJvbC16b29tLFxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLFxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlcixcXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC10aXAge1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICM5OTk7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGRpdiBpY29uICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtZGl2LWljb24ge1xcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgIzY2NjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogVG9vbHRpcCAqL1xcclxcbi8qIEJhc2Ugc3R5bGVzIGZvciB0aGUgZWxlbWVudCB0aGF0IGhhcyBhIHRvb2x0aXAgKi9cXHJcXG4ubGVhZmxldC10b29sdGlwIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0cGFkZGluZzogNnB4O1xcclxcblxcdGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxyXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgI2ZmZjtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiAzcHg7XFxyXFxuXFx0Y29sb3I6ICMyMjI7XFxyXFxuXFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcXHJcXG5cXHQtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0LW1zLXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdHVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdGJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsMCwwLDAuNCk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAubGVhZmxldC1jbGlja2FibGUge1xcclxcblxcdGN1cnNvcjogcG9pbnRlcjtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogYXV0bztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtYm90dG9tOmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQ6YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcmlnaHQ6YmVmb3JlIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0Ym9yZGVyOiA2cHggc29saWQgdHJhbnNwYXJlbnQ7XFxyXFxuXFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxuXFx0Y29udGVudDogXFxcIlxcXCI7XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIERpcmVjdGlvbnMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC10b29sdGlwLWJvdHRvbSB7XFxyXFxuXFx0bWFyZ2luLXRvcDogNnB4O1xcclxcbn1cXHJcXG4ubGVhZmxldC10b29sdGlwLXRvcCB7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1ib3R0b206YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtdG9wOmJlZm9yZSB7XFxyXFxuXFx0bGVmdDogNTAlO1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtNnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLXRvcDpiZWZvcmUge1xcclxcblxcdGJvdHRvbTogMDtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAtMTJweDtcXHJcXG5cXHRib3JkZXItdG9wLWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLWJvdHRvbTpiZWZvcmUge1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtMTJweDtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTZweDtcXHJcXG5cXHRib3JkZXItYm90dG9tLWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQge1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtNnB4O1xcclxcbn1cXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0IHtcXHJcXG5cXHRtYXJnaW4tbGVmdDogNnB4O1xcclxcbn1cXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQ6YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcmlnaHQ6YmVmb3JlIHtcXHJcXG5cXHR0b3A6IDUwJTtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtNnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQ6YmVmb3JlIHtcXHJcXG5cXHRyaWdodDogMDtcXHJcXG5cXHRtYXJnaW4tcmlnaHQ6IC0xMnB4O1xcclxcblxcdGJvcmRlci1sZWZ0LWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0OmJlZm9yZSB7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTEycHg7XFxyXFxuXFx0Ym9yZGVyLXJpZ2h0LWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLG9CQUFvQjs7QUFFcEI7Ozs7Ozs7Ozs7Q0FVQyxrQkFBa0I7Q0FD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VztDQUNYLG1CQUFtQjtDQUNuQix5QkFBeUI7Q0FDekIsc0JBQXNCO0NBQ3RCLHFCQUFxQjtDQUNyQixpQkFBaUI7Q0FDakIsb0JBQW9CO0NBQ3BCLHFDQUFxQztDQUNyQztBQUNEO0NBQ0MsZUFBZTtDQUNmLG9CQUFvQjtDQUNwQjtBQUNEOzs7O0NBSUMsa0JBQWtCO0NBQ2xCLG9CQUFvQjtDQUNwQiw2QkFBNkI7Q0FDN0IsdUJBQXVCO0NBQ3ZCLFdBQVc7Q0FDWDs7QUFFRCxlQUFlOztBQUVmO0NBQ0MsZUFBZTtBQUNoQjtBQUNBO0NBQ0MsZ0JBQWdCO0FBQ2pCO0FBQ0E7O0NBRUMsU0FBUztDQUNULGlCQUFpQjtDQUNqQjtBQUNEO0NBQ0MsU0FBUztDQUNULG9CQUFvQjtDQUNwQixzQkFBc0I7Q0FDdEI7QUFDRDtDQUNDLE1BQU07Q0FDTixpQkFBaUI7Q0FDakIsaUJBQWlCO0NBQ2pCLHlCQUF5QjtDQUN6QjtBQUNEO0NBQ0MsaUJBQWlCO0FBQ2xCO0FBQ0E7Q0FDQyxnQkFBZ0I7QUFDakI7QUFDQTs7Q0FFQyxRQUFRO0NBQ1IsZ0JBQWdCO0NBQ2hCO0FBQ0Q7Q0FDQyxRQUFRO0NBQ1IsbUJBQW1CO0NBQ25CLHVCQUF1QjtDQUN2QjtBQUNEO0NBQ0MsT0FBTztDQUNQLGtCQUFrQjtDQUNsQix3QkFBd0I7Q0FDeEJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLyogcmVxdWlyZWQgc3R5bGVzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtcGFuZSxcXHJcXG4ubGVhZmxldC10aWxlLFxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3csXFxyXFxuLmxlYWZsZXQtdGlsZS1jb250YWluZXIsXFxyXFxuLmxlYWZsZXQtcGFuZSA+IHN2ZyxcXHJcXG4ubGVhZmxldC1wYW5lID4gY2FudmFzLFxcclxcbi5sZWFmbGV0LXpvb20tYm94LFxcclxcbi5sZWFmbGV0LWltYWdlLWxheWVyLFxcclxcbi5sZWFmbGV0LWxheWVyIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciB7XFxyXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdGlsZSxcXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93IHtcXHJcXG5cXHQtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdCAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0ICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQgIC13ZWJraXQtdXNlci1kcmFnOiBub25lO1xcclxcblxcdH1cXHJcXG4vKiBQcmV2ZW50cyBJRTExIGZyb20gaGlnaGxpZ2h0aW5nIHRpbGVzIGluIGJsdWUgKi9cXHJcXG4ubGVhZmxldC10aWxlOjpzZWxlY3Rpb24ge1xcclxcblxcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG4vKiBTYWZhcmkgcmVuZGVycyBub24tcmV0aW5hIHRpbGUgb24gcmV0aW5hIGJldHRlciB3aXRoIHRoaXMsIGJ1dCBDaHJvbWUgaXMgd29yc2UgKi9cXHJcXG4ubGVhZmxldC1zYWZhcmkgLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0aW1hZ2UtcmVuZGVyaW5nOiAtd2Via2l0LW9wdGltaXplLWNvbnRyYXN0O1xcclxcblxcdH1cXHJcXG4vKiBoYWNrIHRoYXQgcHJldmVudHMgaHcgbGF5ZXJzIFxcXCJzdHJldGNoaW5nXFxcIiB3aGVuIGxvYWRpbmcgbmV3IHRpbGVzICovXFxyXFxuLmxlYWZsZXQtc2FmYXJpIC5sZWFmbGV0LXRpbGUtY29udGFpbmVyIHtcXHJcXG5cXHR3aWR0aDogMTYwMHB4O1xcclxcblxcdGhlaWdodDogMTYwMHB4O1xcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93IHtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHR9XFxyXFxuLyogLmxlYWZsZXQtY29udGFpbmVyIHN2ZzogcmVzZXQgc3ZnIG1heC13aWR0aCBkZWNsZXJhdGlvbiBzaGlwcGVkIGluIEpvb21sYSEgKGpvb21sYS5vcmcpIDMueCAqL1xcclxcbi8qIC5sZWFmbGV0LWNvbnRhaW5lciBpbWc6IG1hcCBpcyBicm9rZW4gaW4gRkYgaWYgeW91IGhhdmUgbWF4LXdpZHRoOiAxMDAlIG9uIHRpbGVzICovXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LW92ZXJsYXktcGFuZSBzdmcsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LW1hcmtlci1wYW5lIGltZyxcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtc2hhZG93LXBhbmUgaW1nLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC10aWxlLXBhbmUgaW1nLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBpbWcubGVhZmxldC1pbWFnZS1sYXllcixcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0bWF4LXdpZHRoOiBub25lICFpbXBvcnRhbnQ7XFxyXFxuXFx0bWF4LWhlaWdodDogbm9uZSAhaW1wb3J0YW50O1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250YWluZXIubGVhZmxldC10b3VjaC16b29tIHtcXHJcXG5cXHQtbXMtdG91Y2gtYWN0aW9uOiBwYW4teCBwYW4teTtcXHJcXG5cXHR0b3VjaC1hY3Rpb246IHBhbi14IHBhbi15O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIubGVhZmxldC10b3VjaC1kcmFnIHtcXHJcXG5cXHQtbXMtdG91Y2gtYWN0aW9uOiBwaW5jaC16b29tO1xcclxcblxcdC8qIEZhbGxiYWNrIGZvciBGRiB3aGljaCBkb2Vzbid0IHN1cHBvcnQgcGluY2gtem9vbSAqL1xcclxcblxcdHRvdWNoLWFjdGlvbjogbm9uZTtcXHJcXG5cXHR0b3VjaC1hY3Rpb246IHBpbmNoLXpvb207XFxyXFxufVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLWRyYWcubGVhZmxldC10b3VjaC16b29tIHtcXHJcXG5cXHQtbXMtdG91Y2gtYWN0aW9uOiBub25lO1xcclxcblxcdHRvdWNoLWFjdGlvbjogbm9uZTtcXHJcXG59XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHQtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYSB7XFxyXFxuXFx0LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDUxLCAxODEsIDIyOSwgMC40KTtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0ZmlsdGVyOiBpbmhlcml0O1xcclxcblxcdHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdGlsZS1sb2FkZWQge1xcclxcblxcdHZpc2liaWxpdHk6IGluaGVyaXQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYm94IHtcXHJcXG5cXHR3aWR0aDogMDtcXHJcXG5cXHRoZWlnaHQ6IDA7XFxyXFxuXFx0LW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcdCAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG5cXHR6LWluZGV4OiA4MDA7XFxyXFxuXFx0fVxcclxcbi8qIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4ODMxOSAqL1xcclxcbi5sZWFmbGV0LW92ZXJsYXktcGFuZSBzdmcge1xcclxcblxcdC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXBhbmUgICAgICAgICB7IHotaW5kZXg6IDQwMDsgfVxcclxcblxcclxcbi5sZWFmbGV0LXRpbGUtcGFuZSAgICB7IHotaW5kZXg6IDIwMDsgfVxcclxcbi5sZWFmbGV0LW92ZXJsYXktcGFuZSB7IHotaW5kZXg6IDQwMDsgfVxcclxcbi5sZWFmbGV0LXNoYWRvdy1wYW5lICB7IHotaW5kZXg6IDUwMDsgfVxcclxcbi5sZWFmbGV0LW1hcmtlci1wYW5lICB7IHotaW5kZXg6IDYwMDsgfVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcGFuZSAgIHsgei1pbmRleDogNjUwOyB9XFxyXFxuLmxlYWZsZXQtcG9wdXAtcGFuZSAgIHsgei1pbmRleDogNzAwOyB9XFxyXFxuXFxyXFxuLmxlYWZsZXQtbWFwLXBhbmUgY2FudmFzIHsgei1pbmRleDogMTAwOyB9XFxyXFxuLmxlYWZsZXQtbWFwLXBhbmUgc3ZnICAgIHsgei1pbmRleDogMjAwOyB9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdm1sLXNoYXBlIHtcXHJcXG5cXHR3aWR0aDogMXB4O1xcclxcblxcdGhlaWdodDogMXB4O1xcclxcblxcdH1cXHJcXG4ubHZtbCB7XFxyXFxuXFx0YmVoYXZpb3I6IHVybCgjZGVmYXVsdCNWTUwpO1xcclxcblxcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGNvbnRyb2wgcG9zaXRpb25pbmcgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuXFx0ei1pbmRleDogODAwO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiB2aXNpYmxlUGFpbnRlZDsgLyogSUUgOS0xMCBkb2Vzbid0IGhhdmUgYXV0byAqL1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3AsXFxyXFxuLmxlYWZsZXQtYm90dG9tIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0ei1pbmRleDogMTAwMDtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9wIHtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJpZ2h0IHtcXHJcXG5cXHRyaWdodDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYm90dG9tIHtcXHJcXG5cXHRib3R0b206IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWxlZnQge1xcclxcblxcdGxlZnQ6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGZsb2F0OiBsZWZ0O1xcclxcblxcdGNsZWFyOiBib3RoO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1yaWdodCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRmbG9hdDogcmlnaHQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvcCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1ib3R0b20gLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbTogMTBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtbGVmdCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tbGVmdDogMTBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmlnaHQgLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0bWFyZ2luLXJpZ2h0OiAxMHB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiB6b29tIGFuZCBmYWRlIGFuaW1hdGlvbnMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0d2lsbC1jaGFuZ2U6IG9wYWNpdHk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWZhZGUtYW5pbSAubGVhZmxldC1wb3B1cCB7XFxyXFxuXFx0b3BhY2l0eTogMDtcXHJcXG5cXHQtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBsaW5lYXI7XFxyXFxuXFx0ICAgLW1vei10cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgbGluZWFyO1xcclxcblxcdCAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGxpbmVhcjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZmFkZS1hbmltIC5sZWFmbGV0LW1hcC1wYW5lIC5sZWFmbGV0LXBvcHVwIHtcXHJcXG5cXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWFuaW1hdGVkIHtcXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHQgICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHQgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20tYW5pbWF0ZWQge1xcclxcblxcdHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYW5pbSAubGVhZmxldC16b29tLWFuaW1hdGVkIHtcXHJcXG5cXHQtd2Via2l0LXRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtIDAuMjVzIGN1YmljLWJlemllcigwLDAsMC4yNSwxKTtcXHJcXG5cXHQgICAtbW96LXRyYW5zaXRpb246ICAgIC1tb3otdHJhbnNmb3JtIDAuMjVzIGN1YmljLWJlemllcigwLDAsMC4yNSwxKTtcXHJcXG5cXHQgICAgICAgIHRyYW5zaXRpb246ICAgICAgICAgdHJhbnNmb3JtIDAuMjVzIGN1YmljLWJlemllcigwLDAsMC4yNSwxKTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXRpbGUsXFxyXFxuLmxlYWZsZXQtcGFuLWFuaW0gLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0LXdlYmtpdC10cmFuc2l0aW9uOiBub25lO1xcclxcblxcdCAgIC1tb3otdHJhbnNpdGlvbjogbm9uZTtcXHJcXG5cXHQgICAgICAgIHRyYW5zaXRpb246IG5vbmU7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXpvb20tYW5pbSAubGVhZmxldC16b29tLWhpZGUge1xcclxcblxcdHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogY3Vyc29ycyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWludGVyYWN0aXZlIHtcXHJcXG5cXHRjdXJzb3I6IHBvaW50ZXI7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWdyYWIge1xcclxcblxcdGN1cnNvcjogLXdlYmtpdC1ncmFiO1xcclxcblxcdGN1cnNvcjogICAgLW1vei1ncmFiO1xcclxcblxcdGN1cnNvcjogICAgICAgICBncmFiO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jcm9zc2hhaXIsXFxyXFxuLmxlYWZsZXQtY3Jvc3NoYWlyIC5sZWFmbGV0LWludGVyYWN0aXZlIHtcXHJcXG5cXHRjdXJzb3I6IGNyb3NzaGFpcjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtcGFuZSxcXHJcXG4ubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRjdXJzb3I6IGF1dG87XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWRyYWdnaW5nIC5sZWFmbGV0LWdyYWIsXFxyXFxuLmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtZ3JhYiAubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG4ubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlIHtcXHJcXG5cXHRjdXJzb3I6IG1vdmU7XFxyXFxuXFx0Y3Vyc29yOiAtd2Via2l0LWdyYWJiaW5nO1xcclxcblxcdGN1cnNvcjogICAgLW1vei1ncmFiYmluZztcXHJcXG5cXHRjdXJzb3I6ICAgICAgICAgZ3JhYmJpbmc7XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIG1hcmtlciAmIG92ZXJsYXlzIGludGVyYWN0aXZpdHkgKi9cXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93LFxcclxcbi5sZWFmbGV0LWltYWdlLWxheWVyLFxcclxcbi5sZWFmbGV0LXBhbmUgPiBzdmcgcGF0aCxcXHJcXG4ubGVhZmxldC10aWxlLWNvbnRhaW5lciB7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLmxlYWZsZXQtaW50ZXJhY3RpdmUsXFxyXFxuLmxlYWZsZXQtaW1hZ2UtbGF5ZXIubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG4ubGVhZmxldC1wYW5lID4gc3ZnIHBhdGgubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG5zdmcubGVhZmxldC1pbWFnZS1sYXllci5sZWFmbGV0LWludGVyYWN0aXZlIHBhdGgge1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiB2aXNpYmxlUGFpbnRlZDsgLyogSUUgOS0xMCBkb2Vzbid0IGhhdmUgYXV0byAqL1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiB2aXN1YWwgdHdlYWtzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZGRkO1xcclxcblxcdG91dGxpbmU6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhIHtcXHJcXG5cXHRjb2xvcjogIzAwNzhBODtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1hY3RpdmUge1xcclxcblxcdG91dGxpbmU6IDJweCBzb2xpZCBvcmFuZ2U7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYm94IHtcXHJcXG5cXHRib3JkZXI6IDJweCBkb3R0ZWQgIzM4ZjtcXHJcXG5cXHRiYWNrZ3JvdW5kOiByZ2JhKDI1NSwyNTUsMjU1LDAuNSk7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGdlbmVyYWwgdHlwb2dyYXBoeSAqL1xcclxcbi5sZWFmbGV0LWNvbnRhaW5lciB7XFxyXFxuXFx0Zm9udDogMTJweC8xLjUgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogZ2VuZXJhbCB0b29sYmFyIHN0eWxlcyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWJhciB7XFxyXFxuXFx0Ym94LXNoYWRvdzogMCAxcHggNXB4IHJnYmEoMCwwLDAsMC42NSk7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogNHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYSxcXHJcXG4ubGVhZmxldC1iYXIgYTpob3ZlciB7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXHJcXG5cXHRib3JkZXItYm90dG9tOiAxcHggc29saWQgI2NjYztcXHJcXG5cXHR3aWR0aDogMjZweDtcXHJcXG5cXHRoZWlnaHQ6IDI2cHg7XFxyXFxuXFx0bGluZS1oZWlnaHQ6IDI2cHg7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG5cXHRjb2xvcjogYmxhY2s7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0YmFja2dyb3VuZC1wb3NpdGlvbjogNTAlIDUwJTtcXHJcXG5cXHRiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYTpob3ZlciB7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYmFyIGE6Zmlyc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDRweDtcXHJcXG5cXHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogNHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYTpsYXN0LWNoaWxkIHtcXHJcXG5cXHRib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA0cHg7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDRweDtcXHJcXG5cXHRib3JkZXItYm90dG9tOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYS5sZWFmbGV0LWRpc2FibGVkIHtcXHJcXG5cXHRjdXJzb3I6IGRlZmF1bHQ7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcXHJcXG5cXHRjb2xvcjogI2JiYjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIGEge1xcclxcblxcdHdpZHRoOiAzMHB4O1xcclxcblxcdGhlaWdodDogMzBweDtcXHJcXG5cXHRsaW5lLWhlaWdodDogMzBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIGE6Zmlyc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDJweDtcXHJcXG5cXHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYTpsYXN0LWNoaWxkIHtcXHJcXG5cXHRib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAycHg7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDJweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogem9vbSBjb250cm9sICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udHJvbC16b29tLWluLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXQge1xcclxcblxcdGZvbnQ6IGJvbGQgMThweCAnTHVjaWRhIENvbnNvbGUnLCBNb25hY28sIG1vbm9zcGFjZTtcXHJcXG5cXHR0ZXh0LWluZGVudDogMXB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLXpvb20taW4sIC5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXQgIHtcXHJcXG5cXHRmb250LXNpemU6IDIycHg7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGxheWVycyBjb250cm9sICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMge1xcclxcblxcdGJveC1zaGFkb3c6IDAgMXB4IDVweCByZ2JhKDAsMCwwLDAuNCk7XFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKGltYWdlcy9sYXllcnMucG5nKTtcXHJcXG5cXHR3aWR0aDogMzZweDtcXHJcXG5cXHRoZWlnaHQ6IDM2cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJldGluYSAubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGUge1xcclxcblxcdGJhY2tncm91bmQtaW1hZ2U6IHVybChpbWFnZXMvbGF5ZXJzLTJ4LnBuZyk7XFxyXFxuXFx0YmFja2dyb3VuZC1zaXplOiAyNnB4IDI2cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0d2lkdGg6IDQ0cHg7XFxyXFxuXFx0aGVpZ2h0OiA0NHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycyAubGVhZmxldC1jb250cm9sLWxheWVycy1saXN0LFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0ZGlzcGxheTogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtbGlzdCB7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCB7XFxyXFxuXFx0cGFkZGluZzogNnB4IDEwcHggNnB4IDZweDtcXHJcXG5cXHRjb2xvcjogIzMzMztcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXIge1xcclxcblxcdG92ZXJmbG93LXk6IHNjcm9sbDtcXHJcXG5cXHRvdmVyZmxvdy14OiBoaWRkZW47XFxyXFxuXFx0cGFkZGluZy1yaWdodDogNXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvciB7XFxyXFxuXFx0bWFyZ2luLXRvcDogMnB4O1xcclxcblxcdHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG5cXHR0b3A6IDFweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMgbGFiZWwge1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1zZXBhcmF0b3Ige1xcclxcblxcdGhlaWdodDogMDtcXHJcXG5cXHRib3JkZXItdG9wOiAxcHggc29saWQgI2RkZDtcXHJcXG5cXHRtYXJnaW46IDVweCAtMTBweCA1cHggLTZweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogRGVmYXVsdCBpY29uIFVSTHMgKi9cXHJcXG4ubGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCB7XFxyXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKGltYWdlcy9tYXJrZXItaWNvbi5wbmcpO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBhdHRyaWJ1dGlvbiBhbmQgc2NhbGUgY29udHJvbHMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiB7XFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHRiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyk7XFxyXFxuXFx0bWFyZ2luOiAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZSB7XFxyXFxuXFx0cGFkZGluZzogMCA1cHg7XFxyXFxuXFx0Y29sb3I6ICMzMzM7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24gYSB7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uIGE6aG92ZXIge1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbixcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtY29udHJvbC1zY2FsZSB7XFxyXFxuXFx0Zm9udC1zaXplOiAxMXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1sZWZ0IC5sZWFmbGV0LWNvbnRyb2wtc2NhbGUge1xcclxcblxcdG1hcmdpbi1sZWZ0OiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJvdHRvbSAubGVhZmxldC1jb250cm9sLXNjYWxlIHtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZSB7XFxyXFxuXFx0Ym9yZGVyOiAycHggc29saWQgIzc3NztcXHJcXG5cXHRib3JkZXItdG9wOiBub25lO1xcclxcblxcdGxpbmUtaGVpZ2h0OiAxLjE7XFxyXFxuXFx0cGFkZGluZzogMnB4IDVweCAxcHg7XFxyXFxuXFx0Zm9udC1zaXplOiAxMXB4O1xcclxcblxcdHdoaXRlLXNwYWNlOiBub3dyYXA7XFxyXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG5cXHQtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuXFx0ICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0YmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmU6bm90KDpmaXJzdC1jaGlsZCkge1xcclxcblxcdGJvcmRlci10b3A6IDJweCBzb2xpZCAjNzc3O1xcclxcblxcdGJvcmRlci1ib3R0b206IG5vbmU7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTJweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1zY2FsZS1saW5lOm5vdCg6Zmlyc3QtY2hpbGQpOm5vdCg6bGFzdC1jaGlsZCkge1xcclxcblxcdGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAjNzc3O1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uLFxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLFxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciB7XFxyXFxuXFx0Ym94LXNoYWRvdzogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMsXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIHtcXHJcXG5cXHRib3JkZXI6IDJweCBzb2xpZCByZ2JhKDAsMCwwLDAuMik7XFxyXFxuXFx0YmFja2dyb3VuZC1jbGlwOiBwYWRkaW5nLWJveDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogcG9wdXAgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1wb3B1cCB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAyMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXIge1xcclxcblxcdHBhZGRpbmc6IDFweDtcXHJcXG5cXHR0ZXh0LWFsaWduOiBsZWZ0O1xcclxcblxcdGJvcmRlci1yYWRpdXM6IDEycHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQge1xcclxcblxcdG1hcmdpbjogMTNweCAxOXB4O1xcclxcblxcdGxpbmUtaGVpZ2h0OiAxLjQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQgcCB7XFxyXFxuXFx0bWFyZ2luOiAxOHB4IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXIge1xcclxcblxcdHdpZHRoOiA0MHB4O1xcclxcblxcdGhlaWdodDogMjBweDtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0bGVmdDogNTAlO1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtMjBweDtcXHJcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC10aXAge1xcclxcblxcdHdpZHRoOiAxN3B4O1xcclxcblxcdGhlaWdodDogMTdweDtcXHJcXG5cXHRwYWRkaW5nOiAxcHg7XFxyXFxuXFxyXFxuXFx0bWFyZ2luOiAtMTBweCBhdXRvIDA7XFxyXFxuXFxyXFxuXFx0LXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0ICAgLW1vei10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0ICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0ICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlcixcXHJcXG4ubGVhZmxldC1wb3B1cC10aXAge1xcclxcblxcdGJhY2tncm91bmQ6IHdoaXRlO1xcclxcblxcdGNvbG9yOiAjMzMzO1xcclxcblxcdGJveC1zaGFkb3c6IDAgM3B4IDE0cHggcmdiYSgwLDAsMCwwLjQpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LXBvcHVwLWNsb3NlLWJ1dHRvbiB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHRyaWdodDogMDtcXHJcXG5cXHRwYWRkaW5nOiA0cHggNHB4IDAgMDtcXHJcXG5cXHRib3JkZXI6IG5vbmU7XFxyXFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcclxcblxcdHdpZHRoOiAxOHB4O1xcclxcblxcdGhlaWdodDogMTRweDtcXHJcXG5cXHRmb250OiAxNnB4LzE0cHggVGFob21hLCBWZXJkYW5hLCBzYW5zLXNlcmlmO1xcclxcblxcdGNvbG9yOiAjYzNjM2MzO1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG5cXHRmb250LXdlaWdodDogYm9sZDtcXHJcXG5cXHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b246aG92ZXIge1xcclxcblxcdGNvbG9yOiAjOTk5O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1zY3JvbGxlZCB7XFxyXFxuXFx0b3ZlcmZsb3c6IGF1dG87XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkZGQ7XFxyXFxuXFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkICNkZGQ7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlciB7XFxyXFxuXFx0em9vbTogMTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtdGlwIHtcXHJcXG5cXHR3aWR0aDogMjRweDtcXHJcXG5cXHRtYXJnaW46IDAgYXV0bztcXHJcXG5cXHJcXG5cXHQtbXMtZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9MC43MDcxMDY3OCwgTTEyPTAuNzA3MTA2NzgsIE0yMT0tMC43MDcxMDY3OCwgTTIyPTAuNzA3MTA2NzgpXFxcIjtcXHJcXG5cXHRmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPTAuNzA3MTA2NzgsIE0xMj0wLjcwNzEwNjc4LCBNMjE9LTAuNzA3MTA2NzgsIE0yMj0wLjcwNzEwNjc4KTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtdGlwLWNvbnRhaW5lciB7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTFweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtY29udHJvbC16b29tLFxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLFxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlcixcXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC10aXAge1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICM5OTk7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGRpdiBpY29uICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtZGl2LWljb24ge1xcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgIzY2NjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogVG9vbHRpcCAqL1xcclxcbi8qIEJhc2Ugc3R5bGVzIGZvciB0aGUgZWxlbWVudCB0aGF0IGhhcyBhIHRvb2x0aXAgKi9cXHJcXG4ubGVhZmxldC10b29sdGlwIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0cGFkZGluZzogNnB4O1xcclxcblxcdGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxyXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgI2ZmZjtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiAzcHg7XFxyXFxuXFx0Y29sb3I6ICMyMjI7XFxyXFxuXFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcXHJcXG5cXHQtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0LW1zLXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdHVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdGJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsMCwwLDAuNCk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAubGVhZmxldC1jbGlja2FibGUge1xcclxcblxcdGN1cnNvcjogcG9pbnRlcjtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogYXV0bztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtYm90dG9tOmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQ6YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcmlnaHQ6YmVmb3JlIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0Ym9yZGVyOiA2cHggc29saWQgdHJhbnNwYXJlbnQ7XFxyXFxuXFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxuXFx0Y29udGVudDogXFxcIlxcXCI7XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIERpcmVjdGlvbnMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC10b29sdGlwLWJvdHRvbSB7XFxyXFxuXFx0bWFyZ2luLXRvcDogNnB4O1xcclxcbn1cXHJcXG4ubGVhZmxldC10b29sdGlwLXRvcCB7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1ib3R0b206YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtdG9wOmJlZm9yZSB7XFxyXFxuXFx0bGVmdDogNTAlO1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtNnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLXRvcDpiZWZvcmUge1xcclxcblxcdGJvdHRvbTogMDtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAtMTJweDtcXHJcXG5cXHRib3JkZXItdG9wLWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLWJvdHRvbTpiZWZvcmUge1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtMTJweDtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTZweDtcXHJcXG5cXHRib3JkZXItYm90dG9tLWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQge1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtNnB4O1xcclxcbn1cXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0IHtcXHJcXG5cXHRtYXJnaW4tbGVmdDogNnB4O1xcclxcbn1cXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQ6YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcmlnaHQ6YmVmb3JlIHtcXHJcXG5cXHR0b3A6IDUwJTtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtNnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQ6YmVmb3JlIHtcXHJcXG5cXHRyaWdodDogMDtcXHJcXG5cXHRtYXJnaW4tcmlnaHQ6IC0xMnB4O1xcclxcblxcdGJvcmRlci1sZWZ0LWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0OmJlZm9yZSB7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTEycHg7XFxyXFxuXFx0Ym9yZGVyLXJpZ2h0LWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdXJsID0gU3RyaW5nKHVybC5fX2VzTW9kdWxlID8gdXJsLmRlZmF1bHQgOiB1cmwpOyAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cblxuICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGFzaCkge1xuICAgIHVybCArPSBvcHRpb25zLmhhc2g7XG4gIH0gLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuXG5cbiAgaWYgKC9bXCInKCkgXFx0XFxuXXwoJTIwKS8udGVzdCh1cmwpIHx8IG9wdGlvbnMubmVlZFF1b3Rlcykge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQodXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKSwgXCJcXFwiXCIpO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiLCIvKiBAcHJlc2VydmVcbiAqIExlYWZsZXQgMS42LjAsIGEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwcy4gaHR0cDovL2xlYWZsZXRqcy5jb21cbiAqIChjKSAyMDEwLTIwMTkgVmxhZGltaXIgQWdhZm9ua2luLCAoYykgMjAxMC0yMDExIENsb3VkTWFkZVxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5MID0ge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciB2ZXJzaW9uID0gXCIxLjYuMFwiO1xuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqL1xyXG5cclxudmFyIGZyZWV6ZSA9IE9iamVjdC5mcmVlemU7XHJcbk9iamVjdC5mcmVlemUgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmo7IH07XHJcblxyXG4vLyBAZnVuY3Rpb24gZXh0ZW5kKGRlc3Q6IE9iamVjdCwgc3JjPzogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgYHNyY2Agb2JqZWN0IChvciBtdWx0aXBsZSBvYmplY3RzKSBpbnRvIGBkZXN0YCBvYmplY3QgYW5kIHJldHVybnMgdGhlIGxhdHRlci4gSGFzIGFuIGBMLmV4dGVuZGAgc2hvcnRjdXQuXHJcbmZ1bmN0aW9uIGV4dGVuZChkZXN0KSB7XHJcblx0dmFyIGksIGosIGxlbiwgc3JjO1xyXG5cclxuXHRmb3IgKGogPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuXHRcdHNyYyA9IGFyZ3VtZW50c1tqXTtcclxuXHRcdGZvciAoaSBpbiBzcmMpIHtcclxuXHRcdFx0ZGVzdFtpXSA9IHNyY1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGRlc3Q7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUocHJvdG86IE9iamVjdCwgcHJvcGVydGllcz86IE9iamVjdCk6IE9iamVjdFxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbT2JqZWN0LmNyZWF0ZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZSlcclxudmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcclxuXHRmdW5jdGlvbiBGKCkge31cclxuXHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvKSB7XHJcblx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cdFx0cmV0dXJuIG5ldyBGKCk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbi8vIEBmdW5jdGlvbiBiaW5kKGZuOiBGdW5jdGlvbiwg4oCmKTogRnVuY3Rpb25cclxuLy8gUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBib3VuZCB0byB0aGUgYXJndW1lbnRzIHBhc3NlZCwgbGlrZSBbRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQpLlxyXG4vLyBIYXMgYSBgTC5iaW5kKClgIHNob3J0Y3V0LlxyXG5mdW5jdGlvbiBiaW5kKGZuLCBvYmopIHtcclxuXHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG5cdGlmIChmbi5iaW5kKSB7XHJcblx0XHRyZXR1cm4gZm4uYmluZC5hcHBseShmbiwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuXHR9XHJcblxyXG5cdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5sZW5ndGggPyBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogYXJndW1lbnRzKTtcclxuXHR9O1xyXG59XHJcblxyXG4vLyBAcHJvcGVydHkgbGFzdElkOiBOdW1iZXJcclxuLy8gTGFzdCB1bmlxdWUgSUQgdXNlZCBieSBbYHN0YW1wKClgXSgjdXRpbC1zdGFtcClcclxudmFyIGxhc3RJZCA9IDA7XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RhbXAob2JqOiBPYmplY3QpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWduaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcbmZ1bmN0aW9uIHN0YW1wKG9iaikge1xyXG5cdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRvYmouX2xlYWZsZXRfaWQgPSBvYmouX2xlYWZsZXRfaWQgfHwgKytsYXN0SWQ7XHJcblx0cmV0dXJuIG9iai5fbGVhZmxldF9pZDtcclxuXHQvKiBlc2xpbnQtZW5hYmxlICovXHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0aHJvdHRsZShmbjogRnVuY3Rpb24sIHRpbWU6IE51bWJlciwgY29udGV4dDogT2JqZWN0KTogRnVuY3Rpb25cclxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGVzIGZ1bmN0aW9uIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gc2NvcGUgYGNvbnRleHRgXHJcbi8vIChzbyB0aGF0IHRoZSBgdGhpc2Aga2V5d29yZCByZWZlcnMgdG8gYGNvbnRleHRgIGluc2lkZSBgZm5gJ3MgY29kZSkuIFRoZSBmdW5jdGlvblxyXG4vLyBgZm5gIHdpbGwgYmUgY2FsbGVkIG5vIG1vcmUgdGhhbiBvbmUgdGltZSBwZXIgZ2l2ZW4gYW1vdW50IG9mIGB0aW1lYC4gVGhlIGFyZ3VtZW50c1xyXG4vLyByZWNlaXZlZCBieSB0aGUgYm91bmQgZnVuY3Rpb24gd2lsbCBiZSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGJpbmRpbmcgdGhlXHJcbi8vIGZ1bmN0aW9uLCBmb2xsb3dlZCBieSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGludm9raW5nIHRoZSBib3VuZCBmdW5jdGlvbi5cclxuLy8gSGFzIGFuIGBMLnRocm90dGxlYCBzaG9ydGN1dC5cclxuZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHRpbWUsIGNvbnRleHQpIHtcclxuXHR2YXIgbG9jaywgYXJncywgd3JhcHBlckZuLCBsYXRlcjtcclxuXHJcblx0bGF0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyByZXNldCBsb2NrIGFuZCBjYWxsIGlmIHF1ZXVlZFxyXG5cdFx0bG9jayA9IGZhbHNlO1xyXG5cdFx0aWYgKGFyZ3MpIHtcclxuXHRcdFx0d3JhcHBlckZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG5cdFx0XHRhcmdzID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0d3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKGxvY2spIHtcclxuXHRcdFx0Ly8gY2FsbGVkIHRvbyBzb29uLCBxdWV1ZSB0byBjYWxsIGxhdGVyXHJcblx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gY2FsbCBhbmQgbG9jayB1bnRpbCBsYXRlclxyXG5cdFx0XHRmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xyXG5cdFx0XHRzZXRUaW1lb3V0KGxhdGVyLCB0aW1lKTtcclxuXHRcdFx0bG9jayA9IHRydWU7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHdyYXBwZXJGbjtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHdyYXBOdW0obnVtOiBOdW1iZXIsIHJhbmdlOiBOdW1iZXJbXSwgaW5jbHVkZU1heD86IEJvb2xlYW4pOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIG1vZHVsbyBgcmFuZ2VgIGluIHN1Y2ggYSB3YXkgc28gaXQgbGllcyB3aXRoaW5cclxuLy8gYHJhbmdlWzBdYCBhbmQgYHJhbmdlWzFdYC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgYWx3YXlzIHNtYWxsZXIgdGhhblxyXG4vLyBgcmFuZ2VbMV1gIHVubGVzcyBgaW5jbHVkZU1heGAgaXMgc2V0IHRvIGB0cnVlYC5cclxuZnVuY3Rpb24gd3JhcE51bSh4LCByYW5nZSwgaW5jbHVkZU1heCkge1xyXG5cdHZhciBtYXggPSByYW5nZVsxXSxcclxuXHQgICAgbWluID0gcmFuZ2VbMF0sXHJcblx0ICAgIGQgPSBtYXggLSBtaW47XHJcblx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZmFsc2VGbigpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuZnVuY3Rpb24gZmFsc2VGbigpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4vLyBAZnVuY3Rpb24gZm9ybWF0TnVtKG51bTogTnVtYmVyLCBkaWdpdHM/OiBOdW1iZXIpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIHJvdW5kZWQgdG8gYGRpZ2l0c2AgZGVjaW1hbHMsIG9yIHRvIDYgZGVjaW1hbHMgYnkgZGVmYXVsdC5cclxuZnVuY3Rpb24gZm9ybWF0TnVtKG51bSwgZGlnaXRzKSB7XHJcblx0dmFyIHBvdyA9IE1hdGgucG93KDEwLCAoZGlnaXRzID09PSB1bmRlZmluZWQgPyA2IDogZGlnaXRzKSk7XHJcblx0cmV0dXJuIE1hdGgucm91bmQobnVtICogcG93KSAvIHBvdztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRyaW0oc3RyOiBTdHJpbmcpOiBTdHJpbmdcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW1N0cmluZy5wcm90b3R5cGUudHJpbV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0pXHJcbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XHJcblx0cmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cjogU3RyaW5nKTogU3RyaW5nW11cclxuLy8gVHJpbXMgYW5kIHNwbGl0cyB0aGUgc3RyaW5nIG9uIHdoaXRlc3BhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHBhcnRzLlxyXG5mdW5jdGlvbiBzcGxpdFdvcmRzKHN0cikge1xyXG5cdHJldHVybiB0cmltKHN0cikuc3BsaXQoL1xccysvKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqOiBPYmplY3QsIG9wdGlvbnM6IE9iamVjdCk6IE9iamVjdFxyXG4vLyBNZXJnZXMgdGhlIGdpdmVuIHByb3BlcnRpZXMgdG8gdGhlIGBvcHRpb25zYCBvZiB0aGUgYG9iamAgb2JqZWN0LCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyBvcHRpb25zLiBTZWUgYENsYXNzIG9wdGlvbnNgLiBIYXMgYW4gYEwuc2V0T3B0aW9uc2Agc2hvcnRjdXQuXHJcbmZ1bmN0aW9uIHNldE9wdGlvbnMob2JqLCBvcHRpb25zKSB7XHJcblx0aWYgKCFvYmouaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSkge1xyXG5cdFx0b2JqLm9wdGlvbnMgPSBvYmoub3B0aW9ucyA/IGNyZWF0ZShvYmoub3B0aW9ucykgOiB7fTtcclxuXHR9XHJcblx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRvYmoub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0fVxyXG5cdHJldHVybiBvYmoub3B0aW9ucztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iajogT2JqZWN0LCBleGlzdGluZ1VybD86IFN0cmluZywgdXBwZXJjYXNlPzogQm9vbGVhbik6IFN0cmluZ1xyXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIHBhcmFtZXRlciBVUkwgc3RyaW5nLCBlLmcuIGB7YTogXCJmb29cIiwgYjogXCJiYXJcIn1gXHJcbi8vIHRyYW5zbGF0ZXMgdG8gYCc/YT1mb28mYj1iYXInYC4gSWYgYGV4aXN0aW5nVXJsYCBpcyBzZXQsIHRoZSBwYXJhbWV0ZXJzIHdpbGxcclxuLy8gYmUgYXBwZW5kZWQgYXQgdGhlIGVuZC4gSWYgYHVwcGVyY2FzZWAgaXMgYHRydWVgLCB0aGUgcGFyYW1ldGVyIG5hbWVzIHdpbGxcclxuLy8gYmUgdXBwZXJjYXNlZCAoZS5nLiBgJz9BPWZvbyZCPWJhcidgKVxyXG5mdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuXHR2YXIgcGFyYW1zID0gW107XHJcblx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuXHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuXHR9XHJcblx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcbn1cclxuXHJcbnZhciB0ZW1wbGF0ZVJlID0gL1xceyAqKFtcXHdfLV0rKSAqXFx9L2c7XHJcblxyXG4vLyBAZnVuY3Rpb24gdGVtcGxhdGUoc3RyOiBTdHJpbmcsIGRhdGE6IE9iamVjdCk6IFN0cmluZ1xyXG4vLyBTaW1wbGUgdGVtcGxhdGluZyBmYWNpbGl0eSwgYWNjZXB0cyBhIHRlbXBsYXRlIHN0cmluZyBvZiB0aGUgZm9ybSBgJ0hlbGxvIHthfSwge2J9J2BcclxuLy8gYW5kIGEgZGF0YSBvYmplY3QgbGlrZSBge2E6ICdmb28nLCBiOiAnYmFyJ31gLCByZXR1cm5zIGV2YWx1YXRlZCBzdHJpbmdcclxuLy8gYCgnSGVsbG8gZm9vLCBiYXInKWAuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHN0cmluZ3MgZm9yXHJcbi8vIGRhdGEgdmFsdWVzIOKAlCB0aGV5IHdpbGwgYmUgZXZhbHVhdGVkIHBhc3NpbmcgYGRhdGFgIGFzIGFuIGFyZ3VtZW50LlxyXG5mdW5jdGlvbiB0ZW1wbGF0ZShzdHIsIGRhdGEpIHtcclxuXHRyZXR1cm4gc3RyLnJlcGxhY2UodGVtcGxhdGVSZSwgZnVuY3Rpb24gKHN0ciwga2V5KSB7XHJcblx0XHR2YXIgdmFsdWUgPSBkYXRhW2tleV07XHJcblxyXG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyB2YWx1ZSBwcm92aWRlZCBmb3IgdmFyaWFibGUgJyArIHN0cik7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0dmFsdWUgPSB2YWx1ZShkYXRhKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGlzQXJyYXkob2JqKTogQm9vbGVhblxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkuaXNBcnJheV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheSlcclxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBpbmRleE9mKGFycmF5OiBBcnJheSwgZWw6IE9iamVjdCk6IE51bWJlclxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkucHJvdG90eXBlLmluZGV4T2ZdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YpXHJcbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIGVsKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKGFycmF5W2ldID09PSBlbCkgeyByZXR1cm4gaTsgfVxyXG5cdH1cclxuXHRyZXR1cm4gLTE7XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBlbXB0eUltYWdlVXJsOiBTdHJpbmdcclxuLy8gRGF0YSBVUkkgc3RyaW5nIGNvbnRhaW5pbmcgYSBiYXNlNjQtZW5jb2RlZCBlbXB0eSBHSUYgaW1hZ2UuXHJcbi8vIFVzZWQgYXMgYSBoYWNrIHRvIGZyZWUgbWVtb3J5IGZyb20gdW51c2VkIGltYWdlcyBvbiBXZWJLaXQtcG93ZXJlZFxyXG4vLyBtb2JpbGUgZGV2aWNlcyAoYnkgc2V0dGluZyBpbWFnZSBgc3JjYCB0byB0aGlzIHN0cmluZykuXHJcbnZhciBlbXB0eUltYWdlVXJsID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUQvQUN3QUFBQUFBUUFCQUFBQ0FEcz0nO1xyXG5cclxuLy8gaW5zcGlyZWQgYnkgaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHJcbmZ1bmN0aW9uIGdldFByZWZpeGVkKG5hbWUpIHtcclxuXHRyZXR1cm4gd2luZG93Wyd3ZWJraXQnICsgbmFtZV0gfHwgd2luZG93Wydtb3onICsgbmFtZV0gfHwgd2luZG93WydtcycgKyBuYW1lXTtcclxufVxyXG5cclxudmFyIGxhc3RUaW1lID0gMDtcclxuXHJcbi8vIGZhbGxiYWNrIGZvciBJRSA3LThcclxuZnVuY3Rpb24gdGltZW91dERlZmVyKGZuKSB7XHJcblx0dmFyIHRpbWUgPSArbmV3IERhdGUoKSxcclxuXHQgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKHRpbWUgLSBsYXN0VGltZSkpO1xyXG5cclxuXHRsYXN0VGltZSA9IHRpbWUgKyB0aW1lVG9DYWxsO1xyXG5cdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZVRvQ2FsbCk7XHJcbn1cclxuXHJcbnZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXI7XHJcbnZhciBjYW5jZWxGbiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnKSB8fFxyXG5cdFx0Z2V0UHJlZml4ZWQoJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IGZ1bmN0aW9uIChpZCkgeyB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTsgfTtcclxuXHJcbi8vIEBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgaW1tZWRpYXRlPzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBTY2hlZHVsZXMgYGZuYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBicm93c2VyIHJlcGFpbnRzLiBgZm5gIGlzIGJvdW5kIHRvXHJcbi8vIGBjb250ZXh0YCBpZiBnaXZlbi4gV2hlbiBgaW1tZWRpYXRlYCBpcyBzZXQsIGBmbmAgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGlmXHJcbi8vIHRoZSBicm93c2VyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgc3VwcG9ydCBmb3JcclxuLy8gW2B3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLFxyXG4vLyBvdGhlcndpc2UgaXQncyBkZWxheWVkLiBSZXR1cm5zIGEgcmVxdWVzdCBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cclxuZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbiwgY29udGV4dCwgaW1tZWRpYXRlKSB7XHJcblx0aWYgKGltbWVkaWF0ZSAmJiByZXF1ZXN0Rm4gPT09IHRpbWVvdXREZWZlcikge1xyXG5cdFx0Zm4uY2FsbChjb250ZXh0KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIHJlcXVlc3RGbi5jYWxsKHdpbmRvdywgYmluZChmbiwgY29udGV4dCkpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZDogTnVtYmVyKTogdW5kZWZpbmVkXHJcbi8vIENhbmNlbHMgYSBwcmV2aW91cyBgcmVxdWVzdEFuaW1GcmFtZWAuIFNlZSBhbHNvIFt3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvY2FuY2VsQW5pbWF0aW9uRnJhbWUpLlxyXG5mdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQpIHtcclxuXHRpZiAoaWQpIHtcclxuXHRcdGNhbmNlbEZuLmNhbGwod2luZG93LCBpZCk7XHJcblx0fVxyXG59XHJcblxuXG52YXIgVXRpbCA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRmcmVlemU6IGZyZWV6ZSxcblx0ZXh0ZW5kOiBleHRlbmQsXG5cdGNyZWF0ZTogY3JlYXRlLFxuXHRiaW5kOiBiaW5kLFxuXHRsYXN0SWQ6IGxhc3RJZCxcblx0c3RhbXA6IHN0YW1wLFxuXHR0aHJvdHRsZTogdGhyb3R0bGUsXG5cdHdyYXBOdW06IHdyYXBOdW0sXG5cdGZhbHNlRm46IGZhbHNlRm4sXG5cdGZvcm1hdE51bTogZm9ybWF0TnVtLFxuXHR0cmltOiB0cmltLFxuXHRzcGxpdFdvcmRzOiBzcGxpdFdvcmRzLFxuXHRzZXRPcHRpb25zOiBzZXRPcHRpb25zLFxuXHRnZXRQYXJhbVN0cmluZzogZ2V0UGFyYW1TdHJpbmcsXG5cdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblx0aXNBcnJheTogaXNBcnJheSxcblx0aW5kZXhPZjogaW5kZXhPZixcblx0ZW1wdHlJbWFnZVVybDogZW1wdHlJbWFnZVVybCxcblx0cmVxdWVzdEZuOiByZXF1ZXN0Rm4sXG5cdGNhbmNlbEZuOiBjYW5jZWxGbixcblx0cmVxdWVzdEFuaW1GcmFtZTogcmVxdWVzdEFuaW1GcmFtZSxcblx0Y2FuY2VsQW5pbUZyYW1lOiBjYW5jZWxBbmltRnJhbWVcbn0pO1xuXG4vLyBAY2xhc3MgQ2xhc3NcclxuLy8gQGFrYSBMLkNsYXNzXHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBAdW5pbmhlcml0YWJsZVxyXG5cclxuLy8gVGhhbmtzIHRvIEpvaG4gUmVzaWcgYW5kIERlYW4gRWR3YXJkcyBmb3IgaW5zcGlyYXRpb24hXHJcblxyXG5mdW5jdGlvbiBDbGFzcygpIHt9XHJcblxyXG5DbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGV4dGVuZChwcm9wczogT2JqZWN0KTogRnVuY3Rpb25cclxuXHQvLyBbRXh0ZW5kcyB0aGUgY3VycmVudCBjbGFzc10oI2NsYXNzLWluaGVyaXRhbmNlKSBnaXZlbiB0aGUgcHJvcGVydGllcyB0byBiZSBpbmNsdWRlZC5cclxuXHQvLyBSZXR1cm5zIGEgSmF2YXNjcmlwdCBmdW5jdGlvbiB0aGF0IGlzIGEgY2xhc3MgY29uc3RydWN0b3IgKHRvIGJlIGNhbGxlZCB3aXRoIGBuZXdgKS5cclxuXHR2YXIgTmV3Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gY2FsbCB0aGUgY29uc3RydWN0b3JcclxuXHRcdGlmICh0aGlzLmluaXRpYWxpemUpIHtcclxuXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2FsbCBhbGwgY29uc3RydWN0b3IgaG9va3NcclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cdH07XHJcblxyXG5cdHZhciBwYXJlbnRQcm90byA9IE5ld0NsYXNzLl9fc3VwZXJfXyA9IHRoaXMucHJvdG90eXBlO1xyXG5cclxuXHR2YXIgcHJvdG8gPSBjcmVhdGUocGFyZW50UHJvdG8pO1xyXG5cdHByb3RvLmNvbnN0cnVjdG9yID0gTmV3Q2xhc3M7XHJcblxyXG5cdE5ld0NsYXNzLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cclxuXHQvLyBpbmhlcml0IHBhcmVudCdzIHN0YXRpY3NcclxuXHRmb3IgKHZhciBpIGluIHRoaXMpIHtcclxuXHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KGkpICYmIGkgIT09ICdwcm90b3R5cGUnICYmIGkgIT09ICdfX3N1cGVyX18nKSB7XHJcblx0XHRcdE5ld0NsYXNzW2ldID0gdGhpc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIG1peCBzdGF0aWMgcHJvcGVydGllcyBpbnRvIHRoZSBjbGFzc1xyXG5cdGlmIChwcm9wcy5zdGF0aWNzKSB7XHJcblx0XHRleHRlbmQoTmV3Q2xhc3MsIHByb3BzLnN0YXRpY3MpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLnN0YXRpY3M7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggaW5jbHVkZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcblx0XHRjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhwcm9wcy5pbmNsdWRlcyk7XHJcblx0XHRleHRlbmQuYXBwbHkobnVsbCwgW3Byb3RvXS5jb25jYXQocHJvcHMuaW5jbHVkZXMpKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5pbmNsdWRlcztcclxuXHR9XHJcblxyXG5cdC8vIG1lcmdlIG9wdGlvbnNcclxuXHRpZiAocHJvdG8ub3B0aW9ucykge1xyXG5cdFx0cHJvcHMub3B0aW9ucyA9IGV4dGVuZChjcmVhdGUocHJvdG8ub3B0aW9ucyksIHByb3BzLm9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0ZXh0ZW5kKHByb3RvLCBwcm9wcyk7XHJcblxyXG5cdHByb3RvLl9pbml0SG9va3MgPSBbXTtcclxuXHJcblx0Ly8gYWRkIG1ldGhvZCBmb3IgY2FsbGluZyBhbGwgaG9va3NcclxuXHRwcm90by5jYWxsSW5pdEhvb2tzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MpIHtcclxuXHRcdFx0cGFyZW50UHJvdG8uY2FsbEluaXRIb29rcy5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRIb29rc0NhbGxlZCA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3RvLl9pbml0SG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cHJvdG8uX2luaXRIb29rc1tpXS5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiBOZXdDbGFzcztcclxufTtcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaW5jbHVkZShwcm9wZXJ0aWVzOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtJbmNsdWRlcyBhIG1peGluXSgjY2xhc3MtaW5jbHVkZXMpIGludG8gdGhlIGN1cnJlbnQgY2xhc3MuXHJcbkNsYXNzLmluY2x1ZGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHRleHRlbmQodGhpcy5wcm90b3R5cGUsIHByb3BzKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9uczogT2JqZWN0KTogdGhpc1xyXG4vLyBbTWVyZ2VzIGBvcHRpb25zYF0oI2NsYXNzLW9wdGlvbnMpIGludG8gdGhlIGRlZmF1bHRzIG9mIHRoZSBjbGFzcy5cclxuQ2xhc3MubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRleHRlbmQodGhpcy5wcm90b3R5cGUub3B0aW9ucywgb3B0aW9ucyk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkSW5pdEhvb2soZm46IEZ1bmN0aW9uKTogdGhpc1xyXG4vLyBBZGRzIGEgW2NvbnN0cnVjdG9yIGhvb2tdKCNjbGFzcy1jb25zdHJ1Y3Rvci1ob29rcykgdG8gdGhlIGNsYXNzLlxyXG5DbGFzcy5hZGRJbml0SG9vayA9IGZ1bmN0aW9uIChmbikgeyAvLyAoRnVuY3Rpb24pIHx8IChTdHJpbmcsIGFyZ3MuLi4pXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuXHR2YXIgaW5pdCA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpc1tmbl0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0fTtcclxuXHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyA9IHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgfHwgW107XHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcy5wdXNoKGluaXQpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gY2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMoaW5jbHVkZXMpIHtcclxuXHRpZiAodHlwZW9mIEwgPT09ICd1bmRlZmluZWQnIHx8ICFMIHx8ICFMLk1peGluKSB7IHJldHVybjsgfVxyXG5cclxuXHRpbmNsdWRlcyA9IGlzQXJyYXkoaW5jbHVkZXMpID8gaW5jbHVkZXMgOiBbaW5jbHVkZXNdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGluY2x1ZGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAoaW5jbHVkZXNbaV0gPT09IEwuTWl4aW4uRXZlbnRzKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCBpbmNsdWRlIG9mIEwuTWl4aW4uRXZlbnRzOiAnICtcclxuXHRcdFx0XHQndGhpcyBwcm9wZXJ0eSB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzLCAnICtcclxuXHRcdFx0XHQncGxlYXNlIGluaGVyaXQgZnJvbSBMLkV2ZW50ZWQgaW5zdGVhZC4nLCBuZXcgRXJyb3IoKS5zdGFjayk7XHJcblx0XHR9XHJcblx0fVxyXG59XG5cbi8qXHJcbiAqIEBjbGFzcyBFdmVudGVkXHJcbiAqIEBha2EgTC5FdmVudGVkXHJcbiAqIEBpbmhlcml0cyBDbGFzc1xyXG4gKlxyXG4gKiBBIHNldCBvZiBtZXRob2RzIHNoYXJlZCBiZXR3ZWVuIGV2ZW50LXBvd2VyZWQgY2xhc3NlcyAobGlrZSBgTWFwYCBhbmQgYE1hcmtlcmApLiBHZW5lcmFsbHksIGV2ZW50cyBhbGxvdyB5b3UgdG8gZXhlY3V0ZSBzb21lIGZ1bmN0aW9uIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgd2l0aCBhbiBvYmplY3QgKGUuZy4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAsIGNhdXNpbmcgdGhlIG1hcCB0byBmaXJlIGAnY2xpY2snYCBldmVudCkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAqIFx0YWxlcnQoZS5sYXRsbmcpO1xyXG4gKiB9ICk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlYWxzIHdpdGggZXZlbnQgbGlzdGVuZXJzIGJ5IHJlZmVyZW5jZSwgc28gaWYgeW91IHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIgYW5kIHRoZW4gcmVtb3ZlIGl0LCBkZWZpbmUgaXQgYXMgYSBmdW5jdGlvbjpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gb25DbGljayhlKSB7IC4uLiB9XHJcbiAqXHJcbiAqIG1hcC5vbignY2xpY2snLCBvbkNsaWNrKTtcclxuICogbWFwLm9mZignY2xpY2snLCBvbkNsaWNrKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIEV2ZW50cyA9IHtcclxuXHQvKiBAbWV0aG9kIG9uKHR5cGU6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgb2YgdGhlIG9iamVjdC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyIChvYmplY3QgdGhlIHRoaXMga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbCBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb24oZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblx0ICovXHJcblx0b246IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHQvLyB0eXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHQvLyB3ZSBkb24ndCBwcm9jZXNzIHNwYWNlLXNlcGFyYXRlZCBldmVudHMgaGVyZSBmb3IgcGVyZm9ybWFuY2U7XHJcblx0XHRcdFx0Ly8gaXQncyBhIGhvdCBwYXRoIHNpbmNlIExheWVyIHVzZXMgdGhlIG9uKG9iaikgc3ludGF4XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHR5cGVzIGNhbiBiZSBhIHN0cmluZyBvZiBzcGFjZS1zZXBhcmF0ZWQgd29yZHNcclxuXHRcdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvKiBAbWV0aG9kIG9mZih0eXBlOiBTdHJpbmcsIGZuPzogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgb2YgdGhhdCBwYXJ0aWN1bGFyIGV2ZW50IGZyb20gdGhlIG9iamVjdC4gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBgb25gLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmY6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyBvbiB0aGUgb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGltcGxpY2l0bHkgYXR0YWNoZWQgZXZlbnRzLlxyXG5cdCAqL1xyXG5cdG9mZjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICghdHlwZXMpIHtcclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHNcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50cztcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gYXR0YWNoIGxpc3RlbmVyICh3aXRob3V0IHN5bnRhY3RpYyBzdWdhciBub3cpXHJcblx0X29uOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcclxuXHJcblx0XHQvKiBnZXQvaW5pdCBsaXN0ZW5lcnMgZm9yIHR5cGUgKi9cclxuXHRcdHZhciB0eXBlTGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKCF0eXBlTGlzdGVuZXJzKSB7XHJcblx0XHRcdHR5cGVMaXN0ZW5lcnMgPSBbXTtcclxuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gdHlwZUxpc3RlbmVycztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHR2YXIgbmV3TGlzdGVuZXIgPSB7Zm46IGZuLCBjdHg6IGNvbnRleHR9LFxyXG5cdFx0ICAgIGxpc3RlbmVycyA9IHR5cGVMaXN0ZW5lcnM7XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgZm4gYWxyZWFkeSB0aGVyZVxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbiAmJiBsaXN0ZW5lcnNbaV0uY3R4ID09PSBjb250ZXh0KSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGlzdGVuZXJzLnB1c2gobmV3TGlzdGVuZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9vZmY6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyxcclxuXHRcdCAgICBpLFxyXG5cdFx0ICAgIGxlbjtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2V2ZW50cykgeyByZXR1cm47IH1cclxuXHJcblx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghZm4pIHtcclxuXHRcdFx0Ly8gU2V0IGFsbCByZW1vdmVkIGxpc3RlbmVycyB0byBub29wIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRsaXN0ZW5lcnNbaV0uZm4gPSBmYWxzZUZuO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgZm9yIGEgdHlwZSBpZiBmdW5jdGlvbiBpc24ndCBzcGVjaWZpZWRcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxpc3RlbmVycykge1xyXG5cclxuXHRcdFx0Ly8gZmluZCBmbiBhbmQgcmVtb3ZlIGl0XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xyXG5cdFx0XHRcdGlmIChsLmN0eCAhPT0gY29udGV4dCkgeyBjb250aW51ZTsgfVxyXG5cdFx0XHRcdGlmIChsLmZuID09PSBmbikge1xyXG5cclxuXHRcdFx0XHRcdC8vIHNldCB0aGUgcmVtb3ZlZCBsaXN0ZW5lciB0byBub29wIHNvIHRoYXQncyBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuXHRcdFx0XHRcdGwuZm4gPSBmYWxzZUZuO1xyXG5cclxuXHRcdFx0XHRcdGlmICh0aGlzLl9maXJpbmdDb3VudCkge1xyXG5cdFx0XHRcdFx0XHQvKiBjb3B5IGFycmF5IGluIGNhc2UgZXZlbnRzIGFyZSBiZWluZyBmaXJlZCAqL1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmlyZSh0eXBlOiBTdHJpbmcsIGRhdGE/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gRmlyZXMgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhbiBkYXRhXHJcblx0Ly8gb2JqZWN0IOKAlCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgY29udGFpbiBpdHNcclxuXHQvLyBwcm9wZXJ0aWVzLiBUaGUgZXZlbnQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCB0byBldmVudCBwYXJlbnRzLlxyXG5cdGZpcmU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBwcm9wYWdhdGUpIHtcclxuXHRcdGlmICghdGhpcy5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgZXZlbnQgPSBleHRlbmQoe30sIGRhdGEsIHtcclxuXHRcdFx0dHlwZTogdHlwZSxcclxuXHRcdFx0dGFyZ2V0OiB0aGlzLFxyXG5cdFx0XHRzb3VyY2VUYXJnZXQ6IGRhdGEgJiYgZGF0YS5zb3VyY2VUYXJnZXQgfHwgdGhpc1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2V2ZW50cykge1xyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuXHRcdFx0aWYgKGxpc3RlbmVycykge1xyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50ID0gKHRoaXMuX2ZpcmluZ0NvdW50ICsgMSkgfHwgMTtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRcdGwuZm4uY2FsbChsLmN0eCB8fCB0aGlzLCBldmVudCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudC0tO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHBhcmVudHMgKHNldCB3aXRoIGFkZEV2ZW50UGFyZW50KVxyXG5cdFx0XHR0aGlzLl9wcm9wYWdhdGVFdmVudChldmVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBoYXMgYW55IGxpc3RlbmVycyBhdHRhY2hlZCB0byBpdC5cclxuXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLmxlbmd0aCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gYWxzbyBjaGVjayBwYXJlbnRzIGZvciBsaXN0ZW5lcnMgaWYgZXZlbnQgcHJvcGFnYXRlc1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb25jZSjigKYpOiB0aGlzXHJcblx0Ly8gQmVoYXZlcyBhcyBbYG9uKOKApilgXSgjZXZlbnRlZC1vbiksIGV4Y2VwdCB0aGUgbGlzdGVuZXIgd2lsbCBvbmx5IGdldCBmaXJlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXHJcblx0b25jZTogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLm9uY2UodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IGJpbmQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAub2ZmKHR5cGVzLCBmbiwgY29udGV4dClcclxuXHRcdFx0ICAgIC5vZmYodHlwZXMsIGhhbmRsZXIsIGNvbnRleHQpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0Ly8gYWRkIGEgbGlzdGVuZXIgdGhhdCdzIGV4ZWN1dGVkIG9uY2UgYW5kIHJlbW92ZWQgYWZ0ZXIgdGhhdFxyXG5cdFx0cmV0dXJuIHRoaXNcclxuXHRcdCAgICAub24odHlwZXMsIGZuLCBjb250ZXh0KVxyXG5cdFx0ICAgIC5vbih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBldmVudCBwYXJlbnQgLSBhbiBgRXZlbnRlZGAgdGhhdCB3aWxsIHJlY2VpdmUgcHJvcGFnYXRlZCBldmVudHNcclxuXHRhZGRFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dGhpcy5fZXZlbnRQYXJlbnRzID0gdGhpcy5fZXZlbnRQYXJlbnRzIHx8IHt9O1xyXG5cdFx0dGhpcy5fZXZlbnRQYXJlbnRzW3N0YW1wKG9iaildID0gb2JqO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBldmVudCBwYXJlbnQsIHNvIGl0IHdpbGwgc3RvcCByZWNlaXZpbmcgcHJvcGFnYXRlZCBldmVudHNcclxuXHRyZW1vdmVFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRQYXJlbnRzW3N0YW1wKG9iaildO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Byb3BhZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdHRoaXMuX2V2ZW50UGFyZW50c1tpZF0uZmlyZShlLnR5cGUsIGV4dGVuZCh7XHJcblx0XHRcdFx0bGF5ZXI6IGUudGFyZ2V0LFxyXG5cdFx0XHRcdHByb3BhZ2F0ZWRGcm9tOiBlLnRhcmdldFxyXG5cdFx0XHR9LCBlKSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLy8gYWxpYXNlczsgd2Ugc2hvdWxkIGRpdGNoIHRob3NlIGV2ZW50dWFsbHlcclxuXHJcbi8vIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKVxyXG5FdmVudHMuYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbjtcclxuXHJcbi8vIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKOKApilgXSgjZXZlbnRlZC1vZmYpXHJcblxyXG4vLyBAbWV0aG9kIGNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZigpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5FdmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5jbGVhckFsbEV2ZW50TGlzdGVuZXJzID0gRXZlbnRzLm9mZjtcclxuXHJcbi8vIEBtZXRob2QgYWRkT25lVGltZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uY2Uo4oCmKWBdKCNldmVudGVkLW9uY2UpXHJcbkV2ZW50cy5hZGRPbmVUaW1lRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbmNlO1xyXG5cclxuLy8gQG1ldGhvZCBmaXJlRXZlbnQo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYGZpcmUo4oCmKWBdKCNldmVudGVkLWZpcmUpXHJcbkV2ZW50cy5maXJlRXZlbnQgPSBFdmVudHMuZmlyZTtcclxuXHJcbi8vIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lcnMo4oCmKTogQm9vbGVhblxyXG4vLyBBbGlhcyB0byBbYGxpc3RlbnMo4oCmKWBdKCNldmVudGVkLWxpc3RlbnMpXHJcbkV2ZW50cy5oYXNFdmVudExpc3RlbmVycyA9IEV2ZW50cy5saXN0ZW5zO1xyXG5cclxudmFyIEV2ZW50ZWQgPSBDbGFzcy5leHRlbmQoRXZlbnRzKTtcblxuLypcclxuICogQGNsYXNzIFBvaW50XHJcbiAqIEBha2EgTC5Qb2ludFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcG9pbnQgd2l0aCBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBpbiBwaXhlbHMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwb2ludCA9IEwucG9pbnQoMjAwLCAzMDApO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyBhbmQgb3B0aW9ucyB0aGF0IGFjY2VwdCBgUG9pbnRgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5wYW5CeShbMjAwLCAzMDBdKTtcclxuICogbWFwLnBhbkJ5KEwucG9pbnQoMjAwLCAzMDApKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgUG9pbnRgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFBvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0Ly8gQHByb3BlcnR5IHg6IE51bWJlcjsgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG5cdHRoaXMueCA9IChyb3VuZCA/IE1hdGgucm91bmQoeCkgOiB4KTtcclxuXHQvLyBAcHJvcGVydHkgeTogTnVtYmVyOyBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy55ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh5KSA6IHkpO1xyXG59XHJcblxyXG52YXIgdHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uICh2KSB7XHJcblx0cmV0dXJuIHYgPiAwID8gTWF0aC5mbG9vcih2KSA6IE1hdGguY2VpbCh2KTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9uZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50LlxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGFkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBub24tZGVzdHJ1Y3RpdmUsIHJldHVybnMgYSBuZXcgcG9pbnRcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2FkZCh0b1BvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X2FkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XHJcblx0XHR0aGlzLnggKz0gcG9pbnQueDtcclxuXHRcdHRoaXMueSArPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzdWJ0cmFjdChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCBmcm9tIHRoZSBjdXJyZW50LlxyXG5cdHN1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3N1YnRyYWN0KHRvUG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfc3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dGhpcy54IC09IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgLT0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGl2aWRlQnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdGRpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9kaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54IC89IG51bTtcclxuXHRcdHRoaXMueSAvPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG11bHRpcGx5QnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfbXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54ICo9IG51bTtcclxuXHRcdHRoaXMueSAqPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBNdWx0aXBseSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgZWFjaCBjb29yZGluYXRlIG9mXHJcblx0Ly8gYHNjYWxlYC4gSW4gbGluZWFyIGFsZ2VicmEgdGVybXMsIG11bHRpcGx5IHRoZSBwb2ludCBieSB0aGVcclxuXHQvLyBbc2NhbGluZyBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjYWxpbmdfJTI4Z2VvbWV0cnklMjkjTWF0cml4X3JlcHJlc2VudGF0aW9uKVxyXG5cdC8vIGRlZmluZWQgYnkgYHNjYWxlYC5cclxuXHRzY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZUJ5YC4gRGl2aWRlIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieVxyXG5cdC8vIGVhY2ggY29vcmRpbmF0ZSBvZiBgc2NhbGVgLlxyXG5cdHVuc2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgcm91bmQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHJvdW5kZWQgY29vcmRpbmF0ZXMuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X3JvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZsb29yKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBmbG9vcmVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIGRvd24pLlxyXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9mbG9vcigpO1xyXG5cdH0sXHJcblxyXG5cdF9mbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjZWlsKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBjZWlsZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdXApLlxyXG5cdGNlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2NlaWwoKTtcclxuXHR9LFxyXG5cclxuXHRfY2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdHJ1bmMoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHRydW5jYXRlZCBjb29yZGluYXRlcyAocm91bmRlZCB0b3dhcmRzIHplcm8pLlxyXG5cdHRydW5jOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl90cnVuYygpO1xyXG5cdH0sXHJcblxyXG5cdF90cnVuYzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gdHJ1bmModGhpcy54KTtcclxuXHRcdHRoaXMueSA9IHRydW5jKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJQb2ludDogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjYXJ0ZXNpYW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy54LFxyXG5cdFx0ICAgIHkgPSBwb2ludC55IC0gdGhpcy55O1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBvaW50IGhhcyB0aGUgc2FtZSBjb29yZGluYXRlcy5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmXHJcblx0XHQgICAgICAgcG9pbnQueSA9PT0gdGhpcy55O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gcG9pbnQgYXJlIGxlc3MgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBjdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzIChpbiBhYnNvbHV0ZSB2YWx1ZXMpLlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiZcclxuXHRcdCAgICAgICBNYXRoLmFicyhwb2ludC55KSA8PSBNYXRoLmFicyh0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICdQb2ludCgnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueCkgKyAnLCAnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueSkgKyAnKSc7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQGZhY3RvcnkgTC5wb2ludCh4OiBOdW1iZXIsIHk6IE51bWJlciwgcm91bmQ/OiBCb29sZWFuKVxyXG4vLyBDcmVhdGVzIGEgUG9pbnQgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzLiBJZiBvcHRpb25hbCBgcm91bmRgIGlzIHNldCB0byB0cnVlLCByb3VuZHMgdGhlIGB4YCBhbmQgYHlgIHZhbHVlcy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogTnVtYmVyW10pXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5XWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogT2JqZWN0KVxyXG4vLyBFeHBlY3RzIGEgcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eDogTnVtYmVyLCB5OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5mdW5jdGlvbiB0b1BvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0aWYgKHggaW5zdGFuY2VvZiBQb2ludCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmIChpc0FycmF5KHgpKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHhbMF0sIHhbMV0pO1xyXG5cdH1cclxuXHRpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGwpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmICd4JyBpbiB4ICYmICd5JyBpbiB4KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHgueCwgeC55KTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbn1cblxuLypcclxuICogQGNsYXNzIEJvdW5kc1xyXG4gKiBAYWthIEwuQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIGluIHBpeGVsIGNvb3JkaW5hdGVzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcDEgPSBMLnBvaW50KDEwLCAxMCksXHJcbiAqIHAyID0gTC5wb2ludCg0MCwgNjApLFxyXG4gKiBib3VuZHMgPSBMLmJvdW5kcyhwMSwgcDIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBgQm91bmRzYCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogb3RoZXJCb3VuZHMuaW50ZXJzZWN0cyhbWzEwLCAxMF0sIFs0MCwgNjBdXSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYEJvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoIWEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBwb2ludHMgPSBiID8gW2EsIGJdIDogYTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQocG9pbnRzW2ldKTtcclxuXHR9XHJcbn1cclxuXHJcbkJvdW5kcy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBleHRlbmQocG9pbnQ6IFBvaW50KTogdGhpc1xyXG5cdC8vIEV4dGVuZHMgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludC5cclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtaW46IFBvaW50XHJcblx0XHQvLyBUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHQvLyBAcHJvcGVydHkgbWF4OiBQb2ludFxyXG5cdFx0Ly8gVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHRcdGlmICghdGhpcy5taW4gJiYgIXRoaXMubWF4KSB7XHJcblx0XHRcdHRoaXMubWluID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdFx0dGhpcy5tYXggPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5taW4ueCA9IE1hdGgubWluKHBvaW50LngsIHRoaXMubWluLngpO1xyXG5cdFx0XHR0aGlzLm1heC54ID0gTWF0aC5tYXgocG9pbnQueCwgdGhpcy5tYXgueCk7XHJcblx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihwb2ludC55LCB0aGlzLm1pbi55KTtcclxuXHRcdFx0dGhpcy5tYXgueSA9IE1hdGgubWF4KHBvaW50LnksIHRoaXMubWF4LnkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIocm91bmQ/OiBCb29sZWFuKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uIChyb3VuZCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnggKyB0aGlzLm1heC54KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi55ICsgdGhpcy5tYXgueSkgLyAyLCByb3VuZCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21MZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRCb3R0b21MZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMubWluLngsIHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0VG9wUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRUb3BSaWdodDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLm1heC54LCB0aGlzLm1pbi55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFRvcExlZnQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5taW5gXSgjYm91bmRzLW1pbikpLlxyXG5cdGdldFRvcExlZnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1pbjsgLy8gbGVmdCwgdG9wXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21SaWdodCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGJvdHRvbS1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5tYXhgXSgjYm91bmRzLW1heCkpLlxyXG5cdGdldEJvdHRvbVJpZ2h0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXg7IC8vIHJpZ2h0LCBib3R0b21cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBib3VuZHNcclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXguc3VidHJhY3QodGhpcy5taW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhwb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBtaW4sIG1heDtcclxuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgUG9pbnQpIHtcclxuXHRcdFx0b2JqID0gdG9Qb2ludChvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gdG9Cb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcblx0XHRcdG1pbiA9IG9iai5taW47XHJcblx0XHRcdG1heCA9IG9iai5tYXg7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtaW4gPSBtYXggPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChtaW4ueCA+PSB0aGlzLm1pbi54KSAmJlxyXG5cdFx0ICAgICAgIChtYXgueCA8PSB0aGlzLm1heC54KSAmJlxyXG5cdFx0ICAgICAgIChtaW4ueSA+PSB0aGlzLm1pbi55KSAmJlxyXG5cdFx0ICAgICAgIChtYXgueSA8PSB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG5cdC8vIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhJbnRlcnNlY3RzID0gKG1heDIueCA+PSBtaW4ueCkgJiYgKG1pbjIueCA8PSBtYXgueCksXHJcblx0XHQgICAgeUludGVyc2VjdHMgPSAobWF4Mi55ID49IG1pbi55KSAmJiAobWluMi55IDw9IG1heC55KTtcclxuXHJcblx0XHRyZXR1cm4geEludGVyc2VjdHMgJiYgeUludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG5cdC8vIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcblx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeE92ZXJsYXBzID0gKG1heDIueCA+IG1pbi54KSAmJiAobWluMi54IDwgbWF4LngpLFxyXG5cdFx0ICAgIHlPdmVybGFwcyA9IChtYXgyLnkgPiBtaW4ueSkgJiYgKG1pbjIueSA8IG1heC55KTtcclxuXHJcblx0XHRyZXR1cm4geE92ZXJsYXBzICYmIHlPdmVybGFwcztcclxuXHR9LFxyXG5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5taW4gJiYgdGhpcy5tYXgpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhjb3JuZXIxOiBQb2ludCwgY29ybmVyMjogUG9pbnQpXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdHdvIGNvcm5lcnMgY29vcmRpbmF0ZSBwYWlycy5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKHBvaW50czogUG9pbnRbXSlcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgcG9pbnRzLlxyXG5mdW5jdGlvbiB0b0JvdW5kcyhhLCBiKSB7XHJcblx0aWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEJvdW5kcyhhLCBiKTtcclxufVxuXG4vKlxyXG4gKiBAY2xhc3MgTGF0TG5nQm91bmRzXHJcbiAqIEBha2EgTC5MYXRMbmdCb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGdlb2dyYXBoaWNhbCBhcmVhIG9uIGEgbWFwLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgY29ybmVyMSA9IEwubGF0TG5nKDQwLjcxMiwgLTc0LjIyNyksXHJcbiAqIGNvcm5lcjIgPSBMLmxhdExuZyg0MC43NzQsIC03NC4xMjUpLFxyXG4gKiBib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nQm91bmRzIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAuZml0Qm91bmRzKFtcclxuICogXHRbNDAuNzEyLCAtNzQuMjI3XSxcclxuICogXHRbNDAuNzc0LCAtNzQuMTI1XVxyXG4gKiBdKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIENhdXRpb246IGlmIHRoZSBhcmVhIGNyb3NzZXMgdGhlIGFudGltZXJpZGlhbiAob2Z0ZW4gY29uZnVzZWQgd2l0aCB0aGUgSW50ZXJuYXRpb25hbCBEYXRlIExpbmUpLCB5b3UgbXVzdCBzcGVjaWZ5IGNvcm5lcnMgX291dHNpZGVfIHRoZSBbLTE4MCwgMTgwXSBkZWdyZWVzIGxvbmdpdHVkZSByYW5nZS5cclxuICpcclxuICogTm90ZSB0aGF0IGBMYXRMbmdCb3VuZHNgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIExhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKSB7IC8vIChMYXRMbmcsIExhdExuZykgb3IgKExhdExuZ1tdKVxyXG5cdGlmICghY29ybmVyMSkgeyByZXR1cm47IH1cclxuXHJcblx0dmFyIGxhdGxuZ3MgPSBjb3JuZXIyID8gW2Nvcm5lcjEsIGNvcm5lcjJdIDogY29ybmVyMTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKGxhdGxuZ3NbaV0pO1xyXG5cdH1cclxufVxyXG5cclxuTGF0TG5nQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnRcclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBib3VuZHNcclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcblx0XHRcdHN3MiA9IG9iajtcclxuXHRcdFx0bmUyID0gb2JqO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5fc291dGhXZXN0O1xyXG5cdFx0XHRuZTIgPSBvYmouX25vcnRoRWFzdDtcclxuXHJcblx0XHRcdGlmICghc3cyIHx8ICFuZTIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gb2JqID8gdGhpcy5leHRlbmQodG9MYXRMbmcob2JqKSB8fCB0b0xhdExuZ0JvdW5kcyhvYmopKSA6IHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFzdyAmJiAhbmUpIHtcclxuXHRcdFx0dGhpcy5fc291dGhXZXN0ID0gbmV3IExhdExuZyhzdzIubGF0LCBzdzIubG5nKTtcclxuXHRcdFx0dGhpcy5fbm9ydGhFYXN0ID0gbmV3IExhdExuZyhuZTIubGF0LCBuZTIubG5nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN3LmxhdCA9IE1hdGgubWluKHN3Mi5sYXQsIHN3LmxhdCk7XHJcblx0XHRcdHN3LmxuZyA9IE1hdGgubWluKHN3Mi5sbmcsIHN3LmxuZyk7XHJcblx0XHRcdG5lLmxhdCA9IE1hdGgubWF4KG5lMi5sYXQsIG5lLmxhdCk7XHJcblx0XHRcdG5lLmxuZyA9IE1hdGgubWF4KG5lMi5sbmcsIG5lLmxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYWQoYnVmZmVyUmF0aW86IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYm91bmRzIGNyZWF0ZWQgYnkgZXh0ZW5kaW5nIG9yIHJldHJhY3RpbmcgdGhlIGN1cnJlbnQgYm91bmRzIGJ5IGEgZ2l2ZW4gcmF0aW8gaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0Ly8gRm9yIGV4YW1wbGUsIGEgcmF0aW8gb2YgMC41IGV4dGVuZHMgdGhlIGJvdW5kcyBieSA1MCUgaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0Ly8gTmVnYXRpdmUgdmFsdWVzIHdpbGwgcmV0cmFjdCB0aGUgYm91bmRzLlxyXG5cdHBhZDogZnVuY3Rpb24gKGJ1ZmZlclJhdGlvKSB7XHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgaGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMoc3cubGF0IC0gbmUubGF0KSAqIGJ1ZmZlclJhdGlvLFxyXG5cdFx0ICAgIHdpZHRoQnVmZmVyID0gTWF0aC5hYnMoc3cubG5nIC0gbmUubG5nKSAqIGJ1ZmZlclJhdGlvO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxyXG5cdFx0ICAgICAgICBuZXcgTGF0TG5nKHN3LmxhdCAtIGhlaWdodEJ1ZmZlciwgc3cubG5nIC0gd2lkdGhCdWZmZXIpLFxyXG5cdFx0ICAgICAgICBuZXcgTGF0TG5nKG5lLmxhdCArIGhlaWdodEJ1ZmZlciwgbmUubG5nICsgd2lkdGhCdWZmZXIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxhdCArIHRoaXMuX25vcnRoRWFzdC5sYXQpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sbmcgKyB0aGlzLl9ub3J0aEVhc3QubG5nKSAvIDIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aEVhc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldE5vcnRoKCksIHRoaXMuZ2V0V2VzdCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFdlc3QoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgd2VzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGgoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldFNvdXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxhdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVhc3QoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZWFzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGgoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldE5vcnRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxhdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zIChsYXRsbmc6IExhdExuZyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuXHRjb250YWluczogZnVuY3Rpb24gKG9iaikgeyAvLyAoTGF0TG5nQm91bmRzKSBvciAoTGF0TG5nKSAtPiBCb29sZWFuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTGF0TG5nIHx8ICdsYXQnIGluIG9iaikge1xyXG5cdFx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gdG9MYXRMbmdCb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouZ2V0U291dGhXZXN0KCk7XHJcblx0XHRcdG5lMiA9IG9iai5nZXROb3J0aEVhc3QoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN3MiA9IG5lMiA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKHN3Mi5sYXQgPj0gc3cubGF0KSAmJiAobmUyLmxhdCA8PSBuZS5sYXQpICYmXHJcblx0XHQgICAgICAgKHN3Mi5sbmcgPj0gc3cubG5nKSAmJiAobmUyLmxuZyA8PSBuZS5sbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRJbnRlcnNlY3RzID0gKG5lMi5sYXQgPj0gc3cubGF0KSAmJiAoc3cyLmxhdCA8PSBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ0ludGVyc2VjdHMgPSAobmUyLmxuZyA+PSBzdy5sbmcpICYmIChzdzIubG5nIDw9IG5lLmxuZyk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdEludGVyc2VjdHMgJiYgbG5nSW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcblx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdE92ZXJsYXBzID0gKG5lMi5sYXQgPiBzdy5sYXQpICYmIChzdzIubGF0IDwgbmUubGF0KSxcclxuXHRcdCAgICBsbmdPdmVybGFwcyA9IChuZTIubG5nID4gc3cubG5nKSAmJiAoc3cyLmxuZyA8IG5lLmxuZyk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdE92ZXJsYXBzICYmIGxuZ092ZXJsYXBzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9CQm94U3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgd2l0aCBib3VuZGluZyBib3ggY29vcmRpbmF0ZXMgaW4gYSAnc291dGh3ZXN0X2xuZyxzb3V0aHdlc3RfbGF0LG5vcnRoZWFzdF9sbmcsbm9ydGhlYXN0X2xhdCcgZm9ybWF0LiBVc2VmdWwgZm9yIHNlbmRpbmcgcmVxdWVzdHMgdG8gd2ViIHNlcnZpY2VzIHRoYXQgcmV0dXJuIGdlbyBkYXRhLlxyXG5cdHRvQkJveFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIFt0aGlzLmdldFdlc3QoKSwgdGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSwgdGhpcy5nZXROb3J0aCgpXS5qb2luKCcsJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKSB0byB0aGUgZ2l2ZW4gYm91bmRzLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoYm91bmRzLCBtYXhNYXJnaW4pIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5lcXVhbHMoYm91bmRzLmdldFNvdXRoV2VzdCgpLCBtYXhNYXJnaW4pICYmXHJcblx0XHQgICAgICAgdGhpcy5fbm9ydGhFYXN0LmVxdWFscyhib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIG1heE1hcmdpbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm91bmRzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5fc291dGhXZXN0ICYmIHRoaXMuX25vcnRoRWFzdCk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gVE9ETyBJbnRlcm5hdGlvbmFsIGRhdGUgbGluZT9cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGNvcm5lcjE6IExhdExuZywgY29ybmVyMjogTGF0TG5nKVxyXG4vLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGJ5IGRlZmluaW5nIHR3byBkaWFnb25hbGx5IG9wcG9zaXRlIGNvcm5lcnMgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhsYXRsbmdzOiBMYXRMbmdbXSlcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBkZWZpbmVkIGJ5IHRoZSBnZW9ncmFwaGljYWwgcG9pbnRzIGl0IGNvbnRhaW5zLiBWZXJ5IHVzZWZ1bCBmb3Igem9vbWluZyB0aGUgbWFwIHRvIGZpdCBhIHBhcnRpY3VsYXIgc2V0IG9mIGxvY2F0aW9ucyB3aXRoIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5mdW5jdGlvbiB0b0xhdExuZ0JvdW5kcyhhLCBiKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhhLCBiKTtcclxufVxuXG4vKiBAY2xhc3MgTGF0TG5nXHJcbiAqIEBha2EgTC5MYXRMbmdcclxuICpcclxuICogUmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIGEgY2VydGFpbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogdmFyIGxhdGxuZyA9IEwubGF0TG5nKDUwLjUsIDMwLjUpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmcgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gYW5kIHNpbXBsZSBvYmplY3QgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gKlxyXG4gKiBgYGBcclxuICogbWFwLnBhblRvKFs1MCwgMzBdKTtcclxuICogbWFwLnBhblRvKHtsb246IDMwLCBsYXQ6IDUwfSk7XHJcbiAqIG1hcC5wYW5Ubyh7bGF0OiA1MCwgbG5nOiAzMH0pO1xyXG4gKiBtYXAucGFuVG8oTC5sYXRMbmcoNTAsIDMwKSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYExhdExuZ2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZywgYWx0KSB7XHJcblx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XHJcblx0fVxyXG5cclxuXHQvLyBAcHJvcGVydHkgbGF0OiBOdW1iZXJcclxuXHQvLyBMYXRpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuXHQvLyBAcHJvcGVydHkgbG5nOiBOdW1iZXJcclxuXHQvLyBMb25naXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubG5nID0gK2xuZztcclxuXHJcblx0Ly8gQHByb3BlcnR5IGFsdDogTnVtYmVyXHJcblx0Ly8gQWx0aXR1ZGUgaW4gbWV0ZXJzIChvcHRpb25hbClcclxuXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuYWx0ID0gK2FsdDtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJMYXRMbmc6IExhdExuZywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKG9iaiwgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cclxuXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG5cdFx0cmV0dXJuIG1hcmdpbiA8PSAobWF4TWFyZ2luID09PSB1bmRlZmluZWQgPyAxLjBFLTkgOiBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMubGF0LCBwcmVjaXNpb24pICsgJywgJyArXHJcblx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLmxuZywgcHJlY2lzaW9uKSArICcpJztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJMYXRMbmc6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIChpbiBtZXRlcnMpIHRvIHRoZSBnaXZlbiBgTGF0TG5nYCBjYWxjdWxhdGVkIHVzaW5nIHRoZSBbU3BoZXJpY2FsIExhdyBvZiBDb3NpbmVzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGhlcmljYWxfbGF3X29mX2Nvc2luZXMpLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChvdGhlcikge1xyXG5cdFx0cmV0dXJuIEVhcnRoLmRpc3RhbmNlKHRoaXMsIHRvTGF0TG5nKG90aGVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ2Agb2JqZWN0IHdpdGggdGhlIGxvbmdpdHVkZSB3cmFwcGVkIHNvIGl0J3MgYWx3YXlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBFYXJ0aC53cmFwTGF0TG5nKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9Cb3VuZHMoc2l6ZUluTWV0ZXJzOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnMvMmAgbWV0ZXJzIGFwYXJ0IGZyb20gdGhlIGBMYXRMbmdgLlxyXG5cdHRvQm91bmRzOiBmdW5jdGlvbiAoc2l6ZUluTWV0ZXJzKSB7XHJcblx0XHR2YXIgbGF0QWNjdXJhY3kgPSAxODAgKiBzaXplSW5NZXRlcnMgLyA0MDA3NTAxNyxcclxuXHRcdCAgICBsbmdBY2N1cmFjeSA9IGxhdEFjY3VyYWN5IC8gTWF0aC5jb3MoKE1hdGguUEkgLyAxODApICogdGhpcy5sYXQpO1xyXG5cclxuXHRcdHJldHVybiB0b0xhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgW3RoaXMubGF0IC0gbGF0QWNjdXJhY3ksIHRoaXMubG5nIC0gbG5nQWNjdXJhY3ldLFxyXG5cdFx0ICAgICAgICBbdGhpcy5sYXQgKyBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgKyBsbmdBY2N1cmFjeV0pO1xyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmxhdCwgdGhpcy5sbmcsIHRoaXMuYWx0KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGxhdGl0dWRlOiBOdW1iZXIsIGxvbmdpdHVkZTogTnVtYmVyLCBhbHRpdHVkZT86IE51bWJlcik6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAoYW5kIG9wdGlvbmFsbHkgYWx0aXR1ZGUpLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW051bWJlciwgTnVtYmVyXWAgb3IgYFtOdW1iZXIsIE51bWJlciwgTnVtYmVyXWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlcn1gIG9yIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyLCBhbHQ6IE51bWJlcn1gIGluc3RlYWQuXHJcblxyXG5mdW5jdGlvbiB0b0xhdExuZyhhLCBiLCBjKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAoaXNBcnJheShhKSAmJiB0eXBlb2YgYVswXSAhPT0gJ29iamVjdCcpIHtcclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMykge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdLCBhWzJdKTtcclxuXHRcdH1cclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKGEubGF0LCAnbG5nJyBpbiBhID8gYS5sbmcgOiBhLmxvbiwgYS5hbHQpO1xyXG5cdH1cclxuXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoYSwgYiwgYyk7XHJcbn1cblxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5CYXNlXHJcbiAqIE9iamVjdCB0aGF0IGRlZmluZXMgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtcyBmb3IgcHJvamVjdGluZ1xyXG4gKiBnZW9ncmFwaGljYWwgcG9pbnRzIGludG8gcGl4ZWwgKHNjcmVlbikgY29vcmRpbmF0ZXMgYW5kIGJhY2sgKGFuZCB0b1xyXG4gKiBjb29yZGluYXRlcyBpbiBvdGhlciB1bml0cyBmb3IgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuIFNlZVxyXG4gKiBbc3BhdGlhbCByZWZlcmVuY2Ugc3lzdGVtXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Nvb3JkaW5hdGVfcmVmZXJlbmNlX3N5c3RlbSkuXHJcbiAqXHJcbiAqIExlYWZsZXQgZGVmaW5lcyB0aGUgbW9zdCB1c3VhbCBDUlNzIGJ5IGRlZmF1bHQuIElmIHlvdSB3YW50IHRvIHVzZSBhXHJcbiAqIENSUyBub3QgZGVmaW5lZCBieSBkZWZhdWx0LCB0YWtlIGEgbG9vayBhdCB0aGVcclxuICogW1Byb2o0TGVhZmxldF0oaHR0cHM6Ly9naXRodWIuY29tL2thcnRlbmEvUHJvajRMZWFmbGV0KSBwbHVnaW4uXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGUgQ1JTIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiBhbmQgY2FuJ3QgYmUgaW5zdGFudGlhdGVkLiBBbHNvLCBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gdGhlbSxcclxuICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxudmFyIENSUyA9IHtcclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvUG9pbnQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuXHRsYXRMbmdUb1BvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHByb2plY3RlZFBvaW50LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYGxhdExuZ1RvUG9pbnRgLiBQcm9qZWN0cyBwaXhlbCBjb29yZGluYXRlcyBvbiBhIGdpdmVuXHJcblx0Ly8gem9vbSBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuXHQvLyB0aGlzIENSUyAoZS5nLiBtZXRlcnMgZm9yIEVQU0c6Mzg1NywgZm9yIHBhc3NpbmcgaXQgdG8gV01TIHNlcnZpY2VzKS5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG5cdC8vIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGUoem9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIHBhcnRpY3VsYXIgem9vbS4gRm9yIGV4YW1wbGUsIGl0IHJldHVybnNcclxuXHQvLyBgMjU2ICogMl56b29tYCBmb3IgTWVyY2F0b3ItYmFzZWQgQ1JTLlxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIDI1NiAqIE1hdGgucG93KDIsIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGUoKWAsIHJldHVybnMgdGhlIHpvb20gbGV2ZWwgY29ycmVzcG9uZGluZyB0byBhIHNjYWxlXHJcblx0Ly8gZmFjdG9yIG9mIGBzY2FsZWAuXHJcblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUgLyAyNTYpIC8gTWF0aC5MTjI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGlvbidzIGJvdW5kcyBzY2FsZWQgYW5kIHRyYW5zZm9ybWVkIGZvciB0aGUgcHJvdmlkZWQgYHpvb21gLlxyXG5cdGdldFByb2plY3RlZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG5cdFx0dmFyIGIgPSB0aGlzLnByb2plY3Rpb24uYm91bmRzLFxyXG5cdFx0ICAgIHMgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1heCwgcyk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMobWluLCBtYXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuXHQvLyBTdGFuZGFyZCBjb2RlIG5hbWUgb2YgdGhlIENSUyBwYXNzZWQgaW50byBXTVMgc2VydmljZXMgKGUuZy4gYCdFUFNHOjM4NTcnYClcclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG5cdC8vIEFuIGFycmF5IG9mIHR3byBudW1iZXJzIGRlZmluaW5nIHdoZXRoZXIgdGhlIGxvbmdpdHVkZSAoaG9yaXpvbnRhbCkgY29vcmRpbmF0ZVxyXG5cdC8vIGF4aXMgd3JhcHMgYXJvdW5kIGEgZ2l2ZW4gcmFuZ2UgYW5kIGhvdy4gRGVmYXVsdHMgdG8gYFstMTgwLCAxODBdYCBpbiBtb3N0XHJcblx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExhdDogTnVtYmVyW11cclxuXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxyXG5cclxuXHQvLyB3cmFwTG5nOiBbbWluLCBtYXhdLFxyXG5cdC8vIHdyYXBMYXQ6IFttaW4sIG1heF0sXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhblxyXG5cdC8vIElmIHRydWUsIHRoZSBjb29yZGluYXRlIHNwYWNlIHdpbGwgYmUgdW5ib3VuZGVkIChpbmZpbml0ZSBpbiBib3RoIGF4ZXMpXHJcblx0aW5maW5pdGU6IGZhbHNlLFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgbGF0IGFuZCBsbmcgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBsbmcgPSB0aGlzLndyYXBMbmcgPyB3cmFwTnVtKGxhdGxuZy5sbmcsIHRoaXMud3JhcExuZywgdHJ1ZSkgOiBsYXRsbmcubG5nLFxyXG5cdFx0ICAgIGxhdCA9IHRoaXMud3JhcExhdCA/IHdyYXBOdW0obGF0bG5nLmxhdCwgdGhpcy53cmFwTGF0LCB0cnVlKSA6IGxhdGxuZy5sYXQsXHJcblx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhsYXQsIGxuZywgYWx0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nXHJcblx0Ly8gdGhhdCBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dmFyIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLndyYXBMYXRMbmcoY2VudGVyKSxcclxuXHRcdCAgICBsYXRTaGlmdCA9IGNlbnRlci5sYXQgLSBuZXdDZW50ZXIubGF0LFxyXG5cdFx0ICAgIGxuZ1NoaWZ0ID0gY2VudGVyLmxuZyAtIG5ld0NlbnRlci5sbmc7XHJcblxyXG5cdFx0aWYgKGxhdFNoaWZ0ID09PSAwICYmIGxuZ1NoaWZ0ID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBib3VuZHM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cdFx0ICAgIG5ld1N3ID0gbmV3IExhdExuZyhzdy5sYXQgLSBsYXRTaGlmdCwgc3cubG5nIC0gbG5nU2hpZnQpLFxyXG5cdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKG5ld1N3LCBuZXdOZSk7XHJcblx0fVxyXG59O1xuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuRWFydGhcbiAqXG4gKiBTZXJ2ZXMgYXMgdGhlIGJhc2UgZm9yIENSUyB0aGF0IGFyZSBnbG9iYWwgc3VjaCB0aGF0IHRoZXkgY292ZXIgdGhlIGVhcnRoLlxuICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAqIHNpbmNlIGl0IGRvZXMgbm90IGhhdmUgYSBgY29kZWAsIGBwcm9qZWN0aW9uYCBvciBgdHJhbnNmb3JtYXRpb25gLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogbWV0ZXJzLlxuICovXG5cbnZhciBFYXJ0aCA9IGV4dGVuZCh7fSwgQ1JTLCB7XG5cdHdyYXBMbmc6IFstMTgwLCAxODBdLFxuXG5cdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG5cdC8vIHRoZSBJbnRlcm5hdGlvbmFsIFVuaW9uIG9mIEdlb2Rlc3kgYW5kIEdlb3BoeXNpY3MsXG5cdC8vIHNlZSBodHRwOi8vcm9zZXR0YWNvZGUub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcblx0UjogNjM3MTAwMCxcblxuXHQvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgcG9pbnRzIHVzaW5nIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdCAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG5cdFx0ICAgIGxhdDIgPSBsYXRsbmcyLmxhdCAqIHJhZCxcblx0XHQgICAgc2luRExhdCA9IE1hdGguc2luKChsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0KSAqIHJhZCAvIDIpLFxuXHRcdCAgICBzaW5ETG9uID0gTWF0aC5zaW4oKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpICogcmFkIC8gMiksXG5cdFx0ICAgIGEgPSBzaW5ETGF0ICogc2luRExhdCArIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBzaW5ETG9uICogc2luRExvbixcblx0XHQgICAgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG5cdFx0cmV0dXJuIHRoaXMuUiAqIGM7XG5cdH1cbn0pO1xuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yXHJcbiAqXHJcbiAqIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBjb21tb24gcHJvamVjdGlvbiBmb3Igb25saW5lIG1hcHMsXHJcbiAqIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBBc3N1bWVzIHRoYXQgRWFydGggaXNcclxuICogYSBzcGhlcmUuIFVzZWQgYnkgdGhlIGBFUFNHOjM4NTdgIENSUy5cclxuICovXHJcblxyXG52YXIgZWFydGhSYWRpdXMgPSA2Mzc4MTM3O1xyXG5cclxudmFyIFNwaGVyaWNhbE1lcmNhdG9yID0ge1xyXG5cclxuXHRSOiBlYXJ0aFJhZGl1cyxcclxuXHRNQVhfTEFUSVRVREU6IDg1LjA1MTEyODc3OTgsXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuXHRcdCAgICBtYXggPSB0aGlzLk1BWF9MQVRJVFVERSxcclxuXHRcdCAgICBsYXQgPSBNYXRoLm1heChNYXRoLm1pbihtYXgsIGxhdGxuZy5sYXQpLCAtbWF4KSxcclxuXHRcdCAgICBzaW4gPSBNYXRoLnNpbihsYXQgKiBkKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0XHR0aGlzLlIgKiBsYXRsbmcubG5nICogZCxcclxuXHRcdFx0dGhpcy5SICogTWF0aC5sb2coKDEgKyBzaW4pIC8gKDEgLSBzaW4pKSAvIDIpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcblx0XHRcdCgyICogTWF0aC5hdGFuKE1hdGguZXhwKHBvaW50LnkgLyB0aGlzLlIpKSAtIChNYXRoLlBJIC8gMikpICogZCxcclxuXHRcdFx0cG9pbnQueCAqIGQgLyB0aGlzLlIpO1xyXG5cdH0sXHJcblxyXG5cdGJvdW5kczogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBkID0gZWFydGhSYWRpdXMgKiBNYXRoLlBJO1xyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMoWy1kLCAtZF0sIFtkLCBkXSk7XHJcblx0fSkoKVxyXG59O1xuXG4vKlxyXG4gKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICogQGFrYSBMLlRyYW5zZm9ybWF0aW9uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAqIGZvciB0cmFuc2Zvcm1pbmcgYSBwb2ludCBvZiBhIGZvcm0gYCh4LCB5KWAgaW50byBgKGEqeCArIGIsIGMqeSArIGQpYCBhbmQgZG9pbmdcclxuICogdGhlIHJldmVyc2UuIFVzZWQgYnkgTGVhZmxldCBpbiBpdHMgcHJvamVjdGlvbnMgY29kZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHRyYW5zZm9ybWF0aW9uID0gTC50cmFuc2Zvcm1hdGlvbigyLCA1LCAtMSwgMTApLFxyXG4gKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gKiBcdHAzID0gdHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocDIpOyAvLyAgTC5wb2ludCgxLCAyKVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gZmFjdG9yeSBuZXcgTC5UcmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbmZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuXHRpZiAoaXNBcnJheShhKSkge1xyXG5cdFx0Ly8gdXNlIGFycmF5IHByb3BlcnRpZXNcclxuXHRcdHRoaXMuX2EgPSBhWzBdO1xyXG5cdFx0dGhpcy5fYiA9IGFbMV07XHJcblx0XHR0aGlzLl9jID0gYVsyXTtcclxuXHRcdHRoaXMuX2QgPSBhWzNdO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHR0aGlzLl9hID0gYTtcclxuXHR0aGlzLl9iID0gYjtcclxuXHR0aGlzLl9jID0gYztcclxuXHR0aGlzLl9kID0gZDtcclxufVxyXG5cclxuVHJhbnNmb3JtYXRpb24ucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgdHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSB0cmFuc2Zvcm1lZCBwb2ludCwgb3B0aW9uYWxseSBtdWx0aXBsaWVkIGJ5IHRoZSBnaXZlbiBzY2FsZS5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcblx0X3RyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcblx0XHRwb2ludC55ID0gc2NhbGUgKiAodGhpcy5fYyAqIHBvaW50LnkgKyB0aGlzLl9kKTtcclxuXHRcdHJldHVybiBwb2ludDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVudHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR1bnRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdCAgICAgICAgKHBvaW50LnggLyBzY2FsZSAtIHRoaXMuX2IpIC8gdGhpcy5fYSxcclxuXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBUcmFuc2Zvcm1hdGlvbiBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oY29lZmZpY2llbnRzOiBBcnJheSk6IFRyYW5zZm9ybWF0aW9uXHJcbi8vIEV4cGVjdHMgYW4gY29lZmZpY2llbnRzIGFycmF5IG9mIHRoZSBmb3JtXHJcbi8vIGBbYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyXWAuXHJcblxyXG5mdW5jdGlvbiB0b1RyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuXHRyZXR1cm4gbmV3IFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpO1xyXG59XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzM4NTdcclxuICpcclxuICogVGhlIG1vc3QgY29tbW9uIENSUyBmb3Igb25saW5lIG1hcHMsIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsXHJcbiAqIHRpbGUgcHJvdmlkZXJzLiBVc2VzIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLiBTZXQgaW4gYnkgZGVmYXVsdCBpblxyXG4gKiBNYXAncyBgY3JzYCBvcHRpb24uXHJcbiAqL1xyXG5cclxudmFyIEVQU0czODU3ID0gZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG5cdHByb2plY3Rpb246IFNwaGVyaWNhbE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogU3BoZXJpY2FsTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXHJcbnZhciBFUFNHOTAwOTEzID0gZXh0ZW5kKHt9LCBFUFNHMzg1Nywge1xyXG5cdGNvZGU6ICdFUFNHOjkwMDkxMydcclxufSk7XG5cbi8vIEBuYW1lc3BhY2UgU1ZHOyBAc2VjdGlvblxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLlNWRzpcblxuLy8gQGZ1bmN0aW9uIGNyZWF0ZShuYW1lOiBTdHJpbmcpOiBTVkdFbGVtZW50XG4vLyBSZXR1cm5zIGEgaW5zdGFuY2Ugb2YgW1NWR0VsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KSxcbi8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWUgcGFzc2VkLiBGb3IgZXhhbXBsZSwgdXNpbmcgJ2xpbmUnIHdpbGwgcmV0dXJuXG4vLyBhbiBpbnN0YW5jZSBvZiBbU1ZHTGluZUVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdMaW5lRWxlbWVudCkuXG5mdW5jdGlvbiBzdmdDcmVhdGUobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuXG4vLyBAZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzOiBQb2ludFtdLCBjbG9zZWQ6IEJvb2xlYW4pOiBTdHJpbmdcbi8vIEdlbmVyYXRlcyBhIFNWRyBwYXRoIHN0cmluZyBmb3IgbXVsdGlwbGUgcmluZ3MsIHdpdGggZWFjaCByaW5nIHR1cm5pbmdcbi8vIGludG8gXCJNLi5MLi5MLi5cIiBpbnN0cnVjdGlvbnNcbmZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5ncywgY2xvc2VkKSB7XG5cdHZhciBzdHIgPSAnJyxcblx0aSwgaiwgbGVuLCBsZW4yLCBwb2ludHMsIHA7XG5cblx0Zm9yIChpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRwb2ludHMgPSByaW5nc1tpXTtcblxuXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRwID0gcG9pbnRzW2pdO1xuXHRcdFx0c3RyICs9IChqID8gJ0wnIDogJ00nKSArIHAueCArICcgJyArIHAueTtcblx0XHR9XG5cblx0XHQvLyBjbG9zZXMgdGhlIHJpbmcgZm9yIHBvbHlnb25zOyBcInhcIiBpcyBWTUwgc3ludGF4XG5cdFx0c3RyICs9IGNsb3NlZCA/IChzdmcgPyAneicgOiAneCcpIDogJyc7XG5cdH1cblxuXHQvLyBTVkcgY29tcGxhaW5zIGFib3V0IGVtcHR5IHBhdGggc3RyaW5nc1xuXHRyZXR1cm4gc3RyIHx8ICdNMCAwJztcbn1cblxuLypcclxuICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAqIEBha2EgTC5Ccm93c2VyXHJcbiAqXHJcbiAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIHN0eWxlJDEgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgaWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIChub3QgRWRnZSkuXHJcbnZhciBpZSA9ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3c7XHJcblxyXG4vLyBAcHJvcGVydHkgaWVsdDk6IEJvb2xlYW47IGB0cnVlYCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgbGVzcyB0aGFuIDkuXHJcbnZhciBpZWx0OSA9IGllICYmICFkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyO1xyXG5cclxuLy8gQHByb3BlcnR5IGVkZ2U6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIEVkZ2Ugd2ViIGJyb3dzZXIuXHJcbnZhciBlZGdlID0gJ21zTGF1bmNoVXJpJyBpbiBuYXZpZ2F0b3IgJiYgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCk7XHJcblxyXG4vLyBAcHJvcGVydHkgd2Via2l0OiBCb29sZWFuO1xyXG4vLyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBsaWtlIENocm9tZSBhbmQgU2FmYXJpIChpbmNsdWRpbmcgbW9iaWxlIHZlcnNpb25zKS5cclxudmFyIHdlYmtpdCA9IHVzZXJBZ2VudENvbnRhaW5zKCd3ZWJraXQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYW55IGJyb3dzZXIgcnVubmluZyBvbiBhbiBBbmRyb2lkIHBsYXRmb3JtLlxyXG52YXIgYW5kcm9pZCA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZDIzOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHJ1bm5pbmcgb24gQW5kcm9pZCAyIG9yIEFuZHJvaWQgMy5cclxudmFyIGFuZHJvaWQyMyA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDInKSB8fCB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAzJyk7XHJcblxyXG4vKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3OTYxMjY2IGZvciBkZXRhaWxzIG9uIGRldGVjdGluZyBzdG9jayBBbmRyb2lkICovXHJcbnZhciB3ZWJraXRWZXIgPSBwYXJzZUludCgvV2ViS2l0XFwvKFswLTldKyl8JC8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVsxXSwgMTApOyAvLyBhbHNvIG1hdGNoZXMgQXBwbGVXZWJLaXRcclxuLy8gQHByb3BlcnR5IGFuZHJvaWRTdG9jazogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgQW5kcm9pZCBzdG9jayBicm93c2VyIChpLmUuIG5vdCBDaHJvbWUpXHJcbnZhciBhbmRyb2lkU3RvY2sgPSBhbmRyb2lkICYmIHVzZXJBZ2VudENvbnRhaW5zKCdHb29nbGUnKSAmJiB3ZWJraXRWZXIgPCA1MzcgJiYgISgnQXVkaW9Ob2RlJyBpbiB3aW5kb3cpO1xyXG5cclxuLy8gQHByb3BlcnR5IG9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyXHJcbnZhciBvcGVyYSA9ICEhd2luZG93Lm9wZXJhO1xyXG5cclxuLy8gQHByb3BlcnR5IGNocm9tZTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgQ2hyb21lIGJyb3dzZXIuXHJcbnZhciBjaHJvbWUgPSB1c2VyQWdlbnRDb250YWlucygnY2hyb21lJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja286IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxyXG52YXIgZ2Vja28gPSB1c2VyQWdlbnRDb250YWlucygnZ2Vja28nKSAmJiAhd2Via2l0ICYmICFvcGVyYSAmJiAhaWU7XHJcblxyXG4vLyBAcHJvcGVydHkgc2FmYXJpOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBTYWZhcmkgYnJvd3Nlci5cclxudmFyIHNhZmFyaSA9ICFjaHJvbWUgJiYgdXNlckFnZW50Q29udGFpbnMoJ3NhZmFyaScpO1xyXG5cclxudmFyIHBoYW50b20gPSB1c2VyQWdlbnRDb250YWlucygncGhhbnRvbScpO1xyXG5cclxuLy8gQHByb3BlcnR5IG9wZXJhMTI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zICh2ZXJzaW9uIDEyIG9yIGxhdGVyKS5cclxudmFyIG9wZXJhMTIgPSAnT1RyYW5zaXRpb24nIGluIHN0eWxlJDE7XHJcblxyXG4vLyBAcHJvcGVydHkgd2luOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgV2luZG93cyBwbGF0Zm9ybVxyXG52YXIgd2luID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ1dpbicpID09PSAwO1xyXG5cclxuLy8gQHByb3BlcnR5IGllM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbnZhciBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBzdHlsZSQxKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3ZWJraXQzZDogQm9vbGVhbjsgYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIHdlYmtpdDNkID0gKCdXZWJLaXRDU1NNYXRyaXgnIGluIHdpbmRvdykgJiYgKCdtMTEnIGluIG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KCkpICYmICFhbmRyb2lkMjM7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja28zZDogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGUkMTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbnkzZDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgYW55M2QgPSAhd2luZG93LkxfRElTQUJMRV8zRCAmJiAoaWUzZCB8fCB3ZWJraXQzZCB8fCBnZWNrbzNkKSAmJiAhb3BlcmExMiAmJiAhcGhhbnRvbTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG52YXIgbW9iaWxlID0gdHlwZW9mIG9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJyB8fCB1c2VyQWdlbnRDb250YWlucygnbW9iaWxlJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG52YXIgbW9iaWxlV2Via2l0ID0gbW9iaWxlICYmIHdlYmtpdDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQzZDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbnZhciBtb2JpbGVXZWJraXQzZCA9IG1vYmlsZSAmJiB3ZWJraXQzZDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtc1BvaW50ZXI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyBpbXBsZW1lbnRpbmcgdGhlIE1pY3Jvc29mdCB0b3VjaCBldmVudHMgbW9kZWwgKG5vdGFibHkgSUUxMCkuXHJcbnZhciBtc1BvaW50ZXIgPSAhd2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cuTVNQb2ludGVyRXZlbnQ7XHJcblxyXG4vLyBAcHJvcGVydHkgcG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFtwb2ludGVyIGV2ZW50c10oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0NCUyOHY9dnMuODUlMjkuYXNweCkuXHJcbnZhciBwb2ludGVyID0gIXdlYmtpdCAmJiAhISh3aW5kb3cuUG9pbnRlckV2ZW50IHx8IG1zUG9pbnRlcik7XHJcblxyXG4vLyBAcHJvcGVydHkgdG91Y2g6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbdG91Y2ggZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvVG91Y2hfZXZlbnRzKS5cclxuLy8gVGhpcyBkb2VzIG5vdCBuZWNlc3NhcmlseSBtZWFuIHRoYXQgdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIGNvbXB1dGVyIHdpdGhcclxuLy8gYSB0b3VjaHNjcmVlbiwgaXQgb25seSBtZWFucyB0aGF0IHRoZSBicm93c2VyIGlzIGNhcGFibGUgb2YgdW5kZXJzdGFuZGluZ1xyXG4vLyB0b3VjaCBldmVudHMuXHJcbnZhciB0b3VjaCA9ICF3aW5kb3cuTF9OT19UT1VDSCAmJiAocG9pbnRlciB8fCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHxcclxuXHRcdCh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlT3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG52YXIgbW9iaWxlT3BlcmEgPSBtb2JpbGUgJiYgb3BlcmE7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlR2Vja286IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxudmFyIG1vYmlsZUdlY2tvID0gbW9iaWxlICYmIGdlY2tvO1xyXG5cclxuLy8gQHByb3BlcnR5IHJldGluYTogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIG9uIGEgaGlnaC1yZXNvbHV0aW9uIFwicmV0aW5hXCIgc2NyZWVuIG9yIG9uIGFueSBzY3JlZW4gd2hlbiBicm93c2VyJ3MgZGlzcGxheSB6b29tIGlzIG1vcmUgdGhhbiAxMDAlLlxyXG52YXIgcmV0aW5hID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8ICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSkgPiAxO1xyXG5cclxuLy8gQHByb3BlcnR5IHBhc3NpdmVFdmVudHM6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgcGFzc2l2ZSBldmVudHMuXHJcbnZhciBwYXNzaXZlRXZlbnRzID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgc3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gZmFsc2U7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0c3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBmYWxzZUZuLCBvcHRzKTtcclxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIGZhbHNlRm4sIG9wdHMpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8vIEVycm9ycyBjYW4gc2FmZWx5IGJlIGlnbm9yZWQgc2luY2UgdGhpcyBpcyBvbmx5IGEgYnJvd3NlciBzdXBwb3J0IHRlc3QuXHJcblx0fVxyXG5cdHJldHVybiBzdXBwb3J0c1Bhc3NpdmVPcHRpb247XHJcbn0pO1xyXG5cclxuLy8gQHByb3BlcnR5IGNhbnZhczogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxyXG52YXIgY2FudmFzID0gKGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0O1xyXG59KCkpO1xyXG5cclxuLy8gQHByb3BlcnR5IHN2ZzogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxyXG52YXIgc3ZnID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIHN2Z0NyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XHJcblxyXG4vLyBAcHJvcGVydHkgdm1sOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKS5cclxudmFyIHZtbCA9ICFzdmcgJiYgKGZ1bmN0aW9uICgpIHtcclxuXHR0cnkge1xyXG5cdFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0ZGl2LmlubmVySFRNTCA9ICc8djpzaGFwZSBhZGo9XCIxXCIvPic7XHJcblxyXG5cdFx0dmFyIHNoYXBlID0gZGl2LmZpcnN0Q2hpbGQ7XHJcblx0XHRzaGFwZS5zdHlsZS5iZWhhdmlvciA9ICd1cmwoI2RlZmF1bHQjVk1MKSc7XHJcblxyXG5cdFx0cmV0dXJuIHNoYXBlICYmICh0eXBlb2Ygc2hhcGUuYWRqID09PSAnb2JqZWN0Jyk7XHJcblxyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn0oKSk7XHJcblxyXG5cclxuZnVuY3Rpb24gdXNlckFnZW50Q29udGFpbnMoc3RyKSB7XHJcblx0cmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cikgPj0gMDtcclxufVxyXG5cblxudmFyIEJyb3dzZXIgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0aWU6IGllLFxuXHRpZWx0OTogaWVsdDksXG5cdGVkZ2U6IGVkZ2UsXG5cdHdlYmtpdDogd2Via2l0LFxuXHRhbmRyb2lkOiBhbmRyb2lkLFxuXHRhbmRyb2lkMjM6IGFuZHJvaWQyMyxcblx0YW5kcm9pZFN0b2NrOiBhbmRyb2lkU3RvY2ssXG5cdG9wZXJhOiBvcGVyYSxcblx0Y2hyb21lOiBjaHJvbWUsXG5cdGdlY2tvOiBnZWNrbyxcblx0c2FmYXJpOiBzYWZhcmksXG5cdHBoYW50b206IHBoYW50b20sXG5cdG9wZXJhMTI6IG9wZXJhMTIsXG5cdHdpbjogd2luLFxuXHRpZTNkOiBpZTNkLFxuXHR3ZWJraXQzZDogd2Via2l0M2QsXG5cdGdlY2tvM2Q6IGdlY2tvM2QsXG5cdGFueTNkOiBhbnkzZCxcblx0bW9iaWxlOiBtb2JpbGUsXG5cdG1vYmlsZVdlYmtpdDogbW9iaWxlV2Via2l0LFxuXHRtb2JpbGVXZWJraXQzZDogbW9iaWxlV2Via2l0M2QsXG5cdG1zUG9pbnRlcjogbXNQb2ludGVyLFxuXHRwb2ludGVyOiBwb2ludGVyLFxuXHR0b3VjaDogdG91Y2gsXG5cdG1vYmlsZU9wZXJhOiBtb2JpbGVPcGVyYSxcblx0bW9iaWxlR2Vja286IG1vYmlsZUdlY2tvLFxuXHRyZXRpbmE6IHJldGluYSxcblx0cGFzc2l2ZUV2ZW50czogcGFzc2l2ZUV2ZW50cyxcblx0Y2FudmFzOiBjYW52YXMsXG5cdHN2Zzogc3ZnLFxuXHR2bWw6IHZtbFxufSk7XG5cbi8qXG4gKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxuICovXG5cblxudmFyIFBPSU5URVJfRE9XTiA9ICAgbXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nICAgOiAncG9pbnRlcmRvd24nO1xudmFyIFBPSU5URVJfTU9WRSA9ICAgbXNQb2ludGVyID8gJ01TUG9pbnRlck1vdmUnICAgOiAncG9pbnRlcm1vdmUnO1xudmFyIFBPSU5URVJfVVAgPSAgICAgbXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyAgICAgOiAncG9pbnRlcnVwJztcbnZhciBQT0lOVEVSX0NBTkNFTCA9IG1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnO1xudmFyIFRBR19XSElURV9MSVNUID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnT1BUSU9OJ107XG5cbnZhciBfcG9pbnRlcnMgPSB7fTtcbnZhciBfcG9pbnRlckRvY0xpc3RlbmVyID0gZmFsc2U7XG5cbi8vIERvbUV2ZW50LkRvdWJsZVRhcCBuZWVkcyB0byBrbm93IGFib3V0IHRoaXNcbnZhciBfcG9pbnRlcnNDb3VudCA9IDA7XG5cbi8vIFByb3ZpZGVzIGEgdG91Y2ggZXZlbnRzIHdyYXBwZXIgZm9yIChtcylwb2ludGVyIGV2ZW50cy5cbi8vIHJlZiBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cbmZ1bmN0aW9uIGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIsIGlkKSB7XG5cdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRfYWRkUG9pbnRlclN0YXJ0KG9iaiwgaGFuZGxlciwgaWQpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcblx0XHRfYWRkUG9pbnRlck1vdmUob2JqLCBoYW5kbGVyLCBpZCk7XG5cblx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0X2FkZFBvaW50ZXJFbmQob2JqLCBoYW5kbGVyLCBpZCk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaWQpIHtcblx0dmFyIGhhbmRsZXIgPSBvYmpbJ19sZWFmbGV0XycgKyB0eXBlICsgaWRdO1xuXG5cdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIGhhbmRsZXIsIGZhbHNlKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBoYW5kbGVyLCBmYWxzZSk7XG5cblx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgaGFuZGxlciwgZmFsc2UpO1xuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBoYW5kbGVyLCBmYWxzZSk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJTdGFydChvYmosIGhhbmRsZXIsIGlkKSB7XG5cdHZhciBvbkRvd24gPSBiaW5kKGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUucG9pbnRlclR5cGUgIT09ICdtb3VzZScgJiYgZS5NU1BPSU5URVJfVFlQRV9NT1VTRSAmJiBlLnBvaW50ZXJUeXBlICE9PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFKSB7XG5cdFx0XHQvLyBJbiBJRTExLCBzb21lIHRvdWNoIGV2ZW50cyBuZWVkcyB0byBmaXJlIGZvciBmb3JtIGNvbnRyb2xzLCBvclxuXHRcdFx0Ly8gdGhlIGNvbnRyb2xzIHdpbGwgc3RvcCB3b3JraW5nLiBXZSBrZWVwIGEgd2hpdGVsaXN0IG9mIHRhZyBuYW1lcyB0aGF0XG5cdFx0XHQvLyBuZWVkIHRoZXNlIGV2ZW50cy4gRm9yIG90aGVyIHRhcmdldCB0YWdzLCB3ZSBwcmV2ZW50IGRlZmF1bHQgb24gdGhlIGV2ZW50LlxuXHRcdFx0aWYgKFRBR19XSElURV9MSVNULmluZGV4T2YoZS50YXJnZXQudGFnTmFtZSkgPCAwKSB7XG5cdFx0XHRcdHByZXZlbnREZWZhdWx0KGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuXHR9KTtcblxuXHRvYmpbJ19sZWFmbGV0X3RvdWNoc3RhcnQnICsgaWRdID0gb25Eb3duO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIG9uRG93biwgZmFsc2UpO1xuXG5cdC8vIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGF0IHBvaW50ZXJzIGFuZCBob3cgbWFueSBhcmUgYWN0aXZlIHRvIHByb3ZpZGUgZS50b3VjaGVzIGVtdWxhdGlvblxuXHRpZiAoIV9wb2ludGVyRG9jTGlzdGVuZXIpIHtcblx0XHQvLyB3ZSBsaXN0ZW4gZG9jdW1lbnRFbGVtZW50IGFzIGFueSBkcmFncyB0aGF0IGVuZCBieSBtb3ZpbmcgdGhlIHRvdWNoIG9mZiB0aGUgc2NyZWVuIGdldCBmaXJlZCB0aGVyZVxuXHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgX2dsb2JhbFBvaW50ZXJEb3duLCB0cnVlKTtcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIF9nbG9iYWxQb2ludGVyTW92ZSwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXG5cdFx0X3BvaW50ZXJEb2NMaXN0ZW5lciA9IHRydWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJEb3duKGUpIHtcblx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG5cdF9wb2ludGVyc0NvdW50Kys7XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyTW92ZShlKSB7XG5cdGlmIChfcG9pbnRlcnNbZS5wb2ludGVySWRdKSB7XG5cdFx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG5cdH1cbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJVcChlKSB7XG5cdGRlbGV0ZSBfcG9pbnRlcnNbZS5wb2ludGVySWRdO1xuXHRfcG9pbnRlcnNDb3VudC0tO1xufVxuXG5mdW5jdGlvbiBfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKSB7XG5cdGUudG91Y2hlcyA9IFtdO1xuXHRmb3IgKHZhciBpIGluIF9wb2ludGVycykge1xuXHRcdGUudG91Y2hlcy5wdXNoKF9wb2ludGVyc1tpXSk7XG5cdH1cblx0ZS5jaGFuZ2VkVG91Y2hlcyA9IFtlXTtcblxuXHRoYW5kbGVyKGUpO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlck1vdmUob2JqLCBoYW5kbGVyLCBpZCkge1xuXHR2YXIgb25Nb3ZlID0gZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBkb24ndCBmaXJlIHRvdWNoIG1vdmVzIHdoZW4gbW91c2UgaXNuJ3QgZG93blxuXHRcdGlmICgoZS5wb2ludGVyVHlwZSA9PT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSAmJiBlLmJ1dHRvbnMgPT09IDApIHsgcmV0dXJuOyB9XG5cblx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0fTtcblxuXHRvYmpbJ19sZWFmbGV0X3RvdWNobW92ZScgKyBpZF0gPSBvbk1vdmU7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgb25Nb3ZlLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIF9hZGRQb2ludGVyRW5kKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0dmFyIG9uVXAgPSBmdW5jdGlvbiAoZSkge1xuXHRcdF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuXHR9O1xuXG5cdG9ialsnX2xlYWZsZXRfdG91Y2hlbmQnICsgaWRdID0gb25VcDtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgb25VcCwgZmFsc2UpO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0NBTkNFTCwgb25VcCwgZmFsc2UpO1xufVxuXG4vKlxyXG4gKiBFeHRlbmRzIHRoZSBldmVudCBoYW5kbGluZyBjb2RlIHdpdGggZG91YmxlIHRhcCBzdXBwb3J0IGZvciBtb2JpbGUgYnJvd3NlcnMuXHJcbiAqL1xyXG5cclxudmFyIF90b3VjaHN0YXJ0ID0gbXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nIDogcG9pbnRlciA/ICdwb2ludGVyZG93bicgOiAndG91Y2hzdGFydCc7XHJcbnZhciBfdG91Y2hlbmQgPSBtc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnIDogcG9pbnRlciA/ICdwb2ludGVydXAnIDogJ3RvdWNoZW5kJztcclxudmFyIF9wcmUgPSAnX2xlYWZsZXRfJztcclxuXHJcbi8vIGluc3BpcmVkIGJ5IFplcHRvIHRvdWNoIGNvZGUgYnkgVGhvbWFzIEZ1Y2hzXHJcbmZ1bmN0aW9uIGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlciwgaWQpIHtcclxuXHR2YXIgbGFzdCwgdG91Y2gkJDEsXHJcblx0ICAgIGRvdWJsZVRhcCA9IGZhbHNlLFxyXG5cdCAgICBkZWxheSA9IDI1MDtcclxuXHJcblx0ZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcclxuXHRcdHZhciBjb3VudDtcclxuXHJcblx0XHRpZiAocG9pbnRlcikge1xyXG5cdFx0XHRpZiAoKCFlZGdlKSB8fCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7IHJldHVybjsgfVxyXG5cdFx0XHRjb3VudCA9IF9wb2ludGVyc0NvdW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y291bnQgPSBlLnRvdWNoZXMubGVuZ3RoO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb3VudCA+IDEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG5vdyA9IERhdGUubm93KCksXHJcblx0XHQgICAgZGVsdGEgPSBub3cgLSAobGFzdCB8fCBub3cpO1xyXG5cclxuXHRcdHRvdWNoJCQxID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHRcdGRvdWJsZVRhcCA9IChkZWx0YSA+IDAgJiYgZGVsdGEgPD0gZGVsYXkpO1xyXG5cdFx0bGFzdCA9IG5vdztcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uVG91Y2hFbmQoZSkge1xyXG5cdFx0aWYgKGRvdWJsZVRhcCAmJiAhdG91Y2gkJDEuY2FuY2VsQnViYmxlKSB7XHJcblx0XHRcdGlmIChwb2ludGVyKSB7XHJcblx0XHRcdFx0aWYgKCghZWRnZSkgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgeyByZXR1cm47IH1cclxuXHRcdFx0XHQvLyB3b3JrIGFyb3VuZCAudHlwZSBiZWluZyByZWFkb25seSB3aXRoIE1TUG9pbnRlciogZXZlbnRzXHJcblx0XHRcdFx0dmFyIG5ld1RvdWNoID0ge30sXHJcblx0XHRcdFx0ICAgIHByb3AsIGk7XHJcblxyXG5cdFx0XHRcdGZvciAoaSBpbiB0b3VjaCQkMSkge1xyXG5cdFx0XHRcdFx0cHJvcCA9IHRvdWNoJCQxW2ldO1xyXG5cdFx0XHRcdFx0bmV3VG91Y2hbaV0gPSBwcm9wICYmIHByb3AuYmluZCA/IHByb3AuYmluZCh0b3VjaCQkMSkgOiBwcm9wO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0b3VjaCQkMSA9IG5ld1RvdWNoO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRvdWNoJCQxLnR5cGUgPSAnZGJsY2xpY2snO1xyXG5cdFx0XHR0b3VjaCQkMS5idXR0b24gPSAwO1xyXG5cdFx0XHRoYW5kbGVyKHRvdWNoJCQxKTtcclxuXHRcdFx0bGFzdCA9IG51bGw7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRvYmpbX3ByZSArIF90b3VjaHN0YXJ0ICsgaWRdID0gb25Ub3VjaFN0YXJ0O1xyXG5cdG9ialtfcHJlICsgX3RvdWNoZW5kICsgaWRdID0gb25Ub3VjaEVuZDtcclxuXHRvYmpbX3ByZSArICdkYmxjbGljaycgKyBpZF0gPSBoYW5kbGVyO1xyXG5cclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihfdG91Y2hzdGFydCwgb25Ub3VjaFN0YXJ0LCBwYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihfdG91Y2hlbmQsIG9uVG91Y2hFbmQsIHBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cclxuXHQvLyBPbiBzb21lIHBsYXRmb3JtcyAobm90YWJseSwgY2hyb21lPDU1IG9uIHdpbjEwICsgdG91Y2hzY3JlZW4gKyBtb3VzZSksXHJcblx0Ly8gdGhlIGJyb3dzZXIgZG9lc24ndCBmaXJlIHRvdWNoZW5kL3BvaW50ZXJ1cCBldmVudHMgYnV0IGRvZXMgZmlyZVxyXG5cdC8vIG5hdGl2ZSBkYmxjbGlja3MuIFNlZSAjNDEyNy5cclxuXHQvLyBFZGdlIDE0IGFsc28gZmlyZXMgbmF0aXZlIGRibGNsaWNrcywgYnV0IG9ubHkgZm9yIHBvaW50ZXJUeXBlIG1vdXNlLCBzZWUgIzUxODAuXHJcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBpZCkge1xyXG5cdHZhciB0b3VjaHN0YXJ0ID0gb2JqW19wcmUgKyBfdG91Y2hzdGFydCArIGlkXSxcclxuXHQgICAgdG91Y2hlbmQgPSBvYmpbX3ByZSArIF90b3VjaGVuZCArIGlkXSxcclxuXHQgICAgZGJsY2xpY2sgPSBvYmpbX3ByZSArICdkYmxjbGljaycgKyBpZF07XHJcblxyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKF90b3VjaHN0YXJ0LCB0b3VjaHN0YXJ0LCBwYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdG91Y2hlbmQsIHRvdWNoZW5kLCBwYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHRpZiAoIWVkZ2UpIHtcclxuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGRibGNsaWNrLCBmYWxzZSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbVV0aWxcclxuICpcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRfT2JqZWN0X01vZGVsKVxyXG4gKiB0cmVlLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogTW9zdCBmdW5jdGlvbnMgZXhwZWN0aW5nIG9yIHJldHVybmluZyBhIGBIVE1MRWxlbWVudGAgYWxzbyB3b3JrIGZvclxyXG4gKiBTVkcgZWxlbWVudHMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCBjbGFzc2VzIHJlZmVyIHRvIENTUyBjbGFzc2VzXHJcbiAqIGluIEhUTUwgYW5kIFNWRyBjbGFzc2VzIGluIFNWRy5cclxuICovXHJcblxyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TRk9STTogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2Zvcm0gc3R5bGUgbmFtZSAoZS5nLiBgJ3dlYmtpdFRyYW5zZm9ybSdgIGZvciBXZWJLaXQpLlxyXG52YXIgVFJBTlNGT1JNID0gdGVzdFByb3AoXHJcblx0Wyd0cmFuc2Zvcm0nLCAnd2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ10pO1xyXG5cclxuLy8gd2Via2l0VHJhbnNpdGlvbiBjb21lcyBmaXJzdCBiZWNhdXNlIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyB0aGF0IGRyb3AgdmVuZG9yIHByZWZpeCBkb24ndCBkb1xyXG4vLyB0aGUgc2FtZSBmb3IgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQsIGluIHBhcnRpY3VsYXIgdGhlIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb24gc3R5bGUgbmFtZS5cclxudmFyIFRSQU5TSVRJT04gPSB0ZXN0UHJvcChcclxuXHRbJ3dlYmtpdFRyYW5zaXRpb24nLCAndHJhbnNpdGlvbicsICdPVHJhbnNpdGlvbicsICdNb3pUcmFuc2l0aW9uJywgJ21zVHJhbnNpdGlvbiddKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OX0VORDogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uZW5kIGV2ZW50IG5hbWUuXHJcbnZhciBUUkFOU0lUSU9OX0VORCA9XHJcblx0VFJBTlNJVElPTiA9PT0gJ3dlYmtpdFRyYW5zaXRpb24nIHx8IFRSQU5TSVRJT04gPT09ICdPVHJhbnNpdGlvbicgPyBUUkFOU0lUSU9OICsgJ0VuZCcgOiAndHJhbnNpdGlvbmVuZCc7XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldChpZDogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gUmV0dXJucyBhbiBlbGVtZW50IGdpdmVuIGl0cyBET00gaWQsIG9yIHJldHVybnMgdGhlIGVsZW1lbnQgaXRzZWxmXHJcbi8vIGlmIGl0IHdhcyBwYXNzZWQgZGlyZWN0bHkuXHJcbmZ1bmN0aW9uIGdldChpZCkge1xyXG5cdHJldHVybiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTdHlsZShlbDogSFRNTEVsZW1lbnQsIHN0eWxlQXR0cmliOiBTdHJpbmcpOiBTdHJpbmdcclxuLy8gUmV0dXJucyB0aGUgdmFsdWUgZm9yIGEgY2VydGFpbiBzdHlsZSBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcclxuLy8gaW5jbHVkaW5nIGNvbXB1dGVkIHZhbHVlcyBvciB2YWx1ZXMgc2V0IHRocm91Z2ggQ1NTLlxyXG5mdW5jdGlvbiBnZXRTdHlsZShlbCwgc3R5bGUpIHtcclxuXHR2YXIgdmFsdWUgPSBlbC5zdHlsZVtzdHlsZV0gfHwgKGVsLmN1cnJlbnRTdHlsZSAmJiBlbC5jdXJyZW50U3R5bGVbc3R5bGVdKTtcclxuXHJcblx0aWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICdhdXRvJykgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcclxuXHRcdHZhciBjc3MgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcclxuXHRcdHZhbHVlID0gY3NzID8gY3NzW3N0eWxlXSA6IG51bGw7XHJcblx0fVxyXG5cdHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gbnVsbCA6IHZhbHVlO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWU6IFN0cmluZywgY2xhc3NOYW1lPzogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIENyZWF0ZXMgYW4gSFRNTCBlbGVtZW50IHdpdGggYHRhZ05hbWVgLCBzZXRzIGl0cyBjbGFzcyB0byBgY2xhc3NOYW1lYCwgYW5kIG9wdGlvbmFsbHkgYXBwZW5kcyBpdCB0byBgY29udGFpbmVyYCBlbGVtZW50LlxyXG5mdW5jdGlvbiBjcmVhdGUkMSh0YWdOYW1lLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xyXG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcblx0ZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8ICcnO1xyXG5cclxuXHRpZiAoY29udGFpbmVyKSB7XHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gZWw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmUoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBSZW1vdmVzIGBlbGAgZnJvbSBpdHMgcGFyZW50IGVsZW1lbnRcclxuZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCkge1xyXG5cdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBlbXB0eShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIFJlbW92ZXMgYWxsIG9mIGBlbGAncyBjaGlsZHJlbiBlbGVtZW50cyBmcm9tIGBlbGBcclxuZnVuY3Rpb24gZW1wdHkoZWwpIHtcclxuXHR3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xyXG5cdFx0ZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdG9Gcm9udChlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIGBlbGAgdGhlIGxhc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBpbiBmcm9udCBvZiB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbmZ1bmN0aW9uIHRvRnJvbnQoZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50ICYmIHBhcmVudC5sYXN0Q2hpbGQgIT09IGVsKSB7XHJcblx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRvQmFjayhlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIGBlbGAgdGhlIGZpcnN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgYmVoaW5kIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuZnVuY3Rpb24gdG9CYWNrKGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCAmJiBwYXJlbnQuZmlyc3RDaGlsZCAhPT0gZWwpIHtcclxuXHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoZWwsIHBhcmVudC5maXJzdENoaWxkKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBoYXNDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZyk6IEJvb2xlYW5cclxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUgY29udGFpbnMgYG5hbWVgLlxyXG5mdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuXHR9XHJcblx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuXHRyZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIEFkZHMgYG5hbWVgIHRvIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dmFyIGNsYXNzZXMgPSBzcGxpdFdvcmRzKG5hbWUpO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2ldKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKCFoYXNDbGFzcyhlbCwgbmFtZSkpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcblx0XHRzZXRDbGFzcyhlbCwgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5hbWUpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBSZW1vdmVzIGBuYW1lYCBmcm9tIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c2V0Q2xhc3MoZWwsIHRyaW0oKCcgJyArIGdldENsYXNzKGVsKSArICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpKSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIFNldHMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuZnVuY3Rpb24gc2V0Q2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZWwuY2xhc3NOYW1lID0gbmFtZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gaW4gY2FzZSBvZiBTVkcgZWxlbWVudFxyXG5cdFx0ZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBuYW1lO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldENsYXNzKGVsOiBIVE1MRWxlbWVudCk6IFN0cmluZ1xyXG4vLyBSZXR1cm5zIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbmZ1bmN0aW9uIGdldENsYXNzKGVsKSB7XHJcblx0Ly8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgYW4gU1ZHRWxlbWVudEluc3RhbmNlIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmdFbGVtZW50IGluc3RlYWRcclxuXHQvLyAoUmVxdWlyZWQgZm9yIGxpbmtlZCBTVkcgZWxlbWVudHMgaW4gSUUxMS4pXHJcblx0aWYgKGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50KSB7XHJcblx0XHRlbCA9IGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50O1xyXG5cdH1cclxuXHRyZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0T3BhY2l0eShlbDogSFRNTEVsZW1lbnQsIG9wYWNpdHk6IE51bWJlcilcclxuLy8gU2V0IHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgKGluY2x1ZGluZyBvbGQgSUUgc3VwcG9ydCkuXHJcbi8vIGBvcGFjaXR5YCBtdXN0IGJlIGEgbnVtYmVyIGZyb20gYDBgIHRvIGAxYC5cclxuZnVuY3Rpb24gc2V0T3BhY2l0eShlbCwgdmFsdWUpIHtcclxuXHRpZiAoJ29wYWNpdHknIGluIGVsLnN0eWxlKSB7XHJcblx0XHRlbC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XHJcblx0fSBlbHNlIGlmICgnZmlsdGVyJyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0X3NldE9wYWNpdHlJRShlbCwgdmFsdWUpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gX3NldE9wYWNpdHlJRShlbCwgdmFsdWUpIHtcclxuXHR2YXIgZmlsdGVyID0gZmFsc2UsXHJcblx0ICAgIGZpbHRlck5hbWUgPSAnRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEnO1xyXG5cclxuXHQvLyBmaWx0ZXJzIGNvbGxlY3Rpb24gdGhyb3dzIGFuIGVycm9yIGlmIHdlIHRyeSB0byByZXRyaWV2ZSBhIGZpbHRlciB0aGF0IGRvZXNuJ3QgZXhpc3RcclxuXHR0cnkge1xyXG5cdFx0ZmlsdGVyID0gZWwuZmlsdGVycy5pdGVtKGZpbHRlck5hbWUpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8vIGRvbid0IHNldCBvcGFjaXR5IHRvIDEgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IHNldCBhbiBvcGFjaXR5LFxyXG5cdFx0Ly8gaXQgaXNuJ3QgbmVlZGVkIGFuZCBicmVha3MgdHJhbnNwYXJlbnQgcG5ncy5cclxuXHRcdGlmICh2YWx1ZSA9PT0gMSkgeyByZXR1cm47IH1cclxuXHR9XHJcblxyXG5cdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XHJcblxyXG5cdGlmIChmaWx0ZXIpIHtcclxuXHRcdGZpbHRlci5FbmFibGVkID0gKHZhbHVlICE9PSAxMDApO1xyXG5cdFx0ZmlsdGVyLk9wYWNpdHkgPSB2YWx1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZWwuc3R5bGUuZmlsdGVyICs9ICcgcHJvZ2lkOicgKyBmaWx0ZXJOYW1lICsgJyhvcGFjaXR5PScgKyB2YWx1ZSArICcpJztcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wczogU3RyaW5nW10pOiBTdHJpbmd8ZmFsc2VcclxuLy8gR29lcyB0aHJvdWdoIHRoZSBhcnJheSBvZiBzdHlsZSBuYW1lcyBhbmQgcmV0dXJucyB0aGUgZmlyc3QgbmFtZVxyXG4vLyB0aGF0IGlzIGEgdmFsaWQgc3R5bGUgbmFtZSBmb3IgYW4gZWxlbWVudC4gSWYgbm8gc3VjaCBuYW1lIGlzIGZvdW5kLFxyXG4vLyBpdCByZXR1cm5zIGZhbHNlLiBVc2VmdWwgZm9yIHZlbmRvci1wcmVmaXhlZCBzdHlsZXMgbGlrZSBgdHJhbnNmb3JtYC5cclxuZnVuY3Rpb24gdGVzdFByb3AocHJvcHMpIHtcclxuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChwcm9wc1tpXSBpbiBzdHlsZSkge1xyXG5cdFx0XHRyZXR1cm4gcHJvcHNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbDogSFRNTEVsZW1lbnQsIG9mZnNldDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKVxyXG4vLyBSZXNldHMgdGhlIDNEIENTUyB0cmFuc2Zvcm0gb2YgYGVsYCBzbyBpdCBpcyB0cmFuc2xhdGVkIGJ5IGBvZmZzZXRgIHBpeGVsc1xyXG4vLyBhbmQgb3B0aW9uYWxseSBzY2FsZWQgYnkgYHNjYWxlYC4gRG9lcyBub3QgaGF2ZSBhbiBlZmZlY3QgaWYgdGhlXHJcbi8vIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IDNEIENTUyB0cmFuc2Zvcm1zLlxyXG5mdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWwsIG9mZnNldCwgc2NhbGUpIHtcclxuXHR2YXIgcG9zID0gb2Zmc2V0IHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHJcblx0ZWwuc3R5bGVbVFJBTlNGT1JNXSA9XHJcblx0XHQoaWUzZCA/XHJcblx0XHRcdCd0cmFuc2xhdGUoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCknIDpcclxuXHRcdFx0J3RyYW5zbGF0ZTNkKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgsMCknKSArXHJcblx0XHQoc2NhbGUgPyAnIHNjYWxlKCcgKyBzY2FsZSArICcpJyA6ICcnKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCwgcG9zaXRpb246IFBvaW50KVxyXG4vLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBgZWxgIHRvIGNvb3JkaW5hdGVzIHNwZWNpZmllZCBieSBgcG9zaXRpb25gLFxyXG4vLyB1c2luZyBDU1MgdHJhbnNsYXRlIG9yIHRvcC9sZWZ0IHBvc2l0aW9uaW5nIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlclxyXG4vLyAodXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gcG9zaXRpb24gaXRzIGxheWVycykuXHJcbmZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsLCBwb2ludCkge1xyXG5cclxuXHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0ZWwuX2xlYWZsZXRfcG9zID0gcG9pbnQ7XHJcblx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG5cclxuXHRpZiAoYW55M2QpIHtcclxuXHRcdHNldFRyYW5zZm9ybShlbCwgcG9pbnQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlbC5zdHlsZS5sZWZ0ID0gcG9pbnQueCArICdweCc7XHJcblx0XHRlbC5zdHlsZS50b3AgPSBwb2ludC55ICsgJ3B4JztcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4vLyBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiBhbiBlbGVtZW50IHByZXZpb3VzbHkgcG9zaXRpb25lZCB3aXRoIHNldFBvc2l0aW9uLlxyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihlbCkge1xyXG5cdC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBmb3IgZWxlbWVudHMgcHJldmlvdXNseSBwb3NpdGlvbmVkIHVzaW5nIHNldFBvc2l0aW9uLFxyXG5cdC8vIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSB0aGUgcG9zaXRpb24gZm9yIHBlcmZvcm1hbmNlXHJcblxyXG5cdHJldHVybiBlbC5fbGVhZmxldF9wb3MgfHwgbmV3IFBvaW50KDAsIDApO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBQcmV2ZW50cyB0aGUgdXNlciBmcm9tIGdlbmVyYXRpbmcgYHNlbGVjdHN0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZFxyXG4vLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB0aHJvdWdoIGEgcGFnZSB3aXRoIHRleHQuIFVzZWQgaW50ZXJuYWxseVxyXG4vLyBieSBMZWFmbGV0IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvdXIgb2YgYW55IGNsaWNrLWFuZC1kcmFnIGludGVyYWN0aW9uIG9uXHJcbi8vIHRoZSBtYXAuIEFmZmVjdHMgZHJhZyBpbnRlcmFjdGlvbnMgb24gdGhlIHdob2xlIGRvY3VtZW50LlxyXG5cclxuLy8gQGZ1bmN0aW9uIGVuYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbnZhciBkaXNhYmxlVGV4dFNlbGVjdGlvbjtcclxudmFyIGVuYWJsZVRleHRTZWxlY3Rpb247XHJcbnZhciBfdXNlclNlbGVjdDtcclxuaWYgKCdvbnNlbGVjdHN0YXJ0JyBpbiBkb2N1bWVudCkge1xyXG5cdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0b24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxuXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0b2ZmKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcbn0gZWxzZSB7XHJcblx0dmFyIHVzZXJTZWxlY3RQcm9wZXJ0eSA9IHRlc3RQcm9wKFxyXG5cdFx0Wyd1c2VyU2VsZWN0JywgJ1dlYmtpdFVzZXJTZWxlY3QnLCAnT1VzZXJTZWxlY3QnLCAnTW96VXNlclNlbGVjdCcsICdtc1VzZXJTZWxlY3QnXSk7XHJcblxyXG5cdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblx0XHRcdF91c2VyU2VsZWN0ID0gc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XTtcclxuXHRcdFx0c3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9ICdub25lJztcclxuXHRcdH1cclxuXHR9O1xyXG5cdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gX3VzZXJTZWxlY3Q7XHJcblx0XHRcdF91c2VyU2VsZWN0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKClcclxuLy8gQXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbiksIGJ1dFxyXG4vLyBmb3IgYGRyYWdzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWQgd2hlbiB0aGUgdXNlciBkcmFncyBhbiBpbWFnZS5cclxuZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpIHtcclxuXHRvbih3aW5kb3csICdkcmFnc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZ2BdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKCkge1xyXG5cdG9mZih3aW5kb3csICdkcmFnc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuXHJcbnZhciBfb3V0bGluZUVsZW1lbnQ7XG52YXIgX291dGxpbmVTdHlsZTtcclxuLy8gQGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgdGhlIFtvdXRsaW5lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1Mvb3V0bGluZSlcclxuLy8gb2YgdGhlIGVsZW1lbnQgYGVsYCBpbnZpc2libGUuIFVzZWQgaW50ZXJuYWxseSBieSBMZWFmbGV0IHRvIHByZXZlbnRcclxuLy8gZm9jdXNhYmxlIGVsZW1lbnRzIGZyb20gZGlzcGxheWluZyBhbiBvdXRsaW5lIHdoZW4gdGhlIHVzZXIgcGVyZm9ybXMgYVxyXG4vLyBkcmFnIGludGVyYWN0aW9uIG9uIHRoZW0uXHJcbmZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsZW1lbnQpIHtcclxuXHR3aGlsZSAoZWxlbWVudC50YWJJbmRleCA9PT0gLTEpIHtcclxuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblx0fVxyXG5cdGlmICghZWxlbWVudC5zdHlsZSkgeyByZXR1cm47IH1cclxuXHRyZXN0b3JlT3V0bGluZSgpO1xyXG5cdF9vdXRsaW5lRWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0X291dGxpbmVTdHlsZSA9IGVsZW1lbnQuc3R5bGUub3V0bGluZTtcclxuXHRlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XHJcblx0b24od2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuZnVuY3Rpb24gcmVzdG9yZU91dGxpbmUoKSB7XHJcblx0aWYgKCFfb3V0bGluZUVsZW1lbnQpIHsgcmV0dXJuOyB9XHJcblx0X291dGxpbmVFbGVtZW50LnN0eWxlLm91dGxpbmUgPSBfb3V0bGluZVN0eWxlO1xyXG5cdF9vdXRsaW5lRWxlbWVudCA9IHVuZGVmaW5lZDtcclxuXHRfb3V0bGluZVN0eWxlID0gdW5kZWZpbmVkO1xyXG5cdG9mZih3aW5kb3csICdrZXlkb3duJywgcmVzdG9yZU91dGxpbmUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U2l6ZWRQYXJlbnROb2RlKGVsOiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIEZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHdoaWNoIHNpemUgKHdpZHRoIGFuZCBoZWlnaHQpIGlzIG5vdCBudWxsLlxyXG5mdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWxlbWVudCkge1xyXG5cdGRvIHtcclxuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblx0fSB3aGlsZSAoKCFlbGVtZW50Lm9mZnNldFdpZHRoIHx8ICFlbGVtZW50Lm9mZnNldEhlaWdodCkgJiYgZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSk7XHJcblx0cmV0dXJuIGVsZW1lbnQ7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTY2FsZShlbDogSFRNTEVsZW1lbnQpOiBPYmplY3RcclxuLy8gQ29tcHV0ZXMgdGhlIENTUyBzY2FsZSBjdXJyZW50bHkgYXBwbGllZCBvbiB0aGUgZWxlbWVudC5cclxuLy8gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBgeGAgYW5kIGB5YCBtZW1iZXJzIGFzIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHNjYWxlcyByZXNwZWN0aXZlbHksXHJcbi8vIGFuZCBgYm91bmRpbmdDbGllbnRSZWN0YCBhcyB0aGUgcmVzdWx0IG9mIFtgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9nZXRCb3VuZGluZ0NsaWVudFJlY3QpLlxyXG5mdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XHJcblx0dmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBSZWFkLW9ubHkgaW4gb2xkIGJyb3dzZXJzLlxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogcmVjdC53aWR0aCAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSxcclxuXHRcdHk6IHJlY3QuaGVpZ2h0IC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSxcclxuXHRcdGJvdW5kaW5nQ2xpZW50UmVjdDogcmVjdFxyXG5cdH07XHJcbn1cclxuXG5cbnZhciBEb21VdGlsID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdFRSQU5TRk9STTogVFJBTlNGT1JNLFxuXHRUUkFOU0lUSU9OOiBUUkFOU0lUSU9OLFxuXHRUUkFOU0lUSU9OX0VORDogVFJBTlNJVElPTl9FTkQsXG5cdGdldDogZ2V0LFxuXHRnZXRTdHlsZTogZ2V0U3R5bGUsXG5cdGNyZWF0ZTogY3JlYXRlJDEsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRlbXB0eTogZW1wdHksXG5cdHRvRnJvbnQ6IHRvRnJvbnQsXG5cdHRvQmFjazogdG9CYWNrLFxuXHRoYXNDbGFzczogaGFzQ2xhc3MsXG5cdGFkZENsYXNzOiBhZGRDbGFzcyxcblx0cmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuXHRzZXRDbGFzczogc2V0Q2xhc3MsXG5cdGdldENsYXNzOiBnZXRDbGFzcyxcblx0c2V0T3BhY2l0eTogc2V0T3BhY2l0eSxcblx0dGVzdFByb3A6IHRlc3RQcm9wLFxuXHRzZXRUcmFuc2Zvcm06IHNldFRyYW5zZm9ybSxcblx0c2V0UG9zaXRpb246IHNldFBvc2l0aW9uLFxuXHRnZXRQb3NpdGlvbjogZ2V0UG9zaXRpb24sXG5cdGRpc2FibGVUZXh0U2VsZWN0aW9uOiBkaXNhYmxlVGV4dFNlbGVjdGlvbixcblx0ZW5hYmxlVGV4dFNlbGVjdGlvbjogZW5hYmxlVGV4dFNlbGVjdGlvbixcblx0ZGlzYWJsZUltYWdlRHJhZzogZGlzYWJsZUltYWdlRHJhZyxcblx0ZW5hYmxlSW1hZ2VEcmFnOiBlbmFibGVJbWFnZURyYWcsXG5cdHByZXZlbnRPdXRsaW5lOiBwcmV2ZW50T3V0bGluZSxcblx0cmVzdG9yZU91dGxpbmU6IHJlc3RvcmVPdXRsaW5lLFxuXHRnZXRTaXplZFBhcmVudE5vZGU6IGdldFNpemVkUGFyZW50Tm9kZSxcblx0Z2V0U2NhbGU6IGdldFNjYWxlXG59KTtcblxuLypcclxuICogQG5hbWVzcGFjZSBEb21FdmVudFxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET00gZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnQpLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICovXHJcblxyXG4vLyBJbnNwaXJlZCBieSBKb2huIFJlc2lnLCBEZWFuIEVkd2FyZHMgYW5kIFlVSSBhZGRFdmVudCBpbXBsZW1lbnRhdGlvbnMuXHJcblxyXG4vLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIERPTSBldmVudCB0eXBlIG9mIHRoZVxyXG4vLyBlbGVtZW50IGBlbGAuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lclxyXG4vLyAob2JqZWN0IHRoZSBgdGhpc2Aga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbFxyXG4vLyBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcbmZ1bmN0aW9uIG9uKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdGFkZE9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGFkZE9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxudmFyIGV2ZW50c0tleSA9ICdfbGVhZmxldF9ldmVudHMnO1xyXG5cclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uXHJcbi8vIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gb24sIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWVcclxuLy8gY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcbmZ1bmN0aW9uIG9mZihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAodHlwZXMpIHtcclxuXHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdGZvciAodmFyIGogaW4gb2JqW2V2ZW50c0tleV0pIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgaiwgb2JqW2V2ZW50c0tleV1bal0pO1xyXG5cdFx0fVxyXG5cdFx0ZGVsZXRlIG9ialtldmVudHNLZXldO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZE9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0dmFyIGlkID0gdHlwZSArIHN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcblxyXG5cdGlmIChvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcclxuXHR9O1xyXG5cclxuXHR2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcblx0aWYgKHBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHQvLyBOZWVkcyBEb21FdmVudC5Qb2ludGVyLmpzXHJcblx0XHRhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAodG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmIGFkZERvdWJsZVRhcExpc3RlbmVyICYmXHJcblx0ICAgICAgICAgICAhKHBvaW50ZXIgJiYgY2hyb21lKSkge1xyXG5cdFx0Ly8gQ2hyb21lID41NSBkb2VzIG5vdCBuZWVkIHRoZSBzeW50aGV0aWMgZGJsY2xpY2tzIGZyb20gYWRkRG91YmxlVGFwTGlzdGVuZXJcclxuXHRcdC8vIFNlZSAjNTE4MFxyXG5cdFx0YWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ29ud2hlZWwnIGluIG9iaiA/ICd3aGVlbCcgOiAnbW91c2V3aGVlbCcsIGhhbmRsZXIsIHBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoKHR5cGUgPT09ICdtb3VzZWVudGVyJykgfHwgKHR5cGUgPT09ICdtb3VzZWxlYXZlJykpIHtcclxuXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0XHRcdGlmIChpc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcclxuXHRcdFx0XHRcdG9yaWdpbmFsSGFuZGxlcihlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDogJ21vdXNlb3V0JywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICh0eXBlID09PSAnY2xpY2snICYmIGFuZHJvaWQpIHtcclxuXHRcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdGZpbHRlckNsaWNrKGUsIG9yaWdpbmFsSGFuZGxlcik7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XSA9IG9ialtldmVudHNLZXldIHx8IHt9O1xyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IGhhbmRsZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZU9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdHZhciBpZCA9IHR5cGUgKyBzdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIHN0YW1wKGNvbnRleHQpIDogJycpLFxyXG5cdCAgICBoYW5kbGVyID0gb2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdO1xyXG5cclxuXHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0aWYgKHBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHRyZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAodG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmIHJlbW92ZURvdWJsZVRhcExpc3RlbmVyICYmXHJcblx0ICAgICAgICAgICAhKHBvaW50ZXIgJiYgY2hyb21lKSkge1xyXG5cdFx0cmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ud2hlZWwnIGluIG9iaiA/ICd3aGVlbCcgOiAnbW91c2V3aGVlbCcsIGhhbmRsZXIsIHBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFxyXG5cdFx0XHRcdHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDpcclxuXHRcdFx0XHR0eXBlID09PSAnbW91c2VsZWF2ZScgPyAnbW91c2VvdXQnIDogdHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2UgaWYgKCdkZXRhY2hFdmVudCcgaW4gb2JqKSB7XHJcblx0XHRvYmouZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdH1cclxuXHJcblx0b2JqW2V2ZW50c0tleV1baWRdID0gbnVsbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIFN0b3AgdGhlIGdpdmVuIGV2ZW50IGZyb20gcHJvcGFnYXRpb24gdG8gcGFyZW50IGVsZW1lbnRzLiBVc2VkIGluc2lkZSB0aGUgbGlzdGVuZXIgZnVuY3Rpb25zOlxyXG4vLyBgYGBqc1xyXG4vLyBMLkRvbUV2ZW50Lm9uKGRpdiwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2KSB7XHJcbi8vIFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZXYpO1xyXG4vLyB9KTtcclxuLy8gYGBgXHJcbmZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihlKSB7XHJcblxyXG5cdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHR9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudCkgeyAgLy8gSW4gY2FzZSBvZiBMZWFmbGV0IGV2ZW50LlxyXG5cdFx0ZS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkID0gdHJ1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdH1cclxuXHRza2lwcGVkKGUpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbi8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ21vdXNld2hlZWwnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbmZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbCkge1xyXG5cdGFkZE9uZShlbCwgJ21vdXNld2hlZWwnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdjbGljaydgLCBgJ2RvdWJsZWNsaWNrJ2AsXHJcbi8vIGAnbW91c2Vkb3duJ2AgYW5kIGAndG91Y2hzdGFydCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWwpIHtcclxuXHRvbihlbCwgJ21vdXNlZG93biB0b3VjaHN0YXJ0IGRibGNsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRhZGRPbmUoZWwsICdjbGljaycsIGZha2VTdG9wKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIG9mIHRoZSBET00gRXZlbnQgYGV2YCBmcm9tIGhhcHBlbmluZyAoc3VjaCBhc1xyXG4vLyBmb2xsb3dpbmcgYSBsaW5rIGluIHRoZSBocmVmIG9mIHRoZSBhIGVsZW1lbnQsIG9yIGRvaW5nIGEgUE9TVCByZXF1ZXN0XHJcbi8vIHdpdGggcGFnZSByZWxvYWQgd2hlbiBhIGA8Zm9ybT5gIGlzIHN1Ym1pdHRlZCkuXHJcbi8vIFVzZSBpdCBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XHJcblx0aWYgKGUucHJldmVudERlZmF1bHQpIHtcclxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHN0b3AoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBEb2VzIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIGF0IHRoZSBzYW1lIHRpbWUuXHJcbmZ1bmN0aW9uIHN0b3AoZSkge1xyXG5cdHByZXZlbnREZWZhdWx0KGUpO1xyXG5cdHN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZXY6IERPTUV2ZW50LCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIEdldHMgbm9ybWFsaXplZCBtb3VzZSBwb3NpdGlvbiBmcm9tIGEgRE9NIGV2ZW50IHJlbGF0aXZlIHRvIHRoZVxyXG4vLyBgY29udGFpbmVyYCAoYm9yZGVyIGV4Y2x1ZGVkKSBvciB0byB0aGUgd2hvbGUgcGFnZSBpZiBub3Qgc3BlY2lmaWVkLlxyXG5mdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGUsIGNvbnRhaW5lcikge1xyXG5cdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuXHR9XHJcblxyXG5cdHZhciBzY2FsZSA9IGdldFNjYWxlKGNvbnRhaW5lciksXHJcblx0ICAgIG9mZnNldCA9IHNjYWxlLmJvdW5kaW5nQ2xpZW50UmVjdDsgLy8gbGVmdCBhbmQgdG9wICB2YWx1ZXMgYXJlIGluIHBhZ2Ugc2NhbGUgKGxpa2UgdGhlIGV2ZW50IGNsaWVudFgvWSlcclxuXHJcblx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdC8vIG9mZnNldC5sZWZ0L3RvcCB2YWx1ZXMgYXJlIGluIHBhZ2Ugc2NhbGUgKGxpa2UgY2xpZW50WC9ZKSxcclxuXHRcdC8vIHdoZXJlYXMgY2xpZW50TGVmdC9Ub3AgKGJvcmRlciB3aWR0aCkgdmFsdWVzIGFyZSB0aGUgb3JpZ2luYWwgdmFsdWVzIChiZWZvcmUgQ1NTIHNjYWxlIGFwcGxpZXMpLlxyXG5cdFx0KGUuY2xpZW50WCAtIG9mZnNldC5sZWZ0KSAvIHNjYWxlLnggLSBjb250YWluZXIuY2xpZW50TGVmdCxcclxuXHRcdChlLmNsaWVudFkgLSBvZmZzZXQudG9wKSAvIHNjYWxlLnkgLSBjb250YWluZXIuY2xpZW50VG9wXHJcblx0KTtcclxufVxyXG5cclxuLy8gQ2hyb21lIG9uIFdpbiBzY3JvbGxzIGRvdWJsZSB0aGUgcGl4ZWxzIGFzIGluIG90aGVyIHBsYXRmb3JtcyAoc2VlICM0NTM4KSxcclxuLy8gYW5kIEZpcmVmb3ggc2Nyb2xscyBkZXZpY2UgcGl4ZWxzLCBub3QgQ1NTIHBpeGVsc1xyXG52YXIgd2hlZWxQeEZhY3RvciA9XHJcblx0KHdpbiAmJiBjaHJvbWUpID8gMiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDpcclxuXHRnZWNrbyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGV2OiBET01FdmVudCk6IE51bWJlclxyXG4vLyBHZXRzIG5vcm1hbGl6ZWQgd2hlZWwgZGVsdGEgZnJvbSBhIG1vdXNld2hlZWwgRE9NIGV2ZW50LCBpbiB2ZXJ0aWNhbFxyXG4vLyBwaXhlbHMgc2Nyb2xsZWQgKG5lZ2F0aXZlIGlmIHNjcm9sbGluZyBkb3duKS5cclxuLy8gRXZlbnRzIGZyb20gcG9pbnRpbmcgZGV2aWNlcyB3aXRob3V0IHByZWNpc2Ugc2Nyb2xsaW5nIGFyZSBtYXBwZWQgdG9cclxuLy8gYSBiZXN0IGd1ZXNzIG9mIDYwIHBpeGVscy5cclxuZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShlKSB7XHJcblx0cmV0dXJuIChlZGdlKSA/IGUud2hlZWxEZWx0YVkgLyAyIDogLy8gRG9uJ3QgdHJ1c3Qgd2luZG93LWdlb21ldHJ5LWJhc2VkIGRlbHRhXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMCkgPyAtZS5kZWx0YVkgLyB3aGVlbFB4RmFjdG9yIDogLy8gUGl4ZWxzXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMSkgPyAtZS5kZWx0YVkgKiAyMCA6IC8vIExpbmVzXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMikgPyAtZS5kZWx0YVkgKiA2MCA6IC8vIFBhZ2VzXHJcblx0ICAgICAgIChlLmRlbHRhWCB8fCBlLmRlbHRhWikgPyAwIDpcdC8vIFNraXAgaG9yaXpvbnRhbC9kZXB0aCB3aGVlbCBldmVudHNcclxuXHQgICAgICAgZS53aGVlbERlbHRhID8gKGUud2hlZWxEZWx0YVkgfHwgZS53aGVlbERlbHRhKSAvIDIgOiAvLyBMZWdhY3kgSUUgcGl4ZWxzXHJcblx0ICAgICAgIChlLmRldGFpbCAmJiBNYXRoLmFicyhlLmRldGFpbCkgPCAzMjc2NSkgPyAtZS5kZXRhaWwgKiAyMCA6IC8vIExlZ2FjeSBNb3ogbGluZXNcclxuXHQgICAgICAgZS5kZXRhaWwgPyBlLmRldGFpbCAvIC0zMjc2NSAqIDYwIDogLy8gTGVnYWN5IE1veiBwYWdlc1xyXG5cdCAgICAgICAwO1xyXG59XHJcblxyXG52YXIgc2tpcEV2ZW50cyA9IHt9O1xyXG5cclxuZnVuY3Rpb24gZmFrZVN0b3AoZSkge1xyXG5cdC8vIGZha2VzIHN0b3BQcm9wYWdhdGlvbiBieSBzZXR0aW5nIGEgc3BlY2lhbCBldmVudCBmbGFnLCBjaGVja2VkL3Jlc2V0IHdpdGggc2tpcHBlZChlKVxyXG5cdHNraXBFdmVudHNbZS50eXBlXSA9IHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNraXBwZWQoZSkge1xyXG5cdHZhciBldmVudHMgPSBza2lwRXZlbnRzW2UudHlwZV07XHJcblx0Ly8gcmVzZXQgd2hlbiBjaGVja2luZywgYXMgaXQncyBvbmx5IHVzZWQgaW4gbWFwIGNvbnRhaW5lciBhbmQgcHJvcGFnYXRlcyBvdXRzaWRlIG9mIHRoZSBtYXBcclxuXHRza2lwRXZlbnRzW2UudHlwZV0gPSBmYWxzZTtcclxuXHRyZXR1cm4gZXZlbnRzO1xyXG59XHJcblxyXG4vLyBjaGVjayBpZiBlbGVtZW50IHJlYWxseSBsZWZ0L2VudGVyZWQgdGhlIGV2ZW50IHRhcmdldCAoZm9yIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSlcclxuZnVuY3Rpb24gaXNFeHRlcm5hbFRhcmdldChlbCwgZSkge1xyXG5cclxuXHR2YXIgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldDtcclxuXHJcblx0aWYgKCFyZWxhdGVkKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdHRyeSB7XHJcblx0XHR3aGlsZSAocmVsYXRlZCAmJiAocmVsYXRlZCAhPT0gZWwpKSB7XHJcblx0XHRcdHJlbGF0ZWQgPSByZWxhdGVkLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiAocmVsYXRlZCAhPT0gZWwpO1xyXG59XHJcblxyXG52YXIgbGFzdENsaWNrO1xyXG5cclxuLy8gdGhpcyBpcyBhIGhvcnJpYmxlIHdvcmthcm91bmQgZm9yIGEgYnVnIGluIEFuZHJvaWQgd2hlcmUgYSBzaW5nbGUgdG91Y2ggdHJpZ2dlcnMgdHdvIGNsaWNrIGV2ZW50c1xyXG5mdW5jdGlvbiBmaWx0ZXJDbGljayhlLCBoYW5kbGVyKSB7XHJcblx0dmFyIHRpbWVTdGFtcCA9IChlLnRpbWVTdGFtcCB8fCAoZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC50aW1lU3RhbXApKSxcclxuXHQgICAgZWxhcHNlZCA9IGxhc3RDbGljayAmJiAodGltZVN0YW1wIC0gbGFzdENsaWNrKTtcclxuXHJcblx0Ly8gYXJlIHRoZXkgY2xvc2VyIHRvZ2V0aGVyIHRoYW4gNTAwbXMgeWV0IG1vcmUgdGhhbiAxMDBtcz9cclxuXHQvLyBBbmRyb2lkIHR5cGljYWxseSB0cmlnZ2VycyB0aGVtIH4zMDBtcyBhcGFydCB3aGlsZSBtdWx0aXBsZSBsaXN0ZW5lcnNcclxuXHQvLyBvbiB0aGUgc2FtZSBldmVudCBzaG91bGQgYmUgdHJpZ2dlcmVkIGZhciBmYXN0ZXI7XHJcblx0Ly8gb3IgY2hlY2sgaWYgY2xpY2sgaXMgc2ltdWxhdGVkIG9uIHRoZSBlbGVtZW50LCBhbmQgaWYgaXQgaXMsIHJlamVjdCBhbnkgbm9uLXNpbXVsYXRlZCBldmVudHNcclxuXHJcblx0aWYgKChlbGFwc2VkICYmIGVsYXBzZWQgPiAxMDAgJiYgZWxhcHNlZCA8IDUwMCkgfHwgKGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayAmJiAhZS5fc2ltdWxhdGVkKSkge1xyXG5cdFx0c3RvcChlKTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblx0bGFzdENsaWNrID0gdGltZVN0YW1wO1xyXG5cclxuXHRoYW5kbGVyKGUpO1xyXG59XHJcblxyXG5cclxuXG5cbnZhciBEb21FdmVudCA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRvbjogb24sXG5cdG9mZjogb2ZmLFxuXHRzdG9wUHJvcGFnYXRpb246IHN0b3BQcm9wYWdhdGlvbixcblx0ZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uOiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24sXG5cdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uOiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbixcblx0cHJldmVudERlZmF1bHQ6IHByZXZlbnREZWZhdWx0LFxuXHRzdG9wOiBzdG9wLFxuXHRnZXRNb3VzZVBvc2l0aW9uOiBnZXRNb3VzZVBvc2l0aW9uLFxuXHRnZXRXaGVlbERlbHRhOiBnZXRXaGVlbERlbHRhLFxuXHRmYWtlU3RvcDogZmFrZVN0b3AsXG5cdHNraXBwZWQ6IHNraXBwZWQsXG5cdGlzRXh0ZXJuYWxUYXJnZXQ6IGlzRXh0ZXJuYWxUYXJnZXQsXG5cdGFkZExpc3RlbmVyOiBvbixcblx0cmVtb3ZlTGlzdGVuZXI6IG9mZlxufSk7XG5cbi8qXG4gKiBAY2xhc3MgUG9zQW5pbWF0aW9uXG4gKiBAYWthIEwuUG9zQW5pbWF0aW9uXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBwYW5uaW5nIGFuaW1hdGlvbnMsIHV0aWxpemluZyBDU1MzIFRyYW5zaXRpb25zIGZvciBtb2Rlcm4gYnJvd3NlcnMgYW5kIGEgdGltZXIgZmFsbGJhY2sgZm9yIElFNi05LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIGZ4ID0gbmV3IEwuUG9zQW5pbWF0aW9uKCk7XG4gKiBmeC5ydW4oZWwsIFszMDAsIDUwMF0sIDAuNSk7XG4gKiBgYGBcbiAqXG4gKiBAY29uc3RydWN0b3IgTC5Qb3NBbmltYXRpb24oKVxuICogQ3JlYXRlcyBhIGBQb3NBbmltYXRpb25gIG9iamVjdC5cbiAqXG4gKi9cblxudmFyIFBvc0FuaW1hdGlvbiA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBAbWV0aG9kIHJ1bihlbDogSFRNTEVsZW1lbnQsIG5ld1BvczogUG9pbnQsIGR1cmF0aW9uPzogTnVtYmVyLCBlYXNlTGluZWFyaXR5PzogTnVtYmVyKVxuXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG5cdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuXHQvLyBhcmd1bWVudCBvZiB0aGUgW2N1YmljIGJlemllciBjdXJ2ZV0oaHR0cDovL2N1YmljLWJlemllci5jb20vIzAsMCwuNSwxKSxcblx0Ly8gYDAuNWAgYnkgZGVmYXVsdCkuXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG5cdFx0dGhpcy5zdG9wKCk7XG5cblx0XHR0aGlzLl9lbCA9IGVsO1xuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcblx0XHR0aGlzLl9lYXNlT3V0UG93ZXIgPSAxIC8gTWF0aC5tYXgoZWFzZUxpbmVhcml0eSB8fCAwLjUsIDAuMik7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IGdldFBvc2l0aW9uKGVsKTtcblx0XHR0aGlzLl9vZmZzZXQgPSBuZXdQb3Muc3VidHJhY3QodGhpcy5fc3RhcnRQb3MpO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHNcblx0XHR0aGlzLmZpcmUoJ3N0YXJ0Jyk7XG5cblx0XHR0aGlzLl9hbmltYXRlKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzdG9wKClcblx0Ly8gU3RvcHMgdGhlIGFuaW1hdGlvbiAoaWYgY3VycmVudGx5IHJ1bm5pbmcpLlxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fc3RlcCh0cnVlKTtcblx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLl9hbmltSWQgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FuaW1hdGUsIHRoaXMpO1xuXHRcdHRoaXMuX3N0ZXAoKTtcblx0fSxcblxuXHRfc3RlcDogZnVuY3Rpb24gKHJvdW5kKSB7XG5cdFx0dmFyIGVsYXBzZWQgPSAoK25ldyBEYXRlKCkpIC0gdGhpcy5fc3RhcnRUaW1lLFxuXHRcdCAgICBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uICogMTAwMDtcblxuXHRcdGlmIChlbGFwc2VkIDwgZHVyYXRpb24pIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKHRoaXMuX2Vhc2VPdXQoZWxhcHNlZCAvIGR1cmF0aW9uKSwgcm91bmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSgxKTtcblx0XHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9ydW5GcmFtZTogZnVuY3Rpb24gKHByb2dyZXNzLCByb3VuZCkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQodGhpcy5fb2Zmc2V0Lm11bHRpcGx5QnkocHJvZ3Jlc3MpKTtcblx0XHRpZiAocm91bmQpIHtcblx0XHRcdHBvcy5fcm91bmQoKTtcblx0XHR9XG5cdFx0c2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XG5cblx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIHRoZSBhbmltYXRpb24uXG5cdFx0dGhpcy5maXJlKCdzdGVwJyk7XG5cdH0sXG5cblx0X2NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1JZCk7XG5cblx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG5cdFx0Ly8gQGV2ZW50IGVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZW5kcy5cblx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuXHR9LFxuXG5cdF9lYXNlT3V0OiBmdW5jdGlvbiAodCkge1xuXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG5cdH1cbn0pO1xuXG4vKlxyXG4gKiBAY2xhc3MgTWFwXHJcbiAqIEBha2EgTC5NYXBcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogVGhlIGNlbnRyYWwgY2xhc3Mgb2YgdGhlIEFQSSDigJQgaXQgaXMgdXNlZCB0byBjcmVhdGUgYSBtYXAgb24gYSBwYWdlIGFuZCBtYW5pcHVsYXRlIGl0LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiAvLyBpbml0aWFsaXplIHRoZSBtYXAgb24gdGhlIFwibWFwXCIgZGl2IHdpdGggYSBnaXZlbiBjZW50ZXIgYW5kIHpvb21cclxuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XHJcbiAqIFx0Y2VudGVyOiBbNTEuNTA1LCAtMC4wOV0sXHJcbiAqIFx0em9vbTogMTNcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKi9cclxuXHJcbnZhciBNYXAgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBTdGF0ZSBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gTC5DUlMuRVBTRzM4NTdcclxuXHRcdC8vIFRoZSBbQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtXSgjY3JzKSB0byB1c2UuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3RcclxuXHRcdC8vIHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogRVBTRzM4NTcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjZW50ZXI6IExhdExuZyA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBnZW9ncmFwaGljIGNlbnRlciBvZiB0aGUgbWFwXHJcblx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBtYXAgem9vbSBsZXZlbFxyXG5cdFx0em9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gKlxyXG5cdFx0Ly8gTWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuXHRcdC8vIHRoZSBsb3dlc3Qgb2YgdGhlaXIgYG1pblpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtaW5ab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAqXHJcblx0XHQvLyBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxyXG5cdFx0Ly8gdGhlIGhpZ2hlc3Qgb2YgdGhlaXIgYG1heFpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtYXhab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IExheWVyW10gPSBbXVxyXG5cdFx0Ly8gQXJyYXkgb2YgbGF5ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIGluaXRpYWxseVxyXG5cdFx0bGF5ZXJzOiBbXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEJvdW5kczogTGF0TG5nQm91bmRzID0gbnVsbFxyXG5cdFx0Ly8gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBtYXAgcmVzdHJpY3RzIHRoZSB2aWV3IHRvIHRoZSBnaXZlblxyXG5cdFx0Ly8gZ2VvZ3JhcGhpY2FsIGJvdW5kcywgYm91bmNpbmcgdGhlIHVzZXIgYmFjayBpZiB0aGUgdXNlciB0cmllcyB0byBwYW5cclxuXHRcdC8vIG91dHNpZGUgdGhlIHZpZXcuIFRvIHNldCB0aGUgcmVzdHJpY3Rpb24gZHluYW1pY2FsbHksIHVzZVxyXG5cdFx0Ly8gW2BzZXRNYXhCb3VuZHNgXSgjbWFwLXNldG1heGJvdW5kcykgbWV0aG9kLlxyXG5cdFx0bWF4Qm91bmRzOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXIgPSAqXHJcblx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXHJcblx0XHQvLyBvciBgTC5DYW52YXNgIGJ5IGRlZmF1bHQgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydC5cclxuXHRcdHJlbmRlcmVyOiB1bmRlZmluZWQsXHJcblxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgem9vbSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdHpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uVGhyZXNob2xkOiBOdW1iZXIgPSA0XHJcblx0XHQvLyBXb24ndCBhbmltYXRlIHpvb20gaWYgdGhlIHpvb20gZGlmZmVyZW5jZSBleGNlZWRzIHRoaXMgdmFsdWUuXHJcblx0XHR6b29tQW5pbWF0aW9uVGhyZXNob2xkOiA0LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZmFkZUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHRpbGUgZmFkZSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdGZhZGVBbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciBtYXJrZXJzIGFuaW1hdGUgdGhlaXIgem9vbSB3aXRoIHRoZSB6b29tIGFuaW1hdGlvbiwgaWYgZGlzYWJsZWRcclxuXHRcdC8vIHRoZXkgd2lsbCBkaXNhcHBlYXIgZm9yIHRoZSBsZW5ndGggb2YgdGhlIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCBpdCdzXHJcblx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdG1hcmtlclpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc2Zvcm0zRExpbWl0OiBOdW1iZXIgPSAyXjIzXHJcblx0XHQvLyBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBDU1MgdHJhbnNsYXRpb24gdHJhbnNmb3JtLiBUaGUgZGVmYXVsdFxyXG5cdFx0Ly8gdmFsdWUgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIHVubGVzcyBhIHdlYiBicm93c2VyIHBvc2l0aW9ucyBsYXllcnMgaW5cclxuXHRcdC8vIHRoZSB3cm9uZyBwbGFjZSBhZnRlciBkb2luZyBhIGxhcmdlIGBwYW5CeWAuXHJcblx0XHR0cmFuc2Zvcm0zRExpbWl0OiA4Mzg4NjA4LCAvLyBQcmVjaXNpb24gbGltaXQgb2YgYSAzMi1iaXQgZmxvYXRcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21TbmFwOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBGb3JjZXMgdGhlIG1hcCdzIHpvb20gbGV2ZWwgdG8gYWx3YXlzIGJlIGEgbXVsdGlwbGUgb2YgdGhpcywgcGFydGljdWxhcmx5XHJcblx0XHQvLyByaWdodCBhZnRlciBhIFtgZml0Qm91bmRzKClgXSgjbWFwLWZpdGJvdW5kcykgb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgdGhlIHpvb20gbGV2ZWwgc25hcHMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlcjsgbG93ZXIgdmFsdWVzXHJcblx0XHQvLyAoZS5nLiBgMC41YCBvciBgMC4xYCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuIEEgdmFsdWUgb2YgYDBgXHJcblx0XHQvLyBtZWFucyB0aGUgem9vbSBsZXZlbCB3aWxsIG5vdCBiZSBzbmFwcGVkIGFmdGVyIGBmaXRCb3VuZHNgIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdHpvb21TbmFwOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBDb250cm9scyBob3cgbXVjaCB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB3aWxsIGNoYW5nZSBhZnRlciBhXHJcblx0XHQvLyBbYHpvb21JbigpYF0oI21hcC16b29taW4pLCBbYHpvb21PdXQoKWBdKCNtYXAtem9vbW91dCksIHByZXNzaW5nIGArYFxyXG5cdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cclxuXHRcdC8vIFZhbHVlcyBzbWFsbGVyIHRoYW4gYDFgIChlLmcuIGAwLjVgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS5cclxuXHRcdHpvb21EZWx0YTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYWNrUmVzaXplOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBicm93c2VyIHdpbmRvdyByZXNpemUgdG8gdXBkYXRlIGl0c2VsZi5cclxuXHRcdHRyYWNrUmVzaXplOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7IC8vIChIVE1MRWxlbWVudCBvciBTdHJpbmcsIE9iamVjdClcclxuXHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIE1ha2Ugc3VyZSB0byBhc3NpZ24gaW50ZXJuYWwgZmxhZ3MgYXQgdGhlIGJlZ2lubmluZyxcclxuXHRcdC8vIHRvIGF2b2lkIGluY29uc2lzdGVudCBzdGF0ZSBpbiBzb21lIGVkZ2UgY2FzZXMuXHJcblx0XHR0aGlzLl9oYW5kbGVycyA9IFtdO1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl96b29tQm91bmRMYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKGlkKTtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHJcblx0XHQvLyBoYWNrIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xOTgwXHJcblx0XHR0aGlzLl9vblJlc2l6ZSA9IGJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKG9wdGlvbnMuem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuY2VudGVyICYmIG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc2V0Vmlldyh0b0xhdExuZyhvcHRpb25zLmNlbnRlciksIG9wdGlvbnMuem9vbSwge3Jlc2V0OiB0cnVlfSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBUUkFOU0lUSU9OICYmIGFueTNkICYmICFtb2JpbGVPcGVyYSAmJlxyXG5cdFx0XHRcdHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xyXG5cdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdHRoaXMuX2NyZWF0ZUFuaW1Qcm94eSgpO1xyXG5cdFx0XHRvbih0aGlzLl9wcm94eSwgVFJBTlNJVElPTl9FTkQsIHRoaXMuX2NhdGNoVHJhbnNpdGlvbkVuZCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYWRkTGF5ZXJzKHRoaXMub3B0aW9ucy5sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VmlldyhjZW50ZXI6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHdpdGggdGhlIGdpdmVuXHJcblx0Ly8gYW5pbWF0aW9uIG9wdGlvbnMuXHJcblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cdFx0Y2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIodG9MYXRMbmcoY2VudGVyKSwgem9vbSwgdGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiAhb3B0aW9ucy5yZXNldCAmJiBvcHRpb25zICE9PSB0cnVlKSB7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb20gPSBleHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMuem9vbSk7XHJcblx0XHRcdFx0b3B0aW9ucy5wYW4gPSBleHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSwgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb259LCBvcHRpb25zLnBhbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cclxuXHRcdFx0dmFyIG1vdmVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cclxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6XHJcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XHJcblxyXG5cdFx0XHRpZiAobW92ZWQpIHtcclxuXHRcdFx0XHQvLyBwcmV2ZW50IHJlc2l6ZSBoYW5kbGVyIGNhbGwsIHRoZSB2aWV3IHdpbGwgcmVmcmVzaCBhZnRlciBhbmltYXRpb24gYW55d2F5XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRpb24gZGlkbid0IHN0YXJ0LCBqdXN0IHJlc2V0IHRoZSBtYXAgdmlld1xyXG5cdFx0dGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tKHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgem9vbSBvZiB0aGUgbWFwLlxyXG5cdHNldFpvb206IGZ1bmN0aW9uICh6b29tLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tSW4oZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gSW5jcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbUluOiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKGFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tICsgZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbU91dChkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBEZWNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tT3V0OiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKGFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tIC0gZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIGdlb2dyYXBoaWNhbCBwb2ludCBvbiB0aGUgbWFwXHJcblx0Ly8gc3RhdGlvbmFyeSAoZS5nLiB1c2VkIGludGVybmFsbHkgZm9yIHNjcm9sbCB6b29tIGFuZCBkb3VibGUtY2xpY2sgem9vbSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKG9mZnNldDogUG9pbnQsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBwaXhlbCBvbiB0aGUgbWFwIChyZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyKSBzdGF0aW9uYXJ5LlxyXG5cdHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBsYXRsbmcgaW5zdGFuY2VvZiBQb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRCb3VuZHNDZW50ZXJab29tOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRib3VuZHMgPSBib3VuZHMuZ2V0Qm91bmRzID8gYm91bmRzLmdldEJvdW5kcygpIDogdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzLCBmYWxzZSwgcGFkZGluZ1RMLmFkZChwYWRkaW5nQlIpKTtcclxuXHJcblx0XHR6b29tID0gKHR5cGVvZiBvcHRpb25zLm1heFpvb20gPT09ICdudW1iZXInKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuXHRcdGlmICh6b29tID09PSBJbmZpbml0eSkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNlbnRlcjogYm91bmRzLmdldENlbnRlcigpLFxyXG5cdFx0XHRcdHpvb206IHpvb21cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuXHRcdCAgICBzd1BvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSksXHJcblx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb21cclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZ2VvZ3JhcGhpY2FsIGJvdW5kcyB3aXRoIHRoZVxyXG5cdC8vIG1heGltdW0gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBhcmUgbm90IHZhbGlkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdFdvcmxkKG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBtb3N0bHkgY29udGFpbnMgdGhlIHdob2xlIHdvcmxkIHdpdGggdGhlIG1heGltdW1cclxuXHQvLyB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5UbyhsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byBhIGdpdmVuIGNlbnRlci5cclxuXHRwYW5UbzogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkJ5KG9mZnNldDogUG9pbnQsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgYnkgYSBnaXZlbiBudW1iZXIgb2YgcGl4ZWxzIChhbmltYXRlZCkuXHJcblx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQsIG9wdGlvbnMpIHtcclxuXHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gSWYgd2UgcGFuIHRvbyBmYXIsIENocm9tZSBnZXRzIGlzc3VlcyB3aXRoIHRpbGVzXHJcblx0XHQvLyBhbmQgbWFrZXMgdGhlbSBkaXNhcHBlYXIgb3IgYXBwZWFyIGluIHRoZSB3cm9uZyBwbGFjZSAoc2xpZ2h0bHkgb2Zmc2V0KSAjMjYwMlxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkge1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy51bnByb2plY3QodGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBQb3NBbmltYXRpb24oKTtcclxuXHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ub24oe1xyXG5cdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcclxuXHRcdFx0XHQnZW5kJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uRW5kXHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRvbid0IGZpcmUgbW92ZXN0YXJ0IGlmIGFuaW1hdGluZyBpbmVydGlhXHJcblx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSBmYWxzZSkge1xyXG5cdFx0XHRhZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cclxuXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ucnVuKHRoaXMuX21hcFBhbmUsIG5ld1Bvcywgb3B0aW9ucy5kdXJhdGlvbiB8fCAwLjI1LCBvcHRpb25zLmVhc2VMaW5lYXJpdHkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG8obGF0bG5nOiBMYXRMbmcsIHpvb20/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgcGVyZm9ybWluZyBhIHNtb290aFxyXG5cdC8vIHBhbi16b29tIGFuaW1hdGlvbi5cclxuXHRmbHlUbzogZnVuY3Rpb24gKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIWFueTNkKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0dmFyIGZyb20gPSB0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSksXHJcblx0XHQgICAgdG8gPSB0aGlzLnByb2plY3QodGFyZ2V0Q2VudGVyKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgc3RhcnRab29tID0gdGhpcy5fem9vbTtcclxuXHJcblx0XHR0YXJnZXRDZW50ZXIgPSB0b0xhdExuZyh0YXJnZXRDZW50ZXIpO1xyXG5cdFx0dGFyZ2V0Wm9vbSA9IHRhcmdldFpvb20gPT09IHVuZGVmaW5lZCA/IHN0YXJ0Wm9vbSA6IHRhcmdldFpvb207XHJcblxyXG5cdFx0dmFyIHcwID0gTWF0aC5tYXgoc2l6ZS54LCBzaXplLnkpLFxyXG5cdFx0ICAgIHcxID0gdzAgKiB0aGlzLmdldFpvb21TY2FsZShzdGFydFpvb20sIHRhcmdldFpvb20pLFxyXG5cdFx0ICAgIHUxID0gKHRvLmRpc3RhbmNlVG8oZnJvbSkpIHx8IDEsXHJcblx0XHQgICAgcmhvID0gMS40MixcclxuXHRcdCAgICByaG8yID0gcmhvICogcmhvO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHIoaSkge1xyXG5cdFx0XHR2YXIgczEgPSBpID8gLTEgOiAxLFxyXG5cdFx0XHQgICAgczIgPSBpID8gdzEgOiB3MCxcclxuXHRcdFx0ICAgIHQxID0gdzEgKiB3MSAtIHcwICogdzAgKyBzMSAqIHJobzIgKiByaG8yICogdTEgKiB1MSxcclxuXHRcdFx0ICAgIGIxID0gMiAqIHMyICogcmhvMiAqIHUxLFxyXG5cdFx0XHQgICAgYiA9IHQxIC8gYjEsXHJcblx0XHRcdCAgICBzcSA9IE1hdGguc3FydChiICogYiArIDEpIC0gYjtcclxuXHJcblx0XHRcdCAgICAvLyB3b3JrYXJvdW5kIGZvciBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gYnVnIHdoZW4gc3EgPSAwLCBsb2cgPSAtSW5maW5pdGUsXHJcblx0XHRcdCAgICAvLyB0aHVzIHRyaWdnZXJpbmcgYW4gaW5maW5pdGUgbG9vcCBpbiBmbHlUb1xyXG5cdFx0XHQgICAgdmFyIGxvZyA9IHNxIDwgMC4wMDAwMDAwMDEgPyAtMTggOiBNYXRoLmxvZyhzcSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gbG9nO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNpbmgobikgeyByZXR1cm4gKE1hdGguZXhwKG4pIC0gTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuXHRcdGZ1bmN0aW9uIGNvc2gobikgeyByZXR1cm4gKE1hdGguZXhwKG4pICsgTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuXHRcdGZ1bmN0aW9uIHRhbmgobikgeyByZXR1cm4gc2luaChuKSAvIGNvc2gobik7IH1cclxuXHJcblx0XHR2YXIgcjAgPSByKDApO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHcocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgLyBjb3NoKHIwICsgcmhvICogcykpOyB9XHJcblx0XHRmdW5jdGlvbiB1KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApICogdGFuaChyMCArIHJobyAqIHMpIC0gc2luaChyMCkpIC8gcmhvMjsgfVxyXG5cclxuXHRcdGZ1bmN0aW9uIGVhc2VPdXQodCkgeyByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCAxLjUpOyB9XHJcblxyXG5cdFx0dmFyIHN0YXJ0ID0gRGF0ZS5ub3coKSxcclxuXHRcdCAgICBTID0gKHIoMSkgLSByMCkgLyByaG8sXHJcblx0XHQgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID8gMTAwMCAqIG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwICogUyAqIDAuODtcclxuXHJcblx0XHRmdW5jdGlvbiBmcmFtZSgpIHtcclxuXHRcdFx0dmFyIHQgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSAvIGR1cmF0aW9uLFxyXG5cdFx0XHQgICAgcyA9IGVhc2VPdXQodCkgKiBTO1xyXG5cclxuXHRcdFx0aWYgKHQgPD0gMSkge1xyXG5cdFx0XHRcdHRoaXMuX2ZseVRvRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lKGZyYW1lLCB0aGlzKTtcclxuXHJcblx0XHRcdFx0dGhpcy5fbW92ZShcclxuXHRcdFx0XHRcdHRoaXMudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1YnRyYWN0KGZyb20pLm11bHRpcGx5QnkodShzKSAvIHUxKSksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR0aGlzLmdldFNjYWxlWm9vbSh3MCAvIHcocyksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR7Zmx5VG86IHRydWV9KTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpc1xyXG5cdFx0XHRcdFx0Ll9tb3ZlKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSlcclxuXHRcdFx0XHRcdC5fbW92ZUVuZCh0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0KTtcclxuXHJcblx0XHRmcmFtZS5jYWxsKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUb0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCB3aXRoIGEgc21vb3RoIGFuaW1hdGlvbiBsaWtlIFtgZmx5VG9gXSgjbWFwLWZseXRvKSxcclxuXHQvLyBidXQgdGFrZXMgYSBib3VuZHMgcGFyYW1ldGVyIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcblx0Zmx5VG9Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5mbHlUbyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhCb3VuZHMoYm91bmRzOiBCb3VuZHMpOiB0aGlzXHJcblx0Ly8gUmVzdHJpY3RzIHRoZSBtYXAgdmlldyB0byB0aGUgZ2l2ZW4gYm91bmRzIChzZWUgdGhlIFttYXhCb3VuZHNdKCNtYXAtbWF4Ym91bmRzKSBvcHRpb24pLlxyXG5cdHNldE1heEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IG51bGw7XHJcblx0XHRcdHJldHVybiB0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBib3VuZHM7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNaW5ab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBsb3dlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWluWm9vbV0oI21hcC1taW56b29tKSBvcHRpb24pLlxyXG5cdHNldE1pblpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdFx0dGhpcy5vcHRpb25zLm1pblpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmdldFpvb20oKSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Wm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdXBwZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21heFpvb21dKCNtYXAtbWF4em9vbSkgb3B0aW9uKS5cclxuXHRzZXRNYXhab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuXHRcdHRoaXMub3B0aW9ucy5tYXhab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkluc2lkZUJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byB0aGUgY2xvc2VzdCB2aWV3IHRoYXQgd291bGQgbGllIGluc2lkZSB0aGUgZ2l2ZW4gYm91bmRzIChpZiBpdCdzIG5vdCBhbHJlYWR5KSwgY29udHJvbGxpbmcgdGhlIGFuaW1hdGlvbiB1c2luZyB0aGUgb3B0aW9ucyBzcGVjaWZpYywgaWYgYW55LlxyXG5cdHBhbkluc2lkZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKGNlbnRlciwgdGhpcy5fem9vbSwgdG9MYXRMbmdCb3VuZHMoYm91bmRzKSk7XHJcblxyXG5cdFx0aWYgKCFjZW50ZXIuZXF1YWxzKG5ld0NlbnRlcikpIHtcclxuXHRcdFx0dGhpcy5wYW5UbyhuZXdDZW50ZXIsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0aGUgbWluaW11bSBhbW91bnQgdG8gbWFrZSB0aGUgYGxhdGxuZ2AgdmlzaWJsZS4gVXNlXHJcblx0Ly8gYHBhZGRpbmdgLCBgcGFkZGluZ1RvcExlZnRgIGFuZCBgcGFkZGluZ1RvcFJpZ2h0YCBvcHRpb25zIHRvIGZpdFxyXG5cdC8vIHRoZSBkaXNwbGF5IHRvIG1vcmUgcmVzdHJpY3RlZCBib3VuZHMsIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcblx0Ly8gSWYgYGxhdGxuZ2AgaXMgYWxyZWFkeSB3aXRoaW4gdGhlIChvcHRpb25hbGx5IHBhZGRlZCkgZGlzcGxheSBib3VuZHMsXHJcblx0Ly8gdGhlIG1hcCB3aWxsIG5vdCBiZSBwYW5uZWQuXHJcblx0cGFuSW5zaWRlOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBwaXhlbENlbnRlciA9IHRoaXMucHJvamVjdChjZW50ZXIpLFxyXG5cdFx0ICAgIHBpeGVsUG9pbnQgPSB0aGlzLnByb2plY3QobGF0bG5nKSxcclxuXHRcdCAgICBwaXhlbEJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBoYWxmUGl4ZWxCb3VuZHMgPSBwaXhlbEJvdW5kcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgcGFkZGVkQm91bmRzID0gdG9Cb3VuZHMoW3BpeGVsQm91bmRzLm1pbi5hZGQocGFkZGluZ1RMKSwgcGl4ZWxCb3VuZHMubWF4LnN1YnRyYWN0KHBhZGRpbmdCUildKTtcclxuXHJcblx0XHRpZiAoIXBhZGRlZEJvdW5kcy5jb250YWlucyhwaXhlbFBvaW50KSkge1xyXG5cdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG5cdFx0XHR2YXIgZGlmZiA9IHBpeGVsQ2VudGVyLnN1YnRyYWN0KHBpeGVsUG9pbnQpLFxyXG5cdFx0XHQgICAgbmV3Q2VudGVyID0gdG9Qb2ludChwaXhlbFBvaW50LnggKyBkaWZmLngsIHBpeGVsUG9pbnQueSArIGRpZmYueSk7XHJcblxyXG5cdFx0XHRpZiAocGl4ZWxQb2ludC54IDwgcGFkZGVkQm91bmRzLm1pbi54IHx8IHBpeGVsUG9pbnQueCA+IHBhZGRlZEJvdW5kcy5tYXgueCkge1xyXG5cdFx0XHRcdG5ld0NlbnRlci54ID0gcGl4ZWxDZW50ZXIueCAtIGRpZmYueDtcclxuXHRcdFx0XHRpZiAoZGlmZi54ID4gMCkge1xyXG5cdFx0XHRcdFx0bmV3Q2VudGVyLnggKz0gaGFsZlBpeGVsQm91bmRzLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bmV3Q2VudGVyLnggLT0gaGFsZlBpeGVsQm91bmRzLnggLSBwYWRkaW5nQlIueDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHBpeGVsUG9pbnQueSA8IHBhZGRlZEJvdW5kcy5taW4ueSB8fCBwaXhlbFBvaW50LnkgPiBwYWRkZWRCb3VuZHMubWF4LnkpIHtcclxuXHRcdFx0XHRuZXdDZW50ZXIueSA9IHBpeGVsQ2VudGVyLnkgLSBkaWZmLnk7XHJcblx0XHRcdFx0aWYgKGRpZmYueSA+IDApIHtcclxuXHRcdFx0XHRcdG5ld0NlbnRlci55ICs9IGhhbGZQaXhlbEJvdW5kcy55IC0gcGFkZGluZ1RMLnk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG5ld0NlbnRlci55IC09IGhhbGZQaXhlbEJvdW5kcy55IC0gcGFkZGluZ0JSLnk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMucGFuVG8odGhpcy51bnByb2plY3QobmV3Q2VudGVyKSwgb3B0aW9ucyk7XHJcblx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShvcHRpb25zOiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuXHQvLyBwYW4gYnkgZGVmYXVsdC4gSWYgYG9wdGlvbnMucGFuYCBpcyBgZmFsc2VgLCBwYW5uaW5nIHdpbGwgbm90IG9jY3VyLlxyXG5cdC8vIElmIGBvcHRpb25zLmRlYm91bmNlTW92ZWVuZGAgaXMgYHRydWVgLCBpdCB3aWxsIGRlbGF5IGBtb3ZlZW5kYCBldmVudCBzb1xyXG5cdC8vIHRoYXQgaXQgZG9lc24ndCBoYXBwZW4gb2Z0ZW4gZXZlbiBpZiB0aGUgbWV0aG9kIGlzIGNhbGxlZCBtYW55XHJcblx0Ly8gdGltZXMgaW4gYSByb3cuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUoYW5pbWF0ZTogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuXHJcblx0aW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdG9wdGlvbnMgPSBleHRlbmQoe1xyXG5cdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuXHRcdFx0cGFuOiB0cnVlXHJcblx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG5cdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ21vdmVlbmQnKSwgMjAwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcmVzaXplOiBSZXNpemVFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIHJlc2l6ZWQuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdyZXNpemUnLCB7XHJcblx0XHRcdG9sZFNpemU6IG9sZFNpemUsXHJcblx0XHRcdG5ld1NpemU6IG5ld1NpemVcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHQvLyBAbWV0aG9kIHN0b3AoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHRoZSBjdXJyZW50bHkgcnVubmluZyBgcGFuVG9gIG9yIGBmbHlUb2AgYW5pbWF0aW9uLCBpZiBhbnkuXHJcblx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5zZXRab29tKHRoaXMuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy56b29tU25hcCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3N0b3AoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBHZW9sb2NhdGlvbiBtZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBsb2NhdGUob3B0aW9ucz86IExvY2F0ZSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFRyaWVzIHRvIGxvY2F0ZSB0aGUgdXNlciB1c2luZyB0aGUgR2VvbG9jYXRpb24gQVBJLCBmaXJpbmcgYSBbYGxvY2F0aW9uZm91bmRgXSgjbWFwLWxvY2F0aW9uZm91bmQpXHJcblx0Ly8gZXZlbnQgd2l0aCBsb2NhdGlvbiBkYXRhIG9uIHN1Y2Nlc3Mgb3IgYSBbYGxvY2F0aW9uZXJyb3JgXSgjbWFwLWxvY2F0aW9uZXJyb3IpIGV2ZW50IG9uIGZhaWx1cmUsXHJcblx0Ly8gYW5kIG9wdGlvbmFsbHkgc2V0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIHVzZXIncyBsb2NhdGlvbiB3aXRoIHJlc3BlY3QgdG9cclxuXHQvLyBkZXRlY3Rpb24gYWNjdXJhY3kgKG9yIHRvIHRoZSB3b3JsZCB2aWV3IGlmIGdlb2xvY2F0aW9uIGZhaWxlZCkuXHJcblx0Ly8gTm90ZSB0aGF0LCBpZiB5b3VyIHBhZ2UgZG9lc24ndCB1c2UgSFRUUFMsIHRoaXMgbWV0aG9kIHdpbGwgZmFpbCBpblxyXG5cdC8vIG1vZGVybiBicm93c2VycyAoW0Nocm9tZSA1MCBhbmQgbmV3ZXJdKGh0dHBzOi8vc2l0ZXMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9kZXYvSG9tZS9jaHJvbWl1bS1zZWN1cml0eS9kZXByZWNhdGluZy1wb3dlcmZ1bC1mZWF0dXJlcy1vbi1pbnNlY3VyZS1vcmlnaW5zKSlcclxuXHQvLyBTZWUgYExvY2F0ZSBvcHRpb25zYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG5cdGxvY2F0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucyA9IGV4dGVuZCh7XHJcblx0XHRcdHRpbWVvdXQ6IDEwMDAwLFxyXG5cdFx0XHR3YXRjaDogZmFsc2VcclxuXHRcdFx0Ly8gc2V0VmlldzogZmFsc2VcclxuXHRcdFx0Ly8gbWF4Wm9vbTogPE51bWJlcj5cclxuXHRcdFx0Ly8gbWF4aW11bUFnZTogMFxyXG5cdFx0XHQvLyBlbmFibGVIaWdoQWNjdXJhY3k6IGZhbHNlXHJcblx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRpZiAoISgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikpIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvcih7XHJcblx0XHRcdFx0Y29kZTogMCxcclxuXHRcdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gbm90IHN1cHBvcnRlZC4nXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb25SZXNwb25zZSA9IGJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcblx0XHQgICAgb25FcnJvciA9IGJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvciwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMud2F0Y2gpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRpb25XYXRjaElkID1cclxuXHRcdFx0ICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN0b3BMb2NhdGUoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHdhdGNoaW5nIGxvY2F0aW9uIHByZXZpb3VzbHkgaW5pdGlhdGVkIGJ5IGBtYXAubG9jYXRlKHt3YXRjaDogdHJ1ZX0pYFxyXG5cdC8vIGFuZCBhYm9ydHMgcmVzZXR0aW5nIHRoZSBtYXAgdmlldyBpZiBtYXAubG9jYXRlIHdhcyBjYWxsZWQgd2l0aFxyXG5cdC8vIGB7c2V0VmlldzogdHJ1ZX1gLlxyXG5cdHN0b3BMb2NhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24gJiYgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2gpIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fbG9jYXRpb25XYXRjaElkKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdFx0dmFyIGMgPSBlcnJvci5jb2RlLFxyXG5cdFx0ICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMSA/ICdwZXJtaXNzaW9uIGRlbmllZCcgOlxyXG5cdFx0ICAgICAgICAgICAgKGMgPT09IDIgPyAncG9zaXRpb24gdW5hdmFpbGFibGUnIDogJ3RpbWVvdXQnKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyAmJiAhdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuZml0V29ybGQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBMb2NhdGlvbiBldmVudHNcclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmVycm9yOiBFcnJvckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKSBmYWlsZWQuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZXJyb3InLCB7XHJcblx0XHRcdGNvZGU6IGMsXHJcblx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBlcnJvcjogJyArIG1lc3NhZ2UgKyAnLidcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHR2YXIgbGF0ID0gcG9zLmNvb3Jkcy5sYXRpdHVkZSxcclxuXHRcdCAgICBsbmcgPSBwb3MuY29vcmRzLmxvbmdpdHVkZSxcclxuXHRcdCAgICBsYXRsbmcgPSBuZXcgTGF0TG5nKGxhdCwgbG5nKSxcclxuXHRcdCAgICBib3VuZHMgPSBsYXRsbmcudG9Cb3VuZHMocG9zLmNvb3Jkcy5hY2N1cmFjeSAqIDIpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnNldFZpZXcpIHtcclxuXHRcdFx0dmFyIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzKTtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KGxhdGxuZywgb3B0aW9ucy5tYXhab29tID8gTWF0aC5taW4oem9vbSwgb3B0aW9ucy5tYXhab29tKSA6IHpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRsYXRsbmc6IGxhdGxuZyxcclxuXHRcdFx0Ym91bmRzOiBib3VuZHMsXHJcblx0XHRcdHRpbWVzdGFtcDogcG9zLnRpbWVzdGFtcFxyXG5cdFx0fTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHBvcy5jb29yZHMpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBwb3MuY29vcmRzW2ldID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRcdGRhdGFbaV0gPSBwb3MuY29vcmRzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZm91bmQ6IExvY2F0aW9uRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpXHJcblx0XHQvLyB3ZW50IHN1Y2Nlc3NmdWxseS5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25mb3VuZCcsIGRhdGEpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE8gQXBwcm9wcmlhdGUgZG9jcyBzZWN0aW9uP1xyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGFkZEhhbmRsZXIobmFtZTogU3RyaW5nLCBIYW5kbGVyQ2xhc3M6IEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBuZXcgYEhhbmRsZXJgIHRvIHRoZSBtYXAsIGdpdmVuIGl0cyBuYW1lIGFuZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuXHRhZGRIYW5kbGVyOiBmdW5jdGlvbiAobmFtZSwgSGFuZGxlckNsYXNzKSB7XHJcblx0XHRpZiAoIUhhbmRsZXJDbGFzcykgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gdGhpc1tuYW1lXSA9IG5ldyBIYW5kbGVyQ2xhc3ModGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XHJcblx0XHRcdGhhbmRsZXIuZW5hYmxlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmUoKTogdGhpc1xyXG5cdC8vIERlc3Ryb3lzIHRoZSBtYXAgYW5kIGNsZWFycyBhbGwgcmVsYXRlZCBldmVudCBsaXN0ZW5lcnMuXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cyh0cnVlKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY29udGFpbmVySWQgIT09IHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYmVpbmcgcmV1c2VkIGJ5IGFub3RoZXIgaW5zdGFuY2UnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyB0aHJvd3MgZXJyb3IgaW4gSUU2LThcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZDtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcklkO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXJJZCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRpb25XYXRjaElkICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5zdG9wTG9jYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuXHRcdHJlbW92ZSh0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY2xlYXJDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2NsZWFyQ29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpIHtcclxuXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jbGVhckhhbmRsZXJzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgdW5sb2FkOiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgZGVzdHJveWVkIHdpdGggW3JlbW92ZV0oI21hcC1yZW1vdmUpIG1ldGhvZC5cclxuXHRcdFx0dGhpcy5maXJlKCd1bmxvYWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLnJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX3BhbmVzKSB7XHJcblx0XHRcdHJlbW92ZSh0aGlzLl9wYW5lc1tpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLl9wYW5lcyA9IFtdO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX21hcFBhbmU7XHJcblx0XHRkZWxldGUgdGhpcy5fcmVuZGVyZXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgY3JlYXRlUGFuZShuYW1lOiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDcmVhdGVzIGEgbmV3IFttYXAgcGFuZV0oI21hcC1wYW5lKSB3aXRoIHRoZSBnaXZlbiBuYW1lIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeSxcclxuXHQvLyB0aGVuIHJldHVybnMgaXQuIFRoZSBwYW5lIGlzIGNyZWF0ZWQgYXMgYSBjaGlsZCBvZiBgY29udGFpbmVyYCwgb3JcclxuXHQvLyBhcyBhIGNoaWxkIG9mIHRoZSBtYWluIG1hcCBwYW5lIGlmIG5vdCBzZXQuXHJcblx0Y3JlYXRlUGFuZTogZnVuY3Rpb24gKG5hbWUsIGNvbnRhaW5lcikge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LXBhbmUnICsgKG5hbWUgPyAnIGxlYWZsZXQtJyArIG5hbWUucmVwbGFjZSgnUGFuZScsICcnKSArICctcGFuZScgOiAnJyksXHJcblx0XHQgICAgcGFuZSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lciB8fCB0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAobmFtZSkge1xyXG5cdFx0XHR0aGlzLl9wYW5lc1tuYW1lXSA9IHBhbmU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcGFuZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBHZXR0aW5nIE1hcCBTdGF0ZVxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgY2VudGVyIG9mIHRoZSBtYXAgdmlld1xyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0Q2VudGVyICYmICF0aGlzLl9tb3ZlZCgpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9sYXN0Q2VudGVyO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgbWFwIHZpZXdcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgc3cgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0Qm90dG9tTGVmdCgpKSxcclxuXHRcdCAgICBuZSA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRUb3BSaWdodCgpKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhzdywgbmUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWluWm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWluWm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycyksIG9yIGAwYCBieSBkZWZhdWx0LlxyXG5cdGdldE1pblpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fbGF5ZXJzTWluWm9vbSB8fCAwIDogdGhpcy5vcHRpb25zLm1pblpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNYXhab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtYXhab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKS5cclxuXHRnZXRNYXhab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdCh0aGlzLl9sYXllcnNNYXhab29tID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRoaXMuX2xheWVyc01heFpvb20pIDpcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHNab29tKGJvdW5kczogTGF0TG5nQm91bmRzLCBpbnNpZGU/OiBCb29sZWFuLCBwYWRkaW5nPzogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGdpdmVuIGJvdW5kcyBmaXQgdG8gdGhlIG1hcFxyXG5cdC8vIHZpZXcgaW4gaXRzIGVudGlyZXR5LiBJZiBgaW5zaWRlYCAob3B0aW9uYWwpIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBtZXRob2RcclxuXHQvLyBpbnN0ZWFkIHJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbWFwIHZpZXcgZml0cyBpbnRvXHJcblx0Ly8gdGhlIGdpdmVuIGJvdW5kcyBpbiBpdHMgZW50aXJldHkuXHJcblx0Z2V0Qm91bmRzWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKSB7IC8vIChMYXRMbmdCb3VuZHNbLCBCb29sZWFuLCBQb2ludF0pIC0+IE51bWJlclxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHRcdHBhZGRpbmcgPSB0b1BvaW50KHBhZGRpbmcgfHwgWzAsIDBdKTtcclxuXHJcblx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpIHx8IDAsXHJcblx0XHQgICAgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgbncgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCksXHJcblx0XHQgICAgc2UgPSBib3VuZHMuZ2V0U291dGhFYXN0KCksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLnN1YnRyYWN0KHBhZGRpbmcpLFxyXG5cdFx0ICAgIGJvdW5kc1NpemUgPSB0b0JvdW5kcyh0aGlzLnByb2plY3Qoc2UsIHpvb20pLCB0aGlzLnByb2plY3QobncsIHpvb20pKS5nZXRTaXplKCksXHJcblx0XHQgICAgc25hcCA9IGFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMSxcclxuXHRcdCAgICBzY2FsZXggPSBzaXplLnggLyBib3VuZHNTaXplLngsXHJcblx0XHQgICAgc2NhbGV5ID0gc2l6ZS55IC8gYm91bmRzU2l6ZS55LFxyXG5cdFx0ICAgIHNjYWxlID0gaW5zaWRlID8gTWF0aC5tYXgoc2NhbGV4LCBzY2FsZXkpIDogTWF0aC5taW4oc2NhbGV4LCBzY2FsZXkpO1xyXG5cclxuXHRcdHpvb20gPSB0aGlzLmdldFNjYWxlWm9vbShzY2FsZSwgem9vbSk7XHJcblxyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIChzbmFwIC8gMTAwKSkgKiAoc25hcCAvIDEwMCk7IC8vIGRvbid0IGp1bXAgaWYgd2l0aGluIDElIG9mIGEgc25hcCBsZXZlbFxyXG5cdFx0XHR6b29tID0gaW5zaWRlID8gTWF0aC5jZWlsKHpvb20gLyBzbmFwKSAqIHNuYXAgOiBNYXRoLmZsb29yKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBtYXAgY29udGFpbmVyIChpbiBwaXhlbHMpLlxyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IFBvaW50KFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAwLFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgMCk7XHJcblxyXG5cdFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3NpemUuY2xvbmUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsQm91bmRzKCk6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBtYXAgdmlldyBpbiBwcm9qZWN0ZWQgcGl4ZWxcclxuXHQvLyBjb29yZGluYXRlcyAoc29tZXRpbWVzIHVzZWZ1bCBpbiBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0VG9wTGVmdFBvaW50KGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyh0b3BMZWZ0UG9pbnQsIHRvcExlZnRQb2ludC5hZGQodGhpcy5nZXRTaXplKCkpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPOiBDaGVjayBzZW1hbnRpY3MgLSBpc24ndCB0aGUgcGl4ZWwgb3JpZ2luIHRoZSAwLDAgY29vcmQgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgbWFwIHBhbmU/IFwibGVmdCBwb2ludCBvZiB0aGUgbWFwIGxheWVyXCIgY2FuIGJlIGNvbmZ1c2luZywgc3BlY2lhbGx5XHJcblx0Ly8gc2luY2UgdGhlcmUgY2FuIGJlIG5lZ2F0aXZlIG9mZnNldHMuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbE9yaWdpbigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHByb2plY3RlZCBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgdG9wIGxlZnQgcG9pbnQgb2ZcclxuXHQvLyB0aGUgbWFwIGxheWVyICh1c2VmdWwgaW4gY3VzdG9tIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHRcdHJldHVybiB0aGlzLl9waXhlbE9yaWdpbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsV29ybGRCb3VuZHMoem9vbT86IE51bWJlcik6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIHdvcmxkJ3MgYm91bmRzIGluIHBpeGVsIGNvb3JkaW5hdGVzIGZvciB6b29tIGxldmVsIGB6b29tYC5cclxuXHQvLyBJZiBgem9vbWAgaXMgb21pdHRlZCwgdGhlIG1hcCdzIGN1cnJlbnQgem9vbSBsZXZlbCBpcyB1c2VkLlxyXG5cdGdldFBpeGVsV29ybGRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5nZXRQcm9qZWN0ZWRCb3VuZHMoem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRab29tKCkgOiB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShwYW5lOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgYSBbbWFwIHBhbmVdKCNtYXAtcGFuZSksIGdpdmVuIGl0cyBuYW1lIG9yIGl0cyBIVE1MIGVsZW1lbnQgKGl0cyBpZGVudGl0eSkuXHJcblx0Z2V0UGFuZTogZnVuY3Rpb24gKHBhbmUpIHtcclxuXHRcdHJldHVybiB0eXBlb2YgcGFuZSA9PT0gJ3N0cmluZycgPyB0aGlzLl9wYW5lc1twYW5lXSA6IHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lcygpOiBPYmplY3RcclxuXHQvLyBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCBbcGFuZXNdKCNtYXAtcGFuZSkgYXMga2V5cyBhbmRcclxuXHQvLyB0aGUgcGFuZXMgYXMgdmFsdWVzLlxyXG5cdGdldFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGFuZXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIG1hcC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIENvbnZlcnNpb24gTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb21TY2FsZSh0b1pvb206IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNjYWxlIGZhY3RvciB0byBiZSBhcHBsaWVkIHRvIGEgbWFwIHRyYW5zaXRpb24gZnJvbSB6b29tIGxldmVsXHJcblx0Ly8gYGZyb21ab29tYCB0byBgdG9ab29tYC4gVXNlZCBpbnRlcm5hbGx5IHRvIGhlbHAgd2l0aCB6b29tIGFuaW1hdGlvbnMuXHJcblx0Z2V0Wm9vbVNjYWxlOiBmdW5jdGlvbiAodG9ab29tLCBmcm9tWm9vbSkge1xyXG5cdFx0Ly8gVE9ETyByZXBsYWNlIHdpdGggdW5pdmVyc2FsIGltcGxlbWVudGF0aW9uIGFmdGVyIHJlZmFjdG9yaW5nIHByb2plY3Rpb25zXHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHJldHVybiBjcnMuc2NhbGUodG9ab29tKSAvIGNycy5zY2FsZShmcm9tWm9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTY2FsZVpvb20oc2NhbGU6IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHpvb20gbGV2ZWwgdGhhdCB0aGUgbWFwIHdvdWxkIGVuZCB1cCBhdCwgaWYgaXQgaXMgYXQgYGZyb21ab29tYFxyXG5cdC8vIGxldmVsIGFuZCBldmVyeXRoaW5nIGlzIHNjYWxlZCBieSBhIGZhY3RvciBvZiBgc2NhbGVgLiBJbnZlcnNlIG9mXHJcblx0Ly8gW2BnZXRab29tU2NhbGVgXSgjbWFwLWdldFpvb21TY2FsZSkuXHJcblx0Z2V0U2NhbGVab29tOiBmdW5jdGlvbiAoc2NhbGUsIGZyb21ab29tKSB7XHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHZhciB6b29tID0gY3JzLnpvb20oc2NhbGUgKiBjcnMuc2NhbGUoZnJvbVpvb20pKTtcclxuXHRcdHJldHVybiBpc05hTih6b29tKSA/IEluZmluaXR5IDogem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSBgTGF0TG5nYCBhY2NvcmRpbmcgdG8gdGhlIHByb2plY3Rpb25cclxuXHQvLyBvZiB0aGUgbWFwJ3MgQ1JTLCB0aGVuIHNjYWxlcyBpdCBhY2NvcmRpbmcgdG8gYHpvb21gIGFuZCB0aGUgQ1JTJ3NcclxuXHQvLyBgVHJhbnNmb3JtYXRpb25gLiBUaGUgcmVzdWx0IGlzIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgQ1JTIG9yaWdpbi5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KHRvTGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gSW52ZXJzZSBvZiBbYHByb2plY3RgXSgjbWFwLXByb2plY3QpLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKHRvUG9pbnQocG9pbnQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRsYXllclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QocHJvamVjdGVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3QodG9MYXRMbmcobGF0bG5nKSkuX3JvdW5kKCk7XHJcblx0XHRyZXR1cm4gcHJvamVjdGVkUG9pbnQuX3N1YnRyYWN0KHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGBsYXRgIGFuZCBgbG5nYCBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBtYXAncyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZVxyXG5cdC8vIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nKHRvTGF0TG5nKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZ0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmcgdGhhdFxyXG5cdC8vIGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXHJcblx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIHRoZSBjZW50ZXIgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcywgYW5kIHRoZSBtYWpvcml0eSBvZiB0aGUgYm91bmRzXHJcblx0Ly8gb3ZlcmxhcHMgdGhlIENSUydzIGJvdW5kcy5cclxuXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nQm91bmRzKHRvTGF0TG5nQm91bmRzKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvXHJcblx0Ly8gdGhlIG1hcCdzIENSUy4gQnkgZGVmYXVsdCB0aGlzIG1lYXN1cmVzIGRpc3RhbmNlIGluIG1ldGVycy5cclxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmRpc3RhbmNlKHRvTGF0TG5nKGxhdGxuZzEpLCB0b0xhdExuZyhsYXRsbmcyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9Db250YWluZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnNcclxuXHQvLyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRvUG9pbnQocG9pbnQpKTtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KHRvTGF0TG5nKGxhdGxuZykpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZVxyXG5cdC8vIG1hcCBjb250YWluZXIgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gZ2V0TW91c2VQb3NpdGlvbihlLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF5ZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXRMbmcoZXY6IE1vdXNlRXZlbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIHdoZXJlIHRoZVxyXG5cdC8vIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF0TG5nOiBmdW5jdGlvbiAoZSkgeyAvLyAoTW91c2VFdmVudClcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBtYXAgaW5pdGlhbGl6YXRpb24gbWV0aG9kc1xyXG5cclxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZ2V0KGlkKTtcclxuXHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG5cdFx0fSBlbHNlIGlmIChjb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0b24oY29udGFpbmVyLCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIHRoaXMpO1xyXG5cdFx0dGhpcy5fY29udGFpbmVySWQgPSBzdGFtcChjb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG5cclxuXHRcdHRoaXMuX2ZhZGVBbmltYXRlZCA9IHRoaXMub3B0aW9ucy5mYWRlQW5pbWF0aW9uICYmIGFueTNkO1xyXG5cclxuXHRcdGFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udGFpbmVyJyArXHJcblx0XHRcdCh0b3VjaCA/ICcgbGVhZmxldC10b3VjaCcgOiAnJykgK1xyXG5cdFx0XHQocmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG5cdFx0XHQoaWVsdDkgPyAnIGxlYWZsZXQtb2xkaWUnIDogJycpICtcclxuXHRcdFx0KHNhZmFyaSA/ICcgbGVhZmxldC1zYWZhcmknIDogJycpICtcclxuXHRcdFx0KHRoaXMuX2ZhZGVBbmltYXRlZCA/ICcgbGVhZmxldC1mYWRlLWFuaW0nIDogJycpKTtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBnZXRTdHlsZShjb250YWluZXIsICdwb3NpdGlvbicpO1xyXG5cclxuXHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xyXG5cdFx0XHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRQYW5lcygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0Q29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9pbml0Q29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XHJcblx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzID0ge307XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vXHJcblx0XHQvLyBQYW5lcyBhcmUgRE9NIGVsZW1lbnRzIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXJpbmcgb2YgbGF5ZXJzIG9uIHRoZSBtYXAuIFlvdVxyXG5cdFx0Ly8gY2FuIGFjY2VzcyBwYW5lcyB3aXRoIFtgbWFwLmdldFBhbmVgXSgjbWFwLWdldHBhbmUpIG9yXHJcblx0XHQvLyBbYG1hcC5nZXRQYW5lc2BdKCNtYXAtZ2V0cGFuZXMpIG1ldGhvZHMuIE5ldyBwYW5lcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxyXG5cdFx0Ly8gW2BtYXAuY3JlYXRlUGFuZWBdKCNtYXAtY3JlYXRlcGFuZSkgbWV0aG9kLlxyXG5cdFx0Ly9cclxuXHRcdC8vIEV2ZXJ5IG1hcCBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBhbmVzIHRoYXQgZGlmZmVyIG9ubHkgaW4gekluZGV4LlxyXG5cdFx0Ly9cclxuXHRcdC8vIEBwYW5lIG1hcFBhbmU6IEhUTUxFbGVtZW50ID0gJ2F1dG8nXHJcblx0XHQvLyBQYW5lIHRoYXQgY29udGFpbnMgYWxsIG90aGVyIG1hcCBwYW5lc1xyXG5cclxuXHRcdHRoaXMuX21hcFBhbmUgPSB0aGlzLmNyZWF0ZVBhbmUoJ21hcFBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0c2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHQvLyBAcGFuZSB0aWxlUGFuZTogSFRNTEVsZW1lbnQgPSAyMDBcclxuXHRcdC8vIFBhbmUgZm9yIGBHcmlkTGF5ZXJgcyBhbmQgYFRpbGVMYXllcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3RpbGVQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBvdmVybGF5UGFuZTogSFRNTEVsZW1lbnQgPSA0MDBcclxuXHRcdC8vIFBhbmUgZm9yIHZlY3RvcnMgKGBQYXRoYHMsIGxpa2UgYFBvbHlsaW5lYHMgYW5kIGBQb2x5Z29uYHMpLCBgSW1hZ2VPdmVybGF5YHMgYW5kIGBWaWRlb092ZXJsYXlgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdzaGFkb3dQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxyXG5cdFx0Ly8gUGFuZSBmb3Igb3ZlcmxheSBzaGFkb3dzIChlLmcuIGBNYXJrZXJgIHNoYWRvd3MpXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ292ZXJsYXlQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBtYXJrZXJQYW5lOiBIVE1MRWxlbWVudCA9IDYwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEljb25gcyBvZiBgTWFya2VyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnbWFya2VyUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgdG9vbHRpcFBhbmU6IEhUTUxFbGVtZW50ID0gNjUwXHJcblx0XHQvLyBQYW5lIGZvciBgVG9vbHRpcGBzLlxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCd0b29sdGlwUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgcG9wdXBQYW5lOiBIVE1MRWxlbWVudCA9IDcwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYFBvcHVwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3BvcHVwUGFuZScpO1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0YWRkQ2xhc3MocGFuZXMubWFya2VyUGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcblx0XHRcdGFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0c2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHR2YXIgbG9hZGluZyA9ICF0aGlzLl9sb2FkZWQ7XHJcblx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xyXG5cdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdwcmVyZXNldCcpO1xyXG5cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblx0XHR0aGlzXHJcblx0XHRcdC5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkLCBmYWxzZSlcclxuXHRcdFx0Ll9tb3ZlKGNlbnRlciwgem9vbSlcclxuXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgdmlld3Jlc2V0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIG5lZWRzIHRvIHJlZHJhdyBpdHMgY29udGVudCAodGhpcyB1c3VhbGx5IGhhcHBlbnNcclxuXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuXHRcdC8vIGZvciB0aGUgZmlyc3QgdGltZSkuXHJcblx0XHRpZiAobG9hZGluZykge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gaXMgYWJvdXQgdG8gY2hhbmdlIChlLmcuIGJlZm9yZSB6b29tIGFuaW1hdGlvbikuXHJcblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlldyBvZiB0aGUgbWFwIHN0YXJ0cyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21zdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFub01vdmVTdGFydCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X21vdmU6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGRhdGEpIHtcclxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0em9vbSA9IHRoaXMuX3pvb207XHJcblx0XHR9XHJcblx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cclxuXHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0dGhpcy5fbGFzdENlbnRlciA9IGNlbnRlcjtcclxuXHRcdHRoaXMuX3BpeGVsT3JpZ2luID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgem9vbTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBjaGFuZ2UgaW4gem9vbSBsZXZlbCwgaW5jbHVkaW5nIHpvb21cclxuXHRcdC8vIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCB8fCAoZGF0YSAmJiBkYXRhLnBpbmNoKSkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tJywgZGF0YSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgbW92ZW1lbnQgb2YgdGhlIG1hcCwgaW5jbHVkaW5nIHBhbiBhbmRcclxuXHRcdC8vIGZseSBhbmltYXRpb25zLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIGRhdGEpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlRW5kOiBmdW5jdGlvbiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGhhcyBjaGFuZ2VkLCBhZnRlciBhbnkgYW5pbWF0aW9ucy5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21lbmQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGNlbnRlciBvZiB0aGUgbWFwIHN0b3BzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RvcHBlZFxyXG5cdFx0Ly8gZHJhZ2dpbmcgdGhlIG1hcCkuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X3N0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mbHlUb0ZyYW1lKTtcclxuXHRcdGlmICh0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHRzZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KSk7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNYXhab29tKCkgLSB0aGlzLmdldE1pblpvb20oKTtcclxuXHR9LFxyXG5cclxuXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuZm9yY2luZ0JvdW5kcykge1xyXG5cdFx0XHR0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTZXQgbWFwIGNlbnRlciBhbmQgem9vbSBmaXJzdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBET00gZXZlbnQgaGFuZGxpbmdcclxuXHJcblx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gZXZlbnRzXHJcblx0X2luaXRFdmVudHM6IGZ1bmN0aW9uIChyZW1vdmUkJDEpIHtcclxuXHRcdHRoaXMuX3RhcmdldHMgPSB7fTtcclxuXHRcdHRoaXMuX3RhcmdldHNbc3RhbXAodGhpcy5fY29udGFpbmVyKV0gPSB0aGlzO1xyXG5cclxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSQkMSA/IG9mZiA6IG9uO1xyXG5cclxuXHRcdC8vIEBldmVudCBjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKG9yIHRhcHMpIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgZGJsY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgZG91YmxlLWNsaWNrcyAob3IgZG91YmxlLXRhcHMpIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2Vkb3duOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2V1cDogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdmVyOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBlbnRlcnMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW91dDogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2Vtb3ZlOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGlsZSB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGNvbnRleHRtZW51OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgcmlnaHQgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAsIHByZXZlbnRzXHJcblx0XHQvLyBkZWZhdWx0IGJyb3dzZXIgY29udGV4dCBtZW51IGZyb20gc2hvd2luZyBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzIG9uXHJcblx0XHQvLyB0aGlzIGV2ZW50LiBBbHNvIGZpcmVkIG9uIG1vYmlsZSB3aGVuIHRoZSB1c2VyIGhvbGRzIGEgc2luZ2xlIHRvdWNoXHJcblx0XHQvLyBmb3IgYSBzZWNvbmQgKGFsc28gY2FsbGVkIGxvbmcgcHJlc3MpLlxyXG5cdFx0Ly8gQGV2ZW50IGtleXByZXNzOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgdGhhdCBwcm9kdWNlcyBhIGNoYXJhY3RlciB2YWx1ZSB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcblx0XHQvLyBAZXZlbnQga2V5ZG93bjogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC4gVW5saWtlIHRoZSBga2V5cHJlc3NgIGV2ZW50LFxyXG5cdFx0Ly8gdGhlIGBrZXlkb3duYCBldmVudCBpcyBmaXJlZCBmb3Iga2V5cyB0aGF0IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUgYW5kIGZvciBrZXlzXHJcblx0XHQvLyB0aGF0IGRvIG5vdCBwcm9kdWNlIGEgY2hhcmFjdGVyIHZhbHVlLlxyXG5cdFx0Ly8gQGV2ZW50IGtleXVwOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuXHRcdG9uT2ZmKHRoaXMuX2NvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwICcgK1xyXG5cdFx0XHQnbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudSBrZXlwcmVzcyBrZXlkb3duIGtleXVwJywgdGhpcy5faGFuZGxlRE9NRXZlbnQsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUpIHtcclxuXHRcdFx0b25PZmYod2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChhbnkzZCAmJiB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHQocmVtb3ZlJCQxID8gdGhpcy5vZmYgOiB0aGlzLm9uKS5jYWxsKHRoaXMsICdtb3ZlZW5kJywgdGhpcy5fb25Nb3ZlRW5kKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25SZXNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuXHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKFxyXG5cdFx0ICAgICAgICBmdW5jdGlvbiAoKSB7IHRoaXMuaW52YWxpZGF0ZVNpemUoe2RlYm91bmNlTW92ZWVuZDogdHJ1ZX0pOyB9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25TY3JvbGw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3AgID0gMDtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxMZWZ0ID0gMDtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0aWYgKE1hdGgubWF4KE1hdGguYWJzKHBvcy54KSwgTWF0aC5hYnMocG9zLnkpKSA+PSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHQvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjAzODczIGJ1dCBXZWJraXQgYWxzbyBoYXZlXHJcblx0XHRcdC8vIGEgcGl4ZWwgb2Zmc2V0IG9uIHZlcnkgaGlnaCB2YWx1ZXMsIHNlZTogaHR0cDovL2pzZmlkZGxlLm5ldC9kZzZyNWhoYi9cclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZmluZEV2ZW50VGFyZ2V0czogZnVuY3Rpb24gKGUsIHR5cGUpIHtcclxuXHRcdHZhciB0YXJnZXRzID0gW10sXHJcblx0XHQgICAgdGFyZ2V0LFxyXG5cdFx0ICAgIGlzSG92ZXIgPSB0eXBlID09PSAnbW91c2VvdXQnIHx8IHR5cGUgPT09ICdtb3VzZW92ZXInLFxyXG5cdFx0ICAgIHNyYyA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcclxuXHRcdCAgICBkcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuXHRcdHdoaWxlIChzcmMpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1tzdGFtcChzcmMpXTtcclxuXHRcdFx0aWYgKHRhcmdldCAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAncHJlY2xpY2snKSAmJiAhZS5fc2ltdWxhdGVkICYmIHRoaXMuX2RyYWdnYWJsZU1vdmVkKHRhcmdldCkpIHtcclxuXHRcdFx0XHQvLyBQcmV2ZW50IGZpcmluZyBjbGljayBhZnRlciB5b3UganVzdCBkcmFnZ2VkIGFuIG9iamVjdC5cclxuXHRcdFx0XHRkcmFnZ2luZyA9IHRydWU7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRhcmdldCAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyICYmICFpc0V4dGVybmFsVGFyZ2V0KHNyYywgZSkpIHsgYnJlYWs7IH1cclxuXHRcdFx0XHR0YXJnZXRzLnB1c2godGFyZ2V0KTtcclxuXHRcdFx0XHRpZiAoaXNIb3ZlcikgeyBicmVhazsgfVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChzcmMgPT09IHRoaXMuX2NvbnRhaW5lcikgeyBicmVhazsgfVxyXG5cdFx0XHRzcmMgPSBzcmMucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGggJiYgIWRyYWdnaW5nICYmICFpc0hvdmVyICYmIGlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkge1xyXG5cdFx0XHR0YXJnZXRzID0gW3RoaXNdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRhcmdldHM7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZURPTUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQgfHwgc2tpcHBlZChlKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgdHlwZSA9IGUudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ21vdXNlZG93bicgfHwgdHlwZSA9PT0gJ2tleXByZXNzJyB8fCB0eXBlID09PSAna2V5dXAnIHx8IHR5cGUgPT09ICdrZXlkb3duJykge1xyXG5cdFx0XHQvLyBwcmV2ZW50cyBvdXRsaW5lIHdoZW4gY2xpY2tpbmcgb24ga2V5Ym9hcmQtZm9jdXNhYmxlIGVsZW1lbnRcclxuXHRcdFx0cHJldmVudE91dGxpbmUoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9maXJlRE9NRXZlbnQoZSwgdHlwZSk7XHJcblx0fSxcclxuXHJcblx0X21vdXNlRXZlbnRzOiBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdjb250ZXh0bWVudSddLFxyXG5cclxuXHRfZmlyZURPTUV2ZW50OiBmdW5jdGlvbiAoZSwgdHlwZSwgdGFyZ2V0cykge1xyXG5cclxuXHRcdGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcclxuXHRcdFx0Ly8gRmlyZSBhIHN5bnRoZXRpYyAncHJlY2xpY2snIGV2ZW50IHdoaWNoIHByb3BhZ2F0ZXMgdXAgKG1haW5seSBmb3IgY2xvc2luZyBwb3B1cHMpLlxyXG5cdFx0XHQvLyBAZXZlbnQgcHJlY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgYmVmb3JlIG1vdXNlIGNsaWNrIG9uIHRoZSBtYXAgKHNvbWV0aW1lcyB1c2VmdWwgd2hlbiB5b3VcclxuXHRcdFx0Ly8gd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9uIGNsaWNrIGJlZm9yZSBhbnkgZXhpc3RpbmcgY2xpY2tcclxuXHRcdFx0Ly8gaGFuZGxlcnMgc3RhcnQgcnVubmluZykuXHJcblx0XHRcdHZhciBzeW50aCA9IGV4dGVuZCh7fSwgZSk7XHJcblx0XHRcdHN5bnRoLnR5cGUgPSAncHJlY2xpY2snO1xyXG5cdFx0XHR0aGlzLl9maXJlRE9NRXZlbnQoc3ludGgsIHN5bnRoLnR5cGUsIHRhcmdldHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlLl9zdG9wcGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEZpbmQgdGhlIGxheWVyIHRoZSBldmVudCBpcyBwcm9wYWdhdGluZyBmcm9tIGFuZCBpdHMgcGFyZW50cy5cclxuXHRcdHRhcmdldHMgPSAodGFyZ2V0cyB8fCBbXSkuY29uY2F0KHRoaXMuX2ZpbmRFdmVudFRhcmdldHMoZSwgdHlwZSkpO1xyXG5cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGgpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbMF07XHJcblx0XHRpZiAodHlwZSA9PT0gJ2NvbnRleHRtZW51JyAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0b3JpZ2luYWxFdmVudDogZVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoZS50eXBlICE9PSAna2V5cHJlc3MnICYmIGUudHlwZSAhPT0gJ2tleWRvd24nICYmIGUudHlwZSAhPT0gJ2tleXVwJykge1xyXG5cdFx0XHR2YXIgaXNNYXJrZXIgPSB0YXJnZXQuZ2V0TGF0TG5nICYmICghdGFyZ2V0Ll9yYWRpdXMgfHwgdGFyZ2V0Ll9yYWRpdXMgPD0gMTApO1xyXG5cdFx0XHRkYXRhLmNvbnRhaW5lclBvaW50ID0gaXNNYXJrZXIgP1xyXG5cdFx0XHRcdHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludCh0YXJnZXQuZ2V0TGF0TG5nKCkpIDogdGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcclxuXHRcdFx0ZGF0YS5sYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChkYXRhLmNvbnRhaW5lclBvaW50KTtcclxuXHRcdFx0ZGF0YS5sYXRsbmcgPSBpc01hcmtlciA/IHRhcmdldC5nZXRMYXRMbmcoKSA6IHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGRhdGEubGF5ZXJQb2ludCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRhcmdldHNbaV0uZmlyZSh0eXBlLCBkYXRhLCB0cnVlKTtcclxuXHRcdFx0aWYgKGRhdGEub3JpZ2luYWxFdmVudC5fc3RvcHBlZCB8fFxyXG5cdFx0XHRcdCh0YXJnZXRzW2ldLm9wdGlvbnMuYnViYmxpbmdNb3VzZUV2ZW50cyA9PT0gZmFsc2UgJiYgaW5kZXhPZih0aGlzLl9tb3VzZUV2ZW50cywgdHlwZSkgIT09IC0xKSkgeyByZXR1cm47IH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZHJhZ2dhYmxlTW92ZWQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdG9iaiA9IG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcuZW5hYmxlZCgpID8gb2JqIDogdGhpcztcclxuXHRcdHJldHVybiAob2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5tb3ZlZCgpKSB8fCAodGhpcy5ib3hab29tICYmIHRoaXMuYm94Wm9vbS5tb3ZlZCgpKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2hhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZXJzW2ldLmRpc2FibGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2Qgd2hlblJlYWR5KGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBSdW5zIHRoZSBnaXZlbiBmdW5jdGlvbiBgZm5gIHdoZW4gdGhlIG1hcCBnZXRzIGluaXRpYWxpemVkIHdpdGhcclxuXHQvLyBhIHZpZXcgKGNlbnRlciBhbmQgem9vbSkgYW5kIGF0IGxlYXN0IG9uZSBsYXllciwgb3IgaW1tZWRpYXRlbHlcclxuXHQvLyBpZiBpdCdzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIG9wdGlvbmFsbHkgcGFzc2luZyBhIGZ1bmN0aW9uIGNvbnRleHQuXHJcblx0d2hlblJlYWR5OiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0IHx8IHRoaXMsIHt0YXJnZXQ6IHRoaXN9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub24oJ2xvYWQnLCBjYWxsYmFjaywgY29udGV4dCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHRfZ2V0TWFwUGFuZVBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGdldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUpIHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRyZXR1cm4gcG9zICYmICFwb3MuZXF1YWxzKFswLCAwXSk7XHJcblx0fSxcclxuXHJcblx0X2dldFRvcExlZnRQb2ludDogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHBpeGVsT3JpZ2luID0gY2VudGVyICYmIHpvb20gIT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkgOlxyXG5cdFx0XHR0aGlzLmdldFBpeGVsT3JpZ2luKCk7XHJcblx0XHRyZXR1cm4gcGl4ZWxPcmlnaW4uc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TmV3UGl4ZWxPcmlnaW46IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKS5fc3VidHJhY3Qodmlld0hhbGYpLl9hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBjZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QobGF0bG5nLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRvQm91bmRzKFtcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpXHJcblx0XHRdKTtcclxuXHR9LFxyXG5cclxuXHQvLyBsYXllciBwb2ludCBvZiB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRfZ2V0Q2VudGVyTGF5ZXJQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBvZmZzZXQgb2YgdGhlIHNwZWNpZmllZCBwbGFjZSB0byB0aGUgY3VycmVudCBjZW50ZXIgaW4gcGl4ZWxzXHJcblx0X2dldENlbnRlck9mZnNldDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZykuc3VidHJhY3QodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3QgY2VudGVyIGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0Q2VudGVyOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBib3VuZHMpIHtcclxuXHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gY2VudGVyOyB9XHJcblxyXG5cdFx0dmFyIGNlbnRlclBvaW50ID0gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICB2aWV3Qm91bmRzID0gbmV3IEJvdW5kcyhjZW50ZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZiksIGNlbnRlclBvaW50LmFkZCh2aWV3SGFsZikpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xyXG5cclxuXHRcdC8vIElmIG9mZnNldCBpcyBsZXNzIHRoYW4gYSBwaXhlbCwgaWdub3JlLlxyXG5cdFx0Ly8gVGhpcyBwcmV2ZW50cyB1bnN0YWJsZSBwcm9qZWN0aW9ucyBmcm9tIGdldHRpbmcgaW50b1xyXG5cdFx0Ly8gYW4gaW5maW5pdGUgbG9vcCBvZiB0aW55IG9mZnNldHMuXHJcblx0XHRpZiAob2Zmc2V0LnJvdW5kKCkuZXF1YWxzKFswLCAwXSkpIHtcclxuXHRcdFx0cmV0dXJuIGNlbnRlcjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QoY2VudGVyUG9pbnQuYWRkKG9mZnNldCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQsIGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIG9mZnNldDsgfVxyXG5cclxuXHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIG5ld0JvdW5kcyA9IG5ldyBCb3VuZHModmlld0JvdW5kcy5taW4uYWRkKG9mZnNldCksIHZpZXdCb3VuZHMubWF4LmFkZChvZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0LmFkZCh0aGlzLl9nZXRCb3VuZHNPZmZzZXQobmV3Qm91bmRzLCBib3VuZHMpKTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm5zIG9mZnNldCBuZWVkZWQgZm9yIHB4Qm91bmRzIHRvIGdldCBpbnNpZGUgbWF4Qm91bmRzIGF0IGEgc3BlY2lmaWVkIHpvb21cclxuXHRfZ2V0Qm91bmRzT2Zmc2V0OiBmdW5jdGlvbiAocHhCb3VuZHMsIG1heEJvdW5kcywgem9vbSkge1xyXG5cdFx0dmFyIHByb2plY3RlZE1heEJvdW5kcyA9IHRvQm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSlcclxuXHRcdCAgICApLFxyXG5cdFx0ICAgIG1pbk9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5taW4uc3VidHJhY3QocHhCb3VuZHMubWluKSxcclxuXHRcdCAgICBtYXhPZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWF4LnN1YnRyYWN0KHB4Qm91bmRzLm1heCksXHJcblxyXG5cdFx0ICAgIGR4ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueCwgLW1heE9mZnNldC54KSxcclxuXHRcdCAgICBkeSA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LnksIC1tYXhPZmZzZXQueSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChkeCwgZHkpO1xyXG5cdH0sXHJcblxyXG5cdF9yZWJvdW5kOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuXHRcdHJldHVybiBsZWZ0ICsgcmlnaHQgPiAwID9cclxuXHRcdFx0TWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6XHJcblx0XHRcdE1hdGgubWF4KDAsIE1hdGguY2VpbChsZWZ0KSkgLSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHJpZ2h0KSk7XHJcblx0fSxcclxuXHJcblx0X2xpbWl0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBzbmFwID0gYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxO1xyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH0sXHJcblxyXG5cdF9vblBhblRyYW5zaXRpb25TdGVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHR9LFxyXG5cclxuXHRfb25QYW5UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X3RyeUFuaW1hdGVkUGFuOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7XHJcblx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xyXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl90cnVuYygpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xyXG5cdFx0aWYgKChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0ZSkgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0dGhpcy5wYW5CeShvZmZzZXQsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcHJveHkgPSB0aGlzLl9wcm94eSA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC1wcm94eSBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHRcdHRoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQocHJveHkpO1xyXG5cclxuXHRcdHRoaXMub24oJ3pvb21hbmltJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0dmFyIHByb3AgPSBUUkFOU0ZPUk0sXHJcblx0XHRcdCAgICB0cmFuc2Zvcm0gPSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXTtcclxuXHJcblx0XHRcdHNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGUuY2VudGVyLCBlLnpvb20pLCB0aGlzLmdldFpvb21TY2FsZShlLnpvb20sIDEpKTtcclxuXHJcblx0XHRcdC8vIHdvcmthcm91bmQgZm9yIGNhc2Ugd2hlbiB0cmFuc2Zvcm0gaXMgdGhlIHNhbWUgYW5kIHNvIHRyYW5zaXRpb25lbmQgZXZlbnQgaXMgbm90IGZpcmVkXHJcblx0XHRcdGlmICh0cmFuc2Zvcm0gPT09IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdICYmIHRoaXMuX2FuaW1hdGluZ1pvb20pIHtcclxuXHRcdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMub24oJ2xvYWQgbW92ZWVuZCcsIHRoaXMuX2FuaW1Nb3ZlRW5kLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveUFuaW1Qcm94eSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X2Rlc3Ryb3lBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJlbW92ZSh0aGlzLl9wcm94eSk7XHJcblx0XHR0aGlzLm9mZignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3Byb3h5O1xyXG5cdH0sXHJcblxyXG5cdF9hbmltTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGMgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIHogPSB0aGlzLmdldFpvb20oKTtcclxuXHRcdHNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGMsIHopLCB0aGlzLmdldFpvb21TY2FsZSh6LCAxKSk7XHJcblx0fSxcclxuXHJcblx0X2NhdGNoVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcclxuXHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9ub3RoaW5nVG9BbmltYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKS5sZW5ndGg7XHJcblx0fSxcclxuXHJcblx0X3RyeUFuaW1hdGVkWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiBkaXNhYmxlZCwgbm90IHN1cHBvcnRlZCBvciB6b29tIGRpZmZlcmVuY2UgaXMgdG9vIGxhcmdlXHJcblx0XHRpZiAoIXRoaXMuX3pvb21BbmltYXRlZCB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8IHRoaXMuX25vdGhpbmdUb0FuaW1hdGUoKSB8fFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHQvLyBvZmZzZXQgaXMgdGhlIHBpeGVsIGNvb3JkcyBvZiB0aGUgem9vbSBvcmlnaW4gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiB0aGUgem9vbSBvcmlnaW4gaXNuJ3Qgd2l0aGluIG9uZSBzY3JlZW4gZnJvbSB0aGUgY3VycmVudCBjZW50ZXIsIHVubGVzcyBmb3JjZWRcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0cmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKVxyXG5cdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBzdGFydEFuaW0sIG5vVXBkYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcFBhbmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHN0YXJ0QW5pbSkge1xyXG5cdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vIHJlbWVtYmVyIHdoYXQgY2VudGVyL3pvb20gdG8gc2V0IGFmdGVyIGFuaW1hdGlvblxyXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xyXG5cclxuXHRcdFx0YWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gT3RoZXIgRXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgem9vbWFuaW06IFpvb21BbmltRXZlbnRcclxuXHRcdC8vIEZpcmVkIGF0IGxlYXN0IG9uY2UgcGVyIHpvb20gYW5pbWF0aW9uLiBGb3IgY29udGludW91cyB6b29tLCBsaWtlIHBpbmNoIHpvb21pbmcsIGZpcmVkIG9uY2UgcGVyIGZyYW1lIGR1cmluZyB6b29tLlxyXG5cdFx0dGhpcy5maXJlKCd6b29tYW5pbScsIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb20sXHJcblx0XHRcdG5vVXBkYXRlOiBub1VwZGF0ZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gV29yayBhcm91bmQgd2Via2l0IG5vdCBmaXJpbmcgJ3RyYW5zaXRpb25lbmQnLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzY4OSwgMjY5M1xyXG5cdFx0c2V0VGltZW91dChiaW5kKHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQsIHRoaXMpLCAyNTApO1xyXG5cdH0sXHJcblxyXG5cdF9vblpvb21UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcFBhbmUpIHtcclxuXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tKTtcclxuXHJcblx0XHQvLyBUaGlzIGFuaW0gZnJhbWUgc2hvdWxkIHByZXZlbnQgYW4gb2JzY3VyZSBpT1Mgd2Via2l0IHRpbGUgbG9hZGluZyByYWNlIGNvbmRpdGlvbi5cclxuXHRcdHJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLl9tb3ZlRW5kKHRydWUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBzZWN0aW9uXHJcblxyXG4vLyBAZmFjdG9yeSBMLm1hcChpZDogU3RyaW5nLCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gdGhlIERPTSBJRCBvZiBhIGA8ZGl2PmAgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbi8vXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLm1hcChlbDogSFRNTEVsZW1lbnQsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiBhbiBpbnN0YW5jZSBvZiBhIGA8ZGl2PmAgSFRNTCBlbGVtZW50XHJcbi8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuZnVuY3Rpb24gY3JlYXRlTWFwKGlkLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBNYXAoaWQsIG9wdGlvbnMpO1xyXG59XG5cbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sXHJcbiAqIEBha2EgTC5Db250cm9sXHJcbiAqIEBpbmhlcml0cyBDbGFzc1xyXG4gKlxyXG4gKiBMLkNvbnRyb2wgaXMgYSBiYXNlIGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgbWFwIGNvbnRyb2xzLiBIYW5kbGVzIHBvc2l0aW9uaW5nLlxyXG4gKiBBbGwgb3RoZXIgY29udHJvbHMgZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICovXHJcblxyXG52YXIgQ29udHJvbCA9IENsYXNzLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gcG9zaXRpb246IFN0cmluZyA9ICd0b3ByaWdodCdcclxuXHRcdC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCAob25lIG9mIHRoZSBtYXAgY29ybmVycykuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYCd0b3BsZWZ0J2AsXHJcblx0XHQvLyBgJ3RvcHJpZ2h0J2AsIGAnYm90dG9tbGVmdCdgIG9yIGAnYm90dG9tcmlnaHQnYFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIEwuQ29udHJvbCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBnZXRQb3NpdGlvbjogc3RyaW5nXHJcblx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcblx0ICovXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb247XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQb3NpdGlvbihwb3NpdGlvbjogc3RyaW5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAucmVtb3ZlQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5hZGRDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUxFbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGNvbnRyb2wuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkVG8obWFwOiBNYXApOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgY29udHJvbCB0byB0aGUgZ2l2ZW4gbWFwLlxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLnJlbW92ZSgpO1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCksXHJcblx0XHQgICAgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpLFxyXG5cdFx0ICAgIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcclxuXHJcblx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wnKTtcclxuXHJcblx0XHRpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xyXG5cdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29ybmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9uKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBjb250cm9sIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub25SZW1vdmUpIHtcclxuXHRcdFx0dGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5vZmYoJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3JlZm9jdXNPbk1hcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIGlmIG1hcCBleGlzdHMgYW5kIGV2ZW50IGlzIG5vdCBhIGtleWJvYXJkIGV2ZW50XHJcblx0XHRpZiAodGhpcy5fbWFwICYmIGUgJiYgZS5zY3JlZW5YID4gMCAmJiBlLnNjcmVlblkgPiAwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5mb2N1cygpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG52YXIgY29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBDb250cm9sKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICogQHVuaW5oZXJpdGFibGVcclxuICpcclxuICogRXZlcnkgY29udHJvbCBzaG91bGQgZXh0ZW5kIGZyb20gYEwuQ29udHJvbGAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cclxuICpcclxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50XHJcbiAqIFNob3VsZCByZXR1cm4gdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgYW5kIGFkZCBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgY29udHJvbC5hZGRUbyhtYXApYF0oI2NvbnRyb2wtYWRkVG8pLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKVxyXG4gKiBPcHRpb25hbCBtZXRob2QuIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNjb250cm9sLW9uYWRkKS4gQ2FsbGVkIG9uIFtgY29udHJvbC5yZW1vdmUoKWBdKCNjb250cm9sLXJlbW92ZSkuXHJcbiAqL1xyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gKi9cclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2QgYWRkQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcFxyXG5cdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLmFkZFRvKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXBcclxuXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5yZW1vdmUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0Q29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9LFxyXG5cdFx0ICAgIGwgPSAnbGVhZmxldC0nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRyb2xDb250YWluZXIgPVxyXG5cdFx0ICAgICAgICAgICAgY3JlYXRlJDEoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcblx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ3JpZ2h0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fY29udHJvbENvcm5lcnMpIHtcclxuXHRcdFx0cmVtb3ZlKHRoaXMuX2NvbnRyb2xDb3JuZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJlbW92ZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9jb250cm9sQ29ybmVycztcclxuXHRcdGRlbGV0ZSB0aGlzLl9jb250cm9sQ29udGFpbmVyO1xyXG5cdH1cclxufSk7XG5cbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkxheWVyc1xyXG4gKiBAYWthIEwuQ29udHJvbC5MYXllcnNcclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogVGhlIGxheWVycyBjb250cm9sIGdpdmVzIHVzZXJzIHRoZSBhYmlsaXR5IHRvIHN3aXRjaCBiZXR3ZWVuIGRpZmZlcmVudCBiYXNlIGxheWVycyBhbmQgc3dpdGNoIG92ZXJsYXlzIG9uL29mZiAoY2hlY2sgb3V0IHRoZSBbZGV0YWlsZWQgZXhhbXBsZV0oaHR0cDovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvbGF5ZXJzLWNvbnRyb2wvKSkuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgYmFzZUxheWVycyA9IHtcclxuICogXHRcIk1hcGJveFwiOiBtYXBib3gsXHJcbiAqIFx0XCJPcGVuU3RyZWV0TWFwXCI6IG9zbVxyXG4gKiB9O1xyXG4gKlxyXG4gKiB2YXIgb3ZlcmxheXMgPSB7XHJcbiAqIFx0XCJNYXJrZXJcIjogbWFya2VyLFxyXG4gKiBcdFwiUm9hZHNcIjogcm9hZHNMYXllclxyXG4gKiB9O1xyXG4gKlxyXG4gKiBMLmNvbnRyb2wubGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGBiYXNlTGF5ZXJzYCBhbmQgYG92ZXJsYXlzYCBwYXJhbWV0ZXJzIGFyZSBvYmplY3QgbGl0ZXJhbHMgd2l0aCBsYXllciBuYW1lcyBhcyBrZXlzIGFuZCBgTGF5ZXJgIG9iamVjdHMgYXMgdmFsdWVzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB7XHJcbiAqICAgICBcIjxzb21lTmFtZTE+XCI6IGxheWVyMSxcclxuICogICAgIFwiPHNvbWVOYW1lMj5cIjogbGF5ZXIyXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBsYXllciBuYW1lcyBjYW4gY29udGFpbiBIVE1MLCB3aGljaCBhbGxvd3MgeW91IHRvIGFkZCBhZGRpdGlvbmFsIHN0eWxpbmcgdG8gdGhlIGl0ZW1zOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB7XCI8aW1nIHNyYz0nbXktbGF5ZXItaWNvbicgLz4gPHNwYW4gY2xhc3M9J215LWxheWVyLWl0ZW0nPk15IExheWVyPC9zcGFuPlwiOiBteUxheWVyfVxyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgTGF5ZXJzID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkxheWVycyBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjb2xsYXBzZWQ6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYmUgY29sbGFwc2VkIGludG8gYW4gaWNvbiBhbmQgZXhwYW5kZWQgb24gbW91c2UgaG92ZXIgb3IgdG91Y2guXHJcblx0XHRjb2xsYXBzZWQ6IHRydWUsXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9aSW5kZXg6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYXNzaWduIHpJbmRleGVzIGluIGluY3JlYXNpbmcgb3JkZXIgdG8gYWxsIG9mIGl0cyBsYXllcnMgc28gdGhhdCB0aGUgb3JkZXIgaXMgcHJlc2VydmVkIHdoZW4gc3dpdGNoaW5nIHRoZW0gb24vb2ZmLlxyXG5cdFx0YXV0b1pJbmRleDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGhpZGVTaW5nbGVCYXNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGJhc2UgbGF5ZXJzIGluIHRoZSBjb250cm9sIHdpbGwgYmUgaGlkZGVuIHdoZW4gdGhlcmUgaXMgb25seSBvbmUuXHJcblx0XHRoaWRlU2luZ2xlQmFzZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzb3J0TGF5ZXJzOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgbGF5ZXJzLiBXaGVuIGBmYWxzZWAsIGxheWVycyB3aWxsIGtlZXAgdGhlIG9yZGVyXHJcblx0XHQvLyBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQgdG8gdGhlIGNvbnRyb2wuXHJcblx0XHRzb3J0TGF5ZXJzOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRGdW5jdGlvbjogRnVuY3Rpb24gPSAqXHJcblx0XHQvLyBBIFtjb21wYXJlIGZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0KVxyXG5cdFx0Ly8gdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHNvcnRpbmcgdGhlIGxheWVycywgd2hlbiBgc29ydExheWVyc2AgaXMgYHRydWVgLlxyXG5cdFx0Ly8gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGJvdGggdGhlIGBMLkxheWVyYCBpbnN0YW5jZXMgYW5kIHRoZWlyIG5hbWVzLCBhcyBpblxyXG5cdFx0Ly8gYHNvcnRGdW5jdGlvbihsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKWAuXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBpdCBzb3J0cyBsYXllcnMgYWxwaGFiZXRpY2FsbHkgYnkgdGhlaXIgbmFtZS5cclxuXHRcdHNvcnRGdW5jdGlvbjogZnVuY3Rpb24gKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpIHtcclxuXHRcdFx0cmV0dXJuIG5hbWVBIDwgbmFtZUIgPyAtMSA6IChuYW1lQiA8IG5hbWVBID8gMSA6IDApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMgPSBbXTtcclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fbGFzdFpJbmRleCA9IDA7XHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBiYXNlTGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKGJhc2VMYXllcnNbaV0sIGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSBpbiBvdmVybGF5cykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihvdmVybGF5c1tpXSwgaSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdENvbnRyb2wucHJvdG90eXBlLmFkZFRvLmNhbGwodGhpcywgbWFwKTtcclxuXHRcdC8vIFRyaWdnZXIgZXhwYW5kIGFmdGVyIExheWVycyBDb250cm9sIGhhcyBiZWVuIGluc2VydGVkIGludG8gRE9NIHNvIHRoYXQgaXMgbm93IGhhcyBhbiBhY3R1YWwgaGVpZ2h0LlxyXG5cdFx0cmV0dXJuIHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRCYXNlTGF5ZXIobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhIGJhc2UgbGF5ZXIgKHJhZGlvIGJ1dHRvbiBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRCYXNlTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkT3ZlcmxheShsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIG92ZXJsYXkgKGNoZWNrYm94IGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZE92ZXJsYXk6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUsIHRydWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZSB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgY29udHJvbC5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRsYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoc3RhbXAobGF5ZXIpKTtcclxuXHRcdGlmIChvYmopIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNwbGljZSh0aGlzLl9sYXllcnMuaW5kZXhPZihvYmopLCAxKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGV4cGFuZCgpOiB0aGlzXHJcblx0Ly8gRXhwYW5kIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBjb2xsYXBzZWQuXHJcblx0ZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHR0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodCA9IG51bGw7XHJcblx0XHR2YXIgYWNjZXB0YWJsZUhlaWdodCA9IHRoaXMuX21hcC5nZXRTaXplKCkueSAtICh0aGlzLl9jb250YWluZXIub2Zmc2V0VG9wICsgNTApO1xyXG5cdFx0aWYgKGFjY2VwdGFibGVIZWlnaHQgPCB0aGlzLl9zZWN0aW9uLmNsaWVudEhlaWdodCkge1xyXG5cdFx0XHRhZGRDbGFzcyh0aGlzLl9zZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdFx0dGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQgPSBhY2NlcHRhYmxlSGVpZ2h0ICsgJ3B4JztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb2xsYXBzZSgpOiB0aGlzXHJcblx0Ly8gQ29sbGFwc2UgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGV4cGFuZGVkLlxyXG5cdGNvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lKSxcclxuXHRcdCAgICBjb2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2VkO1xyXG5cclxuXHRcdC8vIG1ha2VzIHRoaXMgd29yayBvbiBJRSB0b3VjaCBkZXZpY2VzIGJ5IHN0b3BwaW5nIGl0IGZyb20gZmlyaW5nIGEgbW91c2VvdXQgZXZlbnQgd2hlbiB0aGUgdG91Y2ggaXMgcmVsZWFzZWRcclxuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcclxuXHJcblx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cdFx0ZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblxyXG5cdFx0dmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uID0gY3JlYXRlJDEoJ3NlY3Rpb24nLCBjbGFzc05hbWUgKyAnLWxpc3QnKTtcclxuXHJcblx0XHRpZiAoY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLmNvbGxhcHNlLCB0aGlzKTtcclxuXHJcblx0XHRcdGlmICghYW5kcm9pZCkge1xyXG5cdFx0XHRcdG9uKGNvbnRhaW5lciwge1xyXG5cdFx0XHRcdFx0bW91c2VlbnRlcjogdGhpcy5leHBhbmQsXHJcblx0XHRcdFx0XHRtb3VzZWxlYXZlOiB0aGlzLmNvbGxhcHNlXHJcblx0XHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGluayA9IHRoaXMuX2xheWVyc0xpbmsgPSBjcmVhdGUkMSgnYScsIGNsYXNzTmFtZSArICctdG9nZ2xlJywgY29udGFpbmVyKTtcclxuXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdGxpbmsudGl0bGUgPSAnTGF5ZXJzJztcclxuXHJcblx0XHRpZiAodG91Y2gpIHtcclxuXHRcdFx0b24obGluaywgJ2NsaWNrJywgc3RvcCk7XHJcblx0XHRcdG9uKGxpbmssICdjbGljaycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9uKGxpbmssICdmb2N1cycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIHNlY3Rpb24pO1xyXG5cdFx0dGhpcy5fc2VwYXJhdG9yID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctc2VwYXJhdG9yJywgc2VjdGlvbik7XHJcblx0XHR0aGlzLl9vdmVybGF5c0xpc3QgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lICsgJy1vdmVybGF5cycsIHNlY3Rpb24pO1xyXG5cclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWN0aW9uKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcblx0XHRcdGlmICh0aGlzLl9sYXllcnNbaV0gJiYgc3RhbXAodGhpcy5fbGF5ZXJzW2ldLmxheWVyKSA9PT0gaWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0bGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllcnMucHVzaCh7XHJcblx0XHRcdGxheWVyOiBsYXllcixcclxuXHRcdFx0bmFtZTogbmFtZSxcclxuXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zb3J0TGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zb3J0KGJpbmQoZnVuY3Rpb24gKGEsIGIpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnNvcnRGdW5jdGlvbihhLmxheWVyLCBiLmxheWVyLCBhLm5hbWUsIGIubmFtZSk7XHJcblx0XHRcdH0sIHRoaXMpKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9aSW5kZXggJiYgbGF5ZXIuc2V0WkluZGV4KSB7XHJcblx0XHRcdHRoaXMuX2xhc3RaSW5kZXgrKztcclxuXHRcdFx0bGF5ZXIuc2V0WkluZGV4KHRoaXMuX2xhc3RaSW5kZXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRlbXB0eSh0aGlzLl9iYXNlTGF5ZXJzTGlzdCk7XHJcblx0XHRlbXB0eSh0aGlzLl9vdmVybGF5c0xpc3QpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG5cdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50LCBvdmVybGF5c1ByZXNlbnQsIGksIG9iaiwgYmFzZUxheWVyc0NvdW50ID0gMDtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0dGhpcy5fYWRkSXRlbShvYmopO1xyXG5cdFx0XHRvdmVybGF5c1ByZXNlbnQgPSBvdmVybGF5c1ByZXNlbnQgfHwgb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzQ291bnQgKz0gIW9iai5vdmVybGF5ID8gMSA6IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmhpZGVTaW5nbGVCYXNlKSB7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgJiYgYmFzZUxheWVyc0NvdW50ID4gMTtcclxuXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2VwYXJhdG9yLnN0eWxlLmRpc3BsYXkgPSBvdmVybGF5c1ByZXNlbnQgJiYgYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb25MYXllckNoYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoc3RhbXAoZS50YXJnZXQpKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gTGF5ZXIgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgYmFzZWxheWVyY2hhbmdlOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGJhc2UgbGF5ZXIgaXMgY2hhbmdlZCB0aHJvdWdoIHRoZSBbbGF5ZXIgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBldmVudCBvdmVybGF5YWRkOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXIgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBldmVudCBvdmVybGF5cmVtb3ZlOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBkZXNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllciBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBDb250cm9sLkxheWVyc1xyXG5cdFx0dmFyIHR5cGUgPSBvYmoub3ZlcmxheSA/XHJcblx0XHRcdChlLnR5cGUgPT09ICdhZGQnID8gJ292ZXJsYXlhZGQnIDogJ292ZXJsYXlyZW1vdmUnKSA6XHJcblx0XHRcdChlLnR5cGUgPT09ICdhZGQnID8gJ2Jhc2VsYXllcmNoYW5nZScgOiBudWxsKTtcclxuXHJcblx0XHRpZiAodHlwZSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSh0eXBlLCBvYmopO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIElFNyBidWdzIG91dCBpZiB5b3UgY3JlYXRlIGEgcmFkaW8gZHluYW1pY2FsbHksIHNvIHlvdSBoYXZlIHRvIGRvIGl0IHRoaXMgaGFja3kgd2F5IChzZWUgaHR0cDovL2JpdC5seS9QcVlMQmUpXHJcblx0X2NyZWF0ZVJhZGlvRWxlbWVudDogZnVuY3Rpb24gKG5hbWUsIGNoZWNrZWQpIHtcclxuXHJcblx0XHR2YXIgcmFkaW9IdG1sID0gJzxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImxlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3JcIiBuYW1lPVwiJyArXHJcblx0XHRcdFx0bmFtZSArICdcIicgKyAoY2hlY2tlZCA/ICcgY2hlY2tlZD1cImNoZWNrZWRcIicgOiAnJykgKyAnLz4nO1xyXG5cclxuXHRcdHZhciByYWRpb0ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRyYWRpb0ZyYWdtZW50LmlubmVySFRNTCA9IHJhZGlvSHRtbDtcclxuXHJcblx0XHRyZXR1cm4gcmFkaW9GcmFnbWVudC5maXJzdENoaWxkO1xyXG5cdH0sXHJcblxyXG5cdF9hZGRJdGVtOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpLFxyXG5cdFx0ICAgIGNoZWNrZWQgPSB0aGlzLl9tYXAuaGFzTGF5ZXIob2JqLmxheWVyKSxcclxuXHRcdCAgICBpbnB1dDtcclxuXHJcblx0XHRpZiAob2JqLm92ZXJsYXkpIHtcclxuXHRcdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG5cdFx0XHRpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcclxuXHRcdFx0aW5wdXQuY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3InO1xyXG5cdFx0XHRpbnB1dC5kZWZhdWx0Q2hlY2tlZCA9IGNoZWNrZWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpbnB1dCA9IHRoaXMuX2NyZWF0ZVJhZGlvRWxlbWVudCgnbGVhZmxldC1iYXNlLWxheWVyc18nICsgc3RhbXAodGhpcyksIGNoZWNrZWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cy5wdXNoKGlucHV0KTtcclxuXHRcdGlucHV0LmxheWVySWQgPSBzdGFtcChvYmoubGF5ZXIpO1xyXG5cclxuXHRcdG9uKGlucHV0LCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpO1xyXG5cclxuXHRcdHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcclxuXHJcblx0XHQvLyBIZWxwcyBmcm9tIHByZXZlbnRpbmcgbGF5ZXIgY29udHJvbCBmbGlja2VyIHdoZW4gY2hlY2tib3hlcyBhcmUgZGlzYWJsZWRcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzI3NzFcclxuXHRcdHZhciBob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKGlucHV0KTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChuYW1lKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH0sXHJcblxyXG5cdF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcblx0XHQgICAgaW5wdXQsIGxheWVyO1xyXG5cdFx0dmFyIGFkZGVkTGF5ZXJzID0gW10sXHJcblx0XHQgICAgcmVtb3ZlZExheWVycyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblxyXG5cdFx0XHRpZiAoaW5wdXQuY2hlY2tlZCkge1xyXG5cdFx0XHRcdGFkZGVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFpbnB1dC5jaGVja2VkKSB7XHJcblx0XHRcdFx0cmVtb3ZlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJ1Z2ZpeCBpc3N1ZSAyMzE4OiBTaG91bGQgcmVtb3ZlIGFsbCBvbGQgbGF5ZXJzIGJlZm9yZSByZWFkZGluZyBuZXcgb25lc1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcihyZW1vdmVkTGF5ZXJzW2ldKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihyZW1vdmVkTGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGFkZGVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICghdGhpcy5fbWFwLmhhc0xheWVyKGFkZGVkTGF5ZXJzW2ldKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihhZGRlZExheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fcmVmb2N1c09uTWFwKCk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrRGlzYWJsZWRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcblx0XHQgICAgaW5wdXQsXHJcblx0XHQgICAgbGF5ZXIsXHJcblx0XHQgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHRcdFx0aW5wdXQuZGlzYWJsZWQgPSAobGF5ZXIub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA8IGxheWVyLm9wdGlvbnMubWluWm9vbSkgfHxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAobGF5ZXIub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA+IGxheWVyLm9wdGlvbnMubWF4Wm9vbSk7XHJcblxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9leHBhbmRJZk5vdENvbGxhcHNlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmV4cGFuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmNvbGxhcHNlKCk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmxheWVycyhiYXNlbGF5ZXJzPzogT2JqZWN0LCBvdmVybGF5cz86IE9iamVjdCwgb3B0aW9ucz86IENvbnRyb2wuTGF5ZXJzIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSBsYXllcnMgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBsYXllcnMuIEJhc2UgbGF5ZXJzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCByYWRpbyBidXR0b25zLCB3aGlsZSBvdmVybGF5cyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggY2hlY2tib3hlcy4gTm90ZSB0aGF0IGFsbCBiYXNlIGxheWVycyBzaG91bGQgYmUgcGFzc2VkIGluIHRoZSBiYXNlIGxheWVycyBvYmplY3QsIGJ1dCBvbmx5IG9uZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG1hcCBkdXJpbmcgbWFwIGluc3RhbnRpYXRpb24uXHJcbnZhciBsYXllcnMgPSBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IExheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucyk7XHJcbn07XG5cbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLlpvb21cclxuICogQGFrYSBMLkNvbnRyb2wuWm9vbVxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBBIGJhc2ljIHpvb20gY29udHJvbCB3aXRoIHR3byBidXR0b25zICh6b29tIGluIGFuZCB6b29tIG91dCkuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgdG8gYGZhbHNlYC4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqL1xyXG5cclxudmFyIFpvb20gPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuWm9vbSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICd0b3BsZWZ0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRleHQ6IFN0cmluZyA9ICcrJ1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGV4dDogJysnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGl0bGU6IFN0cmluZyA9ICdab29tIGluJ1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJyYjeDIyMTI7J1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUZXh0OiAnJiN4MjIxMjsnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRpdGxlOiBTdHJpbmcgPSAnWm9vbSBvdXQnXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUaXRsZTogJ1pvb20gb3V0J1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR2YXIgem9vbU5hbWUgPSAnbGVhZmxldC1jb250cm9sLXpvb20nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCB6b29tTmFtZSArICcgbGVhZmxldC1iYXInKSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdHRoaXMuX3pvb21JbkJ1dHRvbiAgPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tSW5UZXh0LCBvcHRpb25zLnpvb21JblRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4pO1xyXG5cdFx0dGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21PdXRUZXh0LCBvcHRpb25zLnpvb21PdXRUaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdG1hcC5vbignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBjb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IHRydWU7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF96b29tSW46IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA8IHRoaXMuX21hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21Jbih0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3pvb21PdXQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA+IHRoaXMuX21hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uIChodG1sLCB0aXRsZSwgY2xhc3NOYW1lLCBjb250YWluZXIsIGZuKSB7XHJcblx0XHR2YXIgbGluayA9IGNyZWF0ZSQxKCdhJywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5pbm5lckhUTUwgPSBodG1sO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9IHRpdGxlO1xyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBXaWxsIGZvcmNlIHNjcmVlbiByZWFkZXJzIGxpa2UgVm9pY2VPdmVyIHRvIHJlYWQgdGhpcyBhcyBcIlpvb20gaW4gLSBidXR0b25cIlxyXG5cdFx0ICovXHJcblx0XHRsaW5rLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xyXG5cclxuXHRcdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGxpbmspO1xyXG5cdFx0b24obGluaywgJ2NsaWNrJywgc3RvcCk7XHJcblx0XHRvbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcyk7XHJcblx0XHRvbihsaW5rLCAnY2xpY2snLCB0aGlzLl9yZWZvY3VzT25NYXAsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBsaW5rO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBjbGFzc05hbWUgPSAnbGVhZmxldC1kaXNhYmxlZCc7XHJcblxyXG5cdFx0cmVtb3ZlQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0cmVtb3ZlQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWluWm9vbSgpKSB7XHJcblx0XHRcdGFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdGFkZENsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gem9vbUNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbem9vbSBjb250cm9sXSgjY29udHJvbC16b29tKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdHpvb21Db250cm9sOiB0cnVlXHJcbn0pO1xyXG5cclxuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLnpvb21Db250cm9sKSB7XHJcblx0XHQvLyBAc2VjdGlvbiBDb250cm9sc1xyXG5cdFx0Ly8gQHByb3BlcnR5IHpvb21Db250cm9sOiBDb250cm9sLlpvb21cclxuXHRcdC8vIFRoZSBkZWZhdWx0IHpvb20gY29udHJvbCAob25seSBhdmFpbGFibGUgaWYgdGhlXHJcblx0XHQvLyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHdhcyBgdHJ1ZWAgd2hlbiBjcmVhdGluZyB0aGUgbWFwKS5cclxuXHRcdHRoaXMuem9vbUNvbnRyb2wgPSBuZXcgWm9vbSgpO1xyXG5cdFx0dGhpcy5hZGRDb250cm9sKHRoaXMuem9vbUNvbnRyb2wpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuWm9vbVxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuem9vbShvcHRpb25zOiBDb250cm9sLlpvb20gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIHpvb20gY29udHJvbFxyXG52YXIgem9vbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBab29tKG9wdGlvbnMpO1xyXG59O1xuXG4vKlxuICogQGNsYXNzIENvbnRyb2wuU2NhbGVcbiAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxuICpcbiAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY29udHJvbC5zY2FsZSgpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG52YXIgU2NhbGUgPSBDb250cm9sLmV4dGVuZCh7XG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ29udHJvbC5TY2FsZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMTAwXG5cdFx0Ly8gTWF4aW11bSB3aWR0aCBvZiB0aGUgY29udHJvbCBpbiBwaXhlbHMuIFRoZSB3aWR0aCBpcyBzZXQgZHluYW1pY2FsbHkgdG8gc2hvdyByb3VuZCB2YWx1ZXMgKGUuZy4gMTAwLCAyMDAsIDUwMCkuXG5cdFx0bWF4V2lkdGg6IDEwMCxcblxuXHRcdC8vIEBvcHRpb24gbWV0cmljOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgbWV0cmljIHNjYWxlIGxpbmUgKG0va20pLlxuXHRcdG1ldHJpYzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gaW1wZXJpYWw6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBpbXBlcmlhbCBzY2FsZSBsaW5lIChtaS9mdCkuXG5cdFx0aW1wZXJpYWw6IHRydWVcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgaXMgdXBkYXRlZCBvbiBbYG1vdmVlbmRgXSgjbWFwLW1vdmVlbmQpLCBvdGhlcndpc2UgaXQncyBhbHdheXMgdXAtdG8tZGF0ZSAodXBkYXRlZCBvbiBbYG1vdmVgXSgjbWFwLW1vdmUpKS5cblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLXNjYWxlJyxcblx0XHQgICAgY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLl9hZGRTY2FsZXMob3B0aW9ucywgY2xhc3NOYW1lICsgJy1saW5lJywgY29udGFpbmVyKTtcblxuXHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHRcdG1hcC53aGVuUmVhZHkodGhpcy5fdXBkYXRlLCB0aGlzKTtcblxuXHRcdHJldHVybiBjb250YWluZXI7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAub2ZmKHRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0fSxcblxuXHRfYWRkU2NhbGVzOiBmdW5jdGlvbiAob3B0aW9ucywgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcblx0XHRpZiAob3B0aW9ucy5tZXRyaWMpIHtcblx0XHRcdHRoaXMuX21TY2FsZSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmltcGVyaWFsKSB7XG5cdFx0XHR0aGlzLl9pU2NhbGUgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgeSA9IG1hcC5nZXRTaXplKCkueSAvIDI7XG5cblx0XHR2YXIgbWF4TWV0ZXJzID0gbWFwLmRpc3RhbmNlKFxuXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoWzAsIHldKSxcblx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFt0aGlzLm9wdGlvbnMubWF4V2lkdGgsIHldKSk7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZXMobWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlU2NhbGVzOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVNZXRyaWMobWF4TWV0ZXJzKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVNZXRyaWM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWV0ZXJzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWV0ZXJzKSxcblx0XHQgICAgbGFiZWwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5fbVNjYWxlLCBsYWJlbCwgbWV0ZXJzIC8gbWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlSW1wZXJpYWw6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWF4RmVldCA9IG1heE1ldGVycyAqIDMuMjgwODM5OSxcblx0XHQgICAgbWF4TWlsZXMsIG1pbGVzLCBmZWV0O1xuXG5cdFx0aWYgKG1heEZlZXQgPiA1MjgwKSB7XG5cdFx0XHRtYXhNaWxlcyA9IG1heEZlZXQgLyA1MjgwO1xuXHRcdFx0bWlsZXMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNaWxlcyk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIG1pbGVzICsgJyBtaScsIG1pbGVzIC8gbWF4TWlsZXMpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZlZXQgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhGZWV0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgZmVldCArICcgZnQnLCBmZWV0IC8gbWF4RmVldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVTY2FsZTogZnVuY3Rpb24gKHNjYWxlLCB0ZXh0LCByYXRpbykge1xuXHRcdHNjYWxlLnN0eWxlLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGggKiByYXRpbykgKyAncHgnO1xuXHRcdHNjYWxlLmlubmVySFRNTCA9IHRleHQ7XG5cdH0sXG5cblx0X2dldFJvdW5kTnVtOiBmdW5jdGlvbiAobnVtKSB7XG5cdFx0dmFyIHBvdzEwID0gTWF0aC5wb3coMTAsIChNYXRoLmZsb29yKG51bSkgKyAnJykubGVuZ3RoIC0gMSksXG5cdFx0ICAgIGQgPSBudW0gLyBwb3cxMDtcblxuXHRcdGQgPSBkID49IDEwID8gMTAgOlxuXHRcdCAgICBkID49IDUgPyA1IDpcblx0XHQgICAgZCA+PSAzID8gMyA6XG5cdFx0ICAgIGQgPj0gMiA/IDIgOiAxO1xuXG5cdFx0cmV0dXJuIHBvdzEwICogZDtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnNjYWxlKG9wdGlvbnM/OiBDb250cm9sLlNjYWxlIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGFuIHNjYWxlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbnZhciBzY2FsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgU2NhbGUob3B0aW9ucyk7XG59O1xuXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICovXHJcblxyXG52YXIgQXR0cmlidXRpb24gPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcHJlZml4OiBTdHJpbmcgPSAnTGVhZmxldCdcclxuXHRcdC8vIFRoZSBIVE1MIHRleHQgc2hvd24gYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuIFBhc3MgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG5cdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHBzOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+TGVhZmxldDwvYT4nXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zID0ge307XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wgPSB0aGlzO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24nKTtcclxuXHRcdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0Ly8gVE9ETyB1Z2x5LCByZWZhY3RvclxyXG5cdFx0Zm9yICh2YXIgaSBpbiBtYXAuX2xheWVycykge1xyXG5cdFx0XHRpZiAobWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFByZWZpeChwcmVmaXg6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB0ZXh0IGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLlxyXG5cdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnVmVjdG9yIGRhdGEgJmNvcHk7IE1hcGJveCdgKS5cclxuXHRhZGRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSA9IDA7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFuIGF0dHJpYnV0aW9uIHRleHQuXHJcblx0cmVtb3ZlQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XS0tO1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgYXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fYXR0cmlidXRpb25zKSB7XHJcblx0XHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcclxuXHRcdFx0XHRhdHRyaWJzLnB1c2goaSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcHJlZml4QW5kQXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucHJlZml4KSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaCh0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuXHRcdH1cclxuXHRcdGlmIChhdHRyaWJzLmxlbmd0aCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gcHJlZml4QW5kQXR0cmlicy5qb2luKCcgfCAnKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW2F0dHJpYnV0aW9uIGNvbnRyb2xdKCNjb250cm9sLWF0dHJpYnV0aW9uKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuXHRcdG5ldyBBdHRyaWJ1dGlvbigpLmFkZFRvKHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuQXR0cmlidXRpb25cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG52YXIgYXR0cmlidXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgQXR0cmlidXRpb24ob3B0aW9ucyk7XHJcbn07XG5cbkNvbnRyb2wuTGF5ZXJzID0gTGF5ZXJzO1xuQ29udHJvbC5ab29tID0gWm9vbTtcbkNvbnRyb2wuU2NhbGUgPSBTY2FsZTtcbkNvbnRyb2wuQXR0cmlidXRpb24gPSBBdHRyaWJ1dGlvbjtcblxuY29udHJvbC5sYXllcnMgPSBsYXllcnM7XG5jb250cm9sLnpvb20gPSB6b29tO1xuY29udHJvbC5zY2FsZSA9IHNjYWxlO1xuY29udHJvbC5hdHRyaWJ1dGlvbiA9IGF0dHJpYnV0aW9uO1xuXG4vKlxuXHRMLkhhbmRsZXIgaXMgYSBiYXNlIGNsYXNzIGZvciBoYW5kbGVyIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5IHRvIGluamVjdFxuXHRpbnRlcmFjdGlvbiBmZWF0dXJlcyBsaWtlIGRyYWdnaW5nIHRvIGNsYXNzZXMgbGlrZSBNYXAgYW5kIE1hcmtlci5cbiovXG5cbi8vIEBjbGFzcyBIYW5kbGVyXG4vLyBAYWthIEwuSGFuZGxlclxuLy8gQWJzdHJhY3QgY2xhc3MgZm9yIG1hcCBpbnRlcmFjdGlvbiBoYW5kbGVyc1xuXG52YXIgSGFuZGxlciA9IENsYXNzLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGUoKTogdGhpc1xuXHQvLyBFbmFibGVzIHRoZSBoYW5kbGVyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLmFkZEhvb2tzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBkaXNhYmxlKCk6IHRoaXNcblx0Ly8gRGlzYWJsZXMgdGhlIGhhbmRsZXJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXHRcdHRoaXMucmVtb3ZlSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZWQoKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaGFuZGxlciBpcyBlbmFibGVkXG5cdGVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9lbmFibGVkO1xuXHR9XG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gQ2xhc3NlcyBpbmhlcml0aW5nIGZyb20gYEhhbmRsZXJgIG11c3QgaW1wbGVtZW50IHRoZSB0d28gZm9sbG93aW5nIG1ldGhvZHM6XG5cdC8vIEBtZXRob2QgYWRkSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBlbmFibGVkLCBzaG91bGQgYWRkIGV2ZW50IGhvb2tzLlxuXHQvLyBAbWV0aG9kIHJlbW92ZUhvb2tzKClcblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZGlzYWJsZWQsIHNob3VsZCByZW1vdmUgdGhlIGV2ZW50IGhvb2tzIGFkZGVkIHByZXZpb3VzbHkuXG59KTtcblxuLy8gQHNlY3Rpb24gVGhlcmUgaXMgc3RhdGljIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuSGFuZGxlcjpcbi8vIEBmdW5jdGlvbiBhZGRUbyhtYXA6IE1hcCwgbmFtZTogU3RyaW5nKTogdGhpc1xuLy8gQWRkcyBhIG5ldyBIYW5kbGVyIHRvIHRoZSBnaXZlbiBtYXAgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbkhhbmRsZXIuYWRkVG8gPSBmdW5jdGlvbiAobWFwLCBuYW1lKSB7XG5cdG1hcC5hZGRIYW5kbGVyKG5hbWUsIHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbnZhciBNaXhpbiA9IHtFdmVudHM6IEV2ZW50c307XG5cbi8qXHJcbiAqIEBjbGFzcyBEcmFnZ2FibGVcclxuICogQGFrYSBMLkRyYWdnYWJsZVxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBBIGNsYXNzIGZvciBtYWtpbmcgRE9NIGVsZW1lbnRzIGRyYWdnYWJsZSAoaW5jbHVkaW5nIHRvdWNoIHN1cHBvcnQpLlxyXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIG1hcCBhbmQgbWFya2VyIGRyYWdnaW5nLiBPbmx5IHdvcmtzIGZvciBlbGVtZW50c1xyXG4gKiB0aGF0IHdlcmUgcG9zaXRpb25lZCB3aXRoIFtgTC5Eb21VdGlsLnNldFBvc2l0aW9uYF0oI2RvbXV0aWwtc2V0cG9zaXRpb24pLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKGVsZW1lbnRUb0RyYWcpO1xyXG4gKiBkcmFnZ2FibGUuZW5hYmxlKCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBTVEFSVCA9IHRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nO1xyXG52YXIgRU5EID0ge1xyXG5cdG1vdXNlZG93bjogJ21vdXNldXAnLFxyXG5cdHRvdWNoc3RhcnQ6ICd0b3VjaGVuZCcsXHJcblx0cG9pbnRlcmRvd246ICd0b3VjaGVuZCcsXHJcblx0TVNQb2ludGVyRG93bjogJ3RvdWNoZW5kJ1xyXG59O1xyXG52YXIgTU9WRSA9IHtcclxuXHRtb3VzZWRvd246ICdtb3VzZW1vdmUnLFxyXG5cdHRvdWNoc3RhcnQ6ICd0b3VjaG1vdmUnLFxyXG5cdHBvaW50ZXJkb3duOiAndG91Y2htb3ZlJyxcclxuXHRNU1BvaW50ZXJEb3duOiAndG91Y2htb3ZlJ1xyXG59O1xyXG5cclxuXHJcbnZhciBEcmFnZ2FibGUgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvLyBAYWthIERyYWdnYWJsZSBvcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNsaWNrVG9sZXJhbmNlOiBOdW1iZXIgPSAzXHJcblx0XHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBjbGlja1xyXG5cdFx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCBjbGljayAoYXMgb3Bwb3NlZCB0byBhIG1vdXNlIGRyYWcpLlxyXG5cdFx0Y2xpY2tUb2xlcmFuY2U6IDNcclxuXHR9LFxyXG5cclxuXHQvLyBAY29uc3RydWN0b3IgTC5EcmFnZ2FibGUoZWw6IEhUTUxFbGVtZW50LCBkcmFnSGFuZGxlPzogSFRNTEVsZW1lbnQsIHByZXZlbnRPdXRsaW5lPzogQm9vbGVhbiwgb3B0aW9ucz86IERyYWdnYWJsZSBvcHRpb25zKVxyXG5cdC8vIENyZWF0ZXMgYSBgRHJhZ2dhYmxlYCBvYmplY3QgZm9yIG1vdmluZyBgZWxgIHdoZW4geW91IHN0YXJ0IGRyYWdnaW5nIHRoZSBgZHJhZ0hhbmRsZWAgZWxlbWVudCAoZXF1YWxzIGBlbGAgaXRzZWxmIGJ5IGRlZmF1bHQpLlxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChlbGVtZW50LCBkcmFnU3RhcnRUYXJnZXQsIHByZXZlbnRPdXRsaW5lJCQxLCBvcHRpb25zKSB7XHJcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG5cdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9wcmV2ZW50T3V0bGluZSA9IHByZXZlbnRPdXRsaW5lJCQxO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZW5hYmxlKClcclxuXHQvLyBFbmFibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRvbih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpXHJcblx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gSWYgd2UncmUgY3VycmVudGx5IGRyYWdnaW5nIHRoaXMgZHJhZ2dhYmxlLFxyXG5cdFx0Ly8gZGlzYWJsaW5nIGl0IGNvdW50cyBhcyBmaXJzdCBlbmRpbmcgdGhlIGRyYWcuXHJcblx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyA9PT0gdGhpcykge1xyXG5cdFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRvZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKGhhc0NsYXNzKHRoaXMuX2VsZW1lbnQsICdsZWFmbGV0LXpvb20tYW5pbScpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nIHx8IGUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpICYmICFlLnRvdWNoZXMpKSB7IHJldHVybjsgfVxyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRoaXM7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcblx0XHRpZiAodGhpcy5fcHJldmVudE91dGxpbmUpIHtcclxuXHRcdFx0cHJldmVudE91dGxpbmUodGhpcy5fZWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGlzYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEBldmVudCBkb3duOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgaXMgYWJvdXQgdG8gc3RhcnQuXHJcblx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxyXG5cdFx0ICAgIHNpemVkUGFyZW50ID0gZ2V0U2l6ZWRQYXJlbnROb2RlKHRoaXMuX2VsZW1lbnQpO1xyXG5cclxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XHJcblxyXG5cdFx0Ly8gQ2FjaGUgdGhlIHNjYWxlLCBzbyB0aGF0IHdlIGNhbiBjb250aW51b3VzbHkgY29tcGVuc2F0ZSBmb3IgaXQgZHVyaW5nIGRyYWcgKF9vbk1vdmUpLlxyXG5cdFx0dGhpcy5fcGFyZW50U2NhbGUgPSBnZXRTY2FsZShzaXplZFBhcmVudCk7XHJcblxyXG5cdFx0b24oZG9jdW1lbnQsIE1PVkVbZS50eXBlXSwgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdG9uKGRvY3VtZW50LCBFTkRbZS50eXBlXSwgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmlyc3QgPSAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDEgPyBlLnRvdWNoZXNbMF0gOiBlKSxcclxuXHRcdCAgICBvZmZzZXQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSkuX3N1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybjsgfVxyXG5cdFx0aWYgKE1hdGguYWJzKG9mZnNldC54KSArIE1hdGguYWJzKG9mZnNldC55KSA8IHRoaXMub3B0aW9ucy5jbGlja1RvbGVyYW5jZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBXZSBhc3N1bWUgdGhhdCB0aGUgcGFyZW50IGNvbnRhaW5lcidzIHBvc2l0aW9uLCBib3JkZXIgYW5kIHNjYWxlIGRvIG5vdCBjaGFuZ2UgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZHJhZy5cclxuXHRcdC8vIFRoZXJlZm9yZSB0aGVyZSBpcyBubyBuZWVkIHRvIGFjY291bnQgZm9yIHRoZSBwb3NpdGlvbiBhbmQgYm9yZGVyICh0aGV5IGFyZSBlbGltaW5hdGVkIGJ5IHRoZSBzdWJ0cmFjdGlvbilcclxuXHRcdC8vIGFuZCB3ZSBjYW4gdXNlIHRoZSBjYWNoZWQgdmFsdWUgZm9yIHRoZSBzY2FsZS5cclxuXHRcdG9mZnNldC54IC89IHRoaXMuX3BhcmVudFNjYWxlLng7XHJcblx0XHRvZmZzZXQueSAvPSB0aGlzLl9wYXJlbnRTY2FsZS55O1xyXG5cclxuXHRcdHByZXZlbnREZWZhdWx0KGUpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgc3RhcnRzXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblxyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHRoaXMuX3N0YXJ0UG9zID0gZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCkuc3VidHJhY3Qob2Zmc2V0KTtcclxuXHJcblx0XHRcdGFkZENsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xyXG5cdFx0XHQvLyBJRSBhbmQgRWRnZSBkbyBub3QgZ2l2ZSB0aGUgPHVzZT4gZWxlbWVudCwgc28gZmV0Y2ggaXRcclxuXHRcdFx0Ly8gaWYgbmVjZXNzYXJ5XHJcblx0XHRcdGlmICgod2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSkgJiYgKHRoaXMuX2xhc3RUYXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50SW5zdGFuY2UpKSB7XHJcblx0XHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IHRoaXMuX2xhc3RUYXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XHJcblx0XHRcdH1cclxuXHRcdFx0YWRkQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9uZXdQb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcclxuXHRcdHRoaXMuX21vdmluZyA9IHRydWU7XHJcblxyXG5cdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHRcdHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlUG9zaXRpb24sIHRoaXMsIHRydWUpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGUgPSB7b3JpZ2luYWxFdmVudDogdGhpcy5fbGFzdEV2ZW50fTtcclxuXHJcblx0XHQvLyBAZXZlbnQgcHJlZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcgKmJlZm9yZSogZWFjaCBjb3JyZXNwb25kaW5nXHJcblx0XHQvLyB1cGRhdGUgb2YgdGhlIGVsZW1lbnQncyBwb3NpdGlvbi5cclxuXHRcdHRoaXMuZmlyZSgncHJlZHJhZycsIGUpO1xyXG5cdFx0c2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCwgdGhpcy5fbmV3UG9zKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcuXHJcblx0XHR0aGlzLmZpcmUoJ2RyYWcnLCBlKTtcclxuXHR9LFxyXG5cclxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHR9LFxyXG5cclxuXHRmaW5pc2hEcmFnOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0VGFyZ2V0KSB7XHJcblx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gTU9WRSkge1xyXG5cdFx0XHRvZmYoZG9jdW1lbnQsIE1PVkVbaV0sIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcblx0XHRcdG9mZihkb2N1bWVudCwgRU5EW2ldLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRlbmFibGVJbWFnZURyYWcoKTtcclxuXHRcdGVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nKSB7XHJcblx0XHRcdC8vIGVuc3VyZSBkcmFnIGlzIG5vdCBmaXJlZCBhZnRlciBkcmFnZW5kXHJcblx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XHJcblxyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGRyYWcgZW5kcy5cclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xyXG5cdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XHJcblx0XHREcmFnZ2FibGUuX2RyYWdnaW5nID0gZmFsc2U7XHJcblx0fVxyXG5cclxufSk7XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGluZVV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWxpbmUgcG9pbnRzIHByb2Nlc3NpbmcsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIG1ha2UgcG9seWxpbmVzIGxpZ2h0bmluZy1mYXN0LlxyXG4gKi9cclxuXHJcbi8vIFNpbXBsaWZ5IHBvbHlsaW5lIHdpdGggdmVydGV4IHJlZHVjdGlvbiBhbmQgRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLlxyXG4vLyBJbXByb3ZlcyByZW5kZXJpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IGJ5IGxlc3NlbmluZyB0aGUgbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3LlxyXG5cclxuLy8gQGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50czogUG9pbnRbXSwgdG9sZXJhbmNlOiBOdW1iZXIpOiBQb2ludFtdXHJcbi8vIERyYW1hdGljYWxseSByZWR1Y2VzIHRoZSBudW1iZXIgb2YgcG9pbnRzIGluIGEgcG9seWxpbmUgd2hpbGUgcmV0YWluaW5nXHJcbi8vIGl0cyBzaGFwZSBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBzaW1wbGlmaWVkIHBvaW50cywgdXNpbmcgdGhlXHJcbi8vIFtEb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0pLlxyXG4vLyBVc2VkIGZvciBhIGh1Z2UgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiBwcm9jZXNzaW5nL2Rpc3BsYXlpbmcgTGVhZmxldCBwb2x5bGluZXMgZm9yXHJcbi8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuLy8gc2ltcGxpZmljYXRpb24gKGxlc3NlciB2YWx1ZSBtZWFucyBoaWdoZXIgcXVhbGl0eSBidXQgc2xvd2VyIGFuZCB3aXRoIG1vcmUgcG9pbnRzKS5cclxuLy8gQWxzbyByZWxlYXNlZCBhcyBhIHNlcGFyYXRlZCBtaWNyby1saWJyYXJ5IFtTaW1wbGlmeS5qc10oaHR0cDovL21vdXJuZXIuZ2l0aHViLmNvbS9zaW1wbGlmeS1qcy8pLlxyXG5mdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xyXG5cdGlmICghdG9sZXJhbmNlIHx8ICFwb2ludHMubGVuZ3RoKSB7XHJcblx0XHRyZXR1cm4gcG9pbnRzLnNsaWNlKCk7XHJcblx0fVxyXG5cclxuXHR2YXIgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XHJcblxyXG5cdCAgICAvLyBzdGFnZSAxOiB2ZXJ0ZXggcmVkdWN0aW9uXHJcblx0ICAgIHBvaW50cyA9IF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdCAgICAvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cclxuXHQgICAgcG9pbnRzID0gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGBwYCBhbmQgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbmZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIE1hdGguc3FydChfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCB0cnVlKSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIGNsb3Nlc3QgcG9pbnQgZnJvbSBhIHBvaW50IGBwYCBvbiBhIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5mdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG59XHJcblxyXG4vLyBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG1cclxuZnVuY3Rpb24gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuXHR2YXIgbGVuID0gcG9pbnRzLmxlbmd0aCxcclxuXHQgICAgQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSB1bmRlZmluZWQgKyAnJyA/IFVpbnQ4QXJyYXkgOiBBcnJheSxcclxuXHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG5cdCAgICBtYXJrZXJzWzBdID0gbWFya2Vyc1tsZW4gLSAxXSA9IDE7XHJcblxyXG5cdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCAwLCBsZW4gLSAxKTtcclxuXHJcblx0dmFyIGksXHJcblx0ICAgIG5ld1BvaW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGlmIChtYXJrZXJzW2ldKSB7XHJcblx0XHRcdG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3UG9pbnRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcclxuXHJcblx0dmFyIG1heFNxRGlzdCA9IDAsXHJcblx0aW5kZXgsIGksIHNxRGlzdDtcclxuXHJcblx0Zm9yIChpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3QgLSAxOyBpKyspIHtcclxuXHRcdHNxRGlzdCA9IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSwgdHJ1ZSk7XHJcblxyXG5cdFx0aWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xyXG5cdFx0XHRpbmRleCA9IGk7XHJcblx0XHRcdG1heFNxRGlzdCA9IHNxRGlzdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0bWFya2Vyc1tpbmRleF0gPSAxO1xyXG5cclxuXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG5cdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGluZGV4LCBsYXN0KTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIHJlZHVjZSBwb2ludHMgdGhhdCBhcmUgdG9vIGNsb3NlIHRvIGVhY2ggb3RoZXIgdG8gYSBzaW5nbGUgcG9pbnRcclxuZnVuY3Rpb24gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblx0dmFyIHJlZHVjZWRQb2ludHMgPSBbcG9pbnRzWzBdXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDEsIHByZXYgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGlmIChfc3FEaXN0KHBvaW50c1tpXSwgcG9pbnRzW3ByZXZdKSA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0XHRwcmV2ID0gaTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHByZXYgPCBsZW4gLSAxKSB7XHJcblx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2xlbiAtIDFdKTtcclxuXHR9XHJcblx0cmV0dXJuIHJlZHVjZWRQb2ludHM7XHJcbn1cclxuXHJcbnZhciBfbGFzdENvZGU7XHJcblxyXG4vLyBAZnVuY3Rpb24gY2xpcFNlZ21lbnQoYTogUG9pbnQsIGI6IFBvaW50LCBib3VuZHM6IEJvdW5kcywgdXNlTGFzdENvZGU/OiBCb29sZWFuLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdfEJvb2xlYW5cclxuLy8gQ2xpcHMgdGhlIHNlZ21lbnQgYSB0byBiIGJ5IHJlY3Rhbmd1bGFyIGJvdW5kcyB3aXRoIHRoZVxyXG4vLyBbQ29oZW4tU3V0aGVybGFuZCBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuJUUyJTgwJTkzU3V0aGVybGFuZF9hbGdvcml0aG0pXHJcbi8vIChtb2RpZnlpbmcgdGhlIHNlZ21lbnQgcG9pbnRzIGRpcmVjdGx5ISkuIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWxpbmVcclxuLy8gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZyBwZXJmb3JtYW5jZS5cclxuZnVuY3Rpb24gY2xpcFNlZ21lbnQoYSwgYiwgYm91bmRzLCB1c2VMYXN0Q29kZSwgcm91bmQpIHtcclxuXHR2YXIgY29kZUEgPSB1c2VMYXN0Q29kZSA/IF9sYXN0Q29kZSA6IF9nZXRCaXRDb2RlKGEsIGJvdW5kcyksXHJcblx0ICAgIGNvZGVCID0gX2dldEJpdENvZGUoYiwgYm91bmRzKSxcclxuXHJcblx0ICAgIGNvZGVPdXQsIHAsIG5ld0NvZGU7XHJcblxyXG5cdCAgICAvLyBzYXZlIDJuZCBjb2RlIHRvIGF2b2lkIGNhbGN1bGF0aW5nIGl0IG9uIHRoZSBuZXh0IHNlZ21lbnRcclxuXHQgICAgX2xhc3RDb2RlID0gY29kZUI7XHJcblxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHQvLyBpZiBhLGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCBhY2NlcHQpXHJcblx0XHRpZiAoIShjb2RlQSB8IGNvZGVCKSkge1xyXG5cdFx0XHRyZXR1cm4gW2EsIGJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIGEsYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCByZWplY3QpXHJcblx0XHRpZiAoY29kZUEgJiBjb2RlQikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb3RoZXIgY2FzZXNcclxuXHRcdGNvZGVPdXQgPSBjb2RlQSB8fCBjb2RlQjtcclxuXHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlT3V0LCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdG5ld0NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cclxuXHRcdGlmIChjb2RlT3V0ID09PSBjb2RlQSkge1xyXG5cdFx0XHRhID0gcDtcclxuXHRcdFx0Y29kZUEgPSBuZXdDb2RlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YiA9IHA7XHJcblx0XHRcdGNvZGVCID0gbmV3Q29kZTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGUsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgZHggPSBiLnggLSBhLngsXHJcblx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG5cdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdCAgICB4LCB5O1xyXG5cclxuXHRpZiAoY29kZSAmIDgpIHsgLy8gdG9wXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWF4LnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWF4Lnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWluLnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuXHRcdHggPSBtYXgueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMSkgeyAvLyBsZWZ0XHJcblx0XHR4ID0gbWluLng7XHJcblx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX2dldEJpdENvZGUocCwgYm91bmRzKSB7XHJcblx0dmFyIGNvZGUgPSAwO1xyXG5cclxuXHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuXHRcdGNvZGUgfD0gMTtcclxuXHR9IGVsc2UgaWYgKHAueCA+IGJvdW5kcy5tYXgueCkgeyAvLyByaWdodFxyXG5cdFx0Y29kZSB8PSAyO1xyXG5cdH1cclxuXHJcblx0aWYgKHAueSA8IGJvdW5kcy5taW4ueSkgeyAvLyBib3R0b21cclxuXHRcdGNvZGUgfD0gNDtcclxuXHR9IGVsc2UgaWYgKHAueSA+IGJvdW5kcy5tYXgueSkgeyAvLyB0b3BcclxuXHRcdGNvZGUgfD0gODtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb2RlO1xyXG59XHJcblxyXG4vLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuZnVuY3Rpb24gX3NxRGlzdChwMSwgcDIpIHtcclxuXHR2YXIgZHggPSBwMi54IC0gcDEueCxcclxuXHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuXHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG5mdW5jdGlvbiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCBzcURpc3QpIHtcclxuXHR2YXIgeCA9IHAxLngsXHJcblx0ICAgIHkgPSBwMS55LFxyXG5cdCAgICBkeCA9IHAyLnggLSB4LFxyXG5cdCAgICBkeSA9IHAyLnkgLSB5LFxyXG5cdCAgICBkb3QgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuXHQgICAgdDtcclxuXHJcblx0aWYgKGRvdCA+IDApIHtcclxuXHRcdHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyBkb3Q7XHJcblxyXG5cdFx0aWYgKHQgPiAxKSB7XHJcblx0XHRcdHggPSBwMi54O1xyXG5cdFx0XHR5ID0gcDIueTtcclxuXHRcdH0gZWxzZSBpZiAodCA+IDApIHtcclxuXHRcdFx0eCArPSBkeCAqIHQ7XHJcblx0XHRcdHkgKz0gZHkgKiB0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZHggPSBwLnggLSB4O1xyXG5cdGR5ID0gcC55IC0geTtcclxuXHJcblx0cmV0dXJuIHNxRGlzdCA/IGR4ICogZHggKyBkeSAqIGR5IDogbmV3IFBvaW50KHgsIHkpO1xyXG59XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGlzRmxhdChsYXRsbmdzOiBMYXRMbmdbXSk6IEJvb2xlYW5cclxuLy8gUmV0dXJucyB0cnVlIGlmIGBsYXRsbmdzYCBpcyBhIGZsYXQgYXJyYXksIGZhbHNlIGlzIG5lc3RlZC5cclxuZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3MpIHtcclxuXHRyZXR1cm4gIWlzQXJyYXkobGF0bG5nc1swXSkgfHwgKHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ3VuZGVmaW5lZCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfZmxhdChsYXRsbmdzKSB7XHJcblx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIHVzZSBvZiBfZmxhdCwgcGxlYXNlIHVzZSBMLkxpbmVVdGlsLmlzRmxhdCBpbnN0ZWFkLicpO1xyXG5cdHJldHVybiBpc0ZsYXQobGF0bG5ncyk7XHJcbn1cclxuXG5cbnZhciBMaW5lVXRpbCA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRzaW1wbGlmeTogc2ltcGxpZnksXG5cdHBvaW50VG9TZWdtZW50RGlzdGFuY2U6IHBvaW50VG9TZWdtZW50RGlzdGFuY2UsXG5cdGNsb3Nlc3RQb2ludE9uU2VnbWVudDogY2xvc2VzdFBvaW50T25TZWdtZW50LFxuXHRjbGlwU2VnbWVudDogY2xpcFNlZ21lbnQsXG5cdF9nZXRFZGdlSW50ZXJzZWN0aW9uOiBfZ2V0RWRnZUludGVyc2VjdGlvbixcblx0X2dldEJpdENvZGU6IF9nZXRCaXRDb2RlLFxuXHRfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQ6IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcblx0aXNGbGF0OiBpc0ZsYXQsXG5cdF9mbGF0OiBfZmxhdFxufSk7XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgUG9seVV0aWxcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gKi9cclxuXHJcbi8qIEBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHM6IFBvaW50W10sIGJvdW5kczogQm91bmRzLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdXHJcbiAqIENsaXBzIHRoZSBwb2x5Z29uIGdlb21ldHJ5IGRlZmluZWQgYnkgdGhlIGdpdmVuIGBwb2ludHNgIGJ5IHRoZSBnaXZlbiBib3VuZHMgKHVzaW5nIHRoZSBbU3V0aGVybGFuZC1Ib2RnbWFuIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtKSkuXHJcbiAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAqIHBlcmZvcm1hbmNlLiBOb3RlIHRoYXQgcG9seWdvbiBwb2ludHMgbmVlZHMgZGlmZmVyZW50IGFsZ29yaXRobSBmb3IgY2xpcHBpbmdcclxuICogdGhhbiBwb2x5bGluZSwgc28gdGhlcmUncyBhIHNlcGFyYXRlIG1ldGhvZCBmb3IgaXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHMsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgY2xpcHBlZFBvaW50cyxcclxuXHQgICAgZWRnZXMgPSBbMSwgNCwgMiwgOF0sXHJcblx0ICAgIGksIGosIGssXHJcblx0ICAgIGEsIGIsXHJcblx0ICAgIGxlbiwgZWRnZSwgcDtcclxuXHJcblx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRwb2ludHNbaV0uX2NvZGUgPSBfZ2V0Qml0Q29kZShwb2ludHNbaV0sIGJvdW5kcyk7XHJcblx0fVxyXG5cclxuXHQvLyBmb3IgZWFjaCBlZGdlIChsZWZ0LCBib3R0b20sIHJpZ2h0LCB0b3ApXHJcblx0Zm9yIChrID0gMDsgayA8IDQ7IGsrKykge1xyXG5cdFx0ZWRnZSA9IGVkZ2VzW2tdO1xyXG5cdFx0Y2xpcHBlZFBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcblx0XHRcdGEgPSBwb2ludHNbaV07XHJcblx0XHRcdGIgPSBwb2ludHNbal07XHJcblxyXG5cdFx0XHQvLyBpZiBhIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3dcclxuXHRcdFx0aWYgKCEoYS5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0Ly8gaWYgYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBnb2VzIG91dCBvZiBzY3JlZW4pXHJcblx0XHRcdFx0aWYgKGIuX2NvZGUgJiBlZGdlKSB7XHJcblx0XHRcdFx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRcdFx0XHRwLl9jb2RlID0gX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKGEpO1xyXG5cclxuXHRcdFx0Ly8gZWxzZSBpZiBiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZW50ZXJzIHRoZSBzY3JlZW4pXHJcblx0XHRcdH0gZWxzZSBpZiAoIShiLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRcdFx0cC5fY29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRwb2ludHMgPSBjbGlwcGVkUG9pbnRzO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxufVxyXG5cblxudmFyIFBvbHlVdGlsID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdGNsaXBQb2x5Z29uOiBjbGlwUG9seWdvblxufSk7XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAc2VjdGlvblxyXG4gKiBMZWFmbGV0IGNvbWVzIHdpdGggYSBzZXQgb2YgYWxyZWFkeSBkZWZpbmVkIFByb2plY3Rpb25zIG91dCBvZiB0aGUgYm94OlxyXG4gKlxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTG9uTGF0XHJcbiAqXHJcbiAqIEVxdWlyZWN0YW5ndWxhciwgb3IgUGxhdGUgQ2FycmVlIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IHNpbXBsZSBwcm9qZWN0aW9uLFxyXG4gKiBtb3N0bHkgdXNlZCBieSBHSVMgZW50aHVzaWFzdHMuIERpcmVjdGx5IG1hcHMgYHhgIGFzIGxvbmdpdHVkZSwgYW5kIGB5YCBhc1xyXG4gKiBsYXRpdHVkZS4gQWxzbyBzdWl0YWJsZSBmb3IgZmxhdCB3b3JsZHMsIGUuZy4gZ2FtZSBtYXBzLiBVc2VkIGJ5IHRoZVxyXG4gKiBgRVBTRzo0MzI2YCBhbmQgYFNpbXBsZWAgQ1JTLlxyXG4gKi9cclxuXHJcbnZhciBMb25MYXQgPSB7XHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMTgwLCAtOTBdLCBbMTgwLCA5MF0pXHJcbn07XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTWVyY2F0b3JcclxuICpcclxuICogRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCBtb3JlIGNvbXBsZXggdGhhbiBTcGhlcmljYWwgTWVyY2F0b3IuIEFzc3VtZXMgdGhhdCBFYXJ0aCBpcyBhbiBlbGxpcHNvaWQuIFVzZWQgYnkgdGhlIEVQU0c6MzM5NSBDUlMuXHJcbiAqL1xyXG5cclxudmFyIE1lcmNhdG9yID0ge1xyXG5cdFI6IDYzNzgxMzcsXHJcblx0Ul9NSU5PUjogNjM1Njc1Mi4zMTQyNDUxNzksXHJcblxyXG5cdGJvdW5kczogbmV3IEJvdW5kcyhbLTIwMDM3NTA4LjM0Mjc5LCAtMTU0OTY1NzAuNzM5NzJdLCBbMjAwMzc1MDguMzQyNzksIDE4NzY0NjU2LjIzMTM4XSksXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHkgPSBsYXRsbmcubGF0ICogZCxcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgY29uID0gZSAqIE1hdGguc2luKHkpO1xyXG5cclxuXHRcdHZhciB0cyA9IE1hdGgudGFuKE1hdGguUEkgLyA0IC0geSAvIDIpIC8gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHR5ID0gLXIgKiBNYXRoLmxvZyhNYXRoLm1heCh0cywgMUUtMTApKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGxhdGxuZy5sbmcgKiBkICogciwgeSk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSSxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICB0cyA9IE1hdGguZXhwKC1wb2ludC55IC8gciksXHJcblx0XHQgICAgcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgZHBoaSA9IDAuMSwgY29uOyBpIDwgMTUgJiYgTWF0aC5hYnMoZHBoaSkgPiAxZS03OyBpKyspIHtcclxuXHRcdFx0Y29uID0gZSAqIE1hdGguc2luKHBoaSk7XHJcblx0XHRcdGNvbiA9IE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0XHRkcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzICogY29uKSAtIHBoaTtcclxuXHRcdFx0cGhpICs9IGRwaGk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocGhpICogZCwgcG9pbnQueCAqIGQgLyByKTtcclxuXHR9XHJcbn07XG5cbi8qXG4gKiBAY2xhc3MgUHJvamVjdGlvblxuXG4gKiBBbiBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBwcm9qZWN0aW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgd29ybGQgb250b1xuICogYSBmbGF0IHN1cmZhY2UgKGFuZCBiYWNrKS4gU2VlIFtNYXAgcHJvamVjdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBfcHJvamVjdGlvbikuXG5cbiAqIEBwcm9wZXJ0eSBib3VuZHM6IEJvdW5kc1xuICogVGhlIGJvdW5kcyAoc3BlY2lmaWVkIGluIENSUyB1bml0cykgd2hlcmUgdGhlIHByb2plY3Rpb24gaXMgdmFsaWRcblxuICogQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcbiAqIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGEgMkQgcG9pbnQuXG4gKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gKiBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcbiAqIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC4gUHJvamVjdHMgYSAyRCBwb2ludCBpbnRvIGEgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLlxuICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gKiBOb3RlIHRoYXQgdGhlIHByb2plY3Rpb24gaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXG4gKiBhbmQgY2FuJ3QgYmUgaW5zdGFudGlhdGVkLiBBbHNvLCBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gdGhlbSxcbiAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxuXG4gKi9cblxuXG5cblxudmFyIGluZGV4ID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdExvbkxhdDogTG9uTGF0LFxuXHRNZXJjYXRvcjogTWVyY2F0b3IsXG5cdFNwaGVyaWNhbE1lcmNhdG9yOiBTcGhlcmljYWxNZXJjYXRvclxufSk7XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzMzOTVcclxuICpcclxuICogUmFyZWx5IHVzZWQgYnkgc29tZSBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBVc2VzIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICovXHJcbnZhciBFUFNHMzM5NSA9IGV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuXHRwcm9qZWN0aW9uOiBNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzQzMjZcclxuICpcclxuICogQSBjb21tb24gQ1JTIGFtb25nIEdJUyBlbnRodXNpYXN0cy4gVXNlcyBzaW1wbGUgRXF1aXJlY3Rhbmd1bGFyIHByb2plY3Rpb24uXHJcbiAqXHJcbiAqIExlYWZsZXQgMS4wLnggY29tcGxpZXMgd2l0aCB0aGUgW1RNUyBjb29yZGluYXRlIHNjaGVtZSBmb3IgRVBTRzo0MzI2XShodHRwczovL3dpa2kub3NnZW8ub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZV9TcGVjaWZpY2F0aW9uI2dsb2JhbC1nZW9kZXRpYyksXHJcbiAqIHdoaWNoIGlzIGEgYnJlYWtpbmcgY2hhbmdlIGZyb20gMC43LnggYmVoYXZpb3VyLiAgSWYgeW91IGFyZSB1c2luZyBhIGBUaWxlTGF5ZXJgXHJcbiAqIHdpdGggdGhpcyBDUlMsIGVuc3VyZSB0aGF0IHRoZXJlIGFyZSB0d28gMjU2eDI1NiBwaXhlbCB0aWxlcyBjb3ZlcmluZyB0aGVcclxuICogd2hvbGUgZWFydGggYXQgem9vbSBsZXZlbCB6ZXJvLCBhbmQgdGhhdCB0aGUgdGlsZSBjb29yZGluYXRlIG9yaWdpbiBpcyAoLTE4MCwrOTApLFxyXG4gKiBvciAoLTE4MCwtOTApIGZvciBgVGlsZUxheWVyYHMgd2l0aCBbdGhlIGB0bXNgIG9wdGlvbl0oI3RpbGVsYXllci10bXMpIHNldC5cclxuICovXHJcblxyXG52YXIgRVBTRzQzMjYgPSBleHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6NDMyNicsXHJcblx0cHJvamVjdGlvbjogTG9uTGF0LFxyXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEgLyAxODAsIDEsIC0xIC8gMTgwLCAwLjUpXHJcbn0pO1xuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuU2ltcGxlXG4gKlxuICogQSBzaW1wbGUgQ1JTIHRoYXQgbWFwcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIGludG8gYHhgIGFuZCBgeWAgZGlyZWN0bHkuXG4gKiBNYXkgYmUgdXNlZCBmb3IgbWFwcyBvZiBmbGF0IHN1cmZhY2VzIChlLmcuIGdhbWUgbWFwcykuIE5vdGUgdGhhdCB0aGUgYHlgXG4gKiBheGlzIHNob3VsZCBzdGlsbCBiZSBpbnZlcnRlZCAoZ29pbmcgZnJvbSBib3R0b20gdG8gdG9wKS4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAqIHNpbXBsZSBldWNsaWRlYW4gZGlzdGFuY2UuXG4gKi9cblxudmFyIFNpbXBsZSA9IGV4dGVuZCh7fSwgQ1JTLCB7XG5cdHByb2plY3Rpb246IExvbkxhdCxcblx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSwgMCwgLTEsIDApLFxuXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcblx0fSxcblxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjI7XG5cdH0sXG5cblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG5cdFx0dmFyIGR4ID0gbGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZyxcblx0XHQgICAgZHkgPSBsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0O1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdH0sXG5cblx0aW5maW5pdGU6IHRydWVcbn0pO1xuXG5DUlMuRWFydGggPSBFYXJ0aDtcbkNSUy5FUFNHMzM5NSA9IEVQU0czMzk1O1xuQ1JTLkVQU0czODU3ID0gRVBTRzM4NTc7XG5DUlMuRVBTRzkwMDkxMyA9IEVQU0c5MDA5MTM7XG5DUlMuRVBTRzQzMjYgPSBFUFNHNDMyNjtcbkNSUy5TaW1wbGUgPSBTaW1wbGU7XG5cbi8qXG4gKiBAY2xhc3MgTGF5ZXJcbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBAYWthIEwuTGF5ZXJcbiAqIEBha2EgSUxheWVyXG4gKlxuICogQSBzZXQgb2YgbWV0aG9kcyBmcm9tIHRoZSBMYXllciBiYXNlIGNsYXNzIHRoYXQgYWxsIExlYWZsZXQgbGF5ZXJzIHVzZS5cbiAqIEluaGVyaXRzIGFsbCBtZXRob2RzLCBvcHRpb25zIGFuZCBldmVudHMgZnJvbSBgTC5FdmVudGVkYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLm1hcmtlcihsYXRsbmcpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5hZGRUbyhtYXApO1xuICogbGF5ZXIucmVtb3ZlKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXZlbnQgYWRkOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIGFkZGVkIHRvIGEgbWFwXG4gKlxuICogQGV2ZW50IHJlbW92ZTogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBtYXBcbiAqL1xuXG5cbnZhciBMYXllciA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ292ZXJsYXlQYW5lJ1xuXHRcdC8vIEJ5IGRlZmF1bHQgdGhlIGxheWVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCdzIFtvdmVybGF5IHBhbmVdKCNtYXAtb3ZlcmxheXBhbmUpLiBPdmVycmlkaW5nIHRoaXMgb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGxheWVyIHRvIGJlIHBsYWNlZCBvbiBhbm90aGVyIHBhbmUgYnkgZGVmYXVsdC5cblx0XHRwYW5lOiAnb3ZlcmxheVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxuXHRcdC8vIFN0cmluZyB0byBiZSBzaG93biBpbiB0aGUgYXR0cmlidXRpb24gY29udHJvbCwgZS5nLiBcIsKpIE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzXCIuIEl0IGRlc2NyaWJlcyB0aGUgbGF5ZXIgZGF0YSBhbmQgaXMgb2Z0ZW4gYSBsZWdhbCBvYmxpZ2F0aW9uIHRvd2FyZHMgY29weXJpZ2h0IGhvbGRlcnMgYW5kIHRpbGUgcHJvdmlkZXJzLlxuXHRcdGF0dHJpYnV0aW9uOiBudWxsLFxuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdC8qIEBzZWN0aW9uXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZFRvKG1hcDogTWFwfExheWVyR3JvdXApOiB0aGlzXG5cdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXAgb3IgbGF5ZXIgZ3JvdXAuXG5cdCAqL1xuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShtYXA6IE1hcCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG5cdHJlbW92ZUZyb206IGZ1bmN0aW9uIChvYmopIHtcblx0XHRpZiAob2JqKSB7XG5cdFx0XHRvYmoucmVtb3ZlTGF5ZXIodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShuYW1lPyA6IFN0cmluZyk6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgcmVwcmVzZW50aW5nIHRoZSBuYW1lZCBwYW5lIG9uIHRoZSBtYXAuIElmIGBuYW1lYCBpcyBvbWl0dGVkLCByZXR1cm5zIHRoZSBwYW5lIGZvciB0aGlzIGxheWVyLlxuXHRnZXRQYW5lOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZShuYW1lID8gKHRoaXMub3B0aW9uc1tuYW1lXSB8fCBuYW1lKSA6IHRoaXMub3B0aW9ucy5wYW5lKTtcblx0fSxcblxuXHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0dGhpcy5fbWFwLl90YXJnZXRzW3N0YW1wKHRhcmdldEVsKV0gPSB0aGlzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHRkZWxldGUgdGhpcy5fbWFwLl90YXJnZXRzW3N0YW1wKHRhcmdldEVsKV07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbjogU3RyaW5nXG5cdC8vIFVzZWQgYnkgdGhlIGBhdHRyaWJ1dGlvbiBjb250cm9sYCwgcmV0dXJucyB0aGUgW2F0dHJpYnV0aW9uIG9wdGlvbl0oI2dyaWRsYXllci1hdHRyaWJ1dGlvbikuXG5cdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbjtcblx0fSxcblxuXHRfbGF5ZXJBZGQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IGUudGFyZ2V0O1xuXG5cdFx0Ly8gY2hlY2sgaW4gY2FzZSBsYXllciBnZXRzIGFkZGVkIGFuZCB0aGVuIHJlbW92ZWQgYmVmb3JlIHRoZSBtYXAgaXMgcmVhZHlcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcblxuXHRcdGlmICh0aGlzLmdldEV2ZW50cykge1xuXHRcdFx0dmFyIGV2ZW50cyA9IHRoaXMuZ2V0RXZlbnRzKCk7XG5cdFx0XHRtYXAub24oZXZlbnRzLCB0aGlzKTtcblx0XHRcdHRoaXMub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRtYXAub2ZmKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLm9uQWRkKG1hcCk7XG5cblx0XHRpZiAodGhpcy5nZXRBdHRyaWJ1dGlvbiAmJiBtYXAuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sLmFkZEF0dHJpYnV0aW9uKHRoaXMuZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5maXJlKCdhZGQnKTtcblx0XHRtYXAuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IHRoaXN9KTtcblx0fVxufSk7XG5cbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gKiBAdW5pbmhlcml0YWJsZVxuICpcbiAqIEV2ZXJ5IGxheWVyIHNob3VsZCBleHRlbmQgZnJvbSBgTC5MYXllcmAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cbiAqXG4gKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gY29kZSB0aGF0IGNyZWF0ZXMgRE9NIGVsZW1lbnRzIGZvciB0aGUgbGF5ZXIsIGFkZHMgdGhlbSB0byBgbWFwIHBhbmVzYCB3aGVyZSB0aGV5IHNob3VsZCBiZWxvbmcgYW5kIHB1dHMgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsYXllcidzIGVsZW1lbnRzIGZyb20gdGhlIERPTSBhbmQgcmVtb3ZlcyBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2xheWVyLW9uYWRkKS4gQ2FsbGVkIG9uIFtgbWFwLnJlbW92ZUxheWVyKGxheWVyKWBdKCNtYXAtcmVtb3ZlbGF5ZXIpLlxuICpcbiAqIEBtZXRob2QgZ2V0RXZlbnRzKCk6IE9iamVjdFxuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBvYmplY3QgbGlrZSBgeyB2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0IH1gIGZvciBbYGFkZEV2ZW50TGlzdGVuZXJgXSgjZXZlbnRlZC1hZGRldmVudGxpc3RlbmVyKS4gVGhlIGV2ZW50IGhhbmRsZXJzIGluIHRoaXMgb2JqZWN0IHdpbGwgYmUgYXV0b21hdGljYWxseSBhZGRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgd2l0aCB5b3VyIGxheWVyLlxuICpcbiAqIEBtZXRob2QgZ2V0QXR0cmlidXRpb24oKTogU3RyaW5nXG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgSFRNTCB0byBiZSBzaG93biBvbiB0aGUgYEF0dHJpYnV0aW9uIGNvbnRyb2xgIHdoZW5ldmVyIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICpcbiAqIEBtZXRob2QgYmVmb3JlQWRkKG1hcDogTWFwKTogdGhpc1xuICogT3B0aW9uYWwgbWV0aG9kLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllciksIGJlZm9yZSB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcCwgYmVmb3JlIGV2ZW50cyBhcmUgaW5pdGlhbGl6ZWQsIHdpdGhvdXQgd2FpdGluZyB1bnRpbCB0aGUgbWFwIGlzIGluIGEgdXNhYmxlIHN0YXRlLiBVc2UgZm9yIGVhcmx5IGluaXRpYWxpemF0aW9uIG9ubHkuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcFxuICogQHNlY3Rpb24gTGF5ZXIgZXZlbnRzXG4gKlxuICogQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIGEgbmV3IGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAuXG4gKlxuICogQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIHNvbWUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXBcbiAqXG4gKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG4gKi9cbk1hcC5pbmNsdWRlKHtcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBtYXBcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghbGF5ZXIuX2xheWVyQWRkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBvYmplY3QgaXMgbm90IGEgTGF5ZXIuJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGlkID0gc3RhbXAobGF5ZXIpO1xuXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG5cdFx0bGF5ZXIuX21hcFRvQWRkID0gdGhpcztcblxuXHRcdGlmIChsYXllci5iZWZvcmVBZGQpIHtcblx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLndoZW5SZWFkeShsYXllci5fbGF5ZXJBZGQsIGxheWVyKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBzdGFtcChsYXllcik7XG5cblx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdGxheWVyLm9uUmVtb3ZlKHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5nZXRBdHRyaWJ1dGlvbiAmJiB0aGlzLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wucmVtb3ZlQXR0cmlidXRpb24obGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xuXHRcdFx0bGF5ZXIuZmlyZSgncmVtb3ZlJyk7XG5cdFx0fVxuXG5cdFx0bGF5ZXIuX21hcCA9IGxheWVyLl9tYXBUb0FkZCA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgbWFwXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRyZXR1cm4gISFsYXllciAmJiAoc3RhbXAobGF5ZXIpIGluIHRoaXMuX2xheWVycyk7XG5cdH0sXG5cblx0LyogQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xuXHQgKiBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIG1hcCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuXHQgKiBgYGBcblx0ICogbWFwLmVhY2hMYXllcihmdW5jdGlvbihsYXllcil7XG5cdCAqICAgICBsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XG5cdCAqIH0pO1xuXHQgKiBgYGBcblx0ICovXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfYWRkTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XG5cdFx0bGF5ZXJzID0gbGF5ZXJzID8gKGlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF0pIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl96b29tQm91bmRMYXllcnNbaWRdO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlWm9vbUxldmVsczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtaW5ab29tID0gSW5maW5pdHksXG5cdFx0ICAgIG1heFpvb20gPSAtSW5maW5pdHksXG5cdFx0ICAgIG9sZFpvb21TcGFuID0gdGhpcy5fZ2V0Wm9vbVNwYW4oKTtcblxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fem9vbUJvdW5kTGF5ZXJzKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXS5vcHRpb25zO1xuXG5cdFx0XHRtaW5ab29tID0gb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyBtaW5ab29tIDogTWF0aC5taW4obWluWm9vbSwgb3B0aW9ucy5taW5ab29tKTtcblx0XHRcdG1heFpvb20gPSBvcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/IG1heFpvb20gOiBNYXRoLm1heChtYXhab29tLCBvcHRpb25zLm1heFpvb20pO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xheWVyc01heFpvb20gPSBtYXhab29tID09PSAtSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtYXhab29tO1xuXHRcdHRoaXMuX2xheWVyc01pblpvb20gPSBtaW5ab29tID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1pblpvb207XG5cblx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xuXHRcdC8vIEBldmVudCB6b29tbGV2ZWxzY2hhbmdlOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG51bWJlciBvZiB6b29tbGV2ZWxzIG9uIHRoZSBtYXAgaXMgY2hhbmdlZCBkdWVcblx0XHQvLyB0byBhZGRpbmcgb3IgcmVtb3ZpbmcgYSBsYXllci5cblx0XHRpZiAob2xkWm9vbVNwYW4gIT09IHRoaXMuX2dldFpvb21TcGFuKCkpIHtcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01heFpvb20gJiYgdGhpcy5nZXRab29tKCkgPiB0aGlzLl9sYXllcnNNYXhab29tKSB7XG5cdFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWF4Wm9vbSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01pblpvb20gJiYgdGhpcy5nZXRab29tKCkgPCB0aGlzLl9sYXllcnNNaW5ab29tKSB7XG5cdFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWluWm9vbSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLypcclxuICogQGNsYXNzIExheWVyR3JvdXBcclxuICogQGFrYSBMLkxheWVyR3JvdXBcclxuICogQGluaGVyaXRzIExheWVyXHJcbiAqXHJcbiAqIFVzZWQgdG8gZ3JvdXAgc2V2ZXJhbCBsYXllcnMgYW5kIGhhbmRsZSB0aGVtIGFzIG9uZS4gSWYgeW91IGFkZCBpdCB0byB0aGUgbWFwLFxyXG4gKiBhbnkgbGF5ZXJzIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgZ3JvdXAgd2lsbCBiZSBhZGRlZC9yZW1vdmVkIG9uIHRoZSBtYXAgYXNcclxuICogd2VsbC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmxheWVyR3JvdXAoW21hcmtlcjEsIG1hcmtlcjJdKVxyXG4gKiBcdC5hZGRMYXllcihwb2x5bGluZSlcclxuICogXHQuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIExheWVyR3JvdXAgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdHZhciBpLCBsZW47XHJcblxyXG5cdFx0aWYgKGxheWVycykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgZ3JvdXAuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIoaWQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBmcm9tIHRoZSBncm91cC5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSBsYXllciBpbiB0aGlzLl9sYXllcnMgPyBsYXllciA6IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiB0aGlzLl9sYXllcnNbaWRdKSB7XHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbaWRdKTtcclxuXHRcdH1cclxuXHJcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGlkOiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGludGVybmFsIElEIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0cmV0dXJuICEhbGF5ZXIgJiYgKGxheWVyIGluIHRoaXMuX2xheWVycyB8fCB0aGlzLmdldExheWVySWQobGF5ZXIpIGluIHRoaXMuX2xheWVycyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbGVhckxheWVycygpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbGwgdGhlIGxheWVycyBmcm9tIHRoZSBncm91cC5cclxuXHRjbGVhckxheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVtb3ZlTGF5ZXIsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52b2tlKG1ldGhvZE5hbWU6IFN0cmluZywg4oCmKTogdGhpc1xyXG5cdC8vIENhbGxzIGBtZXRob2ROYW1lYCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyBhbnlcclxuXHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEhhcyBubyBlZmZlY3QgaWYgdGhlIGxheWVycyBjb250YWluZWQgZG8gbm90XHJcblx0Ly8gaW1wbGVtZW50IGBtZXRob2ROYW1lYC5cclxuXHRpbnZva2U6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XHJcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcblx0XHQgICAgaSwgbGF5ZXI7XHJcblxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHJcblx0XHRcdGlmIChsYXllclttZXRob2ROYW1lXSkge1xyXG5cdFx0XHRcdGxheWVyW21ldGhvZE5hbWVdLmFwcGx5KGxheWVyLCBhcmdzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcihtYXAuYWRkTGF5ZXIsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5yZW1vdmVMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBncm91cCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxyXG5cdC8vIGBgYGpzXHJcblx0Ly8gZ3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdC8vIFx0bGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xyXG5cdC8vIH0pO1xyXG5cdC8vIGBgYFxyXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXIoaWQ6IE51bWJlcik6IExheWVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQuXHJcblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpZF07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcnMoKTogTGF5ZXJbXVxyXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBsYXllcnMgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGdldExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGxheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobGF5ZXJzLnB1c2gsIGxheWVycyk7XHJcblx0XHRyZXR1cm4gbGF5ZXJzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENhbGxzIGBzZXRaSW5kZXhgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIHRoZSB6LWluZGV4LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRaSW5kZXgnLCB6SW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJJZChsYXllcjogTGF5ZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBJRCBmb3IgYSBsYXllclxyXG5cdGdldExheWVySWQ6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0cmV0dXJuIHN0YW1wKGxheWVyKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF5ZXJHcm91cChsYXllcnM/OiBMYXllcltdLCBvcHRpb25zPzogT2JqZWN0KVxyXG4vLyBDcmVhdGUgYSBsYXllciBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbnZhciBsYXllckdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTGF5ZXJHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG59O1xuXG4vKlxyXG4gKiBAY2xhc3MgRmVhdHVyZUdyb3VwXHJcbiAqIEBha2EgTC5GZWF0dXJlR3JvdXBcclxuICogQGluaGVyaXRzIExheWVyR3JvdXBcclxuICpcclxuICogRXh0ZW5kZWQgYExheWVyR3JvdXBgIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIGRvIHRoZSBzYW1lIHRoaW5nIHRvIGFsbCBpdHMgbWVtYmVyIGxheWVyczpcclxuICogICogW2BiaW5kUG9wdXBgXSgjbGF5ZXItYmluZHBvcHVwKSBiaW5kcyBhIHBvcHVwIHRvIGFsbCBvZiB0aGUgbGF5ZXJzIGF0IG9uY2UgKGxpa2V3aXNlIHdpdGggW2BiaW5kVG9vbHRpcGBdKCNsYXllci1iaW5kdG9vbHRpcCkpXHJcbiAqICAqIEV2ZW50cyBhcmUgcHJvcGFnYXRlZCB0byB0aGUgYEZlYXR1cmVHcm91cGAsIHNvIGlmIHRoZSBncm91cCBoYXMgYW4gZXZlbnRcclxuICogaGFuZGxlciwgaXQgd2lsbCBoYW5kbGUgZXZlbnRzIGZyb20gYW55IG9mIHRoZSBsYXllcnMuIFRoaXMgaW5jbHVkZXMgbW91c2UgZXZlbnRzXHJcbiAqIGFuZCBjdXN0b20gZXZlbnRzLlxyXG4gKiAgKiBIYXMgYGxheWVyYWRkYCBhbmQgYGxheWVycmVtb3ZlYCBldmVudHNcclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5mZWF0dXJlR3JvdXAoW21hcmtlcjEsIG1hcmtlcjIsIHBvbHlsaW5lXSlcclxuICogXHQuYmluZFBvcHVwKCdIZWxsbyB3b3JsZCEnKVxyXG4gKiBcdC5vbignY2xpY2snLCBmdW5jdGlvbigpIHsgYWxlcnQoJ0NsaWNrZWQgb24gYSBtZW1iZXIgb2YgdGhlIGdyb3VwIScpOyB9KVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgRmVhdHVyZUdyb3VwID0gTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgYWRkZWQgdG8gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdExheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2l2ZW4gcGF0aCBvcHRpb25zIHRvIGVhY2ggbGF5ZXIgb2YgdGhlIGdyb3VwIHRoYXQgaGFzIGEgYHNldFN0eWxlYCBtZXRob2QuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0Zyb250Jyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgYmFjayBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0JhY2snKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBMYXRMbmdCb3VuZHMgb2YgdGhlIEZlYXR1cmUgR3JvdXAgKGNyZWF0ZWQgZnJvbSBib3VuZHMgYW5kIGNvb3JkaW5hdGVzIG9mIGl0cyBjaGlsZHJlbikuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xyXG5cclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdFx0XHRib3VuZHMuZXh0ZW5kKGxheWVyLmdldEJvdW5kcyA/IGxheWVyLmdldEJvdW5kcygpIDogbGF5ZXIuZ2V0TGF0TG5nKCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5mZWF0dXJlR3JvdXAobGF5ZXJzOiBMYXllcltdKVxyXG4vLyBDcmVhdGUgYSBmZWF0dXJlIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycy5cclxudmFyIGZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG59O1xuXG4vKlxyXG4gKiBAY2xhc3MgSWNvblxyXG4gKiBAYWthIEwuSWNvblxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGljb24gdG8gcHJvdmlkZSB3aGVuIGNyZWF0aW5nIGEgbWFya2VyLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbXlJY29uID0gTC5pY29uKHtcclxuICogICAgIGljb25Vcmw6ICdteS1pY29uLnBuZycsXHJcbiAqICAgICBpY29uUmV0aW5hVXJsOiAnbXktaWNvbkAyeC5wbmcnLFxyXG4gKiAgICAgaWNvblNpemU6IFszOCwgOTVdLFxyXG4gKiAgICAgaWNvbkFuY2hvcjogWzIyLCA5NF0sXHJcbiAqICAgICBwb3B1cEFuY2hvcjogWy0zLCAtNzZdLFxyXG4gKiAgICAgc2hhZG93VXJsOiAnbXktaWNvbi1zaGFkb3cucG5nJyxcclxuICogICAgIHNoYWRvd1JldGluYVVybDogJ215LWljb24tc2hhZG93QDJ4LnBuZycsXHJcbiAqICAgICBzaGFkb3dTaXplOiBbNjgsIDk1XSxcclxuICogICAgIHNoYWRvd0FuY2hvcjogWzIyLCA5NF1cclxuICogfSk7XHJcbiAqXHJcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBgTC5JY29uLkRlZmF1bHRgIGV4dGVuZHMgYEwuSWNvbmAgYW5kIGlzIHRoZSBibHVlIGljb24gTGVhZmxldCB1c2VzIGZvciBtYXJrZXJzIGJ5IGRlZmF1bHQuXHJcbiAqXHJcbiAqL1xyXG5cclxudmFyIEljb24gPSBDbGFzcy5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgSWNvbiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25Vcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiAqKihyZXF1aXJlZCkqKiBUaGUgVVJMIHRvIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyIHNjcmlwdCBwYXRoKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblJldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gYSByZXRpbmEgc2l6ZWQgdmVyc2lvbiBvZiB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91clxyXG5cdCAqIHNjcmlwdCBwYXRoKS4gVXNlZCBmb3IgUmV0aW5hIHNjcmVlbiBkZXZpY2VzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uU2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgaWNvbiBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25BbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgaWNvbiAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikuIFRoZSBpY29uXHJcblx0ICogd2lsbCBiZSBhbGlnbmVkIHNvIHRoYXQgdGhpcyBwb2ludCBpcyBhdCB0aGUgbWFya2VyJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLiBDZW50ZXJlZFxyXG5cdCAqIGJ5IGRlZmF1bHQgaWYgc2l6ZSBpcyBzcGVjaWZpZWQsIGFsc28gY2FuIGJlIHNldCBpbiBDU1Mgd2l0aCBuZWdhdGl2ZSBtYXJnaW5zLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb3B1cEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggcG9wdXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gdG9vbHRpcEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggdG9vbHRpcHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIHRoZSBpY29uIHNoYWRvdyBpbWFnZS4gSWYgbm90IHNwZWNpZmllZCwgbm8gc2hhZG93IGltYWdlIHdpbGwgYmUgY3JlYXRlZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93UmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1NpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIHNoYWRvdyBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd0FuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBzaGFkb3cgKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpICh0aGUgc2FtZVxyXG5cdCAqIGFzIGljb25BbmNob3IgaWYgbm90IHNwZWNpZmllZCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHQgKiBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byBib3RoIGljb24gYW5kIHNoYWRvdyBpbWFnZXMuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcblx0ICovXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvcHVwQW5jaG9yOiBbMCwgMF0sXHJcblx0XHR0b29sdGlwQW5jaG9yOiBbMCwgMF1cclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZUljb24ob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBpY29uIGhhcyB0byBiZSBzaG93biwgcmV0dXJucyBhIGA8aW1nPmAgSFRNTCBlbGVtZW50XHJcblx0Ly8gc3R5bGVkIGFjY29yZGluZyB0byB0aGUgb3B0aW9ucy5cclxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVNoYWRvdyhvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIEFzIGBjcmVhdGVJY29uYCwgYnV0IGZvciB0aGUgc2hhZG93IGJlbmVhdGggaXQuXHJcblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ3NoYWRvdycsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJY29uOiBmdW5jdGlvbiAobmFtZSwgb2xkSWNvbikge1xyXG5cdFx0dmFyIHNyYyA9IHRoaXMuX2dldEljb25VcmwobmFtZSk7XHJcblxyXG5cdFx0aWYgKCFzcmMpIHtcclxuXHRcdFx0aWYgKG5hbWUgPT09ICdpY29uJykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignaWNvblVybCBub3Qgc2V0IGluIEljb24gb3B0aW9ucyAoc2VlIHRoZSBkb2NzKS4nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdJTUcnID8gb2xkSWNvbiA6IG51bGwpO1xyXG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpO1xyXG5cclxuXHRcdHJldHVybiBpbWc7XHJcblx0fSxcclxuXHJcblx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdFx0dmFyIHNpemVPcHRpb24gPSBvcHRpb25zW25hbWUgKyAnU2l6ZSddO1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygc2l6ZU9wdGlvbiA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0c2l6ZU9wdGlvbiA9IFtzaXplT3B0aW9uLCBzaXplT3B0aW9uXTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2l6ZSA9IHRvUG9pbnQoc2l6ZU9wdGlvbiksXHJcblx0XHQgICAgYW5jaG9yID0gdG9Qb2ludChuYW1lID09PSAnc2hhZG93JyAmJiBvcHRpb25zLnNoYWRvd0FuY2hvciB8fCBvcHRpb25zLmljb25BbmNob3IgfHxcclxuXHRcdCAgICAgICAgICAgIHNpemUgJiYgc2l6ZS5kaXZpZGVCeSgyLCB0cnVlKSk7XHJcblxyXG5cdFx0aW1nLmNsYXNzTmFtZSA9ICdsZWFmbGV0LW1hcmtlci0nICsgbmFtZSArICcgJyArIChvcHRpb25zLmNsYXNzTmFtZSB8fCAnJyk7XHJcblxyXG5cdFx0aWYgKGFuY2hvcikge1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luTGVmdCA9ICgtYW5jaG9yLngpICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoLWFuY2hvci55KSArICdweCc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNpemUpIHtcclxuXHRcdFx0aW1nLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJbWc6IGZ1bmN0aW9uIChzcmMsIGVsKSB7XHJcblx0XHRlbCA9IGVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cdFx0ZWwuc3JjID0gc3JjO1xyXG5cdFx0cmV0dXJuIGVsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0cmV0dXJuIHJldGluYSAmJiB0aGlzLm9wdGlvbnNbbmFtZSArICdSZXRpbmFVcmwnXSB8fCB0aGlzLm9wdGlvbnNbbmFtZSArICdVcmwnXTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuaWNvbihvcHRpb25zOiBJY29uIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gaWNvbiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxyXG5mdW5jdGlvbiBpY29uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEljb24ob3B0aW9ucyk7XHJcbn1cblxuLypcbiAqIEBtaW5pY2xhc3MgSWNvbi5EZWZhdWx0IChJY29uKVxuICogQGFrYSBMLkljb24uRGVmYXVsdFxuICogQHNlY3Rpb25cbiAqXG4gKiBBIHRyaXZpYWwgc3ViY2xhc3Mgb2YgYEljb25gLCByZXByZXNlbnRzIHRoZSBpY29uIHRvIHVzZSBpbiBgTWFya2VyYHMgd2hlblxuICogbm8gaWNvbiBpcyBzcGVjaWZpZWQuIFBvaW50cyB0byB0aGUgYmx1ZSBtYXJrZXIgaW1hZ2UgZGlzdHJpYnV0ZWQgd2l0aCBMZWFmbGV0XG4gKiByZWxlYXNlcy5cbiAqXG4gKiBJbiBvcmRlciB0byBjdXN0b21pemUgdGhlIGRlZmF1bHQgaWNvbiwganVzdCBjaGFuZ2UgdGhlIHByb3BlcnRpZXMgb2YgYEwuSWNvbi5EZWZhdWx0LnByb3RvdHlwZS5vcHRpb25zYFxuICogKHdoaWNoIGlzIGEgc2V0IG9mIGBJY29uIG9wdGlvbnNgKS5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBfY29tcGxldGVseV8gcmVwbGFjZSB0aGUgZGVmYXVsdCBpY29uLCBvdmVycmlkZSB0aGVcbiAqIGBMLk1hcmtlci5wcm90b3R5cGUub3B0aW9ucy5pY29uYCB3aXRoIHlvdXIgb3duIGljb24gaW5zdGVhZC5cbiAqL1xuXG52YXIgSWNvbkRlZmF1bHQgPSBJY29uLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGljb25Vcmw6ICAgICAgICdtYXJrZXItaWNvbi5wbmcnLFxuXHRcdGljb25SZXRpbmFVcmw6ICdtYXJrZXItaWNvbi0yeC5wbmcnLFxuXHRcdHNoYWRvd1VybDogICAgICdtYXJrZXItc2hhZG93LnBuZycsXG5cdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuXHRcdGljb25BbmNob3I6ICBbMTIsIDQxXSxcblx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG5cdFx0dG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuXHRcdHNoYWRvd1NpemU6ICBbNDEsIDQxXVxuXHR9LFxuXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmICghSWNvbkRlZmF1bHQuaW1hZ2VQYXRoKSB7XHQvLyBEZXByZWNhdGVkLCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBvbmx5XG5cdFx0XHRJY29uRGVmYXVsdC5pbWFnZVBhdGggPSB0aGlzLl9kZXRlY3RJY29uUGF0aCgpO1xuXHRcdH1cblxuXHRcdC8vIEBvcHRpb24gaW1hZ2VQYXRoOiBTdHJpbmdcblx0XHQvLyBgSWNvbi5EZWZhdWx0YCB3aWxsIHRyeSB0byBhdXRvLWRldGVjdCB0aGUgbG9jYXRpb24gb2YgdGhlXG5cdFx0Ly8gYmx1ZSBpY29uIGltYWdlcy4gSWYgeW91IGFyZSBwbGFjaW5nIHRoZXNlIGltYWdlcyBpbiBhIG5vbi1zdGFuZGFyZFxuXHRcdC8vIHdheSwgc2V0IHRoaXMgb3B0aW9uIHRvIHBvaW50IHRvIHRoZSByaWdodCBwYXRoLlxuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLmltYWdlUGF0aCB8fCBJY29uRGVmYXVsdC5pbWFnZVBhdGgpICsgSWNvbi5wcm90b3R5cGUuX2dldEljb25VcmwuY2FsbCh0aGlzLCBuYW1lKTtcblx0fSxcblxuXHRfZGV0ZWN0SWNvblBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWwgPSBjcmVhdGUkMSgnZGl2JywgICdsZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoJywgZG9jdW1lbnQuYm9keSk7XG5cdFx0dmFyIHBhdGggPSBnZXRTdHlsZShlbCwgJ2JhY2tncm91bmQtaW1hZ2UnKSB8fFxuXHRcdCAgICAgICAgICAgZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kSW1hZ2UnKTtcdC8vIElFOFxuXG5cdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG5cblx0XHRpZiAocGF0aCA9PT0gbnVsbCB8fCBwYXRoLmluZGV4T2YoJ3VybCcpICE9PSAwKSB7XG5cdFx0XHRwYXRoID0gJyc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoL151cmxcXChbXCInXT8vLCAnJykucmVwbGFjZSgvbWFya2VyLWljb25cXC5wbmdbXCInXT9cXCkkLywgJycpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYXRoO1xuXHR9XG59KTtcblxuLypcbiAqIEwuSGFuZGxlci5NYXJrZXJEcmFnIGlzIHVzZWQgaW50ZXJuYWxseSBieSBMLk1hcmtlciB0byBtYWtlIHRoZSBtYXJrZXJzIGRyYWdnYWJsZS5cbiAqL1xuXG5cbi8qIEBuYW1lc3BhY2UgTWFya2VyXG4gKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBoYW5kbGVyc1xuICpcbiAqIEludGVyYWN0aW9uIGhhbmRsZXJzIGFyZSBwcm9wZXJ0aWVzIG9mIGEgbWFya2VyIGluc3RhbmNlIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2wgaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaCBhcyBkcmFnZ2luZyAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogbWFya2VyLmRyYWdnaW5nLmRpc2FibGUoKTtcbiAqIGBgYFxuICpcbiAqIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuICogTWFya2VyIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS4gT25seSB2YWxpZCB3aGVuIHRoZSBtYXJrZXIgaXMgb24gdGhlIG1hcCAoT3RoZXJ3aXNlIHNldCBbYG1hcmtlci5vcHRpb25zLmRyYWdnYWJsZWBdKCNtYXJrZXItZHJhZ2dhYmxlKSkuXG4gKi9cblxudmFyIE1hcmtlckRyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHR0aGlzLl9tYXJrZXIgPSBtYXJrZXI7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblxuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKGljb24sIGljb24sIHRydWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZW5hYmxlKCk7XG5cblx0XHRhZGRDbGFzcyhpY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9kcmFnZ2FibGUub2ZmKHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRwcmVkcmFnOiB0aGlzLl9vblByZURyYWcsXG5cdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHR9LCB0aGlzKS5kaXNhYmxlKCk7XG5cblx0XHRpZiAodGhpcy5fbWFya2VyLl9pY29uKSB7XG5cdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXJrZXIuX2ljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0XHR9XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG5cdH0sXG5cblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuXHRcdCAgICBtYXAgPSBtYXJrZXIuX21hcCxcblx0XHQgICAgc3BlZWQgPSB0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuU3BlZWQsXG5cdFx0ICAgIHBhZGRpbmcgPSB0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuUGFkZGluZyxcblx0XHQgICAgaWNvblBvcyA9IGdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGJvdW5kcyA9IG1hcC5nZXRQaXhlbEJvdW5kcygpLFxuXHRcdCAgICBvcmlnaW4gPSBtYXAuZ2V0UGl4ZWxPcmlnaW4oKTtcblxuXHRcdHZhciBwYW5Cb3VuZHMgPSB0b0JvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4uX3N1YnRyYWN0KG9yaWdpbikuYWRkKHBhZGRpbmcpLFxuXHRcdFx0Ym91bmRzLm1heC5fc3VidHJhY3Qob3JpZ2luKS5zdWJ0cmFjdChwYWRkaW5nKVxuXHRcdCk7XG5cblx0XHRpZiAoIXBhbkJvdW5kcy5jb250YWlucyhpY29uUG9zKSkge1xuXHRcdFx0Ly8gQ29tcHV0ZSBpbmNyZW1lbnRhbCBtb3ZlbWVudFxuXHRcdFx0dmFyIG1vdmVtZW50ID0gdG9Qb2ludChcblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5tYXgueCkgLyAoYm91bmRzLm1heC54IC0gcGFuQm91bmRzLm1heC54KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLngsIGljb25Qb3MueCkgLSBwYW5Cb3VuZHMubWluLngpIC8gKGJvdW5kcy5taW4ueCAtIHBhbkJvdW5kcy5taW4ueCksXG5cblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5tYXgueSkgLyAoYm91bmRzLm1heC55IC0gcGFuQm91bmRzLm1heC55KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWluLnkpIC8gKGJvdW5kcy5taW4ueSAtIHBhbkJvdW5kcy5taW4ueSlcblx0XHRcdCkubXVsdGlwbHlCeShzcGVlZCk7XG5cblx0XHRcdG1hcC5wYW5CeShtb3ZlbWVudCwge2FuaW1hdGU6IGZhbHNlfSk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLl9hZGQobW92ZW1lbnQpO1xuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5fYWRkKG1vdmVtZW50KTtcblxuXHRcdFx0c2V0UG9zaXRpb24obWFya2VyLl9pY29uLCB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcyk7XG5cdFx0XHR0aGlzLl9vbkRyYWcoZSk7XG5cblx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQHNlY3Rpb24gRHJhZ2dpbmcgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RhcnRzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cblx0XHR0aGlzLl9vbGRMYXRMbmcgPSB0aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCk7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5jbG9zZVBvcHVwKClcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcblx0fSxcblxuXHRfb25QcmVEcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuKSB7XG5cdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG5cdFx0XHR0aGlzLl9wYW5SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLCBlKSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHQgICAgc2hhZG93ID0gbWFya2VyLl9zaGFkb3csXG5cdFx0ICAgIGljb25Qb3MgPSBnZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuXHRcdCAgICBsYXRsbmcgPSBtYXJrZXIuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG5cblx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG5cdFx0aWYgKHNoYWRvdykge1xuXHRcdFx0c2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcblx0XHR9XG5cblx0XHRtYXJrZXIuX2xhdGxuZyA9IGxhdGxuZztcblx0XHRlLmxhdGxuZyA9IGxhdGxuZztcblx0XHRlLm9sZExhdExuZyA9IHRoaXMuX29sZExhdExuZztcblxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIG1hcmtlci5cblx0XHRtYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdCBjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG5cblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RvcHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblx0XHRkZWxldGUgdGhpcy5fb2xkTGF0TG5nO1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZWVuZCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnZW5kJywgZSk7XG5cdH1cbn0pO1xuXG4vKlxyXG4gKiBAY2xhc3MgTWFya2VyXHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKiBAYWthIEwuTWFya2VyXHJcbiAqIEwuTWFya2VyIGlzIHVzZWQgdG8gZGlzcGxheSBjbGlja2FibGUvZHJhZ2dhYmxlIGljb25zIG9uIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5tYXJrZXIoWzUwLjUsIDMwLjVdKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgTWFya2VyID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIE1hcmtlciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBpY29uOiBJY29uID0gKlxyXG5cdFx0Ly8gSWNvbiBpbnN0YW5jZSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbWFya2VyLlxyXG5cdFx0Ly8gU2VlIFtJY29uIGRvY3VtZW50YXRpb25dKCNMLkljb24pIGZvciBkZXRhaWxzIG9uIGhvdyB0byBjdXN0b21pemUgdGhlIG1hcmtlciBpY29uLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCwgYSBjb21tb24gaW5zdGFuY2Ugb2YgYEwuSWNvbi5EZWZhdWx0YCBpcyB1c2VkLlxyXG5cdFx0aWNvbjogbmV3IEljb25EZWZhdWx0KCksXHJcblxyXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xyXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBjYW4gYmUgdGFiYmVkIHRvIHdpdGggYSBrZXlib2FyZCBhbmQgY2xpY2tlZCBieSBwcmVzc2luZyBlbnRlci5cclxuXHRcdGtleWJvYXJkOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYnJvd3NlciB0b29sdGlwIHRoYXQgYXBwZWFyIG9uIG1hcmtlciBob3ZlciAobm8gdG9vbHRpcCBieSBkZWZhdWx0KS5cclxuXHRcdHRpdGxlOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGljb24gaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4T2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBtYXJrZXIgaW1hZ2VzIHpJbmRleCBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgbGF0aXR1ZGUuIFVzZSB0aGlzIG9wdGlvbiBpZiB5b3Ugd2FudCB0byBwdXQgdGhlIG1hcmtlciBvbiB0b3Agb2YgYWxsIG90aGVycyAob3IgYmVsb3cpLCBzcGVjaWZ5aW5nIGEgaGlnaCB2YWx1ZSBsaWtlIGAxMDAwYCAob3IgaGlnaCBuZWdhdGl2ZSB2YWx1ZSwgcmVzcGVjdGl2ZWx5KS5cclxuXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT25Ib3ZlcjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBtYXJrZXIgd2lsbCBnZXQgb24gdG9wIG9mIG90aGVycyB3aGVuIHlvdSBob3ZlciB0aGUgbW91c2Ugb3ZlciBpdC5cclxuXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPZmZzZXQ6IE51bWJlciA9IDI1MFxyXG5cdFx0Ly8gVGhlIHotaW5kZXggb2Zmc2V0IHVzZWQgZm9yIHRoZSBgcmlzZU9uSG92ZXJgIGZlYXR1cmUuXHJcblx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnbWFya2VyUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgaWNvbiB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3NoYWRvd1BhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIHNoYWRvdyB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0c2hhZG93UGFuZTogJ3NoYWRvd1BhbmUnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIG1hcmtlciB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxyXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXHJcblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBEcmFnZ2FibGUgbWFya2VyIG9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gZHJhZ2dhYmxlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXHJcblx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRvIHBhbiB0aGUgbWFwIHdoZW4gZHJhZ2dpbmcgdGhpcyBtYXJrZXIgbmVhciBpdHMgZWRnZSBvciBub3QuXHJcblx0XHRhdXRvUGFuOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUwLCA1MClcclxuXHRcdC8vIERpc3RhbmNlIChpbiBwaXhlbHMgdG8gdGhlIGxlZnQvcmlnaHQgYW5kIHRvIHRoZSB0b3AvYm90dG9tKSBvZiB0aGVcclxuXHRcdC8vIG1hcCBlZGdlIHRvIHN0YXJ0IHBhbm5pbmcgdGhlIG1hcC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNTAsIDUwXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5TcGVlZDogTnVtYmVyID0gMTBcclxuXHRcdC8vIE51bWJlciBvZiBwaXhlbHMgdGhlIG1hcCBzaG91bGQgcGFuIGJ5LlxyXG5cdFx0YXV0b1BhblNwZWVkOiAxMFxyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICpcclxuXHQgKiBJbiBhZGRpdGlvbiB0byBbc2hhcmVkIGxheWVyIG1ldGhvZHNdKCNMYXllcikgbGlrZSBgYWRkVG8oKWAgYW5kIGByZW1vdmUoKWAgYW5kIFtwb3B1cCBtZXRob2RzXSgjUG9wdXApIGxpa2UgYmluZFBvcHVwKCkgeW91IGNhbiBhbHNvIHVzZSB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmICh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nLnJlbW92ZUhvb2tzKCk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgdGhpcy5kcmFnZ2luZztcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0em9vbTogdGhpcy51cGRhdGUsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy51cGRhdGVcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBwb3NpdGlvbiB0byB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI21hcmtlci1zZXRsYXRsbmcpIG9yIGJ5IFtkcmFnZ2luZ10oI21hcmtlci1kcmFnZ2luZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleE9mZnNldChvZmZzZXQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4IG9mZnNldF0oI21hcmtlci16aW5kZXhvZmZzZXQpIG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0ID0gb2Zmc2V0O1xyXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRJY29uOiBJY29uXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBpY29uIHVzZWQgYnkgdGhlIG1hcmtlclxyXG5cdGdldEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldEljb24oaWNvbjogSWNvbik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgaWNvbi5cclxuXHRzZXRJY29uOiBmdW5jdGlvbiAoaWNvbikge1xyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLCB0aGlzLl9wb3B1cC5vcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faWNvbjtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbiAmJiB0aGlzLl9tYXApIHtcclxuXHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpO1xyXG5cdFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIGNsYXNzVG9BZGQgPSAnbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XHJcblxyXG5cdFx0dmFyIGljb24gPSBvcHRpb25zLmljb24uY3JlYXRlSWNvbih0aGlzLl9pY29uKSxcclxuXHRcdCAgICBhZGRJY29uID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gaWYgd2UncmUgbm90IHJldXNpbmcgdGhlIGljb24sIHJlbW92ZSB0aGUgb2xkIG9uZSBhbmQgaW5pdCBuZXcgb25lXHJcblx0XHRpZiAoaWNvbiAhPT0gdGhpcy5faWNvbikge1xyXG5cdFx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRhZGRJY29uID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLnRpdGxlKSB7XHJcblx0XHRcdFx0aWNvbi50aXRsZSA9IG9wdGlvbnMudGl0bGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChpY29uLnRhZ05hbWUgPT09ICdJTUcnKSB7XHJcblx0XHRcdFx0aWNvbi5hbHQgPSBvcHRpb25zLmFsdCB8fCAnJztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGFkZENsYXNzKGljb24sIGNsYXNzVG9BZGQpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmtleWJvYXJkKSB7XHJcblx0XHRcdGljb24udGFiSW5kZXggPSAnMCc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdTaGFkb3cgPSBvcHRpb25zLmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdyksXHJcblx0XHQgICAgYWRkU2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdyAhPT0gdGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdFx0XHRhZGRTaGFkb3cgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cpIHtcclxuXHRcdFx0YWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcclxuXHRcdFx0bmV3U2hhZG93LmFsdCA9ICcnO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbmV3U2hhZG93O1xyXG5cclxuXHJcblx0XHRpZiAob3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGlmIChhZGRJY29uKSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ljb24pO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5faW5pdEludGVyYWN0aW9uKCk7XHJcblx0XHRpZiAobmV3U2hhZG93ICYmIGFkZFNoYWRvdykge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUob3B0aW9ucy5zaGFkb3dQYW5lKS5hcHBlbmRDaGlsZCh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdHRoaXMub2ZmKHtcclxuXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmVtb3ZlKHRoaXMuX2ljb24pO1xyXG5cdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHR0aGlzLl9pY29uID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHJlbW92ZSh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfc2V0UG9zOiBmdW5jdGlvbiAocG9zKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0c2V0UG9zaXRpb24odGhpcy5faWNvbiwgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRhZGRDbGFzcyh0aGlzLl9pY29uLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cclxuXHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0aWYgKE1hcmtlckRyYWcpIHtcclxuXHRcdFx0dmFyIGRyYWdnYWJsZSA9IHRoaXMub3B0aW9ucy5kcmFnZ2FibGU7XHJcblx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcblx0XHRcdFx0ZHJhZ2dhYmxlID0gdGhpcy5kcmFnZ2luZy5lbmFibGVkKCk7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBuZXcgTWFya2VyRHJhZyh0aGlzKTtcclxuXHJcblx0XHRcdGlmIChkcmFnZ2FibGUpIHtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3BhY2l0eSA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdHNldE9wYWNpdHkodGhpcy5faWNvbiwgb3BhY2l0eSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHRzZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0UG9wdXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb29sdGlwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuXHJcbi8vIEBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBNYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5mdW5jdGlvbiBtYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcclxufVxuXG4vKlxuICogQGNsYXNzIFBhdGhcbiAqIEBha2EgTC5QYXRoXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcbiAqXG4gKiBBbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGNvbnRhaW5zIG9wdGlvbnMgYW5kIGNvbnN0YW50cyBzaGFyZWQgYmV0d2VlbiB2ZWN0b3JcbiAqIG92ZXJsYXlzIChQb2x5Z29uLCBQb2x5bGluZSwgQ2lyY2xlKS4gRG8gbm90IHVzZSBpdCBkaXJlY3RseS4gRXh0ZW5kcyBgTGF5ZXJgLlxuICovXG5cbnZhciBQYXRoID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBhdGggb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzdHJva2U6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hldGhlciB0byBkcmF3IHN0cm9rZSBhbG9uZyB0aGUgcGF0aC4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBib3JkZXJzIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0c3Ryb2tlOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBjb2xvcjogU3RyaW5nID0gJyMzMzg4ZmYnXG5cdFx0Ly8gU3Ryb2tlIGNvbG9yXG5cdFx0Y29sb3I6ICcjMzM4OGZmJyxcblxuXHRcdC8vIEBvcHRpb24gd2VpZ2h0OiBOdW1iZXIgPSAzXG5cdFx0Ly8gU3Ryb2tlIHdpZHRoIGluIHBpeGVsc1xuXHRcdHdlaWdodDogMyxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gU3Ryb2tlIG9wYWNpdHlcblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lQ2FwOiBTdHJpbmc9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGVuZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWNhcCkgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lQ2FwOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lSm9pbjogU3RyaW5nID0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgY29ybmVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWpvaW4pIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUpvaW46ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hBcnJheTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIFtkYXNoIHBhdHRlcm5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hhcnJheSkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoQXJyYXk6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hPZmZzZXQ6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIFtkaXN0YW5jZSBpbnRvIHRoZSBkYXNoIHBhdHRlcm4gdG8gc3RhcnQgdGhlIGRhc2hdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hvZmZzZXQpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaE9mZnNldDogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbDogQm9vbGVhbiA9IGRlcGVuZHNcblx0XHQvLyBXaGV0aGVyIHRvIGZpbGwgdGhlIHBhdGggd2l0aCBjb2xvci4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBmaWxsaW5nIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0ZmlsbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxDb2xvcjogU3RyaW5nID0gKlxuXHRcdC8vIEZpbGwgY29sb3IuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgW2Bjb2xvcmBdKCNwYXRoLWNvbG9yKSBvcHRpb25cblx0XHRmaWxsQ29sb3I6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxPcGFjaXR5OiBOdW1iZXIgPSAwLjJcblx0XHQvLyBGaWxsIG9wYWNpdHkuXG5cdFx0ZmlsbE9wYWNpdHk6IDAuMixcblxuXHRcdC8vIEBvcHRpb24gZmlsbFJ1bGU6IFN0cmluZyA9ICdldmVub2RkJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbaG93IHRoZSBpbnNpZGUgb2YgYSBzaGFwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9maWxsLXJ1bGUpIGlzIGRldGVybWluZWQuXG5cdFx0ZmlsbFJ1bGU6ICdldmVub2RkJyxcblxuXHRcdC8vIGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBwYXRoIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdC8vIFJlbmRlcmVyIGlzIHNldCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHJlbmRlcmVyLmdldEV2ZW50c1xuXHRcdC8vIGJlZm9yZSB0aGlzLmdldEV2ZW50cy5cblx0XHR0aGlzLl9yZW5kZXJlciA9IG1hcC5nZXRSZW5kZXJlcih0aGlzKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9pbml0UGF0aCh0aGlzKTtcblx0XHR0aGlzLl9yZXNldCgpO1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9hZGRQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3JlbW92ZVBhdGgodGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXcoKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSBsYXllci4gU29tZXRpbWVzIHVzZWZ1bCBhZnRlciB5b3UgY2hhbmdlZCB0aGUgY29vcmRpbmF0ZXMgdGhhdCB0aGUgcGF0aCB1c2VzLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUGF0aCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBhcHBlYXJhbmNlIG9mIGEgUGF0aCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBpbiB0aGUgYFBhdGggb3B0aW9uc2Agb2JqZWN0LlxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBzdHlsZSk7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlU3R5bGUodGhpcyk7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnN0cm9rZSAmJiBzdHlsZSAmJiBzdHlsZS5oYXNPd25Qcm9wZXJ0eSgnd2VpZ2h0JykpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0Zyb250KHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvQmFjayh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGRlZmluZWQgaW4gY2hpbGQgY2xhc3Nlc1xuXHRcdHRoaXMuX3Byb2plY3QoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfY2xpY2tUb2xlcmFuY2U6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB1c2VkIHdoZW4gZG9pbmcgaGl0IGRldGVjdGlvbiBmb3IgQ2FudmFzIGxheWVyc1xuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnN0cm9rZSA/IHRoaXMub3B0aW9ucy53ZWlnaHQgLyAyIDogMCkgKyB0aGlzLl9yZW5kZXJlci5vcHRpb25zLnRvbGVyYW5jZTtcblx0fVxufSk7XG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlTWFya2VyXG4gKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAqL1xuXG52YXIgQ2lyY2xlTWFya2VyID0gUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ2lyY2xlTWFya2VyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyID0gMTBcblx0XHQvLyBSYWRpdXMgb2YgdGhlIGNpcmNsZSBtYXJrZXIsIGluIHBpeGVsc1xuXHRcdHJhZGl1czogMTBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0TG5nOiBMYXRMbmcpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgY2lyY2xlIG1hcmtlciB0byBhIG5ldyBsb2NhdGlvbi5cblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMucmVkcmF3KCk7XG5cblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI2NpcmNsZW1hcmtlci1zZXRsYXRsbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUgbWFya2VyLiBVbml0cyBhcmUgaW4gcGl4ZWxzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLm9wdGlvbnMucmFkaXVzID0gdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiB0aGUgY2lyY2xlXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XG5cdH0sXG5cblx0c2V0U3R5bGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHZhciByYWRpdXMgPSBvcHRpb25zICYmIG9wdGlvbnMucmFkaXVzIHx8IHRoaXMuX3JhZGl1cztcblx0XHRQYXRoLnByb3RvdHlwZS5zZXRTdHlsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHIgPSB0aGlzLl9yYWRpdXMsXG5cdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IFtyICsgdywgcjIgKyB3XTtcblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ2lyY2xlKHRoaXMpO1xuXHR9LFxuXG5cdF9lbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXMgJiYgIXRoaXMuX3JlbmRlcmVyLl9ib3VuZHMuaW50ZXJzZWN0cyh0aGlzLl9weEJvdW5kcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbmZ1bmN0aW9uIGNpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBDaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcbn1cblxuLypcbiAqIEBjbGFzcyBDaXJjbGVcbiAqIEBha2EgTC5DaXJjbGVcbiAqIEBpbmhlcml0cyBDaXJjbGVNYXJrZXJcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIGNpcmNsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgQ2lyY2xlTWFya2VyYC5cbiAqXG4gKiBJdCdzIGFuIGFwcHJveGltYXRpb24gYW5kIHN0YXJ0cyB0byBkaXZlcmdlIGZyb20gYSByZWFsIGNpcmNsZSBjbG9zZXIgdG8gcG9sZXMgKGR1ZSB0byBwcm9qZWN0aW9uIGRpc3RvcnRpb24pLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY2lyY2xlKFs1MC41LCAzMC41XSwge3JhZGl1czogMjAwfSkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbnZhciBDaXJjbGUgPSBDaXJjbGVNYXJrZXIuZXh0ZW5kKHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBmYWN0b3J5IChsYXRsbmcsIHJhZGl1cywgb3B0aW9ucz8pXG5cdFx0XHRvcHRpb25zID0gZXh0ZW5kKHt9LCBsZWdhY3lPcHRpb25zLCB7cmFkaXVzOiBvcHRpb25zfSk7XG5cdFx0fVxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblxuXHRcdGlmIChpc05hTih0aGlzLm9wdGlvbnMucmFkaXVzKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0NpcmNsZSByYWRpdXMgY2Fubm90IGJlIE5hTicpOyB9XG5cblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgQ2lyY2xlIG9wdGlvbnNcblx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyOyBSYWRpdXMgb2YgdGhlIGNpcmNsZSwgaW4gbWV0ZXJzLlxuXHRcdHRoaXMuX21SYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuXHRcdHRoaXMuX21SYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbVJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBoYWxmID0gW3RoaXMuX3JhZGl1cywgdGhpcy5fcmFkaXVzWSB8fCB0aGlzLl9yYWRpdXNdO1xuXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LnN1YnRyYWN0KGhhbGYpKSxcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKGhhbGYpKSk7XG5cdH0sXG5cblx0c2V0U3R5bGU6IFBhdGgucHJvdG90eXBlLnNldFN0eWxlLFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbG5nID0gdGhpcy5fbGF0bG5nLmxuZyxcblx0XHQgICAgbGF0ID0gdGhpcy5fbGF0bG5nLmxhdCxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoY3JzLmRpc3RhbmNlID09PSBFYXJ0aC5kaXN0YW5jZSkge1xuXHRcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdFx0ICAgIGxhdFIgPSAodGhpcy5fbVJhZGl1cyAvIEVhcnRoLlIpIC8gZCxcblx0XHRcdCAgICB0b3AgPSBtYXAucHJvamVjdChbbGF0ICsgbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgYm90dG9tID0gbWFwLnByb2plY3QoW2xhdCAtIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIHAgPSB0b3AuYWRkKGJvdHRvbSkuZGl2aWRlQnkoMiksXG5cdFx0XHQgICAgbGF0MiA9IG1hcC51bnByb2plY3QocCkubGF0LFxuXHRcdFx0ICAgIGxuZ1IgPSBNYXRoLmFjb3MoKE1hdGguY29zKGxhdFIgKiBkKSAtIE1hdGguc2luKGxhdCAqIGQpICogTWF0aC5zaW4obGF0MiAqIGQpKSAvXG5cdFx0XHQgICAgICAgICAgICAoTWF0aC5jb3MobGF0ICogZCkgKiBNYXRoLmNvcyhsYXQyICogZCkpKSAvIGQ7XG5cblx0XHRcdGlmIChpc05hTihsbmdSKSB8fCBsbmdSID09PSAwKSB7XG5cdFx0XHRcdGxuZ1IgPSBsYXRSIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIGxhdCk7IC8vIEZhbGxiYWNrIGZvciBlZGdlIGNhc2UsICMyNDI1XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gcC5zdWJ0cmFjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSBpc05hTihsbmdSKSA/IDAgOiBwLnggLSBtYXAucHJvamVjdChbbGF0MiwgbG5nIC0gbG5nUl0pLng7XG5cdFx0XHR0aGlzLl9yYWRpdXNZID0gcC55IC0gdG9wLnk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxhdGxuZzIgPSBjcnMudW5wcm9qZWN0KGNycy5wcm9qZWN0KHRoaXMuX2xhdGxuZykuc3VidHJhY3QoW3RoaXMuX21SYWRpdXMsIDBdKSk7XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5fcG9pbnQueCAtIG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nMikueDtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9ucyBvYmplY3Rcbi8vIHdoaWNoIGNvbnRhaW5zIHRoZSBjaXJjbGUgcmFkaXVzLlxuLy8gQGFsdGVybmF0aXZlXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgcmFkaXVzOiBOdW1iZXIsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIE9ic29sZXRlIHdheSBvZiBpbnN0YW50aWF0aW5nIGEgY2lyY2xlLCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGNvZGUuXG4vLyBEbyBub3QgdXNlIGluIG5ldyBhcHBsaWNhdGlvbnMgb3IgcGx1Z2lucy5cbmZ1bmN0aW9uIGNpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBDaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKTtcbn1cblxuLypcbiAqIEBjbGFzcyBQb2x5bGluZVxuICogQGFrYSBMLlBvbHlsaW5lXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWxpbmUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBhdGhgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbNDUuNTEsIC0xMjIuNjhdLFxuICogXHRbMzcuNzcsIC0xMjIuNDNdLFxuICogXHRbMzQuMDQsIC0xMTguMl1cbiAqIF07XG4gKlxuICogdmFyIHBvbHlsaW5lID0gTC5wb2x5bGluZShsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlsaW5lXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlsaW5lLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgYE11bHRpUG9seWxpbmVgIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBhcnJheXMgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFtbNDUuNTEsIC0xMjIuNjhdLFxuICogXHQgWzM3Ljc3LCAtMTIyLjQzXSxcbiAqIFx0IFszNC4wNCwgLTExOC4yXV0sXG4gKiBcdFtbNDAuNzgsIC03My45MV0sXG4gKiBcdCBbNDEuODMsIC04Ny42Ml0sXG4gKiBcdCBbMzIuNzYsIC05Ni43Ml1dXG4gKiBdO1xuICogYGBgXG4gKi9cblxuXG52YXIgUG9seWxpbmUgPSBQYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBQb2x5bGluZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHNtb290aEZhY3RvcjogTnVtYmVyID0gMS4wXG5cdFx0Ly8gSG93IG11Y2ggdG8gc2ltcGxpZnkgdGhlIHBvbHlsaW5lIG9uIGVhY2ggem9vbSBsZXZlbC4gTW9yZSBtZWFuc1xuXHRcdC8vIGJldHRlciBwZXJmb3JtYW5jZSBhbmQgc21vb3RoZXIgbG9vaywgYW5kIGxlc3MgbWVhbnMgbW9yZSBhY2N1cmF0ZSByZXByZXNlbnRhdGlvbi5cblx0XHRzbW9vdGhGYWN0b3I6IDEuMCxcblxuXHRcdC8vIEBvcHRpb24gbm9DbGlwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBEaXNhYmxlIHBvbHlsaW5lIGNsaXBwaW5nLlxuXHRcdG5vQ2xpcDogZmFsc2Vcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZ3MoKTogTGF0TG5nW11cblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcG9pbnRzIGluIHRoZSBwYXRoLCBvciBuZXN0ZWQgYXJyYXlzIG9mIHBvaW50cyBpbiBjYXNlIG9mIG11bHRpLXBvbHlsaW5lLlxuXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZ3M7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmdzKGxhdGxuZ3M6IExhdExuZ1tdKTogdGhpc1xuXHQvLyBSZXBsYWNlcyBhbGwgdGhlIHBvaW50cyBpbiB0aGUgcG9seWxpbmUgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cy5cblx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNFbXB0eSgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBQb2x5bGluZSBoYXMgbm8gTGF0TG5ncy5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGg7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZXN0TGF5ZXJQb2ludChwOiBQb2ludCk6IFBvaW50XG5cdC8vIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYHBgIG9uIHRoZSBQb2x5bGluZS5cblx0Y2xvc2VzdExheWVyUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksXG5cdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcblx0XHQgICAgY2xvc2VzdCA9IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcblx0XHQgICAgcDEsIHAyO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcblx0XHRcdHZhciBwb2ludHMgPSB0aGlzLl9wYXJ0c1tqXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG5cdFx0XHRcdHAyID0gcG9pbnRzW2ldO1xuXG5cdFx0XHRcdHZhciBzcURpc3QgPSBjbG9zZXN0KHAsIHAxLCBwMiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBzcURpc3Q7XG5cdFx0XHRcdFx0bWluUG9pbnQgPSBjbG9zZXN0KHAsIHAxLCBwMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG1pblBvaW50KSB7XG5cdFx0XHRtaW5Qb2ludC5kaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZSk7XG5cdFx0fVxuXHRcdHJldHVybiBtaW5Qb2ludDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcG9seWxpbmUuXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cblx0XHR2YXIgaSwgaGFsZkRpc3QsIHNlZ0Rpc3QsIGRpc3QsIHAxLCBwMiwgcmF0aW8sXG5cdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuIG51bGw7IH1cblxuXHRcdC8vIHBvbHlsaW5lIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0Zm9yIChpID0gMCwgaGFsZkRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG5cdFx0XHRoYWxmRGlzdCArPSBwb2ludHNbaV0uZGlzdGFuY2VUbyhwb2ludHNbaSArIDFdKSAvIDI7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGxpbmUgaXMgc28gc21hbGwgaW4gdGhlIGN1cnJlbnQgdmlldyB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHRoZSBzYW1lIHBpeGVsLlxuXHRcdGlmIChoYWxmRGlzdCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcocG9pbnRzWzBdKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBkaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tpICsgMV07XG5cdFx0XHRzZWdEaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XG5cblx0XHRcdGlmIChkaXN0ID4gaGFsZkRpc3QpIHtcblx0XHRcdFx0cmF0aW8gPSAoZGlzdCAtIGhhbGZEaXN0KSAvIHNlZ0Rpc3Q7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKFtcblx0XHRcdFx0XHRwMi54IC0gcmF0aW8gKiAocDIueCAtIHAxLngpLFxuXHRcdFx0XHRcdHAyLnkgLSByYXRpbyAqIChwMi55IC0gcDEueSlcblx0XHRcdFx0XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZExhdExuZyhsYXRsbmc6IExhdExuZywgbGF0bG5ncz8gTGF0TG5nW10pOiB0aGlzXG5cdC8vIEFkZHMgYSBnaXZlbiBwb2ludCB0byB0aGUgcG9seWxpbmUuIEJ5IGRlZmF1bHQsIGFkZHMgdG8gdGhlIGZpcnN0IHJpbmcgb2Zcblx0Ly8gdGhlIHBvbHlsaW5lIGluIGNhc2Ugb2YgYSBtdWx0aS1wb2x5bGluZSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3Npbmdcblx0Ly8gYSBzcGVjaWZpYyByaW5nIGFzIGEgTGF0TG5nIGFycmF5ICh0aGF0IHlvdSBjYW4gZWFybGllciBhY2Nlc3Mgd2l0aCBbYGdldExhdExuZ3NgXSgjcG9seWxpbmUtZ2V0bGF0bG5ncykpLlxuXHRhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcblx0XHRsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9kZWZhdWx0U2hhcGUoKTtcblx0XHRsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xuXHRcdHRoaXMuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XG5cdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gaXNGbGF0KHRoaXMuX2xhdGxuZ3MpID8gdGhpcy5fbGF0bG5ncyA6IHRoaXMuX2xhdGxuZ3NbMF07XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgY29udmVydCBsYXRsbmdzIGlucHV0IGludG8gYWN0dWFsIExhdExuZyBpbnN0YW5jZXM7IGNhbGN1bGF0ZSBib3VuZHMgYWxvbmcgdGhlIHdheVxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdCAgICBmbGF0ID0gaXNGbGF0KGxhdGxuZ3MpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChmbGF0KSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKHJlc3VsdFtpXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Qm91bmRzID0gbmV3IEJvdW5kcygpO1xuXHRcdHRoaXMuX3JpbmdzID0gW107XG5cdFx0dGhpcy5fcHJvamVjdExhdGxuZ3ModGhpcy5fbGF0bG5ncywgdGhpcy5fcmluZ3MsIHB4Qm91bmRzKTtcblxuXHRcdGlmICh0aGlzLl9ib3VuZHMuaXNWYWxpZCgpICYmIHB4Qm91bmRzLmlzVmFsaWQoKSkge1xuXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMgPSBweEJvdW5kcztcblx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEJvdW5kcyhbXG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcy5taW4uc3VidHJhY3QocCksXG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcy5tYXguYWRkKHApXG5cdFx0XSk7XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgdHVybnMgbGF0bG5ncyBpbnRvIGEgc2V0IG9mIHJpbmdzIHdpdGggcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdF9wcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKSB7XG5cdFx0dmFyIGZsYXQgPSBsYXRsbmdzWzBdIGluc3RhbmNlb2YgTGF0TG5nLFxuXHRcdCAgICBsZW4gPSBsYXRsbmdzLmxlbmd0aCxcblx0XHQgICAgaSwgcmluZztcblxuXHRcdGlmIChmbGF0KSB7XG5cdFx0XHRyaW5nID0gW107XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmluZ1tpXSA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHByb2plY3RlZEJvdW5kcy5leHRlbmQocmluZ1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQucHVzaChyaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKGxhdGxuZ3NbaV0sIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gY2xpcCBwb2x5bGluZSBieSByZW5kZXJlciBib3VuZHMgc28gdGhhdCB3ZSBoYXZlIGxlc3MgdG8gcmVuZGVyIGZvciBwZXJmb3JtYW5jZVxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgaSwgaiwgaywgbGVuLCBsZW4yLCBzZWdtZW50LCBwb2ludHM7XG5cblx0XHRmb3IgKGkgPSAwLCBrID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBvaW50cyA9IHRoaXMuX3JpbmdzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjIgLSAxOyBqKyspIHtcblx0XHRcdFx0c2VnbWVudCA9IGNsaXBTZWdtZW50KHBvaW50c1tqXSwgcG9pbnRzW2ogKyAxXSwgYm91bmRzLCBqLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoIXNlZ21lbnQpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRwYXJ0c1trXSA9IHBhcnRzW2tdIHx8IFtdO1xuXHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMF0pO1xuXG5cdFx0XHRcdC8vIGlmIHNlZ21lbnQgZ29lcyBvdXQgb2Ygc2NyZWVuLCBvciBpdCdzIHRoZSBsYXN0IG9uZSwgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lIHBhcnRcblx0XHRcdFx0aWYgKChzZWdtZW50WzFdICE9PSBwb2ludHNbaiArIDFdKSB8fCAoaiA9PT0gbGVuMiAtIDIpKSB7XG5cdFx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzFdKTtcblx0XHRcdFx0XHRrKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gc2ltcGxpZnkgZWFjaCBjbGlwcGVkIHBhcnQgb2YgdGhlIHBvbHlsaW5lIGZvciBwZXJmb3JtYW5jZVxuXHRfc2ltcGxpZnlQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgdG9sZXJhbmNlID0gdGhpcy5vcHRpb25zLnNtb290aEZhY3RvcjtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydHNbaV0gPSBzaW1wbGlmeShwYXJ0c1tpXSwgdG9sZXJhbmNlKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY2xpcFBvaW50cygpO1xuXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XG5cdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHAsIGNsb3NlZCkge1xuXHRcdHZhciBpLCBqLCBrLCBsZW4sIGxlbjIsIHBhcnQsXG5cdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyBoaXQgZGV0ZWN0aW9uIGZvciBwb2x5bGluZXNcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0aWYgKHBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSkgPD0gdykge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwucG9seWxpbmUobGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgcG9seWxpbmUgb2JqZWN0IGdpdmVuIGFuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMgYW5kXG4vLyBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LiBZb3UgY2FuIGNyZWF0ZSBhIGBQb2x5bGluZWAgb2JqZWN0IHdpdGhcbi8vIG11bHRpcGxlIHNlcGFyYXRlIGxpbmVzIChgTXVsdGlQb2x5bGluZWApIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgYXJyYXlzXG4vLyBvZiBnZW9ncmFwaGljIHBvaW50cy5cbmZ1bmN0aW9uIHBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcbn1cblxuLy8gUmV0cm9jb21wYXQuIEFsbG93IHBsdWdpbnMgdG8gc3VwcG9ydCBMZWFmbGV0IHZlcnNpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgMS4xLlxuUG9seWxpbmUuX2ZsYXQgPSBfZmxhdDtcblxuLypcbiAqIEBjbGFzcyBQb2x5Z29uXG4gKiBAYWthIEwuUG9seWdvblxuICogQGluaGVyaXRzIFBvbHlsaW5lXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5Z29uIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5bGluZWAuXG4gKlxuICogTm90ZSB0aGF0IHBvaW50cyB5b3UgcGFzcyB3aGVuIGNyZWF0aW5nIGEgcG9seWdvbiBzaG91bGRuJ3QgaGF2ZSBhbiBhZGRpdGlvbmFsIGxhc3QgcG9pbnQgZXF1YWwgdG8gdGhlIGZpcnN0IG9uZSDigJQgaXQncyBiZXR0ZXIgdG8gZmlsdGVyIG91dCBzdWNoIHBvaW50cy5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlnb24gZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXTtcbiAqXG4gKiB2YXIgcG9seWdvbiA9IEwucG9seWdvbihsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlnb25cbiAqIG1hcC5maXRCb3VuZHMocG9seWdvbi5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgbGF0bG5ncywgd2l0aCB0aGUgZmlyc3QgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBvdXRlciBzaGFwZSBhbmQgdGhlIG90aGVyIGFycmF5cyByZXByZXNlbnRpbmcgaG9sZXMgaW4gdGhlIG91dGVyIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gKiAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gKiBdO1xuICogYGBgXG4gKlxuICogQWRkaXRpb25hbGx5LCB5b3UgY2FuIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBNdWx0aVBvbHlnb24gc2hhcGUuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbIC8vIGZpcnN0IHBvbHlnb25cbiAqICAgICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAqICAgICBbWzM3LjI5LCAtMTA4LjU4XSxbNDAuNzEsIC0xMDguNThdLFs0MC43MSwgLTEwMi41MF0sWzM3LjI5LCAtMTAyLjUwXV0gLy8gaG9sZVxuICogICBdLFxuICogICBbIC8vIHNlY29uZCBwb2x5Z29uXG4gKiAgICAgW1s0MSwgLTExMS4wM10sWzQ1LCAtMTExLjA0XSxbNDUsIC0xMDQuMDVdLFs0MSwgLTEwNC4wNV1dXG4gKiAgIF1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG52YXIgUG9seWdvbiA9IFBvbHlsaW5lLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWVcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aCB8fCAhdGhpcy5fbGF0bG5nc1swXS5sZW5ndGg7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblxuXHRcdHZhciBpLCBqLCBwMSwgcDIsIGYsIGFyZWEsIHgsIHksIGNlbnRlcixcblx0XHQgICAgcG9pbnRzID0gdGhpcy5fcmluZ3NbMF0sXG5cdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm4gbnVsbDsgfVxuXG5cdFx0Ly8gcG9seWdvbiBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGFyZWEgPSB4ID0geSA9IDA7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tqXTtcblxuXHRcdFx0ZiA9IHAxLnkgKiBwMi54IC0gcDIueSAqIHAxLng7XG5cdFx0XHR4ICs9IChwMS54ICsgcDIueCkgKiBmO1xuXHRcdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcblx0XHRcdGFyZWEgKz0gZiAqIDM7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZWEgPT09IDApIHtcblx0XHRcdC8vIFBvbHlnb24gaXMgc28gc21hbGwgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiBzYW1lIHBpeGVsLlxuXHRcdFx0Y2VudGVyID0gcG9pbnRzWzBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjZW50ZXIgPSBbeCAvIGFyZWEsIHkgLyBhcmVhXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoY2VudGVyKTtcblx0fSxcblxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcblx0XHQgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblxuXHRcdC8vIHJlbW92ZSBsYXN0IHBvaW50IGlmIGl0IGVxdWFscyBmaXJzdCBvbmVcblx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuXHRcdFx0cmVzdWx0LnBvcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdFBvbHlsaW5lLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xuXHRcdGlmIChpc0ZsYXQodGhpcy5fbGF0bG5ncykpIHtcblx0XHRcdHRoaXMuX2xhdGxuZ3MgPSBbdGhpcy5fbGF0bG5nc107XG5cdFx0fVxuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG5cdH0sXG5cblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwb2x5Z29ucyBuZWVkIGEgZGlmZmVyZW50IGNsaXBwaW5nIGFsZ29yaXRobSBzbyB3ZSByZWRlZmluZSB0aGF0XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcblx0XHQgICAgdyA9IHRoaXMub3B0aW9ucy53ZWlnaHQsXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cblx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG5cdFx0Ym91bmRzID0gbmV3IEJvdW5kcyhib3VuZHMubWluLnN1YnRyYWN0KHApLCBib3VuZHMubWF4LmFkZChwKSk7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGgsIGNsaXBwZWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y2xpcHBlZCA9IGNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMsIHRydWUpO1xuXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX3BhcnRzLnB1c2goY2xpcHBlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgaW5zaWRlID0gZmFsc2UsXG5cdFx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyByYXkgY2FzdGluZyBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBpZiBwb2ludCBpcyBpbiBwb2x5Z29uXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRcdHAxID0gcGFydFtqXTtcblx0XHRcdFx0cDIgPSBwYXJ0W2tdO1xuXG5cdFx0XHRcdGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG5cdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFsc28gY2hlY2sgaWYgaXQncyBvbiBwb2x5Z29uIHN0cm9rZVxuXHRcdHJldHVybiBpbnNpZGUgfHwgUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSk7XG5cdH1cblxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5wb2x5Z29uKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbmZ1bmN0aW9uIHBvbHlnb24obGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XG59XG5cbi8qXHJcbiAqIEBjbGFzcyBHZW9KU09OXHJcbiAqIEBha2EgTC5HZW9KU09OXHJcbiAqIEBpbmhlcml0cyBGZWF0dXJlR3JvdXBcclxuICpcclxuICogUmVwcmVzZW50cyBhIEdlb0pTT04gb2JqZWN0IG9yIGFuIGFycmF5IG9mIEdlb0pTT04gb2JqZWN0cy4gQWxsb3dzIHlvdSB0byBwYXJzZVxyXG4gKiBHZW9KU09OIGRhdGEgYW5kIGRpc3BsYXkgaXQgb24gdGhlIG1hcC4gRXh0ZW5kcyBgRmVhdHVyZUdyb3VwYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5nZW9KU09OKGRhdGEsIHtcclxuICogXHRzdHlsZTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICogXHRcdHJldHVybiB7Y29sb3I6IGZlYXR1cmUucHJvcGVydGllcy5jb2xvcn07XHJcbiAqIFx0fVxyXG4gKiB9KS5iaW5kUG9wdXAoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAqIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbjtcclxuICogfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIEdlb0pTT04gPSBGZWF0dXJlR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEdlb0pTT04gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb2ludFRvTGF5ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyBob3cgR2VvSlNPTiBwb2ludHMgc3Bhd24gTGVhZmxldCBsYXllcnMuIEl0IGlzIGludGVybmFsbHlcclxuXHQgKiBjYWxsZWQgd2hlbiBkYXRhIGlzIGFkZGVkLCBwYXNzaW5nIHRoZSBHZW9KU09OIHBvaW50IGZlYXR1cmUgYW5kIGl0cyBgTGF0TG5nYC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBzcGF3biBhIGRlZmF1bHQgYE1hcmtlcmA6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbihnZW9Kc29uUG9pbnQsIGxhdGxuZykge1xyXG5cdCAqIFx0cmV0dXJuIEwubWFya2VyKGxhdGxuZyk7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzdHlsZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIHRoZSBgUGF0aCBvcHRpb25zYCBmb3Igc3R5bGluZyBHZW9KU09OIGxpbmVzIGFuZCBwb2x5Z29ucyxcclxuXHQgKiBjYWxsZWQgaW50ZXJuYWxseSB3aGVuIGRhdGEgaXMgYWRkZWQuXHJcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdG8gbm90IG92ZXJyaWRlIGFueSBkZWZhdWx0czpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHt9XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBvbkVhY2hGZWF0dXJlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGNyZWF0ZWQgYEZlYXR1cmVgLCBhZnRlciBpdCBoYXNcclxuXHQgKiBiZWVuIGNyZWF0ZWQgYW5kIHN0eWxlZC4gVXNlZnVsIGZvciBhdHRhY2hpbmcgZXZlbnRzIGFuZCBwb3B1cHMgdG8gZmVhdHVyZXMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gZG8gbm90aGluZyB3aXRoIHRoZSBuZXdseSBjcmVhdGVkIGxheWVyczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChmZWF0dXJlLCBsYXllcikge31cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gZmlsdGVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG8gaW5jbHVkZSBhIGZlYXR1cmUgb3Igbm90LlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGluY2x1ZGUgYWxsIGZlYXR1cmVzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4gdHJ1ZTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICogTm90ZTogZHluYW1pY2FsbHkgY2hhbmdpbmcgdGhlIGBmaWx0ZXJgIG9wdGlvbiB3aWxsIGhhdmUgZWZmZWN0IG9ubHkgb24gbmV3bHlcclxuXHQgKiBhZGRlZCBkYXRhLiBJdCB3aWxsIF9ub3RfIHJlLWV2YWx1YXRlIGFscmVhZHkgaW5jbHVkZWQgZmVhdHVyZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNvb3Jkc1RvTGF0TG5nOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgR2VvSlNPTiBjb29yZGluYXRlcyB0byBgTGF0TG5nYHMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdGhlIGBjb29yZHNUb0xhdExuZ2Agc3RhdGljIG1ldGhvZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gbWFya2Vyc0luaGVyaXRPcHRpb25zOiBCb29sZWFuID0gZmFsc2VcclxuXHQgKiBXaGV0aGVyIGRlZmF1bHQgTWFya2VycyBmb3IgXCJQb2ludFwiIHR5cGUgRmVhdHVyZXMgaW5oZXJpdCBmcm9tIGdyb3VwIG9wdGlvbnMuXHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdGlmIChnZW9qc29uKSB7XHJcblx0XHRcdHRoaXMuYWRkRGF0YShnZW9qc29uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZERhdGEoIDxHZW9KU09OPiBkYXRhICk6IHRoaXNcclxuXHQvLyBBZGRzIGEgR2VvSlNPTiBvYmplY3QgdG8gdGhlIGxheWVyLlxyXG5cdGFkZERhdGE6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcblx0XHR2YXIgZmVhdHVyZXMgPSBpc0FycmF5KGdlb2pzb24pID8gZ2VvanNvbiA6IGdlb2pzb24uZmVhdHVyZXMsXHJcblx0XHQgICAgaSwgbGVuLCBmZWF0dXJlO1xyXG5cclxuXHRcdGlmIChmZWF0dXJlcykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdC8vIG9ubHkgYWRkIHRoaXMgaWYgZ2VvbWV0cnkgb3IgZ2VvbWV0cmllcyBhcmUgc2V0IGFuZCBub3QgbnVsbFxyXG5cdFx0XHRcdGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcclxuXHRcdFx0XHRpZiAoZmVhdHVyZS5nZW9tZXRyaWVzIHx8IGZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5mZWF0dXJlcyB8fCBmZWF0dXJlLmNvb3JkaW5hdGVzKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFkZERhdGEoZmVhdHVyZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmZpbHRlciAmJiAhb3B0aW9ucy5maWx0ZXIoZ2VvanNvbikpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgbGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucyk7XHJcblx0XHRpZiAoIWxheWVyKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0bGF5ZXIuZmVhdHVyZSA9IGFzRmVhdHVyZShnZW9qc29uKTtcclxuXHJcblx0XHRsYXllci5kZWZhdWx0T3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XHJcblx0XHR0aGlzLnJlc2V0U3R5bGUobGF5ZXIpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm9uRWFjaEZlYXR1cmUpIHtcclxuXHRcdFx0b3B0aW9ucy5vbkVhY2hGZWF0dXJlKGdlb2pzb24sIGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihsYXllcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZXNldFN0eWxlKCA8UGF0aD4gbGF5ZXI/ICk6IHRoaXNcclxuXHQvLyBSZXNldHMgdGhlIGdpdmVuIHZlY3RvciBsYXllcidzIHN0eWxlIHRvIHRoZSBvcmlnaW5hbCBHZW9KU09OIHN0eWxlLCB1c2VmdWwgZm9yIHJlc2V0dGluZyBzdHlsZSBhZnRlciBob3ZlciBldmVudHMuXHJcblx0Ly8gSWYgYGxheWVyYCBpcyBvbWl0dGVkLCB0aGUgc3R5bGUgb2YgYWxsIGZlYXR1cmVzIGluIHRoZSBjdXJyZW50IGxheWVyIGlzIHJlc2V0LlxyXG5cdHJlc2V0U3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVzZXRTdHlsZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0XHQvLyByZXNldCBhbnkgY3VzdG9tIHN0eWxlc1xyXG5cdFx0bGF5ZXIub3B0aW9ucyA9IGV4dGVuZCh7fSwgbGF5ZXIuZGVmYXVsdE9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgdGhpcy5vcHRpb25zLnN0eWxlKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoIDxGdW5jdGlvbj4gc3R5bGUgKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgc3R5bGVzIG9mIEdlb0pTT04gdmVjdG9yIGxheWVycyB3aXRoIHRoZSBnaXZlbiBzdHlsZSBmdW5jdGlvbi5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRMYXllclN0eWxlOiBmdW5jdGlvbiAobGF5ZXIsIHN0eWxlKSB7XHJcblx0XHRpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuR2VvSlNPTjpcclxuXHJcbi8vIEBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZmVhdHVyZURhdGE6IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucyk6IExheWVyXHJcbi8vIENyZWF0ZXMgYSBgTGF5ZXJgIGZyb20gYSBnaXZlbiBHZW9KU09OIGZlYXR1cmUuIENhbiB1c2UgYSBjdXN0b21cclxuLy8gW2Bwb2ludFRvTGF5ZXJgXSgjZ2VvanNvbi1wb2ludHRvbGF5ZXIpIGFuZC9vciBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbi8vIGZ1bmN0aW9ucyBpZiBwcm92aWRlZCBhcyBvcHRpb25zLlxyXG5mdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uLFxyXG5cdCAgICBjb29yZHMgPSBnZW9tZXRyeSA/IGdlb21ldHJ5LmNvb3JkaW5hdGVzIDogbnVsbCxcclxuXHQgICAgbGF5ZXJzID0gW10sXHJcblx0ICAgIHBvaW50VG9MYXllciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wb2ludFRvTGF5ZXIsXHJcblx0ICAgIF9jb29yZHNUb0xhdExuZyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZyxcclxuXHQgICAgbGF0bG5nLCBsYXRsbmdzLCBpLCBsZW47XHJcblxyXG5cdGlmICghY29vcmRzICYmICFnZW9tZXRyeSkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHRzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcclxuXHRjYXNlICdQb2ludCc6XHJcblx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzKTtcclxuXHRcdHJldHVybiBfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllciwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnTXVsdGlQb2ludCc6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkc1tpXSk7XHJcblx0XHRcdGxheWVycy5wdXNoKF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdGNhc2UgJ0xpbmVTdHJpbmcnOlxyXG5cdGNhc2UgJ011bHRpTGluZVN0cmluZyc6XHJcblx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnID8gMCA6IDEsIF9jb29yZHNUb0xhdExuZyk7XHJcblx0XHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdQb2x5Z29uJzpcclxuXHRjYXNlICdNdWx0aVBvbHlnb24nOlxyXG5cdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyA/IDEgOiAyLCBfY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR2YXIgbGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoe1xyXG5cdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeS5nZW9tZXRyaWVzW2ldLFxyXG5cdFx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdFx0XHRwcm9wZXJ0aWVzOiBnZW9qc29uLnByb3BlcnRpZXNcclxuXHRcdFx0fSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0XHRpZiAobGF5ZXIpIHtcclxuXHRcdFx0XHRsYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdGRlZmF1bHQ6XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllckZuLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gcG9pbnRUb0xheWVyRm4gP1xyXG5cdFx0cG9pbnRUb0xheWVyRm4oZ2VvanNvbiwgbGF0bG5nKSA6XHJcblx0XHRuZXcgTWFya2VyKGxhdGxuZywgb3B0aW9ucyAmJiBvcHRpb25zLm1hcmtlcnNJbmhlcml0T3B0aW9ucyAmJiBvcHRpb25zKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdgIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIDIgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSlcclxuLy8gb3IgMyBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlLCBhbHRpdHVkZSkgdXNlZCBpbiBHZW9KU09OIGZvciBwb2ludHMuXHJcbmZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3Jkcykge1xyXG5cdHJldHVybiBuZXcgTGF0TG5nKGNvb3Jkc1sxXSwgY29vcmRzWzBdLCBjb29yZHNbMl0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNvb3Jkc1RvTGF0TG5nPzogRnVuY3Rpb24pOiBBcnJheVxyXG4vLyBDcmVhdGVzIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBvZiBgTGF0TG5nYHMgZnJvbSBhIEdlb0pTT04gY29vcmRpbmF0ZXMgYXJyYXkuXHJcbi8vIGBsZXZlbHNEZWVwYCBzcGVjaWZpZXMgdGhlIG5lc3RpbmcgbGV2ZWwgKDAgaXMgZm9yIGFuIGFycmF5IG9mIHBvaW50cywgMSBmb3IgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBvaW50cywgZXRjLiwgMCBieSBkZWZhdWx0KS5cclxuLy8gQ2FuIHVzZSBhIGN1c3RvbSBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpIGZ1bmN0aW9uLlxyXG5mdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBsZXZlbHNEZWVwLCBfY29vcmRzVG9MYXRMbmcpIHtcclxuXHR2YXIgbGF0bG5ncyA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aCwgbGF0bG5nOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGxhdGxuZyA9IGxldmVsc0RlZXAgP1xyXG5cdFx0XHRjb29yZHNUb0xhdExuZ3MoY29vcmRzW2ldLCBsZXZlbHNEZWVwIC0gMSwgX2Nvb3Jkc1RvTGF0TG5nKSA6XHJcblx0XHRcdChfY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcpKGNvb3Jkc1tpXSk7XHJcblxyXG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbGF0bG5ncztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZzogTGF0TG5nLCBwcmVjaXNpb24/OiBOdW1iZXIpOiBBcnJheVxyXG4vLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nLCBwcmVjaXNpb24pIHtcclxuXHRwcmVjaXNpb24gPSB0eXBlb2YgcHJlY2lzaW9uID09PSAnbnVtYmVyJyA/IHByZWNpc2lvbiA6IDY7XHJcblx0cmV0dXJuIGxhdGxuZy5hbHQgIT09IHVuZGVmaW5lZCA/XHJcblx0XHRbZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIGZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pLCBmb3JtYXROdW0obGF0bG5nLmFsdCwgcHJlY2lzaW9uKV0gOlxyXG5cdFx0W2Zvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBmb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKV07XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5nczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNsb3NlZD86IEJvb2xlYW4pOiBBcnJheVxyXG4vLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdzYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmdzKVxyXG4vLyBgY2xvc2VkYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZpcnN0IHBvaW50IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSB0byBjbG9zZSB0aGUgZmVhdHVyZSwgb25seSB1c2VkIHdoZW4gYGxldmVsc0RlZXBgIGlzIDAuIEZhbHNlIGJ5IGRlZmF1bHQuXHJcbmZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzLCBsZXZlbHNEZWVwLCBjbG9zZWQsIHByZWNpc2lvbikge1xyXG5cdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGNvb3Jkcy5wdXNoKGxldmVsc0RlZXAgP1xyXG5cdFx0XHRsYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIGNsb3NlZCwgcHJlY2lzaW9uKSA6XHJcblx0XHRcdGxhdExuZ1RvQ29vcmRzKGxhdGxuZ3NbaV0sIHByZWNpc2lvbikpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFsZXZlbHNEZWVwICYmIGNsb3NlZCkge1xyXG5cdFx0Y29vcmRzLnB1c2goY29vcmRzWzBdKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb29yZHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEZlYXR1cmUobGF5ZXIsIG5ld0dlb21ldHJ5KSB7XHJcblx0cmV0dXJuIGxheWVyLmZlYXR1cmUgP1xyXG5cdFx0ZXh0ZW5kKHt9LCBsYXllci5mZWF0dXJlLCB7Z2VvbWV0cnk6IG5ld0dlb21ldHJ5fSkgOlxyXG5cdFx0YXNGZWF0dXJlKG5ld0dlb21ldHJ5KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTm9ybWFsaXplIEdlb0pTT04gZ2VvbWV0cmllcy9mZWF0dXJlcyBpbnRvIEdlb0pTT04gZmVhdHVyZXMuXHJcbmZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uKSB7XHJcblx0aWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnIHx8IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG5cdFx0cmV0dXJuIGdlb2pzb247XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0cHJvcGVydGllczoge30sXHJcblx0XHRnZW9tZXRyeTogZ2VvanNvblxyXG5cdH07XHJcbn1cclxuXHJcbnZhciBQb2ludFRvR2VvSlNPTiA9IHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ1BvaW50JyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGxhdExuZ1RvQ29vcmRzKHRoaXMuZ2V0TGF0TG5nKCksIHByZWNpc2lvbilcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFya2VyXHJcbi8vIEBzZWN0aW9uIE90aGVyIG1ldGhvZHNcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcbi8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG4vLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2IHBsYWNlcy5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbk1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ2lyY2xlTWFya2VyXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4vLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuQ2lyY2xlLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5DaXJjbGVNYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5bGluZVxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXIpOiBPYmplY3RcclxuLy8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcbi8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWxpbmUgKGFzIGEgR2VvSlNPTiBgTGluZVN0cmluZ2Agb3IgYE11bHRpTGluZVN0cmluZ2AgRmVhdHVyZSkuXHJcblBvbHlsaW5lLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIG11bHRpID0gIWlzRmxhdCh0aGlzLl9sYXRsbmdzKTtcclxuXHJcblx0XHR2YXIgY29vcmRzID0gbGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMSA6IDAsIGZhbHNlLCBwcmVjaXNpb24pO1xyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdMaW5lU3RyaW5nJyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWdvblxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXIpOiBPYmplY3RcclxuLy8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcbi8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWdvbiAoYXMgYSBHZW9KU09OIGBQb2x5Z29uYCBvciBgTXVsdGlQb2x5Z29uYCBGZWF0dXJlKS5cclxuUG9seWdvbi5pbmNsdWRlKHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBob2xlcyA9ICFpc0ZsYXQodGhpcy5fbGF0bG5ncyksXHJcblx0XHQgICAgbXVsdGkgPSBob2xlcyAmJiAhaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pO1xyXG5cclxuXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAyIDogaG9sZXMgPyAxIDogMCwgdHJ1ZSwgcHJlY2lzaW9uKTtcclxuXHJcblx0XHRpZiAoIWhvbGVzKSB7XHJcblx0XHRcdGNvb3JkcyA9IFtjb29yZHNdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdQb2x5Z29uJyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIExheWVyR3JvdXBcclxuTGF5ZXJHcm91cC5pbmNsdWRlKHtcclxuXHR0b011bHRpUG9pbnQ6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0Y29vcmRzLnB1c2gobGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbikuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnTXVsdGlQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG5cdC8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG5cdC8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG5cdC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllciBncm91cCAoYXMgYSBHZW9KU09OIGBGZWF0dXJlQ29sbGVjdGlvbmAsIGBHZW9tZXRyeUNvbGxlY3Rpb25gLCBvciBgTXVsdGlQb2ludGApLlxyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cclxuXHRcdHZhciB0eXBlID0gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvTXVsdGlQb2ludChwcmVjaXNpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxyXG5cdFx0ICAgIGpzb25zID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGlmIChsYXllci50b0dlb0pTT04pIHtcclxuXHRcdFx0XHR2YXIganNvbiA9IGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pO1xyXG5cdFx0XHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRcdFx0anNvbnMucHVzaChqc29uLmdlb21ldHJ5KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIGZlYXR1cmUgPSBhc0ZlYXR1cmUoanNvbik7XHJcblx0XHRcdFx0XHQvLyBTcXVhc2ggbmVzdGVkIGZlYXR1cmUgY29sbGVjdGlvbnNcclxuXHRcdFx0XHRcdGlmIChmZWF0dXJlLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuXHRcdFx0XHRcdFx0anNvbnMucHVzaC5hcHBseShqc29ucywgZmVhdHVyZS5mZWF0dXJlcyk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRqc29ucy5wdXNoKGZlYXR1cmUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0XHRnZW9tZXRyaWVzOiBqc29ucyxcclxuXHRcdFx0XHR0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxyXG5cdFx0XHRmZWF0dXJlczoganNvbnNcclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgR2VvSlNPTlxyXG4vLyBAZmFjdG9yeSBMLmdlb0pTT04oZ2VvanNvbj86IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIEdlb0pTT04gbGF5ZXIuIE9wdGlvbmFsbHkgYWNjZXB0cyBhbiBvYmplY3QgaW5cclxuLy8gW0dlb0pTT04gZm9ybWF0XShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzk0NikgdG8gZGlzcGxheSBvbiB0aGUgbWFwXHJcbi8vICh5b3UgY2FuIGFsdGVybmF0aXZlbHkgYWRkIGl0IGxhdGVyIHdpdGggYGFkZERhdGFgIG1ldGhvZCkgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbmZ1bmN0aW9uIGdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgR2VvSlNPTihnZW9qc29uLCBvcHRpb25zKTtcclxufVxyXG5cclxuLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxudmFyIGdlb0pzb24gPSBnZW9KU09OO1xuXG4vKlxyXG4gKiBAY2xhc3MgSW1hZ2VPdmVybGF5XHJcbiAqIEBha2EgTC5JbWFnZU92ZXJsYXlcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHNpbmdsZSBpbWFnZSBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBpbWFnZVVybCA9ICdodHRwOi8vd3d3LmxpYi51dGV4YXMuZWR1L21hcHMvaGlzdG9yaWNhbC9uZXdhcmtfbmpfMTkyMi5qcGcnLFxyXG4gKiBcdGltYWdlQm91bmRzID0gW1s0MC43MTIyMTYsIC03NC4yMjY1NV0sIFs0MC43NzM5NDEsIC03NC4xMjU0NF1dO1xyXG4gKiBMLmltYWdlT3ZlcmxheShpbWFnZVVybCwgaW1hZ2VCb3VuZHMpLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBJbWFnZU92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgSW1hZ2VPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgaW1hZ2Ugb3ZlcmxheSB3aWxsIGVtaXQgW21vdXNlIGV2ZW50c10oI2ludGVyYWN0aXZlLWxheWVyKSB3aGVuIGNsaWNrZWQgb3IgaG92ZXJlZC5cclxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgaW1hZ2UuXHJcblx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgdGhlIGltYWdlIHdpbGwgaGF2ZSBpdHMgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgaW1hZ2UgcGl4ZWwgZGF0YS5cclxuXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBlcnJvck92ZXJsYXlVcmw6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBVUkwgdG8gdGhlIG92ZXJsYXkgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgb3ZlcmxheSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG5cdFx0ZXJyb3JPdmVybGF5VXJsOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IFt6SW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4KSBvZiB0aGUgb3ZlcmxheSBsYXllci5cclxuXHRcdHpJbmRleDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBpbWFnZS4gRW1wdHkgYnkgZGVmYXVsdC5cclxuXHRcdGNsYXNzTmFtZTogJydcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgTGF0TG5nQm91bmRzLCBPYmplY3QpXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW5pdEltYWdlKCk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHRhZGRDbGFzcyh0aGlzLl9pbWFnZSwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cdFx0dGhpcy5fcmVzZXQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmVtb3ZlKHRoaXMuX2ltYWdlKTtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBvdmVybGF5LlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGVPcHRzKSB7XHJcblx0XHRpZiAoc3R5bGVPcHRzLm9wYWNpdHkpIHtcclxuXHRcdFx0dGhpcy5zZXRPcGFjaXR5KHN0eWxlT3B0cy5vcGFjaXR5KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0b0Zyb250KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dG9CYWNrKHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsKSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IHVybDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fcmVzZXQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXQsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHZhbHVlOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2ltYWdlb3ZlcmxheS16aW5kZXgpIG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdmFsdWU7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIEdldCB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTEltYWdlRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50KVxyXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdJTUcnO1xyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogY3JlYXRlJDEoJ2ltZycpO1xyXG5cclxuXHRcdGFkZENsYXNzKGltZywgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgYWRkQ2xhc3MoaW1nLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IGFkZENsYXNzKGltZywgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcblx0XHRpbWcub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XHJcblx0XHRpbWcub25tb3VzZW1vdmUgPSBmYWxzZUZuO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGhhcyBsb2FkZWQgaXRzIGltYWdlXHJcblx0XHRpbWcub25sb2FkID0gYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XHJcblx0XHRpbWcub25lcnJvciA9IGJpbmQodGhpcy5fb3ZlcmxheU9uRXJyb3IsIHRoaXMsICdlcnJvcicpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG5cdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcblx0XHRcdHRoaXMuX3VybCA9IGltZy5zcmM7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpbWcuc3JjID0gdGhpcy5fdXJsO1xyXG5cdFx0aW1nLmFsdCA9IHRoaXMub3B0aW9ucy5hbHQ7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZShlLnpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX21hcC5fbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyh0aGlzLl9ib3VuZHMsIGUuem9vbSwgZS5jZW50ZXIpLm1pbjtcclxuXHJcblx0XHRzZXRUcmFuc2Zvcm0odGhpcy5faW1hZ2UsIG9mZnNldCwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGltYWdlID0gdGhpcy5faW1hZ2UsXHJcblx0XHQgICAgYm91bmRzID0gbmV3IEJvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG5cdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXRTb3V0aEVhc3QoKSkpLFxyXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuXHRcdHNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcblx0XHRpbWFnZS5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0c2V0T3BhY2l0eSh0aGlzLl9pbWFnZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9pbWFnZSAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vdmVybGF5T25FcnJvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQGV2ZW50IGVycm9yOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGZhaWxzIHRvIGxvYWQgaXRzIGltYWdlXHJcblx0XHR0aGlzLmZpcmUoJ2Vycm9yJyk7XHJcblxyXG5cdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yT3ZlcmxheVVybDtcclxuXHRcdGlmIChlcnJvclVybCAmJiB0aGlzLl91cmwgIT09IGVycm9yVXJsKSB7XHJcblx0XHRcdHRoaXMuX3VybCA9IGVycm9yVXJsO1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSBlcnJvclVybDtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmw6IFN0cmluZywgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBJbWFnZU92ZXJsYXkgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIGltYWdlIGFuZCB0aGVcclxuLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG52YXIgaW1hZ2VPdmVybGF5ID0gZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBJbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59O1xuXG4vKlxyXG4gKiBAY2xhc3MgVmlkZW9PdmVybGF5XHJcbiAqIEBha2EgTC5WaWRlb092ZXJsYXlcclxuICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxyXG4gKlxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSB2aWRlbyBwbGF5ZXIgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cclxuICpcclxuICogQSB2aWRlbyBvdmVybGF5IHVzZXMgdGhlIFtgPHZpZGVvPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUTUwvRWxlbWVudC92aWRlbylcclxuICogSFRNTDUgZWxlbWVudC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHZpZGVvVXJsID0gJ2h0dHBzOi8vd3d3Lm1hcGJveC5jb20vYml0ZXMvMDAxODgvcGF0cmljaWFfbmFzYS53ZWJtJyxcclxuICogXHR2aWRlb0JvdW5kcyA9IFtbIDMyLCAtMTMwXSwgWyAxMywgLTEwMF1dO1xyXG4gKiBMLnZpZGVvT3ZlcmxheSh2aWRlb1VybCwgdmlkZW9Cb3VuZHMgKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgVmlkZW9PdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBWaWRlb092ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gYXV0b3BsYXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgcGxheWluZyBhdXRvbWF0aWNhbGx5IHdoZW4gbG9hZGVkLlxyXG5cdFx0YXV0b3BsYXk6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsb29wOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBsb29wIGJhY2sgdG8gdGhlIGJlZ2lubmluZyB3aGVuIHBsYXllZC5cclxuXHRcdGxvb3A6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZWVwQXNwZWN0UmF0aW86IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIHNhdmUgYXNwZWN0IHJhdGlvIGFmdGVyIHRoZSBwcm9qZWN0aW9uLlxyXG5cdFx0Ly8gUmVsZXZhbnQgZm9yIHN1cHBvcnRlZCBicm93c2Vycy4gQnJvd3NlciBjb21wYXRpYmlsaXR5LSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvb2JqZWN0LWZpdFxyXG5cdFx0a2VlcEFzcGVjdFJhdGlvOiB0cnVlXHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnVklERU8nO1xyXG5cdFx0dmFyIHZpZCA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogY3JlYXRlJDEoJ3ZpZGVvJyk7XHJcblxyXG5cdFx0YWRkQ2xhc3ModmlkLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBhZGRDbGFzcyh2aWQsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgYWRkQ2xhc3ModmlkLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxyXG5cclxuXHRcdHZpZC5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcclxuXHRcdHZpZC5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWRlbyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgZmlyc3QgZnJhbWVcclxuXHRcdHZpZC5vbmxvYWRlZGRhdGEgPSBiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHJcblx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcblx0XHRcdHZhciBzb3VyY2VFbGVtZW50cyA9IHZpZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJyk7XHJcblx0XHRcdHZhciBzb3VyY2VzID0gW107XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc291cmNlRWxlbWVudHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRzb3VyY2VzLnB1c2goc291cmNlRWxlbWVudHNbal0uc3JjKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fdXJsID0gKHNvdXJjZUVsZW1lbnRzLmxlbmd0aCA+IDApID8gc291cmNlcyA6IFt2aWQuc3JjXTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghaXNBcnJheSh0aGlzLl91cmwpKSB7IHRoaXMuX3VybCA9IFt0aGlzLl91cmxdOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMua2VlcEFzcGVjdFJhdGlvICYmIHZpZC5zdHlsZS5oYXNPd25Qcm9wZXJ0eSgnb2JqZWN0Rml0JykpIHsgdmlkLnN0eWxlWydvYmplY3RGaXQnXSA9ICdmaWxsJzsgfVxyXG5cdFx0dmlkLmF1dG9wbGF5ID0gISF0aGlzLm9wdGlvbnMuYXV0b3BsYXk7XHJcblx0XHR2aWQubG9vcCA9ICEhdGhpcy5vcHRpb25zLmxvb3A7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3VybC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgc291cmNlID0gY3JlYXRlJDEoJ3NvdXJjZScpO1xyXG5cdFx0XHRzb3VyY2Uuc3JjID0gdGhpcy5fdXJsW2ldO1xyXG5cdFx0XHR2aWQuYXBwZW5kQ2hpbGQoc291cmNlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MVmlkZW9FbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MVmlkZW9FbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxWaWRlb0VsZW1lbnQpXHJcblx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudmlkZW9PdmVybGF5KHZpZGVvOiBTdHJpbmd8QXJyYXl8SFRNTFZpZGVvRWxlbWVudCwgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBWaWRlb092ZXJsYXkgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIHZpZGVvIChvciBhcnJheSBvZiBVUkxzLCBvciBldmVuIGEgdmlkZW8gZWxlbWVudCkgYW5kIHRoZVxyXG4vLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcblxyXG5mdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59XG5cbi8qXG4gKiBAY2xhc3MgU1ZHT3ZlcmxheVxuICogQGFrYSBMLlNWR092ZXJsYXlcbiAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcbiAqXG4gKiBVc2VkIHRvIGxvYWQsIGRpc3BsYXkgYW5kIHByb3ZpZGUgRE9NIGFjY2VzcyB0byBhbiBTVkcgZmlsZSBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxuICpcbiAqIEFuIFNWRyBvdmVybGF5IHVzZXMgdGhlIFtgPHN2Zz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvRWxlbWVudC9zdmcpIGVsZW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogdmFyIHN2Z0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAqIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd4bWxucycsIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIik7XG4gKiBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFwiMCAwIDIwMCAyMDBcIik7XG4gKiBzdmdFbGVtZW50LmlubmVySFRNTCA9ICc8cmVjdCB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwMFwiLz48cmVjdCB4PVwiNzVcIiB5PVwiMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6cmVkXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIxMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6IzAwMTNmZlwiLz4nO1xuICogdmFyIHN2Z0VsZW1lbnRCb3VuZHMgPSBbIFsgMzIsIC0xMzAgXSwgWyAxMywgLTEwMCBdIF07XG4gKiBMLnN2Z092ZXJsYXkoc3ZnRWxlbWVudCwgc3ZnRWxlbWVudEJvdW5kcykuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbnZhciBTVkdPdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWwgPSB0aGlzLl9pbWFnZSA9IHRoaXMuX3VybDtcblxuXHRcdGFkZENsYXNzKGVsLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgYWRkQ2xhc3MoZWwsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IGFkZENsYXNzKGVsLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxuXG5cdFx0ZWwub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XG5cdFx0ZWwub25tb3VzZW1vdmUgPSBmYWxzZUZuO1xuXHR9XG5cblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IFNWR0VsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BTVkdFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5zdmdPdmVybGF5KHN2ZzogU3RyaW5nfFNWR0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogU1ZHT3ZlcmxheSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIGFuIFNWRyBlbGVtZW50IGFuZCB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxuLy8gQSB2aWV3Qm94IGF0dHJpYnV0ZSBpcyByZXF1aXJlZCBvbiB0aGUgU1ZHIGVsZW1lbnQgdG8gem9vbSBpbiBhbmQgb3V0IHByb3Blcmx5LlxuXG5mdW5jdGlvbiBzdmdPdmVybGF5KGVsLCBib3VuZHMsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTVkdPdmVybGF5KGVsLCBib3VuZHMsIG9wdGlvbnMpO1xufVxuXG4vKlxyXG4gKiBAY2xhc3MgRGl2T3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICogQGFrYSBMLkRpdk92ZXJsYXlcclxuICogQmFzZSBtb2RlbCBmb3IgTC5Qb3B1cCBhbmQgTC5Ub29sdGlwLiBJbmhlcml0IGZyb20gaXQgZm9yIGN1c3RvbSBwb3B1cCBsaWtlIHBsdWdpbnMuXHJcbiAqL1xyXG5cclxuLy8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbnZhciBEaXZPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIERpdk92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDcpXHJcblx0XHQvLyBUaGUgb2Zmc2V0IG9mIHRoZSBwb3B1cCBwb3NpdGlvbi4gVXNlZnVsIHRvIGNvbnRyb2wgdGhlIGFuY2hvclxyXG5cdFx0Ly8gb2YgdGhlIHBvcHVwIHdoZW4gb3BlbmluZyBpdCBvbiBzb21lIG92ZXJsYXlzLlxyXG5cdFx0b2Zmc2V0OiBbMCwgN10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxyXG5cdFx0Y2xhc3NOYW1lOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdwb3B1cFBhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBwb3B1cCB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ3BvcHVwUGFuZSdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZVRpbWVvdXQpO1xyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAxKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJyaW5nVG9Gcm9udCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVUaW1lb3V0ID0gc2V0VGltZW91dChiaW5kKHJlbW92ZSwgdW5kZWZpbmVkLCB0aGlzLl9jb250YWluZXIpLCAyMDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgb2YgcG9wdXAuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBvcGVuLlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHRcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwLlxyXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Q29udGVudChodG1sQ29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgcG9wdXAuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgcG9wdXAuXHJcblx0c2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gQWxpYXMgZm9yIFtnZXRDb250ZW50KCldKCNwb3B1cC1nZXRjb250ZW50KVxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1cGRhdGU6IG51bGxcclxuXHQvLyBVcGRhdGVzIHRoZSBwb3B1cCBjb250ZW50LCBsYXlvdXQgYW5kIHBvc2l0aW9uLiBVc2VmdWwgZm9yIHVwZGF0aW5nIHRoZSBwb3B1cCBhZnRlciBzb21ldGhpbmcgaW5zaWRlIGNoYW5nZWQsIGUuZy4gaW1hZ2UgbG9hZGVkLlxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcblx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XHJcblx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuXHJcblx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3VwZGF0ZVBvc2l0aW9uLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNPcGVuOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgcG9wdXAgaXMgdmlzaWJsZSBvbiB0aGUgbWFwLlxyXG5cdGlzT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGlzIHBvcHVwIGluIGZyb250IG9mIG90aGVyIHBvcHVwcyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgdG8gdGhlIGJhY2sgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcHJlcGFyZU9wZW46IGZ1bmN0aW9uIChwYXJlbnQsIGxheWVyLCBsYXRsbmcpIHtcclxuXHRcdGlmICghKGxheWVyIGluc3RhbmNlb2YgTGF5ZXIpKSB7XHJcblx0XHRcdGxhdGxuZyA9IGxheWVyO1xyXG5cdFx0XHRsYXllciA9IHBhcmVudDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApIHtcclxuXHRcdFx0Zm9yICh2YXIgaWQgaW4gcGFyZW50Ll9sYXllcnMpIHtcclxuXHRcdFx0XHRsYXllciA9IHBhcmVudC5fbGF5ZXJzW2lkXTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghbGF0bG5nKSB7XHJcblx0XHRcdGlmIChsYXllci5nZXRDZW50ZXIpIHtcclxuXHRcdFx0XHRsYXRsbmcgPSBsYXllci5nZXRDZW50ZXIoKTtcclxuXHRcdFx0fSBlbHNlIGlmIChsYXllci5nZXRMYXRMbmcpIHtcclxuXHRcdFx0XHRsYXRsbmcgPSBsYXllci5nZXRMYXRMbmcoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgc291cmNlIGxheWVyIExhdExuZy4nKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNldCBvdmVybGF5IHNvdXJjZSB0byB0aGlzIGxheWVyXHJcblx0XHR0aGlzLl9zb3VyY2UgPSBsYXllcjtcclxuXHJcblx0XHQvLyB1cGRhdGUgdGhlIG92ZXJsYXkgKGNvbnRlbnQsIGxheW91dCwgZWN0Li4uKVxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRlbnQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG5vZGUgPSB0aGlzLl9jb250ZW50Tm9kZTtcclxuXHRcdHZhciBjb250ZW50ID0gKHR5cGVvZiB0aGlzLl9jb250ZW50ID09PSAnZnVuY3Rpb24nKSA/IHRoaXMuX2NvbnRlbnQodGhpcy5fc291cmNlIHx8IHRoaXMpIDogdGhpcy5fY29udGVudDtcclxuXHJcblx0XHRpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG5vZGUuaW5uZXJIVE1MID0gY29udGVudDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xyXG5cdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRub2RlLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5maXJlKCdjb250ZW50dXBkYXRlJyk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuXHRcdCAgICBsZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueDtcclxuXHJcblx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIHBvcHVwIGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgY2hhbmdlcyAoaW1hZ2VzIGxvYWRpbmcgZXRjKVxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IGJvdHRvbSArICdweCc7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbMCwgMF07XHJcblx0fVxyXG5cclxufSk7XG5cbi8qXHJcbiAqIEBjbGFzcyBQb3B1cFxyXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxyXG4gKiBAYWthIEwuUG9wdXBcclxuICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gKiBvcGVuIHBvcHVwcyB3aGlsZSBtYWtpbmcgc3VyZSB0aGF0IG9ubHkgb25lIHBvcHVwIGlzIG9wZW4gYXQgb25lIHRpbWVcclxuICogKHJlY29tbWVuZGVkIGZvciB1c2FiaWxpdHkpLCBvciB1c2UgW01hcC5hZGRMYXllcl0oI21hcC1hZGRsYXllcikgdG8gb3BlbiBhcyBtYW55IGFzIHlvdSB3YW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICpcclxuICogYGBganNcclxuICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gKiBgYGBcclxuICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFBvcHVwYCBtZXRob2QuXHJcbiAqIEhlcmUncyBhIG1vcmUgY29tcGxpY2F0ZWQgd2F5IHRvIG9wZW4gYSBwb3B1cCBvbiBhIG1hcDpcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAqIFx0LnNldExhdExuZyhsYXRsbmcpXHJcbiAqIFx0LnNldENvbnRlbnQoJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gKiBcdC5vcGVuT24obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxudmFyIFBvcHVwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDMwMFxyXG5cdFx0Ly8gTWF4IHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWF4V2lkdGg6IDMwMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pbldpZHRoOiBOdW1iZXIgPSA1MFxyXG5cdFx0Ly8gTWluIHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWluV2lkdGg6IDUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4SGVpZ2h0OiBOdW1iZXIgPSBudWxsXHJcblx0XHQvLyBJZiBzZXQsIGNyZWF0ZXMgYSBzY3JvbGxhYmxlIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0XHJcblx0XHQvLyBpbnNpZGUgYSBwb3B1cCBpZiBpdHMgY29udGVudCBleGNlZWRzIGl0LlxyXG5cdFx0bWF4SGVpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gZG8gcGFubmluZyBhbmltYXRpb25cclxuXHRcdC8vIHRvIGZpdCB0aGUgb3BlbmVkIHBvcHVwLlxyXG5cdFx0YXV0b1BhbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUsIDUpXHJcblx0XHQvLyBFcXVpdmFsZW50IG9mIHNldHRpbmcgYm90aCB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGF1dG9wYW4gcGFkZGluZyB0byB0aGUgc2FtZSB2YWx1ZS5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNSwgNV0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZWVwSW5WaWV3OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFNldCBpdCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gcHJldmVudCB1c2VycyBmcm9tIHBhbm5pbmcgdGhlIHBvcHVwXHJcblx0XHQvLyBvZmYgb2YgdGhlIHNjcmVlbiB3aGlsZSBpdCBpcyBvcGVuLlxyXG5cdFx0a2VlcEluVmlldzogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZUJ1dHRvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIENvbnRyb2xzIHRoZSBwcmVzZW5jZSBvZiBhIGNsb3NlIGJ1dHRvbiBpbiB0aGUgcG9wdXAuXHJcblx0XHRjbG9zZUJ1dHRvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9DbG9zZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcblx0XHQvLyB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG5cdFx0YXV0b0Nsb3NlOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VPbkVzY2FwZUtleTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcblx0XHQvLyB0aGUgRVNDIGtleSBmb3IgY2xvc2luZyBvZiB0aGUgcG9wdXAuXHJcblx0XHRjbG9zZU9uRXNjYXBlS2V5OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VPbkNsaWNrOiBCb29sZWFuID0gKlxyXG5cdFx0Ly8gU2V0IGl0IGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gdXNlciBjbGlja3NcclxuXHRcdC8vIG9uIHRoZSBtYXAuIERlZmF1bHRzIHRvIHRoZSBtYXAncyBbYGNsb3NlUG9wdXBPbkNsaWNrYF0oI21hcC1jbG9zZXBvcHVwb25jbGljaykgb3B0aW9uLlxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuXHRcdGNsYXNzTmFtZTogJydcclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcblx0Ly8gQG1ldGhvZCBvcGVuT24obWFwOiBNYXApOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgcG9wdXAgdG8gdGhlIG1hcCBhbmQgY2xvc2VzIHRoZSBwcmV2aW91cyBvbmUuIFRoZSBzYW1lIGFzIGBtYXAub3BlblBvcHVwKHBvcHVwKWAuXHJcblx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub3BlblBvcHVwKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0Ly8gRm9yIG5vbi1wYXRoIGxheWVycywgd2UgdG9nZ2xlIHRoZSBwb3B1cCB3aGVuIGNsaWNraW5nXHJcblx0XHRcdC8vIGFnYWluIHRoZSBsYXllciwgc28gcHJldmVudCB0aGUgbWFwIHRvIHJlb3BlbiBpdC5cclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub24oJ3ByZWNsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpbiB0aGUgbWFwIGlzIGNsb3NlZFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vZmYoJ3ByZWNsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICE9PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdGV2ZW50cy5tb3ZlZW5kID0gdGhpcy5fYWRqdXN0UGFuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5jbG9zZVBvcHVwKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtcG9wdXAnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLFxyXG5cdFx0XHRwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgK1xyXG5cdFx0XHQnIGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cclxuXHRcdHZhciB3cmFwcGVyID0gdGhpcy5fd3JhcHBlciA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQtd3JhcHBlcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQnLCB3cmFwcGVyKTtcclxuXHJcblx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih3cmFwcGVyKTtcclxuXHRcdGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSk7XHJcblx0XHRvbih3cmFwcGVyLCAnY29udGV4dG1lbnUnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cclxuXHRcdHRoaXMuX3RpcENvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLXRpcC1jb250YWluZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fdGlwID0gY3JlYXRlJDEoJ2RpdicsIHByZWZpeCArICctdGlwJywgdGhpcy5fdGlwQ29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uKSB7XHJcblx0XHRcdHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuX2Nsb3NlQnV0dG9uID0gY3JlYXRlJDEoJ2EnLCBwcmVmaXggKyAnLWNsb3NlLWJ1dHRvbicsIGNvbnRhaW5lcik7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmhyZWYgPSAnI2Nsb3NlJztcclxuXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJyYjMjE1Oyc7XHJcblxyXG5cdFx0XHRvbihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgdGhpcy5fb25DbG9zZUJ1dHRvbkNsaWNrLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGVudE5vZGUsXHJcblx0XHQgICAgc3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAnJztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcclxuXHJcblx0XHR2YXIgd2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0XHR3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLm9wdGlvbnMubWF4V2lkdGgpO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICh3aWR0aCArIDEpICsgJ3B4JztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnJztcclxuXHJcblx0XHRzdHlsZS5oZWlnaHQgPSAnJztcclxuXHJcblx0XHR2YXIgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuXHRcdCAgICBtYXhIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0LFxyXG5cdFx0ICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCc7XHJcblxyXG5cdFx0aWYgKG1heEhlaWdodCAmJiBoZWlnaHQgPiBtYXhIZWlnaHQpIHtcclxuXHRcdFx0c3R5bGUuaGVpZ2h0ID0gbWF4SGVpZ2h0ICsgJ3B4JztcclxuXHRcdFx0YWRkQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlciksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblx0XHRzZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0fSxcclxuXHJcblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXV0b1BhbikgeyByZXR1cm47IH1cclxuXHRcdGlmICh0aGlzLl9tYXAuX3BhbkFuaW0pIHsgdGhpcy5fbWFwLl9wYW5BbmltLnN0b3AoKTsgfVxyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgbWFyZ2luQm90dG9tID0gcGFyc2VJbnQoZ2V0U3R5bGUodGhpcy5fY29udGFpbmVyLCAnbWFyZ2luQm90dG9tJyksIDEwKSB8fCAwLFxyXG5cdFx0ICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyBtYXJnaW5Cb3R0b20sXHJcblx0XHQgICAgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJXaWR0aCxcclxuXHRcdCAgICBsYXllclBvcyA9IG5ldyBQb2ludCh0aGlzLl9jb250YWluZXJMZWZ0LCAtY29udGFpbmVySGVpZ2h0IC0gdGhpcy5fY29udGFpbmVyQm90dG9tKTtcclxuXHJcblx0XHRsYXllclBvcy5fYWRkKGdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcikpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXJQb3MgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQobGF5ZXJQb3MpLFxyXG5cdFx0ICAgIHBhZGRpbmcgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ1RMID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdUb3BMZWZ0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgc2l6ZSA9IG1hcC5nZXRTaXplKCksXHJcblx0XHQgICAgZHggPSAwLFxyXG5cdFx0ICAgIGR5ID0gMDtcclxuXHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCArIHBhZGRpbmdCUi54ID4gc2l6ZS54KSB7IC8vIHJpZ2h0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCAtIHNpemUueCArIHBhZGRpbmdCUi54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54IC0gZHggLSBwYWRkaW5nVEwueCA8IDApIHsgLy8gbGVmdFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54IC0gcGFkZGluZ1RMLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgKyBwYWRkaW5nQlIueSA+IHNpemUueSkgeyAvLyBib3R0b21cclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55IC0gZHkgLSBwYWRkaW5nVEwueSA8IDApIHsgLy8gdG9wXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgLSBwYWRkaW5nVEwueTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgYXV0b3BhbnN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHN0YXJ0cyBhdXRvcGFubmluZyB3aGVuIG9wZW5pbmcgYSBwb3B1cC5cclxuXHRcdGlmIChkeCB8fCBkeSkge1xyXG5cdFx0XHRtYXBcclxuXHRcdFx0ICAgIC5maXJlKCdhdXRvcGFuc3RhcnQnKVxyXG5cdFx0XHQgICAgLnBhbkJ5KFtkeCwgZHldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25DbG9zZUJ1dHRvbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fY2xvc2UoKTtcclxuXHRcdHN0b3AoZSk7XHJcblx0fSxcclxuXHJcblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgcG9wdXAgb24gdGhlIHNvdXJjZSBsYXllcj9cclxuXHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yID8gdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvcigpIDogWzAsIDBdKTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxuLy8gQGZhY3RvcnkgTC5wb3B1cChvcHRpb25zPzogUG9wdXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXHJcbi8vIEluc3RhbnRpYXRlcyBhIGBQb3B1cGAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgcG9wdXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxyXG52YXIgcG9wdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0cmV0dXJuIG5ldyBQb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG59O1xyXG5cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICogQG9wdGlvbiBjbG9zZVBvcHVwT25DbGljazogQm9vbGVhbiA9IHRydWVcclxuICogU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgcG9wdXBzIHRvIGNsb3NlIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcC5cclxuICovXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKHBvcHVwOiBQb3B1cCk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHBvcHVwIHdoaWxlIGNsb3NpbmcgdGhlIHByZXZpb3VzbHkgb3BlbmVkICh0byBtYWtlIHN1cmUgb25seSBvbmUgaXMgb3BlbmVkIGF0IG9uZSB0aW1lIGZvciB1c2FiaWxpdHkpLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENyZWF0ZXMgYSBwb3B1cCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbnMgaXQgaW4gdGhlIGdpdmVuIHBvaW50IG9uIGEgbWFwLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdGlmICghKHBvcHVwIGluc3RhbmNlb2YgUG9wdXApKSB7XHJcblx0XHRcdHBvcHVwID0gbmV3IFBvcHVwKG9wdGlvbnMpLnNldENvbnRlbnQocG9wdXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXRsbmcpIHtcclxuXHRcdFx0cG9wdXAuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIocG9wdXApKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSkge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wb3B1cCA9IHBvcHVwO1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIocG9wdXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBvcGVuZWQgd2l0aCBbb3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgKG9yIHRoZSBnaXZlbiBvbmUpLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG5cdFx0aWYgKCFwb3B1cCB8fCBwb3B1cCA9PT0gdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cG9wdXAgPSB0aGlzLl9wb3B1cDtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHBvcHVwKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIocG9wdXApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICogQHNlY3Rpb24gUG9wdXAgbWV0aG9kcyBleGFtcGxlXHJcbiAqXHJcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICpcclxuICogYGBganNcclxuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICogbGF5ZXIub3BlblBvcHVwKCk7XHJcbiAqIGxheWVyLmNsb3NlUG9wdXAoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFBvcHVwcyB3aWxsIGFsc28gYmUgYXV0b21hdGljYWxseSBvcGVuZWQgd2hlbiB0aGUgbGF5ZXIgaXMgY2xpY2tlZCBvbiBhbmQgY2xvc2VkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIG9yIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG4gKi9cclxuXHJcbi8vIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHNcclxuTGF5ZXIuaW5jbHVkZSh7XHJcblxyXG5cdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQmluZHMgYSBwb3B1cCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcclxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxyXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxyXG5cdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIFBvcHVwKSB7XHJcblx0XHRcdHNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gY29udGVudDtcclxuXHRcdFx0Y29udGVudC5fc291cmNlID0gdGhpcztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICghdGhpcy5fcG9wdXAgfHwgb3B0aW9ucykge1xyXG5cdFx0XHRcdHRoaXMuX3BvcHVwID0gbmV3IFBvcHVwKG9wdGlvbnMsIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQpIHtcclxuXHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bmJpbmRQb3B1cCgpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kUG9wdXBgLlxyXG5cdHVuYmluZFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5vZmYoe1xyXG5cdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcblx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXHJcblx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIE9wZW5zIHRoZSBib3VuZCBwb3B1cCBhdCB0aGUgc3BlY2lmaWVkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHBvcHVwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAobGF5ZXIsIGxhdGxuZykge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX21hcCkge1xyXG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9wb3B1cC5fcHJlcGFyZU9wZW4odGhpcywgbGF5ZXIsIGxhdGxuZyk7XHJcblxyXG5cdFx0XHQvLyBvcGVuIHRoZSBwb3B1cCBvbiB0aGUgbWFwXHJcblx0XHRcdHRoaXMuX21hcC5vcGVuUG9wdXAodGhpcy5fcG9wdXAsIGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcclxuXHQvLyBDbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuX2Nsb3NlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvZ2dsZVBvcHVwKCk6IHRoaXNcclxuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxyXG5cdHRvZ2dsZVBvcHVwOiBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0aWYgKHRoaXMuX3BvcHVwLl9tYXApIHtcclxuXHRcdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLm9wZW5Qb3B1cCh0YXJnZXQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzUG9wdXBPcGVuKCk6IGJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cclxuXHRpc1BvcHVwT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICh0aGlzLl9wb3B1cCA/IHRoaXMuX3BvcHVwLmlzT3BlbigpIDogZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9wdXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxQb3B1cCk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxyXG5cdHNldFBvcHVwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQb3B1cCgpOiBQb3B1cFxyXG5cdC8vIFJldHVybnMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcblx0Z2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wb3B1cDtcclxuXHR9LFxyXG5cclxuXHRfb3BlblBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIGxheWVyID0gZS5sYXllciB8fCBlLnRhcmdldDtcclxuXHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcHJldmVudCBtYXAgY2xpY2tcclxuXHRcdHN0b3AoZSk7XHJcblxyXG5cdFx0Ly8gaWYgdGhpcyBpbmhlcml0cyBmcm9tIFBhdGggaXRzIGEgdmVjdG9yIGFuZCB3ZSBjYW4ganVzdFxyXG5cdFx0Ly8gb3BlbiB0aGUgcG9wdXAgYXQgdGhlIG5ldyBsb2NhdGlvblxyXG5cdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgUGF0aCkge1xyXG5cdFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxheWVyIHx8IGUudGFyZ2V0LCBlLmxhdGxuZyk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlcndpc2UgdHJlYXQgaXQgbGlrZSBhIG1hcmtlciBhbmQgZmlndXJlIG91dFxyXG5cdFx0Ly8gaWYgd2Ugc2hvdWxkIHRvZ2dsZSBpdCBvcGVuL2Nsb3NlZFxyXG5cdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcih0aGlzLl9wb3B1cCkgJiYgdGhpcy5fcG9wdXAuX3NvdXJjZSA9PT0gbGF5ZXIpIHtcclxuXHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm9wZW5Qb3B1cChsYXllciwgZS5sYXRsbmcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9tb3ZlUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdF9vbktleVByZXNzOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID09PSAxMykge1xyXG5cdFx0XHR0aGlzLl9vcGVuUG9wdXAoZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcblxuLypcbiAqIEBjbGFzcyBUb29sdGlwXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxuICogQGFrYSBMLlRvb2x0aXBcbiAqIFVzZWQgdG8gZGlzcGxheSBzbWFsbCB0ZXh0cyBvbiB0b3Agb2YgbWFwIGxheWVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuYmluZFRvb2x0aXAoXCJteSB0b29sdGlwIHRleHRcIikub3BlblRvb2x0aXAoKTtcbiAqIGBgYFxuICogTm90ZSBhYm91dCB0b29sdGlwIG9mZnNldC4gTGVhZmxldCB0YWtlcyB0d28gb3B0aW9ucyBpbiBjb25zaWRlcmF0aW9uXG4gKiBmb3IgY29tcHV0aW5nIHRvb2x0aXAgb2Zmc2V0dGluZzpcbiAqIC0gdGhlIGBvZmZzZXRgIFRvb2x0aXAgb3B0aW9uOiBpdCBkZWZhdWx0cyB0byBbMCwgMF0sIGFuZCBpdCdzIHNwZWNpZmljIHRvIG9uZSB0b29sdGlwLlxuICogICBBZGQgYSBwb3NpdGl2ZSB4IG9mZnNldCB0byBtb3ZlIHRoZSB0b29sdGlwIHRvIHRoZSByaWdodCwgYW5kIGEgcG9zaXRpdmUgeSBvZmZzZXQgdG9cbiAqICAgbW92ZSBpdCB0byB0aGUgYm90dG9tLiBOZWdhdGl2ZXMgd2lsbCBtb3ZlIHRvIHRoZSBsZWZ0IGFuZCB0b3AuXG4gKiAtIHRoZSBgdG9vbHRpcEFuY2hvcmAgSWNvbiBvcHRpb246IHRoaXMgd2lsbCBvbmx5IGJlIGNvbnNpZGVyZWQgZm9yIE1hcmtlci4gWW91XG4gKiAgIHNob3VsZCBhZGFwdCB0aGlzIHZhbHVlIGlmIHlvdSB1c2UgYSBjdXN0b20gaWNvbi5cbiAqL1xuXG5cbi8vIEBuYW1lc3BhY2UgVG9vbHRpcFxudmFyIFRvb2x0aXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBUb29sdGlwIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3Rvb2x0aXBQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHRvb2x0aXAgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndG9vbHRpcFBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcblx0XHQvLyBPcHRpb25hbCBvZmZzZXQgb2YgdGhlIHRvb2x0aXAgcG9zaXRpb24uXG5cdFx0b2Zmc2V0OiBbMCwgMF0sXG5cblx0XHQvLyBAb3B0aW9uIGRpcmVjdGlvbjogU3RyaW5nID0gJ2F1dG8nXG5cdFx0Ly8gRGlyZWN0aW9uIHdoZXJlIHRvIG9wZW4gdGhlIHRvb2x0aXAuIFBvc3NpYmxlIHZhbHVlcyBhcmU6IGByaWdodGAsIGBsZWZ0YCxcblx0XHQvLyBgdG9wYCwgYGJvdHRvbWAsIGBjZW50ZXJgLCBgYXV0b2AuXG5cdFx0Ly8gYGF1dG9gIHdpbGwgZHluYW1pY2FsbHkgc3dpdGNoIGJldHdlZW4gYHJpZ2h0YCBhbmQgYGxlZnRgIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcFxuXHRcdC8vIHBvc2l0aW9uIG9uIHRoZSBtYXAuXG5cdFx0ZGlyZWN0aW9uOiAnYXV0bycsXG5cblx0XHQvLyBAb3B0aW9uIHBlcm1hbmVudDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0byBvcGVuIHRoZSB0b29sdGlwIHBlcm1hbmVudGx5IG9yIG9ubHkgb24gbW91c2VvdmVyLlxuXHRcdHBlcm1hbmVudDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHN0aWNreTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBmb2xsb3cgdGhlIG1vdXNlIGluc3RlYWQgb2YgYmVpbmcgZml4ZWQgYXQgdGhlIGZlYXR1cmUgY2VudGVyLlxuXHRcdHN0aWNreTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGxpc3RlbiB0byB0aGUgZmVhdHVyZSBldmVudHMuXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAwLjlcblx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBvcGFjaXR5LlxuXHRcdG9wYWNpdHk6IDAuOVxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuXHRcdHRoaXMuc2V0T3BhY2l0eSh0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpcyBvcGVuZWQgaW4gdGhlIG1hcC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGluIHRoZSBtYXAgaXMgY2xvc2VkLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKHRvdWNoICYmICF0aGlzLm9wdGlvbnMucGVybWFuZW50KSB7XG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLl9jbG9zZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9jbG9zZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX21hcC5jbG9zZVRvb2x0aXAodGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXRvb2x0aXAnLFxuXHRcdCAgICBjbGFzc05hbWUgPSBwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgKyAnIGxlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xuXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSB0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lKTtcblx0fSxcblxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfc2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3MpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIGNlbnRlclBvaW50ID0gbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobWFwLmdldENlbnRlcigpKSxcblx0XHQgICAgdG9vbHRpcFBvaW50ID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvcyksXG5cdFx0ICAgIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24sXG5cdFx0ICAgIHRvb2x0aXBXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcblx0XHQgICAgdG9vbHRpcEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG5cdFx0ICAgIG9mZnNldCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xuXG5cdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdHBvcyA9IHBvcy5hZGQodG9Qb2ludCgtdG9vbHRpcFdpZHRoIC8gMiArIG9mZnNldC54LCAtdG9vbHRpcEhlaWdodCArIG9mZnNldC55ICsgYW5jaG9yLnksIHRydWUpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHRvb2x0aXBXaWR0aCAvIDIgLSBvZmZzZXQueCwgLW9mZnNldC55LCB0cnVlKSk7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludCh0b29sdGlwV2lkdGggLyAyICsgb2Zmc2V0LngsIHRvb2x0aXBIZWlnaHQgLyAyIC0gYW5jaG9yLnkgKyBvZmZzZXQueSwgdHJ1ZSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnIHx8IGRpcmVjdGlvbiA9PT0gJ2F1dG8nICYmIHRvb2x0aXBQb2ludC54IDwgY2VudGVyUG9pbnQueCkge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ3JpZ2h0Jztcblx0XHRcdHBvcyA9IHBvcy5hZGQodG9Qb2ludChvZmZzZXQueCArIGFuY2hvci54LCBhbmNob3IueSAtIHRvb2x0aXBIZWlnaHQgLyAyICsgb2Zmc2V0LnksIHRydWUpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ2xlZnQnO1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQodG9vbHRpcFdpZHRoICsgYW5jaG9yLnggLSBvZmZzZXQueCwgdG9vbHRpcEhlaWdodCAvIDIgLSBhbmNob3IueSAtIG9mZnNldC55LCB0cnVlKSk7XG5cdFx0fVxuXG5cdFx0cmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXJpZ2h0Jyk7XG5cdFx0cmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWxlZnQnKTtcblx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtdG9wJyk7XG5cdFx0cmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWJvdHRvbScpO1xuXHRcdGFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC0nICsgZGlyZWN0aW9uKTtcblx0XHRzZXRQb3NpdGlvbihjb250YWluZXIsIHBvcyk7XG5cdH0sXG5cblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIG9wYWNpdHkpO1xuXHRcdH1cblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlcik7XG5cdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcblx0fSxcblxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgdG9vbHRpcCBvbiB0aGUgc291cmNlIGxheWVyP1xuXHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IgJiYgIXRoaXMub3B0aW9ucy5zdGlja3kgPyB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IoKSA6IFswLCAwXSk7XG5cdH1cblxufSk7XG5cbi8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuLy8gQGZhY3RvcnkgTC50b29sdGlwKG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxuLy8gSW5zdGFudGlhdGVzIGEgVG9vbHRpcCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSB0b29sdGlwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cbnZhciB0b29sdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuXHRyZXR1cm4gbmV3IFRvb2x0aXAob3B0aW9ucywgc291cmNlKTtcbn07XG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG5NYXAuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHRvb2x0aXAuXG5cdC8vIEBhbHRlcm5hdGl2ZVxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENyZWF0ZXMgYSB0b29sdGlwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVuIGl0LlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucykge1xuXHRcdGlmICghKHRvb2x0aXAgaW5zdGFuY2VvZiBUb29sdGlwKSkge1xuXHRcdFx0dG9vbHRpcCA9IG5ldyBUb29sdGlwKG9wdGlvbnMpLnNldENvbnRlbnQodG9vbHRpcCk7XG5cdFx0fVxuXG5cdFx0aWYgKGxhdGxuZykge1xuXHRcdFx0dG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5oYXNMYXllcih0b29sdGlwKSkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIodG9vbHRpcCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAodG9vbHRpcD86IFRvb2x0aXApOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBnaXZlbiBhcyBwYXJhbWV0ZXIuXG5cdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXApIHtcblx0XHRpZiAodG9vbHRpcCkge1xuXHRcdFx0dGhpcy5yZW1vdmVMYXllcih0b29sdGlwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufSk7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIExheWVyXG4gKiBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHMgZXhhbXBsZVxuICpcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHRvb2x0aXBzIHRvIGl0LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFRvb2x0aXAoJ0hpIFRoZXJlIScpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5vcGVuVG9vbHRpcCgpO1xuICogbGF5ZXIuY2xvc2VUb29sdGlwKCk7XG4gKiBgYGBcbiAqL1xuXG4vLyBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHNcbkxheWVyLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2QgYmluZFRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFRvb2x0aXAsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIEJpbmRzIGEgdG9vbHRpcCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcblx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG5cdGJpbmRUb29sdGlwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXG5cdFx0aWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBUb29sdGlwKSB7XG5cdFx0XHRzZXRPcHRpb25zKGNvbnRlbnQsIG9wdGlvbnMpO1xuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IGNvbnRlbnQ7XG5cdFx0XHRjb250ZW50Ll9zb3VyY2UgPSB0aGlzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgb3B0aW9ucykge1xuXHRcdFx0XHR0aGlzLl90b29sdGlwID0gbmV3IFRvb2x0aXAob3B0aW9ucywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucygpO1xuXG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQgJiYgdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKSkge1xuXHRcdFx0dGhpcy5vcGVuVG9vbHRpcCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdW5iaW5kVG9vbHRpcCgpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIHRvb2x0aXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kVG9vbHRpcGAuXG5cdHVuYmluZFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnModHJ1ZSk7XG5cdFx0XHR0aGlzLmNsb3NlVG9vbHRpcCgpO1xuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9pbml0VG9vbHRpcEludGVyYWN0aW9uczogZnVuY3Rpb24gKHJlbW92ZSQkMSkge1xuXHRcdGlmICghcmVtb3ZlJCQxICYmIHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkKSB7IHJldHVybjsgfVxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSQkMSA/ICdvZmYnIDogJ29uJyxcblx0XHQgICAgZXZlbnRzID0ge1xuXHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlVG9vbHRpcCxcblx0XHRcdG1vdmU6IHRoaXMuX21vdmVUb29sdGlwXG5cdFx0ICAgIH07XG5cdFx0aWYgKCF0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50KSB7XG5cdFx0XHRldmVudHMubW91c2VvdmVyID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHRldmVudHMubW91c2VvdXQgPSB0aGlzLmNsb3NlVG9vbHRpcDtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5KSB7XG5cdFx0XHRcdGV2ZW50cy5tb3VzZW1vdmUgPSB0aGlzLl9tb3ZlVG9vbHRpcDtcblx0XHRcdH1cblx0XHRcdGlmICh0b3VjaCkge1xuXHRcdFx0XHRldmVudHMuY2xpY2sgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXZlbnRzLmFkZCA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdH1cblx0XHR0aGlzW29uT2ZmXShldmVudHMpO1xuXHRcdHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkID0gIXJlbW92ZSQkMTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHRvb2x0aXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCB0b29sdGlwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAobGF5ZXIsIGxhdGxuZykge1xuXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuX21hcCkge1xuXHRcdFx0bGF0bG5nID0gdGhpcy5fdG9vbHRpcC5fcHJlcGFyZU9wZW4odGhpcywgbGF5ZXIsIGxhdGxuZyk7XG5cblx0XHRcdC8vIG9wZW4gdGhlIHRvb2x0aXAgb24gdGhlIG1hcFxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Ub29sdGlwKHRoaXMuX3Rvb2x0aXAsIGxhdGxuZyk7XG5cblx0XHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG1heSBub3QgYmUgZGVmaW5lZCBpZiBub3QgcGVybWFuZW50IGFuZCBuZXZlclxuXHRcdFx0Ly8gb3BlbmVkLlxuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiB0aGlzLl90b29sdGlwLl9jb250YWluZXIpIHtcblx0XHRcdFx0YWRkQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuX2Nsb3NlKCk7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLmludGVyYWN0aXZlICYmIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcikge1xuXHRcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl90b29sdGlwLl9jb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdG9nZ2xlVG9vbHRpcCgpOiB0aGlzXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cblx0dG9nZ2xlVG9vbHRpcDogZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5fbWFwKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm9wZW5Ub29sdGlwKHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNUb29sdGlwT3BlbigpOiBib29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXG5cdGlzVG9vbHRpcE9wZW46IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcC5pc09wZW4oKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFRvb2x0aXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxUb29sdGlwKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdHNldFRvb2x0aXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0VG9vbHRpcCgpOiBUb29sdGlwXG5cdC8vIFJldHVybnMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0Z2V0VG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwO1xuXHR9LFxuXG5cdF9vcGVuVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG5cdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8ICF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5vcGVuVG9vbHRpcChsYXllciwgdGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSA/IGUubGF0bG5nIDogdW5kZWZpbmVkKTtcblx0fSxcblxuXHRfbW92ZVRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxhdGxuZyA9IGUubGF0bG5nLCBjb250YWluZXJQb2ludCwgbGF5ZXJQb2ludDtcblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSAmJiBlLm9yaWdpbmFsRXZlbnQpIHtcblx0XHRcdGNvbnRhaW5lclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUub3JpZ2luYWxFdmVudCk7XG5cdFx0XHRsYXllclBvaW50ID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGNvbnRhaW5lclBvaW50KTtcblx0XHRcdGxhdGxuZyA9IHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XG5cdFx0fVxuXHRcdHRoaXMuX3Rvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG5cdH1cbn0pO1xuXG4vKlxuICogQGNsYXNzIERpdkljb25cbiAqIEBha2EgTC5EaXZJY29uXG4gKiBAaW5oZXJpdHMgSWNvblxuICpcbiAqIFJlcHJlc2VudHMgYSBsaWdodHdlaWdodCBpY29uIGZvciBtYXJrZXJzIHRoYXQgdXNlcyBhIHNpbXBsZSBgPGRpdj5gXG4gKiBlbGVtZW50IGluc3RlYWQgb2YgYW4gaW1hZ2UuIEluaGVyaXRzIGZyb20gYEljb25gIGJ1dCBpZ25vcmVzIHRoZSBgaWNvblVybGAgYW5kIHNoYWRvdyBvcHRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIG15SWNvbiA9IEwuZGl2SWNvbih7Y2xhc3NOYW1lOiAnbXktZGl2LWljb24nfSk7XG4gKiAvLyB5b3UgY2FuIHNldCAubXktZGl2LWljb24gc3R5bGVzIGluIENTU1xuICpcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCBoYXMgYSAnbGVhZmxldC1kaXYtaWNvbicgQ1NTIGNsYXNzIGFuZCBpcyBzdHlsZWQgYXMgYSBsaXR0bGUgd2hpdGUgc3F1YXJlIHdpdGggYSBzaGFkb3cuXG4gKi9cblxudmFyIERpdkljb24gPSBJY29uLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgRGl2SWNvbiBvcHRpb25zXG5cdFx0aWNvblNpemU6IFsxMiwgMTJdLCAvLyBhbHNvIGNhbiBiZSBzZXQgdGhyb3VnaCBDU1NcblxuXHRcdC8vIGljb25BbmNob3I6IChQb2ludCksXG5cdFx0Ly8gcG9wdXBBbmNob3I6IChQb2ludCksXG5cblx0XHQvLyBAb3B0aW9uIGh0bWw6IFN0cmluZ3xIVE1MRWxlbWVudCA9ICcnXG5cdFx0Ly8gQ3VzdG9tIEhUTUwgY29kZSB0byBwdXQgaW5zaWRlIHRoZSBkaXYgZWxlbWVudCwgZW1wdHkgYnkgZGVmYXVsdC4gQWx0ZXJuYXRpdmVseSxcblx0XHQvLyBhbiBpbnN0YW5jZSBvZiBgSFRNTEVsZW1lbnRgLlxuXHRcdGh0bWw6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBiZ1BvczogUG9pbnQgPSBbMCwgMF1cblx0XHQvLyBPcHRpb25hbCByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgYmFja2dyb3VuZCwgaW4gcGl4ZWxzXG5cdFx0YmdQb3M6IG51bGwsXG5cblx0XHRjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uJ1xuXHR9LFxuXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XG5cdFx0dmFyIGRpdiA9IChvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0RJVicpID8gb2xkSWNvbiA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdGlvbnMuaHRtbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcblx0XHRcdGVtcHR5KGRpdik7XG5cdFx0XHRkaXYuYXBwZW5kQ2hpbGQob3B0aW9ucy5odG1sKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGl2LmlubmVySFRNTCA9IG9wdGlvbnMuaHRtbCAhPT0gZmFsc2UgPyBvcHRpb25zLmh0bWwgOiAnJztcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5iZ1Bvcykge1xuXHRcdFx0dmFyIGJnUG9zID0gdG9Qb2ludChvcHRpb25zLmJnUG9zKTtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4Jztcblx0XHR9XG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cblx0XHRyZXR1cm4gZGl2O1xuXHR9LFxuXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBgRGl2SWNvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmZ1bmN0aW9uIGRpdkljb24ob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IERpdkljb24ob3B0aW9ucyk7XG59XG5cbkljb24uRGVmYXVsdCA9IEljb25EZWZhdWx0O1xuXG4vKlxuICogQGNsYXNzIEdyaWRMYXllclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuR3JpZExheWVyXG4gKlxuICogR2VuZXJpYyBjbGFzcyBmb3IgaGFuZGxpbmcgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMuIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCB0aWxlIGxheWVycyBhbmQgcmVwbGFjZXMgYFRpbGVMYXllci5DYW52YXNgLlxuICogR3JpZExheWVyIGNhbiBiZSBleHRlbmRlZCB0byBjcmVhdGUgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMgbGlrZSBgPGNhbnZhcz5gLCBgPGltZz5gIG9yIGA8ZGl2PmAuIEdyaWRMYXllciB3aWxsIGhhbmRsZSBjcmVhdGluZyBhbmQgYW5pbWF0aW5nIHRoZXNlIERPTSBlbGVtZW50cyBmb3IgeW91LlxuICpcbiAqXG4gKiBAc2VjdGlvbiBTeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUbyBjcmVhdGUgYSBjdXN0b20gbGF5ZXIsIGV4dGVuZCBHcmlkTGF5ZXIgYW5kIGltcGxlbWVudCB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLCB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIGBQb2ludGAgb2JqZWN0IHdpdGggdGhlIGB4YCwgYHlgLCBhbmQgYHpgICh6b29tIGxldmVsKSBjb29yZGluYXRlcyB0byBkcmF3IHlvdXIgdGlsZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMpe1xuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBnZXQgYSBjYW52YXMgY29udGV4dCBhbmQgZHJhdyBzb21ldGhpbmcgb24gaXQgdXNpbmcgY29vcmRzLngsIGNvb3Jkcy55IGFuZCBjb29yZHMuelxuICogICAgICAgICB2YXIgY3R4ID0gdGlsZS5nZXRDb250ZXh0KCcyZCcpO1xuICpcbiAqICAgICAgICAgLy8gcmV0dXJuIHRoZSB0aWxlIHNvIGl0IGNhbiBiZSByZW5kZXJlZCBvbiBzY3JlZW5cbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvbiBBc3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVGlsZSBjcmVhdGlvbiBjYW4gYWxzbyBiZSBhc3luY2hyb25vdXMsIHRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYSB0aGlyZC1wYXJ0eSBkcmF3aW5nIGxpYnJhcnkuIE9uY2UgdGhlIHRpbGUgaXMgZmluaXNoZWQgZHJhd2luZyBpdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBgZG9uZSgpYCBjYWxsYmFjay5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpe1xuICogICAgICAgICB2YXIgZXJyb3I7XG4gKlxuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBkcmF3IHNvbWV0aGluZyBhc3luY2hyb25vdXNseSBhbmQgcGFzcyB0aGUgdGlsZSB0byB0aGUgZG9uZSgpIGNhbGxiYWNrXG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBkb25lKGVycm9yLCB0aWxlKTtcbiAqICAgICAgICAgfSwgMTAwMCk7XG4gKlxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uXG4gKi9cblxuXG52YXIgR3JpZExheWVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIEdyaWRMYXllciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHRpbGVTaXplOiBOdW1iZXJ8UG9pbnQgPSAyNTZcblx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRpbGVzIGluIHRoZSBncmlkLiBVc2UgYSBudW1iZXIgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZXF1YWwsIG9yIGBMLnBvaW50KHdpZHRoLCBoZWlnaHQpYCBvdGhlcndpc2UuXG5cdFx0dGlsZVNpemU6IDI1NixcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gT3BhY2l0eSBvZiB0aGUgdGlsZXMuIENhbiBiZSB1c2VkIGluIHRoZSBgY3JlYXRlVGlsZSgpYCBmdW5jdGlvbi5cblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IChkZXBlbmRzKVxuXHRcdC8vIExvYWQgbmV3IHRpbGVzIG9ubHkgd2hlbiBwYW5uaW5nIGVuZHMuXG5cdFx0Ly8gYHRydWVgIGJ5IGRlZmF1bHQgb24gbW9iaWxlIGJyb3dzZXJzLCBpbiBvcmRlciB0byBhdm9pZCB0b28gbWFueSByZXF1ZXN0cyBhbmQga2VlcCBzbW9vdGggbmF2aWdhdGlvbi5cblx0XHQvLyBgZmFsc2VgIG90aGVyd2lzZSBpbiBvcmRlciB0byBkaXNwbGF5IG5ldyB0aWxlcyBfZHVyaW5nXyBwYW5uaW5nLCBzaW5jZSBpdCBpcyBlYXN5IHRvIHBhbiBvdXRzaWRlIHRoZVxuXHRcdC8vIFtga2VlcEJ1ZmZlcmBdKCNncmlkbGF5ZXIta2VlcGJ1ZmZlcikgb3B0aW9uIGluIGRlc2t0b3AgYnJvd3NlcnMuXG5cdFx0dXBkYXRlV2hlbklkbGU6IG1vYmlsZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlblpvb21pbmc6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYSBzbW9vdGggem9vbSBhbmltYXRpb24gKGR1cmluZyBhIFt0b3VjaCB6b29tXSgjbWFwLXRvdWNoem9vbSkgb3IgYSBbYGZseVRvKClgXSgjbWFwLWZseXRvKSkgd2lsbCB1cGRhdGUgZ3JpZCBsYXllcnMgZXZlcnkgaW50ZWdlciB6b29tIGxldmVsLiBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgd2lsbCB1cGRhdGUgdGhlIGdyaWQgbGF5ZXIgb25seSB3aGVuIHRoZSBzbW9vdGggYW5pbWF0aW9uIGVuZHMuXG5cdFx0dXBkYXRlV2hlblpvb21pbmc6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZUludGVydmFsOiBOdW1iZXIgPSAyMDBcblx0XHQvLyBUaWxlcyB3aWxsIG5vdCB1cGRhdGUgbW9yZSB0aGFuIG9uY2UgZXZlcnkgYHVwZGF0ZUludGVydmFsYCBtaWxsaXNlY29uZHMgd2hlbiBwYW5uaW5nLlxuXHRcdHVwZGF0ZUludGVydmFsOiAyMDAsXG5cblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxuXHRcdC8vIFRoZSBleHBsaWNpdCB6SW5kZXggb2YgdGhlIHRpbGUgbGF5ZXIuXG5cdFx0ekluZGV4OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBib3VuZHM6IExhdExuZ0JvdW5kcyA9IHVuZGVmaW5lZFxuXHRcdC8vIElmIHNldCwgdGlsZXMgd2lsbCBvbmx5IGJlIGxvYWRlZCBpbnNpZGUgdGhlIHNldCBgTGF0TG5nQm91bmRzYC5cblx0XHRib3VuZHM6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cblx0XHRtaW5ab29tOiAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhOYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBNYXhpbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBoaWdoZXIgdGhhbiBgbWF4TmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcblx0XHQvLyBmcm9tIGBtYXhOYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG5cdFx0bWF4TmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBtaW5OYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBNaW5pbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBsb3dlciB0aGFuIGBtaW5OYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuXHRcdC8vIGZyb20gYG1pbk5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cblx0XHRtaW5OYXRpdmVab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG5vV3JhcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0aGUgbGF5ZXIgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGFudGltZXJpZGlhbi4gSWYgYHRydWVgLCB0aGVcblx0XHQvLyBHcmlkTGF5ZXIgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBvbmNlIGF0IGxvdyB6b29tIGxldmVscy4gSGFzIG5vXG5cdFx0Ly8gZWZmZWN0IHdoZW4gdGhlIFttYXAgQ1JTXSgjbWFwLWNycykgZG9lc24ndCB3cmFwIGFyb3VuZC4gQ2FuIGJlIHVzZWRcblx0XHQvLyBpbiBjb21iaW5hdGlvbiB3aXRoIFtgYm91bmRzYF0oI2dyaWRsYXllci1ib3VuZHMpIHRvIHByZXZlbnQgcmVxdWVzdGluZ1xuXHRcdC8vIHRpbGVzIG91dHNpZGUgdGhlIENSUyBsaW1pdHMuXG5cdFx0bm9XcmFwOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3RpbGVQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIGdyaWQgbGF5ZXIgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndGlsZVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHRpbGUgbGF5ZXIuIEVtcHR5IGJ5IGRlZmF1bHQuXG5cdFx0Y2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIEBvcHRpb24ga2VlcEJ1ZmZlcjogTnVtYmVyID0gMlxuXHRcdC8vIFdoZW4gcGFubmluZyB0aGUgbWFwLCBrZWVwIHRoaXMgbWFueSByb3dzIGFuZCBjb2x1bW5zIG9mIHRpbGVzIGJlZm9yZSB1bmxvYWRpbmcgdGhlbS5cblx0XHRrZWVwQnVmZmVyOiAyXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xuXG5cdFx0dGhpcy5fbGV2ZWxzID0ge307XG5cdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuXHRcdHRoaXMuX3Jlc2V0VmlldygpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5fYWRkWm9vbUxpbWl0KHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRtYXAuX3JlbW92ZVpvb21MaW1pdCh0aGlzKTtcblx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1heCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRvQmFjayh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW29wYWNpdHldKCNncmlkbGF5ZXItb3BhY2l0eSkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHRpbGUgaW4gdGhlIGdyaWQgbGF5ZXIgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLlxuXHRpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdzogdGhpc1xuXHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcblx0XHRcdC8vIHVwZGF0ZSB0aWxlcyBvbiBtb3ZlLCBidXQgbm90IG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciBnaXZlbiBpbnRlcnZhbFxuXHRcdFx0aWYgKCF0aGlzLl9vbk1vdmUpIHtcblx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gdGhyb3R0bGUodGhpcy5fb25Nb3ZlRW5kLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRldmVudHMubW92ZSA9IHRoaXMuX29uTW92ZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIExheWVycyBleHRlbmRpbmcgYEdyaWRMYXllcmAgc2hhbGwgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgbXVzdCBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGBjb29yZHNgLiBJZiB0aGUgYGRvbmVgIGNhbGxiYWNrXG5cdC8vIGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgZmluaXNoZWQgbG9hZGluZyBhbmQgZHJhd2luZy5cblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0fSxcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAbWV0aG9kIGdldFRpbGVTaXplOiBQb2ludFxuXHQvLyBOb3JtYWxpemVzIHRoZSBbdGlsZVNpemUgb3B0aW9uXSgjZ3JpZGxheWVyLXRpbGVzaXplKSBpbnRvIGEgcG9pbnQuIFVzZWQgYnkgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZC5cblx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcyA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcblx0XHRyZXR1cm4gcyBpbnN0YW5jZW9mIFBvaW50ID8gcyA6IG5ldyBQb2ludChzLCBzKTtcblx0fSxcblxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRBdXRvWkluZGV4OiBmdW5jdGlvbiAoY29tcGFyZSkge1xuXHRcdC8vIGdvIHRocm91Z2ggYWxsIG90aGVyIGxheWVycyBvZiB0aGUgc2FtZSBwYW5lLCBzZXQgekluZGV4IHRvIG1heCArIDEgKGZyb250KSBvciBtaW4gLSAxIChiYWNrKVxuXG5cdFx0dmFyIGxheWVycyA9IHRoaXMuZ2V0UGFuZSgpLmNoaWxkcmVuLFxuXHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoLUluZmluaXR5LCBJbmZpbml0eSk7IC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aCwgekluZGV4OyBpIDwgbGVuOyBpKyspIHtcblxuXHRcdFx0ekluZGV4ID0gbGF5ZXJzW2ldLnN0eWxlLnpJbmRleDtcblxuXHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyICYmIHpJbmRleCkge1xuXHRcdFx0XHRlZGdlWkluZGV4ID0gY29tcGFyZShlZGdlWkluZGV4LCArekluZGV4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNGaW5pdGUoZWRnZVpJbmRleCkpIHtcblx0XHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSBlZGdlWkluZGV4ICsgY29tcGFyZSgtMSwgMSk7XG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdC8vIElFIGRvZXNuJ3QgaW5oZXJpdCBmaWx0ZXIgb3BhY2l0eSBwcm9wZXJseSwgc28gd2UncmUgZm9yY2VkIHRvIHNldCBpdCBvbiB0aWxlc1xuXHRcdGlmIChpZWx0OSkgeyByZXR1cm47IH1cblxuXHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG5cdFx0ICAgIG5leHRGcmFtZSA9IGZhbHNlLFxuXHRcdCAgICB3aWxsUHJ1bmUgPSBmYWxzZTtcblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKCF0aWxlLmN1cnJlbnQgfHwgIXRpbGUubG9hZGVkKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cblx0XHRcdHNldE9wYWNpdHkodGlsZS5lbCwgZmFkZSk7XG5cdFx0XHRpZiAoZmFkZSA8IDEpIHtcblx0XHRcdFx0bmV4dEZyYW1lID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHdpbGxQcnVuZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fb25PcGFxdWVUaWxlKHRpbGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAod2lsbFBydW5lICYmICF0aGlzLl9ub1BydW5lKSB7IHRoaXMuX3BydW5lVGlsZXMoKTsgfVxuXG5cdFx0aWYgKG5leHRGcmFtZSkge1xuXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfb25PcGFxdWVUaWxlOiBmYWxzZUZuLFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC1sYXllciAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVMZXZlbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG5cdFx0ICAgIG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcblxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcblx0XHRcdFx0dGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG5cdFx0XHRcdHRoaXMuX29uVXBkYXRlTGV2ZWwoeik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZXNBdFpvb20oeik7XG5cdFx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoeik7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAoIWxldmVsKSB7XG5cdFx0XHRsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSA9IHt9O1xuXG5cdFx0XHRsZXZlbC5lbCA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC10aWxlLWNvbnRhaW5lciBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0bGV2ZWwuZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbTtcblxuXHRcdFx0bGV2ZWwub3JpZ2luID0gbWFwLnByb2plY3QobWFwLnVucHJvamVjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSksIHpvb20pLnJvdW5kKCk7XG5cdFx0XHRsZXZlbC56b29tID0gem9vbTtcblxuXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShsZXZlbCwgbWFwLmdldENlbnRlcigpLCBtYXAuZ2V0Wm9vbSgpKTtcblxuXHRcdFx0Ly8gZm9yY2UgdGhlIGJyb3dzZXIgdG8gY29uc2lkZXIgdGhlIG5ld2x5IGFkZGVkIGVsZW1lbnQgZm9yIHRyYW5zaXRpb25cblx0XHRcdGZhbHNlRm4obGV2ZWwuZWwub2Zmc2V0V2lkdGgpO1xuXG5cdFx0XHR0aGlzLl9vbkNyZWF0ZUxldmVsKGxldmVsKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sZXZlbCA9IGxldmVsO1xuXG5cdFx0cmV0dXJuIGxldmVsO1xuXHR9LFxuXG5cdF9vblVwZGF0ZUxldmVsOiBmYWxzZUZuLFxuXG5cdF9vblJlbW92ZUxldmVsOiBmYWxzZUZuLFxuXG5cdF9vbkNyZWF0ZUxldmVsOiBmYWxzZUZuLFxuXG5cdF9wcnVuZVRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIga2V5LCB0aWxlO1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHRcdGlmICh6b29tID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHxcblx0XHRcdHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAodGlsZS5jdXJyZW50ICYmICF0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gdGlsZS5jb29yZHM7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV0YWluUGFyZW50KGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56IC0gNSkpIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5yZXRhaW4pIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlVGlsZXNBdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAodGhpcy5fdGlsZXNba2V5XS5jb29yZHMueiAhPT0gem9vbSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZUFsbFRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbnZhbGlkYXRlQWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0fVxuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cblx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRfcmV0YWluUGFyZW50OiBmdW5jdGlvbiAoeCwgeSwgeiwgbWluWm9vbSkge1xuXHRcdHZhciB4MiA9IE1hdGguZmxvb3IoeCAvIDIpLFxuXHRcdCAgICB5MiA9IE1hdGguZmxvb3IoeSAvIDIpLFxuXHRcdCAgICB6MiA9IHogLSAxLFxuXHRcdCAgICBjb29yZHMyID0gbmV3IFBvaW50KCt4MiwgK3kyKTtcblx0XHRjb29yZHMyLnogPSArejI7XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkczIpLFxuXHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICh6MiA+IG1pblpvb20pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXRhaW5QYXJlbnQoeDIsIHkyLCB6MiwgbWluWm9vbSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9yZXRhaW5DaGlsZHJlbjogZnVuY3Rpb24gKHgsIHksIHosIG1heFpvb20pIHtcblxuXHRcdGZvciAodmFyIGkgPSAyICogeDsgaSA8IDIgKiB4ICsgMjsgaSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMiAqIHk7IGogPCAyICogeSArIDI7IGorKykge1xuXG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0geiArIDE7XG5cblx0XHRcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpLFxuXHRcdFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRcdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHogKyAxIDwgbWF4Wm9vbSkge1xuXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGksIGosIHogKyAxLCBtYXhab29tKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBhbmltYXRpbmcgPSBlICYmIChlLnBpbmNoIHx8IGUuZmx5VG8pO1xuXHRcdHRoaXMuX3NldFZpZXcodGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpLCBhbmltYXRpbmcsIGFuaW1hdGluZyk7XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX3NldFZpZXcoZS5jZW50ZXIsIGUuem9vbSwgdHJ1ZSwgZS5ub1VwZGF0ZSk7XG5cdH0sXG5cblx0X2NsYW1wWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWluTmF0aXZlWm9vbSAmJiB6b29tIDwgb3B0aW9ucy5taW5OYXRpdmVab29tKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5taW5OYXRpdmVab29tO1xuXHRcdH1cblxuXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWF4TmF0aXZlWm9vbSAmJiBvcHRpb25zLm1heE5hdGl2ZVpvb20gPCB6b29tKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5tYXhOYXRpdmVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiB6b29tO1xuXHR9LFxuXG5cdF9zZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBub1BydW5lLCBub1VwZGF0ZSkge1xuXHRcdHZhciB0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbShNYXRoLnJvdW5kKHpvb20pKTtcblx0XHRpZiAoKHRoaXMub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkgfHxcblx0XHQgICAgKHRoaXMub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRpbGVab29tID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHZhciB0aWxlWm9vbUNoYW5nZWQgPSB0aGlzLm9wdGlvbnMudXBkYXRlV2hlblpvb21pbmcgJiYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSk7XG5cblx0XHRpZiAoIW5vVXBkYXRlIHx8IHRpbGVab29tQ2hhbmdlZCkge1xuXG5cdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXG5cdFx0XHRpZiAodGhpcy5fYWJvcnRMb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2Fib3J0TG9hZGluZygpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcblx0XHRcdHRoaXMuX3Jlc2V0R3JpZCgpO1xuXG5cdFx0XHRpZiAodGlsZVpvb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl91cGRhdGUoY2VudGVyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFub1BydW5lKSB7XG5cdFx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmxhZyB0byBwcmV2ZW50IF91cGRhdGVPcGFjaXR5IGZyb20gcHJ1bmluZyB0aWxlcyBkdXJpbmdcblx0XHRcdC8vIGEgem9vbSBhbmltIG9yIGEgcGluY2ggZ2VzdHVyZVxuXHRcdFx0dGhpcy5fbm9QcnVuZSA9ICEhbm9QcnVuZTtcblx0XHR9XG5cblx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtcyhjZW50ZXIsIHpvb20pO1xuXHR9LFxuXG5cdF9zZXRab29tVHJhbnNmb3JtczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKHRoaXMuX2xldmVsc1tpXSwgY2VudGVyLCB6b29tKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm06IGZ1bmN0aW9uIChsZXZlbCwgY2VudGVyLCB6b29tKSB7XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCBsZXZlbC56b29tKSxcblx0XHQgICAgdHJhbnNsYXRlID0gbGV2ZWwub3JpZ2luLm11bHRpcGx5Qnkoc2NhbGUpXG5cdFx0ICAgICAgICAuc3VidHJhY3QodGhpcy5fbWFwLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pKS5yb3VuZCgpO1xuXG5cdFx0aWYgKGFueTNkKSB7XG5cdFx0XHRzZXRUcmFuc2Zvcm0obGV2ZWwuZWwsIHRyYW5zbGF0ZSwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZXRQb3NpdGlvbihsZXZlbC5lbCwgdHJhbnNsYXRlKTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0R3JpZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycyxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLl90aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblx0XHQgICAgdGlsZVpvb20gPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcyh0aGlzLl90aWxlWm9vbSk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dGhpcy5fZ2xvYmFsVGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShib3VuZHMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3dyYXBYID0gY3JzLndyYXBMbmcgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMF1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1sxXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHRcdHRoaXMuX3dyYXBZID0gY3JzLndyYXBMYXQgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMF0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFsxXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHR9LFxuXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfZ2V0VGlsZWRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG1hcFpvb20gPSBtYXAuX2FuaW1hdGluZ1pvb20gPyBNYXRoLm1heChtYXAuX2FuaW1hdGVUb1pvb20sIG1hcC5nZXRab29tKCkpIDogbWFwLmdldFpvb20oKSxcblx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKG1hcFpvb20sIHRoaXMuX3RpbGVab29tKSxcblx0XHQgICAgcGl4ZWxDZW50ZXIgPSBtYXAucHJvamVjdChjZW50ZXIsIHRoaXMuX3RpbGVab29tKS5mbG9vcigpLFxuXHRcdCAgICBoYWxmU2l6ZSA9IG1hcC5nZXRTaXplKCkuZGl2aWRlQnkoc2NhbGUgKiAyKTtcblxuXHRcdHJldHVybiBuZXcgQm91bmRzKHBpeGVsQ2VudGVyLnN1YnRyYWN0KGhhbGZTaXplKSwgcGl4ZWxDZW50ZXIuYWRkKGhhbGZTaXplKSk7XG5cdH0sXG5cblx0Ly8gUHJpdmF0ZSBtZXRob2QgdG8gbG9hZCB0aWxlcyBpbiB0aGUgZ3JpZCdzIGFjdGl2ZSB6b29tIGxldmVsIGFjY29yZGluZyB0byBtYXAgYm91bmRzXG5cdF91cGRhdGU6IGZ1bmN0aW9uIChjZW50ZXIpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxuXHRcdHZhciB6b29tID0gdGhpcy5fY2xhbXBab29tKG1hcC5nZXRab29tKCkpO1xuXG5cdFx0aWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSB7IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTsgfVxuXHRcdGlmICh0aGlzLl90aWxlWm9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfVx0Ly8gaWYgb3V0IG9mIG1pbnpvb20vbWF4em9vbVxuXG5cdFx0dmFyIHBpeGVsQm91bmRzID0gdGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyhjZW50ZXIpLFxuXHRcdCAgICB0aWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKHBpeGVsQm91bmRzKSxcblx0XHQgICAgdGlsZUNlbnRlciA9IHRpbGVSYW5nZS5nZXRDZW50ZXIoKSxcblx0XHQgICAgcXVldWUgPSBbXSxcblx0XHQgICAgbWFyZ2luID0gdGhpcy5vcHRpb25zLmtlZXBCdWZmZXIsXG5cdFx0ICAgIG5vUHJ1bmVSYW5nZSA9IG5ldyBCb3VuZHModGlsZVJhbmdlLmdldEJvdHRvbUxlZnQoKS5zdWJ0cmFjdChbbWFyZ2luLCAtbWFyZ2luXSksXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVJhbmdlLmdldFRvcFJpZ2h0KCkuYWRkKFttYXJnaW4sIC1tYXJnaW5dKSk7XG5cblx0XHQvLyBTYW5pdHkgY2hlY2s6IHBhbmljIGlmIHRoZSB0aWxlIHJhbmdlIGNvbnRhaW5zIEluZmluaXR5IHNvbWV3aGVyZS5cblx0XHRpZiAoIShpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLngpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1pbi55KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LnkpKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBsb2FkIGFuIGluZmluaXRlIG51bWJlciBvZiB0aWxlcycpOyB9XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciBjID0gdGhpcy5fdGlsZXNba2V5XS5jb29yZHM7XG5cdFx0XHRpZiAoYy56ICE9PSB0aGlzLl90aWxlWm9vbSB8fCAhbm9QcnVuZVJhbmdlLmNvbnRhaW5zKG5ldyBQb2ludChjLngsIGMueSkpKSB7XG5cdFx0XHRcdHRoaXMuX3RpbGVzW2tleV0uY3VycmVudCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIF91cGRhdGUganVzdCBsb2FkcyBtb3JlIHRpbGVzLiBJZiB0aGUgdGlsZSB6b29tIGxldmVsIGRpZmZlcnMgdG9vIG11Y2hcblx0XHQvLyBmcm9tIHRoZSBtYXAncywgbGV0IF9zZXRWaWV3IHJlc2V0IGxldmVscyBhbmQgcHJ1bmUgb2xkIHRpbGVzLlxuXHRcdGlmIChNYXRoLmFicyh6b29tIC0gdGhpcy5fdGlsZVpvb20pID4gMSkgeyB0aGlzLl9zZXRWaWV3KGNlbnRlciwgem9vbSk7IHJldHVybjsgfVxuXG5cdFx0Ly8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCB0aWxlcyBmcm9tXG5cdFx0Zm9yICh2YXIgaiA9IHRpbGVSYW5nZS5taW4ueTsgaiA8PSB0aWxlUmFuZ2UubWF4Lnk7IGorKykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRpbGVSYW5nZS5taW4ueDsgaSA8PSB0aWxlUmFuZ2UubWF4Lng7IGkrKykge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuXHRcdFx0XHRjb29yZHMueiA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0XHRcdGlmICghdGhpcy5faXNWYWxpZFRpbGUoY29vcmRzKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyldO1xuXHRcdFx0XHRpZiAodGlsZSkge1xuXHRcdFx0XHRcdHRpbGUuY3VycmVudCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaChjb29yZHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc29ydCB0aWxlIHF1ZXVlIHRvIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG5cdFx0cXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0cmV0dXJuIGEuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKSAtIGIuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKTtcblx0XHR9KTtcblxuXHRcdGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcblx0XHRcdC8vIGlmIGl0J3MgdGhlIGZpcnN0IGJhdGNoIG9mIHRpbGVzIHRvIGxvYWRcblx0XHRcdGlmICghdGhpcy5fbG9hZGluZykge1xuXHRcdFx0XHR0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0Ly8gQGV2ZW50IGxvYWRpbmc6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgc3RhcnRzIGxvYWRpbmcgdGlsZXMuXG5cdFx0XHRcdHRoaXMuZmlyZSgnbG9hZGluZycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjcmVhdGUgRE9NIGZyYWdtZW50IHRvIGFwcGVuZCB0aWxlcyBpbiBvbmUgYmF0Y2hcblx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX2FkZFRpbGUocXVldWVbaV0sIGZyYWdtZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGV2ZWwuZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuXHRcdH1cblx0fSxcblxuXHRfaXNWYWxpZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKCFjcnMuaW5maW5pdGUpIHtcblx0XHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCdzIG91dCBvZiBib3VuZHMgYW5kIG5vdCB3cmFwcGVkXG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlO1xuXHRcdFx0aWYgKCghY3JzLndyYXBMbmcgJiYgKGNvb3Jkcy54IDwgYm91bmRzLm1pbi54IHx8IGNvb3Jkcy54ID4gYm91bmRzLm1heC54KSkgfHxcblx0XHRcdCAgICAoIWNycy53cmFwTGF0ICYmIChjb29yZHMueSA8IGJvdW5kcy5taW4ueSB8fCBjb29yZHMueSA+IGJvdW5kcy5tYXgueSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5vcHRpb25zLmJvdW5kcykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3VuZHMgaW4gb3B0aW9uc1xuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3Jkcyk7XG5cdFx0cmV0dXJuIHRvTGF0TG5nQm91bmRzKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKHRpbGVCb3VuZHMpO1xuXHR9LFxuXG5cdF9rZXlUb0JvdW5kczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSkpO1xuXHR9LFxuXG5cdF90aWxlQ29vcmRzVG9Od1NlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG5cdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZCh0aWxlU2l6ZSksXG5cdFx0ICAgIG53ID0gbWFwLnVucHJvamVjdChud1BvaW50LCBjb29yZHMueiksXG5cdFx0ICAgIHNlID0gbWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueik7XG5cdFx0cmV0dXJuIFtudywgc2VdO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcblx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBicCA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcblx0XHQgICAgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhicFswXSwgYnBbMV0pO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubm9XcmFwKSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLl9tYXAud3JhcExhdExuZ0JvdW5kcyhib3VuZHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGtleSBmb3IgdGhlIHRpbGUgY2FjaGVcblx0X3RpbGVDb29yZHNUb0tleTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMueCArICc6JyArIGNvb3Jkcy55ICsgJzonICsgY29vcmRzLno7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjYWNoZSBrZXkgdG8gY29vcmRpbmF0ZXNcblx0X2tleVRvVGlsZUNvb3JkczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBrID0ga2V5LnNwbGl0KCc6JyksXG5cdFx0ICAgIGNvb3JkcyA9IG5ldyBQb2ludCgra1swXSwgK2tbMV0pO1xuXHRcdGNvb3Jkcy56ID0gK2tbMl07XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fSxcblxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHRyZW1vdmUodGlsZS5lbCk7XG5cblx0XHRkZWxldGUgdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdC8vIEBldmVudCB0aWxldW5sb2FkOiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZW1vdmVkIChlLmcuIHdoZW4gYSB0aWxlIGdvZXMgb2ZmIHRoZSBzY3JlZW4pLlxuXHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHtcblx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRjb29yZHM6IHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpXG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuXHRcdGFkZENsYXNzKHRpbGUsICdsZWFmbGV0LXRpbGUnKTtcblxuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHR0aWxlLnN0eWxlLndpZHRoID0gdGlsZVNpemUueCArICdweCc7XG5cdFx0dGlsZS5zdHlsZS5oZWlnaHQgPSB0aWxlU2l6ZS55ICsgJ3B4JztcblxuXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XG5cdFx0dGlsZS5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XG5cblx0XHQvLyB1cGRhdGUgb3BhY2l0eSBvbiB0aWxlcyBpbiBJRTctOCBiZWNhdXNlIG9mIGZpbHRlciBpbmhlcml0YW5jZSBwcm9ibGVtc1xuXHRcdGlmIChpZWx0OSAmJiB0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdHNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXHRcdH1cblxuXHRcdC8vIHdpdGhvdXQgdGhpcyBoYWNrLCB0aWxlcyBkaXNhcHBlYXIgYWZ0ZXIgem9vbSBvbiBDaHJvbWUgZm9yIEFuZHJvaWRcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yMDc4XG5cdFx0aWYgKGFuZHJvaWQgJiYgIWFuZHJvaWQyMykge1xuXHRcdFx0dGlsZS5zdHlsZS5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0XHR9XG5cdH0sXG5cblx0X2FkZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGNvbnRhaW5lcikge1xuXHRcdHZhciB0aWxlUG9zID0gdGhpcy5fZ2V0VGlsZVBvcyhjb29yZHMpLFxuXHRcdCAgICBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHZhciB0aWxlID0gdGhpcy5jcmVhdGVUaWxlKHRoaXMuX3dyYXBDb29yZHMoY29vcmRzKSwgYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuXG5cdFx0dGhpcy5faW5pdFRpbGUodGlsZSk7XG5cblx0XHQvLyBpZiBjcmVhdGVUaWxlIGlzIGRlZmluZWQgd2l0aCBhIHNlY29uZCBhcmd1bWVudCAoXCJkb25lXCIgY2FsbGJhY2spLFxuXHRcdC8vIHdlIGtub3cgdGhhdCB0aWxlIGlzIGFzeW5jIGFuZCB3aWxsIGJlIHJlYWR5IGxhdGVyOyBvdGhlcndpc2Vcblx0XHRpZiAodGhpcy5jcmVhdGVUaWxlLmxlbmd0aCA8IDIpIHtcblx0XHRcdC8vIG1hcmsgdGlsZSBhcyByZWFkeSwgYnV0IGRlbGF5IG9uZSBmcmFtZSBmb3Igb3BhY2l0eSBhbmltYXRpb24gdG8gaGFwcGVuXG5cdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKGJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMsIG51bGwsIHRpbGUpKTtcblx0XHR9XG5cblx0XHRzZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zKTtcblxuXHRcdC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuXHRcdHRoaXMuX3RpbGVzW2tleV0gPSB7XG5cdFx0XHRlbDogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzLFxuXHRcdFx0Y3VycmVudDogdHJ1ZVxuXHRcdH07XG5cblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGlsZSk7XG5cdFx0Ly8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlcXVlc3RlZCBhbmQgc3RhcnRzIGxvYWRpbmcuXG5cdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuXHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0fSk7XG5cdH0sXG5cblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XG5cdFx0aWYgKGVycikge1xuXHRcdFx0Ly8gQGV2ZW50IHRpbGVlcnJvcjogVGlsZUVycm9yRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgbG9hZGluZyBhIHRpbGUuXG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVlcnJvcicsIHtcblx0XHRcdFx0ZXJyb3I6IGVycixcblx0XHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuXHRcdHRpbGUubG9hZGVkID0gK25ldyBEYXRlKCk7XG5cdFx0aWYgKHRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHRzZXRPcGFjaXR5KHRpbGUuZWwsIDApO1xuXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFlcnIpIHtcblx0XHRcdGFkZENsYXNzKHRpbGUuZWwsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XG5cblx0XHRcdC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBsb2Fkcy5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWxvYWQnLCB7XG5cdFx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG5cdFx0XHR0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG5cdFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XG5cblx0XHRcdGlmIChpZWx0OSB8fCAhdGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdFx0cmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcblx0XHRcdFx0Ly8gdG8gdHJpZ2dlciBhIHBydW5pbmcuXG5cdFx0XHRcdHNldFRpbWVvdXQoYmluZCh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKSwgMjUwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKS5zdWJ0cmFjdCh0aGlzLl9sZXZlbC5vcmlnaW4pO1xuXHR9LFxuXG5cdF93cmFwQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG5ld0Nvb3JkcyA9IG5ldyBQb2ludChcblx0XHRcdHRoaXMuX3dyYXBYID8gd3JhcE51bShjb29yZHMueCwgdGhpcy5fd3JhcFgpIDogY29vcmRzLngsXG5cdFx0XHR0aGlzLl93cmFwWSA/IHdyYXBOdW0oY29vcmRzLnksIHRoaXMuX3dyYXBZKSA6IGNvb3Jkcy55KTtcblx0XHRuZXdDb29yZHMueiA9IGNvb3Jkcy56O1xuXHRcdHJldHVybiBuZXdDb29yZHM7XG5cdH0sXG5cblx0X3B4Qm91bmRzVG9UaWxlUmFuZ2U6IGZ1bmN0aW9uIChib3VuZHMpIHtcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMoXG5cdFx0XHRib3VuZHMubWluLnVuc2NhbGVCeSh0aWxlU2l6ZSkuZmxvb3IoKSxcblx0XHRcdGJvdW5kcy5tYXgudW5zY2FsZUJ5KHRpbGVTaXplKS5jZWlsKCkuc3VidHJhY3QoWzEsIDFdKSk7XG5cdH0sXG5cblx0X25vVGlsZXNUb0xvYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5sb2FkZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5ncmlkTGF5ZXIob3B0aW9ucz86IEdyaWRMYXllciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBHcmlkTGF5ZXIgd2l0aCB0aGUgc3VwcGxpZWQgb3B0aW9ucy5cbmZ1bmN0aW9uIGdyaWRMYXllcihvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgR3JpZExheWVyKG9wdGlvbnMpO1xufVxuXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyXHJcbiAqIEBpbmhlcml0cyBHcmlkTGF5ZXJcclxuICogQGFrYSBMLlRpbGVMYXllclxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gTm90ZSB0aGF0IG1vc3QgdGlsZSBzZXJ2ZXJzIHJlcXVpcmUgYXR0cmlidXRpb24sIHdoaWNoIHlvdSBjYW4gc2V0IHVuZGVyIGBMYXllcmAuIEV4dGVuZHMgYEdyaWRMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwudGlsZUxheWVyKCdodHRwczovL3tzfS50aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZz97Zm9vfScsIHtmb286ICdiYXInLCBhdHRyaWJ1dGlvbjogJ01hcCBkYXRhICZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvXCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzLCA8YSBocmVmPVwiaHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LXNhLzIuMC9cIj5DQy1CWS1TQTwvYT4nfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBzZWN0aW9uIFVSTCB0ZW1wbGF0ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBBIHN0cmluZyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiAnaHR0cDovL3tzfS5zb21lZG9tYWluLmNvbS9ibGFibGEve3p9L3t4fS97eX17cn0ucG5nJ1xyXG4gKiBgYGBcclxuICpcclxuICogYHtzfWAgbWVhbnMgb25lIG9mIHRoZSBhdmFpbGFibGUgc3ViZG9tYWlucyAodXNlZCBzZXF1ZW50aWFsbHkgdG8gaGVscCB3aXRoIGJyb3dzZXIgcGFyYWxsZWwgcmVxdWVzdHMgcGVyIGRvbWFpbiBsaW1pdGF0aW9uOyBzdWJkb21haW4gdmFsdWVzIGFyZSBzcGVjaWZpZWQgaW4gb3B0aW9uczsgYGFgLCBgYmAgb3IgYGNgIGJ5IGRlZmF1bHQsIGNhbiBiZSBvbWl0dGVkKSwgYHt6fWAg4oCUIHpvb20gbGV2ZWwsIGB7eH1gIGFuZCBge3l9YCDigJQgdGlsZSBjb29yZGluYXRlcy4gYHtyfWAgY2FuIGJlIHVzZWQgdG8gYWRkIFwiJmNvbW1hdDsyeFwiIHRvIHRoZSBVUkwgdG8gbG9hZCByZXRpbmEgdGlsZXMuXHJcbiAqXHJcbiAqIFlvdSBjYW4gdXNlIGN1c3RvbSBrZXlzIGluIHRoZSB0ZW1wbGF0ZSwgd2hpY2ggd2lsbCBiZSBbZXZhbHVhdGVkXSgjdXRpbC10ZW1wbGF0ZSkgZnJvbSBUaWxlTGF5ZXIgb3B0aW9ucywgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBcclxuICogTC50aWxlTGF5ZXIoJ2h0dHA6Ly97c30uc29tZWRvbWFpbi5jb20ve2Zvb30ve3p9L3t4fS97eX0ucG5nJywge2ZvbzogJ2Jhcid9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbnZhciBUaWxlTGF5ZXIgPSBHcmlkTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuXHRcdG1pblpvb206IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAxOFxyXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWF4Wm9vbTogMTgsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdWJkb21haW5zOiBTdHJpbmd8U3RyaW5nW10gPSAnYWJjJ1xyXG5cdFx0Ly8gU3ViZG9tYWlucyBvZiB0aGUgdGlsZSBzZXJ2aWNlLiBDYW4gYmUgcGFzc2VkIGluIHRoZSBmb3JtIG9mIG9uZSBzdHJpbmcgKHdoZXJlIGVhY2ggbGV0dGVyIGlzIGEgc3ViZG9tYWluIG5hbWUpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcblx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yVGlsZVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgdGlsZSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSB0aWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gVGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgb2Zmc2V0IHdpdGggdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21PZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0bXM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBpbnZlcnNlcyBZIGF4aXMgbnVtYmVyaW5nIGZvciB0aWxlcyAodHVybiB0aGlzIG9uIGZvciBbVE1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuXHJcblx0XHR0bXM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbVJldmVyc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgc2V0IHRvIHRydWUsIHRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIHJldmVyc2VkIChgbWF4Wm9vbSAtIHpvb21gIGluc3RlYWQgb2YgYHpvb21gKVxyXG5cdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZGV0ZWN0UmV0aW5hOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCBhbmQgdXNlciBpcyBvbiBhIHJldGluYSBkaXNwbGF5LCBpdCB3aWxsIHJlcXVlc3QgZm91ciB0aWxlcyBvZiBoYWxmIHRoZSBzcGVjaWZpZWQgc2l6ZSBhbmQgYSBiaWdnZXIgem9vbSBsZXZlbCBpbiBwbGFjZSBvZiBvbmUgdG8gdXRpbGl6ZSB0aGUgaGlnaCByZXNvbHV0aW9uLlxyXG5cdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcblx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcblx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcblx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgcmV0aW5hICYmIG9wdGlvbnMubWF4Wm9vbSA+IDApIHtcclxuXHJcblx0XHRcdG9wdGlvbnMudGlsZVNpemUgPSBNYXRoLmZsb29yKG9wdGlvbnMudGlsZVNpemUgLyAyKTtcclxuXHJcblx0XHRcdGlmICghb3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldCsrO1xyXG5cdFx0XHRcdG9wdGlvbnMubWF4Wm9vbS0tO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldC0tO1xyXG5cdFx0XHRcdG9wdGlvbnMubWluWm9vbSsrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5zdWJkb21haW5zID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRvcHRpb25zLnN1YmRvbWFpbnMgPSBvcHRpb25zLnN1YmRvbWFpbnMuc3BsaXQoJycpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xMzdcclxuXHRcdGlmICghYW5kcm9pZCkge1xyXG5cdFx0XHR0aGlzLm9uKCd0aWxldW5sb2FkJywgdGhpcy5fb25UaWxlUmVtb3ZlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZywgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIFVwZGF0ZXMgdGhlIGxheWVyJ3MgVVJMIHRlbXBsYXRlIGFuZCByZWRyYXdzIGl0ICh1bmxlc3MgYG5vUmVkcmF3YCBpcyBzZXQgdG8gYHRydWVgKS5cclxuXHQvLyBJZiB0aGUgVVJMIGRvZXMgbm90IGNoYW5nZSwgdGhlIGxheWVyIHdpbGwgbm90IGJlIHJlZHJhd24gdW5sZXNzXHJcblx0Ly8gdGhlIG5vUmVkcmF3IHBhcmFtZXRlciBpcyBzZXQgdG8gZmFsc2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsLCBub1JlZHJhdykge1xyXG5cdFx0aWYgKHRoaXMuX3VybCA9PT0gdXJsICYmIG5vUmVkcmF3ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0bm9SZWRyYXcgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgb3ZlcnJpZGVzIEdyaWRMYXllcidzIFtgY3JlYXRlVGlsZSgpYF0oI2dyaWRsYXllci1jcmVhdGV0aWxlKVxyXG5cdC8vIHRvIHJldHVybiBhbiBgPGltZz5gIEhUTUwgZWxlbWVudCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBpbWFnZSBVUkwgZ2l2ZW4gYGNvb3Jkc2AuIFRoZSBgZG9uZWBcclxuXHQvLyBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgYmVlbiBsb2FkZWQuXHJcblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgZG9uZSkge1xyXG5cdFx0dmFyIHRpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHJcblx0XHRvbih0aWxlLCAnbG9hZCcsIGJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cdFx0b24odGlsZSwgJ2Vycm9yJywgYmluZCh0aGlzLl90aWxlT25FcnJvciwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG5cdFx0XHR0aWxlLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcblx0XHR9XHJcblxyXG5cdFx0LypcclxuXHRcdCBBbHQgdGFnIGlzIHNldCB0byBlbXB0eSBzdHJpbmcgdG8ga2VlcCBzY3JlZW4gcmVhZGVycyBmcm9tIHJlYWRpbmcgVVJMIGFuZCBmb3IgY29tcGxpYW5jZSByZWFzb25zXHJcblx0XHQgaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0g2N1xyXG5cdFx0Ki9cclxuXHRcdHRpbGUuYWx0ID0gJyc7XHJcblxyXG5cdFx0LypcclxuXHRcdCBTZXQgcm9sZT1cInByZXNlbnRhdGlvblwiIHRvIGZvcmNlIHNjcmVlbiByZWFkZXJzIHRvIGlnbm9yZSB0aGlzXHJcblx0XHQgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhL3JvbGVzI3RleHRhbHRlcm5hdGl2ZWNvbXB1dGF0aW9uXHJcblx0XHQqL1xyXG5cdFx0dGlsZS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XHJcblxyXG5cdFx0dGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGlsZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG5cdC8vIEB1bmluaGVyaXRhYmxlXHJcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBtaWdodCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cclxuXHQvLyBAbWV0aG9kIGdldFRpbGVVcmwoY29vcmRzOiBPYmplY3QpOiBTdHJpbmdcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCByZXR1cm5zIHRoZSBVUkwgZm9yIGEgdGlsZSBnaXZlbiBpdHMgY29vcmRpbmF0ZXMuXHJcblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYFRpbGVMYXllcmAgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gcHJvdmlkZSBjdXN0b20gdGlsZSBVUkwgbmFtaW5nIHNjaGVtZXMuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdHI6IHJldGluYSA/ICdAMngnIDogJycsXHJcblx0XHRcdHM6IHRoaXMuX2dldFN1YmRvbWFpbihjb29yZHMpLFxyXG5cdFx0XHR4OiBjb29yZHMueCxcclxuXHRcdFx0eTogY29vcmRzLnksXHJcblx0XHRcdHo6IHRoaXMuX2dldFpvb21Gb3JVcmwoKVxyXG5cdFx0fTtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xyXG5cdFx0XHR2YXIgaW52ZXJ0ZWRZID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlLm1heC55IC0gY29vcmRzLnk7XHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XHJcblx0XHRcdFx0ZGF0YVsneSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGFbJy15J10gPSBpbnZlcnRlZFk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRlbXBsYXRlKHRoaXMuX3VybCwgZXh0ZW5kKGRhdGEsIHRoaXMub3B0aW9ucykpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSkge1xyXG5cdFx0Ly8gRm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzMzMzJcclxuXHRcdGlmIChpZWx0OSkge1xyXG5cdFx0XHRzZXRUaW1lb3V0KGJpbmQoZG9uZSwgdGhpcywgbnVsbCwgdGlsZSksIDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZG9uZShudWxsLCB0aWxlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uIChkb25lLCB0aWxlLCBlKSB7XHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JUaWxlVXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGlsZS5zcmMgPSBlcnJvclVybDtcclxuXHRcdH1cclxuXHRcdGRvbmUoZSwgdGlsZSk7XHJcblx0fSxcclxuXHJcblx0X29uVGlsZVJlbW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGUudGlsZS5vbmxvYWQgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tRm9yVXJsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxyXG5cdFx0bWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tLFxyXG5cdFx0em9vbVJldmVyc2UgPSB0aGlzLm9wdGlvbnMuem9vbVJldmVyc2UsXHJcblx0XHR6b29tT2Zmc2V0ID0gdGhpcy5vcHRpb25zLnpvb21PZmZzZXQ7XHJcblxyXG5cdFx0aWYgKHpvb21SZXZlcnNlKSB7XHJcblx0XHRcdHpvb20gPSBtYXhab29tIC0gem9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gem9vbSArIHpvb21PZmZzZXQ7XHJcblx0fSxcclxuXHJcblx0X2dldFN1YmRvbWFpbjogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG5cdFx0dmFyIGluZGV4ID0gTWF0aC5hYnModGlsZVBvaW50LnggKyB0aWxlUG9pbnQueSkgJSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucy5sZW5ndGg7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnN1YmRvbWFpbnNbaW5kZXhdO1xyXG5cdH0sXHJcblxyXG5cdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXHJcblx0X2Fib3J0TG9hZGluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGksIHRpbGU7XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2ldLmNvb3Jkcy56ICE9PSB0aGlzLl90aWxlWm9vbSkge1xyXG5cdFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1tpXS5lbDtcclxuXHJcblx0XHRcdFx0dGlsZS5vbmxvYWQgPSBmYWxzZUZuO1xyXG5cdFx0XHRcdHRpbGUub25lcnJvciA9IGZhbHNlRm47XHJcblxyXG5cdFx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xyXG5cdFx0XHRcdFx0dGlsZS5zcmMgPSBlbXB0eUltYWdlVXJsO1xyXG5cdFx0XHRcdFx0cmVtb3ZlKHRpbGUpO1xyXG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2ldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XHJcblx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XHJcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gQ2FuY2VscyBhbnkgcGVuZGluZyBodHRwIHJlcXVlc3RzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdGlsZVxyXG5cdFx0Ly8gdW5sZXNzIHdlJ3JlIG9uIEFuZHJvaWQncyBzdG9jayBicm93c2VyLFxyXG5cdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xyXG5cdFx0aWYgKCFhbmRyb2lkU3RvY2spIHtcclxuXHRcdFx0dGlsZS5lbC5zZXRBdHRyaWJ1dGUoJ3NyYycsIGVtcHR5SW1hZ2VVcmwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl9yZW1vdmVUaWxlLmNhbGwodGhpcywga2V5KTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwIHx8ICh0aWxlICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSA9PT0gZW1wdHlJbWFnZVVybCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl90aWxlUmVhZHkuY2FsbCh0aGlzLCBjb29yZHMsIGVyciwgdGlsZSk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYFVSTCB0ZW1wbGF0ZWAgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcblxyXG5mdW5jdGlvbiB0aWxlTGF5ZXIodXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXIodXJsLCBvcHRpb25zKTtcclxufVxuXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyLldNU1xyXG4gKiBAaW5oZXJpdHMgVGlsZUxheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXIuV01TXHJcbiAqIFVzZWQgdG8gZGlzcGxheSBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzIGFzIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYFRpbGVMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBuZXhyYWQgPSBMLnRpbGVMYXllci53bXMoXCJodHRwOi8vbWVzb25ldC5hZ3Jvbi5pYXN0YXRlLmVkdS9jZ2ktYmluL3dtcy9uZXhyYWQvbjByLmNnaVwiLCB7XHJcbiAqIFx0bGF5ZXJzOiAnbmV4cmFkLW4wci05MDA5MTMnLFxyXG4gKiBcdGZvcm1hdDogJ2ltYWdlL3BuZycsXHJcbiAqIFx0dHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAqIFx0YXR0cmlidXRpb246IFwiV2VhdGhlciBkYXRhIMKpIDIwMTIgSUVNIE5leHJhZFwiXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgVGlsZUxheWVyV01TID0gVGlsZUxheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBUaWxlTGF5ZXIuV01TIG9wdGlvbnNcclxuXHQvLyBJZiBhbnkgY3VzdG9tIG9wdGlvbnMgbm90IGRvY3VtZW50ZWQgaGVyZSBhcmUgdXNlZCwgdGhleSB3aWxsIGJlIHNlbnQgdG8gdGhlXHJcblx0Ly8gV01TIHNlcnZlciBhcyBleHRyYSBwYXJhbWV0ZXJzIGluIGVhY2ggcmVxdWVzdCBVUkwuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcclxuXHQvLyBbbm9uLXN0YW5kYXJkIHZlbmRvciBXTVMgcGFyYW1ldGVyc10oaHR0cDovL2RvY3MuZ2Vvc2VydmVyLm9yZy9zdGFibGUvZW4vdXNlci9zZXJ2aWNlcy93bXMvdmVuZG9yLmh0bWwpLlxyXG5cdGRlZmF1bHRXbXNQYXJhbXM6IHtcclxuXHRcdHNlcnZpY2U6ICdXTVMnLFxyXG5cdFx0cmVxdWVzdDogJ0dldE1hcCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyAqKihyZXF1aXJlZCkqKiBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgbGF5ZXJzIHRvIHNob3cuXHJcblx0XHRsYXllcnM6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc3R5bGVzOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIHN0eWxlcy5cclxuXHRcdHN0eWxlczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBmb3JtYXQ6IFN0cmluZyA9ICdpbWFnZS9qcGVnJ1xyXG5cdFx0Ly8gV01TIGltYWdlIGZvcm1hdCAodXNlIGAnaW1hZ2UvcG5nJ2AgZm9yIGxheWVycyB3aXRoIHRyYW5zcGFyZW5jeSkuXHJcblx0XHRmb3JtYXQ6ICdpbWFnZS9qcGVnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYW5zcGFyZW50OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIFdNUyBzZXJ2aWNlIHdpbGwgcmV0dXJuIGltYWdlcyB3aXRoIHRyYW5zcGFyZW5jeS5cclxuXHRcdHRyYW5zcGFyZW50OiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHZlcnNpb246IFN0cmluZyA9ICcxLjEuMSdcclxuXHRcdC8vIFZlcnNpb24gb2YgdGhlIFdNUyBzZXJ2aWNlIHRvIHVzZVxyXG5cdFx0dmVyc2lvbjogJzEuMS4xJ1xyXG5cdH0sXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBudWxsXHJcblx0XHQvLyBDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW0gdG8gdXNlIGZvciB0aGUgV01TIHJlcXVlc3RzLCBkZWZhdWx0cyB0b1xyXG5cdFx0Ly8gbWFwIENSUy4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdCBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB1cHBlcmNhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBXTVMgcmVxdWVzdCBwYXJhbWV0ZXIga2V5cyB3aWxsIGJlIHVwcGVyY2FzZS5cclxuXHRcdHVwcGVyY2FzZTogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdHZhciB3bXNQYXJhbXMgPSBleHRlbmQoe30sIHRoaXMuZGVmYXVsdFdtc1BhcmFtcyk7XHJcblxyXG5cdFx0Ly8gYWxsIGtleXMgdGhhdCBhcmUgbm90IFRpbGVMYXllciBvcHRpb25zIGdvIHRvIFdNUyBwYXJhbXNcclxuXHRcdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0XHRpZiAoIShpIGluIHRoaXMub3B0aW9ucykpIHtcclxuXHRcdFx0XHR3bXNQYXJhbXNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0b3B0aW9ucyA9IHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIHJlYWxSZXRpbmEgPSBvcHRpb25zLmRldGVjdFJldGluYSAmJiByZXRpbmEgPyAyIDogMTtcclxuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcclxuXHRcdHdtc1BhcmFtcy53aWR0aCA9IHRpbGVTaXplLnggKiByZWFsUmV0aW5hO1xyXG5cdFx0d21zUGFyYW1zLmhlaWdodCA9IHRpbGVTaXplLnkgKiByZWFsUmV0aW5hO1xyXG5cclxuXHRcdHRoaXMud21zUGFyYW1zID0gd21zUGFyYW1zO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblxyXG5cdFx0dGhpcy5fY3JzID0gdGhpcy5vcHRpb25zLmNycyB8fCBtYXAub3B0aW9ucy5jcnM7XHJcblx0XHR0aGlzLl93bXNWZXJzaW9uID0gcGFyc2VGbG9hdCh0aGlzLndtc1BhcmFtcy52ZXJzaW9uKTtcclxuXHJcblx0XHR2YXIgcHJvamVjdGlvbktleSA9IHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zID8gJ2NycycgOiAnc3JzJztcclxuXHRcdHRoaXMud21zUGFyYW1zW3Byb2plY3Rpb25LZXldID0gdGhpcy5fY3JzLmNvZGU7XHJcblxyXG5cdFx0VGlsZUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cclxuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvTndTZShjb29yZHMpLFxyXG5cdFx0ICAgIGNycyA9IHRoaXMuX2NycyxcclxuXHRcdCAgICBib3VuZHMgPSB0b0JvdW5kcyhjcnMucHJvamVjdCh0aWxlQm91bmRzWzBdKSwgY3JzLnByb2plY3QodGlsZUJvdW5kc1sxXSkpLFxyXG5cdFx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuXHRcdCAgICBiYm94ID0gKHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zICYmIHRoaXMuX2NycyA9PT0gRVBTRzQzMjYgP1xyXG5cdFx0ICAgIFttaW4ueSwgbWluLngsIG1heC55LCBtYXgueF0gOlxyXG5cdFx0ICAgIFttaW4ueCwgbWluLnksIG1heC54LCBtYXgueV0pLmpvaW4oJywnKSxcclxuXHRcdCAgICB1cmwgPSBUaWxlTGF5ZXIucHJvdG90eXBlLmdldFRpbGVVcmwuY2FsbCh0aGlzLCBjb29yZHMpO1xyXG5cdFx0cmV0dXJuIHVybCArXHJcblx0XHRcdGdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB1cmwsIHRoaXMub3B0aW9ucy51cHBlcmNhc2UpICtcclxuXHRcdFx0KHRoaXMub3B0aW9ucy51cHBlcmNhc2UgPyAnJkJCT1g9JyA6ICcmYmJveD0nKSArIGJib3g7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQYXJhbXMocGFyYW1zOiBPYmplY3QsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBNZXJnZXMgYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBwYXJhbWV0ZXJzIGFuZCByZS1yZXF1ZXN0cyB0aWxlcyBvbiB0aGUgY3VycmVudCBzY3JlZW4gKHVubGVzcyBgbm9SZWRyYXdgIHdhcyBzZXQgdG8gdHJ1ZSkuXHJcblx0c2V0UGFyYW1zOiBmdW5jdGlvbiAocGFyYW1zLCBub1JlZHJhdykge1xyXG5cclxuXHRcdGV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVMYXllci53bXMoYmFzZVVybDogU3RyaW5nLCBvcHRpb25zOiBUaWxlTGF5ZXIuV01TIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIFdNUyB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGJhc2UgVVJMIG9mIHRoZSBXTVMgc2VydmljZSBhbmQgYSBXTVMgcGFyYW1ldGVycy9vcHRpb25zIG9iamVjdC5cclxuZnVuY3Rpb24gdGlsZUxheWVyV01TKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVGlsZUxheWVyV01TKHVybCwgb3B0aW9ucyk7XHJcbn1cblxuVGlsZUxheWVyLldNUyA9IFRpbGVMYXllcldNUztcbnRpbGVMYXllci53bXMgPSB0aWxlTGF5ZXJXTVM7XG5cbi8qXG4gKiBAY2xhc3MgUmVuZGVyZXJcbiAqIEBpbmhlcml0cyBMYXllclxuICogQGFrYSBMLlJlbmRlcmVyXG4gKlxuICogQmFzZSBjbGFzcyBmb3IgdmVjdG9yIHJlbmRlcmVyIGltcGxlbWVudGF0aW9ucyAoYFNWR2AsIGBDYW52YXNgKS4gSGFuZGxlcyB0aGVcbiAqIERPTSBjb250YWluZXIgb2YgdGhlIHJlbmRlcmVyLCBpdHMgYm91bmRzLCBhbmQgaXRzIHpvb20gYW5pbWF0aW9uLlxuICpcbiAqIEEgYFJlbmRlcmVyYCB3b3JrcyBhcyBhbiBpbXBsaWNpdCBsYXllciBncm91cCBmb3IgYWxsIGBQYXRoYHMgLSB0aGUgcmVuZGVyZXJcbiAqIGl0c2VsZiBjYW4gYmUgYWRkZWQgb3IgcmVtb3ZlZCB0byB0aGUgbWFwLiBBbGwgcGF0aHMgdXNlIGEgcmVuZGVyZXIsIHdoaWNoIGNhblxuICogYmUgaW1wbGljaXQgKHRoZSBtYXAgd2lsbCBkZWNpZGUgdGhlIHR5cGUgb2YgcmVuZGVyZXIgYW5kIHVzZSBpdCBhdXRvbWF0aWNhbGx5KVxuICogb3IgZXhwbGljaXQgKHVzaW5nIHRoZSBbYHJlbmRlcmVyYF0oI3BhdGgtcmVuZGVyZXIpIG9wdGlvbiBvZiB0aGUgcGF0aCkuXG4gKlxuICogRG8gbm90IHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5LCB1c2UgYFNWR2AgYW5kIGBDYW52YXNgIGluc3RlYWQuXG4gKlxuICogQGV2ZW50IHVwZGF0ZTogRXZlbnRcbiAqIEZpcmVkIHdoZW4gdGhlIHJlbmRlcmVyIHVwZGF0ZXMgaXRzIGJvdW5kcywgY2VudGVyIGFuZCB6b29tLCBmb3IgZXhhbXBsZSB3aGVuXG4gKiBpdHMgbWFwIGhhcyBtb3ZlZFxuICovXG5cbnZhciBSZW5kZXJlciA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBSZW5kZXJlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhZGRpbmc6IE51bWJlciA9IDAuMVxuXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpcCBhcmVhIGFyb3VuZCB0aGUgbWFwIHZpZXcgKHJlbGF0aXZlIHRvIGl0cyBzaXplKVxuXHRcdC8vIGUuZy4gMC4xIHdvdWxkIGJlIDEwJSBvZiBtYXAgdmlldyBpbiBlYWNoIGRpcmVjdGlvblxuXHRcdHBhZGRpbmc6IDAuMSxcblxuXHRcdC8vIEBvcHRpb24gdG9sZXJhbmNlOiBOdW1iZXIgPSAwXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIGNsaWNrIHRvbGVyYW5jZSByb3VuZCBhIHBhdGgvb2JqZWN0IG9uIHRoZSBtYXBcblx0XHR0b2xlcmFuY2UgOiAwXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHN0YW1wKHRoaXMpO1xuXHRcdHRoaXMuX2xheWVycyA9IHRoaXMuX2xheWVycyB8fCB7fTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7IC8vIGRlZmluZWQgYnkgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zXG5cblx0XHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdFx0YWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR0aGlzLm9uKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLm9mZigndXBkYXRlJywgdGhpcy5fdXBkYXRlUGF0aHMsIHRoaXMpO1xuXHRcdHRoaXMuX2Rlc3Ryb3lDb250YWluZXIoKTtcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcblx0XHRcdHpvb206IHRoaXMuX29uWm9vbSxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZSxcblx0XHRcdHpvb21lbmQ6IHRoaXMuX29uWm9vbUVuZFxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcblx0XHR9XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25BbmltWm9vbTogZnVuY3Rpb24gKGV2KSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKGV2LmNlbnRlciwgZXYuem9vbSk7XG5cdH0sXG5cblx0X29uWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHR9LFxuXG5cdF91cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIHRoaXMuX3pvb20pLFxuXHRcdCAgICBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciksXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5fbWFwLmdldFNpemUoKS5tdWx0aXBseUJ5KDAuNSArIHRoaXMub3B0aW9ucy5wYWRkaW5nKSxcblx0XHQgICAgY3VycmVudENlbnRlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QodGhpcy5fY2VudGVyLCB6b29tKSxcblx0XHQgICAgZGVzdENlbnRlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QoY2VudGVyLCB6b29tKSxcblx0XHQgICAgY2VudGVyT2Zmc2V0ID0gZGVzdENlbnRlclBvaW50LnN1YnRyYWN0KGN1cnJlbnRDZW50ZXJQb2ludCksXG5cblx0XHQgICAgdG9wTGVmdE9mZnNldCA9IHZpZXdIYWxmLm11bHRpcGx5QnkoLXNjYWxlKS5hZGQocG9zaXRpb24pLmFkZCh2aWV3SGFsZikuc3VidHJhY3QoY2VudGVyT2Zmc2V0KTtcblxuXHRcdGlmIChhbnkzZCkge1xuXHRcdFx0c2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fY2VudGVyLCB0aGlzLl96b29tKTtcblxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fcmVzZXQoKTtcblx0XHR9XG5cdH0sXG5cblx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fcHJvamVjdCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3VwZGF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVXBkYXRlIHBpeGVsIGJvdW5kcyBvZiByZW5kZXJlciBjb250YWluZXIgKGZvciBwb3NpdGlvbmluZy9zaXppbmcvY2xpcHBpbmcgbGF0ZXIpXG5cdFx0Ly8gU3ViY2xhc3NlcyBhcmUgcmVzcG9uc2libGUgb2YgZmlyaW5nIHRoZSAndXBkYXRlJyBldmVudC5cblx0XHR2YXIgcCA9IHRoaXMub3B0aW9ucy5wYWRkaW5nLFxuXHRcdCAgICBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKSxcblx0XHQgICAgbWluID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHNpemUubXVsdGlwbHlCeSgtcCkpLnJvdW5kKCk7XG5cblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzKG1pbiwgbWluLmFkZChzaXplLm11bHRpcGx5QnkoMSArIHAgKiAyKSkucm91bmQoKSk7XG5cblx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCk7XG5cdFx0dGhpcy5fem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cdH1cbn0pO1xuXG4vKlxuICogQGNsYXNzIENhbnZhc1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuQ2FudmFzXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPWNhbnZhcyksIENhbnZhcyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IElFOCwgYW5kIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMgbWlnaHRcbiAqIG5vdCBkaXNwbGF5IHByb3Blcmx5IGluIHNvbWUgZWRnZSBjYXNlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBDYW52YXMgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5jYW52YXMoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5jYW52YXMoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbnZhciBDYW52YXMgPSBSZW5kZXJlci5leHRlbmQoe1xuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXHRcdGV2ZW50cy52aWV3cHJlcmVzZXQgPSB0aGlzLl9vblZpZXdQcmVSZXNldDtcblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vblZpZXdQcmVSZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFNldCBhIGZsYWcgc28gdGhhdCBhIHZpZXdwcmVyZXNldCttb3ZlZW5kK3ZpZXdyZXNldCBvbmx5IHVwZGF0ZXMmcmVkcmF3cyBvbmNlXG5cdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IHRydWU7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRSZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKTtcblxuXHRcdC8vIFJlZHJhdyB2ZWN0b3JzIHNpbmNlIGNhbnZhcyBpcyBjbGVhcmVkIHVwb24gcmVtb3ZhbCxcblx0XHQvLyBpbiBjYXNlIG9mIHJlbW92aW5nIHRoZSByZW5kZXJlciBpdHNlbGYgZnJvbSB0aGUgbWFwLlxuXHRcdHRoaXMuX2RyYXcoKTtcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuXHRcdG9uKGNvbnRhaW5lciwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcblx0XHRvbihjb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBjb250ZXh0bWVudScsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXHRcdG9uKGNvbnRhaW5lciwgJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlTW91c2VPdXQsIHRoaXMpO1xuXG5cdFx0dGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcmVkcmF3UmVxdWVzdCk7XG5cdFx0ZGVsZXRlIHRoaXMuX2N0eDtcblx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRvZmYodGhpcy5fY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGxheWVyO1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRsYXllci5fdXBkYXRlKCk7XG5cdFx0fVxuXHRcdHRoaXMuX3JlZHJhdygpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIG0gPSByZXRpbmEgPyAyIDogMTtcblxuXHRcdHNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG5cdFx0Ly8gc2V0IGNhbnZhcyBzaXplIChhbHNvIGNsZWFyaW5nIGl0KTsgdXNlIGRvdWJsZSBzaXplIG9uIHJldGluYVxuXHRcdGNvbnRhaW5lci53aWR0aCA9IG0gKiBzaXplLng7XG5cdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG5cdFx0Y29udGFpbmVyLnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4Jztcblx0XHRjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcblxuXHRcdGlmIChyZXRpbmEpIHtcblx0XHRcdHRoaXMuX2N0eC5zY2FsZSgyLCAyKTtcblx0XHR9XG5cblx0XHQvLyB0cmFuc2xhdGUgc28gd2UgdXNlIHRoZSBzYW1lIHBhdGggY29vcmRpbmF0ZXMgYWZ0ZXIgY2FudmFzIGVsZW1lbnQgbW92ZXNcblx0XHR0aGlzLl9jdHgudHJhbnNsYXRlKC1iLm1pbi54LCAtYi5taW4ueSk7XG5cblx0XHQvLyBUZWxsIHBhdGhzIHRvIHJlZHJhdyB0aGVtc2VsdmVzXG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3Jlc2V0LmNhbGwodGhpcyk7XG5cblx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykge1xuXHRcdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fdXBkYXRlUGF0aHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG5cblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXIgPSB7XG5cdFx0XHRsYXllcjogbGF5ZXIsXG5cdFx0XHRwcmV2OiB0aGlzLl9kcmF3TGFzdCxcblx0XHRcdG5leHQ6IG51bGxcblx0XHR9O1xuXHRcdGlmICh0aGlzLl9kcmF3TGFzdCkgeyB0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7IH1cblx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IHRoaXMuX2RyYXdGaXJzdCB8fCB0aGlzLl9kcmF3TGFzdDtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIGxheWVyLl9vcmRlcjtcblxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHQvLyBSZWRyYXcgdGhlIHVuaW9uIG9mIHRoZSBsYXllcidzIG9sZCBwaXhlbFxuXHRcdC8vIGJvdW5kcyBhbmQgdGhlIG5ldyBwaXhlbCBib3VuZHMuXG5cdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHQvLyBUaGUgcmVkcmF3IHdpbGwgZXh0ZW5kIHRoZSByZWRyYXcgYm91bmRzXG5cdFx0Ly8gd2l0aCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZURhc2hBcnJheTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKHR5cGVvZiBsYXllci5vcHRpb25zLmRhc2hBcnJheSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhciBwYXJ0cyA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5LnNwbGl0KC9bLCBdKy8pLFxuXHRcdFx0ICAgIGRhc2hBcnJheSA9IFtdLFxuXHRcdFx0ICAgIGRhc2hWYWx1ZSxcblx0XHRcdCAgICBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRhc2hWYWx1ZSA9IE51bWJlcihwYXJ0c1tpXSk7XG5cdFx0XHRcdC8vIElnbm9yZSBkYXNoIGFycmF5IGNvbnRhaW5pbmcgaW52YWxpZCBsZW5ndGhzXG5cdFx0XHRcdGlmIChpc05hTihkYXNoVmFsdWUpKSB7IHJldHVybjsgfVxuXHRcdFx0XHRkYXNoQXJyYXkucHVzaChkYXNoVmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheTtcblx0XHR9XG5cdH0sXG5cblx0X3JlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcblx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gdGhpcy5fcmVkcmF3UmVxdWVzdCB8fCByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3JlZHJhdywgdGhpcyk7XG5cdH0sXG5cblx0X2V4dGVuZFJlZHJhd0JvdW5kczogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKGxheWVyLl9weEJvdW5kcykge1xuXHRcdFx0dmFyIHBhZGRpbmcgPSAobGF5ZXIub3B0aW9ucy53ZWlnaHQgfHwgMCkgKyAxO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzIHx8IG5ldyBCb3VuZHMoKTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1pbi5zdWJ0cmFjdChbcGFkZGluZywgcGFkZGluZ10pKTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1heC5hZGQoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gbnVsbDtcblxuXHRcdGlmICh0aGlzLl9yZWRyYXdCb3VuZHMpIHtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5taW4uX2Zsb29yKCk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWF4Ll9jZWlsKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fY2xlYXIoKTsgLy8gY2xlYXIgbGF5ZXJzIGluIHJlZHJhdyBib3VuZHNcblx0XHR0aGlzLl9kcmF3KCk7IC8vIGRyYXcgbGF5ZXJzXG5cblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHR9LFxuXG5cdF9jbGVhcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHM7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgc2l6ZS54LCBzaXplLnkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NvbnRhaW5lci53aWR0aCwgdGhpcy5fY29udGFpbmVyLmhlaWdodCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGxheWVyLCBib3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHM7XG5cdFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cdFx0XHR0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG5cdFx0XHR0aGlzLl9jdHgucmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgc2l6ZS54LCBzaXplLnkpO1xuXHRcdFx0dGhpcy5fY3R4LmNsaXAoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kcmF3aW5nID0gdHJ1ZTtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKCFib3VuZHMgfHwgKGxheWVyLl9weEJvdW5kcyAmJiBsYXllci5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSkge1xuXHRcdFx0XHRsYXllci5fdXBkYXRlUGF0aCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2RyYXdpbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7ICAvLyBSZXN0b3JlIHN0YXRlIGJlZm9yZSBjbGlwcGluZy5cblx0fSxcblxuXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcblx0XHRpZiAoIXRoaXMuX2RyYXdpbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgaSwgaiwgbGVuMiwgcCxcblx0XHQgICAgcGFydHMgPSBsYXllci5fcGFydHMsXG5cdFx0ICAgIGxlbiA9IHBhcnRzLmxlbmd0aCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4O1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuOyB9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0c1tpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdFx0cCA9IHBhcnRzW2ldW2pdO1xuXHRcdFx0XHRjdHhbaiA/ICdsaW5lVG8nIDogJ21vdmVUbyddKHAueCwgcC55KTtcblx0XHRcdH1cblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cblx0XHQvLyBUT0RPIG9wdGltaXphdGlvbjogMSBmaWxsL3N0cm9rZSBmb3IgYWxsIGZlYXR1cmVzIHdpdGggZXF1YWwgc3R5bGUgaW5zdGVhZCBvZiAxIGZvciBlYWNoIGZlYXR1cmVcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblxuXHRcdGlmICghdGhpcy5fZHJhd2luZyB8fCBsYXllci5fZW1wdHkoKSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdCAgICBjdHggPSB0aGlzLl9jdHgsXG5cdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcblx0XHQgICAgcyA9IChNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcikgLyByO1xuXG5cdFx0aWYgKHMgIT09IDEpIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguc2NhbGUoMSwgcyk7XG5cdFx0fVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5hcmMocC54LCBwLnkgLyBzLCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuXG5cdFx0aWYgKHMgIT09IDEpIHtcblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblx0fSxcblxuXHRfZmlsbFN0cm9rZTogZnVuY3Rpb24gKGN0eCwgbGF5ZXIpIHtcblx0XHR2YXIgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRjdHguZmlsbChvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlICYmIG9wdGlvbnMud2VpZ2h0ICE9PSAwKSB7XG5cdFx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsYXllci5vcHRpb25zICYmIGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSB8fCBbXSk7XG5cdFx0XHR9XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLm9wYWNpdHk7XG5cdFx0XHRjdHgubGluZVdpZHRoID0gb3B0aW9ucy53ZWlnaHQ7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmxpbmVDYXAgPSBvcHRpb25zLmxpbmVDYXA7XG5cdFx0XHRjdHgubGluZUpvaW4gPSBvcHRpb25zLmxpbmVKb2luO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBDYW52YXMgb2J2aW91c2x5IGRvZXNuJ3QgaGF2ZSBtb3VzZSBldmVudHMgZm9yIGluZGl2aWR1YWwgZHJhd24gb2JqZWN0cyxcblx0Ly8gc28gd2UgZW11bGF0ZSB0aGF0IGJ5IGNhbGN1bGF0aW5nIHdoYXQncyB1bmRlciB0aGUgbW91c2Ugb24gbW91c2Vtb3ZlL2NsaWNrIG1hbnVhbGx5XG5cblx0X29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSksIGxheWVyLCBjbGlja2VkTGF5ZXI7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSAmJiAhdGhpcy5fbWFwLl9kcmFnZ2FibGVNb3ZlZChsYXllcikpIHtcblx0XHRcdFx0Y2xpY2tlZExheWVyID0gbGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjbGlja2VkTGF5ZXIpICB7XG5cdFx0XHRmYWtlU3RvcChlKTtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbY2xpY2tlZExheWVyXSwgZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG5cdFx0dGhpcy5faGFuZGxlTW91c2VIb3ZlcihlLCBwb2ludCk7XG5cdH0sXG5cblxuXHRfaGFuZGxlTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5faG92ZXJlZExheWVyO1xuXHRcdGlmIChsYXllcikge1xuXHRcdFx0Ly8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcblx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbbGF5ZXJdLCBlLCAnbW91c2VvdXQnKTtcblx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IG51bGw7XG5cdFx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVNb3VzZUhvdmVyOiBmdW5jdGlvbiAoZSwgcG9pbnQpIHtcblx0XHRpZiAodGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBsYXllciwgY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0Y2FuZGlkYXRlSG92ZXJlZExheWVyID0gbGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllciAhPT0gdGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVNb3VzZU91dChlKTtcblxuXHRcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllcikge1xuXHRcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7IC8vIGNoYW5nZSBjdXJzb3Jcblx0XHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtjYW5kaWRhdGVIb3ZlcmVkTGF5ZXJdLCBlLCAnbW91c2VvdmVyJyk7XG5cdFx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW3RoaXMuX2hvdmVyZWRMYXllcl0sIGUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSB0cnVlO1xuXHRcdHNldFRpbWVvdXQoTC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcblx0XHR9LCB0aGlzKSwgMzIpO1xuXHR9LFxuXG5cdF9maXJlRXZlbnQ6IGZ1bmN0aW9uIChsYXllcnMsIGUsIHR5cGUpIHtcblx0XHR0aGlzLl9tYXAuX2ZpcmVET01FdmVudChlLCB0eXBlIHx8IGUudHlwZSwgbGF5ZXJzKTtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cblx0XHRpZiAoIW9yZGVyKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBBbHJlYWR5IGxhc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIGlmIChuZXh0KSB7XG5cdFx0XHQvLyBVcGRhdGUgZmlyc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG5cdFx0XHQvLyBzaW5nbGUgZW50cnlcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IHRoaXMuX2RyYXdMYXN0O1xuXHRcdHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjtcblxuXHRcdG9yZGVyLm5leHQgPSBudWxsO1xuXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgZmlyc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIGlmIChwcmV2KSB7XG5cdFx0XHQvLyBVcGRhdGUgbGFzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuXHRcdH1cblxuXHRcdG9yZGVyLnByZXYgPSBudWxsO1xuXG5cdFx0b3JkZXIubmV4dCA9IHRoaXMuX2RyYXdGaXJzdDtcblx0XHR0aGlzLl9kcmF3Rmlyc3QucHJldiA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IG9yZGVyO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNhbnZhcyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmZ1bmN0aW9uIGNhbnZhcyQxKG9wdGlvbnMpIHtcblx0cmV0dXJuIGNhbnZhcyA/IG5ldyBDYW52YXMob3B0aW9ucykgOiBudWxsO1xufVxuXG4vKlxuICogVGhhbmtzIHRvIERtaXRyeSBCYXJhbm92c2t5IGFuZCBoaXMgUmFwaGFlbCBsaWJyYXJ5IGZvciBpbnNwaXJhdGlvbiFcbiAqL1xuXG5cbnZhciB2bWxDcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuXHR0cnkge1xuXHRcdGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKCdsdm1sJywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGx2bWw6JyArIG5hbWUgKyAnIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdH07XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8JyArIG5hbWUgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cImx2bWxcIj4nKTtcblx0XHR9O1xuXHR9XG59KSgpO1xuXG5cbi8qXG4gKiBAY2xhc3MgU1ZHXG4gKlxuICpcbiAqIFZNTCB3YXMgZGVwcmVjYXRlZCBpbiAyMDEyLCB3aGljaCBtZWFucyBWTUwgZnVuY3Rpb25hbGl0eSBleGlzdHMgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqIHdpdGggb2xkIHZlcnNpb25zIG9mIEludGVybmV0IEV4cGxvcmVyLlxuICovXG5cbi8vIG1peGluIHRvIHJlZGVmaW5lIHNvbWUgU1ZHIG1ldGhvZHMgdG8gaGFuZGxlIFZNTCBzeW50YXggd2hpY2ggaXMgc2ltaWxhciBidXQgd2l0aCBzb21lIGRpZmZlcmVuY2VzXG52YXIgdm1sTWl4aW4gPSB7XG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtdm1sLWNvbnRhaW5lcicpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gdm1sQ3JlYXRlKCdzaGFwZScpO1xuXG5cdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC12bWwtc2hhcGUgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cblx0XHRjb250YWluZXIuY29vcmRzaXplID0gJzEgMSc7XG5cblx0XHRsYXllci5fcGF0aCA9IHZtbENyZWF0ZSgncGF0aCcpO1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdHJlbW92ZShjb250YWluZXIpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHN0cm9rZSA9IGxheWVyLl9zdHJva2UsXG5cdFx0ICAgIGZpbGwgPSBsYXllci5fZmlsbCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cblx0XHRjb250YWluZXIuc3Ryb2tlZCA9ICEhb3B0aW9ucy5zdHJva2U7XG5cdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRpZiAoIXN0cm9rZSkge1xuXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gdm1sQ3JlYXRlKCdzdHJva2UnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHJva2UpO1xuXHRcdFx0c3Ryb2tlLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0ICsgJ3B4Jztcblx0XHRcdHN0cm9rZS5jb2xvciA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRzdHJva2Uub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSBpc0FycmF5KG9wdGlvbnMuZGFzaEFycmF5KSA/XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5qb2luKCcgJykgOlxuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLCAnICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9ICcnO1xuXHRcdFx0fVxuXHRcdFx0c3Ryb2tlLmVuZGNhcCA9IG9wdGlvbnMubGluZUNhcC5yZXBsYWNlKCdidXR0JywgJ2ZsYXQnKTtcblx0XHRcdHN0cm9rZS5qb2luc3R5bGUgPSBvcHRpb25zLmxpbmVKb2luO1xuXG5cdFx0fSBlbHNlIGlmIChzdHJva2UpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdHJva2UpO1xuXHRcdFx0bGF5ZXIuX3N0cm9rZSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0aWYgKCFmaWxsKSB7XG5cdFx0XHRcdGZpbGwgPSBsYXllci5fZmlsbCA9IHZtbENyZWF0ZSgnZmlsbCcpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGwpO1xuXHRcdFx0ZmlsbC5jb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRmaWxsLm9wYWNpdHkgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXG5cdFx0fSBlbHNlIGlmIChmaWxsKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XG5cdFx0XHRsYXllci5fZmlsbCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LnJvdW5kKCksXG5cdFx0ICAgIHIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLFxuXHRcdCAgICByMiA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kgfHwgcik7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHQnQUwgJyArIHAueCArICcsJyArIHAueSArICcgJyArIHIgKyAnLCcgKyByMiArICcgMCwnICsgKDY1NTM1ICogMzYwKSk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnYgPSBwYXRoO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0b0JhY2sobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH1cbn07XG5cbnZhciBjcmVhdGUkMiA9IHZtbCA/IHZtbENyZWF0ZSA6IHN2Z0NyZWF0ZTtcblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLlNWR1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zdmcpLCBTVkcgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBBbmRyb2lkIDIueCBhbmQgMy54LlxuICpcbiAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0XG4gKiBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKVxuICogKGEgbm93IGRlcHJlY2F0ZWQgdGVjaG5vbG9neSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpblxuICogdGhpcyBjYXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIFNWRyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLnN2ZygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIFNWRyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLnN2Zyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxudmFyIFNWRyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMuem9vbXN0YXJ0ID0gdGhpcy5fb25ab29tU3RhcnQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQyKCdzdmcnKTtcblxuXHRcdC8vIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGNsaWNrIHRocm91Z2ggc3ZnIHJvb3Q7IHdlJ2xsIHJlc2V0IGl0IGJhY2sgaW4gaW5kaXZpZHVhbCBwYXRoc1xuXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblxuXHRcdHRoaXMuX3Jvb3RHcm91cCA9IGNyZWF0ZSQyKCdnJyk7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3Jvb3RHcm91cCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRvZmYodGhpcy5fY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuXHRcdGRlbGV0ZSB0aGlzLl9yb290R3JvdXA7XG5cdFx0ZGVsZXRlIHRoaXMuX3N2Z1NpemU7XG5cdH0sXG5cblx0X29uWm9vbVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gRHJhZy10aGVuLXBpbmNoIGludGVyYWN0aW9ucyBtaWdodCBtZXNzIHVwIHRoZSBjZW50ZXIgYW5kIHpvb20uXG5cdFx0Ly8gSW4gdGhpcyBjYXNlLCB0aGUgZWFzaWVzdCB3YXkgdG8gcHJldmVudCB0aGlzIGlzIHJlLWRvIHRoZSByZW5kZXJlclxuXHRcdC8vICAgYm91bmRzIGFuZCBwYWRkaW5nIHdoZW4gdGhlIHpvb21pbmcgc3RhcnRzLlxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG5cblx0XHQvLyBzZXQgc2l6ZSBvZiBzdmctY29udGFpbmVyIGlmIGNoYW5nZWRcblx0XHRpZiAoIXRoaXMuX3N2Z1NpemUgfHwgIXRoaXMuX3N2Z1NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR0aGlzLl9zdmdTaXplID0gc2l6ZTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc2l6ZS54KTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUueSk7XG5cdFx0fVxuXG5cdFx0Ly8gbW92ZW1lbnQ6IHVwZGF0ZSBjb250YWluZXIgdmlld0JveCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIGNvb3JkaW5hdGVzIG9mIGluZGl2aWR1YWwgbGF5ZXJzXG5cdFx0c2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFtiLm1pbi54LCBiLm1pbi55LCBzaXplLngsIHNpemUueV0uam9pbignICcpKTtcblxuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0Ly8gbWV0aG9kcyBiZWxvdyBhcmUgY2FsbGVkIGJ5IHZlY3RvciBsYXllcnMgaW1wbGVtZW50YXRpb25zXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoID0gY3JlYXRlJDIoJ3BhdGgnKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aFxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQ3VzdG9tIGNsYXNzIG5hbWUgc2V0IG9uIGFuIGVsZW1lbnQuIE9ubHkgZm9yIFNWRyByZW5kZXJlci5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpIHtcblx0XHRcdGFkZENsYXNzKHBhdGgsIGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKTtcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0YWRkQ2xhc3MocGF0aCwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9yb290R3JvdXApIHsgdGhpcy5faW5pdENvbnRhaW5lcigpOyB9XG5cdFx0dGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHJlbW92ZShsYXllci5fcGF0aCk7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmICghcGF0aCkgeyByZXR1cm47IH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5Jywgb3B0aW9ucy5vcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvcHRpb25zLndlaWdodCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCBvcHRpb25zLmxpbmVDYXApO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIG9wdGlvbnMubGluZUpvaW4pO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBvcHRpb25zLmRhc2hBcnJheSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoT2Zmc2V0KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIG9wdGlvbnMuZGFzaE9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdub25lJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCBvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgcG9pbnRzVG9QYXRoKGxheWVyLl9wYXJ0cywgY2xvc2VkKSk7XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcblx0XHQgICAgcjIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcixcblx0XHQgICAgYXJjID0gJ2EnICsgciArICcsJyArIHIyICsgJyAwIDEsMCAnO1xuXG5cdFx0Ly8gZHJhd2luZyBhIGNpcmNsZSB3aXRoIHR3byBoYWxmLWFyY3Ncblx0XHR2YXIgZCA9IGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdCdNJyArIChwLnggLSByKSArICcsJyArIHAueSArXG5cdFx0XHRhcmMgKyAociAqIDIpICsgJywwICcgK1xuXHRcdFx0YXJjICsgKC1yICogMikgKyAnLDAgJztcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGQpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoKTtcblx0fSxcblxuXHQvLyBTVkcgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiB6SW5kZXggc28gd2UgcmVzb3J0IHRvIGNoYW5naW5nIHRoZSBET00gb3JkZXIgb2YgZWxlbWVudHNcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dG9Gcm9udChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0b0JhY2sobGF5ZXIuX3BhdGgpO1xuXHR9XG59KTtcblxuaWYgKHZtbCkge1xuXHRTVkcuaW5jbHVkZSh2bWxNaXhpbik7XG59XG5cbi8vIEBuYW1lc3BhY2UgU1ZHXG4vLyBAZmFjdG9yeSBMLnN2ZyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBTVkcgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmZ1bmN0aW9uIHN2ZyQxKG9wdGlvbnMpIHtcblx0cmV0dXJuIHN2ZyB8fCB2bWwgPyBuZXcgU1ZHKG9wdGlvbnMpIDogbnVsbDtcbn1cblxuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbmFtZXNwYWNlIE1hcDsgQG1ldGhvZCBnZXRSZW5kZXJlcihsYXllcjogUGF0aCk6IFJlbmRlcmVyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG5cdC8vIGBQYXRoYC4gSXQgd2lsbCBlbnN1cmUgdGhhdCB0aGUgYHJlbmRlcmVyYCBvcHRpb25zIG9mIHRoZSBtYXAgYW5kIHBhdGhzXG5cdC8vIGFyZSByZXNwZWN0ZWQsIGFuZCB0aGF0IHRoZSByZW5kZXJlcnMgZG8gZXhpc3Qgb24gdGhlIG1hcC5cblx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aDsgQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXJcblx0XHQvLyBVc2UgdGhpcyBzcGVjaWZpYyBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIGZvciB0aGlzIHBhdGguIFRha2VzXG5cdFx0Ly8gcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXAncyBbZGVmYXVsdCByZW5kZXJlcl0oI21hcC1yZW5kZXJlcikuXG5cdFx0dmFyIHJlbmRlcmVyID0gbGF5ZXIub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9nZXRQYW5lUmVuZGVyZXIobGF5ZXIub3B0aW9ucy5wYW5lKSB8fCB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fcmVuZGVyZXI7XG5cblx0XHRpZiAoIXJlbmRlcmVyKSB7XG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIocmVuZGVyZXIpKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9LFxuXG5cdF9nZXRQYW5lUmVuZGVyZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09ICdvdmVybGF5UGFuZScgfHwgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXTtcblx0XHRpZiAocmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcih7cGFuZTogbmFtZX0pO1xuXHRcdFx0dGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXSA9IHJlbmRlcmVyO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2NyZWF0ZVJlbmRlcmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdC8vIEBuYW1lc3BhY2UgTWFwOyBAb3B0aW9uIHByZWZlckNhbnZhczogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciBgUGF0aGBzIHNob3VsZCBiZSByZW5kZXJlZCBvbiBhIGBDYW52YXNgIHJlbmRlcmVyLlxuXHRcdC8vIEJ5IGRlZmF1bHQsIGFsbCBgUGF0aGBzIGFyZSByZW5kZXJlZCBpbiBhIGBTVkdgIHJlbmRlcmVyLlxuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnByZWZlckNhbnZhcyAmJiBjYW52YXMkMShvcHRpb25zKSkgfHwgc3ZnJDEob3B0aW9ucyk7XG5cdH1cbn0pO1xuXG4vKlxuICogTC5SZWN0YW5nbGUgZXh0ZW5kcyBQb2x5Z29uIGFuZCBjcmVhdGVzIGEgcmVjdGFuZ2xlIHdoZW4gcGFzc2VkIGEgTGF0TG5nQm91bmRzIG9iamVjdC5cbiAqL1xuXG4vKlxuICogQGNsYXNzIFJlY3RhbmdsZVxuICogQGFrYSBMLlJlY3RhbmdsZVxuICogQGluaGVyaXRzIFBvbHlnb25cbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHJlY3RhbmdsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWdvbmAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVmaW5lIHJlY3RhbmdsZSBnZW9ncmFwaGljYWwgYm91bmRzXG4gKiB2YXIgYm91bmRzID0gW1s1NC41NTkzMjIsIC01Ljc2NzgyMl0sIFs1Ni4xMjEwNjA0LCAtMy4wMjEyNDBdXTtcbiAqXG4gKiAvLyBjcmVhdGUgYW4gb3JhbmdlIHJlY3RhbmdsZVxuICogTC5yZWN0YW5nbGUoYm91bmRzLCB7Y29sb3I6IFwiI2ZmNzgwMFwiLCB3ZWlnaHQ6IDF9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcmVjdGFuZ2xlIGJvdW5kc1xuICogbWFwLmZpdEJvdW5kcyhib3VuZHMpO1xuICogYGBgXG4gKlxuICovXG5cblxudmFyIFJlY3RhbmdsZSA9IFBvbHlnb24uZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRcdFBvbHlnb24ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSwgb3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIHJlY3RhbmdsZSB3aXRoIHRoZSBwYXNzZWQgYm91bmRzLlxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRMYXRMbmdzKHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpKTtcblx0fSxcblxuXHRfYm91bmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0bGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0TG5nQm91bmRzKTtcblx0XHRyZXR1cm4gW1xuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpXG5cdFx0XTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5yZWN0YW5nbGUobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuZnVuY3Rpb24gcmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpO1xufVxuXG5TVkcuY3JlYXRlID0gY3JlYXRlJDI7XG5TVkcucG9pbnRzVG9QYXRoID0gcG9pbnRzVG9QYXRoO1xuXG5HZW9KU09OLmdlb21ldHJ5VG9MYXllciA9IGdlb21ldHJ5VG9MYXllcjtcbkdlb0pTT04uY29vcmRzVG9MYXRMbmcgPSBjb29yZHNUb0xhdExuZztcbkdlb0pTT04uY29vcmRzVG9MYXRMbmdzID0gY29vcmRzVG9MYXRMbmdzO1xuR2VvSlNPTi5sYXRMbmdUb0Nvb3JkcyA9IGxhdExuZ1RvQ29vcmRzO1xuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHMgPSBsYXRMbmdzVG9Db29yZHM7XG5HZW9KU09OLmdldEZlYXR1cmUgPSBnZXRGZWF0dXJlO1xuR2VvSlNPTi5hc0ZlYXR1cmUgPSBhc0ZlYXR1cmU7XG5cbi8qXG4gKiBMLkhhbmRsZXIuQm94Wm9vbSBpcyB1c2VkIHRvIGFkZCBzaGlmdC1kcmFnIHpvb20gaW50ZXJhY3Rpb24gdG8gdGhlIG1hcFxuICogKHpvb20gdG8gYSBzZWxlY3RlZCBib3VuZGluZyBib3gpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGJveFpvb206IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIHRvIGEgcmVjdGFuZ3VsYXIgYXJlYSBzcGVjaWZpZWQgYnlcblx0Ly8gZHJhZ2dpbmcgdGhlIG1vdXNlIHdoaWxlIHByZXNzaW5nIHRoZSBzaGlmdCBrZXkuXG5cdGJveFpvb206IHRydWVcbn0pO1xuXG52YXIgQm94Wm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0bWFwLm9uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95LCB0aGlzKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9uKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbW92ZWQ7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRyZW1vdmUodGhpcy5fcGFuZSk7XG5cdFx0ZGVsZXRlIHRoaXMuX3BhbmU7XG5cdH0sXG5cblx0X3Jlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0fSxcblxuXHRfY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgIT09IDApIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZXNldFN0YXRlVGltZW91dCk7XG5cdFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIENsZWFyIHRoZSBkZWZlcnJlZCByZXNldFN0YXRlIGlmIGl0IGhhc24ndCBleGVjdXRlZCB5ZXQsIG90aGVyd2lzZSBpdFxuXHRcdC8vIHdpbGwgaW50ZXJydXB0IHRoZSBpbnRlcmFjdGlvbiBhbmQgb3JwaGFuIGEgYm94IGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lci5cblx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcblxuXHRcdGRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0ZGlzYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdG9uKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLl9ib3ggPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtem9vbS1ib3gnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0YWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblxuXHRcdFx0dGhpcy5fbWFwLmZpcmUoJ2JveHpvb21zdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQsIHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblxuXHRcdHNldFBvc2l0aW9uKHRoaXMuX2JveCwgYm91bmRzLm1pbik7XG5cblx0XHR0aGlzLl9ib3guc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4Jztcblx0XHR0aGlzLl9ib3guc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4Jztcblx0fSxcblxuXHRfZmluaXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21vdmVkKSB7XG5cdFx0XHRyZW1vdmUodGhpcy5fYm94KTtcblx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cdFx0fVxuXG5cdFx0ZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdGVuYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0b2ZmKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2ZpbmlzaCgpO1xuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkgeyByZXR1cm47IH1cblx0XHQvLyBQb3N0cG9uZSB0byBuZXh0IEpTIHRpY2sgc28gaW50ZXJuYWwgY2xpY2sgZXZlbnQgaGFuZGxpbmdcblx0XHQvLyBzdGlsbCBzZWUgaXQgYXMgXCJtb3ZlZFwiLlxuXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQodGhpcy5fcmVzZXRTdGF0ZSwgdGhpcyksIDApO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50KSk7XG5cblx0XHR0aGlzLl9tYXBcblx0XHRcdC5maXRCb3VuZHMoYm91bmRzKVxuXHRcdFx0LmZpcmUoJ2JveHpvb21lbmQnLCB7Ym94Wm9vbUJvdW5kczogYm91bmRzfSk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5rZXlDb2RlID09PSAyNykge1xuXHRcdFx0dGhpcy5fZmluaXNoKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBib3hab29tOiBIYW5kbGVyXG4vLyBCb3ggKHNoaWZ0LWRyYWcgd2l0aCBtb3VzZSkgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2JveFpvb20nLCBCb3hab29tKTtcblxuLypcbiAqIEwuSGFuZGxlci5Eb3VibGVDbGlja1pvb20gaXMgdXNlZCB0byBoYW5kbGUgZG91YmxlLWNsaWNrIHpvb20gb24gdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5cbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRvdWJsZUNsaWNrWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGluIGJ5IGRvdWJsZSBjbGlja2luZyBvbiBpdCBhbmRcblx0Ly8gem9vbWVkIG91dCBieSBkb3VibGUgY2xpY2tpbmcgd2hpbGUgaG9sZGluZyBzaGlmdC4gSWYgcGFzc2VkXG5cdC8vIGAnY2VudGVyJ2AsIGRvdWJsZS1jbGljayB6b29tIHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZVxuXHQvLyAgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdGRvdWJsZUNsaWNrWm9vbTogdHJ1ZVxufSk7XG5cbnZhciBEb3VibGVDbGlja1pvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgZGVsdGEgPSBtYXAub3B0aW9ucy56b29tRGVsdGEsXG5cdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vL1xuLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4vLyBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoXG4vLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcbi8vXG4vLyBgYGBqc1xuLy8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4vLyBgYGBcbi8vXG4vLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG4vLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RvdWJsZUNsaWNrWm9vbScsIERvdWJsZUNsaWNrWm9vbSk7XG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFwRHJhZyBpcyB1c2VkIHRvIG1ha2UgdGhlIG1hcCBkcmFnZ2FibGUgKHdpdGggcGFubmluZyBpbmVydGlhKSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBkcmFnZ2luZzogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGJlIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cblx0ZHJhZ2dpbmc6IHRydWUsXG5cblx0Ly8gQHNlY3Rpb24gUGFubmluZyBJbmVydGlhIE9wdGlvbnNcblx0Ly8gQG9wdGlvbiBpbmVydGlhOiBCb29sZWFuID0gKlxuXHQvLyBJZiBlbmFibGVkLCBwYW5uaW5nIG9mIHRoZSBtYXAgd2lsbCBoYXZlIGFuIGluZXJ0aWEgZWZmZWN0IHdoZXJlXG5cdC8vIHRoZSBtYXAgYnVpbGRzIG1vbWVudHVtIHdoaWxlIGRyYWdnaW5nIGFuZCBjb250aW51ZXMgbW92aW5nIGluXG5cdC8vIHRoZSBzYW1lIGRpcmVjdGlvbiBmb3Igc29tZSB0aW1lLiBGZWVscyBlc3BlY2lhbGx5IG5pY2Ugb24gdG91Y2hcblx0Ly8gZGV2aWNlcy4gRW5hYmxlZCBieSBkZWZhdWx0IHVubGVzcyBydW5uaW5nIG9uIG9sZCBBbmRyb2lkIGRldmljZXMuXG5cdGluZXJ0aWE6ICFhbmRyb2lkMjMsXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhRGVjZWxlcmF0aW9uOiBOdW1iZXIgPSAzMDAwXG5cdC8vIFRoZSByYXRlIHdpdGggd2hpY2ggdGhlIGluZXJ0aWFsIG1vdmVtZW50IHNsb3dzIGRvd24sIGluIHBpeGVscy9zZWNvbmTCsi5cblx0aW5lcnRpYURlY2VsZXJhdGlvbjogMzQwMCwgLy8gcHgvc14yXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhTWF4U3BlZWQ6IE51bWJlciA9IEluZmluaXR5XG5cdC8vIE1heCBzcGVlZCBvZiB0aGUgaW5lcnRpYWwgbW92ZW1lbnQsIGluIHBpeGVscy9zZWNvbmQuXG5cdGluZXJ0aWFNYXhTcGVlZDogSW5maW5pdHksIC8vIHB4L3NcblxuXHQvLyBAb3B0aW9uIGVhc2VMaW5lYXJpdHk6IE51bWJlciA9IDAuMlxuXHRlYXNlTGluZWFyaXR5OiAwLjIsXG5cblx0Ly8gVE9ETyByZWZhY3RvciwgbW92ZSB0byBDUlNcblx0Ly8gQG9wdGlvbiB3b3JsZENvcHlKdW1wOiBCb29sZWFuID0gZmFsc2Vcblx0Ly8gV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCB0aGUgbWFwIHRyYWNrcyB3aGVuIHlvdSBwYW4gdG8gYW5vdGhlciBcImNvcHlcIlxuXHQvLyBvZiB0aGUgd29ybGQgYW5kIHNlYW1sZXNzbHkganVtcHMgdG8gdGhlIG9yaWdpbmFsIG9uZSBzbyB0aGF0IGFsbCBvdmVybGF5c1xuXHQvLyBsaWtlIG1hcmtlcnMgYW5kIHZlY3RvciBsYXllcnMgYXJlIHN0aWxsIHZpc2libGUuXG5cdHdvcmxkQ29weUp1bXA6IGZhbHNlLFxuXG5cdC8vIEBvcHRpb24gbWF4Qm91bmRzVmlzY29zaXR5OiBOdW1iZXIgPSAwLjBcblx0Ly8gSWYgYG1heEJvdW5kc2AgaXMgc2V0LCB0aGlzIG9wdGlvbiB3aWxsIGNvbnRyb2wgaG93IHNvbGlkIHRoZSBib3VuZHNcblx0Ly8gYXJlIHdoZW4gZHJhZ2dpbmcgdGhlIG1hcCBhcm91bmQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGAwLjBgIGFsbG93cyB0aGVcblx0Ly8gdXNlciB0byBkcmFnIG91dHNpZGUgdGhlIGJvdW5kcyBhdCBub3JtYWwgc3BlZWQsIGhpZ2hlciB2YWx1ZXMgd2lsbFxuXHQvLyBzbG93IGRvd24gbWFwIGRyYWdnaW5nIG91dHNpZGUgYm91bmRzLCBhbmQgYDEuMGAgbWFrZXMgdGhlIGJvdW5kcyBmdWxseVxuXHQvLyBzb2xpZCwgcHJldmVudGluZyB0aGUgdXNlciBmcm9tIGRyYWdnaW5nIG91dHNpZGUgdGhlIGJvdW5kcy5cblx0bWF4Qm91bmRzVmlzY29zaXR5OiAwLjBcbn0pO1xuXG52YXIgRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZShtYXAuX21hcFBhbmUsIG1hcC5fY29udGFpbmVyKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdMaW1pdCwgdGhpcyk7XG5cdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xuXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdXcmFwLCB0aGlzKTtcblx0XHRcdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblxuXHRcdFx0XHRtYXAud2hlblJlYWR5KHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiIGxlYWZsZXQtdG91Y2gtZHJhZycpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKTtcblx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWInKTtcblx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtZHJhZycpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5kaXNhYmxlKCk7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG5cdH0sXG5cblx0bW92aW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmluZztcblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0bWFwLl9zdG9wKCk7XG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyAmJiB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpIHtcblx0XHRcdHZhciBib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IHRvQm91bmRzKFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLm11bHRpcGx5QnkoLTEpLFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0U291dGhFYXN0KCkpLm11bHRpcGx5QnkoLTEpXG5cdFx0XHRcdFx0LmFkZCh0aGlzLl9tYXAuZ2V0U2l6ZSgpKSk7XG5cblx0XHRcdHRoaXMuX3Zpc2Nvc2l0eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4wLCB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSBudWxsO1xuXHRcdH1cblxuXHRcdG1hcFxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLl9sYXN0VGltZSA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnB1c2gocG9zKTtcblx0XHRcdHRoaXMuX3RpbWVzLnB1c2godGltZSk7XG5cblx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKHRpbWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21hcFxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X3BydW5lUG9zaXRpb25zOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHdoaWxlICh0aGlzLl9wb3NpdGlvbnMubGVuZ3RoID4gMSAmJiB0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiA1MCkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnNoaWZ0KCk7XG5cdFx0XHR0aGlzLl90aW1lcy5zaGlmdCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Q2VudGVyID0gdGhpcy5fbWFwLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcblx0XHQgICAgcHhXb3JsZENlbnRlciA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoWzAsIDBdKTtcblxuXHRcdHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCA9IHB4V29ybGRDZW50ZXIuc3VidHJhY3QocHhDZW50ZXIpLng7XG5cdFx0dGhpcy5fd29ybGRXaWR0aCA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKCkuZ2V0U2l6ZSgpLng7XG5cdH0sXG5cblx0X3Zpc2NvdXNMaW1pdDogZnVuY3Rpb24gKHZhbHVlLCB0aHJlc2hvbGQpIHtcblx0XHRyZXR1cm4gdmFsdWUgLSAodmFsdWUgLSB0aHJlc2hvbGQpICogdGhpcy5fdmlzY29zaXR5O1xuXHR9LFxuXG5cdF9vblByZURyYWdMaW1pdDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fdmlzY29zaXR5IHx8ICF0aGlzLl9vZmZzZXRMaW1pdCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zKTtcblxuXHRcdHZhciBsaW1pdCA9IHRoaXMuX29mZnNldExpbWl0O1xuXHRcdGlmIChvZmZzZXQueCA8IGxpbWl0Lm1pbi54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5taW4ueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPCBsaW1pdC5taW4ueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWluLnkpOyB9XG5cdFx0aWYgKG9mZnNldC54ID4gbGltaXQubWF4LngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1heC54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA+IGxpbWl0Lm1heC55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5tYXgueSk7IH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcblx0fSxcblxuXHRfb25QcmVEcmFnV3JhcDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRPRE8gcmVmYWN0b3IgdG8gYmUgYWJsZSB0byBhZGp1c3QgbWFwIHBhbmUgcG9zaXRpb24gYWZ0ZXIgem9vbVxuXHRcdHZhciB3b3JsZFdpZHRoID0gdGhpcy5fd29ybGRXaWR0aCxcblx0XHQgICAgaGFsZldpZHRoID0gTWF0aC5yb3VuZCh3b3JsZFdpZHRoIC8gMiksXG5cdFx0ICAgIGR4ID0gdGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0LFxuXHRcdCAgICB4ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCxcblx0XHQgICAgbmV3WDEgPSAoeCAtIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggKyBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WDIgPSAoeCArIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggLSBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WCA9IE1hdGguYWJzKG5ld1gxICsgZHgpIDwgTWF0aC5hYnMobmV3WDIgKyBkeCkgPyBuZXdYMSA6IG5ld1gyO1xuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5jbG9uZSgpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnggPSBuZXdYO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb3B0aW9ucyA9IG1hcC5vcHRpb25zLFxuXG5cdFx0ICAgIG5vSW5lcnRpYSA9ICFvcHRpb25zLmluZXJ0aWEgfHwgdGhpcy5fdGltZXMubGVuZ3RoIDwgMjtcblxuXHRcdG1hcC5maXJlKCdkcmFnZW5kJywgZSk7XG5cblx0XHRpZiAobm9JbmVydGlhKSB7XG5cdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKCtuZXcgRGF0ZSgpKTtcblxuXHRcdFx0dmFyIGRpcmVjdGlvbiA9IHRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxcblx0XHRcdCAgICBkdXJhdGlvbiA9ICh0aGlzLl9sYXN0VGltZSAtIHRoaXMuX3RpbWVzWzBdKSAvIDEwMDAsXG5cdFx0XHQgICAgZWFzZSA9IG9wdGlvbnMuZWFzZUxpbmVhcml0eSxcblxuXHRcdFx0ICAgIHNwZWVkVmVjdG9yID0gZGlyZWN0aW9uLm11bHRpcGx5QnkoZWFzZSAvIGR1cmF0aW9uKSxcblx0XHRcdCAgICBzcGVlZCA9IHNwZWVkVmVjdG9yLmRpc3RhbmNlVG8oWzAsIDBdKSxcblxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZCA9IE1hdGgubWluKG9wdGlvbnMuaW5lcnRpYU1heFNwZWVkLCBzcGVlZCksXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkVmVjdG9yID0gc3BlZWRWZWN0b3IubXVsdGlwbHlCeShsaW1pdGVkU3BlZWQgLyBzcGVlZCksXG5cblx0XHRcdCAgICBkZWNlbGVyYXRpb25EdXJhdGlvbiA9IGxpbWl0ZWRTcGVlZCAvIChvcHRpb25zLmluZXJ0aWFEZWNlbGVyYXRpb24gKiBlYXNlKSxcblx0XHRcdCAgICBvZmZzZXQgPSBsaW1pdGVkU3BlZWRWZWN0b3IubXVsdGlwbHlCeSgtZGVjZWxlcmF0aW9uRHVyYXRpb24gLyAyKS5yb3VuZCgpO1xuXG5cdFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xuXHRcdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KG9mZnNldCwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuXHRcdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0LCB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogZGVjZWxlcmF0aW9uRHVyYXRpb24sXG5cdFx0XHRcdFx0XHRlYXNlTGluZWFyaXR5OiBlYXNlLFxuXHRcdFx0XHRcdFx0bm9Nb3ZlU3RhcnQ6IHRydWUsXG5cdFx0XHRcdFx0XHRhbmltYXRlOiB0cnVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbi8vIE1hcCBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZHJhZ2dpbmcnLCBEcmFnKTtcblxuLypcbiAqIEwuTWFwLktleWJvYXJkIGlzIGhhbmRsaW5nIGtleWJvYXJkIGludGVyYWN0aW9uIHdpdGggdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBLZXlib2FyZCBOYXZpZ2F0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBNYWtlcyB0aGUgbWFwIGZvY3VzYWJsZSBhbmQgYWxsb3dzIHVzZXJzIHRvIG5hdmlnYXRlIHRoZSBtYXAgd2l0aCBrZXlib2FyZFxuXHQvLyBhcnJvd3MgYW5kIGArYC9gLWAga2V5cy5cblx0a2V5Ym9hcmQ6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiBrZXlib2FyZFBhbkRlbHRhOiBOdW1iZXIgPSA4MFxuXHQvLyBBbW91bnQgb2YgcGl4ZWxzIHRvIHBhbiB3aGVuIHByZXNzaW5nIGFuIGFycm93IGtleS5cblx0a2V5Ym9hcmRQYW5EZWx0YTogODBcbn0pO1xuXG52YXIgS2V5Ym9hcmQgPSBIYW5kbGVyLmV4dGVuZCh7XG5cblx0a2V5Q29kZXM6IHtcblx0XHRsZWZ0OiAgICBbMzddLFxuXHRcdHJpZ2h0OiAgIFszOV0sXG5cdFx0ZG93bjogICAgWzQwXSxcblx0XHR1cDogICAgICBbMzhdLFxuXHRcdHpvb21JbjogIFsxODcsIDEwNywgNjEsIDE3MV0sXG5cdFx0em9vbU91dDogWzE4OSwgMTA5LCA1NCwgMTczXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cblx0XHR0aGlzLl9zZXRQYW5EZWx0YShtYXAub3B0aW9ucy5rZXlib2FyZFBhbkRlbHRhKTtcblx0XHR0aGlzLl9zZXRab29tRGVsdGEobWFwLm9wdGlvbnMuem9vbURlbHRhKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9tYXAuX2NvbnRhaW5lcjtcblxuXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xuXHRcdGlmIChjb250YWluZXIudGFiSW5kZXggPD0gMCkge1xuXHRcdFx0Y29udGFpbmVyLnRhYkluZGV4ID0gJzAnO1xuXHRcdH1cblxuXHRcdG9uKGNvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub24oe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cblx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9mZih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9mb2N1c2VkKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuXHRcdCAgICBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxuXHRcdCAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsLnNjcm9sbExlZnQ7XG5cblx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xuXG5cdFx0d2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG5cdH0sXG5cblx0X29uRm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnZm9jdXMnKTtcblx0fSxcblxuXHRfb25CbHVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdibHVyJyk7XG5cdH0sXG5cblx0X3NldFBhbkRlbHRhOiBmdW5jdGlvbiAocGFuRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3BhbktleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5sZWZ0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmxlZnRbaV1dID0gWy0xICogcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5yaWdodC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5yaWdodFtpXV0gPSBbcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5kb3duLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmRvd25baV1dID0gWzAsIHBhbkRlbHRhXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMudXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMudXBbaV1dID0gWzAsIC0xICogcGFuRGVsdGFdO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbURlbHRhOiBmdW5jdGlvbiAoem9vbURlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl96b29tS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21Jbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tSW5baV1dID0gem9vbURlbHRhO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tT3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21PdXRbaV1dID0gLXpvb21EZWx0YTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGtleSA9IGUua2V5Q29kZSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvZmZzZXQ7XG5cblx0XHRpZiAoa2V5IGluIHRoaXMuX3BhbktleXMpIHtcblx0XHRcdGlmICghbWFwLl9wYW5BbmltIHx8ICFtYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpIHtcblx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5fcGFuS2V5c1trZXldO1xuXHRcdFx0XHRpZiAoZS5zaGlmdEtleSkge1xuXHRcdFx0XHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5tdWx0aXBseUJ5KDMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCk7XG5cblx0XHRcdFx0aWYgKG1hcC5vcHRpb25zLm1heEJvdW5kcykge1xuXHRcdFx0XHRcdG1hcC5wYW5JbnNpZGVCb3VuZHMobWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgKGUuc2hpZnRLZXkgPyAzIDogMSkgKiB0aGlzLl96b29tS2V5c1trZXldKTtcblxuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAyNyAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5jbG9zZU9uRXNjYXBlS2V5KSB7XG5cdFx0XHRtYXAuY2xvc2VQb3B1cCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzdG9wKGUpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkga2V5Ym9hcmQ6IEhhbmRsZXJcbi8vIEtleWJvYXJkIG5hdmlnYXRpb24gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEtleWJvYXJkKTtcblxuLypcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIE1vdXNld2hlZWwgb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHNjcm9sbFdoZWVsWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHVzaW5nIHRoZSBtb3VzZSB3aGVlbC4gSWYgcGFzc2VkIGAnY2VudGVyJ2AsXG5cdC8vIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0c2Nyb2xsV2hlZWxab29tOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxEZWJvdW5jZVRpbWU6IE51bWJlciA9IDQwXG5cdC8vIExpbWl0cyB0aGUgcmF0ZSBhdCB3aGljaCBhIHdoZWVsIGNhbiBmaXJlIChpbiBtaWxsaXNlY29uZHMpLiBCeSBkZWZhdWx0XG5cdC8vIHVzZXIgY2FuJ3Qgem9vbSB2aWEgd2hlZWwgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIDQwIG1zLlxuXHR3aGVlbERlYm91bmNlVGltZTogNDAsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbFB4UGVyWm9vbUxldmVsOiBOdW1iZXIgPSA2MFxuXHQvLyBIb3cgbWFueSBzY3JvbGwgcGl4ZWxzIChhcyByZXBvcnRlZCBieSBbTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhXSgjZG9tZXZlbnQtZ2V0d2hlZWxkZWx0YSkpXG5cdC8vIG1lYW4gYSBjaGFuZ2Ugb2Ygb25lIGZ1bGwgem9vbSBsZXZlbC4gU21hbGxlciB2YWx1ZXMgd2lsbCBtYWtlIHdoZWVsLXpvb21pbmdcblx0Ly8gZmFzdGVyIChhbmQgdmljZSB2ZXJzYSkuXG5cdHdoZWVsUHhQZXJab29tTGV2ZWw6IDYwXG59KTtcblxudmFyIFNjcm9sbFdoZWVsWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblx0fSxcblxuXHRfb25XaGVlbFNjcm9sbDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgZGVsdGEgPSBnZXRXaGVlbERlbHRhKGUpO1xuXG5cdFx0dmFyIGRlYm91bmNlID0gdGhpcy5fbWFwLm9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWU7XG5cblx0XHR0aGlzLl9kZWx0YSArPSBkZWx0YTtcblx0XHR0aGlzLl9sYXN0TW91c2VQb3MgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHRpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGxlZnQgPSBNYXRoLm1heChkZWJvdW5jZSAtICgrbmV3IERhdGUoKSAtIHRoaXMuX3N0YXJ0VGltZSksIDApO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcblx0XHR0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG5cdFx0c3RvcChlKTtcblx0fSxcblxuXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgc25hcCA9IHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwIHx8IDA7XG5cblx0XHRtYXAuX3N0b3AoKTsgLy8gc3RvcCBwYW5uaW5nIGFuZCBmbHkgYW5pbWF0aW9ucyBpZiBhbnlcblxuXHRcdC8vIG1hcCB0aGUgZGVsdGEgd2l0aCBhIHNpZ21vaWQgZnVuY3Rpb24gdG8gLTQuLjQgcmFuZ2UgbGVhbmluZyBvbiAtMS4uMVxuXHRcdHZhciBkMiA9IHRoaXMuX2RlbHRhIC8gKHRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwgKiA0KSxcblx0XHQgICAgZDMgPSA0ICogTWF0aC5sb2coMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGQyKSkpKSAvIE1hdGguTE4yLFxuXHRcdCAgICBkNCA9IHNuYXAgPyBNYXRoLmNlaWwoZDMgLyBzbmFwKSAqIHNuYXAgOiBkMyxcblx0XHQgICAgZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgKHRoaXMuX2RlbHRhID4gMCA/IGQ0IDogLWQ0KSkgLSB6b29tO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0XHRpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20gKyBkZWx0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHNjcm9sbFdoZWVsWm9vbTogSGFuZGxlclxuLy8gU2Nyb2xsIHdoZWVsIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdzY3JvbGxXaGVlbFpvb20nLCBTY3JvbGxXaGVlbFpvb20pO1xuXG4vKlxuICogTC5NYXAuVGFwIGlzIHVzZWQgdG8gZW5hYmxlIG1vYmlsZSBoYWNrcyBsaWtlIHF1aWNrIHRhcHMgYW5kIGxvbmcgaG9sZC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0YXA6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIEVuYWJsZXMgbW9iaWxlIGhhY2tzIGZvciBzdXBwb3J0aW5nIGluc3RhbnQgdGFwcyAoZml4aW5nIDIwMG1zIGNsaWNrXG5cdC8vIGRlbGF5IG9uIGlPUy9BbmRyb2lkKSBhbmQgdG91Y2ggaG9sZHMgKGZpcmVkIGFzIGBjb250ZXh0bWVudWAgZXZlbnRzKS5cblx0dGFwOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gdGFwVG9sZXJhbmNlOiBOdW1iZXIgPSAxNVxuXHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCBoaXMgZmluZ2VyIGR1cmluZyB0b3VjaFxuXHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIHRhcC5cblx0dGFwVG9sZXJhbmNlOiAxNVxufSk7XG5cbnZhciBUYXAgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMpIHsgcmV0dXJuOyB9XG5cblx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblxuXHRcdHRoaXMuX2ZpcmVDbGljayA9IHRydWU7XG5cblx0XHQvLyBkb24ndCBzaW11bGF0ZSBjbGljayBvciB0cmFjayBsb25ncHJlc3MgaWYgbW9yZSB0aGFuIDEgdG91Y2hcblx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF0sXG5cdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cblx0XHQvLyBpZiB0b3VjaGluZyBhIGxpbmssIGhpZ2hsaWdodCBpdFxuXHRcdGlmIChlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHRhZGRDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0fVxuXG5cdFx0Ly8gc2ltdWxhdGUgbG9uZyBob2xkIGJ1dCBzZXR0aW5nIGEgdGltZW91dFxuXHRcdHRoaXMuX2hvbGRUaW1lb3V0ID0gc2V0VGltZW91dChiaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX29uVXAoKTtcblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyksIDEwMDApO1xuXG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vkb3duJywgZmlyc3QpO1xuXG5cdFx0b24oZG9jdW1lbnQsIHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXG5cdFx0b2ZmKGRvY3VtZW50LCB7XG5cdFx0XHR0b3VjaG1vdmU6IHRoaXMuX29uTW92ZSxcblx0XHRcdHRvdWNoZW5kOiB0aGlzLl9vblVwXG5cdFx0fSwgdGhpcyk7XG5cblx0XHRpZiAodGhpcy5fZmlyZUNsaWNrICYmIGUgJiYgZS5jaGFuZ2VkVG91Y2hlcykge1xuXG5cdFx0XHR2YXIgZmlyc3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLFxuXHRcdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0XHRpZiAoZWwgJiYgZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuXHRcdFx0XHRyZW1vdmVDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNldXAnLCBmaXJzdCk7XG5cblx0XHRcdC8vIHNpbXVsYXRlIGNsaWNrIGlmIHRoZSB0b3VjaCBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjbGljaycsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0fSxcblxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vtb3ZlJywgZmlyc3QpO1xuXHR9LFxuXG5cdF9zaW11bGF0ZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuXHRcdHZhciBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuX3NpbXVsYXRlZCA9IHRydWU7XG5cdFx0ZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrID0gdHJ1ZTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KFxuXHRcdCAgICAgICAgdHlwZSwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAxLFxuXHRcdCAgICAgICAgZS5zY3JlZW5YLCBlLnNjcmVlblksXG5cdFx0ICAgICAgICBlLmNsaWVudFgsIGUuY2xpZW50WSxcblx0XHQgICAgICAgIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblxuXHRcdGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0YXA6IEhhbmRsZXJcbi8vIE1vYmlsZSB0b3VjaCBoYWNrcyAocXVpY2sgdGFwIGFuZCB0b3VjaCBob2xkKSBoYW5kbGVyLlxuaWYgKHRvdWNoICYmICFwb2ludGVyKSB7XG5cdE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0YXAnLCBUYXApO1xufVxuXG4vKlxuICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdG91Y2hab29tOiBCb29sZWFufFN0cmluZyA9ICpcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdG91Y2gtZHJhZ2dpbmcgd2l0aCB0d28gZmluZ2Vycy4gSWZcblx0Ly8gcGFzc2VkIGAnY2VudGVyJ2AsIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Zcblx0Ly8gd2hlcmUgdGhlIHRvdWNoIGV2ZW50cyAoZmluZ2Vycykgd2VyZS4gRW5hYmxlZCBmb3IgdG91Y2gtY2FwYWJsZSB3ZWJcblx0Ly8gYnJvd3NlcnMgZXhjZXB0IGZvciBvbGQgQW5kcm9pZHMuXG5cdHRvdWNoWm9vbTogdG91Y2ggJiYgIWFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGJvdW5jZUF0Wm9vbUxpbWl0czogQm9vbGVhbiA9IHRydWVcblx0Ly8gU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gem9vbSBiZXlvbmQgbWluL21heCB6b29tXG5cdC8vIGFuZCB0aGVuIGJvdW5jZSBiYWNrIHdoZW4gcGluY2gtem9vbWluZy5cblx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG59KTtcblxudmFyIFRvdWNoWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRhZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdG9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IG1hcC5fYW5pbWF0aW5nWm9vbSB8fCB0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSk7XG5cblx0XHR0aGlzLl9jZW50ZXJQb2ludCA9IG1hcC5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xuXHRcdHRoaXMuX3N0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gIT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9waW5jaFN0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocDEuYWRkKHAyKS5fZGl2aWRlQnkoMikpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdHRoaXMuX3N0YXJ0Wm9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3pvb21pbmcgPSB0cnVlO1xuXG5cdFx0bWFwLl9zdG9wKCk7XG5cblx0XHRvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcblx0XHRvbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cblx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCAhdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSksXG5cdFx0ICAgIHNjYWxlID0gcDEuZGlzdGFuY2VUbyhwMikgLyB0aGlzLl9zdGFydERpc3Q7XG5cblx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuXHRcdGlmICghbWFwLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzICYmIChcblx0XHRcdCh0aGlzLl96b29tIDwgbWFwLmdldE1pblpvb20oKSAmJiBzY2FsZSA8IDEpIHx8XG5cdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcblx0XHRcdHRoaXMuX3pvb20gPSBtYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRMYXRMbmc7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCBkZWx0YSBmcm9tIHBpbmNoIHRvIGNlbnRlciwgc28gY2VudGVyTGF0TG5nIGlzIGRlbHRhIGFwcGxpZWQgdG8gaW5pdGlhbCBwaW5jaExhdExuZ1xuXHRcdFx0dmFyIGRlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuXHRcdFx0dGhpcy5fY2VudGVyID0gbWFwLnVucHJvamVjdChtYXAucHJvamVjdCh0aGlzLl9waW5jaFN0YXJ0TGF0TG5nLCB0aGlzLl96b29tKS5zdWJ0cmFjdChkZWx0YSksIHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdG1hcC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKTtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0dmFyIG1vdmVGbiA9IGJpbmQobWFwLl9tb3ZlLCBtYXAsIHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSwge3BpbmNoOiB0cnVlLCByb3VuZDogZmFsc2V9KTtcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuXHRcdHByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCB8fCAhdGhpcy5fem9vbWluZykge1xuXHRcdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0b2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuXHRcdG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCk7XG5cblx0XHQvLyBQaW5jaCB1cGRhdGVzIEdyaWRMYXllcnMnIGxldmVscyBvbmx5IHdoZW4gem9vbVNuYXAgaXMgb2ZmLCBzbyB6b29tU25hcCBiZWNvbWVzIG5vVXBkYXRlLlxuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XG5cdFx0XHR0aGlzLl9tYXAuX2FuaW1hdGVab29tKHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSksIHRydWUsIHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fbWFwLl9yZXNldFZpZXcodGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0b3VjaFpvb206IEhhbmRsZXJcbi8vIFRvdWNoIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0b3VjaFpvb20nLCBUb3VjaFpvb20pO1xuXG5NYXAuQm94Wm9vbSA9IEJveFpvb207XG5NYXAuRG91YmxlQ2xpY2tab29tID0gRG91YmxlQ2xpY2tab29tO1xuTWFwLkRyYWcgPSBEcmFnO1xuTWFwLktleWJvYXJkID0gS2V5Ym9hcmQ7XG5NYXAuU2Nyb2xsV2hlZWxab29tID0gU2Nyb2xsV2hlZWxab29tO1xuTWFwLlRhcCA9IFRhcDtcbk1hcC5Ub3VjaFpvb20gPSBUb3VjaFpvb207XG5cbk9iamVjdC5mcmVlemUgPSBmcmVlemU7XG5cbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5leHBvcnRzLkNvbnRyb2wgPSBDb250cm9sO1xuZXhwb3J0cy5jb250cm9sID0gY29udHJvbDtcbmV4cG9ydHMuQnJvd3NlciA9IEJyb3dzZXI7XG5leHBvcnRzLkV2ZW50ZWQgPSBFdmVudGVkO1xuZXhwb3J0cy5NaXhpbiA9IE1peGluO1xuZXhwb3J0cy5VdGlsID0gVXRpbDtcbmV4cG9ydHMuQ2xhc3MgPSBDbGFzcztcbmV4cG9ydHMuSGFuZGxlciA9IEhhbmRsZXI7XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbmV4cG9ydHMuYmluZCA9IGJpbmQ7XG5leHBvcnRzLnN0YW1wID0gc3RhbXA7XG5leHBvcnRzLnNldE9wdGlvbnMgPSBzZXRPcHRpb25zO1xuZXhwb3J0cy5Eb21FdmVudCA9IERvbUV2ZW50O1xuZXhwb3J0cy5Eb21VdGlsID0gRG9tVXRpbDtcbmV4cG9ydHMuUG9zQW5pbWF0aW9uID0gUG9zQW5pbWF0aW9uO1xuZXhwb3J0cy5EcmFnZ2FibGUgPSBEcmFnZ2FibGU7XG5leHBvcnRzLkxpbmVVdGlsID0gTGluZVV0aWw7XG5leHBvcnRzLlBvbHlVdGlsID0gUG9seVV0aWw7XG5leHBvcnRzLlBvaW50ID0gUG9pbnQ7XG5leHBvcnRzLnBvaW50ID0gdG9Qb2ludDtcbmV4cG9ydHMuQm91bmRzID0gQm91bmRzO1xuZXhwb3J0cy5ib3VuZHMgPSB0b0JvdW5kcztcbmV4cG9ydHMuVHJhbnNmb3JtYXRpb24gPSBUcmFuc2Zvcm1hdGlvbjtcbmV4cG9ydHMudHJhbnNmb3JtYXRpb24gPSB0b1RyYW5zZm9ybWF0aW9uO1xuZXhwb3J0cy5Qcm9qZWN0aW9uID0gaW5kZXg7XG5leHBvcnRzLkxhdExuZyA9IExhdExuZztcbmV4cG9ydHMubGF0TG5nID0gdG9MYXRMbmc7XG5leHBvcnRzLkxhdExuZ0JvdW5kcyA9IExhdExuZ0JvdW5kcztcbmV4cG9ydHMubGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHM7XG5leHBvcnRzLkNSUyA9IENSUztcbmV4cG9ydHMuR2VvSlNPTiA9IEdlb0pTT047XG5leHBvcnRzLmdlb0pTT04gPSBnZW9KU09OO1xuZXhwb3J0cy5nZW9Kc29uID0gZ2VvSnNvbjtcbmV4cG9ydHMuTGF5ZXIgPSBMYXllcjtcbmV4cG9ydHMuTGF5ZXJHcm91cCA9IExheWVyR3JvdXA7XG5leHBvcnRzLmxheWVyR3JvdXAgPSBsYXllckdyb3VwO1xuZXhwb3J0cy5GZWF0dXJlR3JvdXAgPSBGZWF0dXJlR3JvdXA7XG5leHBvcnRzLmZlYXR1cmVHcm91cCA9IGZlYXR1cmVHcm91cDtcbmV4cG9ydHMuSW1hZ2VPdmVybGF5ID0gSW1hZ2VPdmVybGF5O1xuZXhwb3J0cy5pbWFnZU92ZXJsYXkgPSBpbWFnZU92ZXJsYXk7XG5leHBvcnRzLlZpZGVvT3ZlcmxheSA9IFZpZGVvT3ZlcmxheTtcbmV4cG9ydHMudmlkZW9PdmVybGF5ID0gdmlkZW9PdmVybGF5O1xuZXhwb3J0cy5TVkdPdmVybGF5ID0gU1ZHT3ZlcmxheTtcbmV4cG9ydHMuc3ZnT3ZlcmxheSA9IHN2Z092ZXJsYXk7XG5leHBvcnRzLkRpdk92ZXJsYXkgPSBEaXZPdmVybGF5O1xuZXhwb3J0cy5Qb3B1cCA9IFBvcHVwO1xuZXhwb3J0cy5wb3B1cCA9IHBvcHVwO1xuZXhwb3J0cy5Ub29sdGlwID0gVG9vbHRpcDtcbmV4cG9ydHMudG9vbHRpcCA9IHRvb2x0aXA7XG5leHBvcnRzLkljb24gPSBJY29uO1xuZXhwb3J0cy5pY29uID0gaWNvbjtcbmV4cG9ydHMuRGl2SWNvbiA9IERpdkljb247XG5leHBvcnRzLmRpdkljb24gPSBkaXZJY29uO1xuZXhwb3J0cy5NYXJrZXIgPSBNYXJrZXI7XG5leHBvcnRzLm1hcmtlciA9IG1hcmtlcjtcbmV4cG9ydHMuVGlsZUxheWVyID0gVGlsZUxheWVyO1xuZXhwb3J0cy50aWxlTGF5ZXIgPSB0aWxlTGF5ZXI7XG5leHBvcnRzLkdyaWRMYXllciA9IEdyaWRMYXllcjtcbmV4cG9ydHMuZ3JpZExheWVyID0gZ3JpZExheWVyO1xuZXhwb3J0cy5TVkcgPSBTVkc7XG5leHBvcnRzLnN2ZyA9IHN2ZyQxO1xuZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xuZXhwb3J0cy5DYW52YXMgPSBDYW52YXM7XG5leHBvcnRzLmNhbnZhcyA9IGNhbnZhcyQxO1xuZXhwb3J0cy5QYXRoID0gUGF0aDtcbmV4cG9ydHMuQ2lyY2xlTWFya2VyID0gQ2lyY2xlTWFya2VyO1xuZXhwb3J0cy5jaXJjbGVNYXJrZXIgPSBjaXJjbGVNYXJrZXI7XG5leHBvcnRzLkNpcmNsZSA9IENpcmNsZTtcbmV4cG9ydHMuY2lyY2xlID0gY2lyY2xlO1xuZXhwb3J0cy5Qb2x5bGluZSA9IFBvbHlsaW5lO1xuZXhwb3J0cy5wb2x5bGluZSA9IHBvbHlsaW5lO1xuZXhwb3J0cy5Qb2x5Z29uID0gUG9seWdvbjtcbmV4cG9ydHMucG9seWdvbiA9IHBvbHlnb247XG5leHBvcnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcbmV4cG9ydHMucmVjdGFuZ2xlID0gcmVjdGFuZ2xlO1xuZXhwb3J0cy5NYXAgPSBNYXA7XG5leHBvcnRzLm1hcCA9IGNyZWF0ZU1hcDtcblxudmFyIG9sZEwgPSB3aW5kb3cuTDtcbmV4cG9ydHMubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuXHR3aW5kb3cuTCA9IG9sZEw7XG5cdHJldHVybiB0aGlzO1xufVxuXG4vLyBBbHdheXMgZXhwb3J0IHVzIHRvIHdpbmRvdyBnbG9iYWwgKHNlZSAjMjM2NClcbndpbmRvdy5MID0gZXhwb3J0cztcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlYWZsZXQtc3JjLmpzLm1hcFxuIiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbGVhZmxldC5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbGVhZmxldC5jc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcblxuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdXBkYXRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtbyA9IHt9O1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gIH1cblxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gIH1cblxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuXG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cblxuICBjc3MgKz0gb2JqLmNzcztcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07IiwiLyoqXG4gKiB2aXMtZGF0YVxuICogaHR0cDovL3Zpc2pzLm9yZy9cbiAqXG4gKiBNYW5hZ2UgdW5zdHJ1Y3R1cmVkIGRhdGEgdXNpbmcgRGF0YVNldC4gQWRkLCB1cGRhdGUsIGFuZCByZW1vdmUgZGF0YSwgYW5kIGxpc3RlbiBmb3IgY2hhbmdlcyBpbiB0aGUgZGF0YS5cbiAqXG4gKiBAdmVyc2lvbiA3LjEuNFxuICogQGRhdGUgICAgMjAyMi0wMy0xNVQxNToyMzo1OS4yNDVaXG4gKlxuICogQGNvcHlyaWdodCAoYykgMjAxMS0yMDE3IEFsbWVuZGUgQi5WLCBodHRwOi8vYWxtZW5kZS5jb21cbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTctMjAxOSB2aXNqcyBjb250cmlidXRvcnMsIGh0dHBzOi8vZ2l0aHViLmNvbS92aXNqc1xuICpcbiAqIEBsaWNlbnNlXG4gKiB2aXMuanMgaXMgZHVhbCBsaWNlbnNlZCB1bmRlciBib3RoXG4gKlxuICogICAxLiBUaGUgQXBhY2hlIDIuMCBMaWNlbnNlXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICAgYW5kXG4gKlxuICogICAyLiBUaGUgTUlUIExpY2Vuc2VcbiAqICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICpcbiAqIHZpcy5qcyBtYXkgYmUgZGlzdHJpYnV0ZWQgdW5kZXIgZWl0aGVyIGxpY2Vuc2UuXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC52aXMgPSBnbG9iYWwudmlzIHx8IHt9KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG4gIHZhciBkZWZpbmVQcm9wZXJ0eSRlID0ge2V4cG9ydHM6IHt9fTtcblxuICB2YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xuICB9OyAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxuXG5cbiAgdmFyIGdsb2JhbCRNID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHwgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fCBjaGVjayh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwpIHx8IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0oKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIHZhciBmYWlscyRyID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuICEhZXhlYygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGZhaWxzJHEgPSBmYWlscyRyO1xuICB2YXIgZnVuY3Rpb25CaW5kTmF0aXZlID0gIWZhaWxzJHEoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyogZW1wdHkgKi9cbiAgICB9LmJpbmQoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG5cblxuICAgIHJldHVybiB0eXBlb2YgdGVzdCAhPSAnZnVuY3Rpb24nIHx8IHRlc3QuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZScpO1xuICB9KTtcblxuICB2YXIgTkFUSVZFX0JJTkQkNCA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcbiAgdmFyIEZ1bmN0aW9uUHJvdG90eXBlJDMgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gIHZhciBhcHBseSQ2ID0gRnVuY3Rpb25Qcm90b3R5cGUkMy5hcHBseTtcbiAgdmFyIGNhbGwkYyA9IEZ1bmN0aW9uUHJvdG90eXBlJDMuY2FsbDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXJlZmxlY3QgLS0gc2FmZVxuXG4gIHZhciBmdW5jdGlvbkFwcGx5ID0gdHlwZW9mIFJlZmxlY3QgPT0gJ29iamVjdCcgJiYgUmVmbGVjdC5hcHBseSB8fCAoTkFUSVZFX0JJTkQkNCA/IGNhbGwkYy5iaW5kKGFwcGx5JDYpIDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsJGMuYXBwbHkoYXBwbHkkNiwgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgdmFyIE5BVElWRV9CSU5EJDMgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG4gIHZhciBGdW5jdGlvblByb3RvdHlwZSQyID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgYmluZCRkID0gRnVuY3Rpb25Qcm90b3R5cGUkMi5iaW5kO1xuICB2YXIgY2FsbCRiID0gRnVuY3Rpb25Qcm90b3R5cGUkMi5jYWxsO1xuICB2YXIgdW5jdXJyeVRoaXMkdCA9IE5BVElWRV9CSU5EJDMgJiYgYmluZCRkLmJpbmQoY2FsbCRiLCBjYWxsJGIpO1xuICB2YXIgZnVuY3Rpb25VbmN1cnJ5VGhpcyA9IE5BVElWRV9CSU5EJDMgPyBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gZm4gJiYgdW5jdXJyeVRoaXMkdChmbik7XG4gIH0gOiBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gZm4gJiYgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNhbGwkYi5hcHBseShmbiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxuXG4gIHZhciBpc0NhbGxhYmxlJGggPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbic7XG4gIH07XG5cbiAgdmFyIG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHt9O1xuXG4gIHZhciBmYWlscyRwID0gZmFpbHMkcjsgLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cblxuICB2YXIgZGVzY3JpcHRvcnMgPSAhZmFpbHMkcChmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gNztcbiAgICAgIH1cbiAgICB9KVsxXSAhPSA3O1xuICB9KTtcblxuICB2YXIgTkFUSVZFX0JJTkQkMiA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcbiAgdmFyIGNhbGwkYSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xuICB2YXIgZnVuY3Rpb25DYWxsID0gTkFUSVZFX0JJTkQkMiA/IGNhbGwkYS5iaW5kKGNhbGwkYSkgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGwkYS5hcHBseShjYWxsJGEsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlID0ge307XG5cbiAgdmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSQyID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcblxuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyAvLyBOYXNob3JuIH4gSkRLOCBidWdcblxuICB2YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNSAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlJDIuY2FsbCh7XG4gICAgMTogMlxuICB9LCAxKTsgLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcblxuICBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNSh0aGlzLCBWKTtcbiAgICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbiAgfSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZSQyO1xuXG4gIHZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNSA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH07XG4gIH07XG5cbiAgdmFyIHVuY3VycnlUaGlzJHMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgdG9TdHJpbmckOSA9IHVuY3VycnlUaGlzJHMoe30udG9TdHJpbmcpO1xuICB2YXIgc3RyaW5nU2xpY2UkMSA9IHVuY3VycnlUaGlzJHMoJycuc2xpY2UpO1xuXG4gIHZhciBjbGFzc29mUmF3JDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gc3RyaW5nU2xpY2UkMSh0b1N0cmluZyQ5KGl0KSwgOCwgLTEpO1xuICB9O1xuXG4gIHZhciBnbG9iYWwkTCA9IGdsb2JhbCRNO1xuICB2YXIgdW5jdXJyeVRoaXMkciA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBmYWlscyRvID0gZmFpbHMkcjtcbiAgdmFyIGNsYXNzb2YkZiA9IGNsYXNzb2ZSYXckMTtcbiAgdmFyIE9iamVjdCQ5ID0gZ2xvYmFsJEwuT2JqZWN0O1xuICB2YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcyRyKCcnLnNwbGl0KTsgLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcblxuICB2YXIgaW5kZXhlZE9iamVjdCA9IGZhaWxzJG8oZnVuY3Rpb24gKCkge1xuICAgIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgICByZXR1cm4gIU9iamVjdCQ5KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG4gIH0pID8gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGNsYXNzb2YkZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogT2JqZWN0JDkoaXQpO1xuICB9IDogT2JqZWN0JDk7XG5cbiAgdmFyIGdsb2JhbCRLID0gZ2xvYmFsJE07XG4gIHZhciBUeXBlRXJyb3IkaiA9IGdsb2JhbCRLLlR5cGVFcnJvcjsgLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcblxuICB2YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yJGooXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgICByZXR1cm4gaXQ7XG4gIH07XG5cbiAgdmFyIEluZGV4ZWRPYmplY3QkMyA9IGluZGV4ZWRPYmplY3Q7XG4gIHZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDU7XG5cbiAgdmFyIHRvSW5kZXhlZE9iamVjdCRiID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIEluZGV4ZWRPYmplY3QkMyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQoaXQpKTtcbiAgfTtcblxuICB2YXIgaXNDYWxsYWJsZSRnID0gaXNDYWxsYWJsZSRoO1xuXG4gIHZhciBpc09iamVjdCRmID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZSRnKGl0KTtcbiAgfTtcblxuICB2YXIgcGF0aCRxID0ge307XG5cbiAgdmFyIHBhdGgkcCA9IHBhdGgkcTtcbiAgdmFyIGdsb2JhbCRKID0gZ2xvYmFsJE07XG4gIHZhciBpc0NhbGxhYmxlJGYgPSBpc0NhbGxhYmxlJGg7XG5cbiAgdmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgIHJldHVybiBpc0NhbGxhYmxlJGYodmFyaWFibGUpID8gdmFyaWFibGUgOiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgdmFyIGdldEJ1aWx0SW4kOSA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihwYXRoJHBbbmFtZXNwYWNlXSkgfHwgYUZ1bmN0aW9uKGdsb2JhbCRKW25hbWVzcGFjZV0pIDogcGF0aCRwW25hbWVzcGFjZV0gJiYgcGF0aCRwW25hbWVzcGFjZV1bbWV0aG9kXSB8fCBnbG9iYWwkSltuYW1lc3BhY2VdICYmIGdsb2JhbCRKW25hbWVzcGFjZV1bbWV0aG9kXTtcbiAgfTtcblxuICB2YXIgdW5jdXJyeVRoaXMkcSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBvYmplY3RJc1Byb3RvdHlwZU9mID0gdW5jdXJyeVRoaXMkcSh7fS5pc1Byb3RvdHlwZU9mKTtcblxuICB2YXIgZ2V0QnVpbHRJbiQ4ID0gZ2V0QnVpbHRJbiQ5O1xuICB2YXIgZW5naW5lVXNlckFnZW50ID0gZ2V0QnVpbHRJbiQ4KCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG5cbiAgdmFyIGdsb2JhbCRJID0gZ2xvYmFsJE07XG4gIHZhciB1c2VyQWdlbnQkMyA9IGVuZ2luZVVzZXJBZ2VudDtcbiAgdmFyIHByb2Nlc3MgPSBnbG9iYWwkSS5wcm9jZXNzO1xuICB2YXIgRGVubyA9IGdsb2JhbCRJLkRlbm87XG4gIHZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucyB8fCBEZW5vICYmIERlbm8udmVyc2lvbjtcbiAgdmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG4gIHZhciBtYXRjaCwgdmVyc2lvbjtcblxuICBpZiAodjgpIHtcbiAgICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7IC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcbiAgICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuXG4gICAgdmVyc2lvbiA9IG1hdGNoWzBdID4gMCAmJiBtYXRjaFswXSA8IDQgPyAxIDogKyhtYXRjaFswXSArIG1hdGNoWzFdKTtcbiAgfSAvLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbiAgLy8gc28gY2hlY2sgYHVzZXJBZ2VudGAgZXZlbiBpZiBgLnY4YCBleGlzdHMsIGJ1dCAwXG5cblxuICBpZiAoIXZlcnNpb24gJiYgdXNlckFnZW50JDMpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudCQzLm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG5cbiAgICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgICBtYXRjaCA9IHVzZXJBZ2VudCQzLm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgICB9XG4gIH1cblxuICB2YXIgZW5naW5lVjhWZXJzaW9uID0gdmVyc2lvbjtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbiAgdmFyIFY4X1ZFUlNJT04kMiA9IGVuZ2luZVY4VmVyc2lvbjtcbiAgdmFyIGZhaWxzJG4gPSBmYWlscyRyOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuXG4gIHZhciBuYXRpdmVTeW1ib2wgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzJG4oZnVuY3Rpb24gKCkge1xuICAgIHZhciBzeW1ib2wgPSBTeW1ib2woKTsgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG5cbiAgICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8IC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04kMiAmJiBWOF9WRVJTSU9OJDIgPCA0MTtcbiAgfSk7XG5cbiAgLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG4gIHZhciBOQVRJVkVfU1lNQk9MJDIgPSBuYXRpdmVTeW1ib2w7XG4gIHZhciB1c2VTeW1ib2xBc1VpZCA9IE5BVElWRV9TWU1CT0wkMiAmJiAhU3ltYm9sLnNoYW0gJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxuICB2YXIgZ2xvYmFsJEggPSBnbG9iYWwkTTtcbiAgdmFyIGdldEJ1aWx0SW4kNyA9IGdldEJ1aWx0SW4kOTtcbiAgdmFyIGlzQ2FsbGFibGUkZSA9IGlzQ2FsbGFibGUkaDtcbiAgdmFyIGlzUHJvdG90eXBlT2YkaSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG4gIHZhciBVU0VfU1lNQk9MX0FTX1VJRCQxID0gdXNlU3ltYm9sQXNVaWQ7XG4gIHZhciBPYmplY3QkOCA9IGdsb2JhbCRILk9iamVjdDtcbiAgdmFyIGlzU3ltYm9sJDMgPSBVU0VfU1lNQk9MX0FTX1VJRCQxID8gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbiAgfSA6IGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbiQ3KCdTeW1ib2wnKTtcbiAgICByZXR1cm4gaXNDYWxsYWJsZSRlKCRTeW1ib2wpICYmIGlzUHJvdG90eXBlT2YkaSgkU3ltYm9sLnByb3RvdHlwZSwgT2JqZWN0JDgoaXQpKTtcbiAgfTtcblxuICB2YXIgZ2xvYmFsJEcgPSBnbG9iYWwkTTtcbiAgdmFyIFN0cmluZyQ0ID0gZ2xvYmFsJEcuU3RyaW5nO1xuXG4gIHZhciB0cnlUb1N0cmluZyQ0ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBTdHJpbmckNChhcmd1bWVudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiAnT2JqZWN0JztcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdsb2JhbCRGID0gZ2xvYmFsJE07XG4gIHZhciBpc0NhbGxhYmxlJGQgPSBpc0NhbGxhYmxlJGg7XG4gIHZhciB0cnlUb1N0cmluZyQzID0gdHJ5VG9TdHJpbmckNDtcbiAgdmFyIFR5cGVFcnJvciRpID0gZ2xvYmFsJEYuVHlwZUVycm9yOyAvLyBgQXNzZXJ0OiBJc0NhbGxhYmxlKGFyZ3VtZW50KSBpcyB0cnVlYFxuXG4gIHZhciBhQ2FsbGFibGUkNyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgIGlmIChpc0NhbGxhYmxlJGQoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gICAgdGhyb3cgVHlwZUVycm9yJGkodHJ5VG9TdHJpbmckMyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH07XG5cbiAgdmFyIGFDYWxsYWJsZSQ2ID0gYUNhbGxhYmxlJDc7IC8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxuXG4gIHZhciBnZXRNZXRob2QkMyA9IGZ1bmN0aW9uIChWLCBQKSB7XG4gICAgdmFyIGZ1bmMgPSBWW1BdO1xuICAgIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhQ2FsbGFibGUkNihmdW5jKTtcbiAgfTtcblxuICB2YXIgZ2xvYmFsJEUgPSBnbG9iYWwkTTtcbiAgdmFyIGNhbGwkOSA9IGZ1bmN0aW9uQ2FsbDtcbiAgdmFyIGlzQ2FsbGFibGUkYyA9IGlzQ2FsbGFibGUkaDtcbiAgdmFyIGlzT2JqZWN0JGUgPSBpc09iamVjdCRmO1xuICB2YXIgVHlwZUVycm9yJGggPSBnbG9iYWwkRS5UeXBlRXJyb3I7IC8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG5cbiAgdmFyIG9yZGluYXJ5VG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICAgIHZhciBmbiwgdmFsO1xuICAgIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJGMoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JGUodmFsID0gY2FsbCQ5KGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICAgIGlmIChpc0NhbGxhYmxlJGMoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QkZSh2YWwgPSBjYWxsJDkoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gICAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkYyhmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkZSh2YWwgPSBjYWxsJDkoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gICAgdGhyb3cgVHlwZUVycm9yJGgoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH07XG5cbiAgdmFyIHNoYXJlZCQ0ID0ge2V4cG9ydHM6IHt9fTtcblxuICB2YXIgZ2xvYmFsJEQgPSBnbG9iYWwkTTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG5cbiAgdmFyIGRlZmluZVByb3BlcnR5JGQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbiAgdmFyIHNldEdsb2JhbCQxID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgZGVmaW5lUHJvcGVydHkkZChnbG9iYWwkRCwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGdsb2JhbCREW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgdmFyIGdsb2JhbCRDID0gZ2xvYmFsJE07XG4gIHZhciBzZXRHbG9iYWwgPSBzZXRHbG9iYWwkMTtcbiAgdmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xuICB2YXIgc3RvcmUkMyA9IGdsb2JhbCRDW1NIQVJFRF0gfHwgc2V0R2xvYmFsKFNIQVJFRCwge30pO1xuICB2YXIgc2hhcmVkU3RvcmUgPSBzdG9yZSQzO1xuXG4gIHZhciBzdG9yZSQyID0gc2hhcmVkU3RvcmU7XG4gIChzaGFyZWQkNC5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc3RvcmUkMltrZXldIHx8IChzdG9yZSQyW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG4gIH0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgICB2ZXJzaW9uOiAnMy4yMS4xJyxcbiAgICBtb2RlOiAncHVyZScgLFxuICAgIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gICAgbGljZW5zZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvdjMuMjEuMS9MSUNFTlNFJyxcbiAgICBzb3VyY2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcydcbiAgfSk7XG5cbiAgdmFyIGdsb2JhbCRCID0gZ2xvYmFsJE07XG4gIHZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDMgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDU7XG4gIHZhciBPYmplY3QkNyA9IGdsb2JhbCRCLk9iamVjdDsgLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxuXG4gIHZhciB0b09iamVjdCRlID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgcmV0dXJuIE9iamVjdCQ3KHJlcXVpcmVPYmplY3RDb2VyY2libGUkMyhhcmd1bWVudCkpO1xuICB9O1xuXG4gIHZhciB1bmN1cnJ5VGhpcyRwID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIHRvT2JqZWN0JGQgPSB0b09iamVjdCRlO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyRwKHt9Lmhhc093blByb3BlcnR5KTsgLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1oYXNvd25wcm9wZXJ0eVxuXG4gIHZhciBoYXNPd25Qcm9wZXJ0eV8xID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0b09iamVjdCRkKGl0KSwga2V5KTtcbiAgfTtcblxuICB2YXIgdW5jdXJyeVRoaXMkbyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBpZCQxID0gMDtcbiAgdmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xuICB2YXIgdG9TdHJpbmckOCA9IHVuY3VycnlUaGlzJG8oMS4wLnRvU3RyaW5nKTtcblxuICB2YXIgdWlkJDQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZyQ4KCsraWQkMSArIHBvc3RmaXgsIDM2KTtcbiAgfTtcblxuICB2YXIgZ2xvYmFsJEEgPSBnbG9iYWwkTTtcbiAgdmFyIHNoYXJlZCQzID0gc2hhcmVkJDQuZXhwb3J0cztcbiAgdmFyIGhhc093biRmID0gaGFzT3duUHJvcGVydHlfMTtcbiAgdmFyIHVpZCQzID0gdWlkJDQ7XG4gIHZhciBOQVRJVkVfU1lNQk9MJDEgPSBuYXRpdmVTeW1ib2w7XG4gIHZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHVzZVN5bWJvbEFzVWlkO1xuICB2YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlJDEgPSBzaGFyZWQkMygnd2tzJyk7XG4gIHZhciBTeW1ib2wkMiA9IGdsb2JhbCRBLlN5bWJvbDtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbCQyICYmIFN5bWJvbCQyWydmb3InXTtcbiAgdmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sJDIgOiBTeW1ib2wkMiAmJiBTeW1ib2wkMi53aXRob3V0U2V0dGVyIHx8IHVpZCQzO1xuXG4gIHZhciB3ZWxsS25vd25TeW1ib2wkaiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKCFoYXNPd24kZihXZWxsS25vd25TeW1ib2xzU3RvcmUkMSwgbmFtZSkgfHwgIShOQVRJVkVfU1lNQk9MJDEgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZSQxW25hbWVdID09ICdzdHJpbmcnKSkge1xuICAgICAgdmFyIGRlc2NyaXB0aW9uID0gJ1N5bWJvbC4nICsgbmFtZTtcblxuICAgICAgaWYgKE5BVElWRV9TWU1CT0wkMSAmJiBoYXNPd24kZihTeW1ib2wkMiwgbmFtZSkpIHtcbiAgICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlJDFbbmFtZV0gPSBTeW1ib2wkMltuYW1lXTtcbiAgICAgIH0gZWxzZSBpZiAoVVNFX1NZTUJPTF9BU19VSUQgJiYgc3ltYm9sRm9yKSB7XG4gICAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZSQxW25hbWVdID0gc3ltYm9sRm9yKGRlc2NyaXB0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZSQxW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKGRlc2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlJDFbbmFtZV07XG4gIH07XG5cbiAgdmFyIGdsb2JhbCR6ID0gZ2xvYmFsJE07XG4gIHZhciBjYWxsJDggPSBmdW5jdGlvbkNhbGw7XG4gIHZhciBpc09iamVjdCRkID0gaXNPYmplY3QkZjtcbiAgdmFyIGlzU3ltYm9sJDIgPSBpc1N5bWJvbCQzO1xuICB2YXIgZ2V0TWV0aG9kJDIgPSBnZXRNZXRob2QkMztcbiAgdmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBvcmRpbmFyeVRvUHJpbWl0aXZlJDE7XG4gIHZhciB3ZWxsS25vd25TeW1ib2wkaSA9IHdlbGxLbm93blN5bWJvbCRqO1xuICB2YXIgVHlwZUVycm9yJGcgPSBnbG9iYWwkei5UeXBlRXJyb3I7XG4gIHZhciBUT19QUklNSVRJVkUkMSA9IHdlbGxLbm93blN5bWJvbCRpKCd0b1ByaW1pdGl2ZScpOyAvLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG5cbiAgdmFyIHRvUHJpbWl0aXZlJDEgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgICBpZiAoIWlzT2JqZWN0JGQoaW5wdXQpIHx8IGlzU3ltYm9sJDIoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gICAgdmFyIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZCQyKGlucHV0LCBUT19QUklNSVRJVkUkMSk7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgICByZXN1bHQgPSBjYWxsJDgoZXhvdGljVG9QcmltLCBpbnB1dCwgcHJlZik7XG4gICAgICBpZiAoIWlzT2JqZWN0JGQocmVzdWx0KSB8fCBpc1N5bWJvbCQyKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IkZyhcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbiAgICB9XG5cbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ251bWJlcic7XG4gICAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xuICB9O1xuXG4gIHZhciB0b1ByaW1pdGl2ZSA9IHRvUHJpbWl0aXZlJDE7XG4gIHZhciBpc1N5bWJvbCQxID0gaXNTeW1ib2wkMzsgLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcblxuICB2YXIgdG9Qcm9wZXJ0eUtleSQ0ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCAnc3RyaW5nJyk7XG4gICAgcmV0dXJuIGlzU3ltYm9sJDEoa2V5KSA/IGtleSA6IGtleSArICcnO1xuICB9O1xuXG4gIHZhciBnbG9iYWwkeSA9IGdsb2JhbCRNO1xuICB2YXIgaXNPYmplY3QkYyA9IGlzT2JqZWN0JGY7XG4gIHZhciBkb2N1bWVudCQxID0gZ2xvYmFsJHkuZG9jdW1lbnQ7IC8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxuXG4gIHZhciBFWElTVFMkMSA9IGlzT2JqZWN0JGMoZG9jdW1lbnQkMSkgJiYgaXNPYmplY3QkYyhkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQpO1xuXG4gIHZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBFWElTVFMkMSA/IGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbiAgfTtcblxuICB2YXIgREVTQ1JJUFRPUlMkaCA9IGRlc2NyaXB0b3JzO1xuICB2YXIgZmFpbHMkbSA9IGZhaWxzJHI7XG4gIHZhciBjcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDE7IC8vIFRoYW5rcyB0byBJRTggZm9yIGl0cyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxuXG4gIHZhciBpZThEb21EZWZpbmUgPSAhREVTQ1JJUFRPUlMkaCAmJiAhZmFpbHMkbShmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiA3O1xuICAgICAgfVxuICAgIH0pLmEgIT0gNztcbiAgfSk7XG5cbiAgdmFyIERFU0NSSVBUT1JTJGcgPSBkZXNjcmlwdG9ycztcbiAgdmFyIGNhbGwkNyA9IGZ1bmN0aW9uQ2FsbDtcbiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDIgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgdmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ0ID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG4gIHZhciB0b0luZGV4ZWRPYmplY3QkYSA9IHRvSW5kZXhlZE9iamVjdCRiO1xuICB2YXIgdG9Qcm9wZXJ0eUtleSQzID0gdG9Qcm9wZXJ0eUtleSQ0O1xuICB2YXIgaGFzT3duJGUgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuICB2YXIgSUU4X0RPTV9ERUZJTkUkMSA9IGllOERvbURlZmluZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuXG4gIHZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuXG4gIG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mID0gREVTQ1JJUFRPUlMkZyA/ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gICAgTyA9IHRvSW5kZXhlZE9iamVjdCRhKE8pO1xuICAgIFAgPSB0b1Byb3BlcnR5S2V5JDMoUCk7XG4gICAgaWYgKElFOF9ET01fREVGSU5FJDEpIHRyeSB7XG4gICAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyKE8sIFApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvKiBlbXB0eSAqL1xuICAgIH1cbiAgICBpZiAoaGFzT3duJGUoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNCghY2FsbCQ3KHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDIuZiwgTywgUCksIE9bUF0pO1xuICB9O1xuXG4gIHZhciBmYWlscyRsID0gZmFpbHMkcjtcbiAgdmFyIGlzQ2FsbGFibGUkYiA9IGlzQ2FsbGFibGUkaDtcbiAgdmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxuICB2YXIgaXNGb3JjZWQkMSA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gICAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZSA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlIDogaXNDYWxsYWJsZSRiKGRldGVjdGlvbikgPyBmYWlscyRsKGRldGVjdGlvbikgOiAhIWRldGVjdGlvbjtcbiAgfTtcblxuICB2YXIgbm9ybWFsaXplID0gaXNGb3JjZWQkMS5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICB2YXIgZGF0YSA9IGlzRm9yY2VkJDEuZGF0YSA9IHt9O1xuICB2YXIgTkFUSVZFID0gaXNGb3JjZWQkMS5OQVRJVkUgPSAnTic7XG4gIHZhciBQT0xZRklMTCA9IGlzRm9yY2VkJDEuUE9MWUZJTEwgPSAnUCc7XG4gIHZhciBpc0ZvcmNlZF8xID0gaXNGb3JjZWQkMTtcblxuICB2YXIgdW5jdXJyeVRoaXMkbiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBhQ2FsbGFibGUkNSA9IGFDYWxsYWJsZSQ3O1xuICB2YXIgTkFUSVZFX0JJTkQkMSA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcbiAgdmFyIGJpbmQkYyA9IHVuY3VycnlUaGlzJG4odW5jdXJyeVRoaXMkbi5iaW5kKTsgLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5cbiAgdmFyIGZ1bmN0aW9uQmluZENvbnRleHQgPSBmdW5jdGlvbiAoZm4sIHRoYXQpIHtcbiAgICBhQ2FsbGFibGUkNShmbik7XG4gICAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQkMSA/IGJpbmQkYyhmbiwgdGhhdCkgOiBmdW5jdGlvblxuICAgICAgLyogLi4uYXJncyAqL1xuICAgICgpIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIG9iamVjdERlZmluZVByb3BlcnR5ID0ge307XG5cbiAgdmFyIERFU0NSSVBUT1JTJGYgPSBkZXNjcmlwdG9ycztcbiAgdmFyIGZhaWxzJGsgPSBmYWlscyRyOyAvLyBWOCB+IENocm9tZSAzNi1cbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxuXG4gIHZhciB2OFByb3RvdHlwZURlZmluZUJ1ZyA9IERFU0NSSVBUT1JTJGYgJiYgZmFpbHMkayhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkge1xuICAgICAgLyogZW1wdHkgKi9cbiAgICB9LCAncHJvdG90eXBlJywge1xuICAgICAgdmFsdWU6IDQyLFxuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSkucHJvdG90eXBlICE9IDQyO1xuICB9KTtcblxuICB2YXIgZ2xvYmFsJHggPSBnbG9iYWwkTTtcbiAgdmFyIGlzT2JqZWN0JGIgPSBpc09iamVjdCRmO1xuICB2YXIgU3RyaW5nJDMgPSBnbG9iYWwkeC5TdHJpbmc7XG4gIHZhciBUeXBlRXJyb3IkZiA9IGdsb2JhbCR4LlR5cGVFcnJvcjsgLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxuXG4gIHZhciBhbk9iamVjdCRiID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgaWYgKGlzT2JqZWN0JGIoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gICAgdGhyb3cgVHlwZUVycm9yJGYoU3RyaW5nJDMoYXJndW1lbnQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gIH07XG5cbiAgdmFyIGdsb2JhbCR3ID0gZ2xvYmFsJE07XG4gIHZhciBERVNDUklQVE9SUyRlID0gZGVzY3JpcHRvcnM7XG4gIHZhciBJRThfRE9NX0RFRklORSA9IGllOERvbURlZmluZTtcbiAgdmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbiAgdmFyIGFuT2JqZWN0JGEgPSBhbk9iamVjdCRiO1xuICB2YXIgdG9Qcm9wZXJ0eUtleSQyID0gdG9Qcm9wZXJ0eUtleSQ0O1xuICB2YXIgVHlwZUVycm9yJGUgPSBnbG9iYWwkdy5UeXBlRXJyb3I7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuXG4gIHZhciAkZGVmaW5lUHJvcGVydHkkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuXG4gIHZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICB2YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbiAgdmFyIENPTkZJR1VSQUJMRSQxID0gJ2NvbmZpZ3VyYWJsZSc7XG4gIHZhciBXUklUQUJMRSA9ICd3cml0YWJsZSc7IC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuXG4gIG9iamVjdERlZmluZVByb3BlcnR5LmYgPSBERVNDUklQVE9SUyRlID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgICBhbk9iamVjdCRhKE8pO1xuICAgIFAgPSB0b1Byb3BlcnR5S2V5JDIoUCk7XG4gICAgYW5PYmplY3QkYShBdHRyaWJ1dGVzKTtcblxuICAgIGlmICh0eXBlb2YgTyA9PT0gJ2Z1bmN0aW9uJyAmJiBQID09PSAncHJvdG90eXBlJyAmJiAndmFsdWUnIGluIEF0dHJpYnV0ZXMgJiYgV1JJVEFCTEUgaW4gQXR0cmlidXRlcyAmJiAhQXR0cmlidXRlc1tXUklUQUJMRV0pIHtcbiAgICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKE8sIFApO1xuXG4gICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50W1dSSVRBQkxFXSkge1xuICAgICAgICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICAgICAgQXR0cmlidXRlcyA9IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IENPTkZJR1VSQUJMRSQxIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0NPTkZJR1VSQUJMRSQxXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFJDFdLFxuICAgICAgICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxuICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkkMShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSA6ICRkZWZpbmVQcm9wZXJ0eSQxIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICAgIGFuT2JqZWN0JGEoTyk7XG4gICAgUCA9IHRvUHJvcGVydHlLZXkkMihQKTtcbiAgICBhbk9iamVjdCRhKEF0dHJpYnV0ZXMpO1xuICAgIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkkMShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLyogZW1wdHkgKi9cbiAgICB9XG4gICAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yJGUoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgcmV0dXJuIE87XG4gIH07XG5cbiAgdmFyIERFU0NSSVBUT1JTJGQgPSBkZXNjcmlwdG9ycztcbiAgdmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDQgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbiAgdmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQzID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG4gIHZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNiA9IERFU0NSSVBUT1JTJGQgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlJDQuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMoMSwgdmFsdWUpKTtcbiAgfSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG5cbiAgdmFyIGdsb2JhbCR2ID0gZ2xvYmFsJE07XG4gIHZhciBhcHBseSQ1ID0gZnVuY3Rpb25BcHBseTtcbiAgdmFyIHVuY3VycnlUaGlzJG0gPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgaXNDYWxsYWJsZSRhID0gaXNDYWxsYWJsZSRoO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDQgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbiAgdmFyIGlzRm9yY2VkID0gaXNGb3JjZWRfMTtcbiAgdmFyIHBhdGgkbyA9IHBhdGgkcTtcbiAgdmFyIGJpbmQkYiA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG4gIHZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xuICB2YXIgaGFzT3duJGQgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuXG4gIHZhciB3cmFwQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoTmF0aXZlQ29uc3RydWN0b3IpIHtcbiAgICB2YXIgV3JhcHBlciA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFdyYXBwZXIpIHtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpO1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcihhKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlQ29uc3RydWN0b3IoYSwgYik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGEsIGIsIGMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXBwbHkkNShOYXRpdmVDb25zdHJ1Y3RvciwgdGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBOYXRpdmVDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgcmV0dXJuIFdyYXBwZXI7XG4gIH07XG4gIC8qXG4gICAgb3B0aW9ucy50YXJnZXQgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgICBvcHRpb25zLmdsb2JhbCAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gICAgb3B0aW9ucy5zdGF0ICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgICBvcHRpb25zLnByb3RvICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICAgIG9wdGlvbnMucmVhbCAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICAgIG9wdGlvbnMuZm9yY2VkICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gICAgb3B0aW9ucy5iaW5kICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gICAgb3B0aW9ucy53cmFwICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICAgIG9wdGlvbnMudW5zYWZlICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgICBvcHRpb25zLnNoYW0gICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIG9wdGlvbnMuZW51bWVyYWJsZSAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICAgIG9wdGlvbnMubm9UYXJnZXRHZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4gICAgb3B0aW9ucy5uYW1lICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuICAqL1xuXG5cbiAgdmFyIF9leHBvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gICAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICAgIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICAgIHZhciBQUk9UTyA9IG9wdGlvbnMucHJvdG87XG4gICAgdmFyIG5hdGl2ZVNvdXJjZSA9IEdMT0JBTCA/IGdsb2JhbCR2IDogU1RBVElDID8gZ2xvYmFsJHZbVEFSR0VUXSA6IChnbG9iYWwkdltUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gICAgdmFyIHRhcmdldCA9IEdMT0JBTCA/IHBhdGgkbyA6IHBhdGgkb1tUQVJHRVRdIHx8IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHBhdGgkbywgVEFSR0VULCB7fSlbVEFSR0VUXTtcbiAgICB2YXIgdGFyZ2V0UHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICB2YXIgRk9SQ0VELCBVU0VfTkFUSVZFLCBWSVJUVUFMX1BST1RPVFlQRTtcbiAgICB2YXIga2V5LCBzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHksIG5hdGl2ZVByb3BlcnR5LCByZXN1bHRQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcblxuICAgIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgICAgRk9SQ0VEID0gaXNGb3JjZWQoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTsgLy8gY29udGFpbnMgaW4gbmF0aXZlXG5cbiAgICAgIFVTRV9OQVRJVkUgPSAhRk9SQ0VEICYmIG5hdGl2ZVNvdXJjZSAmJiBoYXNPd24kZChuYXRpdmVTb3VyY2UsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgICAgaWYgKFVTRV9OQVRJVkUpIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7XG4gICAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNChuYXRpdmVTb3VyY2UsIGtleSk7XG4gICAgICAgIG5hdGl2ZVByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgfSBlbHNlIG5hdGl2ZVByb3BlcnR5ID0gbmF0aXZlU291cmNlW2tleV07IC8vIGV4cG9ydCBuYXRpdmUgb3IgaW1wbGVtZW50YXRpb25cblxuICAgICAgc291cmNlUHJvcGVydHkgPSBVU0VfTkFUSVZFICYmIG5hdGl2ZVByb3BlcnR5ID8gbmF0aXZlUHJvcGVydHkgOiBzb3VyY2Vba2V5XTtcbiAgICAgIGlmIChVU0VfTkFUSVZFICYmIHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSA9PSB0eXBlb2Ygc291cmNlUHJvcGVydHkpIGNvbnRpbnVlOyAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuXG4gICAgICBpZiAob3B0aW9ucy5iaW5kICYmIFVTRV9OQVRJVkUpIHJlc3VsdFByb3BlcnR5ID0gYmluZCRiKHNvdXJjZVByb3BlcnR5LCBnbG9iYWwkdik7IC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ3MgaW4gdGhpcyB2ZXJzaW9uXG4gICAgICBlbHNlIGlmIChvcHRpb25zLndyYXAgJiYgVVNFX05BVElWRSkgcmVzdWx0UHJvcGVydHkgPSB3cmFwQ29uc3RydWN0b3Ioc291cmNlUHJvcGVydHkpOyAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICAgIGVsc2UgaWYgKFBST1RPICYmIGlzQ2FsbGFibGUkYShzb3VyY2VQcm9wZXJ0eSkpIHJlc3VsdFByb3BlcnR5ID0gdW5jdXJyeVRoaXMkbShzb3VyY2VQcm9wZXJ0eSk7IC8vIGRlZmF1bHQgY2FzZVxuICAgICAgZWxzZSByZXN1bHRQcm9wZXJ0eSA9IHNvdXJjZVByb3BlcnR5OyAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG5cbiAgICAgIGlmIChvcHRpb25zLnNoYW0gfHwgc291cmNlUHJvcGVydHkgJiYgc291cmNlUHJvcGVydHkuc2hhbSB8fCB0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHJlc3VsdFByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNSh0YXJnZXQsIGtleSwgcmVzdWx0UHJvcGVydHkpO1xuXG4gICAgICBpZiAoUFJPVE8pIHtcbiAgICAgICAgVklSVFVBTF9QUk9UT1RZUEUgPSBUQVJHRVQgKyAnUHJvdG90eXBlJztcblxuICAgICAgICBpZiAoIWhhc093biRkKHBhdGgkbywgVklSVFVBTF9QUk9UT1RZUEUpKSB7XG4gICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUocGF0aCRvLCBWSVJUVUFMX1BST1RPVFlQRSwge30pO1xuICAgICAgICB9IC8vIGV4cG9ydCB2aXJ0dWFsIHByb3RvdHlwZSBtZXRob2RzXG5cblxuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNShwYXRoJG9bVklSVFVBTF9QUk9UT1RZUEVdLCBrZXksIHNvdXJjZVByb3BlcnR5KTsgLy8gZXhwb3J0IHJlYWwgcHJvdG90eXBlIG1ldGhvZHNcblxuICAgICAgICBpZiAob3B0aW9ucy5yZWFsICYmIHRhcmdldFByb3RvdHlwZSAmJiAhdGFyZ2V0UHJvdG90eXBlW2tleV0pIHtcbiAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNSh0YXJnZXRQcm90b3R5cGUsIGtleSwgc291cmNlUHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciAkJEMgPSBfZXhwb3J0O1xuICB2YXIgREVTQ1JJUFRPUlMkYyA9IGRlc2NyaXB0b3JzO1xuICB2YXIgZGVmaW5lUHJvcGVydHkkYyA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7IC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcblxuICAkJEMoe1xuICAgIHRhcmdldDogJ09iamVjdCcsXG4gICAgc3RhdDogdHJ1ZSxcbiAgICBmb3JjZWQ6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gZGVmaW5lUHJvcGVydHkkYyxcbiAgICBzaGFtOiAhREVTQ1JJUFRPUlMkY1xuICB9LCB7XG4gICAgZGVmaW5lUHJvcGVydHk6IGRlZmluZVByb3BlcnR5JGNcbiAgfSk7XG5cbiAgdmFyIHBhdGgkbiA9IHBhdGgkcTtcbiAgdmFyIE9iamVjdCQ2ID0gcGF0aCRuLk9iamVjdDtcblxuICB2YXIgZGVmaW5lUHJvcGVydHkkYiA9IGRlZmluZVByb3BlcnR5JGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpIHtcbiAgICByZXR1cm4gT2JqZWN0JDYuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYgKE9iamVjdCQ2LmRlZmluZVByb3BlcnR5LnNoYW0pIGRlZmluZVByb3BlcnR5JGIuc2hhbSA9IHRydWU7XG5cbiAgdmFyIHBhcmVudCRWID0gZGVmaW5lUHJvcGVydHkkZS5leHBvcnRzO1xuICB2YXIgZGVmaW5lUHJvcGVydHkkYSA9IHBhcmVudCRWO1xuXG4gIHZhciBwYXJlbnQkVSA9IGRlZmluZVByb3BlcnR5JGE7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSQ5ID0gcGFyZW50JFU7XG5cbiAgdmFyIHBhcmVudCRUID0gZGVmaW5lUHJvcGVydHkkOTtcbiAgdmFyIGRlZmluZVByb3BlcnR5JDggPSBwYXJlbnQkVDtcblxuICB2YXIgZGVmaW5lUHJvcGVydHkkNyA9IGRlZmluZVByb3BlcnR5JDg7XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgICBkZWZpbmVQcm9wZXJ0eSQ3KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG5cbiAgICBkZWZpbmVQcm9wZXJ0eSQ3KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9KTtcblxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgZGVmaW5lUHJvcGVydHkkNyhvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgdW5jdXJyeVRoaXMkbCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBhcnJheVNsaWNlJDUgPSB1bmN1cnJ5VGhpcyRsKFtdLnNsaWNlKTtcblxuICB2YXIgZ2xvYmFsJHUgPSBnbG9iYWwkTTtcbiAgdmFyIHVuY3VycnlUaGlzJGsgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgYUNhbGxhYmxlJDQgPSBhQ2FsbGFibGUkNztcbiAgdmFyIGlzT2JqZWN0JGEgPSBpc09iamVjdCRmO1xuICB2YXIgaGFzT3duJGMgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuICB2YXIgYXJyYXlTbGljZSQ0ID0gYXJyYXlTbGljZSQ1O1xuICB2YXIgTkFUSVZFX0JJTkQgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG4gIHZhciBGdW5jdGlvbiQyID0gZ2xvYmFsJHUuRnVuY3Rpb247XG4gIHZhciBjb25jYXQkNiA9IHVuY3VycnlUaGlzJGsoW10uY29uY2F0KTtcbiAgdmFyIGpvaW4gPSB1bmN1cnJ5VGhpcyRrKFtdLmpvaW4pO1xuICB2YXIgZmFjdG9yaWVzID0ge307XG5cbiAgdmFyIGNvbnN0cnVjdCQ0ID0gZnVuY3Rpb24gKEMsIGFyZ3NMZW5ndGgsIGFyZ3MpIHtcbiAgICBpZiAoIWhhc093biRjKGZhY3RvcmllcywgYXJnc0xlbmd0aCkpIHtcbiAgICAgIGZvciAodmFyIGxpc3QgPSBbXSwgaSA9IDA7IGkgPCBhcmdzTGVuZ3RoOyBpKyspIGxpc3RbaV0gPSAnYVsnICsgaSArICddJztcblxuICAgICAgZmFjdG9yaWVzW2FyZ3NMZW5ndGhdID0gRnVuY3Rpb24kMignQyxhJywgJ3JldHVybiBuZXcgQygnICsgam9pbihsaXN0LCAnLCcpICsgJyknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFjdG9yaWVzW2FyZ3NMZW5ndGhdKEMsIGFyZ3MpO1xuICB9OyAvLyBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG5cblxuICB2YXIgZnVuY3Rpb25CaW5kID0gTkFUSVZFX0JJTkQgPyBGdW5jdGlvbiQyLmJpbmQgOiBmdW5jdGlvbiBiaW5kKHRoYXRcbiAgLyogLCAuLi5hcmdzICovXG4gICkge1xuICAgIHZhciBGID0gYUNhbGxhYmxlJDQodGhpcyk7XG4gICAgdmFyIFByb3RvdHlwZSA9IEYucHJvdG90eXBlO1xuICAgIHZhciBwYXJ0QXJncyA9IGFycmF5U2xpY2UkNChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBmdW5jdGlvblxuICAgICAgLyogYXJncy4uLiAqL1xuICAgIGJvdW5kKCkge1xuICAgICAgdmFyIGFyZ3MgPSBjb25jYXQkNihwYXJ0QXJncywgYXJyYXlTbGljZSQ0KGFyZ3VtZW50cykpO1xuICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZEZ1bmN0aW9uID8gY29uc3RydWN0JDQoRiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogRi5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgaWYgKGlzT2JqZWN0JGEoUHJvdG90eXBlKSkgYm91bmRGdW5jdGlvbi5wcm90b3R5cGUgPSBQcm90b3R5cGU7XG4gICAgcmV0dXJuIGJvdW5kRnVuY3Rpb247XG4gIH07XG5cbiAgdmFyICQkQiA9IF9leHBvcnQ7XG4gIHZhciBiaW5kJGEgPSBmdW5jdGlvbkJpbmQ7IC8vIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcblxuICAkJEIoe1xuICAgIHRhcmdldDogJ0Z1bmN0aW9uJyxcbiAgICBwcm90bzogdHJ1ZSxcbiAgICBmb3JjZWQ6IEZ1bmN0aW9uLmJpbmQgIT09IGJpbmQkYVxuICB9LCB7XG4gICAgYmluZDogYmluZCRhXG4gIH0pO1xuXG4gIHZhciBwYXRoJG0gPSBwYXRoJHE7XG5cbiAgdmFyIGVudHJ5VmlydHVhbCRrID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SKSB7XG4gICAgcmV0dXJuIHBhdGgkbVtDT05TVFJVQ1RPUiArICdQcm90b3R5cGUnXTtcbiAgfTtcblxuICB2YXIgZW50cnlWaXJ0dWFsJGogPSBlbnRyeVZpcnR1YWwkaztcbiAgdmFyIGJpbmQkOSA9IGVudHJ5VmlydHVhbCRqKCdGdW5jdGlvbicpLmJpbmQ7XG5cbiAgdmFyIGlzUHJvdG90eXBlT2YkaCA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG4gIHZhciBtZXRob2QkZSA9IGJpbmQkOTtcbiAgdmFyIEZ1bmN0aW9uUHJvdG90eXBlJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgdmFyIGJpbmQkOCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBvd24gPSBpdC5iaW5kO1xuICAgIHJldHVybiBpdCA9PT0gRnVuY3Rpb25Qcm90b3R5cGUkMSB8fCBpc1Byb3RvdHlwZU9mJGgoRnVuY3Rpb25Qcm90b3R5cGUkMSwgaXQpICYmIG93biA9PT0gRnVuY3Rpb25Qcm90b3R5cGUkMS5iaW5kID8gbWV0aG9kJGUgOiBvd247XG4gIH07XG5cbiAgdmFyIHBhcmVudCRTID0gYmluZCQ4O1xuICB2YXIgYmluZCQ3ID0gcGFyZW50JFM7XG5cbiAgdmFyIGJpbmQkNiA9IGJpbmQkNztcblxuICB2YXIgY2VpbCA9IE1hdGguY2VpbDtcbiAgdmFyIGZsb29yJDEgPSBNYXRoLmZsb29yOyAvLyBgVG9JbnRlZ2VyT3JJbmZpbml0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2Vyb3JpbmZpbml0eVxuXG4gIHZhciB0b0ludGVnZXJPckluZmluaXR5JDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICB2YXIgbnVtYmVyID0gK2FyZ3VtZW50OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIHNhZmVcblxuICAgIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogKG51bWJlciA+IDAgPyBmbG9vciQxIDogY2VpbCkobnVtYmVyKTtcbiAgfTtcblxuICB2YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQzID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ0O1xuICB2YXIgbWluJDIgPSBNYXRoLm1pbjsgLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxuXG4gIHZhciB0b0xlbmd0aCQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbiQyKHRvSW50ZWdlck9ySW5maW5pdHkkMyhhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxuICB9O1xuXG4gIHZhciB0b0xlbmd0aCA9IHRvTGVuZ3RoJDE7IC8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbGVuZ3Rob2ZhcnJheWxpa2VcblxuICB2YXIgbGVuZ3RoT2ZBcnJheUxpa2UkZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdG9MZW5ndGgob2JqLmxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIGdsb2JhbCR0ID0gZ2xvYmFsJE07XG4gIHZhciBhQ2FsbGFibGUkMyA9IGFDYWxsYWJsZSQ3O1xuICB2YXIgdG9PYmplY3QkYyA9IHRvT2JqZWN0JGU7XG4gIHZhciBJbmRleGVkT2JqZWN0JDIgPSBpbmRleGVkT2JqZWN0O1xuICB2YXIgbGVuZ3RoT2ZBcnJheUxpa2UkYyA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG4gIHZhciBUeXBlRXJyb3IkZCA9IGdsb2JhbCR0LlR5cGVFcnJvcjsgLy8gYEFycmF5LnByb3RvdHlwZS57IHJlZHVjZSwgcmVkdWNlUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXG4gIHZhciBjcmVhdGVNZXRob2QkNSA9IGZ1bmN0aW9uIChJU19SSUdIVCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGhhdCwgY2FsbGJhY2tmbiwgYXJndW1lbnRzTGVuZ3RoLCBtZW1vKSB7XG4gICAgICBhQ2FsbGFibGUkMyhjYWxsYmFja2ZuKTtcbiAgICAgIHZhciBPID0gdG9PYmplY3QkYyh0aGF0KTtcbiAgICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdCQyKE8pO1xuICAgICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJGMoTyk7XG4gICAgICB2YXIgaW5kZXggPSBJU19SSUdIVCA/IGxlbmd0aCAtIDEgOiAwO1xuICAgICAgdmFyIGkgPSBJU19SSUdIVCA/IC0xIDogMTtcbiAgICAgIGlmIChhcmd1bWVudHNMZW5ndGggPCAyKSB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgICAgICBpbmRleCArPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggKz0gaTtcblxuICAgICAgICBpZiAoSVNfUklHSFQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IkZCgnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBJU19SSUdIVCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICB2YXIgYXJyYXlSZWR1Y2UgPSB7XG4gICAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuICAgIGxlZnQ6IGNyZWF0ZU1ldGhvZCQ1KGZhbHNlKSxcbiAgICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0YCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VyaWdodFxuICAgIHJpZ2h0OiBjcmVhdGVNZXRob2QkNSh0cnVlKVxuICB9O1xuXG4gIHZhciBmYWlscyRqID0gZmFpbHMkcjtcblxuICB2YXIgYXJyYXlNZXRob2RJc1N0cmljdCQ1ID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBhcmd1bWVudCkge1xuICAgIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG4gICAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzJGooZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgICAgbWV0aG9kLmNhbGwobnVsbCwgYXJndW1lbnQgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0sIDEpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjbGFzc29mJGUgPSBjbGFzc29mUmF3JDE7XG4gIHZhciBnbG9iYWwkcyA9IGdsb2JhbCRNO1xuICB2YXIgZW5naW5lSXNOb2RlID0gY2xhc3NvZiRlKGdsb2JhbCRzLnByb2Nlc3MpID09ICdwcm9jZXNzJztcblxuICB2YXIgJCRBID0gX2V4cG9ydDtcbiAgdmFyICRyZWR1Y2UgPSBhcnJheVJlZHVjZS5sZWZ0O1xuICB2YXIgYXJyYXlNZXRob2RJc1N0cmljdCQ0ID0gYXJyYXlNZXRob2RJc1N0cmljdCQ1O1xuICB2YXIgQ0hST01FX1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG4gIHZhciBJU19OT0RFID0gZW5naW5lSXNOb2RlO1xuICB2YXIgU1RSSUNUX01FVEhPRCQ0ID0gYXJyYXlNZXRob2RJc1N0cmljdCQ0KCdyZWR1Y2UnKTsgLy8gQ2hyb21lIDgwLTgyIGhhcyBhIGNyaXRpY2FsIGJ1Z1xuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDQ5OTgyXG5cbiAgdmFyIENIUk9NRV9CVUcgPSAhSVNfTk9ERSAmJiBDSFJPTUVfVkVSU0lPTiA+IDc5ICYmIENIUk9NRV9WRVJTSU9OIDwgODM7IC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG5cbiAgJCRBKHtcbiAgICB0YXJnZXQ6ICdBcnJheScsXG4gICAgcHJvdG86IHRydWUsXG4gICAgZm9yY2VkOiAhU1RSSUNUX01FVEhPRCQ0IHx8IENIUk9NRV9CVUdcbiAgfSwge1xuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm5cbiAgICAvKiAsIGluaXRpYWxWYWx1ZSAqL1xuICAgICkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBsZW5ndGgsIGxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGVudHJ5VmlydHVhbCRpID0gZW50cnlWaXJ0dWFsJGs7XG4gIHZhciByZWR1Y2UkMyA9IGVudHJ5VmlydHVhbCRpKCdBcnJheScpLnJlZHVjZTtcblxuICB2YXIgaXNQcm90b3R5cGVPZiRnID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbiAgdmFyIG1ldGhvZCRkID0gcmVkdWNlJDM7XG4gIHZhciBBcnJheVByb3RvdHlwZSRlID0gQXJyYXkucHJvdG90eXBlO1xuXG4gIHZhciByZWR1Y2UkMiA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBvd24gPSBpdC5yZWR1Y2U7XG4gICAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRlIHx8IGlzUHJvdG90eXBlT2YkZyhBcnJheVByb3RvdHlwZSRlLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRlLnJlZHVjZSA/IG1ldGhvZCRkIDogb3duO1xuICB9O1xuXG4gIHZhciBwYXJlbnQkUiA9IHJlZHVjZSQyO1xuICB2YXIgcmVkdWNlJDEgPSBwYXJlbnQkUjtcblxuICB2YXIgcmVkdWNlID0gcmVkdWNlJDE7XG5cbiAgdmFyIGNsYXNzb2YkZCA9IGNsYXNzb2ZSYXckMTsgLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWlzYXJyYXkgLS0gc2FmZVxuXG4gIHZhciBpc0FycmF5JGQgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJndW1lbnQpIHtcbiAgICByZXR1cm4gY2xhc3NvZiRkKGFyZ3VtZW50KSA9PSAnQXJyYXknO1xuICB9O1xuXG4gIHZhciB3ZWxsS25vd25TeW1ib2wkaCA9IHdlbGxLbm93blN5bWJvbCRqO1xuICB2YXIgVE9fU1RSSU5HX1RBRyQzID0gd2VsbEtub3duU3ltYm9sJGgoJ3RvU3RyaW5nVGFnJyk7XG4gIHZhciB0ZXN0JDIgPSB7fTtcbiAgdGVzdCQyW1RPX1NUUklOR19UQUckM10gPSAneic7XG4gIHZhciB0b1N0cmluZ1RhZ1N1cHBvcnQgPSBTdHJpbmcodGVzdCQyKSA9PT0gJ1tvYmplY3Qgel0nO1xuXG4gIHZhciBnbG9iYWwkciA9IGdsb2JhbCRNO1xuICB2YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUJDIgPSB0b1N0cmluZ1RhZ1N1cHBvcnQ7XG4gIHZhciBpc0NhbGxhYmxlJDkgPSBpc0NhbGxhYmxlJGg7XG4gIHZhciBjbGFzc29mUmF3ID0gY2xhc3NvZlJhdyQxO1xuICB2YXIgd2VsbEtub3duU3ltYm9sJGcgPSB3ZWxsS25vd25TeW1ib2wkajtcbiAgdmFyIFRPX1NUUklOR19UQUckMiA9IHdlbGxLbm93blN5bWJvbCRnKCd0b1N0cmluZ1RhZycpO1xuICB2YXIgT2JqZWN0JDUgPSBnbG9iYWwkci5PYmplY3Q7IC8vIEVTMyB3cm9uZyBoZXJlXG5cbiAgdmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cztcbiAgfSgpKSA9PSAnQXJndW1lbnRzJzsgLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcblxuICB2YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGl0W2tleV07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8qIGVtcHR5ICovXG4gICAgfVxuICB9OyAvLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5cblxuICB2YXIgY2xhc3NvZiRjID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUJDIgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICAgIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJyAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSBPYmplY3QkNShpdCksIFRPX1NUUklOR19UQUckMikpID09ICdzdHJpbmcnID8gdGFnIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiBpc0NhbGxhYmxlJDkoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHVuY3VycnlUaGlzJGogPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgaXNDYWxsYWJsZSQ4ID0gaXNDYWxsYWJsZSRoO1xuICB2YXIgc3RvcmUkMSA9IHNoYXJlZFN0b3JlO1xuICB2YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzJGooRnVuY3Rpb24udG9TdHJpbmcpOyAvLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5cbiAgaWYgKCFpc0NhbGxhYmxlJDgoc3RvcmUkMS5pbnNwZWN0U291cmNlKSkge1xuICAgIHN0b3JlJDEuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICAgIH07XG4gIH1cblxuICB2YXIgaW5zcGVjdFNvdXJjZSQyID0gc3RvcmUkMS5pbnNwZWN0U291cmNlO1xuXG4gIHZhciB1bmN1cnJ5VGhpcyRpID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIGZhaWxzJGkgPSBmYWlscyRyO1xuICB2YXIgaXNDYWxsYWJsZSQ3ID0gaXNDYWxsYWJsZSRoO1xuICB2YXIgY2xhc3NvZiRiID0gY2xhc3NvZiRjO1xuICB2YXIgZ2V0QnVpbHRJbiQ2ID0gZ2V0QnVpbHRJbiQ5O1xuICB2YXIgaW5zcGVjdFNvdXJjZSQxID0gaW5zcGVjdFNvdXJjZSQyO1xuXG4gIHZhciBub29wID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH07XG5cbiAgdmFyIGVtcHR5ID0gW107XG4gIHZhciBjb25zdHJ1Y3QkMyA9IGdldEJ1aWx0SW4kNignUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbiAgdmFyIGNvbnN0cnVjdG9yUmVnRXhwID0gL15cXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxiLztcbiAgdmFyIGV4ZWMkMiA9IHVuY3VycnlUaGlzJGkoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG4gIHZhciBJTkNPUlJFQ1RfVE9fU1RSSU5HID0gIWNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMobm9vcCk7XG5cbiAgdmFyIGlzQ29uc3RydWN0b3JNb2Rlcm4gPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gICAgaWYgKCFpc0NhbGxhYmxlJDcoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3RydWN0JDMobm9vcCwgZW1wdHksIGFyZ3VtZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0NvbnN0cnVjdG9yTGVnYWN5ID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICAgIGlmICghaXNDYWxsYWJsZSQ3KGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgc3dpdGNoIChjbGFzc29mJGIoYXJndW1lbnQpKSB7XG4gICAgICBjYXNlICdBc3luY0Z1bmN0aW9uJzpcbiAgICAgIGNhc2UgJ0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgICAgIGNhc2UgJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIHdlIGNhbid0IGNoZWNrIC5wcm90b3R5cGUgc2luY2UgY29uc3RydWN0b3JzIHByb2R1Y2VkIGJ5IC5iaW5kIGhhdmVuJ3QgaXRcbiAgICAgIC8vIGBGdW5jdGlvbiN0b1N0cmluZ2AgdGhyb3dzIG9uIHNvbWUgYnVpbHQtaXQgZnVuY3Rpb24gaW4gc29tZSBsZWdhY3kgZW5naW5lc1xuICAgICAgLy8gKGZvciBleGFtcGxlLCBgRE9NUXVhZGAgYW5kIHNpbWlsYXIgaW4gRkY0MS0pXG4gICAgICByZXR1cm4gSU5DT1JSRUNUX1RPX1NUUklORyB8fCAhIWV4ZWMkMihjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZSQxKGFyZ3VtZW50KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBpc0NvbnN0cnVjdG9yTGVnYWN5LnNoYW0gPSB0cnVlOyAvLyBgSXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjb25zdHJ1Y3RvclxuXG4gIHZhciBpc0NvbnN0cnVjdG9yJDQgPSAhY29uc3RydWN0JDMgfHwgZmFpbHMkaShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbGxlZDtcbiAgICByZXR1cm4gaXNDb25zdHJ1Y3Rvck1vZGVybihpc0NvbnN0cnVjdG9yTW9kZXJuLmNhbGwpIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKE9iamVjdCkgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB9KSB8fCBjYWxsZWQ7XG4gIH0pID8gaXNDb25zdHJ1Y3RvckxlZ2FjeSA6IGlzQ29uc3RydWN0b3JNb2Rlcm47XG5cbiAgdmFyIGdsb2JhbCRxID0gZ2xvYmFsJE07XG4gIHZhciBpc0FycmF5JGMgPSBpc0FycmF5JGQ7XG4gIHZhciBpc0NvbnN0cnVjdG9yJDMgPSBpc0NvbnN0cnVjdG9yJDQ7XG4gIHZhciBpc09iamVjdCQ5ID0gaXNPYmplY3QkZjtcbiAgdmFyIHdlbGxLbm93blN5bWJvbCRmID0gd2VsbEtub3duU3ltYm9sJGo7XG4gIHZhciBTUEVDSUVTJDMgPSB3ZWxsS25vd25TeW1ib2wkZignc3BlY2llcycpO1xuICB2YXIgQXJyYXkkNSA9IGdsb2JhbCRxLkFycmF5OyAvLyBhIHBhcnQgb2YgYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5cbiAgdmFyIGFycmF5U3BlY2llc0NvbnN0cnVjdG9yJDEgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSkge1xuICAgIHZhciBDO1xuXG4gICAgaWYgKGlzQXJyYXkkYyhvcmlnaW5hbEFycmF5KSkge1xuICAgICAgQyA9IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3I7IC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG5cbiAgICAgIGlmIChpc0NvbnN0cnVjdG9yJDMoQykgJiYgKEMgPT09IEFycmF5JDUgfHwgaXNBcnJheSRjKEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7ZWxzZSBpZiAoaXNPYmplY3QkOShDKSkge1xuICAgICAgICBDID0gQ1tTUEVDSUVTJDNdO1xuICAgICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkkNSA6IEM7XG4gIH07XG5cbiAgdmFyIGFycmF5U3BlY2llc0NvbnN0cnVjdG9yID0gYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IkMTsgLy8gYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5cbiAgdmFyIGFycmF5U3BlY2llc0NyZWF0ZSQ0ID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXksIGxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgKGFycmF5U3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsQXJyYXkpKShsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgYmluZCQ1ID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbiAgdmFyIHVuY3VycnlUaGlzJGggPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgSW5kZXhlZE9iamVjdCQxID0gaW5kZXhlZE9iamVjdDtcbiAgdmFyIHRvT2JqZWN0JGIgPSB0b09iamVjdCRlO1xuICB2YXIgbGVuZ3RoT2ZBcnJheUxpa2UkYiA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG4gIHZhciBhcnJheVNwZWNpZXNDcmVhdGUkMyA9IGFycmF5U3BlY2llc0NyZWF0ZSQ0O1xuICB2YXIgcHVzaCQ1ID0gdW5jdXJyeVRoaXMkaChbXS5wdXNoKTsgLy8gYEFycmF5LnByb3RvdHlwZS57IGZvckVhY2gsIG1hcCwgZmlsdGVyLCBzb21lLCBldmVyeSwgZmluZCwgZmluZEluZGV4LCBmaWx0ZXJSZWplY3QgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXG4gIHZhciBjcmVhdGVNZXRob2QkNCA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gICAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICAgIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICAgIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgICB2YXIgSVNfRklMVEVSX1JFSkVDVCA9IFRZUEUgPT0gNztcbiAgICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xuICAgICAgdmFyIE8gPSB0b09iamVjdCRiKCR0aGlzKTtcbiAgICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdCQxKE8pO1xuICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kJDUoY2FsbGJhY2tmbiwgdGhhdCk7XG4gICAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkYihzZWxmKTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgY3JlYXRlID0gc3BlY2lmaWNDcmVhdGUgfHwgYXJyYXlTcGVjaWVzQ3JlYXRlJDM7XG4gICAgICB2YXIgdGFyZ2V0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSIHx8IElTX0ZJTFRFUl9SRUpFQ1QgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHZhbHVlLCByZXN1bHQ7XG5cbiAgICAgIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xuXG4gICAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgICAgaWYgKElTX01BUCkgdGFyZ2V0W2luZGV4XSA9IHJlc3VsdDsgLy8gbWFwXG4gICAgICAgICAgZWxzZSBpZiAocmVzdWx0KSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAvLyBzb21lXG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgLy8gZmluZFxuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHB1c2gkNSh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgICAgIC8vIGZpbHRlclxuICAgICAgICAgIH0gZWxzZSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy8gZXZlcnlcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBwdXNoJDUodGFyZ2V0LCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyBmaWx0ZXJSZWplY3RcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHRhcmdldDtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBhcnJheUl0ZXJhdGlvbiA9IHtcbiAgICAvLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiAgICBmb3JFYWNoOiBjcmVhdGVNZXRob2QkNCgwKSxcbiAgICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4gICAgbWFwOiBjcmVhdGVNZXRob2QkNCgxKSxcbiAgICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gICAgZmlsdGVyOiBjcmVhdGVNZXRob2QkNCgyKSxcbiAgICAvLyBgQXJyYXkucHJvdG90eXBlLnNvbWVgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcbiAgICBzb21lOiBjcmVhdGVNZXRob2QkNCgzKSxcbiAgICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuICAgIGV2ZXJ5OiBjcmVhdGVNZXRob2QkNCg0KSxcbiAgICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcbiAgICBmaW5kOiBjcmVhdGVNZXRob2QkNCg1KSxcbiAgICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XG4gICAgZmluZEluZGV4OiBjcmVhdGVNZXRob2QkNCg2KSxcbiAgICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlclJlamVjdGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXktZmlsdGVyaW5nXG4gICAgZmlsdGVyUmVqZWN0OiBjcmVhdGVNZXRob2QkNCg3KVxuICB9O1xuXG4gIHZhciBmYWlscyRoID0gZmFpbHMkcjtcbiAgdmFyIHdlbGxLbm93blN5bWJvbCRlID0gd2VsbEtub3duU3ltYm9sJGo7XG4gIHZhciBWOF9WRVJTSU9OJDEgPSBlbmdpbmVWOFZlcnNpb247XG4gIHZhciBTUEVDSUVTJDIgPSB3ZWxsS25vd25TeW1ib2wkZSgnc3BlY2llcycpO1xuXG4gIHZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDUgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgICAvLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgICAvLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzdcbiAgICByZXR1cm4gVjhfVkVSU0lPTiQxID49IDUxIHx8ICFmYWlscyRoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgdmFyIGNvbnN0cnVjdG9yID0gYXJyYXkuY29uc3RydWN0b3IgPSB7fTtcblxuICAgICAgY29uc3RydWN0b3JbU1BFQ0lFUyQyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmb286IDFcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBhcnJheVtNRVRIT0RfTkFNRV0oQm9vbGVhbikuZm9vICE9PSAxO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciAkJHogPSBfZXhwb3J0O1xuICB2YXIgJGZpbHRlciA9IGFycmF5SXRlcmF0aW9uLmZpbHRlcjtcbiAgdmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNTtcbiAgdmFyIEhBU19TUEVDSUVTX1NVUFBPUlQkMyA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNCgnZmlsdGVyJyk7IC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gIC8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG5cbiAgJCR6KHtcbiAgICB0YXJnZXQ6ICdBcnJheScsXG4gICAgcHJvdG86IHRydWUsXG4gICAgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCQzXG4gIH0sIHtcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuXG4gICAgLyogLCB0aGlzQXJnICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZW50cnlWaXJ0dWFsJGggPSBlbnRyeVZpcnR1YWwkaztcbiAgdmFyIGZpbHRlciQzID0gZW50cnlWaXJ0dWFsJGgoJ0FycmF5JykuZmlsdGVyO1xuXG4gIHZhciBpc1Byb3RvdHlwZU9mJGYgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuICB2YXIgbWV0aG9kJGMgPSBmaWx0ZXIkMztcbiAgdmFyIEFycmF5UHJvdG90eXBlJGQgPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgdmFyIGZpbHRlciQyID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIG93biA9IGl0LmZpbHRlcjtcbiAgICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJGQgfHwgaXNQcm90b3R5cGVPZiRmKEFycmF5UHJvdG90eXBlJGQsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGQuZmlsdGVyID8gbWV0aG9kJGMgOiBvd247XG4gIH07XG5cbiAgdmFyIHBhcmVudCRRID0gZmlsdGVyJDI7XG4gIHZhciBmaWx0ZXIkMSA9IHBhcmVudCRRO1xuXG4gIHZhciBmaWx0ZXIgPSBmaWx0ZXIkMTtcblxuICB2YXIgJCR5ID0gX2V4cG9ydDtcbiAgdmFyICRtYXAgPSBhcnJheUl0ZXJhdGlvbi5tYXA7XG4gIHZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDMgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDU7XG4gIHZhciBIQVNfU1BFQ0lFU19TVVBQT1JUJDIgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDMoJ21hcCcpOyAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuICAvLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xuXG4gICQkeSh7XG4gICAgdGFyZ2V0OiAnQXJyYXknLFxuICAgIHByb3RvOiB0cnVlLFxuICAgIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQkMlxuICB9LCB7XG4gICAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmblxuICAgIC8qICwgdGhpc0FyZyAqL1xuICAgICkge1xuICAgICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGVudHJ5VmlydHVhbCRnID0gZW50cnlWaXJ0dWFsJGs7XG4gIHZhciBtYXAkNiA9IGVudHJ5VmlydHVhbCRnKCdBcnJheScpLm1hcDtcblxuICB2YXIgaXNQcm90b3R5cGVPZiRlID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbiAgdmFyIG1ldGhvZCRiID0gbWFwJDY7XG4gIHZhciBBcnJheVByb3RvdHlwZSRjID0gQXJyYXkucHJvdG90eXBlO1xuXG4gIHZhciBtYXAkNSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBvd24gPSBpdC5tYXA7XG4gICAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRjIHx8IGlzUHJvdG90eXBlT2YkZShBcnJheVByb3RvdHlwZSRjLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRjLm1hcCA/IG1ldGhvZCRiIDogb3duO1xuICB9O1xuXG4gIHZhciBwYXJlbnQkUCA9IG1hcCQ1O1xuICB2YXIgbWFwJDQgPSBwYXJlbnQkUDtcblxuICB2YXIgbWFwJDMgPSBtYXAkNDtcblxuICB2YXIgZ2xvYmFsJHAgPSBnbG9iYWwkTTtcbiAgdmFyIGlzQXJyYXkkYiA9IGlzQXJyYXkkZDtcbiAgdmFyIGxlbmd0aE9mQXJyYXlMaWtlJGEgPSBsZW5ndGhPZkFycmF5TGlrZSRkO1xuICB2YXIgYmluZCQ0ID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbiAgdmFyIFR5cGVFcnJvciRjID0gZ2xvYmFsJHAuVHlwZUVycm9yOyAvLyBgRmxhdHRlbkludG9BcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtZmxhdE1hcC8jc2VjLUZsYXR0ZW5JbnRvQXJyYXlcblxuICB2YXIgZmxhdHRlbkludG9BcnJheSQxID0gZnVuY3Rpb24gKHRhcmdldCwgb3JpZ2luYWwsIHNvdXJjZSwgc291cmNlTGVuLCBzdGFydCwgZGVwdGgsIG1hcHBlciwgdGhpc0FyZykge1xuICAgIHZhciB0YXJnZXRJbmRleCA9IHN0YXJ0O1xuICAgIHZhciBzb3VyY2VJbmRleCA9IDA7XG4gICAgdmFyIG1hcEZuID0gbWFwcGVyID8gYmluZCQ0KG1hcHBlciwgdGhpc0FyZykgOiBmYWxzZTtcbiAgICB2YXIgZWxlbWVudCwgZWxlbWVudExlbjtcblxuICAgIHdoaWxlIChzb3VyY2VJbmRleCA8IHNvdXJjZUxlbikge1xuICAgICAgaWYgKHNvdXJjZUluZGV4IGluIHNvdXJjZSkge1xuICAgICAgICBlbGVtZW50ID0gbWFwRm4gPyBtYXBGbihzb3VyY2Vbc291cmNlSW5kZXhdLCBzb3VyY2VJbmRleCwgb3JpZ2luYWwpIDogc291cmNlW3NvdXJjZUluZGV4XTtcblxuICAgICAgICBpZiAoZGVwdGggPiAwICYmIGlzQXJyYXkkYihlbGVtZW50KSkge1xuICAgICAgICAgIGVsZW1lbnRMZW4gPSBsZW5ndGhPZkFycmF5TGlrZSRhKGVsZW1lbnQpO1xuICAgICAgICAgIHRhcmdldEluZGV4ID0gZmxhdHRlbkludG9BcnJheSQxKHRhcmdldCwgb3JpZ2luYWwsIGVsZW1lbnQsIGVsZW1lbnRMZW4sIHRhcmdldEluZGV4LCBkZXB0aCAtIDEpIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGFyZ2V0SW5kZXggPj0gMHgxRkZGRkZGRkZGRkZGRikgdGhyb3cgVHlwZUVycm9yJGMoJ0V4Y2VlZCB0aGUgYWNjZXB0YWJsZSBhcnJheSBsZW5ndGgnKTtcbiAgICAgICAgICB0YXJnZXRbdGFyZ2V0SW5kZXhdID0gZWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldEluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZUluZGV4Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldEluZGV4O1xuICB9O1xuXG4gIHZhciBmbGF0dGVuSW50b0FycmF5XzEgPSBmbGF0dGVuSW50b0FycmF5JDE7XG5cbiAgdmFyICQkeCA9IF9leHBvcnQ7XG4gIHZhciBmbGF0dGVuSW50b0FycmF5ID0gZmxhdHRlbkludG9BcnJheV8xO1xuICB2YXIgYUNhbGxhYmxlJDIgPSBhQ2FsbGFibGUkNztcbiAgdmFyIHRvT2JqZWN0JGEgPSB0b09iamVjdCRlO1xuICB2YXIgbGVuZ3RoT2ZBcnJheUxpa2UkOSA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG4gIHZhciBhcnJheVNwZWNpZXNDcmVhdGUkMiA9IGFycmF5U3BlY2llc0NyZWF0ZSQ0OyAvLyBgQXJyYXkucHJvdG90eXBlLmZsYXRNYXBgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mbGF0bWFwXG5cbiAgJCR4KHtcbiAgICB0YXJnZXQ6ICdBcnJheScsXG4gICAgcHJvdG86IHRydWVcbiAgfSwge1xuICAgIGZsYXRNYXA6IGZ1bmN0aW9uIGZsYXRNYXAoY2FsbGJhY2tmblxuICAgIC8qICwgdGhpc0FyZyAqL1xuICAgICkge1xuICAgICAgdmFyIE8gPSB0b09iamVjdCRhKHRoaXMpO1xuICAgICAgdmFyIHNvdXJjZUxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlJDkoTyk7XG4gICAgICB2YXIgQTtcbiAgICAgIGFDYWxsYWJsZSQyKGNhbGxiYWNrZm4pO1xuICAgICAgQSA9IGFycmF5U3BlY2llc0NyZWF0ZSQyKE8sIDApO1xuICAgICAgQS5sZW5ndGggPSBmbGF0dGVuSW50b0FycmF5KEEsIE8sIE8sIHNvdXJjZUxlbiwgMCwgMSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuIEE7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZW50cnlWaXJ0dWFsJGYgPSBlbnRyeVZpcnR1YWwkaztcbiAgdmFyIGZsYXRNYXAkMyA9IGVudHJ5VmlydHVhbCRmKCdBcnJheScpLmZsYXRNYXA7XG5cbiAgdmFyIGlzUHJvdG90eXBlT2YkZCA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG4gIHZhciBtZXRob2QkYSA9IGZsYXRNYXAkMztcbiAgdmFyIEFycmF5UHJvdG90eXBlJGIgPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgdmFyIGZsYXRNYXAkMiA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBvd24gPSBpdC5mbGF0TWFwO1xuICAgIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkYiB8fCBpc1Byb3RvdHlwZU9mJGQoQXJyYXlQcm90b3R5cGUkYiwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkYi5mbGF0TWFwID8gbWV0aG9kJGEgOiBvd247XG4gIH07XG5cbiAgdmFyIHBhcmVudCRPID0gZmxhdE1hcCQyO1xuICB2YXIgZmxhdE1hcCQxID0gcGFyZW50JE87XG5cbiAgdmFyIGZsYXRNYXAgPSBmbGF0TWFwJDE7XG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIG5ldyBkYXRhIHBpcGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSBzb3VyY2UgZGF0YSBzZXQgb3IgZGF0YSB2aWV3LlxyXG4gICAqIEByZW1hcmtzXHJcbiAgICogRXhhbXBsZSB1c2FnZTpcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogaW50ZXJmYWNlIEFwcEl0ZW0ge1xyXG4gICAqICAgd2hvYW1pOiBzdHJpbmc7XHJcbiAgICogICBhcHBEYXRhOiB1bmtub3duO1xyXG4gICAqICAgdmlzRGF0YTogVmlzSXRlbTtcclxuICAgKiB9XHJcbiAgICogaW50ZXJmYWNlIFZpc0l0ZW0ge1xyXG4gICAqICAgaWQ6IG51bWJlcjtcclxuICAgKiAgIGxhYmVsOiBzdHJpbmc7XHJcbiAgICogICBjb2xvcjogc3RyaW5nO1xyXG4gICAqICAgeDogbnVtYmVyO1xyXG4gICAqICAgeTogbnVtYmVyO1xyXG4gICAqIH1cclxuICAgKlxyXG4gICAqIGNvbnN0IGRzMSA9IG5ldyBEYXRhU2V0PEFwcEl0ZW0sIFwid2hvYW1pXCI+KFtdLCB7IGZpZWxkSWQ6IFwid2hvYW1pXCIgfSk7XHJcbiAgICogY29uc3QgZHMyID0gbmV3IERhdGFTZXQ8VmlzSXRlbSwgXCJpZFwiPigpO1xyXG4gICAqXHJcbiAgICogY29uc3QgcGlwZSA9IGNyZWF0ZU5ld0RhdGFQaXBlRnJvbShkczEpXHJcbiAgICogICAuZmlsdGVyKChpdGVtKTogYm9vbGVhbiA9PiBpdGVtLmVuYWJsZWQgPT09IHRydWUpXHJcbiAgICogICAubWFwPFZpc0l0ZW0sIFwiaWRcIj4oKGl0ZW0pOiBWaXNJdGVtID0+IGl0ZW0udmlzRGF0YSlcclxuICAgKiAgIC50byhkczIpO1xyXG4gICAqXHJcbiAgICogcGlwZS5zdGFydCgpO1xyXG4gICAqIGBgYFxyXG4gICAqIEByZXR1cm5zIEEgZmFjdG9yeSB3aG9zZSBtZXRob2RzIGNhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgcGlwZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlTmV3RGF0YVBpcGVGcm9tKGZyb20pIHtcbiAgICByZXR1cm4gbmV3IERhdGFQaXBlVW5kZXJDb25zdHJ1Y3Rpb24oZnJvbSk7XG4gIH1cbiAgLyoqXHJcbiAgICogSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIHBpcGUuIFRoaXMgc2hvdWxkIGJlIGFjY2Vzc2libGUgb25seSB0aHJvdWdoXHJcbiAgICogYGNyZWF0ZU5ld0RhdGFQaXBlRnJvbWAgZnJvbSB0aGUgb3V0c2lkZS5cclxuICAgKlxyXG4gICAqIEB0eXBlUGFyYW0gU0kgLSBTb3VyY2UgaXRlbSB0eXBlLlxyXG4gICAqIEB0eXBlUGFyYW0gU1AgLSBTb3VyY2UgaXRlbSB0eXBlJ3MgaWQgcHJvcGVydHkgbmFtZS5cclxuICAgKiBAdHlwZVBhcmFtIFRJIC0gVGFyZ2V0IGl0ZW0gdHlwZS5cclxuICAgKiBAdHlwZVBhcmFtIFRQIC0gVGFyZ2V0IGl0ZW0gdHlwZSdzIGlkIHByb3BlcnR5IG5hbWUuXHJcbiAgICovXG5cbiAgdmFyIFNpbXBsZURhdGFQaXBlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAvKipcclxuICAgICAqIEJvdW5kIGxpc3RlbmVycyBmb3IgdXNlIHdpdGggYERhdGFJbnRlcmZhY2VbJ29uJyB8ICdvZmYnXWAuXHJcbiAgICAgKi9cblxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGRhdGEgcGlwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gX3NvdXJjZSAtIFRoZSBkYXRhIHNldCBvciBkYXRhIHZpZXcgdGhhdCB3aWxsIGJlIG9ic2VydmVkLlxyXG4gICAgICogQHBhcmFtIF90cmFuc2Zvcm1lcnMgLSBBbiBhcnJheSBvZiB0cmFuc2Zvcm1pbmcgZnVuY3Rpb25zIHRvIGJlIHVzZWQgdG9cclxuICAgICAqIGZpbHRlciBvciB0cmFuc2Zvcm0gdGhlIGl0ZW1zIGluIHRoZSBwaXBlLlxyXG4gICAgICogQHBhcmFtIF90YXJnZXQgLSBUaGUgZGF0YSBzZXQgb3IgZGF0YSB2aWV3IHRoYXQgd2lsbCByZWNlaXZlIHRoZSBpdGVtcy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNpbXBsZURhdGFQaXBlKF9zb3VyY2UsIF90cmFuc2Zvcm1lcnMsIF90YXJnZXQpIHtcbiAgICAgIHZhciBfY29udGV4dCwgX2NvbnRleHQyLCBfY29udGV4dDM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaW1wbGVEYXRhUGlwZSk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zb3VyY2VcIiwgdm9pZCAwKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RyYW5zZm9ybWVyc1wiLCB2b2lkIDApO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGFyZ2V0XCIsIHZvaWQgMCk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9saXN0ZW5lcnNcIiwge1xuICAgICAgICBhZGQ6IGJpbmQkNihfY29udGV4dCA9IHRoaXMuX2FkZCkuY2FsbChfY29udGV4dCwgdGhpcyksXG4gICAgICAgIHJlbW92ZTogYmluZCQ2KF9jb250ZXh0MiA9IHRoaXMuX3JlbW92ZSkuY2FsbChfY29udGV4dDIsIHRoaXMpLFxuICAgICAgICB1cGRhdGU6IGJpbmQkNihfY29udGV4dDMgPSB0aGlzLl91cGRhdGUpLmNhbGwoX2NvbnRleHQzLCB0aGlzKVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3NvdXJjZSA9IF9zb3VyY2U7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1lcnMgPSBfdHJhbnNmb3JtZXJzO1xuICAgICAgdGhpcy5fdGFyZ2V0ID0gX3RhcmdldDtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhTaW1wbGVEYXRhUGlwZSwgW3tcbiAgICAgIGtleTogXCJhbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbGwoKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC51cGRhdGUodGhpcy5fdHJhbnNmb3JtSXRlbXModGhpcy5fc291cmNlLmdldCgpKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdGFydFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLl9zb3VyY2Uub24oXCJhZGRcIiwgdGhpcy5fbGlzdGVuZXJzLmFkZCk7XG5cbiAgICAgICAgdGhpcy5fc291cmNlLm9uKFwicmVtb3ZlXCIsIHRoaXMuX2xpc3RlbmVycy5yZW1vdmUpO1xuXG4gICAgICAgIHRoaXMuX3NvdXJjZS5vbihcInVwZGF0ZVwiLCB0aGlzLl9saXN0ZW5lcnMudXBkYXRlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInN0b3BcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICB0aGlzLl9zb3VyY2Uub2ZmKFwiYWRkXCIsIHRoaXMuX2xpc3RlbmVycy5hZGQpO1xuXG4gICAgICAgIHRoaXMuX3NvdXJjZS5vZmYoXCJyZW1vdmVcIiwgdGhpcy5fbGlzdGVuZXJzLnJlbW92ZSk7XG5cbiAgICAgICAgdGhpcy5fc291cmNlLm9mZihcInVwZGF0ZVwiLCB0aGlzLl9saXN0ZW5lcnMudXBkYXRlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBBcHBseSB0aGUgdHJhbnNmb3JtZXJzIHRvIHRoZSBpdGVtcy5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIGl0ZW1zIC0gVGhlIGl0ZW1zIHRvIGJlIHRyYW5zZm9ybWVkLlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNmb3JtZWQgaXRlbXMuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl90cmFuc2Zvcm1JdGVtc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2Zvcm1JdGVtcyhpdGVtcykge1xuICAgICAgICB2YXIgX2NvbnRleHQ0O1xuXG4gICAgICAgIHJldHVybiByZWR1Y2UoX2NvbnRleHQ0ID0gdGhpcy5fdHJhbnNmb3JtZXJzKS5jYWxsKF9jb250ZXh0NCwgZnVuY3Rpb24gKGl0ZW1zLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtKGl0ZW1zKTtcbiAgICAgICAgfSwgaXRlbXMpO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIEhhbmRsZSBhbiBhZGQgZXZlbnQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBfbmFtZSAtIElnbm9yZWQuXHJcbiAgICAgICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIHBheWxvYWQgY29udGFpbmluZyB0aGUgaWRzIG9mIHRoZSBhZGRlZCBpdGVtcy5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2FkZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGQoX25hbWUsIHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHBheWxvYWQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RhcmdldC5hZGQodGhpcy5fdHJhbnNmb3JtSXRlbXModGhpcy5fc291cmNlLmdldChwYXlsb2FkLml0ZW1zKSkpO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIEhhbmRsZSBhbiB1cGRhdGUgZXZlbnQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBfbmFtZSAtIElnbm9yZWQuXHJcbiAgICAgICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIHBheWxvYWQgY29udGFpbmluZyB0aGUgaWRzIG9mIHRoZSB1cGRhdGVkIGl0ZW1zLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZShfbmFtZSwgcGF5bG9hZCkge1xuICAgICAgICBpZiAocGF5bG9hZCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdGFyZ2V0LnVwZGF0ZSh0aGlzLl90cmFuc2Zvcm1JdGVtcyh0aGlzLl9zb3VyY2UuZ2V0KHBheWxvYWQuaXRlbXMpKSk7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogSGFuZGxlIGEgcmVtb3ZlIGV2ZW50LlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gX25hbWUgLSBJZ25vcmVkLlxyXG4gICAgICAgKiBAcGFyYW0gcGF5bG9hZCAtIFRoZSBwYXlsb2FkIGNvbnRhaW5pbmcgdGhlIGRhdGEgb2YgdGhlIHJlbW92ZWQgaXRlbXMuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZW1vdmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlKF9uYW1lLCBwYXlsb2FkKSB7XG4gICAgICAgIGlmIChwYXlsb2FkID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90YXJnZXQucmVtb3ZlKHRoaXMuX3RyYW5zZm9ybUl0ZW1zKHBheWxvYWQub2xkRGF0YSkpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTaW1wbGVEYXRhUGlwZTtcbiAgfSgpO1xuICAvKipcclxuICAgKiBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgcGlwZSBmYWN0b3J5LiBUaGlzIHNob3VsZCBiZSBhY2Nlc3NpYmxlXHJcbiAgICogb25seSB0aHJvdWdoIGBjcmVhdGVOZXdEYXRhUGlwZUZyb21gIGZyb20gdGhlIG91dHNpZGUuXHJcbiAgICpcclxuICAgKiBAdHlwZVBhcmFtIFRJIC0gVGFyZ2V0IGl0ZW0gdHlwZS5cclxuICAgKiBAdHlwZVBhcmFtIFRQIC0gVGFyZ2V0IGl0ZW0gdHlwZSdzIGlkIHByb3BlcnR5IG5hbWUuXHJcbiAgICovXG5cblxuICB2YXIgRGF0YVBpcGVVbmRlckNvbnN0cnVjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSB0cmFuc2Zvcm1lcnMgdXNlZCB0byB0cmFuc2Zvcm0gaXRlbXMgd2l0aGluIHRoZSBwaXBlLiBUaGlzIGlzIHR5cGVkXHJcbiAgICAgKiBhcyBhbnkgZm9yIHRoZSBzYWtlIG9mIHNpbXBsaWNpdHkuXHJcbiAgICAgKi9cblxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGRhdGEgcGlwZSBmYWN0b3J5LiBUaGlzIGlzIGFuIGludGVybmFsIGNvbnN0cnVjdG9yIHRoYXRcclxuICAgICAqIHNob3VsZCBuZXZlciBiZSBjYWxsZWQgZnJvbSBvdXRzaWRlIG9mIHRoaXMgZmlsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gX3NvdXJjZSAtIFRoZSBzb3VyY2UgZGF0YSBzZXQgb3IgZGF0YSB2aWV3IGZvciB0aGlzIHBpcGUuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRhUGlwZVVuZGVyQ29uc3RydWN0aW9uKF9zb3VyY2UpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhUGlwZVVuZGVyQ29uc3RydWN0aW9uKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NvdXJjZVwiLCB2b2lkIDApO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdHJhbnNmb3JtZXJzXCIsIFtdKTtcblxuICAgICAgdGhpcy5fc291cmNlID0gX3NvdXJjZTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBGaWx0ZXIgdGhlIGl0ZW1zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEEgZmlsdGVyaW5nIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIGdpdmVuIGl0ZW1cclxuICAgICAqIHNob3VsZCBiZSBwaXBlZCBhbmQgZmFsc2UgaWYgbm90LlxyXG4gICAgICogQHJldHVybnMgVGhpcyBmYWN0b3J5IGZvciBmdXJ0aGVyIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKERhdGFQaXBlVW5kZXJDb25zdHJ1Y3Rpb24sIFt7XG4gICAgICBrZXk6IFwiZmlsdGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmlsdGVyJDEoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZXJzLnB1c2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIGZpbHRlcihpbnB1dCkuY2FsbChpbnB1dCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBNYXAgZWFjaCBzb3VyY2UgaXRlbSB0byBhIG5ldyB0eXBlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBIG1hcHBpbmcgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHNvdXJjZSBpdGVtIGFuZCByZXR1cm5zXHJcbiAgICAgICAqIGNvcnJlc3BvbmRpbmcgbWFwcGVkIGl0ZW0uXHJcbiAgICAgICAqIEB0eXBlUGFyYW0gVEkgLSBUYXJnZXQgaXRlbSB0eXBlLlxyXG4gICAgICAgKiBAdHlwZVBhcmFtIFRQIC0gVGFyZ2V0IGl0ZW0gdHlwZSdzIGlkIHByb3BlcnR5IG5hbWUuXHJcbiAgICAgICAqIEByZXR1cm5zIFRoaXMgZmFjdG9yeSBmb3IgZnVydGhlciBjb25maWd1cmF0aW9uLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZXJzLnB1c2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIG1hcCQzKGlucHV0KS5jYWxsKGlucHV0LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIE1hcCBlYWNoIHNvdXJjZSBpdGVtIHRvIHplcm8gb3IgbW9yZSBpdGVtcyBvZiBhIG5ldyB0eXBlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBIG1hcHBpbmcgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHNvdXJjZSBpdGVtIGFuZCByZXR1cm5zXHJcbiAgICAgICAqIGFuIGFycmF5IG9mIGNvcnJlc3BvbmRpbmcgbWFwcGVkIGl0ZW1zLlxyXG4gICAgICAgKiBAdHlwZVBhcmFtIFRJIC0gVGFyZ2V0IGl0ZW0gdHlwZS5cclxuICAgICAgICogQHR5cGVQYXJhbSBUUCAtIFRhcmdldCBpdGVtIHR5cGUncyBpZCBwcm9wZXJ0eSBuYW1lLlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGlzIGZhY3RvcnkgZm9yIGZ1cnRoZXIgY29uZmlndXJhdGlvbi5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZmxhdE1hcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZsYXRNYXAkMShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1lcnMucHVzaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gZmxhdE1hcChpbnB1dCkuY2FsbChpbnB1dCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBDb25uZWN0IHRoaXMgcGlwZSB0byBnaXZlbiBkYXRhIHNldC5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSBkYXRhIHNldCB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgaXRlbXMgZnJvbSB0aGlzIHBpcGUuXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSBwaXBlIGNvbm5lY3RlZCBiZXR3ZWVuIGdpdmVuIGRhdGEgc2V0cyBhbmQgcGVyZm9ybWluZ1xyXG4gICAgICAgKiBjb25maWd1cmVkIHRyYW5zZm9ybWF0aW9uIG9uIHRoZSBwcm9jZXNzZWQgaXRlbXMuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInRvXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG8odGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlRGF0YVBpcGUodGhpcy5fc291cmNlLCB0aGlzLl90cmFuc2Zvcm1lcnMsIHRhcmdldCk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERhdGFQaXBlVW5kZXJDb25zdHJ1Y3Rpb247XG4gIH0oKTtcblxuICB2YXIgZ2xvYmFsJG8gPSBnbG9iYWwkTTtcbiAgdmFyIGNsYXNzb2YkYSA9IGNsYXNzb2YkYztcbiAgdmFyIFN0cmluZyQyID0gZ2xvYmFsJG8uU3RyaW5nO1xuXG4gIHZhciB0b1N0cmluZyQ3ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgaWYgKGNsYXNzb2YkYShhcmd1bWVudCkgPT09ICdTeW1ib2wnKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XG4gICAgcmV0dXJuIFN0cmluZyQyKGFyZ3VtZW50KTtcbiAgfTtcblxuICB2YXIgdW5jdXJyeVRoaXMkZyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciB0b0ludGVnZXJPckluZmluaXR5JDIgPSB0b0ludGVnZXJPckluZmluaXR5JDQ7XG4gIHZhciB0b1N0cmluZyQ2ID0gdG9TdHJpbmckNztcbiAgdmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMiA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcbiAgdmFyIGNoYXJBdCQyID0gdW5jdXJyeVRoaXMkZygnJy5jaGFyQXQpO1xuICB2YXIgY2hhckNvZGVBdCQxID0gdW5jdXJyeVRoaXMkZygnJy5jaGFyQ29kZUF0KTtcbiAgdmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMkZygnJy5zbGljZSk7XG5cbiAgdmFyIGNyZWF0ZU1ldGhvZCQzID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgcG9zKSB7XG4gICAgICB2YXIgUyA9IHRvU3RyaW5nJDYocmVxdWlyZU9iamVjdENvZXJjaWJsZSQyKCR0aGlzKSk7XG4gICAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXJPckluZmluaXR5JDIocG9zKTtcbiAgICAgIHZhciBzaXplID0gUy5sZW5ndGg7XG4gICAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgICBmaXJzdCA9IGNoYXJDb2RlQXQkMShTLCBwb3NpdGlvbik7XG4gICAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplIHx8IChzZWNvbmQgPSBjaGFyQ29kZUF0JDEoUywgcG9zaXRpb24gKyAxKSkgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGID8gQ09OVkVSVF9UT19TVFJJTkcgPyBjaGFyQXQkMihTLCBwb3NpdGlvbikgOiBmaXJzdCA6IENPTlZFUlRfVE9fU1RSSU5HID8gc3RyaW5nU2xpY2UoUywgcG9zaXRpb24sIHBvc2l0aW9uICsgMikgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIHN0cmluZ011bHRpYnl0ZSA9IHtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0XG4gICAgY29kZUF0OiBjcmVhdGVNZXRob2QkMyhmYWxzZSksXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUuYXRgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbiAgICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCQzKHRydWUpXG4gIH07XG5cbiAgdmFyIGdsb2JhbCRuID0gZ2xvYmFsJE07XG4gIHZhciBpc0NhbGxhYmxlJDYgPSBpc0NhbGxhYmxlJGg7XG4gIHZhciBpbnNwZWN0U291cmNlID0gaW5zcGVjdFNvdXJjZSQyO1xuICB2YXIgV2Vha01hcCQxID0gZ2xvYmFsJG4uV2Vha01hcDtcbiAgdmFyIG5hdGl2ZVdlYWtNYXAgPSBpc0NhbGxhYmxlJDYoV2Vha01hcCQxKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZShXZWFrTWFwJDEpKTtcblxuICB2YXIgc2hhcmVkJDIgPSBzaGFyZWQkNC5leHBvcnRzO1xuICB2YXIgdWlkJDIgPSB1aWQkNDtcbiAgdmFyIGtleXMkNyA9IHNoYXJlZCQyKCdrZXlzJyk7XG5cbiAgdmFyIHNoYXJlZEtleSQ0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXlzJDdba2V5XSB8fCAoa2V5cyQ3W2tleV0gPSB1aWQkMihrZXkpKTtcbiAgfTtcblxuICB2YXIgaGlkZGVuS2V5cyQ2ID0ge307XG5cbiAgdmFyIE5BVElWRV9XRUFLX01BUCA9IG5hdGl2ZVdlYWtNYXA7XG4gIHZhciBnbG9iYWwkbSA9IGdsb2JhbCRNO1xuICB2YXIgdW5jdXJyeVRoaXMkZiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBpc09iamVjdCQ4ID0gaXNPYmplY3QkZjtcbiAgdmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDY7XG4gIHZhciBoYXNPd24kYiA9IGhhc093blByb3BlcnR5XzE7XG4gIHZhciBzaGFyZWQkMSA9IHNoYXJlZFN0b3JlO1xuICB2YXIgc2hhcmVkS2V5JDMgPSBzaGFyZWRLZXkkNDtcbiAgdmFyIGhpZGRlbktleXMkNSA9IGhpZGRlbktleXMkNjtcbiAgdmFyIE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gJ09iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkJztcbiAgdmFyIFR5cGVFcnJvciRiID0gZ2xvYmFsJG0uVHlwZUVycm9yO1xuICB2YXIgV2Vha01hcCA9IGdsb2JhbCRtLldlYWtNYXA7XG4gIHZhciBzZXQkMywgZ2V0LCBoYXM7XG5cbiAgdmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQkMyhpdCwge30pO1xuICB9O1xuXG4gIHZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHZhciBzdGF0ZTtcblxuICAgICAgaWYgKCFpc09iamVjdCQ4KGl0KSB8fCAoc3RhdGUgPSBnZXQoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvciRiKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbiAgfTtcblxuICBpZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZCQxLnN0YXRlKSB7XG4gICAgdmFyIHN0b3JlID0gc2hhcmVkJDEuc3RhdGUgfHwgKHNoYXJlZCQxLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gICAgdmFyIHdtZ2V0ID0gdW5jdXJyeVRoaXMkZihzdG9yZS5nZXQpO1xuICAgIHZhciB3bWhhcyA9IHVuY3VycnlUaGlzJGYoc3RvcmUuaGFzKTtcbiAgICB2YXIgd21zZXQgPSB1bmN1cnJ5VGhpcyRmKHN0b3JlLnNldCk7XG5cbiAgICBzZXQkMyA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICAgIGlmICh3bWhhcyhzdG9yZSwgaXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yJGIoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgICB3bXNldChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9O1xuXG4gICAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gd21nZXQoc3RvcmUsIGl0KSB8fCB7fTtcbiAgICB9O1xuXG4gICAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gd21oYXMoc3RvcmUsIGl0KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBTVEFURSA9IHNoYXJlZEtleSQzKCdzdGF0ZScpO1xuICAgIGhpZGRlbktleXMkNVtTVEFURV0gPSB0cnVlO1xuXG4gICAgc2V0JDMgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgICBpZiAoaGFzT3duJGIoaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvciRiKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfTtcblxuICAgIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGhhc093biRiKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgICB9O1xuXG4gICAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gaGFzT3duJGIoaXQsIFNUQVRFKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGludGVybmFsU3RhdGUgPSB7XG4gICAgc2V0OiBzZXQkMyxcbiAgICBnZXQ6IGdldCxcbiAgICBoYXM6IGhhcyxcbiAgICBlbmZvcmNlOiBlbmZvcmNlLFxuICAgIGdldHRlckZvcjogZ2V0dGVyRm9yXG4gIH07XG5cbiAgdmFyIERFU0NSSVBUT1JTJGIgPSBkZXNjcmlwdG9ycztcbiAgdmFyIGhhc093biRhID0gaGFzT3duUHJvcGVydHlfMTtcbiAgdmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG5cbiAgdmFyIGdldERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyRiICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gIHZhciBFWElTVFMgPSBoYXNPd24kYShGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKTsgLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xuXG4gIHZhciBQUk9QRVIgPSBFWElTVFMgJiYgZnVuY3Rpb24gc29tZXRoaW5nKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH0ubmFtZSA9PT0gJ3NvbWV0aGluZyc7XG5cbiAgdmFyIENPTkZJR1VSQUJMRSA9IEVYSVNUUyAmJiAoIURFU0NSSVBUT1JTJGIgfHwgREVTQ1JJUFRPUlMkYiAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpLmNvbmZpZ3VyYWJsZSk7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSB7XG4gICAgRVhJU1RTOiBFWElTVFMsXG4gICAgUFJPUEVSOiBQUk9QRVIsXG4gICAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbiAgfTtcblxuICB2YXIgb2JqZWN0RGVmaW5lUHJvcGVydGllcyA9IHt9O1xuXG4gIHZhciB0b0ludGVnZXJPckluZmluaXR5JDEgPSB0b0ludGVnZXJPckluZmluaXR5JDQ7XG4gIHZhciBtYXgkMyA9IE1hdGgubWF4O1xuICB2YXIgbWluJDEgPSBNYXRoLm1pbjsgLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4gIC8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cbiAgLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cblxuICB2YXIgdG9BYnNvbHV0ZUluZGV4JDUgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICAgIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQxKGluZGV4KTtcbiAgICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgkMyhpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbiQxKGludGVnZXIsIGxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHRvSW5kZXhlZE9iamVjdCQ5ID0gdG9JbmRleGVkT2JqZWN0JGI7XG4gIHZhciB0b0Fic29sdXRlSW5kZXgkNCA9IHRvQWJzb2x1dGVJbmRleCQ1O1xuICB2YXIgbGVuZ3RoT2ZBcnJheUxpa2UkOCA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7IC8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cbiAgdmFyIGNyZWF0ZU1ldGhvZCQyID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkOSgkdGhpcyk7XG4gICAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkOChPKTtcbiAgICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleCQ0KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICAgIHZhciB2YWx1ZTsgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcblxuICAgICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSBPW2luZGV4KytdOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7IC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICAgIH0gZWxzZSBmb3IgKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBhcnJheUluY2x1ZGVzID0ge1xuICAgIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gICAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCQyKHRydWUpLFxuICAgIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICAgIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZCQyKGZhbHNlKVxuICB9O1xuXG4gIHZhciB1bmN1cnJ5VGhpcyRlID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIGhhc093biQ5ID0gaGFzT3duUHJvcGVydHlfMTtcbiAgdmFyIHRvSW5kZXhlZE9iamVjdCQ4ID0gdG9JbmRleGVkT2JqZWN0JGI7XG4gIHZhciBpbmRleE9mID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xuICB2YXIgaGlkZGVuS2V5cyQ0ID0gaGlkZGVuS2V5cyQ2O1xuICB2YXIgcHVzaCQ0ID0gdW5jdXJyeVRoaXMkZShbXS5wdXNoKTtcblxuICB2YXIgb2JqZWN0S2V5c0ludGVybmFsID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQ4KG9iamVjdCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5O1xuXG4gICAgZm9yIChrZXkgaW4gTykgIWhhc093biQ5KGhpZGRlbktleXMkNCwga2V5KSAmJiBoYXNPd24kOShPLCBrZXkpICYmIHB1c2gkNChyZXN1bHQsIGtleSk7IC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcblxuXG4gICAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXNPd24kOShPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gkNChyZXN1bHQsIGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgZW51bUJ1Z0tleXMkMyA9IFsnY29uc3RydWN0b3InLCAnaGFzT3duUHJvcGVydHknLCAnaXNQcm90b3R5cGVPZicsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICd0b0xvY2FsZVN0cmluZycsICd0b1N0cmluZycsICd2YWx1ZU9mJ107XG5cbiAgdmFyIGludGVybmFsT2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5c0ludGVybmFsO1xuICB2YXIgZW51bUJ1Z0tleXMkMiA9IGVudW1CdWdLZXlzJDM7IC8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1rZXlzIC0tIHNhZmVcblxuICB2YXIgb2JqZWN0S2V5cyQ0ID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gICAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyQxKE8sIGVudW1CdWdLZXlzJDIpO1xuICB9O1xuXG4gIHZhciBERVNDUklQVE9SUyRhID0gZGVzY3JpcHRvcnM7XG4gIHZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IHY4UHJvdG90eXBlRGVmaW5lQnVnO1xuICB2YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMyA9IG9iamVjdERlZmluZVByb3BlcnR5O1xuICB2YXIgYW5PYmplY3QkOSA9IGFuT2JqZWN0JGI7XG4gIHZhciB0b0luZGV4ZWRPYmplY3QkNyA9IHRvSW5kZXhlZE9iamVjdCRiO1xuICB2YXIgb2JqZWN0S2V5cyQzID0gb2JqZWN0S2V5cyQ0OyAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG5cbiAgb2JqZWN0RGVmaW5lUHJvcGVydGllcy5mID0gREVTQ1JJUFRPUlMkYSAmJiAhVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICAgIGFuT2JqZWN0JDkoTyk7XG4gICAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0JDcoUHJvcGVydGllcyk7XG4gICAgdmFyIGtleXMgPSBvYmplY3RLZXlzJDMoUHJvcGVydGllcyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGtleTtcblxuICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgZGVmaW5lUHJvcGVydHlNb2R1bGUkMy5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xuXG4gICAgcmV0dXJuIE87XG4gIH07XG5cbiAgdmFyIGdldEJ1aWx0SW4kNSA9IGdldEJ1aWx0SW4kOTtcbiAgdmFyIGh0bWwkMSA9IGdldEJ1aWx0SW4kNSgnZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG5cbiAgLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgLS0gb2xkIElFLCBXU0ggKi9cbiAgdmFyIGFuT2JqZWN0JDggPSBhbk9iamVjdCRiO1xuICB2YXIgZGVmaW5lUHJvcGVydGllc01vZHVsZSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcztcbiAgdmFyIGVudW1CdWdLZXlzJDEgPSBlbnVtQnVnS2V5cyQzO1xuICB2YXIgaGlkZGVuS2V5cyQzID0gaGlkZGVuS2V5cyQ2O1xuICB2YXIgaHRtbCA9IGh0bWwkMTtcbiAgdmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxO1xuICB2YXIgc2hhcmVkS2V5JDIgPSBzaGFyZWRLZXkkNDtcbiAgdmFyIEdUID0gJz4nO1xuICB2YXIgTFQgPSAnPCc7XG4gIHZhciBQUk9UT1RZUEUkMSA9ICdwcm90b3R5cGUnO1xuICB2YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG4gIHZhciBJRV9QUk9UTyQxID0gc2hhcmVkS2V5JDIoJ0lFX1BST1RPJyk7XG5cbiAgdmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfTtcblxuICB2YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xuICB9OyAvLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgQWN0aXZlWCBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxuXG5cbiAgdmFyIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVggPSBmdW5jdGlvbiAoYWN0aXZlWERvY3VtZW50KSB7XG4gICAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICAgIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICAgIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50LnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gICAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcblxuICAgIHJldHVybiB0ZW1wO1xuICB9OyAvLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG5cblxuICB2YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICAgIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcblxuICAgIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xuICAgIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICAgIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XG4gICAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbiAgfTsgLy8gQ2hlY2sgZm9yIGRvY3VtZW50LmRvbWFpbiBhbmQgYWN0aXZlIHggc3VwcG9ydFxuICAvLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuICAvLyB2YXJpYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tpdGNhbWJyaWRnZS9lczUtc2hpbS9jb21taXQvNGY3MzhhYzA2NjM0NlxuICAvLyBhdm9pZCBJRSBHQyBidWdcblxuXG4gIHZhciBhY3RpdmVYRG9jdW1lbnQ7XG5cbiAgdmFyIE51bGxQcm90b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8qIGlnbm9yZSAqL1xuICAgIH1cblxuICAgIE51bGxQcm90b09iamVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJyA/IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnQgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgLy8gb2xkIElFXG4gICAgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKSA6IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KTsgLy8gV1NIXG5cbiAgICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMkMS5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFJDFdW2VudW1CdWdLZXlzJDFbbGVuZ3RoXV07XG5cbiAgICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG4gIH07XG5cbiAgaGlkZGVuS2V5cyQzW0lFX1BST1RPJDFdID0gdHJ1ZTsgLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcblxuICB2YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAoTyAhPT0gbnVsbCkge1xuICAgICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEUkMV0gPSBhbk9iamVjdCQ4KE8pO1xuICAgICAgcmVzdWx0ID0gbmV3IEVtcHR5Q29uc3RydWN0b3IoKTtcbiAgICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFJDFdID0gbnVsbDsgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuXG4gICAgICByZXN1bHRbSUVfUFJPVE8kMV0gPSBPO1xuICAgIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcblxuICAgIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlJDEuZihyZXN1bHQsIFByb3BlcnRpZXMpO1xuICB9O1xuXG4gIHZhciBmYWlscyRnID0gZmFpbHMkcjtcbiAgdmFyIGNvcnJlY3RQcm90b3R5cGVHZXR0ZXIgPSAhZmFpbHMkZyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRigpIHtcbiAgICAgIC8qIGVtcHR5ICovXG4gICAgfVxuXG4gICAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbiAgfSk7XG5cbiAgdmFyIGdsb2JhbCRsID0gZ2xvYmFsJE07XG4gIHZhciBoYXNPd24kOCA9IGhhc093blByb3BlcnR5XzE7XG4gIHZhciBpc0NhbGxhYmxlJDUgPSBpc0NhbGxhYmxlJGg7XG4gIHZhciB0b09iamVjdCQ5ID0gdG9PYmplY3QkZTtcbiAgdmFyIHNoYXJlZEtleSQxID0gc2hhcmVkS2V5JDQ7XG4gIHZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIkMSA9IGNvcnJlY3RQcm90b3R5cGVHZXR0ZXI7XG4gIHZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSQxKCdJRV9QUk9UTycpO1xuICB2YXIgT2JqZWN0JDQgPSBnbG9iYWwkbC5PYmplY3Q7XG4gIHZhciBPYmplY3RQcm90b3R5cGUkMiA9IE9iamVjdCQ0LnByb3RvdHlwZTsgLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG5cbiAgdmFyIG9iamVjdEdldFByb3RvdHlwZU9mID0gQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSJDEgPyBPYmplY3QkNC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0JDkoTyk7XG4gICAgaWYgKGhhc093biQ4KG9iamVjdCwgSUVfUFJPVE8pKSByZXR1cm4gb2JqZWN0W0lFX1BST1RPXTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG5cbiAgICBpZiAoaXNDYWxsYWJsZSQ1KGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgT2JqZWN0JDQgPyBPYmplY3RQcm90b3R5cGUkMiA6IG51bGw7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQzID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDY7XG5cbiAgdmFyIHJlZGVmaW5lJDQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbnVtZXJhYmxlKSB0YXJnZXRba2V5XSA9IHZhbHVlO2Vsc2UgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDModGFyZ2V0LCBrZXksIHZhbHVlKTtcbiAgfTtcblxuICB2YXIgZmFpbHMkZiA9IGZhaWxzJHI7XG4gIHZhciBpc0NhbGxhYmxlJDQgPSBpc0NhbGxhYmxlJGg7XG4gIHZhciBjcmVhdGUkYSA9IG9iamVjdENyZWF0ZTtcbiAgdmFyIGdldFByb3RvdHlwZU9mJDYgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbiAgdmFyIHJlZGVmaW5lJDMgPSByZWRlZmluZSQ0O1xuICB2YXIgd2VsbEtub3duU3ltYm9sJGQgPSB3ZWxsS25vd25TeW1ib2wkajtcbiAgdmFyIElURVJBVE9SJDUgPSB3ZWxsS25vd25TeW1ib2wkZCgnaXRlcmF0b3InKTtcbiAgdmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSA9IGZhbHNlOyAvLyBgJUl0ZXJhdG9yUHJvdG90eXBlJWAgb2JqZWN0XG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcblxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUkMSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1hcnJheS1wcm90b3R5cGUta2V5cyAtLSBzYWZlICovXG5cbiAgaWYgKFtdLmtleXMpIHtcbiAgICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpOyAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcblxuICAgIGlmICghKCduZXh0JyBpbiBhcnJheUl0ZXJhdG9yKSkgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gdHJ1ZTtlbHNlIHtcbiAgICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mJDYoZ2V0UHJvdG90eXBlT2YkNihhcnJheUl0ZXJhdG9yKSk7XG4gICAgICBpZiAoUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKSBJdGVyYXRvclByb3RvdHlwZSQxID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gSXRlcmF0b3JQcm90b3R5cGUkMSA9PSB1bmRlZmluZWQgfHwgZmFpbHMkZihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRlc3QgPSB7fTsgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG5cbiAgICByZXR1cm4gSXRlcmF0b3JQcm90b3R5cGUkMVtJVEVSQVRPUiQ1XS5jYWxsKHRlc3QpICE9PSB0ZXN0O1xuICB9KTtcbiAgaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlJDEgPSB7fTtlbHNlIEl0ZXJhdG9yUHJvdG90eXBlJDEgPSBjcmVhdGUkYShJdGVyYXRvclByb3RvdHlwZSQxKTsgLy8gYCVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1AQGl0ZXJhdG9yXG5cbiAgaWYgKCFpc0NhbGxhYmxlJDQoSXRlcmF0b3JQcm90b3R5cGUkMVtJVEVSQVRPUiQ1XSkpIHtcbiAgICByZWRlZmluZSQzKEl0ZXJhdG9yUHJvdG90eXBlJDEsIElURVJBVE9SJDUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGl0ZXJhdG9yc0NvcmUgPSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlJDEsXG4gICAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxXG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCQxID0gdG9TdHJpbmdUYWdTdXBwb3J0O1xuICB2YXIgY2xhc3NvZiQ5ID0gY2xhc3NvZiRjOyAvLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuXG4gIHZhciBvYmplY3RUb1N0cmluZyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCQxID8ge30udG9TdHJpbmcgOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YkOSh0aGlzKSArICddJztcbiAgfTtcblxuICB2YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gdG9TdHJpbmdUYWdTdXBwb3J0O1xuICB2YXIgZGVmaW5lUHJvcGVydHkkNiA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG4gIHZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMiA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xuICB2YXIgaGFzT3duJDcgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuICB2YXIgdG9TdHJpbmckNSA9IG9iamVjdFRvU3RyaW5nO1xuICB2YXIgd2VsbEtub3duU3ltYm9sJGMgPSB3ZWxsS25vd25TeW1ib2wkajtcbiAgdmFyIFRPX1NUUklOR19UQUckMSA9IHdlbGxLbm93blN5bWJvbCRjKCd0b1N0cmluZ1RhZycpO1xuXG4gIHZhciBzZXRUb1N0cmluZ1RhZyQ1ID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQywgU0VUX01FVEhPRCkge1xuICAgIGlmIChpdCkge1xuICAgICAgdmFyIHRhcmdldCA9IFNUQVRJQyA/IGl0IDogaXQucHJvdG90eXBlO1xuXG4gICAgICBpZiAoIWhhc093biQ3KHRhcmdldCwgVE9fU1RSSU5HX1RBRyQxKSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSQ2KHRhcmdldCwgVE9fU1RSSU5HX1RBRyQxLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBUQUdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChTRVRfTUVUSE9EICYmICFUT19TVFJJTkdfVEFHX1NVUFBPUlQpIHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIodGFyZ2V0LCAndG9TdHJpbmcnLCB0b1N0cmluZyQ1KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGl0ZXJhdG9ycyA9IHt9O1xuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IGl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG4gIHZhciBjcmVhdGUkOSA9IG9iamVjdENyZWF0ZTtcbiAgdmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG4gIHZhciBzZXRUb1N0cmluZ1RhZyQ0ID0gc2V0VG9TdHJpbmdUYWckNTtcbiAgdmFyIEl0ZXJhdG9ycyQ1ID0gaXRlcmF0b3JzO1xuXG4gIHZhciByZXR1cm5UaGlzJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0LCBFTlVNRVJBQkxFX05FWFQpIHtcbiAgICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZSQ5KEl0ZXJhdG9yUHJvdG90eXBlLCB7XG4gICAgICBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMigrIUVOVU1FUkFCTEVfTkVYVCwgbmV4dClcbiAgICB9KTtcbiAgICBzZXRUb1N0cmluZ1RhZyQ0KEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiAgICBJdGVyYXRvcnMkNVtUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXMkMTtcbiAgICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3RvcjtcbiAgfTtcblxuICB2YXIgZ2xvYmFsJGsgPSBnbG9iYWwkTTtcbiAgdmFyIGlzQ2FsbGFibGUkMyA9IGlzQ2FsbGFibGUkaDtcbiAgdmFyIFN0cmluZyQxID0gZ2xvYmFsJGsuU3RyaW5nO1xuICB2YXIgVHlwZUVycm9yJGEgPSBnbG9iYWwkay5UeXBlRXJyb3I7XG5cbiAgdmFyIGFQb3NzaWJsZVByb3RvdHlwZSQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudCA9PSAnb2JqZWN0JyB8fCBpc0NhbGxhYmxlJDMoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gICAgdGhyb3cgVHlwZUVycm9yJGEoXCJDYW4ndCBzZXQgXCIgKyBTdHJpbmckMShhcmd1bWVudCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG4gIH07XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gLS0gc2FmZSAqL1xuICB2YXIgdW5jdXJyeVRoaXMkZCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBhbk9iamVjdCQ3ID0gYW5PYmplY3QkYjtcbiAgdmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IGFQb3NzaWJsZVByb3RvdHlwZSQxOyAvLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2ZcbiAgLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qtc2V0cHJvdG90eXBlb2YgLS0gc2FmZVxuXG4gIHZhciBvYmplY3RTZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gICAgdmFyIHRlc3QgPSB7fTtcbiAgICB2YXIgc2V0dGVyO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbiAgICAgIHNldHRlciA9IHVuY3VycnlUaGlzJGQoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0KTtcbiAgICAgIHNldHRlcih0ZXN0LCBbXSk7XG4gICAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLyogZW1wdHkgKi9cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgIGFuT2JqZWN0JDcoTyk7XG4gICAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIoTywgcHJvdG8pO2Vsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgIHJldHVybiBPO1xuICAgIH07XG4gIH0oKSA6IHVuZGVmaW5lZCk7XG5cbiAgdmFyICQkdyA9IF9leHBvcnQ7XG4gIHZhciBjYWxsJDYgPSBmdW5jdGlvbkNhbGw7XG4gIHZhciBGdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWU7XG4gIHZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxO1xuICB2YXIgZ2V0UHJvdG90eXBlT2YkNSA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xuICB2YXIgc2V0VG9TdHJpbmdUYWckMyA9IHNldFRvU3RyaW5nVGFnJDU7XG4gIHZhciByZWRlZmluZSQyID0gcmVkZWZpbmUkNDtcbiAgdmFyIHdlbGxLbm93blN5bWJvbCRiID0gd2VsbEtub3duU3ltYm9sJGo7XG4gIHZhciBJdGVyYXRvcnMkNCA9IGl0ZXJhdG9ycztcbiAgdmFyIEl0ZXJhdG9yc0NvcmUgPSBpdGVyYXRvcnNDb3JlO1xuICB2YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUkMSA9IEZ1bmN0aW9uTmFtZS5QUk9QRVI7XG4gIHZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gSXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xuICB2YXIgSVRFUkFUT1IkNCA9IHdlbGxLbm93blN5bWJvbCRiKCdpdGVyYXRvcicpO1xuICB2YXIgS0VZUyA9ICdrZXlzJztcbiAgdmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuICB2YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxuICB2YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZGVmaW5lSXRlcmF0b3IkMyA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgICBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXG4gICAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gICAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xuXG4gICAgICBzd2l0Y2ggKEtJTkQpIHtcbiAgICAgICAgY2FzZSBLRVlTOlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgY2FzZSBWQUxVRVM6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgRU5UUklFUzpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTtcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gICAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICAgIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDRdIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ10gfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcbiAgICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuICAgIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7IC8vIGZpeCBuYXRpdmVcblxuICAgIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xuICAgICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YkNShhbnlOYXRpdmVJdGVyYXRvci5jYWxsKG5ldyBJdGVyYWJsZSgpKSk7XG5cbiAgICAgIGlmIChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcblxuXG4gICAgICAgIHNldFRvU3RyaW5nVGFnJDMoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgSXRlcmF0b3JzJDRbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICAgICAgfVxuICAgIH0gLy8gZml4IEFycmF5LnByb3RvdHlwZS57IHZhbHVlcywgQEBpdGVyYXRvciB9Lm5hbWUgaW4gVjggLyBGRlxuXG5cbiAgICBpZiAoUFJPUEVSX0ZVTkNUSU9OX05BTUUkMSAmJiBERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICAgIHtcbiAgICAgICAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcblxuICAgICAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGwkNihuYXRpdmVJdGVyYXRvciwgdGhpcyk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG5cblxuICAgIGlmIChERUZBVUxUKSB7XG4gICAgICBtZXRob2RzID0ge1xuICAgICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAgICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgICAgfTtcbiAgICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICAgIHJlZGVmaW5lJDIoSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlICQkdyh7XG4gICAgICAgIHRhcmdldDogTkFNRSxcbiAgICAgICAgcHJvdG86IHRydWUsXG4gICAgICAgIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUVcbiAgICAgIH0sIG1ldGhvZHMpO1xuICAgIH0gLy8gZGVmaW5lIGl0ZXJhdG9yXG5cblxuICAgIGlmICgoRk9SQ0VEKSAmJiBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQ0XSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgICByZWRlZmluZSQyKEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiQ0LCBkZWZhdWx0SXRlcmF0b3IsIHtcbiAgICAgICAgbmFtZTogREVGQVVMVFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgSXRlcmF0b3JzJDRbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG4gICAgcmV0dXJuIG1ldGhvZHM7XG4gIH07XG5cbiAgdmFyIGNoYXJBdCQxID0gc3RyaW5nTXVsdGlieXRlLmNoYXJBdDtcbiAgdmFyIHRvU3RyaW5nJDQgPSB0b1N0cmluZyQ3O1xuICB2YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0ID0gaW50ZXJuYWxTdGF0ZTtcbiAgdmFyIGRlZmluZUl0ZXJhdG9yJDIgPSBkZWZpbmVJdGVyYXRvciQzO1xuICB2YXIgU1RSSU5HX0lURVJBVE9SID0gJ1N0cmluZyBJdGVyYXRvcic7XG4gIHZhciBzZXRJbnRlcm5hbFN0YXRlJDQgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDQuc2V0O1xuICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0LmdldHRlckZvcihTVFJJTkdfSVRFUkFUT1IpOyAvLyBgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5cbiAgZGVmaW5lSXRlcmF0b3IkMihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgICBzZXRJbnRlcm5hbFN0YXRlJDQodGhpcywge1xuICAgICAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxuICAgICAgc3RyaW5nOiB0b1N0cmluZyQ0KGl0ZXJhdGVkKSxcbiAgICAgIGluZGV4OiAwXG4gICAgfSk7IC8vIGAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXN0cmluZ2l0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG4gIH0sIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQyKHRoaXMpO1xuICAgIHZhciBzdHJpbmcgPSBzdGF0ZS5zdHJpbmc7XG4gICAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gICAgdmFyIHBvaW50O1xuICAgIGlmIChpbmRleCA+PSBzdHJpbmcubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRvbmU6IHRydWVcbiAgICB9O1xuICAgIHBvaW50ID0gY2hhckF0JDEoc3RyaW5nLCBpbmRleCk7XG4gICAgc3RhdGUuaW5kZXggKz0gcG9pbnQubGVuZ3RoO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogcG9pbnQsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH0pO1xuXG4gIHZhciBjYWxsJDUgPSBmdW5jdGlvbkNhbGw7XG4gIHZhciBhbk9iamVjdCQ2ID0gYW5PYmplY3QkYjtcbiAgdmFyIGdldE1ldGhvZCQxID0gZ2V0TWV0aG9kJDM7XG5cbiAgdmFyIGl0ZXJhdG9yQ2xvc2UkMiA9IGZ1bmN0aW9uIChpdGVyYXRvciwga2luZCwgdmFsdWUpIHtcbiAgICB2YXIgaW5uZXJSZXN1bHQsIGlubmVyRXJyb3I7XG4gICAgYW5PYmplY3QkNihpdGVyYXRvcik7XG5cbiAgICB0cnkge1xuICAgICAgaW5uZXJSZXN1bHQgPSBnZXRNZXRob2QkMShpdGVyYXRvciwgJ3JldHVybicpO1xuXG4gICAgICBpZiAoIWlubmVyUmVzdWx0KSB7XG4gICAgICAgIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpbm5lclJlc3VsdCA9IGNhbGwkNShpbm5lclJlc3VsdCwgaXRlcmF0b3IpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpbm5lckVycm9yID0gdHJ1ZTtcbiAgICAgIGlubmVyUmVzdWx0ID0gZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICAgIGlmIChpbm5lckVycm9yKSB0aHJvdyBpbm5lclJlc3VsdDtcbiAgICBhbk9iamVjdCQ2KGlubmVyUmVzdWx0KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgdmFyIGFuT2JqZWN0JDUgPSBhbk9iamVjdCRiO1xuICB2YXIgaXRlcmF0b3JDbG9zZSQxID0gaXRlcmF0b3JDbG9zZSQyOyAvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG5cbiAgdmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmckMSA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBFTlRSSUVTKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBFTlRSSUVTID8gZm4oYW5PYmplY3QkNSh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZSQxKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIHZhciB3ZWxsS25vd25TeW1ib2wkYSA9IHdlbGxLbm93blN5bWJvbCRqO1xuICB2YXIgSXRlcmF0b3JzJDMgPSBpdGVyYXRvcnM7XG4gIHZhciBJVEVSQVRPUiQzID0gd2VsbEtub3duU3ltYm9sJGEoJ2l0ZXJhdG9yJyk7XG4gIHZhciBBcnJheVByb3RvdHlwZSRhID0gQXJyYXkucHJvdG90eXBlOyAvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG5cbiAgdmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycyQzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZSRhW0lURVJBVE9SJDNdID09PSBpdCk7XG4gIH07XG5cbiAgdmFyIHRvUHJvcGVydHlLZXkkMSA9IHRvUHJvcGVydHlLZXkkNDtcbiAgdmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbiAgdmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG5cbiAgdmFyIGNyZWF0ZVByb3BlcnR5JDYgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIHByb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQxKGtleSk7XG4gICAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgZGVmaW5lUHJvcGVydHlNb2R1bGUkMi5mKG9iamVjdCwgcHJvcGVydHlLZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxKDAsIHZhbHVlKSk7ZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG4gIH07XG5cbiAgdmFyIGNsYXNzb2YkOCA9IGNsYXNzb2YkYztcbiAgdmFyIGdldE1ldGhvZCA9IGdldE1ldGhvZCQzO1xuICB2YXIgSXRlcmF0b3JzJDIgPSBpdGVyYXRvcnM7XG4gIHZhciB3ZWxsS25vd25TeW1ib2wkOSA9IHdlbGxLbm93blN5bWJvbCRqO1xuICB2YXIgSVRFUkFUT1IkMiA9IHdlbGxLbm93blN5bWJvbCQ5KCdpdGVyYXRvcicpO1xuXG4gIHZhciBnZXRJdGVyYXRvck1ldGhvZCQ4ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGdldE1ldGhvZChpdCwgSVRFUkFUT1IkMikgfHwgZ2V0TWV0aG9kKGl0LCAnQEBpdGVyYXRvcicpIHx8IEl0ZXJhdG9ycyQyW2NsYXNzb2YkOChpdCldO1xuICB9O1xuXG4gIHZhciBnbG9iYWwkaiA9IGdsb2JhbCRNO1xuICB2YXIgY2FsbCQ0ID0gZnVuY3Rpb25DYWxsO1xuICB2YXIgYUNhbGxhYmxlJDEgPSBhQ2FsbGFibGUkNztcbiAgdmFyIGFuT2JqZWN0JDQgPSBhbk9iamVjdCRiO1xuICB2YXIgdHJ5VG9TdHJpbmckMiA9IHRyeVRvU3RyaW5nJDQ7XG4gIHZhciBnZXRJdGVyYXRvck1ldGhvZCQ3ID0gZ2V0SXRlcmF0b3JNZXRob2QkODtcbiAgdmFyIFR5cGVFcnJvciQ5ID0gZ2xvYmFsJGouVHlwZUVycm9yO1xuXG4gIHZhciBnZXRJdGVyYXRvciQ3ID0gZnVuY3Rpb24gKGFyZ3VtZW50LCB1c2luZ0l0ZXJhdG9yKSB7XG4gICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBnZXRJdGVyYXRvck1ldGhvZCQ3KGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XG4gICAgaWYgKGFDYWxsYWJsZSQxKGl0ZXJhdG9yTWV0aG9kKSkgcmV0dXJuIGFuT2JqZWN0JDQoY2FsbCQ0KGl0ZXJhdG9yTWV0aG9kLCBhcmd1bWVudCkpO1xuICAgIHRocm93IFR5cGVFcnJvciQ5KHRyeVRvU3RyaW5nJDIoYXJndW1lbnQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbiAgfTtcblxuICB2YXIgZ2xvYmFsJGkgPSBnbG9iYWwkTTtcbiAgdmFyIGJpbmQkMyA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG4gIHZhciBjYWxsJDMgPSBmdW5jdGlvbkNhbGw7XG4gIHZhciB0b09iamVjdCQ4ID0gdG9PYmplY3QkZTtcbiAgdmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nJDE7XG4gIHZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMSA9IGlzQXJyYXlJdGVyYXRvck1ldGhvZCQyO1xuICB2YXIgaXNDb25zdHJ1Y3RvciQyID0gaXNDb25zdHJ1Y3RvciQ0O1xuICB2YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNyA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG4gIHZhciBjcmVhdGVQcm9wZXJ0eSQ1ID0gY3JlYXRlUHJvcGVydHkkNjtcbiAgdmFyIGdldEl0ZXJhdG9yJDYgPSBnZXRJdGVyYXRvciQ3O1xuICB2YXIgZ2V0SXRlcmF0b3JNZXRob2QkNiA9IGdldEl0ZXJhdG9yTWV0aG9kJDg7XG4gIHZhciBBcnJheSQ0ID0gZ2xvYmFsJGkuQXJyYXk7IC8vIGBBcnJheS5mcm9tYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5mcm9tXG5cbiAgdmFyIGFycmF5RnJvbSA9IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlXG4gIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi9cbiAgKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCQ4KGFycmF5TGlrZSk7XG4gICAgdmFyIElTX0NPTlNUUlVDVE9SID0gaXNDb25zdHJ1Y3RvciQyKHRoaXMpO1xuICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChtYXBwaW5nKSBtYXBmbiA9IGJpbmQkMyhtYXBmbiwgYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QkNihPKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3IsIG5leHQsIHZhbHVlOyAvLyBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBpdGVyYWJsZSBvciBpdCdzIGFuIGFycmF5IHdpdGggdGhlIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2UgYSBzaW1wbGUgY2FzZVxuXG4gICAgaWYgKGl0ZXJhdG9yTWV0aG9kICYmICEodGhpcyA9PSBBcnJheSQ0ICYmIGlzQXJyYXlJdGVyYXRvck1ldGhvZCQxKGl0ZXJhdG9yTWV0aG9kKSkpIHtcbiAgICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkNihPLCBpdGVyYXRvck1ldGhvZCk7XG4gICAgICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgICAgIHJlc3VsdCA9IElTX0NPTlNUUlVDVE9SID8gbmV3IHRoaXMoKSA6IFtdO1xuXG4gICAgICBmb3IgKDsgIShzdGVwID0gY2FsbCQzKG5leHQsIGl0ZXJhdG9yKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgICB2YWx1ZSA9IG1hcHBpbmcgPyBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlO1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eSQ1KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNyhPKTtcbiAgICAgIHJlc3VsdCA9IElTX0NPTlNUUlVDVE9SID8gbmV3IHRoaXMobGVuZ3RoKSA6IEFycmF5JDQobGVuZ3RoKTtcblxuICAgICAgZm9yICg7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHZhbHVlID0gbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkkNShyZXN1bHQsIGluZGV4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHdlbGxLbm93blN5bWJvbCQ4ID0gd2VsbEtub3duU3ltYm9sJGo7XG4gIHZhciBJVEVSQVRPUiQxID0gd2VsbEtub3duU3ltYm9sJDgoJ2l0ZXJhdG9yJyk7XG4gIHZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBjYWxsZWQgPSAwO1xuICAgIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogISFjYWxsZWQrK1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUiQxXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1mcm9tLCBuby10aHJvdy1saXRlcmFsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cblxuICAgIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyAyO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cblxuICB2YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDEgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG4gICAgaWYgKCFTS0lQX0NMT1NJTkcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBvYmplY3QgPSB7fTtcblxuICAgICAgb2JqZWN0W0lURVJBVE9SJDFdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRvbmU6IElURVJBVElPTl9TVVBQT1JUID0gdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBleGVjKG9iamVjdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8qIGVtcHR5ICovXG4gICAgfVxuXG4gICAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xuICB9O1xuXG4gIHZhciAkJHYgPSBfZXhwb3J0O1xuICB2YXIgZnJvbSQ2ID0gYXJyYXlGcm9tO1xuICB2YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDE7XG4gIHZhciBJTkNPUlJFQ1RfSVRFUkFUSU9OID0gIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktZnJvbSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIEFycmF5LmZyb20oaXRlcmFibGUpO1xuICB9KTsgLy8gYEFycmF5LmZyb21gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cblxuICAkJHYoe1xuICAgIHRhcmdldDogJ0FycmF5JyxcbiAgICBzdGF0OiB0cnVlLFxuICAgIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTlxuICB9LCB7XG4gICAgZnJvbTogZnJvbSQ2XG4gIH0pO1xuXG4gIHZhciBwYXRoJGwgPSBwYXRoJHE7XG4gIHZhciBmcm9tJDUgPSBwYXRoJGwuQXJyYXkuZnJvbTtcblxuICB2YXIgcGFyZW50JE4gPSBmcm9tJDU7XG4gIHZhciBmcm9tJDQgPSBwYXJlbnQkTjtcblxuICB2YXIgZnJvbSQzID0gZnJvbSQ0O1xuXG4gIHZhciB0b0luZGV4ZWRPYmplY3QkNiA9IHRvSW5kZXhlZE9iamVjdCRiO1xuICB2YXIgSXRlcmF0b3JzJDEgPSBpdGVyYXRvcnM7XG4gIHZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDMgPSBpbnRlcm5hbFN0YXRlO1xuICBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuICB2YXIgZGVmaW5lSXRlcmF0b3IkMSA9IGRlZmluZUl0ZXJhdG9yJDM7XG4gIHZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG4gIHZhciBzZXRJbnRlcm5hbFN0YXRlJDMgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDMuc2V0O1xuICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQzLmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7IC8vIGBBcnJheS5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmVudHJpZXNcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuICAvLyBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuICAvLyBgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEBpdGVyYXRvclxuICAvLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxuXG4gIGRlZmluZUl0ZXJhdG9yJDEoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgIHNldEludGVybmFsU3RhdGUkMyh0aGlzLCB7XG4gICAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0JDYoaXRlcmF0ZWQpLFxuICAgICAgLy8gdGFyZ2V0XG4gICAgICBpbmRleDogMCxcbiAgICAgIC8vIG5leHQgaW5kZXhcbiAgICAgIGtpbmQ6IGtpbmQgLy8ga2luZFxuXG4gICAgfSk7IC8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxuICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMpO1xuICAgIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gICAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICAgIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG5cbiAgICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBpbmRleCxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB0YXJnZXRbaW5kZXhdLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogW2luZGV4LCB0YXJnZXRbaW5kZXhdXSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfSwgJ3ZhbHVlcycpOyAvLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyVcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGV1bm1hcHBlZGFyZ3VtZW50c29iamVjdFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxuXG4gIEl0ZXJhdG9ycyQxLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycyQxLkFycmF5OyAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5cbiAgdmFyIGdldEl0ZXJhdG9yTWV0aG9kJDUgPSBnZXRJdGVyYXRvck1ldGhvZCQ4O1xuICB2YXIgZ2V0SXRlcmF0b3JNZXRob2RfMSA9IGdldEl0ZXJhdG9yTWV0aG9kJDU7XG5cbiAgLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xuXG4gIHZhciBkb21JdGVyYWJsZXMgPSB7XG4gICAgQ1NTUnVsZUxpc3Q6IDAsXG4gICAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogMCxcbiAgICBDU1NWYWx1ZUxpc3Q6IDAsXG4gICAgQ2xpZW50UmVjdExpc3Q6IDAsXG4gICAgRE9NUmVjdExpc3Q6IDAsXG4gICAgRE9NU3RyaW5nTGlzdDogMCxcbiAgICBET01Ub2tlbkxpc3Q6IDEsXG4gICAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IDAsXG4gICAgRmlsZUxpc3Q6IDAsXG4gICAgSFRNTEFsbENvbGxlY3Rpb246IDAsXG4gICAgSFRNTENvbGxlY3Rpb246IDAsXG4gICAgSFRNTEZvcm1FbGVtZW50OiAwLFxuICAgIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxuICAgIE1lZGlhTGlzdDogMCxcbiAgICBNaW1lVHlwZUFycmF5OiAwLFxuICAgIE5hbWVkTm9kZU1hcDogMCxcbiAgICBOb2RlTGlzdDogMSxcbiAgICBQYWludFJlcXVlc3RMaXN0OiAwLFxuICAgIFBsdWdpbjogMCxcbiAgICBQbHVnaW5BcnJheTogMCxcbiAgICBTVkdMZW5ndGhMaXN0OiAwLFxuICAgIFNWR051bWJlckxpc3Q6IDAsXG4gICAgU1ZHUGF0aFNlZ0xpc3Q6IDAsXG4gICAgU1ZHUG9pbnRMaXN0OiAwLFxuICAgIFNWR1N0cmluZ0xpc3Q6IDAsXG4gICAgU1ZHVHJhbnNmb3JtTGlzdDogMCxcbiAgICBTb3VyY2VCdWZmZXJMaXN0OiAwLFxuICAgIFN0eWxlU2hlZXRMaXN0OiAwLFxuICAgIFRleHRUcmFja0N1ZUxpc3Q6IDAsXG4gICAgVGV4dFRyYWNrTGlzdDogMCxcbiAgICBUb3VjaExpc3Q6IDBcbiAgfTtcblxuICB2YXIgRE9NSXRlcmFibGVzJDQgPSBkb21JdGVyYWJsZXM7XG4gIHZhciBnbG9iYWwkaCA9IGdsb2JhbCRNO1xuICB2YXIgY2xhc3NvZiQ3ID0gY2xhc3NvZiRjO1xuICB2YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcbiAgdmFyIEl0ZXJhdG9ycyA9IGl0ZXJhdG9ycztcbiAgdmFyIHdlbGxLbm93blN5bWJvbCQ3ID0gd2VsbEtub3duU3ltYm9sJGo7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sJDcoJ3RvU3RyaW5nVGFnJyk7XG5cbiAgZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcyQ0KSB7XG4gICAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWwkaFtDT0xMRUNUSU9OX05BTUVdO1xuICAgIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcblxuICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlICYmIGNsYXNzb2YkNyhDb2xsZWN0aW9uUHJvdG90eXBlKSAhPT0gVE9fU1RSSU5HX1RBRykge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgQ09MTEVDVElPTl9OQU1FKTtcbiAgICB9XG5cbiAgICBJdGVyYXRvcnNbQ09MTEVDVElPTl9OQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbiAgfVxuXG4gIHZhciBwYXJlbnQkTSA9IGdldEl0ZXJhdG9yTWV0aG9kXzE7XG4gIHZhciBnZXRJdGVyYXRvck1ldGhvZCQ0ID0gcGFyZW50JE07XG5cbiAgdmFyIHBhcmVudCRMID0gZ2V0SXRlcmF0b3JNZXRob2QkNDtcbiAgdmFyIGdldEl0ZXJhdG9yTWV0aG9kJDMgPSBwYXJlbnQkTDtcblxuICB2YXIgcGFyZW50JEsgPSBnZXRJdGVyYXRvck1ldGhvZCQzO1xuICB2YXIgZ2V0SXRlcmF0b3JNZXRob2QkMiA9IHBhcmVudCRLO1xuXG4gIHZhciBnZXRJdGVyYXRvck1ldGhvZCQxID0gZ2V0SXRlcmF0b3JNZXRob2QkMjtcblxuICB2YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHt9O1xuXG4gIHZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG4gIHZhciBlbnVtQnVnS2V5cyA9IGVudW1CdWdLZXlzJDM7XG4gIHZhciBoaWRkZW5LZXlzJDIgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTsgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxuXG4gIG9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICAgIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyQyKTtcbiAgfTtcblxuICB2YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsID0ge307XG5cbiAgdmFyIGdsb2JhbCRnID0gZ2xvYmFsJE07XG4gIHZhciB0b0Fic29sdXRlSW5kZXgkMyA9IHRvQWJzb2x1dGVJbmRleCQ1O1xuICB2YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNiA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG4gIHZhciBjcmVhdGVQcm9wZXJ0eSQ0ID0gY3JlYXRlUHJvcGVydHkkNjtcbiAgdmFyIEFycmF5JDMgPSBnbG9iYWwkZy5BcnJheTtcbiAgdmFyIG1heCQyID0gTWF0aC5tYXg7XG5cbiAgdmFyIGFycmF5U2xpY2VTaW1wbGUgPSBmdW5jdGlvbiAoTywgc3RhcnQsIGVuZCkge1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ2KE8pO1xuICAgIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4JDMoc3RhcnQsIGxlbmd0aCk7XG4gICAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleCQzKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpO1xuICAgIHZhciByZXN1bHQgPSBBcnJheSQzKG1heCQyKGZpbiAtIGssIDApKTtcblxuICAgIGZvciAodmFyIG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgY3JlYXRlUHJvcGVydHkkNChyZXN1bHQsIG4sIE9ba10pO1xuXG4gICAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlICovXG4gIHZhciBjbGFzc29mJDYgPSBjbGFzc29mUmF3JDE7XG4gIHZhciB0b0luZGV4ZWRPYmplY3QkNSA9IHRvSW5kZXhlZE9iamVjdCRiO1xuICB2YXIgJGdldE93blByb3BlcnR5TmFtZXMkMSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZjtcbiAgdmFyIGFycmF5U2xpY2UkMyA9IGFycmF5U2xpY2VTaW1wbGU7XG4gIHZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG4gIHZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gJGdldE93blByb3BlcnR5TmFtZXMkMShpdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBhcnJheVNsaWNlJDMod2luZG93TmFtZXMpO1xuICAgIH1cbiAgfTsgLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xuXG5cbiAgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzICYmIGNsYXNzb2YkNihpdCkgPT0gJ1dpbmRvdycgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiAkZ2V0T3duUHJvcGVydHlOYW1lcyQxKHRvSW5kZXhlZE9iamVjdCQ1KGl0KSk7XG4gIH07XG5cbiAgdmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IHt9O1xuXG4gIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuICB2YXIgd2VsbEtub3duU3ltYm9sV3JhcHBlZCA9IHt9O1xuXG4gIHZhciB3ZWxsS25vd25TeW1ib2wkNiA9IHdlbGxLbm93blN5bWJvbCRqO1xuICB3ZWxsS25vd25TeW1ib2xXcmFwcGVkLmYgPSB3ZWxsS25vd25TeW1ib2wkNjtcblxuICB2YXIgcGF0aCRrID0gcGF0aCRxO1xuICB2YXIgaGFzT3duJDYgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuICB2YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSQxID0gd2VsbEtub3duU3ltYm9sV3JhcHBlZDtcbiAgdmFyIGRlZmluZVByb3BlcnR5JDUgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXG4gIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkbCA9IGZ1bmN0aW9uIChOQU1FKSB7XG4gICAgdmFyIFN5bWJvbCA9IHBhdGgkay5TeW1ib2wgfHwgKHBhdGgkay5TeW1ib2wgPSB7fSk7XG4gICAgaWYgKCFoYXNPd24kNihTeW1ib2wsIE5BTUUpKSBkZWZpbmVQcm9wZXJ0eSQ1KFN5bWJvbCwgTkFNRSwge1xuICAgICAgdmFsdWU6IHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUkMS5mKE5BTUUpXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyICQkdSA9IF9leHBvcnQ7XG4gIHZhciBnbG9iYWwkZiA9IGdsb2JhbCRNO1xuICB2YXIgZ2V0QnVpbHRJbiQ0ID0gZ2V0QnVpbHRJbiQ5O1xuICB2YXIgYXBwbHkkNCA9IGZ1bmN0aW9uQXBwbHk7XG4gIHZhciBjYWxsJDIgPSBmdW5jdGlvbkNhbGw7XG4gIHZhciB1bmN1cnJ5VGhpcyRjID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIERFU0NSSVBUT1JTJDkgPSBkZXNjcmlwdG9ycztcbiAgdmFyIE5BVElWRV9TWU1CT0wgPSBuYXRpdmVTeW1ib2w7XG4gIHZhciBmYWlscyRlID0gZmFpbHMkcjtcbiAgdmFyIGhhc093biQ1ID0gaGFzT3duUHJvcGVydHlfMTtcbiAgdmFyIGlzQXJyYXkkYSA9IGlzQXJyYXkkZDtcbiAgdmFyIGlzQ2FsbGFibGUkMiA9IGlzQ2FsbGFibGUkaDtcbiAgdmFyIGlzT2JqZWN0JDcgPSBpc09iamVjdCRmO1xuICB2YXIgaXNQcm90b3R5cGVPZiRjID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbiAgdmFyIGlzU3ltYm9sID0gaXNTeW1ib2wkMztcbiAgdmFyIGFuT2JqZWN0JDMgPSBhbk9iamVjdCRiO1xuICB2YXIgdG9PYmplY3QkNyA9IHRvT2JqZWN0JGU7XG4gIHZhciB0b0luZGV4ZWRPYmplY3QkNCA9IHRvSW5kZXhlZE9iamVjdCRiO1xuICB2YXIgdG9Qcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkkNDtcbiAgdmFyICR0b1N0cmluZyA9IHRvU3RyaW5nJDc7XG4gIHZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbiAgdmFyIG5hdGl2ZU9iamVjdENyZWF0ZSA9IG9iamVjdENyZWF0ZTtcbiAgdmFyIG9iamVjdEtleXMkMiA9IG9iamVjdEtleXMkNDtcbiAgdmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUkMiA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXM7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWw7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICB2YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xuICB2YXIgZGVmaW5lUHJvcGVydGllc01vZHVsZSA9IG9iamVjdERlZmluZVByb3BlcnRpZXM7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHZhciBhcnJheVNsaWNlJDIgPSBhcnJheVNsaWNlJDU7XG4gIHZhciByZWRlZmluZSQxID0gcmVkZWZpbmUkNDtcbiAgdmFyIHNoYXJlZCA9IHNoYXJlZCQ0LmV4cG9ydHM7XG4gIHZhciBzaGFyZWRLZXkgPSBzaGFyZWRLZXkkNDtcbiAgdmFyIGhpZGRlbktleXMkMSA9IGhpZGRlbktleXMkNjtcbiAgdmFyIHVpZCQxID0gdWlkJDQ7XG4gIHZhciB3ZWxsS25vd25TeW1ib2wkNSA9IHdlbGxLbm93blN5bWJvbCRqO1xuICB2YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHdlbGxLbm93blN5bWJvbFdyYXBwZWQ7XG4gIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkayA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsO1xuICB2YXIgc2V0VG9TdHJpbmdUYWckMiA9IHNldFRvU3RyaW5nVGFnJDU7XG4gIHZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDIgPSBpbnRlcm5hbFN0YXRlO1xuICB2YXIgJGZvckVhY2gkMSA9IGFycmF5SXRlcmF0aW9uLmZvckVhY2g7XG4gIHZhciBISURERU4gPSBzaGFyZWRLZXkoJ2hpZGRlbicpO1xuICB2YXIgU1lNQk9MID0gJ1N5bWJvbCc7XG4gIHZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbiAgdmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCQ1KCd0b1ByaW1pdGl2ZScpO1xuICB2YXIgc2V0SW50ZXJuYWxTdGF0ZSQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLnNldDtcbiAgdmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDIuZ2V0dGVyRm9yKFNZTUJPTCk7XG4gIHZhciBPYmplY3RQcm90b3R5cGUkMSA9IE9iamVjdFtQUk9UT1RZUEVdO1xuICB2YXIgJFN5bWJvbCA9IGdsb2JhbCRmLlN5bWJvbDtcbiAgdmFyIFN5bWJvbFByb3RvdHlwZSA9ICRTeW1ib2wgJiYgJFN5bWJvbFtQUk9UT1RZUEVdO1xuICB2YXIgVHlwZUVycm9yJDggPSBnbG9iYWwkZi5UeXBlRXJyb3I7XG4gIHZhciBRT2JqZWN0ID0gZ2xvYmFsJGYuUU9iamVjdDtcbiAgdmFyICRzdHJpbmdpZnkkMSA9IGdldEJ1aWx0SW4kNCgnSlNPTicsICdzdHJpbmdpZnknKTtcbiAgdmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDEuZjtcbiAgdmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUkMS5mO1xuICB2YXIgbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mO1xuICB2YXIgbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxLmY7XG4gIHZhciBwdXNoJDMgPSB1bmN1cnJ5VGhpcyRjKFtdLnB1c2gpO1xuICB2YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xuICB2YXIgT2JqZWN0UHJvdG90eXBlU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xuICB2YXIgU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3RyaW5nLXRvLXN5bWJvbC1yZWdpc3RyeScpO1xuICB2YXIgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXRvLXN0cmluZy1yZWdpc3RyeScpO1xuICB2YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTsgLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG5cbiAgdmFyIFVTRV9TRVRURVIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkOyAvLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcblxuICB2YXIgc2V0U3ltYm9sRGVzY3JpcHRvciA9IERFU0NSSVBUT1JTJDkgJiYgZmFpbHMkZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5hdGl2ZU9iamVjdENyZWF0ZShuYXRpdmVEZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KHRoaXMsICdhJywge1xuICAgICAgICAgIHZhbHVlOiA3XG4gICAgICAgIH0pLmE7XG4gICAgICB9XG4gICAgfSkpLmEgIT0gNztcbiAgfSkgPyBmdW5jdGlvbiAoTywgUCwgQXR0cmlidXRlcykge1xuICAgIHZhciBPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yID0gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoT2JqZWN0UHJvdG90eXBlJDEsIFApO1xuICAgIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKSBkZWxldGUgT2JqZWN0UHJvdG90eXBlJDFbUF07XG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG5cbiAgICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciAmJiBPICE9PSBPYmplY3RQcm90b3R5cGUkMSkge1xuICAgICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlJDEsIFAsIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpO1xuICAgIH1cbiAgfSA6IG5hdGl2ZURlZmluZVByb3BlcnR5O1xuXG4gIHZhciB3cmFwJDEgPSBmdW5jdGlvbiAodGFnLCBkZXNjcmlwdGlvbikge1xuICAgIHZhciBzeW1ib2wgPSBBbGxTeW1ib2xzW3RhZ10gPSBuYXRpdmVPYmplY3RDcmVhdGUoU3ltYm9sUHJvdG90eXBlKTtcbiAgICBzZXRJbnRlcm5hbFN0YXRlJDIoc3ltYm9sLCB7XG4gICAgICB0eXBlOiBTWU1CT0wsXG4gICAgICB0YWc6IHRhZyxcbiAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICAgIH0pO1xuICAgIGlmICghREVTQ1JJUFRPUlMkOSkgc3ltYm9sLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfTtcblxuICB2YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICAgIGlmIChPID09PSBPYmplY3RQcm90b3R5cGUkMSkgJGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFAsIEF0dHJpYnV0ZXMpO1xuICAgIGFuT2JqZWN0JDMoTyk7XG4gICAgdmFyIGtleSA9IHRvUHJvcGVydHlLZXkoUCk7XG4gICAgYW5PYmplY3QkMyhBdHRyaWJ1dGVzKTtcblxuICAgIGlmIChoYXNPd24kNShBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgICBpZiAoIUF0dHJpYnV0ZXMuZW51bWVyYWJsZSkge1xuICAgICAgICBpZiAoIWhhc093biQ1KE8sIEhJRERFTikpIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIEhJRERFTiwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHt9KSk7XG4gICAgICAgIE9bSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChoYXNPd24kNShPLCBISURERU4pICYmIE9bSElEREVOXVtrZXldKSBPW0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgICBBdHRyaWJ1dGVzID0gbmF0aXZlT2JqZWN0Q3JlYXRlKEF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgZmFsc2UpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0U3ltYm9sRGVzY3JpcHRvcihPLCBrZXksIEF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBrZXksIEF0dHJpYnV0ZXMpO1xuICB9O1xuXG4gIHZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICAgIGFuT2JqZWN0JDMoTyk7XG4gICAgdmFyIHByb3BlcnRpZXMgPSB0b0luZGV4ZWRPYmplY3QkNChQcm9wZXJ0aWVzKTtcbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXMkMihwcm9wZXJ0aWVzKS5jb25jYXQoJGdldE93blByb3BlcnR5U3ltYm9scyhwcm9wZXJ0aWVzKSk7XG4gICAgJGZvckVhY2gkMShrZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoIURFU0NSSVBUT1JTJDkgfHwgY2FsbCQyKCRwcm9wZXJ0eUlzRW51bWVyYWJsZSQxLCBwcm9wZXJ0aWVzLCBrZXkpKSAkZGVmaW5lUHJvcGVydHkoTywga2V5LCBwcm9wZXJ0aWVzW2tleV0pO1xuICAgIH0pO1xuICAgIHJldHVybiBPO1xuICB9O1xuXG4gIHZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gbmF0aXZlT2JqZWN0Q3JlYXRlKE8pIDogJGRlZmluZVByb3BlcnRpZXMobmF0aXZlT2JqZWN0Q3JlYXRlKE8pLCBQcm9wZXJ0aWVzKTtcbiAgfTtcblxuICB2YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlJDEgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gICAgdmFyIFAgPSB0b1Byb3BlcnR5S2V5KFYpO1xuICAgIHZhciBlbnVtZXJhYmxlID0gY2FsbCQyKG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLCB0aGlzLCBQKTtcbiAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlJDEgJiYgaGFzT3duJDUoQWxsU3ltYm9scywgUCkgJiYgIWhhc093biQ1KE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFApKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGVudW1lcmFibGUgfHwgIWhhc093biQ1KHRoaXMsIFApIHx8ICFoYXNPd24kNShBbGxTeW1ib2xzLCBQKSB8fCBoYXNPd24kNSh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtQXSA/IGVudW1lcmFibGUgOiB0cnVlO1xuICB9O1xuXG4gIHZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgICB2YXIgaXQgPSB0b0luZGV4ZWRPYmplY3QkNChPKTtcbiAgICB2YXIga2V5ID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgICBpZiAoaXQgPT09IE9iamVjdFByb3RvdHlwZSQxICYmIGhhc093biQ1KEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhc093biQ1KE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgICB2YXIgZGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKGl0LCBrZXkpO1xuXG4gICAgaWYgKGRlc2NyaXB0b3IgJiYgaGFzT3duJDUoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhc093biQ1KGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIHtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gIH07XG5cbiAgdmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gICAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyh0b0luZGV4ZWRPYmplY3QkNChPKSk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICRmb3JFYWNoJDEobmFtZXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghaGFzT3duJDUoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzT3duJDUoaGlkZGVuS2V5cyQxLCBrZXkpKSBwdXNoJDMocmVzdWx0LCBrZXkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTykge1xuICAgIHZhciBJU19PQkpFQ1RfUFJPVE9UWVBFID0gTyA9PT0gT2JqZWN0UHJvdG90eXBlJDE7XG4gICAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyhJU19PQkpFQ1RfUFJPVE9UWVBFID8gT2JqZWN0UHJvdG90eXBlU3ltYm9scyA6IHRvSW5kZXhlZE9iamVjdCQ0KE8pKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgJGZvckVhY2gkMShuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKGhhc093biQ1KEFsbFN5bWJvbHMsIGtleSkgJiYgKCFJU19PQkpFQ1RfUFJPVE9UWVBFIHx8IGhhc093biQ1KE9iamVjdFByb3RvdHlwZSQxLCBrZXkpKSkge1xuICAgICAgICBwdXNoJDMocmVzdWx0LCBBbGxTeW1ib2xzW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07IC8vIGBTeW1ib2xgIGNvbnN0cnVjdG9yXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLWNvbnN0cnVjdG9yXG5cblxuICBpZiAoIU5BVElWRV9TWU1CT0wpIHtcbiAgICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgICAgaWYgKGlzUHJvdG90eXBlT2YkYyhTeW1ib2xQcm90b3R5cGUsIHRoaXMpKSB0aHJvdyBUeXBlRXJyb3IkOCgnU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG4gICAgICB2YXIgZGVzY3JpcHRpb24gPSAhYXJndW1lbnRzLmxlbmd0aCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICR0b1N0cmluZyhhcmd1bWVudHNbMF0pO1xuICAgICAgdmFyIHRhZyA9IHVpZCQxKGRlc2NyaXB0aW9uKTtcblxuICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlJDEpIGNhbGwkMihzZXR0ZXIsIE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIHZhbHVlKTtcbiAgICAgICAgaWYgKGhhc093biQ1KHRoaXMsIEhJRERFTikgJiYgaGFzT3duJDUodGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgICBzZXRTeW1ib2xEZXNjcmlwdG9yKHRoaXMsIHRhZywgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoREVTQ1JJUFRPUlMkOSAmJiBVU0VfU0VUVEVSKSBzZXRTeW1ib2xEZXNjcmlwdG9yKE9iamVjdFByb3RvdHlwZSQxLCB0YWcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gd3JhcCQxKHRhZywgZGVzY3JpcHRpb24pO1xuICAgIH07XG5cbiAgICBTeW1ib2xQcm90b3R5cGUgPSAkU3ltYm9sW1BST1RPVFlQRV07XG4gICAgcmVkZWZpbmUkMShTeW1ib2xQcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykudGFnO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lJDEoJFN5bWJvbCwgJ3dpdGhvdXRTZXR0ZXInLCBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICAgIHJldHVybiB3cmFwJDEodWlkJDEoZGVzY3JpcHRpb24pLCBkZXNjcmlwdGlvbik7XG4gICAgfSk7XG4gICAgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlJDE7XG4gICAgZGVmaW5lUHJvcGVydHlNb2R1bGUkMS5mID0gJGRlZmluZVByb3BlcnR5O1xuICAgIGRlZmluZVByb3BlcnRpZXNNb2R1bGUuZiA9ICRkZWZpbmVQcm9wZXJ0aWVzO1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSQxLmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUkMi5mID0gZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMi5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICAgIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gd3JhcCQxKHdlbGxLbm93blN5bWJvbCQ1KG5hbWUpLCBuYW1lKTtcbiAgICB9O1xuXG4gICAgaWYgKERFU0NSSVBUT1JTJDkpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLVN5bWJvbC1kZXNjcmlwdGlvblxuICAgICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoU3ltYm9sUHJvdG90eXBlLCAnZGVzY3JpcHRpb24nLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5kZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgJCR1KHtcbiAgICBnbG9iYWw6IHRydWUsXG4gICAgd3JhcDogdHJ1ZSxcbiAgICBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLFxuICAgIHNoYW06ICFOQVRJVkVfU1lNQk9MXG4gIH0sIHtcbiAgICBTeW1ib2w6ICRTeW1ib2xcbiAgfSk7XG4gICRmb3JFYWNoJDEob2JqZWN0S2V5cyQyKFdlbGxLbm93blN5bWJvbHNTdG9yZSksIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgZGVmaW5lV2VsbEtub3duU3ltYm9sJGsobmFtZSk7XG4gIH0pO1xuICAkJHUoe1xuICAgIHRhcmdldDogU1lNQk9MLFxuICAgIHN0YXQ6IHRydWUsXG4gICAgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTFxuICB9LCB7XG4gICAgLy8gYFN5bWJvbC5mb3JgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmZvclxuICAgICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgc3RyaW5nID0gJHRvU3RyaW5nKGtleSk7XG4gICAgICBpZiAoaGFzT3duJDUoU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSwgc3RyaW5nKSkgcmV0dXJuIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXTtcbiAgICAgIHZhciBzeW1ib2wgPSAkU3ltYm9sKHN0cmluZyk7XG4gICAgICBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ10gPSBzeW1ib2w7XG4gICAgICBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5W3N5bWJvbF0gPSBzdHJpbmc7XG4gICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH0sXG4gICAgLy8gYFN5bWJvbC5rZXlGb3JgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmtleWZvclxuICAgIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3IkOChzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCcpO1xuICAgICAgaWYgKGhhc093biQ1KFN5bWJvbFRvU3RyaW5nUmVnaXN0cnksIHN5bSkpIHJldHVybiBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5W3N5bV07XG4gICAgfSxcbiAgICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFVTRV9TRVRURVIgPSB0cnVlO1xuICAgIH0sXG4gICAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBVU0VfU0VUVEVSID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgJCR1KHtcbiAgICB0YXJnZXQ6ICdPYmplY3QnLFxuICAgIHN0YXQ6IHRydWUsXG4gICAgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCxcbiAgICBzaGFtOiAhREVTQ1JJUFRPUlMkOVxuICB9LCB7XG4gICAgLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuICAgIGNyZWF0ZTogJGNyZWF0ZSxcbiAgICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuICAgIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gICAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4gICAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gICAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgfSk7XG4gICQkdSh7XG4gICAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgICBzdGF0OiB0cnVlLFxuICAgIGZvcmNlZDogIU5BVElWRV9TWU1CT0xcbiAgfSwge1xuICAgIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuICAgIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAgIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eXN5bWJvbHNcbiAgICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbiAgfSk7IC8vIENocm9tZSAzOCBhbmQgMzkgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIGZhaWxzIG9uIHByaW1pdGl2ZXNcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0M1xuXG4gICQkdSh7XG4gICAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgICBzdGF0OiB0cnVlLFxuICAgIGZvcmNlZDogZmFpbHMkZShmdW5jdGlvbiAoKSB7XG4gICAgICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMi5mKDEpO1xuICAgIH0pXG4gIH0sIHtcbiAgICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICAgICAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQyLmYodG9PYmplY3QkNyhpdCkpO1xuICAgIH1cbiAgfSk7IC8vIGBKU09OLnN0cmluZ2lmeWAgbWV0aG9kIGJlaGF2aW9yIHdpdGggc3ltYm9sc1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5XG5cbiAgaWYgKCRzdHJpbmdpZnkkMSkge1xuICAgIHZhciBGT1JDRURfSlNPTl9TVFJJTkdJRlkgPSAhTkFUSVZFX1NZTUJPTCB8fCBmYWlscyRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzeW1ib2wgPSAkU3ltYm9sKCk7IC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG5cbiAgICAgIHJldHVybiAkc3RyaW5naWZ5JDEoW3N5bWJvbF0pICE9ICdbbnVsbF0nIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAgICAgfHwgJHN0cmluZ2lmeSQxKHtcbiAgICAgICAgYTogc3ltYm9sXG4gICAgICB9KSAhPSAne30nIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gICAgICB8fCAkc3RyaW5naWZ5JDEoT2JqZWN0KHN5bWJvbCkpICE9ICd7fSc7XG4gICAgfSk7XG4gICAgJCR1KHtcbiAgICAgIHRhcmdldDogJ0pTT04nLFxuICAgICAgc3RhdDogdHJ1ZSxcbiAgICAgIGZvcmNlZDogRk9SQ0VEX0pTT05fU1RSSU5HSUZZXG4gICAgfSwge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0LCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlJDIoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyICRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgICAgICBpZiAoIWlzT2JqZWN0JDcocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcblxuICAgICAgICBpZiAoIWlzQXJyYXkkYShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoaXNDYWxsYWJsZSQyKCRyZXBsYWNlcikpIHZhbHVlID0gY2FsbCQyKCRyZXBsYWNlciwgdGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgICAgICByZXR1cm4gYXBwbHkkNCgkc3RyaW5naWZ5JDEsIG51bGwsIGFyZ3MpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IC8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcblxuXG4gIGlmICghU3ltYm9sUHJvdG90eXBlW1RPX1BSSU1JVElWRV0pIHtcbiAgICB2YXIgdmFsdWVPZiA9IFN5bWJvbFByb3RvdHlwZS52YWx1ZU9mOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIC5sZW5ndGhcblxuICAgIHJlZGVmaW5lJDEoU3ltYm9sUHJvdG90eXBlLCBUT19QUklNSVRJVkUsIGZ1bmN0aW9uIChoaW50KSB7XG4gICAgICAvLyBUT0RPOiBpbXByb3ZlIGhpbnQgbG9naWNcbiAgICAgIHJldHVybiBjYWxsJDIodmFsdWVPZiwgdGhpcyk7XG4gICAgfSk7XG4gIH0gLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11gIHByb3BlcnR5XG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnXG5cblxuICBzZXRUb1N0cmluZ1RhZyQyKCRTeW1ib2wsIFNZTUJPTCk7XG4gIGhpZGRlbktleXMkMVtISURERU5dID0gdHJ1ZTtcblxuICB2YXIgcGF0aCRqID0gcGF0aCRxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzJDIgPSBwYXRoJGouT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuICB2YXIgcGFyZW50JEogPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMkMjtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyQxID0gcGFyZW50JEo7XG5cbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyQxO1xuXG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyA9IHtleHBvcnRzOiB7fX07XG5cbiAgdmFyICQkdCA9IF9leHBvcnQ7XG4gIHZhciBmYWlscyRkID0gZmFpbHMkcjtcbiAgdmFyIHRvSW5kZXhlZE9iamVjdCQzID0gdG9JbmRleGVkT2JqZWN0JGI7XG4gIHZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbiAgdmFyIERFU0NSSVBUT1JTJDggPSBkZXNjcmlwdG9ycztcbiAgdmFyIEZBSUxTX09OX1BSSU1JVElWRVMkMyA9IGZhaWxzJGQoZnVuY3Rpb24gKCkge1xuICAgIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcigxKTtcbiAgfSk7XG4gIHZhciBGT1JDRUQkNSA9ICFERVNDUklQVE9SUyQ4IHx8IEZBSUxTX09OX1BSSU1JVElWRVMkMzsgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcblxuICAkJHQoe1xuICAgIHRhcmdldDogJ09iamVjdCcsXG4gICAgc3RhdDogdHJ1ZSxcbiAgICBmb3JjZWQ6IEZPUkNFRCQ1LFxuICAgIHNoYW06ICFERVNDUklQVE9SUyQ4XG4gIH0sIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSW5kZXhlZE9iamVjdCQzKGl0KSwga2V5KTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwYXRoJGkgPSBwYXRoJHE7XG4gIHZhciBPYmplY3QkMyA9IHBhdGgkaS5PYmplY3Q7XG5cbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdCQzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbiAgfTtcblxuICBpZiAoT2JqZWN0JDMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLnNoYW0pIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyLnNoYW0gPSB0cnVlO1xuXG4gIHZhciBwYXJlbnQkSSA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzLmV4cG9ydHM7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IHBhcmVudCRJO1xuXG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMTtcblxuICB2YXIgZ2V0QnVpbHRJbiQzID0gZ2V0QnVpbHRJbiQ5O1xuICB2YXIgdW5jdXJyeVRoaXMkYiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4gIHZhciBhbk9iamVjdCQyID0gYW5PYmplY3QkYjtcbiAgdmFyIGNvbmNhdCQ1ID0gdW5jdXJyeVRoaXMkYihbXS5jb25jYXQpOyAvLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG5cbiAgdmFyIG93bktleXMkNiA9IGdldEJ1aWx0SW4kMygnUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSQxLmYoYW5PYmplY3QkMihpdCkpO1xuICAgIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMS5mO1xuICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQkNShrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG4gIH07XG5cbiAgdmFyICQkcyA9IF9leHBvcnQ7XG4gIHZhciBERVNDUklQVE9SUyQ3ID0gZGVzY3JpcHRvcnM7XG4gIHZhciBvd25LZXlzJDUgPSBvd25LZXlzJDY7XG4gIHZhciB0b0luZGV4ZWRPYmplY3QkMiA9IHRvSW5kZXhlZE9iamVjdCRiO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICB2YXIgY3JlYXRlUHJvcGVydHkkMyA9IGNyZWF0ZVByb3BlcnR5JDY7IC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcblxuICAkJHMoe1xuICAgIHRhcmdldDogJ09iamVjdCcsXG4gICAgc3RhdDogdHJ1ZSxcbiAgICBzaGFtOiAhREVTQ1JJUFRPUlMkN1xuICB9LCB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0JDIob2JqZWN0KTtcbiAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgICAgIHZhciBrZXlzID0gb3duS2V5cyQ1KE8pO1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBrZXksIGRlc2NyaXB0b3I7XG5cbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywga2V5ID0ga2V5c1tpbmRleCsrXSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5JDMocmVzdWx0LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHBhdGgkaCA9IHBhdGgkcTtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMkMiA9IHBhdGgkaC5PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcblxuICB2YXIgcGFyZW50JEggPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJDI7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJDEgPSBwYXJlbnQkSDtcblxuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMkMTtcblxuICB2YXIgZGVmaW5lUHJvcGVydGllcyQ0ID0ge2V4cG9ydHM6IHt9fTtcblxuICB2YXIgJCRyID0gX2V4cG9ydDtcbiAgdmFyIERFU0NSSVBUT1JTJDYgPSBkZXNjcmlwdG9ycztcbiAgdmFyIGRlZmluZVByb3BlcnRpZXMkMyA9IG9iamVjdERlZmluZVByb3BlcnRpZXMuZjsgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnRpZXMgLS0gc2FmZVxuXG4gICQkcih7XG4gICAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgICBzdGF0OiB0cnVlLFxuICAgIGZvcmNlZDogT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgIT09IGRlZmluZVByb3BlcnRpZXMkMyxcbiAgICBzaGFtOiAhREVTQ1JJUFRPUlMkNlxuICB9LCB7XG4gICAgZGVmaW5lUHJvcGVydGllczogZGVmaW5lUHJvcGVydGllcyQzXG4gIH0pO1xuXG4gIHZhciBwYXRoJGcgPSBwYXRoJHE7XG4gIHZhciBPYmplY3QkMiA9IHBhdGgkZy5PYmplY3Q7XG5cbiAgdmFyIGRlZmluZVByb3BlcnRpZXMkMiA9IGRlZmluZVByb3BlcnRpZXMkNC5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhULCBEKSB7XG4gICAgcmV0dXJuIE9iamVjdCQyLmRlZmluZVByb3BlcnRpZXMoVCwgRCk7XG4gIH07XG5cbiAgaWYgKE9iamVjdCQyLmRlZmluZVByb3BlcnRpZXMuc2hhbSkgZGVmaW5lUHJvcGVydGllcyQyLnNoYW0gPSB0cnVlO1xuXG4gIHZhciBwYXJlbnQkRyA9IGRlZmluZVByb3BlcnRpZXMkNC5leHBvcnRzO1xuICB2YXIgZGVmaW5lUHJvcGVydGllcyQxID0gcGFyZW50JEc7XG5cbiAgdmFyIGRlZmluZVByb3BlcnRpZXMgPSBkZWZpbmVQcm9wZXJ0aWVzJDE7XG5cbiAgdmFyIGRlZmluZVByb3BlcnR5JDQgPSBkZWZpbmVQcm9wZXJ0eSRhO1xuXG4gIHZhciAkJHEgPSBfZXhwb3J0O1xuICB2YXIgaXNBcnJheSQ5ID0gaXNBcnJheSRkOyAvLyBgQXJyYXkuaXNBcnJheWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuaXNhcnJheVxuXG4gICQkcSh7XG4gICAgdGFyZ2V0OiAnQXJyYXknLFxuICAgIHN0YXQ6IHRydWVcbiAgfSwge1xuICAgIGlzQXJyYXk6IGlzQXJyYXkkOVxuICB9KTtcblxuICB2YXIgcGF0aCRmID0gcGF0aCRxO1xuICB2YXIgaXNBcnJheSQ4ID0gcGF0aCRmLkFycmF5LmlzQXJyYXk7XG5cbiAgdmFyIHBhcmVudCRGID0gaXNBcnJheSQ4O1xuICB2YXIgaXNBcnJheSQ3ID0gcGFyZW50JEY7XG5cbiAgdmFyIHBhcmVudCRFID0gaXNBcnJheSQ3O1xuICB2YXIgaXNBcnJheSQ2ID0gcGFyZW50JEU7XG5cbiAgdmFyIHBhcmVudCREID0gaXNBcnJheSQ2O1xuICB2YXIgaXNBcnJheSQ1ID0gcGFyZW50JEQ7XG5cbiAgdmFyIGlzQXJyYXkkNCA9IGlzQXJyYXkkNTtcblxuICBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gICAgaWYgKGlzQXJyYXkkNChhcnIpKSByZXR1cm4gYXJyO1xuICB9XG5cbiAgdmFyICQkcCA9IF9leHBvcnQ7XG4gIHZhciBnbG9iYWwkZSA9IGdsb2JhbCRNO1xuICB2YXIgZmFpbHMkYyA9IGZhaWxzJHI7XG4gIHZhciBpc0FycmF5JDMgPSBpc0FycmF5JGQ7XG4gIHZhciBpc09iamVjdCQ2ID0gaXNPYmplY3QkZjtcbiAgdmFyIHRvT2JqZWN0JDYgPSB0b09iamVjdCRlO1xuICB2YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNSA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG4gIHZhciBjcmVhdGVQcm9wZXJ0eSQyID0gY3JlYXRlUHJvcGVydHkkNjtcbiAgdmFyIGFycmF5U3BlY2llc0NyZWF0ZSQxID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDQ7XG4gIHZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDIgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDU7XG4gIHZhciB3ZWxsS25vd25TeW1ib2wkNCA9IHdlbGxLbm93blN5bWJvbCRqO1xuICB2YXIgVjhfVkVSU0lPTiA9IGVuZ2luZVY4VmVyc2lvbjtcbiAgdmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gd2VsbEtub3duU3ltYm9sJDQoJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xuICB2YXIgTUFYX1NBRkVfSU5URUdFUiQxID0gMHgxRkZGRkZGRkZGRkZGRjtcbiAgdmFyIE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCA9ICdNYXhpbXVtIGFsbG93ZWQgaW5kZXggZXhjZWVkZWQnO1xuICB2YXIgVHlwZUVycm9yJDcgPSBnbG9iYWwkZS5UeXBlRXJyb3I7IC8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuICAvLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG5cbiAgdmFyIElTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgPSBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyRjKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBhcnJheVtJU19DT05DQVRfU1BSRUFEQUJMRV0gPSBmYWxzZTtcbiAgICByZXR1cm4gYXJyYXkuY29uY2F0KClbMF0gIT09IGFycmF5O1xuICB9KTtcbiAgdmFyIFNQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMignY29uY2F0Jyk7XG5cbiAgdmFyIGlzQ29uY2F0U3ByZWFkYWJsZSA9IGZ1bmN0aW9uIChPKSB7XG4gICAgaWYgKCFpc09iamVjdCQ2KE8pKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHNwcmVhZGFibGUgPSBPW0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcbiAgICByZXR1cm4gc3ByZWFkYWJsZSAhPT0gdW5kZWZpbmVkID8gISFzcHJlYWRhYmxlIDogaXNBcnJheSQzKE8pO1xuICB9O1xuXG4gIHZhciBGT1JDRUQkNCA9ICFJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUIHx8ICFTUEVDSUVTX1NVUFBPUlQ7IC8vIGBBcnJheS5wcm90b3R5cGUuY29uY2F0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuY29uY2F0XG4gIC8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBpc0NvbmNhdFNwcmVhZGFibGUgYW5kIEBAc3BlY2llc1xuXG4gICQkcCh7XG4gICAgdGFyZ2V0OiAnQXJyYXknLFxuICAgIHByb3RvOiB0cnVlLFxuICAgIGZvcmNlZDogRk9SQ0VEJDRcbiAgfSwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gICAgY29uY2F0OiBmdW5jdGlvbiBjb25jYXQoYXJnKSB7XG4gICAgICB2YXIgTyA9IHRvT2JqZWN0JDYodGhpcyk7XG4gICAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZSQxKE8sIDApO1xuICAgICAgdmFyIG4gPSAwO1xuICAgICAgdmFyIGksIGssIGxlbmd0aCwgbGVuLCBFO1xuXG4gICAgICBmb3IgKGkgPSAtMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIEUgPSBpID09PSAtMSA/IE8gOiBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgaWYgKGlzQ29uY2F0U3ByZWFkYWJsZShFKSkge1xuICAgICAgICAgIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlJDUoRSk7XG4gICAgICAgICAgaWYgKG4gKyBsZW4gPiBNQVhfU0FGRV9JTlRFR0VSJDEpIHRocm93IFR5cGVFcnJvciQ3KE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7XG5cbiAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyssIG4rKykgaWYgKGsgaW4gRSkgY3JlYXRlUHJvcGVydHkkMihBLCBuLCBFW2tdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobiA+PSBNQVhfU0FGRV9JTlRFR0VSJDEpIHRocm93IFR5cGVFcnJvciQ3KE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7XG4gICAgICAgICAgY3JlYXRlUHJvcGVydHkkMihBLCBuKyssIEUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEEubGVuZ3RoID0gbjtcbiAgICAgIHJldHVybiBBO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRqID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAgd2VsbC1rbm93biBzeW1ib2xcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuYXN5bmNpdGVyYXRvclxuXG4gIGRlZmluZVdlbGxLbm93blN5bWJvbCRqKCdhc3luY0l0ZXJhdG9yJyk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRpID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuaGFzSW5zdGFuY2VgIHdlbGwta25vd24gc3ltYm9sXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmhhc2luc3RhbmNlXG5cbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJGkoJ2hhc0luc3RhbmNlJyk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRoID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlYCB3ZWxsLWtub3duIHN5bWJvbFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5pc2NvbmNhdHNwcmVhZGFibGVcblxuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkaCgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRnID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuaXRlcmF0b3JgIHdlbGwta25vd24gc3ltYm9sXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLml0ZXJhdG9yXG5cbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJGcoJ2l0ZXJhdG9yJyk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRmID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wubWF0Y2hgIHdlbGwta25vd24gc3ltYm9sXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLm1hdGNoXG5cbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJGYoJ21hdGNoJyk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRlID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wubWF0Y2hBbGxgIHdlbGwta25vd24gc3ltYm9sXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLm1hdGNoYWxsXG5cbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJGUoJ21hdGNoQWxsJyk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRkID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wucmVwbGFjZWAgd2VsbC1rbm93biBzeW1ib2xcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucmVwbGFjZVxuXG4gIGRlZmluZVdlbGxLbm93blN5bWJvbCRkKCdyZXBsYWNlJyk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRjID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuc2VhcmNoYCB3ZWxsLWtub3duIHN5bWJvbFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5zZWFyY2hcblxuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkYygnc2VhcmNoJyk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRiID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuc3BlY2llc2Agd2VsbC1rbm93biBzeW1ib2xcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuc3BlY2llc1xuXG4gIGRlZmluZVdlbGxLbm93blN5bWJvbCRiKCdzcGVjaWVzJyk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRhID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuc3BsaXRgIHdlbGwta25vd24gc3ltYm9sXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnNwbGl0XG5cbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJGEoJ3NwbGl0Jyk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQ5ID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wudG9QcmltaXRpdmVgIHdlbGwta25vd24gc3ltYm9sXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnRvcHJpbWl0aXZlXG5cbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJDkoJ3RvUHJpbWl0aXZlJyk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQ4ID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wudG9TdHJpbmdUYWdgIHdlbGwta25vd24gc3ltYm9sXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnRvc3RyaW5ndGFnXG5cbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJDgoJ3RvU3RyaW5nVGFnJyk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQ3ID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wudW5zY29wYWJsZXNgIHdlbGwta25vd24gc3ltYm9sXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnVuc2NvcGFibGVzXG5cbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJDcoJ3Vuc2NvcGFibGVzJyk7XG5cbiAgdmFyIGdsb2JhbCRkID0gZ2xvYmFsJE07XG4gIHZhciBzZXRUb1N0cmluZ1RhZyQxID0gc2V0VG9TdHJpbmdUYWckNTsgLy8gSlNPTltAQHRvU3RyaW5nVGFnXSBwcm9wZXJ0eVxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24tQEB0b3N0cmluZ3RhZ1xuXG4gIHNldFRvU3RyaW5nVGFnJDEoZ2xvYmFsJGQuSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxuICB2YXIgcGF0aCRlID0gcGF0aCRxO1xuICB2YXIgc3ltYm9sJDUgPSBwYXRoJGUuU3ltYm9sO1xuXG4gIHZhciBwYXJlbnQkQyA9IHN5bWJvbCQ1O1xuICB2YXIgc3ltYm9sJDQgPSBwYXJlbnQkQztcblxuICB2YXIgcGFyZW50JEIgPSBzeW1ib2wkNDtcbiAgdmFyIHN5bWJvbCQzID0gcGFyZW50JEI7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQ2ID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuYXN5bmNEaXNwb3NlYCB3ZWxsLWtub3duIHN5bWJvbFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC11c2luZy1zdGF0ZW1lbnRcblxuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkNignYXN5bmNEaXNwb3NlJyk7XG5cbiAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQ1ID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuZGlzcG9zZWAgd2VsbC1rbm93biBzeW1ib2xcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtdXNpbmctc3RhdGVtZW50XG5cbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJDUoJ2Rpc3Bvc2UnKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDQgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5tYXRjaGVyYCB3ZWxsLWtub3duIHN5bWJvbFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wYXR0ZXJuLW1hdGNoaW5nXG5cbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJDQoJ21hdGNoZXInKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDMgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5tZXRhZGF0YWAgd2VsbC1rbm93biBzeW1ib2xcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZGVjb3JhdG9yc1xuXG4gIGRlZmluZVdlbGxLbm93blN5bWJvbCQzKCdtZXRhZGF0YScpO1xuXG4gIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkMiA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLm9ic2VydmFibGVgIHdlbGwta25vd24gc3ltYm9sXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcblxuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkMignb2JzZXJ2YWJsZScpO1xuXG4gIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkMSA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLnBhdHRlcm5NYXRjaGAgd2VsbC1rbm93biBzeW1ib2xcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcGF0dGVybi1tYXRjaGluZ1xuXG4gIGRlZmluZVdlbGxLbm93blN5bWJvbCQxKCdwYXR0ZXJuTWF0Y2gnKTtcblxuICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7XG4gIGRlZmluZVdlbGxLbm93blN5bWJvbCgncmVwbGFjZUFsbCcpO1xuXG4gIHZhciBwYXJlbnQkQSA9IHN5bWJvbCQzOyAvLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxuICAvLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxuXG4gIHZhciBzeW1ib2wkMiA9IHBhcmVudCRBO1xuXG4gIHZhciBzeW1ib2wkMSA9IHN5bWJvbCQyO1xuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2Ygc3ltYm9sJDEgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShhcnIpIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcblxuICAgIHZhciBfcywgX2U7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgdmFyICQkbyA9IF9leHBvcnQ7XG4gIHZhciBnbG9iYWwkYyA9IGdsb2JhbCRNO1xuICB2YXIgaXNBcnJheSQyID0gaXNBcnJheSRkO1xuICB2YXIgaXNDb25zdHJ1Y3RvciQxID0gaXNDb25zdHJ1Y3RvciQ0O1xuICB2YXIgaXNPYmplY3QkNSA9IGlzT2JqZWN0JGY7XG4gIHZhciB0b0Fic29sdXRlSW5kZXgkMiA9IHRvQWJzb2x1dGVJbmRleCQ1O1xuICB2YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNCA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG4gIHZhciB0b0luZGV4ZWRPYmplY3QkMSA9IHRvSW5kZXhlZE9iamVjdCRiO1xuICB2YXIgY3JlYXRlUHJvcGVydHkkMSA9IGNyZWF0ZVByb3BlcnR5JDY7XG4gIHZhciB3ZWxsS25vd25TeW1ib2wkMyA9IHdlbGxLbm93blN5bWJvbCRqO1xuICB2YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQxID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ1O1xuICB2YXIgdW4kU2xpY2UgPSBhcnJheVNsaWNlJDU7XG4gIHZhciBIQVNfU1BFQ0lFU19TVVBQT1JUJDEgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDEoJ3NsaWNlJyk7XG4gIHZhciBTUEVDSUVTJDEgPSB3ZWxsS25vd25TeW1ib2wkMygnc3BlY2llcycpO1xuICB2YXIgQXJyYXkkMiA9IGdsb2JhbCRjLkFycmF5O1xuICB2YXIgbWF4JDEgPSBNYXRoLm1heDsgLy8gYEFycmF5LnByb3RvdHlwZS5zbGljZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNsaWNlXG4gIC8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcblxuICAkJG8oe1xuICAgIHRhcmdldDogJ0FycmF5JyxcbiAgICBwcm90bzogdHJ1ZSxcbiAgICBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUJDFcbiAgfSwge1xuICAgIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQxKHRoaXMpO1xuICAgICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDQoTyk7XG4gICAgICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleCQyKHN0YXJ0LCBsZW5ndGgpO1xuICAgICAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleCQyKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpOyAvLyBpbmxpbmUgYEFycmF5U3BlY2llc0NyZWF0ZWAgZm9yIHVzYWdlIG5hdGl2ZSBgQXJyYXkjc2xpY2VgIHdoZXJlIGl0J3MgcG9zc2libGVcblxuICAgICAgdmFyIENvbnN0cnVjdG9yLCByZXN1bHQsIG47XG5cbiAgICAgIGlmIChpc0FycmF5JDIoTykpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSBPLmNvbnN0cnVjdG9yOyAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuXG4gICAgICAgIGlmIChpc0NvbnN0cnVjdG9yJDEoQ29uc3RydWN0b3IpICYmIChDb25zdHJ1Y3RvciA9PT0gQXJyYXkkMiB8fCBpc0FycmF5JDIoQ29uc3RydWN0b3IucHJvdG90eXBlKSkpIHtcbiAgICAgICAgICBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdCQ1KENvbnN0cnVjdG9yKSkge1xuICAgICAgICAgIENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3JbU1BFQ0lFUyQxXTtcbiAgICAgICAgICBpZiAoQ29uc3RydWN0b3IgPT09IG51bGwpIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBBcnJheSQyIHx8IENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW4kU2xpY2UoTywgaywgZmluKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBuZXcgKENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgPyBBcnJheSQyIDogQ29uc3RydWN0b3IpKG1heCQxKGZpbiAtIGssIDApKTtcblxuICAgICAgZm9yIChuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGlmIChrIGluIE8pIGNyZWF0ZVByb3BlcnR5JDEocmVzdWx0LCBuLCBPW2tdKTtcblxuICAgICAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGVudHJ5VmlydHVhbCRlID0gZW50cnlWaXJ0dWFsJGs7XG4gIHZhciBzbGljZSQ2ID0gZW50cnlWaXJ0dWFsJGUoJ0FycmF5Jykuc2xpY2U7XG5cbiAgdmFyIGlzUHJvdG90eXBlT2YkYiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG4gIHZhciBtZXRob2QkOSA9IHNsaWNlJDY7XG4gIHZhciBBcnJheVByb3RvdHlwZSQ5ID0gQXJyYXkucHJvdG90eXBlO1xuXG4gIHZhciBzbGljZSQ1ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIG93biA9IGl0LnNsaWNlO1xuICAgIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkOSB8fCBpc1Byb3RvdHlwZU9mJGIoQXJyYXlQcm90b3R5cGUkOSwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkOS5zbGljZSA/IG1ldGhvZCQ5IDogb3duO1xuICB9O1xuXG4gIHZhciBwYXJlbnQkeiA9IHNsaWNlJDU7XG4gIHZhciBzbGljZSQ0ID0gcGFyZW50JHo7XG5cbiAgdmFyIHBhcmVudCR5ID0gc2xpY2UkNDtcbiAgdmFyIHNsaWNlJDMgPSBwYXJlbnQkeTtcblxuICB2YXIgcGFyZW50JHggPSBzbGljZSQzO1xuICB2YXIgc2xpY2UkMiA9IHBhcmVudCR4O1xuXG4gIHZhciBzbGljZSQxID0gc2xpY2UkMjtcblxuICB2YXIgcGFyZW50JHcgPSBmcm9tJDQ7XG4gIHZhciBmcm9tJDIgPSBwYXJlbnQkdztcblxuICB2YXIgcGFyZW50JHYgPSBmcm9tJDI7XG4gIHZhciBmcm9tJDEgPSBwYXJlbnQkdjtcblxuICB2YXIgZnJvbSA9IGZyb20kMTtcblxuICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ0KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cblxuICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNChvLCBtaW5MZW4pIHtcbiAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ0KG8sIG1pbkxlbik7XG5cbiAgICB2YXIgbiA9IHNsaWNlJDEoX2NvbnRleHQgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQsIDgsIC0xKTtcblxuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb20obyk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ0KG8sIG1pbkxlbik7XG4gIH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG4gIH1cblxuICB2YXIgV3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHdlbGxLbm93blN5bWJvbFdyYXBwZWQ7XG4gIHZhciBpdGVyYXRvciQ1ID0gV3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mKCdpdGVyYXRvcicpO1xuXG4gIHZhciBwYXJlbnQkdSA9IGl0ZXJhdG9yJDU7XG4gIHZhciBpdGVyYXRvciQ0ID0gcGFyZW50JHU7XG5cbiAgdmFyIHBhcmVudCR0ID0gaXRlcmF0b3IkNDtcbiAgdmFyIGl0ZXJhdG9yJDMgPSBwYXJlbnQkdDtcblxuICB2YXIgcGFyZW50JHMgPSBpdGVyYXRvciQzO1xuICB2YXIgaXRlcmF0b3IkMiA9IHBhcmVudCRzO1xuXG4gIHZhciBpdGVyYXRvciQxID0gaXRlcmF0b3IkMjtcblxuICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICAgIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBzeW1ib2wkMSAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBpdGVyYXRvciQxID8gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBzeW1ib2wkMSAmJiBvYmouY29uc3RydWN0b3IgPT09IHN5bWJvbCQxICYmIG9iaiAhPT0gc3ltYm9sJDEucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfSwgX3R5cGVvZihvYmopO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICAgIGlmIChpc0FycmF5JDQoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDQoYXJyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICAgIGlmICh0eXBlb2Ygc3ltYm9sJDEgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShpdGVyKSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBmcm9tKGl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDQoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbiAgfVxuXG4gIHZhciBzeW1ib2wgPSBzeW1ib2wkNDtcblxuICB2YXIgZW50cnlWaXJ0dWFsJGQgPSBlbnRyeVZpcnR1YWwkaztcbiAgdmFyIGNvbmNhdCQ0ID0gZW50cnlWaXJ0dWFsJGQoJ0FycmF5JykuY29uY2F0O1xuXG4gIHZhciBpc1Byb3RvdHlwZU9mJGEgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuICB2YXIgbWV0aG9kJDggPSBjb25jYXQkNDtcbiAgdmFyIEFycmF5UHJvdG90eXBlJDggPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgdmFyIGNvbmNhdCQzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIG93biA9IGl0LmNvbmNhdDtcbiAgICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDggfHwgaXNQcm90b3R5cGVPZiRhKEFycmF5UHJvdG90eXBlJDgsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDguY29uY2F0ID8gbWV0aG9kJDggOiBvd247XG4gIH07XG5cbiAgdmFyIHBhcmVudCRyID0gY29uY2F0JDM7XG4gIHZhciBjb25jYXQkMiA9IHBhcmVudCRyO1xuXG4gIHZhciBjb25jYXQkMSA9IGNvbmNhdCQyO1xuXG4gIHZhciBzbGljZSA9IHNsaWNlJDQ7XG5cbiAgdmFyICQkbiA9IF9leHBvcnQ7XG4gIHZhciBvd25LZXlzJDQgPSBvd25LZXlzJDY7IC8vIGBSZWZsZWN0Lm93bktleXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZmxlY3Qub3dua2V5c1xuXG4gICQkbih7XG4gICAgdGFyZ2V0OiAnUmVmbGVjdCcsXG4gICAgc3RhdDogdHJ1ZVxuICB9LCB7XG4gICAgb3duS2V5czogb3duS2V5cyQ0XG4gIH0pO1xuXG4gIHZhciBwYXRoJGQgPSBwYXRoJHE7XG4gIHZhciBvd25LZXlzJDMgPSBwYXRoJGQuUmVmbGVjdC5vd25LZXlzO1xuXG4gIHZhciBwYXJlbnQkcSA9IG93bktleXMkMztcbiAgdmFyIG93bktleXMkMiA9IHBhcmVudCRxO1xuXG4gIHZhciBvd25LZXlzJDEgPSBvd25LZXlzJDI7XG5cbiAgdmFyIGlzQXJyYXkkMSA9IGlzQXJyYXkkNztcblxuICB2YXIgJCRtID0gX2V4cG9ydDtcbiAgdmFyIHRvT2JqZWN0JDUgPSB0b09iamVjdCRlO1xuICB2YXIgbmF0aXZlS2V5cyA9IG9iamVjdEtleXMkNDtcbiAgdmFyIGZhaWxzJGIgPSBmYWlscyRyO1xuICB2YXIgRkFJTFNfT05fUFJJTUlUSVZFUyQyID0gZmFpbHMkYihmdW5jdGlvbiAoKSB7XG4gICAgbmF0aXZlS2V5cygxKTtcbiAgfSk7IC8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcblxuICAkJG0oe1xuICAgIHRhcmdldDogJ09iamVjdCcsXG4gICAgc3RhdDogdHJ1ZSxcbiAgICBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMkMlxuICB9LCB7XG4gICAga2V5czogZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUtleXModG9PYmplY3QkNShpdCkpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHBhdGgkYyA9IHBhdGgkcTtcbiAgdmFyIGtleXMkNiA9IHBhdGgkYy5PYmplY3Qua2V5cztcblxuICB2YXIgcGFyZW50JHAgPSBrZXlzJDY7XG4gIHZhciBrZXlzJDUgPSBwYXJlbnQkcDtcblxuICB2YXIga2V5cyQ0ID0ga2V5cyQ1O1xuXG4gIHZhciAkJGwgPSBfZXhwb3J0O1xuICB2YXIgZ2xvYmFsJGIgPSBnbG9iYWwkTTtcbiAgdmFyIHVuY3VycnlUaGlzJGEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgRGF0ZSQxID0gZ2xvYmFsJGIuRGF0ZTtcbiAgdmFyIGdldFRpbWUgPSB1bmN1cnJ5VGhpcyRhKERhdGUkMS5wcm90b3R5cGUuZ2V0VGltZSk7IC8vIGBEYXRlLm5vd2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZGF0ZS5ub3dcblxuICAkJGwoe1xuICAgIHRhcmdldDogJ0RhdGUnLFxuICAgIHN0YXQ6IHRydWVcbiAgfSwge1xuICAgIG5vdzogZnVuY3Rpb24gbm93KCkge1xuICAgICAgcmV0dXJuIGdldFRpbWUobmV3IERhdGUkMSgpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwYXRoJGIgPSBwYXRoJHE7XG4gIHBhdGgkYi5EYXRlLm5vdztcblxuICB2YXIgJGZvckVhY2ggPSBhcnJheUl0ZXJhdGlvbi5mb3JFYWNoO1xuICB2YXIgYXJyYXlNZXRob2RJc1N0cmljdCQzID0gYXJyYXlNZXRob2RJc1N0cmljdCQ1O1xuICB2YXIgU1RSSUNUX01FVEhPRCQzID0gYXJyYXlNZXRob2RJc1N0cmljdCQzKCdmb3JFYWNoJyk7IC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcblxuICB2YXIgYXJyYXlGb3JFYWNoID0gIVNUUklDVF9NRVRIT0QkMyA/IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmblxuICAvKiAsIHRoaXNBcmcgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LXByb3RvdHlwZS1mb3JlYWNoIC0tIHNhZmVcbiAgfSA6IFtdLmZvckVhY2g7XG5cbiAgdmFyICQkayA9IF9leHBvcnQ7XG4gIHZhciBmb3JFYWNoJDUgPSBhcnJheUZvckVhY2g7IC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LXByb3RvdHlwZS1mb3JlYWNoIC0tIHNhZmVcblxuICAkJGsoe1xuICAgIHRhcmdldDogJ0FycmF5JyxcbiAgICBwcm90bzogdHJ1ZSxcbiAgICBmb3JjZWQ6IFtdLmZvckVhY2ggIT0gZm9yRWFjaCQ1XG4gIH0sIHtcbiAgICBmb3JFYWNoOiBmb3JFYWNoJDVcbiAgfSk7XG5cbiAgdmFyIGVudHJ5VmlydHVhbCRjID0gZW50cnlWaXJ0dWFsJGs7XG4gIHZhciBmb3JFYWNoJDQgPSBlbnRyeVZpcnR1YWwkYygnQXJyYXknKS5mb3JFYWNoO1xuXG4gIHZhciBwYXJlbnQkbyA9IGZvckVhY2gkNDtcbiAgdmFyIGZvckVhY2gkMyA9IHBhcmVudCRvO1xuXG4gIHZhciBjbGFzc29mJDUgPSBjbGFzc29mJGM7XG4gIHZhciBoYXNPd24kNCA9IGhhc093blByb3BlcnR5XzE7XG4gIHZhciBpc1Byb3RvdHlwZU9mJDkgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuICB2YXIgbWV0aG9kJDcgPSBmb3JFYWNoJDM7XG4gIHZhciBBcnJheVByb3RvdHlwZSQ3ID0gQXJyYXkucHJvdG90eXBlO1xuICB2YXIgRE9NSXRlcmFibGVzJDMgPSB7XG4gICAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICAgIE5vZGVMaXN0OiB0cnVlXG4gIH07XG5cbiAgdmFyIGZvckVhY2gkMiA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBvd24gPSBpdC5mb3JFYWNoO1xuICAgIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkNyB8fCBpc1Byb3RvdHlwZU9mJDkoQXJyYXlQcm90b3R5cGUkNywgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkNy5mb3JFYWNoIHx8IGhhc093biQ0KERPTUl0ZXJhYmxlcyQzLCBjbGFzc29mJDUoaXQpKSA/IG1ldGhvZCQ3IDogb3duO1xuICB9O1xuXG4gIHZhciBmb3JFYWNoJDEgPSBmb3JFYWNoJDI7XG5cbiAgdmFyICQkaiA9IF9leHBvcnQ7XG4gIHZhciB1bmN1cnJ5VGhpcyQ5ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbiAgdmFyIGlzQXJyYXkgPSBpc0FycmF5JGQ7XG4gIHZhciB1biRSZXZlcnNlID0gdW5jdXJyeVRoaXMkOShbXS5yZXZlcnNlKTtcbiAgdmFyIHRlc3QkMSA9IFsxLCAyXTsgLy8gYEFycmF5LnByb3RvdHlwZS5yZXZlcnNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmV2ZXJzZVxuICAvLyBmaXggZm9yIFNhZmFyaSAxMi4wIGJ1Z1xuICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg4Nzk0XG5cbiAgJCRqKHtcbiAgICB0YXJnZXQ6ICdBcnJheScsXG4gICAgcHJvdG86IHRydWUsXG4gICAgZm9yY2VkOiBTdHJpbmcodGVzdCQxKSA9PT0gU3RyaW5nKHRlc3QkMS5yZXZlcnNlKCkpXG4gIH0sIHtcbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduIC0tIGRpcnR5IGhhY2tcbiAgICAgIGlmIChpc0FycmF5KHRoaXMpKSB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHVuJFJldmVyc2UodGhpcyk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZW50cnlWaXJ0dWFsJGIgPSBlbnRyeVZpcnR1YWwkaztcbiAgdmFyIHJldmVyc2UkMyA9IGVudHJ5VmlydHVhbCRiKCdBcnJheScpLnJldmVyc2U7XG5cbiAgdmFyIGlzUHJvdG90eXBlT2YkOCA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG4gIHZhciBtZXRob2QkNiA9IHJldmVyc2UkMztcbiAgdmFyIEFycmF5UHJvdG90eXBlJDYgPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgdmFyIHJldmVyc2UkMiA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBvd24gPSBpdC5yZXZlcnNlO1xuICAgIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkNiB8fCBpc1Byb3RvdHlwZU9mJDgoQXJyYXlQcm90b3R5cGUkNiwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkNi5yZXZlcnNlID8gbWV0aG9kJDYgOiBvd247XG4gIH07XG5cbiAgdmFyIHBhcmVudCRuID0gcmV2ZXJzZSQyO1xuICB2YXIgcmV2ZXJzZSQxID0gcGFyZW50JG47XG5cbiAgdmFyIHJldmVyc2UgPSByZXZlcnNlJDE7XG5cbiAgdmFyICQkaSA9IF9leHBvcnQ7XG4gIHZhciBnbG9iYWwkYSA9IGdsb2JhbCRNO1xuICB2YXIgdG9BYnNvbHV0ZUluZGV4JDEgPSB0b0Fic29sdXRlSW5kZXgkNTtcbiAgdmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSB0b0ludGVnZXJPckluZmluaXR5JDQ7XG4gIHZhciBsZW5ndGhPZkFycmF5TGlrZSQzID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbiAgdmFyIHRvT2JqZWN0JDQgPSB0b09iamVjdCRlO1xuICB2YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDQ7XG4gIHZhciBjcmVhdGVQcm9wZXJ0eSA9IGNyZWF0ZVByb3BlcnR5JDY7XG4gIHZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ1O1xuICB2YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ3NwbGljZScpO1xuICB2YXIgVHlwZUVycm9yJDYgPSBnbG9iYWwkYS5UeXBlRXJyb3I7XG4gIHZhciBtYXggPSBNYXRoLm1heDtcbiAgdmFyIG1pbiA9IE1hdGgubWluO1xuICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MUZGRkZGRkZGRkZGRkY7XG4gIHZhciBNQVhJTVVNX0FMTE9XRURfTEVOR1RIX0VYQ0VFREVEID0gJ01heGltdW0gYWxsb3dlZCBsZW5ndGggZXhjZWVkZWQnOyAvLyBgQXJyYXkucHJvdG90eXBlLnNwbGljZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNwbGljZVxuICAvLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xuXG4gICQkaSh7XG4gICAgdGFyZ2V0OiAnQXJyYXknLFxuICAgIHByb3RvOiB0cnVlLFxuICAgIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlRcbiAgfSwge1xuICAgIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudFxuICAgIC8qICwgLi4uaXRlbXMgKi9cbiAgICApIHtcbiAgICAgIHZhciBPID0gdG9PYmplY3QkNCh0aGlzKTtcbiAgICAgIHZhciBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZSQzKE8pO1xuICAgICAgdmFyIGFjdHVhbFN0YXJ0ID0gdG9BYnNvbHV0ZUluZGV4JDEoc3RhcnQsIGxlbik7XG4gICAgICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBpbnNlcnRDb3VudCwgYWN0dWFsRGVsZXRlQ291bnQsIEEsIGssIGZyb20sIHRvO1xuXG4gICAgICBpZiAoYXJndW1lbnRzTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluc2VydENvdW50ID0gYWN0dWFsRGVsZXRlQ291bnQgPSAwO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgaW5zZXJ0Q291bnQgPSAwO1xuICAgICAgICBhY3R1YWxEZWxldGVDb3VudCA9IGxlbiAtIGFjdHVhbFN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zZXJ0Q291bnQgPSBhcmd1bWVudHNMZW5ndGggLSAyO1xuICAgICAgICBhY3R1YWxEZWxldGVDb3VudCA9IG1pbihtYXgodG9JbnRlZ2VyT3JJbmZpbml0eShkZWxldGVDb3VudCksIDApLCBsZW4gLSBhY3R1YWxTdGFydCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZW4gKyBpbnNlcnRDb3VudCAtIGFjdHVhbERlbGV0ZUNvdW50ID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IkNihNQVhJTVVNX0FMTE9XRURfTEVOR1RIX0VYQ0VFREVEKTtcbiAgICAgIH1cblxuICAgICAgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCBhY3R1YWxEZWxldGVDb3VudCk7XG5cbiAgICAgIGZvciAoayA9IDA7IGsgPCBhY3R1YWxEZWxldGVDb3VudDsgaysrKSB7XG4gICAgICAgIGZyb20gPSBhY3R1YWxTdGFydCArIGs7XG4gICAgICAgIGlmIChmcm9tIGluIE8pIGNyZWF0ZVByb3BlcnR5KEEsIGssIE9bZnJvbV0pO1xuICAgICAgfVxuXG4gICAgICBBLmxlbmd0aCA9IGFjdHVhbERlbGV0ZUNvdW50O1xuXG4gICAgICBpZiAoaW5zZXJ0Q291bnQgPCBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgICBmb3IgKGsgPSBhY3R1YWxTdGFydDsgayA8IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50OyBrKyspIHtcbiAgICAgICAgICBmcm9tID0gayArIGFjdHVhbERlbGV0ZUNvdW50O1xuICAgICAgICAgIHRvID0gayArIGluc2VydENvdW50O1xuICAgICAgICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoayA9IGxlbjsgayA+IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaW5zZXJ0Q291bnQ7IGstLSkgZGVsZXRlIE9bayAtIDFdO1xuICAgICAgfSBlbHNlIGlmIChpbnNlcnRDb3VudCA+IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICAgIGZvciAoayA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50OyBrID4gYWN0dWFsU3RhcnQ7IGstLSkge1xuICAgICAgICAgIGZyb20gPSBrICsgYWN0dWFsRGVsZXRlQ291bnQgLSAxO1xuICAgICAgICAgIHRvID0gayArIGluc2VydENvdW50IC0gMTtcbiAgICAgICAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07ZWxzZSBkZWxldGUgT1t0b107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChrID0gMDsgayA8IGluc2VydENvdW50OyBrKyspIHtcbiAgICAgICAgT1trICsgYWN0dWFsU3RhcnRdID0gYXJndW1lbnRzW2sgKyAyXTtcbiAgICAgIH1cblxuICAgICAgTy5sZW5ndGggPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGluc2VydENvdW50O1xuICAgICAgcmV0dXJuIEE7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZW50cnlWaXJ0dWFsJGEgPSBlbnRyeVZpcnR1YWwkaztcbiAgdmFyIHNwbGljZSQzID0gZW50cnlWaXJ0dWFsJGEoJ0FycmF5Jykuc3BsaWNlO1xuXG4gIHZhciBpc1Byb3RvdHlwZU9mJDcgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuICB2YXIgbWV0aG9kJDUgPSBzcGxpY2UkMztcbiAgdmFyIEFycmF5UHJvdG90eXBlJDUgPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgdmFyIHNwbGljZSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIG93biA9IGl0LnNwbGljZTtcbiAgICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDUgfHwgaXNQcm90b3R5cGVPZiQ3KEFycmF5UHJvdG90eXBlJDUsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDUuc3BsaWNlID8gbWV0aG9kJDUgOiBvd247XG4gIH07XG5cbiAgdmFyIHBhcmVudCRtID0gc3BsaWNlJDI7XG4gIHZhciBzcGxpY2UkMSA9IHBhcmVudCRtO1xuXG4gIHZhciBzcGxpY2UgPSBzcGxpY2UkMTtcblxuICB2YXIgREVTQ1JJUFRPUlMkNSA9IGRlc2NyaXB0b3JzO1xuICB2YXIgdW5jdXJyeVRoaXMkOCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBjYWxsJDEgPSBmdW5jdGlvbkNhbGw7XG4gIHZhciBmYWlscyRhID0gZmFpbHMkcjtcbiAgdmFyIG9iamVjdEtleXMkMSA9IG9iamVjdEtleXMkNDtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHZhciB0b09iamVjdCQzID0gdG9PYmplY3QkZTtcbiAgdmFyIEluZGV4ZWRPYmplY3QgPSBpbmRleGVkT2JqZWN0OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWFzc2lnbiAtLSBzYWZlXG5cbiAgdmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cbiAgdmFyIGRlZmluZVByb3BlcnR5JDMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIHZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyQ4KFtdLmNvbmNhdCk7IC8vIGBPYmplY3QuYXNzaWduYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG5cbiAgdmFyIG9iamVjdEFzc2lnbiA9ICEkYXNzaWduIHx8IGZhaWxzJGEoZnVuY3Rpb24gKCkge1xuICAgIC8vIHNob3VsZCBoYXZlIGNvcnJlY3Qgb3JkZXIgb2Ygb3BlcmF0aW9ucyAoRWRnZSBidWcpXG4gICAgaWYgKERFU0NSSVBUT1JTJDUgJiYgJGFzc2lnbih7XG4gICAgICBiOiAxXG4gICAgfSwgJGFzc2lnbihkZWZpbmVQcm9wZXJ0eSQzKHt9LCAnYScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkkMyh0aGlzLCAnYicsIHtcbiAgICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSwge1xuICAgICAgYjogMlxuICAgIH0pKS5iICE9PSAxKSByZXR1cm4gdHJ1ZTsgLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5cbiAgICB2YXIgQSA9IHt9O1xuICAgIHZhciBCID0ge307IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1zeW1ib2wgLS0gc2FmZVxuXG4gICAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICAgIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gICAgQVtzeW1ib2xdID0gNztcbiAgICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7XG4gICAgICBCW2Nocl0gPSBjaHI7XG4gICAgfSk7XG4gICAgcmV0dXJuICRhc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzJDEoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IGFscGhhYmV0O1xuICB9KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICAgIHZhciBUID0gdG9PYmplY3QkMyh0YXJnZXQpO1xuICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IDE7XG4gICAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICAgIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG5cbiAgICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhciBTID0gSW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQob2JqZWN0S2V5cyQxKFMpLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUykpIDogb2JqZWN0S2V5cyQxKFMpO1xuICAgICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgdmFyIGogPSAwO1xuICAgICAgdmFyIGtleTtcblxuICAgICAgd2hpbGUgKGxlbmd0aCA+IGopIHtcbiAgICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgICBpZiAoIURFU0NSSVBUT1JTJDUgfHwgY2FsbCQxKHByb3BlcnR5SXNFbnVtZXJhYmxlLCBTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFQ7XG4gIH0gOiAkYXNzaWduO1xuXG4gIHZhciAkJGggPSBfZXhwb3J0O1xuICB2YXIgYXNzaWduJDUgPSBvYmplY3RBc3NpZ247IC8vIGBPYmplY3QuYXNzaWduYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtYXNzaWduIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cbiAgJCRoKHtcbiAgICB0YXJnZXQ6ICdPYmplY3QnLFxuICAgIHN0YXQ6IHRydWUsXG4gICAgZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ24kNVxuICB9LCB7XG4gICAgYXNzaWduOiBhc3NpZ24kNVxuICB9KTtcblxuICB2YXIgcGF0aCRhID0gcGF0aCRxO1xuICB2YXIgYXNzaWduJDQgPSBwYXRoJGEuT2JqZWN0LmFzc2lnbjtcblxuICB2YXIgcGFyZW50JGwgPSBhc3NpZ24kNDtcbiAgdmFyIGFzc2lnbiQzID0gcGFyZW50JGw7XG5cbiAgdmFyIGFzc2lnbiQyID0gYXNzaWduJDM7XG5cbiAgdmFyICQkZyA9IF9leHBvcnQ7XG4gIHZhciAkaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLmluY2x1ZGVzO1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuXG4gICQkZyh7XG4gICAgdGFyZ2V0OiAnQXJyYXknLFxuICAgIHByb3RvOiB0cnVlXG4gIH0sIHtcbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWxcbiAgICAvKiAsIGZyb21JbmRleCA9IDAgKi9cbiAgICApIHtcbiAgICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gIH0pOyAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5cbiAgdmFyIGVudHJ5VmlydHVhbCQ5ID0gZW50cnlWaXJ0dWFsJGs7XG4gIGVudHJ5VmlydHVhbCQ5KCdBcnJheScpLmluY2x1ZGVzO1xuXG4gIHZhciBpc09iamVjdCQ0ID0gaXNPYmplY3QkZjtcbiAgdmFyIGNsYXNzb2YkNCA9IGNsYXNzb2ZSYXckMTtcbiAgdmFyIHdlbGxLbm93blN5bWJvbCQyID0gd2VsbEtub3duU3ltYm9sJGo7XG4gIHZhciBNQVRDSCQxID0gd2VsbEtub3duU3ltYm9sJDIoJ21hdGNoJyk7IC8vIGBJc1JlZ0V4cGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNyZWdleHBcblxuICB2YXIgaXNSZWdleHAgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgaXNSZWdFeHA7XG4gICAgcmV0dXJuIGlzT2JqZWN0JDQoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSCQxXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjbGFzc29mJDQoaXQpID09ICdSZWdFeHAnKTtcbiAgfTtcblxuICB2YXIgZ2xvYmFsJDkgPSBnbG9iYWwkTTtcbiAgdmFyIGlzUmVnRXhwID0gaXNSZWdleHA7XG4gIHZhciBUeXBlRXJyb3IkNSA9IGdsb2JhbCQ5LlR5cGVFcnJvcjtcblxuICB2YXIgbm90QVJlZ2V4cCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIGlmIChpc1JlZ0V4cChpdCkpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvciQ1KFwiVGhlIG1ldGhvZCBkb2Vzbid0IGFjY2VwdCByZWd1bGFyIGV4cHJlc3Npb25zXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBpdDtcbiAgfTtcblxuICB2YXIgd2VsbEtub3duU3ltYm9sJDEgPSB3ZWxsS25vd25TeW1ib2wkajtcbiAgdmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sJDEoJ21hdGNoJyk7XG5cbiAgdmFyIGNvcnJlY3RJc1JlZ2V4cExvZ2ljID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gICAgdmFyIHJlZ2V4cCA9IC8uLztcblxuICAgIHRyeSB7XG4gICAgICAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlZ2V4cFtNQVRDSF0gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuICcvLi8nW01FVEhPRF9OQU1FXShyZWdleHApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgIC8qIGVtcHR5ICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHZhciAkJGYgPSBfZXhwb3J0O1xuICB2YXIgdW5jdXJyeVRoaXMkNyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciBub3RBUmVnRXhwID0gbm90QVJlZ2V4cDtcbiAgdmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcbiAgdmFyIHRvU3RyaW5nJDMgPSB0b1N0cmluZyQ3O1xuICB2YXIgY29ycmVjdElzUmVnRXhwTG9naWMgPSBjb3JyZWN0SXNSZWdleHBMb2dpYztcbiAgdmFyIHN0cmluZ0luZGV4T2YgPSB1bmN1cnJ5VGhpcyQ3KCcnLmluZGV4T2YpOyAvLyBgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc1xuXG4gICQkZih7XG4gICAgdGFyZ2V0OiAnU3RyaW5nJyxcbiAgICBwcm90bzogdHJ1ZSxcbiAgICBmb3JjZWQ6ICFjb3JyZWN0SXNSZWdFeHBMb2dpYygnaW5jbHVkZXMnKVxuICB9LCB7XG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZ1xuICAgIC8qICwgcG9zaXRpb24gPSAwICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gISF+c3RyaW5nSW5kZXhPZih0b1N0cmluZyQzKHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSh0aGlzKSksIHRvU3RyaW5nJDMobm90QVJlZ0V4cChzZWFyY2hTdHJpbmcpKSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGVudHJ5VmlydHVhbCQ4ID0gZW50cnlWaXJ0dWFsJGs7XG4gIGVudHJ5VmlydHVhbCQ4KCdTdHJpbmcnKS5pbmNsdWRlcztcblxuICB2YXIgJCRlID0gX2V4cG9ydDtcbiAgdmFyIGZhaWxzJDkgPSBmYWlscyRyO1xuICB2YXIgdG9PYmplY3QkMiA9IHRvT2JqZWN0JGU7XG4gIHZhciBuYXRpdmVHZXRQcm90b3R5cGVPZiA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xuICB2YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gY29ycmVjdFByb3RvdHlwZUdldHRlcjtcbiAgdmFyIEZBSUxTX09OX1BSSU1JVElWRVMkMSA9IGZhaWxzJDkoZnVuY3Rpb24gKCkge1xuICAgIG5hdGl2ZUdldFByb3RvdHlwZU9mKDEpO1xuICB9KTsgLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG5cbiAgJCRlKHtcbiAgICB0YXJnZXQ6ICdPYmplY3QnLFxuICAgIHN0YXQ6IHRydWUsXG4gICAgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTJDEsXG4gICAgc2hhbTogIUNPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUlxuICB9LCB7XG4gICAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgICByZXR1cm4gbmF0aXZlR2V0UHJvdG90eXBlT2YodG9PYmplY3QkMihpdCkpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHBhdGgkOSA9IHBhdGgkcTtcbiAgdmFyIGdldFByb3RvdHlwZU9mJDQgPSBwYXRoJDkuT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG4gIHZhciBwYXJlbnQkayA9IGdldFByb3RvdHlwZU9mJDQ7XG4gIHZhciBnZXRQcm90b3R5cGVPZiQzID0gcGFyZW50JGs7XG5cbiAgdmFyIERFU0NSSVBUT1JTJDQgPSBkZXNjcmlwdG9ycztcbiAgdmFyIHVuY3VycnlUaGlzJDYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgb2JqZWN0S2V5cyA9IG9iamVjdEtleXMkNDtcbiAgdmFyIHRvSW5kZXhlZE9iamVjdCA9IHRvSW5kZXhlZE9iamVjdCRiO1xuICB2YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZjtcbiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gdW5jdXJyeVRoaXMkNigkcHJvcGVydHlJc0VudW1lcmFibGUpO1xuICB2YXIgcHVzaCQyID0gdW5jdXJyeVRoaXMkNihbXS5wdXNoKTsgLy8gYE9iamVjdC57IGVudHJpZXMsIHZhbHVlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cbiAgdmFyIGNyZWF0ZU1ldGhvZCQxID0gZnVuY3Rpb24gKFRPX0VOVFJJRVMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChpdCk7XG4gICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoTyk7XG4gICAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIga2V5O1xuXG4gICAgICB3aGlsZSAobGVuZ3RoID4gaSkge1xuICAgICAgICBrZXkgPSBrZXlzW2krK107XG5cbiAgICAgICAgaWYgKCFERVNDUklQVE9SUyQ0IHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlKE8sIGtleSkpIHtcbiAgICAgICAgICBwdXNoJDIocmVzdWx0LCBUT19FTlRSSUVTID8gW2tleSwgT1trZXldXSA6IE9ba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBvYmplY3RUb0FycmF5ID0ge1xuICAgIC8vIGBPYmplY3QuZW50cmllc2AgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZW50cmllc1xuICAgIGVudHJpZXM6IGNyZWF0ZU1ldGhvZCQxKHRydWUpLFxuICAgIC8vIGBPYmplY3QudmFsdWVzYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC52YWx1ZXNcbiAgICB2YWx1ZXM6IGNyZWF0ZU1ldGhvZCQxKGZhbHNlKVxuICB9O1xuXG4gIHZhciAkJGQgPSBfZXhwb3J0O1xuICB2YXIgJHZhbHVlcyA9IG9iamVjdFRvQXJyYXkudmFsdWVzOyAvLyBgT2JqZWN0LnZhbHVlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnZhbHVlc1xuXG4gICQkZCh7XG4gICAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgICBzdGF0OiB0cnVlXG4gIH0sIHtcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhPKSB7XG4gICAgICByZXR1cm4gJHZhbHVlcyhPKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwYXRoJDggPSBwYXRoJHE7XG4gIHBhdGgkOC5PYmplY3QudmFsdWVzO1xuXG4gIHZhciB3aGl0ZXNwYWNlcyQzID0gJ1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MjAwMFxcdTIwMDFcXHUyMDAyJyArICdcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG5cbiAgdmFyIHVuY3VycnlUaGlzJDUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcbiAgdmFyIHRvU3RyaW5nJDIgPSB0b1N0cmluZyQ3O1xuICB2YXIgd2hpdGVzcGFjZXMkMiA9IHdoaXRlc3BhY2VzJDM7XG4gIHZhciByZXBsYWNlJDEgPSB1bmN1cnJ5VGhpcyQ1KCcnLnJlcGxhY2UpO1xuICB2YXIgd2hpdGVzcGFjZSA9ICdbJyArIHdoaXRlc3BhY2VzJDIgKyAnXSc7XG4gIHZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyB3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJyk7XG4gIHZhciBydHJpbSA9IFJlZ0V4cCh3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJCcpOyAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW0sIHRyaW1TdGFydCwgdHJpbUVuZCwgdHJpbUxlZnQsIHRyaW1SaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cbiAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcykge1xuICAgICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nJDIocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgICAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSByZXBsYWNlJDEoc3RyaW5nLCBsdHJpbSwgJycpO1xuICAgICAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSByZXBsYWNlJDEoc3RyaW5nLCBydHJpbSwgJycpO1xuICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9O1xuICB9O1xuXG4gIHZhciBzdHJpbmdUcmltID0ge1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbUxlZnQsIHRyaW1TdGFydCB9YCBtZXRob2RzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1zdGFydFxuICAgIHN0YXJ0OiBjcmVhdGVNZXRob2QoMSksXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltUmlnaHQsIHRyaW1FbmQgfWAgbWV0aG9kc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltZW5kXG4gICAgZW5kOiBjcmVhdGVNZXRob2QoMiksXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiAgICB0cmltOiBjcmVhdGVNZXRob2QoMylcbiAgfTtcblxuICB2YXIgZ2xvYmFsJDggPSBnbG9iYWwkTTtcbiAgdmFyIGZhaWxzJDggPSBmYWlscyRyO1xuICB2YXIgdW5jdXJyeVRoaXMkNCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciB0b1N0cmluZyQxID0gdG9TdHJpbmckNztcbiAgdmFyIHRyaW0gPSBzdHJpbmdUcmltLnRyaW07XG4gIHZhciB3aGl0ZXNwYWNlcyQxID0gd2hpdGVzcGFjZXMkMztcbiAgdmFyICRwYXJzZUludCQxID0gZ2xvYmFsJDgucGFyc2VJbnQ7XG4gIHZhciBTeW1ib2wkMSA9IGdsb2JhbCQ4LlN5bWJvbDtcbiAgdmFyIElURVJBVE9SID0gU3ltYm9sJDEgJiYgU3ltYm9sJDEuaXRlcmF0b3I7XG4gIHZhciBoZXggPSAvXlsrLV0/MHgvaTtcbiAgdmFyIGV4ZWMkMSA9IHVuY3VycnlUaGlzJDQoaGV4LmV4ZWMpO1xuICB2YXIgRk9SQ0VEJDMgPSAkcGFyc2VJbnQkMSh3aGl0ZXNwYWNlcyQxICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50JDEod2hpdGVzcGFjZXMkMSArICcweDE2JykgIT09IDIyIC8vIE1TIEVkZ2UgMTgtIGJyb2tlbiB3aXRoIGJveGVkIHN5bWJvbHNcbiAgfHwgSVRFUkFUT1IgJiYgIWZhaWxzJDgoZnVuY3Rpb24gKCkge1xuICAgICRwYXJzZUludCQxKE9iamVjdChJVEVSQVRPUikpO1xuICB9KTsgLy8gYHBhcnNlSW50YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wYXJzZWludC1zdHJpbmctcmFkaXhcblxuICB2YXIgbnVtYmVyUGFyc2VJbnQgPSBGT1JDRUQkMyA/IGZ1bmN0aW9uIHBhcnNlSW50KHN0cmluZywgcmFkaXgpIHtcbiAgICB2YXIgUyA9IHRyaW0odG9TdHJpbmckMShzdHJpbmcpKTtcbiAgICByZXR1cm4gJHBhcnNlSW50JDEoUywgcmFkaXggPj4+IDAgfHwgKGV4ZWMkMShoZXgsIFMpID8gMTYgOiAxMCkpO1xuICB9IDogJHBhcnNlSW50JDE7XG5cbiAgdmFyICQkYyA9IF9leHBvcnQ7XG4gIHZhciAkcGFyc2VJbnQgPSBudW1iZXJQYXJzZUludDsgLy8gYHBhcnNlSW50YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wYXJzZWludC1zdHJpbmctcmFkaXhcblxuICAkJGMoe1xuICAgIGdsb2JhbDogdHJ1ZSxcbiAgICBmb3JjZWQ6IHBhcnNlSW50ICE9ICRwYXJzZUludFxuICB9LCB7XG4gICAgcGFyc2VJbnQ6ICRwYXJzZUludFxuICB9KTtcblxuICB2YXIgcGF0aCQ3ID0gcGF0aCRxO1xuICBwYXRoJDcucGFyc2VJbnQ7XG5cbiAgLyogZXNsaW50LWRpc2FibGUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWluZGV4b2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxuXG4gIHZhciAkJGIgPSBfZXhwb3J0O1xuICB2YXIgdW5jdXJyeVRoaXMkMyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG4gIHZhciAkSW5kZXhPZiA9IGFycmF5SW5jbHVkZXMuaW5kZXhPZjtcbiAgdmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkMiA9IGFycmF5TWV0aG9kSXNTdHJpY3QkNTtcbiAgdmFyIHVuJEluZGV4T2YgPSB1bmN1cnJ5VGhpcyQzKFtdLmluZGV4T2YpO1xuICB2YXIgTkVHQVRJVkVfWkVSTyA9ICEhdW4kSW5kZXhPZiAmJiAxIC8gdW4kSW5kZXhPZihbMV0sIDEsIC0wKSA8IDA7XG4gIHZhciBTVFJJQ1RfTUVUSE9EJDIgPSBhcnJheU1ldGhvZElzU3RyaWN0JDIoJ2luZGV4T2YnKTsgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuXG4gICQkYih7XG4gICAgdGFyZ2V0OiAnQXJyYXknLFxuICAgIHByb3RvOiB0cnVlLFxuICAgIGZvcmNlZDogTkVHQVRJVkVfWkVSTyB8fCAhU1RSSUNUX01FVEhPRCQyXG4gIH0sIHtcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnRcbiAgICAvKiAsIGZyb21JbmRleCA9IDAgKi9cbiAgICApIHtcbiAgICAgIHZhciBmcm9tSW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBORUdBVElWRV9aRVJPIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICAgID8gdW4kSW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHx8IDAgOiAkSW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGVudHJ5VmlydHVhbCQ3ID0gZW50cnlWaXJ0dWFsJGs7XG4gIGVudHJ5VmlydHVhbCQ3KCdBcnJheScpLmluZGV4T2Y7XG5cbiAgdmFyIFBST1BFUl9GVU5DVElPTl9OQU1FID0gZnVuY3Rpb25OYW1lLlBST1BFUjtcbiAgdmFyIGZhaWxzJDcgPSBmYWlscyRyO1xuICB2YXIgd2hpdGVzcGFjZXMgPSB3aGl0ZXNwYWNlcyQzO1xuICB2YXIgbm9uID0gJ1xcdTIwMEJcXHUwMDg1XFx1MTgwRSc7IC8vIGNoZWNrIHRoYXQgYSBtZXRob2Qgd29ya3Mgd2l0aCB0aGUgY29ycmVjdCBsaXN0XG4gIC8vIG9mIHdoaXRlc3BhY2VzIGFuZCBoYXMgYSBjb3JyZWN0IG5hbWVcblxuICB2YXIgc3RyaW5nVHJpbUZvcmNlZCA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICAgIHJldHVybiBmYWlscyQ3KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhIXdoaXRlc3BhY2VzW01FVEhPRF9OQU1FXSgpIHx8IG5vbltNRVRIT0RfTkFNRV0oKSAhPT0gbm9uIHx8IFBST1BFUl9GVU5DVElPTl9OQU1FICYmIHdoaXRlc3BhY2VzW01FVEhPRF9OQU1FXS5uYW1lICE9PSBNRVRIT0RfTkFNRTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgJCRhID0gX2V4cG9ydDtcbiAgdmFyICR0cmltID0gc3RyaW5nVHJpbS50cmltO1xuICB2YXIgZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCA9IHN0cmluZ1RyaW1Gb3JjZWQ7IC8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuXG4gICQkYSh7XG4gICAgdGFyZ2V0OiAnU3RyaW5nJyxcbiAgICBwcm90bzogdHJ1ZSxcbiAgICBmb3JjZWQ6IGZvcmNlZFN0cmluZ1RyaW1NZXRob2QoJ3RyaW0nKVxuICB9LCB7XG4gICAgdHJpbTogZnVuY3Rpb24gdHJpbSgpIHtcbiAgICAgIHJldHVybiAkdHJpbSh0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBlbnRyeVZpcnR1YWwkNiA9IGVudHJ5VmlydHVhbCRrO1xuICBlbnRyeVZpcnR1YWwkNignU3RyaW5nJykudHJpbTtcblxuICB2YXIgJCQ5ID0gX2V4cG9ydDtcbiAgdmFyIERFU0NSSVBUT1JTJDMgPSBkZXNjcmlwdG9ycztcbiAgdmFyIGNyZWF0ZSQ4ID0gb2JqZWN0Q3JlYXRlOyAvLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuXG4gICQkOSh7XG4gICAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgICBzdGF0OiB0cnVlLFxuICAgIHNoYW06ICFERVNDUklQVE9SUyQzXG4gIH0sIHtcbiAgICBjcmVhdGU6IGNyZWF0ZSQ4XG4gIH0pO1xuXG4gIHZhciBwYXRoJDYgPSBwYXRoJHE7XG4gIHZhciBPYmplY3QkMSA9IHBhdGgkNi5PYmplY3Q7XG5cbiAgdmFyIGNyZWF0ZSQ3ID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpIHtcbiAgICByZXR1cm4gT2JqZWN0JDEuY3JlYXRlKFAsIEQpO1xuICB9O1xuXG4gIHZhciBwYXJlbnQkaiA9IGNyZWF0ZSQ3O1xuICB2YXIgY3JlYXRlJDYgPSBwYXJlbnQkajtcblxuICB2YXIgY3JlYXRlJDUgPSBjcmVhdGUkNjtcblxuICB2YXIgJCQ4ID0gX2V4cG9ydDtcbiAgdmFyIGdsb2JhbCQ3ID0gZ2xvYmFsJE07XG4gIHZhciBnZXRCdWlsdEluJDIgPSBnZXRCdWlsdEluJDk7XG4gIHZhciBhcHBseSQzID0gZnVuY3Rpb25BcHBseTtcbiAgdmFyIHVuY3VycnlUaGlzJDIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgZmFpbHMkNiA9IGZhaWxzJHI7XG4gIHZhciBBcnJheSQxID0gZ2xvYmFsJDcuQXJyYXk7XG4gIHZhciAkc3RyaW5naWZ5ID0gZ2V0QnVpbHRJbiQyKCdKU09OJywgJ3N0cmluZ2lmeScpO1xuICB2YXIgZXhlYyA9IHVuY3VycnlUaGlzJDIoLy4vLmV4ZWMpO1xuICB2YXIgY2hhckF0ID0gdW5jdXJyeVRoaXMkMignJy5jaGFyQXQpO1xuICB2YXIgY2hhckNvZGVBdCA9IHVuY3VycnlUaGlzJDIoJycuY2hhckNvZGVBdCk7XG4gIHZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMkMignJy5yZXBsYWNlKTtcbiAgdmFyIG51bWJlclRvU3RyaW5nID0gdW5jdXJyeVRoaXMkMigxLjAudG9TdHJpbmcpO1xuICB2YXIgdGVzdGVyID0gL1tcXHVEODAwLVxcdURGRkZdL2c7XG4gIHZhciBsb3cgPSAvXltcXHVEODAwLVxcdURCRkZdJC87XG4gIHZhciBoaSA9IC9eW1xcdURDMDAtXFx1REZGRl0kLztcblxuICB2YXIgZml4ID0gZnVuY3Rpb24gKG1hdGNoLCBvZmZzZXQsIHN0cmluZykge1xuICAgIHZhciBwcmV2ID0gY2hhckF0KHN0cmluZywgb2Zmc2V0IC0gMSk7XG4gICAgdmFyIG5leHQgPSBjaGFyQXQoc3RyaW5nLCBvZmZzZXQgKyAxKTtcblxuICAgIGlmIChleGVjKGxvdywgbWF0Y2gpICYmICFleGVjKGhpLCBuZXh0KSB8fCBleGVjKGhpLCBtYXRjaCkgJiYgIWV4ZWMobG93LCBwcmV2KSkge1xuICAgICAgcmV0dXJuICdcXFxcdScgKyBudW1iZXJUb1N0cmluZyhjaGFyQ29kZUF0KG1hdGNoLCAwKSwgMTYpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcblxuICB2YXIgRk9SQ0VEJDIgPSBmYWlscyQ2KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJHN0cmluZ2lmeSgnXFx1REYwNlxcdUQ4MzQnKSAhPT0gJ1wiXFxcXHVkZjA2XFxcXHVkODM0XCInIHx8ICRzdHJpbmdpZnkoJ1xcdURFQUQnKSAhPT0gJ1wiXFxcXHVkZWFkXCInO1xuICB9KTtcblxuICBpZiAoJHN0cmluZ2lmeSkge1xuICAgIC8vIGBKU09OLnN0cmluZ2lmeWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1qc29uLnN0cmluZ2lmeVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXdlbGwtZm9ybWVkLXN0cmluZ2lmeVxuICAgICQkOCh7XG4gICAgICB0YXJnZXQ6ICdKU09OJyxcbiAgICAgIHN0YXQ6IHRydWUsXG4gICAgICBmb3JjZWQ6IEZPUkNFRCQyXG4gICAgfSwge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0LCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkkMShsKTsgaSA8IGw7IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gYXBwbHkkMygkc3RyaW5naWZ5LCBudWxsLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT0gJ3N0cmluZycgPyByZXBsYWNlKHJlc3VsdCwgdGVzdGVyLCBmaXgpIDogcmVzdWx0O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHBhdGgkNSA9IHBhdGgkcTtcbiAgdmFyIGFwcGx5JDIgPSBmdW5jdGlvbkFwcGx5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tanNvbiAtLSBzYWZlXG5cbiAgaWYgKCFwYXRoJDUuSlNPTikgcGF0aCQ1LkpTT04gPSB7XG4gICAgc3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeVxuICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuXG4gIHZhciBzdHJpbmdpZnkkMyA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgcmV0dXJuIGFwcGx5JDIocGF0aCQ1LkpTT04uc3RyaW5naWZ5LCBudWxsLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwYXJlbnQkaSA9IHN0cmluZ2lmeSQzO1xuICB2YXIgc3RyaW5naWZ5JDIgPSBwYXJlbnQkaTtcblxuICB2YXIgc3RyaW5naWZ5JDEgPSBzdHJpbmdpZnkkMjtcblxuICB2YXIgZ2xvYmFsJDYgPSBnbG9iYWwkTTtcbiAgdmFyIFR5cGVFcnJvciQ0ID0gZ2xvYmFsJDYuVHlwZUVycm9yO1xuXG4gIHZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxID0gZnVuY3Rpb24gKHBhc3NlZCwgcmVxdWlyZWQpIHtcbiAgICBpZiAocGFzc2VkIDwgcmVxdWlyZWQpIHRocm93IFR5cGVFcnJvciQ0KCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICAgIHJldHVybiBwYXNzZWQ7XG4gIH07XG5cbiAgdmFyICQkNyA9IF9leHBvcnQ7XG4gIHZhciBnbG9iYWwkNSA9IGdsb2JhbCRNO1xuICB2YXIgYXBwbHkkMSA9IGZ1bmN0aW9uQXBwbHk7XG4gIHZhciBpc0NhbGxhYmxlJDEgPSBpc0NhbGxhYmxlJGg7XG4gIHZhciB1c2VyQWdlbnQkMiA9IGVuZ2luZVVzZXJBZ2VudDtcbiAgdmFyIGFycmF5U2xpY2UkMSA9IGFycmF5U2xpY2UkNTtcbiAgdmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMTtcbiAgdmFyIE1TSUUgPSAvTVNJRSAuXFwuLy50ZXN0KHVzZXJBZ2VudCQyKTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xuXG4gIHZhciBGdW5jdGlvbiQxID0gZ2xvYmFsJDUuRnVuY3Rpb247XG5cbiAgdmFyIHdyYXAgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChoYW5kbGVyLCB0aW1lb3V0XG4gICAgLyogLCAuLi5hcmd1bWVudHMgKi9cbiAgICApIHtcbiAgICAgIHZhciBib3VuZEFyZ3MgPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKSA+IDI7XG4gICAgICB2YXIgZm4gPSBpc0NhbGxhYmxlJDEoaGFuZGxlcikgPyBoYW5kbGVyIDogRnVuY3Rpb24kMShoYW5kbGVyKTtcbiAgICAgIHZhciBhcmdzID0gYm91bmRBcmdzID8gYXJyYXlTbGljZSQxKGFyZ3VtZW50cywgMikgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gc2NoZWR1bGVyKGJvdW5kQXJncyA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXBwbHkkMShmbiwgdGhpcywgYXJncyk7XG4gICAgICB9IDogZm4sIHRpbWVvdXQpO1xuICAgIH07XG4gIH07IC8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdGltZXJzLWFuZC11c2VyLXByb21wdHMuaHRtbCN0aW1lcnNcblxuXG4gICQkNyh7XG4gICAgZ2xvYmFsOiB0cnVlLFxuICAgIGJpbmQ6IHRydWUsXG4gICAgZm9yY2VkOiBNU0lFXG4gIH0sIHtcbiAgICAvLyBgc2V0VGltZW91dGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdGltZXJzLWFuZC11c2VyLXByb21wdHMuaHRtbCNkb20tc2V0dGltZW91dFxuICAgIHNldFRpbWVvdXQ6IHdyYXAoZ2xvYmFsJDUuc2V0VGltZW91dCksXG4gICAgLy8gYHNldEludGVydmFsYCBtZXRob2RcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS90aW1lcnMtYW5kLXVzZXItcHJvbXB0cy5odG1sI2RvbS1zZXRpbnRlcnZhbFxuICAgIHNldEludGVydmFsOiB3cmFwKGdsb2JhbCQ1LnNldEludGVydmFsKVxuICB9KTtcblxuICB2YXIgcGF0aCQ0ID0gcGF0aCRxO1xuICB2YXIgc2V0VGltZW91dCQyID0gcGF0aCQ0LnNldFRpbWVvdXQ7XG5cbiAgdmFyIHNldFRpbWVvdXQkMSA9IHNldFRpbWVvdXQkMjtcblxuICB2YXIgdG9PYmplY3QkMSA9IHRvT2JqZWN0JGU7XG4gIHZhciB0b0Fic29sdXRlSW5kZXggPSB0b0Fic29sdXRlSW5kZXgkNTtcbiAgdmFyIGxlbmd0aE9mQXJyYXlMaWtlJDIgPSBsZW5ndGhPZkFycmF5TGlrZSRkOyAvLyBgQXJyYXkucHJvdG90eXBlLmZpbGxgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWxsXG5cbiAgdmFyIGFycmF5RmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsdWVcbiAgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi9cbiAgKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCQxKHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQyKE8pO1xuICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICAgIHZhciBlbmQgPSBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoZW5kUG9zID4gaW5kZXgpIE9baW5kZXgrK10gPSB2YWx1ZTtcblxuICAgIHJldHVybiBPO1xuICB9O1xuXG4gIHZhciAkJDYgPSBfZXhwb3J0O1xuICB2YXIgZmlsbCA9IGFycmF5RmlsbDtcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsbFxuXG4gICQkNih7XG4gICAgdGFyZ2V0OiAnQXJyYXknLFxuICAgIHByb3RvOiB0cnVlXG4gIH0sIHtcbiAgICBmaWxsOiBmaWxsXG4gIH0pOyAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5cbiAgdmFyIGVudHJ5VmlydHVhbCQ1ID0gZW50cnlWaXJ0dWFsJGs7XG4gIGVudHJ5VmlydHVhbCQ1KCdBcnJheScpLmZpbGw7XG5cbiAgdmFyIGNvbXBvbmVudEVtaXR0ZXIgPSB7ZXhwb3J0czoge319O1xuXG4gIChmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgLyoqXHJcbiAgICAgKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gICAgICovXG4gICAge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gICAgICpcclxuICAgICAqIEBhcGkgcHVibGljXHJcbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgICAgIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAgICogQGFwaSBwcml2YXRlXHJcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIG1peGluKG9iaikge1xuICAgICAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICAgICAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAgICAgKiBAYXBpIHB1YmxpY1xyXG4gICAgICovXG5cblxuICAgIEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgICAgICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSkucHVzaChmbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAgICAgKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICAgICAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAgICAgKiBAYXBpIHB1YmxpY1xyXG4gICAgICovXG5cblxuICAgIEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICBmdW5jdGlvbiBvbigpIHtcbiAgICAgICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcbiAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgb24uZm4gPSBmbjtcbiAgICAgIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gICAgICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gICAgICogQHJldHVybiB7RW1pdHRlcn1cclxuICAgICAqIEBhcGkgcHVibGljXHJcbiAgICAgKi9cblxuXG4gICAgRW1pdHRlci5wcm90b3R5cGUub2ZmID0gRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9OyAvLyBhbGxcblxuICAgICAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IC8vIHNwZWNpZmljIGV2ZW50XG5cblxuICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7IC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcblxuICAgICAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG5cblxuICAgICAgdmFyIGNiO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYiA9IGNhbGxiYWNrc1tpXTtcblxuICAgICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmVtb3ZlIGV2ZW50IHNwZWNpZmljIGFycmF5cyBmb3IgZXZlbnQgdHlwZXMgdGhhdCBub1xuICAgICAgLy8gb25lIGlzIHN1YnNjcmliZWQgZm9yIHRvIGF2b2lkIG1lbW9yeSBsZWFrLlxuXG5cbiAgICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICAgICAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAgICAgKi9cblxuXG4gICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxuICAgICAgICAgIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICAgKiBAYXBpIHB1YmxpY1xyXG4gICAgICovXG5cblxuICAgIEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKiBAYXBpIHB1YmxpY1xyXG4gICAgICovXG5cblxuICAgIEVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbiAgICB9O1xuICB9KShjb21wb25lbnRFbWl0dGVyKTtcblxuICB2YXIgRW1pdHRlciA9IGNvbXBvbmVudEVtaXR0ZXIuZXhwb3J0cztcblxuICAvKiEgSGFtbWVyLkpTIC0gdjIuMC4xNy1yYyAtIDIwMTktMTItMTZcbiAgICogaHR0cDovL25hdmVyLmdpdGh1Yi5pby9lZ2pzXG4gICAqXG4gICAqIEZvcmtlZCBCeSBOYXZlciBlZ2pzXG4gICAqIENvcHlyaWdodCAoYykgaGFtbWVyanNcbiAgICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlICovXG4gIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICAgIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICAgIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG4gIH1cblxuICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkJDEoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZXh0ZW5kIG9iamVjdC5cbiAgICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHNfdG9fYXNzaWduXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICAgKi9cblxuXG4gIHZhciBhc3NpZ247XG5cbiAgaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcblxuICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbiAgfVxuXG4gIHZhciBhc3NpZ24kMSA9IGFzc2lnbjtcbiAgdmFyIFZFTkRPUl9QUkVGSVhFUyA9IFsnJywgJ3dlYmtpdCcsICdNb3onLCAnTVMnLCAnbXMnLCAnbyddO1xuICB2YXIgVEVTVF9FTEVNRU5UID0gdHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiID8ge1xuICAgIHN0eWxlOiB7fVxuICB9IDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICAgIGFicyA9IE1hdGguYWJzO1xuICB2YXIgbm93ID0gRGF0ZS5ub3c7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBnZXQgdGhlIHByZWZpeGVkIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEByZXR1cm5zIHtTdHJpbmd8VW5kZWZpbmVkfSBwcmVmaXhlZFxuICAgKi9cblxuICBmdW5jdGlvbiBwcmVmaXhlZChvYmosIHByb3BlcnR5KSB7XG4gICAgdmFyIHByZWZpeDtcbiAgICB2YXIgcHJvcDtcbiAgICB2YXIgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgICAgcHJlZml4ID0gVkVORE9SX1BSRUZJWEVTW2ldO1xuICAgICAgcHJvcCA9IHByZWZpeCA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xuXG4gICAgICBpZiAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jLCBuby1uZXN0ZWQtdGVybmFyeSAqL1xuXG5cbiAgdmFyIHdpbjtcblxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIHdpbmRvdyBpcyB1bmRlZmluZWQgaW4gbm9kZS5qc1xuICAgIHdpbiA9IHt9O1xuICB9IGVsc2Uge1xuICAgIHdpbiA9IHdpbmRvdztcbiAgfVxuXG4gIHZhciBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gPSBwcmVmaXhlZChURVNUX0VMRU1FTlQuc3R5bGUsICd0b3VjaEFjdGlvbicpO1xuICB2YXIgTkFUSVZFX1RPVUNIX0FDVElPTiA9IFBSRUZJWEVEX1RPVUNIX0FDVElPTiAhPT0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uUHJvcHMoKSB7XG4gICAgaWYgKCFOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHRvdWNoTWFwID0ge307XG4gICAgdmFyIGNzc1N1cHBvcnRzID0gd2luLkNTUyAmJiB3aW4uQ1NTLnN1cHBvcnRzO1xuICAgIFsnYXV0bycsICdtYW5pcHVsYXRpb24nLCAncGFuLXknLCAncGFuLXgnLCAncGFuLXggcGFuLXknLCAnbm9uZSddLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuICAgICAgLy8gSWYgY3NzLnN1cHBvcnRzIGlzIG5vdCBzdXBwb3J0ZWQgYnV0IHRoZXJlIGlzIG5hdGl2ZSB0b3VjaC1hY3Rpb24gYXNzdW1lIGl0IHN1cHBvcnRzXG4gICAgICAvLyBhbGwgdmFsdWVzLiBUaGlzIGlzIHRoZSBjYXNlIGZvciBJRSAxMCBhbmQgMTEuXG4gICAgICByZXR1cm4gdG91Y2hNYXBbdmFsXSA9IGNzc1N1cHBvcnRzID8gd2luLkNTUy5zdXBwb3J0cygndG91Y2gtYWN0aW9uJywgdmFsKSA6IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvdWNoTWFwO1xuICB9XG5cbiAgdmFyIFRPVUNIX0FDVElPTl9DT01QVVRFID0gJ2NvbXB1dGUnO1xuICB2YXIgVE9VQ0hfQUNUSU9OX0FVVE8gPSAnYXV0byc7XG4gIHZhciBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OID0gJ21hbmlwdWxhdGlvbic7IC8vIG5vdCBpbXBsZW1lbnRlZFxuXG4gIHZhciBUT1VDSF9BQ1RJT05fTk9ORSA9ICdub25lJztcbiAgdmFyIFRPVUNIX0FDVElPTl9QQU5fWCA9ICdwYW4teCc7XG4gIHZhciBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xuICB2YXIgVE9VQ0hfQUNUSU9OX01BUCA9IGdldFRvdWNoQWN0aW9uUHJvcHMoKTtcbiAgdmFyIE1PQklMRV9SRUdFWCA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWQvaTtcbiAgdmFyIFNVUFBPUlRfVE9VQ0ggPSAoJ29udG91Y2hzdGFydCcgaW4gd2luKTtcbiAgdmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW4sICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xuICB2YXIgSU5QVVRfVFlQRV9QRU4gPSAncGVuJztcbiAgdmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xuICB2YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcbiAgdmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcbiAgdmFyIElOUFVUX1NUQVJUID0gMTtcbiAgdmFyIElOUFVUX01PVkUgPSAyO1xuICB2YXIgSU5QVVRfRU5EID0gNDtcbiAgdmFyIElOUFVUX0NBTkNFTCA9IDg7XG4gIHZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG4gIHZhciBESVJFQ1RJT05fTEVGVCA9IDI7XG4gIHZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xuICB2YXIgRElSRUNUSU9OX1VQID0gODtcbiAgdmFyIERJUkVDVElPTl9ET1dOID0gMTY7XG4gIHZhciBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9MRUZUIHwgRElSRUNUSU9OX1JJR0hUO1xuICB2YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG4gIHZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG4gIHZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG4gIHZhciBQUk9QU19DTElFTlRfWFkgPSBbJ2NsaWVudFgnLCAnY2xpZW50WSddO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKi9cblxuICBmdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoaSkgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICAgKiB0aGlzIGZpcnN0IGl0ZW0gaW4gYXJncyB3aWxsIGJlIHVzZWQgYXMgdGhlIGNvbnRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAgICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgdmFsID09PSBUWVBFX0ZVTkNUSU9OKSB7XG4gICAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc21hbGwgaW5kZXhPZiB3cmFwcGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGZvdW5kXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5TdHIoc3RyLCBmaW5kKSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uc1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG5cblxuICBmdW5jdGlvbiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zKSB7XG4gICAgLy8gbm9uZVxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcbiAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpOyAvLyBpZiBib3RoIHBhbi14IGFuZCBwYW4teSBhcmUgc2V0IChkaWZmZXJlbnQgcmVjb2duaXplcnNcbiAgICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgICAvLyB3ZSBuZWVkIG5vbmUgKGFzIG90aGVyd2lzZSB3aXRoIHBhbi14IHBhbi15IGNvbWJpbmVkIG5vbmUgb2YgdGhlc2VcbiAgICAvLyByZWNvZ25pemVycyB3aWxsIHdvcmssIHNpbmNlIHRoZSBicm93c2VyIHdvdWxkIGhhbmRsZSBhbGwgcGFubmluZ1xuXG4gICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH0gLy8gcGFuLXggT1IgcGFuLXlcblxuXG4gICAgaWYgKGhhc1BhblggfHwgaGFzUGFuWSkge1xuICAgICAgcmV0dXJuIGhhc1BhblggPyBUT1VDSF9BQ1RJT05fUEFOX1ggOiBUT1VDSF9BQ1RJT05fUEFOX1k7XG4gICAgfSAvLyBtYW5pcHVsYXRpb25cblxuXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04pKSB7XG4gICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTjtcbiAgICB9XG5cbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFRvdWNoIEFjdGlvblxuICAgKiBzZXRzIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBvciB1c2VzIHRoZSBqcyBhbHRlcm5hdGl2ZVxuICAgKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cblxuXG4gIHZhciBUb3VjaEFjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG91Y2hBY3Rpb24obWFuYWdlciwgdmFsdWUpIHtcbiAgICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgICB0aGlzLnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZSBvbiB0aGUgZWxlbWVudCBvciBlbmFibGUgdGhlIHBvbHlmaWxsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG5cblxuICAgIHZhciBfcHJvdG8gPSBUb3VjaEFjdGlvbi5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAvLyBmaW5kIG91dCB0aGUgdG91Y2gtYWN0aW9uIGJ5IHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAgaWYgKHZhbHVlID09PSBUT1VDSF9BQ1RJT05fQ09NUFVURSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTiAmJiB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZSAmJiBUT1VDSF9BQ1RJT05fTUFQW3ZhbHVlXSkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWN0aW9ucyA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuc2V0KHRoaXMubWFuYWdlci5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLmNvbXB1dGUgPSBmdW5jdGlvbiBjb21wdXRlKCkge1xuICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgIGVhY2godGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLCBmdW5jdGlvbiAocmVjb2duaXplcikge1xuICAgICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xuICAgICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLmNvbmNhdChyZWNvZ25pemVyLmdldFRvdWNoQWN0aW9uKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuXG5cbiAgICBfcHJvdG8ucHJldmVudERlZmF1bHRzID0gZnVuY3Rpb24gcHJldmVudERlZmF1bHRzKGlucHV0KSB7XG4gICAgICB2YXIgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247IC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuXG4gICAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICB2YXIgaGFzTm9uZSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1hdO1xuXG4gICAgICBpZiAoaGFzTm9uZSkge1xuICAgICAgICAvLyBkbyBub3QgcHJldmVudCBkZWZhdWx0cyBpZiB0aGlzIGlzIGEgdGFwIGdlc3R1cmVcbiAgICAgICAgdmFyIGlzVGFwUG9pbnRlciA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgdmFyIGlzVGFwTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IDI7XG4gICAgICAgIHZhciBpc1RhcFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IDI1MDtcblxuICAgICAgICBpZiAoaXNUYXBQb2ludGVyICYmIGlzVGFwTW92ZW1lbnQgJiYgaXNUYXBUb3VjaFRpbWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICAvLyBgcGFuLXggcGFuLXlgIG1lYW5zIGJyb3dzZXIgaGFuZGxlcyBhbGwgc2Nyb2xsaW5nL3Bhbm5pbmcsIGRvIG5vdCBwcmV2ZW50XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc05vbmUgfHwgaGFzUGFuWSAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8fCBoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50U3JjKHNyY0V2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XG4gICAgICovXG5cblxuICAgIF9wcm90by5wcmV2ZW50U3JjID0gZnVuY3Rpb24gcHJldmVudFNyYyhzcmNFdmVudCkge1xuICAgICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcbiAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUb3VjaEFjdGlvbjtcbiAgfSgpO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICAgKiBAbWV0aG9kIGhhc1BhcmVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgcG9pbnRlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRlcnNcbiAgICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldENlbnRlcihwb2ludGVycykge1xuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDsgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcblxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXG4gICAgICAgIHk6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBwb2ludGVyc0xlbmd0aCkge1xuICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxuICAgICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNyZWF0ZSBhIHNpbXBsZSBjbG9uZSBmcm9tIHRoZSBpbnB1dCB1c2VkIGZvciBzdG9yYWdlIG9mIGZpcnN0SW5wdXQgYW5kIGZpcnN0TXVsdGlwbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGNsb25lZElucHV0RGF0YVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XG4gICAgLy8gbWFrZSBhIHNpbXBsZSBjb3B5IG9mIHRoZSBwb2ludGVycyBiZWNhdXNlIHdlIHdpbGwgZ2V0IGEgcmVmZXJlbmNlIGlmIHdlIGRvbid0XG4gICAgLy8gd2Ugb25seSBuZWVkIGNsaWVudFhZIGZvciB0aGUgY2FsY3VsYXRpb25zXG4gICAgdmFyIHBvaW50ZXJzID0gW107XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBpbnB1dC5wb2ludGVycy5sZW5ndGgpIHtcbiAgICAgIHBvaW50ZXJzW2ldID0ge1xuICAgICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcbiAgICAgICAgY2xpZW50WTogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WSlcbiAgICAgIH07XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRpbWVTdGFtcDogbm93KCksXG4gICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgICBkZWx0YVg6IGlucHV0LmRlbHRhWCxcbiAgICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAgICogQHBhcmFtIHtPYmplY3R9IHAxIHt4LCB5fVxuICAgKiBAcGFyYW0ge09iamVjdH0gcDIge3gsIHl9XG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAgICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cblxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dO1xuICAgIHZhciB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHAxXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwMlxuICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXTtcbiAgICB2YXIgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGRpcmVjdGlvblxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldERpcmVjdGlvbih4LCB5KSB7XG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xuICAgICAgcmV0dXJuIHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7IC8vIGxldCB7IG9mZnNldERlbHRhOm9mZnNldCA9IHt9LCBwcmV2RGVsdGEgPSB7fSwgcHJldklucHV0ID0ge30gfSA9IHNlc3Npb247XG4gICAgLy8ganNjcyB0aHJvd2luZyBlcnJvciBvbiBkZWZhbHV0IGRlc3RydWN0dXJlZCB2YWx1ZXMgYW5kIHdpdGhvdXQgZGVmYXVsdHMgdGVzdHMgZmFpbFxuXG4gICAgdmFyIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcblxuICAgIGlmIChpbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX1NUQVJUIHx8IHByZXZJbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX0VORCkge1xuICAgICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICAgIHg6IHByZXZJbnB1dC5kZWx0YVggfHwgMCxcbiAgICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgICB9O1xuICAgICAgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSA9IHtcbiAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgIHk6IGNlbnRlci55XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICAgIGlucHV0LmRlbHRhWSA9IHByZXZEZWx0YS55ICsgKGNlbnRlci55IC0gb2Zmc2V0LnkpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4IC8gZGVsdGFUaW1lIHx8IDAsXG4gICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjYWxjdWxhdGUgdGhlIHNjYWxlIGZhY3RvciBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICAgKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gICAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gICAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpICsgZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dDtcbiAgICB2YXIgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXA7XG4gICAgdmFyIHZlbG9jaXR5O1xuICAgIHZhciB2ZWxvY2l0eVg7XG4gICAgdmFyIHZlbG9jaXR5WTtcbiAgICB2YXIgZGlyZWN0aW9uO1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPT0gSU5QVVRfQ0FOQ0VMICYmIChkZWx0YVRpbWUgPiBDT01QVVRFX0lOVEVSVkFMIHx8IGxhc3QudmVsb2NpdHkgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIHZhciBkZWx0YVggPSBpbnB1dC5kZWx0YVggLSBsYXN0LmRlbHRhWDtcbiAgICAgIHZhciBkZWx0YVkgPSBpbnB1dC5kZWx0YVkgLSBsYXN0LmRlbHRhWTtcbiAgICAgIHZhciB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICB2ZWxvY2l0eVggPSB2Lng7XG4gICAgICB2ZWxvY2l0eVkgPSB2Lnk7XG4gICAgICB2ZWxvY2l0eSA9IGFicyh2LngpID4gYWJzKHYueSkgPyB2LnggOiB2Lnk7XG4gICAgICBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgPSBpbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXNlIGxhdGVzdCB2ZWxvY2l0eSBpbmZvIGlmIGl0IGRvZXNuJ3Qgb3ZlcnRha2UgYSBtaW5pbXVtIHBlcmlvZFxuICAgICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xuICAgICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XG4gICAgICB2ZWxvY2l0eVkgPSBsYXN0LnZlbG9jaXR5WTtcbiAgICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICAgIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gIH1cbiAgLyoqXG4gICogQHByaXZhdGVcbiAgICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICAgKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG5cblxuICBmdW5jdGlvbiBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KSB7XG4gICAgdmFyIHNlc3Npb24gPSBtYW5hZ2VyLnNlc3Npb247XG4gICAgdmFyIHBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnM7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoOyAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG5cbiAgICBpZiAoIXNlc3Npb24uZmlyc3RJbnB1dCkge1xuICAgICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH0gLy8gdG8gY29tcHV0ZSBzY2FsZSBhbmQgcm90YXRpb24gd2UgbmVlZCB0byBzdG9yZSB0aGUgbXVsdGlwbGUgdG91Y2hlc1xuXG5cbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcbiAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RJbnB1dCA9IHNlc3Npb24uZmlyc3RJbnB1dCxcbiAgICAgICAgZmlyc3RNdWx0aXBsZSA9IHNlc3Npb24uZmlyc3RNdWx0aXBsZTtcbiAgICB2YXIgb2Zmc2V0Q2VudGVyID0gZmlyc3RNdWx0aXBsZSA/IGZpcnN0TXVsdGlwbGUuY2VudGVyIDogZmlyc3RJbnB1dC5jZW50ZXI7XG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlciA9IGdldENlbnRlcihwb2ludGVycyk7XG4gICAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XG4gICAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gICAgaW5wdXQuZGlzdGFuY2UgPSBnZXREaXN0YW5jZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gICAgY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpO1xuICAgIGlucHV0Lm9mZnNldERpcmVjdGlvbiA9IGdldERpcmVjdGlvbihpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG4gICAgdmFyIG92ZXJhbGxWZWxvY2l0eSA9IGdldFZlbG9jaXR5KGlucHV0LmRlbHRhVGltZSwgaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVggPSBvdmVyYWxsVmVsb2NpdHkueDtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZID0gb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5ID0gYWJzKG92ZXJhbGxWZWxvY2l0eS54KSA+IGFicyhvdmVyYWxsVmVsb2NpdHkueSkgPyBvdmVyYWxsVmVsb2NpdHkueCA6IG92ZXJhbGxWZWxvY2l0eS55O1xuICAgIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XG4gICAgaW5wdXQucm90YXRpb24gPSBmaXJzdE11bHRpcGxlID8gZ2V0Um90YXRpb24oZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMDtcbiAgICBpbnB1dC5tYXhQb2ludGVycyA9ICFzZXNzaW9uLnByZXZJbnB1dCA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA+IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnM7XG4gICAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTsgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcblxuICAgIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgdmFyIHNyY0V2ZW50VGFyZ2V0O1xuXG4gICAgaWYgKHNyY0V2ZW50LmNvbXBvc2VkUGF0aCkge1xuICAgICAgc3JjRXZlbnRUYXJnZXQgPSBzcmNFdmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgICB9IGVsc2UgaWYgKHNyY0V2ZW50LnBhdGgpIHtcbiAgICAgIHNyY0V2ZW50VGFyZ2V0ID0gc3JjRXZlbnQucGF0aFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3JjRXZlbnRUYXJnZXQgPSBzcmNFdmVudC50YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKGhhc1BhcmVudChzcmNFdmVudFRhcmdldCwgdGFyZ2V0KSkge1xuICAgICAgdGFyZ2V0ID0gc3JjRXZlbnRUYXJnZXQ7XG4gICAgfVxuXG4gICAgaW5wdXQudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBoYW5kbGUgaW5wdXQgZXZlbnRzXG4gICAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlucHV0SGFuZGxlcihtYW5hZ2VyLCBldmVudFR5cGUsIGlucHV0KSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoO1xuICAgIHZhciBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xuICAgIHZhciBpc0ZpcnN0ID0gZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgcG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDA7XG4gICAgdmFyIGlzRmluYWwgPSBldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiBwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMDtcbiAgICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICAgIGlucHV0LmlzRmluYWwgPSAhIWlzRmluYWw7XG5cbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgbWFuYWdlci5zZXNzaW9uID0ge307XG4gICAgfSAvLyBzb3VyY2UgZXZlbnQgaXMgdGhlIG5vcm1hbGl6ZWQgdmFsdWUgb2YgdGhlIGRvbUV2ZW50c1xuICAgIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xuXG5cbiAgICBpbnB1dC5ldmVudFR5cGUgPSBldmVudFR5cGU7IC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xuXG4gICAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7IC8vIGVtaXQgc2VjcmV0IGV2ZW50XG5cbiAgICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcbiAgICBtYW5hZ2VyLnJlY29nbml6ZShpbnB1dCk7XG4gICAgbWFuYWdlci5zZXNzaW9uLnByZXZJbnB1dCA9IGlucHV0O1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcbiAgICovXG5cblxuICBmdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogYWRkRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZ2V0IHRoZSB3aW5kb3cgb2JqZWN0IG9mIGFuIGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJucyB7RG9jdW1lbnRWaWV3fFdpbmRvd31cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG4gICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93IHx8IHdpbmRvdztcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtJbnB1dH1cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuXG5cbiAgdmFyIElucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICAgIHRoaXMudGFyZ2V0ID0gbWFuYWdlci5vcHRpb25zLmlucHV0VGFyZ2V0OyAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAgIC8vIHNvIHdoZW4gZGlzYWJsZWQgdGhlIGlucHV0IGV2ZW50cyBhcmUgY29tcGxldGVseSBieXBhc3NlZC5cblxuICAgICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmIChib29sT3JGbihtYW5hZ2VyLm9wdGlvbnMuZW5hYmxlLCBbbWFuYWdlcl0pKSB7XG4gICAgICAgICAgc2VsZi5oYW5kbGVyKGV2KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogc2hvdWxkIGhhbmRsZSB0aGUgaW5wdXRFdmVudCBkYXRhIGFuZCB0cmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG5cblxuICAgIHZhciBfcHJvdG8gPSBJbnB1dC5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7fTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIGJpbmQgdGhlIGV2ZW50c1xuICAgICAqL1xuXG5cbiAgICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLmV2RWwgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgdGhpcy5ldldpbiAmJiBhZGRFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG5cblxuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgIHRoaXMuZXZUYXJnZXQgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICB0aGlzLmV2V2luICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIElucHV0O1xuICB9KCk7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNyY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cbiAgICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcbiAgICovXG5cblxuICBmdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gICAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kIHx8ICFmaW5kQnlLZXkgJiYgc3JjW2ldID09PSBmaW5kKSB7XG4gICAgICAgICAgLy8gZG8gbm90IHVzZSA9PT0gaGVyZSwgdGVzdCBmYWlsc1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgdmFyIFBPSU5URVJfSU5QVVRfTUFQID0ge1xuICAgIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcbiAgICBwb2ludGVybW92ZTogSU5QVVRfTU9WRSxcbiAgICBwb2ludGVydXA6IElOUFVUX0VORCxcbiAgICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXG4gICAgcG9pbnRlcm91dDogSU5QVVRfQ0FOQ0VMXG4gIH07IC8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG5cbiAgdmFyIElFMTBfUE9JTlRFUl9UWVBFX0VOVU0gPSB7XG4gICAgMjogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAzOiBJTlBVVF9UWVBFX1BFTixcbiAgICA0OiBJTlBVVF9UWVBFX01PVVNFLFxuICAgIDU6IElOUFVUX1RZUEVfS0lORUNUIC8vIHNlZSBodHRwczovL3R3aXR0ZXIuY29tL2phY29icm9zc2kvc3RhdHVzLzQ4MDU5NjQzODQ4OTg5MDgxNlxuXG4gIH07XG4gIHZhciBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ3BvaW50ZXJkb3duJztcbiAgdmFyIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdwb2ludGVybW92ZSBwb2ludGVydXAgcG9pbnRlcmNhbmNlbCc7IC8vIElFMTAgaGFzIHByZWZpeGVkIHN1cHBvcnQsIGFuZCBjYXNlLXNlbnNpdGl2ZVxuXG4gIGlmICh3aW4uTVNQb2ludGVyRXZlbnQgJiYgIXdpbi5Qb2ludGVyRXZlbnQpIHtcbiAgICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xuICAgIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdNU1BvaW50ZXJNb3ZlIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBJbnB1dFxuICAgKi9cblxuXG4gIHZhciBQb2ludGVyRXZlbnRJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lucHV0KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoUG9pbnRlckV2ZW50SW5wdXQsIF9JbnB1dCk7XG5cbiAgICBmdW5jdGlvbiBQb2ludGVyRXZlbnRJbnB1dCgpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgdmFyIHByb3RvID0gUG9pbnRlckV2ZW50SW5wdXQucHJvdG90eXBlO1xuICAgICAgcHJvdG8uZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgICBwcm90by5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcbiAgICAgIF90aGlzID0gX0lucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgIF90aGlzLnN0b3JlID0gX3RoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG5cblxuICAgIHZhciBfcHJvdG8gPSBQb2ludGVyRXZlbnRJbnB1dC5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXYpIHtcbiAgICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZhbHNlO1xuICAgICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XG4gICAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XG4gICAgICB2YXIgcG9pbnRlclR5cGUgPSBJRTEwX1BPSU5URVJfVFlQRV9FTlVNW2V2LnBvaW50ZXJUeXBlXSB8fCBldi5wb2ludGVyVHlwZTtcbiAgICAgIHZhciBpc1RvdWNoID0gcG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfVE9VQ0g7IC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG5cbiAgICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7IC8vIHN0YXJ0IGFuZCBtb3VzZSBtdXN0IGJlIGRvd25cblxuICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChldi5idXR0b24gPT09IDAgfHwgaXNUb3VjaCkpIHtcbiAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICAgICAgc3RvcmVJbmRleCA9IHN0b3JlLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgcmVtb3ZlUG9pbnRlciA9IHRydWU7XG4gICAgICB9IC8vIGl0IG5vdCBmb3VuZCwgc28gdGhlIHBvaW50ZXIgaGFzbid0IGJlZW4gZG93biAoc28gaXQncyBwcm9iYWJseSBhIGhvdmVyKVxuXG5cbiAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHVwZGF0ZSB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG5cblxuICAgICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgcG9pbnRlcnM6IHN0b3JlLFxuICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlbW92ZVBvaW50ZXIpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlXG4gICAgICAgIHN0b3JlLnNwbGljZShzdG9yZUluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFBvaW50ZXJFdmVudElucHV0O1xuICB9KElucHV0KTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHVuaXF1ZSBhcnJheSB3aXRoIG9iamVjdHMgYmFzZWQgb24gYSBrZXkgKGxpa2UgJ2lkJykgb3IganVzdCBieSB0aGUgYXJyYXkncyB2YWx1ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc29ydD1GYWxzZV1cbiAgICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAgICovXG5cblxuICBmdW5jdGlvbiB1bmlxdWVBcnJheShzcmMsIGtleSwgc29ydCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuXG4gICAgICBpZiAoaW5BcnJheSh2YWx1ZXMsIHZhbCkgPCAwKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChzcmNbaV0pO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZXNbaV0gPSB2YWw7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKHNvcnQpIHtcbiAgICAgIGlmICgha2V5KSB7XG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIHZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxuICB9O1xuICB2YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBNdWx0aS11c2VyIHRvdWNoIGV2ZW50cyBpbnB1dFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG5cbiAgdmFyIFRvdWNoSW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbnB1dCkge1xuICAgIF9pbmhlcml0c0xvb3NlKFRvdWNoSW5wdXQsIF9JbnB1dCk7XG5cbiAgICBmdW5jdGlvbiBUb3VjaElucHV0KCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBUb3VjaElucHV0LnByb3RvdHlwZS5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgICBfdGhpcyA9IF9JbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICBfdGhpcy50YXJnZXRJZHMgPSB7fTsgLy8gdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gVG91Y2hJbnB1dC5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXYpIHtcbiAgICAgIHZhciB0eXBlID0gVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuXG4gICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvdWNoSW5wdXQ7XG4gIH0oSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIGdldFRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICB2YXIgYWxsVG91Y2hlcyA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzOyAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHRvdWNoLCB0aGUgcHJvY2VzcyBjYW4gYmUgc2ltcGxpZmllZFxuXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfU1RBUlQgfCBJTlBVVF9NT1ZFKSAmJiBhbGxUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGFyZ2V0SWRzW2FsbFRvdWNoZXNbMF0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgcmV0dXJuIFthbGxUb3VjaGVzLCBhbGxUb3VjaGVzXTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgdGFyZ2V0VG91Y2hlcztcbiAgICB2YXIgY2hhbmdlZFRvdWNoZXMgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcbiAgICB2YXIgY2hhbmdlZFRhcmdldFRvdWNoZXMgPSBbXTtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7IC8vIGdldCB0YXJnZXQgdG91Y2hlcyBmcm9tIHRvdWNoZXNcblxuICAgIHRhcmdldFRvdWNoZXMgPSBhbGxUb3VjaGVzLmZpbHRlcihmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgIHJldHVybiBoYXNQYXJlbnQodG91Y2gudGFyZ2V0LCB0YXJnZXQpO1xuICAgIH0pOyAvLyBjb2xsZWN0IHRvdWNoZXNcblxuICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpIDwgdGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSAvLyBmaWx0ZXIgY2hhbmdlZCB0b3VjaGVzIHRvIG9ubHkgY29udGFpbiB0b3VjaGVzIHRoYXQgZXhpc3QgaW4gdGhlIGNvbGxlY3RlZCB0YXJnZXQgaWRzXG5cblxuICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XG4gICAgICB9IC8vIGNsZWFudXAgcmVtb3ZlZCB0b3VjaGVzXG5cblxuICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICBkZWxldGUgdGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKCFjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gWy8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xuICAgIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSwgY2hhbmdlZFRhcmdldFRvdWNoZXNdO1xuICB9XG5cbiAgdmFyIE1PVVNFX0lOUFVUX01BUCA9IHtcbiAgICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxuICAgIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgICBtb3VzZXVwOiBJTlBVVF9FTkRcbiAgfTtcbiAgdmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XG4gIHZhciBNT1VTRV9XSU5ET1dfRVZFTlRTID0gJ21vdXNlbW92ZSBtb3VzZXVwJztcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIE1vdXNlIGV2ZW50cyBpbnB1dFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG5cbiAgdmFyIE1vdXNlSW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbnB1dCkge1xuICAgIF9pbmhlcml0c0xvb3NlKE1vdXNlSW5wdXQsIF9JbnB1dCk7XG5cbiAgICBmdW5jdGlvbiBNb3VzZUlucHV0KCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICB2YXIgcHJvdG8gPSBNb3VzZUlucHV0LnByb3RvdHlwZTtcbiAgICAgIHByb3RvLmV2RWwgPSBNT1VTRV9FTEVNRU5UX0VWRU5UUztcbiAgICAgIHByb3RvLmV2V2luID0gTU9VU0VfV0lORE9XX0VWRU5UUztcbiAgICAgIF90aGlzID0gX0lucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgIF90aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG5cblxuICAgIHZhciBfcHJvdG8gPSBNb3VzZUlucHV0LnByb3RvdHlwZTtcblxuICAgIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTsgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG5cbiAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcbiAgICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgICAgfSAvLyBtb3VzZSBtdXN0IGJlIGRvd25cblxuXG4gICAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBNb3VzZUlucHV0O1xuICB9KElucHV0KTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICAgKlxuICAgKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cbiAgICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG5cblxuICB2YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG4gIHZhciBERURVUF9ESVNUQU5DRSA9IDI1O1xuXG4gIGZ1bmN0aW9uIHNldExhc3RUb3VjaChldmVudERhdGEpIHtcbiAgICB2YXIgX2V2ZW50RGF0YSRjaGFuZ2VkUG9pID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVycyxcbiAgICAgICAgdG91Y2ggPSBfZXZlbnREYXRhJGNoYW5nZWRQb2lbMF07XG5cbiAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcbiAgICAgIHZhciBsYXN0VG91Y2ggPSB7XG4gICAgICAgIHg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgIHk6IHRvdWNoLmNsaWVudFlcbiAgICAgIH07XG4gICAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcbiAgICAgIHRoaXMubGFzdFRvdWNoZXMucHVzaChsYXN0VG91Y2gpO1xuXG4gICAgICB2YXIgcmVtb3ZlTGFzdFRvdWNoID0gZnVuY3Rpb24gcmVtb3ZlTGFzdFRvdWNoKCkge1xuICAgICAgICB2YXIgaSA9IGx0cy5pbmRleE9mKGxhc3RUb3VjaCk7XG5cbiAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgIGx0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNldFRpbWVvdXQocmVtb3ZlTGFzdFRvdWNoLCBERURVUF9USU1FT1VUKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRUb3VjaGVzKGV2ZW50VHlwZSwgZXZlbnREYXRhKSB7XG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICB0aGlzLnByaW1hcnlUb3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF0uaWRlbnRpZmllcjtcbiAgICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bnRoZXRpY0V2ZW50KGV2ZW50RGF0YSkge1xuICAgIHZhciB4ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFg7XG4gICAgdmFyIHkgPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYXN0VG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHQgPSB0aGlzLmxhc3RUb3VjaGVzW2ldO1xuICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoeCAtIHQueCk7XG4gICAgICB2YXIgZHkgPSBNYXRoLmFicyh5IC0gdC55KTtcblxuICAgICAgaWYgKGR4IDw9IERFRFVQX0RJU1RBTkNFICYmIGR5IDw9IERFRFVQX0RJU1RBTkNFKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBUb3VjaE1vdXNlSW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIHZhciBUb3VjaE1vdXNlSW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbnB1dCkge1xuICAgICAgX2luaGVyaXRzTG9vc2UoVG91Y2hNb3VzZUlucHV0LCBfSW5wdXQpO1xuXG4gICAgICBmdW5jdGlvbiBUb3VjaE1vdXNlSW5wdXQoX21hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcztcblxuICAgICAgICBfdGhpcyA9IF9JbnB1dC5jYWxsKHRoaXMsIF9tYW5hZ2VyLCBjYWxsYmFjaykgfHwgdGhpcztcblxuICAgICAgICBfdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24gKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgICAgIHZhciBpc1RvdWNoID0gaW5wdXREYXRhLnBvaW50ZXJUeXBlID09PSBJTlBVVF9UWVBFX1RPVUNIO1xuICAgICAgICAgIHZhciBpc01vdXNlID0gaW5wdXREYXRhLnBvaW50ZXJUeXBlID09PSBJTlBVVF9UWVBFX01PVVNFO1xuXG4gICAgICAgICAgaWYgKGlzTW91c2UgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcyAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIHdoZW4gd2UncmUgaW4gYSB0b3VjaCBldmVudCwgcmVjb3JkIHRvdWNoZXMgdG8gIGRlLWR1cGUgc3ludGhldGljIG1vdXNlIGV2ZW50XG5cblxuICAgICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICByZWNvcmRUb3VjaGVzLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZCQxKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQkMShfdGhpcykpLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiBpc1N5bnRoZXRpY0V2ZW50LmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZCQxKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQkMShfdGhpcykpLCBpbnB1dERhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy50b3VjaCA9IG5ldyBUb3VjaElucHV0KF90aGlzLm1hbmFnZXIsIF90aGlzLmhhbmRsZXIpO1xuICAgICAgICBfdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KF90aGlzLm1hbmFnZXIsIF90aGlzLmhhbmRsZXIpO1xuICAgICAgICBfdGhpcy5wcmltYXJ5VG91Y2ggPSBudWxsO1xuICAgICAgICBfdGhpcy5sYXN0VG91Y2hlcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICAgICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dEV2ZW50XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICAgKi9cblxuXG4gICAgICB2YXIgX3Byb3RvID0gVG91Y2hNb3VzZUlucHV0LnByb3RvdHlwZTtcbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgKi9cblxuICAgICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gVG91Y2hNb3VzZUlucHV0O1xuICAgIH0oSW5wdXQpO1xuXG4gICAgcmV0dXJuIFRvdWNoTW91c2VJbnB1dDtcbiAgfSgpO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAgICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAqIEByZXR1cm5zIHtJbnB1dH1cbiAgICovXG5cblxuICBmdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcbiAgICB2YXIgVHlwZTsgLy8gbGV0IGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcblxuICAgIHZhciBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgICBpZiAoaW5wdXRDbGFzcykge1xuICAgICAgVHlwZSA9IGlucHV0Q2xhc3M7XG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XG4gICAgICBUeXBlID0gUG9pbnRlckV2ZW50SW5wdXQ7XG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX09OTFlfVE9VQ0gpIHtcbiAgICAgIFR5cGUgPSBUb3VjaElucHV0O1xuICAgIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcbiAgICAgIFR5cGUgPSBNb3VzZUlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICBUeXBlID0gVG91Y2hNb3VzZUlucHV0O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVHlwZShtYW5hZ2VyLCBpbnB1dEhhbmRsZXIpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICAgKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAgICogdGhpcyBpcyB1c2VkIGJ5IGFsbCB0aGUgbWV0aG9kcyB0aGF0IGFjY2VwdCBhIHNpbmdsZSBhbmQgYXJyYXkgYXJndW1lbnQuXG4gICAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbiAgdmFyIFNUQVRFX0JFR0FOID0gMjtcbiAgdmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xuICB2YXIgU1RBVEVfRU5ERUQgPSA4O1xuICB2YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xuICB2YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XG4gIHZhciBTVEFURV9GQUlMRUQgPSAzMjtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGdldCBhIHVuaXF1ZSBpZFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICAgKi9cblxuICB2YXIgX3VuaXF1ZUlkID0gMTtcblxuICBmdW5jdGlvbiB1bmlxdWVJZCgpIHtcbiAgICByZXR1cm4gX3VuaXF1ZUlkKys7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gb3RoZXJSZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgcmVjb2duaXplcikge1xuICAgIHZhciBtYW5hZ2VyID0gcmVjb2duaXplci5tYW5hZ2VyO1xuXG4gICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgIHJldHVybiBtYW5hZ2VyLmdldChvdGhlclJlY29nbml6ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBvdGhlclJlY29nbml6ZXI7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGdldCBhIHVzYWJsZSBzdHJpbmcsIHVzZWQgYXMgZXZlbnQgcG9zdGZpeFxuICAgKiBAcGFyYW0ge2NvbnN0YW50fSBzdGF0ZVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlICYgU1RBVEVfQ0FOQ0VMTEVEKSB7XG4gICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgICByZXR1cm4gJ2VuZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICAgIHJldHVybiAnbW92ZSc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0JFR0FOKSB7XG4gICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFJlY29nbml6ZXIgZmxvdyBleHBsYWluZWQ7ICpcbiAgICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICAgKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAgICogRXhhbXBsZSBzZXNzaW9uIGZvciBtb3VzZS1pbnB1dDogbW91c2Vkb3duIC0+IG1vdXNlbW92ZSAtPiBtb3VzZXVwXG4gICAqXG4gICAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAgICogd2hpY2ggZGV0ZXJtaW5lcyB3aXRoIHN0YXRlIGl0IHNob3VsZCBiZS5cbiAgICpcbiAgICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICAgKiBQT1NTSUJMRSB0byBnaXZlIGl0IGFub3RoZXIgY2hhbmdlIG9uIHRoZSBuZXh0IGN5Y2xlLlxuICAgKlxuICAgKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gICAqICAgICAgICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gICAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogICAgICArLS0tLS0rLS0tLS0rICAgICAgICAgICAgICAgfFxuICAgKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gICAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tKy0tLS0tLStcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmRlZC9SZWNvZ25pemVkXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBSZWNvZ25pemVyXG4gICAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgdmFyIFJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHtcbiAgICAgICAgZW5hYmxlOiB0cnVlXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xuICAgICAgdGhpcy5tYW5hZ2VyID0gbnVsbDsgLy8gZGVmYXVsdCBpcyBlbmFibGUgdHJ1ZVxuXG4gICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgICAgdGhpcy5yZXF1aXJlRmFpbCA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgICAgIGFzc2lnbiQxKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7IC8vIGFsc28gdXBkYXRlIHRoZSB0b3VjaEFjdGlvbiwgaW4gY2FzZSBzb21ldGhpbmcgY2hhbmdlZCBhYm91dCB0aGUgZGlyZWN0aW9ucy9lbmFibGVkIHN0YXRlXG5cbiAgICAgIHRoaXMubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuXG5cbiAgICBfcHJvdG8ucmVjb2duaXplV2l0aCA9IGZ1bmN0aW9uIHJlY29nbml6ZVdpdGgob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2ltdWx0YW5lb3VzID0gdGhpcy5zaW11bHRhbmVvdXM7XG4gICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG5cbiAgICAgIGlmICghc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0pIHtcbiAgICAgICAgc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0gPSBvdGhlclJlY29nbml6ZXI7XG4gICAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogZHJvcCB0aGUgc2ltdWx0YW5lb3VzIGxpbmsuIGl0IGRvZXNudCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuXG5cbiAgICBfcHJvdG8uZHJvcFJlY29nbml6ZVdpdGggPSBmdW5jdGlvbiBkcm9wUmVjb2duaXplV2l0aChvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICBkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiByZWNvZ25pemVyIGNhbiBvbmx5IHJ1biB3aGVuIGFuIG90aGVyIGlzIGZhaWxpbmdcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG5cblxuICAgIF9wcm90by5yZXF1aXJlRmFpbHVyZSA9IGZ1bmN0aW9uIHJlcXVpcmVGYWlsdXJlKG90aGVyUmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXF1aXJlRmFpbCA9IHRoaXMucmVxdWlyZUZhaWw7XG4gICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG5cbiAgICAgIGlmIChpbkFycmF5KHJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpID09PSAtMSkge1xuICAgICAgICByZXF1aXJlRmFpbC5wdXNoKG90aGVyUmVjb2duaXplcik7XG4gICAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZSh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIGRyb3AgdGhlIHJlcXVpcmVGYWlsdXJlIGxpbmsuIGl0IGRvZXMgbm90IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG5cblxuICAgIF9wcm90by5kcm9wUmVxdWlyZUZhaWx1cmUgPSBmdW5jdGlvbiBkcm9wUmVxdWlyZUZhaWx1cmUob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgIHZhciBpbmRleCA9IGluQXJyYXkodGhpcy5yZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKTtcblxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogaGFzIHJlcXVpcmUgZmFpbHVyZXMgYm9vbGVhblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBfcHJvdG8uaGFzUmVxdWlyZUZhaWx1cmVzID0gZnVuY3Rpb24gaGFzUmVxdWlyZUZhaWx1cmVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogaWYgdGhlIHJlY29nbml6ZXIgY2FuIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLmNhblJlY29nbml6ZVdpdGggPSBmdW5jdGlvbiBjYW5SZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgICAgcmV0dXJuICEhdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogWW91IHNob3VsZCB1c2UgYHRyeUVtaXRgIGluc3RlYWQgb2YgYGVtaXRgIGRpcmVjdGx5IHRvIGNoZWNrXG4gICAgICogdGhhdCBhbGwgdGhlIG5lZWRlZCByZWNvZ25pemVycyBoYXMgZmFpbGVkIGJlZm9yZSBlbWl0dGluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICAgIHNlbGYubWFuYWdlci5lbWl0KGV2ZW50LCBpbnB1dCk7XG4gICAgICB9IC8vICdwYW5zdGFydCcgYW5kICdwYW5tb3ZlJ1xuXG5cbiAgICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgIH1cblxuICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXG5cbiAgICAgIGlmIChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpIHtcbiAgICAgICAgLy8gYWRkaXRpb25hbCBldmVudChwYW5sZWZ0LCBwYW5yaWdodCwgcGluY2hpbiwgcGluY2hvdXQuLi4pXG4gICAgICAgIGVtaXQoaW5wdXQuYWRkaXRpb25hbEV2ZW50KTtcbiAgICAgIH0gLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcblxuXG4gICAgICBpZiAoc3RhdGUgPj0gU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBDaGVjayB0aGF0IGFsbCB0aGUgcmVxdWlyZSBmYWlsdXJlIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQsXG4gICAgICogaWYgdHJ1ZSwgaXQgZW1pdHMgYSBnZXN0dXJlIGV2ZW50LFxuICAgICAqIG90aGVyd2lzZSwgc2V0dXAgdGhlIHN0YXRlIHRvIEZBSUxFRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLnRyeUVtaXQgPSBmdW5jdGlvbiB0cnlFbWl0KGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5jYW5FbWl0KCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XG4gICAgICB9IC8vIGl0J3MgZmFpbGluZyBhbnl3YXlcblxuXG4gICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBjYW4gd2UgZW1pdD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLmNhbkVtaXQgPSBmdW5jdGlvbiBjYW5FbWl0KCkge1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XG4gICAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHVwZGF0ZSB0aGUgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLnJlY29nbml6ZSA9IGZ1bmN0aW9uIHJlY29nbml6ZShpbnB1dERhdGEpIHtcbiAgICAgIC8vIG1ha2UgYSBuZXcgY29weSBvZiB0aGUgaW5wdXREYXRhXG4gICAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xuICAgICAgdmFyIGlucHV0RGF0YUNsb25lID0gYXNzaWduJDEoe30sIGlucHV0RGF0YSk7IC8vIGlzIGlzIGVuYWJsZWQgYW5kIGFsbG93IHJlY29nbml6aW5nP1xuXG4gICAgICBpZiAoIWJvb2xPckZuKHRoaXMub3B0aW9ucy5lbmFibGUsIFt0aGlzLCBpbnB1dERhdGFDbG9uZV0pKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyByZXNldCB3aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxuXG5cbiAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7IC8vIHRoZSByZWNvZ25pemVyIGhhcyByZWNvZ25pemVkIGEgZ2VzdHVyZVxuICAgICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxuXG4gICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcbiAgICAgICAgdGhpcy50cnlFbWl0KGlucHV0RGF0YUNsb25lKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqIEByZXR1cm5zIHtjb25zdGFudH0gU1RBVEVcbiAgICAgKi9cblxuICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblxuXG4gICAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGlucHV0RGF0YSkge307XG4gICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogcmV0dXJuIHRoZSBwcmVmZXJyZWQgdG91Y2gtYWN0aW9uXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG5cblxuICAgIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge307XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuXG5cbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHt9O1xuXG4gICAgcmV0dXJuIFJlY29nbml6ZXI7XG4gIH0oKTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEEgdGFwIGlzIHJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXG4gICAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICAgKiBhIHNpbmdsZSB0YXAuXG4gICAqXG4gICAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICAgKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gICAqL1xuXG5cbiAgdmFyIFRhcFJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWNvZ25pemVyKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoVGFwUmVjb2duaXplciwgX1JlY29nbml6ZXIpO1xuXG4gICAgZnVuY3Rpb24gVGFwUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBfdGhpcyA9IF9SZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgICBldmVudDogJ3RhcCcsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICB0YXBzOiAxLFxuICAgICAgICBpbnRlcnZhbDogMzAwLFxuICAgICAgICAvLyBtYXggdGltZSBiZXR3ZWVuIHRoZSBtdWx0aS10YXAgdGFwc1xuICAgICAgICB0aW1lOiAyNTAsXG4gICAgICAgIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXG4gICAgICAgIHRocmVzaG9sZDogOSxcbiAgICAgICAgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICAgICAgcG9zVGhyZXNob2xkOiAxMFxuICAgICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7IC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAgIC8vIHVzZWQgZm9yIHRhcCBjb3VudGluZ1xuXG4gICAgICBfdGhpcy5wVGltZSA9IGZhbHNlO1xuICAgICAgX3RoaXMucENlbnRlciA9IGZhbHNlO1xuICAgICAgX3RoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgIF90aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgICBfdGhpcy5jb3VudCA9IDA7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFRhcFJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgdmFyIHZhbGlkVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgb3B0aW9ucy50aW1lO1xuICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgdGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgfSAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuXG5cbiAgICAgIGlmICh2YWxpZE1vdmVtZW50ICYmIHZhbGlkVG91Y2hUaW1lICYmIHZhbGlkUG9pbnRlcnMpIHtcbiAgICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPT0gSU5QVVRfRU5EKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IGlucHV0LnRpbWVTdGFtcCAtIHRoaXMucFRpbWUgPCBvcHRpb25zLmludGVydmFsIDogdHJ1ZTtcbiAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuICAgICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xuICAgICAgICB0aGlzLnBDZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG5cbiAgICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XG4gICAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDsgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxuICAgICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuXG4gICAgICAgIHZhciB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG5cbiAgICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XG4gICAgICAgICAgLy8gbm8gZmFpbGluZyByZXF1aXJlbWVudHMsIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHRhcCBldmVudFxuICAgICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxuICAgICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG5cbiAgICAgICAgICAgICAgX3RoaXMyLnRyeUVtaXQoKTtcbiAgICAgICAgICAgIH0sIG9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZmFpbFRpbWVvdXQgPSBmdW5jdGlvbiBmYWlsVGltZW91dCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICB9LCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICB0aGlzLl9pbnB1dC50YXBDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gVGFwUmVjb2duaXplcjtcbiAgfShSZWNvZ25pemVyKTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFRoaXMgcmVjb2duaXplciBpcyBqdXN0IHVzZWQgYXMgYSBiYXNlIGZvciB0aGUgc2ltcGxlIGF0dHJpYnV0ZSByZWNvZ25pemVycy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAgICovXG5cblxuICB2YXIgQXR0clJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWNvZ25pemVyKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoQXR0clJlY29nbml6ZXIsIF9SZWNvZ25pemVyKTtcblxuICAgIGZ1bmN0aW9uIEF0dHJSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX1JlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICAgIHBvaW50ZXJzOiAxXG4gICAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgICB2YXIgb3B0aW9uUG9pbnRlcnMgPSB0aGlzLm9wdGlvbnMucG9pbnRlcnM7XG4gICAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMgeyp9IFN0YXRlXG4gICAgICovXG5cblxuICAgIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhpbnB1dCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHZhciBldmVudFR5cGUgPSBpbnB1dC5ldmVudFR5cGU7XG4gICAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICAgIHZhciBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7IC8vIG9uIGNhbmNlbCBpbnB1dCBhbmQgd2UndmUgcmVjb2duaXplZCBiZWZvcmUsIHJldHVybiBTVEFURV9DQU5DRUxMRURcblxuICAgICAgaWYgKGlzUmVjb2duaXplZCAmJiAoZXZlbnRUeXBlICYgSU5QVVRfQ0FOQ0VMIHx8ICFpc1ZhbGlkKSkge1xuICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DQU5DRUxMRUQ7XG4gICAgICB9IGVsc2UgaWYgKGlzUmVjb2duaXplZCB8fCBpc1ZhbGlkKSB7XG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9FTkRFRDtcbiAgICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XG4gICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEF0dHJSZWNvZ25pemVyO1xuICB9KFJlY29nbml6ZXIpO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZGlyZWN0aW9uIGNvbnMgdG8gc3RyaW5nXG4gICAqIEBwYXJhbSB7Y29uc3RhbnR9IGRpcmVjdGlvblxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGRpcmVjdGlvblN0cihkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fRE9XTikge1xuICAgICAgcmV0dXJuICdkb3duJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1VQKSB7XG4gICAgICByZXR1cm4gJ3VwJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9SSUdIVCkge1xuICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBQYW5cbiAgICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuXG5cbiAgdmFyIFBhblJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BdHRyUmVjb2duaXplcikge1xuICAgIF9pbmhlcml0c0xvb3NlKFBhblJlY29nbml6ZXIsIF9BdHRyUmVjb2duaXplcik7XG5cbiAgICBmdW5jdGlvbiBQYW5SZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIF90aGlzID0gX0F0dHJSZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgICBldmVudDogJ3BhbicsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICAgICAgX3RoaXMucFggPSBudWxsO1xuICAgICAgX3RoaXMucFkgPSBudWxsO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBQYW5SZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuXG4gICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY3Rpb25zO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZGlyZWN0aW9uVGVzdCA9IGZ1bmN0aW9uIGRpcmVjdGlvblRlc3QoaW5wdXQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIGhhc01vdmVkID0gdHJ1ZTtcbiAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbiAgICAgIHZhciB4ID0gaW5wdXQuZGVsdGFYO1xuICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7IC8vIGxvY2sgdG8gYXhpcz9cblxuICAgICAgaWYgKCEoZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb24pKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgZGlyZWN0aW9uID0geCA9PT0gMCA/IERJUkVDVElPTl9OT05FIDogeCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgICBoYXNNb3ZlZCA9IHggIT09IHRoaXMucFg7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpcmVjdGlvbiA9IHkgPT09IDAgPyBESVJFQ1RJT05fTk9ORSA6IHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgaGFzTW92ZWQgPSB5ICE9PSB0aGlzLnBZO1xuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFZKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgKCAvLyByZXBsYWNlIHdpdGggYSBzdXBlciBjYWxsXG4gICAgICB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgISh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pICYmIHRoaXMuZGlyZWN0aW9uVGVzdChpbnB1dCkpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XG4gICAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xuXG4gICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgX0F0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGFuUmVjb2duaXplcjtcbiAgfShBdHRyUmVjb2duaXplcik7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBTd2lwZVxuICAgKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAgICovXG5cblxuICB2YXIgU3dpcGVSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXR0clJlY29nbml6ZXIpIHtcbiAgICBfaW5oZXJpdHNMb29zZShTd2lwZVJlY29nbml6ZXIsIF9BdHRyUmVjb2duaXplcik7XG5cbiAgICBmdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICAgIGV2ZW50OiAnc3dpcGUnLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICB2ZWxvY2l0eTogMC4zLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgICBwb2ludGVyczogMVxuICAgICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFN3aXBlUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICAgIHJldHVybiBQYW5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uYXR0clRlc3QgPSBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICB2YXIgdmVsb2NpdHk7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5O1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVg7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmIGRpcmVjdGlvbiAmIGlucHV0Lm9mZnNldERpcmVjdGlvbiAmJiBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiYgaW5wdXQubWF4UG9pbnRlcnMgPT09IHRoaXMub3B0aW9ucy5wb2ludGVycyAmJiBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0Lm9mZnNldERpcmVjdGlvbik7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3dpcGVSZWNvZ25pemVyO1xuICB9KEF0dHJSZWNvZ25pemVyKTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFBpbmNoXG4gICAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuXG5cbiAgdmFyIFBpbmNoUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoUGluY2hSZWNvZ25pemVyLCBfQXR0clJlY29nbml6ZXIpO1xuXG4gICAgZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgICBldmVudDogJ3BpbmNoJyxcbiAgICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgICBwb2ludGVyczogMlxuICAgICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFBpbmNoUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIH07XG5cbiAgICBfcHJvdG8uYXR0clRlc3QgPSBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfTtcblxuICAgIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0LnNjYWxlICE9PSAxKSB7XG4gICAgICAgIHZhciBpbk91dCA9IGlucHV0LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JztcbiAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgaW5PdXQ7XG4gICAgICB9XG5cbiAgICAgIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBpbmNoUmVjb2duaXplcjtcbiAgfShBdHRyUmVjb2duaXplcik7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBSb3RhdGVcbiAgICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuXG5cbiAgdmFyIFJvdGF0ZVJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BdHRyUmVjb2duaXplcikge1xuICAgIF9pbmhlcml0c0xvb3NlKFJvdGF0ZVJlY29nbml6ZXIsIF9BdHRyUmVjb2duaXplcik7XG5cbiAgICBmdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBSb3RhdGVSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfTtcblxuICAgIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiAoTWF0aC5hYnMoaW5wdXQucm90YXRpb24pID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH07XG5cbiAgICByZXR1cm4gUm90YXRlUmVjb2duaXplcjtcbiAgfShBdHRyUmVjb2duaXplcik7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBQcmVzc1xuICAgKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBmb3IgeCBtcyB3aXRob3V0IGFueSBtb3ZlbWVudC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAgICovXG5cblxuICB2YXIgUHJlc3NSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVjb2duaXplcikge1xuICAgIF9pbmhlcml0c0xvb3NlKFByZXNzUmVjb2duaXplciwgX1JlY29nbml6ZXIpO1xuXG4gICAgZnVuY3Rpb24gUHJlc3NSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIF90aGlzID0gX1JlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICAgIGV2ZW50OiAncHJlc3MnLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgdGltZTogMjUxLFxuICAgICAgICAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxuICAgICAgICB0aHJlc2hvbGQ6IDlcbiAgICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICAgICAgX3RoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgIF90aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFByZXNzUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX0FVVE9dO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgdmFyIHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcbiAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7IC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG5cbiAgICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCBpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG5cbiAgICAgICAgICBfdGhpczIudHJ5RW1pdCgpO1xuICAgICAgICB9LCBvcHRpb25zLnRpbWUpO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfTtcblxuICAgIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnB1dCAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgXCJ1cFwiLCBpbnB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBQcmVzc1JlY29nbml6ZXI7XG4gIH0oUmVjb2duaXplcik7XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cbiAgICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZG9tRXZlbnRzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXG4gICAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBjb21wdXRlXG4gICAgICovXG4gICAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgZW5hYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAgICogQ2hhbmdlIHRoZSBwYXJlbnQgaW5wdXQgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0Q2xhc3M6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFNvbWUgQ1NTIHByb3BlcnRpZXMgY2FuIGJlIHVzZWQgdG8gaW1wcm92ZSB0aGUgd29ya2luZyBvZiBIYW1tZXIuXG4gICAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBjc3NQcm9wczoge1xuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICovXG4gICAgICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgKi9cbiAgICAgIHRvdWNoU2VsZWN0OiBcIm5vbmVcIixcblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAgICogYSBjYWxsb3V0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmsuIFRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBkaXNhYmxlIHRoYXQgY2FsbG91dC5cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAqL1xuICAgICAgdG91Y2hDYWxsb3V0OiBcIm5vbmVcIixcblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgem9vbWluZyBpcyBlbmFibGVkLiBVc2VkIGJ5IElFMTA+XG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnRab29taW5nOiBcIm5vbmVcIixcblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICovXG4gICAgICB1c2VyRHJhZzogXCJub25lXCIsXG5cbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIE92ZXJyaWRlcyB0aGUgaGlnaGxpZ2h0IGNvbG9yIHNob3duIHdoZW4gdGhlIHVzZXIgdGFwcyBhIGxpbmsgb3IgYSBKYXZhU2NyaXB0XG4gICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgJ3JnYmEoMCwwLDAsMCknXG4gICAgICAgKi9cbiAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiBcInJnYmEoMCwwLDAsMClcIlxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIERlZmF1bHQgcmVjb2duaXplciBzZXR1cCB3aGVuIGNhbGxpbmcgYEhhbW1lcigpYFxuICAgKiBXaGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIgdGhlc2Ugd2lsbCBiZSBza2lwcGVkLlxuICAgKiBUaGlzIGlzIHNlcGFyYXRlZCB3aXRoIG90aGVyIGRlZmF1bHRzIGJlY2F1c2Ugb2YgdHJlZS1zaGFraW5nLlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuXG4gIHZhciBwcmVzZXQgPSBbW1JvdGF0ZVJlY29nbml6ZXIsIHtcbiAgICBlbmFibGU6IGZhbHNlXG4gIH1dLCBbUGluY2hSZWNvZ25pemVyLCB7XG4gICAgZW5hYmxlOiBmYWxzZVxuICB9LCBbJ3JvdGF0ZSddXSwgW1N3aXBlUmVjb2duaXplciwge1xuICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUxcbiAgfV0sIFtQYW5SZWNvZ25pemVyLCB7XG4gICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTFxuICB9LCBbJ3N3aXBlJ11dLCBbVGFwUmVjb2duaXplcl0sIFtUYXBSZWNvZ25pemVyLCB7XG4gICAgZXZlbnQ6ICdkb3VibGV0YXAnLFxuICAgIHRhcHM6IDJcbiAgfSwgWyd0YXAnXV0sIFtQcmVzc1JlY29nbml6ZXJdXTtcbiAgdmFyIFNUT1AgPSAxO1xuICB2YXIgRk9SQ0VEX1NUT1AgPSAyO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogYWRkL3JlbW92ZSB0aGUgY3NzIHByb3BlcnRpZXMgYXMgZGVmaW5lZCBpbiBtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHNcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICAgIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuXG4gICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3A7XG4gICAgZWFjaChtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHMsIGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgcHJvcCA9IHByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpO1xuXG4gICAgICBpZiAoYWRkKSB7XG4gICAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gPSBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSB8fCBcIlwiO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFhZGQpIHtcbiAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHMgPSB7fTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xuICAgIGdlc3R1cmVFdmVudC5nZXN0dXJlID0gZGF0YTtcbiAgICBkYXRhLnRhcmdldC5kaXNwYXRjaEV2ZW50KGdlc3R1cmVFdmVudCk7XG4gIH1cbiAgLyoqXG4gICogQHByaXZhdGVcbiAgICogTWFuYWdlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuXG5cbiAgdmFyIE1hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5vcHRpb25zID0gYXNzaWduJDEoe30sIGRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgIHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCA9IHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCB8fCBlbGVtZW50O1xuICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgICB0aGlzLnJlY29nbml6ZXJzID0gW107XG4gICAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5pbnB1dCA9IGNyZWF0ZUlucHV0SW5zdGFuY2UodGhpcyk7XG4gICAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gICAgICB0b2dnbGVDc3NQcm9wcyh0aGlzLCB0cnVlKTtcbiAgICAgIGVhY2godGhpcy5vcHRpb25zLnJlY29nbml6ZXJzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgcmVjb2duaXplciA9IF90aGlzLmFkZChuZXcgaXRlbVswXShpdGVtWzFdKSk7XG5cbiAgICAgICAgaXRlbVsyXSAmJiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbVsyXSk7XG4gICAgICAgIGl0ZW1bM10gJiYgcmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShpdGVtWzNdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IE1hbmFnZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldChvcHRpb25zKSB7XG4gICAgICBhc3NpZ24kMSh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpOyAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG5cbiAgICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVpbml0aWFsaXplXG4gICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICAgIHRoaXMuaW5wdXQuaW5pdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAgICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAgICovXG5cblxuICAgIF9wcm90by5zdG9wID0gZnVuY3Rpb24gc3RvcChmb3JjZSkge1xuICAgICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG4gICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuXG5cbiAgICBfcHJvdG8ucmVjb2duaXplID0gZnVuY3Rpb24gcmVjb2duaXplKGlucHV0RGF0YSkge1xuICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG5cbiAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuXG5cbiAgICAgIHRoaXMudG91Y2hBY3Rpb24ucHJldmVudERlZmF1bHRzKGlucHV0RGF0YSk7XG4gICAgICB2YXIgcmVjb2duaXplcjtcbiAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7IC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgLy8gc28gdGhlIHJlY29nbml6ZXIncyBzdGF0ZSBuZWVkcyB0byBiZSBCRUdBTiwgQ0hBTkdFRCwgRU5ERUQgb3IgUkVDT0dOSVpFRFxuICAgICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxuXG4gICAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjsgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxuXG4gICAgICBpZiAoIWN1clJlY29nbml6ZXIgfHwgY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgICBjdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07IC8vIGZpbmQgb3V0IGlmIHdlIGFyZSBhbGxvd2VkIHRyeSB0byByZWNvZ25pemUgdGhlIGlucHV0IGZvciB0aGlzIG9uZS5cbiAgICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgICAvLyAgICAgIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuXG4gICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICggLy8gMVxuICAgICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09PSBjdXJSZWNvZ25pemVyIHx8IC8vIDJcbiAgICAgICAgcmVjb2duaXplci5jYW5SZWNvZ25pemVXaXRoKGN1clJlY29nbml6ZXIpKSkge1xuICAgICAgICAgIC8vIDNcbiAgICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY29nbml6ZXIucmVzZXQoKTtcbiAgICAgICAgfSAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxuICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSByZWNvZ25pemVyLiBidXQgb25seSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYW4gYWN0aXZlIHJlY29nbml6ZXJcblxuXG4gICAgICAgIGlmICghY3VyUmVjb2duaXplciAmJiByZWNvZ25pemVyLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEKSkge1xuICAgICAgICAgIHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgICAgY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XG4gICAgICovXG5cblxuICAgIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQocmVjb2duaXplcikge1xuICAgICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09PSByZWNvZ25pemVyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXJzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGUgYWRkIGEgcmVjb2duaXplciB0byB0aGUgbWFuYWdlclxuICAgICAqIGV4aXN0aW5nIHJlY29nbml6ZXJzIHdpdGggdGhlIHNhbWUgZXZlbnQgbmFtZSB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxNYW5hZ2VyfVxuICAgICAqL1xuXG5cbiAgICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHJlY29nbml6ZXIpIHtcbiAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCBcImFkZFwiLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gLy8gcmVtb3ZlIGV4aXN0aW5nXG5cblxuICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQocmVjb2duaXplci5vcHRpb25zLmV2ZW50KTtcblxuICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nbml6ZXIpO1xuICAgICAgcmVjb2duaXplci5tYW5hZ2VyID0gdGhpcztcbiAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuXG5cbiAgICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHJlY29nbml6ZXIpIHtcbiAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCBcInJlbW92ZVwiLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHRhcmdldFJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTsgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcblxuICAgICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheShyZWNvZ25pemVycywgdGFyZ2V0UmVjb2duaXplcik7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHJlY29nbml6ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogYmluZCBldmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuXG5cbiAgICBfcHJvdG8ub24gPSBmdW5jdGlvbiBvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCB8fCBoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIHVuYmluZCBldmVudCwgbGVhdmUgZW1pdCBibGFuayB0byByZW1vdmUgYWxsIGhhbmRsZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXVxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLm9mZiA9IGZ1bmN0aW9uIG9mZihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlcnNbZXZlbnRdICYmIGhhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaW5BcnJheShoYW5kbGVyc1tldmVudF0sIGhhbmRsZXIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIGVtaXQgZXZlbnQgdG8gdGhlIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG5cblxuICAgIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgZGF0YSkge1xuICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcbiAgICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICAgIH0gLy8gbm8gaGFuZGxlcnMsIHNvIHNraXAgaXQgYWxsXG5cblxuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF0gJiYgdGhpcy5oYW5kbGVyc1tldmVudF0uc2xpY2UoKTtcblxuICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGF0YS50eXBlID0gZXZlbnQ7XG5cbiAgICAgIGRhdGEucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRhdGEuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXG4gICAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICAgKi9cblxuXG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcbiAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWFuYWdlcjtcbiAgfSgpO1xuXG4gIHZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbiAgfTtcbiAgdmFyIFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQnO1xuICB2YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogVG91Y2ggZXZlbnRzIGlucHV0XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBJbnB1dFxuICAgKi9cblxuICB2YXIgU2luZ2xlVG91Y2hJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lucHV0KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoU2luZ2xlVG91Y2hJbnB1dCwgX0lucHV0KTtcblxuICAgIGZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIHZhciBwcm90byA9IFNpbmdsZVRvdWNoSW5wdXQucHJvdG90eXBlO1xuICAgICAgcHJvdG8uZXZUYXJnZXQgPSBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICAgIHByb3RvLmV2V2luID0gU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFM7XG4gICAgICBfdGhpcyA9IF9JbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFNpbmdsZVRvdWNoSW5wdXQucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGV2KSB7XG4gICAgICB2YXIgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07IC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cblxuICAgICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpOyAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXG5cbiAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTaW5nbGVUb3VjaElucHV0O1xuICB9KElucHV0KTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVTaW5nbGVUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbCA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiB3cmFwIGEgbWV0aG9kIHdpdGggYSBkZXByZWNhdGlvbiB3YXJuaW5nIGFuZCBzdGFjayB0cmFjZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyB0aGUgc3VwcGxpZWQgbWV0aG9kLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZShtZXRob2QsIG5hbWUsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZGVwcmVjYXRpb25NZXNzYWdlID0gXCJERVBSRUNBVEVEIE1FVEhPRDogXCIgKyBuYW1lICsgXCJcXG5cIiArIG1lc3NhZ2UgKyBcIiBBVCBcXG5cIjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ2dldC1zdGFjay10cmFjZScpO1xuICAgICAgdmFyIHN0YWNrID0gZSAmJiBlLnN0YWNrID8gZS5zdGFjay5yZXBsYWNlKC9eW15cXChdKz9bXFxuJF0vZ20sICcnKS5yZXBsYWNlKC9eXFxzK2F0XFxzKy9nbSwgJycpLnJlcGxhY2UoL15PYmplY3QuPGFub255bW91cz5cXHMqXFwoL2dtLCAne2Fub255bW91c30oKUAnKSA6ICdVbmtub3duIFN0YWNrIFRyYWNlJztcbiAgICAgIHZhciBsb2cgPSB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUud2FybiB8fCB3aW5kb3cuY29uc29sZS5sb2cpO1xuXG4gICAgICBpZiAobG9nKSB7XG4gICAgICAgIGxvZy5jYWxsKHdpbmRvdy5jb25zb2xlLCBkZXByZWNhdGlvbk1lc3NhZ2UsIHN0YWNrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGV4dGVuZCBvYmplY3QuXG4gICAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlPWZhbHNlXVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gICAqL1xuXG5cbiAgdmFyIGV4dGVuZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgICBpZiAoIW1lcmdlIHx8IG1lcmdlICYmIGRlc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc3Q7XG4gIH0sICdleHRlbmQnLCAnVXNlIGBhc3NpZ25gLicpO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAgICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gICAqL1xuXG4gIHZhciBtZXJnZSQxID0gZGVwcmVjYXRlKGZ1bmN0aW9uIChkZXN0LCBzcmMpIHtcbiAgICByZXR1cm4gZXh0ZW5kKGRlc3QsIHNyYywgdHJ1ZSk7XG4gIH0sICdtZXJnZScsICdVc2UgYGFzc2lnbmAuJyk7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIGJhc2UsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgYmFzZVAgPSBiYXNlLnByb3RvdHlwZTtcbiAgICB2YXIgY2hpbGRQO1xuICAgIGNoaWxkUCA9IGNoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZVApO1xuICAgIGNoaWxkUC5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICAgIGNoaWxkUC5fc3VwZXIgPSBiYXNlUDtcblxuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICBhc3NpZ24kMShjaGlsZFAsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJpbmRGbihmbiwgY29udGV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBib3VuZEZuKCkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cblxuXG4gIHZhciBIYW1tZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIHZhciBIYW1tZXIgPVxuICAgIC8qKlxuICAgICAgKiBAcHJpdmF0ZVxuICAgICAgKiBAY29uc3Qge3N0cmluZ31cbiAgICAgICovXG4gICAgZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgX2V4dGVuZHMoe1xuICAgICAgICByZWNvZ25pemVyczogcHJlc2V0LmNvbmNhdCgpXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfTtcblxuICAgIEhhbW1lci5WRVJTSU9OID0gXCIyLjAuMTctcmNcIjtcbiAgICBIYW1tZXIuRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9BTEw7XG4gICAgSGFtbWVyLkRJUkVDVElPTl9ET1dOID0gRElSRUNUSU9OX0RPV047XG4gICAgSGFtbWVyLkRJUkVDVElPTl9MRUZUID0gRElSRUNUSU9OX0xFRlQ7XG4gICAgSGFtbWVyLkRJUkVDVElPTl9SSUdIVCA9IERJUkVDVElPTl9SSUdIVDtcbiAgICBIYW1tZXIuRElSRUNUSU9OX1VQID0gRElSRUNUSU9OX1VQO1xuICAgIEhhbW1lci5ESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMO1xuICAgIEhhbW1lci5ESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVkVSVElDQUw7XG4gICAgSGFtbWVyLkRJUkVDVElPTl9OT05FID0gRElSRUNUSU9OX05PTkU7XG4gICAgSGFtbWVyLkRJUkVDVElPTl9ET1dOID0gRElSRUNUSU9OX0RPV047XG4gICAgSGFtbWVyLklOUFVUX1NUQVJUID0gSU5QVVRfU1RBUlQ7XG4gICAgSGFtbWVyLklOUFVUX01PVkUgPSBJTlBVVF9NT1ZFO1xuICAgIEhhbW1lci5JTlBVVF9FTkQgPSBJTlBVVF9FTkQ7XG4gICAgSGFtbWVyLklOUFVUX0NBTkNFTCA9IElOUFVUX0NBTkNFTDtcbiAgICBIYW1tZXIuU1RBVEVfUE9TU0lCTEUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICBIYW1tZXIuU1RBVEVfQkVHQU4gPSBTVEFURV9CRUdBTjtcbiAgICBIYW1tZXIuU1RBVEVfQ0hBTkdFRCA9IFNUQVRFX0NIQU5HRUQ7XG4gICAgSGFtbWVyLlNUQVRFX0VOREVEID0gU1RBVEVfRU5ERUQ7XG4gICAgSGFtbWVyLlNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgIEhhbW1lci5TVEFURV9DQU5DRUxMRUQgPSBTVEFURV9DQU5DRUxMRUQ7XG4gICAgSGFtbWVyLlNUQVRFX0ZBSUxFRCA9IFNUQVRFX0ZBSUxFRDtcbiAgICBIYW1tZXIuTWFuYWdlciA9IE1hbmFnZXI7XG4gICAgSGFtbWVyLklucHV0ID0gSW5wdXQ7XG4gICAgSGFtbWVyLlRvdWNoQWN0aW9uID0gVG91Y2hBY3Rpb247XG4gICAgSGFtbWVyLlRvdWNoSW5wdXQgPSBUb3VjaElucHV0O1xuICAgIEhhbW1lci5Nb3VzZUlucHV0ID0gTW91c2VJbnB1dDtcbiAgICBIYW1tZXIuUG9pbnRlckV2ZW50SW5wdXQgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgICBIYW1tZXIuVG91Y2hNb3VzZUlucHV0ID0gVG91Y2hNb3VzZUlucHV0O1xuICAgIEhhbW1lci5TaW5nbGVUb3VjaElucHV0ID0gU2luZ2xlVG91Y2hJbnB1dDtcbiAgICBIYW1tZXIuUmVjb2duaXplciA9IFJlY29nbml6ZXI7XG4gICAgSGFtbWVyLkF0dHJSZWNvZ25pemVyID0gQXR0clJlY29nbml6ZXI7XG4gICAgSGFtbWVyLlRhcCA9IFRhcFJlY29nbml6ZXI7XG4gICAgSGFtbWVyLlBhbiA9IFBhblJlY29nbml6ZXI7XG4gICAgSGFtbWVyLlN3aXBlID0gU3dpcGVSZWNvZ25pemVyO1xuICAgIEhhbW1lci5QaW5jaCA9IFBpbmNoUmVjb2duaXplcjtcbiAgICBIYW1tZXIuUm90YXRlID0gUm90YXRlUmVjb2duaXplcjtcbiAgICBIYW1tZXIuUHJlc3MgPSBQcmVzc1JlY29nbml6ZXI7XG4gICAgSGFtbWVyLm9uID0gYWRkRXZlbnRMaXN0ZW5lcnM7XG4gICAgSGFtbWVyLm9mZiA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzO1xuICAgIEhhbW1lci5lYWNoID0gZWFjaDtcbiAgICBIYW1tZXIubWVyZ2UgPSBtZXJnZSQxO1xuICAgIEhhbW1lci5leHRlbmQgPSBleHRlbmQ7XG4gICAgSGFtbWVyLmJpbmRGbiA9IGJpbmRGbjtcbiAgICBIYW1tZXIuYXNzaWduID0gYXNzaWduJDE7XG4gICAgSGFtbWVyLmluaGVyaXQgPSBpbmhlcml0O1xuICAgIEhhbW1lci5iaW5kRm4gPSBiaW5kRm47XG4gICAgSGFtbWVyLnByZWZpeGVkID0gcHJlZml4ZWQ7XG4gICAgSGFtbWVyLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIEhhbW1lci5pbkFycmF5ID0gaW5BcnJheTtcbiAgICBIYW1tZXIudW5pcXVlQXJyYXkgPSB1bmlxdWVBcnJheTtcbiAgICBIYW1tZXIuc3BsaXRTdHIgPSBzcGxpdFN0cjtcbiAgICBIYW1tZXIuYm9vbE9yRm4gPSBib29sT3JGbjtcbiAgICBIYW1tZXIuaGFzUGFyZW50ID0gaGFzUGFyZW50O1xuICAgIEhhbW1lci5hZGRFdmVudExpc3RlbmVycyA9IGFkZEV2ZW50TGlzdGVuZXJzO1xuICAgIEhhbW1lci5yZW1vdmVFdmVudExpc3RlbmVycyA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzO1xuICAgIEhhbW1lci5kZWZhdWx0cyA9IGFzc2lnbiQxKHt9LCBkZWZhdWx0cywge1xuICAgICAgcHJlc2V0OiBwcmVzZXRcbiAgICB9KTtcbiAgICByZXR1cm4gSGFtbWVyO1xuICB9KCk7IC8vICBzdHlsZSBsb2FkZXIgYnV0IGJ5IHNjcmlwdCB0YWcsIG5vdCBieSB0aGUgbG9hZGVyLlxuICB2YXIgUmVhbEhhbW1lciA9IEhhbW1lcjtcblxuICBmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBzeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoaXNBcnJheSQxKG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQzKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMyhvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0MjE7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQzKG8sIG1pbkxlbik7IHZhciBuID0gc2xpY2UoX2NvbnRleHQyMSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDIxLCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tJDMobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMyhvLCBtaW5MZW4pOyB9XG5cbiAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMyhhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbiAgLyoqXHJcbiAgICogVXNlIHRoaXMgc3ltYm9sIHRvIGRlbGV0ZSBwcm9wZXJpZXMgaW4gZGVlcE9iamVjdEFzc2lnbi5cclxuICAgKi9cblxuICB2YXIgREVMRVRFID0gc3ltYm9sKFwiREVMRVRFXCIpO1xuICAvKipcclxuICAgKiBQdXJlIHZlcnNpb24gb2YgZGVlcE9iamVjdEFzc2lnbiwgaXQgZG9lc24ndCBtb2RpZnkgYW55IG9mIGl0J3MgYXJndW1lbnRzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGJhc2UgLSBUaGUgYmFzZSBvYmplY3QgdGhhdCBmdWxsZmlscyB0aGUgd2hvbGUgaW50ZXJmYWNlIFQuXHJcbiAgICogQHBhcmFtIHVwZGF0ZXMgLSBVcGRhdGVzIHRoYXQgbWF5IGNoYW5nZSBvciBkZWxldGUgcHJvcHMuXHJcbiAgICogQHJldHVybnMgQSBicmFuZCBuZXcgaW5zdGFuY2Ugd2l0aCBhbGwgdGhlIHN1cHBsaWVkIG9iamVjdHMgZGVlcGx5IG1lcmdlZC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHB1cmVEZWVwT2JqZWN0QXNzaWduKGJhc2UpIHtcbiAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdXBkYXRlcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICB1cGRhdGVzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVlcE9iamVjdEFzc2lnbi5hcHBseSh2b2lkIDAsIGNvbmNhdCQxKF9jb250ZXh0ID0gW3t9LCBiYXNlXSkuY2FsbChfY29udGV4dCwgdXBkYXRlcykpO1xuICB9XG4gIC8qKlxyXG4gICAqIERlZXAgdmVyc2lvbiBvZiBvYmplY3QgYXNzaWduIHdpdGggYWRkaXRpb25hbCBkZWxldGluZyBieSB0aGUgREVMRVRFIHN5bWJvbC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YWx1ZXMgLSBPYmplY3RzIHRvIGJlIGRlZXBseSBtZXJnZWQuXHJcbiAgICogQHJldHVybnMgVGhlIGZpcnN0IG9iamVjdCBmcm9tIHZhbHVlcy5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGRlZXBPYmplY3RBc3NpZ24oKSB7XG4gICAgdmFyIG1lcmdlZCA9IGRlZXBPYmplY3RBc3NpZ25Ob25lbnRyeS5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgc3RyaXBEZWxldGUobWVyZ2VkKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9XG4gIC8qKlxyXG4gICAqIERlZXAgdmVyc2lvbiBvZiBvYmplY3QgYXNzaWduIHdpdGggYWRkaXRpb25hbCBkZWxldGluZyBieSB0aGUgREVMRVRFIHN5bWJvbC5cclxuICAgKlxyXG4gICAqIEByZW1hcmtzXHJcbiAgICogVGhpcyBkb2Vzbid0IHN0cmlwIHRoZSBERUxFVEUgc3ltYm9scyBzbyB0aGV5IG1heSBlbmQgdXAgaW4gdGhlIGZpbmFsIG9iamVjdC5cclxuICAgKiBAcGFyYW0gdmFsdWVzIC0gT2JqZWN0cyB0byBiZSBkZWVwbHkgbWVyZ2VkLlxyXG4gICAqIEByZXR1cm5zIFRoZSBmaXJzdCBvYmplY3QgZnJvbSB2YWx1ZXMuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBkZWVwT2JqZWN0QXNzaWduTm9uZW50cnkoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIHZhbHVlc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHZhbHVlc1swXTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPiAyKSB7XG4gICAgICB2YXIgX2NvbnRleHQyO1xuXG4gICAgICByZXR1cm4gZGVlcE9iamVjdEFzc2lnbk5vbmVudHJ5LmFwcGx5KHZvaWQgMCwgY29uY2F0JDEoX2NvbnRleHQyID0gW2RlZXBPYmplY3RBc3NpZ24odmFsdWVzWzBdLCB2YWx1ZXNbMV0pXSkuY2FsbChfY29udGV4dDIsIF90b0NvbnN1bWFibGVBcnJheShzbGljZSh2YWx1ZXMpLmNhbGwodmFsdWVzLCAyKSkpKTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IHZhbHVlc1swXTtcbiAgICB2YXIgYiA9IHZhbHVlc1sxXTtcblxuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKG93bktleXMkMShiKSksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBwcm9wID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGIsIHByb3ApKSA7ZWxzZSBpZiAoYltwcm9wXSA9PT0gREVMRVRFKSB7XG4gICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgIH0gZWxzZSBpZiAoYVtwcm9wXSAhPT0gbnVsbCAmJiBiW3Byb3BdICE9PSBudWxsICYmIF90eXBlb2YoYVtwcm9wXSkgPT09IFwib2JqZWN0XCIgJiYgX3R5cGVvZihiW3Byb3BdKSA9PT0gXCJvYmplY3RcIiAmJiAhaXNBcnJheSQxKGFbcHJvcF0pICYmICFpc0FycmF5JDEoYltwcm9wXSkpIHtcbiAgICAgICAgICBhW3Byb3BdID0gZGVlcE9iamVjdEFzc2lnbk5vbmVudHJ5KGFbcHJvcF0sIGJbcHJvcF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFbcHJvcF0gPSBjbG9uZShiW3Byb3BdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfVxuICAvKipcclxuICAgKiBEZWVwIGNsb25lIGdpdmVuIG9iamVjdCBvciBhcnJheS4gSW4gY2FzZSBvZiBwcmltaXRpdmUgc2ltcGx5IHJldHVybi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBhIC0gQW55dGhpbmcuXHJcbiAgICogQHJldHVybnMgRGVlcCBjbG9uZWQgb2JqZWN0L2FycmF5IG9yIHVuY2hhbmdlZCBhLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIGlmIChpc0FycmF5JDEoYSkpIHtcbiAgICAgIHJldHVybiBtYXAkMyhhKS5jYWxsKGEsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2xvbmUodmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKGEpID09PSBcIm9iamVjdFwiICYmIGEgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBkZWVwT2JqZWN0QXNzaWduTm9uZW50cnkoe30sIGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogU3RyaXAgREVMRVRFIGZyb20gZ2l2ZW4gb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGEgLSBPYmplY3Qgd2hpY2ggbWF5IGNvbnRhaW4gREVMRVRFIGJ1dCB3b24ndCBhZnRlciB0aGlzIGlzIGV4ZWN1dGVkLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc3RyaXBEZWxldGUoYSkge1xuICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0ga2V5cyQ0KGEpOyBfaSA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBwcm9wID0gX09iamVjdCRrZXlzW19pXTtcblxuICAgICAgaWYgKGFbcHJvcF0gPT09IERFTEVURSkge1xuICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihhW3Byb3BdKSA9PT0gXCJvYmplY3RcIiAmJiBhW3Byb3BdICE9PSBudWxsKSB7XG4gICAgICAgIHN0cmlwRGVsZXRlKGFbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0dXAgYSBtb2NrIGhhbW1lci5qcyBvYmplY3QsIGZvciB1bml0IHRlc3RpbmcuXG4gICAqXG4gICAqIEluc3BpcmF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vdWJlci9kZWNrLmdsL3B1bGwvNjU4XG4gICAqXG4gICAqIEByZXR1cm5zIHt7b246IG5vb3AsIG9mZjogbm9vcCwgZGVzdHJveTogbm9vcCwgZW1pdDogbm9vcCwgZ2V0OiBnZXR9fVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGhhbW1lck1vY2soKSB7XG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbiAgICByZXR1cm4ge1xuICAgICAgb246IG5vb3AsXG4gICAgICBvZmY6IG5vb3AsXG4gICAgICBkZXN0cm95OiBub29wLFxuICAgICAgZW1pdDogbm9vcCxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNldDogbm9vcFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgSGFtbWVyJDEgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LkhhbW1lciB8fCBSZWFsSGFtbWVyIDogZnVuY3Rpb24gKCkge1xuICAgIC8vIGhhbW1lci5qcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBhIGJyb3dzZXIsIG5vdCBpbiBub2RlLmpzLiBSZXBsYWNpbmcgaXQgd2l0aCBhIG1vY2sgb2JqZWN0LlxuICAgIHJldHVybiBoYW1tZXJNb2NrKCk7XG4gIH07XG4gIC8qKlxuICAgKiBUdXJuIGFuIGVsZW1lbnQgaW50byBhbiBjbGlja1RvVXNlIGVsZW1lbnQuXG4gICAqIFdoZW4gbm90IGFjdGl2ZSwgdGhlIGVsZW1lbnQgaGFzIGEgdHJhbnNwYXJlbnQgb3ZlcmxheS4gV2hlbiB0aGUgb3ZlcmxheSBpc1xuICAgKiBjbGlja2VkLCB0aGUgbW9kZSBpcyBjaGFuZ2VkIHRvIGFjdGl2ZS5cbiAgICogV2hlbiBhY3RpdmUsIHRoZSBlbGVtZW50IGlzIGRpc3BsYXllZCB3aXRoIGEgYmx1ZSBib3JkZXIgYXJvdW5kIGl0LCBhbmRcbiAgICogdGhlIGludGVyYWN0aXZlIGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50IGNhbiBiZSB1c2VkLiBXaGVuIGNsaWNrZWQgb3V0c2lkZVxuICAgKiB0aGUgZWxlbWVudCwgdGhlIGVsZW1lbnRzIG1vZGUgaXMgY2hhbmdlZCB0byBpbmFjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcbiAgICogQGNsYXNzIEFjdGl2YXRvclxuICAgKi9cblxuICBmdW5jdGlvbiBBY3RpdmF0b3IkMShjb250YWluZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBfY29udGV4dDM7XG5cbiAgICB0aGlzLl9jbGVhbnVwUXVldWUgPSBbXTtcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuX2RvbSA9IHtcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgb3ZlcmxheTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgIH07XG5cbiAgICB0aGlzLl9kb20ub3ZlcmxheS5jbGFzc0xpc3QuYWRkKFwidmlzLW92ZXJsYXlcIik7XG5cbiAgICB0aGlzLl9kb20uY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2RvbS5vdmVybGF5KTtcblxuICAgIHRoaXMuX2NsZWFudXBRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9kb20ub3ZlcmxheS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF90aGlzLl9kb20ub3ZlcmxheSk7XG4gICAgfSk7XG5cbiAgICB2YXIgaGFtbWVyID0gSGFtbWVyJDEodGhpcy5fZG9tLm92ZXJsYXkpO1xuICAgIGhhbW1lci5vbihcInRhcFwiLCBiaW5kJDYoX2NvbnRleHQzID0gdGhpcy5fb25UYXBPdmVybGF5KS5jYWxsKF9jb250ZXh0MywgdGhpcykpO1xuXG4gICAgdGhpcy5fY2xlYW51cFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaGFtbWVyLmRlc3Ryb3koKTsgLy8gRklYTUU6IGNsZWFuaW5nIHVwIGhhbW1lciBpbnN0YW5jZXMgZG9lc24ndCB3b3JrIChUaW1lbGluZSBub3QgcmVtb3ZlZFxuICAgICAgLy8gZnJvbSBtZW1vcnkpXG4gICAgfSk7IC8vIGJsb2NrIGFsbCB0b3VjaCBldmVudHMgKGV4Y2VwdCB0YXApXG5cblxuICAgIHZhciBldmVudHMgPSBbXCJ0YXBcIiwgXCJkb3VibGV0YXBcIiwgXCJwcmVzc1wiLCBcInBpbmNoXCIsIFwicGFuXCIsIFwicGFuc3RhcnRcIiwgXCJwYW5tb3ZlXCIsIFwicGFuZW5kXCJdO1xuXG4gICAgZm9yRWFjaCQxKGV2ZW50cykuY2FsbChldmVudHMsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaGFtbWVyLm9uKGV2ZW50LCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICB9KTsgLy8gYXR0YWNoIGEgY2xpY2sgZXZlbnQgdG8gdGhlIHdpbmRvdywgaW4gb3JkZXIgdG8gZGVhY3RpdmF0ZSB3aGVuIGNsaWNraW5nIG91dHNpZGUgdGhlIHRpbWVsaW5lXG5cblxuICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgICB0aGlzLl9vbkNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghX2hhc1BhcmVudChldmVudC50YXJnZXQsIGNvbnRhaW5lcikpIHtcbiAgICAgICAgICBfdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29uQ2xpY2spO1xuXG4gICAgICB0aGlzLl9jbGVhbnVwUXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIF90aGlzLl9vbkNsaWNrKTtcbiAgICAgIH0pO1xuICAgIH0gLy8gcHJlcGFyZSBlc2NhcGUga2V5IGxpc3RlbmVyIGZvciBkZWFjdGl2YXRpbmcgd2hlbiBhY3RpdmVcblxuXG4gICAgdGhpcy5fZXNjTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChcImtleVwiIGluIGV2ZW50ID8gZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiIDogZXZlbnQua2V5Q29kZSA9PT0gMjdcbiAgICAgIC8qIHRoZSBrZXlDb2RlIGlzIGZvciBJRTExICovXG4gICAgICApIHtcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0gLy8gdHVybiBpbnRvIGFuIGV2ZW50IGVtaXR0ZXJcblxuXG4gIEVtaXR0ZXIoQWN0aXZhdG9yJDEucHJvdG90eXBlKTsgLy8gVGhlIGN1cnJlbnRseSBhY3RpdmUgYWN0aXZhdG9yXG5cbiAgQWN0aXZhdG9yJDEuY3VycmVudCA9IG51bGw7XG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBhY3RpdmF0b3IuIENsZWFucyB1cCBhbGwgY3JlYXRlZCBET00gYW5kIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cblxuICBBY3RpdmF0b3IkMS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2NvbnRleHQ0LCBfY29udGV4dDU7XG5cbiAgICB0aGlzLmRlYWN0aXZhdGUoKTtcblxuICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyhyZXZlcnNlKF9jb250ZXh0NCA9IHNwbGljZShfY29udGV4dDUgPSB0aGlzLl9jbGVhbnVwUXVldWUpLmNhbGwoX2NvbnRleHQ1LCAwKSkuY2FsbChfY29udGV4dDQpKSxcbiAgICAgICAgX3N0ZXAyO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBBY3RpdmF0ZSB0aGUgZWxlbWVudFxuICAgKiBPdmVybGF5IGlzIGhpZGRlbiwgZWxlbWVudCBpcyBkZWNvcmF0ZWQgd2l0aCBhIGJsdWUgc2hhZG93IGJvcmRlclxuICAgKi9cblxuXG4gIEFjdGl2YXRvciQxLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB3ZSBhbGxvdyBvbmx5IG9uZSBhY3RpdmUgYWN0aXZhdG9yIGF0IGEgdGltZVxuICAgIGlmIChBY3RpdmF0b3IkMS5jdXJyZW50KSB7XG4gICAgICBBY3RpdmF0b3IkMS5jdXJyZW50LmRlYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBBY3RpdmF0b3IkMS5jdXJyZW50ID0gdGhpcztcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5fZG9tLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG4gICAgdGhpcy5fZG9tLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidmlzLWFjdGl2ZVwiKTtcblxuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgICB0aGlzLmVtaXQoXCJhY3RpdmF0ZVwiKTsgLy8gdWdseSBoYWNrOiBiaW5kIEVTQyBhZnRlciBlbWl0dGluZyB0aGUgZXZlbnRzLCBhcyB0aGUgTmV0d29yayByZWJpbmRzIGFsbFxuICAgIC8vIGtleWJvYXJkIGV2ZW50cyBvbiBhICdjaGFuZ2UnIGV2ZW50XG5cbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2VzY0xpc3RlbmVyKTtcbiAgfTtcbiAgLyoqXG4gICAqIERlYWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAgICogT3ZlcmxheSBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIHRoZSBlbGVtZW50XG4gICAqL1xuXG5cbiAgQWN0aXZhdG9yJDEucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9kb20ub3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gICAgdGhpcy5fZG9tLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwidmlzLWFjdGl2ZVwiKTtcblxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fZXNjTGlzdGVuZXIpO1xuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgICB0aGlzLmVtaXQoXCJkZWFjdGl2YXRlXCIpO1xuICB9O1xuICAvKipcbiAgICogSGFuZGxlIGEgdGFwIGV2ZW50OiBhY3RpdmF0ZSB0aGUgY29udGFpbmVyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIEFjdGl2YXRvciQxLnByb3RvdHlwZS5fb25UYXBPdmVybGF5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYWN0aXZhdGUgdGhlIGNvbnRhaW5lclxuICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICBldmVudC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciB0aGUgZWxlbWVudCBoYXMgdGhlIHJlcXVlc3RlZCBwYXJlbnQgZWxlbWVudCBzb21ld2hlcmUgaW5cbiAgICogaXRzIGNoYWluIG9mIHBhcmVudCBub2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBwYXJlbnQgaXMgZm91bmQgc29tZXdoZXJlIGluIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgY2hhaW4gb2YgcGFyZW50IG5vZGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIF9oYXNQYXJlbnQoZWxlbWVudCwgcGFyZW50KSB7XG4gICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIHV0aWxpdHkgZnVuY3Rpb25zXG5cbiAgdmFyIGdsb2JhbCQ0ID0gZ2xvYmFsJE07XG4gIHZhciBpc0NvbnN0cnVjdG9yID0gaXNDb25zdHJ1Y3RvciQ0O1xuICB2YXIgdHJ5VG9TdHJpbmckMSA9IHRyeVRvU3RyaW5nJDQ7XG4gIHZhciBUeXBlRXJyb3IkMyA9IGdsb2JhbCQ0LlR5cGVFcnJvcjsgLy8gYEFzc2VydDogSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkgaXMgdHJ1ZWBcblxuICB2YXIgYUNvbnN0cnVjdG9yJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICBpZiAoaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgICB0aHJvdyBUeXBlRXJyb3IkMyh0cnlUb1N0cmluZyQxKGFyZ3VtZW50KSArICcgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgfTtcblxuICB2YXIgJCQ1ID0gX2V4cG9ydDtcbiAgdmFyIGdldEJ1aWx0SW4kMSA9IGdldEJ1aWx0SW4kOTtcbiAgdmFyIGFwcGx5ID0gZnVuY3Rpb25BcHBseTtcbiAgdmFyIGJpbmQkMiA9IGZ1bmN0aW9uQmluZDtcbiAgdmFyIGFDb25zdHJ1Y3RvciA9IGFDb25zdHJ1Y3RvciQxO1xuICB2YXIgYW5PYmplY3QkMSA9IGFuT2JqZWN0JGI7XG4gIHZhciBpc09iamVjdCQzID0gaXNPYmplY3QkZjtcbiAgdmFyIGNyZWF0ZSQ0ID0gb2JqZWN0Q3JlYXRlO1xuICB2YXIgZmFpbHMkNSA9IGZhaWxzJHI7XG4gIHZhciBuYXRpdmVDb25zdHJ1Y3QgPSBnZXRCdWlsdEluJDEoJ1JlZmxlY3QnLCAnY29uc3RydWN0Jyk7XG4gIHZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgcHVzaCQxID0gW10ucHVzaDsgLy8gYFJlZmxlY3QuY29uc3RydWN0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWZsZWN0LmNvbnN0cnVjdFxuICAvLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbiAgLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxuXG4gIHZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzJDUoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEYoKSB7XG4gICAgICAvKiBlbXB0eSAqL1xuICAgIH1cblxuICAgIHJldHVybiAhKG5hdGl2ZUNvbnN0cnVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAvKiBlbXB0eSAqL1xuICAgIH0sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xuICB9KTtcbiAgdmFyIEFSR1NfQlVHID0gIWZhaWxzJDUoZnVuY3Rpb24gKCkge1xuICAgIG5hdGl2ZUNvbnN0cnVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAvKiBlbXB0eSAqL1xuICAgIH0pO1xuICB9KTtcbiAgdmFyIEZPUkNFRCQxID0gTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUc7XG4gICQkNSh7XG4gICAgdGFyZ2V0OiAnUmVmbGVjdCcsXG4gICAgc3RhdDogdHJ1ZSxcbiAgICBmb3JjZWQ6IEZPUkNFRCQxLFxuICAgIHNoYW06IEZPUkNFRCQxXG4gIH0sIHtcbiAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChUYXJnZXQsIGFyZ3NcbiAgICAvKiAsIG5ld1RhcmdldCAqL1xuICAgICkge1xuICAgICAgYUNvbnN0cnVjdG9yKFRhcmdldCk7XG4gICAgICBhbk9iamVjdCQxKGFyZ3MpO1xuICAgICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUNvbnN0cnVjdG9yKGFyZ3VtZW50c1syXSk7XG4gICAgICBpZiAoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKSByZXR1cm4gbmF0aXZlQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcblxuICAgICAgaWYgKFRhcmdldCA9PSBuZXdUYXJnZXQpIHtcbiAgICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KCk7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgfSAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIGxvdCBvZiBhcmd1bWVudHMgY2FzZVxuXG5cbiAgICAgICAgdmFyICRhcmdzID0gW251bGxdO1xuICAgICAgICBhcHBseShwdXNoJDEsICRhcmdzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIG5ldyAoYXBwbHkoYmluZCQyLCBUYXJnZXQsICRhcmdzKSkoKTtcbiAgICAgIH0gLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG5cblxuICAgICAgdmFyIHByb3RvID0gbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZSQ0KGlzT2JqZWN0JDMocHJvdG8pID8gcHJvdG8gOiBPYmplY3RQcm90b3R5cGUpO1xuICAgICAgdmFyIHJlc3VsdCA9IGFwcGx5KFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgcmV0dXJuIGlzT2JqZWN0JDMocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHBhdGgkMyA9IHBhdGgkcTtcbiAgdmFyIGNvbnN0cnVjdCQyID0gcGF0aCQzLlJlZmxlY3QuY29uc3RydWN0O1xuXG4gIHZhciBwYXJlbnQkaCA9IGNvbnN0cnVjdCQyO1xuICB2YXIgY29uc3RydWN0JDEgPSBwYXJlbnQkaDtcblxuICB2YXIgY29uc3RydWN0ID0gY29uc3RydWN0JDE7XG5cbiAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgdmFyIHBhcmVudCRnID0gY3JlYXRlJDY7XG4gIHZhciBjcmVhdGUkMyA9IHBhcmVudCRnO1xuXG4gIHZhciBwYXJlbnQkZiA9IGNyZWF0ZSQzO1xuICB2YXIgY3JlYXRlJDIgPSBwYXJlbnQkZjtcblxuICB2YXIgY3JlYXRlJDEgPSBjcmVhdGUkMjtcblxuICB2YXIgJCQ0ID0gX2V4cG9ydDtcbiAgdmFyIHNldFByb3RvdHlwZU9mJDUgPSBvYmplY3RTZXRQcm90b3R5cGVPZjsgLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG5cbiAgJCQ0KHtcbiAgICB0YXJnZXQ6ICdPYmplY3QnLFxuICAgIHN0YXQ6IHRydWVcbiAgfSwge1xuICAgIHNldFByb3RvdHlwZU9mOiBzZXRQcm90b3R5cGVPZiQ1XG4gIH0pO1xuXG4gIHZhciBwYXRoJDIgPSBwYXRoJHE7XG4gIHZhciBzZXRQcm90b3R5cGVPZiQ0ID0gcGF0aCQyLk9iamVjdC5zZXRQcm90b3R5cGVPZjtcblxuICB2YXIgcGFyZW50JGUgPSBzZXRQcm90b3R5cGVPZiQ0O1xuICB2YXIgc2V0UHJvdG90eXBlT2YkMyA9IHBhcmVudCRlO1xuXG4gIHZhciBwYXJlbnQkZCA9IHNldFByb3RvdHlwZU9mJDM7XG4gIHZhciBzZXRQcm90b3R5cGVPZiQyID0gcGFyZW50JGQ7XG5cbiAgdmFyIHBhcmVudCRjID0gc2V0UHJvdG90eXBlT2YkMjtcbiAgdmFyIHNldFByb3RvdHlwZU9mJDEgPSBwYXJlbnQkYztcblxuICB2YXIgc2V0UHJvdG90eXBlT2YgPSBzZXRQcm90b3R5cGVPZiQxO1xuXG4gIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgIHJldHVybiBvO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IGNyZWF0ZSQxKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGVmaW5lUHJvcGVydHkkNyhzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbiAgfVxuXG4gIHZhciBwYXJlbnQkYiA9IGdldFByb3RvdHlwZU9mJDM7XG4gIHZhciBnZXRQcm90b3R5cGVPZiQyID0gcGFyZW50JGI7XG5cbiAgdmFyIHBhcmVudCRhID0gZ2V0UHJvdG90eXBlT2YkMjtcbiAgdmFyIGdldFByb3RvdHlwZU9mJDEgPSBwYXJlbnQkYTtcblxuICB2YXIgZ2V0UHJvdG90eXBlT2YgPSBnZXRQcm90b3R5cGVPZiQxO1xuXG4gIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gc2V0UHJvdG90eXBlT2YgPyBnZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xuICB9XG5cbiAgdmFyIHJ1bnRpbWUgPSB7ZXhwb3J0czoge319O1xuXG4gIC8qKlxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAgICpcbiAgICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gICAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAgICovXG5cbiAgKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICB2YXIgcnVudGltZSA9IGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgICAgIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gICAgICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gICAgICB2YXIgdW5kZWZpbmVkJDE7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuXG4gICAgICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICAgICAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgICAgIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gICAgICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gICAgICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgICAgICBkZWZpbmUoe30sIFwiXCIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGRlZmluZSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgICAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICAgICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pOyAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cblxuICAgICAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBnZW5lcmF0b3I7XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydHMud3JhcCA9IHdyYXA7IC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAgICAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gICAgICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgICAgIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgICAgIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgICAgIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgICAgIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gICAgICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgICAgIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgICAgIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cblxuICAgICAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICBhcmc6IGZuLmNhbGwob2JqLCBhcmcpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwidGhyb3dcIixcbiAgICAgICAgICAgIGFyZzogZXJyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgICAgIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICAgICAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgICAgIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7IC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgICAgIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cblxuICAgICAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gICAgICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgICAgIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gICAgICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuXG4gICAgICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuXG4gICAgICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG5cbiAgICAgIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge30gLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAgICAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cblxuXG4gICAgICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgICAgIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KTtcbiAgICAgIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgICAgIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcblxuICAgICAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICAgICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgICAgIH1cblxuICAgICAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoR3AsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgICAgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKTtcbiAgICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTsgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgICAgIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG5cbiAgICAgIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICAgICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIGN0b3IgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiIDogZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgICAgICByZXR1cm4gZ2VuRnVuO1xuICAgICAgfTsgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gICAgICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAgICAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAgICAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cblxuXG4gICAgICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIF9fYXdhaXQ6IGFyZ1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHtcbiAgICAgICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICAgICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPSAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgICAgIH0gLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAgICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG5cblxuICAgICAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICAgICAgfVxuXG4gICAgICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICAgICAgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSk7XG4gICAgICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yOyAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gICAgICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgICAgIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuXG4gICAgICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgICAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuICAgICAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICAgIH0gLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcblxuXG4gICAgICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG5cbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG4gICAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBHZW5TdGF0ZUNvbXBsZXRlZCA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDsgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuXG4gICAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgICAgIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgICAgIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAgICAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG5cblxuICAgICAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuXG4gICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCQxKSB7XG4gICAgICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTsgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuXG4gICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYzsgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgIH0gLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAgICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cblxuXG4gICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH0gLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgICAgIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cblxuXG4gICAgICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuICAgICAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7IC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gICAgICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAgICAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgICAgIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICAgIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KTtcbiAgICAgIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgICB0cnlMb2M6IGxvY3NbMF1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgICAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICAgICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgICAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAgICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgICAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgICAgIHRoaXMudHJ5RW50cmllcyA9IFt7XG4gICAgICAgICAgdHJ5TG9jOiBcInJvb3RcIlxuICAgICAgICB9XTtcbiAgICAgICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgICAgICB0aGlzLnJlc2V0KHRydWUpO1xuICAgICAgfVxuXG4gICAgICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIHZhciBrZXlzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5yZXZlcnNlKCk7IC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cblxuXG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgICAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG5cbiAgICAgICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG5cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5leHQ6IGRvbmVSZXN1bHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgICAgIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCQxLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuICAgICAgICByZXNldDogZnVuY3Rpb24gKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgICAgIHRoaXMubmV4dCA9IDA7IC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cblxuICAgICAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFicnVwdDogZnVuY3Rpb24gKHR5cGUsIGFyZykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJiAodHlwZSA9PT0gXCJicmVha1wiIHx8IHR5cGUgPT09IFwiY29udGludWVcIikgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uIChyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHwgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9LFxuICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uIChmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJjYXRjaFwiOiBmdW5jdGlvbiAodHJ5TG9jKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG5cblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH07IC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgICAgIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAgICAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gICAgICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuXG4gICAgICByZXR1cm4gZXhwb3J0cztcbiAgICB9KCAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAgIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gICAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAgIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gICAgbW9kdWxlLmV4cG9ydHMgKTtcblxuICAgIHRyeSB7XG4gICAgICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICAgIH0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gICAgICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAgICAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gICAgICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIGluIG1vZGVybiBlbmdpbmVzXG4gICAgICAvLyB3ZSBjYW4gZXhwbGljaXRseSBhY2Nlc3MgZ2xvYmFsVGhpcy4gSW4gb2xkZXIgZW5naW5lcyB3ZSBjYW4gZXNjYXBlXG4gICAgICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgICAgIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAgICAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgICAgIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gICAgICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgICAgIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGdsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9KShydW50aW1lKTtcblxuICB2YXIgcmVnZW5lcmF0b3IgPSBydW50aW1lLmV4cG9ydHM7XG5cbiAgdmFyIGludGVybmFsTWV0YWRhdGEgPSB7ZXhwb3J0czoge319O1xuXG4gIHZhciBmYWlscyQ0ID0gZmFpbHMkcjtcbiAgdmFyIGFycmF5QnVmZmVyTm9uRXh0ZW5zaWJsZSA9IGZhaWxzJDQoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig4KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1pc2V4dGVuc2libGUsIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG5cbiAgICAgIGlmIChPYmplY3QuaXNFeHRlbnNpYmxlKGJ1ZmZlcikpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShidWZmZXIsICdhJywge1xuICAgICAgICB2YWx1ZTogOFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZmFpbHMkMyA9IGZhaWxzJHI7XG4gIHZhciBpc09iamVjdCQyID0gaXNPYmplY3QkZjtcbiAgdmFyIGNsYXNzb2YkMyA9IGNsYXNzb2ZSYXckMTtcbiAgdmFyIEFSUkFZX0JVRkZFUl9OT05fRVhURU5TSUJMRSA9IGFycmF5QnVmZmVyTm9uRXh0ZW5zaWJsZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1pc2V4dGVuc2libGUgLS0gc2FmZVxuXG4gIHZhciAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbiAgdmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgICAkaXNFeHRlbnNpYmxlKDEpO1xuICB9KTsgLy8gYE9iamVjdC5pc0V4dGVuc2libGVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5pc2V4dGVuc2libGVcblxuICB2YXIgb2JqZWN0SXNFeHRlbnNpYmxlID0gRkFJTFNfT05fUFJJTUlUSVZFUyB8fCBBUlJBWV9CVUZGRVJfTk9OX0VYVEVOU0lCTEUgPyBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpIHtcbiAgICBpZiAoIWlzT2JqZWN0JDIoaXQpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKEFSUkFZX0JVRkZFUl9OT05fRVhURU5TSUJMRSAmJiBjbGFzc29mJDMoaXQpID09ICdBcnJheUJ1ZmZlcicpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZTtcbiAgfSA6ICRpc0V4dGVuc2libGU7XG5cbiAgdmFyIGZhaWxzJDIgPSBmYWlscyRyO1xuICB2YXIgZnJlZXppbmcgPSAhZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1pc2V4dGVuc2libGUsIGVzL25vLW9iamVjdC1wcmV2ZW50ZXh0ZW5zaW9ucyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIHJldHVybiBPYmplY3QuaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xuICB9KTtcblxuICB2YXIgJCQzID0gX2V4cG9ydDtcbiAgdmFyIHVuY3VycnlUaGlzJDEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgaGlkZGVuS2V5cyA9IGhpZGRlbktleXMkNjtcbiAgdmFyIGlzT2JqZWN0JDEgPSBpc09iamVjdCRmO1xuICB2YXIgaGFzT3duJDMgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuICB2YXIgZGVmaW5lUHJvcGVydHkkMiA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcztcbiAgdmFyIGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbE1vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbDtcbiAgdmFyIGlzRXh0ZW5zaWJsZSA9IG9iamVjdElzRXh0ZW5zaWJsZTtcbiAgdmFyIHVpZCA9IHVpZCQ0O1xuICB2YXIgRlJFRVpJTkcgPSBmcmVlemluZztcbiAgdmFyIFJFUVVJUkVEID0gZmFsc2U7XG4gIHZhciBNRVRBREFUQSA9IHVpZCgnbWV0YScpO1xuICB2YXIgaWQgPSAwO1xuXG4gIHZhciBzZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIGRlZmluZVByb3BlcnR5JDIoaXQsIE1FVEFEQVRBLCB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBvYmplY3RJRDogJ08nICsgaWQrKyxcbiAgICAgICAgLy8gb2JqZWN0IElEXG4gICAgICAgIHdlYWtEYXRhOiB7fSAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGZhc3RLZXkkMSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gICAgLy8gcmV0dXJuIGEgcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gICAgaWYgKCFpc09iamVjdCQxKGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcblxuICAgIGlmICghaGFzT3duJDMoaXQsIE1FVEFEQVRBKSkge1xuICAgICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJzsgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcblxuICAgICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7IC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG5cbiAgICAgIHNldE1ldGFkYXRhKGl0KTsgLy8gcmV0dXJuIG9iamVjdCBJRFxuICAgIH1cblxuICAgIHJldHVybiBpdFtNRVRBREFUQV0ub2JqZWN0SUQ7XG4gIH07XG5cbiAgdmFyIGdldFdlYWtEYXRhID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgICBpZiAoIWhhc093biQzKGl0LCBNRVRBREFUQSkpIHtcbiAgICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlOyAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuXG4gICAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlOyAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuXG4gICAgICBzZXRNZXRhZGF0YShpdCk7IC8vIHJldHVybiB0aGUgc3RvcmUgb2Ygd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgICB9XG5cbiAgICByZXR1cm4gaXRbTUVUQURBVEFdLndlYWtEYXRhO1xuICB9OyAvLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcblxuXG4gIHZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIGlmIChGUkVFWklORyAmJiBSRVFVSVJFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXNPd24kMyhpdCwgTUVUQURBVEEpKSBzZXRNZXRhZGF0YShpdCk7XG4gICAgcmV0dXJuIGl0O1xuICB9O1xuXG4gIHZhciBlbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbWV0YS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKiBlbXB0eSAqL1xuICAgIH07XG5cbiAgICBSRVFVSVJFRCA9IHRydWU7XG4gICAgdmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmY7XG4gICAgdmFyIHNwbGljZSA9IHVuY3VycnlUaGlzJDEoW10uc3BsaWNlKTtcbiAgICB2YXIgdGVzdCA9IHt9O1xuICAgIHRlc3RbTUVUQURBVEFdID0gMTsgLy8gcHJldmVudCBleHBvc2luZyBvZiBtZXRhZGF0YSBrZXlcblxuICAgIGlmIChnZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QpLmxlbmd0aCkge1xuICAgICAgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdFtpXSA9PT0gTUVUQURBVEEpIHtcbiAgICAgICAgICAgIHNwbGljZShyZXN1bHQsIGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgICQkMyh7XG4gICAgICAgIHRhcmdldDogJ09iamVjdCcsXG4gICAgICAgIHN0YXQ6IHRydWUsXG4gICAgICAgIGZvcmNlZDogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWxNb2R1bGUuZlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBtZXRhID0gaW50ZXJuYWxNZXRhZGF0YS5leHBvcnRzID0ge1xuICAgIGVuYWJsZTogZW5hYmxlLFxuICAgIGZhc3RLZXk6IGZhc3RLZXkkMSxcbiAgICBnZXRXZWFrRGF0YTogZ2V0V2Vha0RhdGEsXG4gICAgb25GcmVlemU6IG9uRnJlZXplXG4gIH07XG4gIGhpZGRlbktleXNbTUVUQURBVEFdID0gdHJ1ZTtcblxuICB2YXIgZ2xvYmFsJDMgPSBnbG9iYWwkTTtcbiAgdmFyIGJpbmQkMSA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG4gIHZhciBjYWxsID0gZnVuY3Rpb25DYWxsO1xuICB2YXIgYW5PYmplY3QgPSBhbk9iamVjdCRiO1xuICB2YXIgdHJ5VG9TdHJpbmcgPSB0cnlUb1N0cmluZyQ0O1xuICB2YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDI7XG4gIHZhciBsZW5ndGhPZkFycmF5TGlrZSQxID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbiAgdmFyIGlzUHJvdG90eXBlT2YkNiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG4gIHZhciBnZXRJdGVyYXRvciQ1ID0gZ2V0SXRlcmF0b3IkNztcbiAgdmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QkODtcbiAgdmFyIGl0ZXJhdG9yQ2xvc2UgPSBpdGVyYXRvckNsb3NlJDI7XG4gIHZhciBUeXBlRXJyb3IkMiA9IGdsb2JhbCQzLlR5cGVFcnJvcjtcblxuICB2YXIgUmVzdWx0ID0gZnVuY3Rpb24gKHN0b3BwZWQsIHJlc3VsdCkge1xuICAgIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XG4gICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIFJlc3VsdFByb3RvdHlwZSA9IFJlc3VsdC5wcm90b3R5cGU7XG5cbiAgdmFyIGl0ZXJhdGUkMiA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgdW5ib3VuZEZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoYXQgPSBvcHRpb25zICYmIG9wdGlvbnMudGhhdDtcbiAgICB2YXIgQVNfRU5UUklFUyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5BU19FTlRSSUVTKTtcbiAgICB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpO1xuICAgIHZhciBJTlRFUlJVUFRFRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JTlRFUlJVUFRFRCk7XG4gICAgdmFyIGZuID0gYmluZCQxKHVuYm91bmRGdW5jdGlvbiwgdGhhdCk7XG4gICAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcblxuICAgIHZhciBzdG9wID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJywgY29uZGl0aW9uKTtcbiAgICAgIHJldHVybiBuZXcgUmVzdWx0KHRydWUsIGNvbmRpdGlvbik7XG4gICAgfTtcblxuICAgIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChBU19FTlRSSUVTKSB7XG4gICAgICAgIGFuT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWVbMF0sIHZhbHVlWzFdLCBzdG9wKSA6IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgaWYgKElTX0lURVJBVE9SKSB7XG4gICAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG4gICAgICBpZiAoIWl0ZXJGbikgdGhyb3cgVHlwZUVycm9yJDIodHJ5VG9TdHJpbmcoaXRlcmFibGUpICsgJyBpcyBub3QgaXRlcmFibGUnKTsgLy8gb3B0aW1pc2F0aW9uIGZvciBhcnJheSBpdGVyYXRvcnNcblxuICAgICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7XG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQxKGl0ZXJhYmxlKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgICByZXN1bHQgPSBjYWxsRm4oaXRlcmFibGVbaW5kZXhdKTtcbiAgICAgICAgICBpZiAocmVzdWx0ICYmIGlzUHJvdG90eXBlT2YkNihSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkNShpdGVyYWJsZSwgaXRlckZuKTtcbiAgICB9XG5cbiAgICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcblxuICAgIHdoaWxlICghKHN0ZXAgPSBjYWxsKG5leHQsIGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgaXNQcm90b3R5cGVPZiQ2KFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gIH07XG5cbiAgdmFyIGdsb2JhbCQyID0gZ2xvYmFsJE07XG4gIHZhciBpc1Byb3RvdHlwZU9mJDUgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuICB2YXIgVHlwZUVycm9yJDEgPSBnbG9iYWwkMi5UeXBlRXJyb3I7XG5cbiAgdmFyIGFuSW5zdGFuY2UkMiA9IGZ1bmN0aW9uIChpdCwgUHJvdG90eXBlKSB7XG4gICAgaWYgKGlzUHJvdG90eXBlT2YkNShQcm90b3R5cGUsIGl0KSkgcmV0dXJuIGl0O1xuICAgIHRocm93IFR5cGVFcnJvciQxKCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xuICB9O1xuXG4gIHZhciAkJDIgPSBfZXhwb3J0O1xuICB2YXIgZ2xvYmFsJDEgPSBnbG9iYWwkTTtcbiAgdmFyIEludGVybmFsTWV0YWRhdGFNb2R1bGUgPSBpbnRlcm5hbE1ldGFkYXRhLmV4cG9ydHM7XG4gIHZhciBmYWlscyQxID0gZmFpbHMkcjtcbiAgdmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xuICB2YXIgaXRlcmF0ZSQxID0gaXRlcmF0ZSQyO1xuICB2YXIgYW5JbnN0YW5jZSQxID0gYW5JbnN0YW5jZSQyO1xuICB2YXIgaXNDYWxsYWJsZSA9IGlzQ2FsbGFibGUkaDtcbiAgdmFyIGlzT2JqZWN0ID0gaXNPYmplY3QkZjtcbiAgdmFyIHNldFRvU3RyaW5nVGFnID0gc2V0VG9TdHJpbmdUYWckNTtcbiAgdmFyIGRlZmluZVByb3BlcnR5JDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuICB2YXIgZm9yRWFjaCA9IGFycmF5SXRlcmF0aW9uLmZvckVhY2g7XG4gIHZhciBERVNDUklQVE9SUyQyID0gZGVzY3JpcHRvcnM7XG4gIHZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDEgPSBpbnRlcm5hbFN0YXRlO1xuICB2YXIgc2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLnNldDtcbiAgdmFyIGludGVybmFsU3RhdGVHZXR0ZXJGb3IkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5nZXR0ZXJGb3I7XG5cbiAgdmFyIGNvbGxlY3Rpb24kMiA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FLCB3cmFwcGVyLCBjb21tb24pIHtcbiAgICB2YXIgSVNfTUFQID0gQ09OU1RSVUNUT1JfTkFNRS5pbmRleE9mKCdNYXAnKSAhPT0gLTE7XG4gICAgdmFyIElTX1dFQUsgPSBDT05TVFJVQ1RPUl9OQU1FLmluZGV4T2YoJ1dlYWsnKSAhPT0gLTE7XG4gICAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgICB2YXIgTmF0aXZlQ29uc3RydWN0b3IgPSBnbG9iYWwkMVtDT05TVFJVQ1RPUl9OQU1FXTtcbiAgICB2YXIgTmF0aXZlUHJvdG90eXBlID0gTmF0aXZlQ29uc3RydWN0b3IgJiYgTmF0aXZlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHZhciBleHBvcnRlZCA9IHt9O1xuICAgIHZhciBDb25zdHJ1Y3RvcjtcblxuICAgIGlmICghREVTQ1JJUFRPUlMkMiB8fCAhaXNDYWxsYWJsZShOYXRpdmVDb25zdHJ1Y3RvcikgfHwgIShJU19XRUFLIHx8IE5hdGl2ZVByb3RvdHlwZS5mb3JFYWNoICYmICFmYWlscyQxKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpLmVudHJpZXMoKS5uZXh0KCk7XG4gICAgfSkpKSB7XG4gICAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgICAgQ29uc3RydWN0b3IgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgICBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlLmVuYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKHRhcmdldCwgaXRlcmFibGUpIHtcbiAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZSQxKGFuSW5zdGFuY2UkMSh0YXJnZXQsIFByb3RvdHlwZSksIHtcbiAgICAgICAgICB0eXBlOiBDT05TVFJVQ1RPUl9OQU1FLFxuICAgICAgICAgIGNvbGxlY3Rpb246IG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBpdGVyYXRlJDEoaXRlcmFibGUsIHRhcmdldFtBRERFUl0sIHtcbiAgICAgICAgICB0aGF0OiB0YXJnZXQsXG4gICAgICAgICAgQVNfRU5UUklFUzogSVNfTUFQXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgUHJvdG90eXBlID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yJDEoQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgICBmb3JFYWNoKFsnYWRkJywgJ2NsZWFyJywgJ2RlbGV0ZScsICdmb3JFYWNoJywgJ2dldCcsICdoYXMnLCAnc2V0JywgJ2tleXMnLCAndmFsdWVzJywgJ2VudHJpZXMnXSwgZnVuY3Rpb24gKEtFWSkge1xuICAgICAgICB2YXIgSVNfQURERVIgPSBLRVkgPT0gJ2FkZCcgfHwgS0VZID09ICdzZXQnO1xuXG4gICAgICAgIGlmIChLRVkgaW4gTmF0aXZlUHJvdG90eXBlICYmICEoSVNfV0VBSyAmJiBLRVkgPT0gJ2NsZWFyJykpIHtcbiAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoUHJvdG90eXBlLCBLRVksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IGdldEludGVybmFsU3RhdGUodGhpcykuY29sbGVjdGlvbjtcbiAgICAgICAgICAgIGlmICghSVNfQURERVIgJiYgSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkpIHJldHVybiBLRVkgPT0gJ2dldCcgPyB1bmRlZmluZWQgOiBmYWxzZTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb2xsZWN0aW9uW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgICAgIHJldHVybiBJU19BRERFUiA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgSVNfV0VBSyB8fCBkZWZpbmVQcm9wZXJ0eSQxKFByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuY29sbGVjdGlvbi5zaXplO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgZmFsc2UsIHRydWUpO1xuICAgIGV4cG9ydGVkW0NPTlNUUlVDVE9SX05BTUVdID0gQ29uc3RydWN0b3I7XG4gICAgJCQyKHtcbiAgICAgIGdsb2JhbDogdHJ1ZSxcbiAgICAgIGZvcmNlZDogdHJ1ZVxuICAgIH0sIGV4cG9ydGVkKTtcbiAgICBpZiAoIUlTX1dFQUspIGNvbW1vbi5zZXRTdHJvbmcoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xuXG4gIHZhciByZWRlZmluZSA9IHJlZGVmaW5lJDQ7XG5cbiAgdmFyIHJlZGVmaW5lQWxsJDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnVuc2FmZSAmJiB0YXJnZXRba2V5XSkgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtlbHNlIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICB2YXIgZ2V0QnVpbHRJbiA9IGdldEJ1aWx0SW4kOTtcbiAgdmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG4gIHZhciB3ZWxsS25vd25TeW1ib2wgPSB3ZWxsS25vd25TeW1ib2wkajtcbiAgdmFyIERFU0NSSVBUT1JTJDEgPSBkZXNjcmlwdG9ycztcbiAgdmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxuICB2YXIgc2V0U3BlY2llcyQxID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSBnZXRCdWlsdEluKENPTlNUUlVDVE9SX05BTUUpO1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG5cbiAgICBpZiAoREVTQ1JJUFRPUlMkMSAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFU10pIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBTUEVDSUVTLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuICB2YXIgY3JlYXRlID0gb2JqZWN0Q3JlYXRlO1xuICB2YXIgcmVkZWZpbmVBbGwgPSByZWRlZmluZUFsbCQxO1xuICB2YXIgYmluZCA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG4gIHZhciBhbkluc3RhbmNlID0gYW5JbnN0YW5jZSQyO1xuICB2YXIgaXRlcmF0ZSA9IGl0ZXJhdGUkMjtcbiAgdmFyIGRlZmluZUl0ZXJhdG9yID0gZGVmaW5lSXRlcmF0b3IkMztcbiAgdmFyIHNldFNwZWNpZXMgPSBzZXRTcGVjaWVzJDE7XG4gIHZhciBERVNDUklQVE9SUyA9IGRlc2NyaXB0b3JzO1xuICB2YXIgZmFzdEtleSA9IGludGVybmFsTWV0YWRhdGEuZXhwb3J0cy5mYXN0S2V5O1xuICB2YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IGludGVybmFsU3RhdGU7XG4gIHZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG4gIHZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3I7XG4gIHZhciBjb2xsZWN0aW9uU3Ryb25nJDIgPSB7XG4gICAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFByb3RvdHlwZSk7XG4gICAgICAgIHNldEludGVybmFsU3RhdGUodGhhdCwge1xuICAgICAgICAgIHR5cGU6IENPTlNUUlVDVE9SX05BTUUsXG4gICAgICAgICAgaW5kZXg6IGNyZWF0ZShudWxsKSxcbiAgICAgICAgICBmaXJzdDogdW5kZWZpbmVkLFxuICAgICAgICAgIGxhc3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgICBzaXplOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIURFU0NSSVBUT1JTKSB0aGF0LnNpemUgPSAwO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBpdGVyYXRlKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwge1xuICAgICAgICAgIHRoYXQ6IHRoYXQsXG4gICAgICAgICAgQVNfRU5UUklFUzogSVNfTUFQXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgUHJvdG90eXBlID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpO1xuXG4gICAgICB2YXIgZGVmaW5lID0gZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgdmFyIHByZXZpb3VzLCBpbmRleDsgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG5cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTsgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmxhc3QgPSBlbnRyeSA9IHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSxcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzID0gc3RhdGUubGFzdCxcbiAgICAgICAgICAgIG5leHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlbW92ZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoIXN0YXRlLmZpcnN0KSBzdGF0ZS5maXJzdCA9IGVudHJ5O1xuICAgICAgICAgIGlmIChwcmV2aW91cykgcHJldmlvdXMubmV4dCA9IGVudHJ5O1xuICAgICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZSsrO2Vsc2UgdGhhdC5zaXplKys7IC8vIGFkZCB0byBpbmRleFxuXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHN0YXRlLmluZGV4W2luZGV4XSA9IGVudHJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7IC8vIGZhc3QgY2FzZVxuXG4gICAgICAgIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHN0YXRlLmluZGV4W2luZGV4XTsgLy8gZnJvemVuIG9iamVjdCBjYXNlXG5cbiAgICAgICAgZm9yIChlbnRyeSA9IHN0YXRlLmZpcnN0OyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uZXh0KSB7XG4gICAgICAgICAgaWYgKGVudHJ5LmtleSA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmVkZWZpbmVBbGwoUHJvdG90eXBlLCB7XG4gICAgICAgIC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLmNsZWFyKClgIG1ldGhvZHNcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmNsZWFyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5jbGVhclxuICAgICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICAgICAgdmFyIGRhdGEgPSBzdGF0ZS5pbmRleDtcbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGF0ZS5maXJzdDtcblxuICAgICAgICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgICAgICAgZW50cnkucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZW50cnkucHJldmlvdXMpIGVudHJ5LnByZXZpb3VzID0gZW50cnkucHJldmlvdXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmluZGV4XTtcbiAgICAgICAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGF0ZS5maXJzdCA9IHN0YXRlLmxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplID0gMDtlbHNlIHRoYXQuc2l6ZSA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLmRlbGV0ZShrZXkpYCBtZXRob2RzXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5kZWxldGVcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmRlbGV0ZVxuICAgICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG5cbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkubmV4dDtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuaW5kZXhbZW50cnkuaW5kZXhdO1xuICAgICAgICAgICAgZW50cnkucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAocHJldikgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnByZXZpb3VzID0gcHJldjtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5maXJzdCA9PSBlbnRyeSkgc3RhdGUuZmlyc3QgPSBuZXh0O1xuICAgICAgICAgICAgaWYgKHN0YXRlLmxhc3QgPT0gZW50cnkpIHN0YXRlLmxhc3QgPSBwcmV2O1xuICAgICAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplLS07ZWxzZSB0aGF0LnNpemUtLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gISFlbnRyeTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKWAgbWV0aG9kc1xuICAgICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZm9yZWFjaFxuICAgICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZm9yZWFjaFxuICAgICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm5cbiAgICAgICAgLyogLCB0aGF0ID0gdW5kZWZpbmVkICovXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICB2YXIgZW50cnk7XG5cbiAgICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5maXJzdCkge1xuICAgICAgICAgICAgYm91bmRGdW5jdGlvbihlbnRyeS52YWx1ZSwgZW50cnkua2V5LCB0aGlzKTsgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG5cbiAgICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yZW1vdmVkKSBlbnRyeSA9IGVudHJ5LnByZXZpb3VzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gYHsgTWFwLCBTZXR9LnByb3RvdHlwZS5oYXMoa2V5KWAgbWV0aG9kc1xuICAgICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuaGFzXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5oYXNcbiAgICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZWRlZmluZUFsbChQcm90b3R5cGUsIElTX01BUCA/IHtcbiAgICAgICAgLy8gYE1hcC5wcm90b3R5cGUuZ2V0KGtleSlgIG1ldGhvZFxuICAgICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZ2V0XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICAvLyBgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlgIG1ldGhvZFxuICAgICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuc2V0XG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSA6IHtcbiAgICAgICAgLy8gYFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKWAgbWV0aG9kXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5hZGRcbiAgICAgICAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KFByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNpemU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgIH0sXG4gICAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCkge1xuICAgICAgdmFyIElURVJBVE9SX05BTUUgPSBDT05TVFJVQ1RPUl9OQU1FICsgJyBJdGVyYXRvcic7XG4gICAgICB2YXIgZ2V0SW50ZXJuYWxDb2xsZWN0aW9uU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpO1xuICAgICAgdmFyIGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoSVRFUkFUT1JfTkFNRSk7IC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLnsga2V5cywgdmFsdWVzLCBlbnRyaWVzLCBAQGl0ZXJhdG9yIH0oKWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmVudHJpZXNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5rZXlzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUudmFsdWVzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUtQEBpdGVyYXRvclxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmVudHJpZXNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5rZXlzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUudmFsdWVzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUtQEBpdGVyYXRvclxuXG4gICAgICBkZWZpbmVJdGVyYXRvcihDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gICAgICAgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgICAgICAgIHR5cGU6IElURVJBVE9SX05BTUUsXG4gICAgICAgICAgdGFyZ2V0OiBpdGVyYXRlZCxcbiAgICAgICAgICBzdGF0ZTogZ2V0SW50ZXJuYWxDb2xsZWN0aW9uU3RhdGUoaXRlcmF0ZWQpLFxuICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgbGFzdDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUodGhpcyk7XG4gICAgICAgIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgICAgICAgdmFyIGVudHJ5ID0gc3RhdGUubGFzdDsgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG5cbiAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7IC8vIGdldCBuZXh0IGVudHJ5XG5cblxuICAgICAgICBpZiAoIXN0YXRlLnRhcmdldCB8fCAhKHN0YXRlLmxhc3QgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubmV4dCA6IHN0YXRlLnN0YXRlLmZpcnN0KSkge1xuICAgICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuXG5cbiAgICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBlbnRyeS5rZXksXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IFtlbnRyeS5rZXksIGVudHJ5LnZhbHVlXSxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpOyAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZVtAQHNwZWNpZXNdYCBhY2Nlc3NvcnNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LW1hcC1AQHNwZWNpZXNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LXNldC1AQHNwZWNpZXNcblxuICAgICAgc2V0U3BlY2llcyhDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNvbGxlY3Rpb24kMSA9IGNvbGxlY3Rpb24kMjtcbiAgdmFyIGNvbGxlY3Rpb25TdHJvbmckMSA9IGNvbGxlY3Rpb25TdHJvbmckMjsgLy8gYE1hcGAgY29uc3RydWN0b3JcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAtb2JqZWN0c1xuXG4gIGNvbGxlY3Rpb24kMSgnTWFwJywgZnVuY3Rpb24gKGluaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gTWFwKCkge1xuICAgICAgcmV0dXJuIGluaXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgfSwgY29sbGVjdGlvblN0cm9uZyQxKTtcblxuICB2YXIgcGF0aCQxID0gcGF0aCRxO1xuICB2YXIgbWFwJDIgPSBwYXRoJDEuTWFwO1xuXG4gIHZhciBwYXJlbnQkOSA9IG1hcCQyO1xuICB2YXIgbWFwJDEgPSBwYXJlbnQkOTtcblxuICB2YXIgbWFwID0gbWFwJDE7XG5cbiAgdmFyICQkMSA9IF9leHBvcnQ7XG4gIHZhciAkc29tZSA9IGFycmF5SXRlcmF0aW9uLnNvbWU7XG4gIHZhciBhcnJheU1ldGhvZElzU3RyaWN0JDEgPSBhcnJheU1ldGhvZElzU3RyaWN0JDU7XG4gIHZhciBTVFJJQ1RfTUVUSE9EJDEgPSBhcnJheU1ldGhvZElzU3RyaWN0JDEoJ3NvbWUnKTsgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuXG4gICQkMSh7XG4gICAgdGFyZ2V0OiAnQXJyYXknLFxuICAgIHByb3RvOiB0cnVlLFxuICAgIGZvcmNlZDogIVNUUklDVF9NRVRIT0QkMVxuICB9LCB7XG4gICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuXG4gICAgLyogLCB0aGlzQXJnICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGVudHJ5VmlydHVhbCQ0ID0gZW50cnlWaXJ0dWFsJGs7XG4gIHZhciBzb21lJDMgPSBlbnRyeVZpcnR1YWwkNCgnQXJyYXknKS5zb21lO1xuXG4gIHZhciBpc1Byb3RvdHlwZU9mJDQgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuICB2YXIgbWV0aG9kJDQgPSBzb21lJDM7XG4gIHZhciBBcnJheVByb3RvdHlwZSQ0ID0gQXJyYXkucHJvdG90eXBlO1xuXG4gIHZhciBzb21lJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgb3duID0gaXQuc29tZTtcbiAgICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDQgfHwgaXNQcm90b3R5cGVPZiQ0KEFycmF5UHJvdG90eXBlJDQsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDQuc29tZSA/IG1ldGhvZCQ0IDogb3duO1xuICB9O1xuXG4gIHZhciBwYXJlbnQkOCA9IHNvbWUkMjtcbiAgdmFyIHNvbWUkMSA9IHBhcmVudCQ4O1xuXG4gIHZhciBzb21lID0gc29tZSQxO1xuXG4gIHZhciBlbnRyeVZpcnR1YWwkMyA9IGVudHJ5VmlydHVhbCRrO1xuICB2YXIga2V5cyQzID0gZW50cnlWaXJ0dWFsJDMoJ0FycmF5Jykua2V5cztcblxuICB2YXIgcGFyZW50JDcgPSBrZXlzJDM7XG4gIHZhciBrZXlzJDIgPSBwYXJlbnQkNztcblxuICB2YXIgY2xhc3NvZiQyID0gY2xhc3NvZiRjO1xuICB2YXIgaGFzT3duJDIgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuICB2YXIgaXNQcm90b3R5cGVPZiQzID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbiAgdmFyIG1ldGhvZCQzID0ga2V5cyQyO1xuICB2YXIgQXJyYXlQcm90b3R5cGUkMyA9IEFycmF5LnByb3RvdHlwZTtcbiAgdmFyIERPTUl0ZXJhYmxlcyQyID0ge1xuICAgIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgICBOb2RlTGlzdDogdHJ1ZVxuICB9O1xuXG4gIHZhciBrZXlzJDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgb3duID0gaXQua2V5cztcbiAgICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDMgfHwgaXNQcm90b3R5cGVPZiQzKEFycmF5UHJvdG90eXBlJDMsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDMua2V5cyB8fCBoYXNPd24kMihET01JdGVyYWJsZXMkMiwgY2xhc3NvZiQyKGl0KSkgPyBtZXRob2QkMyA6IG93bjtcbiAgfTtcblxuICB2YXIga2V5cyA9IGtleXMkMTtcblxuICB2YXIgYXJyYXlTbGljZSA9IGFycmF5U2xpY2VTaW1wbGU7XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbiAgdmFyIG1lcmdlU29ydCA9IGZ1bmN0aW9uIChhcnJheSwgY29tcGFyZWZuKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgbWlkZGxlID0gZmxvb3IobGVuZ3RoIC8gMik7XG4gICAgcmV0dXJuIGxlbmd0aCA8IDggPyBpbnNlcnRpb25Tb3J0KGFycmF5LCBjb21wYXJlZm4pIDogbWVyZ2UoYXJyYXksIG1lcmdlU29ydChhcnJheVNsaWNlKGFycmF5LCAwLCBtaWRkbGUpLCBjb21wYXJlZm4pLCBtZXJnZVNvcnQoYXJyYXlTbGljZShhcnJheSwgbWlkZGxlKSwgY29tcGFyZWZuKSwgY29tcGFyZWZuKTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0aW9uU29ydCA9IGZ1bmN0aW9uIChhcnJheSwgY29tcGFyZWZuKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIGVsZW1lbnQsIGo7XG5cbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgaiA9IGk7XG4gICAgICBlbGVtZW50ID0gYXJyYXlbaV07XG5cbiAgICAgIHdoaWxlIChqICYmIGNvbXBhcmVmbihhcnJheVtqIC0gMV0sIGVsZW1lbnQpID4gMCkge1xuICAgICAgICBhcnJheVtqXSA9IGFycmF5Wy0tal07XG4gICAgICB9XG5cbiAgICAgIGlmIChqICE9PSBpKyspIGFycmF5W2pdID0gZWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH07XG5cbiAgdmFyIG1lcmdlID0gZnVuY3Rpb24gKGFycmF5LCBsZWZ0LCByaWdodCwgY29tcGFyZWZuKSB7XG4gICAgdmFyIGxsZW5ndGggPSBsZWZ0Lmxlbmd0aDtcbiAgICB2YXIgcmxlbmd0aCA9IHJpZ2h0Lmxlbmd0aDtcbiAgICB2YXIgbGluZGV4ID0gMDtcbiAgICB2YXIgcmluZGV4ID0gMDtcblxuICAgIHdoaWxlIChsaW5kZXggPCBsbGVuZ3RoIHx8IHJpbmRleCA8IHJsZW5ndGgpIHtcbiAgICAgIGFycmF5W2xpbmRleCArIHJpbmRleF0gPSBsaW5kZXggPCBsbGVuZ3RoICYmIHJpbmRleCA8IHJsZW5ndGggPyBjb21wYXJlZm4obGVmdFtsaW5kZXhdLCByaWdodFtyaW5kZXhdKSA8PSAwID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK10gOiBsaW5kZXggPCBsbGVuZ3RoID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK107XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xuXG4gIHZhciBhcnJheVNvcnQgPSBtZXJnZVNvcnQ7XG5cbiAgdmFyIHVzZXJBZ2VudCQxID0gZW5naW5lVXNlckFnZW50O1xuICB2YXIgZmlyZWZveCA9IHVzZXJBZ2VudCQxLm1hdGNoKC9maXJlZm94XFwvKFxcZCspL2kpO1xuICB2YXIgZW5naW5lRmZWZXJzaW9uID0gISFmaXJlZm94ICYmICtmaXJlZm94WzFdO1xuXG4gIHZhciBVQSA9IGVuZ2luZVVzZXJBZ2VudDtcbiAgdmFyIGVuZ2luZUlzSWVPckVkZ2UgPSAvTVNJRXxUcmlkZW50Ly50ZXN0KFVBKTtcblxuICB2YXIgdXNlckFnZW50ID0gZW5naW5lVXNlckFnZW50O1xuICB2YXIgd2Via2l0ID0gdXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pO1xuICB2YXIgZW5naW5lV2Via2l0VmVyc2lvbiA9ICEhd2Via2l0ICYmICt3ZWJraXRbMV07XG5cbiAgdmFyICQgPSBfZXhwb3J0O1xuICB2YXIgdW5jdXJyeVRoaXMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuICB2YXIgYUNhbGxhYmxlID0gYUNhbGxhYmxlJDc7XG4gIHZhciB0b09iamVjdCA9IHRvT2JqZWN0JGU7XG4gIHZhciBsZW5ndGhPZkFycmF5TGlrZSA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG4gIHZhciB0b1N0cmluZyA9IHRvU3RyaW5nJDc7XG4gIHZhciBmYWlscyA9IGZhaWxzJHI7XG4gIHZhciBpbnRlcm5hbFNvcnQgPSBhcnJheVNvcnQ7XG4gIHZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gYXJyYXlNZXRob2RJc1N0cmljdCQ1O1xuICB2YXIgRkYgPSBlbmdpbmVGZlZlcnNpb247XG4gIHZhciBJRV9PUl9FREdFID0gZW5naW5lSXNJZU9yRWRnZTtcbiAgdmFyIFY4ID0gZW5naW5lVjhWZXJzaW9uO1xuICB2YXIgV0VCS0lUID0gZW5naW5lV2Via2l0VmVyc2lvbjtcbiAgdmFyIHRlc3QgPSBbXTtcbiAgdmFyIHVuJFNvcnQgPSB1bmN1cnJ5VGhpcyh0ZXN0LnNvcnQpO1xuICB2YXIgcHVzaCA9IHVuY3VycnlUaGlzKHRlc3QucHVzaCk7IC8vIElFOC1cblxuICB2YXIgRkFJTFNfT05fVU5ERUZJTkVEID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHRlc3Quc29ydCh1bmRlZmluZWQpO1xuICB9KTsgLy8gVjggYnVnXG5cbiAgdmFyIEZBSUxTX09OX05VTEwgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdGVzdC5zb3J0KG51bGwpO1xuICB9KTsgLy8gT2xkIFdlYktpdFxuXG4gIHZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnc29ydCcpO1xuICB2YXIgU1RBQkxFX1NPUlQgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGZlYXR1cmUgZGV0ZWN0aW9uIGNhbiBiZSB0b28gc2xvdywgc28gY2hlY2sgZW5naW5lcyB2ZXJzaW9uc1xuICAgIGlmIChWOCkgcmV0dXJuIFY4IDwgNzA7XG4gICAgaWYgKEZGICYmIEZGID4gMykgcmV0dXJuO1xuICAgIGlmIChJRV9PUl9FREdFKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoV0VCS0lUKSByZXR1cm4gV0VCS0lUIDwgNjAzO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgY29kZSwgY2hyLCB2YWx1ZSwgaW5kZXg7IC8vIGdlbmVyYXRlIGFuIGFycmF5IHdpdGggbW9yZSA1MTIgZWxlbWVudHMgKENoYWtyYSBhbmQgb2xkIFY4IGZhaWxzIG9ubHkgaW4gdGhpcyBjYXNlKVxuXG4gICAgZm9yIChjb2RlID0gNjU7IGNvZGUgPCA3NjsgY29kZSsrKSB7XG4gICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuXG4gICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSA2NjpcbiAgICAgICAgY2FzZSA2OTpcbiAgICAgICAgY2FzZSA3MDpcbiAgICAgICAgY2FzZSA3MjpcbiAgICAgICAgICB2YWx1ZSA9IDM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA2ODpcbiAgICAgICAgY2FzZSA3MTpcbiAgICAgICAgICB2YWx1ZSA9IDQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWx1ZSA9IDI7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IDQ3OyBpbmRleCsrKSB7XG4gICAgICAgIHRlc3QucHVzaCh7XG4gICAgICAgICAgazogY2hyICsgaW5kZXgsXG4gICAgICAgICAgdjogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGVzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYi52IC0gYS52O1xuICAgIH0pO1xuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGVzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNociA9IHRlc3RbaW5kZXhdLmsuY2hhckF0KDApO1xuICAgICAgaWYgKHJlc3VsdC5jaGFyQXQocmVzdWx0Lmxlbmd0aCAtIDEpICE9PSBjaHIpIHJlc3VsdCArPSBjaHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCAhPT0gJ0RHQkVGSEFDSUpLJztcbiAgfSk7XG4gIHZhciBGT1JDRUQgPSBGQUlMU19PTl9VTkRFRklORUQgfHwgIUZBSUxTX09OX05VTEwgfHwgIVNUUklDVF9NRVRIT0QgfHwgIVNUQUJMRV9TT1JUO1xuXG4gIHZhciBnZXRTb3J0Q29tcGFyZSA9IGZ1bmN0aW9uIChjb21wYXJlZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHJldHVybiAtMTtcbiAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHJldHVybiAxO1xuICAgICAgaWYgKGNvbXBhcmVmbiAhPT0gdW5kZWZpbmVkKSByZXR1cm4gK2NvbXBhcmVmbih4LCB5KSB8fCAwO1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHgpID4gdG9TdHJpbmcoeSkgPyAxIDogLTE7XG4gICAgfTtcbiAgfTsgLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29ydFxuXG5cbiAgJCh7XG4gICAgdGFyZ2V0OiAnQXJyYXknLFxuICAgIHByb3RvOiB0cnVlLFxuICAgIGZvcmNlZDogRk9SQ0VEXG4gIH0sIHtcbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgICAgaWYgKGNvbXBhcmVmbiAhPT0gdW5kZWZpbmVkKSBhQ2FsbGFibGUoY29tcGFyZWZuKTtcbiAgICAgIHZhciBhcnJheSA9IHRvT2JqZWN0KHRoaXMpO1xuICAgICAgaWYgKFNUQUJMRV9TT1JUKSByZXR1cm4gY29tcGFyZWZuID09PSB1bmRlZmluZWQgPyB1biRTb3J0KGFycmF5KSA6IHVuJFNvcnQoYXJyYXksIGNvbXBhcmVmbik7XG4gICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgIHZhciBhcnJheUxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKGFycmF5KTtcbiAgICAgIHZhciBpdGVtc0xlbmd0aCwgaW5kZXg7XG5cbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGFycmF5TGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGlmIChpbmRleCBpbiBhcnJheSkgcHVzaChpdGVtcywgYXJyYXlbaW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgaW50ZXJuYWxTb3J0KGl0ZW1zLCBnZXRTb3J0Q29tcGFyZShjb21wYXJlZm4pKTtcbiAgICAgIGl0ZW1zTGVuZ3RoID0gaXRlbXMubGVuZ3RoO1xuICAgICAgaW5kZXggPSAwO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBpdGVtc0xlbmd0aCkgYXJyYXlbaW5kZXhdID0gaXRlbXNbaW5kZXgrK107XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGFycmF5TGVuZ3RoKSBkZWxldGUgYXJyYXlbaW5kZXgrK107XG5cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBlbnRyeVZpcnR1YWwkMiA9IGVudHJ5VmlydHVhbCRrO1xuICB2YXIgc29ydCQzID0gZW50cnlWaXJ0dWFsJDIoJ0FycmF5Jykuc29ydDtcblxuICB2YXIgaXNQcm90b3R5cGVPZiQyID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbiAgdmFyIG1ldGhvZCQyID0gc29ydCQzO1xuICB2YXIgQXJyYXlQcm90b3R5cGUkMiA9IEFycmF5LnByb3RvdHlwZTtcblxuICB2YXIgc29ydCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIG93biA9IGl0LnNvcnQ7XG4gICAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQyIHx8IGlzUHJvdG90eXBlT2YkMihBcnJheVByb3RvdHlwZSQyLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQyLnNvcnQgPyBtZXRob2QkMiA6IG93bjtcbiAgfTtcblxuICB2YXIgcGFyZW50JDYgPSBzb3J0JDI7XG4gIHZhciBzb3J0JDEgPSBwYXJlbnQkNjtcblxuICB2YXIgc29ydCA9IHNvcnQkMTtcblxuICB2YXIgZW50cnlWaXJ0dWFsJDEgPSBlbnRyeVZpcnR1YWwkaztcbiAgdmFyIHZhbHVlcyQzID0gZW50cnlWaXJ0dWFsJDEoJ0FycmF5JykudmFsdWVzO1xuXG4gIHZhciBwYXJlbnQkNSA9IHZhbHVlcyQzO1xuICB2YXIgdmFsdWVzJDIgPSBwYXJlbnQkNTtcblxuICB2YXIgY2xhc3NvZiQxID0gY2xhc3NvZiRjO1xuICB2YXIgaGFzT3duJDEgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuICB2YXIgaXNQcm90b3R5cGVPZiQxID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbiAgdmFyIG1ldGhvZCQxID0gdmFsdWVzJDI7XG4gIHZhciBBcnJheVByb3RvdHlwZSQxID0gQXJyYXkucHJvdG90eXBlO1xuICB2YXIgRE9NSXRlcmFibGVzJDEgPSB7XG4gICAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICAgIE5vZGVMaXN0OiB0cnVlXG4gIH07XG5cbiAgdmFyIHZhbHVlcyQxID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIG93biA9IGl0LnZhbHVlcztcbiAgICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDEgfHwgaXNQcm90b3R5cGVPZiQxKEFycmF5UHJvdG90eXBlJDEsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDEudmFsdWVzIHx8IGhhc093biQxKERPTUl0ZXJhYmxlcyQxLCBjbGFzc29mJDEoaXQpKSA/IG1ldGhvZCQxIDogb3duO1xuICB9O1xuXG4gIHZhciB2YWx1ZXMgPSB2YWx1ZXMkMTtcblxuICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvciQ0O1xuXG4gIHZhciBlbnRyeVZpcnR1YWwgPSBlbnRyeVZpcnR1YWwkaztcbiAgdmFyIGVudHJpZXMkMyA9IGVudHJ5VmlydHVhbCgnQXJyYXknKS5lbnRyaWVzO1xuXG4gIHZhciBwYXJlbnQkNCA9IGVudHJpZXMkMztcbiAgdmFyIGVudHJpZXMkMiA9IHBhcmVudCQ0O1xuXG4gIHZhciBjbGFzc29mID0gY2xhc3NvZiRjO1xuICB2YXIgaGFzT3duID0gaGFzT3duUHJvcGVydHlfMTtcbiAgdmFyIGlzUHJvdG90eXBlT2YgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuICB2YXIgbWV0aG9kID0gZW50cmllcyQyO1xuICB2YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG4gIHZhciBET01JdGVyYWJsZXMgPSB7XG4gICAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICAgIE5vZGVMaXN0OiB0cnVlXG4gIH07XG5cbiAgdmFyIGVudHJpZXMkMSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBvd24gPSBpdC5lbnRyaWVzO1xuICAgIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUgfHwgaXNQcm90b3R5cGVPZihBcnJheVByb3RvdHlwZSwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUuZW50cmllcyB8fCBoYXNPd24oRE9NSXRlcmFibGVzLCBjbGFzc29mKGl0KSkgPyBtZXRob2QgOiBvd247XG4gIH07XG5cbiAgdmFyIGVudHJpZXMgPSBlbnRyaWVzJDE7XG5cbiAgLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4gIC8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuICAvLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxuICB2YXIgZ2V0UmFuZG9tVmFsdWVzO1xuICB2YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG4gIGZ1bmN0aW9uIHJuZygpIHtcbiAgICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLiBBbHNvLFxuICAgICAgLy8gZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIChtc0NyeXB0bykgb24gSUUxMS5cbiAgICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcblxuICAgICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xuICB9XG5cbiAgdmFyIFJFR0VYID0gL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO1xuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gICAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICAgKi9cblxuICB2YXIgYnl0ZVRvSGV4ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5KGFycikge1xuICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7IC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gICAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG5cbiAgICB2YXIgdXVpZCA9IChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAgIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gICAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICAgIH1cblxuICAgIHJldHVybiB1dWlkO1xuICB9XG5cbiAgZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICAgIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gICAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeShybmRzKTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIERldGVybWluZSB3aGV0aGVyIGEgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdmFsdWUgLSBJbnB1dCB2YWx1ZSBvZiB1bmtub3duIHR5cGUuXHJcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdmFsaWQgaWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gaXNJZCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xuICB9XG5cbiAgLyoqXHJcbiAgICogQSBxdWV1ZS5cclxuICAgKlxyXG4gICAqIEB0eXBlUGFyYW0gVCAtIFRoZSB0eXBlIG9mIG1ldGhvZCBuYW1lcyB0byBiZSByZXBsYWNlZCBieSBxdWV1ZWQgdmVyc2lvbnMuXHJcbiAgICovXG4gIHZhciBRdWV1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgLyoqIERlbGF5IGluIG1pbGxpc2Vjb25kcy4gSWYgZGVmaW5lZCB0aGUgcXVldWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgZmx1c2hlZC4gKi9cblxuICAgIC8qKiBNYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBxdWV1ZSBiZWZvcmUgaXQgd2lsbCBiZSBmbHVzaGVkLiAqL1xuXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgUXVldWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBRdWV1ZSBjb25maWd1cmF0aW9uLlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gUXVldWUob3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1ZXVlKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVsYXlcIiwgdm9pZCAwKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4XCIsIHZvaWQgMCk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9xdWV1ZVwiLCBbXSk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90aW1lb3V0XCIsIG51bGwpO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZXh0ZW5kZWRcIiwgbnVsbCk7XG5cbiAgICAgIC8vIG9wdGlvbnNcbiAgICAgIHRoaXMuZGVsYXkgPSBudWxsO1xuICAgICAgdGhpcy5tYXggPSBJbmZpbml0eTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHF1ZXVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUXVldWUgY29uZmlndXJhdGlvbi5cclxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoUXVldWUsIFt7XG4gICAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5kZWxheSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdGhpcy5tYXggPSBvcHRpb25zLm1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZsdXNoSWZOZWVkZWQoKTtcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBFeHRlbmQgYW4gb2JqZWN0IHdpdGggcXVldWluZyBmdW5jdGlvbmFsaXR5LlxyXG4gICAgICAgKiBUaGUgb2JqZWN0IHdpbGwgYmUgZXh0ZW5kZWQgd2l0aCBhIGZ1bmN0aW9uIGZsdXNoLCBhbmQgdGhlIG1ldGhvZHMgcHJvdmlkZWQgaW4gb3B0aW9ucy5yZXBsYWNlIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBxdWV1ZWQgb25lcy5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIG9iamVjdCAtIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWQuXHJcbiAgICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zLlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBxdWV1ZS5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgICAgdmFsdWU6XG4gICAgICAvKipcclxuICAgICAgICogRGVzdHJveSB0aGUgcXVldWUuIFRoZSBxdWV1ZSB3aWxsIGZpcnN0IGZsdXNoIGFsbCBxdWV1ZWQgYWN0aW9ucywgYW5kIGluIGNhc2UgaXQgaGFzIGV4dGVuZGVkIGFuIG9iamVjdCwgd2lsbCByZXN0b3JlIHRoZSBvcmlnaW5hbCBvYmplY3QuXHJcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9leHRlbmRlZCkge1xuICAgICAgICAgIHZhciBvYmplY3QgPSB0aGlzLl9leHRlbmRlZC5vYmplY3Q7XG4gICAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLl9leHRlbmRlZC5tZXRob2RzO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gbWV0aG9kc1tpXTtcblxuICAgICAgICAgICAgaWYgKG1ldGhvZC5vcmlnaW5hbCkge1xuICAgICAgICAgICAgICAvLyBAVE9ETzogYmV0dGVyIHNvbHV0aW9uP1xuICAgICAgICAgICAgICBvYmplY3RbbWV0aG9kLm5hbWVdID0gbWV0aG9kLm9yaWdpbmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gQFRPRE86IGJldHRlciBzb2x1dGlvbj9cbiAgICAgICAgICAgICAgZGVsZXRlIG9iamVjdFttZXRob2QubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fZXh0ZW5kZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogUmVwbGFjZSBhIG1ldGhvZCBvbiBhbiBvYmplY3Qgd2l0aCBhIHF1ZXVlZCB2ZXJzaW9uLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IGhhdmluZyB0aGUgbWV0aG9kLlxyXG4gICAgICAgKiBAcGFyYW0gbWV0aG9kIC0gVGhlIG1ldGhvZCBuYW1lLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZXBsYWNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZShvYmplY3QsIG1ldGhvZCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMgLS0gRnVuY3Rpb24gdGhpcyBpcyBuZWNlc3NhcnkgaW4gdGhlIGZ1bmN0aW9uIGJlbGxvdywgc28gY2xhc3MgdGhpcyBoYXMgdG8gYmUgc2F2ZWQgaW50byBhIHZhcmlhYmxlIGhlcmUuICovXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBvcmlnaW5hbCA9IG9iamVjdFttZXRob2RdO1xuXG4gICAgICAgIGlmICghb3JpZ2luYWwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2QgXCIgKyBtZXRob2QgKyBcIiB1bmRlZmluZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBvYmplY3RbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRkIHRoaXMgY2FsbCB0byB0aGUgcXVldWVcbiAgICAgICAgICBtZS5xdWV1ZSh7XG4gICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgICAgZm46IG9yaWdpbmFsLFxuICAgICAgICAgICAgY29udGV4dDogdGhpc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIFF1ZXVlIGEgY2FsbC5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIGVudHJ5IC0gVGhlIGZ1bmN0aW9uIG9yIGVudHJ5IHRvIGJlIHF1ZXVlZC5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicXVldWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBxdWV1ZShlbnRyeSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgIGZuOiBlbnRyeVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goZW50cnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZmx1c2hJZk5lZWRlZCgpO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIHF1ZXVlIG5lZWRzIHRvIGJlIGZsdXNoZWQuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9mbHVzaElmTmVlZGVkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZsdXNoSWZOZWVkZWQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgLy8gZmx1c2ggd2hlbiB0aGUgbWF4aW11bSBpcyBleGNlZWRlZC5cbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9IC8vIGZsdXNoIGFmdGVyIGEgcGVyaW9kIG9mIGluYWN0aXZpdHkgd2hlbiBhIGRlbGF5IGlzIGNvbmZpZ3VyZWRcblxuXG4gICAgICAgIGlmICh0aGlzLl90aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICAgICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwICYmIHR5cGVvZiB0aGlzLmRlbGF5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQkMShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5mbHVzaCgpO1xuICAgICAgICAgIH0sIHRoaXMuZGVsYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogRmx1c2ggYWxsIHF1ZXVlZCBjYWxsc1xyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmbHVzaFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICB2YXIgX2NvbnRleHQsIF9jb250ZXh0MjtcblxuICAgICAgICBmb3JFYWNoJDEoX2NvbnRleHQgPSBzcGxpY2UoX2NvbnRleHQyID0gdGhpcy5fcXVldWUpLmNhbGwoX2NvbnRleHQyLCAwKSkuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgZW50cnkuZm4uYXBwbHkoZW50cnkuY29udGV4dCB8fCBlbnRyeS5mbiwgZW50cnkuYXJncyB8fCBbXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImV4dGVuZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZChvYmplY3QsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gbmV3IFF1ZXVlKG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChvYmplY3QuZmx1c2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRhcmdldCBvYmplY3QgYWxyZWFkeSBoYXMgYSBwcm9wZXJ0eSBmbHVzaFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iamVjdC5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBxdWV1ZS5mbHVzaCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtZXRob2RzID0gW3tcbiAgICAgICAgICBuYW1lOiBcImZsdXNoXCIsXG4gICAgICAgICAgb3JpZ2luYWw6IHVuZGVmaW5lZFxuICAgICAgICB9XTtcblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMucmVwbGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLnJlcGxhY2VbaV07XG4gICAgICAgICAgICBtZXRob2RzLnB1c2goe1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAvLyBAVE9ETzogYmV0dGVyIHNvbHV0aW9uP1xuICAgICAgICAgICAgICBvcmlnaW5hbDogb2JqZWN0W25hbWVdXG4gICAgICAgICAgICB9KTsgLy8gQFRPRE86IGJldHRlciBzb2x1dGlvbj9cblxuICAgICAgICAgICAgcXVldWUucmVwbGFjZShvYmplY3QsIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXVlLl9leHRlbmRlZCA9IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBtZXRob2RzOiBtZXRob2RzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBxdWV1ZTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUXVldWU7XG4gIH0oKTtcblxuICAvKipcclxuICAgKiBbW0RhdGFTZXRdXSBjb2RlIHRoYXQgY2FuIGJlIHJldXNlZCBpbiBbW0RhdGFWaWV3XV0gb3Igb3RoZXIgc2ltaWxhciBpbXBsZW1lbnRhdGlvbnMgb2YgW1tEYXRhSW50ZXJmYWNlXV0uXHJcbiAgICpcclxuICAgKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxyXG4gICAqIEB0eXBlUGFyYW0gSWRQcm9wIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGUgaWQuXHJcbiAgICovXG4gIHZhciBEYXRhU2V0UGFydCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0YVNldFBhcnQoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YVNldFBhcnQpO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3Vic2NyaWJlcnNcIiwge1xuICAgICAgICBcIipcIjogW10sXG4gICAgICAgIGFkZDogW10sXG4gICAgICAgIHJlbW92ZTogW10sXG4gICAgICAgIHVwZGF0ZTogW11cbiAgICAgIH0pO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdWJzY3JpYmVcIiwgRGF0YVNldFBhcnQucHJvdG90eXBlLm9uKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidW5zdWJzY3JpYmVcIiwgRGF0YVNldFBhcnQucHJvdG90eXBlLm9mZik7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKERhdGFTZXRQYXJ0LCBbe1xuICAgICAga2V5OiBcIl90cmlnZ2VyXCIsXG4gICAgICB2YWx1ZTpcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUcmlnZ2VyIGFuIGV2ZW50XHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBldmVudCAtIEV2ZW50IG5hbWUuXHJcbiAgICAgICAqIEBwYXJhbSBwYXlsb2FkIC0gRXZlbnQgcGF5bG9hZC5cclxuICAgICAgICogQHBhcmFtIHNlbmRlcklkIC0gSWQgb2YgdGhlIHNlbmRlci5cclxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBfdHJpZ2dlcihldmVudCwgcGF5bG9hZCwgc2VuZGVySWQpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0LCBfY29udGV4dDI7XG5cbiAgICAgICAgaWYgKGV2ZW50ID09PSBcIipcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0cmlnZ2VyIGV2ZW50ICpcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JFYWNoJDEoX2NvbnRleHQgPSBjb25jYXQkMShfY29udGV4dDIgPSBbXSkuY2FsbChfY29udGV4dDIsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0pLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fc3Vic2NyaWJlcnNbXCIqXCJdKSkpLmNhbGwoX2NvbnRleHQsIGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgc3Vic2NyaWJlcihldmVudCwgcGF5bG9hZCwgc2VuZGVySWQgIT0gbnVsbCA/IHNlbmRlcklkIDogbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIFN1YnNjcmliZSB0byBhbiBldmVudCwgYWRkIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmVtYXJrcyBOb24tZnVuY3Rpb24gY2FsbGJhY2tzIGFyZSBpZ25vcmVkLlxyXG4gICAgICAgKiBAcGFyYW0gZXZlbnQgLSBFdmVudCBuYW1lLlxyXG4gICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsYmFjayBtZXRob2QuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSAvLyBAVE9ETzogTWF5YmUgdGhyb3cgZm9yIGludmFsaWQgY2FsbGJhY2tzP1xuXG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogVW5zdWJzY3JpYmUgZnJvbSBhbiBldmVudCwgcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmVtYXJrcyBJZiB0aGUgc2FtZSBjYWxsYmFjayB3YXMgc3Vic2NyaWJlZCBtb3JlIHRoYW4gb25jZSAqKmFsbCoqIG9jY3VyZW5jZXMgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICAgKiBAcGFyYW0gZXZlbnQgLSBFdmVudCBuYW1lLlxyXG4gICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsYmFjayBtZXRob2QuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm9mZlwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MztcblxuICAgICAgICB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0gPSBmaWx0ZXIoX2NvbnRleHQzID0gdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdKS5jYWxsKF9jb250ZXh0MywgZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlciAhPT0gY2FsbGJhY2s7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBvbiBpbnN0ZWFkIChQUzogRGF0YVZpZXcuc3Vic2NyaWJlID09PSBEYXRhVmlldy5vbikuXHJcbiAgICAgICAqL1xuXG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERhdGFTZXRQYXJ0O1xuICB9KCk7XG5cbiAgdmFyIGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uJDI7XG4gIHZhciBjb2xsZWN0aW9uU3Ryb25nID0gY29sbGVjdGlvblN0cm9uZyQyOyAvLyBgU2V0YCBjb25zdHJ1Y3RvclxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC1vYmplY3RzXG5cbiAgY29sbGVjdGlvbignU2V0JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gU2V0KCkge1xuICAgICAgcmV0dXJuIGluaXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgfSwgY29sbGVjdGlvblN0cm9uZyk7XG5cbiAgdmFyIHBhdGggPSBwYXRoJHE7XG4gIHZhciBzZXQkMiA9IHBhdGguU2V0O1xuXG4gIHZhciBwYXJlbnQkMyA9IHNldCQyO1xuICB2YXIgc2V0JDEgPSBwYXJlbnQkMztcblxuICB2YXIgc2V0ID0gc2V0JDE7XG5cbiAgdmFyIGdldEl0ZXJhdG9yJDQgPSBnZXRJdGVyYXRvciQ3O1xuICB2YXIgZ2V0SXRlcmF0b3JfMSA9IGdldEl0ZXJhdG9yJDQ7XG5cbiAgdmFyIHBhcmVudCQyID0gZ2V0SXRlcmF0b3JfMTtcbiAgdmFyIGdldEl0ZXJhdG9yJDMgPSBwYXJlbnQkMjtcblxuICB2YXIgcGFyZW50JDEgPSBnZXRJdGVyYXRvciQzO1xuICB2YXIgZ2V0SXRlcmF0b3IkMiA9IHBhcmVudCQxO1xuXG4gIHZhciBwYXJlbnQgPSBnZXRJdGVyYXRvciQyO1xuICB2YXIgZ2V0SXRlcmF0b3IkMSA9IHBhcmVudDtcblxuICB2YXIgZ2V0SXRlcmF0b3IgPSBnZXRJdGVyYXRvciQxO1xuXG4gIHZhciBfU3ltYm9sJGl0ZXJhdG9yO1xuXG4gIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIHN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChpc0FycmF5JDEobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG4gIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQyKG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQxMDsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDIobywgbWluTGVuKTsgdmFyIG4gPSBzbGljZShfY29udGV4dDEwID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0MTAsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb20kMyhvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQyKG8sIG1pbkxlbik7IH1cblxuICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQyKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4gIF9TeW1ib2wkaXRlcmF0b3IgPSBpdGVyYXRvcjtcblxuICAvKipcclxuICAgKiBEYXRhIHN0cmVhbVxyXG4gICAqXHJcbiAgICogQHJlbWFya3NcclxuICAgKiBbW0RhdGFTdHJlYW1dXSBvZmZlcnMgYW4gYWx3YXlzIHVwIHRvIGRhdGUgc3RyZWFtIG9mIGl0ZW1zIGZyb20gYSBbW0RhdGFTZXRdXSBvciBbW0RhdGFWaWV3XV0uXHJcbiAgICogVGhhdCBtZWFucyB0aGF0IHRoZSBzdHJlYW0gaXMgZXZhbHVhdGVkIGF0IHRoZSB0aW1lIG9mIGl0ZXJhdGlvbiwgY29udmVyc2lvbiB0byBhbm90aGVyIGRhdGEgdHlwZSBvciB3aGVuIFtbY2FjaGVdXSBpcyBjYWxsZWQsIG5vdCB3aGVuIHRoZSBbW0RhdGFTdHJlYW1dXSB3YXMgY3JlYXRlZC5cclxuICAgKiBNdWx0aXBsZSBpbnZvY2F0aW9ucyBvZiBmb3IgZXhhbXBsZSBbW3RvSXRlbUFycmF5XV0gbWF5IHlpZWxkIGRpZmZlcmVudCByZXN1bHRzIChpZiB0aGUgZGF0YSBzb3VyY2UgbGlrZSBmb3IgZXhhbXBsZSBbW0RhdGFTZXRdXSBnZXRzIG1vZGlmaWVkKS5cclxuICAgKiBAdHlwZVBhcmFtIEl0ZW0gLSBUaGUgaXRlbSB0eXBlIHRoaXMgc3RyZWFtIGlzIGdvaW5nIHRvIHdvcmsgd2l0aC5cclxuICAgKi9cbiAgdmFyIERhdGFTdHJlYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGRhdGEgc3RyZWFtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYWlycyAtIFRoZSBpZCwgaXRlbSBwYWlycy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERhdGFTdHJlYW0ocGFpcnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhU3RyZWFtKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhaXJzXCIsIHZvaWQgMCk7XG5cbiAgICAgIHRoaXMuX3BhaXJzID0gcGFpcnM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGFuIGl0ZXJhYmxlIG9mIGtleSwgdmFsdWUgcGFpcnMgZm9yIGV2ZXJ5IGVudHJ5IGluIHRoZSBzdHJlYW0uXHJcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKERhdGFTdHJlYW0sIFt7XG4gICAgICBrZXk6IF9TeW1ib2wkaXRlcmF0b3IsXG4gICAgICB2YWx1ZTpcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIHJlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IsIF9zdGVwLCBfc3RlcCR2YWx1ZSwgaWQsIGl0ZW07XG5cbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gdmFsdWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIodGhpcy5fcGFpcnMpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnMoKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKChfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksIGlkID0gX3N0ZXAkdmFsdWVbMF0sIGl0ZW0gPSBfc3RlcCR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICByZXR1cm4gW2lkLCBpdGVtXTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxMTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IuZShfY29udGV4dC50MCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTQ7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgxNCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB2YWx1ZSwgdGhpcywgW1sxLCAxMSwgMTQsIDE3XV0pO1xuICAgICAgfSlcbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXR1cm4gYW4gaXRlcmFibGUgb2Yga2V5LCB2YWx1ZSBwYWlycyBmb3IgZXZlcnkgZW50cnkgaW4gdGhlIHN0cmVhbS5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZW50cmllc1wiLFxuICAgICAgdmFsdWU6XG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICByZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IyLCBfc3RlcDIsIF9zdGVwMiR2YWx1ZSwgaWQsIGl0ZW07XG5cbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gZW50cmllcyQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIodGhpcy5fcGFpcnMpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIucygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAoKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfc3RlcDIkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDIudmFsdWUsIDIpLCBpZCA9IF9zdGVwMiR2YWx1ZVswXSwgaXRlbSA9IF9zdGVwMiR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtpZCwgaXRlbV07XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLmUoX2NvbnRleHQyLnQwKTtcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTQ7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDE0KTtcblxuICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBlbnRyaWVzLCB0aGlzLCBbWzEsIDExLCAxNCwgMTddXSk7XG4gICAgICB9KVxuICAgICAgLyoqXHJcbiAgICAgICAqIFJldHVybiBhbiBpdGVyYWJsZSBvZiBrZXlzIGluIHRoZSBzdHJlYW0uXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImtleXNcIixcbiAgICAgIHZhbHVlOlxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yMywgX3N0ZXAzLCBfc3RlcDMkdmFsdWUsIGlkO1xuXG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIGtleXMkKF9jb250ZXh0Mykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKHRoaXMuX3BhaXJzKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDE7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IzLnMoKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKChfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3N0ZXAzJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAzLnZhbHVlLCAxKSwgaWQgPSBfc3RlcDMkdmFsdWVbMF07XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxMTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMuZShfY29udGV4dDMudDApO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxNDtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5maW5pc2goMTQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIGtleXMsIHRoaXMsIFtbMSwgMTEsIDE0LCAxN11dKTtcbiAgICAgIH0pXG4gICAgICAvKipcclxuICAgICAgICogUmV0dXJuIGFuIGl0ZXJhYmxlIG9mIHZhbHVlcyBpbiB0aGUgc3RyZWFtLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ2YWx1ZXNcIixcbiAgICAgIHZhbHVlOlxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3I0LCBfc3RlcDQsIF9zdGVwNCR2YWx1ZSwgaXRlbTtcblxuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiB2YWx1ZXMkKF9jb250ZXh0NCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKHRoaXMuX3BhaXJzKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDE7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3I0LnMoKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKChfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3N0ZXA0JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA0LnZhbHVlLCAyKSwgaXRlbSA9IF9zdGVwNCR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gX2NvbnRleHQ0W1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3I0LmUoX2NvbnRleHQ0LnQwKTtcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMTQ7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3I0LmYoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuZmluaXNoKDE0KTtcblxuICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB2YWx1ZXMsIHRoaXMsIFtbMSwgMTEsIDE0LCAxN11dKTtcbiAgICAgIH0pXG4gICAgICAvKipcclxuICAgICAgICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBpZHMgaW4gdGhpcyBzdHJlYW0uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZW1hcmtzXHJcbiAgICAgICAqIFRoZSBhcnJheSBtYXkgY29udGFpbiBkdXBsaWNpdGllcy5cclxuICAgICAgICogQHJldHVybnMgVGhlIGFycmF5IHdpdGggYWxsIGlkcyBmcm9tIHRoaXMgc3RyZWFtLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b0lkQXJyYXlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0lkQXJyYXkoKSB7XG4gICAgICAgIHZhciBfY29udGV4dDU7XG5cbiAgICAgICAgcmV0dXJuIG1hcCQzKF9jb250ZXh0NSA9IF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9wYWlycykpLmNhbGwoX2NvbnRleHQ1LCBmdW5jdGlvbiAocGFpcikge1xuICAgICAgICAgIHJldHVybiBwYWlyWzBdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIGl0ZW1zIGluIHRoaXMgc3RyZWFtLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmVtYXJrc1xyXG4gICAgICAgKiBUaGUgYXJyYXkgbWF5IGNvbnRhaW4gZHVwbGljaXRpZXMuXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSBhcnJheSB3aXRoIGFsbCBpdGVtcyBmcm9tIHRoaXMgc3RyZWFtLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b0l0ZW1BcnJheVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSXRlbUFycmF5KCkge1xuICAgICAgICB2YXIgX2NvbnRleHQ2O1xuXG4gICAgICAgIHJldHVybiBtYXAkMyhfY29udGV4dDYgPSBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fcGFpcnMpKS5jYWxsKF9jb250ZXh0NiwgZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICByZXR1cm4gcGFpclsxXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBlbnRyaWVzIGluIHRoaXMgc3RyZWFtLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmVtYXJrc1xyXG4gICAgICAgKiBUaGUgYXJyYXkgbWF5IGNvbnRhaW4gZHVwbGljaXRpZXMuXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSBhcnJheSB3aXRoIGFsbCBlbnRyaWVzIGZyb20gdGhpcyBzdHJlYW0uXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInRvRW50cnlBcnJheVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvRW50cnlBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9wYWlycyk7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogUmV0dXJuIGFuIG9iamVjdCBtYXAgY29udGFpbmluZyBhbGwgdGhlIGl0ZW1zIGluIHRoaXMgc3RyZWFtIGFjY2Vzc2libGUgYnkgaWRzLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmVtYXJrc1xyXG4gICAgICAgKiBJbiBjYXNlIG9mIGR1cGxpY2F0ZSBpZHMgKGNvZXJjZWQgdG8gc3RyaW5nIHNvIGA3ID09ICc3J2ApIHRoZSBsYXN0IGVuY291dGVyZWQgYXBwZWFycyBpbiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgb2JqZWN0IG1hcCBvZiBhbGwgaWQg4oaSIGl0ZW0gcGFpcnMgZnJvbSB0aGlzIHN0cmVhbS5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidG9PYmplY3RNYXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b09iamVjdE1hcCgpIHtcbiAgICAgICAgdmFyIG1hcCA9IGNyZWF0ZSQ1KG51bGwpO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMih0aGlzLl9wYWlycyksXG4gICAgICAgICAgICBfc3RlcDU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIF9zdGVwNSR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNS52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgaWQgPSBfc3RlcDUkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgaXRlbSA9IF9zdGVwNSR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgbWFwW2lkXSA9IGl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogUmV0dXJuIGEgbWFwIGNvbnRhaW5pbmcgYWxsIHRoZSBpdGVtcyBpbiB0aGlzIHN0cmVhbSBhY2Nlc3NpYmxlIGJ5IGlkcy5cclxuICAgICAgICpcclxuICAgICAgICogQHJldHVybnMgVGhlIG1hcCBvZiBhbGwgaWQg4oaSIGl0ZW0gcGFpcnMgZnJvbSB0aGlzIHN0cmVhbS5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidG9NYXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b01hcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtYXAodGhpcy5fcGFpcnMpO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIFJldHVybiBhIHNldCBjb250YWluaW5nIGFsbCB0aGUgKHVuaXF1ZSkgaWRzIGluIHRoaXMgc3RyZWFtLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgc2V0IG9mIGFsbCBpZHMgZnJvbSB0aGlzIHN0cmVhbS5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidG9JZFNldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSWRTZXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgc2V0KHRoaXMudG9JZEFycmF5KCkpO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIFJldHVybiBhIHNldCBjb250YWluaW5nIGFsbCB0aGUgKHVuaXF1ZSkgaXRlbXMgaW4gdGhpcyBzdHJlYW0uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSBzZXQgb2YgYWxsIGl0ZW1zIGZyb20gdGhpcyBzdHJlYW0uXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInRvSXRlbVNldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSXRlbVNldCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBzZXQodGhpcy50b0l0ZW1BcnJheSgpKTtcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBDYWNoZSB0aGUgaXRlbXMgZnJvbSB0aGlzIHN0cmVhbS5cclxuICAgICAgICpcclxuICAgICAgICogQHJlbWFya3NcclxuICAgICAgICogVGhpcyBtZXRob2QgYWxsb3dzIGZvciBpdGVtcyB0byBiZSBmZXRjaGVkIGltbWVkaWF0ZWxseSBhbmQgdXNlZCAocG9zc2libHkgbXVsdGlwbGUgdGltZXMpIGxhdGVyLlxyXG4gICAgICAgKiBJdCBjYW4gYWxzbyBiZSB1c2VkIHRvIG9wdGltaXplIHBlcmZvcm1hbmNlIGFzIFtbRGF0YVN0cmVhbV1dIHdvdWxkIG90aGVyd2lzZSByZWV2YWx1YXRlIGV2ZXJ5dGhpbmcgdXBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgICAgICpcclxuICAgICAgICogIyMgRXhhbXBsZVxyXG4gICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAqIGNvbnN0IGRzID0gbmV3IERhdGFTZXQoW+KApl0pXHJcbiAgICAgICAqXHJcbiAgICAgICAqIGNvbnN0IGNhY2hlZFN0cmVhbSA9IGRzLnN0cmVhbSgpXHJcbiAgICAgICAqICAgLmZpbHRlcijigKYpXHJcbiAgICAgICAqICAgLnNvcnQo4oCmKVxyXG4gICAgICAgKiAgIC5tYXAo4oCmKVxyXG4gICAgICAgKiAgIC5jYWNoZWQo4oCmKSAvLyBEYXRhIGFyZSBmZXRjaGVkLCBwcm9jZXNzZWQgYW5kIGNhY2hlZCBoZXJlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBkcy5jbGVhcigpXHJcbiAgICAgICAqIGNoYWNoZWRTdHJlYW0gLy8gU3RpbGwgaGFzIGFsbCB0aGUgaXRlbXMuXHJcbiAgICAgICAqIGBgYFxyXG4gICAgICAgKiBAcmV0dXJucyBBIG5ldyBbW0RhdGFTdHJlYW1dXSB3aXRoIGNhY2hlZCBpdGVtcyAoZGV0YWNoZWQgZnJvbSB0aGUgb3JpZ2luYWwgW1tEYXRhU2V0XV0pLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjYWNoZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhY2hlKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGFTdHJlYW0oX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX3BhaXJzKSk7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogR2V0IHRoZSBkaXN0aW5jdCB2YWx1ZXMgb2YgZ2l2ZW4gcHJvcGVydHkuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IHBpY2tzIGFuZCBwb3NzaWJseSBjb252ZXJ0cyB0aGUgcHJvcGVydHkuXHJcbiAgICAgICAqIEB0eXBlUGFyYW0gVCAtIFRoZSB0eXBlIG9mIHRoZSBkaXN0aW5jdCB2YWx1ZS5cclxuICAgICAgICogQHJldHVybnMgQSBzZXQgb2YgYWxsIGRpc3RpbmN0IHByb3BlcnRpZXMuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImRpc3RpbmN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGluY3QoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNldCQxID0gbmV3IHNldCgpO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMih0aGlzLl9wYWlycyksXG4gICAgICAgICAgICBfc3RlcDY7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIF9zdGVwNiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNi52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgaWQgPSBfc3RlcDYkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgaXRlbSA9IF9zdGVwNiR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgc2V0JDEuYWRkKGNhbGxiYWNrKGl0ZW0sIGlkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXQkMTtcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBGaWx0ZXIgdGhlIGl0ZW1zIG9mIHRoZSBzdHJlYW0uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IGRlY2lkZXMgd2hldGhlciBhbiBpdGVtIHdpbGwgYmUgaW5jbHVkZWQuXHJcbiAgICAgICAqIEByZXR1cm5zIEEgbmV3IGRhdGEgc3RyZWFtIHdpdGggdGhlIGZpbHRlcmVkIGl0ZW1zLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmaWx0ZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHBhaXJzID0gdGhpcy5fcGFpcnM7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbShfZGVmaW5lUHJvcGVydHkoe30sIGl0ZXJhdG9yLCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3I3LCBfc3RlcDcsIF9zdGVwNyR2YWx1ZSwgaWQsIGl0ZW07XG5cbiAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dDcpIHtcbiAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKHBhaXJzKTtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMTtcblxuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNy5zKCk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICBpZiAoKF9zdGVwNyA9IF9pdGVyYXRvcjcubigpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfc3RlcDckdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDcudmFsdWUsIDIpLCBpZCA9IF9zdGVwNyR2YWx1ZVswXSwgaXRlbSA9IF9zdGVwNyR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFjayhpdGVtLCBpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtpZCwgaXRlbV07XG5cbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAxMjtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny50MCA9IF9jb250ZXh0N1tcImNhdGNoXCJdKDEpO1xuXG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3I3LmUoX2NvbnRleHQ3LnQwKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDE1O1xuXG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3I3LmYoKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5maW5pc2goMTUpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMSwgMTIsIDE1LCAxOF1dKTtcbiAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggaXRlbSBvZiB0aGUgc3RyZWFtLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgZm9yIGVhY2ggaXRlbS5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjggPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKHRoaXMuX3BhaXJzKSxcbiAgICAgICAgICAgIF9zdGVwODtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yOC5zKCk7ICEoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgX3N0ZXA4JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA4LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICBpZCA9IF9zdGVwOCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICBpdGVtID0gX3N0ZXA4JHZhbHVlWzFdO1xuXG4gICAgICAgICAgICBjYWxsYmFjayhpdGVtLCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3I4LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3I4LmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIE1hcCB0aGUgaXRlbXMgaW50byBhIGRpZmZlcmVudCB0eXBlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdGhhdCBkb2VzIHRoZSBjb252ZXJzaW9uLlxyXG4gICAgICAgKiBAdHlwZVBhcmFtIE1hcHBlZCAtIFRoZSB0eXBlIG9mIHRoZSBpdGVtIGFmdGVyIG1hcHBpbmcuXHJcbiAgICAgICAqIEByZXR1cm5zIEEgbmV3IGRhdGEgc3RyZWFtIHdpdGggdGhlIG1hcHBlZCBpdGVtcy5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWFwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBwYWlycyA9IHRoaXMuX3BhaXJzO1xuICAgICAgICByZXR1cm4gbmV3IERhdGFTdHJlYW0oX2RlZmluZVByb3BlcnR5KHt9LCBpdGVyYXRvciwgLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjksIF9zdGVwOSwgX3N0ZXA5JHZhbHVlLCBpZCwgaXRlbTtcblxuICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDgpIHtcbiAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjkgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKHBhaXJzKTtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5wcmV2ID0gMTtcblxuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yOS5zKCk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICBpZiAoKF9zdGVwOSA9IF9pdGVyYXRvcjkubigpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIF9zdGVwOSR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwOS52YWx1ZSwgMiksIGlkID0gX3N0ZXA5JHZhbHVlWzBdLCBpdGVtID0gX3N0ZXA5JHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtpZCwgY2FsbGJhY2soaXRlbSwgaWQpXTtcblxuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgudDAgPSBfY29udGV4dDhbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yOS5lKF9jb250ZXh0OC50MCk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAxNDtcblxuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yOS5mKCk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguZmluaXNoKDE0KTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBfY2FsbGVlMiwgbnVsbCwgW1sxLCAxMSwgMTQsIDE3XV0pO1xuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIEdldCB0aGUgaXRlbSB3aXRoIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGdpdmVuIHByb3BlcnR5LlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdGhhdCBwaWNrcyBhbmQgcG9zc2libHkgY29udmVydHMgdGhlIHByb3BlcnR5LlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSB3aXRoIHRoZSBtYXhpbXVtIGlmIGZvdW5kIG90aGVyd2lzZSBudWxsLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXgoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGl0ZXIgPSBnZXRJdGVyYXRvcih0aGlzLl9wYWlycyk7XG5cbiAgICAgICAgdmFyIGN1cnIgPSBpdGVyLm5leHQoKTtcblxuICAgICAgICBpZiAoY3Vyci5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF4SXRlbSA9IGN1cnIudmFsdWVbMV07XG4gICAgICAgIHZhciBtYXhWYWx1ZSA9IGNhbGxiYWNrKGN1cnIudmFsdWVbMV0sIGN1cnIudmFsdWVbMF0pO1xuXG4gICAgICAgIHdoaWxlICghKGN1cnIgPSBpdGVyLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBfY3VyciR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KGN1cnIudmFsdWUsIDIpLFxuICAgICAgICAgICAgICBpZCA9IF9jdXJyJHZhbHVlWzBdLFxuICAgICAgICAgICAgICBpdGVtID0gX2N1cnIkdmFsdWVbMV07XG5cbiAgICAgICAgICB2YXIgX3ZhbHVlID0gY2FsbGJhY2soaXRlbSwgaWQpO1xuXG4gICAgICAgICAgaWYgKF92YWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgICAgICAgICBtYXhWYWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgICAgIG1heEl0ZW0gPSBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXhJdGVtO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIEdldCB0aGUgaXRlbSB3aXRoIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGdpdmVuIHByb3BlcnR5LlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdGhhdCBwaWNrcyBhbmQgcG9zc2libHkgY29udmVydHMgdGhlIHByb3BlcnR5LlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSB3aXRoIHRoZSBtaW5pbXVtIGlmIGZvdW5kIG90aGVyd2lzZSBudWxsLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtaW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtaW4oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGl0ZXIgPSBnZXRJdGVyYXRvcih0aGlzLl9wYWlycyk7XG5cbiAgICAgICAgdmFyIGN1cnIgPSBpdGVyLm5leHQoKTtcblxuICAgICAgICBpZiAoY3Vyci5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluSXRlbSA9IGN1cnIudmFsdWVbMV07XG4gICAgICAgIHZhciBtaW5WYWx1ZSA9IGNhbGxiYWNrKGN1cnIudmFsdWVbMV0sIGN1cnIudmFsdWVbMF0pO1xuXG4gICAgICAgIHdoaWxlICghKGN1cnIgPSBpdGVyLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBfY3VyciR2YWx1ZTIgPSBfc2xpY2VkVG9BcnJheShjdXJyLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgaWQgPSBfY3VyciR2YWx1ZTJbMF0sXG4gICAgICAgICAgICAgIGl0ZW0gPSBfY3VyciR2YWx1ZTJbMV07XG5cbiAgICAgICAgICB2YXIgX3ZhbHVlMiA9IGNhbGxiYWNrKGl0ZW0sIGlkKTtcblxuICAgICAgICAgIGlmIChfdmFsdWUyIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICAgIG1pblZhbHVlID0gX3ZhbHVlMjtcbiAgICAgICAgICAgIG1pbkl0ZW0gPSBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtaW5JdGVtO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIFJlZHVjZSB0aGUgaXRlbXMgaW50byBhIHNpbmdsZSB2YWx1ZS5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRoYXQgZG9lcyB0aGUgcmVkdWN0aW9uLlxyXG4gICAgICAgKiBAcGFyYW0gYWNjdW11bGF0b3IgLSBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXHJcbiAgICAgICAqIEB0eXBlUGFyYW0gVCAtIFRoZSB0eXBlIG9mIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cclxuICAgICAgICogQHJldHVybnMgVGhlIHJlZHVjZWQgdmFsdWUuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJlZHVjZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFjaywgYWNjdW11bGF0b3IpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjEwID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMih0aGlzLl9wYWlycyksXG4gICAgICAgICAgICBfc3RlcDEwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IxMC5zKCk7ICEoX3N0ZXAxMCA9IF9pdGVyYXRvcjEwLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBfc3RlcDEwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAxMC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgaWQgPSBfc3RlcDEwJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIGl0ZW0gPSBfc3RlcDEwJHZhbHVlWzFdO1xuXG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBpdGVtLCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IxMC5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMTAuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIFNvcnQgdGhlIGl0ZW1zLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBJdGVtIGNvbXBhcmF0b3IuXHJcbiAgICAgICAqIEByZXR1cm5zIEEgbmV3IHN0cmVhbSB3aXRoIHNvcnRlZCBpdGVtcy5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic29ydFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQkMShjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbShfZGVmaW5lUHJvcGVydHkoe30sIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0OTtcblxuICAgICAgICAgIHJldHVybiBnZXRJdGVyYXRvcihzb3J0KF9jb250ZXh0OSA9IF90b0NvbnN1bWFibGVBcnJheShfdGhpcy5fcGFpcnMpKS5jYWxsKF9jb250ZXh0OSwgZnVuY3Rpb24gKF9yZWYsIF9yZWYyKSB7XG4gICAgICAgICAgICB2YXIgX3JlZjMgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgICAgICBpZEEgPSBfcmVmM1swXSxcbiAgICAgICAgICAgICAgICBpdGVtQSA9IF9yZWYzWzFdO1xuXG4gICAgICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMiwgMiksXG4gICAgICAgICAgICAgICAgaWRCID0gX3JlZjRbMF0sXG4gICAgICAgICAgICAgICAgaXRlbUIgPSBfcmVmNFsxXTtcblxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGl0ZW1BLCBpdGVtQiwgaWRBLCBpZEIpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBEYXRhU3RyZWFtO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0ga2V5cyQ0KG9iamVjdCk7IGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBmaWx0ZXIoc3ltYm9scykuY2FsbChzeW1ib2xzLCBmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbiAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIF9jb250ZXh0MTAsIF9jb250ZXh0MTE7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IGZvckVhY2gkMShfY29udGV4dDEwID0gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApKS5jYWxsKF9jb250ZXh0MTAsIGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogZm9yRWFjaCQxKF9jb250ZXh0MTEgPSBvd25LZXlzKE9iamVjdChzb3VyY2UpKSkuY2FsbChfY29udGV4dDExLCBmdW5jdGlvbiAoa2V5KSB7IGRlZmluZVByb3BlcnR5JDQodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2Ygc3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGdldEl0ZXJhdG9yTWV0aG9kJDEobykgfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKGlzQXJyYXkkMShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbiAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEobywgbWluTGVuKSB7IHZhciBfY29udGV4dDk7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IHZhciBuID0gc2xpY2UoX2NvbnRleHQ5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0OSwgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gZnJvbSQzKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDEobywgbWluTGVuKTsgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDEoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDEoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG4gIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4gIC8qKlxyXG4gICAqIEFkZCBhbiBpZCB0byBnaXZlbiBpdGVtIGlmIGl0IGRvZXNuJ3QgaGF2ZSBvbmUgYWxyZWFkeS5cclxuICAgKlxyXG4gICAqIEByZW1hcmtzXHJcbiAgICogVGhlIGl0ZW0gd2lsbCBiZSBtb2RpZmllZC5cclxuICAgKiBAcGFyYW0gaXRlbSAtIFRoZSBpdGVtIHRoYXQgd2lsbCBoYXZlIGFuIGlkIGFmdGVyIGEgY2FsbCB0byB0aGlzIGZ1bmN0aW9uLlxyXG4gICAqIEBwYXJhbSBpZFByb3AgLSBUaGUga2V5IG9mIHRoZSBpZCBwcm9wZXJ0eS5cclxuICAgKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxyXG4gICAqIEB0eXBlUGFyYW0gSWRQcm9wIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGUgaWQuXHJcbiAgICogQHJldHVybnMgdHJ1ZVxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUZ1bGxJdGVtKGl0ZW0sIGlkUHJvcCkge1xuICAgIGlmIChpdGVtW2lkUHJvcF0gPT0gbnVsbCkge1xuICAgICAgLy8gZ2VuZXJhdGUgYW4gaWRcbiAgICAgIGl0ZW1baWRQcm9wXSA9IHY0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgLyoqXHJcbiAgICogIyBEYXRhU2V0XHJcbiAgICpcclxuICAgKiBWaXMuanMgY29tZXMgd2l0aCBhIGZsZXhpYmxlIERhdGFTZXQsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGhvbGQgYW5kXHJcbiAgICogbWFuaXB1bGF0ZSB1bnN0cnVjdHVyZWQgZGF0YSBhbmQgbGlzdGVuIGZvciBjaGFuZ2VzIGluIHRoZSBkYXRhLiBUaGUgRGF0YVNldFxyXG4gICAqIGlzIGtleS92YWx1ZSBiYXNlZC4gRGF0YSBpdGVtcyBjYW4gYmUgYWRkZWQsIHVwZGF0ZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGVcclxuICAgKiBEYXRhU2V0LCBhbmQgb25lIGNhbiBzdWJzY3JpYmUgdG8gY2hhbmdlcyBpbiB0aGUgRGF0YVNldC4gVGhlIGRhdGEgaW4gdGhlXHJcbiAgICogRGF0YVNldCBjYW4gYmUgZmlsdGVyZWQgYW5kIG9yZGVyZWQuIERhdGEgY2FuIGJlIG5vcm1hbGl6ZWQgd2hlbiBhcHBlbmRpbmcgaXRcclxuICAgKiB0byB0aGUgRGF0YVNldCBhcyB3ZWxsLlxyXG4gICAqXHJcbiAgICogIyMgRXhhbXBsZVxyXG4gICAqXHJcbiAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byB1c2UgYSBEYXRhU2V0LlxyXG4gICAqXHJcbiAgICogYGBgamF2YXNjcmlwdFxyXG4gICAqIC8vIGNyZWF0ZSBhIERhdGFTZXRcclxuICAgKiB2YXIgb3B0aW9ucyA9IHt9O1xyXG4gICAqIHZhciBkYXRhID0gbmV3IHZpcy5EYXRhU2V0KG9wdGlvbnMpO1xyXG4gICAqXHJcbiAgICogLy8gYWRkIGl0ZW1zXHJcbiAgICogLy8gbm90ZSB0aGF0IHRoZSBkYXRhIGl0ZW1zIGNhbiBjb250YWluIGRpZmZlcmVudCBwcm9wZXJ0aWVzIGFuZCBkYXRhIGZvcm1hdHNcclxuICAgKiBkYXRhLmFkZChbXHJcbiAgICogICB7aWQ6IDEsIHRleHQ6ICdpdGVtIDEnLCBkYXRlOiBuZXcgRGF0ZSgyMDEzLCA2LCAyMCksIGdyb3VwOiAxLCBmaXJzdDogdHJ1ZX0sXHJcbiAgICogICB7aWQ6IDIsIHRleHQ6ICdpdGVtIDInLCBkYXRlOiAnMjAxMy0wNi0yMycsIGdyb3VwOiAyfSxcclxuICAgKiAgIHtpZDogMywgdGV4dDogJ2l0ZW0gMycsIGRhdGU6ICcyMDEzLTA2LTI1JywgZ3JvdXA6IDJ9LFxyXG4gICAqICAge2lkOiA0LCB0ZXh0OiAnaXRlbSA0J31cclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIHN1YnNjcmliZSB0byBhbnkgY2hhbmdlIGluIHRoZSBEYXRhU2V0XHJcbiAgICogZGF0YS5vbignKicsIGZ1bmN0aW9uIChldmVudCwgcHJvcGVydGllcywgc2VuZGVySWQpIHtcclxuICAgKiAgIGNvbnNvbGUubG9nKCdldmVudCcsIGV2ZW50LCBwcm9wZXJ0aWVzKTtcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIC8vIHVwZGF0ZSBhbiBleGlzdGluZyBpdGVtXHJcbiAgICogZGF0YS51cGRhdGUoe2lkOiAyLCBncm91cDogMX0pO1xyXG4gICAqXHJcbiAgICogLy8gcmVtb3ZlIGFuIGl0ZW1cclxuICAgKiBkYXRhLnJlbW92ZSg0KTtcclxuICAgKlxyXG4gICAqIC8vIGdldCBhbGwgaWRzXHJcbiAgICogdmFyIGlkcyA9IGRhdGEuZ2V0SWRzKCk7XHJcbiAgICogY29uc29sZS5sb2coJ2lkcycsIGlkcyk7XHJcbiAgICpcclxuICAgKiAvLyBnZXQgYSBzcGVjaWZpYyBpdGVtXHJcbiAgICogdmFyIGl0ZW0xID0gZGF0YS5nZXQoMSk7XHJcbiAgICogY29uc29sZS5sb2coJ2l0ZW0xJywgaXRlbTEpO1xyXG4gICAqXHJcbiAgICogLy8gcmV0cmlldmUgYSBmaWx0ZXJlZCBzdWJzZXQgb2YgdGhlIGRhdGFcclxuICAgKiB2YXIgaXRlbXMgPSBkYXRhLmdldCh7XHJcbiAgICogICBmaWx0ZXI6IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICogICAgIHJldHVybiBpdGVtLmdyb3VwID09IDE7XHJcbiAgICogICB9XHJcbiAgICogfSk7XHJcbiAgICogY29uc29sZS5sb2coJ2ZpbHRlcmVkIGl0ZW1zJywgaXRlbXMpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQHR5cGVQYXJhbSBJdGVtIC0gSXRlbSB0eXBlIHRoYXQgbWF5IG9yIG1heSBub3QgaGF2ZSBhbiBpZC5cclxuICAgKiBAdHlwZVBhcmFtIElkUHJvcCAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlIGlkLlxyXG4gICAqL1xuXG5cbiAgdmFyIERhdGFTZXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EYXRhU2V0UGFydCkge1xuICAgIF9pbmhlcml0cyhEYXRhU2V0LCBfRGF0YVNldFBhcnQpO1xuXG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQxKERhdGFTZXQpO1xuXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgRGF0YVNldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIEluaXRpYWwgZGF0YSBvciBvcHRpb25zLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zICh0eXBlIGVycm9yIGlmIGRhdGEgaXMgYWxzbyBvcHRpb25zKS5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERhdGFTZXQoZGF0YSwgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YVNldCk7XG5cbiAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7IC8vIGNvcnJlY3RseSByZWFkIG9wdGlvbmFsIGFyZ3VtZW50c1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZmx1c2hcIiwgdm9pZCAwKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImxlbmd0aFwiLCB2b2lkIDApO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX29wdGlvbnNcIiwgdm9pZCAwKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9kYXRhXCIsIHZvaWQgMCk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfaWRQcm9wXCIsIHZvaWQgMCk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfcXVldWVcIiwgbnVsbCk7XG5cbiAgICAgIGlmIChkYXRhICYmICFpc0FycmF5JDEoZGF0YSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IGRhdGE7XG4gICAgICAgIGRhdGEgPSBbXTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgX3RoaXMuX2RhdGEgPSBuZXcgbWFwKCk7IC8vIG1hcCB3aXRoIGRhdGEgaW5kZXhlZCBieSBpZFxuXG4gICAgICBfdGhpcy5sZW5ndGggPSAwOyAvLyBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIERhdGFTZXRcblxuICAgICAgX3RoaXMuX2lkUHJvcCA9IF90aGlzLl9vcHRpb25zLmZpZWxkSWQgfHwgXCJpZFwiOyAvLyBuYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIGlkXG4gICAgICAvLyBhZGQgaW5pdGlhbCBkYXRhIHdoZW4gcHJvdmlkZWRcblxuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgX3RoaXMuYWRkKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU2V0IG5ldyBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG5ldyBvcHRpb25zLlxyXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhEYXRhU2V0LCBbe1xuICAgICAga2V5OiBcImlkUHJvcFwiLFxuICAgICAgZ2V0OlxuICAgICAgLyoqIEZsdXNoIGFsbCBxdWV1ZWQgY2FsbHMuICovXG5cbiAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gICAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkUHJvcDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnF1ZXVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5xdWV1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIGRlbGV0ZSBxdWV1ZSBpZiBsb2FkZWRcbiAgICAgICAgICAgIGlmICh0aGlzLl9xdWV1ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5kZXN0cm95KCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fcXVldWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgcXVldWUgYW5kIHVwZGF0ZSBpdHMgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9xdWV1ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9xdWV1ZSA9IFF1ZXVlLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZTogW1wiYWRkXCIsIFwidXBkYXRlXCIsIFwicmVtb3ZlXCJdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5xdWV1ZSAmJiBfdHlwZW9mKG9wdGlvbnMucXVldWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnNldE9wdGlvbnMob3B0aW9ucy5xdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogQWRkIGEgZGF0YSBpdGVtIG9yIGFuIGFycmF5IHdpdGggaXRlbXMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEFmdGVyIHRoZSBpdGVtcyBhcmUgYWRkZWQgdG8gdGhlIERhdGFTZXQsIHRoZSBEYXRhU2V0IHdpbGwgdHJpZ2dlciBhbiBldmVudCBgYWRkYC4gV2hlbiBhIGBzZW5kZXJJZGAgaXMgcHJvdmlkZWQsIHRoaXMgaWQgd2lsbCBiZSBwYXNzZWQgd2l0aCB0aGUgdHJpZ2dlcmVkIGV2ZW50IHRvIGFsbCBzdWJzY3JpYmVycy5cclxuICAgICAgICpcclxuICAgICAgICogIyMgRXhhbXBsZVxyXG4gICAgICAgKlxyXG4gICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAqIC8vIGNyZWF0ZSBhIERhdGFTZXRcclxuICAgICAgICogY29uc3QgZGF0YSA9IG5ldyB2aXMuRGF0YVNldCgpXHJcbiAgICAgICAqXHJcbiAgICAgICAqIC8vIGFkZCBpdGVtc1xyXG4gICAgICAgKiBjb25zdCBpZHMgPSBkYXRhLmFkZChbXHJcbiAgICAgICAqICAgeyBpZDogMSwgdGV4dDogJ2l0ZW0gMScgfSxcclxuICAgICAgICogICB7IGlkOiAyLCB0ZXh0OiAnaXRlbSAyJyB9LFxyXG4gICAgICAgKiAgIHsgdGV4dDogJ2l0ZW0gd2l0aG91dCBhbiBpZCcgfVxyXG4gICAgICAgKiBdKVxyXG4gICAgICAgKlxyXG4gICAgICAgKiBjb25zb2xlLmxvZyhpZHMpIC8vIFsxLCAyLCAnPFVVSUR2ND4nXVxyXG4gICAgICAgKiBgYGBcclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIGRhdGEgLSBJdGVtcyB0byBiZSBhZGRlZCAoaWRzIHdpbGwgYmUgZ2VuZXJhdGVkIGlmIG1pc3NpbmcpLlxyXG4gICAgICAgKiBAcGFyYW0gc2VuZGVySWQgLSBTZW5kZXIgaWQuXHJcbiAgICAgICAqIEByZXR1cm5zIGFkZGVkSWRzIC0gQXJyYXkgd2l0aCB0aGUgaWRzIChnZW5lcmF0ZWQgaWYgbm90IHByZXNlbnQpIG9mIHRoZSBhZGRlZCBpdGVtcy5cclxuICAgICAgICogQHRocm93cyBXaGVuIGFuIGl0ZW0gd2l0aCB0aGUgc2FtZSBpZCBhcyBhbnkgb2YgdGhlIGFkZGVkIGl0ZW1zIGFscmVhZHkgZXhpc3RzLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZGF0YSwgc2VuZGVySWQpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGFkZGVkSWRzID0gW107XG4gICAgICAgIHZhciBpZDtcblxuICAgICAgICBpZiAoaXNBcnJheSQxKGRhdGEpKSB7XG4gICAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgICB2YXIgaWRzVG9BZGQgPSBtYXAkMyhkYXRhKS5jYWxsKGRhdGEsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZFtfdGhpczIuX2lkUHJvcF07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoc29tZShpZHNUb0FkZCkuY2FsbChpZHNUb0FkZCwgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9kYXRhLmhhcyhpZCk7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgZHVwbGljYXRlIGlkIHdhcyBmb3VuZCBpbiB0aGUgcGFyYW1ldGVyIGFycmF5LlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWQgPSB0aGlzLl9hZGRJdGVtKGRhdGFbaV0pO1xuICAgICAgICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgJiYgX3R5cGVvZihkYXRhKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIC8vIFNpbmdsZSBpdGVtXG4gICAgICAgICAgaWQgPSB0aGlzLl9hZGRJdGVtKGRhdGEpO1xuICAgICAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YVR5cGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWRkZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlcihcImFkZFwiLCB7XG4gICAgICAgICAgICBpdGVtczogYWRkZWRJZHNcbiAgICAgICAgICB9LCBzZW5kZXJJZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWRkZWRJZHM7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogVXBkYXRlIGV4aXN0aW5nIGl0ZW1zLiBXaGVuIGFuIGl0ZW0gZG9lcyBub3QgZXhpc3QsIGl0IHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICAgICpcclxuICAgICAgICogQHJlbWFya3NcclxuICAgICAgICogVGhlIHByb3ZpZGVkIHByb3BlcnRpZXMgd2lsbCBiZSBtZXJnZWQgaW4gdGhlIGV4aXN0aW5nIGl0ZW0uIFdoZW4gYW4gaXRlbSBkb2VzIG5vdCBleGlzdCwgaXQgd2lsbCBiZSBjcmVhdGVkLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBBZnRlciB0aGUgaXRlbXMgYXJlIHVwZGF0ZWQsIHRoZSBEYXRhU2V0IHdpbGwgdHJpZ2dlciBhbiBldmVudCBgYWRkYCBmb3IgdGhlIGFkZGVkIGl0ZW1zLCBhbmQgYW4gZXZlbnQgYHVwZGF0ZWAuIFdoZW4gYSBgc2VuZGVySWRgIGlzIHByb3ZpZGVkLCB0aGlzIGlkIHdpbGwgYmUgcGFzc2VkIHdpdGggdGhlIHRyaWdnZXJlZCBldmVudCB0byBhbGwgc3Vic2NyaWJlcnMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqICMjIEV4YW1wbGVcclxuICAgICAgICpcclxuICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgKiAvLyBjcmVhdGUgYSBEYXRhU2V0XHJcbiAgICAgICAqIGNvbnN0IGRhdGEgPSBuZXcgdmlzLkRhdGFTZXQoW1xyXG4gICAgICAgKiAgIHsgaWQ6IDEsIHRleHQ6ICdpdGVtIDEnIH0sXHJcbiAgICAgICAqICAgeyBpZDogMiwgdGV4dDogJ2l0ZW0gMicgfSxcclxuICAgICAgICogICB7IGlkOiAzLCB0ZXh0OiAnaXRlbSAzJyB9XHJcbiAgICAgICAqIF0pXHJcbiAgICAgICAqXHJcbiAgICAgICAqIC8vIHVwZGF0ZSBpdGVtc1xyXG4gICAgICAgKiBjb25zdCBpZHMgPSBkYXRhLnVwZGF0ZShbXHJcbiAgICAgICAqICAgeyBpZDogMiwgdGV4dDogJ2l0ZW0gMiAodXBkYXRlZCknIH0sXHJcbiAgICAgICAqICAgeyBpZDogNCwgdGV4dDogJ2l0ZW0gNCAobmV3KScgfVxyXG4gICAgICAgKiBdKVxyXG4gICAgICAgKlxyXG4gICAgICAgKiBjb25zb2xlLmxvZyhpZHMpIC8vIFsyLCA0XVxyXG4gICAgICAgKiBgYGBcclxuICAgICAgICpcclxuICAgICAgICogIyMgV2FybmluZyBmb3IgVHlwZVNjcmlwdCB1c2Vyc1xyXG4gICAgICAgKiBUaGlzIG1ldGhvZCBtYXkgaW50cm9kdWNlIHBhcnRpYWwgaXRlbXMgaW50byB0aGUgZGF0YSBzZXQuIFVzZSBhZGQgb3IgdXBkYXRlT25seSBpbnN0ZWFkIGZvciBiZXR0ZXIgdHlwZSBzYWZldHkuXHJcbiAgICAgICAqIEBwYXJhbSBkYXRhIC0gSXRlbXMgdG8gYmUgdXBkYXRlZCAoaWYgdGhlIGlkIGlzIGFscmVhZHkgcHJlc2VudCkgb3IgYWRkZWQgKGlmIHRoZSBpZCBpcyBtaXNzaW5nKS5cclxuICAgICAgICogQHBhcmFtIHNlbmRlcklkIC0gU2VuZGVyIGlkLlxyXG4gICAgICAgKiBAcmV0dXJucyB1cGRhdGVkSWRzIC0gVGhlIGlkcyBvZiB0aGUgYWRkZWQgKHRoZXNlIG1heSBiZSBuZXdseSBnZW5lcmF0ZWQgaWYgdGhlcmUgd2FzIG5vIGlkIGluIHRoZSBpdGVtIGZyb20gdGhlIGRhdGEpIG9yIHVwZGF0ZWQgaXRlbXMuXHJcbiAgICAgICAqIEB0aHJvd3MgV2hlbiB0aGUgc3VwcGxpZWQgZGF0YSBpcyBuZWl0aGVyIGFuIGl0ZW0gbm9yIGFuIGFycmF5IG9mIGl0ZW1zLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoZGF0YSwgc2VuZGVySWQpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGFkZGVkSWRzID0gW107XG4gICAgICAgIHZhciB1cGRhdGVkSWRzID0gW107XG4gICAgICAgIHZhciBvbGREYXRhID0gW107XG4gICAgICAgIHZhciB1cGRhdGVkRGF0YSA9IFtdO1xuICAgICAgICB2YXIgaWRQcm9wID0gdGhpcy5faWRQcm9wO1xuXG4gICAgICAgIHZhciBhZGRPclVwZGF0ZSA9IGZ1bmN0aW9uIGFkZE9yVXBkYXRlKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgb3JpZ0lkID0gaXRlbVtpZFByb3BdO1xuXG4gICAgICAgICAgaWYgKG9yaWdJZCAhPSBudWxsICYmIF90aGlzMy5fZGF0YS5oYXMob3JpZ0lkKSkge1xuICAgICAgICAgICAgdmFyIGZ1bGxJdGVtID0gaXRlbTsgLy8gaXQgaGFzIGFuIGlkLCB0aGVyZWZvcmUgaXQgaXMgYSBmdWxsaXRlbVxuXG4gICAgICAgICAgICB2YXIgb2xkSXRlbSA9IGFzc2lnbiQyKHt9LCBfdGhpczMuX2RhdGEuZ2V0KG9yaWdJZCkpOyAvLyB1cGRhdGUgaXRlbVxuXG5cbiAgICAgICAgICAgIHZhciBpZCA9IF90aGlzMy5fdXBkYXRlSXRlbShmdWxsSXRlbSk7XG5cbiAgICAgICAgICAgIHVwZGF0ZWRJZHMucHVzaChpZCk7XG4gICAgICAgICAgICB1cGRhdGVkRGF0YS5wdXNoKGZ1bGxJdGVtKTtcbiAgICAgICAgICAgIG9sZERhdGEucHVzaChvbGRJdGVtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYWRkIG5ldyBpdGVtXG4gICAgICAgICAgICB2YXIgX2lkID0gX3RoaXMzLl9hZGRJdGVtKGl0ZW0pO1xuXG4gICAgICAgICAgICBhZGRlZElkcy5wdXNoKF9pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpc0FycmF5JDEoZGF0YSkpIHtcbiAgICAgICAgICAvLyBBcnJheVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtpXSAmJiBfdHlwZW9mKGRhdGFbaV0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIGFkZE9yVXBkYXRlKGRhdGFbaV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiSWdub3JpbmcgaW5wdXQgaXRlbSwgd2hpY2ggaXMgbm90IGFuIG9iamVjdCBhdCBpbmRleCBcIiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkYXRhICYmIF90eXBlb2YoZGF0YSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAvLyBTaW5nbGUgaXRlbVxuICAgICAgICAgIGFkZE9yVXBkYXRlKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YVR5cGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWRkZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlcihcImFkZFwiLCB7XG4gICAgICAgICAgICBpdGVtczogYWRkZWRJZHNcbiAgICAgICAgICB9LCBzZW5kZXJJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICBpdGVtczogdXBkYXRlZElkcyxcbiAgICAgICAgICAgIG9sZERhdGE6IG9sZERhdGEsXG4gICAgICAgICAgICBkYXRhOiB1cGRhdGVkRGF0YVxuICAgICAgICAgIH07IC8vIFRPRE86IHJlbW92ZSBkZXByZWNhdGVkIHByb3BlcnR5ICdkYXRhJyBzb21lIGRheVxuICAgICAgICAgIC8vT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAnZGF0YScsIHtcbiAgICAgICAgICAvLyAgJ2dldCc6IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyAgICBjb25zb2xlLndhcm4oJ1Byb3BlcnR5IGRhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIERhdGFTZXQuZ2V0KGlkcykgdG8gcmV0cmlldmUgdGhlIG5ldyBkYXRhLCB1c2UgdGhlIG9sZERhdGEgcHJvcGVydHkgb24gdGhpcyBvYmplY3QgdG8gZ2V0IHRoZSBvbGQgZGF0YScpO1xuICAgICAgICAgIC8vICAgIHJldHVybiB1cGRhdGVkRGF0YTtcbiAgICAgICAgICAvLyAgfSkuYmluZCh0aGlzKVxuICAgICAgICAgIC8vfSk7XG5cbiAgICAgICAgICB0aGlzLl90cmlnZ2VyKFwidXBkYXRlXCIsIHByb3BzLCBzZW5kZXJJZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uY2F0JDEoYWRkZWRJZHMpLmNhbGwoYWRkZWRJZHMsIHVwZGF0ZWRJZHMpO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIFVwZGF0ZSBleGlzdGluZyBpdGVtcy4gV2hlbiBhbiBpdGVtIGRvZXMgbm90IGV4aXN0LCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cclxuICAgICAgICpcclxuICAgICAgICogQHJlbWFya3NcclxuICAgICAgICogVGhlIHByb3ZpZGVkIHByb3BlcnRpZXMgd2lsbCBiZSBkZWVwbHkgbWVyZ2VkIGludG8gdGhlIGV4aXN0aW5nIGl0ZW0uXHJcbiAgICAgICAqIFdoZW4gYW4gaXRlbSBkb2VzIG5vdCBleGlzdCAoaWQgbm90IHByZXNlbnQgaW4gdGhlIGRhdGEgc2V0IG9yIGFic2VudCksIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duIGFuZCBub3RoaW5nIHdpbGwgYmUgY2hhbmdlZC5cclxuICAgICAgICpcclxuICAgICAgICogQWZ0ZXIgdGhlIGl0ZW1zIGFyZSB1cGRhdGVkLCB0aGUgRGF0YVNldCB3aWxsIHRyaWdnZXIgYW4gZXZlbnQgYHVwZGF0ZWAuXHJcbiAgICAgICAqIFdoZW4gYSBgc2VuZGVySWRgIGlzIHByb3ZpZGVkLCB0aGlzIGlkIHdpbGwgYmUgcGFzc2VkIHdpdGggdGhlIHRyaWdnZXJlZCBldmVudCB0byBhbGwgc3Vic2NyaWJlcnMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqICMjIEV4YW1wbGVcclxuICAgICAgICpcclxuICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgKiAvLyBjcmVhdGUgYSBEYXRhU2V0XHJcbiAgICAgICAqIGNvbnN0IGRhdGEgPSBuZXcgdmlzLkRhdGFTZXQoW1xyXG4gICAgICAgKiAgIHsgaWQ6IDEsIHRleHQ6ICdpdGVtIDEnIH0sXHJcbiAgICAgICAqICAgeyBpZDogMiwgdGV4dDogJ2l0ZW0gMicgfSxcclxuICAgICAgICogICB7IGlkOiAzLCB0ZXh0OiAnaXRlbSAzJyB9LFxyXG4gICAgICAgKiBdKVxyXG4gICAgICAgKlxyXG4gICAgICAgKiAvLyB1cGRhdGUgaXRlbXNcclxuICAgICAgICogY29uc3QgaWRzID0gZGF0YS51cGRhdGUoW1xyXG4gICAgICAgKiAgIHsgaWQ6IDIsIHRleHQ6ICdpdGVtIDIgKHVwZGF0ZWQpJyB9LCAvLyB3b3Jrc1xyXG4gICAgICAgKiAgIC8vIHsgaWQ6IDQsIHRleHQ6ICdpdGVtIDQgKG5ldyknIH0sIC8vIHdvdWxkIHRocm93XHJcbiAgICAgICAqICAgLy8geyB0ZXh0OiAnaXRlbSA0IChuZXcpJyB9LCAvLyB3b3VsZCBhbHNvIHRocm93XHJcbiAgICAgICAqIF0pXHJcbiAgICAgICAqXHJcbiAgICAgICAqIGNvbnNvbGUubG9nKGlkcykgLy8gWzJdXHJcbiAgICAgICAqIGBgYFxyXG4gICAgICAgKiBAcGFyYW0gZGF0YSAtIFVwZGF0ZXMgKHRoZSBpZCBhbmQgb3B0aW9uYWxseSBvdGhlciBwcm9wcykgdG8gdGhlIGl0ZW1zIGluIHRoaXMgZGF0YSBzZXQuXHJcbiAgICAgICAqIEBwYXJhbSBzZW5kZXJJZCAtIFNlbmRlciBpZC5cclxuICAgICAgICogQHJldHVybnMgdXBkYXRlZElkcyAtIFRoZSBpZHMgb2YgdGhlIHVwZGF0ZWQgaXRlbXMuXHJcbiAgICAgICAqIEB0aHJvd3MgV2hlbiB0aGUgc3VwcGxpZWQgZGF0YSBpcyBuZWl0aGVyIGFuIGl0ZW0gbm9yIGFuIGFycmF5IG9mIGl0ZW1zLCB3aGVuIHRoZSBpZHMgYXJlIG1pc3NpbmcuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInVwZGF0ZU9ubHlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVPbmx5KGRhdGEsIHNlbmRlcklkKSB7XG4gICAgICAgIHZhciBfY29udGV4dCxcbiAgICAgICAgICAgIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFpc0FycmF5JDEoZGF0YSkpIHtcbiAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVwZGF0ZUV2ZW50RGF0YSA9IG1hcCQzKF9jb250ZXh0ID0gbWFwJDMoZGF0YSkuY2FsbChkYXRhLCBmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgICAgdmFyIG9sZERhdGEgPSBfdGhpczQuX2RhdGEuZ2V0KHVwZGF0ZVtfdGhpczQuX2lkUHJvcF0pO1xuXG4gICAgICAgICAgaWYgKG9sZERhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXBkYXRpbmcgbm9uLWV4aXN0ZW50IGl0ZW1zIGlzIG5vdCBhbGxvd2VkLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2xkRGF0YTogb2xkRGF0YSxcbiAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSkpLmNhbGwoX2NvbnRleHQsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIG9sZERhdGEgPSBfcmVmLm9sZERhdGEsXG4gICAgICAgICAgICAgIHVwZGF0ZSA9IF9yZWYudXBkYXRlO1xuICAgICAgICAgIHZhciBpZCA9IG9sZERhdGFbX3RoaXM0Ll9pZFByb3BdO1xuICAgICAgICAgIHZhciB1cGRhdGVkRGF0YSA9IHB1cmVEZWVwT2JqZWN0QXNzaWduKG9sZERhdGEsIHVwZGF0ZSk7XG5cbiAgICAgICAgICBfdGhpczQuX2RhdGEuc2V0KGlkLCB1cGRhdGVkRGF0YSk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgb2xkRGF0YTogb2xkRGF0YSxcbiAgICAgICAgICAgIHVwZGF0ZWREYXRhOiB1cGRhdGVkRGF0YVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh1cGRhdGVFdmVudERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgICAgaXRlbXM6IG1hcCQzKHVwZGF0ZUV2ZW50RGF0YSkuY2FsbCh1cGRhdGVFdmVudERhdGEsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuaWQ7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9sZERhdGE6IG1hcCQzKHVwZGF0ZUV2ZW50RGF0YSkuY2FsbCh1cGRhdGVFdmVudERhdGEsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUub2xkRGF0YTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZGF0YTogbWFwJDModXBkYXRlRXZlbnREYXRhKS5jYWxsKHVwZGF0ZUV2ZW50RGF0YSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS51cGRhdGVkRGF0YTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTsgLy8gVE9ETzogcmVtb3ZlIGRlcHJlY2F0ZWQgcHJvcGVydHkgJ2RhdGEnIHNvbWUgZGF5XG4gICAgICAgICAgLy9PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdkYXRhJywge1xuICAgICAgICAgIC8vICAnZ2V0JzogKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vICAgIGNvbnNvbGUud2FybignUHJvcGVydHkgZGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgRGF0YVNldC5nZXQoaWRzKSB0byByZXRyaWV2ZSB0aGUgbmV3IGRhdGEsIHVzZSB0aGUgb2xkRGF0YSBwcm9wZXJ0eSBvbiB0aGlzIG9iamVjdCB0byBnZXQgdGhlIG9sZCBkYXRhJyk7XG4gICAgICAgICAgLy8gICAgcmV0dXJuIHVwZGF0ZWREYXRhO1xuICAgICAgICAgIC8vICB9KS5iaW5kKHRoaXMpXG4gICAgICAgICAgLy99KTtcblxuICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXCJ1cGRhdGVcIiwgcHJvcHMsIHNlbmRlcklkKTtcblxuICAgICAgICAgIHJldHVybiBwcm9wcy5pdGVtcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIC8vIEBUT0RPOiBXb3Vkbid0IGl0IGJlIGJldHRlciB0byBzcGxpdCB0aGlzIGludG8gbXVsdGlwbGUgbWV0aG9kcz9cbiAgICAgICAgLy8gcGFyc2UgdGhlIGFyZ3VtZW50c1xuICAgICAgICB2YXIgaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBpZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChpc0lkKGZpcnN0KSkge1xuICAgICAgICAgIC8vIGdldChpZCBbLCBvcHRpb25zXSlcbiAgICAgICAgICBpZCA9IGZpcnN0O1xuICAgICAgICAgIG9wdGlvbnMgPSBzZWNvbmQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSQxKGZpcnN0KSkge1xuICAgICAgICAgIC8vIGdldChpZHMgWywgb3B0aW9uc10pXG4gICAgICAgICAgaWRzID0gZmlyc3Q7XG4gICAgICAgICAgb3B0aW9ucyA9IHNlY29uZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBnZXQoWywgb3B0aW9uc10pXG4gICAgICAgICAgb3B0aW9ucyA9IGZpcnN0O1xuICAgICAgICB9IC8vIGRldGVybWluZSB0aGUgcmV0dXJuIHR5cGVcblxuXG4gICAgICAgIHZhciByZXR1cm5UeXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnJldHVyblR5cGUgPT09IFwiT2JqZWN0XCIgPyBcIk9iamVjdFwiIDogXCJBcnJheVwiOyAvLyBAVE9ETzogV1RGIGlzIHRoaXM/IE9yIGFtIEkgbWlzc2luZyBzb21ldGhpbmc/XG4gICAgICAgIC8vIHZhciByZXR1cm5UeXBlXG4gICAgICAgIC8vIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmV0dXJuVHlwZSkge1xuICAgICAgICAvLyAgIHZhciBhbGxvd2VkVmFsdWVzID0gWydBcnJheScsICdPYmplY3QnXVxuICAgICAgICAvLyAgIHJldHVyblR5cGUgPVxuICAgICAgICAvLyAgICAgYWxsb3dlZFZhbHVlcy5pbmRleE9mKG9wdGlvbnMucmV0dXJuVHlwZSkgPT0gLTFcbiAgICAgICAgLy8gICAgICAgPyAnQXJyYXknXG4gICAgICAgIC8vICAgICAgIDogb3B0aW9ucy5yZXR1cm5UeXBlXG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgcmV0dXJuVHlwZSA9ICdBcnJheSdcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBidWlsZCBvcHRpb25zXG5cbiAgICAgICAgdmFyIGZpbHRlciQxID0gb3B0aW9ucyAmJiBmaWx0ZXIob3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgIHZhciBpdGVtID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgaXRlbUlkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGl0ZW1JZCA9IHVuZGVmaW5lZDsgLy8gY29udmVydCBpdGVtc1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gcmV0dXJuIGEgc2luZ2xlIGl0ZW1cbiAgICAgICAgICBpdGVtID0gdGhpcy5fZGF0YS5nZXQoaWQpO1xuXG4gICAgICAgICAgaWYgKGl0ZW0gJiYgZmlsdGVyJDEgJiYgIWZpbHRlciQxKGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpZHMgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIHJldHVybiBhIHN1YnNldCBvZiBpdGVtc1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLl9kYXRhLmdldChpZHNbaV0pO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSAhPSBudWxsICYmICghZmlsdGVyJDEgfHwgZmlsdGVyJDEoaXRlbSkpKSB7XG4gICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfY29udGV4dDI7XG5cbiAgICAgICAgICAvLyByZXR1cm4gYWxsIGl0ZW1zXG4gICAgICAgICAgaXRlbUlkcyA9IF90b0NvbnN1bWFibGVBcnJheShrZXlzKF9jb250ZXh0MiA9IHRoaXMuX2RhdGEpLmNhbGwoX2NvbnRleHQyKSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9sZW4gPSBpdGVtSWRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBpdGVtSWQgPSBpdGVtSWRzW19pXTtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLl9kYXRhLmdldChpdGVtSWQpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSAhPSBudWxsICYmICghZmlsdGVyJDEgfHwgZmlsdGVyJDEoaXRlbSkpKSB7XG4gICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIG9yZGVyIHRoZSByZXN1bHRzXG5cblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyICYmIGlkID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9wdGlvbnMub3JkZXIpO1xuICAgICAgICB9IC8vIGZpbHRlciBmaWVsZHMgb2YgdGhlIGl0ZW1zXG5cblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZpZWxkcykge1xuICAgICAgICAgIHZhciBmaWVsZHMgPSBvcHRpb25zLmZpZWxkcztcblxuICAgICAgICAgIGlmIChpZCAhPSB1bmRlZmluZWQgJiYgaXRlbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5fZmlsdGVyRmllbGRzKGl0ZW0sIGZpZWxkcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9sZW4yID0gaXRlbXMubGVuZ3RoOyBfaTIgPCBfbGVuMjsgX2kyKyspIHtcbiAgICAgICAgICAgICAgaXRlbXNbX2kyXSA9IHRoaXMuX2ZpbHRlckZpZWxkcyhpdGVtc1tfaTJdLCBmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyByZXR1cm4gdGhlIHJlc3VsdHNcblxuXG4gICAgICAgIGlmIChyZXR1cm5UeXBlID09IFwiT2JqZWN0XCIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwLCBfbGVuMyA9IGl0ZW1zLmxlbmd0aDsgX2kzIDwgX2xlbjM7IF9pMysrKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0YW50ID0gaXRlbXNbX2kzXTsgLy8gQFRPRE86IFNob3Vkbid0IHRoaXMgYmUgdGhpcy5fZmllbGRJZD9cbiAgICAgICAgICAgIC8vIHJlc3VsdFtyZXN1bHRhbnQuaWRdID0gcmVzdWx0YW50XG5cbiAgICAgICAgICAgIHZhciBfaWQyID0gcmVzdWx0YW50W3RoaXMuX2lkUHJvcF07XG4gICAgICAgICAgICByZXN1bHRbX2lkMl0gPSByZXN1bHRhbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9pdGVtO1xuXG4gICAgICAgICAgICAvLyBhIHNpbmdsZSBpdGVtXG4gICAgICAgICAgICByZXR1cm4gKF9pdGVtID0gaXRlbSkgIT09IG51bGwgJiYgX2l0ZW0gIT09IHZvaWQgMCA/IF9pdGVtIDogbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8ganVzdCByZXR1cm4gb3VyIGFycmF5XG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRJZHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJZHMob3B0aW9ucykge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdmFyIGZpbHRlciQxID0gb3B0aW9ucyAmJiBmaWx0ZXIob3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIG9yZGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyO1xuXG4gICAgICAgIHZhciBpdGVtSWRzID0gX3RvQ29uc3VtYWJsZUFycmF5KGtleXMoZGF0YSkuY2FsbChkYXRhKSk7XG5cbiAgICAgICAgdmFyIGlkcyA9IFtdO1xuXG4gICAgICAgIGlmIChmaWx0ZXIkMSkge1xuICAgICAgICAgIC8vIGdldCBmaWx0ZXJlZCBpdGVtc1xuICAgICAgICAgIGlmIChvcmRlcikge1xuICAgICAgICAgICAgLy8gY3JlYXRlIG9yZGVyZWQgbGlzdFxuICAgICAgICAgICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBpZCA9IGl0ZW1JZHNbaV07XG5cbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9kYXRhLmdldChpZCk7XG5cbiAgICAgICAgICAgICAgaWYgKGl0ZW0gIT0gbnVsbCAmJiBmaWx0ZXIkMShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc29ydChpdGVtcywgb3JkZXIpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwLCBfbGVuNCA9IGl0ZW1zLmxlbmd0aDsgX2k0IDwgX2xlbjQ7IF9pNCsrKSB7XG4gICAgICAgICAgICAgIGlkcy5wdXNoKGl0ZW1zW19pNF1bdGhpcy5faWRQcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB1bm9yZGVyZWQgbGlzdFxuICAgICAgICAgICAgZm9yICh2YXIgX2k1ID0gMCwgX2xlbjUgPSBpdGVtSWRzLmxlbmd0aDsgX2k1IDwgX2xlbjU7IF9pNSsrKSB7XG4gICAgICAgICAgICAgIHZhciBfaWQzID0gaXRlbUlkc1tfaTVdO1xuXG4gICAgICAgICAgICAgIHZhciBfaXRlbTIgPSB0aGlzLl9kYXRhLmdldChfaWQzKTtcblxuICAgICAgICAgICAgICBpZiAoX2l0ZW0yICE9IG51bGwgJiYgZmlsdGVyJDEoX2l0ZW0yKSkge1xuICAgICAgICAgICAgICAgIGlkcy5wdXNoKF9pdGVtMlt0aGlzLl9pZFByb3BdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBnZXQgYWxsIGl0ZW1zXG4gICAgICAgICAgaWYgKG9yZGVyKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYW4gb3JkZXJlZCBsaXN0XG4gICAgICAgICAgICB2YXIgX2l0ZW1zID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pNiA9IDAsIF9sZW42ID0gaXRlbUlkcy5sZW5ndGg7IF9pNiA8IF9sZW42OyBfaTYrKykge1xuICAgICAgICAgICAgICB2YXIgX2lkNCA9IGl0ZW1JZHNbX2k2XTtcblxuICAgICAgICAgICAgICBfaXRlbXMucHVzaChkYXRhLmdldChfaWQ0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NvcnQoX2l0ZW1zLCBvcmRlcik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pNyA9IDAsIF9sZW43ID0gX2l0ZW1zLmxlbmd0aDsgX2k3IDwgX2xlbjc7IF9pNysrKSB7XG4gICAgICAgICAgICAgIGlkcy5wdXNoKF9pdGVtc1tfaTddW3RoaXMuX2lkUHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgdW5vcmRlcmVkIGxpc3RcbiAgICAgICAgICAgIGZvciAodmFyIF9pOCA9IDAsIF9sZW44ID0gaXRlbUlkcy5sZW5ndGg7IF9pOCA8IF9sZW44OyBfaTgrKykge1xuICAgICAgICAgICAgICB2YXIgX2lkNSA9IGl0ZW1JZHNbX2k4XTtcblxuICAgICAgICAgICAgICB2YXIgX2l0ZW0zID0gZGF0YS5nZXQoX2lkNSk7XG5cbiAgICAgICAgICAgICAgaWYgKF9pdGVtMyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWRzLnB1c2goX2l0ZW0zW3RoaXMuX2lkUHJvcF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgIH1cbiAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldERhdGFTZXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREYXRhU2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImZvckVhY2hcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBmaWx0ZXIkMSA9IG9wdGlvbnMgJiYgZmlsdGVyKG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB2YXIgaXRlbUlkcyA9IF90b0NvbnN1bWFibGVBcnJheShrZXlzKGRhdGEpLmNhbGwoZGF0YSkpO1xuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIpIHtcbiAgICAgICAgICAvLyBleGVjdXRlIGZvckVhY2ggb24gb3JkZXJlZCBsaXN0XG4gICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5nZXQob3B0aW9ucyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICB2YXIgaWQgPSBpdGVtW3RoaXMuX2lkUHJvcF07XG4gICAgICAgICAgICBjYWxsYmFjayhpdGVtLCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVub3JkZXJlZFxuICAgICAgICAgIGZvciAodmFyIF9pOSA9IDAsIF9sZW45ID0gaXRlbUlkcy5sZW5ndGg7IF9pOSA8IF9sZW45OyBfaTkrKykge1xuICAgICAgICAgICAgdmFyIF9pZDYgPSBpdGVtSWRzW19pOV07XG5cbiAgICAgICAgICAgIHZhciBfaXRlbTQgPSB0aGlzLl9kYXRhLmdldChfaWQ2KTtcblxuICAgICAgICAgICAgaWYgKF9pdGVtNCAhPSBudWxsICYmICghZmlsdGVyJDEgfHwgZmlsdGVyJDEoX2l0ZW00KSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soX2l0ZW00LCBfaWQ2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1hcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICB2YXIgZmlsdGVyJDEgPSBvcHRpb25zICYmIGZpbHRlcihvcHRpb25zKTtcblxuICAgICAgICB2YXIgbWFwcGVkSXRlbXMgPSBbXTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHZhciBpdGVtSWRzID0gX3RvQ29uc3VtYWJsZUFycmF5KGtleXMoZGF0YSkuY2FsbChkYXRhKSk7IC8vIGNvbnZlcnQgYW5kIGZpbHRlciBpdGVtc1xuXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgaWQgPSBpdGVtSWRzW2ldO1xuXG4gICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9kYXRhLmdldChpZCk7XG5cbiAgICAgICAgICBpZiAoaXRlbSAhPSBudWxsICYmICghZmlsdGVyJDEgfHwgZmlsdGVyJDEoaXRlbSkpKSB7XG4gICAgICAgICAgICBtYXBwZWRJdGVtcy5wdXNoKGNhbGxiYWNrKGl0ZW0sIGlkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIG9yZGVyIGl0ZW1zXG5cblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyKSB7XG4gICAgICAgICAgdGhpcy5fc29ydChtYXBwZWRJdGVtcywgb3B0aW9ucy5vcmRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFwcGVkSXRlbXM7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogRmlsdGVyIHRoZSBmaWVsZHMgb2YgYW4gaXRlbS5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIGl0ZW0gLSBUaGUgaXRlbSB3aG9zZSBmaWVsZHMgc2hvdWxkIGJlIGZpbHRlcmVkLlxyXG4gICAgICAgKiBAcGFyYW0gZmllbGRzIC0gVGhlIG5hbWVzIG9mIHRoZSBmaWVsZHMgdGhhdCB3aWxsIGJlIGtlcHQuXHJcbiAgICAgICAqIEB0eXBlUGFyYW0gSyAtIEZpZWxkIG5hbWUgdHlwZS5cclxuICAgICAgICogQHJldHVybnMgVGhlIGl0ZW0gd2l0aG91dCBhbnkgYWRkaXRpb25hbCBmaWVsZHMuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9maWx0ZXJGaWVsZHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmlsdGVyRmllbGRzKGl0ZW0sIGZpZWxkcykge1xuICAgICAgICB2YXIgX2NvbnRleHQzO1xuXG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgIC8vIGl0ZW0gaXMgbnVsbFxuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZHVjZShfY29udGV4dDMgPSBpc0FycmF5JDEoZmllbGRzKSA/IC8vIFVzZSB0aGUgc3VwcGxpZWQgYXJyYXlcbiAgICAgICAgZmllbGRzIDogLy8gVXNlIHRoZSBrZXlzIG9mIHRoZSBzdXBwbGllZCBvYmplY3RcbiAgICAgICAga2V5cyQ0KGZpZWxkcykpLmNhbGwoX2NvbnRleHQzLCBmdW5jdGlvbiAoZmlsdGVyZWRJdGVtLCBmaWVsZCkge1xuICAgICAgICAgIGZpbHRlcmVkSXRlbVtmaWVsZF0gPSBpdGVtW2ZpZWxkXTtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyZWRJdGVtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogU29ydCB0aGUgcHJvdmlkZWQgYXJyYXkgd2l0aCBpdGVtcy5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIGl0ZW1zIC0gSXRlbXMgdG8gYmUgc29ydGVkIGluIHBsYWNlLlxyXG4gICAgICAgKiBAcGFyYW0gb3JkZXIgLSBBIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXHJcbiAgICAgICAqIEB0eXBlUGFyYW0gVCAtIFRoZSB0eXBlIG9mIHRoZSBpdGVtcyBpbiB0aGUgaXRlbXMgYXJyYXkuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zb3J0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NvcnQoaXRlbXMsIG9yZGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3JkZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAvLyBvcmRlciBieSBwcm92aWRlZCBmaWVsZCBuYW1lXG4gICAgICAgICAgdmFyIG5hbWUgPSBvcmRlcjsgLy8gZmllbGQgbmFtZVxuXG4gICAgICAgICAgc29ydChpdGVtcykuY2FsbChpdGVtcywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiBIb3cgdG8gdHJlYXQgbWlzc2luZyBwcm9wZXJ0aWVzP1xuICAgICAgICAgICAgdmFyIGF2ID0gYVtuYW1lXTtcbiAgICAgICAgICAgIHZhciBidiA9IGJbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gYXYgPiBidiA/IDEgOiBhdiA8IGJ2ID8gLTEgOiAwO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcmRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgLy8gb3JkZXIgYnkgc29ydCBmdW5jdGlvblxuICAgICAgICAgIHNvcnQoaXRlbXMpLmNhbGwoaXRlbXMsIG9yZGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUT0RPOiBleHRlbmQgb3JkZXIgYnkgYW4gT2JqZWN0IHtmaWVsZDpzdHJpbmcsIGRpcmVjdGlvbjpzdHJpbmd9XG4gICAgICAgICAgLy8gICAgICAgd2hlcmUgZGlyZWN0aW9uIGNhbiBiZSAnYXNjJyBvciAnZGVzYydcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT3JkZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogUmVtb3ZlIGFuIGl0ZW0gb3IgbXVsdGlwbGUgaXRlbXMgYnkg4oCccmVmZXJlbmNl4oCdIChvbmx5IHRoZSBpZCBpcyB1c2VkKSBvciBieSBpZC5cclxuICAgICAgICpcclxuICAgICAgICogVGhlIG1ldGhvZCBpZ25vcmVzIHJlbW92YWwgb2Ygbm9uLWV4aXN0aW5nIGl0ZW1zLCBhbmQgcmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBpZHMgb2YgdGhlIGl0ZW1zIHdoaWNoIGFyZSBhY3R1YWxseSByZW1vdmVkIGZyb20gdGhlIERhdGFTZXQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEFmdGVyIHRoZSBpdGVtcyBhcmUgcmVtb3ZlZCwgdGhlIERhdGFTZXQgd2lsbCB0cmlnZ2VyIGFuIGV2ZW50IGByZW1vdmVgIGZvciB0aGUgcmVtb3ZlZCBpdGVtcy4gV2hlbiBhIGBzZW5kZXJJZGAgaXMgcHJvdmlkZWQsIHRoaXMgaWQgd2lsbCBiZSBwYXNzZWQgd2l0aCB0aGUgdHJpZ2dlcmVkIGV2ZW50IHRvIGFsbCBzdWJzY3JpYmVycy5cclxuICAgICAgICpcclxuICAgICAgICogIyMgRXhhbXBsZVxyXG4gICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAqIC8vIGNyZWF0ZSBhIERhdGFTZXRcclxuICAgICAgICogY29uc3QgZGF0YSA9IG5ldyB2aXMuRGF0YVNldChbXHJcbiAgICAgICAqICAgeyBpZDogMSwgdGV4dDogJ2l0ZW0gMScgfSxcclxuICAgICAgICogICB7IGlkOiAyLCB0ZXh0OiAnaXRlbSAyJyB9LFxyXG4gICAgICAgKiAgIHsgaWQ6IDMsIHRleHQ6ICdpdGVtIDMnIH1cclxuICAgICAgICogXSlcclxuICAgICAgICpcclxuICAgICAgICogLy8gcmVtb3ZlIGl0ZW1zXHJcbiAgICAgICAqIGNvbnN0IGlkcyA9IGRhdGEucmVtb3ZlKFsyLCB7IGlkOiAzIH0sIDRdKVxyXG4gICAgICAgKlxyXG4gICAgICAgKiBjb25zb2xlLmxvZyhpZHMpIC8vIFsyLCAzXVxyXG4gICAgICAgKiBgYGBcclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIGlkIC0gT25lIG9yIG1vcmUgaXRlbXMgb3IgaWRzIG9mIGl0ZW1zIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgICAqIEBwYXJhbSBzZW5kZXJJZCAtIFNlbmRlciBpZC5cclxuICAgICAgICogQHJldHVybnMgVGhlIGlkcyBvZiB0aGUgcmVtb3ZlZCBpdGVtcy5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGlkLCBzZW5kZXJJZCkge1xuICAgICAgICB2YXIgcmVtb3ZlZElkcyA9IFtdO1xuICAgICAgICB2YXIgcmVtb3ZlZEl0ZW1zID0gW107IC8vIGZvcmNlIGV2ZXJ5dGhpbmcgdG8gYmUgYW4gYXJyYXkgZm9yIHNpbXBsaWNpdHlcblxuICAgICAgICB2YXIgaWRzID0gaXNBcnJheSQxKGlkKSA/IGlkIDogW2lkXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9yZW1vdmUoaWRzW2ldKTtcblxuICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgaXRlbUlkID0gaXRlbVt0aGlzLl9pZFByb3BdO1xuXG4gICAgICAgICAgICBpZiAoaXRlbUlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlZElkcy5wdXNoKGl0ZW1JZCk7XG4gICAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW1vdmVkSWRzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIiwge1xuICAgICAgICAgICAgaXRlbXM6IHJlbW92ZWRJZHMsXG4gICAgICAgICAgICBvbGREYXRhOiByZW1vdmVkSXRlbXNcbiAgICAgICAgICB9LCBzZW5kZXJJZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVtb3ZlZElkcztcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZW1vdmUgYW4gaXRlbSBieSBpdHMgaWQgb3IgcmVmZXJlbmNlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gaWQgLSBJZCBvZiBhbiBpdGVtIG9yIHRoZSBpdGVtIGl0c2VsZi5cclxuICAgICAgICogQHJldHVybnMgVGhlIHJlbW92ZWQgaXRlbSBpZiByZW1vdmVkLCBudWxsIG90aGVyd2lzZS5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JlbW92ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmUoaWQpIHtcbiAgICAgICAgLy8gQFRPRE86IEl0IG9yaWdpYW5sbHkgcmV0dXJuZWQgdGhlIGl0ZW0gYWx0aG91Z2ggdGhlIGRvY3Mgc2F5IGlkLlxuICAgICAgICAvLyBUaGUgY29kZSBleHBlY3RzIHRoZSBpdGVtLCBzbyBwcm9iYWJseSBhbiBlcnJvciBpbiB0aGUgZG9jcy5cbiAgICAgICAgdmFyIGlkZW50OyAvLyBjb25maXJtIHRoZSBpZCB0byB1c2UgYmFzZWQgb24gdGhlIGFyZ3MgdHlwZVxuXG4gICAgICAgIGlmIChpc0lkKGlkKSkge1xuICAgICAgICAgIGlkZW50ID0gaWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaWQgJiYgX3R5cGVvZihpZCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBpZGVudCA9IGlkW3RoaXMuX2lkUHJvcF07IC8vIGxvb2sgZm9yIHRoZSBpZGVudGlmaWVyIGZpZWxkIHVzaW5nIC5faWRQcm9wXG4gICAgICAgIH0gLy8gZG8gdGhlIHJlbW92aW5nIGlmIHRoZSBpdGVtIGlzIGZvdW5kXG5cblxuICAgICAgICBpZiAoaWRlbnQgIT0gbnVsbCAmJiB0aGlzLl9kYXRhLmhhcyhpZGVudCkpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkZW50KSB8fCBudWxsO1xuXG4gICAgICAgICAgdGhpcy5fZGF0YS5kZWxldGUoaWRlbnQpO1xuXG4gICAgICAgICAgLS10aGlzLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIENsZWFyIHRoZSBlbnRpcmUgZGF0YSBzZXQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEFmdGVyIHRoZSBpdGVtcyBhcmUgcmVtb3ZlZCwgdGhlIFtbRGF0YVNldF1dIHdpbGwgdHJpZ2dlciBhbiBldmVudCBgcmVtb3ZlYCBmb3IgYWxsIHJlbW92ZWQgaXRlbXMuIFdoZW4gYSBgc2VuZGVySWRgIGlzIHByb3ZpZGVkLCB0aGlzIGlkIHdpbGwgYmUgcGFzc2VkIHdpdGggdGhlIHRyaWdnZXJlZCBldmVudCB0byBhbGwgc3Vic2NyaWJlcnMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBzZW5kZXJJZCAtIFNlbmRlciBpZC5cclxuICAgICAgICogQHJldHVybnMgcmVtb3ZlZElkcyAtIFRoZSBpZHMgb2YgYWxsIHJlbW92ZWQgaXRlbXMuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImNsZWFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoc2VuZGVySWQpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NDtcblxuICAgICAgICB2YXIgaWRzID0gX3RvQ29uc3VtYWJsZUFycmF5KGtleXMoX2NvbnRleHQ0ID0gdGhpcy5fZGF0YSkuY2FsbChfY29udGV4dDQpKTtcblxuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaXRlbXMucHVzaCh0aGlzLl9kYXRhLmdldChpZHNbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RhdGEuY2xlYXIoKTtcblxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcInJlbW92ZVwiLCB7XG4gICAgICAgICAgaXRlbXM6IGlkcyxcbiAgICAgICAgICBvbGREYXRhOiBpdGVtc1xuICAgICAgICB9LCBzZW5kZXJJZCk7XG5cbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBGaW5kIHRoZSBpdGVtIHdpdGggbWF4aW11bSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBmaWVsZC5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIGZpZWxkIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgc2VhcmNoZWQgZm9yIG1heCB2YWx1ZS5cclxuICAgICAgICogQHJldHVybnMgSXRlbSBjb250YWluaW5nIG1heCB2YWx1ZSwgb3IgbnVsbCBpZiBubyBpdGVtcy5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWF4KGZpZWxkKSB7XG4gICAgICAgIHZhciBfY29udGV4dDU7XG5cbiAgICAgICAgdmFyIG1heCA9IG51bGw7XG4gICAgICAgIHZhciBtYXhGaWVsZCA9IG51bGw7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEodmFsdWVzKF9jb250ZXh0NSA9IHRoaXMuX2RhdGEpLmNhbGwoX2NvbnRleHQ1KSksXG4gICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGl0ZW1GaWVsZCA9IGl0ZW1bZmllbGRdO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW1GaWVsZCA9PT0gXCJudW1iZXJcIiAmJiAobWF4RmllbGQgPT0gbnVsbCB8fCBpdGVtRmllbGQgPiBtYXhGaWVsZCkpIHtcbiAgICAgICAgICAgICAgbWF4ID0gaXRlbTtcbiAgICAgICAgICAgICAgbWF4RmllbGQgPSBpdGVtRmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF4IHx8IG51bGw7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogRmluZCB0aGUgaXRlbSB3aXRoIG1pbmltdW0gdmFsdWUgb2YgYSBzcGVjaWZpZWQgZmllbGQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBmaWVsZCAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIGZvciBtaW4gdmFsdWUuXHJcbiAgICAgICAqIEByZXR1cm5zIEl0ZW0gY29udGFpbmluZyBtaW4gdmFsdWUsIG9yIG51bGwgaWYgbm8gaXRlbXMuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1pblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1pbihmaWVsZCkge1xuICAgICAgICB2YXIgX2NvbnRleHQ2O1xuXG4gICAgICAgIHZhciBtaW4gPSBudWxsO1xuICAgICAgICB2YXIgbWluRmllbGQgPSBudWxsO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMSh2YWx1ZXMoX2NvbnRleHQ2ID0gdGhpcy5fZGF0YSkuY2FsbChfY29udGV4dDYpKSxcbiAgICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgIHZhciBpdGVtRmllbGQgPSBpdGVtW2ZpZWxkXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtRmllbGQgPT09IFwibnVtYmVyXCIgJiYgKG1pbkZpZWxkID09IG51bGwgfHwgaXRlbUZpZWxkIDwgbWluRmllbGQpKSB7XG4gICAgICAgICAgICAgIG1pbiA9IGl0ZW07XG4gICAgICAgICAgICAgIG1pbkZpZWxkID0gaXRlbUZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWluIHx8IG51bGw7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogRmluZCBhbGwgZGlzdGluY3QgdmFsdWVzIG9mIGEgc3BlY2lmaWVkIGZpZWxkXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBwcm9wIC0gVGhlIHByb3BlcnR5IG5hbWUgd2hvc2UgZGlzdGluY3QgdmFsdWVzIHNob3VsZCBiZSByZXR1cm5lZC5cclxuICAgICAgICogQHJldHVybnMgVW5vcmRlcmVkIGFycmF5IGNvbnRhaW5pbmcgYWxsIGRpc3RpbmN0IHZhbHVlcy4gSXRlbXMgd2l0aG91dCBzcGVjaWZpZWQgcHJvcGVydHkgYXJlIGlnbm9yZWQuXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImRpc3RpbmN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGluY3QocHJvcCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdmFyIGl0ZW1JZHMgPSBfdG9Db25zdW1hYmxlQXJyYXkoa2V5cyhkYXRhKS5jYWxsKGRhdGEpKTtcblxuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgICAgIHZhciBpdGVtID0gZGF0YS5nZXQoaWQpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1bcHJvcF07XG4gICAgICAgICAgdmFyIGV4aXN0cyA9IGZhbHNlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW2pdID09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZXhpc3RzICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlc1tjb3VudF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBBZGQgYSBzaW5nbGUgaXRlbS4gV2lsbCBmYWlsIHdoZW4gYW4gaXRlbSB3aXRoIHRoZSBzYW1lIGlkIGFscmVhZHkgZXhpc3RzLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gaXRlbSAtIEEgbmV3IGl0ZW0gdG8gYmUgYWRkZWQuXHJcbiAgICAgICAqIEByZXR1cm5zIEFkZGVkIGl0ZW0ncyBpZC4gQW4gaWQgaXMgZ2VuZXJhdGVkIHdoZW4gaXQgaXMgbm90IHByZXNlbnQgaW4gdGhlIGl0ZW0uXHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9hZGRJdGVtXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEl0ZW0oaXRlbSkge1xuICAgICAgICB2YXIgZnVsbEl0ZW0gPSBlbnN1cmVGdWxsSXRlbShpdGVtLCB0aGlzLl9pZFByb3ApO1xuICAgICAgICB2YXIgaWQgPSBmdWxsSXRlbVt0aGlzLl9pZFByb3BdOyAvLyBjaGVjayB3aGV0aGVyIHRoaXMgaWQgaXMgYWxyZWFkeSB0YWtlblxuXG4gICAgICAgIGlmICh0aGlzLl9kYXRhLmhhcyhpZCkpIHtcbiAgICAgICAgICAvLyBpdGVtIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBpdGVtOiBpdGVtIHdpdGggaWQgXCIgKyBpZCArIFwiIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGF0YS5zZXQoaWQsIGZ1bGxJdGVtKTtcblxuICAgICAgICArK3RoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9XG4gICAgICAvKipcclxuICAgICAgICogVXBkYXRlIGEgc2luZ2xlIGl0ZW06IG1lcmdlIHdpdGggZXhpc3RpbmcgaXRlbS5cclxuICAgICAgICogV2lsbCBmYWlsIHdoZW4gdGhlIGl0ZW0gaGFzIG5vIGlkLCBvciB3aGVuIHRoZXJlIGRvZXMgbm90IGV4aXN0IGFuIGl0ZW0gd2l0aCB0aGUgc2FtZSBpZC5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHVwZGF0ZSAtIFRoZSBuZXcgaXRlbVxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgaWQgb2YgdGhlIHVwZGF0ZWQgaXRlbS5cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3VwZGF0ZUl0ZW1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlSXRlbSh1cGRhdGUpIHtcbiAgICAgICAgdmFyIGlkID0gdXBkYXRlW3RoaXMuX2lkUHJvcF07XG5cbiAgICAgICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIGl0ZW06IGl0ZW0gaGFzIG5vIGlkIChpdGVtOiBcIiArIHN0cmluZ2lmeSQxKHVwZGF0ZSkgKyBcIilcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAvLyBpdGVtIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIGl0ZW06IG5vIGl0ZW0gd2l0aCBpZCBcIiArIGlkICsgXCIgZm91bmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kYXRhLnNldChpZCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBpdGVtKSwgdXBkYXRlKSk7XG5cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfVxuICAgICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RyZWFtXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RyZWFtKGlkcykge1xuICAgICAgICBpZiAoaWRzKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbShfZGVmaW5lUHJvcGVydHkoe30sIGl0ZXJhdG9yLCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjMsIF9zdGVwMywgaWQsIGl0ZW07XG5cbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0Nykge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShpZHMpO1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5zKCk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZCA9IF9zdGVwMy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGRhdGEuZ2V0KGlkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIShpdGVtICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2lkLCBpdGVtXTtcblxuICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAxMztcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3LnQwID0gX2NvbnRleHQ3W1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5lKF9jb250ZXh0Ny50MCk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMTY7XG5cbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5maW5pc2goMTYpO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMSwgMTMsIDE2LCAxOV1dKTtcbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfY29udGV4dDg7XG5cbiAgICAgICAgICByZXR1cm4gbmV3IERhdGFTdHJlYW0oX2RlZmluZVByb3BlcnR5KHt9LCBpdGVyYXRvciwgYmluZCQ2KF9jb250ZXh0OCA9IGVudHJpZXModGhpcy5fZGF0YSkpLmNhbGwoX2NvbnRleHQ4LCB0aGlzLl9kYXRhKSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERhdGFTZXQ7XG4gIH0oRGF0YVNldFBhcnQpO1xuXG4gIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBzeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoaXNBcnJheSQxKG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbiAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQ1OyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBzbGljZShfY29udGV4dDUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQ1LCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tJDMobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG4gIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuICAvKipcclxuICAgKiBEYXRhVmlld1xyXG4gICAqXHJcbiAgICogQSBEYXRhVmlldyBvZmZlcnMgYSBmaWx0ZXJlZCBhbmQvb3IgZm9ybWF0dGVkIHZpZXcgb24gYSBEYXRhU2V0LiBPbmUgY2FuIHN1YnNjcmliZSB0byBjaGFuZ2VzIGluIGEgRGF0YVZpZXcsIGFuZCBlYXNpbHkgZ2V0IGZpbHRlcmVkIG9yIGZvcm1hdHRlZCBkYXRhIHdpdGhvdXQgaGF2aW5nIHRvIHNwZWNpZnkgZmlsdGVycyBhbmQgZmllbGQgdHlwZXMgYWxsIHRoZSB0aW1lLlxyXG4gICAqXHJcbiAgICogIyMgRXhhbXBsZVxyXG4gICAqIGBgYGphdmFzY3JpcHRcclxuICAgKiAvLyBjcmVhdGUgYSBEYXRhU2V0XHJcbiAgICogdmFyIGRhdGEgPSBuZXcgdmlzLkRhdGFTZXQoKTtcclxuICAgKiBkYXRhLmFkZChbXHJcbiAgICogICB7aWQ6IDEsIHRleHQ6ICdpdGVtIDEnLCBkYXRlOiBuZXcgRGF0ZSgyMDEzLCA2LCAyMCksIGdyb3VwOiAxLCBmaXJzdDogdHJ1ZX0sXHJcbiAgICogICB7aWQ6IDIsIHRleHQ6ICdpdGVtIDInLCBkYXRlOiAnMjAxMy0wNi0yMycsIGdyb3VwOiAyfSxcclxuICAgKiAgIHtpZDogMywgdGV4dDogJ2l0ZW0gMycsIGRhdGU6ICcyMDEzLTA2LTI1JywgZ3JvdXA6IDJ9LFxyXG4gICAqICAge2lkOiA0LCB0ZXh0OiAnaXRlbSA0J31cclxuICAgKiBdKTtcclxuICAgKlxyXG4gICAqIC8vIGNyZWF0ZSBhIERhdGFWaWV3XHJcbiAgICogLy8gdGhlIHZpZXcgd2lsbCBvbmx5IGNvbnRhaW4gaXRlbXMgaGF2aW5nIGEgcHJvcGVydHkgZ3JvdXAgd2l0aCB2YWx1ZSAxLFxyXG4gICAqIC8vIGFuZCB3aWxsIG9ubHkgb3V0cHV0IGZpZWxkcyBpZCwgdGV4dCwgYW5kIGRhdGUuXHJcbiAgICogdmFyIHZpZXcgPSBuZXcgdmlzLkRhdGFWaWV3KGRhdGEsIHtcclxuICAgKiAgIGZpbHRlcjogZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgKiAgICAgcmV0dXJuIChpdGVtLmdyb3VwID09IDEpO1xyXG4gICAqICAgfSxcclxuICAgKiAgIGZpZWxkczogWydpZCcsICd0ZXh0JywgJ2RhdGUnXVxyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogLy8gc3Vic2NyaWJlIHRvIGFueSBjaGFuZ2UgaW4gdGhlIERhdGFWaWV3XHJcbiAgICogdmlldy5vbignKicsIGZ1bmN0aW9uIChldmVudCwgcHJvcGVydGllcywgc2VuZGVySWQpIHtcclxuICAgKiAgIGNvbnNvbGUubG9nKCdldmVudCcsIGV2ZW50LCBwcm9wZXJ0aWVzKTtcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIC8vIHVwZGF0ZSBhbiBpdGVtIGluIHRoZSBkYXRhIHNldFxyXG4gICAqIGRhdGEudXBkYXRlKHtpZDogMiwgZ3JvdXA6IDF9KTtcclxuICAgKlxyXG4gICAqIC8vIGdldCBhbGwgaWRzIGluIHRoZSB2aWV3XHJcbiAgICogdmFyIGlkcyA9IHZpZXcuZ2V0SWRzKCk7XHJcbiAgICogY29uc29sZS5sb2coJ2lkcycsIGlkcyk7IC8vIHdpbGwgb3V0cHV0IFsxLCAyXVxyXG4gICAqXHJcbiAgICogLy8gZ2V0IGFsbCBpdGVtcyBpbiB0aGUgdmlld1xyXG4gICAqIHZhciBpdGVtcyA9IHZpZXcuZ2V0KCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxyXG4gICAqIEB0eXBlUGFyYW0gSWRQcm9wIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGUgaWQuXHJcbiAgICovXG5cbiAgdmFyIERhdGFWaWV3ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRGF0YVNldFBhcnQpIHtcbiAgICBfaW5oZXJpdHMoRGF0YVZpZXcsIF9EYXRhU2V0UGFydCk7XG5cbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERhdGFWaWV3KTtcblxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgRGF0YVZpZXcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgaW5zdGFuY2UgY29udGFpbmluZyBkYXRhIChkaXJlY3RseSBvciBpbmRpcmVjdGx5KS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBjb25maWd1cmUgdGhpcyBkYXRhIHZpZXcuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRhVmlldyhkYXRhLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFWaWV3KTtcblxuICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImxlbmd0aFwiLCAwKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9saXN0ZW5lclwiLCB2b2lkIDApO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX2RhdGFcIiwgdm9pZCAwKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9pZHNcIiwgbmV3IHNldCgpKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9vcHRpb25zXCIsIHZvaWQgMCk7XG5cbiAgICAgIF90aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIF90aGlzLl9saXN0ZW5lciA9IGJpbmQkNihfY29udGV4dCA9IF90aGlzLl9vbkV2ZW50KS5jYWxsKF9jb250ZXh0LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgIF90aGlzLnNldERhdGEoZGF0YSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9IC8vIFRPRE86IGltcGxlbWVudCBhIGZ1bmN0aW9uIC5jb25maWcoKSB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhpbmdzIGxpa2UgY29uZmlndXJlZCBmaWx0ZXJcbiAgICAvLyBhbmQgdHJpZ2dlciBjaGFuZ2VzIGFjY29yZGluZ2x5XG5cbiAgICAvKipcclxuICAgICAqIFNldCBhIGRhdGEgc291cmNlIGZvciB0aGUgdmlldy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBpbnN0YW5jZSBjb250YWluaW5nIGRhdGEgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHkpLlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIE5vdGUgdGhhdCB3aGVuIHRoZSBkYXRhIHZpZXcgaXMgYm91bmQgdG8gYSBkYXRhIHNldCBpdCB3b24ndCBiZSBnYXJiYWdlXHJcbiAgICAgKiBjb2xsZWN0ZWQgdW5sZXNzIHRoZSBkYXRhIHNldCBpcyB0b28uIFVzZSBgZGF0YVZpZXcuc2V0RGF0YShudWxsKWAgb3JcclxuICAgICAqIGBkYXRhVmlldy5kaXNwb3NlKClgIHRvIGVuYWJsZSBnYXJiYWdlIGNvbGxlY3Rpb24gYmVmb3JlIHlvdSBsb3NlIHRoZSBsYXN0XHJcbiAgICAgKiByZWZlcmVuY2UuXHJcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKERhdGFWaWV3LCBbe1xuICAgICAga2V5OiBcImlkUHJvcFwiLFxuICAgICAgZ2V0OlxuICAgICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhU2V0KCkuaWRQcm9wO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXREYXRhXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBjdXJyZW50IGRhdGFzZXRcbiAgICAgICAgICBpZiAodGhpcy5fZGF0YS5vZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEub2ZmKFwiKlwiLCB0aGlzLl9saXN0ZW5lcik7XG4gICAgICAgICAgfSAvLyB0cmlnZ2VyIGEgcmVtb3ZlIG9mIGFsbCBpdGVtcyBpbiBtZW1vcnlcblxuXG4gICAgICAgICAgdmFyIGlkcyA9IHRoaXMuX2RhdGEuZ2V0SWRzKHtcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyKHRoaXMuX29wdGlvbnMpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLl9kYXRhLmdldChpZHMpO1xuXG4gICAgICAgICAgdGhpcy5faWRzLmNsZWFyKCk7XG5cbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICB0aGlzLl90cmlnZ2VyKFwicmVtb3ZlXCIsIHtcbiAgICAgICAgICAgIGl0ZW1zOiBpZHMsXG4gICAgICAgICAgICBvbGREYXRhOiBpdGVtc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhOyAvLyB0cmlnZ2VyIGFuIGFkZCBvZiBhbGwgYWRkZWQgaXRlbXNcblxuICAgICAgICAgIHZhciBfaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoe1xuICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIodGhpcy5fb3B0aW9ucylcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBfaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBfaWRzW2ldO1xuXG4gICAgICAgICAgICB0aGlzLl9pZHMuYWRkKGlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IF9pZHMubGVuZ3RoO1xuXG4gICAgICAgICAgdGhpcy5fdHJpZ2dlcihcImFkZFwiLCB7XG4gICAgICAgICAgICBpdGVtczogX2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgICB9IC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuXG5cbiAgICAgICAgaWYgKHRoaXMuX2RhdGEub24pIHtcbiAgICAgICAgICB0aGlzLl9kYXRhLm9uKFwiKlwiLCB0aGlzLl9saXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZWZyZXNoIHRoZSBEYXRhVmlldy5cclxuICAgICAgICogVXNlZnVsIHdoZW4gdGhlIERhdGFWaWV3IGhhcyBhIGZpbHRlciBmdW5jdGlvbiBjb250YWluaW5nIGEgdmFyaWFibGUgcGFyYW1ldGVyLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZWZyZXNoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgICAgdmFyIGlkcyA9IHRoaXMuX2RhdGEuZ2V0SWRzKHtcbiAgICAgICAgICBmaWx0ZXI6IGZpbHRlcih0aGlzLl9vcHRpb25zKVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgb2xkSWRzID0gX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX2lkcyk7XG5cbiAgICAgICAgdmFyIG5ld0lkcyA9IHt9O1xuICAgICAgICB2YXIgYWRkZWRJZHMgPSBbXTtcbiAgICAgICAgdmFyIHJlbW92ZWRJZHMgPSBbXTtcbiAgICAgICAgdmFyIHJlbW92ZWRJdGVtcyA9IFtdOyAvLyBjaGVjayBmb3IgYWRkaXRpb25zXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgICBuZXdJZHNbaWRdID0gdHJ1ZTtcblxuICAgICAgICAgIGlmICghdGhpcy5faWRzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuXG4gICAgICAgICAgICB0aGlzLl9pZHMuYWRkKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gY2hlY2sgZm9yIHJlbW92YWxzXG5cblxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9sZW4gPSBvbGRJZHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICB2YXIgX2lkID0gb2xkSWRzW19pXTtcblxuICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5fZGF0YS5nZXQoX2lkKTtcblxuICAgICAgICAgIGlmIChpdGVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiBJbnZlc3RpZ2F0ZS5cbiAgICAgICAgICAgIC8vIERvZXNuJ3QgaGFwcGVuIGR1cmluZyB0ZXN0cyBvciBleGFtcGxlcy5cbiAgICAgICAgICAgIC8vIElzIGl0IHJlYWxseSBpbXBvc3NpYmxlIG9yIGNvdWxkIGl0IGV2ZW50dWFsbHkgaGFwcGVuP1xuICAgICAgICAgICAgLy8gSG93IHRvIGhhbmRsZSBpdCBpZiBpdCBkb2VzPyBUaGUgdHlwZXMgZ3VhcmFudGVlIG5vbi1udWxsYWJsZSBpdGVtcy5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJZiB5b3Ugc2VlIHRoaXMsIHJlcG9ydCBpdCBwbGVhc2UuXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW5ld0lkc1tfaWRdKSB7XG4gICAgICAgICAgICByZW1vdmVkSWRzLnB1c2goX2lkKTtcbiAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKGl0ZW0pO1xuXG4gICAgICAgICAgICB0aGlzLl9pZHMuZGVsZXRlKF9pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gYWRkZWRJZHMubGVuZ3RoIC0gcmVtb3ZlZElkcy5sZW5ndGg7IC8vIHRyaWdnZXIgZXZlbnRzXG5cbiAgICAgICAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXCJhZGRcIiwge1xuICAgICAgICAgICAgaXRlbXM6IGFkZGVkSWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVtb3ZlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyKFwicmVtb3ZlXCIsIHtcbiAgICAgICAgICAgIGl0ZW1zOiByZW1vdmVkSWRzLFxuICAgICAgICAgICAgb2xkRGF0YTogcmVtb3ZlZEl0ZW1zXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSAvLyBwYXJzZSB0aGUgYXJndW1lbnRzXG5cblxuICAgICAgICB2YXIgaWRzID0gbnVsbDtcbiAgICAgICAgdmFyIG9wdGlvbnM7XG5cbiAgICAgICAgaWYgKGlzSWQoZmlyc3QpIHx8IGlzQXJyYXkkMShmaXJzdCkpIHtcbiAgICAgICAgICBpZHMgPSBmaXJzdDtcbiAgICAgICAgICBvcHRpb25zID0gc2Vjb25kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSBmaXJzdDtcbiAgICAgICAgfSAvLyBleHRlbmQgdGhlIG9wdGlvbnMgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zIGFuZCBwcm92aWRlZCBvcHRpb25zXG5cblxuICAgICAgICB2YXIgdmlld09wdGlvbnMgPSBhc3NpZ24kMih7fSwgdGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7IC8vIGNyZWF0ZSBhIGNvbWJpbmVkIGZpbHRlciBtZXRob2Qgd2hlbiBuZWVkZWRcblxuXG4gICAgICAgIHZhciB0aGlzRmlsdGVyID0gZmlsdGVyKHRoaXMuX29wdGlvbnMpO1xuXG4gICAgICAgIHZhciBvcHRpb25zRmlsdGVyID0gb3B0aW9ucyAmJiBmaWx0ZXIob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRoaXNGaWx0ZXIgJiYgb3B0aW9uc0ZpbHRlcikge1xuICAgICAgICAgIHZpZXdPcHRpb25zLmZpbHRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc0ZpbHRlcihpdGVtKSAmJiBvcHRpb25zRmlsdGVyKGl0ZW0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWRzID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXQodmlld09wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldChpZHMsIHZpZXdPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SWRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SWRzKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGRlZmF1bHRGaWx0ZXIgPSBmaWx0ZXIodGhpcy5fb3B0aW9ucyk7XG5cbiAgICAgICAgICB2YXIgb3B0aW9uc0ZpbHRlciA9IG9wdGlvbnMgIT0gbnVsbCA/IGZpbHRlcihvcHRpb25zKSA6IG51bGw7XG4gICAgICAgICAgdmFyIGZpbHRlciQxO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnNGaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0RmlsdGVyKSB7XG4gICAgICAgICAgICAgIGZpbHRlciQxID0gZnVuY3Rpb24gZmlsdGVyKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdEZpbHRlcihpdGVtKSAmJiBvcHRpb25zRmlsdGVyKGl0ZW0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmlsdGVyJDEgPSBvcHRpb25zRmlsdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWx0ZXIkMSA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0SWRzKHtcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyJDEsXG4gICAgICAgICAgICBvcmRlcjogb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmb3JFYWNoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgICAgIHZhciBfY29udGV4dDI7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdEZpbHRlciA9IGZpbHRlcih0aGlzLl9vcHRpb25zKTtcblxuICAgICAgICAgIHZhciBvcHRpb25zRmlsdGVyID0gb3B0aW9ucyAmJiBmaWx0ZXIob3B0aW9ucyk7XG5cbiAgICAgICAgICB2YXIgZmlsdGVyJDE7XG5cbiAgICAgICAgICBpZiAob3B0aW9uc0ZpbHRlcikge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgZmlsdGVyJDEgPSBmdW5jdGlvbiBmaWx0ZXIoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RmlsdGVyKGl0ZW0pICYmIG9wdGlvbnNGaWx0ZXIoaXRlbSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaWx0ZXIkMSA9IG9wdGlvbnNGaWx0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlciQxID0gZGVmYXVsdEZpbHRlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3JFYWNoJDEoX2NvbnRleHQyID0gdGhpcy5fZGF0YSkuY2FsbChfY29udGV4dDIsIGNhbGxiYWNrLCB7XG4gICAgICAgICAgICBmaWx0ZXI6IGZpbHRlciQxLFxuICAgICAgICAgICAgb3JkZXI6IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQzO1xuXG4gICAgICAgICAgdmFyIGRlZmF1bHRGaWx0ZXIgPSBmaWx0ZXIodGhpcy5fb3B0aW9ucyk7XG5cbiAgICAgICAgICB2YXIgb3B0aW9uc0ZpbHRlciA9IG9wdGlvbnMgJiYgZmlsdGVyKG9wdGlvbnMpO1xuXG4gICAgICAgICAgdmFyIGZpbHRlciQxO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnNGaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0RmlsdGVyKSB7XG4gICAgICAgICAgICAgIGZpbHRlciQxID0gZnVuY3Rpb24gZmlsdGVyKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdEZpbHRlcihpdGVtKSAmJiBvcHRpb25zRmlsdGVyKGl0ZW0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmlsdGVyJDEgPSBvcHRpb25zRmlsdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWx0ZXIkMSA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG1hcCQzKF9jb250ZXh0MyA9IHRoaXMuX2RhdGEpLmNhbGwoX2NvbnRleHQzLCBjYWxsYmFjaywge1xuICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIkMSxcbiAgICAgICAgICAgIG9yZGVyOiBvcHRpb25zICYmIG9wdGlvbnMub3JkZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldERhdGFTZXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREYXRhU2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXREYXRhU2V0KCk7XG4gICAgICB9XG4gICAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdHJlYW1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJlYW0oaWRzKSB7XG4gICAgICAgIHZhciBfY29udGV4dDQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuc3RyZWFtKGlkcyB8fCBfZGVmaW5lUHJvcGVydHkoe30sIGl0ZXJhdG9yLCBiaW5kJDYoX2NvbnRleHQ0ID0ga2V5cyh0aGlzLl9pZHMpKS5jYWxsKF9jb250ZXh0NCwgdGhpcy5faWRzKSkpO1xuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIFJlbmRlciB0aGUgaW5zdGFuY2UgdW51c2FibGUgcHJpb3IgdG8gZ2FyYmFnZSBjb2xsZWN0aW9uLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmVtYXJrc1xyXG4gICAgICAgKiBUaGUgaW50ZW50aW9uIG9mIHRoaXMgbWV0aG9kIGlzIHRvIGhlbHAgZGlzY292ZXIgc2NlbmFyaW9zIHdoZXJlIHRoZSBkYXRhXHJcbiAgICAgICAqIHZpZXcgaXMgYmVpbmcgdXNlZCB3aGVuIHRoZSBwcm9ncmFtbWVyIHRoaW5rcyBpdCBoYXMgYmVlbiBnYXJiYWdlIGNvbGxlY3RlZFxyXG4gICAgICAgKiBhbHJlYWR5LiBJdCdzIHN0cmljdGVyIHZlcnNpb24gb2YgYGRhdGFWaWV3LnNldERhdGEobnVsbClgLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgdmFyIF90aGlzJF9kYXRhO1xuXG4gICAgICAgIGlmICgoX3RoaXMkX2RhdGEgPSB0aGlzLl9kYXRhKSAhPT0gbnVsbCAmJiBfdGhpcyRfZGF0YSAhPT0gdm9pZCAwICYmIF90aGlzJF9kYXRhLm9mZikge1xuICAgICAgICAgIHRoaXMuX2RhdGEub2ZmKFwiKlwiLCB0aGlzLl9saXN0ZW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiVGhpcyBkYXRhIHZpZXcgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZCBvZi5cIjtcbiAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0ge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG93bktleXMkMShEYXRhVmlldy5wcm90b3R5cGUpKSxcbiAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkkNCh0aGlzLCBrZXksIHJlcGxhY2VtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXHJcbiAgICAgICAqIEV2ZW50IGxpc3RlbmVyLiBXaWxsIHByb3BhZ2F0ZSBhbGwgZXZlbnRzIGZyb20gdGhlIGNvbm5lY3RlZCBkYXRhIHNldCB0byB0aGUgc3Vic2NyaWJlcnMgb2YgdGhlIERhdGFWaWV3LCBidXQgd2lsbCBmaWx0ZXIgdGhlIGl0ZW1zIGFuZCBvbmx5IHRyaWdnZXIgd2hlbiB0aGVyZSBhcmUgY2hhbmdlcyBpbiB0aGUgZmlsdGVyZWQgZGF0YSBzZXQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgb2YgdGhlIGV2ZW50LlxyXG4gICAgICAgKiBAcGFyYW0gc2VuZGVySWQgLSBJZCBzdXBwbGllZCBieSB0aGUgc2VuZGVyLlxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfb25FdmVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkV2ZW50KGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICAgIGlmICghcGFyYW1zIHx8ICFwYXJhbXMuaXRlbXMgfHwgIXRoaXMuX2RhdGEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWRzID0gcGFyYW1zLml0ZW1zO1xuICAgICAgICB2YXIgYWRkZWRJZHMgPSBbXTtcbiAgICAgICAgdmFyIHVwZGF0ZWRJZHMgPSBbXTtcbiAgICAgICAgdmFyIHJlbW92ZWRJZHMgPSBbXTtcbiAgICAgICAgdmFyIG9sZEl0ZW1zID0gW107XG4gICAgICAgIHZhciB1cGRhdGVkSXRlbXMgPSBbXTtcbiAgICAgICAgdmFyIHJlbW92ZWRJdGVtcyA9IFtdO1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgICBjYXNlIFwiYWRkXCI6XG4gICAgICAgICAgICAvLyBmaWx0ZXIgdGhlIGlkcyBvZiB0aGUgYWRkZWQgaXRlbXNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0KGlkKTtcblxuICAgICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lkcy5hZGQoaWQpO1xuXG4gICAgICAgICAgICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIGV2ZW50IGZyb20gdGhlIHZpZXdzIHZpZXdwb2ludDogYW4gdXBkYXRlZFxuICAgICAgICAgICAgLy8gaXRlbSBjYW4gYmUgYWRkZWQsIHVwZGF0ZWQsIG9yIHJlbW92ZWQgZnJvbSB0aGlzIHZpZXcuXG4gICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfbGVuMiA9IGlkcy5sZW5ndGg7IF9pMiA8IF9sZW4yOyBfaTIrKykge1xuICAgICAgICAgICAgICB2YXIgX2lkMiA9IGlkc1tfaTJdO1xuXG4gICAgICAgICAgICAgIHZhciBfaXRlbSA9IHRoaXMuZ2V0KF9pZDIpO1xuXG4gICAgICAgICAgICAgIGlmIChfaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pZHMuaGFzKF9pZDIpKSB7XG4gICAgICAgICAgICAgICAgICB1cGRhdGVkSWRzLnB1c2goX2lkMik7XG4gICAgICAgICAgICAgICAgICB1cGRhdGVkSXRlbXMucHVzaChwYXJhbXMuZGF0YVtfaTJdKTtcbiAgICAgICAgICAgICAgICAgIG9sZEl0ZW1zLnB1c2gocGFyYW1zLm9sZERhdGFbX2kyXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2lkcy5hZGQoX2lkMik7XG5cbiAgICAgICAgICAgICAgICAgIGFkZGVkSWRzLnB1c2goX2lkMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pZHMuaGFzKF9pZDIpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9pZHMuZGVsZXRlKF9pZDIpO1xuXG4gICAgICAgICAgICAgICAgICByZW1vdmVkSWRzLnB1c2goX2lkMik7XG4gICAgICAgICAgICAgICAgICByZW1vdmVkSXRlbXMucHVzaChwYXJhbXMub2xkRGF0YVtfaTJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICAgICAgICAvLyBmaWx0ZXIgdGhlIGlkcyBvZiB0aGUgcmVtb3ZlZCBpdGVtc1xuICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMCwgX2xlbjMgPSBpZHMubGVuZ3RoOyBfaTMgPCBfbGVuMzsgX2kzKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9pZDMgPSBpZHNbX2kzXTtcblxuICAgICAgICAgICAgICBpZiAodGhpcy5faWRzLmhhcyhfaWQzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lkcy5kZWxldGUoX2lkMyk7XG5cbiAgICAgICAgICAgICAgICByZW1vdmVkSWRzLnB1c2goX2lkMyk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2gocGFyYW1zLm9sZERhdGFbX2kzXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxlbmd0aCArPSBhZGRlZElkcy5sZW5ndGggLSByZW1vdmVkSWRzLmxlbmd0aDtcblxuICAgICAgICBpZiAoYWRkZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlcihcImFkZFwiLCB7XG4gICAgICAgICAgICBpdGVtczogYWRkZWRJZHNcbiAgICAgICAgICB9LCBzZW5kZXJJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyKFwidXBkYXRlXCIsIHtcbiAgICAgICAgICAgIGl0ZW1zOiB1cGRhdGVkSWRzLFxuICAgICAgICAgICAgb2xkRGF0YTogb2xkSXRlbXMsXG4gICAgICAgICAgICBkYXRhOiB1cGRhdGVkSXRlbXNcbiAgICAgICAgICB9LCBzZW5kZXJJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVtb3ZlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyKFwicmVtb3ZlXCIsIHtcbiAgICAgICAgICAgIGl0ZW1zOiByZW1vdmVkSWRzLFxuICAgICAgICAgICAgb2xkRGF0YTogcmVtb3ZlZEl0ZW1zXG4gICAgICAgICAgfSwgc2VuZGVySWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERhdGFWaWV3O1xuICB9KERhdGFTZXRQYXJ0KTtcblxuICAvKipcclxuICAgKiBDaGVjayB0aGF0IGdpdmVuIHZhbHVlIGlzIGNvbXBhdGlibGUgd2l0aCBWaXMgRGF0YSBTZXQgaW50ZXJmYWNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGlkUHJvcCAtIFRoZSBleHBlY3RlZCBwcm9wZXJ0eSB0byBjb250YWluIGl0ZW0gaWQuXHJcbiAgICogQHBhcmFtIHYgLSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkLlxyXG4gICAqIEByZXR1cm5zIFRydWUgaWYgYWxsIGV4cGVjdGVkIHZhbHVlcyBhbmQgbWV0aG9kcyBtYXRjaCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBpc0RhdGFTZXRMaWtlKGlkUHJvcCwgdikge1xuICAgIHJldHVybiBfdHlwZW9mKHYpID09PSBcIm9iamVjdFwiICYmIHYgIT09IG51bGwgJiYgaWRQcm9wID09PSB2LmlkUHJvcCAmJiB0eXBlb2Ygdi5hZGQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5jbGVhciA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LmRpc3RpbmN0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGZvckVhY2gkMSh2KSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LmdldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LmdldERhdGFTZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5nZXRJZHMgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5sZW5ndGggPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG1hcCQzKHYpID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYubWF4ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYubWluID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYub2ZmID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYub24gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5yZW1vdmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5zZXRPcHRpb25zID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuc3RyZWFtID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYudXBkYXRlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYudXBkYXRlT25seSA9PT0gXCJmdW5jdGlvblwiO1xuICB9XG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgdGhhdCBnaXZlbiB2YWx1ZSBpcyBjb21wYXRpYmxlIHdpdGggVmlzIERhdGEgVmlldyBpbnRlcmZhY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaWRQcm9wIC0gVGhlIGV4cGVjdGVkIHByb3BlcnR5IHRvIGNvbnRhaW4gaXRlbSBpZC5cclxuICAgKiBAcGFyYW0gdiAtIFRoZSB2YWx1ZSB0byBiZSB0ZXN0ZWQuXHJcbiAgICogQHJldHVybnMgVHJ1ZSBpZiBhbGwgZXhwZWN0ZWQgdmFsdWVzIGFuZCBtZXRob2RzIG1hdGNoLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gaXNEYXRhVmlld0xpa2UoaWRQcm9wLCB2KSB7XG4gICAgcmV0dXJuIF90eXBlb2YodikgPT09IFwib2JqZWN0XCIgJiYgdiAhPT0gbnVsbCAmJiBpZFByb3AgPT09IHYuaWRQcm9wICYmIHR5cGVvZiBmb3JFYWNoJDEodikgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5nZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5nZXREYXRhU2V0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuZ2V0SWRzID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYubGVuZ3RoID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBtYXAkMyh2KSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2Lm9mZiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2Lm9uID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuc3RyZWFtID09PSBcImZ1bmN0aW9uXCIgJiYgaXNEYXRhU2V0TGlrZShpZFByb3AsIHYuZ2V0RGF0YVNldCgpKTtcbiAgfVxuXG4gIGV4cG9ydHMuREVMRVRFID0gREVMRVRFO1xuICBleHBvcnRzLkRhdGFTZXQgPSBEYXRhU2V0O1xuICBleHBvcnRzLkRhdGFTdHJlYW0gPSBEYXRhU3RyZWFtO1xuICBleHBvcnRzLkRhdGFWaWV3ID0gRGF0YVZpZXc7XG4gIGV4cG9ydHMuUXVldWUgPSBRdWV1ZTtcbiAgZXhwb3J0cy5jcmVhdGVOZXdEYXRhUGlwZUZyb20gPSBjcmVhdGVOZXdEYXRhUGlwZUZyb207XG4gIGV4cG9ydHMuaXNEYXRhU2V0TGlrZSA9IGlzRGF0YVNldExpa2U7XG4gIGV4cG9ydHMuaXNEYXRhVmlld0xpa2UgPSBpc0RhdGFWaWV3TGlrZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aXMtZGF0YS5qcy5tYXBcbiIsIi8qKlxuICogdmlzLWRhdGFcbiAqIGh0dHA6Ly92aXNqcy5vcmcvXG4gKlxuICogTWFuYWdlIHVuc3RydWN0dXJlZCBkYXRhIHVzaW5nIERhdGFTZXQuIEFkZCwgdXBkYXRlLCBhbmQgcmVtb3ZlIGRhdGEsIGFuZCBsaXN0ZW4gZm9yIGNoYW5nZXMgaW4gdGhlIGRhdGEuXG4gKlxuICogQHZlcnNpb24gNy4xLjRcbiAqIEBkYXRlICAgIDIwMjItMDMtMTVUMTU6MjM6NTkuMjQ1WlxuICpcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTEtMjAxNyBBbG1lbmRlIEIuViwgaHR0cDovL2FsbWVuZGUuY29tXG4gKiBAY29weXJpZ2h0IChjKSAyMDE3LTIwMTkgdmlzanMgY29udHJpYnV0b3JzLCBodHRwczovL2dpdGh1Yi5jb20vdmlzanNcbiAqXG4gKiBAbGljZW5zZVxuICogdmlzLmpzIGlzIGR1YWwgbGljZW5zZWQgdW5kZXIgYm90aFxuICpcbiAqICAgMS4gVGhlIEFwYWNoZSAyLjAgTGljZW5zZVxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgIGFuZFxuICpcbiAqICAgMi4gVGhlIE1JVCBMaWNlbnNlXG4gKiAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiB2aXMuanMgbWF5IGJlIGRpc3RyaWJ1dGVkIHVuZGVyIGVpdGhlciBsaWNlbnNlLlxuICovXG4hZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9lKGV4cG9ydHMpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiZXhwb3J0c1wiXSxlKTplKCh0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6dHx8c2VsZikudmlzPXQudmlzfHx7fSl9KHRoaXMsKGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfXZhciByPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp7fSxuPXtleHBvcnRzOnt9fSxpPWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0Lk1hdGg9PU1hdGgmJnR9LG89aShcIm9iamVjdFwiPT10eXBlb2YgZ2xvYmFsVGhpcyYmZ2xvYmFsVGhpcyl8fGkoXCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyYmd2luZG93KXx8aShcIm9iamVjdFwiPT10eXBlb2Ygc2VsZiYmc2VsZil8fGkoXCJvYmplY3RcIj09dHlwZW9mIHImJnIpfHxmdW5jdGlvbigpe3JldHVybiB0aGlzfSgpfHxGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCksYT1mdW5jdGlvbih0KXt0cnl7cmV0dXJuISF0KCl9Y2F0Y2godCl7cmV0dXJuITB9fSx1PSFhKChmdW5jdGlvbigpe3ZhciB0PWZ1bmN0aW9uKCl7fS5iaW5kKCk7cmV0dXJuXCJmdW5jdGlvblwiIT10eXBlb2YgdHx8dC5oYXNPd25Qcm9wZXJ0eShcInByb3RvdHlwZVwiKX0pKSxzPXUsYz1GdW5jdGlvbi5wcm90b3R5cGUsZj1jLmFwcGx5LGw9Yy5jYWxsLGg9XCJvYmplY3RcIj09dHlwZW9mIFJlZmxlY3QmJlJlZmxlY3QuYXBwbHl8fChzP2wuYmluZChmKTpmdW5jdGlvbigpe3JldHVybiBsLmFwcGx5KGYsYXJndW1lbnRzKX0pLHA9dSx2PUZ1bmN0aW9uLnByb3RvdHlwZSxkPXYuYmluZCx5PXYuY2FsbCxnPXAmJmQuYmluZCh5LHkpLG09cD9mdW5jdGlvbih0KXtyZXR1cm4gdCYmZyh0KX06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJmZ1bmN0aW9uKCl7cmV0dXJuIHkuYXBwbHkodCxhcmd1bWVudHMpfX0sYj1mdW5jdGlvbih0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0fSxfPXt9LHc9IWEoKGZ1bmN0aW9uKCl7cmV0dXJuIDchPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwxLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KVsxXX0pKSxPPXUsRT1GdW5jdGlvbi5wcm90b3R5cGUuY2FsbCxUPU8/RS5iaW5kKEUpOmZ1bmN0aW9uKCl7cmV0dXJuIEUuYXBwbHkoRSxhcmd1bWVudHMpfSx4PXt9LGs9e30ucHJvcGVydHlJc0VudW1lcmFibGUsUz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLEE9UyYmIWsuY2FsbCh7MToyfSwxKTt4LmY9QT9mdW5jdGlvbih0KXt2YXIgZT1TKHRoaXMsdCk7cmV0dXJuISFlJiZlLmVudW1lcmFibGV9Oms7dmFyIGosUCxJPWZ1bmN0aW9uKHQsZSl7cmV0dXJue2VudW1lcmFibGU6ISgxJnQpLGNvbmZpZ3VyYWJsZTohKDImdCksd3JpdGFibGU6ISg0JnQpLHZhbHVlOmV9fSxEPW0sTD1EKHt9LnRvU3RyaW5nKSxDPUQoXCJcIi5zbGljZSksUj1mdW5jdGlvbih0KXtyZXR1cm4gQyhMKHQpLDgsLTEpfSxNPW0sRj1hLE49Uix6PW8uT2JqZWN0LHE9TShcIlwiLnNwbGl0KSxZPUYoKGZ1bmN0aW9uKCl7cmV0dXJuIXooXCJ6XCIpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApfSkpP2Z1bmN0aW9uKHQpe3JldHVyblwiU3RyaW5nXCI9PU4odCk/cSh0LFwiXCIpOnoodCl9OnosRz1vLlR5cGVFcnJvcixYPWZ1bmN0aW9uKHQpe2lmKG51bGw9PXQpdGhyb3cgRyhcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiK3QpO3JldHVybiB0fSxVPVksVz1YLFY9ZnVuY3Rpb24odCl7cmV0dXJuIFUoVyh0KSl9LEg9YiwkPWZ1bmN0aW9uKHQpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiB0P251bGwhPT10OkgodCl9LEI9e30sSj1CLEs9byxRPWIsWj1mdW5jdGlvbih0KXtyZXR1cm4gUSh0KT90OnZvaWQgMH0sdHQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aDwyP1ooSlt0XSl8fFooS1t0XSk6Slt0XSYmSlt0XVtlXXx8S1t0XSYmS1t0XVtlXX0sZXQ9bSh7fS5pc1Byb3RvdHlwZU9mKSxydD10dChcIm5hdmlnYXRvclwiLFwidXNlckFnZW50XCIpfHxcIlwiLG50PW8saXQ9cnQsb3Q9bnQucHJvY2VzcyxhdD1udC5EZW5vLHV0PW90JiZvdC52ZXJzaW9uc3x8YXQmJmF0LnZlcnNpb24sc3Q9dXQmJnV0LnY4O3N0JiYoUD0oaj1zdC5zcGxpdChcIi5cIikpWzBdPjAmJmpbMF08ND8xOisoalswXStqWzFdKSksIVAmJml0JiYoIShqPWl0Lm1hdGNoKC9FZGdlXFwvKFxcZCspLykpfHxqWzFdPj03NCkmJihqPWl0Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKSkmJihQPStqWzFdKTt2YXIgY3Q9UCxmdD1jdCxsdD1hLGh0PSEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyYmIWx0KChmdW5jdGlvbigpe3ZhciB0PVN5bWJvbCgpO3JldHVybiFTdHJpbmcodCl8fCEoT2JqZWN0KHQpaW5zdGFuY2VvZiBTeW1ib2wpfHwhU3ltYm9sLnNoYW0mJmZ0JiZmdDw0MX0pKSxwdD1odCYmIVN5bWJvbC5zaGFtJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yLHZ0PXR0LGR0PWIseXQ9ZXQsZ3Q9cHQsbXQ9by5PYmplY3QsYnQ9Z3Q/ZnVuY3Rpb24odCl7cmV0dXJuXCJzeW1ib2xcIj09dHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3ZhciBlPXZ0KFwiU3ltYm9sXCIpO3JldHVybiBkdChlKSYmeXQoZS5wcm90b3R5cGUsbXQodCkpfSxfdD1vLlN0cmluZyx3dD1mdW5jdGlvbih0KXt0cnl7cmV0dXJuIF90KHQpfWNhdGNoKHQpe3JldHVyblwiT2JqZWN0XCJ9fSxPdD1iLEV0PXd0LFR0PW8uVHlwZUVycm9yLHh0PWZ1bmN0aW9uKHQpe2lmKE90KHQpKXJldHVybiB0O3Rocm93IFR0KEV0KHQpK1wiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpfSxrdD14dCxTdD1mdW5jdGlvbih0LGUpe3ZhciByPXRbZV07cmV0dXJuIG51bGw9PXI/dm9pZCAwOmt0KHIpfSxBdD1ULGp0PWIsUHQ9JCxJdD1vLlR5cGVFcnJvcixEdD17ZXhwb3J0czp7fX0sTHQ9byxDdD1PYmplY3QuZGVmaW5lUHJvcGVydHksUnQ9ZnVuY3Rpb24odCxlKXt0cnl7Q3QoTHQsdCx7dmFsdWU6ZSxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KX1jYXRjaChyKXtMdFt0XT1lfXJldHVybiBlfSxNdD1cIl9fY29yZS1qc19zaGFyZWRfX1wiLEZ0PW9bTXRdfHxSdChNdCx7fSksTnQ9RnQ7KER0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gTnRbdF18fChOdFt0XT12b2lkIDAhPT1lP2U6e30pfSkoXCJ2ZXJzaW9uc1wiLFtdKS5wdXNoKHt2ZXJzaW9uOlwiMy4yMS4xXCIsbW9kZTpcInB1cmVcIixjb3B5cmlnaHQ6XCLCqSAyMDE0LTIwMjIgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSlcIixsaWNlbnNlOlwiaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4yMS4xL0xJQ0VOU0VcIixzb3VyY2U6XCJodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qc1wifSk7dmFyIHp0PVgscXQ9by5PYmplY3QsWXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHF0KHp0KHQpKX0sR3Q9WXQsWHQ9bSh7fS5oYXNPd25Qcm9wZXJ0eSksVXQ9T2JqZWN0Lmhhc093bnx8ZnVuY3Rpb24odCxlKXtyZXR1cm4gWHQoR3QodCksZSl9LFd0PW0sVnQ9MCxIdD1NYXRoLnJhbmRvbSgpLCR0PVd0KDEuLnRvU3RyaW5nKSxCdD1mdW5jdGlvbih0KXtyZXR1cm5cIlN5bWJvbChcIisodm9pZCAwPT09dD9cIlwiOnQpK1wiKV9cIiskdCgrK1Z0K0h0LDM2KX0sSnQ9byxLdD1EdC5leHBvcnRzLFF0PVV0LFp0PUJ0LHRlPWh0LGVlPXB0LHJlPUt0KFwid2tzXCIpLG5lPUp0LlN5bWJvbCxpZT1uZSYmbmUuZm9yLG9lPWVlP25lOm5lJiZuZS53aXRob3V0U2V0dGVyfHxadCxhZT1mdW5jdGlvbih0KXtpZighUXQocmUsdCl8fCF0ZSYmXCJzdHJpbmdcIiE9dHlwZW9mIHJlW3RdKXt2YXIgZT1cIlN5bWJvbC5cIit0O3RlJiZRdChuZSx0KT9yZVt0XT1uZVt0XTpyZVt0XT1lZSYmaWU/aWUoZSk6b2UoZSl9cmV0dXJuIHJlW3RdfSx1ZT1ULHNlPSQsY2U9YnQsZmU9U3QsbGU9ZnVuY3Rpb24odCxlKXt2YXIgcixuO2lmKFwic3RyaW5nXCI9PT1lJiZqdChyPXQudG9TdHJpbmcpJiYhUHQobj1BdChyLHQpKSlyZXR1cm4gbjtpZihqdChyPXQudmFsdWVPZikmJiFQdChuPUF0KHIsdCkpKXJldHVybiBuO2lmKFwic3RyaW5nXCIhPT1lJiZqdChyPXQudG9TdHJpbmcpJiYhUHQobj1BdChyLHQpKSlyZXR1cm4gbjt0aHJvdyBJdChcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKX0saGU9YWUscGU9by5UeXBlRXJyb3IsdmU9aGUoXCJ0b1ByaW1pdGl2ZVwiKSxkZT1mdW5jdGlvbih0LGUpe2lmKCFzZSh0KXx8Y2UodCkpcmV0dXJuIHQ7dmFyIHIsbj1mZSh0LHZlKTtpZihuKXtpZih2b2lkIDA9PT1lJiYoZT1cImRlZmF1bHRcIikscj11ZShuLHQsZSksIXNlKHIpfHxjZShyKSlyZXR1cm4gcjt0aHJvdyBwZShcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKX1yZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJudW1iZXJcIiksbGUodCxlKX0seWU9YnQsZ2U9ZnVuY3Rpb24odCl7dmFyIGU9ZGUodCxcInN0cmluZ1wiKTtyZXR1cm4geWUoZSk/ZTplK1wiXCJ9LG1lPSQsYmU9by5kb2N1bWVudCxfZT1tZShiZSkmJm1lKGJlLmNyZWF0ZUVsZW1lbnQpLHdlPWZ1bmN0aW9uKHQpe3JldHVybiBfZT9iZS5jcmVhdGVFbGVtZW50KHQpOnt9fSxPZT13ZSxFZT0hdyYmIWEoKGZ1bmN0aW9uKCl7cmV0dXJuIDchPU9iamVjdC5kZWZpbmVQcm9wZXJ0eShPZShcImRpdlwiKSxcImFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYX0pKSxUZT13LHhlPVQsa2U9eCxTZT1JLEFlPVYsamU9Z2UsUGU9VXQsSWU9RWUsRGU9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtfLmY9VGU/RGU6ZnVuY3Rpb24odCxlKXtpZih0PUFlKHQpLGU9amUoZSksSWUpdHJ5e3JldHVybiBEZSh0LGUpfWNhdGNoKHQpe31pZihQZSh0LGUpKXJldHVybiBTZSgheGUoa2UuZix0LGUpLHRbZV0pfTt2YXIgTGU9YSxDZT1iLFJlPS8jfFxcLnByb3RvdHlwZVxcLi8sTWU9ZnVuY3Rpb24odCxlKXt2YXIgcj1OZVtGZSh0KV07cmV0dXJuIHI9PXFlfHxyIT16ZSYmKENlKGUpP0xlKGUpOiEhZSl9LEZlPU1lLm5vcm1hbGl6ZT1mdW5jdGlvbih0KXtyZXR1cm4gU3RyaW5nKHQpLnJlcGxhY2UoUmUsXCIuXCIpLnRvTG93ZXJDYXNlKCl9LE5lPU1lLmRhdGE9e30semU9TWUuTkFUSVZFPVwiTlwiLHFlPU1lLlBPTFlGSUxMPVwiUFwiLFllPU1lLEdlPXh0LFhlPXUsVWU9bShtLmJpbmQpLFdlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEdlKHQpLHZvaWQgMD09PWU/dDpYZT9VZSh0LGUpOmZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkoZSxhcmd1bWVudHMpfX0sVmU9e30sSGU9dyYmYSgoZnVuY3Rpb24oKXtyZXR1cm4gNDIhPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSgoZnVuY3Rpb24oKXt9KSxcInByb3RvdHlwZVwiLHt2YWx1ZTo0Mix3cml0YWJsZTohMX0pLnByb3RvdHlwZX0pKSwkZT1vLEJlPSQsSmU9JGUuU3RyaW5nLEtlPSRlLlR5cGVFcnJvcixRZT1mdW5jdGlvbih0KXtpZihCZSh0KSlyZXR1cm4gdDt0aHJvdyBLZShKZSh0KStcIiBpcyBub3QgYW4gb2JqZWN0XCIpfSxaZT13LHRyPUVlLGVyPUhlLHJyPVFlLG5yPWdlLGlyPW8uVHlwZUVycm9yLG9yPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxhcj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLHVyPVwiZW51bWVyYWJsZVwiLHNyPVwiY29uZmlndXJhYmxlXCIsY3I9XCJ3cml0YWJsZVwiO1ZlLmY9WmU/ZXI/ZnVuY3Rpb24odCxlLHIpe2lmKHJyKHQpLGU9bnIoZSkscnIociksXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmXCJwcm90b3R5cGVcIj09PWUmJlwidmFsdWVcImluIHImJmNyIGluIHImJiFyLndyaXRhYmxlKXt2YXIgbj1hcih0LGUpO24mJm4ud3JpdGFibGUmJih0W2VdPXIudmFsdWUscj17Y29uZmlndXJhYmxlOnNyIGluIHI/ci5jb25maWd1cmFibGU6bi5jb25maWd1cmFibGUsZW51bWVyYWJsZTp1ciBpbiByP3IuZW51bWVyYWJsZTpuLmVudW1lcmFibGUsd3JpdGFibGU6ITF9KX1yZXR1cm4gb3IodCxlLHIpfTpvcjpmdW5jdGlvbih0LGUscil7aWYocnIodCksZT1ucihlKSxycihyKSx0cil0cnl7cmV0dXJuIG9yKHQsZSxyKX1jYXRjaCh0KXt9aWYoXCJnZXRcImluIHJ8fFwic2V0XCJpbiByKXRocm93IGlyKFwiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuXCJ2YWx1ZVwiaW4gciYmKHRbZV09ci52YWx1ZSksdH07dmFyIGZyPVZlLGxyPUksaHI9dz9mdW5jdGlvbih0LGUscil7cmV0dXJuIGZyLmYodCxlLGxyKDEscikpfTpmdW5jdGlvbih0LGUscil7cmV0dXJuIHRbZV09cix0fSxwcj1vLHZyPWgsZHI9bSx5cj1iLGdyPV8uZixtcj1ZZSxicj1CLF9yPVdlLHdyPWhyLE9yPVV0LEVyPWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKHIsbixpKXtpZih0aGlzIGluc3RhbmNlb2YgZSl7c3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbmV3IHQ7Y2FzZSAxOnJldHVybiBuZXcgdChyKTtjYXNlIDI6cmV0dXJuIG5ldyB0KHIsbil9cmV0dXJuIG5ldyB0KHIsbixpKX1yZXR1cm4gdnIodCx0aGlzLGFyZ3VtZW50cyl9O3JldHVybiBlLnByb3RvdHlwZT10LnByb3RvdHlwZSxlfSxUcj1mdW5jdGlvbih0LGUpe3ZhciByLG4saSxvLGEsdSxzLGMsZj10LnRhcmdldCxsPXQuZ2xvYmFsLGg9dC5zdGF0LHA9dC5wcm90byx2PWw/cHI6aD9wcltmXToocHJbZl18fHt9KS5wcm90b3R5cGUsZD1sP2JyOmJyW2ZdfHx3cihicixmLHt9KVtmXSx5PWQucHJvdG90eXBlO2ZvcihpIGluIGUpcj0hbXIobD9pOmYrKGg/XCIuXCI6XCIjXCIpK2ksdC5mb3JjZWQpJiZ2JiZPcih2LGkpLGE9ZFtpXSxyJiYodT10Lm5vVGFyZ2V0R2V0PyhjPWdyKHYsaSkpJiZjLnZhbHVlOnZbaV0pLG89ciYmdT91OmVbaV0sciYmdHlwZW9mIGE9PXR5cGVvZiBvfHwocz10LmJpbmQmJnI/X3Iobyxwcik6dC53cmFwJiZyP0VyKG8pOnAmJnlyKG8pP2RyKG8pOm8sKHQuc2hhbXx8byYmby5zaGFtfHxhJiZhLnNoYW0pJiZ3cihzLFwic2hhbVwiLCEwKSx3cihkLGkscykscCYmKE9yKGJyLG49ZitcIlByb3RvdHlwZVwiKXx8d3IoYnIsbix7fSksd3IoYnJbbl0saSxvKSx0LnJlYWwmJnkmJiF5W2ldJiZ3cih5LGksbykpKX0seHI9VHIsa3I9dyxTcj1WZS5mO3hyKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDpPYmplY3QuZGVmaW5lUHJvcGVydHkhPT1TcixzaGFtOiFrcn0se2RlZmluZVByb3BlcnR5OlNyfSk7dmFyIEFyPUIuT2JqZWN0LGpyPW4uZXhwb3J0cz1mdW5jdGlvbih0LGUscil7cmV0dXJuIEFyLmRlZmluZVByb3BlcnR5KHQsZSxyKX07QXIuZGVmaW5lUHJvcGVydHkuc2hhbSYmKGpyLnNoYW09ITApO3ZhciBQcj1uLmV4cG9ydHMsSXI9UHI7ZnVuY3Rpb24gRHIodCxlKXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIG49ZVtyXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksSXIodCxuLmtleSxuKX19ZnVuY3Rpb24gTHIodCxlLHIpe3JldHVybiBlJiZEcih0LnByb3RvdHlwZSxlKSxyJiZEcih0LHIpLElyKHQsXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KSx0fWZ1bmN0aW9uIENyKHQsZSxyKXtyZXR1cm4gZSBpbiB0P0lyKHQsZSx7dmFsdWU6cixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09cix0fXZhciBScj1tKFtdLnNsaWNlKSxNcj1tLEZyPXh0LE5yPSQsenI9VXQscXI9UnIsWXI9dSxHcj1vLkZ1bmN0aW9uLFhyPU1yKFtdLmNvbmNhdCksVXI9TXIoW10uam9pbiksV3I9e30sVnI9ZnVuY3Rpb24odCxlLHIpe2lmKCF6cihXcixlKSl7Zm9yKHZhciBuPVtdLGk9MDtpPGU7aSsrKW5baV09XCJhW1wiK2krXCJdXCI7V3JbZV09R3IoXCJDLGFcIixcInJldHVybiBuZXcgQyhcIitVcihuLFwiLFwiKStcIilcIil9cmV0dXJuIFdyW2VdKHQscil9LEhyPVlyP0dyLmJpbmQ6ZnVuY3Rpb24odCl7dmFyIGU9RnIodGhpcykscj1lLnByb3RvdHlwZSxuPXFyKGFyZ3VtZW50cywxKSxpPWZ1bmN0aW9uKCl7dmFyIHI9WHIobixxcihhcmd1bWVudHMpKTtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGk/VnIoZSxyLmxlbmd0aCxyKTplLmFwcGx5KHQscil9O3JldHVybiBOcihyKSYmKGkucHJvdG90eXBlPXIpLGl9LCRyPUhyO1RyKHt0YXJnZXQ6XCJGdW5jdGlvblwiLHByb3RvOiEwLGZvcmNlZDpGdW5jdGlvbi5iaW5kIT09JHJ9LHtiaW5kOiRyfSk7dmFyIEJyPUIsSnI9ZnVuY3Rpb24odCl7cmV0dXJuIEJyW3QrXCJQcm90b3R5cGVcIl19LEtyPUpyKFwiRnVuY3Rpb25cIikuYmluZCxRcj1ldCxacj1Lcix0bj1GdW5jdGlvbi5wcm90b3R5cGUsZW49ZnVuY3Rpb24odCl7dmFyIGU9dC5iaW5kO3JldHVybiB0PT09dG58fFFyKHRuLHQpJiZlPT09dG4uYmluZD9acjplfSxybj1NYXRoLmNlaWwsbm49TWF0aC5mbG9vcixvbj1mdW5jdGlvbih0KXt2YXIgZT0rdDtyZXR1cm4gZSE9ZXx8MD09PWU/MDooZT4wP25uOnJuKShlKX0sYW49b24sdW49TWF0aC5taW4sc249ZnVuY3Rpb24odCl7cmV0dXJuIHQ+MD91bihhbih0KSw5MDA3MTk5MjU0NzQwOTkxKTowfSxjbj1mdW5jdGlvbih0KXtyZXR1cm4gc24odC5sZW5ndGgpfSxmbj14dCxsbj1ZdCxobj1ZLHBuPWNuLHZuPW8uVHlwZUVycm9yLGRuPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLHIsbixpKXtmbihyKTt2YXIgbz1sbihlKSxhPWhuKG8pLHU9cG4obykscz10P3UtMTowLGM9dD8tMToxO2lmKG48Milmb3IoOzspe2lmKHMgaW4gYSl7aT1hW3NdLHMrPWM7YnJlYWt9aWYocys9Yyx0P3M8MDp1PD1zKXRocm93IHZuKFwiUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZVwiKX1mb3IoO3Q/cz49MDp1PnM7cys9YylzIGluIGEmJihpPXIoaSxhW3NdLHMsbykpO3JldHVybiBpfX0seW49e2xlZnQ6ZG4oITEpLHJpZ2h0OmRuKCEwKX0sZ249YSxtbj1mdW5jdGlvbih0LGUpe3ZhciByPVtdW3RdO3JldHVybiEhciYmZ24oKGZ1bmN0aW9uKCl7ci5jYWxsKG51bGwsZXx8ZnVuY3Rpb24oKXtyZXR1cm4gMX0sMSl9KSl9LGJuPVwicHJvY2Vzc1wiPT1SKG8ucHJvY2VzcyksX249eW4ubGVmdCx3bj1jdCxPbj1ibjtUcih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IW1uKFwicmVkdWNlXCIpfHwhT24mJnduPjc5JiZ3bjw4M30se3JlZHVjZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoO3JldHVybiBfbih0aGlzLHQsZSxlPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSk7dmFyIEVuPUpyKFwiQXJyYXlcIikucmVkdWNlLFRuPWV0LHhuPUVuLGtuPUFycmF5LnByb3RvdHlwZSxTbj1mdW5jdGlvbih0KXt2YXIgZT10LnJlZHVjZTtyZXR1cm4gdD09PWtufHxUbihrbix0KSYmZT09PWtuLnJlZHVjZT94bjplfSxBbj1SLGpuPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKHQpe3JldHVyblwiQXJyYXlcIj09QW4odCl9LFBuPXt9O1BuW2FlKFwidG9TdHJpbmdUYWdcIildPVwielwiO3ZhciBJbj1cIltvYmplY3Qgel1cIj09PVN0cmluZyhQbiksRG49byxMbj1JbixDbj1iLFJuPVIsTW49YWUoXCJ0b1N0cmluZ1RhZ1wiKSxGbj1Ebi5PYmplY3QsTm49XCJBcmd1bWVudHNcIj09Um4oZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKSx6bj1Mbj9SbjpmdW5jdGlvbih0KXt2YXIgZSxyLG47cmV0dXJuIHZvaWQgMD09PXQ/XCJVbmRlZmluZWRcIjpudWxsPT09dD9cIk51bGxcIjpcInN0cmluZ1wiPT10eXBlb2Yocj1mdW5jdGlvbih0LGUpe3RyeXtyZXR1cm4gdFtlXX1jYXRjaCh0KXt9fShlPUZuKHQpLE1uKSk/cjpObj9SbihlKTpcIk9iamVjdFwiPT0obj1SbihlKSkmJkNuKGUuY2FsbGVlKT9cIkFyZ3VtZW50c1wiOm59LHFuPWIsWW49RnQsR249bShGdW5jdGlvbi50b1N0cmluZyk7cW4oWW4uaW5zcGVjdFNvdXJjZSl8fChZbi5pbnNwZWN0U291cmNlPWZ1bmN0aW9uKHQpe3JldHVybiBHbih0KX0pO3ZhciBYbj1Zbi5pbnNwZWN0U291cmNlLFVuPW0sV249YSxWbj1iLEhuPXpuLCRuPVhuLEJuPWZ1bmN0aW9uKCl7fSxKbj1bXSxLbj10dChcIlJlZmxlY3RcIixcImNvbnN0cnVjdFwiKSxRbj0vXlxccyooPzpjbGFzc3xmdW5jdGlvbilcXGIvLFpuPVVuKFFuLmV4ZWMpLHRpPSFRbi5leGVjKEJuKSxlaT1mdW5jdGlvbih0KXtpZighVm4odCkpcmV0dXJuITE7dHJ5e3JldHVybiBLbihCbixKbix0KSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19LHJpPWZ1bmN0aW9uKHQpe2lmKCFWbih0KSlyZXR1cm4hMTtzd2l0Y2goSG4odCkpe2Nhc2VcIkFzeW5jRnVuY3Rpb25cIjpjYXNlXCJHZW5lcmF0b3JGdW5jdGlvblwiOmNhc2VcIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb25cIjpyZXR1cm4hMX10cnl7cmV0dXJuIHRpfHwhIVpuKFFuLCRuKHQpKX1jYXRjaCh0KXtyZXR1cm4hMH19O3JpLnNoYW09ITA7dmFyIG5pPSFLbnx8V24oKGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIGVpKGVpLmNhbGwpfHwhZWkoT2JqZWN0KXx8IWVpKChmdW5jdGlvbigpe3Q9ITB9KSl8fHR9KSk/cmk6ZWksaWk9byxvaT1qbixhaT1uaSx1aT0kLHNpPWFlKFwic3BlY2llc1wiKSxjaT1paS5BcnJheSxmaT1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gb2kodCkmJihlPXQuY29uc3RydWN0b3IsKGFpKGUpJiYoZT09PWNpfHxvaShlLnByb3RvdHlwZSkpfHx1aShlKSYmbnVsbD09PShlPWVbc2ldKSkmJihlPXZvaWQgMCkpLHZvaWQgMD09PWU/Y2k6ZX0sbGk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3KGZpKHQpKSgwPT09ZT8wOmUpfSxoaT1XZSxwaT1ZLHZpPVl0LGRpPWNuLHlpPWxpLGdpPW0oW10ucHVzaCksbWk9ZnVuY3Rpb24odCl7dmFyIGU9MT09dCxyPTI9PXQsbj0zPT10LGk9ND09dCxvPTY9PXQsYT03PT10LHU9NT09dHx8bztyZXR1cm4gZnVuY3Rpb24ocyxjLGYsbCl7Zm9yKHZhciBoLHAsdj12aShzKSxkPXBpKHYpLHk9aGkoYyxmKSxnPWRpKGQpLG09MCxiPWx8fHlpLF89ZT9iKHMsZyk6cnx8YT9iKHMsMCk6dm9pZCAwO2c+bTttKyspaWYoKHV8fG0gaW4gZCkmJihwPXkoaD1kW21dLG0sdiksdCkpaWYoZSlfW21dPXA7ZWxzZSBpZihwKXN3aXRjaCh0KXtjYXNlIDM6cmV0dXJuITA7Y2FzZSA1OnJldHVybiBoO2Nhc2UgNjpyZXR1cm4gbTtjYXNlIDI6Z2koXyxoKX1lbHNlIHN3aXRjaCh0KXtjYXNlIDQ6cmV0dXJuITE7Y2FzZSA3OmdpKF8saCl9cmV0dXJuIG8/LTE6bnx8aT9pOl99fSxiaT17Zm9yRWFjaDptaSgwKSxtYXA6bWkoMSksZmlsdGVyOm1pKDIpLHNvbWU6bWkoMyksZXZlcnk6bWkoNCksZmluZDptaSg1KSxmaW5kSW5kZXg6bWkoNiksZmlsdGVyUmVqZWN0Om1pKDcpfSxfaT1hLHdpPWN0LE9pPWFlKFwic3BlY2llc1wiKSxFaT1mdW5jdGlvbih0KXtyZXR1cm4gd2k+PTUxfHwhX2koKGZ1bmN0aW9uKCl7dmFyIGU9W107cmV0dXJuKGUuY29uc3RydWN0b3I9e30pW09pXT1mdW5jdGlvbigpe3JldHVybntmb286MX19LDEhPT1lW3RdKEJvb2xlYW4pLmZvb30pKX0sVGk9YmkuZmlsdGVyO1RyKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohRWkoXCJmaWx0ZXJcIil9LHtmaWx0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIFRpKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSk7dmFyIHhpPUpyKFwiQXJyYXlcIikuZmlsdGVyLGtpPWV0LFNpPXhpLEFpPUFycmF5LnByb3RvdHlwZSxqaT1mdW5jdGlvbih0KXt2YXIgZT10LmZpbHRlcjtyZXR1cm4gdD09PUFpfHxraShBaSx0KSYmZT09PUFpLmZpbHRlcj9TaTplfSxQaT1iaS5tYXA7VHIoe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOiFFaShcIm1hcFwiKX0se21hcDpmdW5jdGlvbih0KXtyZXR1cm4gUGkodGhpcyx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19KTt2YXIgSWk9SnIoXCJBcnJheVwiKS5tYXAsRGk9ZXQsTGk9SWksQ2k9QXJyYXkucHJvdG90eXBlLFJpPWZ1bmN0aW9uKHQpe3ZhciBlPXQubWFwO3JldHVybiB0PT09Q2l8fERpKENpLHQpJiZlPT09Q2kubWFwP0xpOmV9LE1pPWpuLEZpPWNuLE5pPVdlLHppPW8uVHlwZUVycm9yLHFpPWZ1bmN0aW9uKHQsZSxyLG4saSxvLGEsdSl7Zm9yKHZhciBzLGMsZj1pLGw9MCxoPSEhYSYmTmkoYSx1KTtsPG47KXtpZihsIGluIHIpe2lmKHM9aD9oKHJbbF0sbCxlKTpyW2xdLG8+MCYmTWkocykpYz1GaShzKSxmPXFpKHQsZSxzLGMsZixvLTEpLTE7ZWxzZXtpZihmPj05MDA3MTk5MjU0NzQwOTkxKXRocm93IHppKFwiRXhjZWVkIHRoZSBhY2NlcHRhYmxlIGFycmF5IGxlbmd0aFwiKTt0W2ZdPXN9ZisrfWwrK31yZXR1cm4gZn0sWWk9cWksR2k9eHQsWGk9WXQsVWk9Y24sV2k9bGk7VHIoe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITB9LHtmbGF0TWFwOmZ1bmN0aW9uKHQpe3ZhciBlLHI9WGkodGhpcyksbj1VaShyKTtyZXR1cm4gR2kodCksKGU9V2kociwwKSkubGVuZ3RoPVlpKGUscixyLG4sMCwxLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApLGV9fSk7dmFyIFZpPUpyKFwiQXJyYXlcIikuZmxhdE1hcCxIaT1ldCwkaT1WaSxCaT1BcnJheS5wcm90b3R5cGUsSmk9ZnVuY3Rpb24odCl7dmFyIGU9dC5mbGF0TWFwO3JldHVybiB0PT09Qml8fEhpKEJpLHQpJiZlPT09QmkuZmxhdE1hcD8kaTplfTt2YXIgS2ksUWksWmksdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHIsbixpKXt2YXIgbyxhLHU7ZSh0aGlzLHQpLENyKHRoaXMsXCJfc291cmNlXCIsdm9pZCAwKSxDcih0aGlzLFwiX3RyYW5zZm9ybWVyc1wiLHZvaWQgMCksQ3IodGhpcyxcIl90YXJnZXRcIix2b2lkIDApLENyKHRoaXMsXCJfbGlzdGVuZXJzXCIse2FkZDplbihvPXRoaXMuX2FkZCkuY2FsbChvLHRoaXMpLHJlbW92ZTplbihhPXRoaXMuX3JlbW92ZSkuY2FsbChhLHRoaXMpLHVwZGF0ZTplbih1PXRoaXMuX3VwZGF0ZSkuY2FsbCh1LHRoaXMpfSksdGhpcy5fc291cmNlPXIsdGhpcy5fdHJhbnNmb3JtZXJzPW4sdGhpcy5fdGFyZ2V0PWl9cmV0dXJuIExyKHQsW3trZXk6XCJhbGxcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl90YXJnZXQudXBkYXRlKHRoaXMuX3RyYW5zZm9ybUl0ZW1zKHRoaXMuX3NvdXJjZS5nZXQoKSkpLHRoaXN9fSx7a2V5Olwic3RhcnRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zb3VyY2Uub24oXCJhZGRcIix0aGlzLl9saXN0ZW5lcnMuYWRkKSx0aGlzLl9zb3VyY2Uub24oXCJyZW1vdmVcIix0aGlzLl9saXN0ZW5lcnMucmVtb3ZlKSx0aGlzLl9zb3VyY2Uub24oXCJ1cGRhdGVcIix0aGlzLl9saXN0ZW5lcnMudXBkYXRlKSx0aGlzfX0se2tleTpcInN0b3BcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zb3VyY2Uub2ZmKFwiYWRkXCIsdGhpcy5fbGlzdGVuZXJzLmFkZCksdGhpcy5fc291cmNlLm9mZihcInJlbW92ZVwiLHRoaXMuX2xpc3RlbmVycy5yZW1vdmUpLHRoaXMuX3NvdXJjZS5vZmYoXCJ1cGRhdGVcIix0aGlzLl9saXN0ZW5lcnMudXBkYXRlKSx0aGlzfX0se2tleTpcIl90cmFuc2Zvcm1JdGVtc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBTbihlPXRoaXMuX3RyYW5zZm9ybWVycykuY2FsbChlLChmdW5jdGlvbih0LGUpe3JldHVybiBlKHQpfSksdCl9fSx7a2V5OlwiX2FkZFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7bnVsbCE9ZSYmdGhpcy5fdGFyZ2V0LmFkZCh0aGlzLl90cmFuc2Zvcm1JdGVtcyh0aGlzLl9zb3VyY2UuZ2V0KGUuaXRlbXMpKSl9fSx7a2V5OlwiX3VwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7bnVsbCE9ZSYmdGhpcy5fdGFyZ2V0LnVwZGF0ZSh0aGlzLl90cmFuc2Zvcm1JdGVtcyh0aGlzLl9zb3VyY2UuZ2V0KGUuaXRlbXMpKSl9fSx7a2V5OlwiX3JlbW92ZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7bnVsbCE9ZSYmdGhpcy5fdGFyZ2V0LnJlbW92ZSh0aGlzLl90cmFuc2Zvcm1JdGVtcyhlLm9sZERhdGEpKX19XSksdH0oKSxlbz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQocil7ZSh0aGlzLHQpLENyKHRoaXMsXCJfc291cmNlXCIsdm9pZCAwKSxDcih0aGlzLFwiX3RyYW5zZm9ybWVyc1wiLFtdKSx0aGlzLl9zb3VyY2U9cn1yZXR1cm4gTHIodCxbe2tleTpcImZpbHRlclwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl90cmFuc2Zvcm1lcnMucHVzaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGppKGUpLmNhbGwoZSx0KX0pKSx0aGlzfX0se2tleTpcIm1hcFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl90cmFuc2Zvcm1lcnMucHVzaCgoZnVuY3Rpb24oZSl7cmV0dXJuIFJpKGUpLmNhbGwoZSx0KX0pKSx0aGlzfX0se2tleTpcImZsYXRNYXBcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fdHJhbnNmb3JtZXJzLnB1c2goKGZ1bmN0aW9uKGUpe3JldHVybiBKaShlKS5jYWxsKGUsdCl9KSksdGhpc319LHtrZXk6XCJ0b1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgdG8odGhpcy5fc291cmNlLHRoaXMuX3RyYW5zZm9ybWVycyx0KX19XSksdH0oKSxybz16bixubz1vLlN0cmluZyxpbz1mdW5jdGlvbih0KXtpZihcIlN5bWJvbFwiPT09cm8odCkpdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmdcIik7cmV0dXJuIG5vKHQpfSxvbz1tLGFvPW9uLHVvPWlvLHNvPVgsY289b28oXCJcIi5jaGFyQXQpLGZvPW9vKFwiXCIuY2hhckNvZGVBdCksbG89b28oXCJcIi5zbGljZSksaG89ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUscil7dmFyIG4saSxvPXVvKHNvKGUpKSxhPWFvKHIpLHU9by5sZW5ndGg7cmV0dXJuIGE8MHx8YT49dT90P1wiXCI6dm9pZCAwOihuPWZvKG8sYSkpPDU1Mjk2fHxuPjU2MzE5fHxhKzE9PT11fHwoaT1mbyhvLGErMSkpPDU2MzIwfHxpPjU3MzQzP3Q/Y28obyxhKTpuOnQ/bG8obyxhLGErMik6aS01NjMyMCsobi01NTI5Njw8MTApKzY1NTM2fX0scG89e2NvZGVBdDpobyghMSksY2hhckF0OmhvKCEwKX0sdm89Yix5bz1Ybixnbz1vLldlYWtNYXAsbW89dm8oZ28pJiYvbmF0aXZlIGNvZGUvLnRlc3QoeW8oZ28pKSxibz1EdC5leHBvcnRzLF9vPUJ0LHdvPWJvKFwia2V5c1wiKSxPbz1mdW5jdGlvbih0KXtyZXR1cm4gd29bdF18fCh3b1t0XT1fbyh0KSl9LEVvPXt9LFRvPW1vLHhvPW8sa289bSxTbz0kLEFvPWhyLGpvPVV0LFBvPUZ0LElvPU9vLERvPUVvLExvPVwiT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWRcIixDbz14by5UeXBlRXJyb3IsUm89eG8uV2Vha01hcDtpZihUb3x8UG8uc3RhdGUpe3ZhciBNbz1Qby5zdGF0ZXx8KFBvLnN0YXRlPW5ldyBSbyksRm89a28oTW8uZ2V0KSxObz1rbyhNby5oYXMpLHpvPWtvKE1vLnNldCk7S2k9ZnVuY3Rpb24odCxlKXtpZihObyhNbyx0KSl0aHJvdyBuZXcgQ28oTG8pO3JldHVybiBlLmZhY2FkZT10LHpvKE1vLHQsZSksZX0sUWk9ZnVuY3Rpb24odCl7cmV0dXJuIEZvKE1vLHQpfHx7fX0sWmk9ZnVuY3Rpb24odCl7cmV0dXJuIE5vKE1vLHQpfX1lbHNle3ZhciBxbz1JbyhcInN0YXRlXCIpO0RvW3FvXT0hMCxLaT1mdW5jdGlvbih0LGUpe2lmKGpvKHQscW8pKXRocm93IG5ldyBDbyhMbyk7cmV0dXJuIGUuZmFjYWRlPXQsQW8odCxxbyxlKSxlfSxRaT1mdW5jdGlvbih0KXtyZXR1cm4gam8odCxxbyk/dFtxb106e319LFppPWZ1bmN0aW9uKHQpe3JldHVybiBqbyh0LHFvKX19dmFyIFlvPXtzZXQ6S2ksZ2V0OlFpLGhhczpaaSxlbmZvcmNlOmZ1bmN0aW9uKHQpe3JldHVybiBaaSh0KT9RaSh0KTpLaSh0LHt9KX0sZ2V0dGVyRm9yOmZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgcjtpZighU28oZSl8fChyPVFpKGUpKS50eXBlIT09dCl0aHJvdyBDbyhcIkluY29tcGF0aWJsZSByZWNlaXZlciwgXCIrdCtcIiByZXF1aXJlZFwiKTtyZXR1cm4gcn19fSxHbz13LFhvPVV0LFVvPUZ1bmN0aW9uLnByb3RvdHlwZSxXbz1HbyYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixWbz1YbyhVbyxcIm5hbWVcIiksSG89e0VYSVNUUzpWbyxQUk9QRVI6Vm8mJlwic29tZXRoaW5nXCI9PT1mdW5jdGlvbigpe30ubmFtZSxDT05GSUdVUkFCTEU6Vm8mJighR298fEdvJiZXbyhVbyxcIm5hbWVcIikuY29uZmlndXJhYmxlKX0sJG89e30sQm89b24sSm89TWF0aC5tYXgsS289TWF0aC5taW4sUW89ZnVuY3Rpb24odCxlKXt2YXIgcj1Cbyh0KTtyZXR1cm4gcjwwP0pvKHIrZSwwKTpLbyhyLGUpfSxabz1WLHRhPVFvLGVhPWNuLHJhPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLHIsbil7dmFyIGksbz1abyhlKSxhPWVhKG8pLHU9dGEobixhKTtpZih0JiZyIT1yKXtmb3IoO2E+dTspaWYoKGk9b1t1KytdKSE9aSlyZXR1cm4hMH1lbHNlIGZvcig7YT51O3UrKylpZigodHx8dSBpbiBvKSYmb1t1XT09PXIpcmV0dXJuIHR8fHV8fDA7cmV0dXJuIXQmJi0xfX0sbmE9e2luY2x1ZGVzOnJhKCEwKSxpbmRleE9mOnJhKCExKX0saWE9VXQsb2E9VixhYT1uYS5pbmRleE9mLHVhPUVvLHNhPW0oW10ucHVzaCksY2E9ZnVuY3Rpb24odCxlKXt2YXIgcixuPW9hKHQpLGk9MCxvPVtdO2ZvcihyIGluIG4pIWlhKHVhLHIpJiZpYShuLHIpJiZzYShvLHIpO2Zvcig7ZS5sZW5ndGg+aTspaWEobixyPWVbaSsrXSkmJih+YWEobyxyKXx8c2EobyxyKSk7cmV0dXJuIG99LGZhPVtcImNvbnN0cnVjdG9yXCIsXCJoYXNPd25Qcm9wZXJ0eVwiLFwiaXNQcm90b3R5cGVPZlwiLFwicHJvcGVydHlJc0VudW1lcmFibGVcIixcInRvTG9jYWxlU3RyaW5nXCIsXCJ0b1N0cmluZ1wiLFwidmFsdWVPZlwiXSxsYT1jYSxoYT1mYSxwYT1PYmplY3Qua2V5c3x8ZnVuY3Rpb24odCl7cmV0dXJuIGxhKHQsaGEpfSx2YT13LGRhPUhlLHlhPVZlLGdhPVFlLG1hPVYsYmE9cGE7JG8uZj12YSYmIWRhP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzOmZ1bmN0aW9uKHQsZSl7Z2EodCk7Zm9yKHZhciByLG49bWEoZSksaT1iYShlKSxvPWkubGVuZ3RoLGE9MDtvPmE7KXlhLmYodCxyPWlbYSsrXSxuW3JdKTtyZXR1cm4gdH07dmFyIF9hLHdhPXR0KFwiZG9jdW1lbnRcIixcImRvY3VtZW50RWxlbWVudFwiKSxPYT1RZSxFYT0kbyxUYT1mYSx4YT1FbyxrYT13YSxTYT13ZSxBYT1PbyhcIklFX1BST1RPXCIpLGphPWZ1bmN0aW9uKCl7fSxQYT1mdW5jdGlvbih0KXtyZXR1cm5cIjxzY3JpcHQ+XCIrdCtcIjwvXCIrXCJzY3JpcHQ+XCJ9LElhPWZ1bmN0aW9uKHQpe3Qud3JpdGUoUGEoXCJcIikpLHQuY2xvc2UoKTt2YXIgZT10LnBhcmVudFdpbmRvdy5PYmplY3Q7cmV0dXJuIHQ9bnVsbCxlfSxEYT1mdW5jdGlvbigpe3RyeXtfYT1uZXcgQWN0aXZlWE9iamVjdChcImh0bWxmaWxlXCIpfWNhdGNoKHQpe312YXIgdCxlO0RhPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudD9kb2N1bWVudC5kb21haW4mJl9hP0lhKF9hKTooKGU9U2EoXCJpZnJhbWVcIikpLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsa2EuYXBwZW5kQ2hpbGQoZSksZS5zcmM9U3RyaW5nKFwiamF2YXNjcmlwdDpcIiksKHQ9ZS5jb250ZW50V2luZG93LmRvY3VtZW50KS5vcGVuKCksdC53cml0ZShQYShcImRvY3VtZW50LkY9T2JqZWN0XCIpKSx0LmNsb3NlKCksdC5GKTpJYShfYSk7Zm9yKHZhciByPVRhLmxlbmd0aDtyLS07KWRlbGV0ZSBEYS5wcm90b3R5cGVbVGFbcl1dO3JldHVybiBEYSgpfTt4YVtBYV09ITA7dmFyIExhLENhLFJhLE1hPU9iamVjdC5jcmVhdGV8fGZ1bmN0aW9uKHQsZSl7dmFyIHI7cmV0dXJuIG51bGwhPT10PyhqYS5wcm90b3R5cGU9T2EodCkscj1uZXcgamEsamEucHJvdG90eXBlPW51bGwscltBYV09dCk6cj1EYSgpLHZvaWQgMD09PWU/cjpFYS5mKHIsZSl9LEZhPSFhKChmdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPW51bGwsT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyB0KSE9PXQucHJvdG90eXBlfSkpLE5hPW8semE9VXQscWE9YixZYT1ZdCxHYT1GYSxYYT1PbyhcIklFX1BST1RPXCIpLFVhPU5hLk9iamVjdCxXYT1VYS5wcm90b3R5cGUsVmE9R2E/VWEuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7dmFyIGU9WWEodCk7aWYoemEoZSxYYSkpcmV0dXJuIGVbWGFdO3ZhciByPWUuY29uc3RydWN0b3I7cmV0dXJuIHFhKHIpJiZlIGluc3RhbmNlb2Ygcj9yLnByb3RvdHlwZTplIGluc3RhbmNlb2YgVWE/V2E6bnVsbH0sSGE9aHIsJGE9ZnVuY3Rpb24odCxlLHIsbil7biYmbi5lbnVtZXJhYmxlP3RbZV09cjpIYSh0LGUscil9LEJhPWEsSmE9YixLYT1NYSxRYT1WYSxaYT0kYSx0dT1hZShcIml0ZXJhdG9yXCIpLGV1PSExO1tdLmtleXMmJihcIm5leHRcImluKFJhPVtdLmtleXMoKSk/KENhPVFhKFFhKFJhKSkpIT09T2JqZWN0LnByb3RvdHlwZSYmKExhPUNhKTpldT0hMCk7dmFyIHJ1PW51bGw9PUxhfHxCYSgoZnVuY3Rpb24oKXt2YXIgdD17fTtyZXR1cm4gTGFbdHVdLmNhbGwodCkhPT10fSkpO0phKChMYT1ydT97fTpLYShMYSkpW3R1XSl8fFphKExhLHR1LChmdW5jdGlvbigpe3JldHVybiB0aGlzfSkpO3ZhciBudT17SXRlcmF0b3JQcm90b3R5cGU6TGEsQlVHR1lfU0FGQVJJX0lURVJBVE9SUzpldX0saXU9em4sb3U9SW4/e30udG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIltvYmplY3QgXCIraXUodGhpcykrXCJdXCJ9LGF1PUluLHV1PVZlLmYsc3U9aHIsY3U9VXQsZnU9b3UsbHU9YWUoXCJ0b1N0cmluZ1RhZ1wiKSxodT1mdW5jdGlvbih0LGUscixuKXtpZih0KXt2YXIgaT1yP3Q6dC5wcm90b3R5cGU7Y3UoaSxsdSl8fHV1KGksbHUse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTplfSksbiYmIWF1JiZzdShpLFwidG9TdHJpbmdcIixmdSl9fSxwdT17fSx2dT1udS5JdGVyYXRvclByb3RvdHlwZSxkdT1NYSx5dT1JLGd1PWh1LG11PXB1LGJ1PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LF91PW8sd3U9YixPdT1fdS5TdHJpbmcsRXU9X3UuVHlwZUVycm9yLFR1PW0seHU9UWUsa3U9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIHR8fHd1KHQpKXJldHVybiB0O3Rocm93IEV1KFwiQ2FuJ3Qgc2V0IFwiK091KHQpK1wiIGFzIGEgcHJvdG90eXBlXCIpfSxTdT1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fChcIl9fcHJvdG9fX1wiaW57fT9mdW5jdGlvbigpe3ZhciB0LGU9ITEscj17fTt0cnl7KHQ9VHUoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLFwiX19wcm90b19fXCIpLnNldCkpKHIsW10pLGU9ciBpbnN0YW5jZW9mIEFycmF5fWNhdGNoKHQpe31yZXR1cm4gZnVuY3Rpb24ocixuKXtyZXR1cm4geHUociksa3UobiksZT90KHIsbik6ci5fX3Byb3RvX189bixyfX0oKTp2b2lkIDApLEF1PVRyLGp1PVQsUHU9ZnVuY3Rpb24odCxlLHIsbil7dmFyIGk9ZStcIiBJdGVyYXRvclwiO3JldHVybiB0LnByb3RvdHlwZT1kdSh2dSx7bmV4dDp5dSgrIW4scil9KSxndSh0LGksITEsITApLG11W2ldPWJ1LHR9LEl1PVZhLER1PWh1LEx1PSRhLEN1PXB1LFJ1PUhvLlBST1BFUixNdT1udS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTLEZ1PWFlKFwiaXRlcmF0b3JcIiksTnU9XCJrZXlzXCIsenU9XCJ2YWx1ZXNcIixxdT1cImVudHJpZXNcIixZdT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxHdT1mdW5jdGlvbih0LGUscixuLGksbyxhKXtQdShyLGUsbik7dmFyIHUscyxjLGY9ZnVuY3Rpb24odCl7aWYodD09PWkmJmQpcmV0dXJuIGQ7aWYoIU11JiZ0IGluIHApcmV0dXJuIHBbdF07c3dpdGNoKHQpe2Nhc2UgTnU6Y2FzZSB6dTpjYXNlIHF1OnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgcih0aGlzLHQpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHIodGhpcyl9fSxsPWUrXCIgSXRlcmF0b3JcIixoPSExLHA9dC5wcm90b3R5cGUsdj1wW0Z1XXx8cFtcIkBAaXRlcmF0b3JcIl18fGkmJnBbaV0sZD0hTXUmJnZ8fGYoaSkseT1cIkFycmF5XCI9PWUmJnAuZW50cmllc3x8djtpZih5JiYodT1JdSh5LmNhbGwobmV3IHQpKSkhPT1PYmplY3QucHJvdG90eXBlJiZ1Lm5leHQmJihEdSh1LGwsITAsITApLEN1W2xdPVl1KSxSdSYmaT09enUmJnYmJnYubmFtZSE9PXp1JiYoaD0hMCxkPWZ1bmN0aW9uKCl7cmV0dXJuIGp1KHYsdGhpcyl9KSxpKWlmKHM9e3ZhbHVlczpmKHp1KSxrZXlzOm8/ZDpmKE51KSxlbnRyaWVzOmYocXUpfSxhKWZvcihjIGluIHMpKE11fHxofHwhKGMgaW4gcCkpJiZMdShwLGMsc1tjXSk7ZWxzZSBBdSh7dGFyZ2V0OmUscHJvdG86ITAsZm9yY2VkOk11fHxofSxzKTtyZXR1cm4gYSYmcFtGdV0hPT1kJiZMdShwLEZ1LGQse25hbWU6aX0pLEN1W2VdPWQsc30sWHU9cG8uY2hhckF0LFV1PWlvLFd1PVlvLFZ1PUd1LEh1PVwiU3RyaW5nIEl0ZXJhdG9yXCIsJHU9V3Uuc2V0LEJ1PVd1LmdldHRlckZvcihIdSk7VnUoU3RyaW5nLFwiU3RyaW5nXCIsKGZ1bmN0aW9uKHQpeyR1KHRoaXMse3R5cGU6SHUsc3RyaW5nOlV1KHQpLGluZGV4OjB9KX0pLChmdW5jdGlvbigpe3ZhciB0LGU9QnUodGhpcykscj1lLnN0cmluZyxuPWUuaW5kZXg7cmV0dXJuIG4+PXIubGVuZ3RoP3t2YWx1ZTp2b2lkIDAsZG9uZTohMH06KHQ9WHUocixuKSxlLmluZGV4Kz10Lmxlbmd0aCx7dmFsdWU6dCxkb25lOiExfSl9KSk7dmFyIEp1PVQsS3U9UWUsUXU9U3QsWnU9ZnVuY3Rpb24odCxlLHIpe3ZhciBuLGk7S3UodCk7dHJ5e2lmKCEobj1RdSh0LFwicmV0dXJuXCIpKSl7aWYoXCJ0aHJvd1wiPT09ZSl0aHJvdyByO3JldHVybiByfW49SnUobix0KX1jYXRjaCh0KXtpPSEwLG49dH1pZihcInRocm93XCI9PT1lKXRocm93IHI7aWYoaSl0aHJvdyBuO3JldHVybiBLdShuKSxyfSx0cz1RZSxlcz1adSxycz1wdSxucz1hZShcIml0ZXJhdG9yXCIpLGlzPUFycmF5LnByb3RvdHlwZSxvcz1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dCYmKHJzLkFycmF5PT09dHx8aXNbbnNdPT09dCl9LGFzPWdlLHVzPVZlLHNzPUksY3M9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPWFzKGUpO24gaW4gdD91cy5mKHQsbixzcygwLHIpKTp0W25dPXJ9LGZzPXpuLGxzPVN0LGhzPXB1LHBzPWFlKFwiaXRlcmF0b3JcIiksdnM9ZnVuY3Rpb24odCl7aWYobnVsbCE9dClyZXR1cm4gbHModCxwcyl8fGxzKHQsXCJAQGl0ZXJhdG9yXCIpfHxoc1tmcyh0KV19LGRzPVQseXM9eHQsZ3M9UWUsbXM9d3QsYnM9dnMsX3M9by5UeXBlRXJyb3Isd3M9ZnVuY3Rpb24odCxlKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPDI/YnModCk6ZTtpZih5cyhyKSlyZXR1cm4gZ3MoZHMocix0KSk7dGhyb3cgX3MobXModCkrXCIgaXMgbm90IGl0ZXJhYmxlXCIpfSxPcz1XZSxFcz1ULFRzPVl0LHhzPWZ1bmN0aW9uKHQsZSxyLG4pe3RyeXtyZXR1cm4gbj9lKHRzKHIpWzBdLHJbMV0pOmUocil9Y2F0Y2goZSl7ZXModCxcInRocm93XCIsZSl9fSxrcz1vcyxTcz1uaSxBcz1jbixqcz1jcyxQcz13cyxJcz12cyxEcz1vLkFycmF5LExzPWFlKFwiaXRlcmF0b3JcIiksQ3M9ITE7dHJ5e3ZhciBScz0wLE1zPXtuZXh0OmZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6ISFScysrfX0scmV0dXJuOmZ1bmN0aW9uKCl7Q3M9ITB9fTtNc1tMc109ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sQXJyYXkuZnJvbShNcywoZnVuY3Rpb24oKXt0aHJvdyAyfSkpfWNhdGNoKHQpe312YXIgRnM9ZnVuY3Rpb24odCl7dmFyIGU9VHModCkscj1Tcyh0aGlzKSxuPWFyZ3VtZW50cy5sZW5ndGgsaT1uPjE/YXJndW1lbnRzWzFdOnZvaWQgMCxvPXZvaWQgMCE9PWk7byYmKGk9T3MoaSxuPjI/YXJndW1lbnRzWzJdOnZvaWQgMCkpO3ZhciBhLHUscyxjLGYsbCxoPUlzKGUpLHA9MDtpZighaHx8dGhpcz09RHMmJmtzKGgpKWZvcihhPUFzKGUpLHU9cj9uZXcgdGhpcyhhKTpEcyhhKTthPnA7cCsrKWw9bz9pKGVbcF0scCk6ZVtwXSxqcyh1LHAsbCk7ZWxzZSBmb3IoZj0oYz1QcyhlLGgpKS5uZXh0LHU9cj9uZXcgdGhpczpbXTshKHM9RXMoZixjKSkuZG9uZTtwKyspbD1vP3hzKGMsaSxbcy52YWx1ZSxwXSwhMCk6cy52YWx1ZSxqcyh1LHAsbCk7cmV0dXJuIHUubGVuZ3RoPXAsdX0sTnM9ZnVuY3Rpb24odCxlKXtpZighZSYmIUNzKXJldHVybiExO3ZhciByPSExO3RyeXt2YXIgbj17fTtuW0xzXT1mdW5jdGlvbigpe3JldHVybntuZXh0OmZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6cj0hMH19fX0sdChuKX1jYXRjaCh0KXt9cmV0dXJuIHJ9O1RyKHt0YXJnZXQ6XCJBcnJheVwiLHN0YXQ6ITAsZm9yY2VkOiFOcygoZnVuY3Rpb24odCl7QXJyYXkuZnJvbSh0KX0pKX0se2Zyb206RnN9KTt2YXIgenM9Qi5BcnJheS5mcm9tLHFzPXpzLFlzPVYsR3M9cHUsWHM9WW87VmUuZjt2YXIgVXM9R3UsV3M9XCJBcnJheSBJdGVyYXRvclwiLFZzPVhzLnNldCxIcz1Ycy5nZXR0ZXJGb3IoV3MpO1VzKEFycmF5LFwiQXJyYXlcIiwoZnVuY3Rpb24odCxlKXtWcyh0aGlzLHt0eXBlOldzLHRhcmdldDpZcyh0KSxpbmRleDowLGtpbmQ6ZX0pfSksKGZ1bmN0aW9uKCl7dmFyIHQ9SHModGhpcyksZT10LnRhcmdldCxyPXQua2luZCxuPXQuaW5kZXgrKztyZXR1cm4hZXx8bj49ZS5sZW5ndGg/KHQudGFyZ2V0PXZvaWQgMCx7dmFsdWU6dm9pZCAwLGRvbmU6ITB9KTpcImtleXNcIj09cj97dmFsdWU6bixkb25lOiExfTpcInZhbHVlc1wiPT1yP3t2YWx1ZTplW25dLGRvbmU6ITF9Ont2YWx1ZTpbbixlW25dXSxkb25lOiExfX0pLFwidmFsdWVzXCIpLEdzLkFyZ3VtZW50cz1Hcy5BcnJheTt2YXIgJHM9dnMsQnM9e0NTU1J1bGVMaXN0OjAsQ1NTU3R5bGVEZWNsYXJhdGlvbjowLENTU1ZhbHVlTGlzdDowLENsaWVudFJlY3RMaXN0OjAsRE9NUmVjdExpc3Q6MCxET01TdHJpbmdMaXN0OjAsRE9NVG9rZW5MaXN0OjEsRGF0YVRyYW5zZmVySXRlbUxpc3Q6MCxGaWxlTGlzdDowLEhUTUxBbGxDb2xsZWN0aW9uOjAsSFRNTENvbGxlY3Rpb246MCxIVE1MRm9ybUVsZW1lbnQ6MCxIVE1MU2VsZWN0RWxlbWVudDowLE1lZGlhTGlzdDowLE1pbWVUeXBlQXJyYXk6MCxOYW1lZE5vZGVNYXA6MCxOb2RlTGlzdDoxLFBhaW50UmVxdWVzdExpc3Q6MCxQbHVnaW46MCxQbHVnaW5BcnJheTowLFNWR0xlbmd0aExpc3Q6MCxTVkdOdW1iZXJMaXN0OjAsU1ZHUGF0aFNlZ0xpc3Q6MCxTVkdQb2ludExpc3Q6MCxTVkdTdHJpbmdMaXN0OjAsU1ZHVHJhbnNmb3JtTGlzdDowLFNvdXJjZUJ1ZmZlckxpc3Q6MCxTdHlsZVNoZWV0TGlzdDowLFRleHRUcmFja0N1ZUxpc3Q6MCxUZXh0VHJhY2tMaXN0OjAsVG91Y2hMaXN0OjB9LEpzPW8sS3M9em4sUXM9aHIsWnM9cHUsdGM9YWUoXCJ0b1N0cmluZ1RhZ1wiKTtmb3IodmFyIGVjIGluIEJzKXt2YXIgcmM9SnNbZWNdLG5jPXJjJiZyYy5wcm90b3R5cGU7bmMmJktzKG5jKSE9PXRjJiZRcyhuYyx0YyxlYyksWnNbZWNdPVpzLkFycmF5fXZhciBpYz0kcyxvYz17fSxhYz1jYSx1Yz1mYS5jb25jYXQoXCJsZW5ndGhcIixcInByb3RvdHlwZVwiKTtvYy5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzfHxmdW5jdGlvbih0KXtyZXR1cm4gYWModCx1Yyl9O3ZhciBzYz17fSxjYz1RbyxmYz1jbixsYz1jcyxoYz1vLkFycmF5LHBjPU1hdGgubWF4LHZjPWZ1bmN0aW9uKHQsZSxyKXtmb3IodmFyIG49ZmModCksaT1jYyhlLG4pLG89Y2Modm9pZCAwPT09cj9uOnIsbiksYT1oYyhwYyhvLWksMCkpLHU9MDtpPG87aSsrLHUrKylsYyhhLHUsdFtpXSk7cmV0dXJuIGEubGVuZ3RoPXUsYX0sZGM9Uix5Yz1WLGdjPW9jLmYsbWM9dmMsYmM9XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyYmd2luZG93JiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz9PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpOltdO3NjLmY9ZnVuY3Rpb24odCl7cmV0dXJuIGJjJiZcIldpbmRvd1wiPT1kYyh0KT9mdW5jdGlvbih0KXt0cnl7cmV0dXJuIGdjKHQpfWNhdGNoKHQpe3JldHVybiBtYyhiYyl9fSh0KTpnYyh5Yyh0KSl9O3ZhciBfYz17fTtfYy5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7dmFyIHdjPXt9LE9jPWFlO3djLmY9T2M7dmFyIEVjPUIsVGM9VXQseGM9d2Msa2M9VmUuZixTYz1mdW5jdGlvbih0KXt2YXIgZT1FYy5TeW1ib2x8fChFYy5TeW1ib2w9e30pO1RjKGUsdCl8fGtjKGUsdCx7dmFsdWU6eGMuZih0KX0pfSxBYz1UcixqYz1vLFBjPXR0LEljPWgsRGM9VCxMYz1tLENjPXcsUmM9aHQsTWM9YSxGYz1VdCxOYz1qbix6Yz1iLHFjPSQsWWM9ZXQsR2M9YnQsWGM9UWUsVWM9WXQsV2M9VixWYz1nZSxIYz1pbywkYz1JLEJjPU1hLEpjPXBhLEtjPW9jLFFjPXNjLFpjPV9jLHRmPV8sZWY9VmUscmY9JG8sbmY9eCxvZj1ScixhZj0kYSx1Zj1EdC5leHBvcnRzLHNmPUVvLGNmPUJ0LGZmPWFlLGxmPXdjLGhmPVNjLHBmPWh1LHZmPVlvLGRmPWJpLmZvckVhY2gseWY9T28oXCJoaWRkZW5cIiksZ2Y9XCJTeW1ib2xcIixtZj1mZihcInRvUHJpbWl0aXZlXCIpLGJmPXZmLnNldCxfZj12Zi5nZXR0ZXJGb3IoZ2YpLHdmPU9iamVjdC5wcm90b3R5cGUsT2Y9amMuU3ltYm9sLEVmPU9mJiZPZi5wcm90b3R5cGUsVGY9amMuVHlwZUVycm9yLHhmPWpjLlFPYmplY3Qsa2Y9UGMoXCJKU09OXCIsXCJzdHJpbmdpZnlcIiksU2Y9dGYuZixBZj1lZi5mLGpmPVFjLmYsUGY9bmYuZixJZj1MYyhbXS5wdXNoKSxEZj11ZihcInN5bWJvbHNcIiksTGY9dWYoXCJvcC1zeW1ib2xzXCIpLENmPXVmKFwic3RyaW5nLXRvLXN5bWJvbC1yZWdpc3RyeVwiKSxSZj11ZihcInN5bWJvbC10by1zdHJpbmctcmVnaXN0cnlcIiksTWY9dWYoXCJ3a3NcIiksRmY9IXhmfHwheGYucHJvdG90eXBlfHwheGYucHJvdG90eXBlLmZpbmRDaGlsZCxOZj1DYyYmTWMoKGZ1bmN0aW9uKCl7cmV0dXJuIDchPUJjKEFmKHt9LFwiYVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQWYodGhpcyxcImFcIix7dmFsdWU6N30pLmF9fSkpLmF9KSk/ZnVuY3Rpb24odCxlLHIpe3ZhciBuPVNmKHdmLGUpO24mJmRlbGV0ZSB3ZltlXSxBZih0LGUsciksbiYmdCE9PXdmJiZBZih3ZixlLG4pfTpBZix6Zj1mdW5jdGlvbih0LGUpe3ZhciByPURmW3RdPUJjKEVmKTtyZXR1cm4gYmYocix7dHlwZTpnZix0YWc6dCxkZXNjcmlwdGlvbjplfSksQ2N8fChyLmRlc2NyaXB0aW9uPWUpLHJ9LHFmPWZ1bmN0aW9uKHQsZSxyKXt0PT09d2YmJnFmKExmLGUsciksWGModCk7dmFyIG49VmMoZSk7cmV0dXJuIFhjKHIpLEZjKERmLG4pPyhyLmVudW1lcmFibGU/KEZjKHQseWYpJiZ0W3lmXVtuXSYmKHRbeWZdW25dPSExKSxyPUJjKHIse2VudW1lcmFibGU6JGMoMCwhMSl9KSk6KEZjKHQseWYpfHxBZih0LHlmLCRjKDEse30pKSx0W3lmXVtuXT0hMCksTmYodCxuLHIpKTpBZih0LG4scil9LFlmPWZ1bmN0aW9uKHQsZSl7WGModCk7dmFyIHI9V2MoZSksbj1KYyhyKS5jb25jYXQoV2YocikpO3JldHVybiBkZihuLChmdW5jdGlvbihlKXtDYyYmIURjKEdmLHIsZSl8fHFmKHQsZSxyW2VdKX0pKSx0fSxHZj1mdW5jdGlvbih0KXt2YXIgZT1WYyh0KSxyPURjKFBmLHRoaXMsZSk7cmV0dXJuISh0aGlzPT09d2YmJkZjKERmLGUpJiYhRmMoTGYsZSkpJiYoIShyfHwhRmModGhpcyxlKXx8IUZjKERmLGUpfHxGYyh0aGlzLHlmKSYmdGhpc1t5Zl1bZV0pfHxyKX0sWGY9ZnVuY3Rpb24odCxlKXt2YXIgcj1XYyh0KSxuPVZjKGUpO2lmKHIhPT13Znx8IUZjKERmLG4pfHxGYyhMZixuKSl7dmFyIGk9U2YocixuKTtyZXR1cm4haXx8IUZjKERmLG4pfHxGYyhyLHlmKSYmclt5Zl1bbl18fChpLmVudW1lcmFibGU9ITApLGl9fSxVZj1mdW5jdGlvbih0KXt2YXIgZT1qZihXYyh0KSkscj1bXTtyZXR1cm4gZGYoZSwoZnVuY3Rpb24odCl7RmMoRGYsdCl8fEZjKHNmLHQpfHxJZihyLHQpfSkpLHJ9LFdmPWZ1bmN0aW9uKHQpe3ZhciBlPXQ9PT13ZixyPWpmKGU/TGY6V2ModCkpLG49W107cmV0dXJuIGRmKHIsKGZ1bmN0aW9uKHQpeyFGYyhEZix0KXx8ZSYmIUZjKHdmLHQpfHxJZihuLERmW3RdKX0pKSxufTtpZihSY3x8KE9mPWZ1bmN0aW9uKCl7aWYoWWMoRWYsdGhpcykpdGhyb3cgVGYoXCJTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3JcIik7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP0hjKGFyZ3VtZW50c1swXSk6dm9pZCAwLGU9Y2YodCkscj1mdW5jdGlvbih0KXt0aGlzPT09d2YmJkRjKHIsTGYsdCksRmModGhpcyx5ZikmJkZjKHRoaXNbeWZdLGUpJiYodGhpc1t5Zl1bZV09ITEpLE5mKHRoaXMsZSwkYygxLHQpKX07cmV0dXJuIENjJiZGZiYmTmYod2YsZSx7Y29uZmlndXJhYmxlOiEwLHNldDpyfSksemYoZSx0KX0sYWYoRWY9T2YucHJvdG90eXBlLFwidG9TdHJpbmdcIiwoZnVuY3Rpb24oKXtyZXR1cm4gX2YodGhpcykudGFnfSkpLGFmKE9mLFwid2l0aG91dFNldHRlclwiLChmdW5jdGlvbih0KXtyZXR1cm4gemYoY2YodCksdCl9KSksbmYuZj1HZixlZi5mPXFmLHJmLmY9WWYsdGYuZj1YZixLYy5mPVFjLmY9VWYsWmMuZj1XZixsZi5mPWZ1bmN0aW9uKHQpe3JldHVybiB6ZihmZih0KSx0KX0sQ2MmJkFmKEVmLFwiZGVzY3JpcHRpb25cIix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBfZih0aGlzKS5kZXNjcmlwdGlvbn19KSksQWMoe2dsb2JhbDohMCx3cmFwOiEwLGZvcmNlZDohUmMsc2hhbTohUmN9LHtTeW1ib2w6T2Z9KSxkZihKYyhNZiksKGZ1bmN0aW9uKHQpe2hmKHQpfSkpLEFjKHt0YXJnZXQ6Z2Ysc3RhdDohMCxmb3JjZWQ6IVJjfSx7Zm9yOmZ1bmN0aW9uKHQpe3ZhciBlPUhjKHQpO2lmKEZjKENmLGUpKXJldHVybiBDZltlXTt2YXIgcj1PZihlKTtyZXR1cm4gQ2ZbZV09cixSZltyXT1lLHJ9LGtleUZvcjpmdW5jdGlvbih0KXtpZighR2ModCkpdGhyb3cgVGYodCtcIiBpcyBub3QgYSBzeW1ib2xcIik7aWYoRmMoUmYsdCkpcmV0dXJuIFJmW3RdfSx1c2VTZXR0ZXI6ZnVuY3Rpb24oKXtGZj0hMH0sdXNlU2ltcGxlOmZ1bmN0aW9uKCl7RmY9ITF9fSksQWMoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOiFSYyxzaGFtOiFDY30se2NyZWF0ZTpmdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lP0JjKHQpOllmKEJjKHQpLGUpfSxkZWZpbmVQcm9wZXJ0eTpxZixkZWZpbmVQcm9wZXJ0aWVzOllmLGdldE93blByb3BlcnR5RGVzY3JpcHRvcjpYZn0pLEFjKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDohUmN9LHtnZXRPd25Qcm9wZXJ0eU5hbWVzOlVmLGdldE93blByb3BlcnR5U3ltYm9sczpXZn0pLEFjKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDpNYygoZnVuY3Rpb24oKXtaYy5mKDEpfSkpfSx7Z2V0T3duUHJvcGVydHlTeW1ib2xzOmZ1bmN0aW9uKHQpe3JldHVybiBaYy5mKFVjKHQpKX19KSxrZil7dmFyIFZmPSFSY3x8TWMoKGZ1bmN0aW9uKCl7dmFyIHQ9T2YoKTtyZXR1cm5cIltudWxsXVwiIT1rZihbdF0pfHxcInt9XCIhPWtmKHthOnR9KXx8XCJ7fVwiIT1rZihPYmplY3QodCkpfSkpO0FjKHt0YXJnZXQ6XCJKU09OXCIsc3RhdDohMCxmb3JjZWQ6VmZ9LHtzdHJpbmdpZnk6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPW9mKGFyZ3VtZW50cyksaT1lO2lmKChxYyhlKXx8dm9pZCAwIT09dCkmJiFHYyh0KSlyZXR1cm4gTmMoZSl8fChlPWZ1bmN0aW9uKHQsZSl7aWYoemMoaSkmJihlPURjKGksdGhpcyx0LGUpKSwhR2MoZSkpcmV0dXJuIGV9KSxuWzFdPWUsSWMoa2YsbnVsbCxuKX19KX1pZighRWZbbWZdKXt2YXIgSGY9RWYudmFsdWVPZjthZihFZixtZiwoZnVuY3Rpb24odCl7cmV0dXJuIERjKEhmLHRoaXMpfSkpfXBmKE9mLGdmKSxzZlt5Zl09ITA7dmFyICRmPUIuT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxCZj17ZXhwb3J0czp7fX0sSmY9VHIsS2Y9YSxRZj1WLFpmPV8uZix0bD13LGVsPUtmKChmdW5jdGlvbigpe1pmKDEpfSkpO0pmKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDohdGx8fGVsLHNoYW06IXRsfSx7Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIFpmKFFmKHQpLGUpfX0pO3ZhciBybD1CLk9iamVjdCxubD1CZi5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHJsLmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGUpfTtybC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iuc2hhbSYmKG5sLnNoYW09ITApO3ZhciBpbD1CZi5leHBvcnRzLG9sPXR0LGFsPW9jLHVsPV9jLHNsPVFlLGNsPW0oW10uY29uY2F0KSxmbD1vbChcIlJlZmxlY3RcIixcIm93bktleXNcIil8fGZ1bmN0aW9uKHQpe3ZhciBlPWFsLmYoc2wodCkpLHI9dWwuZjtyZXR1cm4gcj9jbChlLHIodCkpOmV9LGxsPWZsLGhsPVYscGw9Xyx2bD1jcztUcih7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxzaGFtOiF3fSx7Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczpmdW5jdGlvbih0KXtmb3IodmFyIGUscixuPWhsKHQpLGk9cGwuZixvPWxsKG4pLGE9e30sdT0wO28ubGVuZ3RoPnU7KXZvaWQgMCE9PShyPWkobixlPW9bdSsrXSkpJiZ2bChhLGUscik7cmV0dXJuIGF9fSk7dmFyIGRsPUIuT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMseWw9e2V4cG9ydHM6e319LGdsPVRyLG1sPXcsYmw9JG8uZjtnbCh7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxmb3JjZWQ6T2JqZWN0LmRlZmluZVByb3BlcnRpZXMhPT1ibCxzaGFtOiFtbH0se2RlZmluZVByb3BlcnRpZXM6Ymx9KTt2YXIgX2w9Qi5PYmplY3Qsd2w9eWwuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybiBfbC5kZWZpbmVQcm9wZXJ0aWVzKHQsZSl9O19sLmRlZmluZVByb3BlcnRpZXMuc2hhbSYmKHdsLnNoYW09ITApO3ZhciBPbD15bC5leHBvcnRzLEVsPVByO1RyKHt0YXJnZXQ6XCJBcnJheVwiLHN0YXQ6ITB9LHtpc0FycmF5OmpufSk7dmFyIFRsPUIuQXJyYXkuaXNBcnJheSx4bD1UbDt2YXIga2w9VHIsU2w9byxBbD1hLGpsPWpuLFBsPSQsSWw9WXQsRGw9Y24sTGw9Y3MsQ2w9bGksUmw9RWksTWw9Y3QsRmw9YWUoXCJpc0NvbmNhdFNwcmVhZGFibGVcIiksTmw9OTAwNzE5OTI1NDc0MDk5MSx6bD1cIk1heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZFwiLHFsPVNsLlR5cGVFcnJvcixZbD1NbD49NTF8fCFBbCgoZnVuY3Rpb24oKXt2YXIgdD1bXTtyZXR1cm4gdFtGbF09ITEsdC5jb25jYXQoKVswXSE9PXR9KSksR2w9UmwoXCJjb25jYXRcIiksWGw9ZnVuY3Rpb24odCl7aWYoIVBsKHQpKXJldHVybiExO3ZhciBlPXRbRmxdO3JldHVybiB2b2lkIDAhPT1lPyEhZTpqbCh0KX07a2woe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOiFZbHx8IUdsfSx7Y29uY2F0OmZ1bmN0aW9uKHQpe3ZhciBlLHIsbixpLG8sYT1JbCh0aGlzKSx1PUNsKGEsMCkscz0wO2ZvcihlPS0xLG49YXJndW1lbnRzLmxlbmd0aDtlPG47ZSsrKWlmKFhsKG89LTE9PT1lP2E6YXJndW1lbnRzW2VdKSl7aWYocysoaT1EbChvKSk+TmwpdGhyb3cgcWwoemwpO2ZvcihyPTA7cjxpO3IrKyxzKyspciBpbiBvJiZMbCh1LHMsb1tyXSl9ZWxzZXtpZihzPj1ObCl0aHJvdyBxbCh6bCk7TGwodSxzKyssbyl9cmV0dXJuIHUubGVuZ3RoPXMsdX19KSxTYyhcImFzeW5jSXRlcmF0b3JcIiksU2MoXCJoYXNJbnN0YW5jZVwiKSxTYyhcImlzQ29uY2F0U3ByZWFkYWJsZVwiKSxTYyhcIml0ZXJhdG9yXCIpLFNjKFwibWF0Y2hcIiksU2MoXCJtYXRjaEFsbFwiKSxTYyhcInJlcGxhY2VcIiksU2MoXCJzZWFyY2hcIiksU2MoXCJzcGVjaWVzXCIpLFNjKFwic3BsaXRcIiksU2MoXCJ0b1ByaW1pdGl2ZVwiKSxTYyhcInRvU3RyaW5nVGFnXCIpLFNjKFwidW5zY29wYWJsZXNcIiksaHUoby5KU09OLFwiSlNPTlwiLCEwKTt2YXIgVWw9Qi5TeW1ib2wsV2w9VWw7U2MoXCJhc3luY0Rpc3Bvc2VcIiksU2MoXCJkaXNwb3NlXCIpLFNjKFwibWF0Y2hlclwiKSxTYyhcIm1ldGFkYXRhXCIpLFNjKFwib2JzZXJ2YWJsZVwiKSxTYyhcInBhdHRlcm5NYXRjaFwiKSxTYyhcInJlcGxhY2VBbGxcIik7dmFyIFZsPVdsO3ZhciBIbD1UciwkbD1vLEJsPWpuLEpsPW5pLEtsPSQsUWw9UW8sWmw9Y24sdGg9VixlaD1jcyxyaD1hZSxuaD1ScixpaD1FaShcInNsaWNlXCIpLG9oPXJoKFwic3BlY2llc1wiKSxhaD0kbC5BcnJheSx1aD1NYXRoLm1heDtIbCh7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IWlofSx7c2xpY2U6ZnVuY3Rpb24odCxlKXt2YXIgcixuLGksbz10aCh0aGlzKSxhPVpsKG8pLHU9UWwodCxhKSxzPVFsKHZvaWQgMD09PWU/YTplLGEpO2lmKEJsKG8pJiYocj1vLmNvbnN0cnVjdG9yLChKbChyKSYmKHI9PT1haHx8Qmwoci5wcm90b3R5cGUpKXx8S2wocikmJm51bGw9PT0ocj1yW29oXSkpJiYocj12b2lkIDApLHI9PT1haHx8dm9pZCAwPT09cikpcmV0dXJuIG5oKG8sdSxzKTtmb3Iobj1uZXcodm9pZCAwPT09cj9haDpyKSh1aChzLXUsMCkpLGk9MDt1PHM7dSsrLGkrKyl1IGluIG8mJmVoKG4saSxvW3VdKTtyZXR1cm4gbi5sZW5ndGg9aSxufX0pO3ZhciBzaD1KcihcIkFycmF5XCIpLnNsaWNlLGNoPWV0LGZoPXNoLGxoPUFycmF5LnByb3RvdHlwZSxoaD1mdW5jdGlvbih0KXt2YXIgZT10LnNsaWNlO3JldHVybiB0PT09bGh8fGNoKGxoLHQpJiZlPT09bGguc2xpY2U/Zmg6ZX0scGg9aGgsdmg9enM7ZnVuY3Rpb24gZGgodCxlKXsobnVsbD09ZXx8ZT50Lmxlbmd0aCkmJihlPXQubGVuZ3RoKTtmb3IodmFyIHI9MCxuPW5ldyBBcnJheShlKTtyPGU7cisrKW5bcl09dFtyXTtyZXR1cm4gbn1mdW5jdGlvbiB5aCh0LGUpe3ZhciByO2lmKHQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXJldHVybiBkaCh0LGUpO3ZhciBuPXBoKHI9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKS5jYWxsKHIsOCwtMSk7cmV0dXJuXCJPYmplY3RcIj09PW4mJnQuY29uc3RydWN0b3ImJihuPXQuY29uc3RydWN0b3IubmFtZSksXCJNYXBcIj09PW58fFwiU2V0XCI9PT1uP3ZoKHQpOlwiQXJndW1lbnRzXCI9PT1ufHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKT9kaCh0LGUpOnZvaWQgMH19ZnVuY3Rpb24gZ2godCxlKXtyZXR1cm4gZnVuY3Rpb24odCl7aWYoeGwodCkpcmV0dXJuIHR9KHQpfHxmdW5jdGlvbih0LGUpe3ZhciByPW51bGw9PXQ/bnVsbDp2b2lkIDAhPT1WbCYmaWModCl8fHRbXCJAQGl0ZXJhdG9yXCJdO2lmKG51bGwhPXIpe3ZhciBuLGksbz1bXSxhPSEwLHU9ITE7dHJ5e2ZvcihyPXIuY2FsbCh0KTshKGE9KG49ci5uZXh0KCkpLmRvbmUpJiYoby5wdXNoKG4udmFsdWUpLCFlfHxvLmxlbmd0aCE9PWUpO2E9ITApO31jYXRjaCh0KXt1PSEwLGk9dH1maW5hbGx5e3RyeXthfHxudWxsPT1yLnJldHVybnx8ci5yZXR1cm4oKX1maW5hbGx5e2lmKHUpdGhyb3cgaX19cmV0dXJuIG99fSh0LGUpfHx5aCh0LGUpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCl9dmFyIG1oPXdjLmYoXCJpdGVyYXRvclwiKSxiaD1taDtmdW5jdGlvbiBfaCh0KXtyZXR1cm4gX2g9XCJmdW5jdGlvblwiPT10eXBlb2YgVmwmJlwic3ltYm9sXCI9PXR5cGVvZiBiaD9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBWbCYmdC5jb25zdHJ1Y3Rvcj09PVZsJiZ0IT09VmwucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9LF9oKHQpfWZ1bmN0aW9uIHdoKHQpe3JldHVybiBmdW5jdGlvbih0KXtpZih4bCh0KSlyZXR1cm4gZGgodCl9KHQpfHxmdW5jdGlvbih0KXtpZih2b2lkIDAhPT1WbCYmbnVsbCE9aWModCl8fG51bGwhPXRbXCJAQGl0ZXJhdG9yXCJdKXJldHVybiB2aCh0KX0odCl8fHloKHQpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfSgpfXZhciBPaD1VbCxFaD1KcihcIkFycmF5XCIpLmNvbmNhdCxUaD1ldCx4aD1FaCxraD1BcnJheS5wcm90b3R5cGUsU2g9ZnVuY3Rpb24odCl7dmFyIGU9dC5jb25jYXQ7cmV0dXJuIHQ9PT1raHx8VGgoa2gsdCkmJmU9PT1raC5jb25jYXQ/eGg6ZX0sQWg9aGg7VHIoe3RhcmdldDpcIlJlZmxlY3RcIixzdGF0OiEwfSx7b3duS2V5czpmbH0pO3ZhciBqaD1CLlJlZmxlY3Qub3duS2V5cyxQaD1UbCxJaD1ZdCxEaD1wYTtUcih7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxmb3JjZWQ6YSgoZnVuY3Rpb24oKXtEaCgxKX0pKX0se2tleXM6ZnVuY3Rpb24odCl7cmV0dXJuIERoKEloKHQpKX19KTt2YXIgTGg9Qi5PYmplY3Qua2V5cyxDaD1UcixSaD1tLE1oPW8uRGF0ZSxGaD1SaChNaC5wcm90b3R5cGUuZ2V0VGltZSk7Q2goe3RhcmdldDpcIkRhdGVcIixzdGF0OiEwfSx7bm93OmZ1bmN0aW9uKCl7cmV0dXJuIEZoKG5ldyBNaCl9fSksQi5EYXRlLm5vdzt2YXIgTmg9YmkuZm9yRWFjaCx6aD1tbihcImZvckVhY2hcIik/W10uZm9yRWFjaDpmdW5jdGlvbih0KXtyZXR1cm4gTmgodGhpcyx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX07VHIoe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOltdLmZvckVhY2ghPXpofSx7Zm9yRWFjaDp6aH0pO3ZhciBxaD1KcihcIkFycmF5XCIpLmZvckVhY2gsWWg9em4sR2g9VXQsWGg9ZXQsVWg9cWgsV2g9QXJyYXkucHJvdG90eXBlLFZoPXtET01Ub2tlbkxpc3Q6ITAsTm9kZUxpc3Q6ITB9LEhoPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZm9yRWFjaDtyZXR1cm4gdD09PVdofHxYaChXaCx0KSYmZT09PVdoLmZvckVhY2h8fEdoKFZoLFloKHQpKT9VaDplfSwkaD1UcixCaD1qbixKaD1tKFtdLnJldmVyc2UpLEtoPVsxLDJdOyRoKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDpTdHJpbmcoS2gpPT09U3RyaW5nKEtoLnJldmVyc2UoKSl9LHtyZXZlcnNlOmZ1bmN0aW9uKCl7cmV0dXJuIEJoKHRoaXMpJiYodGhpcy5sZW5ndGg9dGhpcy5sZW5ndGgpLEpoKHRoaXMpfX0pO3ZhciBRaD1KcihcIkFycmF5XCIpLnJldmVyc2UsWmg9ZXQsdHA9UWgsZXA9QXJyYXkucHJvdG90eXBlLHJwPWZ1bmN0aW9uKHQpe3ZhciBlPXQucmV2ZXJzZTtyZXR1cm4gdD09PWVwfHxaaChlcCx0KSYmZT09PWVwLnJldmVyc2U/dHA6ZX0sbnA9VHIsaXA9byxvcD1RbyxhcD1vbix1cD1jbixzcD1ZdCxjcD1saSxmcD1jcyxscD1FaShcInNwbGljZVwiKSxocD1pcC5UeXBlRXJyb3IscHA9TWF0aC5tYXgsdnA9TWF0aC5taW4sZHA9OTAwNzE5OTI1NDc0MDk5MSx5cD1cIk1heGltdW0gYWxsb3dlZCBsZW5ndGggZXhjZWVkZWRcIjtucCh7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IWxwfSx7c3BsaWNlOmZ1bmN0aW9uKHQsZSl7dmFyIHIsbixpLG8sYSx1LHM9c3AodGhpcyksYz11cChzKSxmPW9wKHQsYyksbD1hcmd1bWVudHMubGVuZ3RoO2lmKDA9PT1sP3I9bj0wOjE9PT1sPyhyPTAsbj1jLWYpOihyPWwtMixuPXZwKHBwKGFwKGUpLDApLGMtZikpLGMrci1uPmRwKXRocm93IGhwKHlwKTtmb3IoaT1jcChzLG4pLG89MDtvPG47bysrKShhPWYrbylpbiBzJiZmcChpLG8sc1thXSk7aWYoaS5sZW5ndGg9bixyPG4pe2ZvcihvPWY7bzxjLW47bysrKXU9bytyLChhPW8rbilpbiBzP3NbdV09c1thXTpkZWxldGUgc1t1XTtmb3Iobz1jO28+Yy1uK3I7by0tKWRlbGV0ZSBzW28tMV19ZWxzZSBpZihyPm4pZm9yKG89Yy1uO28+ZjtvLS0pdT1vK3ItMSwoYT1vK24tMSlpbiBzP3NbdV09c1thXTpkZWxldGUgc1t1XTtmb3Iobz0wO288cjtvKyspc1tvK2ZdPWFyZ3VtZW50c1tvKzJdO3JldHVybiBzLmxlbmd0aD1jLW4rcixpfX0pO3ZhciBncD1KcihcIkFycmF5XCIpLnNwbGljZSxtcD1ldCxicD1ncCxfcD1BcnJheS5wcm90b3R5cGUsd3A9ZnVuY3Rpb24odCl7dmFyIGU9dC5zcGxpY2U7cmV0dXJuIHQ9PT1fcHx8bXAoX3AsdCkmJmU9PT1fcC5zcGxpY2U/YnA6ZX0sT3A9dyxFcD1tLFRwPVQseHA9YSxrcD1wYSxTcD1fYyxBcD14LGpwPVl0LFBwPVksSXA9T2JqZWN0LmFzc2lnbixEcD1PYmplY3QuZGVmaW5lUHJvcGVydHksTHA9RXAoW10uY29uY2F0KSxDcD0hSXB8fHhwKChmdW5jdGlvbigpe2lmKE9wJiYxIT09SXAoe2I6MX0sSXAoRHAoe30sXCJhXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7RHAodGhpcyxcImJcIix7dmFsdWU6MyxlbnVtZXJhYmxlOiExfSl9fSkse2I6Mn0pKS5iKXJldHVybiEwO3ZhciB0PXt9LGU9e30scj1TeW1ib2woKSxuPVwiYWJjZGVmZ2hpamtsbW5vcHFyc3RcIjtyZXR1cm4gdFtyXT03LG4uc3BsaXQoXCJcIikuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZVt0XT10fSkpLDchPUlwKHt9LHQpW3JdfHxrcChJcCh7fSxlKSkuam9pbihcIlwiKSE9bn0pKT9mdW5jdGlvbih0LGUpe2Zvcih2YXIgcj1qcCh0KSxuPWFyZ3VtZW50cy5sZW5ndGgsaT0xLG89U3AuZixhPUFwLmY7bj5pOylmb3IodmFyIHUscz1QcChhcmd1bWVudHNbaSsrXSksYz1vP0xwKGtwKHMpLG8ocykpOmtwKHMpLGY9Yy5sZW5ndGgsbD0wO2Y+bDspdT1jW2wrK10sT3AmJiFUcChhLHMsdSl8fChyW3VdPXNbdV0pO3JldHVybiByfTpJcCxScD1DcDtUcih7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxmb3JjZWQ6T2JqZWN0LmFzc2lnbiE9PVJwfSx7YXNzaWduOlJwfSk7dmFyIE1wPUIuT2JqZWN0LmFzc2lnbixGcD1uYS5pbmNsdWRlcztUcih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMH0se2luY2x1ZGVzOmZ1bmN0aW9uKHQpe3JldHVybiBGcCh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pLEpyKFwiQXJyYXlcIikuaW5jbHVkZXM7dmFyIE5wPSQsenA9UixxcD1hZShcIm1hdGNoXCIpLFlwPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBOcCh0KSYmKHZvaWQgMCE9PShlPXRbcXBdKT8hIWU6XCJSZWdFeHBcIj09enAodCkpfSxHcD1vLlR5cGVFcnJvcixYcD1hZShcIm1hdGNoXCIpLFVwPVRyLFdwPWZ1bmN0aW9uKHQpe2lmKFlwKHQpKXRocm93IEdwKFwiVGhlIG1ldGhvZCBkb2Vzbid0IGFjY2VwdCByZWd1bGFyIGV4cHJlc3Npb25zXCIpO3JldHVybiB0fSxWcD1YLEhwPWlvLCRwPWZ1bmN0aW9uKHQpe3ZhciBlPS8uLzt0cnl7XCIvLi9cIlt0XShlKX1jYXRjaChyKXt0cnl7cmV0dXJuIGVbWHBdPSExLFwiLy4vXCJbdF0oZSl9Y2F0Y2godCl7fX1yZXR1cm4hMX0sQnA9bShcIlwiLmluZGV4T2YpO1VwKHt0YXJnZXQ6XCJTdHJpbmdcIixwcm90bzohMCxmb3JjZWQ6ISRwKFwiaW5jbHVkZXNcIil9LHtpbmNsdWRlczpmdW5jdGlvbih0KXtyZXR1cm4hIX5CcChIcChWcCh0aGlzKSksSHAoV3AodCkpLGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19KSxKcihcIlN0cmluZ1wiKS5pbmNsdWRlczt2YXIgSnA9WXQsS3A9VmEsUXA9RmE7VHIoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOmEoKGZ1bmN0aW9uKCl7S3AoMSl9KSksc2hhbTohUXB9LHtnZXRQcm90b3R5cGVPZjpmdW5jdGlvbih0KXtyZXR1cm4gS3AoSnAodCkpfX0pO3ZhciBacD1CLk9iamVjdC5nZXRQcm90b3R5cGVPZix0dj13LGV2PW0scnY9cGEsbnY9Vixpdj1ldih4LmYpLG92PWV2KFtdLnB1c2gpLGF2PWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtmb3IodmFyIHIsbj1udihlKSxpPXJ2KG4pLG89aS5sZW5ndGgsYT0wLHU9W107bz5hOylyPWlbYSsrXSx0diYmIWl2KG4scil8fG92KHUsdD9bcixuW3JdXTpuW3JdKTtyZXR1cm4gdX19LHV2PXtlbnRyaWVzOmF2KCEwKSx2YWx1ZXM6YXYoITEpfS52YWx1ZXM7VHIoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITB9LHt2YWx1ZXM6ZnVuY3Rpb24odCl7cmV0dXJuIHV2KHQpfX0pLEIuT2JqZWN0LnZhbHVlczt2YXIgc3Y9XCJcXHRcXG5cXHZcXGZcXHIgwqDhmoDigIDigIHigILigIPigITigIXigIbigIfigIjigInigIrigK/igZ/jgIBcXHUyMDI4XFx1MjAyOVxcdWZlZmZcIixjdj1YLGZ2PWlvLGx2PW0oXCJcIi5yZXBsYWNlKSxodj1cIltcXHRcXG5cXHZcXGZcXHIgwqDhmoDigIDigIHigILigIPigITigIXigIbigIfigIjigInigIrigK/igZ/jgIBcXHUyMDI4XFx1MjAyOVxcdWZlZmZdXCIscHY9UmVnRXhwKFwiXlwiK2h2K2h2K1wiKlwiKSx2dj1SZWdFeHAoaHYraHYrXCIqJFwiKSxkdj1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHI9ZnYoY3YoZSkpO3JldHVybiAxJnQmJihyPWx2KHIscHYsXCJcIikpLDImdCYmKHI9bHYocix2dixcIlwiKSkscn19LHl2PXtzdGFydDpkdigxKSxlbmQ6ZHYoMiksdHJpbTpkdigzKX0sZ3Y9byxtdj1hLGJ2PW0sX3Y9aW8sd3Y9eXYudHJpbSxPdj1zdixFdj1ndi5wYXJzZUludCxUdj1ndi5TeW1ib2wseHY9VHYmJlR2Lml0ZXJhdG9yLGt2PS9eWystXT8weC9pLFN2PWJ2KGt2LmV4ZWMpLEF2PTghPT1FdihPditcIjA4XCIpfHwyMiE9PUV2KE92K1wiMHgxNlwiKXx8eHYmJiFtdigoZnVuY3Rpb24oKXtFdihPYmplY3QoeHYpKX0pKT9mdW5jdGlvbih0LGUpe3ZhciByPXd2KF92KHQpKTtyZXR1cm4gRXYocixlPj4+MHx8KFN2KGt2LHIpPzE2OjEwKSl9OkV2O1RyKHtnbG9iYWw6ITAsZm9yY2VkOnBhcnNlSW50IT1Bdn0se3BhcnNlSW50OkF2fSk7dmFyIGp2PVRyLFB2PW5hLmluZGV4T2YsSXY9bW4sRHY9bShbXS5pbmRleE9mKSxMdj0hIUR2JiYxL0R2KFsxXSwxLC0wKTwwLEN2PUl2KFwiaW5kZXhPZlwiKTtqdih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6THZ8fCFDdn0se2luZGV4T2Y6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDA7cmV0dXJuIEx2P0R2KHRoaXMsdCxlKXx8MDpQdih0aGlzLHQsZSl9fSksSnIoXCJBcnJheVwiKS5pbmRleE9mO3ZhciBSdj1Iby5QUk9QRVIsTXY9YSxGdj1zdixOdj15di50cmltO1RyKHt0YXJnZXQ6XCJTdHJpbmdcIixwcm90bzohMCxmb3JjZWQ6ZnVuY3Rpb24odCl7cmV0dXJuIE12KChmdW5jdGlvbigpe3JldHVybiEhRnZbdF0oKXx8XCLigIvCheGgjlwiIT09XCLigIvCheGgjlwiW3RdKCl8fFJ2JiZGdlt0XS5uYW1lIT09dH0pKX0oXCJ0cmltXCIpfSx7dHJpbTpmdW5jdGlvbigpe3JldHVybiBOdih0aGlzKX19KSxKcihcIlN0cmluZ1wiKS50cmltLFRyKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLHNoYW06IXd9LHtjcmVhdGU6TWF9KTt2YXIgenY9Qi5PYmplY3QscXY9ZnVuY3Rpb24odCxlKXtyZXR1cm4genYuY3JlYXRlKHQsZSl9LFl2PXF2LEd2PVRyLFh2PXR0LFV2PWgsV3Y9bSxWdj1hLEh2PW8uQXJyYXksJHY9WHYoXCJKU09OXCIsXCJzdHJpbmdpZnlcIiksQnY9V3YoLy4vLmV4ZWMpLEp2PVd2KFwiXCIuY2hhckF0KSxLdj1XdihcIlwiLmNoYXJDb2RlQXQpLFF2PVd2KFwiXCIucmVwbGFjZSksWnY9V3YoMS4udG9TdHJpbmcpLHRkPS9bXFx1RDgwMC1cXHVERkZGXS9nLGVkPS9eW1xcdUQ4MDAtXFx1REJGRl0kLyxyZD0vXltcXHVEQzAwLVxcdURGRkZdJC8sbmQ9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPUp2KHIsZS0xKSxpPUp2KHIsZSsxKTtyZXR1cm4gQnYoZWQsdCkmJiFCdihyZCxpKXx8QnYocmQsdCkmJiFCdihlZCxuKT9cIlxcXFx1XCIrWnYoS3YodCwwKSwxNik6dH0saWQ9VnYoKGZ1bmN0aW9uKCl7cmV0dXJuJ1wiXFxcXHVkZjA2XFxcXHVkODM0XCInIT09JHYoXCJcXHVkZjA2XFx1ZDgzNFwiKXx8J1wiXFxcXHVkZWFkXCInIT09JHYoXCJcXHVkZWFkXCIpfSkpOyR2JiZHdih7dGFyZ2V0OlwiSlNPTlwiLHN0YXQ6ITAsZm9yY2VkOmlkfSx7c3RyaW5naWZ5OmZ1bmN0aW9uKHQsZSxyKXtmb3IodmFyIG49MCxpPWFyZ3VtZW50cy5sZW5ndGgsbz1IdihpKTtuPGk7bisrKW9bbl09YXJndW1lbnRzW25dO3ZhciBhPVV2KCR2LG51bGwsbyk7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGE/UXYoYSx0ZCxuZCk6YX19KTt2YXIgb2Q9QixhZD1oO29kLkpTT058fChvZC5KU09OPXtzdHJpbmdpZnk6SlNPTi5zdHJpbmdpZnl9KTt2YXIgdWQ9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBhZChvZC5KU09OLnN0cmluZ2lmeSxudWxsLGFyZ3VtZW50cyl9LHNkPXVkLGNkPW8uVHlwZUVycm9yLGZkPVRyLGxkPW8saGQ9aCxwZD1iLHZkPVJyLGRkPWZ1bmN0aW9uKHQsZSl7aWYodDxlKXRocm93IGNkKFwiTm90IGVub3VnaCBhcmd1bWVudHNcIik7cmV0dXJuIHR9LHlkPS9NU0lFIC5cXC4vLnRlc3QocnQpLGdkPWxkLkZ1bmN0aW9uLG1kPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLHIpe3ZhciBuPWRkKGFyZ3VtZW50cy5sZW5ndGgsMSk+MixpPXBkKGUpP2U6Z2QoZSksbz1uP3ZkKGFyZ3VtZW50cywyKTp2b2lkIDA7cmV0dXJuIHQobj9mdW5jdGlvbigpe2hkKGksdGhpcyxvKX06aSxyKX19O2ZkKHtnbG9iYWw6ITAsYmluZDohMCxmb3JjZWQ6eWR9LHtzZXRUaW1lb3V0Om1kKGxkLnNldFRpbWVvdXQpLHNldEludGVydmFsOm1kKGxkLnNldEludGVydmFsKX0pO3ZhciBiZD1CLnNldFRpbWVvdXQsX2Q9WXQsd2Q9UW8sT2Q9Y24sRWQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPV9kKHRoaXMpLHI9T2QoZSksbj1hcmd1bWVudHMubGVuZ3RoLGk9d2Qobj4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsciksbz1uPjI/YXJndW1lbnRzWzJdOnZvaWQgMCxhPXZvaWQgMD09PW8/cjp3ZChvLHIpO2E+aTspZVtpKytdPXQ7cmV0dXJuIGV9O1RyKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwfSx7ZmlsbDpFZH0pLEpyKFwiQXJyYXlcIikuZmlsbDt2YXIgVGQ9e2V4cG9ydHM6e319OyFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe2lmKHQpcmV0dXJuIGZ1bmN0aW9uKHQpe2Zvcih2YXIgciBpbiBlLnByb3RvdHlwZSl0W3JdPWUucHJvdG90eXBlW3JdO3JldHVybiB0fSh0KX10LmV4cG9ydHM9ZSxlLnByb3RvdHlwZS5vbj1lLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9LCh0aGlzLl9jYWxsYmFja3NbXCIkXCIrdF09dGhpcy5fY2FsbGJhY2tzW1wiJFwiK3RdfHxbXSkucHVzaChlKSx0aGlzfSxlLnByb3RvdHlwZS5vbmNlPWZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gcigpe3RoaXMub2ZmKHQsciksZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIHIuZm49ZSx0aGlzLm9uKHQsciksdGhpc30sZS5wcm90b3R5cGUub2ZmPWUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyPWUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1lLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e30sMD09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fY2FsbGJhY2tzPXt9LHRoaXM7dmFyIHIsbj10aGlzLl9jYWxsYmFja3NbXCIkXCIrdF07aWYoIW4pcmV0dXJuIHRoaXM7aWYoMT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tcIiRcIit0XSx0aGlzO2Zvcih2YXIgaT0wO2k8bi5sZW5ndGg7aSsrKWlmKChyPW5baV0pPT09ZXx8ci5mbj09PWUpe24uc3BsaWNlKGksMSk7YnJlYWt9cmV0dXJuIDA9PT1uLmxlbmd0aCYmZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tcIiRcIit0XSx0aGlzfSxlLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKHQpe3RoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9O2Zvcih2YXIgZT1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKSxyPXRoaXMuX2NhbGxiYWNrc1tcIiRcIit0XSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyllW24tMV09YXJndW1lbnRzW25dO2lmKHIpe249MDtmb3IodmFyIGk9KHI9ci5zbGljZSgwKSkubGVuZ3RoO248aTsrK24pcltuXS5hcHBseSh0aGlzLGUpfXJldHVybiB0aGlzfSxlLnByb3RvdHlwZS5saXN0ZW5lcnM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9LHRoaXMuX2NhbGxiYWNrc1tcIiRcIit0XXx8W119LGUucHJvdG90eXBlLmhhc0xpc3RlbmVycz1mdW5jdGlvbih0KXtyZXR1cm4hIXRoaXMubGlzdGVuZXJzKHQpLmxlbmd0aH19KFRkKTt2YXIgeGQsa2Q9VGQuZXhwb3J0cztcbi8qISBIYW1tZXIuSlMgLSB2Mi4wLjE3LXJjIC0gMjAxOS0xMi0xNlxuICAgKiBodHRwOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanNcbiAgICpcbiAgICogRm9ya2VkIEJ5IE5hdmVyIGVnanNcbiAgICogQ29weXJpZ2h0IChjKSBoYW1tZXJqc1xuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9mdW5jdGlvbiBTZCgpe3JldHVybiBTZD1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgcj1hcmd1bWVudHNbZV07Zm9yKHZhciBuIGluIHIpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsbikmJih0W25dPXJbbl0pfXJldHVybiB0fSxTZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gQWQodCxlKXt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10LHQuX19wcm90b19fPWV9ZnVuY3Rpb24gamQodCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9eGQ9XCJmdW5jdGlvblwiIT10eXBlb2YgT2JqZWN0LmFzc2lnbj9mdW5jdGlvbih0KXtpZihudWxsPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcIik7Zm9yKHZhciBlPU9iamVjdCh0KSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dmFyIG49YXJndW1lbnRzW3JdO2lmKG51bGwhPW4pZm9yKHZhciBpIGluIG4pbi5oYXNPd25Qcm9wZXJ0eShpKSYmKGVbaV09bltpXSl9cmV0dXJuIGV9Ok9iamVjdC5hc3NpZ247dmFyIFBkLElkPXhkLERkPVtcIlwiLFwid2Via2l0XCIsXCJNb3pcIixcIk1TXCIsXCJtc1wiLFwib1wiXSxMZD1cInVuZGVmaW5lZFwiPT10eXBlb2YgZG9jdW1lbnQ/e3N0eWxlOnt9fTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLENkPU1hdGgucm91bmQsUmQ9TWF0aC5hYnMsTWQ9RGF0ZS5ub3c7ZnVuY3Rpb24gRmQodCxlKXtmb3IodmFyIHIsbixpPWVbMF0udG9VcHBlckNhc2UoKStlLnNsaWNlKDEpLG89MDtvPERkLmxlbmd0aDspe2lmKChuPShyPURkW29dKT9yK2k6ZSlpbiB0KXJldHVybiBuO28rK319UGQ9XCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz97fTp3aW5kb3c7dmFyIE5kPUZkKExkLnN0eWxlLFwidG91Y2hBY3Rpb25cIiksemQ9dm9pZCAwIT09TmQ7dmFyIHFkPVwiY29tcHV0ZVwiLFlkPVwiYXV0b1wiLEdkPVwibWFuaXB1bGF0aW9uXCIsWGQ9XCJub25lXCIsVWQ9XCJwYW4teFwiLFdkPVwicGFuLXlcIixWZD1mdW5jdGlvbigpe2lmKCF6ZClyZXR1cm4hMTt2YXIgdD17fSxlPVBkLkNTUyYmUGQuQ1NTLnN1cHBvcnRzO3JldHVybltcImF1dG9cIixcIm1hbmlwdWxhdGlvblwiLFwicGFuLXlcIixcInBhbi14XCIsXCJwYW4teCBwYW4teVwiLFwibm9uZVwiXS5mb3JFYWNoKChmdW5jdGlvbihyKXtyZXR1cm4gdFtyXT0hZXx8UGQuQ1NTLnN1cHBvcnRzKFwidG91Y2gtYWN0aW9uXCIscil9KSksdH0oKSxIZD1cIm9udG91Y2hzdGFydFwiaW4gUGQsJGQ9dm9pZCAwIT09RmQoUGQsXCJQb2ludGVyRXZlbnRcIiksQmQ9SGQmJi9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLEpkPVwidG91Y2hcIixLZD1cIm1vdXNlXCIsUWQ9MTYsWmQ9MjQsdHk9W1wieFwiLFwieVwiXSxleT1bXCJjbGllbnRYXCIsXCJjbGllbnRZXCJdO2Z1bmN0aW9uIHJ5KHQsZSxyKXt2YXIgbjtpZih0KWlmKHQuZm9yRWFjaCl0LmZvckVhY2goZSxyKTtlbHNlIGlmKHZvaWQgMCE9PXQubGVuZ3RoKWZvcihuPTA7bjx0Lmxlbmd0aDspZS5jYWxsKHIsdFtuXSxuLHQpLG4rKztlbHNlIGZvcihuIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShuKSYmZS5jYWxsKHIsdFtuXSxuLHQpfWZ1bmN0aW9uIG55KHQsZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdD90LmFwcGx5KGUmJmVbMF18fHZvaWQgMCxlKTp0fWZ1bmN0aW9uIGl5KHQsZSl7cmV0dXJuIHQuaW5kZXhPZihlKT4tMX12YXIgb3k9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dGhpcy5tYW5hZ2VyPXQsdGhpcy5zZXQoZSl9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuc2V0PWZ1bmN0aW9uKHQpe3Q9PT1xZCYmKHQ9dGhpcy5jb21wdXRlKCkpLHpkJiZ0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZSYmVmRbdF0mJih0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtOZF09dCksdGhpcy5hY3Rpb25zPXQudG9Mb3dlckNhc2UoKS50cmltKCl9LGUudXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pfSxlLmNvbXB1dGU9ZnVuY3Rpb24oKXt2YXIgdD1bXTtyZXR1cm4gcnkodGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLChmdW5jdGlvbihlKXtueShlLm9wdGlvbnMuZW5hYmxlLFtlXSkmJih0PXQuY29uY2F0KGUuZ2V0VG91Y2hBY3Rpb24oKSkpfSkpLGZ1bmN0aW9uKHQpe2lmKGl5KHQsWGQpKXJldHVybiBYZDt2YXIgZT1peSh0LFVkKSxyPWl5KHQsV2QpO3JldHVybiBlJiZyP1hkOmV8fHI/ZT9VZDpXZDppeSh0LEdkKT9HZDpZZH0odC5qb2luKFwiIFwiKSl9LGUucHJldmVudERlZmF1bHRzPWZ1bmN0aW9uKHQpe3ZhciBlPXQuc3JjRXZlbnQscj10Lm9mZnNldERpcmVjdGlvbjtpZih0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpZS5wcmV2ZW50RGVmYXVsdCgpO2Vsc2V7dmFyIG49dGhpcy5hY3Rpb25zLGk9aXkobixYZCkmJiFWZC5ub25lLG89aXkobixXZCkmJiFWZFtcInBhbi15XCJdLGE9aXkobixVZCkmJiFWZFtcInBhbi14XCJdO2lmKGkpe3ZhciB1PTE9PT10LnBvaW50ZXJzLmxlbmd0aCxzPXQuZGlzdGFuY2U8MixjPXQuZGVsdGFUaW1lPDI1MDtpZih1JiZzJiZjKXJldHVybn1pZighYXx8IW8pcmV0dXJuIGl8fG8mJjYmcnx8YSYmciZaZD90aGlzLnByZXZlbnRTcmMoZSk6dm9pZCAwfX0sZS5wcmV2ZW50U3JjPWZ1bmN0aW9uKHQpe3RoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZD0hMCx0LnByZXZlbnREZWZhdWx0KCl9LHR9KCk7ZnVuY3Rpb24gYXkodCxlKXtmb3IoO3Q7KXtpZih0PT09ZSlyZXR1cm4hMDt0PXQucGFyZW50Tm9kZX1yZXR1cm4hMX1mdW5jdGlvbiB1eSh0KXt2YXIgZT10Lmxlbmd0aDtpZigxPT09ZSlyZXR1cm57eDpDZCh0WzBdLmNsaWVudFgpLHk6Q2QodFswXS5jbGllbnRZKX07Zm9yKHZhciByPTAsbj0wLGk9MDtpPGU7KXIrPXRbaV0uY2xpZW50WCxuKz10W2ldLmNsaWVudFksaSsrO3JldHVybnt4OkNkKHIvZSkseTpDZChuL2UpfX1mdW5jdGlvbiBzeSh0KXtmb3IodmFyIGU9W10scj0wO3I8dC5wb2ludGVycy5sZW5ndGg7KWVbcl09e2NsaWVudFg6Q2QodC5wb2ludGVyc1tyXS5jbGllbnRYKSxjbGllbnRZOkNkKHQucG9pbnRlcnNbcl0uY2xpZW50WSl9LHIrKztyZXR1cm57dGltZVN0YW1wOk1kKCkscG9pbnRlcnM6ZSxjZW50ZXI6dXkoZSksZGVsdGFYOnQuZGVsdGFYLGRlbHRhWTp0LmRlbHRhWX19ZnVuY3Rpb24gY3kodCxlLHIpe3J8fChyPXR5KTt2YXIgbj1lW3JbMF1dLXRbclswXV0saT1lW3JbMV1dLXRbclsxXV07cmV0dXJuIE1hdGguc3FydChuKm4raSppKX1mdW5jdGlvbiBmeSh0LGUscil7cnx8KHI9dHkpO3ZhciBuPWVbclswXV0tdFtyWzBdXSxpPWVbclsxXV0tdFtyWzFdXTtyZXR1cm4gMTgwKk1hdGguYXRhbjIoaSxuKS9NYXRoLlBJfWZ1bmN0aW9uIGx5KHQsZSl7cmV0dXJuIHQ9PT1lPzE6UmQodCk+PVJkKGUpP3Q8MD8yOjQ6ZTwwPzg6UWR9ZnVuY3Rpb24gaHkodCxlLHIpe3JldHVybnt4OmUvdHx8MCx5OnIvdHx8MH19ZnVuY3Rpb24gcHkodCxlKXt2YXIgcj10LnNlc3Npb24sbj1lLnBvaW50ZXJzLGk9bi5sZW5ndGg7ci5maXJzdElucHV0fHwoci5maXJzdElucHV0PXN5KGUpKSxpPjEmJiFyLmZpcnN0TXVsdGlwbGU/ci5maXJzdE11bHRpcGxlPXN5KGUpOjE9PT1pJiYoci5maXJzdE11bHRpcGxlPSExKTt2YXIgbz1yLmZpcnN0SW5wdXQsYT1yLmZpcnN0TXVsdGlwbGUsdT1hP2EuY2VudGVyOm8uY2VudGVyLHM9ZS5jZW50ZXI9dXkobik7ZS50aW1lU3RhbXA9TWQoKSxlLmRlbHRhVGltZT1lLnRpbWVTdGFtcC1vLnRpbWVTdGFtcCxlLmFuZ2xlPWZ5KHUscyksZS5kaXN0YW5jZT1jeSh1LHMpLGZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5jZW50ZXIsbj10Lm9mZnNldERlbHRhfHx7fSxpPXQucHJldkRlbHRhfHx7fSxvPXQucHJldklucHV0fHx7fTsxIT09ZS5ldmVudFR5cGUmJjQhPT1vLmV2ZW50VHlwZXx8KGk9dC5wcmV2RGVsdGE9e3g6by5kZWx0YVh8fDAseTpvLmRlbHRhWXx8MH0sbj10Lm9mZnNldERlbHRhPXt4OnIueCx5OnIueX0pLGUuZGVsdGFYPWkueCsoci54LW4ueCksZS5kZWx0YVk9aS55KyhyLnktbi55KX0ocixlKSxlLm9mZnNldERpcmVjdGlvbj1seShlLmRlbHRhWCxlLmRlbHRhWSk7dmFyIGMsZixsPWh5KGUuZGVsdGFUaW1lLGUuZGVsdGFYLGUuZGVsdGFZKTtlLm92ZXJhbGxWZWxvY2l0eVg9bC54LGUub3ZlcmFsbFZlbG9jaXR5WT1sLnksZS5vdmVyYWxsVmVsb2NpdHk9UmQobC54KT5SZChsLnkpP2wueDpsLnksZS5zY2FsZT1hPyhjPWEucG9pbnRlcnMsY3koKGY9bilbMF0sZlsxXSxleSkvY3koY1swXSxjWzFdLGV5KSk6MSxlLnJvdGF0aW9uPWE/ZnVuY3Rpb24odCxlKXtyZXR1cm4gZnkoZVsxXSxlWzBdLGV5KStmeSh0WzFdLHRbMF0sZXkpfShhLnBvaW50ZXJzLG4pOjAsZS5tYXhQb2ludGVycz1yLnByZXZJbnB1dD9lLnBvaW50ZXJzLmxlbmd0aD5yLnByZXZJbnB1dC5tYXhQb2ludGVycz9lLnBvaW50ZXJzLmxlbmd0aDpyLnByZXZJbnB1dC5tYXhQb2ludGVyczplLnBvaW50ZXJzLmxlbmd0aCxmdW5jdGlvbih0LGUpe3ZhciByLG4saSxvLGE9dC5sYXN0SW50ZXJ2YWx8fGUsdT1lLnRpbWVTdGFtcC1hLnRpbWVTdGFtcDtpZig4IT09ZS5ldmVudFR5cGUmJih1PjI1fHx2b2lkIDA9PT1hLnZlbG9jaXR5KSl7dmFyIHM9ZS5kZWx0YVgtYS5kZWx0YVgsYz1lLmRlbHRhWS1hLmRlbHRhWSxmPWh5KHUscyxjKTtuPWYueCxpPWYueSxyPVJkKGYueCk+UmQoZi55KT9mLng6Zi55LG89bHkocyxjKSx0Lmxhc3RJbnRlcnZhbD1lfWVsc2Ugcj1hLnZlbG9jaXR5LG49YS52ZWxvY2l0eVgsaT1hLnZlbG9jaXR5WSxvPWEuZGlyZWN0aW9uO2UudmVsb2NpdHk9cixlLnZlbG9jaXR5WD1uLGUudmVsb2NpdHlZPWksZS5kaXJlY3Rpb249b30ocixlKTt2YXIgaCxwPXQuZWxlbWVudCx2PWUuc3JjRXZlbnQ7YXkoaD12LmNvbXBvc2VkUGF0aD92LmNvbXBvc2VkUGF0aCgpWzBdOnYucGF0aD92LnBhdGhbMF06di50YXJnZXQscCkmJihwPWgpLGUudGFyZ2V0PXB9ZnVuY3Rpb24gdnkodCxlLHIpe3ZhciBuPXIucG9pbnRlcnMubGVuZ3RoLGk9ci5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoLG89MSZlJiZuLWk9PTAsYT0xMiZlJiZuLWk9PTA7ci5pc0ZpcnN0PSEhbyxyLmlzRmluYWw9ISFhLG8mJih0LnNlc3Npb249e30pLHIuZXZlbnRUeXBlPWUscHkodCxyKSx0LmVtaXQoXCJoYW1tZXIuaW5wdXRcIixyKSx0LnJlY29nbml6ZShyKSx0LnNlc3Npb24ucHJldklucHV0PXJ9ZnVuY3Rpb24gZHkodCl7cmV0dXJuIHQudHJpbSgpLnNwbGl0KC9cXHMrL2cpfWZ1bmN0aW9uIHl5KHQsZSxyKXtyeShkeShlKSwoZnVuY3Rpb24oZSl7dC5hZGRFdmVudExpc3RlbmVyKGUsciwhMSl9KSl9ZnVuY3Rpb24gZ3kodCxlLHIpe3J5KGR5KGUpLChmdW5jdGlvbihlKXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSxyLCExKX0pKX1mdW5jdGlvbiBteSh0KXt2YXIgZT10Lm93bmVyRG9jdW1lbnR8fHQ7cmV0dXJuIGUuZGVmYXVsdFZpZXd8fGUucGFyZW50V2luZG93fHx3aW5kb3d9dmFyIGJ5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3ZhciByPXRoaXM7dGhpcy5tYW5hZ2VyPXQsdGhpcy5jYWxsYmFjaz1lLHRoaXMuZWxlbWVudD10LmVsZW1lbnQsdGhpcy50YXJnZXQ9dC5vcHRpb25zLmlucHV0VGFyZ2V0LHRoaXMuZG9tSGFuZGxlcj1mdW5jdGlvbihlKXtueSh0Lm9wdGlvbnMuZW5hYmxlLFt0XSkmJnIuaGFuZGxlcihlKX0sdGhpcy5pbml0KCl9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuaGFuZGxlcj1mdW5jdGlvbigpe30sZS5pbml0PWZ1bmN0aW9uKCl7dGhpcy5ldkVsJiZ5eSh0aGlzLmVsZW1lbnQsdGhpcy5ldkVsLHRoaXMuZG9tSGFuZGxlciksdGhpcy5ldlRhcmdldCYmeXkodGhpcy50YXJnZXQsdGhpcy5ldlRhcmdldCx0aGlzLmRvbUhhbmRsZXIpLHRoaXMuZXZXaW4mJnl5KG15KHRoaXMuZWxlbWVudCksdGhpcy5ldldpbix0aGlzLmRvbUhhbmRsZXIpfSxlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLmV2RWwmJmd5KHRoaXMuZWxlbWVudCx0aGlzLmV2RWwsdGhpcy5kb21IYW5kbGVyKSx0aGlzLmV2VGFyZ2V0JiZneSh0aGlzLnRhcmdldCx0aGlzLmV2VGFyZ2V0LHRoaXMuZG9tSGFuZGxlciksdGhpcy5ldldpbiYmZ3kobXkodGhpcy5lbGVtZW50KSx0aGlzLmV2V2luLHRoaXMuZG9tSGFuZGxlcil9LHR9KCk7ZnVuY3Rpb24gX3kodCxlLHIpe2lmKHQuaW5kZXhPZiYmIXIpcmV0dXJuIHQuaW5kZXhPZihlKTtmb3IodmFyIG49MDtuPHQubGVuZ3RoOyl7aWYociYmdFtuXVtyXT09ZXx8IXImJnRbbl09PT1lKXJldHVybiBuO24rK31yZXR1cm4tMX12YXIgd3k9e3BvaW50ZXJkb3duOjEscG9pbnRlcm1vdmU6Mixwb2ludGVydXA6NCxwb2ludGVyY2FuY2VsOjgscG9pbnRlcm91dDo4fSxPeT17MjpKZCwzOlwicGVuXCIsNDpLZCw1Olwia2luZWN0XCJ9LEV5PVwicG9pbnRlcmRvd25cIixUeT1cInBvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsXCI7UGQuTVNQb2ludGVyRXZlbnQmJiFQZC5Qb2ludGVyRXZlbnQmJihFeT1cIk1TUG9pbnRlckRvd25cIixUeT1cIk1TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsXCIpO3ZhciB4eT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHIsbj1lLnByb3RvdHlwZTtyZXR1cm4gbi5ldkVsPUV5LG4uZXZXaW49VHksKHI9dC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXMpLnN0b3JlPXIubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHM9W10scn1yZXR1cm4gQWQoZSx0KSxlLnByb3RvdHlwZS5oYW5kbGVyPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuc3RvcmUscj0hMSxuPXQudHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoXCJtc1wiLFwiXCIpLGk9d3lbbl0sbz1PeVt0LnBvaW50ZXJUeXBlXXx8dC5wb2ludGVyVHlwZSxhPW89PT1KZCx1PV95KGUsdC5wb2ludGVySWQsXCJwb2ludGVySWRcIik7MSZpJiYoMD09PXQuYnV0dG9ufHxhKT91PDAmJihlLnB1c2godCksdT1lLmxlbmd0aC0xKToxMiZpJiYocj0hMCksdTwwfHwoZVt1XT10LHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLGkse3BvaW50ZXJzOmUsY2hhbmdlZFBvaW50ZXJzOlt0XSxwb2ludGVyVHlwZTpvLHNyY0V2ZW50OnR9KSxyJiZlLnNwbGljZSh1LDEpKX0sZX0oYnkpO2Z1bmN0aW9uIGt5KHQpe3JldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LDApfWZ1bmN0aW9uIFN5KHQsZSxyKXtmb3IodmFyIG49W10saT1bXSxvPTA7bzx0Lmxlbmd0aDspe3ZhciBhPWU/dFtvXVtlXTp0W29dO195KGksYSk8MCYmbi5wdXNoKHRbb10pLGlbb109YSxvKyt9cmV0dXJuIHImJihuPWU/bi5zb3J0KChmdW5jdGlvbih0LHIpe3JldHVybiB0W2VdPnJbZV19KSk6bi5zb3J0KCkpLG59dmFyIEF5PXt0b3VjaHN0YXJ0OjEsdG91Y2htb3ZlOjIsdG91Y2hlbmQ6NCx0b3VjaGNhbmNlbDo4fSxqeT1cInRvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsXCIsUHk9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciByO3JldHVybiBlLnByb3RvdHlwZS5ldlRhcmdldD1qeSwocj10LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcykudGFyZ2V0SWRzPXt9LHJ9cmV0dXJuIEFkKGUsdCksZS5wcm90b3R5cGUuaGFuZGxlcj1mdW5jdGlvbih0KXt2YXIgZT1BeVt0LnR5cGVdLHI9SXkuY2FsbCh0aGlzLHQsZSk7ciYmdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsZSx7cG9pbnRlcnM6clswXSxjaGFuZ2VkUG9pbnRlcnM6clsxXSxwb2ludGVyVHlwZTpKZCxzcmNFdmVudDp0fSl9LGV9KGJ5KTtmdW5jdGlvbiBJeSh0LGUpe3ZhciByLG4saT1reSh0LnRvdWNoZXMpLG89dGhpcy50YXJnZXRJZHM7aWYoMyZlJiYxPT09aS5sZW5ndGgpcmV0dXJuIG9baVswXS5pZGVudGlmaWVyXT0hMCxbaSxpXTt2YXIgYT1reSh0LmNoYW5nZWRUb3VjaGVzKSx1PVtdLHM9dGhpcy50YXJnZXQ7aWYobj1pLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIGF5KHQudGFyZ2V0LHMpfSkpLDE9PT1lKWZvcihyPTA7cjxuLmxlbmd0aDspb1tuW3JdLmlkZW50aWZpZXJdPSEwLHIrKztmb3Iocj0wO3I8YS5sZW5ndGg7KW9bYVtyXS5pZGVudGlmaWVyXSYmdS5wdXNoKGFbcl0pLDEyJmUmJmRlbGV0ZSBvW2Fbcl0uaWRlbnRpZmllcl0scisrO3JldHVybiB1Lmxlbmd0aD9bU3kobi5jb25jYXQodSksXCJpZGVudGlmaWVyXCIsITApLHVdOnZvaWQgMH12YXIgRHk9e21vdXNlZG93bjoxLG1vdXNlbW92ZToyLG1vdXNldXA6NH0sTHk9XCJtb3VzZWRvd25cIixDeT1cIm1vdXNlbW92ZSBtb3VzZXVwXCIsUnk9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciByLG49ZS5wcm90b3R5cGU7cmV0dXJuIG4uZXZFbD1MeSxuLmV2V2luPUN5LChyPXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzKS5wcmVzc2VkPSExLHJ9cmV0dXJuIEFkKGUsdCksZS5wcm90b3R5cGUuaGFuZGxlcj1mdW5jdGlvbih0KXt2YXIgZT1EeVt0LnR5cGVdOzEmZSYmMD09PXQuYnV0dG9uJiYodGhpcy5wcmVzc2VkPSEwKSwyJmUmJjEhPT10LndoaWNoJiYoZT00KSx0aGlzLnByZXNzZWQmJig0JmUmJih0aGlzLnByZXNzZWQ9ITEpLHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLGUse3BvaW50ZXJzOlt0XSxjaGFuZ2VkUG9pbnRlcnM6W3RdLHBvaW50ZXJUeXBlOktkLHNyY0V2ZW50OnR9KSl9LGV9KGJ5KTtmdW5jdGlvbiBNeSh0KXt2YXIgZT10LmNoYW5nZWRQb2ludGVyc1swXTtpZihlLmlkZW50aWZpZXI9PT10aGlzLnByaW1hcnlUb3VjaCl7dmFyIHI9e3g6ZS5jbGllbnRYLHk6ZS5jbGllbnRZfSxuPXRoaXMubGFzdFRvdWNoZXM7dGhpcy5sYXN0VG91Y2hlcy5wdXNoKHIpO3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7dmFyIHQ9bi5pbmRleE9mKHIpO3Q+LTEmJm4uc3BsaWNlKHQsMSl9KSwyNTAwKX19ZnVuY3Rpb24gRnkodCxlKXsxJnQ/KHRoaXMucHJpbWFyeVRvdWNoPWUuY2hhbmdlZFBvaW50ZXJzWzBdLmlkZW50aWZpZXIsTXkuY2FsbCh0aGlzLGUpKToxMiZ0JiZNeS5jYWxsKHRoaXMsZSl9ZnVuY3Rpb24gTnkodCl7Zm9yKHZhciBlPXQuc3JjRXZlbnQuY2xpZW50WCxyPXQuc3JjRXZlbnQuY2xpZW50WSxuPTA7bjx0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDtuKyspe3ZhciBpPXRoaXMubGFzdFRvdWNoZXNbbl0sbz1NYXRoLmFicyhlLWkueCksYT1NYXRoLmFicyhyLWkueSk7aWYobzw9MjUmJmE8PTI1KXJldHVybiEwfXJldHVybiExfXZhciB6eT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIG47cmV0dXJuKG49dC5jYWxsKHRoaXMsZSxyKXx8dGhpcykuaGFuZGxlcj1mdW5jdGlvbih0LGUscil7dmFyIGk9ci5wb2ludGVyVHlwZT09PUpkLG89ci5wb2ludGVyVHlwZT09PUtkO2lmKCEobyYmci5zb3VyY2VDYXBhYmlsaXRpZXMmJnIuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHMpKXtpZihpKUZ5LmNhbGwoamQoamQobikpLGUscik7ZWxzZSBpZihvJiZOeS5jYWxsKGpkKGpkKG4pKSxyKSlyZXR1cm47bi5jYWxsYmFjayh0LGUscil9fSxuLnRvdWNoPW5ldyBQeShuLm1hbmFnZXIsbi5oYW5kbGVyKSxuLm1vdXNlPW5ldyBSeShuLm1hbmFnZXIsbi5oYW5kbGVyKSxuLnByaW1hcnlUb3VjaD1udWxsLG4ubGFzdFRvdWNoZXM9W10sbn1yZXR1cm4gQWQoZSx0KSxlLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy50b3VjaC5kZXN0cm95KCksdGhpcy5tb3VzZS5kZXN0cm95KCl9LGV9KGJ5KX0oKTtmdW5jdGlvbiBxeSh0LGUscil7cmV0dXJuISFBcnJheS5pc0FycmF5KHQpJiYocnkodCxyW2VdLHIpLCEwKX12YXIgWXk9MzIsR3k9MTtmdW5jdGlvbiBYeSh0LGUpe3ZhciByPWUubWFuYWdlcjtyZXR1cm4gcj9yLmdldCh0KTp0fWZ1bmN0aW9uIFV5KHQpe3JldHVybiAxNiZ0P1wiY2FuY2VsXCI6OCZ0P1wiZW5kXCI6NCZ0P1wibW92ZVwiOjImdD9cInN0YXJ0XCI6XCJcIn12YXIgV3k9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3ZvaWQgMD09PXQmJih0PXt9KSx0aGlzLm9wdGlvbnM9U2Qoe2VuYWJsZTohMH0sdCksdGhpcy5pZD1HeSsrLHRoaXMubWFuYWdlcj1udWxsLHRoaXMuc3RhdGU9MSx0aGlzLnNpbXVsdGFuZW91cz17fSx0aGlzLnJlcXVpcmVGYWlsPVtdfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLnNldD1mdW5jdGlvbih0KXtyZXR1cm4gSWQodGhpcy5vcHRpb25zLHQpLHRoaXMubWFuYWdlciYmdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpLHRoaXN9LGUucmVjb2duaXplV2l0aD1mdW5jdGlvbih0KXtpZihxeSh0LFwicmVjb2duaXplV2l0aFwiLHRoaXMpKXJldHVybiB0aGlzO3ZhciBlPXRoaXMuc2ltdWx0YW5lb3VzO3JldHVybiBlWyh0PVh5KHQsdGhpcykpLmlkXXx8KGVbdC5pZF09dCx0LnJlY29nbml6ZVdpdGgodGhpcykpLHRoaXN9LGUuZHJvcFJlY29nbml6ZVdpdGg9ZnVuY3Rpb24odCl7cmV0dXJuIHF5KHQsXCJkcm9wUmVjb2duaXplV2l0aFwiLHRoaXMpfHwodD1YeSh0LHRoaXMpLGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1t0LmlkXSksdGhpc30sZS5yZXF1aXJlRmFpbHVyZT1mdW5jdGlvbih0KXtpZihxeSh0LFwicmVxdWlyZUZhaWx1cmVcIix0aGlzKSlyZXR1cm4gdGhpczt2YXIgZT10aGlzLnJlcXVpcmVGYWlsO3JldHVybi0xPT09X3koZSx0PVh5KHQsdGhpcykpJiYoZS5wdXNoKHQpLHQucmVxdWlyZUZhaWx1cmUodGhpcykpLHRoaXN9LGUuZHJvcFJlcXVpcmVGYWlsdXJlPWZ1bmN0aW9uKHQpe2lmKHF5KHQsXCJkcm9wUmVxdWlyZUZhaWx1cmVcIix0aGlzKSlyZXR1cm4gdGhpczt0PVh5KHQsdGhpcyk7dmFyIGU9X3kodGhpcy5yZXF1aXJlRmFpbCx0KTtyZXR1cm4gZT4tMSYmdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoZSwxKSx0aGlzfSxlLmhhc1JlcXVpcmVGYWlsdXJlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aD4wfSxlLmNhblJlY29nbml6ZVdpdGg9ZnVuY3Rpb24odCl7cmV0dXJuISF0aGlzLnNpbXVsdGFuZW91c1t0LmlkXX0sZS5lbWl0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj10aGlzLnN0YXRlO2Z1bmN0aW9uIG4ocil7ZS5tYW5hZ2VyLmVtaXQocix0KX1yPDgmJm4oZS5vcHRpb25zLmV2ZW50K1V5KHIpKSxuKGUub3B0aW9ucy5ldmVudCksdC5hZGRpdGlvbmFsRXZlbnQmJm4odC5hZGRpdGlvbmFsRXZlbnQpLHI+PTgmJm4oZS5vcHRpb25zLmV2ZW50K1V5KHIpKX0sZS50cnlFbWl0PWZ1bmN0aW9uKHQpe2lmKHRoaXMuY2FuRW1pdCgpKXJldHVybiB0aGlzLmVtaXQodCk7dGhpcy5zdGF0ZT1ZeX0sZS5jYW5FbWl0PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDx0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aDspe2lmKCEoMzMmdGhpcy5yZXF1aXJlRmFpbFt0XS5zdGF0ZSkpcmV0dXJuITE7dCsrfXJldHVybiEwfSxlLnJlY29nbml6ZT1mdW5jdGlvbih0KXt2YXIgZT1JZCh7fSx0KTtpZighbnkodGhpcy5vcHRpb25zLmVuYWJsZSxbdGhpcyxlXSkpcmV0dXJuIHRoaXMucmVzZXQoKSx2b2lkKHRoaXMuc3RhdGU9WXkpOzU2JnRoaXMuc3RhdGUmJih0aGlzLnN0YXRlPTEpLHRoaXMuc3RhdGU9dGhpcy5wcm9jZXNzKGUpLDMwJnRoaXMuc3RhdGUmJnRoaXMudHJ5RW1pdChlKX0sZS5wcm9jZXNzPWZ1bmN0aW9uKHQpe30sZS5nZXRUb3VjaEFjdGlvbj1mdW5jdGlvbigpe30sZS5yZXNldD1mdW5jdGlvbigpe30sdH0oKSxWeT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciByO3JldHVybiB2b2lkIDA9PT1lJiYoZT17fSksKHI9dC5jYWxsKHRoaXMsU2Qoe2V2ZW50OlwidGFwXCIscG9pbnRlcnM6MSx0YXBzOjEsaW50ZXJ2YWw6MzAwLHRpbWU6MjUwLHRocmVzaG9sZDo5LHBvc1RocmVzaG9sZDoxMH0sZSkpfHx0aGlzKS5wVGltZT0hMSxyLnBDZW50ZXI9ITEsci5fdGltZXI9bnVsbCxyLl9pbnB1dD1udWxsLHIuY291bnQ9MCxyfUFkKGUsdCk7dmFyIHI9ZS5wcm90b3R5cGU7cmV0dXJuIHIuZ2V0VG91Y2hBY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm5bR2RdfSxyLnByb2Nlc3M9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPXRoaXMub3B0aW9ucyxuPXQucG9pbnRlcnMubGVuZ3RoPT09ci5wb2ludGVycyxpPXQuZGlzdGFuY2U8ci50aHJlc2hvbGQsbz10LmRlbHRhVGltZTxyLnRpbWU7aWYodGhpcy5yZXNldCgpLDEmdC5ldmVudFR5cGUmJjA9PT10aGlzLmNvdW50KXJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7aWYoaSYmbyYmbil7aWYoNCE9PXQuZXZlbnRUeXBlKXJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7dmFyIGE9IXRoaXMucFRpbWV8fHQudGltZVN0YW1wLXRoaXMucFRpbWU8ci5pbnRlcnZhbCx1PSF0aGlzLnBDZW50ZXJ8fGN5KHRoaXMucENlbnRlcix0LmNlbnRlcik8ci5wb3NUaHJlc2hvbGQ7aWYodGhpcy5wVGltZT10LnRpbWVTdGFtcCx0aGlzLnBDZW50ZXI9dC5jZW50ZXIsdSYmYT90aGlzLmNvdW50Kz0xOnRoaXMuY291bnQ9MSx0aGlzLl9pbnB1dD10LDA9PT10aGlzLmNvdW50JXIudGFwcylyZXR1cm4gdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKT8odGhpcy5fdGltZXI9c2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLnN0YXRlPTgsZS50cnlFbWl0KCl9KSxyLmludGVydmFsKSwyKTo4fXJldHVybiBZeX0sci5mYWlsVGltZW91dD1mdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIHRoaXMuX3RpbWVyPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7dC5zdGF0ZT1ZeX0pLHRoaXMub3B0aW9ucy5pbnRlcnZhbCksWXl9LHIucmVzZXQ9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpfSxyLmVtaXQ9ZnVuY3Rpb24oKXs4PT09dGhpcy5zdGF0ZSYmKHRoaXMuX2lucHV0LnRhcENvdW50PXRoaXMuY291bnQsdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LHRoaXMuX2lucHV0KSl9LGV9KFd5KSxIeT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT17fSksdC5jYWxsKHRoaXMsU2Qoe3BvaW50ZXJzOjF9LGUpKXx8dGhpc31BZChlLHQpO3ZhciByPWUucHJvdG90eXBlO3JldHVybiByLmF0dHJUZXN0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMub3B0aW9ucy5wb2ludGVycztyZXR1cm4gMD09PWV8fHQucG9pbnRlcnMubGVuZ3RoPT09ZX0sci5wcm9jZXNzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuc3RhdGUscj10LmV2ZW50VHlwZSxuPTYmZSxpPXRoaXMuYXR0clRlc3QodCk7cmV0dXJuIG4mJig4JnJ8fCFpKT8xNnxlOm58fGk/NCZyPzh8ZToyJmU/NHxlOjI6WXl9LGV9KFd5KTtmdW5jdGlvbiAkeSh0KXtyZXR1cm4gdD09PVFkP1wiZG93blwiOjg9PT10P1widXBcIjoyPT09dD9cImxlZnRcIjo0PT09dD9cInJpZ2h0XCI6XCJcIn12YXIgQnk9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgcjtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9e30pLChyPXQuY2FsbCh0aGlzLFNkKHtldmVudDpcInBhblwiLHRocmVzaG9sZDoxMCxwb2ludGVyczoxLGRpcmVjdGlvbjozMH0sZSkpfHx0aGlzKS5wWD1udWxsLHIucFk9bnVsbCxyfUFkKGUsdCk7dmFyIHI9ZS5wcm90b3R5cGU7cmV0dXJuIHIuZ2V0VG91Y2hBY3Rpb249ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm9wdGlvbnMuZGlyZWN0aW9uLGU9W107cmV0dXJuIDYmdCYmZS5wdXNoKFdkKSx0JlpkJiZlLnB1c2goVWQpLGV9LHIuZGlyZWN0aW9uVGVzdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLm9wdGlvbnMscj0hMCxuPXQuZGlzdGFuY2UsaT10LmRpcmVjdGlvbixvPXQuZGVsdGFYLGE9dC5kZWx0YVk7cmV0dXJuIGkmZS5kaXJlY3Rpb258fCg2JmUuZGlyZWN0aW9uPyhpPTA9PT1vPzE6bzwwPzI6NCxyPW8hPT10aGlzLnBYLG49TWF0aC5hYnModC5kZWx0YVgpKTooaT0wPT09YT8xOmE8MD84OlFkLHI9YSE9PXRoaXMucFksbj1NYXRoLmFicyh0LmRlbHRhWSkpKSx0LmRpcmVjdGlvbj1pLHImJm4+ZS50aHJlc2hvbGQmJmkmZS5kaXJlY3Rpb259LHIuYXR0clRlc3Q9ZnVuY3Rpb24odCl7cmV0dXJuIEh5LnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsdCkmJigyJnRoaXMuc3RhdGV8fCEoMiZ0aGlzLnN0YXRlKSYmdGhpcy5kaXJlY3Rpb25UZXN0KHQpKX0sci5lbWl0PWZ1bmN0aW9uKGUpe3RoaXMucFg9ZS5kZWx0YVgsdGhpcy5wWT1lLmRlbHRhWTt2YXIgcj0keShlLmRpcmVjdGlvbik7ciYmKGUuYWRkaXRpb25hbEV2ZW50PXRoaXMub3B0aW9ucy5ldmVudCtyKSx0LnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcyxlKX0sZX0oSHkpLEp5PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSx0LmNhbGwodGhpcyxTZCh7ZXZlbnQ6XCJzd2lwZVwiLHRocmVzaG9sZDoxMCx2ZWxvY2l0eTouMyxkaXJlY3Rpb246MzAscG9pbnRlcnM6MX0sZSkpfHx0aGlzfUFkKGUsdCk7dmFyIHI9ZS5wcm90b3R5cGU7cmV0dXJuIHIuZ2V0VG91Y2hBY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4gQnkucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyl9LHIuYXR0clRlc3Q9ZnVuY3Rpb24oZSl7dmFyIHIsbj10aGlzLm9wdGlvbnMuZGlyZWN0aW9uO3JldHVybiAzMCZuP3I9ZS5vdmVyYWxsVmVsb2NpdHk6NiZuP3I9ZS5vdmVyYWxsVmVsb2NpdHlYOm4mWmQmJihyPWUub3ZlcmFsbFZlbG9jaXR5WSksdC5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLGUpJiZuJmUub2Zmc2V0RGlyZWN0aW9uJiZlLmRpc3RhbmNlPnRoaXMub3B0aW9ucy50aHJlc2hvbGQmJmUubWF4UG9pbnRlcnM9PT10aGlzLm9wdGlvbnMucG9pbnRlcnMmJlJkKHIpPnRoaXMub3B0aW9ucy52ZWxvY2l0eSYmNCZlLmV2ZW50VHlwZX0sci5lbWl0PWZ1bmN0aW9uKHQpe3ZhciBlPSR5KHQub2Zmc2V0RGlyZWN0aW9uKTtlJiZ0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQrZSx0KSx0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsdCl9LGV9KEh5KSxLeT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT17fSksdC5jYWxsKHRoaXMsU2Qoe2V2ZW50OlwicGluY2hcIix0aHJlc2hvbGQ6MCxwb2ludGVyczoyfSxlKSl8fHRoaXN9QWQoZSx0KTt2YXIgcj1lLnByb3RvdHlwZTtyZXR1cm4gci5nZXRUb3VjaEFjdGlvbj1mdW5jdGlvbigpe3JldHVybltYZF19LHIuYXR0clRlc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHQucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcyxlKSYmKE1hdGguYWJzKGUuc2NhbGUtMSk+dGhpcy5vcHRpb25zLnRocmVzaG9sZHx8MiZ0aGlzLnN0YXRlKX0sci5lbWl0PWZ1bmN0aW9uKGUpe2lmKDEhPT1lLnNjYWxlKXt2YXIgcj1lLnNjYWxlPDE/XCJpblwiOlwib3V0XCI7ZS5hZGRpdGlvbmFsRXZlbnQ9dGhpcy5vcHRpb25zLmV2ZW50K3J9dC5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsZSl9LGV9KEh5KSxReT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT17fSksdC5jYWxsKHRoaXMsU2Qoe2V2ZW50Olwicm90YXRlXCIsdGhyZXNob2xkOjAscG9pbnRlcnM6Mn0sZSkpfHx0aGlzfUFkKGUsdCk7dmFyIHI9ZS5wcm90b3R5cGU7cmV0dXJuIHIuZ2V0VG91Y2hBY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm5bWGRdfSxyLmF0dHJUZXN0PWZ1bmN0aW9uKGUpe3JldHVybiB0LnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsZSkmJihNYXRoLmFicyhlLnJvdGF0aW9uKT50aGlzLm9wdGlvbnMudGhyZXNob2xkfHwyJnRoaXMuc3RhdGUpfSxlfShIeSksWnk9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgcjtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9e30pLChyPXQuY2FsbCh0aGlzLFNkKHtldmVudDpcInByZXNzXCIscG9pbnRlcnM6MSx0aW1lOjI1MSx0aHJlc2hvbGQ6OX0sZSkpfHx0aGlzKS5fdGltZXI9bnVsbCxyLl9pbnB1dD1udWxsLHJ9QWQoZSx0KTt2YXIgcj1lLnByb3RvdHlwZTtyZXR1cm4gci5nZXRUb3VjaEFjdGlvbj1mdW5jdGlvbigpe3JldHVybltZZF19LHIucHJvY2Vzcz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9dGhpcy5vcHRpb25zLG49dC5wb2ludGVycy5sZW5ndGg9PT1yLnBvaW50ZXJzLGk9dC5kaXN0YW5jZTxyLnRocmVzaG9sZCxvPXQuZGVsdGFUaW1lPnIudGltZTtpZih0aGlzLl9pbnB1dD10LCFpfHwhbnx8MTImdC5ldmVudFR5cGUmJiFvKXRoaXMucmVzZXQoKTtlbHNlIGlmKDEmdC5ldmVudFR5cGUpdGhpcy5yZXNldCgpLHRoaXMuX3RpbWVyPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZS5zdGF0ZT04LGUudHJ5RW1pdCgpfSksci50aW1lKTtlbHNlIGlmKDQmdC5ldmVudFR5cGUpcmV0dXJuIDg7cmV0dXJuIFl5fSxyLnJlc2V0PWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKX0sci5lbWl0PWZ1bmN0aW9uKHQpezg9PT10aGlzLnN0YXRlJiYodCYmNCZ0LmV2ZW50VHlwZT90aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQrXCJ1cFwiLHQpOih0aGlzLl9pbnB1dC50aW1lU3RhbXA9TWQoKSx0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsdGhpcy5faW5wdXQpKSl9LGV9KFd5KSx0Zz17ZG9tRXZlbnRzOiExLHRvdWNoQWN0aW9uOnFkLGVuYWJsZTohMCxpbnB1dFRhcmdldDpudWxsLGlucHV0Q2xhc3M6bnVsbCxjc3NQcm9wczp7dXNlclNlbGVjdDpcIm5vbmVcIix0b3VjaFNlbGVjdDpcIm5vbmVcIix0b3VjaENhbGxvdXQ6XCJub25lXCIsY29udGVudFpvb21pbmc6XCJub25lXCIsdXNlckRyYWc6XCJub25lXCIsdGFwSGlnaGxpZ2h0Q29sb3I6XCJyZ2JhKDAsMCwwLDApXCJ9fSxlZz1bW1F5LHtlbmFibGU6ITF9XSxbS3kse2VuYWJsZTohMX0sW1wicm90YXRlXCJdXSxbSnkse2RpcmVjdGlvbjo2fV0sW0J5LHtkaXJlY3Rpb246Nn0sW1wic3dpcGVcIl1dLFtWeV0sW1Z5LHtldmVudDpcImRvdWJsZXRhcFwiLHRhcHM6Mn0sW1widGFwXCJdXSxbWnldXTtmdW5jdGlvbiByZyh0LGUpe3ZhciByLG49dC5lbGVtZW50O24uc3R5bGUmJihyeSh0Lm9wdGlvbnMuY3NzUHJvcHMsKGZ1bmN0aW9uKGksbyl7cj1GZChuLnN0eWxlLG8pLGU/KHQub2xkQ3NzUHJvcHNbcl09bi5zdHlsZVtyXSxuLnN0eWxlW3JdPWkpOm4uc3R5bGVbcl09dC5vbGRDc3NQcm9wc1tyXXx8XCJcIn0pKSxlfHwodC5vbGRDc3NQcm9wcz17fSkpfXZhciBuZz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt2YXIgcixuPXRoaXM7dGhpcy5vcHRpb25zPUlkKHt9LHRnLGV8fHt9KSx0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQ9dGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0fHx0LHRoaXMuaGFuZGxlcnM9e30sdGhpcy5zZXNzaW9uPXt9LHRoaXMucmVjb2duaXplcnM9W10sdGhpcy5vbGRDc3NQcm9wcz17fSx0aGlzLmVsZW1lbnQ9dCx0aGlzLmlucHV0PW5ldygocj10aGlzKS5vcHRpb25zLmlucHV0Q2xhc3N8fCgkZD94eTpCZD9QeTpIZD96eTpSeSkpKHIsdnkpLHRoaXMudG91Y2hBY3Rpb249bmV3IG95KHRoaXMsdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKSxyZyh0aGlzLCEwKSxyeSh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsKGZ1bmN0aW9uKHQpe3ZhciBlPW4uYWRkKG5ldyB0WzBdKHRbMV0pKTt0WzJdJiZlLnJlY29nbml6ZVdpdGgodFsyXSksdFszXSYmZS5yZXF1aXJlRmFpbHVyZSh0WzNdKX0pLHRoaXMpfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLnNldD1mdW5jdGlvbih0KXtyZXR1cm4gSWQodGhpcy5vcHRpb25zLHQpLHQudG91Y2hBY3Rpb24mJnRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCksdC5pbnB1dFRhcmdldCYmKHRoaXMuaW5wdXQuZGVzdHJveSgpLHRoaXMuaW5wdXQudGFyZ2V0PXQuaW5wdXRUYXJnZXQsdGhpcy5pbnB1dC5pbml0KCkpLHRoaXN9LGUuc3RvcD1mdW5jdGlvbih0KXt0aGlzLnNlc3Npb24uc3RvcHBlZD10PzI6MX0sZS5yZWNvZ25pemU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5zZXNzaW9uO2lmKCFlLnN0b3BwZWQpe3ZhciByO3RoaXMudG91Y2hBY3Rpb24ucHJldmVudERlZmF1bHRzKHQpO3ZhciBuPXRoaXMucmVjb2duaXplcnMsaT1lLmN1clJlY29nbml6ZXI7KCFpfHxpJiY4Jmkuc3RhdGUpJiYoZS5jdXJSZWNvZ25pemVyPW51bGwsaT1udWxsKTtmb3IodmFyIG89MDtvPG4ubGVuZ3RoOylyPW5bb10sMj09PWUuc3RvcHBlZHx8aSYmciE9PWkmJiFyLmNhblJlY29nbml6ZVdpdGgoaSk/ci5yZXNldCgpOnIucmVjb2duaXplKHQpLCFpJiYxNCZyLnN0YXRlJiYoZS5jdXJSZWNvZ25pemVyPXIsaT1yKSxvKyt9fSxlLmdldD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgV3kpcmV0dXJuIHQ7Zm9yKHZhciBlPXRoaXMucmVjb2duaXplcnMscj0wO3I8ZS5sZW5ndGg7cisrKWlmKGVbcl0ub3B0aW9ucy5ldmVudD09PXQpcmV0dXJuIGVbcl07cmV0dXJuIG51bGx9LGUuYWRkPWZ1bmN0aW9uKHQpe2lmKHF5KHQsXCJhZGRcIix0aGlzKSlyZXR1cm4gdGhpczt2YXIgZT10aGlzLmdldCh0Lm9wdGlvbnMuZXZlbnQpO3JldHVybiBlJiZ0aGlzLnJlbW92ZShlKSx0aGlzLnJlY29nbml6ZXJzLnB1c2godCksdC5tYW5hZ2VyPXRoaXMsdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKSx0fSxlLnJlbW92ZT1mdW5jdGlvbih0KXtpZihxeSh0LFwicmVtb3ZlXCIsdGhpcykpcmV0dXJuIHRoaXM7dmFyIGU9dGhpcy5nZXQodCk7aWYodCl7dmFyIHI9dGhpcy5yZWNvZ25pemVycyxuPV95KHIsZSk7LTEhPT1uJiYoci5zcGxpY2UobiwxKSx0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpKX1yZXR1cm4gdGhpc30sZS5vbj1mdW5jdGlvbih0LGUpe2lmKHZvaWQgMD09PXR8fHZvaWQgMD09PWUpcmV0dXJuIHRoaXM7dmFyIHI9dGhpcy5oYW5kbGVycztyZXR1cm4gcnkoZHkodCksKGZ1bmN0aW9uKHQpe3JbdF09clt0XXx8W10sclt0XS5wdXNoKGUpfSkpLHRoaXN9LGUub2ZmPWZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpczt2YXIgcj10aGlzLmhhbmRsZXJzO3JldHVybiByeShkeSh0KSwoZnVuY3Rpb24odCl7ZT9yW3RdJiZyW3RdLnNwbGljZShfeShyW3RdLGUpLDEpOmRlbGV0ZSByW3RdfSkpLHRoaXN9LGUuZW1pdD1mdW5jdGlvbih0LGUpe3RoaXMub3B0aW9ucy5kb21FdmVudHMmJmZ1bmN0aW9uKHQsZSl7dmFyIHI9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtyLmluaXRFdmVudCh0LCEwLCEwKSxyLmdlc3R1cmU9ZSxlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHIpfSh0LGUpO3ZhciByPXRoaXMuaGFuZGxlcnNbdF0mJnRoaXMuaGFuZGxlcnNbdF0uc2xpY2UoKTtpZihyJiZyLmxlbmd0aCl7ZS50eXBlPXQsZS5wcmV2ZW50RGVmYXVsdD1mdW5jdGlvbigpe2Uuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKX07Zm9yKHZhciBuPTA7bjxyLmxlbmd0aDspcltuXShlKSxuKyt9fSxlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLmVsZW1lbnQmJnJnKHRoaXMsITEpLHRoaXMuaGFuZGxlcnM9e30sdGhpcy5zZXNzaW9uPXt9LHRoaXMuaW5wdXQuZGVzdHJveSgpLHRoaXMuZWxlbWVudD1udWxsfSx0fSgpLGlnPXt0b3VjaHN0YXJ0OjEsdG91Y2htb3ZlOjIsdG91Y2hlbmQ6NCx0b3VjaGNhbmNlbDo4fSxvZz1cInRvdWNoc3RhcnRcIixhZz1cInRvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsXCIsdWc9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciByLG49ZS5wcm90b3R5cGU7cmV0dXJuIG4uZXZUYXJnZXQ9b2csbi5ldldpbj1hZywocj10LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcykuc3RhcnRlZD0hMSxyfXJldHVybiBBZChlLHQpLGUucHJvdG90eXBlLmhhbmRsZXI9ZnVuY3Rpb24odCl7dmFyIGU9aWdbdC50eXBlXTtpZigxPT09ZSYmKHRoaXMuc3RhcnRlZD0hMCksdGhpcy5zdGFydGVkKXt2YXIgcj1zZy5jYWxsKHRoaXMsdCxlKTsxMiZlJiZyWzBdLmxlbmd0aC1yWzFdLmxlbmd0aD09MCYmKHRoaXMuc3RhcnRlZD0hMSksdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsZSx7cG9pbnRlcnM6clswXSxjaGFuZ2VkUG9pbnRlcnM6clsxXSxwb2ludGVyVHlwZTpKZCxzcmNFdmVudDp0fSl9fSxlfShieSk7ZnVuY3Rpb24gc2codCxlKXt2YXIgcj1reSh0LnRvdWNoZXMpLG49a3kodC5jaGFuZ2VkVG91Y2hlcyk7cmV0dXJuIDEyJmUmJihyPVN5KHIuY29uY2F0KG4pLFwiaWRlbnRpZmllclwiLCEwKSksW3Isbl19ZnVuY3Rpb24gY2codCxlLHIpe3ZhciBuPVwiREVQUkVDQVRFRCBNRVRIT0Q6IFwiK2UrXCJcXG5cIityK1wiIEFUIFxcblwiO3JldHVybiBmdW5jdGlvbigpe3ZhciBlPW5ldyBFcnJvcihcImdldC1zdGFjay10cmFjZVwiKSxyPWUmJmUuc3RhY2s/ZS5zdGFjay5yZXBsYWNlKC9eW15cXChdKz9bXFxuJF0vZ20sXCJcIikucmVwbGFjZSgvXlxccythdFxccysvZ20sXCJcIikucmVwbGFjZSgvXk9iamVjdC48YW5vbnltb3VzPlxccypcXCgvZ20sXCJ7YW5vbnltb3VzfSgpQFwiKTpcIlVua25vd24gU3RhY2sgVHJhY2VcIixpPXdpbmRvdy5jb25zb2xlJiYod2luZG93LmNvbnNvbGUud2Fybnx8d2luZG93LmNvbnNvbGUubG9nKTtyZXR1cm4gaSYmaS5jYWxsKHdpbmRvdy5jb25zb2xlLG4sciksdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fXZhciBmZz1jZygoZnVuY3Rpb24odCxlLHIpe2Zvcih2YXIgbj1PYmplY3Qua2V5cyhlKSxpPTA7aTxuLmxlbmd0aDspKCFyfHxyJiZ2b2lkIDA9PT10W25baV1dKSYmKHRbbltpXV09ZVtuW2ldXSksaSsrO3JldHVybiB0fSksXCJleHRlbmRcIixcIlVzZSBgYXNzaWduYC5cIiksbGc9Y2coKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZnKHQsZSwhMCl9KSxcIm1lcmdlXCIsXCJVc2UgYGFzc2lnbmAuXCIpO2Z1bmN0aW9uIGhnKHQsZSxyKXt2YXIgbixpPWUucHJvdG90eXBlOyhuPXQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoaSkpLmNvbnN0cnVjdG9yPXQsbi5fc3VwZXI9aSxyJiZJZChuLHIpfWZ1bmN0aW9uIHBnKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkoZSxhcmd1bWVudHMpfX12YXIgdmc9ZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT17fSksbmV3IG5nKHQsU2Qoe3JlY29nbml6ZXJzOmVnLmNvbmNhdCgpfSxlKSl9O3JldHVybiB0LlZFUlNJT049XCIyLjAuMTctcmNcIix0LkRJUkVDVElPTl9BTEw9MzAsdC5ESVJFQ1RJT05fRE9XTj1RZCx0LkRJUkVDVElPTl9MRUZUPTIsdC5ESVJFQ1RJT05fUklHSFQ9NCx0LkRJUkVDVElPTl9VUD04LHQuRElSRUNUSU9OX0hPUklaT05UQUw9Nix0LkRJUkVDVElPTl9WRVJUSUNBTD1aZCx0LkRJUkVDVElPTl9OT05FPTEsdC5ESVJFQ1RJT05fRE9XTj1RZCx0LklOUFVUX1NUQVJUPTEsdC5JTlBVVF9NT1ZFPTIsdC5JTlBVVF9FTkQ9NCx0LklOUFVUX0NBTkNFTD04LHQuU1RBVEVfUE9TU0lCTEU9MSx0LlNUQVRFX0JFR0FOPTIsdC5TVEFURV9DSEFOR0VEPTQsdC5TVEFURV9FTkRFRD04LHQuU1RBVEVfUkVDT0dOSVpFRD04LHQuU1RBVEVfQ0FOQ0VMTEVEPTE2LHQuU1RBVEVfRkFJTEVEPVl5LHQuTWFuYWdlcj1uZyx0LklucHV0PWJ5LHQuVG91Y2hBY3Rpb249b3ksdC5Ub3VjaElucHV0PVB5LHQuTW91c2VJbnB1dD1SeSx0LlBvaW50ZXJFdmVudElucHV0PXh5LHQuVG91Y2hNb3VzZUlucHV0PXp5LHQuU2luZ2xlVG91Y2hJbnB1dD11Zyx0LlJlY29nbml6ZXI9V3ksdC5BdHRyUmVjb2duaXplcj1IeSx0LlRhcD1WeSx0LlBhbj1CeSx0LlN3aXBlPUp5LHQuUGluY2g9S3ksdC5Sb3RhdGU9UXksdC5QcmVzcz1aeSx0Lm9uPXl5LHQub2ZmPWd5LHQuZWFjaD1yeSx0Lm1lcmdlPWxnLHQuZXh0ZW5kPWZnLHQuYmluZEZuPXBnLHQuYXNzaWduPUlkLHQuaW5oZXJpdD1oZyx0LmJpbmRGbj1wZyx0LnByZWZpeGVkPUZkLHQudG9BcnJheT1reSx0LmluQXJyYXk9X3ksdC51bmlxdWVBcnJheT1TeSx0LnNwbGl0U3RyPWR5LHQuYm9vbE9yRm49bnksdC5oYXNQYXJlbnQ9YXksdC5hZGRFdmVudExpc3RlbmVycz15eSx0LnJlbW92ZUV2ZW50TGlzdGVuZXJzPWd5LHQuZGVmYXVsdHM9SWQoe30sdGcse3ByZXNldDplZ30pLHR9KCk7ZnVuY3Rpb24gZGcodCxlKXt2YXIgcj12b2lkIDAhPT1PaCYmaWModCl8fHRbXCJAQGl0ZXJhdG9yXCJdO2lmKCFyKXtpZihQaCh0KXx8KHI9ZnVuY3Rpb24odCxlKXt2YXIgcjtpZighdClyZXR1cm47aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIHlnKHQsZSk7dmFyIG49QWgocj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpLmNhbGwociw4LC0xKTtcIk9iamVjdFwiPT09biYmdC5jb25zdHJ1Y3RvciYmKG49dC5jb25zdHJ1Y3Rvci5uYW1lKTtpZihcIk1hcFwiPT09bnx8XCJTZXRcIj09PW4pcmV0dXJuIHFzKHQpO2lmKFwiQXJndW1lbnRzXCI9PT1ufHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSlyZXR1cm4geWcodCxlKX0odCkpfHxlJiZ0JiZcIm51bWJlclwiPT10eXBlb2YgdC5sZW5ndGgpe3ImJih0PXIpO3ZhciBuPTAsaT1mdW5jdGlvbigpe307cmV0dXJue3M6aSxuOmZ1bmN0aW9uKCl7cmV0dXJuIG4+PXQubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTp0W24rK119fSxlOmZ1bmN0aW9uKHQpe3Rocm93IHR9LGY6aX19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXZhciBvLGE9ITAsdT0hMTtyZXR1cm57czpmdW5jdGlvbigpe3I9ci5jYWxsKHQpfSxuOmZ1bmN0aW9uKCl7dmFyIHQ9ci5uZXh0KCk7cmV0dXJuIGE9dC5kb25lLHR9LGU6ZnVuY3Rpb24odCl7dT0hMCxvPXR9LGY6ZnVuY3Rpb24oKXt0cnl7YXx8bnVsbD09ci5yZXR1cm58fHIucmV0dXJuKCl9ZmluYWxseXtpZih1KXRocm93IG99fX19ZnVuY3Rpb24geWcodCxlKXsobnVsbD09ZXx8ZT50Lmxlbmd0aCkmJihlPXQubGVuZ3RoKTtmb3IodmFyIHI9MCxuPW5ldyBBcnJheShlKTtyPGU7cisrKW5bcl09dFtyXTtyZXR1cm4gbn12YXIgZ2c9T2goXCJERUxFVEVcIik7ZnVuY3Rpb24gbWcoKXt2YXIgdD1iZy5hcHBseSh2b2lkIDAsYXJndW1lbnRzKTtyZXR1cm4gd2codCksdH1mdW5jdGlvbiBiZygpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLGU9bmV3IEFycmF5KHQpLHI9MDtyPHQ7cisrKWVbcl09YXJndW1lbnRzW3JdO2lmKGUubGVuZ3RoPDIpcmV0dXJuIGVbMF07dmFyIG47aWYoZS5sZW5ndGg+MilyZXR1cm4gYmcuYXBwbHkodm9pZCAwLFNoKG49W21nKGVbMF0sZVsxXSldKS5jYWxsKG4sd2goQWgoZSkuY2FsbChlLDIpKSkpO3ZhciBpLG89ZVswXSxhPWVbMV0sdT1kZyhqaChhKSk7dHJ5e2Zvcih1LnMoKTshKGk9dS5uKCkpLmRvbmU7KXt2YXIgcz1pLnZhbHVlO09iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChhLHMpJiYoYVtzXT09PWdnP2RlbGV0ZSBvW3NdOm51bGw9PT1vW3NdfHxudWxsPT09YVtzXXx8XCJvYmplY3RcIiE9PV9oKG9bc10pfHxcIm9iamVjdFwiIT09X2goYVtzXSl8fFBoKG9bc10pfHxQaChhW3NdKT9vW3NdPV9nKGFbc10pOm9bc109Ymcob1tzXSxhW3NdKSl9fWNhdGNoKHQpe3UuZSh0KX1maW5hbGx5e3UuZigpfXJldHVybiBvfWZ1bmN0aW9uIF9nKHQpe3JldHVybiBQaCh0KT9SaSh0KS5jYWxsKHQsKGZ1bmN0aW9uKHQpe3JldHVybiBfZyh0KX0pKTpcIm9iamVjdFwiPT09X2godCkmJm51bGwhPT10P2JnKHt9LHQpOnR9ZnVuY3Rpb24gd2codCl7Zm9yKHZhciBlPTAscj1MaCh0KTtlPHIubGVuZ3RoO2UrKyl7dmFyIG49cltlXTt0W25dPT09Z2c/ZGVsZXRlIHRbbl06XCJvYmplY3RcIj09PV9oKHRbbl0pJiZudWxsIT09dFtuXSYmd2codFtuXSl9fXZhciBPZz1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5IYW1tZXJ8fHZnOmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24oKXt9O3JldHVybntvbjp0LG9mZjp0LGRlc3Ryb3k6dCxlbWl0OnQsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJue3NldDp0fX19fSgpfTtmdW5jdGlvbiBFZyh0KXt2YXIgZSxyPXRoaXM7dGhpcy5fY2xlYW51cFF1ZXVlPVtdLHRoaXMuYWN0aXZlPSExLHRoaXMuX2RvbT17Y29udGFpbmVyOnQsb3ZlcmxheTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpfSx0aGlzLl9kb20ub3ZlcmxheS5jbGFzc0xpc3QuYWRkKFwidmlzLW92ZXJsYXlcIiksdGhpcy5fZG9tLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kb20ub3ZlcmxheSksdGhpcy5fY2xlYW51cFF1ZXVlLnB1c2goKGZ1bmN0aW9uKCl7ci5fZG9tLm92ZXJsYXkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyLl9kb20ub3ZlcmxheSl9KSk7dmFyIG49T2codGhpcy5fZG9tLm92ZXJsYXkpO24ub24oXCJ0YXBcIixlbihlPXRoaXMuX29uVGFwT3ZlcmxheSkuY2FsbChlLHRoaXMpKSx0aGlzLl9jbGVhbnVwUXVldWUucHVzaCgoZnVuY3Rpb24oKXtuLmRlc3Ryb3koKX0pKTt2YXIgaT1bXCJ0YXBcIixcImRvdWJsZXRhcFwiLFwicHJlc3NcIixcInBpbmNoXCIsXCJwYW5cIixcInBhbnN0YXJ0XCIsXCJwYW5tb3ZlXCIsXCJwYW5lbmRcIl07SGgoaSkuY2FsbChpLChmdW5jdGlvbih0KXtuLm9uKHQsKGZ1bmN0aW9uKHQpe3Quc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCl9KSl9KSksZG9jdW1lbnQmJmRvY3VtZW50LmJvZHkmJih0aGlzLl9vbkNsaWNrPWZ1bmN0aW9uKGUpeyhmdW5jdGlvbih0LGUpe2Zvcig7dDspe2lmKHQ9PT1lKXJldHVybiEwO3Q9dC5wYXJlbnROb2RlfXJldHVybiExfSkoZS50YXJnZXQsdCl8fHIuZGVhY3RpdmF0ZSgpfSxkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX29uQ2xpY2spLHRoaXMuX2NsZWFudXBRdWV1ZS5wdXNoKChmdW5jdGlvbigpe2RvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsci5fb25DbGljayl9KSkpLHRoaXMuX2VzY0xpc3RlbmVyPWZ1bmN0aW9uKHQpeyhcImtleVwiaW4gdD9cIkVzY2FwZVwiPT09dC5rZXk6Mjc9PT10LmtleUNvZGUpJiZyLmRlYWN0aXZhdGUoKX19a2QoRWcucHJvdG90eXBlKSxFZy5jdXJyZW50PW51bGwsRWcucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt2YXIgdCxlO3RoaXMuZGVhY3RpdmF0ZSgpO3ZhciByLG49ZGcocnAodD13cChlPXRoaXMuX2NsZWFudXBRdWV1ZSkuY2FsbChlLDApKS5jYWxsKHQpKTt0cnl7Zm9yKG4ucygpOyEocj1uLm4oKSkuZG9uZTspeygwLHIudmFsdWUpKCl9fWNhdGNoKHQpe24uZSh0KX1maW5hbGx5e24uZigpfX0sRWcucHJvdG90eXBlLmFjdGl2YXRlPWZ1bmN0aW9uKCl7RWcuY3VycmVudCYmRWcuY3VycmVudC5kZWFjdGl2YXRlKCksRWcuY3VycmVudD10aGlzLHRoaXMuYWN0aXZlPSEwLHRoaXMuX2RvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy5fZG9tLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidmlzLWFjdGl2ZVwiKSx0aGlzLmVtaXQoXCJjaGFuZ2VcIiksdGhpcy5lbWl0KFwiYWN0aXZhdGVcIiksZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMuX2VzY0xpc3RlbmVyKX0sRWcucHJvdG90eXBlLmRlYWN0aXZhdGU9ZnVuY3Rpb24oKXt0aGlzLmFjdGl2ZT0hMSx0aGlzLl9kb20ub3ZlcmxheS5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIix0aGlzLl9kb20uY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJ2aXMtYWN0aXZlXCIpLGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLl9lc2NMaXN0ZW5lciksdGhpcy5lbWl0KFwiY2hhbmdlXCIpLHRoaXMuZW1pdChcImRlYWN0aXZhdGVcIil9LEVnLnByb3RvdHlwZS5fb25UYXBPdmVybGF5PWZ1bmN0aW9uKHQpe3RoaXMuYWN0aXZhdGUoKSx0LnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpfTt2YXIgVGc9bmkseGc9d3Qsa2c9by5UeXBlRXJyb3IsU2c9VHIsQWc9aCxqZz1IcixQZz1mdW5jdGlvbih0KXtpZihUZyh0KSlyZXR1cm4gdDt0aHJvdyBrZyh4Zyh0KStcIiBpcyBub3QgYSBjb25zdHJ1Y3RvclwiKX0sSWc9UWUsRGc9JCxMZz1NYSxDZz1hLFJnPXR0KFwiUmVmbGVjdFwiLFwiY29uc3RydWN0XCIpLE1nPU9iamVjdC5wcm90b3R5cGUsRmc9W10ucHVzaCxOZz1DZygoZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiEoUmcoKGZ1bmN0aW9uKCl7fSksW10sdClpbnN0YW5jZW9mIHQpfSkpLHpnPSFDZygoZnVuY3Rpb24oKXtSZygoZnVuY3Rpb24oKXt9KSl9KSkscWc9Tmd8fHpnO1NnKHt0YXJnZXQ6XCJSZWZsZWN0XCIsc3RhdDohMCxmb3JjZWQ6cWcsc2hhbTpxZ30se2NvbnN0cnVjdDpmdW5jdGlvbih0LGUpe1BnKHQpLElnKGUpO3ZhciByPWFyZ3VtZW50cy5sZW5ndGg8Mz90OlBnKGFyZ3VtZW50c1syXSk7aWYoemcmJiFOZylyZXR1cm4gUmcodCxlLHIpO2lmKHQ9PXIpe3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBuZXcgdDtjYXNlIDE6cmV0dXJuIG5ldyB0KGVbMF0pO2Nhc2UgMjpyZXR1cm4gbmV3IHQoZVswXSxlWzFdKTtjYXNlIDM6cmV0dXJuIG5ldyB0KGVbMF0sZVsxXSxlWzJdKTtjYXNlIDQ6cmV0dXJuIG5ldyB0KGVbMF0sZVsxXSxlWzJdLGVbM10pfXZhciBuPVtudWxsXTtyZXR1cm4gQWcoRmcsbixlKSxuZXcoQWcoamcsdCxuKSl9dmFyIGk9ci5wcm90b3R5cGUsbz1MZyhEZyhpKT9pOk1nKSxhPUFnKHQsbyxlKTtyZXR1cm4gRGcoYSk/YTpvfX0pO3ZhciBZZz1CLlJlZmxlY3QuY29uc3RydWN0O2Z1bmN0aW9uIEdnKHQpe2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiB0fXZhciBYZz1xdjtUcih7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMH0se3NldFByb3RvdHlwZU9mOlN1fSk7dmFyIFVnPUIuT2JqZWN0LnNldFByb3RvdHlwZU9mO2Z1bmN0aW9uIFdnKHQsZSl7cmV0dXJuIFdnPVVnfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9LFdnKHQsZSl9ZnVuY3Rpb24gVmcodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7dC5wcm90b3R5cGU9WGcoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxJcih0LFwicHJvdG90eXBlXCIse3dyaXRhYmxlOiExfSksZSYmV2codCxlKX1mdW5jdGlvbiBIZyh0LGUpe2lmKGUmJihcIm9iamVjdFwiPT09X2goZSl8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGUpKXJldHVybiBlO2lmKHZvaWQgMCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO3JldHVybiBHZyh0KX12YXIgJGc9WnA7ZnVuY3Rpb24gQmcodCl7cmV0dXJuIEJnPVVnPyRnOmZ1bmN0aW9uKHQpe3JldHVybiB0Ll9fcHJvdG9fX3x8JGcodCl9LEJnKHQpfXZhciBKZz17ZXhwb3J0czp7fX07IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKHQpe3ZhciBlLHI9T2JqZWN0LnByb3RvdHlwZSxuPXIuaGFzT3duUHJvcGVydHksaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2w/U3ltYm9sOnt9LG89aS5pdGVyYXRvcnx8XCJAQGl0ZXJhdG9yXCIsYT1pLmFzeW5jSXRlcmF0b3J8fFwiQEBhc3luY0l0ZXJhdG9yXCIsdT1pLnRvU3RyaW5nVGFnfHxcIkBAdG9TdHJpbmdUYWdcIjtmdW5jdGlvbiBzKHQsZSxyKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6cixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pLHRbZV19dHJ5e3Moe30sXCJcIil9Y2F0Y2godCl7cz1mdW5jdGlvbih0LGUscil7cmV0dXJuIHRbZV09cn19ZnVuY3Rpb24gYyh0LGUscixuKXt2YXIgaT1lJiZlLnByb3RvdHlwZSBpbnN0YW5jZW9mIHk/ZTp5LG89T2JqZWN0LmNyZWF0ZShpLnByb3RvdHlwZSksYT1uZXcgQShufHxbXSk7cmV0dXJuIG8uX2ludm9rZT1mdW5jdGlvbih0LGUscil7dmFyIG49bDtyZXR1cm4gZnVuY3Rpb24oaSxvKXtpZihuPT09cCl0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO2lmKG49PT12KXtpZihcInRocm93XCI9PT1pKXRocm93IG87cmV0dXJuIFAoKX1mb3Ioci5tZXRob2Q9aSxyLmFyZz1vOzspe3ZhciBhPXIuZGVsZWdhdGU7aWYoYSl7dmFyIHU9eChhLHIpO2lmKHUpe2lmKHU9PT1kKWNvbnRpbnVlO3JldHVybiB1fX1pZihcIm5leHRcIj09PXIubWV0aG9kKXIuc2VudD1yLl9zZW50PXIuYXJnO2Vsc2UgaWYoXCJ0aHJvd1wiPT09ci5tZXRob2Qpe2lmKG49PT1sKXRocm93IG49dixyLmFyZztyLmRpc3BhdGNoRXhjZXB0aW9uKHIuYXJnKX1lbHNlXCJyZXR1cm5cIj09PXIubWV0aG9kJiZyLmFicnVwdChcInJldHVyblwiLHIuYXJnKTtuPXA7dmFyIHM9Zih0LGUscik7aWYoXCJub3JtYWxcIj09PXMudHlwZSl7aWYobj1yLmRvbmU/djpoLHMuYXJnPT09ZCljb250aW51ZTtyZXR1cm57dmFsdWU6cy5hcmcsZG9uZTpyLmRvbmV9fVwidGhyb3dcIj09PXMudHlwZSYmKG49dixyLm1ldGhvZD1cInRocm93XCIsci5hcmc9cy5hcmcpfX19KHQscixhKSxvfWZ1bmN0aW9uIGYodCxlLHIpe3RyeXtyZXR1cm57dHlwZTpcIm5vcm1hbFwiLGFyZzp0LmNhbGwoZSxyKX19Y2F0Y2godCl7cmV0dXJue3R5cGU6XCJ0aHJvd1wiLGFyZzp0fX19dC53cmFwPWM7dmFyIGw9XCJzdXNwZW5kZWRTdGFydFwiLGg9XCJzdXNwZW5kZWRZaWVsZFwiLHA9XCJleGVjdXRpbmdcIix2PVwiY29tcGxldGVkXCIsZD17fTtmdW5jdGlvbiB5KCl7fWZ1bmN0aW9uIGcoKXt9ZnVuY3Rpb24gbSgpe312YXIgYj17fTtzKGIsbywoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pKTt2YXIgXz1PYmplY3QuZ2V0UHJvdG90eXBlT2Ysdz1fJiZfKF8oaihbXSkpKTt3JiZ3IT09ciYmbi5jYWxsKHcsbykmJihiPXcpO3ZhciBPPW0ucHJvdG90eXBlPXkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoYik7ZnVuY3Rpb24gRSh0KXtbXCJuZXh0XCIsXCJ0aHJvd1wiLFwicmV0dXJuXCJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ModCxlLChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5faW52b2tlKGUsdCl9KSl9KSl9ZnVuY3Rpb24gVCh0LGUpe2Z1bmN0aW9uIHIoaSxvLGEsdSl7dmFyIHM9Zih0W2ldLHQsbyk7aWYoXCJ0aHJvd1wiIT09cy50eXBlKXt2YXIgYz1zLmFyZyxsPWMudmFsdWU7cmV0dXJuIGwmJlwib2JqZWN0XCI9PXR5cGVvZiBsJiZuLmNhbGwobCxcIl9fYXdhaXRcIik/ZS5yZXNvbHZlKGwuX19hd2FpdCkudGhlbigoZnVuY3Rpb24odCl7cihcIm5leHRcIix0LGEsdSl9KSwoZnVuY3Rpb24odCl7cihcInRocm93XCIsdCxhLHUpfSkpOmUucmVzb2x2ZShsKS50aGVuKChmdW5jdGlvbih0KXtjLnZhbHVlPXQsYShjKX0pLChmdW5jdGlvbih0KXtyZXR1cm4gcihcInRocm93XCIsdCxhLHUpfSkpfXUocy5hcmcpfXZhciBpO3RoaXMuX2ludm9rZT1mdW5jdGlvbih0LG4pe2Z1bmN0aW9uIG8oKXtyZXR1cm4gbmV3IGUoKGZ1bmN0aW9uKGUsaSl7cih0LG4sZSxpKX0pKX1yZXR1cm4gaT1pP2kudGhlbihvLG8pOm8oKX19ZnVuY3Rpb24geCh0LHIpe3ZhciBuPXQuaXRlcmF0b3Jbci5tZXRob2RdO2lmKG49PT1lKXtpZihyLmRlbGVnYXRlPW51bGwsXCJ0aHJvd1wiPT09ci5tZXRob2Qpe2lmKHQuaXRlcmF0b3IucmV0dXJuJiYoci5tZXRob2Q9XCJyZXR1cm5cIixyLmFyZz1lLHgodCxyKSxcInRocm93XCI9PT1yLm1ldGhvZCkpcmV0dXJuIGQ7ci5tZXRob2Q9XCJ0aHJvd1wiLHIuYXJnPW5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpfXJldHVybiBkfXZhciBpPWYobix0Lml0ZXJhdG9yLHIuYXJnKTtpZihcInRocm93XCI9PT1pLnR5cGUpcmV0dXJuIHIubWV0aG9kPVwidGhyb3dcIixyLmFyZz1pLmFyZyxyLmRlbGVnYXRlPW51bGwsZDt2YXIgbz1pLmFyZztyZXR1cm4gbz9vLmRvbmU/KHJbdC5yZXN1bHROYW1lXT1vLnZhbHVlLHIubmV4dD10Lm5leHRMb2MsXCJyZXR1cm5cIiE9PXIubWV0aG9kJiYoci5tZXRob2Q9XCJuZXh0XCIsci5hcmc9ZSksci5kZWxlZ2F0ZT1udWxsLGQpOm86KHIubWV0aG9kPVwidGhyb3dcIixyLmFyZz1uZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksci5kZWxlZ2F0ZT1udWxsLGQpfWZ1bmN0aW9uIGsodCl7dmFyIGU9e3RyeUxvYzp0WzBdfTsxIGluIHQmJihlLmNhdGNoTG9jPXRbMV0pLDIgaW4gdCYmKGUuZmluYWxseUxvYz10WzJdLGUuYWZ0ZXJMb2M9dFszXSksdGhpcy50cnlFbnRyaWVzLnB1c2goZSl9ZnVuY3Rpb24gUyh0KXt2YXIgZT10LmNvbXBsZXRpb258fHt9O2UudHlwZT1cIm5vcm1hbFwiLGRlbGV0ZSBlLmFyZyx0LmNvbXBsZXRpb249ZX1mdW5jdGlvbiBBKHQpe3RoaXMudHJ5RW50cmllcz1be3RyeUxvYzpcInJvb3RcIn1dLHQuZm9yRWFjaChrLHRoaXMpLHRoaXMucmVzZXQoITApfWZ1bmN0aW9uIGoodCl7aWYodCl7dmFyIHI9dFtvXTtpZihyKXJldHVybiByLmNhbGwodCk7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5uZXh0KXJldHVybiB0O2lmKCFpc05hTih0Lmxlbmd0aCkpe3ZhciBpPS0xLGE9ZnVuY3Rpb24gcigpe2Zvcig7KytpPHQubGVuZ3RoOylpZihuLmNhbGwodCxpKSlyZXR1cm4gci52YWx1ZT10W2ldLHIuZG9uZT0hMSxyO3JldHVybiByLnZhbHVlPWUsci5kb25lPSEwLHJ9O3JldHVybiBhLm5leHQ9YX19cmV0dXJue25leHQ6UH19ZnVuY3Rpb24gUCgpe3JldHVybnt2YWx1ZTplLGRvbmU6ITB9fXJldHVybiBnLnByb3RvdHlwZT1tLHMoTyxcImNvbnN0cnVjdG9yXCIsbSkscyhtLFwiY29uc3RydWN0b3JcIixnKSxnLmRpc3BsYXlOYW1lPXMobSx1LFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksdC5pc0dlbmVyYXRvckZ1bmN0aW9uPWZ1bmN0aW9uKHQpe3ZhciBlPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJnQuY29uc3RydWN0b3I7cmV0dXJuISFlJiYoZT09PWd8fFwiR2VuZXJhdG9yRnVuY3Rpb25cIj09PShlLmRpc3BsYXlOYW1lfHxlLm5hbWUpKX0sdC5tYXJrPWZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsbSk6KHQuX19wcm90b19fPW0scyh0LHUsXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksdC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShPKSx0fSx0LmF3cmFwPWZ1bmN0aW9uKHQpe3JldHVybntfX2F3YWl0OnR9fSxFKFQucHJvdG90eXBlKSxzKFQucHJvdG90eXBlLGEsKGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSksdC5Bc3luY0l0ZXJhdG9yPVQsdC5hc3luYz1mdW5jdGlvbihlLHIsbixpLG8pe3ZvaWQgMD09PW8mJihvPVByb21pc2UpO3ZhciBhPW5ldyBUKGMoZSxyLG4saSksbyk7cmV0dXJuIHQuaXNHZW5lcmF0b3JGdW5jdGlvbihyKT9hOmEubmV4dCgpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRvbmU/dC52YWx1ZTphLm5leHQoKX0pKX0sRShPKSxzKE8sdSxcIkdlbmVyYXRvclwiKSxzKE8sbywoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pKSxzKE8sXCJ0b1N0cmluZ1wiLChmdW5jdGlvbigpe3JldHVyblwiW29iamVjdCBHZW5lcmF0b3JdXCJ9KSksdC5rZXlzPWZ1bmN0aW9uKHQpe3ZhciBlPVtdO2Zvcih2YXIgciBpbiB0KWUucHVzaChyKTtyZXR1cm4gZS5yZXZlcnNlKCksZnVuY3Rpb24gcigpe2Zvcig7ZS5sZW5ndGg7KXt2YXIgbj1lLnBvcCgpO2lmKG4gaW4gdClyZXR1cm4gci52YWx1ZT1uLHIuZG9uZT0hMSxyfXJldHVybiByLmRvbmU9ITAscn19LHQudmFsdWVzPWosQS5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOkEscmVzZXQ6ZnVuY3Rpb24odCl7aWYodGhpcy5wcmV2PTAsdGhpcy5uZXh0PTAsdGhpcy5zZW50PXRoaXMuX3NlbnQ9ZSx0aGlzLmRvbmU9ITEsdGhpcy5kZWxlZ2F0ZT1udWxsLHRoaXMubWV0aG9kPVwibmV4dFwiLHRoaXMuYXJnPWUsdGhpcy50cnlFbnRyaWVzLmZvckVhY2goUyksIXQpZm9yKHZhciByIGluIHRoaXMpXCJ0XCI9PT1yLmNoYXJBdCgwKSYmbi5jYWxsKHRoaXMscikmJiFpc05hTigrci5zbGljZSgxKSkmJih0aGlzW3JdPWUpfSxzdG9wOmZ1bmN0aW9uKCl7dGhpcy5kb25lPSEwO3ZhciB0PXRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uO2lmKFwidGhyb3dcIj09PXQudHlwZSl0aHJvdyB0LmFyZztyZXR1cm4gdGhpcy5ydmFsfSxkaXNwYXRjaEV4Y2VwdGlvbjpmdW5jdGlvbih0KXtpZih0aGlzLmRvbmUpdGhyb3cgdDt2YXIgcj10aGlzO2Z1bmN0aW9uIGkobixpKXtyZXR1cm4gdS50eXBlPVwidGhyb3dcIix1LmFyZz10LHIubmV4dD1uLGkmJihyLm1ldGhvZD1cIm5leHRcIixyLmFyZz1lKSwhIWl9Zm9yKHZhciBvPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtvPj0wOy0tbyl7dmFyIGE9dGhpcy50cnlFbnRyaWVzW29dLHU9YS5jb21wbGV0aW9uO2lmKFwicm9vdFwiPT09YS50cnlMb2MpcmV0dXJuIGkoXCJlbmRcIik7aWYoYS50cnlMb2M8PXRoaXMucHJldil7dmFyIHM9bi5jYWxsKGEsXCJjYXRjaExvY1wiKSxjPW4uY2FsbChhLFwiZmluYWxseUxvY1wiKTtpZihzJiZjKXtpZih0aGlzLnByZXY8YS5jYXRjaExvYylyZXR1cm4gaShhLmNhdGNoTG9jLCEwKTtpZih0aGlzLnByZXY8YS5maW5hbGx5TG9jKXJldHVybiBpKGEuZmluYWxseUxvYyl9ZWxzZSBpZihzKXtpZih0aGlzLnByZXY8YS5jYXRjaExvYylyZXR1cm4gaShhLmNhdGNoTG9jLCEwKX1lbHNle2lmKCFjKXRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO2lmKHRoaXMucHJldjxhLmZpbmFsbHlMb2MpcmV0dXJuIGkoYS5maW5hbGx5TG9jKX19fX0sYWJydXB0OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtyPj0wOy0tcil7dmFyIGk9dGhpcy50cnlFbnRyaWVzW3JdO2lmKGkudHJ5TG9jPD10aGlzLnByZXYmJm4uY2FsbChpLFwiZmluYWxseUxvY1wiKSYmdGhpcy5wcmV2PGkuZmluYWxseUxvYyl7dmFyIG89aTticmVha319byYmKFwiYnJlYWtcIj09PXR8fFwiY29udGludWVcIj09PXQpJiZvLnRyeUxvYzw9ZSYmZTw9by5maW5hbGx5TG9jJiYobz1udWxsKTt2YXIgYT1vP28uY29tcGxldGlvbjp7fTtyZXR1cm4gYS50eXBlPXQsYS5hcmc9ZSxvPyh0aGlzLm1ldGhvZD1cIm5leHRcIix0aGlzLm5leHQ9by5maW5hbGx5TG9jLGQpOnRoaXMuY29tcGxldGUoYSl9LGNvbXBsZXRlOmZ1bmN0aW9uKHQsZSl7aWYoXCJ0aHJvd1wiPT09dC50eXBlKXRocm93IHQuYXJnO3JldHVyblwiYnJlYWtcIj09PXQudHlwZXx8XCJjb250aW51ZVwiPT09dC50eXBlP3RoaXMubmV4dD10LmFyZzpcInJldHVyblwiPT09dC50eXBlPyh0aGlzLnJ2YWw9dGhpcy5hcmc9dC5hcmcsdGhpcy5tZXRob2Q9XCJyZXR1cm5cIix0aGlzLm5leHQ9XCJlbmRcIik6XCJub3JtYWxcIj09PXQudHlwZSYmZSYmKHRoaXMubmV4dD1lKSxkfSxmaW5pc2g6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtlPj0wOy0tZSl7dmFyIHI9dGhpcy50cnlFbnRyaWVzW2VdO2lmKHIuZmluYWxseUxvYz09PXQpcmV0dXJuIHRoaXMuY29tcGxldGUoci5jb21wbGV0aW9uLHIuYWZ0ZXJMb2MpLFMociksZH19LGNhdGNoOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnRyeUVudHJpZXMubGVuZ3RoLTE7ZT49MDstLWUpe3ZhciByPXRoaXMudHJ5RW50cmllc1tlXTtpZihyLnRyeUxvYz09PXQpe3ZhciBuPXIuY29tcGxldGlvbjtpZihcInRocm93XCI9PT1uLnR5cGUpe3ZhciBpPW4uYXJnO1Mocil9cmV0dXJuIGl9fXRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKX0sZGVsZWdhdGVZaWVsZDpmdW5jdGlvbih0LHIsbil7cmV0dXJuIHRoaXMuZGVsZWdhdGU9e2l0ZXJhdG9yOmoodCkscmVzdWx0TmFtZTpyLG5leHRMb2M6bn0sXCJuZXh0XCI9PT10aGlzLm1ldGhvZCYmKHRoaXMuYXJnPWUpLGR9fSx0fSh0LmV4cG9ydHMpO3RyeXtyZWdlbmVyYXRvclJ1bnRpbWU9ZX1jYXRjaCh0KXtcIm9iamVjdFwiPT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZT1lOkZ1bmN0aW9uKFwiclwiLFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShlKX19KEpnKTt2YXIgS2c9SmcuZXhwb3J0cyxRZz17ZXhwb3J0czp7fX0sWmc9YSgoZnVuY3Rpb24oKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBBcnJheUJ1ZmZlcil7dmFyIHQ9bmV3IEFycmF5QnVmZmVyKDgpO09iamVjdC5pc0V4dGVuc2libGUodCkmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiYVwiLHt2YWx1ZTo4fSl9fSkpLHRtPWEsZW09JCxybT1SLG5tPVpnLGltPU9iamVjdC5pc0V4dGVuc2libGUsb209dG0oKGZ1bmN0aW9uKCl7aW0oMSl9KSl8fG5tP2Z1bmN0aW9uKHQpe3JldHVybiEhZW0odCkmJigoIW5tfHxcIkFycmF5QnVmZmVyXCIhPXJtKHQpKSYmKCFpbXx8aW0odCkpKX06aW0sYW09IWEoKGZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSl9KSksdW09VHIsc209bSxjbT1FbyxmbT0kLGxtPVV0LGhtPVZlLmYscG09b2Msdm09c2MsZG09b20seW09YW0sZ209ITEsbW09QnQoXCJtZXRhXCIpLGJtPTAsX209ZnVuY3Rpb24odCl7aG0odCxtbSx7dmFsdWU6e29iamVjdElEOlwiT1wiK2JtKyssd2Vha0RhdGE6e319fSl9LHdtPVFnLmV4cG9ydHM9e2VuYWJsZTpmdW5jdGlvbigpe3dtLmVuYWJsZT1mdW5jdGlvbigpe30sZ209ITA7dmFyIHQ9cG0uZixlPXNtKFtdLnNwbGljZSkscj17fTtyW21tXT0xLHQocikubGVuZ3RoJiYocG0uZj1mdW5jdGlvbihyKXtmb3IodmFyIG49dChyKSxpPTAsbz1uLmxlbmd0aDtpPG87aSsrKWlmKG5baV09PT1tbSl7ZShuLGksMSk7YnJlYWt9cmV0dXJuIG59LHVtKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDohMH0se2dldE93blByb3BlcnR5TmFtZXM6dm0uZn0pKX0sZmFzdEtleTpmdW5jdGlvbih0LGUpe2lmKCFmbSh0KSlyZXR1cm5cInN5bWJvbFwiPT10eXBlb2YgdD90OihcInN0cmluZ1wiPT10eXBlb2YgdD9cIlNcIjpcIlBcIikrdDtpZighbG0odCxtbSkpe2lmKCFkbSh0KSlyZXR1cm5cIkZcIjtpZighZSlyZXR1cm5cIkVcIjtfbSh0KX1yZXR1cm4gdFttbV0ub2JqZWN0SUR9LGdldFdlYWtEYXRhOmZ1bmN0aW9uKHQsZSl7aWYoIWxtKHQsbW0pKXtpZighZG0odCkpcmV0dXJuITA7aWYoIWUpcmV0dXJuITE7X20odCl9cmV0dXJuIHRbbW1dLndlYWtEYXRhfSxvbkZyZWV6ZTpmdW5jdGlvbih0KXtyZXR1cm4geW0mJmdtJiZkbSh0KSYmIWxtKHQsbW0pJiZfbSh0KSx0fX07Y21bbW1dPSEwO3ZhciBPbT1XZSxFbT1ULFRtPVFlLHhtPXd0LGttPW9zLFNtPWNuLEFtPWV0LGptPXdzLFBtPXZzLEltPVp1LERtPW8uVHlwZUVycm9yLExtPWZ1bmN0aW9uKHQsZSl7dGhpcy5zdG9wcGVkPXQsdGhpcy5yZXN1bHQ9ZX0sQ209TG0ucHJvdG90eXBlLFJtPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbixpLG8sYSx1LHMsYyxmPXImJnIudGhhdCxsPSEoIXJ8fCFyLkFTX0VOVFJJRVMpLGg9ISghcnx8IXIuSVNfSVRFUkFUT1IpLHA9ISghcnx8IXIuSU5URVJSVVBURUQpLHY9T20oZSxmKSxkPWZ1bmN0aW9uKHQpe3JldHVybiBuJiZJbShuLFwibm9ybWFsXCIsdCksbmV3IExtKCEwLHQpfSx5PWZ1bmN0aW9uKHQpe3JldHVybiBsPyhUbSh0KSxwP3YodFswXSx0WzFdLGQpOnYodFswXSx0WzFdKSk6cD92KHQsZCk6dih0KX07aWYoaCluPXQ7ZWxzZXtpZighKGk9UG0odCkpKXRocm93IERtKHhtKHQpK1wiIGlzIG5vdCBpdGVyYWJsZVwiKTtpZihrbShpKSl7Zm9yKG89MCxhPVNtKHQpO2E+bztvKyspaWYoKHU9eSh0W29dKSkmJkFtKENtLHUpKXJldHVybiB1O3JldHVybiBuZXcgTG0oITEpfW49am0odCxpKX1mb3Iocz1uLm5leHQ7IShjPUVtKHMsbikpLmRvbmU7KXt0cnl7dT15KGMudmFsdWUpfWNhdGNoKHQpe0ltKG4sXCJ0aHJvd1wiLHQpfWlmKFwib2JqZWN0XCI9PXR5cGVvZiB1JiZ1JiZBbShDbSx1KSlyZXR1cm4gdX1yZXR1cm4gbmV3IExtKCExKX0sTW09ZXQsRm09by5UeXBlRXJyb3IsTm09ZnVuY3Rpb24odCxlKXtpZihNbShlLHQpKXJldHVybiB0O3Rocm93IEZtKFwiSW5jb3JyZWN0IGludm9jYXRpb25cIil9LHptPVRyLHFtPW8sWW09UWcuZXhwb3J0cyxHbT1hLFhtPWhyLFVtPVJtLFdtPU5tLFZtPWIsSG09JCwkbT1odSxCbT1WZS5mLEptPWJpLmZvckVhY2gsS209dyxRbT1Zby5zZXQsWm09WW8uZ2V0dGVyRm9yLHRiPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbixpPS0xIT09dC5pbmRleE9mKFwiTWFwXCIpLG89LTEhPT10LmluZGV4T2YoXCJXZWFrXCIpLGE9aT9cInNldFwiOlwiYWRkXCIsdT1xbVt0XSxzPXUmJnUucHJvdG90eXBlLGM9e307aWYoS20mJlZtKHUpJiYob3x8cy5mb3JFYWNoJiYhR20oKGZ1bmN0aW9uKCl7KG5ldyB1KS5lbnRyaWVzKCkubmV4dCgpfSkpKSl7dmFyIGY9KG49ZSgoZnVuY3Rpb24oZSxyKXtRbShXbShlLGYpLHt0eXBlOnQsY29sbGVjdGlvbjpuZXcgdX0pLG51bGwhPXImJlVtKHIsZVthXSx7dGhhdDplLEFTX0VOVFJJRVM6aX0pfSkpKS5wcm90b3R5cGUsbD1abSh0KTtKbShbXCJhZGRcIixcImNsZWFyXCIsXCJkZWxldGVcIixcImZvckVhY2hcIixcImdldFwiLFwiaGFzXCIsXCJzZXRcIixcImtleXNcIixcInZhbHVlc1wiLFwiZW50cmllc1wiXSwoZnVuY3Rpb24odCl7dmFyIGU9XCJhZGRcIj09dHx8XCJzZXRcIj09dDshKHQgaW4gcyl8fG8mJlwiY2xlYXJcIj09dHx8WG0oZix0LChmdW5jdGlvbihyLG4pe3ZhciBpPWwodGhpcykuY29sbGVjdGlvbjtpZighZSYmbyYmIUhtKHIpKXJldHVyblwiZ2V0XCI9PXQmJnZvaWQgMDt2YXIgYT1pW3RdKDA9PT1yPzA6cixuKTtyZXR1cm4gZT90aGlzOmF9KSl9KSksb3x8Qm0oZixcInNpemVcIix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBsKHRoaXMpLmNvbGxlY3Rpb24uc2l6ZX19KX1lbHNlIG49ci5nZXRDb25zdHJ1Y3RvcihlLHQsaSxhKSxZbS5lbmFibGUoKTtyZXR1cm4gJG0obix0LCExLCEwKSxjW3RdPW4sem0oe2dsb2JhbDohMCxmb3JjZWQ6ITB9LGMpLG98fHIuc2V0U3Ryb25nKG4sdCxpKSxufSxlYj0kYSxyYj10dCxuYj1WZSxpYj13LG9iPWFlKFwic3BlY2llc1wiKSxhYj1WZS5mLHViPU1hLHNiPWZ1bmN0aW9uKHQsZSxyKXtmb3IodmFyIG4gaW4gZSlyJiZyLnVuc2FmZSYmdFtuXT90W25dPWVbbl06ZWIodCxuLGVbbl0scik7cmV0dXJuIHR9LGNiPVdlLGZiPU5tLGxiPVJtLGhiPUd1LHBiPWZ1bmN0aW9uKHQpe3ZhciBlPXJiKHQpLHI9bmIuZjtpYiYmZSYmIWVbb2JdJiZyKGUsb2Ise2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc319KX0sdmI9dyxkYj1RZy5leHBvcnRzLmZhc3RLZXkseWI9WW8uc2V0LGdiPVlvLmdldHRlckZvcixtYj17Z2V0Q29uc3RydWN0b3I6ZnVuY3Rpb24odCxlLHIsbil7dmFyIGk9dCgoZnVuY3Rpb24odCxpKXtmYih0LG8pLHliKHQse3R5cGU6ZSxpbmRleDp1YihudWxsKSxmaXJzdDp2b2lkIDAsbGFzdDp2b2lkIDAsc2l6ZTowfSksdmJ8fCh0LnNpemU9MCksbnVsbCE9aSYmbGIoaSx0W25dLHt0aGF0OnQsQVNfRU5UUklFUzpyfSl9KSksbz1pLnByb3RvdHlwZSxhPWdiKGUpLHU9ZnVuY3Rpb24odCxlLHIpe3ZhciBuLGksbz1hKHQpLHU9cyh0LGUpO3JldHVybiB1P3UudmFsdWU9cjooby5sYXN0PXU9e2luZGV4Omk9ZGIoZSwhMCksa2V5OmUsdmFsdWU6cixwcmV2aW91czpuPW8ubGFzdCxuZXh0OnZvaWQgMCxyZW1vdmVkOiExfSxvLmZpcnN0fHwoby5maXJzdD11KSxuJiYobi5uZXh0PXUpLHZiP28uc2l6ZSsrOnQuc2l6ZSsrLFwiRlwiIT09aSYmKG8uaW5kZXhbaV09dSkpLHR9LHM9ZnVuY3Rpb24odCxlKXt2YXIgcixuPWEodCksaT1kYihlKTtpZihcIkZcIiE9PWkpcmV0dXJuIG4uaW5kZXhbaV07Zm9yKHI9bi5maXJzdDtyO3I9ci5uZXh0KWlmKHIua2V5PT1lKXJldHVybiByfTtyZXR1cm4gc2Iobyx7Y2xlYXI6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9YSh0aGlzKSxlPXQuaW5kZXgscj10LmZpcnN0O3I7KXIucmVtb3ZlZD0hMCxyLnByZXZpb3VzJiYoci5wcmV2aW91cz1yLnByZXZpb3VzLm5leHQ9dm9pZCAwKSxkZWxldGUgZVtyLmluZGV4XSxyPXIubmV4dDt0LmZpcnN0PXQubGFzdD12b2lkIDAsdmI/dC5zaXplPTA6dGhpcy5zaXplPTB9LGRlbGV0ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9YShlKSxuPXMoZSx0KTtpZihuKXt2YXIgaT1uLm5leHQsbz1uLnByZXZpb3VzO2RlbGV0ZSByLmluZGV4W24uaW5kZXhdLG4ucmVtb3ZlZD0hMCxvJiYoby5uZXh0PWkpLGkmJihpLnByZXZpb3VzPW8pLHIuZmlyc3Q9PW4mJihyLmZpcnN0PWkpLHIubGFzdD09biYmKHIubGFzdD1vKSx2Yj9yLnNpemUtLTplLnNpemUtLX1yZXR1cm4hIW59LGZvckVhY2g6ZnVuY3Rpb24odCl7Zm9yKHZhciBlLHI9YSh0aGlzKSxuPWNiKHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApO2U9ZT9lLm5leHQ6ci5maXJzdDspZm9yKG4oZS52YWx1ZSxlLmtleSx0aGlzKTtlJiZlLnJlbW92ZWQ7KWU9ZS5wcmV2aW91c30saGFzOmZ1bmN0aW9uKHQpe3JldHVybiEhcyh0aGlzLHQpfX0pLHNiKG8scj97Z2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXModGhpcyx0KTtyZXR1cm4gZSYmZS52YWx1ZX0sc2V0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHUodGhpcywwPT09dD8wOnQsZSl9fTp7YWRkOmZ1bmN0aW9uKHQpe3JldHVybiB1KHRoaXMsdD0wPT09dD8wOnQsdCl9fSksdmImJmFiKG8sXCJzaXplXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBhKHRoaXMpLnNpemV9fSksaX0sc2V0U3Ryb25nOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1lK1wiIEl0ZXJhdG9yXCIsaT1nYihlKSxvPWdiKG4pO2hiKHQsZSwoZnVuY3Rpb24odCxlKXt5Yih0aGlzLHt0eXBlOm4sdGFyZ2V0OnQsc3RhdGU6aSh0KSxraW5kOmUsbGFzdDp2b2lkIDB9KX0pLChmdW5jdGlvbigpe2Zvcih2YXIgdD1vKHRoaXMpLGU9dC5raW5kLHI9dC5sYXN0O3ImJnIucmVtb3ZlZDspcj1yLnByZXZpb3VzO3JldHVybiB0LnRhcmdldCYmKHQubGFzdD1yPXI/ci5uZXh0OnQuc3RhdGUuZmlyc3QpP1wia2V5c1wiPT1lP3t2YWx1ZTpyLmtleSxkb25lOiExfTpcInZhbHVlc1wiPT1lP3t2YWx1ZTpyLnZhbHVlLGRvbmU6ITF9Ont2YWx1ZTpbci5rZXksci52YWx1ZV0sZG9uZTohMX06KHQudGFyZ2V0PXZvaWQgMCx7dmFsdWU6dm9pZCAwLGRvbmU6ITB9KX0pLHI/XCJlbnRyaWVzXCI6XCJ2YWx1ZXNcIiwhciwhMCkscGIoZSl9fTt0YihcIk1hcFwiLChmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdCh0aGlzLGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzBdOnZvaWQgMCl9fSksbWIpO3ZhciBiYj1CLk1hcCxfYj1iaS5zb21lO1RyKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohbW4oXCJzb21lXCIpfSx7c29tZTpmdW5jdGlvbih0KXtyZXR1cm4gX2IodGhpcyx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19KTt2YXIgd2I9SnIoXCJBcnJheVwiKS5zb21lLE9iPWV0LEViPXdiLFRiPUFycmF5LnByb3RvdHlwZSx4Yj1mdW5jdGlvbih0KXt2YXIgZT10LnNvbWU7cmV0dXJuIHQ9PT1UYnx8T2IoVGIsdCkmJmU9PT1UYi5zb21lP0ViOmV9LGtiPUpyKFwiQXJyYXlcIikua2V5cyxTYj16bixBYj1VdCxqYj1ldCxQYj1rYixJYj1BcnJheS5wcm90b3R5cGUsRGI9e0RPTVRva2VuTGlzdDohMCxOb2RlTGlzdDohMH0sTGI9ZnVuY3Rpb24odCl7dmFyIGU9dC5rZXlzO3JldHVybiB0PT09SWJ8fGpiKEliLHQpJiZlPT09SWIua2V5c3x8QWIoRGIsU2IodCkpP1BiOmV9LENiPXZjLFJiPU1hdGguZmxvb3IsTWI9ZnVuY3Rpb24odCxlKXt2YXIgcj10Lmxlbmd0aCxuPVJiKHIvMik7cmV0dXJuIHI8OD9GYih0LGUpOk5iKHQsTWIoQ2IodCwwLG4pLGUpLE1iKENiKHQsbiksZSksZSl9LEZiPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByLG4saT10Lmxlbmd0aCxvPTE7bzxpOyl7Zm9yKG49byxyPXRbb107biYmZSh0W24tMV0scik+MDspdFtuXT10Wy0tbl07biE9PW8rKyYmKHRbbl09cil9cmV0dXJuIHR9LE5iPWZ1bmN0aW9uKHQsZSxyLG4pe2Zvcih2YXIgaT1lLmxlbmd0aCxvPXIubGVuZ3RoLGE9MCx1PTA7YTxpfHx1PG87KXRbYSt1XT1hPGkmJnU8bz9uKGVbYV0sclt1XSk8PTA/ZVthKytdOnJbdSsrXTphPGk/ZVthKytdOnJbdSsrXTtyZXR1cm4gdH0semI9TWIscWI9cnQubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvaSksWWI9ISFxYiYmK3FiWzFdLEdiPS9NU0lFfFRyaWRlbnQvLnRlc3QocnQpLFhiPXJ0Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pLFViPSEhWGImJitYYlsxXSxXYj1UcixWYj1tLEhiPXh0LCRiPVl0LEJiPWNuLEpiPWlvLEtiPWEsUWI9emIsWmI9bW4sdF89WWIsZV89R2Iscl89Y3Qsbl89VWIsaV89W10sb189VmIoaV8uc29ydCksYV89VmIoaV8ucHVzaCksdV89S2IoKGZ1bmN0aW9uKCl7aV8uc29ydCh2b2lkIDApfSkpLHNfPUtiKChmdW5jdGlvbigpe2lfLnNvcnQobnVsbCl9KSksY189WmIoXCJzb3J0XCIpLGZfPSFLYigoZnVuY3Rpb24oKXtpZihyXylyZXR1cm4gcl88NzA7aWYoISh0XyYmdF8+Mykpe2lmKGVfKXJldHVybiEwO2lmKG5fKXJldHVybiBuXzw2MDM7dmFyIHQsZSxyLG4saT1cIlwiO2Zvcih0PTY1O3Q8NzY7dCsrKXtzd2l0Y2goZT1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpLHQpe2Nhc2UgNjY6Y2FzZSA2OTpjYXNlIDcwOmNhc2UgNzI6cj0zO2JyZWFrO2Nhc2UgNjg6Y2FzZSA3MTpyPTQ7YnJlYWs7ZGVmYXVsdDpyPTJ9Zm9yKG49MDtuPDQ3O24rKylpXy5wdXNoKHtrOmUrbix2OnJ9KX1mb3IoaV8uc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gZS52LXQudn0pKSxuPTA7bjxpXy5sZW5ndGg7bisrKWU9aV9bbl0uay5jaGFyQXQoMCksaS5jaGFyQXQoaS5sZW5ndGgtMSkhPT1lJiYoaSs9ZSk7cmV0dXJuXCJER0JFRkhBQ0lKS1wiIT09aX19KSk7V2Ioe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOnVffHwhc198fCFjX3x8IWZffSx7c29ydDpmdW5jdGlvbih0KXt2b2lkIDAhPT10JiZIYih0KTt2YXIgZT0kYih0aGlzKTtpZihmXylyZXR1cm4gdm9pZCAwPT09dD9vXyhlKTpvXyhlLHQpO3ZhciByLG4saT1bXSxvPUJiKGUpO2ZvcihuPTA7bjxvO24rKyluIGluIGUmJmFfKGksZVtuXSk7Zm9yKFFiKGksZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUscil7cmV0dXJuIHZvaWQgMD09PXI/LTE6dm9pZCAwPT09ZT8xOnZvaWQgMCE9PXQ/K3QoZSxyKXx8MDpKYihlKT5KYihyKT8xOi0xfX0odCkpLHI9aS5sZW5ndGgsbj0wO248cjspZVtuXT1pW24rK107Zm9yKDtuPG87KWRlbGV0ZSBlW24rK107cmV0dXJuIGV9fSk7dmFyIGxfLGhfPUpyKFwiQXJyYXlcIikuc29ydCxwXz1ldCx2Xz1oXyxkXz1BcnJheS5wcm90b3R5cGUseV89ZnVuY3Rpb24odCl7dmFyIGU9dC5zb3J0O3JldHVybiB0PT09ZF98fHBfKGRfLHQpJiZlPT09ZF8uc29ydD92XzplfSxnXz1KcihcIkFycmF5XCIpLnZhbHVlcyxtXz16bixiXz1VdCxfXz1ldCx3Xz1nXyxPXz1BcnJheS5wcm90b3R5cGUsRV89e0RPTVRva2VuTGlzdDohMCxOb2RlTGlzdDohMH0sVF89ZnVuY3Rpb24odCl7dmFyIGU9dC52YWx1ZXM7cmV0dXJuIHQ9PT1PX3x8X18oT18sdCkmJmU9PT1PXy52YWx1ZXN8fGJfKEVfLG1fKHQpKT93XzplfSx4Xz1taCxrXz1KcihcIkFycmF5XCIpLmVudHJpZXMsU189em4sQV89VXQsal89ZXQsUF89a18sSV89QXJyYXkucHJvdG90eXBlLERfPXtET01Ub2tlbkxpc3Q6ITAsTm9kZUxpc3Q6ITB9LExfPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZW50cmllcztyZXR1cm4gdD09PUlffHxqXyhJXyx0KSYmZT09PUlfLmVudHJpZXN8fEFfKERfLFNfKHQpKT9QXzplfSxDXz1uZXcgVWludDhBcnJheSgxNik7ZnVuY3Rpb24gUl8oKXtpZighbF8mJiEobF89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGNyeXB0byYmY3J5cHRvLmdldFJhbmRvbVZhbHVlcyYmY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0byl8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBtc0NyeXB0byYmXCJmdW5jdGlvblwiPT10eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzJiZtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0bykpKXRocm93IG5ldyBFcnJvcihcImNyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkXCIpO3JldHVybiBsXyhDXyl9dmFyIE1fPS9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtmdW5jdGlvbiBGXyh0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdCYmTV8udGVzdCh0KX1mb3IodmFyIE5fPVtdLHpfPTA7el88MjU2Oysrel8pTl8ucHVzaCgoel8rMjU2KS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtmdW5jdGlvbiBxXyh0LGUscil7dmFyIG49KHQ9dHx8e30pLnJhbmRvbXx8KHQucm5nfHxSXykoKTtpZihuWzZdPTE1Jm5bNl18NjQsbls4XT02MyZuWzhdfDEyOCxlKXtyPXJ8fDA7Zm9yKHZhciBpPTA7aTwxNjsrK2kpZVtyK2ldPW5baV07cmV0dXJuIGV9cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTowLHI9KE5fW3RbZSswXV0rTl9bdFtlKzFdXStOX1t0W2UrMl1dK05fW3RbZSszXV0rXCItXCIrTl9bdFtlKzRdXStOX1t0W2UrNV1dK1wiLVwiK05fW3RbZSs2XV0rTl9bdFtlKzddXStcIi1cIitOX1t0W2UrOF1dK05fW3RbZSs5XV0rXCItXCIrTl9bdFtlKzEwXV0rTl9bdFtlKzExXV0rTl9bdFtlKzEyXV0rTl9bdFtlKzEzXV0rTl9bdFtlKzE0XV0rTl9bdFtlKzE1XV0pLnRvTG93ZXJDYXNlKCk7aWYoIUZfKHIpKXRocm93IFR5cGVFcnJvcihcIlN0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZFwiKTtyZXR1cm4gcn0obil9ZnVuY3Rpb24gWV8odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR8fFwibnVtYmVyXCI9PXR5cGVvZiB0fXZhciBHXz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQocil7ZSh0aGlzLHQpLENyKHRoaXMsXCJkZWxheVwiLHZvaWQgMCksQ3IodGhpcyxcIm1heFwiLHZvaWQgMCksQ3IodGhpcyxcIl9xdWV1ZVwiLFtdKSxDcih0aGlzLFwiX3RpbWVvdXRcIixudWxsKSxDcih0aGlzLFwiX2V4dGVuZGVkXCIsbnVsbCksdGhpcy5kZWxheT1udWxsLHRoaXMubWF4PTEvMCx0aGlzLnNldE9wdGlvbnMocil9cmV0dXJuIExyKHQsW3trZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7dCYmdm9pZCAwIT09dC5kZWxheSYmKHRoaXMuZGVsYXk9dC5kZWxheSksdCYmdm9pZCAwIT09dC5tYXgmJih0aGlzLm1heD10Lm1heCksdGhpcy5fZmx1c2hJZk5lZWRlZCgpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuZmx1c2goKSx0aGlzLl9leHRlbmRlZCl7Zm9yKHZhciB0PXRoaXMuX2V4dGVuZGVkLm9iamVjdCxlPXRoaXMuX2V4dGVuZGVkLm1ldGhvZHMscj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgbj1lW3JdO24ub3JpZ2luYWw/dFtuLm5hbWVdPW4ub3JpZ2luYWw6ZGVsZXRlIHRbbi5uYW1lXX10aGlzLl9leHRlbmRlZD1udWxsfX19LHtrZXk6XCJyZXBsYWNlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLG49dFtlXTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2QgXCIrZStcIiB1bmRlZmluZWRcIik7dFtlXT1mdW5jdGlvbigpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLGU9bmV3IEFycmF5KHQpLGk9MDtpPHQ7aSsrKWVbaV09YXJndW1lbnRzW2ldO3IucXVldWUoe2FyZ3M6ZSxmbjpuLGNvbnRleHQ6dGhpc30pfX19LHtrZXk6XCJxdWV1ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe1wiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dGhpcy5fcXVldWUucHVzaCh7Zm46dH0pOnRoaXMuX3F1ZXVlLnB1c2godCksdGhpcy5fZmx1c2hJZk5lZWRlZCgpfX0se2tleTpcIl9mbHVzaElmTmVlZGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuX3F1ZXVlLmxlbmd0aD50aGlzLm1heCYmdGhpcy5mbHVzaCgpLG51bGwhPXRoaXMuX3RpbWVvdXQmJihjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCksdGhpcy5fdGltZW91dD1udWxsKSx0aGlzLnF1ZXVlLmxlbmd0aD4wJiZcIm51bWJlclwiPT10eXBlb2YgdGhpcy5kZWxheSYmKHRoaXMuX3RpbWVvdXQ9YmQoKGZ1bmN0aW9uKCl7dC5mbHVzaCgpfSksdGhpcy5kZWxheSkpfX0se2tleTpcImZsdXNoXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlO0hoKHQ9d3AoZT10aGlzLl9xdWV1ZSkuY2FsbChlLDApKS5jYWxsKHQsKGZ1bmN0aW9uKHQpe3QuZm4uYXBwbHkodC5jb250ZXh0fHx0LmZuLHQuYXJnc3x8W10pfSkpfX1dLFt7a2V5OlwiZXh0ZW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSxyKXt2YXIgbj1uZXcgdChyKTtpZih2b2lkIDAhPT1lLmZsdXNoKXRocm93IG5ldyBFcnJvcihcIlRhcmdldCBvYmplY3QgYWxyZWFkeSBoYXMgYSBwcm9wZXJ0eSBmbHVzaFwiKTtlLmZsdXNoPWZ1bmN0aW9uKCl7bi5mbHVzaCgpfTt2YXIgaT1be25hbWU6XCJmbHVzaFwiLG9yaWdpbmFsOnZvaWQgMH1dO2lmKHImJnIucmVwbGFjZSlmb3IodmFyIG89MDtvPHIucmVwbGFjZS5sZW5ndGg7bysrKXt2YXIgYT1yLnJlcGxhY2Vbb107aS5wdXNoKHtuYW1lOmEsb3JpZ2luYWw6ZVthXX0pLG4ucmVwbGFjZShlLGEpfXJldHVybiBuLl9leHRlbmRlZD17b2JqZWN0OmUsbWV0aG9kczppfSxufX1dKSx0fSgpLFhfPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe2UodGhpcyx0KSxDcih0aGlzLFwiX3N1YnNjcmliZXJzXCIse1wiKlwiOltdLGFkZDpbXSxyZW1vdmU6W10sdXBkYXRlOltdfSksQ3IodGhpcyxcInN1YnNjcmliZVwiLHQucHJvdG90eXBlLm9uKSxDcih0aGlzLFwidW5zdWJzY3JpYmVcIix0LnByb3RvdHlwZS5vZmYpfXJldHVybiBMcih0LFt7a2V5OlwiX3RyaWdnZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUscil7dmFyIG4saTtpZihcIipcIj09PXQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHRyaWdnZXIgZXZlbnQgKlwiKTtIaChuPVNoKGk9W10pLmNhbGwoaSx3aCh0aGlzLl9zdWJzY3JpYmVyc1t0XSksd2godGhpcy5fc3Vic2NyaWJlcnNbXCIqXCJdKSkpLmNhbGwobiwoZnVuY3Rpb24obil7bih0LGUsbnVsbCE9cj9yOm51bGwpfSkpfX0se2tleTpcIm9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZ0aGlzLl9zdWJzY3JpYmVyc1t0XS5wdXNoKGUpfX0se2tleTpcIm9mZlwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIHI7dGhpcy5fc3Vic2NyaWJlcnNbdF09amkocj10aGlzLl9zdWJzY3JpYmVyc1t0XSkuY2FsbChyLChmdW5jdGlvbih0KXtyZXR1cm4gdCE9PWV9KSl9fV0pLHR9KCk7dGIoXCJTZXRcIiwoZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQodGhpcyxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1swXTp2b2lkIDApfX0pLG1iKTt2YXIgVV8sV189Qi5TZXQsVl89d3M7ZnVuY3Rpb24gSF8odCxlKXt2YXIgcj12b2lkIDAhPT1PaCYmaWModCl8fHRbXCJAQGl0ZXJhdG9yXCJdO2lmKCFyKXtpZihQaCh0KXx8KHI9ZnVuY3Rpb24odCxlKXt2YXIgcjtpZighdClyZXR1cm47aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuICRfKHQsZSk7dmFyIG49QWgocj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpLmNhbGwociw4LC0xKTtcIk9iamVjdFwiPT09biYmdC5jb25zdHJ1Y3RvciYmKG49dC5jb25zdHJ1Y3Rvci5uYW1lKTtpZihcIk1hcFwiPT09bnx8XCJTZXRcIj09PW4pcmV0dXJuIHFzKHQpO2lmKFwiQXJndW1lbnRzXCI9PT1ufHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSlyZXR1cm4gJF8odCxlKX0odCkpfHxlJiZ0JiZcIm51bWJlclwiPT10eXBlb2YgdC5sZW5ndGgpe3ImJih0PXIpO3ZhciBuPTAsaT1mdW5jdGlvbigpe307cmV0dXJue3M6aSxuOmZ1bmN0aW9uKCl7cmV0dXJuIG4+PXQubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTp0W24rK119fSxlOmZ1bmN0aW9uKHQpe3Rocm93IHR9LGY6aX19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXZhciBvLGE9ITAsdT0hMTtyZXR1cm57czpmdW5jdGlvbigpe3I9ci5jYWxsKHQpfSxuOmZ1bmN0aW9uKCl7dmFyIHQ9ci5uZXh0KCk7cmV0dXJuIGE9dC5kb25lLHR9LGU6ZnVuY3Rpb24odCl7dT0hMCxvPXR9LGY6ZnVuY3Rpb24oKXt0cnl7YXx8bnVsbD09ci5yZXR1cm58fHIucmV0dXJuKCl9ZmluYWxseXtpZih1KXRocm93IG99fX19ZnVuY3Rpb24gJF8odCxlKXsobnVsbD09ZXx8ZT50Lmxlbmd0aCkmJihlPXQubGVuZ3RoKTtmb3IodmFyIHI9MCxuPW5ldyBBcnJheShlKTtyPGU7cisrKW5bcl09dFtyXTtyZXR1cm4gbn1VXz14Xzt2YXIgQl89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHIpe2UodGhpcyx0KSxDcih0aGlzLFwiX3BhaXJzXCIsdm9pZCAwKSx0aGlzLl9wYWlycz1yfXJldHVybiBMcih0LFt7a2V5OlVfLHZhbHVlOktnLm1hcmsoKGZ1bmN0aW9uIHQoKXt2YXIgZSxyLG4saSxvO3JldHVybiBLZy53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDplPUhfKHRoaXMuX3BhaXJzKSx0LnByZXY9MSxlLnMoKTtjYXNlIDM6aWYoKHI9ZS5uKCkpLmRvbmUpe3QubmV4dD05O2JyZWFrfXJldHVybiBuPWdoKHIudmFsdWUsMiksaT1uWzBdLG89blsxXSx0Lm5leHQ9NyxbaSxvXTtjYXNlIDc6dC5uZXh0PTM7YnJlYWs7Y2FzZSA5OnQubmV4dD0xNDticmVhaztjYXNlIDExOnQucHJldj0xMSx0LnQwPXQuY2F0Y2goMSksZS5lKHQudDApO2Nhc2UgMTQ6cmV0dXJuIHQucHJldj0xNCxlLmYoKSx0LmZpbmlzaCgxNCk7Y2FzZSAxNzpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzLFtbMSwxMSwxNCwxN11dKX0pKX0se2tleTpcImVudHJpZXNcIix2YWx1ZTpLZy5tYXJrKChmdW5jdGlvbiB0KCl7dmFyIGUscixuLGksbztyZXR1cm4gS2cud3JhcCgoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6ZT1IXyh0aGlzLl9wYWlycyksdC5wcmV2PTEsZS5zKCk7Y2FzZSAzOmlmKChyPWUubigpKS5kb25lKXt0Lm5leHQ9OTticmVha31yZXR1cm4gbj1naChyLnZhbHVlLDIpLGk9blswXSxvPW5bMV0sdC5uZXh0PTcsW2ksb107Y2FzZSA3OnQubmV4dD0zO2JyZWFrO2Nhc2UgOTp0Lm5leHQ9MTQ7YnJlYWs7Y2FzZSAxMTp0LnByZXY9MTEsdC50MD10LmNhdGNoKDEpLGUuZSh0LnQwKTtjYXNlIDE0OnJldHVybiB0LnByZXY9MTQsZS5mKCksdC5maW5pc2goMTQpO2Nhc2UgMTc6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQsdGhpcyxbWzEsMTEsMTQsMTddXSl9KSl9LHtrZXk6XCJrZXlzXCIsdmFsdWU6S2cubWFyaygoZnVuY3Rpb24gdCgpe3ZhciBlLHIsbixpO3JldHVybiBLZy53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDplPUhfKHRoaXMuX3BhaXJzKSx0LnByZXY9MSxlLnMoKTtjYXNlIDM6aWYoKHI9ZS5uKCkpLmRvbmUpe3QubmV4dD05O2JyZWFrfXJldHVybiBuPWdoKHIudmFsdWUsMSksaT1uWzBdLHQubmV4dD03LGk7Y2FzZSA3OnQubmV4dD0zO2JyZWFrO2Nhc2UgOTp0Lm5leHQ9MTQ7YnJlYWs7Y2FzZSAxMTp0LnByZXY9MTEsdC50MD10LmNhdGNoKDEpLGUuZSh0LnQwKTtjYXNlIDE0OnJldHVybiB0LnByZXY9MTQsZS5mKCksdC5maW5pc2goMTQpO2Nhc2UgMTc6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQsdGhpcyxbWzEsMTEsMTQsMTddXSl9KSl9LHtrZXk6XCJ2YWx1ZXNcIix2YWx1ZTpLZy5tYXJrKChmdW5jdGlvbiB0KCl7dmFyIGUscixuLGk7cmV0dXJuIEtnLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOmU9SF8odGhpcy5fcGFpcnMpLHQucHJldj0xLGUucygpO2Nhc2UgMzppZigocj1lLm4oKSkuZG9uZSl7dC5uZXh0PTk7YnJlYWt9cmV0dXJuIG49Z2goci52YWx1ZSwyKSxpPW5bMV0sdC5uZXh0PTcsaTtjYXNlIDc6dC5uZXh0PTM7YnJlYWs7Y2FzZSA5OnQubmV4dD0xNDticmVhaztjYXNlIDExOnQucHJldj0xMSx0LnQwPXQuY2F0Y2goMSksZS5lKHQudDApO2Nhc2UgMTQ6cmV0dXJuIHQucHJldj0xNCxlLmYoKSx0LmZpbmlzaCgxNCk7Y2FzZSAxNzpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzLFtbMSwxMSwxNCwxN11dKX0pKX0se2tleTpcInRvSWRBcnJheVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIFJpKHQ9d2godGhpcy5fcGFpcnMpKS5jYWxsKHQsKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSkpfX0se2tleTpcInRvSXRlbUFycmF5XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gUmkodD13aCh0aGlzLl9wYWlycykpLmNhbGwodCwoZnVuY3Rpb24odCl7cmV0dXJuIHRbMV19KSl9fSx7a2V5OlwidG9FbnRyeUFycmF5XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gd2godGhpcy5fcGFpcnMpfX0se2tleTpcInRvT2JqZWN0TWFwXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlPVl2KG51bGwpLHI9SF8odGhpcy5fcGFpcnMpO3RyeXtmb3Ioci5zKCk7ISh0PXIubigpKS5kb25lOyl7dmFyIG49Z2godC52YWx1ZSwyKSxpPW5bMF0sbz1uWzFdO2VbaV09b319Y2F0Y2godCl7ci5lKHQpfWZpbmFsbHl7ci5mKCl9cmV0dXJuIGV9fSx7a2V5OlwidG9NYXBcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBuZXcgYmIodGhpcy5fcGFpcnMpfX0se2tleTpcInRvSWRTZXRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBuZXcgV18odGhpcy50b0lkQXJyYXkoKSl9fSx7a2V5OlwidG9JdGVtU2V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFdfKHRoaXMudG9JdGVtQXJyYXkoKSl9fSx7a2V5OlwiY2FjaGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBuZXcgdCh3aCh0aGlzLl9wYWlycykpfX0se2tleTpcImRpc3RpbmN0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGUscj1uZXcgV18sbj1IXyh0aGlzLl9wYWlycyk7dHJ5e2ZvcihuLnMoKTshKGU9bi5uKCkpLmRvbmU7KXt2YXIgaT1naChlLnZhbHVlLDIpLG89aVswXSxhPWlbMV07ci5hZGQodChhLG8pKX19Y2F0Y2godCl7bi5lKHQpfWZpbmFsbHl7bi5mKCl9cmV0dXJuIHJ9fSx7a2V5OlwiZmlsdGVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHI9dGhpcy5fcGFpcnM7cmV0dXJuIG5ldyB0KENyKHt9LHhfLEtnLm1hcmsoKGZ1bmN0aW9uIHQoKXt2YXIgbixpLG8sYSx1O3JldHVybiBLZy53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpuPUhfKHIpLHQucHJldj0xLG4ucygpO2Nhc2UgMzppZigoaT1uLm4oKSkuZG9uZSl7dC5uZXh0PTEwO2JyZWFrfWlmKG89Z2goaS52YWx1ZSwyKSxhPW9bMF0sdT1vWzFdLCFlKHUsYSkpe3QubmV4dD04O2JyZWFrfXJldHVybiB0Lm5leHQ9OCxbYSx1XTtjYXNlIDg6dC5uZXh0PTM7YnJlYWs7Y2FzZSAxMDp0Lm5leHQ9MTU7YnJlYWs7Y2FzZSAxMjp0LnByZXY9MTIsdC50MD10LmNhdGNoKDEpLG4uZSh0LnQwKTtjYXNlIDE1OnJldHVybiB0LnByZXY9MTUsbi5mKCksdC5maW5pc2goMTUpO2Nhc2UgMTg6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQsbnVsbCxbWzEsMTIsMTUsMThdXSl9KSkpKX19LHtrZXk6XCJmb3JFYWNoXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGUscj1IXyh0aGlzLl9wYWlycyk7dHJ5e2ZvcihyLnMoKTshKGU9ci5uKCkpLmRvbmU7KXt2YXIgbj1naChlLnZhbHVlLDIpLGk9blswXTt0KG5bMV0saSl9fWNhdGNoKHQpe3IuZSh0KX1maW5hbGx5e3IuZigpfX19LHtrZXk6XCJtYXBcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgcj10aGlzLl9wYWlycztyZXR1cm4gbmV3IHQoQ3Ioe30seF8sS2cubWFyaygoZnVuY3Rpb24gdCgpe3ZhciBuLGksbyxhLHU7cmV0dXJuIEtnLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOm49SF8ociksdC5wcmV2PTEsbi5zKCk7Y2FzZSAzOmlmKChpPW4ubigpKS5kb25lKXt0Lm5leHQ9OTticmVha31yZXR1cm4gbz1naChpLnZhbHVlLDIpLGE9b1swXSx1PW9bMV0sdC5uZXh0PTcsW2EsZSh1LGEpXTtjYXNlIDc6dC5uZXh0PTM7YnJlYWs7Y2FzZSA5OnQubmV4dD0xNDticmVhaztjYXNlIDExOnQucHJldj0xMSx0LnQwPXQuY2F0Y2goMSksbi5lKHQudDApO2Nhc2UgMTQ6cmV0dXJuIHQucHJldj0xNCxuLmYoKSx0LmZpbmlzaCgxNCk7Y2FzZSAxNzpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCxudWxsLFtbMSwxMSwxNCwxN11dKX0pKSkpfX0se2tleTpcIm1heFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPVZfKHRoaXMuX3BhaXJzKSxyPWUubmV4dCgpO2lmKHIuZG9uZSlyZXR1cm4gbnVsbDtmb3IodmFyIG49ci52YWx1ZVsxXSxpPXQoci52YWx1ZVsxXSxyLnZhbHVlWzBdKTshKHI9ZS5uZXh0KCkpLmRvbmU7KXt2YXIgbz1naChyLnZhbHVlLDIpLGE9b1swXSx1PW9bMV0scz10KHUsYSk7cz5pJiYoaT1zLG49dSl9cmV0dXJuIG59fSx7a2V5OlwibWluXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9Vl8odGhpcy5fcGFpcnMpLHI9ZS5uZXh0KCk7aWYoci5kb25lKXJldHVybiBudWxsO2Zvcih2YXIgbj1yLnZhbHVlWzFdLGk9dChyLnZhbHVlWzFdLHIudmFsdWVbMF0pOyEocj1lLm5leHQoKSkuZG9uZTspe3ZhciBvPWdoKHIudmFsdWUsMiksYT1vWzBdLHU9b1sxXSxzPXQodSxhKTtzPGkmJihpPXMsbj11KX1yZXR1cm4gbn19LHtrZXk6XCJyZWR1Y2VcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciByLG49SF8odGhpcy5fcGFpcnMpO3RyeXtmb3Iobi5zKCk7IShyPW4ubigpKS5kb25lOyl7dmFyIGk9Z2goci52YWx1ZSwyKSxvPWlbMF07ZT10KGUsaVsxXSxvKX19Y2F0Y2godCl7bi5lKHQpfWZpbmFsbHl7bi5mKCl9cmV0dXJuIGV9fSx7a2V5Olwic29ydFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciByPXRoaXM7cmV0dXJuIG5ldyB0KENyKHt9LHhfLChmdW5jdGlvbigpe3ZhciB0O3JldHVybiBWXyh5Xyh0PXdoKHIuX3BhaXJzKSkuY2FsbCh0LChmdW5jdGlvbih0LHIpe3ZhciBuPWdoKHQsMiksaT1uWzBdLG89blsxXSxhPWdoKHIsMiksdT1hWzBdLHM9YVsxXTtyZXR1cm4gZShvLHMsaSx1KX0pKSl9KSkpfX1dKSx0fSgpO2Z1bmN0aW9uIEpfKHQsZSl7dmFyIHI9TGgodCk7aWYoJGYpe3ZhciBuPSRmKHQpO2UmJihuPWppKG4pLmNhbGwobiwoZnVuY3Rpb24oZSl7cmV0dXJuIGlsKHQsZSkuZW51bWVyYWJsZX0pKSksci5wdXNoLmFwcGx5KHIsbil9cmV0dXJuIHJ9ZnVuY3Rpb24gS18odCl7Zm9yKHZhciBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIHIsbixpPW51bGwhPWFyZ3VtZW50c1tlXT9hcmd1bWVudHNbZV06e307ZSUyP0hoKHI9Sl8oT2JqZWN0KGkpLCEwKSkuY2FsbChyLChmdW5jdGlvbihlKXtDcih0LGUsaVtlXSl9KSk6ZGw/T2wodCxkbChpKSk6SGgobj1KXyhPYmplY3QoaSkpKS5jYWxsKG4sKGZ1bmN0aW9uKGUpe0VsKHQsZSxpbChpLGUpKX0pKX1yZXR1cm4gdH1mdW5jdGlvbiBRXyh0LGUpe3ZhciByPXZvaWQgMCE9PU9oJiZpYyh0KXx8dFtcIkBAaXRlcmF0b3JcIl07aWYoIXIpe2lmKFBoKHQpfHwocj1mdW5jdGlvbih0LGUpe3ZhciByO2lmKCF0KXJldHVybjtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gWl8odCxlKTt2YXIgbj1BaChyPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkuY2FsbChyLDgsLTEpO1wiT2JqZWN0XCI9PT1uJiZ0LmNvbnN0cnVjdG9yJiYobj10LmNvbnN0cnVjdG9yLm5hbWUpO2lmKFwiTWFwXCI9PT1ufHxcIlNldFwiPT09bilyZXR1cm4gcXModCk7aWYoXCJBcmd1bWVudHNcIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKXJldHVybiBaXyh0LGUpfSh0KSl8fGUmJnQmJlwibnVtYmVyXCI9PXR5cGVvZiB0Lmxlbmd0aCl7ciYmKHQ9cik7dmFyIG49MCxpPWZ1bmN0aW9uKCl7fTtyZXR1cm57czppLG46ZnVuY3Rpb24oKXtyZXR1cm4gbj49dC5sZW5ndGg/e2RvbmU6ITB9Ontkb25lOiExLHZhbHVlOnRbbisrXX19LGU6ZnVuY3Rpb24odCl7dGhyb3cgdH0sZjppfX10aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9dmFyIG8sYT0hMCx1PSExO3JldHVybntzOmZ1bmN0aW9uKCl7cj1yLmNhbGwodCl9LG46ZnVuY3Rpb24oKXt2YXIgdD1yLm5leHQoKTtyZXR1cm4gYT10LmRvbmUsdH0sZTpmdW5jdGlvbih0KXt1PSEwLG89dH0sZjpmdW5jdGlvbigpe3RyeXthfHxudWxsPT1yLnJldHVybnx8ci5yZXR1cm4oKX1maW5hbGx5e2lmKHUpdGhyb3cgb319fX1mdW5jdGlvbiBaXyh0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgcj0wLG49bmV3IEFycmF5KGUpO3I8ZTtyKyspbltyXT10W3JdO3JldHVybiBufWZ1bmN0aW9uIHR3KHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFZZylyZXR1cm4hMTtpZihZZy5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFlnKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHIsbj1CZyh0KTtpZihlKXt2YXIgaT1CZyh0aGlzKS5jb25zdHJ1Y3RvcjtyPVlnKG4sYXJndW1lbnRzLGkpfWVsc2Ugcj1uLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gSGcodGhpcyxyKX19dmFyIGV3PWZ1bmN0aW9uKHQpe1ZnKG4sdCk7dmFyIHI9dHcobik7ZnVuY3Rpb24gbih0LGkpe3ZhciBvO3JldHVybiBlKHRoaXMsbiksQ3IoR2cobz1yLmNhbGwodGhpcykpLFwiZmx1c2hcIix2b2lkIDApLENyKEdnKG8pLFwibGVuZ3RoXCIsdm9pZCAwKSxDcihHZyhvKSxcIl9vcHRpb25zXCIsdm9pZCAwKSxDcihHZyhvKSxcIl9kYXRhXCIsdm9pZCAwKSxDcihHZyhvKSxcIl9pZFByb3BcIix2b2lkIDApLENyKEdnKG8pLFwiX3F1ZXVlXCIsbnVsbCksdCYmIVBoKHQpJiYoaT10LHQ9W10pLG8uX29wdGlvbnM9aXx8e30sby5fZGF0YT1uZXcgYmIsby5sZW5ndGg9MCxvLl9pZFByb3A9by5fb3B0aW9ucy5maWVsZElkfHxcImlkXCIsdCYmdC5sZW5ndGgmJm8uYWRkKHQpLG8uc2V0T3B0aW9ucyhpKSxvfXJldHVybiBMcihuLFt7a2V5OlwiaWRQcm9wXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lkUHJvcH19LHtrZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7dCYmdm9pZCAwIT09dC5xdWV1ZSYmKCExPT09dC5xdWV1ZT90aGlzLl9xdWV1ZSYmKHRoaXMuX3F1ZXVlLmRlc3Ryb3koKSx0aGlzLl9xdWV1ZT1udWxsKToodGhpcy5fcXVldWV8fCh0aGlzLl9xdWV1ZT1HXy5leHRlbmQodGhpcyx7cmVwbGFjZTpbXCJhZGRcIixcInVwZGF0ZVwiLFwicmVtb3ZlXCJdfSkpLHQucXVldWUmJlwib2JqZWN0XCI9PT1faCh0LnF1ZXVlKSYmdGhpcy5fcXVldWUuc2V0T3B0aW9ucyh0LnF1ZXVlKSkpfX0se2tleTpcImFkZFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIHIsbj10aGlzLGk9W107aWYoUGgodCkpe3ZhciBvPVJpKHQpLmNhbGwodCwoZnVuY3Rpb24odCl7cmV0dXJuIHRbbi5faWRQcm9wXX0pKTtpZih4YihvKS5jYWxsKG8sKGZ1bmN0aW9uKHQpe3JldHVybiBuLl9kYXRhLmhhcyh0KX0pKSl0aHJvdyBuZXcgRXJyb3IoXCJBIGR1cGxpY2F0ZSBpZCB3YXMgZm91bmQgaW4gdGhlIHBhcmFtZXRlciBhcnJheS5cIik7Zm9yKHZhciBhPTAsdT10Lmxlbmd0aDthPHU7YSsrKXI9dGhpcy5fYWRkSXRlbSh0W2FdKSxpLnB1c2gocil9ZWxzZXtpZighdHx8XCJvYmplY3RcIiE9PV9oKHQpKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YVR5cGVcIik7cj10aGlzLl9hZGRJdGVtKHQpLGkucHVzaChyKX1yZXR1cm4gaS5sZW5ndGgmJnRoaXMuX3RyaWdnZXIoXCJhZGRcIix7aXRlbXM6aX0sZSksaX19LHtrZXk6XCJ1cGRhdGVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciByPXRoaXMsbj1bXSxpPVtdLG89W10sYT1bXSx1PXRoaXMuX2lkUHJvcCxzPWZ1bmN0aW9uKHQpe3ZhciBlPXRbdV07aWYobnVsbCE9ZSYmci5fZGF0YS5oYXMoZSkpe3ZhciBzPXQsYz1NcCh7fSxyLl9kYXRhLmdldChlKSksZj1yLl91cGRhdGVJdGVtKHMpO2kucHVzaChmKSxhLnB1c2gocyksby5wdXNoKGMpfWVsc2V7dmFyIGw9ci5fYWRkSXRlbSh0KTtuLnB1c2gobCl9fTtpZihQaCh0KSlmb3IodmFyIGM9MCxmPXQubGVuZ3RoO2M8ZjtjKyspdFtjXSYmXCJvYmplY3RcIj09PV9oKHRbY10pP3ModFtjXSk6Y29uc29sZS53YXJuKFwiSWdub3JpbmcgaW5wdXQgaXRlbSwgd2hpY2ggaXMgbm90IGFuIG9iamVjdCBhdCBpbmRleCBcIitjKTtlbHNle2lmKCF0fHxcIm9iamVjdFwiIT09X2godCkpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhVHlwZVwiKTtzKHQpfWlmKG4ubGVuZ3RoJiZ0aGlzLl90cmlnZ2VyKFwiYWRkXCIse2l0ZW1zOm59LGUpLGkubGVuZ3RoKXt2YXIgbD17aXRlbXM6aSxvbGREYXRhOm8sZGF0YTphfTt0aGlzLl90cmlnZ2VyKFwidXBkYXRlXCIsbCxlKX1yZXR1cm4gU2gobikuY2FsbChuLGkpfX0se2tleTpcInVwZGF0ZU9ubHlcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciByLG49dGhpcztQaCh0KXx8KHQ9W3RdKTt2YXIgaT1SaShyPVJpKHQpLmNhbGwodCwoZnVuY3Rpb24odCl7dmFyIGU9bi5fZGF0YS5nZXQodFtuLl9pZFByb3BdKTtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIlVwZGF0aW5nIG5vbi1leGlzdGVudCBpdGVtcyBpcyBub3QgYWxsb3dlZC5cIik7cmV0dXJue29sZERhdGE6ZSx1cGRhdGU6dH19KSkpLmNhbGwociwoZnVuY3Rpb24odCl7dmFyIGU9dC5vbGREYXRhLHI9dC51cGRhdGUsaT1lW24uX2lkUHJvcF0sbz1mdW5jdGlvbih0KXtmb3IodmFyIGUscj1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHI+MT9yLTE6MCksaT0xO2k8cjtpKyspbltpLTFdPWFyZ3VtZW50c1tpXTtyZXR1cm4gbWcuYXBwbHkodm9pZCAwLFNoKGU9W3t9LHRdKS5jYWxsKGUsbikpfShlLHIpO3JldHVybiBuLl9kYXRhLnNldChpLG8pLHtpZDppLG9sZERhdGE6ZSx1cGRhdGVkRGF0YTpvfX0pKTtpZihpLmxlbmd0aCl7dmFyIG89e2l0ZW1zOlJpKGkpLmNhbGwoaSwoZnVuY3Rpb24odCl7cmV0dXJuIHQuaWR9KSksb2xkRGF0YTpSaShpKS5jYWxsKGksKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm9sZERhdGF9KSksZGF0YTpSaShpKS5jYWxsKGksKGZ1bmN0aW9uKHQpe3JldHVybiB0LnVwZGF0ZWREYXRhfSkpfTtyZXR1cm4gdGhpcy5fdHJpZ2dlcihcInVwZGF0ZVwiLG8sZSksby5pdGVtc31yZXR1cm5bXX19LHtrZXk6XCJnZXRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciByPXZvaWQgMCxuPXZvaWQgMCxpPXZvaWQgMDtZXyh0KT8ocj10LGk9ZSk6UGgodCk/KG49dCxpPWUpOmk9dDt2YXIgbyxhPWkmJlwiT2JqZWN0XCI9PT1pLnJldHVyblR5cGU/XCJPYmplY3RcIjpcIkFycmF5XCIsdT1pJiZqaShpKSxzPVtdLGM9dm9pZCAwLGY9dm9pZCAwLGw9dm9pZCAwO2lmKG51bGwhPXIpKGM9dGhpcy5fZGF0YS5nZXQocikpJiZ1JiYhdShjKSYmKGM9dm9pZCAwKTtlbHNlIGlmKG51bGwhPW4pZm9yKHZhciBoPTAscD1uLmxlbmd0aDtoPHA7aCsrKW51bGw9PShjPXRoaXMuX2RhdGEuZ2V0KG5baF0pKXx8dSYmIXUoYyl8fHMucHVzaChjKTtlbHNlIGZvcih2YXIgdixkPTAseT0oZj13aChMYih2PXRoaXMuX2RhdGEpLmNhbGwodikpKS5sZW5ndGg7ZDx5O2QrKylsPWZbZF0sbnVsbD09KGM9dGhpcy5fZGF0YS5nZXQobCkpfHx1JiYhdShjKXx8cy5wdXNoKGMpO2lmKGkmJmkub3JkZXImJm51bGw9PXImJnRoaXMuX3NvcnQocyxpLm9yZGVyKSxpJiZpLmZpZWxkcyl7dmFyIGc9aS5maWVsZHM7aWYobnVsbCE9ciYmbnVsbCE9YyljPXRoaXMuX2ZpbHRlckZpZWxkcyhjLGcpO2Vsc2UgZm9yKHZhciBtPTAsYj1zLmxlbmd0aDttPGI7bSsrKXNbbV09dGhpcy5fZmlsdGVyRmllbGRzKHNbbV0sZyl9aWYoXCJPYmplY3RcIj09YSl7Zm9yKHZhciBfPXt9LHc9MCxPPXMubGVuZ3RoO3c8Tzt3Kyspe3ZhciBFPXNbd107X1tFW3RoaXMuX2lkUHJvcF1dPUV9cmV0dXJuIF99cmV0dXJuIG51bGwhPXI/bnVsbCE9PShvPWMpJiZ2b2lkIDAhPT1vP286bnVsbDpzfX0se2tleTpcImdldElkc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2RhdGEscj10JiZqaSh0KSxuPXQmJnQub3JkZXIsaT13aChMYihlKS5jYWxsKGUpKSxvPVtdO2lmKHIpaWYobil7Zm9yKHZhciBhPVtdLHU9MCxzPWkubGVuZ3RoO3U8czt1Kyspe3ZhciBjPWlbdV0sZj10aGlzLl9kYXRhLmdldChjKTtudWxsIT1mJiZyKGYpJiZhLnB1c2goZil9dGhpcy5fc29ydChhLG4pO2Zvcih2YXIgbD0wLGg9YS5sZW5ndGg7bDxoO2wrKylvLnB1c2goYVtsXVt0aGlzLl9pZFByb3BdKX1lbHNlIGZvcih2YXIgcD0wLHY9aS5sZW5ndGg7cDx2O3ArKyl7dmFyIGQ9aVtwXSx5PXRoaXMuX2RhdGEuZ2V0KGQpO251bGwhPXkmJnIoeSkmJm8ucHVzaCh5W3RoaXMuX2lkUHJvcF0pfWVsc2UgaWYobil7Zm9yKHZhciBnPVtdLG09MCxiPWkubGVuZ3RoO208YjttKyspe3ZhciBfPWlbbV07Zy5wdXNoKGUuZ2V0KF8pKX10aGlzLl9zb3J0KGcsbik7Zm9yKHZhciB3PTAsTz1nLmxlbmd0aDt3PE87dysrKW8ucHVzaChnW3ddW3RoaXMuX2lkUHJvcF0pfWVsc2UgZm9yKHZhciBFPTAsVD1pLmxlbmd0aDtFPFQ7RSsrKXt2YXIgeD1pW0VdLGs9ZS5nZXQoeCk7bnVsbCE9ayYmby5wdXNoKGtbdGhpcy5faWRQcm9wXSl9cmV0dXJuIG99fSx7a2V5OlwiZ2V0RGF0YVNldFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9fSx7a2V5OlwiZm9yRWFjaFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIHI9ZSYmamkoZSksbj10aGlzLl9kYXRhLGk9d2goTGIobikuY2FsbChuKSk7aWYoZSYmZS5vcmRlcilmb3IodmFyIG89dGhpcy5nZXQoZSksYT0wLHU9by5sZW5ndGg7YTx1O2ErKyl7dmFyIHM9b1thXTt0KHMsc1t0aGlzLl9pZFByb3BdKX1lbHNlIGZvcih2YXIgYz0wLGY9aS5sZW5ndGg7YzxmO2MrKyl7dmFyIGw9aVtjXSxoPXRoaXMuX2RhdGEuZ2V0KGwpO251bGw9PWh8fHImJiFyKGgpfHx0KGgsbCl9fX0se2tleTpcIm1hcFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPWUmJmppKGUpLG49W10saT10aGlzLl9kYXRhLG89d2goTGIoaSkuY2FsbChpKSksYT0wLHU9by5sZW5ndGg7YTx1O2ErKyl7dmFyIHM9b1thXSxjPXRoaXMuX2RhdGEuZ2V0KHMpO251bGw9PWN8fHImJiFyKGMpfHxuLnB1c2godChjLHMpKX1yZXR1cm4gZSYmZS5vcmRlciYmdGhpcy5fc29ydChuLGUub3JkZXIpLG59fSx7a2V5OlwiX2ZpbHRlckZpZWxkc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIHI7cmV0dXJuIHQ/U24ocj1QaChlKT9lOkxoKGUpKS5jYWxsKHIsKGZ1bmN0aW9uKGUscil7cmV0dXJuIGVbcl09dFtyXSxlfSkse30pOnR9fSx7a2V5OlwiX3NvcnRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXt2YXIgcj1lO3lfKHQpLmNhbGwodCwoZnVuY3Rpb24odCxlKXt2YXIgbj10W3JdLGk9ZVtyXTtyZXR1cm4gbj5pPzE6bjxpPy0xOjB9KSl9ZWxzZXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJPcmRlciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcIik7eV8odCkuY2FsbCh0LGUpfX19LHtrZXk6XCJyZW1vdmVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgcj1bXSxuPVtdLGk9UGgodCk/dDpbdF0sbz0wLGE9aS5sZW5ndGg7bzxhO28rKyl7dmFyIHU9dGhpcy5fcmVtb3ZlKGlbb10pO2lmKHUpe3ZhciBzPXVbdGhpcy5faWRQcm9wXTtudWxsIT1zJiYoci5wdXNoKHMpLG4ucHVzaCh1KSl9fXJldHVybiByLmxlbmd0aCYmdGhpcy5fdHJpZ2dlcihcInJlbW92ZVwiLHtpdGVtczpyLG9sZERhdGE6bn0sZSkscn19LHtrZXk6XCJfcmVtb3ZlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU7aWYoWV8odCk/ZT10OnQmJlwib2JqZWN0XCI9PT1faCh0KSYmKGU9dFt0aGlzLl9pZFByb3BdKSxudWxsIT1lJiZ0aGlzLl9kYXRhLmhhcyhlKSl7dmFyIHI9dGhpcy5fZGF0YS5nZXQoZSl8fG51bGw7cmV0dXJuIHRoaXMuX2RhdGEuZGVsZXRlKGUpLC0tdGhpcy5sZW5ndGgscn1yZXR1cm4gbnVsbH19LHtrZXk6XCJjbGVhclwiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxyPXdoKExiKGU9dGhpcy5fZGF0YSkuY2FsbChlKSksbj1bXSxpPTAsbz1yLmxlbmd0aDtpPG87aSsrKW4ucHVzaCh0aGlzLl9kYXRhLmdldChyW2ldKSk7cmV0dXJuIHRoaXMuX2RhdGEuY2xlYXIoKSx0aGlzLmxlbmd0aD0wLHRoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIix7aXRlbXM6cixvbGREYXRhOm59LHQpLHJ9fSx7a2V5OlwibWF4XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGUscixuPW51bGwsaT1udWxsLG89UV8oVF8oZT10aGlzLl9kYXRhKS5jYWxsKGUpKTt0cnl7Zm9yKG8ucygpOyEocj1vLm4oKSkuZG9uZTspe3ZhciBhPXIudmFsdWUsdT1hW3RdO1wibnVtYmVyXCI9PXR5cGVvZiB1JiYobnVsbD09aXx8dT5pKSYmKG49YSxpPXUpfX1jYXRjaCh0KXtvLmUodCl9ZmluYWxseXtvLmYoKX1yZXR1cm4gbnx8bnVsbH19LHtrZXk6XCJtaW5cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZSxyLG49bnVsbCxpPW51bGwsbz1RXyhUXyhlPXRoaXMuX2RhdGEpLmNhbGwoZSkpO3RyeXtmb3Ioby5zKCk7IShyPW8ubigpKS5kb25lOyl7dmFyIGE9ci52YWx1ZSx1PWFbdF07XCJudW1iZXJcIj09dHlwZW9mIHUmJihudWxsPT1pfHx1PGkpJiYobj1hLGk9dSl9fWNhdGNoKHQpe28uZSh0KX1maW5hbGx5e28uZigpfXJldHVybiBufHxudWxsfX0se2tleTpcImRpc3RpbmN0XCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuX2RhdGEscj13aChMYihlKS5jYWxsKGUpKSxuPVtdLGk9MCxvPTAsYT1yLmxlbmd0aDtvPGE7bysrKXtmb3IodmFyIHU9cltvXSxzPWUuZ2V0KHUpW3RdLGM9ITEsZj0wO2Y8aTtmKyspaWYobltmXT09cyl7Yz0hMDticmVha31jfHx2b2lkIDA9PT1zfHwobltpXT1zLGkrKyl9cmV0dXJuIG59fSx7a2V5OlwiX2FkZEl0ZW1cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbih0LGUpe3JldHVybiBudWxsPT10W2VdJiYodFtlXT1xXygpKSx0fSh0LHRoaXMuX2lkUHJvcCkscj1lW3RoaXMuX2lkUHJvcF07aWYodGhpcy5fZGF0YS5oYXMocikpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBpdGVtOiBpdGVtIHdpdGggaWQgXCIrcitcIiBhbHJlYWR5IGV4aXN0c1wiKTtyZXR1cm4gdGhpcy5fZGF0YS5zZXQocixlKSwrK3RoaXMubGVuZ3RoLHJ9fSx7a2V5OlwiX3VwZGF0ZUl0ZW1cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10W3RoaXMuX2lkUHJvcF07aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIGl0ZW06IGl0ZW0gaGFzIG5vIGlkIChpdGVtOiBcIitzZCh0KStcIilcIik7dmFyIHI9dGhpcy5fZGF0YS5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVwZGF0ZSBpdGVtOiBubyBpdGVtIHdpdGggaWQgXCIrZStcIiBmb3VuZFwiKTtyZXR1cm4gdGhpcy5fZGF0YS5zZXQoZSxLXyhLXyh7fSxyKSx0KSksZX19LHtrZXk6XCJzdHJlYW1cIix2YWx1ZTpmdW5jdGlvbih0KXtpZih0KXt2YXIgZT10aGlzLl9kYXRhO3JldHVybiBuZXcgQl8oQ3Ioe30seF8sS2cubWFyaygoZnVuY3Rpb24gcigpe3ZhciBuLGksbyxhO3JldHVybiBLZy53cmFwKChmdW5jdGlvbihyKXtmb3IoOzspc3dpdGNoKHIucHJldj1yLm5leHQpe2Nhc2UgMDpuPVFfKHQpLHIucHJldj0xLG4ucygpO2Nhc2UgMzppZigoaT1uLm4oKSkuZG9uZSl7ci5uZXh0PTExO2JyZWFrfWlmKG89aS52YWx1ZSxudWxsPT0oYT1lLmdldChvKSkpe3IubmV4dD05O2JyZWFrfXJldHVybiByLm5leHQ9OSxbbyxhXTtjYXNlIDk6ci5uZXh0PTM7YnJlYWs7Y2FzZSAxMTpyLm5leHQ9MTY7YnJlYWs7Y2FzZSAxMzpyLnByZXY9MTMsci50MD1yLmNhdGNoKDEpLG4uZShyLnQwKTtjYXNlIDE2OnJldHVybiByLnByZXY9MTYsbi5mKCksci5maW5pc2goMTYpO2Nhc2UgMTk6Y2FzZVwiZW5kXCI6cmV0dXJuIHIuc3RvcCgpfX0pLHIsbnVsbCxbWzEsMTMsMTYsMTldXSl9KSkpKX12YXIgcjtyZXR1cm4gbmV3IEJfKENyKHt9LHhfLGVuKHI9TF8odGhpcy5fZGF0YSkpLmNhbGwocix0aGlzLl9kYXRhKSkpfX1dKSxufShYXyk7ZnVuY3Rpb24gcncodCxlKXt2YXIgcj12b2lkIDAhPT1PaCYmaWModCl8fHRbXCJAQGl0ZXJhdG9yXCJdO2lmKCFyKXtpZihQaCh0KXx8KHI9ZnVuY3Rpb24odCxlKXt2YXIgcjtpZighdClyZXR1cm47aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIG53KHQsZSk7dmFyIG49QWgocj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpLmNhbGwociw4LC0xKTtcIk9iamVjdFwiPT09biYmdC5jb25zdHJ1Y3RvciYmKG49dC5jb25zdHJ1Y3Rvci5uYW1lKTtpZihcIk1hcFwiPT09bnx8XCJTZXRcIj09PW4pcmV0dXJuIHFzKHQpO2lmKFwiQXJndW1lbnRzXCI9PT1ufHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSlyZXR1cm4gbncodCxlKX0odCkpfHxlJiZ0JiZcIm51bWJlclwiPT10eXBlb2YgdC5sZW5ndGgpe3ImJih0PXIpO3ZhciBuPTAsaT1mdW5jdGlvbigpe307cmV0dXJue3M6aSxuOmZ1bmN0aW9uKCl7cmV0dXJuIG4+PXQubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTp0W24rK119fSxlOmZ1bmN0aW9uKHQpe3Rocm93IHR9LGY6aX19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXZhciBvLGE9ITAsdT0hMTtyZXR1cm57czpmdW5jdGlvbigpe3I9ci5jYWxsKHQpfSxuOmZ1bmN0aW9uKCl7dmFyIHQ9ci5uZXh0KCk7cmV0dXJuIGE9dC5kb25lLHR9LGU6ZnVuY3Rpb24odCl7dT0hMCxvPXR9LGY6ZnVuY3Rpb24oKXt0cnl7YXx8bnVsbD09ci5yZXR1cm58fHIucmV0dXJuKCl9ZmluYWxseXtpZih1KXRocm93IG99fX19ZnVuY3Rpb24gbncodCxlKXsobnVsbD09ZXx8ZT50Lmxlbmd0aCkmJihlPXQubGVuZ3RoKTtmb3IodmFyIHI9MCxuPW5ldyBBcnJheShlKTtyPGU7cisrKW5bcl09dFtyXTtyZXR1cm4gbn1mdW5jdGlvbiBpdyh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhWWcpcmV0dXJuITE7aWYoWWcuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChZZyhCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciByLG49QmcodCk7aWYoZSl7dmFyIGk9QmcodGhpcykuY29uc3RydWN0b3I7cj1ZZyhuLGFyZ3VtZW50cyxpKX1lbHNlIHI9bi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIEhnKHRoaXMscil9fXZhciBvdz1mdW5jdGlvbih0KXtWZyhuLHQpO3ZhciByPWl3KG4pO2Z1bmN0aW9uIG4odCxpKXt2YXIgbyxhO3JldHVybiBlKHRoaXMsbiksQ3IoR2coYT1yLmNhbGwodGhpcykpLFwibGVuZ3RoXCIsMCksQ3IoR2coYSksXCJfbGlzdGVuZXJcIix2b2lkIDApLENyKEdnKGEpLFwiX2RhdGFcIix2b2lkIDApLENyKEdnKGEpLFwiX2lkc1wiLG5ldyBXXyksQ3IoR2coYSksXCJfb3B0aW9uc1wiLHZvaWQgMCksYS5fb3B0aW9ucz1pfHx7fSxhLl9saXN0ZW5lcj1lbihvPWEuX29uRXZlbnQpLmNhbGwobyxHZyhhKSksYS5zZXREYXRhKHQpLGF9cmV0dXJuIExyKG4sW3trZXk6XCJpZFByb3BcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXREYXRhU2V0KCkuaWRQcm9wfX0se2tleTpcInNldERhdGFcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih0aGlzLl9kYXRhKXt0aGlzLl9kYXRhLm9mZiYmdGhpcy5fZGF0YS5vZmYoXCIqXCIsdGhpcy5fbGlzdGVuZXIpO3ZhciBlPXRoaXMuX2RhdGEuZ2V0SWRzKHtmaWx0ZXI6amkodGhpcy5fb3B0aW9ucyl9KSxyPXRoaXMuX2RhdGEuZ2V0KGUpO3RoaXMuX2lkcy5jbGVhcigpLHRoaXMubGVuZ3RoPTAsdGhpcy5fdHJpZ2dlcihcInJlbW92ZVwiLHtpdGVtczplLG9sZERhdGE6cn0pfWlmKG51bGwhPXQpe3RoaXMuX2RhdGE9dDtmb3IodmFyIG49dGhpcy5fZGF0YS5nZXRJZHMoe2ZpbHRlcjpqaSh0aGlzLl9vcHRpb25zKX0pLGk9MCxvPW4ubGVuZ3RoO2k8bztpKyspe3ZhciBhPW5baV07dGhpcy5faWRzLmFkZChhKX10aGlzLmxlbmd0aD1uLmxlbmd0aCx0aGlzLl90cmlnZ2VyKFwiYWRkXCIse2l0ZW1zOm59KX1lbHNlIHRoaXMuX2RhdGE9bmV3IGV3O3RoaXMuX2RhdGEub24mJnRoaXMuX2RhdGEub24oXCIqXCIsdGhpcy5fbGlzdGVuZXIpfX0se2tleTpcInJlZnJlc2hcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLl9kYXRhLmdldElkcyh7ZmlsdGVyOmppKHRoaXMuX29wdGlvbnMpfSksZT13aCh0aGlzLl9pZHMpLHI9e30sbj1bXSxpPVtdLG89W10sYT0wLHU9dC5sZW5ndGg7YTx1O2ErKyl7dmFyIHM9dFthXTtyW3NdPSEwLHRoaXMuX2lkcy5oYXMocyl8fChuLnB1c2gocyksdGhpcy5faWRzLmFkZChzKSl9Zm9yKHZhciBjPTAsZj1lLmxlbmd0aDtjPGY7YysrKXt2YXIgbD1lW2NdLGg9dGhpcy5fZGF0YS5nZXQobCk7bnVsbD09aD9jb25zb2xlLmVycm9yKFwiSWYgeW91IHNlZSB0aGlzLCByZXBvcnQgaXQgcGxlYXNlLlwiKTpyW2xdfHwoaS5wdXNoKGwpLG8ucHVzaChoKSx0aGlzLl9pZHMuZGVsZXRlKGwpKX10aGlzLmxlbmd0aCs9bi5sZW5ndGgtaS5sZW5ndGgsbi5sZW5ndGgmJnRoaXMuX3RyaWdnZXIoXCJhZGRcIix7aXRlbXM6bn0pLGkubGVuZ3RoJiZ0aGlzLl90cmlnZ2VyKFwicmVtb3ZlXCIse2l0ZW1zOmksb2xkRGF0YTpvfSl9fSx7a2V5OlwiZ2V0XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZihudWxsPT10aGlzLl9kYXRhKXJldHVybiBudWxsO3ZhciByLG49bnVsbDtZXyh0KXx8UGgodCk/KG49dCxyPWUpOnI9dDt2YXIgaT1NcCh7fSx0aGlzLl9vcHRpb25zLHIpLG89amkodGhpcy5fb3B0aW9ucyksYT1yJiZqaShyKTtyZXR1cm4gbyYmYSYmKGkuZmlsdGVyPWZ1bmN0aW9uKHQpe3JldHVybiBvKHQpJiZhKHQpfSksbnVsbD09bj90aGlzLl9kYXRhLmdldChpKTp0aGlzLl9kYXRhLmdldChuLGkpfX0se2tleTpcImdldElkc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHRoaXMuX2RhdGEubGVuZ3RoKXt2YXIgZSxyPWppKHRoaXMuX29wdGlvbnMpLG49bnVsbCE9dD9qaSh0KTpudWxsO3JldHVybiBlPW4/cj9mdW5jdGlvbih0KXtyZXR1cm4gcih0KSYmbih0KX06bjpyLHRoaXMuX2RhdGEuZ2V0SWRzKHtmaWx0ZXI6ZSxvcmRlcjp0JiZ0Lm9yZGVyfSl9cmV0dXJuW119fSx7a2V5OlwiZm9yRWFjaFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYodGhpcy5fZGF0YSl7dmFyIHIsbixpPWppKHRoaXMuX29wdGlvbnMpLG89ZSYmamkoZSk7bj1vP2k/ZnVuY3Rpb24odCl7cmV0dXJuIGkodCkmJm8odCl9Om86aSxIaChyPXRoaXMuX2RhdGEpLmNhbGwocix0LHtmaWx0ZXI6bixvcmRlcjplJiZlLm9yZGVyfSl9fX0se2tleTpcIm1hcFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYodGhpcy5fZGF0YSl7dmFyIHIsbixpPWppKHRoaXMuX29wdGlvbnMpLG89ZSYmamkoZSk7cmV0dXJuIG49bz9pP2Z1bmN0aW9uKHQpe3JldHVybiBpKHQpJiZvKHQpfTpvOmksUmkocj10aGlzLl9kYXRhKS5jYWxsKHIsdCx7ZmlsdGVyOm4sb3JkZXI6ZSYmZS5vcmRlcn0pfXJldHVybltdfX0se2tleTpcImdldERhdGFTZXRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9kYXRhLmdldERhdGFTZXQoKX19LHtrZXk6XCJzdHJlYW1cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gdGhpcy5fZGF0YS5zdHJlYW0odHx8Q3Ioe30seF8sZW4oZT1MYih0aGlzLl9pZHMpKS5jYWxsKGUsdGhpcy5faWRzKSkpfX0se2tleTpcImRpc3Bvc2VcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0O251bGwhPT0odD10aGlzLl9kYXRhKSYmdm9pZCAwIT09dCYmdC5vZmYmJnRoaXMuX2RhdGEub2ZmKFwiKlwiLHRoaXMuX2xpc3RlbmVyKTt2YXIgZSxyPVwiVGhpcyBkYXRhIHZpZXcgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZCBvZi5cIixpPXtnZXQ6ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3Iocil9LHNldDpmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihyKX0sY29uZmlndXJhYmxlOiExfSxvPXJ3KGpoKG4ucHJvdG90eXBlKSk7dHJ5e2ZvcihvLnMoKTshKGU9by5uKCkpLmRvbmU7KXt2YXIgYT1lLnZhbHVlO0VsKHRoaXMsYSxpKX19Y2F0Y2godCl7by5lKHQpfWZpbmFsbHl7by5mKCl9fX0se2tleTpcIl9vbkV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24odCxlLHIpe2lmKGUmJmUuaXRlbXMmJnRoaXMuX2RhdGEpe3ZhciBuPWUuaXRlbXMsaT1bXSxvPVtdLGE9W10sdT1bXSxzPVtdLGM9W107c3dpdGNoKHQpe2Nhc2VcImFkZFwiOmZvcih2YXIgZj0wLGw9bi5sZW5ndGg7ZjxsO2YrKyl7dmFyIGg9bltmXTt0aGlzLmdldChoKSYmKHRoaXMuX2lkcy5hZGQoaCksaS5wdXNoKGgpKX1icmVhaztjYXNlXCJ1cGRhdGVcIjpmb3IodmFyIHA9MCx2PW4ubGVuZ3RoO3A8djtwKyspe3ZhciBkPW5bcF07dGhpcy5nZXQoZCk/dGhpcy5faWRzLmhhcyhkKT8oby5wdXNoKGQpLHMucHVzaChlLmRhdGFbcF0pLHUucHVzaChlLm9sZERhdGFbcF0pKToodGhpcy5faWRzLmFkZChkKSxpLnB1c2goZCkpOnRoaXMuX2lkcy5oYXMoZCkmJih0aGlzLl9pZHMuZGVsZXRlKGQpLGEucHVzaChkKSxjLnB1c2goZS5vbGREYXRhW3BdKSl9YnJlYWs7Y2FzZVwicmVtb3ZlXCI6Zm9yKHZhciB5PTAsZz1uLmxlbmd0aDt5PGc7eSsrKXt2YXIgbT1uW3ldO3RoaXMuX2lkcy5oYXMobSkmJih0aGlzLl9pZHMuZGVsZXRlKG0pLGEucHVzaChtKSxjLnB1c2goZS5vbGREYXRhW3ldKSl9fXRoaXMubGVuZ3RoKz1pLmxlbmd0aC1hLmxlbmd0aCxpLmxlbmd0aCYmdGhpcy5fdHJpZ2dlcihcImFkZFwiLHtpdGVtczppfSxyKSxvLmxlbmd0aCYmdGhpcy5fdHJpZ2dlcihcInVwZGF0ZVwiLHtpdGVtczpvLG9sZERhdGE6dSxkYXRhOnN9LHIpLGEubGVuZ3RoJiZ0aGlzLl90cmlnZ2VyKFwicmVtb3ZlXCIse2l0ZW1zOmEsb2xkRGF0YTpjfSxyKX19fV0pLG59KFhfKTtmdW5jdGlvbiBhdyh0LGUpe3JldHVyblwib2JqZWN0XCI9PT1faChlKSYmbnVsbCE9PWUmJnQ9PT1lLmlkUHJvcCYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5hZGQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuY2xlYXImJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZGlzdGluY3QmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEhoKGUpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmdldCYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5nZXREYXRhU2V0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmdldElkcyYmXCJudW1iZXJcIj09dHlwZW9mIGUubGVuZ3RoJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBSaShlKSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5tYXgmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUubWluJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLm9mZiYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5vbiYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5yZW1vdmUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuc2V0T3B0aW9ucyYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5zdHJlYW0mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUudXBkYXRlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnVwZGF0ZU9ubHl9dC5ERUxFVEU9Z2csdC5EYXRhU2V0PWV3LHQuRGF0YVN0cmVhbT1CXyx0LkRhdGFWaWV3PW93LHQuUXVldWU9R18sdC5jcmVhdGVOZXdEYXRhUGlwZUZyb209ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlbyh0KX0sdC5pc0RhdGFTZXRMaWtlPWF3LHQuaXNEYXRhVmlld0xpa2U9ZnVuY3Rpb24odCxlKXtyZXR1cm5cIm9iamVjdFwiPT09X2goZSkmJm51bGwhPT1lJiZ0PT09ZS5pZFByb3AmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEhoKGUpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmdldCYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5nZXREYXRhU2V0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmdldElkcyYmXCJudW1iZXJcIj09dHlwZW9mIGUubGVuZ3RoJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBSaShlKSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5vZmYmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUub24mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuc3RyZWFtJiZhdyh0LGUuZ2V0RGF0YVNldCgpKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aXMtZGF0YS5taW4uanMubWFwXG4iLCIvKipcbiAqIHZpcy1uZXR3b3JrXG4gKiBodHRwczovL3Zpc2pzLmdpdGh1Yi5pby92aXMtbmV0d29yay9cbiAqXG4gKiBBIGR5bmFtaWMsIGJyb3dzZXItYmFzZWQgdmlzdWFsaXphdGlvbiBsaWJyYXJ5LlxuICpcbiAqIEB2ZXJzaW9uIDkuMC40XG4gKiBAZGF0ZSAgICAyMDIxLTAzLTE2VDA1OjQxOjQwLjgxOFpcbiAqXG4gKiBAY29weXJpZ2h0IChjKSAyMDExLTIwMTcgQWxtZW5kZSBCLlYsIGh0dHA6Ly9hbG1lbmRlLmNvbVxuICogQGNvcHlyaWdodCAoYykgMjAxNy0yMDE5IHZpc2pzIGNvbnRyaWJ1dG9ycywgaHR0cHM6Ly9naXRodWIuY29tL3Zpc2pzXG4gKlxuICogQGxpY2Vuc2VcbiAqIHZpcy5qcyBpcyBkdWFsIGxpY2Vuc2VkIHVuZGVyIGJvdGhcbiAqXG4gKiAgIDEuIFRoZSBBcGFjaGUgMi4wIExpY2Vuc2VcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogICBhbmRcbiAqXG4gKiAgIDIuIFRoZSBNSVQgTGljZW5zZVxuICogICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogdmlzLmpzIG1heSBiZSBkaXN0cmlidXRlZCB1bmRlciBlaXRoZXIgbGljZW5zZS5cbiAqL1xuIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/ZShleHBvcnRzLHJlcXVpcmUoXCJ2aXMtZGF0YS9wZWVyL3VtZC92aXMtZGF0YS5qc1wiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCIsXCJ2aXMtZGF0YS9wZWVyL3VtZC92aXMtZGF0YS5qc1wiXSxlKTplKCh0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6dHx8c2VsZikudmlzPXQudmlzfHx7fSx0LnZpcyl9KHRoaXMsKGZ1bmN0aW9uKHQsZSl7dmFyIGk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnt9O2Z1bmN0aW9uIG8odCl7dmFyIGU9e2V4cG9ydHM6e319O3JldHVybiB0KGUsZS5leHBvcnRzKSxlLmV4cG9ydHN9dmFyIG49ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuTWF0aD09TWF0aCYmdH0scj1uKFwib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWxUaGlzJiZnbG9iYWxUaGlzKXx8bihcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cpfHxuKFwib2JqZWN0XCI9PXR5cGVvZiBzZWxmJiZzZWxmKXx8bihcIm9iamVjdFwiPT10eXBlb2YgaSYmaSl8fGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCl8fEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSxzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4hIXQoKX1jYXRjaCh0KXtyZXR1cm4hMH19LGE9IXMoKGZ1bmN0aW9uKCl7cmV0dXJuIDchPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwxLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KVsxXX0pKSxoPXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLGQ9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixsPXtmOmQmJiFoLmNhbGwoezE6Mn0sMSk/ZnVuY3Rpb24odCl7dmFyIGU9ZCh0aGlzLHQpO3JldHVybiEhZSYmZS5lbnVtZXJhYmxlfTpofSxjPWZ1bmN0aW9uKHQsZSl7cmV0dXJue2VudW1lcmFibGU6ISgxJnQpLGNvbmZpZ3VyYWJsZTohKDImdCksd3JpdGFibGU6ISg0JnQpLHZhbHVlOmV9fSx1PXt9LnRvU3RyaW5nLGY9ZnVuY3Rpb24odCl7cmV0dXJuIHUuY2FsbCh0KS5zbGljZSg4LC0xKX0scD1cIlwiLnNwbGl0LHY9cygoZnVuY3Rpb24oKXtyZXR1cm4hT2JqZWN0KFwielwiKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKX0pKT9mdW5jdGlvbih0KXtyZXR1cm5cIlN0cmluZ1wiPT1mKHQpP3AuY2FsbCh0LFwiXCIpOk9iamVjdCh0KX06T2JqZWN0LGc9ZnVuY3Rpb24odCl7aWYobnVsbD09dCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIit0KTtyZXR1cm4gdH0seT1mdW5jdGlvbih0KXtyZXR1cm4gdihnKHQpKX0sbT1mdW5jdGlvbih0KXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgdD9udWxsIT09dDpcImZ1bmN0aW9uXCI9PXR5cGVvZiB0fSxiPWZ1bmN0aW9uKHQsZSl7aWYoIW0odCkpcmV0dXJuIHQ7dmFyIGksbztpZihlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZihpPXQudG9TdHJpbmcpJiYhbShvPWkuY2FsbCh0KSkpcmV0dXJuIG87aWYoXCJmdW5jdGlvblwiPT10eXBlb2YoaT10LnZhbHVlT2YpJiYhbShvPWkuY2FsbCh0KSkpcmV0dXJuIG87aWYoIWUmJlwiZnVuY3Rpb25cIj09dHlwZW9mKGk9dC50b1N0cmluZykmJiFtKG89aS5jYWxsKHQpKSlyZXR1cm4gbzt0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIil9LHc9e30uaGFzT3duUHJvcGVydHksaz1mdW5jdGlvbih0LGUpe3JldHVybiB3LmNhbGwodCxlKX0sXz1yLmRvY3VtZW50LHg9bShfKSYmbShfLmNyZWF0ZUVsZW1lbnQpLEU9ZnVuY3Rpb24odCl7cmV0dXJuIHg/Xy5jcmVhdGVFbGVtZW50KHQpOnt9fSxPPSFhJiYhcygoZnVuY3Rpb24oKXtyZXR1cm4gNyE9T2JqZWN0LmRlZmluZVByb3BlcnR5KEUoXCJkaXZcIiksXCJhXCIse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pLmF9KSksQz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFM9e2Y6YT9DOmZ1bmN0aW9uKHQsZSl7aWYodD15KHQpLGU9YihlLCEwKSxPKXRyeXtyZXR1cm4gQyh0LGUpfWNhdGNoKHQpe31pZihrKHQsZSkpcmV0dXJuIGMoIWwuZi5jYWxsKHQsZSksdFtlXSl9fSxUPS8jfFxcLnByb3RvdHlwZVxcLi8sTT1mdW5jdGlvbih0LGUpe3ZhciBpPURbUCh0KV07cmV0dXJuIGk9PUl8fGkhPUImJihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlP3MoZSk6ISFlKX0sUD1NLm5vcm1hbGl6ZT1mdW5jdGlvbih0KXtyZXR1cm4gU3RyaW5nKHQpLnJlcGxhY2UoVCxcIi5cIikudG9Mb3dlckNhc2UoKX0sRD1NLmRhdGE9e30sQj1NLk5BVElWRT1cIk5cIixJPU0uUE9MWUZJTEw9XCJQXCIsej1NLEY9e30sTj1mdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IFR5cGVFcnJvcihTdHJpbmcodCkrXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7cmV0dXJuIHR9LEE9ZnVuY3Rpb24odCxlLGkpe2lmKE4odCksdm9pZCAwPT09ZSlyZXR1cm4gdDtzd2l0Y2goaSl7Y2FzZSAwOnJldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmNhbGwoZSl9O2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24oaSl7cmV0dXJuIHQuY2FsbChlLGkpfTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKGksbyl7cmV0dXJuIHQuY2FsbChlLGksbyl9O2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24oaSxvLG4pe3JldHVybiB0LmNhbGwoZSxpLG8sbil9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KGUsYXJndW1lbnRzKX19LFI9ZnVuY3Rpb24odCl7aWYoIW0odCkpdGhyb3cgVHlwZUVycm9yKFN0cmluZyh0KStcIiBpcyBub3QgYW4gb2JqZWN0XCIpO3JldHVybiB0fSxqPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxMPXtmOmE/ajpmdW5jdGlvbih0LGUsaSl7aWYoUih0KSxlPWIoZSwhMCksUihpKSxPKXRyeXtyZXR1cm4gaih0LGUsaSl9Y2F0Y2godCl7fWlmKFwiZ2V0XCJpbiBpfHxcInNldFwiaW4gaSl0aHJvdyBUeXBlRXJyb3IoXCJBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm5cInZhbHVlXCJpbiBpJiYodFtlXT1pLnZhbHVlKSx0fX0sSD1hP2Z1bmN0aW9uKHQsZSxpKXtyZXR1cm4gTC5mKHQsZSxjKDEsaSkpfTpmdW5jdGlvbih0LGUsaSl7cmV0dXJuIHRbZV09aSx0fSxXPVMuZixWPWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKGUsaSxvKXtpZih0aGlzIGluc3RhbmNlb2YgdCl7c3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbmV3IHQ7Y2FzZSAxOnJldHVybiBuZXcgdChlKTtjYXNlIDI6cmV0dXJuIG5ldyB0KGUsaSl9cmV0dXJuIG5ldyB0KGUsaSxvKX1yZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3JldHVybiBlLnByb3RvdHlwZT10LnByb3RvdHlwZSxlfSxxPWZ1bmN0aW9uKHQsZSl7dmFyIGksbyxuLHMsYSxoLGQsbCxjPXQudGFyZ2V0LHU9dC5nbG9iYWwsZj10LnN0YXQscD10LnByb3RvLHY9dT9yOmY/cltjXToocltjXXx8e30pLnByb3RvdHlwZSxnPXU/RjpGW2NdfHwoRltjXT17fSkseT1nLnByb3RvdHlwZTtmb3IobiBpbiBlKWk9IXoodT9uOmMrKGY/XCIuXCI6XCIjXCIpK24sdC5mb3JjZWQpJiZ2JiZrKHYsbiksYT1nW25dLGkmJihoPXQubm9UYXJnZXRHZXQ/KGw9Vyh2LG4pKSYmbC52YWx1ZTp2W25dKSxzPWkmJmg/aDplW25dLGkmJnR5cGVvZiBhPT10eXBlb2Ygc3x8KGQ9dC5iaW5kJiZpP0EocyxyKTp0LndyYXAmJmk/VihzKTpwJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBzP0EoRnVuY3Rpb24uY2FsbCxzKTpzLCh0LnNoYW18fHMmJnMuc2hhbXx8YSYmYS5zaGFtKSYmSChkLFwic2hhbVwiLCEwKSxnW25dPWQscCYmKGsoRixvPWMrXCJQcm90b3R5cGVcIil8fEgoRixvLHt9KSxGW29dW25dPXMsdC5yZWFsJiZ5JiYheVtuXSYmSCh5LG4scykpKX0sVT1NYXRoLmNlaWwsWT1NYXRoLmZsb29yLFg9ZnVuY3Rpb24odCl7cmV0dXJuIGlzTmFOKHQ9K3QpPzA6KHQ+MD9ZOlUpKHQpfSxHPU1hdGgubWluLEs9ZnVuY3Rpb24odCl7cmV0dXJuIHQ+MD9HKFgodCksOTAwNzE5OTI1NDc0MDk5MSk6MH0sJD1NYXRoLm1heCxRPU1hdGgubWluLFo9ZnVuY3Rpb24odCxlKXt2YXIgaT1YKHQpO3JldHVybiBpPDA/JChpK2UsMCk6UShpLGUpfSxKPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLGksbyl7dmFyIG4scj15KGUpLHM9SyhyLmxlbmd0aCksYT1aKG8scyk7aWYodCYmaSE9aSl7Zm9yKDtzPmE7KWlmKChuPXJbYSsrXSkhPW4pcmV0dXJuITB9ZWxzZSBmb3IoO3M+YTthKyspaWYoKHR8fGEgaW4gcikmJnJbYV09PT1pKXJldHVybiB0fHxhfHwwO3JldHVybiF0JiYtMX19LHR0PXtpbmNsdWRlczpKKCEwKSxpbmRleE9mOkooITEpfSxldD17fSxpdD10dC5pbmRleE9mLG90PWZ1bmN0aW9uKHQsZSl7dmFyIGksbz15KHQpLG49MCxyPVtdO2ZvcihpIGluIG8pIWsoZXQsaSkmJmsobyxpKSYmci5wdXNoKGkpO2Zvcig7ZS5sZW5ndGg+bjspayhvLGk9ZVtuKytdKSYmKH5pdChyLGkpfHxyLnB1c2goaSkpO3JldHVybiByfSxudD1bXCJjb25zdHJ1Y3RvclwiLFwiaGFzT3duUHJvcGVydHlcIixcImlzUHJvdG90eXBlT2ZcIixcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsXCJ0b0xvY2FsZVN0cmluZ1wiLFwidG9TdHJpbmdcIixcInZhbHVlT2ZcIl0scnQ9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKHQpe3JldHVybiBvdCh0LG50KX0sc3Q9e2Y6T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc30sYXQ9ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdChnKHQpKX0saHQ9T2JqZWN0LmFzc2lnbixkdD1PYmplY3QuZGVmaW5lUHJvcGVydHksbHQ9IWh0fHxzKChmdW5jdGlvbigpe2lmKGEmJjEhPT1odCh7YjoxfSxodChkdCh7fSxcImFcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtkdCh0aGlzLFwiYlwiLHt2YWx1ZTozLGVudW1lcmFibGU6ITF9KX19KSx7YjoyfSkpLmIpcmV0dXJuITA7dmFyIHQ9e30sZT17fSxpPVN5bWJvbCgpLG89XCJhYmNkZWZnaGlqa2xtbm9wcXJzdFwiO3JldHVybiB0W2ldPTcsby5zcGxpdChcIlwiKS5mb3JFYWNoKChmdW5jdGlvbih0KXtlW3RdPXR9KSksNyE9aHQoe30sdClbaV18fHJ0KGh0KHt9LGUpKS5qb2luKFwiXCIpIT1vfSkpP2Z1bmN0aW9uKHQsZSl7Zm9yKHZhciBpPWF0KHQpLG89YXJndW1lbnRzLmxlbmd0aCxuPTEscj1zdC5mLHM9bC5mO28+bjspZm9yKHZhciBoLGQ9dihhcmd1bWVudHNbbisrXSksYz1yP3J0KGQpLmNvbmNhdChyKGQpKTpydChkKSx1PWMubGVuZ3RoLGY9MDt1PmY7KWg9Y1tmKytdLGEmJiFzLmNhbGwoZCxoKXx8KGlbaF09ZFtoXSk7cmV0dXJuIGl9Omh0O3Eoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOk9iamVjdC5hc3NpZ24hPT1sdH0se2Fzc2lnbjpsdH0pO3ZhciBjdD1GLk9iamVjdC5hc3NpZ24sdXQ9W10uc2xpY2UsZnQ9e30scHQ9ZnVuY3Rpb24odCxlLGkpe2lmKCEoZSBpbiBmdCkpe2Zvcih2YXIgbz1bXSxuPTA7bjxlO24rKylvW25dPVwiYVtcIituK1wiXVwiO2Z0W2VdPUZ1bmN0aW9uKFwiQyxhXCIsXCJyZXR1cm4gbmV3IEMoXCIrby5qb2luKFwiLFwiKStcIilcIil9cmV0dXJuIGZ0W2VdKHQsaSl9LHZ0PUZ1bmN0aW9uLmJpbmR8fGZ1bmN0aW9uKHQpe3ZhciBlPU4odGhpcyksaT11dC5jYWxsKGFyZ3VtZW50cywxKSxvPWZ1bmN0aW9uKCl7dmFyIG49aS5jb25jYXQodXQuY2FsbChhcmd1bWVudHMpKTtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIG8/cHQoZSxuLmxlbmd0aCxuKTplLmFwcGx5KHQsbil9O3JldHVybiBtKGUucHJvdG90eXBlKSYmKG8ucHJvdG90eXBlPWUucHJvdG90eXBlKSxvfTtxKHt0YXJnZXQ6XCJGdW5jdGlvblwiLHByb3RvOiEwfSx7YmluZDp2dH0pO3ZhciBndD1mdW5jdGlvbih0KXtyZXR1cm4gRlt0K1wiUHJvdG90eXBlXCJdfSx5dD1ndChcIkZ1bmN0aW9uXCIpLmJpbmQsbXQ9RnVuY3Rpb24ucHJvdG90eXBlLGJ0PWZ1bmN0aW9uKHQpe3ZhciBlPXQuYmluZDtyZXR1cm4gdD09PW10fHx0IGluc3RhbmNlb2YgRnVuY3Rpb24mJmU9PT1tdC5iaW5kP3l0OmV9O2Z1bmN0aW9uIHd0KHQsZSxpLG8pe3QuYmVnaW5QYXRoKCksdC5hcmMoZSxpLG8sMCwyKk1hdGguUEksITEpLHQuY2xvc2VQYXRoKCl9ZnVuY3Rpb24ga3QodCxlLGksbyxuLHIpe3ZhciBzPU1hdGguUEkvMTgwO28tMipyPDAmJihyPW8vMiksbi0yKnI8MCYmKHI9bi8yKSx0LmJlZ2luUGF0aCgpLHQubW92ZVRvKGUrcixpKSx0LmxpbmVUbyhlK28tcixpKSx0LmFyYyhlK28tcixpK3IsciwyNzAqcywzNjAqcywhMSksdC5saW5lVG8oZStvLGkrbi1yKSx0LmFyYyhlK28tcixpK24tcixyLDAsOTAqcywhMSksdC5saW5lVG8oZStyLGkrbiksdC5hcmMoZStyLGkrbi1yLHIsOTAqcywxODAqcywhMSksdC5saW5lVG8oZSxpK3IpLHQuYXJjKGUrcixpK3IsciwxODAqcywyNzAqcywhMSksdC5jbG9zZVBhdGgoKX1mdW5jdGlvbiBfdCh0LGUsaSxvLG4pe3ZhciByPS41NTIyODQ4LHM9by8yKnIsYT1uLzIqcixoPWUrbyxkPWkrbixsPWUrby8yLGM9aStuLzI7dC5iZWdpblBhdGgoKSx0Lm1vdmVUbyhlLGMpLHQuYmV6aWVyQ3VydmVUbyhlLGMtYSxsLXMsaSxsLGkpLHQuYmV6aWVyQ3VydmVUbyhsK3MsaSxoLGMtYSxoLGMpLHQuYmV6aWVyQ3VydmVUbyhoLGMrYSxsK3MsZCxsLGQpLHQuYmV6aWVyQ3VydmVUbyhsLXMsZCxlLGMrYSxlLGMpLHQuY2xvc2VQYXRoKCl9ZnVuY3Rpb24geHQodCxlLGksbyxuKXt2YXIgcj1uKigxLzMpLHM9LjU1MjI4NDgsYT1vLzIqcyxoPXIvMipzLGQ9ZStvLGw9aStyLGM9ZStvLzIsdT1pK3IvMixmPWkrKG4tci8yKSxwPWkrbjt0LmJlZ2luUGF0aCgpLHQubW92ZVRvKGQsdSksdC5iZXppZXJDdXJ2ZVRvKGQsdStoLGMrYSxsLGMsbCksdC5iZXppZXJDdXJ2ZVRvKGMtYSxsLGUsdStoLGUsdSksdC5iZXppZXJDdXJ2ZVRvKGUsdS1oLGMtYSxpLGMsaSksdC5iZXppZXJDdXJ2ZVRvKGMrYSxpLGQsdS1oLGQsdSksdC5saW5lVG8oZCxmKSx0LmJlemllckN1cnZlVG8oZCxmK2gsYythLHAsYyxwKSx0LmJlemllckN1cnZlVG8oYy1hLHAsZSxmK2gsZSxmKSx0LmxpbmVUbyhlLHUpfWZ1bmN0aW9uIEV0KHQsZSxpLG8sbixyKXt0LmJlZ2luUGF0aCgpLHQubW92ZVRvKGUsaSk7Zm9yKHZhciBzPXIubGVuZ3RoLGE9by1lLGg9bi1pLGQ9aC9hLGw9TWF0aC5zcXJ0KGEqYStoKmgpLGM9MCx1PSEwLGY9MCxwPStyWzBdO2w+PS4xOykocD0rcltjKyslc10pPmwmJihwPWwpLGY9TWF0aC5zcXJ0KHAqcC8oMStkKmQpKSxlKz1mPWE8MD8tZjpmLGkrPWQqZiwhMD09PXU/dC5saW5lVG8oZSxpKTp0Lm1vdmVUbyhlLGkpLGwtPXAsdT0hdX12YXIgT3Q9e2NpcmNsZTp3dCxkYXNoZWRMaW5lOkV0LGRhdGFiYXNlOnh0LGRpYW1vbmQ6ZnVuY3Rpb24odCxlLGksbyl7dC5iZWdpblBhdGgoKSx0LmxpbmVUbyhlLGkrbyksdC5saW5lVG8oZStvLGkpLHQubGluZVRvKGUsaS1vKSx0LmxpbmVUbyhlLW8saSksdC5jbG9zZVBhdGgoKX0sZWxsaXBzZTpfdCxlbGxpcHNlX3ZpczpfdCxoZXhhZ29uOmZ1bmN0aW9uKHQsZSxpLG8pe3QuYmVnaW5QYXRoKCk7dmFyIG49MipNYXRoLlBJLzY7dC5tb3ZlVG8oZStvLGkpO2Zvcih2YXIgcj0xO3I8NjtyKyspdC5saW5lVG8oZStvKk1hdGguY29zKG4qciksaStvKk1hdGguc2luKG4qcikpO3QuY2xvc2VQYXRoKCl9LHJvdW5kUmVjdDprdCxzcXVhcmU6ZnVuY3Rpb24odCxlLGksbyl7dC5iZWdpblBhdGgoKSx0LnJlY3QoZS1vLGktbywyKm8sMipvKSx0LmNsb3NlUGF0aCgpfSxzdGFyOmZ1bmN0aW9uKHQsZSxpLG8pe3QuYmVnaW5QYXRoKCksaSs9LjEqKG8qPS44Mik7Zm9yKHZhciBuPTA7bjwxMDtuKyspe3ZhciByPW4lMj09MD8xLjMqbzouNSpvO3QubGluZVRvKGUrcipNYXRoLnNpbigyKm4qTWF0aC5QSS8xMCksaS1yKk1hdGguY29zKDIqbipNYXRoLlBJLzEwKSl9dC5jbG9zZVBhdGgoKX0sdHJpYW5nbGU6ZnVuY3Rpb24odCxlLGksbyl7dC5iZWdpblBhdGgoKSxpKz0uMjc1KihvKj0xLjE1KTt2YXIgbj0yKm8scj1uLzIscz1NYXRoLnNxcnQoMykvNipuLGE9TWF0aC5zcXJ0KG4qbi1yKnIpO3QubW92ZVRvKGUsaS0oYS1zKSksdC5saW5lVG8oZStyLGkrcyksdC5saW5lVG8oZS1yLGkrcyksdC5saW5lVG8oZSxpLShhLXMpKSx0LmNsb3NlUGF0aCgpfSx0cmlhbmdsZURvd246ZnVuY3Rpb24odCxlLGksbyl7dC5iZWdpblBhdGgoKSxpLT0uMjc1KihvKj0xLjE1KTt2YXIgbj0yKm8scj1uLzIscz1NYXRoLnNxcnQoMykvNipuLGE9TWF0aC5zcXJ0KG4qbi1yKnIpO3QubW92ZVRvKGUsaSsoYS1zKSksdC5saW5lVG8oZStyLGktcyksdC5saW5lVG8oZS1yLGktcyksdC5saW5lVG8oZSxpKyhhLXMpKSx0LmNsb3NlUGF0aCgpfX07dmFyIEN0PW8oKGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7aWYodClyZXR1cm4gZnVuY3Rpb24odCl7Zm9yKHZhciBpIGluIGUucHJvdG90eXBlKXRbaV09ZS5wcm90b3R5cGVbaV07cmV0dXJuIHR9KHQpfXQuZXhwb3J0cz1lLGUucHJvdG90eXBlLm9uPWUucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e30sKHRoaXMuX2NhbGxiYWNrc1tcIiRcIit0XT10aGlzLl9jYWxsYmFja3NbXCIkXCIrdF18fFtdKS5wdXNoKGUpLHRoaXN9LGUucHJvdG90eXBlLm9uY2U9ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBpKCl7dGhpcy5vZmYodCxpKSxlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gaS5mbj1lLHRoaXMub24odCxpKSx0aGlzfSxlLnByb3RvdHlwZS5vZmY9ZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI9ZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzPWUucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24odCxlKXtpZih0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzfHx7fSwwPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl9jYWxsYmFja3M9e30sdGhpczt2YXIgaSxvPXRoaXMuX2NhbGxiYWNrc1tcIiRcIit0XTtpZighbylyZXR1cm4gdGhpcztpZigxPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW1wiJFwiK3RdLHRoaXM7Zm9yKHZhciBuPTA7bjxvLmxlbmd0aDtuKyspaWYoKGk9b1tuXSk9PT1lfHxpLmZuPT09ZSl7by5zcGxpY2UobiwxKTticmVha31yZXR1cm4gMD09PW8ubGVuZ3RoJiZkZWxldGUgdGhpcy5fY2FsbGJhY2tzW1wiJFwiK3RdLHRoaXN9LGUucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24odCl7dGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e307Zm9yKHZhciBlPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpLGk9dGhpcy5fY2FsbGJhY2tzW1wiJFwiK3RdLG89MTtvPGFyZ3VtZW50cy5sZW5ndGg7bysrKWVbby0xXT1hcmd1bWVudHNbb107aWYoaSl7bz0wO2Zvcih2YXIgbj0oaT1pLnNsaWNlKDApKS5sZW5ndGg7bzxuOysrbylpW29dLmFwcGx5KHRoaXMsZSl9cmV0dXJuIHRoaXN9LGUucHJvdG90eXBlLmxpc3RlbmVycz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e30sdGhpcy5fY2FsbGJhY2tzW1wiJFwiK3RdfHxbXX0sZS5wcm90b3R5cGUuaGFzTGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3JldHVybiEhdGhpcy5saXN0ZW5lcnModCkubGVuZ3RofX0pKSxTdD1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxpKXt2YXIgbyxuLHI9U3RyaW5nKGcoZSkpLHM9WChpKSxhPXIubGVuZ3RoO3JldHVybiBzPDB8fHM+PWE/dD9cIlwiOnZvaWQgMDoobz1yLmNoYXJDb2RlQXQocykpPDU1Mjk2fHxvPjU2MzE5fHxzKzE9PT1hfHwobj1yLmNoYXJDb2RlQXQocysxKSk8NTYzMjB8fG4+NTczNDM/dD9yLmNoYXJBdChzKTpvOnQ/ci5zbGljZShzLHMrMik6bi01NjMyMCsoby01NTI5Njw8MTApKzY1NTM2fX0sVHQ9e2NvZGVBdDpTdCghMSksY2hhckF0OlN0KCEwKX0sTXQ9XCJfX2NvcmUtanNfc2hhcmVkX19cIixQdD1yW010XXx8ZnVuY3Rpb24odCxlKXt0cnl7SChyLHQsZSl9Y2F0Y2goaSl7clt0XT1lfXJldHVybiBlfShNdCx7fSksRHQ9RnVuY3Rpb24udG9TdHJpbmc7XCJmdW5jdGlvblwiIT10eXBlb2YgUHQuaW5zcGVjdFNvdXJjZSYmKFB0Lmluc3BlY3RTb3VyY2U9ZnVuY3Rpb24odCl7cmV0dXJuIER0LmNhbGwodCl9KTt2YXIgQnQsSXQsenQsRnQ9UHQuaW5zcGVjdFNvdXJjZSxOdD1yLldlYWtNYXAsQXQ9XCJmdW5jdGlvblwiPT10eXBlb2YgTnQmJi9uYXRpdmUgY29kZS8udGVzdChGdChOdCkpLFJ0PW8oKGZ1bmN0aW9uKHQpeyh0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gUHRbdF18fChQdFt0XT12b2lkIDAhPT1lP2U6e30pfSkoXCJ2ZXJzaW9uc1wiLFtdKS5wdXNoKHt2ZXJzaW9uOlwiMy45LjFcIixtb2RlOlwicHVyZVwiLGNvcHlyaWdodDpcIsKpIDIwMjEgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSlcIn0pfSkpLGp0PTAsTHQ9TWF0aC5yYW5kb20oKSxIdD1mdW5jdGlvbih0KXtyZXR1cm5cIlN5bWJvbChcIitTdHJpbmcodm9pZCAwPT09dD9cIlwiOnQpK1wiKV9cIisoKytqdCtMdCkudG9TdHJpbmcoMzYpfSxXdD1SdChcImtleXNcIiksVnQ9ZnVuY3Rpb24odCl7cmV0dXJuIFd0W3RdfHwoV3RbdF09SHQodCkpfSxxdD1yLldlYWtNYXA7aWYoQXQpe3ZhciBVdD1QdC5zdGF0ZXx8KFB0LnN0YXRlPW5ldyBxdCksWXQ9VXQuZ2V0LFh0PVV0LmhhcyxHdD1VdC5zZXQ7QnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5mYWNhZGU9dCxHdC5jYWxsKFV0LHQsZSksZX0sSXQ9ZnVuY3Rpb24odCl7cmV0dXJuIFl0LmNhbGwoVXQsdCl8fHt9fSx6dD1mdW5jdGlvbih0KXtyZXR1cm4gWHQuY2FsbChVdCx0KX19ZWxzZXt2YXIgS3Q9VnQoXCJzdGF0ZVwiKTtldFtLdF09ITAsQnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5mYWNhZGU9dCxIKHQsS3QsZSksZX0sSXQ9ZnVuY3Rpb24odCl7cmV0dXJuIGsodCxLdCk/dFtLdF06e319LHp0PWZ1bmN0aW9uKHQpe3JldHVybiBrKHQsS3QpfX12YXIgJHQsUXQsWnQ9e3NldDpCdCxnZXQ6SXQsaGFzOnp0LGVuZm9yY2U6ZnVuY3Rpb24odCl7cmV0dXJuIHp0KHQpP0l0KHQpOkJ0KHQse30pfSxnZXR0ZXJGb3I6ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciBpO2lmKCFtKGUpfHwoaT1JdChlKSkudHlwZSE9PXQpdGhyb3cgVHlwZUVycm9yKFwiSW5jb21wYXRpYmxlIHJlY2VpdmVyLCBcIit0K1wiIHJlcXVpcmVkXCIpO3JldHVybiBpfX19LEp0PSFzKChmdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPW51bGwsT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyB0KSE9PXQucHJvdG90eXBlfSkpLHRlPVZ0KFwiSUVfUFJPVE9cIiksZWU9T2JqZWN0LnByb3RvdHlwZSxpZT1KdD9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9YXQodCksayh0LHRlKT90W3RlXTpcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmNvbnN0cnVjdG9yJiZ0IGluc3RhbmNlb2YgdC5jb25zdHJ1Y3Rvcj90LmNvbnN0cnVjdG9yLnByb3RvdHlwZTp0IGluc3RhbmNlb2YgT2JqZWN0P2VlOm51bGx9LG9lPVwicHJvY2Vzc1wiPT1mKHIucHJvY2VzcyksbmU9ZnVuY3Rpb24odCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdD90OnZvaWQgMH0scmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aDwyP25lKEZbdF0pfHxuZShyW3RdKTpGW3RdJiZGW3RdW2VdfHxyW3RdJiZyW3RdW2VdfSxzZT1yZShcIm5hdmlnYXRvclwiLFwidXNlckFnZW50XCIpfHxcIlwiLGFlPXIucHJvY2VzcyxoZT1hZSYmYWUudmVyc2lvbnMsZGU9aGUmJmhlLnY4O2RlP1F0PSgkdD1kZS5zcGxpdChcIi5cIikpWzBdKyR0WzFdOnNlJiYoISgkdD1zZS5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pKXx8JHRbMV0+PTc0KSYmKCR0PXNlLm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKSkmJihRdD0kdFsxXSk7dmFyIGxlLGNlLHVlLGZlPVF0JiYrUXQscGU9ISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzJiYhcygoZnVuY3Rpb24oKXtyZXR1cm4hU3ltYm9sLnNoYW0mJihvZT8zOD09PWZlOmZlPjM3JiZmZTw0MSl9KSksdmU9cGUmJiFTeW1ib2wuc2hhbSYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcixnZT1SdChcIndrc1wiKSx5ZT1yLlN5bWJvbCxtZT12ZT95ZTp5ZSYmeWUud2l0aG91dFNldHRlcnx8SHQsYmU9ZnVuY3Rpb24odCl7cmV0dXJuIGsoZ2UsdCkmJihwZXx8XCJzdHJpbmdcIj09dHlwZW9mIGdlW3RdKXx8KHBlJiZrKHllLHQpP2dlW3RdPXllW3RdOmdlW3RdPW1lKFwiU3ltYm9sLlwiK3QpKSxnZVt0XX0sd2U9YmUoXCJpdGVyYXRvclwiKSxrZT0hMTtbXS5rZXlzJiYoXCJuZXh0XCJpbih1ZT1bXS5rZXlzKCkpPyhjZT1pZShpZSh1ZSkpKSE9PU9iamVjdC5wcm90b3R5cGUmJihsZT1jZSk6a2U9ITApO3ZhciBfZT1udWxsPT1sZXx8cygoZnVuY3Rpb24oKXt2YXIgdD17fTtyZXR1cm4gbGVbd2VdLmNhbGwodCkhPT10fSkpO19lJiYobGU9e30pLF9lJiYhayhsZSx3ZSkmJkgobGUsd2UsKGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSk7dmFyIHhlLEVlPXtJdGVyYXRvclByb3RvdHlwZTpsZSxCVUdHWV9TQUZBUklfSVRFUkFUT1JTOmtlfSxPZT1hP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzOmZ1bmN0aW9uKHQsZSl7Uih0KTtmb3IodmFyIGksbz1ydChlKSxuPW8ubGVuZ3RoLHI9MDtuPnI7KUwuZih0LGk9b1tyKytdLGVbaV0pO3JldHVybiB0fSxDZT1yZShcImRvY3VtZW50XCIsXCJkb2N1bWVudEVsZW1lbnRcIiksU2U9VnQoXCJJRV9QUk9UT1wiKSxUZT1mdW5jdGlvbigpe30sTWU9ZnVuY3Rpb24odCl7cmV0dXJuXCI8c2NyaXB0PlwiK3QrXCI8L1wiK1wic2NyaXB0PlwifSxQZT1mdW5jdGlvbigpe3RyeXt4ZT1kb2N1bWVudC5kb21haW4mJm5ldyBBY3RpdmVYT2JqZWN0KFwiaHRtbGZpbGVcIil9Y2F0Y2godCl7fXZhciB0LGU7UGU9eGU/ZnVuY3Rpb24odCl7dC53cml0ZShNZShcIlwiKSksdC5jbG9zZSgpO3ZhciBlPXQucGFyZW50V2luZG93Lk9iamVjdDtyZXR1cm4gdD1udWxsLGV9KHhlKTooKGU9RShcImlmcmFtZVwiKSkuc3R5bGUuZGlzcGxheT1cIm5vbmVcIixDZS5hcHBlbmRDaGlsZChlKSxlLnNyYz1TdHJpbmcoXCJqYXZhc2NyaXB0OlwiKSwodD1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQpLm9wZW4oKSx0LndyaXRlKE1lKFwiZG9jdW1lbnQuRj1PYmplY3RcIikpLHQuY2xvc2UoKSx0LkYpO2Zvcih2YXIgaT1udC5sZW5ndGg7aS0tOylkZWxldGUgUGUucHJvdG90eXBlW250W2ldXTtyZXR1cm4gUGUoKX07ZXRbU2VdPSEwO3ZhciBEZT1PYmplY3QuY3JlYXRlfHxmdW5jdGlvbih0LGUpe3ZhciBpO3JldHVybiBudWxsIT09dD8oVGUucHJvdG90eXBlPVIodCksaT1uZXcgVGUsVGUucHJvdG90eXBlPW51bGwsaVtTZV09dCk6aT1QZSgpLHZvaWQgMD09PWU/aTpPZShpLGUpfSxCZT17fTtCZVtiZShcInRvU3RyaW5nVGFnXCIpXT1cInpcIjt2YXIgSWU9XCJbb2JqZWN0IHpdXCI9PT1TdHJpbmcoQmUpLHplPWJlKFwidG9TdHJpbmdUYWdcIiksRmU9XCJBcmd1bWVudHNcIj09ZihmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpLE5lPUllP2Y6ZnVuY3Rpb24odCl7dmFyIGUsaSxvO3JldHVybiB2b2lkIDA9PT10P1wiVW5kZWZpbmVkXCI6bnVsbD09PXQ/XCJOdWxsXCI6XCJzdHJpbmdcIj09dHlwZW9mKGk9ZnVuY3Rpb24odCxlKXt0cnl7cmV0dXJuIHRbZV19Y2F0Y2godCl7fX0oZT1PYmplY3QodCksemUpKT9pOkZlP2YoZSk6XCJPYmplY3RcIj09KG89ZihlKSkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuY2FsbGVlP1wiQXJndW1lbnRzXCI6b30sQWU9SWU/e30udG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIltvYmplY3QgXCIrTmUodGhpcykrXCJdXCJ9LFJlPUwuZixqZT1iZShcInRvU3RyaW5nVGFnXCIpLExlPWZ1bmN0aW9uKHQsZSxpLG8pe2lmKHQpe3ZhciBuPWk/dDp0LnByb3RvdHlwZTtrKG4samUpfHxSZShuLGplLHtjb25maWd1cmFibGU6ITAsdmFsdWU6ZX0pLG8mJiFJZSYmSChuLFwidG9TdHJpbmdcIixBZSl9fSxIZT17fSxXZT1FZS5JdGVyYXRvclByb3RvdHlwZSxWZT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxxZT1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fChcIl9fcHJvdG9fX1wiaW57fT9mdW5jdGlvbigpe3ZhciB0LGU9ITEsaT17fTt0cnl7KHQ9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLFwiX19wcm90b19fXCIpLnNldCkuY2FsbChpLFtdKSxlPWkgaW5zdGFuY2VvZiBBcnJheX1jYXRjaCh0KXt9cmV0dXJuIGZ1bmN0aW9uKGksbyl7cmV0dXJuIFIoaSksZnVuY3Rpb24odCl7aWYoIW0odCkmJm51bGwhPT10KXRocm93IFR5cGVFcnJvcihcIkNhbid0IHNldCBcIitTdHJpbmcodCkrXCIgYXMgYSBwcm90b3R5cGVcIil9KG8pLGU/dC5jYWxsKGksbyk6aS5fX3Byb3RvX189byxpfX0oKTp2b2lkIDApLFVlPWZ1bmN0aW9uKHQsZSxpLG8pe28mJm8uZW51bWVyYWJsZT90W2VdPWk6SCh0LGUsaSl9LFllPUVlLkl0ZXJhdG9yUHJvdG90eXBlLFhlPUVlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlMsR2U9YmUoXCJpdGVyYXRvclwiKSxLZT1cImtleXNcIiwkZT1cInZhbHVlc1wiLFFlPVwiZW50cmllc1wiLFplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LEplPWZ1bmN0aW9uKHQsZSxpLG8sbixyLHMpeyFmdW5jdGlvbih0LGUsaSl7dmFyIG89ZStcIiBJdGVyYXRvclwiO3QucHJvdG90eXBlPURlKFdlLHtuZXh0OmMoMSxpKX0pLExlKHQsbywhMSwhMCksSGVbb109VmV9KGksZSxvKTt2YXIgYSxoLGQsbD1mdW5jdGlvbih0KXtpZih0PT09biYmZylyZXR1cm4gZztpZighWGUmJnQgaW4gcClyZXR1cm4gcFt0XTtzd2l0Y2godCl7Y2FzZSBLZTpjYXNlICRlOmNhc2UgUWU6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBpKHRoaXMsdCl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgaSh0aGlzKX19LHU9ZStcIiBJdGVyYXRvclwiLGY9ITEscD10LnByb3RvdHlwZSx2PXBbR2VdfHxwW1wiQEBpdGVyYXRvclwiXXx8biYmcFtuXSxnPSFYZSYmdnx8bChuKSx5PVwiQXJyYXlcIj09ZSYmcC5lbnRyaWVzfHx2O2lmKHkmJihhPWllKHkuY2FsbChuZXcgdCkpLFllIT09T2JqZWN0LnByb3RvdHlwZSYmYS5uZXh0JiYoTGUoYSx1LCEwLCEwKSxIZVt1XT1aZSkpLG49PSRlJiZ2JiZ2Lm5hbWUhPT0kZSYmKGY9ITAsZz1mdW5jdGlvbigpe3JldHVybiB2LmNhbGwodGhpcyl9KSxzJiZwW0dlXSE9PWcmJkgocCxHZSxnKSxIZVtlXT1nLG4paWYoaD17dmFsdWVzOmwoJGUpLGtleXM6cj9nOmwoS2UpLGVudHJpZXM6bChRZSl9LHMpZm9yKGQgaW4gaCkoWGV8fGZ8fCEoZCBpbiBwKSkmJlVlKHAsZCxoW2RdKTtlbHNlIHEoe3RhcmdldDplLHByb3RvOiEwLGZvcmNlZDpYZXx8Zn0saCk7cmV0dXJuIGh9LHRpPVR0LmNoYXJBdCxlaT1cIlN0cmluZyBJdGVyYXRvclwiLGlpPVp0LnNldCxvaT1adC5nZXR0ZXJGb3IoZWkpO0plKFN0cmluZyxcIlN0cmluZ1wiLChmdW5jdGlvbih0KXtpaSh0aGlzLHt0eXBlOmVpLHN0cmluZzpTdHJpbmcodCksaW5kZXg6MH0pfSksKGZ1bmN0aW9uKCl7dmFyIHQsZT1vaSh0aGlzKSxpPWUuc3RyaW5nLG89ZS5pbmRleDtyZXR1cm4gbz49aS5sZW5ndGg/e3ZhbHVlOnZvaWQgMCxkb25lOiEwfToodD10aShpLG8pLGUuaW5kZXgrPXQubGVuZ3RoLHt2YWx1ZTp0LGRvbmU6ITF9KX0pKTt2YXIgbmk9ZnVuY3Rpb24odCl7dmFyIGU9dC5yZXR1cm47aWYodm9pZCAwIT09ZSlyZXR1cm4gUihlLmNhbGwodCkpLnZhbHVlfSxyaT1mdW5jdGlvbih0LGUsaSxvKXt0cnl7cmV0dXJuIG8/ZShSKGkpWzBdLGlbMV0pOmUoaSl9Y2F0Y2goZSl7dGhyb3cgbmkodCksZX19LHNpPWJlKFwiaXRlcmF0b3JcIiksYWk9QXJyYXkucHJvdG90eXBlLGhpPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10JiYoSGUuQXJyYXk9PT10fHxhaVtzaV09PT10KX0sZGk9ZnVuY3Rpb24odCxlLGkpe3ZhciBvPWIoZSk7byBpbiB0P0wuZih0LG8sYygwLGkpKTp0W29dPWl9LGxpPWJlKFwiaXRlcmF0b3JcIiksY2k9ZnVuY3Rpb24odCl7aWYobnVsbCE9dClyZXR1cm4gdFtsaV18fHRbXCJAQGl0ZXJhdG9yXCJdfHxIZVtOZSh0KV19LHVpPWJlKFwiaXRlcmF0b3JcIiksZmk9ITE7dHJ5e3ZhciBwaT0wLHZpPXtuZXh0OmZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6ISFwaSsrfX0scmV0dXJuOmZ1bmN0aW9uKCl7Zmk9ITB9fTt2aVt1aV09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sQXJyYXkuZnJvbSh2aSwoZnVuY3Rpb24oKXt0aHJvdyAyfSkpfWNhdGNoKHQpe312YXIgZ2k9IWZ1bmN0aW9uKHQsZSl7aWYoIWUmJiFmaSlyZXR1cm4hMTt2YXIgaT0hMTt0cnl7dmFyIG89e307b1t1aV09ZnVuY3Rpb24oKXtyZXR1cm57bmV4dDpmdW5jdGlvbigpe3JldHVybntkb25lOmk9ITB9fX19LHQobyl9Y2F0Y2godCl7fXJldHVybiBpfSgoZnVuY3Rpb24odCl7QXJyYXkuZnJvbSh0KX0pKTtxKHt0YXJnZXQ6XCJBcnJheVwiLHN0YXQ6ITAsZm9yY2VkOmdpfSx7ZnJvbTpmdW5jdGlvbih0KXt2YXIgZSxpLG8sbixyLHMsYT1hdCh0KSxoPVwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXM/dGhpczpBcnJheSxkPWFyZ3VtZW50cy5sZW5ndGgsbD1kPjE/YXJndW1lbnRzWzFdOnZvaWQgMCxjPXZvaWQgMCE9PWwsdT1jaShhKSxmPTA7aWYoYyYmKGw9QShsLGQ+Mj9hcmd1bWVudHNbMl06dm9pZCAwLDIpKSxudWxsPT11fHxoPT1BcnJheSYmaGkodSkpZm9yKGk9bmV3IGgoZT1LKGEubGVuZ3RoKSk7ZT5mO2YrKylzPWM/bChhW2ZdLGYpOmFbZl0sZGkoaSxmLHMpO2Vsc2UgZm9yKHI9KG49dS5jYWxsKGEpKS5uZXh0LGk9bmV3IGg7IShvPXIuY2FsbChuKSkuZG9uZTtmKyspcz1jP3JpKG4sbCxbby52YWx1ZSxmXSwhMCk6by52YWx1ZSxkaShpLGYscyk7cmV0dXJuIGkubGVuZ3RoPWYsaX19KTt2YXIgeWk9Ri5BcnJheS5mcm9tLG1pPXlpLGJpPVwiQXJyYXkgSXRlcmF0b3JcIix3aT1adC5zZXQsa2k9WnQuZ2V0dGVyRm9yKGJpKTtKZShBcnJheSxcIkFycmF5XCIsKGZ1bmN0aW9uKHQsZSl7d2kodGhpcyx7dHlwZTpiaSx0YXJnZXQ6eSh0KSxpbmRleDowLGtpbmQ6ZX0pfSksKGZ1bmN0aW9uKCl7dmFyIHQ9a2kodGhpcyksZT10LnRhcmdldCxpPXQua2luZCxvPXQuaW5kZXgrKztyZXR1cm4hZXx8bz49ZS5sZW5ndGg/KHQudGFyZ2V0PXZvaWQgMCx7dmFsdWU6dm9pZCAwLGRvbmU6ITB9KTpcImtleXNcIj09aT97dmFsdWU6byxkb25lOiExfTpcInZhbHVlc1wiPT1pP3t2YWx1ZTplW29dLGRvbmU6ITF9Ont2YWx1ZTpbbyxlW29dXSxkb25lOiExfX0pLFwidmFsdWVzXCIpLEhlLkFyZ3VtZW50cz1IZS5BcnJheTt2YXIgX2k9YmUoXCJ0b1N0cmluZ1RhZ1wiKTtmb3IodmFyIHhpIGlue0NTU1J1bGVMaXN0OjAsQ1NTU3R5bGVEZWNsYXJhdGlvbjowLENTU1ZhbHVlTGlzdDowLENsaWVudFJlY3RMaXN0OjAsRE9NUmVjdExpc3Q6MCxET01TdHJpbmdMaXN0OjAsRE9NVG9rZW5MaXN0OjEsRGF0YVRyYW5zZmVySXRlbUxpc3Q6MCxGaWxlTGlzdDowLEhUTUxBbGxDb2xsZWN0aW9uOjAsSFRNTENvbGxlY3Rpb246MCxIVE1MRm9ybUVsZW1lbnQ6MCxIVE1MU2VsZWN0RWxlbWVudDowLE1lZGlhTGlzdDowLE1pbWVUeXBlQXJyYXk6MCxOYW1lZE5vZGVNYXA6MCxOb2RlTGlzdDoxLFBhaW50UmVxdWVzdExpc3Q6MCxQbHVnaW46MCxQbHVnaW5BcnJheTowLFNWR0xlbmd0aExpc3Q6MCxTVkdOdW1iZXJMaXN0OjAsU1ZHUGF0aFNlZ0xpc3Q6MCxTVkdQb2ludExpc3Q6MCxTVkdTdHJpbmdMaXN0OjAsU1ZHVHJhbnNmb3JtTGlzdDowLFNvdXJjZUJ1ZmZlckxpc3Q6MCxTdHlsZVNoZWV0TGlzdDowLFRleHRUcmFja0N1ZUxpc3Q6MCxUZXh0VHJhY2tMaXN0OjAsVG91Y2hMaXN0OjB9KXt2YXIgRWk9clt4aV0sT2k9RWkmJkVpLnByb3RvdHlwZTtPaSYmTmUoT2kpIT09X2kmJkgoT2ksX2kseGkpLEhlW3hpXT1IZS5BcnJheX12YXIgQ2k9Y2ksU2k9ZnVuY3Rpb24odCl7dmFyIGU9Y2kodCk7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKHQpK1wiIGlzIG5vdCBpdGVyYWJsZVwiKTtyZXR1cm4gUihlLmNhbGwodCkpfSxUaT1BcnJheS5pc0FycmF5fHxmdW5jdGlvbih0KXtyZXR1cm5cIkFycmF5XCI9PWYodCl9LE1pPW50LmNvbmNhdChcImxlbmd0aFwiLFwicHJvdG90eXBlXCIpLFBpPXtmOk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzfHxmdW5jdGlvbih0KXtyZXR1cm4gb3QodCxNaSl9fSxEaT1QaS5mLEJpPXt9LnRvU3RyaW5nLElpPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdyYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM/T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KTpbXSx6aT17ZjpmdW5jdGlvbih0KXtyZXR1cm4gSWkmJlwiW29iamVjdCBXaW5kb3ddXCI9PUJpLmNhbGwodCk/ZnVuY3Rpb24odCl7dHJ5e3JldHVybiBEaSh0KX1jYXRjaCh0KXtyZXR1cm4gSWkuc2xpY2UoKX19KHQpOkRpKHkodCkpfX0sRmk9e2Y6YmV9LE5pPUwuZixBaT1mdW5jdGlvbih0KXt2YXIgZT1GLlN5bWJvbHx8KEYuU3ltYm9sPXt9KTtrKGUsdCl8fE5pKGUsdCx7dmFsdWU6RmkuZih0KX0pfSxSaT1iZShcInNwZWNpZXNcIiksamk9ZnVuY3Rpb24odCxlKXt2YXIgaTtyZXR1cm4gVGkodCkmJihcImZ1bmN0aW9uXCIhPXR5cGVvZihpPXQuY29uc3RydWN0b3IpfHxpIT09QXJyYXkmJiFUaShpLnByb3RvdHlwZSk/bShpKSYmbnVsbD09PShpPWlbUmldKSYmKGk9dm9pZCAwKTppPXZvaWQgMCksbmV3KHZvaWQgMD09PWk/QXJyYXk6aSkoMD09PWU/MDplKX0sTGk9W10ucHVzaCxIaT1mdW5jdGlvbih0KXt2YXIgZT0xPT10LGk9Mj09dCxvPTM9PXQsbj00PT10LHI9Nj09dCxzPTc9PXQsYT01PT10fHxyO3JldHVybiBmdW5jdGlvbihoLGQsbCxjKXtmb3IodmFyIHUsZixwPWF0KGgpLGc9dihwKSx5PUEoZCxsLDMpLG09SyhnLmxlbmd0aCksYj0wLHc9Y3x8amksaz1lP3coaCxtKTppfHxzP3coaCwwKTp2b2lkIDA7bT5iO2IrKylpZigoYXx8YiBpbiBnKSYmKGY9eSh1PWdbYl0sYixwKSx0KSlpZihlKWtbYl09ZjtlbHNlIGlmKGYpc3dpdGNoKHQpe2Nhc2UgMzpyZXR1cm4hMDtjYXNlIDU6cmV0dXJuIHU7Y2FzZSA2OnJldHVybiBiO2Nhc2UgMjpMaS5jYWxsKGssdSl9ZWxzZSBzd2l0Y2godCl7Y2FzZSA0OnJldHVybiExO2Nhc2UgNzpMaS5jYWxsKGssdSl9cmV0dXJuIHI/LTE6b3x8bj9uOmt9fSxXaT17Zm9yRWFjaDpIaSgwKSxtYXA6SGkoMSksZmlsdGVyOkhpKDIpLHNvbWU6SGkoMyksZXZlcnk6SGkoNCksZmluZDpIaSg1KSxmaW5kSW5kZXg6SGkoNiksZmlsdGVyT3V0OkhpKDcpfSxWaT1XaS5mb3JFYWNoLHFpPVZ0KFwiaGlkZGVuXCIpLFVpPVwiU3ltYm9sXCIsWWk9YmUoXCJ0b1ByaW1pdGl2ZVwiKSxYaT1adC5zZXQsR2k9WnQuZ2V0dGVyRm9yKFVpKSxLaT1PYmplY3QucHJvdG90eXBlLCRpPXIuU3ltYm9sLFFpPXJlKFwiSlNPTlwiLFwic3RyaW5naWZ5XCIpLFppPVMuZixKaT1MLmYsdG89emkuZixlbz1sLmYsaW89UnQoXCJzeW1ib2xzXCIpLG9vPVJ0KFwib3Atc3ltYm9sc1wiKSxubz1SdChcInN0cmluZy10by1zeW1ib2wtcmVnaXN0cnlcIikscm89UnQoXCJzeW1ib2wtdG8tc3RyaW5nLXJlZ2lzdHJ5XCIpLHNvPVJ0KFwid2tzXCIpLGFvPXIuUU9iamVjdCxobz0hYW98fCFhby5wcm90b3R5cGV8fCFhby5wcm90b3R5cGUuZmluZENoaWxkLGxvPWEmJnMoKGZ1bmN0aW9uKCl7cmV0dXJuIDchPURlKEppKHt9LFwiYVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gSmkodGhpcyxcImFcIix7dmFsdWU6N30pLmF9fSkpLmF9KSk/ZnVuY3Rpb24odCxlLGkpe3ZhciBvPVppKEtpLGUpO28mJmRlbGV0ZSBLaVtlXSxKaSh0LGUsaSksbyYmdCE9PUtpJiZKaShLaSxlLG8pfTpKaSxjbz1mdW5jdGlvbih0LGUpe3ZhciBpPWlvW3RdPURlKCRpLnByb3RvdHlwZSk7cmV0dXJuIFhpKGkse3R5cGU6VWksdGFnOnQsZGVzY3JpcHRpb246ZX0pLGF8fChpLmRlc2NyaXB0aW9uPWUpLGl9LHVvPXZlP2Z1bmN0aW9uKHQpe3JldHVyblwic3ltYm9sXCI9PXR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0KHQpaW5zdGFuY2VvZiAkaX0sZm89ZnVuY3Rpb24odCxlLGkpe3Q9PT1LaSYmZm8ob28sZSxpKSxSKHQpO3ZhciBvPWIoZSwhMCk7cmV0dXJuIFIoaSksayhpbyxvKT8oaS5lbnVtZXJhYmxlPyhrKHQscWkpJiZ0W3FpXVtvXSYmKHRbcWldW29dPSExKSxpPURlKGkse2VudW1lcmFibGU6YygwLCExKX0pKTooayh0LHFpKXx8SmkodCxxaSxjKDEse30pKSx0W3FpXVtvXT0hMCksbG8odCxvLGkpKTpKaSh0LG8saSl9LHBvPWZ1bmN0aW9uKHQsZSl7Uih0KTt2YXIgaT15KGUpLG89cnQoaSkuY29uY2F0KG1vKGkpKTtyZXR1cm4gVmkobywoZnVuY3Rpb24oZSl7YSYmIXZvLmNhbGwoaSxlKXx8Zm8odCxlLGlbZV0pfSkpLHR9LHZvPWZ1bmN0aW9uKHQpe3ZhciBlPWIodCwhMCksaT1lby5jYWxsKHRoaXMsZSk7cmV0dXJuISh0aGlzPT09S2kmJmsoaW8sZSkmJiFrKG9vLGUpKSYmKCEoaXx8IWsodGhpcyxlKXx8IWsoaW8sZSl8fGsodGhpcyxxaSkmJnRoaXNbcWldW2VdKXx8aSl9LGdvPWZ1bmN0aW9uKHQsZSl7dmFyIGk9eSh0KSxvPWIoZSwhMCk7aWYoaSE9PUtpfHwhayhpbyxvKXx8ayhvbyxvKSl7dmFyIG49WmkoaSxvKTtyZXR1cm4hbnx8IWsoaW8sbyl8fGsoaSxxaSkmJmlbcWldW29dfHwobi5lbnVtZXJhYmxlPSEwKSxufX0seW89ZnVuY3Rpb24odCl7dmFyIGU9dG8oeSh0KSksaT1bXTtyZXR1cm4gVmkoZSwoZnVuY3Rpb24odCl7ayhpbyx0KXx8ayhldCx0KXx8aS5wdXNoKHQpfSkpLGl9LG1vPWZ1bmN0aW9uKHQpe3ZhciBlPXQ9PT1LaSxpPXRvKGU/b286eSh0KSksbz1bXTtyZXR1cm4gVmkoaSwoZnVuY3Rpb24odCl7IWsoaW8sdCl8fGUmJiFrKEtpLHQpfHxvLnB1c2goaW9bdF0pfSkpLG99O2lmKHBlfHwoVWUoKCRpPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mICRpKXRocm93IFR5cGVFcnJvcihcIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvclwiKTt2YXIgdD1hcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/U3RyaW5nKGFyZ3VtZW50c1swXSk6dm9pZCAwLGU9SHQodCksaT1mdW5jdGlvbih0KXt0aGlzPT09S2kmJmkuY2FsbChvbyx0KSxrKHRoaXMscWkpJiZrKHRoaXNbcWldLGUpJiYodGhpc1txaV1bZV09ITEpLGxvKHRoaXMsZSxjKDEsdCkpfTtyZXR1cm4gYSYmaG8mJmxvKEtpLGUse2NvbmZpZ3VyYWJsZTohMCxzZXQ6aX0pLGNvKGUsdCl9KS5wcm90b3R5cGUsXCJ0b1N0cmluZ1wiLChmdW5jdGlvbigpe3JldHVybiBHaSh0aGlzKS50YWd9KSksVWUoJGksXCJ3aXRob3V0U2V0dGVyXCIsKGZ1bmN0aW9uKHQpe3JldHVybiBjbyhIdCh0KSx0KX0pKSxsLmY9dm8sTC5mPWZvLFMuZj1nbyxQaS5mPXppLmY9eW8sc3QuZj1tbyxGaS5mPWZ1bmN0aW9uKHQpe3JldHVybiBjbyhiZSh0KSx0KX0sYSYmSmkoJGkucHJvdG90eXBlLFwiZGVzY3JpcHRpb25cIix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBHaSh0aGlzKS5kZXNjcmlwdGlvbn19KSkscSh7Z2xvYmFsOiEwLHdyYXA6ITAsZm9yY2VkOiFwZSxzaGFtOiFwZX0se1N5bWJvbDokaX0pLFZpKHJ0KHNvKSwoZnVuY3Rpb24odCl7QWkodCl9KSkscSh7dGFyZ2V0OlVpLHN0YXQ6ITAsZm9yY2VkOiFwZX0se2ZvcjpmdW5jdGlvbih0KXt2YXIgZT1TdHJpbmcodCk7aWYoayhubyxlKSlyZXR1cm4gbm9bZV07dmFyIGk9JGkoZSk7cmV0dXJuIG5vW2VdPWkscm9baV09ZSxpfSxrZXlGb3I6ZnVuY3Rpb24odCl7aWYoIXVvKHQpKXRocm93IFR5cGVFcnJvcih0K1wiIGlzIG5vdCBhIHN5bWJvbFwiKTtpZihrKHJvLHQpKXJldHVybiByb1t0XX0sdXNlU2V0dGVyOmZ1bmN0aW9uKCl7aG89ITB9LHVzZVNpbXBsZTpmdW5jdGlvbigpe2hvPSExfX0pLHEoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOiFwZSxzaGFtOiFhfSx7Y3JlYXRlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWU/RGUodCk6cG8oRGUodCksZSl9LGRlZmluZVByb3BlcnR5OmZvLGRlZmluZVByb3BlcnRpZXM6cG8sZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOmdvfSkscSh7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxmb3JjZWQ6IXBlfSx7Z2V0T3duUHJvcGVydHlOYW1lczp5byxnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6bW99KSxxKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDpzKChmdW5jdGlvbigpe3N0LmYoMSl9KSl9LHtnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ZnVuY3Rpb24odCl7cmV0dXJuIHN0LmYoYXQodCkpfX0pLFFpKXt2YXIgYm89IXBlfHxzKChmdW5jdGlvbigpe3ZhciB0PSRpKCk7cmV0dXJuXCJbbnVsbF1cIiE9UWkoW3RdKXx8XCJ7fVwiIT1RaSh7YTp0fSl8fFwie31cIiE9UWkoT2JqZWN0KHQpKX0pKTtxKHt0YXJnZXQ6XCJKU09OXCIsc3RhdDohMCxmb3JjZWQ6Ym99LHtzdHJpbmdpZnk6ZnVuY3Rpb24odCxlLGkpe2Zvcih2YXIgbyxuPVt0XSxyPTE7YXJndW1lbnRzLmxlbmd0aD5yOyluLnB1c2goYXJndW1lbnRzW3IrK10pO2lmKG89ZSwobShlKXx8dm9pZCAwIT09dCkmJiF1byh0KSlyZXR1cm4gVGkoZSl8fChlPWZ1bmN0aW9uKHQsZSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgbyYmKGU9by5jYWxsKHRoaXMsdCxlKSksIXVvKGUpKXJldHVybiBlfSksblsxXT1lLFFpLmFwcGx5KG51bGwsbil9fSl9JGkucHJvdG90eXBlW1lpXXx8SCgkaS5wcm90b3R5cGUsWWksJGkucHJvdG90eXBlLnZhbHVlT2YpLExlKCRpLFVpKSxldFtxaV09ITA7dmFyIHdvPUYuT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxrbz1TLmYsX289cygoZnVuY3Rpb24oKXtrbygxKX0pKTtxKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDohYXx8X28sc2hhbTohYX0se2dldE93blByb3BlcnR5RGVzY3JpcHRvcjpmdW5jdGlvbih0LGUpe3JldHVybiBrbyh5KHQpLGUpfX0pO3ZhciB4bz1vKChmdW5jdGlvbih0KXt2YXIgZT1GLk9iamVjdCxpPXQuZXhwb3J0cz1mdW5jdGlvbih0LGkpe3JldHVybiBlLmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGkpfTtlLmdldE93blByb3BlcnR5RGVzY3JpcHRvci5zaGFtJiYoaS5zaGFtPSEwKX0pKSxFbz14byxPbz1yZShcIlJlZmxlY3RcIixcIm93bktleXNcIil8fGZ1bmN0aW9uKHQpe3ZhciBlPVBpLmYoUih0KSksaT1zdC5mO3JldHVybiBpP2UuY29uY2F0KGkodCkpOmV9O3Eoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsc2hhbTohYX0se2dldE93blByb3BlcnR5RGVzY3JpcHRvcnM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlLGksbz15KHQpLG49Uy5mLHI9T28obykscz17fSxhPTA7ci5sZW5ndGg+YTspdm9pZCAwIT09KGk9bihvLGU9clthKytdKSkmJmRpKHMsZSxpKTtyZXR1cm4gc319KTt2YXIgQ289Ri5PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztxKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDohYSxzaGFtOiFhfSx7ZGVmaW5lUHJvcGVydGllczpPZX0pO3ZhciBTbz1vKChmdW5jdGlvbih0KXt2YXIgZT1GLk9iamVjdCxpPXQuZXhwb3J0cz1mdW5jdGlvbih0LGkpe3JldHVybiBlLmRlZmluZVByb3BlcnRpZXModCxpKX07ZS5kZWZpbmVQcm9wZXJ0aWVzLnNoYW0mJihpLnNoYW09ITApfSkpO3Eoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOiFhLHNoYW06IWF9LHtkZWZpbmVQcm9wZXJ0eTpMLmZ9KTt2YXIgVG89bygoZnVuY3Rpb24odCl7dmFyIGU9Ri5PYmplY3QsaT10LmV4cG9ydHM9ZnVuY3Rpb24odCxpLG8pe3JldHVybiBlLmRlZmluZVByb3BlcnR5KHQsaSxvKX07ZS5kZWZpbmVQcm9wZXJ0eS5zaGFtJiYoaS5zaGFtPSEwKX0pKSxNbz1UbztmdW5jdGlvbiBQbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9dmFyIERvPVRvO2Z1bmN0aW9uIEJvKHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBvPWVbaV07by5lbnVtZXJhYmxlPW8uZW51bWVyYWJsZXx8ITEsby5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbyYmKG8ud3JpdGFibGU9ITApLERvKHQsby5rZXksbyl9fWZ1bmN0aW9uIElvKHQsZSxpKXtyZXR1cm4gZSYmQm8odC5wcm90b3R5cGUsZSksaSYmQm8odCxpKSx0fWZ1bmN0aW9uIHpvKHQsZSxpKXtyZXR1cm4gZSBpbiB0P0RvKHQsZSx7dmFsdWU6aSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09aSx0fXEoe3RhcmdldDpcIkFycmF5XCIsc3RhdDohMH0se2lzQXJyYXk6VGl9KTt2YXIgRm89Ri5BcnJheS5pc0FycmF5LE5vPUZvO3ZhciBBbz1iZShcInNwZWNpZXNcIiksUm89ZnVuY3Rpb24odCl7cmV0dXJuIGZlPj01MXx8IXMoKGZ1bmN0aW9uKCl7dmFyIGU9W107cmV0dXJuKGUuY29uc3RydWN0b3I9e30pW0FvXT1mdW5jdGlvbigpe3JldHVybntmb286MX19LDEhPT1lW3RdKEJvb2xlYW4pLmZvb30pKX0sam89YmUoXCJpc0NvbmNhdFNwcmVhZGFibGVcIiksTG89OTAwNzE5OTI1NDc0MDk5MSxIbz1cIk1heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZFwiLFdvPWZlPj01MXx8IXMoKGZ1bmN0aW9uKCl7dmFyIHQ9W107cmV0dXJuIHRbam9dPSExLHQuY29uY2F0KClbMF0hPT10fSkpLFZvPVJvKFwiY29uY2F0XCIpLHFvPWZ1bmN0aW9uKHQpe2lmKCFtKHQpKXJldHVybiExO3ZhciBlPXRbam9dO3JldHVybiB2b2lkIDAhPT1lPyEhZTpUaSh0KX07cSh7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IVdvfHwhVm99LHtjb25jYXQ6ZnVuY3Rpb24odCl7dmFyIGUsaSxvLG4scixzPWF0KHRoaXMpLGE9amkocywwKSxoPTA7Zm9yKGU9LTEsbz1hcmd1bWVudHMubGVuZ3RoO2U8bztlKyspaWYocW8ocj0tMT09PWU/czphcmd1bWVudHNbZV0pKXtpZihoKyhuPUsoci5sZW5ndGgpKT5Mbyl0aHJvdyBUeXBlRXJyb3IoSG8pO2ZvcihpPTA7aTxuO2krKyxoKyspaSBpbiByJiZkaShhLGgscltpXSl9ZWxzZXtpZihoPj1Mbyl0aHJvdyBUeXBlRXJyb3IoSG8pO2RpKGEsaCsrLHIpfXJldHVybiBhLmxlbmd0aD1oLGF9fSksQWkoXCJhc3luY0l0ZXJhdG9yXCIpLEFpKFwiaGFzSW5zdGFuY2VcIiksQWkoXCJpc0NvbmNhdFNwcmVhZGFibGVcIiksQWkoXCJpdGVyYXRvclwiKSxBaShcIm1hdGNoXCIpLEFpKFwibWF0Y2hBbGxcIiksQWkoXCJyZXBsYWNlXCIpLEFpKFwic2VhcmNoXCIpLEFpKFwic3BlY2llc1wiKSxBaShcInNwbGl0XCIpLEFpKFwidG9QcmltaXRpdmVcIiksQWkoXCJ0b1N0cmluZ1RhZ1wiKSxBaShcInVuc2NvcGFibGVzXCIpLExlKHIuSlNPTixcIkpTT05cIiwhMCk7dmFyIFVvPUYuU3ltYm9sO0FpKFwiYXN5bmNEaXNwb3NlXCIpLEFpKFwiZGlzcG9zZVwiKSxBaShcIm9ic2VydmFibGVcIiksQWkoXCJwYXR0ZXJuTWF0Y2hcIiksQWkoXCJyZXBsYWNlQWxsXCIpO3ZhciBZbz1VbyxYbz1iZShcIml0ZXJhdG9yXCIpLEdvPWZ1bmN0aW9uKHQpe3ZhciBlPU9iamVjdCh0KTtyZXR1cm4gdm9pZCAwIT09ZVtYb118fFwiQEBpdGVyYXRvclwiaW4gZXx8SGUuaGFzT3duUHJvcGVydHkoTmUoZSkpfTt2YXIgS289Um8oXCJzbGljZVwiKSwkbz1iZShcInNwZWNpZXNcIiksUW89W10uc2xpY2UsWm89TWF0aC5tYXg7cSh7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IUtvfSx7c2xpY2U6ZnVuY3Rpb24odCxlKXt2YXIgaSxvLG4scj15KHRoaXMpLHM9SyhyLmxlbmd0aCksYT1aKHQscyksaD1aKHZvaWQgMD09PWU/czplLHMpO2lmKFRpKHIpJiYoXCJmdW5jdGlvblwiIT10eXBlb2YoaT1yLmNvbnN0cnVjdG9yKXx8aSE9PUFycmF5JiYhVGkoaS5wcm90b3R5cGUpP20oaSkmJm51bGw9PT0oaT1pWyRvXSkmJihpPXZvaWQgMCk6aT12b2lkIDAsaT09PUFycmF5fHx2b2lkIDA9PT1pKSlyZXR1cm4gUW8uY2FsbChyLGEsaCk7Zm9yKG89bmV3KHZvaWQgMD09PWk/QXJyYXk6aSkoWm8oaC1hLDApKSxuPTA7YTxoO2ErKyxuKyspYSBpbiByJiZkaShvLG4sclthXSk7cmV0dXJuIG8ubGVuZ3RoPW4sb319KTt2YXIgSm89Z3QoXCJBcnJheVwiKS5zbGljZSx0bj1BcnJheS5wcm90b3R5cGUsZW49ZnVuY3Rpb24odCl7dmFyIGU9dC5zbGljZTtyZXR1cm4gdD09PXRufHx0IGluc3RhbmNlb2YgQXJyYXkmJmU9PT10bi5zbGljZT9KbzplfSxvbj1lbixubj15aTtmdW5jdGlvbiBybih0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgaT0wLG89bmV3IEFycmF5KGUpO2k8ZTtpKyspb1tpXT10W2ldO3JldHVybiBvfWZ1bmN0aW9uIHNuKHQsZSl7dmFyIGk7aWYodCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIHJuKHQsZSk7dmFyIG89b24oaT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpLmNhbGwoaSw4LC0xKTtyZXR1cm5cIk9iamVjdFwiPT09byYmdC5jb25zdHJ1Y3RvciYmKG89dC5jb25zdHJ1Y3Rvci5uYW1lKSxcIk1hcFwiPT09b3x8XCJTZXRcIj09PW8/bm4odCk6XCJBcmd1bWVudHNcIj09PW98fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG8pP3JuKHQsZSk6dm9pZCAwfX1mdW5jdGlvbiBhbih0LGUpe3JldHVybiBmdW5jdGlvbih0KXtpZihObyh0KSlyZXR1cm4gdH0odCl8fGZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwIT09WW8mJkdvKE9iamVjdCh0KSkpe3ZhciBpPVtdLG89ITAsbj0hMSxyPXZvaWQgMDt0cnl7Zm9yKHZhciBzLGE9U2kodCk7IShvPShzPWEubmV4dCgpKS5kb25lKSYmKGkucHVzaChzLnZhbHVlKSwhZXx8aS5sZW5ndGghPT1lKTtvPSEwKTt9Y2F0Y2godCl7bj0hMCxyPXR9ZmluYWxseXt0cnl7b3x8bnVsbD09YS5yZXR1cm58fGEucmV0dXJuKCl9ZmluYWxseXtpZihuKXRocm93IHJ9fXJldHVybiBpfX0odCxlKXx8c24odCxlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfSgpfXZhciBobj1GaS5mKFwiaXRlcmF0b3JcIik7ZnVuY3Rpb24gZG4odCl7cmV0dXJuKGRuPVwiZnVuY3Rpb25cIj09dHlwZW9mIFlvJiZcInN5bWJvbFwiPT10eXBlb2YgaG4/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgWW8mJnQuY29uc3RydWN0b3I9PT1ZbyYmdCE9PVlvLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9ZnVuY3Rpb24gbG4odCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKE5vKHQpKXJldHVybiBybih0KX0odCl8fGZ1bmN0aW9uKHQpe2lmKHZvaWQgMCE9PVlvJiZHbyhPYmplY3QodCkpKXJldHVybiBubih0KX0odCl8fHNuKHQpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfSgpfXZhciBjbj1Vbyx1bj1ndChcIkFycmF5XCIpLmNvbmNhdCxmbj1BcnJheS5wcm90b3R5cGUscG49ZnVuY3Rpb24odCl7dmFyIGU9dC5jb25jYXQ7cmV0dXJuIHQ9PT1mbnx8dCBpbnN0YW5jZW9mIEFycmF5JiZlPT09Zm4uY29uY2F0P3VuOmV9LHZuPWVuO3Eoe3RhcmdldDpcIlJlZmxlY3RcIixzdGF0OiEwfSx7b3duS2V5czpPb30pLEYuUmVmbGVjdC5vd25LZXlzO3ZhciBnbj1Gbyx5bj1XaS5tYXAsbW49Um8oXCJtYXBcIik7cSh7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IW1ufSx7bWFwOmZ1bmN0aW9uKHQpe3JldHVybiB5bih0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pO3ZhciBibj1ndChcIkFycmF5XCIpLm1hcCx3bj1BcnJheS5wcm90b3R5cGUsa249ZnVuY3Rpb24odCl7dmFyIGU9dC5tYXA7cmV0dXJuIHQ9PT13bnx8dCBpbnN0YW5jZW9mIEFycmF5JiZlPT09d24ubWFwP2JuOmV9LF9uPXMoKGZ1bmN0aW9uKCl7cnQoMSl9KSk7cSh7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxmb3JjZWQ6X259LHtrZXlzOmZ1bmN0aW9uKHQpe3JldHVybiBydChhdCh0KSl9fSk7dmFyIHhuPUYuT2JqZWN0LmtleXM7cSh7dGFyZ2V0OlwiRGF0ZVwiLHN0YXQ6ITB9LHtub3c6ZnVuY3Rpb24oKXtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKX19KTt2YXIgRW49Ri5EYXRlLm5vdyxPbj1mdW5jdGlvbih0LGUpe3ZhciBpPVtdW3RdO3JldHVybiEhaSYmcygoZnVuY3Rpb24oKXtpLmNhbGwobnVsbCxlfHxmdW5jdGlvbigpe3Rocm93IDF9LDEpfSkpfSxDbj1XaS5mb3JFYWNoLFNuPU9uKFwiZm9yRWFjaFwiKT9bXS5mb3JFYWNoOmZ1bmN0aW9uKHQpe3JldHVybiBDbih0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfTtxKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDpbXS5mb3JFYWNoIT1Tbn0se2ZvckVhY2g6U259KTt2YXIgVG49Z3QoXCJBcnJheVwiKS5mb3JFYWNoLE1uPUFycmF5LnByb3RvdHlwZSxQbj17RE9NVG9rZW5MaXN0OiEwLE5vZGVMaXN0OiEwfSxEbj1mdW5jdGlvbih0KXt2YXIgZT10LmZvckVhY2g7cmV0dXJuIHQ9PT1Nbnx8dCBpbnN0YW5jZW9mIEFycmF5JiZlPT09TW4uZm9yRWFjaHx8UG4uaGFzT3duUHJvcGVydHkoTmUodCkpP1RuOmV9LEJuPVtdLnJldmVyc2UsSW49WzEsMl07cSh7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6U3RyaW5nKEluKT09PVN0cmluZyhJbi5yZXZlcnNlKCkpfSx7cmV2ZXJzZTpmdW5jdGlvbigpe3JldHVybiBUaSh0aGlzKSYmKHRoaXMubGVuZ3RoPXRoaXMubGVuZ3RoKSxCbi5jYWxsKHRoaXMpfX0pO3ZhciB6bj1ndChcIkFycmF5XCIpLnJldmVyc2UsRm49QXJyYXkucHJvdG90eXBlLE5uPWZ1bmN0aW9uKHQpe3ZhciBlPXQucmV2ZXJzZTtyZXR1cm4gdD09PUZufHx0IGluc3RhbmNlb2YgQXJyYXkmJmU9PT1Gbi5yZXZlcnNlP3puOmV9LEFuPVJvKFwic3BsaWNlXCIpLFJuPU1hdGgubWF4LGpuPU1hdGgubWluLExuPTkwMDcxOTkyNTQ3NDA5OTEsSG49XCJNYXhpbXVtIGFsbG93ZWQgbGVuZ3RoIGV4Y2VlZGVkXCI7cSh7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IUFufSx7c3BsaWNlOmZ1bmN0aW9uKHQsZSl7dmFyIGksbyxuLHIscyxhLGg9YXQodGhpcyksZD1LKGgubGVuZ3RoKSxsPVoodCxkKSxjPWFyZ3VtZW50cy5sZW5ndGg7aWYoMD09PWM/aT1vPTA6MT09PWM/KGk9MCxvPWQtbCk6KGk9Yy0yLG89am4oUm4oWChlKSwwKSxkLWwpKSxkK2ktbz5Mbil0aHJvdyBUeXBlRXJyb3IoSG4pO2ZvcihuPWppKGgsbykscj0wO3I8bztyKyspKHM9bCtyKWluIGgmJmRpKG4scixoW3NdKTtpZihuLmxlbmd0aD1vLGk8byl7Zm9yKHI9bDtyPGQtbztyKyspYT1yK2ksKHM9citvKWluIGg/aFthXT1oW3NdOmRlbGV0ZSBoW2FdO2ZvcihyPWQ7cj5kLW8raTtyLS0pZGVsZXRlIGhbci0xXX1lbHNlIGlmKGk+bylmb3Iocj1kLW87cj5sO3ItLSlhPXIraS0xLChzPXIrby0xKWluIGg/aFthXT1oW3NdOmRlbGV0ZSBoW2FdO2ZvcihyPTA7cjxpO3IrKyloW3IrbF09YXJndW1lbnRzW3IrMl07cmV0dXJuIGgubGVuZ3RoPWQtbytpLG59fSk7dmFyIFduPWd0KFwiQXJyYXlcIikuc3BsaWNlLFZuPUFycmF5LnByb3RvdHlwZSxxbj1mdW5jdGlvbih0KXt2YXIgZT10LnNwbGljZTtyZXR1cm4gdD09PVZufHx0IGluc3RhbmNlb2YgQXJyYXkmJmU9PT1Wbi5zcGxpY2U/V246ZX0sVW49dHQuaW5jbHVkZXM7cSh7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMH0se2luY2x1ZGVzOmZ1bmN0aW9uKHQpe3JldHVybiBVbih0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pO3ZhciBZbj1ndChcIkFycmF5XCIpLmluY2x1ZGVzLFhuPWJlKFwibWF0Y2hcIiksR249ZnVuY3Rpb24odCl7aWYoZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIG0odCkmJih2b2lkIDAhPT0oZT10W1huXSk/ISFlOlwiUmVnRXhwXCI9PWYodCkpfSh0KSl0aHJvdyBUeXBlRXJyb3IoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7cmV0dXJuIHR9LEtuPWJlKFwibWF0Y2hcIik7cSh7dGFyZ2V0OlwiU3RyaW5nXCIscHJvdG86ITAsZm9yY2VkOiFmdW5jdGlvbih0KXt2YXIgZT0vLi87dHJ5e1wiLy4vXCJbdF0oZSl9Y2F0Y2goaSl7dHJ5e3JldHVybiBlW0tuXT0hMSxcIi8uL1wiW3RdKGUpfWNhdGNoKHQpe319cmV0dXJuITF9KFwiaW5jbHVkZXNcIil9LHtpbmNsdWRlczpmdW5jdGlvbih0KXtyZXR1cm4hIX5TdHJpbmcoZyh0aGlzKSkuaW5kZXhPZihHbih0KSxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSk7dmFyICRuPWd0KFwiU3RyaW5nXCIpLmluY2x1ZGVzLFFuPUFycmF5LnByb3RvdHlwZSxabj1TdHJpbmcucHJvdG90eXBlLEpuPWZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5jbHVkZXM7cmV0dXJuIHQ9PT1Rbnx8dCBpbnN0YW5jZW9mIEFycmF5JiZlPT09UW4uaW5jbHVkZXM/WW46XCJzdHJpbmdcIj09dHlwZW9mIHR8fHQ9PT1abnx8dCBpbnN0YW5jZW9mIFN0cmluZyYmZT09PVpuLmluY2x1ZGVzPyRuOmV9LHRyPXMoKGZ1bmN0aW9uKCl7aWUoMSl9KSk7cSh7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxmb3JjZWQ6dHIsc2hhbTohSnR9LHtnZXRQcm90b3R5cGVPZjpmdW5jdGlvbih0KXtyZXR1cm4gaWUoYXQodCkpfX0pO3ZhciBlcj1GLk9iamVjdC5nZXRQcm90b3R5cGVPZixpcj1lcixvcj1XaS5maWx0ZXIsbnI9Um8oXCJmaWx0ZXJcIik7cSh7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IW5yfSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe3JldHVybiBvcih0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pO3ZhciBycj1ndChcIkFycmF5XCIpLmZpbHRlcixzcj1BcnJheS5wcm90b3R5cGUsYXI9ZnVuY3Rpb24odCl7dmFyIGU9dC5maWx0ZXI7cmV0dXJuIHQ9PT1zcnx8dCBpbnN0YW5jZW9mIEFycmF5JiZlPT09c3IuZmlsdGVyP3JyOmV9LGhyPWwuZixkcj1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7Zm9yKHZhciBpLG89eShlKSxuPXJ0KG8pLHI9bi5sZW5ndGgscz0wLGg9W107cj5zOylpPW5bcysrXSxhJiYhaHIuY2FsbChvLGkpfHxoLnB1c2godD9baSxvW2ldXTpvW2ldKTtyZXR1cm4gaH19LGxyPXtlbnRyaWVzOmRyKCEwKSx2YWx1ZXM6ZHIoITEpfS52YWx1ZXM7cSh7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMH0se3ZhbHVlczpmdW5jdGlvbih0KXtyZXR1cm4gbHIodCl9fSksRi5PYmplY3QudmFsdWVzO3ZhciBjcj1cIlxcdFxcblxcdlxcZlxcciDCoOGagOKAgOKAgeKAguKAg+KAhOKAheKAhuKAh+KAiOKAieKAiuKAr+KBn+OAgFxcdTIwMjhcXHUyMDI5XFx1ZmVmZlwiLHVyPVwiW1wiK2NyK1wiXVwiLGZyPVJlZ0V4cChcIl5cIit1cit1citcIipcIikscHI9UmVnRXhwKHVyK3VyK1wiKiRcIiksdnI9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciBpPVN0cmluZyhnKGUpKTtyZXR1cm4gMSZ0JiYoaT1pLnJlcGxhY2UoZnIsXCJcIikpLDImdCYmKGk9aS5yZXBsYWNlKHByLFwiXCIpKSxpfX0sZ3I9e3N0YXJ0OnZyKDEpLGVuZDp2cigyKSx0cmltOnZyKDMpfSx5cj1nci50cmltLG1yPXIucGFyc2VJbnQsYnI9L15bKy1dPzBbWHhdLyx3cj04IT09bXIoY3IrXCIwOFwiKXx8MjIhPT1tcihjcitcIjB4MTZcIik/ZnVuY3Rpb24odCxlKXt2YXIgaT15cihTdHJpbmcodCkpO3JldHVybiBtcihpLGU+Pj4wfHwoYnIudGVzdChpKT8xNjoxMCkpfTptcjtxKHtnbG9iYWw6ITAsZm9yY2VkOnBhcnNlSW50IT13cn0se3BhcnNlSW50OndyfSk7dmFyIGtyPUYucGFyc2VJbnQsX3I9dHQuaW5kZXhPZix4cj1bXS5pbmRleE9mLEVyPSEheHImJjEvWzFdLmluZGV4T2YoMSwtMCk8MCxPcj1PbihcImluZGV4T2ZcIik7cSh7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6RXJ8fCFPcn0se2luZGV4T2Y6ZnVuY3Rpb24odCl7cmV0dXJuIEVyP3hyLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8MDpfcih0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pO3ZhciBDcixTcj1ndChcIkFycmF5XCIpLmluZGV4T2YsVHI9QXJyYXkucHJvdG90eXBlLE1yPWZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5kZXhPZjtyZXR1cm4gdD09PVRyfHx0IGluc3RhbmNlb2YgQXJyYXkmJmU9PT1Uci5pbmRleE9mP1NyOmV9LFByPWdyLnRyaW07cSh7dGFyZ2V0OlwiU3RyaW5nXCIscHJvdG86ITAsZm9yY2VkOihDcj1cInRyaW1cIixzKChmdW5jdGlvbigpe3JldHVybiEhY3JbQ3JdKCl8fFwi4oCLwoXhoI5cIiE9XCLigIvCheGgjlwiW0NyXSgpfHxjcltDcl0ubmFtZSE9PUNyfSkpKX0se3RyaW06ZnVuY3Rpb24oKXtyZXR1cm4gUHIodGhpcyl9fSksZ3QoXCJTdHJpbmdcIikudHJpbSxxKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLHNoYW06IWF9LHtjcmVhdGU6RGV9KTt2YXIgRHI9Ri5PYmplY3QsQnI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gRHIuY3JlYXRlKHQsZSl9LElyPUJyLHpyPXJlKFwiSlNPTlwiLFwic3RyaW5naWZ5XCIpLEZyPS9bXFx1RDgwMC1cXHVERkZGXS9nLE5yPS9eW1xcdUQ4MDAtXFx1REJGRl0kLyxBcj0vXltcXHVEQzAwLVxcdURGRkZdJC8sUnI9ZnVuY3Rpb24odCxlLGkpe3ZhciBvPWkuY2hhckF0KGUtMSksbj1pLmNoYXJBdChlKzEpO3JldHVybiBOci50ZXN0KHQpJiYhQXIudGVzdChuKXx8QXIudGVzdCh0KSYmIU5yLnRlc3Qobyk/XCJcXFxcdVwiK3QuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik6dH0sanI9cygoZnVuY3Rpb24oKXtyZXR1cm4nXCJcXFxcdWRmMDZcXFxcdWQ4MzRcIichPT16cihcIlxcdWRmMDZcXHVkODM0XCIpfHwnXCJcXFxcdWRlYWRcIichPT16cihcIlxcdWRlYWRcIil9KSk7enImJnEoe3RhcmdldDpcIkpTT05cIixzdGF0OiEwLGZvcmNlZDpqcn0se3N0cmluZ2lmeTpmdW5jdGlvbih0LGUsaSl7dmFyIG89enIuYXBwbHkobnVsbCxhcmd1bWVudHMpO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBvP28ucmVwbGFjZShGcixScik6b319KSxGLkpTT058fChGLkpTT049e3N0cmluZ2lmeTpKU09OLnN0cmluZ2lmeX0pO3ZhciBMcj1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIEYuSlNPTi5zdHJpbmdpZnkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxIcj1bXS5zbGljZSxXcj0vTVNJRSAuXFwuLy50ZXN0KHNlKSxWcj1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxpKXt2YXIgbz1hcmd1bWVudHMubGVuZ3RoPjIsbj1vP0hyLmNhbGwoYXJndW1lbnRzLDIpOnZvaWQgMDtyZXR1cm4gdChvP2Z1bmN0aW9uKCl7KFwiZnVuY3Rpb25cIj09dHlwZW9mIGU/ZTpGdW5jdGlvbihlKSkuYXBwbHkodGhpcyxuKX06ZSxpKX19O3Eoe2dsb2JhbDohMCxiaW5kOiEwLGZvcmNlZDpXcn0se3NldFRpbWVvdXQ6VnIoci5zZXRUaW1lb3V0KSxzZXRJbnRlcnZhbDpWcihyLnNldEludGVydmFsKX0pO3ZhciBxcj1GLnNldFRpbWVvdXQ7cSh7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMH0se2ZpbGw6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPWF0KHRoaXMpLGk9SyhlLmxlbmd0aCksbz1hcmd1bWVudHMubGVuZ3RoLG49WihvPjE/YXJndW1lbnRzWzFdOnZvaWQgMCxpKSxyPW8+Mj9hcmd1bWVudHNbMl06dm9pZCAwLHM9dm9pZCAwPT09cj9pOloocixpKTtzPm47KWVbbisrXT10O3JldHVybiBlfX0pO3ZhciBVcj1ndChcIkFycmF5XCIpLmZpbGwsWXI9QXJyYXkucHJvdG90eXBlLFhyPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZmlsbDtyZXR1cm4gdD09PVlyfHx0IGluc3RhbmNlb2YgQXJyYXkmJmU9PT1Zci5maWxsP1VyOmV9O1xuLyohIEhhbW1lci5KUyAtIHYyLjAuMTctcmMgLSAyMDE5LTEyLTE2XG5cdCAqIGh0dHA6Ly9uYXZlci5naXRodWIuaW8vZWdqc1xuXHQgKlxuXHQgKiBGb3JrZWQgQnkgTmF2ZXIgZWdqc1xuXHQgKiBDb3B5cmlnaHQgKGMpIGhhbW1lcmpzXG5cdCAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xuZnVuY3Rpb24gR3IoKXtyZXR1cm4oR3I9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIGk9YXJndW1lbnRzW2VdO2Zvcih2YXIgbyBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLG8pJiYodFtvXT1pW29dKX1yZXR1cm4gdH0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBLcih0LGUpe3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXQsdC5fX3Byb3RvX189ZX1mdW5jdGlvbiAkcih0KXtpZih2b2lkIDA9PT10KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gdH12YXIgUXIsWnI9XCJmdW5jdGlvblwiIT10eXBlb2YgT2JqZWN0LmFzc2lnbj9mdW5jdGlvbih0KXtpZihudWxsPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcIik7Zm9yKHZhciBlPU9iamVjdCh0KSxpPTE7aTxhcmd1bWVudHMubGVuZ3RoO2krKyl7dmFyIG89YXJndW1lbnRzW2ldO2lmKG51bGwhPW8pZm9yKHZhciBuIGluIG8pby5oYXNPd25Qcm9wZXJ0eShuKSYmKGVbbl09b1tuXSl9cmV0dXJuIGV9Ok9iamVjdC5hc3NpZ24sSnI9W1wiXCIsXCJ3ZWJraXRcIixcIk1velwiLFwiTVNcIixcIm1zXCIsXCJvXCJdLHRzPVwidW5kZWZpbmVkXCI9PXR5cGVvZiBkb2N1bWVudD97c3R5bGU6e319OmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksZXM9TWF0aC5yb3VuZCxpcz1NYXRoLmFicyxvcz1EYXRlLm5vdztmdW5jdGlvbiBucyh0LGUpe2Zvcih2YXIgaSxvLG49ZVswXS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSkscj0wO3I8SnIubGVuZ3RoOyl7aWYoKG89KGk9SnJbcl0pP2krbjplKWluIHQpcmV0dXJuIG87cisrfX1Rcj1cInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93P3t9OndpbmRvdzt2YXIgcnM9bnModHMuc3R5bGUsXCJ0b3VjaEFjdGlvblwiKSxzcz12b2lkIDAhPT1yczt2YXIgYXM9XCJjb21wdXRlXCIsaHM9XCJhdXRvXCIsZHM9XCJtYW5pcHVsYXRpb25cIixscz1cIm5vbmVcIixjcz1cInBhbi14XCIsdXM9XCJwYW4teVwiLGZzPWZ1bmN0aW9uKCl7aWYoIXNzKXJldHVybiExO3ZhciB0PXt9LGU9UXIuQ1NTJiZRci5DU1Muc3VwcG9ydHM7cmV0dXJuW1wiYXV0b1wiLFwibWFuaXB1bGF0aW9uXCIsXCJwYW4teVwiLFwicGFuLXhcIixcInBhbi14IHBhbi15XCIsXCJub25lXCJdLmZvckVhY2goKGZ1bmN0aW9uKGkpe3JldHVybiB0W2ldPSFlfHxRci5DU1Muc3VwcG9ydHMoXCJ0b3VjaC1hY3Rpb25cIixpKX0pKSx0fSgpLHBzPVwib250b3VjaHN0YXJ0XCJpbiBRcix2cz12b2lkIDAhPT1ucyhRcixcIlBvaW50ZXJFdmVudFwiKSxncz1wcyYmL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkseXM9XCJ0b3VjaFwiLG1zPVwibW91c2VcIixicz0xNix3cz0yNCxrcz1bXCJ4XCIsXCJ5XCJdLF9zPVtcImNsaWVudFhcIixcImNsaWVudFlcIl07ZnVuY3Rpb24geHModCxlLGkpe3ZhciBvO2lmKHQpaWYodC5mb3JFYWNoKXQuZm9yRWFjaChlLGkpO2Vsc2UgaWYodm9pZCAwIT09dC5sZW5ndGgpZm9yKG89MDtvPHQubGVuZ3RoOyllLmNhbGwoaSx0W29dLG8sdCksbysrO2Vsc2UgZm9yKG8gaW4gdCl0Lmhhc093blByb3BlcnR5KG8pJiZlLmNhbGwoaSx0W29dLG8sdCl9ZnVuY3Rpb24gRXModCxlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3QuYXBwbHkoZSYmZVswXXx8dm9pZCAwLGUpOnR9ZnVuY3Rpb24gT3ModCxlKXtyZXR1cm4gdC5pbmRleE9mKGUpPi0xfXZhciBDcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLm1hbmFnZXI9dCx0aGlzLnNldChlKX12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5zZXQ9ZnVuY3Rpb24odCl7dD09PWFzJiYodD10aGlzLmNvbXB1dGUoKSksc3MmJnRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlJiZmc1t0XSYmKHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW3JzXT10KSx0aGlzLmFjdGlvbnM9dC50b0xvd2VyQ2FzZSgpLnRyaW0oKX0sZS51cGRhdGU9ZnVuY3Rpb24oKXt0aGlzLnNldCh0aGlzLm1hbmFnZXIub3B0aW9ucy50b3VjaEFjdGlvbil9LGUuY29tcHV0ZT1mdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiB4cyh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsKGZ1bmN0aW9uKGUpe0VzKGUub3B0aW9ucy5lbmFibGUsW2VdKSYmKHQ9dC5jb25jYXQoZS5nZXRUb3VjaEFjdGlvbigpKSl9KSksZnVuY3Rpb24odCl7aWYoT3ModCxscykpcmV0dXJuIGxzO3ZhciBlPU9zKHQsY3MpLGk9T3ModCx1cyk7cmV0dXJuIGUmJmk/bHM6ZXx8aT9lP2NzOnVzOk9zKHQsZHMpP2RzOmhzfSh0LmpvaW4oXCIgXCIpKX0sZS5wcmV2ZW50RGVmYXVsdHM9ZnVuY3Rpb24odCl7dmFyIGU9dC5zcmNFdmVudCxpPXQub2Zmc2V0RGlyZWN0aW9uO2lmKHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCllLnByZXZlbnREZWZhdWx0KCk7ZWxzZXt2YXIgbz10aGlzLmFjdGlvbnMsbj1PcyhvLGxzKSYmIWZzLm5vbmUscj1PcyhvLHVzKSYmIWZzW1wicGFuLXlcIl0scz1PcyhvLGNzKSYmIWZzW1wicGFuLXhcIl07aWYobil7dmFyIGE9MT09PXQucG9pbnRlcnMubGVuZ3RoLGg9dC5kaXN0YW5jZTwyLGQ9dC5kZWx0YVRpbWU8MjUwO2lmKGEmJmgmJmQpcmV0dXJufWlmKCFzfHwhcilyZXR1cm4gbnx8ciYmNiZpfHxzJiZpJndzP3RoaXMucHJldmVudFNyYyhlKTp2b2lkIDB9fSxlLnByZXZlbnRTcmM9ZnVuY3Rpb24odCl7dGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkPSEwLHQucHJldmVudERlZmF1bHQoKX0sdH0oKTtmdW5jdGlvbiBTcyh0LGUpe2Zvcig7dDspe2lmKHQ9PT1lKXJldHVybiEwO3Q9dC5wYXJlbnROb2RlfXJldHVybiExfWZ1bmN0aW9uIFRzKHQpe3ZhciBlPXQubGVuZ3RoO2lmKDE9PT1lKXJldHVybnt4OmVzKHRbMF0uY2xpZW50WCkseTplcyh0WzBdLmNsaWVudFkpfTtmb3IodmFyIGk9MCxvPTAsbj0wO248ZTspaSs9dFtuXS5jbGllbnRYLG8rPXRbbl0uY2xpZW50WSxuKys7cmV0dXJue3g6ZXMoaS9lKSx5OmVzKG8vZSl9fWZ1bmN0aW9uIE1zKHQpe2Zvcih2YXIgZT1bXSxpPTA7aTx0LnBvaW50ZXJzLmxlbmd0aDspZVtpXT17Y2xpZW50WDplcyh0LnBvaW50ZXJzW2ldLmNsaWVudFgpLGNsaWVudFk6ZXModC5wb2ludGVyc1tpXS5jbGllbnRZKX0saSsrO3JldHVybnt0aW1lU3RhbXA6b3MoKSxwb2ludGVyczplLGNlbnRlcjpUcyhlKSxkZWx0YVg6dC5kZWx0YVgsZGVsdGFZOnQuZGVsdGFZfX1mdW5jdGlvbiBQcyh0LGUsaSl7aXx8KGk9a3MpO3ZhciBvPWVbaVswXV0tdFtpWzBdXSxuPWVbaVsxXV0tdFtpWzFdXTtyZXR1cm4gTWF0aC5zcXJ0KG8qbytuKm4pfWZ1bmN0aW9uIERzKHQsZSxpKXtpfHwoaT1rcyk7dmFyIG89ZVtpWzBdXS10W2lbMF1dLG49ZVtpWzFdXS10W2lbMV1dO3JldHVybiAxODAqTWF0aC5hdGFuMihuLG8pL01hdGguUEl9ZnVuY3Rpb24gQnModCxlKXtyZXR1cm4gdD09PWU/MTppcyh0KT49aXMoZSk/dDwwPzI6NDplPDA/ODpic31mdW5jdGlvbiBJcyh0LGUsaSl7cmV0dXJue3g6ZS90fHwwLHk6aS90fHwwfX1mdW5jdGlvbiB6cyh0LGUpe3ZhciBpPXQuc2Vzc2lvbixvPWUucG9pbnRlcnMsbj1vLmxlbmd0aDtpLmZpcnN0SW5wdXR8fChpLmZpcnN0SW5wdXQ9TXMoZSkpLG4+MSYmIWkuZmlyc3RNdWx0aXBsZT9pLmZpcnN0TXVsdGlwbGU9TXMoZSk6MT09PW4mJihpLmZpcnN0TXVsdGlwbGU9ITEpO3ZhciByPWkuZmlyc3RJbnB1dCxzPWkuZmlyc3RNdWx0aXBsZSxhPXM/cy5jZW50ZXI6ci5jZW50ZXIsaD1lLmNlbnRlcj1UcyhvKTtlLnRpbWVTdGFtcD1vcygpLGUuZGVsdGFUaW1lPWUudGltZVN0YW1wLXIudGltZVN0YW1wLGUuYW5nbGU9RHMoYSxoKSxlLmRpc3RhbmNlPVBzKGEsaCksZnVuY3Rpb24odCxlKXt2YXIgaT1lLmNlbnRlcixvPXQub2Zmc2V0RGVsdGF8fHt9LG49dC5wcmV2RGVsdGF8fHt9LHI9dC5wcmV2SW5wdXR8fHt9OzEhPT1lLmV2ZW50VHlwZSYmNCE9PXIuZXZlbnRUeXBlfHwobj10LnByZXZEZWx0YT17eDpyLmRlbHRhWHx8MCx5OnIuZGVsdGFZfHwwfSxvPXQub2Zmc2V0RGVsdGE9e3g6aS54LHk6aS55fSksZS5kZWx0YVg9bi54KyhpLngtby54KSxlLmRlbHRhWT1uLnkrKGkueS1vLnkpfShpLGUpLGUub2Zmc2V0RGlyZWN0aW9uPUJzKGUuZGVsdGFYLGUuZGVsdGFZKTt2YXIgZCxsLGM9SXMoZS5kZWx0YVRpbWUsZS5kZWx0YVgsZS5kZWx0YVkpO2Uub3ZlcmFsbFZlbG9jaXR5WD1jLngsZS5vdmVyYWxsVmVsb2NpdHlZPWMueSxlLm92ZXJhbGxWZWxvY2l0eT1pcyhjLngpPmlzKGMueSk/Yy54OmMueSxlLnNjYWxlPXM/KGQ9cy5wb2ludGVycyxQcygobD1vKVswXSxsWzFdLF9zKS9QcyhkWzBdLGRbMV0sX3MpKToxLGUucm90YXRpb249cz9mdW5jdGlvbih0LGUpe3JldHVybiBEcyhlWzFdLGVbMF0sX3MpK0RzKHRbMV0sdFswXSxfcyl9KHMucG9pbnRlcnMsbyk6MCxlLm1heFBvaW50ZXJzPWkucHJldklucHV0P2UucG9pbnRlcnMubGVuZ3RoPmkucHJldklucHV0Lm1heFBvaW50ZXJzP2UucG9pbnRlcnMubGVuZ3RoOmkucHJldklucHV0Lm1heFBvaW50ZXJzOmUucG9pbnRlcnMubGVuZ3RoLGZ1bmN0aW9uKHQsZSl7dmFyIGksbyxuLHIscz10Lmxhc3RJbnRlcnZhbHx8ZSxhPWUudGltZVN0YW1wLXMudGltZVN0YW1wO2lmKDghPT1lLmV2ZW50VHlwZSYmKGE+MjV8fHZvaWQgMD09PXMudmVsb2NpdHkpKXt2YXIgaD1lLmRlbHRhWC1zLmRlbHRhWCxkPWUuZGVsdGFZLXMuZGVsdGFZLGw9SXMoYSxoLGQpO289bC54LG49bC55LGk9aXMobC54KT5pcyhsLnkpP2wueDpsLnkscj1CcyhoLGQpLHQubGFzdEludGVydmFsPWV9ZWxzZSBpPXMudmVsb2NpdHksbz1zLnZlbG9jaXR5WCxuPXMudmVsb2NpdHlZLHI9cy5kaXJlY3Rpb247ZS52ZWxvY2l0eT1pLGUudmVsb2NpdHlYPW8sZS52ZWxvY2l0eVk9bixlLmRpcmVjdGlvbj1yfShpLGUpO3ZhciB1LGY9dC5lbGVtZW50LHA9ZS5zcmNFdmVudDtTcyh1PXAuY29tcG9zZWRQYXRoP3AuY29tcG9zZWRQYXRoKClbMF06cC5wYXRoP3AucGF0aFswXTpwLnRhcmdldCxmKSYmKGY9dSksZS50YXJnZXQ9Zn1mdW5jdGlvbiBGcyh0LGUsaSl7dmFyIG89aS5wb2ludGVycy5sZW5ndGgsbj1pLmNoYW5nZWRQb2ludGVycy5sZW5ndGgscj0xJmUmJm8tbj09MCxzPTEyJmUmJm8tbj09MDtpLmlzRmlyc3Q9ISFyLGkuaXNGaW5hbD0hIXMsciYmKHQuc2Vzc2lvbj17fSksaS5ldmVudFR5cGU9ZSx6cyh0LGkpLHQuZW1pdChcImhhbW1lci5pbnB1dFwiLGkpLHQucmVjb2duaXplKGkpLHQuc2Vzc2lvbi5wcmV2SW5wdXQ9aX1mdW5jdGlvbiBOcyh0KXtyZXR1cm4gdC50cmltKCkuc3BsaXQoL1xccysvZyl9ZnVuY3Rpb24gQXModCxlLGkpe3hzKE5zKGUpLChmdW5jdGlvbihlKXt0LmFkZEV2ZW50TGlzdGVuZXIoZSxpLCExKX0pKX1mdW5jdGlvbiBScyh0LGUsaSl7eHMoTnMoZSksKGZ1bmN0aW9uKGUpe3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLGksITEpfSkpfWZ1bmN0aW9uIGpzKHQpe3ZhciBlPXQub3duZXJEb2N1bWVudHx8dDtyZXR1cm4gZS5kZWZhdWx0Vmlld3x8ZS5wYXJlbnRXaW5kb3d8fHdpbmRvd312YXIgTHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dmFyIGk9dGhpczt0aGlzLm1hbmFnZXI9dCx0aGlzLmNhbGxiYWNrPWUsdGhpcy5lbGVtZW50PXQuZWxlbWVudCx0aGlzLnRhcmdldD10Lm9wdGlvbnMuaW5wdXRUYXJnZXQsdGhpcy5kb21IYW5kbGVyPWZ1bmN0aW9uKGUpe0VzKHQub3B0aW9ucy5lbmFibGUsW3RdKSYmaS5oYW5kbGVyKGUpfSx0aGlzLmluaXQoKX12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5oYW5kbGVyPWZ1bmN0aW9uKCl7fSxlLmluaXQ9ZnVuY3Rpb24oKXt0aGlzLmV2RWwmJkFzKHRoaXMuZWxlbWVudCx0aGlzLmV2RWwsdGhpcy5kb21IYW5kbGVyKSx0aGlzLmV2VGFyZ2V0JiZBcyh0aGlzLnRhcmdldCx0aGlzLmV2VGFyZ2V0LHRoaXMuZG9tSGFuZGxlciksdGhpcy5ldldpbiYmQXMoanModGhpcy5lbGVtZW50KSx0aGlzLmV2V2luLHRoaXMuZG9tSGFuZGxlcil9LGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZXZFbCYmUnModGhpcy5lbGVtZW50LHRoaXMuZXZFbCx0aGlzLmRvbUhhbmRsZXIpLHRoaXMuZXZUYXJnZXQmJlJzKHRoaXMudGFyZ2V0LHRoaXMuZXZUYXJnZXQsdGhpcy5kb21IYW5kbGVyKSx0aGlzLmV2V2luJiZScyhqcyh0aGlzLmVsZW1lbnQpLHRoaXMuZXZXaW4sdGhpcy5kb21IYW5kbGVyKX0sdH0oKTtmdW5jdGlvbiBIcyh0LGUsaSl7aWYodC5pbmRleE9mJiYhaSlyZXR1cm4gdC5pbmRleE9mKGUpO2Zvcih2YXIgbz0wO288dC5sZW5ndGg7KXtpZihpJiZ0W29dW2ldPT1lfHwhaSYmdFtvXT09PWUpcmV0dXJuIG87bysrfXJldHVybi0xfXZhciBXcz17cG9pbnRlcmRvd246MSxwb2ludGVybW92ZToyLHBvaW50ZXJ1cDo0LHBvaW50ZXJjYW5jZWw6OCxwb2ludGVyb3V0Ojh9LFZzPXsyOnlzLDM6XCJwZW5cIiw0Om1zLDU6XCJraW5lY3RcIn0scXM9XCJwb2ludGVyZG93blwiLFVzPVwicG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWxcIjtRci5NU1BvaW50ZXJFdmVudCYmIVFyLlBvaW50ZXJFdmVudCYmKHFzPVwiTVNQb2ludGVyRG93blwiLFVzPVwiTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWxcIik7dmFyIFlzPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgaSxvPWUucHJvdG90eXBlO3JldHVybiBvLmV2RWw9cXMsby5ldldpbj1VcywoaT10LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcykuc3RvcmU9aS5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cz1bXSxpfXJldHVybiBLcihlLHQpLGUucHJvdG90eXBlLmhhbmRsZXI9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5zdG9yZSxpPSExLG89dC50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZShcIm1zXCIsXCJcIiksbj1Xc1tvXSxyPVZzW3QucG9pbnRlclR5cGVdfHx0LnBvaW50ZXJUeXBlLHM9cj09PXlzLGE9SHMoZSx0LnBvaW50ZXJJZCxcInBvaW50ZXJJZFwiKTsxJm4mJigwPT09dC5idXR0b258fHMpP2E8MCYmKGUucHVzaCh0KSxhPWUubGVuZ3RoLTEpOjEyJm4mJihpPSEwKSxhPDB8fChlW2FdPXQsdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsbix7cG9pbnRlcnM6ZSxjaGFuZ2VkUG9pbnRlcnM6W3RdLHBvaW50ZXJUeXBlOnIsc3JjRXZlbnQ6dH0pLGkmJmUuc3BsaWNlKGEsMSkpfSxlfShMcyk7ZnVuY3Rpb24gWHModCl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQsMCl9ZnVuY3Rpb24gR3ModCxlLGkpe2Zvcih2YXIgbz1bXSxuPVtdLHI9MDtyPHQubGVuZ3RoOyl7dmFyIHM9ZT90W3JdW2VdOnRbcl07SHMobixzKTwwJiZvLnB1c2godFtyXSksbltyXT1zLHIrK31yZXR1cm4gaSYmKG89ZT9vLnNvcnQoKGZ1bmN0aW9uKHQsaSl7cmV0dXJuIHRbZV0+aVtlXX0pKTpvLnNvcnQoKSksb312YXIgS3M9e3RvdWNoc3RhcnQ6MSx0b3VjaG1vdmU6Mix0b3VjaGVuZDo0LHRvdWNoY2FuY2VsOjh9LCRzPVwidG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWxcIixRcz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIGk7cmV0dXJuIGUucHJvdG90eXBlLmV2VGFyZ2V0PSRzLChpPXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzKS50YXJnZXRJZHM9e30saX1yZXR1cm4gS3IoZSx0KSxlLnByb3RvdHlwZS5oYW5kbGVyPWZ1bmN0aW9uKHQpe3ZhciBlPUtzW3QudHlwZV0saT1acy5jYWxsKHRoaXMsdCxlKTtpJiZ0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlcixlLHtwb2ludGVyczppWzBdLGNoYW5nZWRQb2ludGVyczppWzFdLHBvaW50ZXJUeXBlOnlzLHNyY0V2ZW50OnR9KX0sZX0oTHMpO2Z1bmN0aW9uIFpzKHQsZSl7dmFyIGksbyxuPVhzKHQudG91Y2hlcykscj10aGlzLnRhcmdldElkcztpZigzJmUmJjE9PT1uLmxlbmd0aClyZXR1cm4gcltuWzBdLmlkZW50aWZpZXJdPSEwLFtuLG5dO3ZhciBzPVhzKHQuY2hhbmdlZFRvdWNoZXMpLGE9W10saD10aGlzLnRhcmdldDtpZihvPW4uZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gU3ModC50YXJnZXQsaCl9KSksMT09PWUpZm9yKGk9MDtpPG8ubGVuZ3RoOylyW29baV0uaWRlbnRpZmllcl09ITAsaSsrO2ZvcihpPTA7aTxzLmxlbmd0aDspcltzW2ldLmlkZW50aWZpZXJdJiZhLnB1c2goc1tpXSksMTImZSYmZGVsZXRlIHJbc1tpXS5pZGVudGlmaWVyXSxpKys7cmV0dXJuIGEubGVuZ3RoP1tHcyhvLmNvbmNhdChhKSxcImlkZW50aWZpZXJcIiwhMCksYV06dm9pZCAwfXZhciBKcz17bW91c2Vkb3duOjEsbW91c2Vtb3ZlOjIsbW91c2V1cDo0fSx0YT1cIm1vdXNlZG93blwiLGVhPVwibW91c2Vtb3ZlIG1vdXNldXBcIixpYT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIGksbz1lLnByb3RvdHlwZTtyZXR1cm4gby5ldkVsPXRhLG8uZXZXaW49ZWEsKGk9dC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXMpLnByZXNzZWQ9ITEsaX1yZXR1cm4gS3IoZSx0KSxlLnByb3RvdHlwZS5oYW5kbGVyPWZ1bmN0aW9uKHQpe3ZhciBlPUpzW3QudHlwZV07MSZlJiYwPT09dC5idXR0b24mJih0aGlzLnByZXNzZWQ9ITApLDImZSYmMSE9PXQud2hpY2gmJihlPTQpLHRoaXMucHJlc3NlZCYmKDQmZSYmKHRoaXMucHJlc3NlZD0hMSksdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsZSx7cG9pbnRlcnM6W3RdLGNoYW5nZWRQb2ludGVyczpbdF0scG9pbnRlclR5cGU6bXMsc3JjRXZlbnQ6dH0pKX0sZX0oTHMpO2Z1bmN0aW9uIG9hKHQpe3ZhciBlPXQuY2hhbmdlZFBvaW50ZXJzWzBdO2lmKGUuaWRlbnRpZmllcj09PXRoaXMucHJpbWFyeVRvdWNoKXt2YXIgaT17eDplLmNsaWVudFgseTplLmNsaWVudFl9LG89dGhpcy5sYXN0VG91Y2hlczt0aGlzLmxhc3RUb3VjaGVzLnB1c2goaSk7c2V0VGltZW91dCgoZnVuY3Rpb24oKXt2YXIgdD1vLmluZGV4T2YoaSk7dD4tMSYmby5zcGxpY2UodCwxKX0pLDI1MDApfX1mdW5jdGlvbiBuYSh0LGUpezEmdD8odGhpcy5wcmltYXJ5VG91Y2g9ZS5jaGFuZ2VkUG9pbnRlcnNbMF0uaWRlbnRpZmllcixvYS5jYWxsKHRoaXMsZSkpOjEyJnQmJm9hLmNhbGwodGhpcyxlKX1mdW5jdGlvbiByYSh0KXtmb3IodmFyIGU9dC5zcmNFdmVudC5jbGllbnRYLGk9dC5zcmNFdmVudC5jbGllbnRZLG89MDtvPHRoaXMubGFzdFRvdWNoZXMubGVuZ3RoO28rKyl7dmFyIG49dGhpcy5sYXN0VG91Y2hlc1tvXSxyPU1hdGguYWJzKGUtbi54KSxzPU1hdGguYWJzKGktbi55KTtpZihyPD0yNSYmczw9MjUpcmV0dXJuITB9cmV0dXJuITF9dmFyIHNhPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxpKXt2YXIgbztyZXR1cm4obz10LmNhbGwodGhpcyxlLGkpfHx0aGlzKS5oYW5kbGVyPWZ1bmN0aW9uKHQsZSxpKXt2YXIgbj1pLnBvaW50ZXJUeXBlPT09eXMscj1pLnBvaW50ZXJUeXBlPT09bXM7aWYoIShyJiZpLnNvdXJjZUNhcGFiaWxpdGllcyYmaS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykpe2lmKG4pbmEuY2FsbCgkcigkcihvKSksZSxpKTtlbHNlIGlmKHImJnJhLmNhbGwoJHIoJHIobykpLGkpKXJldHVybjtvLmNhbGxiYWNrKHQsZSxpKX19LG8udG91Y2g9bmV3IFFzKG8ubWFuYWdlcixvLmhhbmRsZXIpLG8ubW91c2U9bmV3IGlhKG8ubWFuYWdlcixvLmhhbmRsZXIpLG8ucHJpbWFyeVRvdWNoPW51bGwsby5sYXN0VG91Y2hlcz1bXSxvfXJldHVybiBLcihlLHQpLGUucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLnRvdWNoLmRlc3Ryb3koKSx0aGlzLm1vdXNlLmRlc3Ryb3koKX0sZX0oTHMpfSgpO2Z1bmN0aW9uIGFhKHQsZSxpKXtyZXR1cm4hIUFycmF5LmlzQXJyYXkodCkmJih4cyh0LGlbZV0saSksITApfXZhciBoYT0zMixkYT0xO2Z1bmN0aW9uIGxhKHQsZSl7dmFyIGk9ZS5tYW5hZ2VyO3JldHVybiBpP2kuZ2V0KHQpOnR9ZnVuY3Rpb24gY2EodCl7cmV0dXJuIDE2JnQ/XCJjYW5jZWxcIjo4JnQ/XCJlbmRcIjo0JnQ/XCJtb3ZlXCI6MiZ0P1wic3RhcnRcIjpcIlwifXZhciB1YT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dm9pZCAwPT09dCYmKHQ9e30pLHRoaXMub3B0aW9ucz1Hcih7ZW5hYmxlOiEwfSx0KSx0aGlzLmlkPWRhKyssdGhpcy5tYW5hZ2VyPW51bGwsdGhpcy5zdGF0ZT0xLHRoaXMuc2ltdWx0YW5lb3VzPXt9LHRoaXMucmVxdWlyZUZhaWw9W119dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuc2V0PWZ1bmN0aW9uKHQpe3JldHVybiBacih0aGlzLm9wdGlvbnMsdCksdGhpcy5tYW5hZ2VyJiZ0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCksdGhpc30sZS5yZWNvZ25pemVXaXRoPWZ1bmN0aW9uKHQpe2lmKGFhKHQsXCJyZWNvZ25pemVXaXRoXCIsdGhpcykpcmV0dXJuIHRoaXM7dmFyIGU9dGhpcy5zaW11bHRhbmVvdXM7cmV0dXJuIGVbKHQ9bGEodCx0aGlzKSkuaWRdfHwoZVt0LmlkXT10LHQucmVjb2duaXplV2l0aCh0aGlzKSksdGhpc30sZS5kcm9wUmVjb2duaXplV2l0aD1mdW5jdGlvbih0KXtyZXR1cm4gYWEodCxcImRyb3BSZWNvZ25pemVXaXRoXCIsdGhpcyl8fCh0PWxhKHQsdGhpcyksZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW3QuaWRdKSx0aGlzfSxlLnJlcXVpcmVGYWlsdXJlPWZ1bmN0aW9uKHQpe2lmKGFhKHQsXCJyZXF1aXJlRmFpbHVyZVwiLHRoaXMpKXJldHVybiB0aGlzO3ZhciBlPXRoaXMucmVxdWlyZUZhaWw7cmV0dXJuLTE9PT1IcyhlLHQ9bGEodCx0aGlzKSkmJihlLnB1c2godCksdC5yZXF1aXJlRmFpbHVyZSh0aGlzKSksdGhpc30sZS5kcm9wUmVxdWlyZUZhaWx1cmU9ZnVuY3Rpb24odCl7aWYoYWEodCxcImRyb3BSZXF1aXJlRmFpbHVyZVwiLHRoaXMpKXJldHVybiB0aGlzO3Q9bGEodCx0aGlzKTt2YXIgZT1Icyh0aGlzLnJlcXVpcmVGYWlsLHQpO3JldHVybiBlPi0xJiZ0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShlLDEpLHRoaXN9LGUuaGFzUmVxdWlyZUZhaWx1cmVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoPjB9LGUuY2FuUmVjb2duaXplV2l0aD1mdW5jdGlvbih0KXtyZXR1cm4hIXRoaXMuc2ltdWx0YW5lb3VzW3QuaWRdfSxlLmVtaXQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxpPXRoaXMuc3RhdGU7ZnVuY3Rpb24gbyhpKXtlLm1hbmFnZXIuZW1pdChpLHQpfWk8OCYmbyhlLm9wdGlvbnMuZXZlbnQrY2EoaSkpLG8oZS5vcHRpb25zLmV2ZW50KSx0LmFkZGl0aW9uYWxFdmVudCYmbyh0LmFkZGl0aW9uYWxFdmVudCksaT49OCYmbyhlLm9wdGlvbnMuZXZlbnQrY2EoaSkpfSxlLnRyeUVtaXQ9ZnVuY3Rpb24odCl7aWYodGhpcy5jYW5FbWl0KCkpcmV0dXJuIHRoaXMuZW1pdCh0KTt0aGlzLnN0YXRlPWhhfSxlLmNhbkVtaXQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoOyl7aWYoISgzMyZ0aGlzLnJlcXVpcmVGYWlsW3RdLnN0YXRlKSlyZXR1cm4hMTt0Kyt9cmV0dXJuITB9LGUucmVjb2duaXplPWZ1bmN0aW9uKHQpe3ZhciBlPVpyKHt9LHQpO2lmKCFFcyh0aGlzLm9wdGlvbnMuZW5hYmxlLFt0aGlzLGVdKSlyZXR1cm4gdGhpcy5yZXNldCgpLHZvaWQodGhpcy5zdGF0ZT1oYSk7NTYmdGhpcy5zdGF0ZSYmKHRoaXMuc3RhdGU9MSksdGhpcy5zdGF0ZT10aGlzLnByb2Nlc3MoZSksMzAmdGhpcy5zdGF0ZSYmdGhpcy50cnlFbWl0KGUpfSxlLnByb2Nlc3M9ZnVuY3Rpb24odCl7fSxlLmdldFRvdWNoQWN0aW9uPWZ1bmN0aW9uKCl7fSxlLnJlc2V0PWZ1bmN0aW9uKCl7fSx0fSgpLGZhPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIGk7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSwoaT10LmNhbGwodGhpcyxHcih7ZXZlbnQ6XCJ0YXBcIixwb2ludGVyczoxLHRhcHM6MSxpbnRlcnZhbDozMDAsdGltZToyNTAsdGhyZXNob2xkOjkscG9zVGhyZXNob2xkOjEwfSxlKSl8fHRoaXMpLnBUaW1lPSExLGkucENlbnRlcj0hMSxpLl90aW1lcj1udWxsLGkuX2lucHV0PW51bGwsaS5jb3VudD0wLGl9S3IoZSx0KTt2YXIgaT1lLnByb3RvdHlwZTtyZXR1cm4gaS5nZXRUb3VjaEFjdGlvbj1mdW5jdGlvbigpe3JldHVybltkc119LGkucHJvY2Vzcz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLGk9dGhpcy5vcHRpb25zLG89dC5wb2ludGVycy5sZW5ndGg9PT1pLnBvaW50ZXJzLG49dC5kaXN0YW5jZTxpLnRocmVzaG9sZCxyPXQuZGVsdGFUaW1lPGkudGltZTtpZih0aGlzLnJlc2V0KCksMSZ0LmV2ZW50VHlwZSYmMD09PXRoaXMuY291bnQpcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtpZihuJiZyJiZvKXtpZig0IT09dC5ldmVudFR5cGUpcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTt2YXIgcz0hdGhpcy5wVGltZXx8dC50aW1lU3RhbXAtdGhpcy5wVGltZTxpLmludGVydmFsLGE9IXRoaXMucENlbnRlcnx8UHModGhpcy5wQ2VudGVyLHQuY2VudGVyKTxpLnBvc1RocmVzaG9sZDtpZih0aGlzLnBUaW1lPXQudGltZVN0YW1wLHRoaXMucENlbnRlcj10LmNlbnRlcixhJiZzP3RoaXMuY291bnQrPTE6dGhpcy5jb3VudD0xLHRoaXMuX2lucHV0PXQsMD09PXRoaXMuY291bnQlaS50YXBzKXJldHVybiB0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpPyh0aGlzLl90aW1lcj1zZXRUaW1lb3V0KChmdW5jdGlvbigpe2Uuc3RhdGU9OCxlLnRyeUVtaXQoKX0pLGkuaW50ZXJ2YWwpLDIpOjh9cmV0dXJuIGhhfSxpLmZhaWxUaW1lb3V0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gdGhpcy5fdGltZXI9c2V0VGltZW91dCgoZnVuY3Rpb24oKXt0LnN0YXRlPWhhfSksdGhpcy5vcHRpb25zLmludGVydmFsKSxoYX0saS5yZXNldD1mdW5jdGlvbigpe2NsZWFyVGltZW91dCh0aGlzLl90aW1lcil9LGkuZW1pdD1mdW5jdGlvbigpezg9PT10aGlzLnN0YXRlJiYodGhpcy5faW5wdXQudGFwQ291bnQ9dGhpcy5jb3VudCx0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsdGhpcy5faW5wdXQpKX0sZX0odWEpLHBhPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSx0LmNhbGwodGhpcyxHcih7cG9pbnRlcnM6MX0sZSkpfHx0aGlzfUtyKGUsdCk7dmFyIGk9ZS5wcm90b3R5cGU7cmV0dXJuIGkuYXR0clRlc3Q9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5vcHRpb25zLnBvaW50ZXJzO3JldHVybiAwPT09ZXx8dC5wb2ludGVycy5sZW5ndGg9PT1lfSxpLnByb2Nlc3M9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5zdGF0ZSxpPXQuZXZlbnRUeXBlLG89NiZlLG49dGhpcy5hdHRyVGVzdCh0KTtyZXR1cm4gbyYmKDgmaXx8IW4pPzE2fGU6b3x8bj80Jmk/OHxlOjImZT80fGU6MjpoYX0sZX0odWEpO2Z1bmN0aW9uIHZhKHQpe3JldHVybiB0PT09YnM/XCJkb3duXCI6OD09PXQ/XCJ1cFwiOjI9PT10P1wibGVmdFwiOjQ9PT10P1wicmlnaHRcIjpcIlwifXZhciBnYT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciBpO3JldHVybiB2b2lkIDA9PT1lJiYoZT17fSksKGk9dC5jYWxsKHRoaXMsR3Ioe2V2ZW50OlwicGFuXCIsdGhyZXNob2xkOjEwLHBvaW50ZXJzOjEsZGlyZWN0aW9uOjMwfSxlKSl8fHRoaXMpLnBYPW51bGwsaS5wWT1udWxsLGl9S3IoZSx0KTt2YXIgaT1lLnByb3RvdHlwZTtyZXR1cm4gaS5nZXRUb3VjaEFjdGlvbj1mdW5jdGlvbigpe3ZhciB0PXRoaXMub3B0aW9ucy5kaXJlY3Rpb24sZT1bXTtyZXR1cm4gNiZ0JiZlLnB1c2godXMpLHQmd3MmJmUucHVzaChjcyksZX0saS5kaXJlY3Rpb25UZXN0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMub3B0aW9ucyxpPSEwLG89dC5kaXN0YW5jZSxuPXQuZGlyZWN0aW9uLHI9dC5kZWx0YVgscz10LmRlbHRhWTtyZXR1cm4gbiZlLmRpcmVjdGlvbnx8KDYmZS5kaXJlY3Rpb24/KG49MD09PXI/MTpyPDA/Mjo0LGk9ciE9PXRoaXMucFgsbz1NYXRoLmFicyh0LmRlbHRhWCkpOihuPTA9PT1zPzE6czwwPzg6YnMsaT1zIT09dGhpcy5wWSxvPU1hdGguYWJzKHQuZGVsdGFZKSkpLHQuZGlyZWN0aW9uPW4saSYmbz5lLnRocmVzaG9sZCYmbiZlLmRpcmVjdGlvbn0saS5hdHRyVGVzdD1mdW5jdGlvbih0KXtyZXR1cm4gcGEucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcyx0KSYmKDImdGhpcy5zdGF0ZXx8ISgyJnRoaXMuc3RhdGUpJiZ0aGlzLmRpcmVjdGlvblRlc3QodCkpfSxpLmVtaXQ9ZnVuY3Rpb24oZSl7dGhpcy5wWD1lLmRlbHRhWCx0aGlzLnBZPWUuZGVsdGFZO3ZhciBpPXZhKGUuZGlyZWN0aW9uKTtpJiYoZS5hZGRpdGlvbmFsRXZlbnQ9dGhpcy5vcHRpb25zLmV2ZW50K2kpLHQucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLGUpfSxlfShwYSkseWE9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9e30pLHQuY2FsbCh0aGlzLEdyKHtldmVudDpcInN3aXBlXCIsdGhyZXNob2xkOjEwLHZlbG9jaXR5Oi4zLGRpcmVjdGlvbjozMCxwb2ludGVyczoxfSxlKSl8fHRoaXN9S3IoZSx0KTt2YXIgaT1lLnByb3RvdHlwZTtyZXR1cm4gaS5nZXRUb3VjaEFjdGlvbj1mdW5jdGlvbigpe3JldHVybiBnYS5wcm90b3R5cGUuZ2V0VG91Y2hBY3Rpb24uY2FsbCh0aGlzKX0saS5hdHRyVGVzdD1mdW5jdGlvbihlKXt2YXIgaSxvPXRoaXMub3B0aW9ucy5kaXJlY3Rpb247cmV0dXJuIDMwJm8/aT1lLm92ZXJhbGxWZWxvY2l0eTo2Jm8/aT1lLm92ZXJhbGxWZWxvY2l0eVg6byZ3cyYmKGk9ZS5vdmVyYWxsVmVsb2NpdHlZKSx0LnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsZSkmJm8mZS5vZmZzZXREaXJlY3Rpb24mJmUuZGlzdGFuY2U+dGhpcy5vcHRpb25zLnRocmVzaG9sZCYmZS5tYXhQb2ludGVycz09PXRoaXMub3B0aW9ucy5wb2ludGVycyYmaXMoaSk+dGhpcy5vcHRpb25zLnZlbG9jaXR5JiY0JmUuZXZlbnRUeXBlfSxpLmVtaXQ9ZnVuY3Rpb24odCl7dmFyIGU9dmEodC5vZmZzZXREaXJlY3Rpb24pO2UmJnRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCtlLHQpLHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCx0KX0sZX0ocGEpLG1hPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSx0LmNhbGwodGhpcyxHcih7ZXZlbnQ6XCJwaW5jaFwiLHRocmVzaG9sZDowLHBvaW50ZXJzOjJ9LGUpKXx8dGhpc31LcihlLHQpO3ZhciBpPWUucHJvdG90eXBlO3JldHVybiBpLmdldFRvdWNoQWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuW2xzXX0saS5hdHRyVGVzdD1mdW5jdGlvbihlKXtyZXR1cm4gdC5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLGUpJiYoTWF0aC5hYnMoZS5zY2FsZS0xKT50aGlzLm9wdGlvbnMudGhyZXNob2xkfHwyJnRoaXMuc3RhdGUpfSxpLmVtaXQ9ZnVuY3Rpb24oZSl7aWYoMSE9PWUuc2NhbGUpe3ZhciBpPWUuc2NhbGU8MT9cImluXCI6XCJvdXRcIjtlLmFkZGl0aW9uYWxFdmVudD10aGlzLm9wdGlvbnMuZXZlbnQraX10LnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcyxlKX0sZX0ocGEpLGJhPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSx0LmNhbGwodGhpcyxHcih7ZXZlbnQ6XCJyb3RhdGVcIix0aHJlc2hvbGQ6MCxwb2ludGVyczoyfSxlKSl8fHRoaXN9S3IoZSx0KTt2YXIgaT1lLnByb3RvdHlwZTtyZXR1cm4gaS5nZXRUb3VjaEFjdGlvbj1mdW5jdGlvbigpe3JldHVybltsc119LGkuYXR0clRlc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHQucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcyxlKSYmKE1hdGguYWJzKGUucm90YXRpb24pPnRoaXMub3B0aW9ucy50aHJlc2hvbGR8fDImdGhpcy5zdGF0ZSl9LGV9KHBhKSx3YT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciBpO3JldHVybiB2b2lkIDA9PT1lJiYoZT17fSksKGk9dC5jYWxsKHRoaXMsR3Ioe2V2ZW50OlwicHJlc3NcIixwb2ludGVyczoxLHRpbWU6MjUxLHRocmVzaG9sZDo5fSxlKSl8fHRoaXMpLl90aW1lcj1udWxsLGkuX2lucHV0PW51bGwsaX1LcihlLHQpO3ZhciBpPWUucHJvdG90eXBlO3JldHVybiBpLmdldFRvdWNoQWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuW2hzXX0saS5wcm9jZXNzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsaT10aGlzLm9wdGlvbnMsbz10LnBvaW50ZXJzLmxlbmd0aD09PWkucG9pbnRlcnMsbj10LmRpc3RhbmNlPGkudGhyZXNob2xkLHI9dC5kZWx0YVRpbWU+aS50aW1lO2lmKHRoaXMuX2lucHV0PXQsIW58fCFvfHwxMiZ0LmV2ZW50VHlwZSYmIXIpdGhpcy5yZXNldCgpO2Vsc2UgaWYoMSZ0LmV2ZW50VHlwZSl0aGlzLnJlc2V0KCksdGhpcy5fdGltZXI9c2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLnN0YXRlPTgsZS50cnlFbWl0KCl9KSxpLnRpbWUpO2Vsc2UgaWYoNCZ0LmV2ZW50VHlwZSlyZXR1cm4gODtyZXR1cm4gaGF9LGkucmVzZXQ9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpfSxpLmVtaXQ9ZnVuY3Rpb24odCl7OD09PXRoaXMuc3RhdGUmJih0JiY0JnQuZXZlbnRUeXBlP3RoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCtcInVwXCIsdCk6KHRoaXMuX2lucHV0LnRpbWVTdGFtcD1vcygpLHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCx0aGlzLl9pbnB1dCkpKX0sZX0odWEpLGthPXtkb21FdmVudHM6ITEsdG91Y2hBY3Rpb246YXMsZW5hYmxlOiEwLGlucHV0VGFyZ2V0Om51bGwsaW5wdXRDbGFzczpudWxsLGNzc1Byb3BzOnt1c2VyU2VsZWN0Olwibm9uZVwiLHRvdWNoU2VsZWN0Olwibm9uZVwiLHRvdWNoQ2FsbG91dDpcIm5vbmVcIixjb250ZW50Wm9vbWluZzpcIm5vbmVcIix1c2VyRHJhZzpcIm5vbmVcIix0YXBIaWdobGlnaHRDb2xvcjpcInJnYmEoMCwwLDAsMClcIn19LF9hPVtbYmEse2VuYWJsZTohMX1dLFttYSx7ZW5hYmxlOiExfSxbXCJyb3RhdGVcIl1dLFt5YSx7ZGlyZWN0aW9uOjZ9XSxbZ2Ese2RpcmVjdGlvbjo2fSxbXCJzd2lwZVwiXV0sW2ZhXSxbZmEse2V2ZW50OlwiZG91YmxldGFwXCIsdGFwczoyfSxbXCJ0YXBcIl1dLFt3YV1dO2Z1bmN0aW9uIHhhKHQsZSl7dmFyIGksbz10LmVsZW1lbnQ7by5zdHlsZSYmKHhzKHQub3B0aW9ucy5jc3NQcm9wcywoZnVuY3Rpb24obixyKXtpPW5zKG8uc3R5bGUsciksZT8odC5vbGRDc3NQcm9wc1tpXT1vLnN0eWxlW2ldLG8uc3R5bGVbaV09bik6by5zdHlsZVtpXT10Lm9sZENzc1Byb3BzW2ldfHxcIlwifSkpLGV8fCh0Lm9sZENzc1Byb3BzPXt9KSl9dmFyIEVhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3ZhciBpLG89dGhpczt0aGlzLm9wdGlvbnM9WnIoe30sa2EsZXx8e30pLHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldD10aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXR8fHQsdGhpcy5oYW5kbGVycz17fSx0aGlzLnNlc3Npb249e30sdGhpcy5yZWNvZ25pemVycz1bXSx0aGlzLm9sZENzc1Byb3BzPXt9LHRoaXMuZWxlbWVudD10LHRoaXMuaW5wdXQ9bmV3KChpPXRoaXMpLm9wdGlvbnMuaW5wdXRDbGFzc3x8KHZzP1lzOmdzP1FzOnBzP3NhOmlhKSkoaSxGcyksdGhpcy50b3VjaEFjdGlvbj1uZXcgQ3ModGhpcyx0aGlzLm9wdGlvbnMudG91Y2hBY3Rpb24pLHhhKHRoaXMsITApLHhzKHRoaXMub3B0aW9ucy5yZWNvZ25pemVycywoZnVuY3Rpb24odCl7dmFyIGU9by5hZGQobmV3IHRbMF0odFsxXSkpO3RbMl0mJmUucmVjb2duaXplV2l0aCh0WzJdKSx0WzNdJiZlLnJlcXVpcmVGYWlsdXJlKHRbM10pfSksdGhpcyl9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuc2V0PWZ1bmN0aW9uKHQpe3JldHVybiBacih0aGlzLm9wdGlvbnMsdCksdC50b3VjaEFjdGlvbiYmdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKSx0LmlucHV0VGFyZ2V0JiYodGhpcy5pbnB1dC5kZXN0cm95KCksdGhpcy5pbnB1dC50YXJnZXQ9dC5pbnB1dFRhcmdldCx0aGlzLmlucHV0LmluaXQoKSksdGhpc30sZS5zdG9wPWZ1bmN0aW9uKHQpe3RoaXMuc2Vzc2lvbi5zdG9wcGVkPXQ/MjoxfSxlLnJlY29nbml6ZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnNlc3Npb247aWYoIWUuc3RvcHBlZCl7dmFyIGk7dGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHModCk7dmFyIG89dGhpcy5yZWNvZ25pemVycyxuPWUuY3VyUmVjb2duaXplcjsoIW58fG4mJjgmbi5zdGF0ZSkmJihlLmN1clJlY29nbml6ZXI9bnVsbCxuPW51bGwpO2Zvcih2YXIgcj0wO3I8by5sZW5ndGg7KWk9b1tyXSwyPT09ZS5zdG9wcGVkfHxuJiZpIT09biYmIWkuY2FuUmVjb2duaXplV2l0aChuKT9pLnJlc2V0KCk6aS5yZWNvZ25pemUodCksIW4mJjE0Jmkuc3RhdGUmJihlLmN1clJlY29nbml6ZXI9aSxuPWkpLHIrK319LGUuZ2V0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiB1YSlyZXR1cm4gdDtmb3IodmFyIGU9dGhpcy5yZWNvZ25pemVycyxpPTA7aTxlLmxlbmd0aDtpKyspaWYoZVtpXS5vcHRpb25zLmV2ZW50PT09dClyZXR1cm4gZVtpXTtyZXR1cm4gbnVsbH0sZS5hZGQ9ZnVuY3Rpb24odCl7aWYoYWEodCxcImFkZFwiLHRoaXMpKXJldHVybiB0aGlzO3ZhciBlPXRoaXMuZ2V0KHQub3B0aW9ucy5ldmVudCk7cmV0dXJuIGUmJnRoaXMucmVtb3ZlKGUpLHRoaXMucmVjb2duaXplcnMucHVzaCh0KSx0Lm1hbmFnZXI9dGhpcyx0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpLHR9LGUucmVtb3ZlPWZ1bmN0aW9uKHQpe2lmKGFhKHQsXCJyZW1vdmVcIix0aGlzKSlyZXR1cm4gdGhpczt2YXIgZT10aGlzLmdldCh0KTtpZih0KXt2YXIgaT10aGlzLnJlY29nbml6ZXJzLG89SHMoaSxlKTstMSE9PW8mJihpLnNwbGljZShvLDEpLHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCkpfXJldHVybiB0aGlzfSxlLm9uPWZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwPT09dHx8dm9pZCAwPT09ZSlyZXR1cm4gdGhpczt2YXIgaT10aGlzLmhhbmRsZXJzO3JldHVybiB4cyhOcyh0KSwoZnVuY3Rpb24odCl7aVt0XT1pW3RdfHxbXSxpW3RdLnB1c2goZSl9KSksdGhpc30sZS5vZmY9ZnVuY3Rpb24odCxlKXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzO3ZhciBpPXRoaXMuaGFuZGxlcnM7cmV0dXJuIHhzKE5zKHQpLChmdW5jdGlvbih0KXtlP2lbdF0mJmlbdF0uc3BsaWNlKEhzKGlbdF0sZSksMSk6ZGVsZXRlIGlbdF19KSksdGhpc30sZS5lbWl0PWZ1bmN0aW9uKHQsZSl7dGhpcy5vcHRpb25zLmRvbUV2ZW50cyYmZnVuY3Rpb24odCxlKXt2YXIgaT1kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO2kuaW5pdEV2ZW50KHQsITAsITApLGkuZ2VzdHVyZT1lLGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoaSl9KHQsZSk7dmFyIGk9dGhpcy5oYW5kbGVyc1t0XSYmdGhpcy5oYW5kbGVyc1t0XS5zbGljZSgpO2lmKGkmJmkubGVuZ3RoKXtlLnR5cGU9dCxlLnByZXZlbnREZWZhdWx0PWZ1bmN0aW9uKCl7ZS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpfTtmb3IodmFyIG89MDtvPGkubGVuZ3RoOylpW29dKGUpLG8rK319LGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZWxlbWVudCYmeGEodGhpcywhMSksdGhpcy5oYW5kbGVycz17fSx0aGlzLnNlc3Npb249e30sdGhpcy5pbnB1dC5kZXN0cm95KCksdGhpcy5lbGVtZW50PW51bGx9LHR9KCksT2E9e3RvdWNoc3RhcnQ6MSx0b3VjaG1vdmU6Mix0b3VjaGVuZDo0LHRvdWNoY2FuY2VsOjh9LENhPVwidG91Y2hzdGFydFwiLFNhPVwidG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWxcIixUYT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIGksbz1lLnByb3RvdHlwZTtyZXR1cm4gby5ldlRhcmdldD1DYSxvLmV2V2luPVNhLChpPXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzKS5zdGFydGVkPSExLGl9cmV0dXJuIEtyKGUsdCksZS5wcm90b3R5cGUuaGFuZGxlcj1mdW5jdGlvbih0KXt2YXIgZT1PYVt0LnR5cGVdO2lmKDE9PT1lJiYodGhpcy5zdGFydGVkPSEwKSx0aGlzLnN0YXJ0ZWQpe3ZhciBpPU1hLmNhbGwodGhpcyx0LGUpOzEyJmUmJmlbMF0ubGVuZ3RoLWlbMV0ubGVuZ3RoPT0wJiYodGhpcy5zdGFydGVkPSExKSx0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlcixlLHtwb2ludGVyczppWzBdLGNoYW5nZWRQb2ludGVyczppWzFdLHBvaW50ZXJUeXBlOnlzLHNyY0V2ZW50OnR9KX19LGV9KExzKTtmdW5jdGlvbiBNYSh0LGUpe3ZhciBpPVhzKHQudG91Y2hlcyksbz1Ycyh0LmNoYW5nZWRUb3VjaGVzKTtyZXR1cm4gMTImZSYmKGk9R3MoaS5jb25jYXQobyksXCJpZGVudGlmaWVyXCIsITApKSxbaSxvXX1mdW5jdGlvbiBQYSh0LGUsaSl7dmFyIG89XCJERVBSRUNBVEVEIE1FVEhPRDogXCIrZStcIlxcblwiK2krXCIgQVQgXFxuXCI7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9bmV3IEVycm9yKFwiZ2V0LXN0YWNrLXRyYWNlXCIpLGk9ZSYmZS5zdGFjaz9lLnN0YWNrLnJlcGxhY2UoL15bXlxcKF0rP1tcXG4kXS9nbSxcIlwiKS5yZXBsYWNlKC9eXFxzK2F0XFxzKy9nbSxcIlwiKS5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKC9nbSxcInthbm9ueW1vdXN9KClAXCIpOlwiVW5rbm93biBTdGFjayBUcmFjZVwiLG49d2luZG93LmNvbnNvbGUmJih3aW5kb3cuY29uc29sZS53YXJufHx3aW5kb3cuY29uc29sZS5sb2cpO3JldHVybiBuJiZuLmNhbGwod2luZG93LmNvbnNvbGUsbyxpKSx0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dmFyIERhPVBhKChmdW5jdGlvbih0LGUsaSl7Zm9yKHZhciBvPU9iamVjdC5rZXlzKGUpLG49MDtuPG8ubGVuZ3RoOykoIWl8fGkmJnZvaWQgMD09PXRbb1tuXV0pJiYodFtvW25dXT1lW29bbl1dKSxuKys7cmV0dXJuIHR9KSxcImV4dGVuZFwiLFwiVXNlIGBhc3NpZ25gLlwiKSxCYT1QYSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gRGEodCxlLCEwKX0pLFwibWVyZ2VcIixcIlVzZSBgYXNzaWduYC5cIik7ZnVuY3Rpb24gSWEodCxlLGkpe3ZhciBvLG49ZS5wcm90b3R5cGU7KG89dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShuKSkuY29uc3RydWN0b3I9dCxvLl9zdXBlcj1uLGkmJlpyKG8saSl9ZnVuY3Rpb24gemEodCxlKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShlLGFyZ3VtZW50cyl9fXZhciBGYT1mdW5jdGlvbigpe3ZhciB0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSxuZXcgRWEodCxHcih7cmVjb2duaXplcnM6X2EuY29uY2F0KCl9LGUpKX07cmV0dXJuIHQuVkVSU0lPTj1cIjIuMC4xNy1yY1wiLHQuRElSRUNUSU9OX0FMTD0zMCx0LkRJUkVDVElPTl9ET1dOPWJzLHQuRElSRUNUSU9OX0xFRlQ9Mix0LkRJUkVDVElPTl9SSUdIVD00LHQuRElSRUNUSU9OX1VQPTgsdC5ESVJFQ1RJT05fSE9SSVpPTlRBTD02LHQuRElSRUNUSU9OX1ZFUlRJQ0FMPXdzLHQuRElSRUNUSU9OX05PTkU9MSx0LkRJUkVDVElPTl9ET1dOPWJzLHQuSU5QVVRfU1RBUlQ9MSx0LklOUFVUX01PVkU9Mix0LklOUFVUX0VORD00LHQuSU5QVVRfQ0FOQ0VMPTgsdC5TVEFURV9QT1NTSUJMRT0xLHQuU1RBVEVfQkVHQU49Mix0LlNUQVRFX0NIQU5HRUQ9NCx0LlNUQVRFX0VOREVEPTgsdC5TVEFURV9SRUNPR05JWkVEPTgsdC5TVEFURV9DQU5DRUxMRUQ9MTYsdC5TVEFURV9GQUlMRUQ9aGEsdC5NYW5hZ2VyPUVhLHQuSW5wdXQ9THMsdC5Ub3VjaEFjdGlvbj1Dcyx0LlRvdWNoSW5wdXQ9UXMsdC5Nb3VzZUlucHV0PWlhLHQuUG9pbnRlckV2ZW50SW5wdXQ9WXMsdC5Ub3VjaE1vdXNlSW5wdXQ9c2EsdC5TaW5nbGVUb3VjaElucHV0PVRhLHQuUmVjb2duaXplcj11YSx0LkF0dHJSZWNvZ25pemVyPXBhLHQuVGFwPWZhLHQuUGFuPWdhLHQuU3dpcGU9eWEsdC5QaW5jaD1tYSx0LlJvdGF0ZT1iYSx0LlByZXNzPXdhLHQub249QXMsdC5vZmY9UnMsdC5lYWNoPXhzLHQubWVyZ2U9QmEsdC5leHRlbmQ9RGEsdC5iaW5kRm49emEsdC5hc3NpZ249WnIsdC5pbmhlcml0PUlhLHQuYmluZEZuPXphLHQucHJlZml4ZWQ9bnMsdC50b0FycmF5PVhzLHQuaW5BcnJheT1Icyx0LnVuaXF1ZUFycmF5PUdzLHQuc3BsaXRTdHI9TnMsdC5ib29sT3JGbj1Fcyx0Lmhhc1BhcmVudD1Tcyx0LmFkZEV2ZW50TGlzdGVuZXJzPUFzLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcnM9UnMsdC5kZWZhdWx0cz1acih7fSxrYSx7cHJlc2V0Ol9hfSksdH0oKTtmdW5jdGlvbiBOYSh0LGUpe3ZhciBpO2lmKHZvaWQgMD09PWNufHxudWxsPT1DaSh0KSl7aWYoZ24odCl8fChpPWZ1bmN0aW9uKHQsZSl7dmFyIGk7aWYoIXQpcmV0dXJuO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXJldHVybiBBYSh0LGUpO3ZhciBvPXZuKGk9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKS5jYWxsKGksOCwtMSk7XCJPYmplY3RcIj09PW8mJnQuY29uc3RydWN0b3ImJihvPXQuY29uc3RydWN0b3IubmFtZSk7aWYoXCJNYXBcIj09PW98fFwiU2V0XCI9PT1vKXJldHVybiBtaSh0KTtpZihcIkFyZ3VtZW50c1wiPT09b3x8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobykpcmV0dXJuIEFhKHQsZSl9KHQpKXx8ZSYmdCYmXCJudW1iZXJcIj09dHlwZW9mIHQubGVuZ3RoKXtpJiYodD1pKTt2YXIgbz0wLG49ZnVuY3Rpb24oKXt9O3JldHVybntzOm4sbjpmdW5jdGlvbigpe3JldHVybiBvPj10Lmxlbmd0aD97ZG9uZTohMH06e2RvbmU6ITEsdmFsdWU6dFtvKytdfX0sZTpmdW5jdGlvbih0KXt0aHJvdyB0fSxmOm59fXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX12YXIgcixzPSEwLGE9ITE7cmV0dXJue3M6ZnVuY3Rpb24oKXtpPVNpKHQpfSxuOmZ1bmN0aW9uKCl7dmFyIHQ9aS5uZXh0KCk7cmV0dXJuIHM9dC5kb25lLHR9LGU6ZnVuY3Rpb24odCl7YT0hMCxyPXR9LGY6ZnVuY3Rpb24oKXt0cnl7c3x8bnVsbD09aS5yZXR1cm58fGkucmV0dXJuKCl9ZmluYWxseXtpZihhKXRocm93IHJ9fX19ZnVuY3Rpb24gQWEodCxlKXsobnVsbD09ZXx8ZT50Lmxlbmd0aCkmJihlPXQubGVuZ3RoKTtmb3IodmFyIGk9MCxvPW5ldyBBcnJheShlKTtpPGU7aSsrKW9baV09dFtpXTtyZXR1cm4gb31mdW5jdGlvbiBSYSgpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLGU9bmV3IEFycmF5KHQpLGk9MDtpPHQ7aSsrKWVbaV09YXJndW1lbnRzW2ldO3JldHVybiBqYShlLmxlbmd0aD9lOltFbigpXSl9ZnVuY3Rpb24gamEodCl7dmFyIGU9YW4oZnVuY3Rpb24oKXtmb3IodmFyIHQ9TGEoKSxlPXQoXCIgXCIpLGk9dChcIiBcIiksbz10KFwiIFwiKSxuPTA7bjxhcmd1bWVudHMubGVuZ3RoO24rKykoZS09dChuPDB8fGFyZ3VtZW50cy5sZW5ndGg8PW4/dm9pZCAwOmFyZ3VtZW50c1tuXSkpPDAmJihlKz0xKSwoaS09dChuPDB8fGFyZ3VtZW50cy5sZW5ndGg8PW4/dm9pZCAwOmFyZ3VtZW50c1tuXSkpPDAmJihpKz0xKSwoby09dChuPDB8fGFyZ3VtZW50cy5sZW5ndGg8PW4/dm9pZCAwOmFyZ3VtZW50c1tuXSkpPDAmJihvKz0xKTtyZXR1cm5bZSxpLG9dfSh0KSwzKSxpPWVbMF0sbz1lWzFdLG49ZVsyXSxyPTEscz1mdW5jdGlvbigpe3ZhciB0PTIwOTE2MzkqaSsyLjMyODMwNjQzNjUzODY5NjNlLTEwKnI7cmV0dXJuIGk9byxvPW4sbj10LShyPTB8dCl9O3JldHVybiBzLnVpbnQzMj1mdW5jdGlvbigpe3JldHVybiA0Mjk0OTY3Mjk2KnMoKX0scy5mcmFjdDUzPWZ1bmN0aW9uKCl7cmV0dXJuIHMoKSsxMTEwMjIzMDI0NjI1MTU2NWUtMzIqKDIwOTcxNTIqcygpfDApfSxzLmFsZ29yaXRobT1cIkFsZWFcIixzLnNlZWQ9dCxzLnZlcnNpb249XCIwLjlcIixzfWZ1bmN0aW9uIExhKCl7dmFyIHQ9NDAyMjg3MTE5NztyZXR1cm4gZnVuY3Rpb24oZSl7Zm9yKHZhciBpPWUudG9TdHJpbmcoKSxvPTA7bzxpLmxlbmd0aDtvKyspe3ZhciBuPS4wMjUxOTYwMzI4MjQxNjkzOCoodCs9aS5jaGFyQ29kZUF0KG8pKTtuLT10PW4+Pj4wLHQ9KG4qPXQpPj4+MCx0Kz00Mjk0OTY3Mjk2KihuLT10KX1yZXR1cm4gMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMCoodD4+PjApfX1jbihcIkRFTEVURVwiKTt2YXIgSGE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3cuSGFtbWVyfHxGYTpmdW5jdGlvbigpe3JldHVybntvbjp0PWZ1bmN0aW9uKCl7fSxvZmY6dCxkZXN0cm95OnQsZW1pdDp0LGdldDpmdW5jdGlvbigpe3JldHVybntzZXQ6dH19fTt2YXIgdH07ZnVuY3Rpb24gV2EodCl7dmFyIGUsaT10aGlzO3RoaXMuX2NsZWFudXBRdWV1ZT1bXSx0aGlzLmFjdGl2ZT0hMSx0aGlzLl9kb209e2NvbnRhaW5lcjp0LG92ZXJsYXk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKX0sdGhpcy5fZG9tLm92ZXJsYXkuY2xhc3NMaXN0LmFkZChcInZpcy1vdmVybGF5XCIpLHRoaXMuX2RvbS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZG9tLm92ZXJsYXkpLHRoaXMuX2NsZWFudXBRdWV1ZS5wdXNoKChmdW5jdGlvbigpe2kuX2RvbS5vdmVybGF5LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaS5fZG9tLm92ZXJsYXkpfSkpO3ZhciBvPUhhKHRoaXMuX2RvbS5vdmVybGF5KTtvLm9uKFwidGFwXCIsYnQoZT10aGlzLl9vblRhcE92ZXJsYXkpLmNhbGwoZSx0aGlzKSksdGhpcy5fY2xlYW51cFF1ZXVlLnB1c2goKGZ1bmN0aW9uKCl7by5kZXN0cm95KCl9KSk7dmFyIG49W1widGFwXCIsXCJkb3VibGV0YXBcIixcInByZXNzXCIsXCJwaW5jaFwiLFwicGFuXCIsXCJwYW5zdGFydFwiLFwicGFubW92ZVwiLFwicGFuZW5kXCJdO0RuKG4pLmNhbGwobiwoZnVuY3Rpb24odCl7by5vbih0LChmdW5jdGlvbih0KXt0LnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpfSkpfSkpLGRvY3VtZW50JiZkb2N1bWVudC5ib2R5JiYodGhpcy5fb25DbGljaz1mdW5jdGlvbihlKXsoZnVuY3Rpb24odCxlKXtmb3IoO3Q7KXtpZih0PT09ZSlyZXR1cm4hMDt0PXQucGFyZW50Tm9kZX1yZXR1cm4hMX0pKGUudGFyZ2V0LHQpfHxpLmRlYWN0aXZhdGUoKX0sZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9vbkNsaWNrKSx0aGlzLl9jbGVhbnVwUXVldWUucHVzaCgoZnVuY3Rpb24oKXtkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGkuX29uQ2xpY2spfSkpKSx0aGlzLl9lc2NMaXN0ZW5lcj1mdW5jdGlvbih0KXsoXCJrZXlcImluIHQ/XCJFc2NhcGVcIj09PXQua2V5OjI3PT09dC5rZXlDb2RlKSYmaS5kZWFjdGl2YXRlKCl9fUN0KFdhLnByb3RvdHlwZSksV2EuY3VycmVudD1udWxsLFdhLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dmFyIHQsZTt0aGlzLmRlYWN0aXZhdGUoKTt2YXIgaSxvPU5hKE5uKHQ9cW4oZT10aGlzLl9jbGVhbnVwUXVldWUpLmNhbGwoZSwwKSkuY2FsbCh0KSk7dHJ5e2ZvcihvLnMoKTshKGk9by5uKCkpLmRvbmU7KXsoMCxpLnZhbHVlKSgpfX1jYXRjaCh0KXtvLmUodCl9ZmluYWxseXtvLmYoKX19LFdhLnByb3RvdHlwZS5hY3RpdmF0ZT1mdW5jdGlvbigpe1dhLmN1cnJlbnQmJldhLmN1cnJlbnQuZGVhY3RpdmF0ZSgpLFdhLmN1cnJlbnQ9dGhpcyx0aGlzLmFjdGl2ZT0hMCx0aGlzLl9kb20ub3ZlcmxheS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLHRoaXMuX2RvbS5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInZpcy1hY3RpdmVcIiksdGhpcy5lbWl0KFwiY2hhbmdlXCIpLHRoaXMuZW1pdChcImFjdGl2YXRlXCIpLGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLl9lc2NMaXN0ZW5lcil9LFdhLnByb3RvdHlwZS5kZWFjdGl2YXRlPWZ1bmN0aW9uKCl7dGhpcy5hY3RpdmU9ITEsdGhpcy5fZG9tLm92ZXJsYXkuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsdGhpcy5fZG9tLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwidmlzLWFjdGl2ZVwiKSxkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5fZXNjTGlzdGVuZXIpLHRoaXMuZW1pdChcImNoYW5nZVwiKSx0aGlzLmVtaXQoXCJkZWFjdGl2YXRlXCIpfSxXYS5wcm90b3R5cGUuX29uVGFwT3ZlcmxheT1mdW5jdGlvbih0KXt0aGlzLmFjdGl2YXRlKCksdC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKX07dmFyIFZhPS9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kscWE9L14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaSxVYT0vXnJnYlxcKCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICosICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqXFwpJC9pLFlhPS9ecmdiYVxcKCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICosICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqLCAqKFswMV18MD9cXC5cXGQrKSAqXFwpJC9pO2Z1bmN0aW9uIFhhKHQpe2lmKHQpZm9yKDshMD09PXQuaGFzQ2hpbGROb2RlcygpOyl7dmFyIGU9dC5maXJzdENoaWxkO2UmJihYYShlKSx0LnJlbW92ZUNoaWxkKGUpKX19ZnVuY3Rpb24gR2EodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBTdHJpbmd8fFwic3RyaW5nXCI9PXR5cGVvZiB0fWZ1bmN0aW9uIEthKHQpe3JldHVyblwib2JqZWN0XCI9PT1kbih0KSYmbnVsbCE9PXR9ZnVuY3Rpb24gJGEodCxlLGksbyl7dmFyIG49ITE7ITA9PT1vJiYobj1udWxsPT09ZVtpXSYmdm9pZCAwIT09dFtpXSksbj9kZWxldGUgdFtpXTp0W2ldPWVbaV19ZnVuY3Rpb24gUWEodCxlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdO2Zvcih2YXIgbyBpbiB0KWlmKHZvaWQgMCE9PWVbb10paWYobnVsbD09PWVbb118fFwib2JqZWN0XCIhPT1kbihlW29dKSkkYSh0LGUsbyxpKTtlbHNle3ZhciBuPXRbb10scj1lW29dO0thKG4pJiZLYShyKSYmUWEobixyLGkpfX1mdW5jdGlvbiBaYSh0LGUsaSl7dmFyIG89YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10mJmFyZ3VtZW50c1szXTtpZihnbihpKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmRcIik7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGkscikpaWYoaVtyXSYmaVtyXS5jb25zdHJ1Y3Rvcj09PU9iamVjdCl2b2lkIDA9PT1lW3JdJiYoZVtyXT17fSksZVtyXS5jb25zdHJ1Y3Rvcj09PU9iamVjdD90aChlW3JdLGlbcl0sITEsbyk6JGEoZSxpLHIsbyk7ZWxzZXtpZihnbihpW3JdKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmRcIik7JGEoZSxpLHIsbyl9fXJldHVybiBlfWZ1bmN0aW9uIEphKHQsZSxpKXt2YXIgbz1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXSYmYXJndW1lbnRzWzNdO2lmKGduKGkpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZFwiKTtmb3IodmFyIG4gaW4gaSlpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSxuKSYmIUpuKHQpLmNhbGwodCxuKSlpZihpW25dJiZpW25dLmNvbnN0cnVjdG9yPT09T2JqZWN0KXZvaWQgMD09PWVbbl0mJihlW25dPXt9KSxlW25dLmNvbnN0cnVjdG9yPT09T2JqZWN0P3RoKGVbbl0saVtuXSk6JGEoZSxpLG4sbyk7ZWxzZSBpZihnbihpW25dKSl7ZVtuXT1bXTtmb3IodmFyIHI9MDtyPGlbbl0ubGVuZ3RoO3IrKyllW25dLnB1c2goaVtuXVtyXSl9ZWxzZSAkYShlLGksbixvKTtyZXR1cm4gZX1mdW5jdGlvbiB0aCh0LGUpe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl0sbz1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXSYmYXJndW1lbnRzWzNdO2Zvcih2YXIgbiBpbiBlKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pfHwhMD09PWkpaWYoXCJvYmplY3RcIj09PWRuKGVbbl0pJiZudWxsIT09ZVtuXSYmaXIoZVtuXSk9PT1PYmplY3QucHJvdG90eXBlKXZvaWQgMD09PXRbbl0/dFtuXT10aCh7fSxlW25dLGkpOlwib2JqZWN0XCI9PT1kbih0W25dKSYmbnVsbCE9PXRbbl0mJmlyKHRbbl0pPT09T2JqZWN0LnByb3RvdHlwZT90aCh0W25dLGVbbl0saSk6JGEodCxlLG4sbyk7ZWxzZSBpZihnbihlW25dKSl7dmFyIHI7dFtuXT12bihyPWVbbl0pLmNhbGwocil9ZWxzZSAkYSh0LGUsbixvKTtyZXR1cm4gdH1mdW5jdGlvbiBlaCh0LGUpe3ZhciBpO3JldHVybiBwbihpPVtdKS5jYWxsKGksbG4odCksW2VdKX1mdW5jdGlvbiBpaCh0KXtyZXR1cm4gdm4odCkuY2FsbCh0KX1mdW5jdGlvbiBvaCh0KXtyZXR1cm4gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3B9ZnVuY3Rpb24gbmgodCxlKXtpZihnbih0KSlmb3IodmFyIGk9dC5sZW5ndGgsbz0wO288aTtvKyspZSh0W29dLG8sdCk7ZWxzZSBmb3IodmFyIG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmZSh0W25dLG4sdCl9ZnVuY3Rpb24gcmgodCl7dmFyIGU7c3dpdGNoKHQubGVuZ3RoKXtjYXNlIDM6Y2FzZSA0OnJldHVybihlPXFhLmV4ZWModCkpP3tyOmtyKGVbMV0rZVsxXSwxNiksZzprcihlWzJdK2VbMl0sMTYpLGI6a3IoZVszXStlWzNdLDE2KX06bnVsbDtjYXNlIDY6Y2FzZSA3OnJldHVybihlPVZhLmV4ZWModCkpP3tyOmtyKGVbMV0sMTYpLGc6a3IoZVsyXSwxNiksYjprcihlWzNdLDE2KX06bnVsbDtkZWZhdWx0OnJldHVybiBudWxsfX1mdW5jdGlvbiBzaCh0LGUpe2lmKEpuKHQpLmNhbGwodCxcInJnYmFcIikpcmV0dXJuIHQ7aWYoSm4odCkuY2FsbCh0LFwicmdiXCIpKXt2YXIgaT10LnN1YnN0cihNcih0KS5jYWxsKHQsXCIoXCIpKzEpLnJlcGxhY2UoXCIpXCIsXCJcIikuc3BsaXQoXCIsXCIpO3JldHVyblwicmdiYShcIitpWzBdK1wiLFwiK2lbMV0rXCIsXCIraVsyXStcIixcIitlK1wiKVwifXZhciBvPXJoKHQpO3JldHVybiBudWxsPT1vP3Q6XCJyZ2JhKFwiK28ucitcIixcIitvLmcrXCIsXCIrby5iK1wiLFwiK2UrXCIpXCJ9ZnVuY3Rpb24gYWgodCxlLGkpe3ZhciBvO3JldHVyblwiI1wiK3ZuKG89KCgxPDwyNCkrKHQ8PDE2KSsoZTw8OCkraSkudG9TdHJpbmcoMTYpKS5jYWxsKG8sMSl9ZnVuY3Rpb24gaGgodCxlKXtpZihHYSh0KSl7dmFyIGk9dDtpZihmaChpKSl7dmFyIG8sbj1rbihvPWkuc3Vic3RyKDQpLnN1YnN0cigwLGkubGVuZ3RoLTUpLnNwbGl0KFwiLFwiKSkuY2FsbChvLChmdW5jdGlvbih0KXtyZXR1cm4ga3IodCl9KSk7aT1haChuWzBdLG5bMV0sblsyXSl9aWYoITA9PT11aChpKSl7dmFyIHI9ZnVuY3Rpb24odCl7dmFyIGU9cmgodCk7aWYoIWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidcIi5jb25jYXQodCxcIicgaXMgbm90IGEgdmFsaWQgY29sb3IuXCIpKTtyZXR1cm4gZGgoZS5yLGUuZyxlLmIpfShpKSxzPXtoOnIuaCxzOi44KnIucyx2Ok1hdGgubWluKDEsMS4wMipyLnYpfSxhPXtoOnIuaCxzOk1hdGgubWluKDEsMS4yNSpyLnMpLHY6Ljgqci52fSxoPWNoKGEuaCxhLnMsYS52KSxkPWNoKHMuaCxzLnMscy52KTtyZXR1cm57YmFja2dyb3VuZDppLGJvcmRlcjpoLGhpZ2hsaWdodDp7YmFja2dyb3VuZDpkLGJvcmRlcjpofSxob3Zlcjp7YmFja2dyb3VuZDpkLGJvcmRlcjpofX19cmV0dXJue2JhY2tncm91bmQ6aSxib3JkZXI6aSxoaWdobGlnaHQ6e2JhY2tncm91bmQ6aSxib3JkZXI6aX0saG92ZXI6e2JhY2tncm91bmQ6aSxib3JkZXI6aX19fXJldHVybiBlP3tiYWNrZ3JvdW5kOnQuYmFja2dyb3VuZHx8ZS5iYWNrZ3JvdW5kLGJvcmRlcjp0LmJvcmRlcnx8ZS5ib3JkZXIsaGlnaGxpZ2h0OkdhKHQuaGlnaGxpZ2h0KT97Ym9yZGVyOnQuaGlnaGxpZ2h0LGJhY2tncm91bmQ6dC5oaWdobGlnaHR9OntiYWNrZ3JvdW5kOnQuaGlnaGxpZ2h0JiZ0LmhpZ2hsaWdodC5iYWNrZ3JvdW5kfHxlLmhpZ2hsaWdodC5iYWNrZ3JvdW5kLGJvcmRlcjp0LmhpZ2hsaWdodCYmdC5oaWdobGlnaHQuYm9yZGVyfHxlLmhpZ2hsaWdodC5ib3JkZXJ9LGhvdmVyOkdhKHQuaG92ZXIpP3tib3JkZXI6dC5ob3ZlcixiYWNrZ3JvdW5kOnQuaG92ZXJ9Ontib3JkZXI6dC5ob3ZlciYmdC5ob3Zlci5ib3JkZXJ8fGUuaG92ZXIuYm9yZGVyLGJhY2tncm91bmQ6dC5ob3ZlciYmdC5ob3Zlci5iYWNrZ3JvdW5kfHxlLmhvdmVyLmJhY2tncm91bmR9fTp7YmFja2dyb3VuZDp0LmJhY2tncm91bmR8fHZvaWQgMCxib3JkZXI6dC5ib3JkZXJ8fHZvaWQgMCxoaWdobGlnaHQ6R2EodC5oaWdobGlnaHQpP3tib3JkZXI6dC5oaWdobGlnaHQsYmFja2dyb3VuZDp0LmhpZ2hsaWdodH06e2JhY2tncm91bmQ6dC5oaWdobGlnaHQmJnQuaGlnaGxpZ2h0LmJhY2tncm91bmR8fHZvaWQgMCxib3JkZXI6dC5oaWdobGlnaHQmJnQuaGlnaGxpZ2h0LmJvcmRlcnx8dm9pZCAwfSxob3ZlcjpHYSh0LmhvdmVyKT97Ym9yZGVyOnQuaG92ZXIsYmFja2dyb3VuZDp0LmhvdmVyfTp7Ym9yZGVyOnQuaG92ZXImJnQuaG92ZXIuYm9yZGVyfHx2b2lkIDAsYmFja2dyb3VuZDp0LmhvdmVyJiZ0LmhvdmVyLmJhY2tncm91bmR8fHZvaWQgMH19fWZ1bmN0aW9uIGRoKHQsZSxpKXt0Lz0yNTUsZS89MjU1LGkvPTI1NTt2YXIgbz1NYXRoLm1pbih0LE1hdGgubWluKGUsaSkpLG49TWF0aC5tYXgodCxNYXRoLm1heChlLGkpKTtyZXR1cm4gbz09PW4/e2g6MCxzOjAsdjpvfTp7aDo2MCooKHQ9PT1vPzM6aT09PW8/MTo1KS0odD09PW8/ZS1pOmk9PT1vP3QtZTppLXQpLyhuLW8pKS8zNjAsczoobi1vKS9uLHY6bn19ZnVuY3Rpb24gbGgodCxlLGkpe3ZhciBvLG4scixzPU1hdGguZmxvb3IoNip0KSxhPTYqdC1zLGg9aSooMS1lKSxkPWkqKDEtYSplKSxsPWkqKDEtKDEtYSkqZSk7c3dpdGNoKHMlNil7Y2FzZSAwOm89aSxuPWwscj1oO2JyZWFrO2Nhc2UgMTpvPWQsbj1pLHI9aDticmVhaztjYXNlIDI6bz1oLG49aSxyPWw7YnJlYWs7Y2FzZSAzOm89aCxuPWQscj1pO2JyZWFrO2Nhc2UgNDpvPWwsbj1oLHI9aTticmVhaztjYXNlIDU6bz1pLG49aCxyPWR9cmV0dXJue3I6TWF0aC5mbG9vcigyNTUqbyksZzpNYXRoLmZsb29yKDI1NSpuKSxiOk1hdGguZmxvb3IoMjU1KnIpfX1mdW5jdGlvbiBjaCh0LGUsaSl7dmFyIG89bGgodCxlLGkpO3JldHVybiBhaChvLnIsby5nLG8uYil9ZnVuY3Rpb24gdWgodCl7cmV0dXJuLyheI1swLTlBLUZdezZ9JCl8KF4jWzAtOUEtRl17M30kKS9pLnRlc3QodCl9ZnVuY3Rpb24gZmgodCl7cmV0dXJuIFVhLnRlc3QodCl9ZnVuY3Rpb24gcGgodCl7cmV0dXJuIFlhLnRlc3QodCl9ZnVuY3Rpb24gdmgodCl7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPT1kbih0KSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgRWxlbWVudClyZXR1cm4gdDt2YXIgZT1Jcih0KTtmb3IodmFyIGkgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxpKSYmXCJvYmplY3RcIj09ZG4odFtpXSkmJihlW2ldPXZoKHRbaV0pKTtyZXR1cm4gZX1mdW5jdGlvbiBnaCh0LGUsaSl7dmFyIG89YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOnt9LG49ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXR9LHI9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10JiZcIm9iamVjdFwiPT09ZG4odCl9LHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSkpcmV0dXJuITE7cmV0dXJuITB9O2lmKCFyKHQpKXRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBtZXJnZVRhcmdldCBtdXN0IGJlIGFuIG9iamVjdFwiKTtpZighcihlKSl0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdFwiKTtpZighbihpKSl0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgb3B0aW9uIG11c3QgaGF2ZSBhIHZhbHVlXCIpO2lmKCFyKG8pKXRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBnbG9iYWxPcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0XCIpO3ZhciBhPWZ1bmN0aW9uKHQsZSxpKXtyKHRbaV0pfHwodFtpXT17fSk7dmFyIG89ZVtpXSxuPXRbaV07Zm9yKHZhciBzIGluIG8pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8scykmJihuW3NdPW9bc10pfSxoPWVbaV0sZD1yKG8pJiYhcyhvKSxsPWQ/b1tpXTp2b2lkIDAsYz1sP2wuZW5hYmxlZDp2b2lkIDA7aWYodm9pZCAwIT09aCl7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBoKXJldHVybiByKHRbaV0pfHwodFtpXT17fSksdm9pZCh0W2ldLmVuYWJsZWQ9aCk7aWYobnVsbD09PWgmJiFyKHRbaV0pKXtpZighbihsKSlyZXR1cm47dFtpXT1JcihsKX1pZihyKGgpKXt2YXIgdT0hMDt2b2lkIDAhPT1oLmVuYWJsZWQ/dT1oLmVuYWJsZWQ6dm9pZCAwIT09YyYmKHU9bC5lbmFibGVkKSxhKHQsZSxpKSx0W2ldLmVuYWJsZWQ9dX19fXZhciB5aD17bGluZWFyOmZ1bmN0aW9uKHQpe3JldHVybiB0fSxlYXNlSW5RdWFkOmZ1bmN0aW9uKHQpe3JldHVybiB0KnR9LGVhc2VPdXRRdWFkOmZ1bmN0aW9uKHQpe3JldHVybiB0KigyLXQpfSxlYXNlSW5PdXRRdWFkOmZ1bmN0aW9uKHQpe3JldHVybiB0PC41PzIqdCp0Oig0LTIqdCkqdC0xfSxlYXNlSW5DdWJpYzpmdW5jdGlvbih0KXtyZXR1cm4gdCp0KnR9LGVhc2VPdXRDdWJpYzpmdW5jdGlvbih0KXtyZXR1cm4tLXQqdCp0KzF9LGVhc2VJbk91dEN1YmljOmZ1bmN0aW9uKHQpe3JldHVybiB0PC41PzQqdCp0KnQ6KHQtMSkqKDIqdC0yKSooMip0LTIpKzF9LGVhc2VJblF1YXJ0OmZ1bmN0aW9uKHQpe3JldHVybiB0KnQqdCp0fSxlYXNlT3V0UXVhcnQ6ZnVuY3Rpb24odCl7cmV0dXJuIDEtIC0tdCp0KnQqdH0sZWFzZUluT3V0UXVhcnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQ8LjU/OCp0KnQqdCp0OjEtOCotLXQqdCp0KnR9LGVhc2VJblF1aW50OmZ1bmN0aW9uKHQpe3JldHVybiB0KnQqdCp0KnR9LGVhc2VPdXRRdWludDpmdW5jdGlvbih0KXtyZXR1cm4gMSstLXQqdCp0KnQqdH0sZWFzZUluT3V0UXVpbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQ8LjU/MTYqdCp0KnQqdCp0OjErMTYqLS10KnQqdCp0KnR9fTtmdW5jdGlvbiBtaCh0LGUpe3ZhciBpO2duKGUpfHwoZT1bZV0pO3ZhciBvLG49TmEodCk7dHJ5e2ZvcihuLnMoKTshKG89bi5uKCkpLmRvbmU7KXt2YXIgcj1vLnZhbHVlO2lmKHIpe2k9cltlWzBdXTtmb3IodmFyIHM9MTtzPGUubGVuZ3RoO3MrKylpJiYoaT1pW2Vbc11dKTtpZih2b2lkIDAhPT1pKWJyZWFrfX19Y2F0Y2godCl7bi5lKHQpfWZpbmFsbHl7bi5mKCl9cmV0dXJuIGl9dmFyIGJoPXtibGFjazpcIiMwMDAwMDBcIixuYXZ5OlwiIzAwMDA4MFwiLGRhcmtibHVlOlwiIzAwMDA4QlwiLG1lZGl1bWJsdWU6XCIjMDAwMENEXCIsYmx1ZTpcIiMwMDAwRkZcIixkYXJrZ3JlZW46XCIjMDA2NDAwXCIsZ3JlZW46XCIjMDA4MDAwXCIsdGVhbDpcIiMwMDgwODBcIixkYXJrY3lhbjpcIiMwMDhCOEJcIixkZWVwc2t5Ymx1ZTpcIiMwMEJGRkZcIixkYXJrdHVycXVvaXNlOlwiIzAwQ0VEMVwiLG1lZGl1bXNwcmluZ2dyZWVuOlwiIzAwRkE5QVwiLGxpbWU6XCIjMDBGRjAwXCIsc3ByaW5nZ3JlZW46XCIjMDBGRjdGXCIsYXF1YTpcIiMwMEZGRkZcIixjeWFuOlwiIzAwRkZGRlwiLG1pZG5pZ2h0Ymx1ZTpcIiMxOTE5NzBcIixkb2RnZXJibHVlOlwiIzFFOTBGRlwiLGxpZ2h0c2VhZ3JlZW46XCIjMjBCMkFBXCIsZm9yZXN0Z3JlZW46XCIjMjI4QjIyXCIsc2VhZ3JlZW46XCIjMkU4QjU3XCIsZGFya3NsYXRlZ3JheTpcIiMyRjRGNEZcIixsaW1lZ3JlZW46XCIjMzJDRDMyXCIsbWVkaXVtc2VhZ3JlZW46XCIjM0NCMzcxXCIsdHVycXVvaXNlOlwiIzQwRTBEMFwiLHJveWFsYmx1ZTpcIiM0MTY5RTFcIixzdGVlbGJsdWU6XCIjNDY4MkI0XCIsZGFya3NsYXRlYmx1ZTpcIiM0ODNEOEJcIixtZWRpdW10dXJxdW9pc2U6XCIjNDhEMUNDXCIsaW5kaWdvOlwiIzRCMDA4MlwiLGRhcmtvbGl2ZWdyZWVuOlwiIzU1NkIyRlwiLGNhZGV0Ymx1ZTpcIiM1RjlFQTBcIixjb3JuZmxvd2VyYmx1ZTpcIiM2NDk1RURcIixtZWRpdW1hcXVhbWFyaW5lOlwiIzY2Q0RBQVwiLGRpbWdyYXk6XCIjNjk2OTY5XCIsc2xhdGVibHVlOlwiIzZBNUFDRFwiLG9saXZlZHJhYjpcIiM2QjhFMjNcIixzbGF0ZWdyYXk6XCIjNzA4MDkwXCIsbGlnaHRzbGF0ZWdyYXk6XCIjNzc4ODk5XCIsbWVkaXVtc2xhdGVibHVlOlwiIzdCNjhFRVwiLGxhd25ncmVlbjpcIiM3Q0ZDMDBcIixjaGFydHJldXNlOlwiIzdGRkYwMFwiLGFxdWFtYXJpbmU6XCIjN0ZGRkQ0XCIsbWFyb29uOlwiIzgwMDAwMFwiLHB1cnBsZTpcIiM4MDAwODBcIixvbGl2ZTpcIiM4MDgwMDBcIixncmF5OlwiIzgwODA4MFwiLHNreWJsdWU6XCIjODdDRUVCXCIsbGlnaHRza3libHVlOlwiIzg3Q0VGQVwiLGJsdWV2aW9sZXQ6XCIjOEEyQkUyXCIsZGFya3JlZDpcIiM4QjAwMDBcIixkYXJrbWFnZW50YTpcIiM4QjAwOEJcIixzYWRkbGVicm93bjpcIiM4QjQ1MTNcIixkYXJrc2VhZ3JlZW46XCIjOEZCQzhGXCIsbGlnaHRncmVlbjpcIiM5MEVFOTBcIixtZWRpdW1wdXJwbGU6XCIjOTM3MEQ4XCIsZGFya3Zpb2xldDpcIiM5NDAwRDNcIixwYWxlZ3JlZW46XCIjOThGQjk4XCIsZGFya29yY2hpZDpcIiM5OTMyQ0NcIix5ZWxsb3dncmVlbjpcIiM5QUNEMzJcIixzaWVubmE6XCIjQTA1MjJEXCIsYnJvd246XCIjQTUyQTJBXCIsZGFya2dyYXk6XCIjQTlBOUE5XCIsbGlnaHRibHVlOlwiI0FERDhFNlwiLGdyZWVueWVsbG93OlwiI0FERkYyRlwiLHBhbGV0dXJxdW9pc2U6XCIjQUZFRUVFXCIsbGlnaHRzdGVlbGJsdWU6XCIjQjBDNERFXCIscG93ZGVyYmx1ZTpcIiNCMEUwRTZcIixmaXJlYnJpY2s6XCIjQjIyMjIyXCIsZGFya2dvbGRlbnJvZDpcIiNCODg2MEJcIixtZWRpdW1vcmNoaWQ6XCIjQkE1NUQzXCIscm9zeWJyb3duOlwiI0JDOEY4RlwiLGRhcmtraGFraTpcIiNCREI3NkJcIixzaWx2ZXI6XCIjQzBDMEMwXCIsbWVkaXVtdmlvbGV0cmVkOlwiI0M3MTU4NVwiLGluZGlhbnJlZDpcIiNDRDVDNUNcIixwZXJ1OlwiI0NEODUzRlwiLGNob2NvbGF0ZTpcIiNEMjY5MUVcIix0YW46XCIjRDJCNDhDXCIsbGlnaHRncmV5OlwiI0QzRDNEM1wiLHBhbGV2aW9sZXRyZWQ6XCIjRDg3MDkzXCIsdGhpc3RsZTpcIiNEOEJGRDhcIixvcmNoaWQ6XCIjREE3MEQ2XCIsZ29sZGVucm9kOlwiI0RBQTUyMFwiLGNyaW1zb246XCIjREMxNDNDXCIsZ2FpbnNib3JvOlwiI0RDRENEQ1wiLHBsdW06XCIjRERBMEREXCIsYnVybHl3b29kOlwiI0RFQjg4N1wiLGxpZ2h0Y3lhbjpcIiNFMEZGRkZcIixsYXZlbmRlcjpcIiNFNkU2RkFcIixkYXJrc2FsbW9uOlwiI0U5OTY3QVwiLHZpb2xldDpcIiNFRTgyRUVcIixwYWxlZ29sZGVucm9kOlwiI0VFRThBQVwiLGxpZ2h0Y29yYWw6XCIjRjA4MDgwXCIsa2hha2k6XCIjRjBFNjhDXCIsYWxpY2VibHVlOlwiI0YwRjhGRlwiLGhvbmV5ZGV3OlwiI0YwRkZGMFwiLGF6dXJlOlwiI0YwRkZGRlwiLHNhbmR5YnJvd246XCIjRjRBNDYwXCIsd2hlYXQ6XCIjRjVERUIzXCIsYmVpZ2U6XCIjRjVGNURDXCIsd2hpdGVzbW9rZTpcIiNGNUY1RjVcIixtaW50Y3JlYW06XCIjRjVGRkZBXCIsZ2hvc3R3aGl0ZTpcIiNGOEY4RkZcIixzYWxtb246XCIjRkE4MDcyXCIsYW50aXF1ZXdoaXRlOlwiI0ZBRUJEN1wiLGxpbmVuOlwiI0ZBRjBFNlwiLGxpZ2h0Z29sZGVucm9keWVsbG93OlwiI0ZBRkFEMlwiLG9sZGxhY2U6XCIjRkRGNUU2XCIscmVkOlwiI0ZGMDAwMFwiLGZ1Y2hzaWE6XCIjRkYwMEZGXCIsbWFnZW50YTpcIiNGRjAwRkZcIixkZWVwcGluazpcIiNGRjE0OTNcIixvcmFuZ2VyZWQ6XCIjRkY0NTAwXCIsdG9tYXRvOlwiI0ZGNjM0N1wiLGhvdHBpbms6XCIjRkY2OUI0XCIsY29yYWw6XCIjRkY3RjUwXCIsZGFya29yYW5nZTpcIiNGRjhDMDBcIixsaWdodHNhbG1vbjpcIiNGRkEwN0FcIixvcmFuZ2U6XCIjRkZBNTAwXCIsbGlnaHRwaW5rOlwiI0ZGQjZDMVwiLHBpbms6XCIjRkZDMENCXCIsZ29sZDpcIiNGRkQ3MDBcIixwZWFjaHB1ZmY6XCIjRkZEQUI5XCIsbmF2YWpvd2hpdGU6XCIjRkZERUFEXCIsbW9jY2FzaW46XCIjRkZFNEI1XCIsYmlzcXVlOlwiI0ZGRTRDNFwiLG1pc3R5cm9zZTpcIiNGRkU0RTFcIixibGFuY2hlZGFsbW9uZDpcIiNGRkVCQ0RcIixwYXBheWF3aGlwOlwiI0ZGRUZENVwiLGxhdmVuZGVyYmx1c2g6XCIjRkZGMEY1XCIsc2Vhc2hlbGw6XCIjRkZGNUVFXCIsY29ybnNpbGs6XCIjRkZGOERDXCIsbGVtb25jaGlmZm9uOlwiI0ZGRkFDRFwiLGZsb3JhbHdoaXRlOlwiI0ZGRkFGMFwiLHNub3c6XCIjRkZGQUZBXCIseWVsbG93OlwiI0ZGRkYwMFwiLGxpZ2h0eWVsbG93OlwiI0ZGRkZFMFwiLGl2b3J5OlwiI0ZGRkZGMFwiLHdoaXRlOlwiI0ZGRkZGRlwifSx3aD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MTtQbyh0aGlzLHQpLHRoaXMucGl4ZWxSYXRpbz1lLHRoaXMuZ2VuZXJhdGVkPSExLHRoaXMuY2VudGVyQ29vcmRpbmF0ZXM9e3g6MTQ0LjUseToxNDQuNX0sdGhpcy5yPTI4OSouNDksdGhpcy5jb2xvcj17cjoyNTUsZzoyNTUsYjoyNTUsYToxfSx0aGlzLmh1ZUNpcmNsZT12b2lkIDAsdGhpcy5pbml0aWFsQ29sb3I9e3I6MjU1LGc6MjU1LGI6MjU1LGE6MX0sdGhpcy5wcmV2aW91c0NvbG9yPXZvaWQgMCx0aGlzLmFwcGxpZWQ9ITEsdGhpcy51cGRhdGVDYWxsYmFjaz1mdW5jdGlvbigpe30sdGhpcy5jbG9zZUNhbGxiYWNrPWZ1bmN0aW9uKCl7fSx0aGlzLl9jcmVhdGUoKX1yZXR1cm4gSW8odCxbe2tleTpcImluc2VydFRvXCIsdmFsdWU6ZnVuY3Rpb24odCl7dm9pZCAwIT09dGhpcy5oYW1tZXImJih0aGlzLmhhbW1lci5kZXN0cm95KCksdGhpcy5oYW1tZXI9dm9pZCAwKSx0aGlzLmNvbnRhaW5lcj10LHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUpLHRoaXMuX2JpbmRIYW1tZXIoKSx0aGlzLl9zZXRTaXplKCl9fSx7a2V5Olwic2V0VXBkYXRlQ2FsbGJhY2tcIix2YWx1ZTpmdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGF0dGVtcHRlZCB0byBzZXQgYXMgY29sb3JQaWNrZXIgdXBkYXRlIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlwiKTt0aGlzLnVwZGF0ZUNhbGxiYWNrPXR9fSx7a2V5Olwic2V0Q2xvc2VDYWxsYmFja1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gYXR0ZW1wdGVkIHRvIHNldCBhcyBjb2xvclBpY2tlciBjbG9zaW5nIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlwiKTt0aGlzLmNsb3NlQ2FsbGJhY2s9dH19LHtrZXk6XCJfaXNDb2xvclN0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXJldHVybiBiaFt0XX19LHtrZXk6XCJzZXRDb2xvclwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV07aWYoXCJub25lXCIhPT10KXt2YXIgaSxvPXRoaXMuX2lzQ29sb3JTdHJpbmcodCk7aWYodm9pZCAwIT09byYmKHQ9byksITA9PT1HYSh0KSl7aWYoITA9PT1maCh0KSl7dmFyIG49dC5zdWJzdHIoNCkuc3Vic3RyKDAsdC5sZW5ndGgtNSkuc3BsaXQoXCIsXCIpO2k9e3I6blswXSxnOm5bMV0sYjpuWzJdLGE6MX19ZWxzZSBpZighMD09PXBoKHQpKXt2YXIgcj10LnN1YnN0cig1KS5zdWJzdHIoMCx0Lmxlbmd0aC02KS5zcGxpdChcIixcIik7aT17cjpyWzBdLGc6clsxXSxiOnJbMl0sYTpyWzNdfX1lbHNlIGlmKCEwPT09dWgodCkpe3ZhciBzPXJoKHQpO2k9e3I6cy5yLGc6cy5nLGI6cy5iLGE6MX19fWVsc2UgaWYodCBpbnN0YW5jZW9mIE9iamVjdCYmdm9pZCAwIT09dC5yJiZ2b2lkIDAhPT10LmcmJnZvaWQgMCE9PXQuYil7dmFyIGE9dm9pZCAwIT09dC5hP3QuYTpcIjEuMFwiO2k9e3I6dC5yLGc6dC5nLGI6dC5iLGE6YX19aWYodm9pZCAwPT09aSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbG9yIHBhc3NlZCB0byB0aGUgY29sb3JQaWNrZXIuIFN1cHBvcnRlZCBhcmUgc3RyaW5nczogcmdiLCBoZXgsIHJnYmEuIE9iamVjdDogcmdiICh7cjpyLGc6ZyxiOmIsW2E6YV19KS4gU3VwcGxpZWQ6IFwiK0xyKHQpKTt0aGlzLl9zZXRDb2xvcihpLGUpfX19LHtrZXk6XCJzaG93XCIsdmFsdWU6ZnVuY3Rpb24oKXt2b2lkIDAhPT10aGlzLmNsb3NlQ2FsbGJhY2smJih0aGlzLmNsb3NlQ2FsbGJhY2soKSx0aGlzLmNsb3NlQ2FsbGJhY2s9dm9pZCAwKSx0aGlzLmFwcGxpZWQ9ITEsdGhpcy5mcmFtZS5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIix0aGlzLl9nZW5lcmF0ZUh1ZUNpcmNsZSgpfX0se2tleTpcIl9oaWRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9IShhcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSl8fGFyZ3VtZW50c1swXTshMD09PWUmJih0aGlzLnByZXZpb3VzQ29sb3I9Y3Qoe30sdGhpcy5jb2xvcikpLCEwPT09dGhpcy5hcHBsaWVkJiZ0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuaW5pdGlhbENvbG9yKSx0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXk9XCJub25lXCIscXIoKGZ1bmN0aW9uKCl7dm9pZCAwIT09dC5jbG9zZUNhbGxiYWNrJiYodC5jbG9zZUNhbGxiYWNrKCksdC5jbG9zZUNhbGxiYWNrPXZvaWQgMCl9KSwwKX19LHtrZXk6XCJfc2F2ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmNvbG9yKSx0aGlzLmFwcGxpZWQ9ITEsdGhpcy5faGlkZSgpfX0se2tleTpcIl9hcHBseVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5hcHBsaWVkPSEwLHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5jb2xvciksdGhpcy5fdXBkYXRlUGlja2VyKHRoaXMuY29sb3IpfX0se2tleTpcIl9sb2FkTGFzdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dm9pZCAwIT09dGhpcy5wcmV2aW91c0NvbG9yP3RoaXMuc2V0Q29sb3IodGhpcy5wcmV2aW91c0NvbG9yLCExKTphbGVydChcIlRoZXJlIGlzIG5vIGxhc3QgY29sb3IgdG8gbG9hZC4uLlwiKX19LHtrZXk6XCJfc2V0Q29sb3JcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT0hKGFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdKXx8YXJndW1lbnRzWzFdOyEwPT09ZSYmKHRoaXMuaW5pdGlhbENvbG9yPWN0KHt9LHQpKSx0aGlzLmNvbG9yPXQ7dmFyIGk9ZGgodC5yLHQuZyx0LmIpLG89MipNYXRoLlBJLG49dGhpcy5yKmkucyxyPXRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCtuKk1hdGguc2luKG8qaS5oKSxzPXRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueStuKk1hdGguY29zKG8qaS5oKTt0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUubGVmdD1yLS41KnRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRXaWR0aCtcInB4XCIsdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLnRvcD1zLS41KnRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRIZWlnaHQrXCJweFwiLHRoaXMuX3VwZGF0ZVBpY2tlcih0KX19LHtrZXk6XCJfc2V0T3BhY2l0eVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuY29sb3IuYT10LzEwMCx0aGlzLl91cGRhdGVQaWNrZXIodGhpcy5jb2xvcil9fSx7a2V5OlwiX3NldEJyaWdodG5lc3NcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1kaCh0aGlzLmNvbG9yLnIsdGhpcy5jb2xvci5nLHRoaXMuY29sb3IuYik7ZS52PXQvMTAwO3ZhciBpPWxoKGUuaCxlLnMsZS52KTtpLmE9dGhpcy5jb2xvci5hLHRoaXMuY29sb3I9aSx0aGlzLl91cGRhdGVQaWNrZXIoKX19LHtrZXk6XCJfdXBkYXRlUGlja2VyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06dGhpcy5jb2xvcixlPWRoKHQucix0LmcsdC5iKSxpPXRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO3ZvaWQgMD09PXRoaXMucGl4ZWxSYXRpb24mJih0aGlzLnBpeGVsUmF0aW89KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfHwxKS8oaS53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvfHxpLm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW98fGkubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvfHxpLm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvfHxpLmJhY2tpbmdTdG9yZVBpeGVsUmF0aW98fDEpKSxpLnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sMCwwLHRoaXMucGl4ZWxSYXRpbywwLDApO3ZhciBvPXRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50V2lkdGgsbj10aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudEhlaWdodDtpLmNsZWFyUmVjdCgwLDAsbyxuKSxpLnB1dEltYWdlRGF0YSh0aGlzLmh1ZUNpcmNsZSwwLDApLGkuZmlsbFN0eWxlPVwicmdiYSgwLDAsMCxcIisoMS1lLnYpK1wiKVwiLGkuY2lyY2xlKHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCx0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnksdGhpcy5yKSxYcihpKS5jYWxsKGkpLHRoaXMuYnJpZ2h0bmVzc1JhbmdlLnZhbHVlPTEwMCplLnYsdGhpcy5vcGFjaXR5UmFuZ2UudmFsdWU9MTAwKnQuYSx0aGlzLmluaXRpYWxDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9XCJyZ2JhKFwiK3RoaXMuaW5pdGlhbENvbG9yLnIrXCIsXCIrdGhpcy5pbml0aWFsQ29sb3IuZytcIixcIit0aGlzLmluaXRpYWxDb2xvci5iK1wiLFwiK3RoaXMuaW5pdGlhbENvbG9yLmErXCIpXCIsdGhpcy5uZXdDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9XCJyZ2JhKFwiK3RoaXMuY29sb3IucitcIixcIit0aGlzLmNvbG9yLmcrXCIsXCIrdGhpcy5jb2xvci5iK1wiLFwiK3RoaXMuY29sb3IuYStcIilcIn19LHtrZXk6XCJfc2V0U2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jb2xvclBpY2tlckNhbnZhcy5zdHlsZS53aWR0aD1cIjEwMCVcIix0aGlzLmNvbG9yUGlja2VyQ2FudmFzLnN0eWxlLmhlaWdodD1cIjEwMCVcIix0aGlzLmNvbG9yUGlja2VyQ2FudmFzLndpZHRoPTI4OSp0aGlzLnBpeGVsUmF0aW8sdGhpcy5jb2xvclBpY2tlckNhbnZhcy5oZWlnaHQ9Mjg5KnRoaXMucGl4ZWxSYXRpb319LHtrZXk6XCJfY3JlYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlLGksbztpZih0aGlzLmZyYW1lPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5mcmFtZS5jbGFzc05hbWU9XCJ2aXMtY29sb3ItcGlja2VyXCIsdGhpcy5jb2xvclBpY2tlckRpdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGFzc05hbWU9XCJ2aXMtc2VsZWN0b3JcIix0aGlzLmNvbG9yUGlja2VyRGl2LmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJTZWxlY3RvciksdGhpcy5jb2xvclBpY2tlckNhbnZhcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLHRoaXMuY29sb3JQaWNrZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlckNhbnZhcyksdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KXt2YXIgbj10aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTt0aGlzLnBpeGVsUmF0aW89KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfHwxKS8obi53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvfHxuLm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW98fG4ubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvfHxuLm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvfHxuLmJhY2tpbmdTdG9yZVBpeGVsUmF0aW98fDEpLHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sMCwwLHRoaXMucGl4ZWxSYXRpbywwLDApfWVsc2V7dmFyIHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtyLnN0eWxlLmNvbG9yPVwicmVkXCIsci5zdHlsZS5mb250V2VpZ2h0PVwiYm9sZFwiLHIuc3R5bGUucGFkZGluZz1cIjEwcHhcIixyLmlubmVyVGV4dD1cIkVycm9yOiB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIGNhbnZhc1wiLHRoaXMuY29sb3JQaWNrZXJDYW52YXMuYXBwZW5kQ2hpbGQocil9dGhpcy5jb2xvclBpY2tlckRpdi5jbGFzc05hbWU9XCJ2aXMtY29sb3JcIix0aGlzLm9wYWNpdHlEaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLm9wYWNpdHlEaXYuY2xhc3NOYW1lPVwidmlzLW9wYWNpdHlcIix0aGlzLmJyaWdodG5lc3NEaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLmJyaWdodG5lc3NEaXYuY2xhc3NOYW1lPVwidmlzLWJyaWdodG5lc3NcIix0aGlzLmFycm93RGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5hcnJvd0Rpdi5jbGFzc05hbWU9XCJ2aXMtYXJyb3dcIix0aGlzLm9wYWNpdHlSYW5nZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7dHJ5e3RoaXMub3BhY2l0eVJhbmdlLnR5cGU9XCJyYW5nZVwiLHRoaXMub3BhY2l0eVJhbmdlLm1pbj1cIjBcIix0aGlzLm9wYWNpdHlSYW5nZS5tYXg9XCIxMDBcIn1jYXRjaCh0KXt9dGhpcy5vcGFjaXR5UmFuZ2UudmFsdWU9XCIxMDBcIix0aGlzLm9wYWNpdHlSYW5nZS5jbGFzc05hbWU9XCJ2aXMtcmFuZ2VcIix0aGlzLmJyaWdodG5lc3NSYW5nZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7dHJ5e3RoaXMuYnJpZ2h0bmVzc1JhbmdlLnR5cGU9XCJyYW5nZVwiLHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm1pbj1cIjBcIix0aGlzLmJyaWdodG5lc3NSYW5nZS5tYXg9XCIxMDBcIn1jYXRjaCh0KXt9dGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWU9XCIxMDBcIix0aGlzLmJyaWdodG5lc3NSYW5nZS5jbGFzc05hbWU9XCJ2aXMtcmFuZ2VcIix0aGlzLm9wYWNpdHlEaXYuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5UmFuZ2UpLHRoaXMuYnJpZ2h0bmVzc0Rpdi5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NSYW5nZSk7dmFyIHM9dGhpczt0aGlzLm9wYWNpdHlSYW5nZS5vbmNoYW5nZT1mdW5jdGlvbigpe3MuX3NldE9wYWNpdHkodGhpcy52YWx1ZSl9LHRoaXMub3BhY2l0eVJhbmdlLm9uaW5wdXQ9ZnVuY3Rpb24oKXtzLl9zZXRPcGFjaXR5KHRoaXMudmFsdWUpfSx0aGlzLmJyaWdodG5lc3NSYW5nZS5vbmNoYW5nZT1mdW5jdGlvbigpe3MuX3NldEJyaWdodG5lc3ModGhpcy52YWx1ZSl9LHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm9uaW5wdXQ9ZnVuY3Rpb24oKXtzLl9zZXRCcmlnaHRuZXNzKHRoaXMudmFsdWUpfSx0aGlzLmJyaWdodG5lc3NMYWJlbD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuYnJpZ2h0bmVzc0xhYmVsLmNsYXNzTmFtZT1cInZpcy1sYWJlbCB2aXMtYnJpZ2h0bmVzc1wiLHRoaXMuYnJpZ2h0bmVzc0xhYmVsLmlubmVyVGV4dD1cImJyaWdodG5lc3M6XCIsdGhpcy5vcGFjaXR5TGFiZWw9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLm9wYWNpdHlMYWJlbC5jbGFzc05hbWU9XCJ2aXMtbGFiZWwgdmlzLW9wYWNpdHlcIix0aGlzLm9wYWNpdHlMYWJlbC5pbm5lclRleHQ9XCJvcGFjaXR5OlwiLHRoaXMubmV3Q29sb3JEaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLm5ld0NvbG9yRGl2LmNsYXNzTmFtZT1cInZpcy1uZXctY29sb3JcIix0aGlzLm5ld0NvbG9yRGl2LmlubmVyVGV4dD1cIm5ld1wiLHRoaXMuaW5pdGlhbENvbG9yRGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5pbml0aWFsQ29sb3JEaXYuY2xhc3NOYW1lPVwidmlzLWluaXRpYWwtY29sb3JcIix0aGlzLmluaXRpYWxDb2xvckRpdi5pbm5lclRleHQ9XCJpbml0aWFsXCIsdGhpcy5jYW5jZWxCdXR0b249ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLmNhbmNlbEJ1dHRvbi5jbGFzc05hbWU9XCJ2aXMtYnV0dG9uIHZpcy1jYW5jZWxcIix0aGlzLmNhbmNlbEJ1dHRvbi5pbm5lclRleHQ9XCJjYW5jZWxcIix0aGlzLmNhbmNlbEJ1dHRvbi5vbmNsaWNrPWJ0KHQ9dGhpcy5faGlkZSkuY2FsbCh0LHRoaXMsITEpLHRoaXMuYXBwbHlCdXR0b249ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLmFwcGx5QnV0dG9uLmNsYXNzTmFtZT1cInZpcy1idXR0b24gdmlzLWFwcGx5XCIsdGhpcy5hcHBseUJ1dHRvbi5pbm5lclRleHQ9XCJhcHBseVwiLHRoaXMuYXBwbHlCdXR0b24ub25jbGljaz1idChlPXRoaXMuX2FwcGx5KS5jYWxsKGUsdGhpcyksdGhpcy5zYXZlQnV0dG9uPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5zYXZlQnV0dG9uLmNsYXNzTmFtZT1cInZpcy1idXR0b24gdmlzLXNhdmVcIix0aGlzLnNhdmVCdXR0b24uaW5uZXJUZXh0PVwic2F2ZVwiLHRoaXMuc2F2ZUJ1dHRvbi5vbmNsaWNrPWJ0KGk9dGhpcy5fc2F2ZSkuY2FsbChpLHRoaXMpLHRoaXMubG9hZEJ1dHRvbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMubG9hZEJ1dHRvbi5jbGFzc05hbWU9XCJ2aXMtYnV0dG9uIHZpcy1sb2FkXCIsdGhpcy5sb2FkQnV0dG9uLmlubmVyVGV4dD1cImxvYWQgbGFzdFwiLHRoaXMubG9hZEJ1dHRvbi5vbmNsaWNrPWJ0KG89dGhpcy5fbG9hZExhc3QpLmNhbGwobyx0aGlzKSx0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJEaXYpLHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcnJvd0RpdiksdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NMYWJlbCksdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NEaXYpLHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5TGFiZWwpLHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5RGl2KSx0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubmV3Q29sb3JEaXYpLHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5pbml0aWFsQ29sb3JEaXYpLHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jYW5jZWxCdXR0b24pLHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcHBseUJ1dHRvbiksdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLnNhdmVCdXR0b24pLHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5sb2FkQnV0dG9uKX19LHtrZXk6XCJfYmluZEhhbW1lclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmRyYWc9e30sdGhpcy5waW5jaD17fSx0aGlzLmhhbW1lcj1uZXcgSGEodGhpcy5jb2xvclBpY2tlckNhbnZhcyksdGhpcy5oYW1tZXIuZ2V0KFwicGluY2hcIikuc2V0KHtlbmFibGU6ITB9KSx0aGlzLmhhbW1lci5vbihcImhhbW1lci5pbnB1dFwiLChmdW5jdGlvbihlKXtlLmlzRmlyc3QmJnQuX21vdmVTZWxlY3RvcihlKX0pKSx0aGlzLmhhbW1lci5vbihcInRhcFwiLChmdW5jdGlvbihlKXt0Ll9tb3ZlU2VsZWN0b3IoZSl9KSksdGhpcy5oYW1tZXIub24oXCJwYW5zdGFydFwiLChmdW5jdGlvbihlKXt0Ll9tb3ZlU2VsZWN0b3IoZSl9KSksdGhpcy5oYW1tZXIub24oXCJwYW5tb3ZlXCIsKGZ1bmN0aW9uKGUpe3QuX21vdmVTZWxlY3RvcihlKX0pKSx0aGlzLmhhbW1lci5vbihcInBhbmVuZFwiLChmdW5jdGlvbihlKXt0Ll9tb3ZlU2VsZWN0b3IoZSl9KSl9fSx7a2V5OlwiX2dlbmVyYXRlSHVlQ2lyY2xlXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZighMT09PXRoaXMuZ2VuZXJhdGVkKXt2YXIgdD10aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTt2b2lkIDA9PT10aGlzLnBpeGVsUmF0aW9uJiYodGhpcy5waXhlbFJhdGlvPSh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb3x8MSkvKHQud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvfHx0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvfHwxKSksdC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLDAsMCx0aGlzLnBpeGVsUmF0aW8sMCwwKTt2YXIgZSxpLG8sbixyPXRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50V2lkdGgscz10aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudEhlaWdodDt0LmNsZWFyUmVjdCgwLDAscixzKSx0aGlzLmNlbnRlckNvb3JkaW5hdGVzPXt4Oi41KnIseTouNSpzfSx0aGlzLnI9LjQ5KnI7dmFyIGEsaD0yKk1hdGguUEkvMzYwLGQ9MS90aGlzLnI7Zm9yKG89MDtvPDM2MDtvKyspZm9yKG49MDtuPHRoaXMucjtuKyspZT10aGlzLmNlbnRlckNvb3JkaW5hdGVzLngrbipNYXRoLnNpbihoKm8pLGk9dGhpcy5jZW50ZXJDb29yZGluYXRlcy55K24qTWF0aC5jb3MoaCpvKSxhPWxoKC4wMDI3Nzc3Nzc3Nzc3Nzc3NzgqbyxuKmQsMSksdC5maWxsU3R5bGU9XCJyZ2IoXCIrYS5yK1wiLFwiK2EuZytcIixcIithLmIrXCIpXCIsdC5maWxsUmVjdChlLS41LGktLjUsMiwyKTt0LnN0cm9rZVN0eWxlPVwicmdiYSgwLDAsMCwxKVwiLHQuY2lyY2xlKHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCx0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnksdGhpcy5yKSx0LnN0cm9rZSgpLHRoaXMuaHVlQ2lyY2xlPXQuZ2V0SW1hZ2VEYXRhKDAsMCxyLHMpfXRoaXMuZ2VuZXJhdGVkPSEwfX0se2tleTpcIl9tb3ZlU2VsZWN0b3JcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmNvbG9yUGlja2VyRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGk9dC5jZW50ZXIueC1lLmxlZnQsbz10LmNlbnRlci55LWUudG9wLG49LjUqdGhpcy5jb2xvclBpY2tlckRpdi5jbGllbnRIZWlnaHQscj0uNSp0aGlzLmNvbG9yUGlja2VyRGl2LmNsaWVudFdpZHRoLHM9aS1yLGE9by1uLGg9TWF0aC5hdGFuMihzLGEpLGQ9Ljk4Kk1hdGgubWluKE1hdGguc3FydChzKnMrYSphKSxyKSxsPU1hdGguY29zKGgpKmQrbixjPU1hdGguc2luKGgpKmQrcjt0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wPWwtLjUqdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudEhlaWdodCtcInB4XCIsdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLmxlZnQ9Yy0uNSp0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50V2lkdGgrXCJweFwiO3ZhciB1PWgvKDIqTWF0aC5QSSk7dT11PDA/dSsxOnU7dmFyIGY9ZC90aGlzLnIscD1kaCh0aGlzLmNvbG9yLnIsdGhpcy5jb2xvci5nLHRoaXMuY29sb3IuYik7cC5oPXUscC5zPWY7dmFyIHY9bGgocC5oLHAucyxwLnYpO3YuYT10aGlzLmNvbG9yLmEsdGhpcy5jb2xvcj12LHRoaXMuaW5pdGlhbENvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvcj1cInJnYmEoXCIrdGhpcy5pbml0aWFsQ29sb3IucitcIixcIit0aGlzLmluaXRpYWxDb2xvci5nK1wiLFwiK3RoaXMuaW5pdGlhbENvbG9yLmIrXCIsXCIrdGhpcy5pbml0aWFsQ29sb3IuYStcIilcIix0aGlzLm5ld0NvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvcj1cInJnYmEoXCIrdGhpcy5jb2xvci5yK1wiLFwiK3RoaXMuY29sb3IuZytcIixcIit0aGlzLmNvbG9yLmIrXCIsXCIrdGhpcy5jb2xvci5hK1wiKVwifX1dKSx0fSgpO2Z1bmN0aW9uIGtoKCl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsZT1uZXcgQXJyYXkodCksaT0wO2k8dDtpKyspZVtpXT1hcmd1bWVudHNbaV07aWYoZS5sZW5ndGg8MSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMuXCIpO2lmKDE9PT1lLmxlbmd0aClyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZVswXSk7dmFyIG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlWzBdKTtyZXR1cm4gby5hcHBlbmRDaGlsZChraC5hcHBseSh2b2lkIDAsbG4odm4oZSkuY2FsbChlLDEpKSkpLG99dmFyIF9oLHhoPSExLEVoPVwiYmFja2dyb3VuZDogI0ZGZWVlZTsgY29sb3I6ICNkZDAwMDBcIixPaD1XYSxDaD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8pe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXToxLHI9YXJndW1lbnRzLmxlbmd0aD40JiZ2b2lkIDAhPT1hcmd1bWVudHNbNF0/YXJndW1lbnRzWzRdOmZ1bmN0aW9uKCl7cmV0dXJuITF9O1BvKHRoaXMsdCksdGhpcy5wYXJlbnQ9ZSx0aGlzLmNoYW5nZWRPcHRpb25zPVtdLHRoaXMuY29udGFpbmVyPWksdGhpcy5hbGxvd0NyZWF0aW9uPSExLHRoaXMuaGlkZU9wdGlvbj1yLHRoaXMub3B0aW9ucz17fSx0aGlzLmluaXRpYWxpemVkPSExLHRoaXMucG9wdXBDb3VudGVyPTAsdGhpcy5kZWZhdWx0T3B0aW9ucz17ZW5hYmxlZDohMSxmaWx0ZXI6ITAsY29udGFpbmVyOnZvaWQgMCxzaG93QnV0dG9uOiEwfSxjdCh0aGlzLm9wdGlvbnMsdGhpcy5kZWZhdWx0T3B0aW9ucyksdGhpcy5jb25maWd1cmVPcHRpb25zPW8sdGhpcy5tb2R1bGVPcHRpb25zPXt9LHRoaXMuZG9tRWxlbWVudHM9W10sdGhpcy5wb3B1cERpdj17fSx0aGlzLnBvcHVwTGltaXQ9NSx0aGlzLnBvcHVwSGlzdG9yeT17fSx0aGlzLmNvbG9yUGlja2VyPW5ldyB3aChuKSx0aGlzLndyYXBwZXI9dm9pZCAwfXJldHVybiBJbyh0LFt7a2V5Olwic2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMCE9PXQpe3RoaXMucG9wdXBIaXN0b3J5PXt9LHRoaXMuX3JlbW92ZVBvcHVwKCk7dmFyIGU9ITA7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpdGhpcy5vcHRpb25zLmZpbHRlcj10O2Vsc2UgaWYoZ24odCkpdGhpcy5vcHRpb25zLmZpbHRlcj10LmpvaW4oKTtlbHNlIGlmKFwib2JqZWN0XCI9PT1kbih0KSl7aWYobnVsbD09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwib3B0aW9ucyBjYW5ub3QgYmUgbnVsbFwiKTt2b2lkIDAhPT10LmNvbnRhaW5lciYmKHRoaXMub3B0aW9ucy5jb250YWluZXI9dC5jb250YWluZXIpLHZvaWQgMCE9PWFyKHQpJiYodGhpcy5vcHRpb25zLmZpbHRlcj1hcih0KSksdm9pZCAwIT09dC5zaG93QnV0dG9uJiYodGhpcy5vcHRpb25zLnNob3dCdXR0b249dC5zaG93QnV0dG9uKSx2b2lkIDAhPT10LmVuYWJsZWQmJihlPXQuZW5hYmxlZCl9ZWxzZVwiYm9vbGVhblwiPT10eXBlb2YgdD8odGhpcy5vcHRpb25zLmZpbHRlcj0hMCxlPXQpOlwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJih0aGlzLm9wdGlvbnMuZmlsdGVyPXQsZT0hMCk7ITE9PT1hcih0aGlzLm9wdGlvbnMpJiYoZT0hMSksdGhpcy5vcHRpb25zLmVuYWJsZWQ9ZX10aGlzLl9jbGVhbigpfX0se2tleTpcInNldE1vZHVsZU9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLm1vZHVsZU9wdGlvbnM9dCwhMD09PXRoaXMub3B0aW9ucy5lbmFibGVkJiYodGhpcy5fY2xlYW4oKSx2b2lkIDAhPT10aGlzLm9wdGlvbnMuY29udGFpbmVyJiYodGhpcy5jb250YWluZXI9dGhpcy5vcHRpb25zLmNvbnRhaW5lciksdGhpcy5fY3JlYXRlKCkpfX0se2tleTpcIl9jcmVhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2NsZWFuKCksdGhpcy5jaGFuZ2VkT3B0aW9ucz1bXTt2YXIgdD1hcih0aGlzLm9wdGlvbnMpLGU9MCxpPSExO2Zvcih2YXIgbyBpbiB0aGlzLmNvbmZpZ3VyZU9wdGlvbnMpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29uZmlndXJlT3B0aW9ucyxvKSYmKHRoaXMuYWxsb3dDcmVhdGlvbj0hMSxpPSExLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/aT0oaT10KG8sW10pKXx8dGhpcy5faGFuZGxlT2JqZWN0KHRoaXMuY29uZmlndXJlT3B0aW9uc1tvXSxbb10sITApOiEwIT09dCYmLTE9PT1Ncih0KS5jYWxsKHQsbyl8fChpPSEwKSwhMSE9PWkmJih0aGlzLmFsbG93Q3JlYXRpb249ITAsZT4wJiZ0aGlzLl9tYWtlSXRlbShbXSksdGhpcy5fbWFrZUhlYWRlcihvKSx0aGlzLl9oYW5kbGVPYmplY3QodGhpcy5jb25maWd1cmVPcHRpb25zW29dLFtvXSkpLGUrKyk7dGhpcy5fbWFrZUJ1dHRvbigpLHRoaXMuX3B1c2goKX19LHtrZXk6XCJfcHVzaFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy53cmFwcGVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy53cmFwcGVyLmNsYXNzTmFtZT1cInZpcy1jb25maWd1cmF0aW9uLXdyYXBwZXJcIix0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXIpO2Zvcih2YXIgdD0wO3Q8dGhpcy5kb21FbGVtZW50cy5sZW5ndGg7dCsrKXRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW3RdKTt0aGlzLl9zaG93UG9wdXBJZk5lZWRlZCgpfX0se2tleTpcIl9jbGVhblwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDx0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDt0KyspdGhpcy53cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudHNbdF0pO3ZvaWQgMCE9PXRoaXMud3JhcHBlciYmKHRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMud3JhcHBlciksdGhpcy53cmFwcGVyPXZvaWQgMCksdGhpcy5kb21FbGVtZW50cz1bXSx0aGlzLl9yZW1vdmVQb3B1cCgpfX0se2tleTpcIl9nZXRWYWx1ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLm1vZHVsZU9wdGlvbnMsaT0wO2k8dC5sZW5ndGg7aSsrKXtpZih2b2lkIDA9PT1lW3RbaV1dKXtlPXZvaWQgMDticmVha31lPWVbdFtpXV19cmV0dXJuIGV9fSx7a2V5OlwiX21ha2VJdGVtXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoITA9PT10aGlzLmFsbG93Q3JlYXRpb24pe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7ZS5jbGFzc05hbWU9XCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWl0ZW0gdmlzLWNvbmZpZy1zXCIrdC5sZW5ndGg7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGgsbz1uZXcgQXJyYXkoaT4xP2ktMTowKSxuPTE7bjxpO24rKylvW24tMV09YXJndW1lbnRzW25dO3JldHVybiBEbihvKS5jYWxsKG8sKGZ1bmN0aW9uKHQpe2UuYXBwZW5kQ2hpbGQodCl9KSksdGhpcy5kb21FbGVtZW50cy5wdXNoKGUpLHRoaXMuZG9tRWxlbWVudHMubGVuZ3RofXJldHVybiAwfX0se2tleTpcIl9tYWtlSGVhZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtlLmNsYXNzTmFtZT1cInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctaGVhZGVyXCIsZS5pbm5lclRleHQ9dCx0aGlzLl9tYWtlSXRlbShbXSxlKX19LHtrZXk6XCJfbWFrZUxhYmVsXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdLG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtpZihvLmNsYXNzTmFtZT1cInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctbGFiZWwgdmlzLWNvbmZpZy1zXCIrZS5sZW5ndGgsITA9PT1pKXtmb3IoO28uZmlyc3RDaGlsZDspby5yZW1vdmVDaGlsZChvLmZpcnN0Q2hpbGQpO28uYXBwZW5kQ2hpbGQoa2goXCJpXCIsXCJiXCIsdCkpfWVsc2Ugby5pbm5lclRleHQ9dCtcIjpcIjtyZXR1cm4gb319LHtrZXk6XCJfbWFrZURyb3Bkb3duXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3ZhciBvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7by5jbGFzc05hbWU9XCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXNlbGVjdFwiO3ZhciBuPTA7dm9pZCAwIT09ZSYmLTEhPT1Ncih0KS5jYWxsKHQsZSkmJihuPU1yKHQpLmNhbGwodCxlKSk7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7cy52YWx1ZT10W3JdLHI9PT1uJiYocy5zZWxlY3RlZD1cInNlbGVjdGVkXCIpLHMuaW5uZXJUZXh0PXRbcl0sby5hcHBlbmRDaGlsZChzKX12YXIgYT10aGlzO28ub25jaGFuZ2U9ZnVuY3Rpb24oKXthLl91cGRhdGUodGhpcy52YWx1ZSxpKX07dmFyIGg9dGhpcy5fbWFrZUxhYmVsKGlbaS5sZW5ndGgtMV0saSk7dGhpcy5fbWFrZUl0ZW0oaSxoLG8pfX0se2tleTpcIl9tYWtlUmFuZ2VcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dmFyIG89dFswXSxuPXRbMV0scj10WzJdLHM9dFszXSxhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTthLmNsYXNzTmFtZT1cInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctcmFuZ2VcIjt0cnl7YS50eXBlPVwicmFuZ2VcIixhLm1pbj1uLGEubWF4PXJ9Y2F0Y2godCl7fWEuc3RlcD1zO3ZhciBoPVwiXCIsZD0wO2lmKHZvaWQgMCE9PWUpe3ZhciBsPTEuMjtlPDAmJmUqbDxuPyhhLm1pbj1NYXRoLmNlaWwoZSpsKSxkPWEubWluLGg9XCJyYW5nZSBpbmNyZWFzZWRcIik6ZS9sPG4mJihhLm1pbj1NYXRoLmNlaWwoZS9sKSxkPWEubWluLGg9XCJyYW5nZSBpbmNyZWFzZWRcIiksZSpsPnImJjEhPT1yJiYoYS5tYXg9TWF0aC5jZWlsKGUqbCksZD1hLm1heCxoPVwicmFuZ2UgaW5jcmVhc2VkXCIpLGEudmFsdWU9ZX1lbHNlIGEudmFsdWU9bzt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7Yy5jbGFzc05hbWU9XCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXJhbmdlaW5wdXRcIixjLnZhbHVlPWEudmFsdWU7dmFyIHU9dGhpczthLm9uY2hhbmdlPWZ1bmN0aW9uKCl7Yy52YWx1ZT10aGlzLnZhbHVlLHUuX3VwZGF0ZShOdW1iZXIodGhpcy52YWx1ZSksaSl9LGEub25pbnB1dD1mdW5jdGlvbigpe2MudmFsdWU9dGhpcy52YWx1ZX07dmFyIGY9dGhpcy5fbWFrZUxhYmVsKGlbaS5sZW5ndGgtMV0saSkscD10aGlzLl9tYWtlSXRlbShpLGYsYSxjKTtcIlwiIT09aCYmdGhpcy5wb3B1cEhpc3RvcnlbcF0hPT1kJiYodGhpcy5wb3B1cEhpc3RvcnlbcF09ZCx0aGlzLl9zZXR1cFBvcHVwKGgscCkpfX0se2tleTpcIl9tYWtlQnV0dG9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKCEwPT09dGhpcy5vcHRpb25zLnNob3dCdXR0b24pe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7ZS5jbGFzc05hbWU9XCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWJ1dHRvblwiLGUuaW5uZXJUZXh0PVwiZ2VuZXJhdGUgb3B0aW9uc1wiLGUub25jbGljaz1mdW5jdGlvbigpe3QuX3ByaW50T3B0aW9ucygpfSxlLm9ubW91c2VvdmVyPWZ1bmN0aW9uKCl7ZS5jbGFzc05hbWU9XCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWJ1dHRvbiBob3ZlclwifSxlLm9ubW91c2VvdXQ9ZnVuY3Rpb24oKXtlLmNsYXNzTmFtZT1cInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uXCJ9LHRoaXMub3B0aW9uc0NvbnRhaW5lcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMub3B0aW9uc0NvbnRhaW5lci5jbGFzc05hbWU9XCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLW9wdGlvbi1jb250YWluZXJcIix0aGlzLmRvbUVsZW1lbnRzLnB1c2godGhpcy5vcHRpb25zQ29udGFpbmVyKSx0aGlzLmRvbUVsZW1lbnRzLnB1c2goZSl9fX0se2tleTpcIl9zZXR1cFBvcHVwXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzO2lmKCEwPT09dGhpcy5pbml0aWFsaXplZCYmITA9PT10aGlzLmFsbG93Q3JlYXRpb24mJnRoaXMucG9wdXBDb3VudGVyPHRoaXMucG9wdXBMaW1pdCl7dmFyIG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtvLmlkPVwidmlzLWNvbmZpZ3VyYXRpb24tcG9wdXBcIixvLmNsYXNzTmFtZT1cInZpcy1jb25maWd1cmF0aW9uLXBvcHVwXCIsby5pbm5lclRleHQ9dCxvLm9uY2xpY2s9ZnVuY3Rpb24oKXtpLl9yZW1vdmVQb3B1cCgpfSx0aGlzLnBvcHVwQ291bnRlcis9MSx0aGlzLnBvcHVwRGl2PXtodG1sOm8saW5kZXg6ZX19fX0se2tleTpcIl9yZW1vdmVQb3B1cFwiLHZhbHVlOmZ1bmN0aW9uKCl7dm9pZCAwIT09dGhpcy5wb3B1cERpdi5odG1sJiYodGhpcy5wb3B1cERpdi5odG1sLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3B1cERpdi5odG1sKSxjbGVhclRpbWVvdXQodGhpcy5wb3B1cERpdi5oaWRlVGltZW91dCksY2xlYXJUaW1lb3V0KHRoaXMucG9wdXBEaXYuZGVsZXRlVGltZW91dCksdGhpcy5wb3B1cERpdj17fSl9fSx7a2V5OlwiX3Nob3dQb3B1cElmTmVlZGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKHZvaWQgMCE9PXRoaXMucG9wdXBEaXYuaHRtbCl7dmFyIGU9dGhpcy5kb21FbGVtZW50c1t0aGlzLnBvcHVwRGl2LmluZGV4XS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt0aGlzLnBvcHVwRGl2Lmh0bWwuc3R5bGUubGVmdD1lLmxlZnQrXCJweFwiLHRoaXMucG9wdXBEaXYuaHRtbC5zdHlsZS50b3A9ZS50b3AtMzArXCJweFwiLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cERpdi5odG1sKSx0aGlzLnBvcHVwRGl2LmhpZGVUaW1lb3V0PXFyKChmdW5jdGlvbigpe3QucG9wdXBEaXYuaHRtbC5zdHlsZS5vcGFjaXR5PTB9KSwxNTAwKSx0aGlzLnBvcHVwRGl2LmRlbGV0ZVRpbWVvdXQ9cXIoKGZ1bmN0aW9uKCl7dC5fcmVtb3ZlUG9wdXAoKX0pLDE4MDApfX19LHtrZXk6XCJfbWFrZUNoZWNrYm94XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3ZhciBvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtvLnR5cGU9XCJjaGVja2JveFwiLG8uY2xhc3NOYW1lPVwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jaGVja2JveFwiLG8uY2hlY2tlZD10LHZvaWQgMCE9PWUmJihvLmNoZWNrZWQ9ZSxlIT09dCYmKFwib2JqZWN0XCI9PT1kbih0KT9lIT09dC5lbmFibGVkJiZ0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe3BhdGg6aSx2YWx1ZTplfSk6dGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtwYXRoOmksdmFsdWU6ZX0pKSk7dmFyIG49dGhpcztvLm9uY2hhbmdlPWZ1bmN0aW9uKCl7bi5fdXBkYXRlKHRoaXMuY2hlY2tlZCxpKX07dmFyIHI9dGhpcy5fbWFrZUxhYmVsKGlbaS5sZW5ndGgtMV0saSk7dGhpcy5fbWFrZUl0ZW0oaSxyLG8pfX0se2tleTpcIl9tYWtlVGV4dElucHV0XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3ZhciBvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtvLnR5cGU9XCJ0ZXh0XCIsby5jbGFzc05hbWU9XCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXRleHRcIixvLnZhbHVlPWUsZSE9PXQmJnRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7cGF0aDppLHZhbHVlOmV9KTt2YXIgbj10aGlzO28ub25jaGFuZ2U9ZnVuY3Rpb24oKXtuLl91cGRhdGUodGhpcy52YWx1ZSxpKX07dmFyIHI9dGhpcy5fbWFrZUxhYmVsKGlbaS5sZW5ndGgtMV0saSk7dGhpcy5fbWFrZUl0ZW0oaSxyLG8pfX0se2tleTpcIl9tYWtlQ29sb3JGaWVsZFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz10aGlzLG49dFsxXSxyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XCJub25lXCIhPT0oZT12b2lkIDA9PT1lP246ZSk/KHIuY2xhc3NOYW1lPVwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jb2xvckJsb2NrXCIsci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9ZSk6ci5jbGFzc05hbWU9XCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNvbG9yQmxvY2sgbm9uZVwiLGU9dm9pZCAwPT09ZT9uOmUsci5vbmNsaWNrPWZ1bmN0aW9uKCl7by5fc2hvd0NvbG9yUGlja2VyKGUscixpKX07dmFyIHM9dGhpcy5fbWFrZUxhYmVsKGlbaS5sZW5ndGgtMV0saSk7dGhpcy5fbWFrZUl0ZW0oaSxzLHIpfX0se2tleTpcIl9zaG93Q29sb3JQaWNrZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dmFyIG89dGhpcztlLm9uY2xpY2s9ZnVuY3Rpb24oKXt9LHRoaXMuY29sb3JQaWNrZXIuaW5zZXJ0VG8oZSksdGhpcy5jb2xvclBpY2tlci5zaG93KCksdGhpcy5jb2xvclBpY2tlci5zZXRDb2xvcih0KSx0aGlzLmNvbG9yUGlja2VyLnNldFVwZGF0ZUNhbGxiYWNrKChmdW5jdGlvbih0KXt2YXIgbj1cInJnYmEoXCIrdC5yK1wiLFwiK3QuZytcIixcIit0LmIrXCIsXCIrdC5hK1wiKVwiO2Uuc3R5bGUuYmFja2dyb3VuZENvbG9yPW4sby5fdXBkYXRlKG4saSl9KSksdGhpcy5jb2xvclBpY2tlci5zZXRDbG9zZUNhbGxiYWNrKChmdW5jdGlvbigpe2Uub25jbGljaz1mdW5jdGlvbigpe28uX3Nob3dDb2xvclBpY2tlcih0LGUsaSl9fSkpfX0se2tleTpcIl9oYW5kbGVPYmplY3RcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06W10saT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdLG89ITEsbj1hcih0aGlzLm9wdGlvbnMpLHI9ITE7Zm9yKHZhciBzIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQscykpe289ITA7dmFyIGE9dFtzXSxoPWVoKGUscyk7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgbiYmITE9PT0obz1uKHMsZSkpJiYhZ24oYSkmJlwic3RyaW5nXCIhPXR5cGVvZiBhJiZcImJvb2xlYW5cIiE9dHlwZW9mIGEmJmEgaW5zdGFuY2VvZiBPYmplY3QmJih0aGlzLmFsbG93Q3JlYXRpb249ITEsbz10aGlzLl9oYW5kbGVPYmplY3QoYSxoLCEwKSx0aGlzLmFsbG93Q3JlYXRpb249ITE9PT1pKSwhMSE9PW8pe3I9ITA7dmFyIGQ9dGhpcy5fZ2V0VmFsdWUoaCk7aWYoZ24oYSkpdGhpcy5faGFuZGxlQXJyYXkoYSxkLGgpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGEpdGhpcy5fbWFrZVRleHRJbnB1dChhLGQsaCk7ZWxzZSBpZihcImJvb2xlYW5cIj09dHlwZW9mIGEpdGhpcy5fbWFrZUNoZWNrYm94KGEsZCxoKTtlbHNlIGlmKGEgaW5zdGFuY2VvZiBPYmplY3Qpe2lmKCF0aGlzLmhpZGVPcHRpb24oZSxzLHRoaXMubW9kdWxlT3B0aW9ucykpaWYodm9pZCAwIT09YS5lbmFibGVkKXt2YXIgbD1laChoLFwiZW5hYmxlZFwiKSxjPXRoaXMuX2dldFZhbHVlKGwpO2lmKCEwPT09Yyl7dmFyIHU9dGhpcy5fbWFrZUxhYmVsKHMsaCwhMCk7dGhpcy5fbWFrZUl0ZW0oaCx1KSxyPXRoaXMuX2hhbmRsZU9iamVjdChhLGgpfHxyfWVsc2UgdGhpcy5fbWFrZUNoZWNrYm94KGEsYyxoKX1lbHNle3ZhciBmPXRoaXMuX21ha2VMYWJlbChzLGgsITApO3RoaXMuX21ha2VJdGVtKGgsZikscj10aGlzLl9oYW5kbGVPYmplY3QoYSxoKXx8cn19ZWxzZSBjb25zb2xlLmVycm9yKFwiZG9udCBrbm93IGhvdyB0byBoYW5kbGVcIixhLHMsaCl9fXJldHVybiByfX0se2tleTpcIl9oYW5kbGVBcnJheVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXtcInN0cmluZ1wiPT10eXBlb2YgdFswXSYmXCJjb2xvclwiPT09dFswXT8odGhpcy5fbWFrZUNvbG9yRmllbGQodCxlLGkpLHRbMV0hPT1lJiZ0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe3BhdGg6aSx2YWx1ZTplfSkpOlwic3RyaW5nXCI9PXR5cGVvZiB0WzBdPyh0aGlzLl9tYWtlRHJvcGRvd24odCxlLGkpLHRbMF0hPT1lJiZ0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe3BhdGg6aSx2YWx1ZTplfSkpOlwibnVtYmVyXCI9PXR5cGVvZiB0WzBdJiYodGhpcy5fbWFrZVJhbmdlKHQsZSxpKSx0WzBdIT09ZSYmdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtwYXRoOmksdmFsdWU6TnVtYmVyKGUpfSkpfX0se2tleTpcIl91cGRhdGVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMuX2NvbnN0cnVjdE9wdGlvbnModCxlKTt0aGlzLnBhcmVudC5ib2R5JiZ0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXImJnRoaXMucGFyZW50LmJvZHkuZW1pdHRlci5lbWl0JiZ0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIuZW1pdChcImNvbmZpZ0NoYW5nZVwiLGkpLHRoaXMuaW5pdGlhbGl6ZWQ9ITAsdGhpcy5wYXJlbnQuc2V0T3B0aW9ucyhpKX19LHtrZXk6XCJfY29uc3RydWN0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnt9LG89aTt0PVwiZmFsc2VcIiE9PSh0PVwidHJ1ZVwiPT09dHx8dCkmJnQ7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspXCJnbG9iYWxcIiE9PWVbbl0mJih2b2lkIDA9PT1vW2Vbbl1dJiYob1tlW25dXT17fSksbiE9PWUubGVuZ3RoLTE/bz1vW2Vbbl1dOm9bZVtuXV09dCk7cmV0dXJuIGl9fSx7a2V5OlwiX3ByaW50T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ2V0T3B0aW9ucygpO3RoaXMub3B0aW9uc0NvbnRhaW5lci5maXJzdENoaWxkOyl0aGlzLm9wdGlvbnNDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5vcHRpb25zQ29udGFpbmVyLmZpcnN0Q2hpbGQpO3RoaXMub3B0aW9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChraChcInByZVwiLFwiY29uc3Qgb3B0aW9ucyA9IFwiK0xyKHQsbnVsbCwyKSkpfX0se2tleTpcImdldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD17fSxlPTA7ZTx0aGlzLmNoYW5nZWRPcHRpb25zLmxlbmd0aDtlKyspdGhpcy5fY29uc3RydWN0T3B0aW9ucyh0aGlzLmNoYW5nZWRPcHRpb25zW2VdLnZhbHVlLHRoaXMuY2hhbmdlZE9wdGlvbnNbZV0ucGF0aCx0KTtyZXR1cm4gdH19XSksdH0oKSxTaD1IYSxUaD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpKXtQbyh0aGlzLHQpLHRoaXMuY29udGFpbmVyPWUsdGhpcy5vdmVyZmxvd01ldGhvZD1pfHxcImNhcFwiLHRoaXMueD0wLHRoaXMueT0wLHRoaXMucGFkZGluZz01LHRoaXMuaGlkZGVuPSExLHRoaXMuZnJhbWU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLmZyYW1lLmNsYXNzTmFtZT1cInZpcy10b29sdGlwXCIsdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSl9cmV0dXJuIElvKHQsW3trZXk6XCJzZXRQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy54PWtyKHQpLHRoaXMueT1rcihlKX19LHtrZXk6XCJzZXRUZXh0XCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIEVsZW1lbnQpe2Zvcig7dGhpcy5mcmFtZS5maXJzdENoaWxkOyl0aGlzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMuZnJhbWUuZmlyc3RDaGlsZCk7dGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0KX1lbHNlIHRoaXMuZnJhbWUuaW5uZXJUZXh0PXR9fSx7a2V5Olwic2hvd1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQmJih0PSEwKSwhMD09PXQpe3ZhciBlPXRoaXMuZnJhbWUuY2xpZW50SGVpZ2h0LGk9dGhpcy5mcmFtZS5jbGllbnRXaWR0aCxvPXRoaXMuZnJhbWUucGFyZW50Tm9kZS5jbGllbnRIZWlnaHQsbj10aGlzLmZyYW1lLnBhcmVudE5vZGUuY2xpZW50V2lkdGgscj0wLHM9MDtpZihcImZsaXBcIj09dGhpcy5vdmVyZmxvd01ldGhvZCl7dmFyIGE9ITEsaD0hMDt0aGlzLnktZTx0aGlzLnBhZGRpbmcmJihoPSExKSx0aGlzLngraT5uLXRoaXMucGFkZGluZyYmKGE9ITApLHI9YT90aGlzLngtaTp0aGlzLngscz1oP3RoaXMueS1lOnRoaXMueX1lbHNlKHM9dGhpcy55LWUpK2UrdGhpcy5wYWRkaW5nPm8mJihzPW8tZS10aGlzLnBhZGRpbmcpLHM8dGhpcy5wYWRkaW5nJiYocz10aGlzLnBhZGRpbmcpLChyPXRoaXMueCkraSt0aGlzLnBhZGRpbmc+biYmKHI9bi1pLXRoaXMucGFkZGluZykscjx0aGlzLnBhZGRpbmcmJihyPXRoaXMucGFkZGluZyk7dGhpcy5mcmFtZS5zdHlsZS5sZWZ0PXIrXCJweFwiLHRoaXMuZnJhbWUuc3R5bGUudG9wPXMrXCJweFwiLHRoaXMuZnJhbWUuc3R5bGUudmlzaWJpbGl0eT1cInZpc2libGVcIix0aGlzLmhpZGRlbj0hMX1lbHNlIHRoaXMuaGlkZSgpfX0se2tleTpcImhpZGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaGlkZGVuPSEwLHRoaXMuZnJhbWUuc3R5bGUubGVmdD1cIjBcIix0aGlzLmZyYW1lLnN0eWxlLnRvcD1cIjBcIix0aGlzLmZyYW1lLnN0eWxlLnZpc2liaWxpdHk9XCJoaWRkZW5cIn19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mcmFtZSl9fV0pLHR9KCksTWg9RWgsUGg9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7UG8odGhpcyx0KX1yZXR1cm4gSW8odCxudWxsLFt7a2V5OlwidmFsaWRhdGVcIix2YWx1ZTpmdW5jdGlvbihlLGksbyl7eGg9ITEsX2g9aTt2YXIgbj1pO3JldHVybiB2b2lkIDAhPT1vJiYobj1pW29dKSx0LnBhcnNlKGUsbixbXSkseGh9fSx7a2V5OlwicGFyc2VcIix2YWx1ZTpmdW5jdGlvbihlLGksbyl7Zm9yKHZhciBuIGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbikmJnQuY2hlY2sobixlLGksbyl9fSx7a2V5OlwiY2hlY2tcIix2YWx1ZTpmdW5jdGlvbihlLGksbyxuKXtpZih2b2lkIDAhPT1vW2VdfHx2b2lkIDAhPT1vLl9fYW55X18pe3ZhciByPWUscz0hMDt2b2lkIDA9PT1vW2VdJiZ2b2lkIDAhPT1vLl9fYW55X18mJihyPVwiX19hbnlfX1wiLHM9XCJvYmplY3RcIj09PXQuZ2V0VHlwZShpW2VdKSk7dmFyIGE9b1tyXTtzJiZ2b2lkIDAhPT1hLl9fdHlwZV9fJiYoYT1hLl9fdHlwZV9fKSx0LmNoZWNrRmllbGRzKGUsaSxvLHIsYSxuKX1lbHNlIHQuZ2V0U3VnZ2VzdGlvbihlLG8sbil9fSx7a2V5OlwiY2hlY2tGaWVsZHNcIix2YWx1ZTpmdW5jdGlvbihlLGksbyxuLHIscyl7dmFyIGE9ZnVuY3Rpb24oaSl7Y29uc29sZS5lcnJvcihcIiVjXCIraSt0LnByaW50TG9jYXRpb24ocyxlKSxFaCl9LGg9dC5nZXRUeXBlKGlbZV0pLGQ9cltoXTt2b2lkIDAhPT1kP1wiYXJyYXlcIj09PXQuZ2V0VHlwZShkKSYmLTE9PT1NcihkKS5jYWxsKGQsaVtlXSk/KGEoJ0ludmFsaWQgb3B0aW9uIGRldGVjdGVkIGluIFwiJytlKydcIi4gQWxsb3dlZCB2YWx1ZXMgYXJlOicrdC5wcmludChkKSsnIG5vdCBcIicraVtlXSsnXCIuICcpLHhoPSEwKTpcIm9iamVjdFwiPT09aCYmXCJfX2FueV9fXCIhPT1uJiYocz1laChzLGUpLHQucGFyc2UoaVtlXSxvW25dLHMpKTp2b2lkIDA9PT1yLmFueSYmKGEoJ0ludmFsaWQgdHlwZSByZWNlaXZlZCBmb3IgXCInK2UrJ1wiLiBFeHBlY3RlZDogJyt0LnByaW50KHhuKHIpKStcIi4gUmVjZWl2ZWQgW1wiK2grJ10gXCInK2lbZV0rJ1wiJykseGg9ITApfX0se2tleTpcImdldFR5cGVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1kbih0KTtyZXR1cm5cIm9iamVjdFwiPT09ZT9udWxsPT09dD9cIm51bGxcIjp0IGluc3RhbmNlb2YgQm9vbGVhbj9cImJvb2xlYW5cIjp0IGluc3RhbmNlb2YgTnVtYmVyP1wibnVtYmVyXCI6dCBpbnN0YW5jZW9mIFN0cmluZz9cInN0cmluZ1wiOmduKHQpP1wiYXJyYXlcIjp0IGluc3RhbmNlb2YgRGF0ZT9cImRhdGVcIjp2b2lkIDAhPT10Lm5vZGVUeXBlP1wiZG9tXCI6ITA9PT10Ll9pc0FNb21lbnRPYmplY3Q/XCJtb21lbnRcIjpcIm9iamVjdFwiOlwibnVtYmVyXCI9PT1lP1wibnVtYmVyXCI6XCJib29sZWFuXCI9PT1lP1wiYm9vbGVhblwiOlwic3RyaW5nXCI9PT1lP1wic3RyaW5nXCI6dm9pZCAwPT09ZT9cInVuZGVmaW5lZFwiOmV9fSx7a2V5OlwiZ2V0U3VnZ2VzdGlvblwiLHZhbHVlOmZ1bmN0aW9uKGUsaSxvKXt2YXIgbixyPXQuZmluZEluT3B0aW9ucyhlLGksbywhMSkscz10LmZpbmRJbk9wdGlvbnMoZSxfaCxbXSwhMCk7bj12b2lkIDAhPT1yLmluZGV4TWF0Y2g/XCIgaW4gXCIrdC5wcmludExvY2F0aW9uKHIucGF0aCxlLFwiXCIpKydQZXJoYXBzIGl0IHdhcyBpbmNvbXBsZXRlPyBEaWQgeW91IG1lYW46IFwiJytyLmluZGV4TWF0Y2grJ1wiP1xcblxcbic6cy5kaXN0YW5jZTw9NCYmci5kaXN0YW5jZT5zLmRpc3RhbmNlP1wiIGluIFwiK3QucHJpbnRMb2NhdGlvbihyLnBhdGgsZSxcIlwiKStcIlBlcmhhcHMgaXQgd2FzIG1pc3BsYWNlZD8gTWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGF0OiBcIit0LnByaW50TG9jYXRpb24ocy5wYXRoLHMuY2xvc2VzdE1hdGNoLFwiXCIpOnIuZGlzdGFuY2U8PTg/Jy4gRGlkIHlvdSBtZWFuIFwiJytyLmNsb3Nlc3RNYXRjaCsnXCI/Jyt0LnByaW50TG9jYXRpb24oci5wYXRoLGUpOlwiLiBEaWQgeW91IG1lYW4gb25lIG9mIHRoZXNlOiBcIit0LnByaW50KHhuKGkpKSt0LnByaW50TG9jYXRpb24obyxlKSxjb25zb2xlLmVycm9yKCclY1Vua25vd24gb3B0aW9uIGRldGVjdGVkOiBcIicrZSsnXCInK24sRWgpLHhoPSEwfX0se2tleTpcImZpbmRJbk9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbihlLGksbyl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10mJmFyZ3VtZW50c1szXSxyPTFlOSxzPVwiXCIsYT1bXSxoPWUudG9Mb3dlckNhc2UoKSxkPXZvaWQgMDtmb3IodmFyIGwgaW4gaSl7dmFyIGM9dm9pZCAwO2lmKHZvaWQgMCE9PWlbbF0uX190eXBlX18mJiEwPT09bil7dmFyIHU9dC5maW5kSW5PcHRpb25zKGUsaVtsXSxlaChvLGwpKTtyPnUuZGlzdGFuY2UmJihzPXUuY2xvc2VzdE1hdGNoLGE9dS5wYXRoLHI9dS5kaXN0YW5jZSxkPXUuaW5kZXhNYXRjaCl9ZWxzZXt2YXIgZjstMSE9PU1yKGY9bC50b0xvd2VyQ2FzZSgpKS5jYWxsKGYsaCkmJihkPWwpLHI+KGM9dC5sZXZlbnNodGVpbkRpc3RhbmNlKGUsbCkpJiYocz1sLGE9aWgobykscj1jKX19cmV0dXJue2Nsb3Nlc3RNYXRjaDpzLHBhdGg6YSxkaXN0YW5jZTpyLGluZGV4TWF0Y2g6ZH19fSx7a2V5OlwicHJpbnRMb2NhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpcIlByb2JsZW0gdmFsdWUgZm91bmQgYXQ6IFxcblwiLG89XCJcXG5cXG5cIitpK1wib3B0aW9ucyA9IHtcXG5cIixuPTA7bjx0Lmxlbmd0aDtuKyspe2Zvcih2YXIgcj0wO3I8bisxO3IrKylvKz1cIiAgXCI7bys9dFtuXStcIjoge1xcblwifWZvcih2YXIgcz0wO3M8dC5sZW5ndGgrMTtzKyspbys9XCIgIFwiO28rPWUrXCJcXG5cIjtmb3IodmFyIGE9MDthPHQubGVuZ3RoKzE7YSsrKXtmb3IodmFyIGg9MDtoPHQubGVuZ3RoLWE7aCsrKW8rPVwiICBcIjtvKz1cIn1cXG5cIn1yZXR1cm4gbytcIlxcblxcblwifX0se2tleTpcInByaW50XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIExyKHQpLnJlcGxhY2UoLyhcIil8KFxcWyl8KFxcXSl8KCxcIl9fdHlwZV9fXCIpL2csXCJcIikucmVwbGFjZSgvKCwpL2csXCIsIFwiKX19LHtrZXk6XCJsZXZlbnNodGVpbkRpc3RhbmNlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZigwPT09dC5sZW5ndGgpcmV0dXJuIGUubGVuZ3RoO2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gdC5sZW5ndGg7dmFyIGksbyxuPVtdO2ZvcihpPTA7aTw9ZS5sZW5ndGg7aSsrKW5baV09W2ldO2ZvcihvPTA7bzw9dC5sZW5ndGg7bysrKW5bMF1bb109bztmb3IoaT0xO2k8PWUubGVuZ3RoO2krKylmb3Iobz0xO288PXQubGVuZ3RoO28rKyllLmNoYXJBdChpLTEpPT10LmNoYXJBdChvLTEpP25baV1bb109bltpLTFdW28tMV06bltpXVtvXT1NYXRoLm1pbihuW2ktMV1bby0xXSsxLE1hdGgubWluKG5baV1bby0xXSsxLG5baS0xXVtvXSsxKSk7cmV0dXJuIG5bZS5sZW5ndGhdW3QubGVuZ3RoXX19XSksdH0oKTtmdW5jdGlvbiBEaCh0KXtyZXR1cm4gamg9dCxmdW5jdGlvbigpe3ZhciB0PXt9O0xoPTAsdm9pZChIaD1qaC5jaGFyQXQoMCkpLFpoKCksXCJzdHJpY3RcIj09PVdoJiYodC5zdHJpY3Q9ITAsWmgoKSk7XCJncmFwaFwiIT09V2gmJlwiZGlncmFwaFwiIT09V2h8fCh0LnR5cGU9V2gsWmgoKSk7Vmg9PT1OaCYmKHQuaWQ9V2gsWmgoKSk7aWYoXCJ7XCIhPVdoKXRocm93IG5kKFwiQW5nbGUgYnJhY2tldCB7IGV4cGVjdGVkXCIpO2lmKFpoKCksSmgodCksXCJ9XCIhPVdoKXRocm93IG5kKFwiQW5nbGUgYnJhY2tldCB9IGV4cGVjdGVkXCIpO2lmKFpoKCksXCJcIiE9PVdoKXRocm93IG5kKFwiRW5kIG9mIGZpbGUgZXhwZWN0ZWRcIik7cmV0dXJuIFpoKCksZGVsZXRlIHQubm9kZSxkZWxldGUgdC5lZGdlLGRlbGV0ZSB0LmdyYXBoLHR9KCl9dmFyIEJoPXtmb250c2l6ZTpcImZvbnQuc2l6ZVwiLGZvbnRjb2xvcjpcImZvbnQuY29sb3JcIixsYWJlbGZvbnRjb2xvcjpcImZvbnQuY29sb3JcIixmb250bmFtZTpcImZvbnQuZmFjZVwiLGNvbG9yOltcImNvbG9yLmJvcmRlclwiLFwiY29sb3IuYmFja2dyb3VuZFwiXSxmaWxsY29sb3I6XCJjb2xvci5iYWNrZ3JvdW5kXCIsdG9vbHRpcDpcInRpdGxlXCIsbGFiZWx0b29sdGlwOlwidGl0bGVcIn0sSWg9SXIoQmgpO0loLmNvbG9yPVwiY29sb3IuY29sb3JcIixJaC5zdHlsZT1cImRhc2hlc1wiO3ZhciB6aD0wLEZoPTEsTmg9MixBaD0zLFJoPXtcIntcIjohMCxcIn1cIjohMCxcIltcIjohMCxcIl1cIjohMCxcIjtcIjohMCxcIj1cIjohMCxcIixcIjohMCxcIi0+XCI6ITAsXCItLVwiOiEwfSxqaD1cIlwiLExoPTAsSGg9XCJcIixXaD1cIlwiLFZoPXpoO2Z1bmN0aW9uIHFoKCl7TGgrKyxIaD1qaC5jaGFyQXQoTGgpfWZ1bmN0aW9uIFVoKCl7cmV0dXJuIGpoLmNoYXJBdChMaCsxKX1mdW5jdGlvbiBZaCh0KXt2YXIgZT10LmNoYXJDb2RlQXQoMCk7cmV0dXJuIGU8NDc/MzU9PT1lfHw0Nj09PWU6ZTw1OT9lPjQ3OmU8OTE/ZT42NDplPDk2Pzk1PT09ZTplPDEyMyYmZT45Nn1mdW5jdGlvbiBYaCh0LGUpe2lmKHR8fCh0PXt9KSxlKWZvcih2YXIgaSBpbiBlKWUuaGFzT3duUHJvcGVydHkoaSkmJih0W2ldPWVbaV0pO3JldHVybiB0fWZ1bmN0aW9uIEdoKHQsZSxpKXtmb3IodmFyIG89ZS5zcGxpdChcIi5cIiksbj10O28ubGVuZ3RoOyl7dmFyIHI9by5zaGlmdCgpO28ubGVuZ3RoPyhuW3JdfHwobltyXT17fSksbj1uW3JdKTpuW3JdPWl9fWZ1bmN0aW9uIEtoKHQsZSl7Zm9yKHZhciBpLG8sbj1udWxsLHI9W3RdLHM9dDtzLnBhcmVudDspci5wdXNoKHMucGFyZW50KSxzPXMucGFyZW50O2lmKHMubm9kZXMpZm9yKGk9MCxvPXMubm9kZXMubGVuZ3RoO2k8bztpKyspaWYoZS5pZD09PXMubm9kZXNbaV0uaWQpe249cy5ub2Rlc1tpXTticmVha31mb3Iobnx8KG49e2lkOmUuaWR9LHQubm9kZSYmKG4uYXR0cj1YaChuLmF0dHIsdC5ub2RlKSkpLGk9ci5sZW5ndGgtMTtpPj0wO2ktLSl7dmFyIGEsaD1yW2ldO2gubm9kZXN8fChoLm5vZGVzPVtdKSwtMT09PU1yKGE9aC5ub2RlcykuY2FsbChhLG4pJiZoLm5vZGVzLnB1c2gobil9ZS5hdHRyJiYobi5hdHRyPVhoKG4uYXR0cixlLmF0dHIpKX1mdW5jdGlvbiAkaCh0LGUpe2lmKHQuZWRnZXN8fCh0LmVkZ2VzPVtdKSx0LmVkZ2VzLnB1c2goZSksdC5lZGdlKXt2YXIgaT1YaCh7fSx0LmVkZ2UpO2UuYXR0cj1YaChpLGUuYXR0cil9fWZ1bmN0aW9uIFFoKHQsZSxpLG8sbil7dmFyIHI9e2Zyb206ZSx0bzppLHR5cGU6b307cmV0dXJuIHQuZWRnZSYmKHIuYXR0cj1YaCh7fSx0LmVkZ2UpKSxyLmF0dHI9WGgoci5hdHRyfHx7fSxuKSxudWxsIT1uJiZuLmhhc093blByb3BlcnR5KFwiYXJyb3dzXCIpJiZudWxsIT1uLmFycm93cyYmKHIuYXJyb3dzPXt0bzp7ZW5hYmxlZDohMCx0eXBlOm4uYXJyb3dzLnR5cGV9fSxuLmFycm93cz1udWxsKSxyfWZ1bmN0aW9uIFpoKCl7Zm9yKFZoPXpoLFdoPVwiXCI7XCIgXCI9PT1IaHx8XCJcXHRcIj09PUhofHxcIlxcblwiPT09SGh8fFwiXFxyXCI9PT1IaDspcWgoKTtkb3t2YXIgdD0hMTtpZihcIiNcIj09PUhoKXtmb3IodmFyIGU9TGgtMTtcIiBcIj09PWpoLmNoYXJBdChlKXx8XCJcXHRcIj09PWpoLmNoYXJBdChlKTspZS0tO2lmKFwiXFxuXCI9PT1qaC5jaGFyQXQoZSl8fFwiXCI9PT1qaC5jaGFyQXQoZSkpe2Zvcig7XCJcIiE9SGgmJlwiXFxuXCIhPUhoOylxaCgpO3Q9ITB9fWlmKFwiL1wiPT09SGgmJlwiL1wiPT09VWgoKSl7Zm9yKDtcIlwiIT1IaCYmXCJcXG5cIiE9SGg7KXFoKCk7dD0hMH1pZihcIi9cIj09PUhoJiZcIipcIj09PVVoKCkpe2Zvcig7XCJcIiE9SGg7KXtpZihcIipcIj09PUhoJiZcIi9cIj09PVVoKCkpe3FoKCkscWgoKTticmVha31xaCgpfXQ9ITB9Zm9yKDtcIiBcIj09PUhofHxcIlxcdFwiPT09SGh8fFwiXFxuXCI9PT1IaHx8XCJcXHJcIj09PUhoOylxaCgpfXdoaWxlKHQpO2lmKFwiXCIhPT1IaCl7dmFyIGk9SGgrVWgoKTtpZihSaFtpXSlyZXR1cm4gVmg9RmgsV2g9aSxxaCgpLHZvaWQgcWgoKTtpZihSaFtIaF0pcmV0dXJuIFZoPUZoLFdoPUhoLHZvaWQgcWgoKTtpZihZaChIaCl8fFwiLVwiPT09SGgpe2ZvcihXaCs9SGgscWgoKTtZaChIaCk7KVdoKz1IaCxxaCgpO3JldHVyblwiZmFsc2VcIj09PVdoP1doPSExOlwidHJ1ZVwiPT09V2g/V2g9ITA6aXNOYU4oTnVtYmVyKFdoKSl8fChXaD1OdW1iZXIoV2gpKSx2b2lkKFZoPU5oKX1pZignXCInPT09SGgpe2ZvcihxaCgpO1wiXCIhPUhoJiYoJ1wiJyE9SGh8fCdcIic9PT1IaCYmJ1wiJz09PVVoKCkpOyknXCInPT09SGg/KFdoKz1IaCxxaCgpKTpcIlxcXFxcIj09PUhoJiZcIm5cIj09PVVoKCk/KFdoKz1cIlxcblwiLHFoKCkpOldoKz1IaCxxaCgpO2lmKCdcIichPUhoKXRocm93IG5kKCdFbmQgb2Ygc3RyaW5nIFwiIGV4cGVjdGVkJyk7cmV0dXJuIHFoKCksdm9pZChWaD1OaCl9Zm9yKFZoPUFoO1wiXCIhPUhoOylXaCs9SGgscWgoKTt0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1N5bnRheCBlcnJvciBpbiBwYXJ0IFwiJytyZChXaCwzMCkrJ1wiJyl9Vmg9Rmh9ZnVuY3Rpb24gSmgodCl7Zm9yKDtcIlwiIT09V2gmJlwifVwiIT1XaDspdGQodCksXCI7XCI9PT1XaCYmWmgoKX1mdW5jdGlvbiB0ZCh0KXt2YXIgZT1lZCh0KTtpZihlKWlkKHQsZSk7ZWxzZSBpZighZnVuY3Rpb24odCl7aWYoXCJub2RlXCI9PT1XaClyZXR1cm4gWmgoKSx0Lm5vZGU9b2QoKSxcIm5vZGVcIjtpZihcImVkZ2VcIj09PVdoKXJldHVybiBaaCgpLHQuZWRnZT1vZCgpLFwiZWRnZVwiO2lmKFwiZ3JhcGhcIj09PVdoKXJldHVybiBaaCgpLHQuZ3JhcGg9b2QoKSxcImdyYXBoXCI7cmV0dXJuIG51bGx9KHQpKXtpZihWaCE9TmgpdGhyb3cgbmQoXCJJZGVudGlmaWVyIGV4cGVjdGVkXCIpO3ZhciBpPVdoO2lmKFpoKCksXCI9XCI9PT1XaCl7aWYoWmgoKSxWaCE9TmgpdGhyb3cgbmQoXCJJZGVudGlmaWVyIGV4cGVjdGVkXCIpO3RbaV09V2gsWmgoKX1lbHNlIWZ1bmN0aW9uKHQsZSl7dmFyIGk9e2lkOmV9LG89b2QoKTtvJiYoaS5hdHRyPW8pO0toKHQsaSksaWQodCxlKX0odCxpKX19ZnVuY3Rpb24gZWQodCl7dmFyIGU9bnVsbDtpZihcInN1YmdyYXBoXCI9PT1XaCYmKChlPXt9KS50eXBlPVwic3ViZ3JhcGhcIixaaCgpLFZoPT09TmgmJihlLmlkPVdoLFpoKCkpKSxcIntcIj09PVdoKXtpZihaaCgpLGV8fChlPXt9KSxlLnBhcmVudD10LGUubm9kZT10Lm5vZGUsZS5lZGdlPXQuZWRnZSxlLmdyYXBoPXQuZ3JhcGgsSmgoZSksXCJ9XCIhPVdoKXRocm93IG5kKFwiQW5nbGUgYnJhY2tldCB9IGV4cGVjdGVkXCIpO1poKCksZGVsZXRlIGUubm9kZSxkZWxldGUgZS5lZGdlLGRlbGV0ZSBlLmdyYXBoLGRlbGV0ZSBlLnBhcmVudCx0LnN1YmdyYXBoc3x8KHQuc3ViZ3JhcGhzPVtdKSx0LnN1YmdyYXBocy5wdXNoKGUpfXJldHVybiBlfWZ1bmN0aW9uIGlkKHQsZSl7Zm9yKDtcIi0+XCI9PT1XaHx8XCItLVwiPT09V2g7KXt2YXIgaSxvPVdoO1poKCk7dmFyIG49ZWQodCk7aWYobilpPW47ZWxzZXtpZihWaCE9TmgpdGhyb3cgbmQoXCJJZGVudGlmaWVyIG9yIHN1YmdyYXBoIGV4cGVjdGVkXCIpO0toKHQse2lkOmk9V2h9KSxaaCgpfSRoKHQsUWgodCxlLGksbyxvZCgpKSksZT1pfX1mdW5jdGlvbiBvZCgpe2Zvcih2YXIgdCxlLGk9bnVsbCxvPXtkYXNoZWQ6ITAsc29saWQ6ITEsZG90dGVkOlsxLDVdfSxuPXtkb3Q6XCJjaXJjbGVcIixib3g6XCJib3hcIixjcm93OlwiY3Jvd1wiLGN1cnZlOlwiY3VydmVcIixpY3VydmU6XCJpbnZfY3VydmVcIixub3JtYWw6XCJ0cmlhbmdsZVwiLGludjpcImludl90cmlhbmdsZVwiLGRpYW1vbmQ6XCJkaWFtb25kXCIsdGVlOlwiYmFyXCIsdmVlOlwidmVlXCJ9LHI9bmV3IEFycmF5LHM9bmV3IEFycmF5O1wiW1wiPT09V2g7KXtmb3IoWmgoKSxpPXt9O1wiXCIhPT1XaCYmXCJdXCIhPVdoOyl7aWYoVmghPU5oKXRocm93IG5kKFwiQXR0cmlidXRlIG5hbWUgZXhwZWN0ZWRcIik7dmFyIGE9V2g7aWYoWmgoKSxcIj1cIiE9V2gpdGhyb3cgbmQoXCJFcXVhbCBzaWduID0gZXhwZWN0ZWRcIik7aWYoWmgoKSxWaCE9TmgpdGhyb3cgbmQoXCJBdHRyaWJ1dGUgdmFsdWUgZXhwZWN0ZWRcIik7dmFyIGg9V2g7XCJzdHlsZVwiPT09YSYmKGg9b1toXSksXCJhcnJvd2hlYWRcIj09PWEmJihhPVwiYXJyb3dzXCIsaD17dG86e2VuYWJsZWQ6ITAsdHlwZTpuW2hdfX0pLFwiYXJyb3d0YWlsXCI9PT1hJiYoYT1cImFycm93c1wiLGg9e2Zyb206e2VuYWJsZWQ6ITAsdHlwZTpuW2hdfX0pLHIucHVzaCh7YXR0cjppLG5hbWU6YSx2YWx1ZTpofSkscy5wdXNoKGEpLFpoKCksXCIsXCI9PVdoJiZaaCgpfWlmKFwiXVwiIT1XaCl0aHJvdyBuZChcIkJyYWNrZXQgXSBleHBlY3RlZFwiKTtaaCgpfWlmKEpuKHMpLmNhbGwocyxcImRpclwiKSl7dmFyIGQ9e2Fycm93czp7fX07Zm9yKHQ9MDt0PHIubGVuZ3RoO3QrKylpZihcImFycm93c1wiPT09clt0XS5uYW1lKWlmKG51bGwhPXJbdF0udmFsdWUudG8pZC5hcnJvd3MudG89dDtlbHNle2lmKG51bGw9PXJbdF0udmFsdWUuZnJvbSl0aHJvdyBuZChcIkludmFsaWQgdmFsdWUgb2YgYXJyb3dzXCIpO2QuYXJyb3dzLmZyb209dH1lbHNlXCJkaXJcIj09PXJbdF0ubmFtZSYmKGQuZGlyPXQpO3ZhciBsLGMsdT1yW2QuZGlyXS52YWx1ZTtpZighSm4ocykuY2FsbChzLFwiYXJyb3dzXCIpKWlmKFwiYm90aFwiPT09dSlyLnB1c2goe2F0dHI6cltkLmRpcl0uYXR0cixuYW1lOlwiYXJyb3dzXCIsdmFsdWU6e3RvOntlbmFibGVkOiEwfX19KSxkLmFycm93cy50bz1yLmxlbmd0aC0xLHIucHVzaCh7YXR0cjpyW2QuZGlyXS5hdHRyLG5hbWU6XCJhcnJvd3NcIix2YWx1ZTp7ZnJvbTp7ZW5hYmxlZDohMH19fSksZC5hcnJvd3MuZnJvbT1yLmxlbmd0aC0xO2Vsc2UgaWYoXCJmb3J3YXJkXCI9PT11KXIucHVzaCh7YXR0cjpyW2QuZGlyXS5hdHRyLG5hbWU6XCJhcnJvd3NcIix2YWx1ZTp7dG86e2VuYWJsZWQ6ITB9fX0pLGQuYXJyb3dzLnRvPXIubGVuZ3RoLTE7ZWxzZSBpZihcImJhY2tcIj09PXUpci5wdXNoKHthdHRyOnJbZC5kaXJdLmF0dHIsbmFtZTpcImFycm93c1wiLHZhbHVlOntmcm9tOntlbmFibGVkOiEwfX19KSxkLmFycm93cy5mcm9tPXIubGVuZ3RoLTE7ZWxzZXtpZihcIm5vbmVcIiE9PXUpdGhyb3cgbmQoJ0ludmFsaWQgZGlyIHR5cGUgXCInK3UrJ1wiJyk7ci5wdXNoKHthdHRyOnJbZC5kaXJdLmF0dHIsbmFtZTpcImFycm93c1wiLHZhbHVlOlwiXCJ9KSxkLmFycm93cy50bz1yLmxlbmd0aC0xfWlmKFwiYm90aFwiPT09dSlkLmFycm93cy50byYmZC5hcnJvd3MuZnJvbT8oYz1yW2QuYXJyb3dzLnRvXS52YWx1ZS50by50eXBlLGw9cltkLmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGUscltkLmFycm93cy50b109e2F0dHI6cltkLmFycm93cy50b10uYXR0cixuYW1lOnJbZC5hcnJvd3MudG9dLm5hbWUsdmFsdWU6e3RvOntlbmFibGVkOiEwLHR5cGU6Y30sZnJvbTp7ZW5hYmxlZDohMCx0eXBlOmx9fX0scW4ocikuY2FsbChyLGQuYXJyb3dzLmZyb20sMSkpOmQuYXJyb3dzLnRvPyhjPXJbZC5hcnJvd3MudG9dLnZhbHVlLnRvLnR5cGUsbD1cImFycm93XCIscltkLmFycm93cy50b109e2F0dHI6cltkLmFycm93cy50b10uYXR0cixuYW1lOnJbZC5hcnJvd3MudG9dLm5hbWUsdmFsdWU6e3RvOntlbmFibGVkOiEwLHR5cGU6Y30sZnJvbTp7ZW5hYmxlZDohMCx0eXBlOmx9fX0pOmQuYXJyb3dzLmZyb20mJihjPVwiYXJyb3dcIixsPXJbZC5hcnJvd3MuZnJvbV0udmFsdWUuZnJvbS50eXBlLHJbZC5hcnJvd3MuZnJvbV09e2F0dHI6cltkLmFycm93cy5mcm9tXS5hdHRyLG5hbWU6cltkLmFycm93cy5mcm9tXS5uYW1lLHZhbHVlOnt0bzp7ZW5hYmxlZDohMCx0eXBlOmN9LGZyb206e2VuYWJsZWQ6ITAsdHlwZTpsfX19KTtlbHNlIGlmKFwiYmFja1wiPT09dSlkLmFycm93cy50byYmZC5hcnJvd3MuZnJvbT8oYz1cIlwiLGw9cltkLmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGUscltkLmFycm93cy5mcm9tXT17YXR0cjpyW2QuYXJyb3dzLmZyb21dLmF0dHIsbmFtZTpyW2QuYXJyb3dzLmZyb21dLm5hbWUsdmFsdWU6e3RvOntlbmFibGVkOiEwLHR5cGU6Y30sZnJvbTp7ZW5hYmxlZDohMCx0eXBlOmx9fX0pOmQuYXJyb3dzLnRvPyhjPVwiXCIsbD1cImFycm93XCIsZC5hcnJvd3MuZnJvbT1kLmFycm93cy50byxyW2QuYXJyb3dzLmZyb21dPXthdHRyOnJbZC5hcnJvd3MuZnJvbV0uYXR0cixuYW1lOnJbZC5hcnJvd3MuZnJvbV0ubmFtZSx2YWx1ZTp7dG86e2VuYWJsZWQ6ITAsdHlwZTpjfSxmcm9tOntlbmFibGVkOiEwLHR5cGU6bH19fSk6ZC5hcnJvd3MuZnJvbSYmKGM9XCJcIixsPXJbZC5hcnJvd3MuZnJvbV0udmFsdWUuZnJvbS50eXBlLHJbZC5hcnJvd3MudG9dPXthdHRyOnJbZC5hcnJvd3MuZnJvbV0uYXR0cixuYW1lOnJbZC5hcnJvd3MuZnJvbV0ubmFtZSx2YWx1ZTp7dG86e2VuYWJsZWQ6ITAsdHlwZTpjfSxmcm9tOntlbmFibGVkOiEwLHR5cGU6bH19fSkscltkLmFycm93cy5mcm9tXT17YXR0cjpyW2QuYXJyb3dzLmZyb21dLmF0dHIsbmFtZTpyW2QuYXJyb3dzLmZyb21dLm5hbWUsdmFsdWU6e2Zyb206e2VuYWJsZWQ6ITAsdHlwZTpyW2QuYXJyb3dzLmZyb21dLnZhbHVlLmZyb20udHlwZX19fTtlbHNlIGlmKFwibm9uZVwiPT09dSl7dmFyIGY7cltmPWQuYXJyb3dzLnRvP2QuYXJyb3dzLnRvOmQuYXJyb3dzLmZyb21dPXthdHRyOnJbZl0uYXR0cixuYW1lOnJbZl0ubmFtZSx2YWx1ZTpcIlwifX1lbHNle2lmKFwiZm9yd2FyZFwiIT09dSl0aHJvdyBuZCgnSW52YWxpZCBkaXIgdHlwZSBcIicrdSsnXCInKTtkLmFycm93cy50byYmZC5hcnJvd3MuZnJvbXx8ZC5hcnJvd3MudG8/KGM9cltkLmFycm93cy50b10udmFsdWUudG8udHlwZSxsPVwiXCIscltkLmFycm93cy50b109e2F0dHI6cltkLmFycm93cy50b10uYXR0cixuYW1lOnJbZC5hcnJvd3MudG9dLm5hbWUsdmFsdWU6e3RvOntlbmFibGVkOiEwLHR5cGU6Y30sZnJvbTp7ZW5hYmxlZDohMCx0eXBlOmx9fX0pOmQuYXJyb3dzLmZyb20mJihjPVwiYXJyb3dcIixsPVwiXCIsZC5hcnJvd3MudG89ZC5hcnJvd3MuZnJvbSxyW2QuYXJyb3dzLnRvXT17YXR0cjpyW2QuYXJyb3dzLnRvXS5hdHRyLG5hbWU6cltkLmFycm93cy50b10ubmFtZSx2YWx1ZTp7dG86e2VuYWJsZWQ6ITAsdHlwZTpjfSxmcm9tOntlbmFibGVkOiEwLHR5cGU6bH19fSkscltkLmFycm93cy50b109e2F0dHI6cltkLmFycm93cy50b10uYXR0cixuYW1lOnJbZC5hcnJvd3MudG9dLm5hbWUsdmFsdWU6e3RvOntlbmFibGVkOiEwLHR5cGU6cltkLmFycm93cy50b10udmFsdWUudG8udHlwZX19fX1xbihyKS5jYWxsKHIsZC5kaXIsMSl9aWYoSm4ocykuY2FsbChzLFwicGVud2lkdGhcIikpe3ZhciBwPVtdO2ZvcihlPXIubGVuZ3RoLHQ9MDt0PGU7dCsrKVwid2lkdGhcIiE9PXJbdF0ubmFtZSYmKFwicGVud2lkdGhcIj09PXJbdF0ubmFtZSYmKHJbdF0ubmFtZT1cIndpZHRoXCIpLHAucHVzaChyW3RdKSk7cj1wfWZvcihlPXIubGVuZ3RoLHQ9MDt0PGU7dCsrKUdoKHJbdF0uYXR0cixyW3RdLm5hbWUsclt0XS52YWx1ZSk7cmV0dXJuIGl9ZnVuY3Rpb24gbmQodCl7cmV0dXJuIG5ldyBTeW50YXhFcnJvcih0KycsIGdvdCBcIicrcmQoV2gsMzApKydcIiAoY2hhciAnK0xoK1wiKVwiKX1mdW5jdGlvbiByZCh0LGUpe3JldHVybiB0Lmxlbmd0aDw9ZT90OnQuc3Vic3RyKDAsMjcpK1wiLi4uXCJ9ZnVuY3Rpb24gc2QodCxlLGkpe2Zvcih2YXIgbz1lLnNwbGl0KFwiLlwiKSxuPW8ucG9wKCkscj10LHM9MDtzPG8ubGVuZ3RoO3MrKyl7dmFyIGE9b1tzXTthIGluIHJ8fChyW2FdPXt9KSxyPXJbYV19cmV0dXJuIHJbbl09aSx0fWZ1bmN0aW9uIGFkKHQsZSl7dmFyIGk9e307Zm9yKHZhciBvIGluIHQpaWYodC5oYXNPd25Qcm9wZXJ0eShvKSl7dmFyIG49ZVtvXTtnbihuKT9EbihuKS5jYWxsKG4sKGZ1bmN0aW9uKGUpe3NkKGksZSx0W29dKX0pKTpzZChpLFwic3RyaW5nXCI9PXR5cGVvZiBuP246byx0W29dKX1yZXR1cm4gaX1mdW5jdGlvbiBoZCh0KXt2YXIgZSxpPURoKHQpLG89e25vZGVzOltdLGVkZ2VzOltdLG9wdGlvbnM6e319O2kubm9kZXMmJkRuKGU9aS5ub2RlcykuY2FsbChlLChmdW5jdGlvbih0KXt2YXIgZT17aWQ6dC5pZCxsYWJlbDpTdHJpbmcodC5sYWJlbHx8dC5pZCl9O1hoKGUsYWQodC5hdHRyLEJoKSksZS5pbWFnZSYmKGUuc2hhcGU9XCJpbWFnZVwiKSxvLm5vZGVzLnB1c2goZSl9KSk7aWYoaS5lZGdlcyl7dmFyIG4scj1mdW5jdGlvbih0KXt2YXIgZT17ZnJvbTp0LmZyb20sdG86dC50b307cmV0dXJuIFhoKGUsYWQodC5hdHRyLEloKSksbnVsbD09ZS5hcnJvd3MmJlwiLT5cIj09PXQudHlwZSYmKGUuYXJyb3dzPVwidG9cIiksZX07RG4obj1pLmVkZ2VzKS5jYWxsKG4sKGZ1bmN0aW9uKHQpe3ZhciBlLGksbixzLGEsaCxkOyhlPXQuZnJvbSBpbnN0YW5jZW9mIE9iamVjdD90LmZyb20ubm9kZXM6e2lkOnQuZnJvbX0saT10LnRvIGluc3RhbmNlb2YgT2JqZWN0P3QudG8ubm9kZXM6e2lkOnQudG99LHQuZnJvbSBpbnN0YW5jZW9mIE9iamVjdCYmdC5mcm9tLmVkZ2VzKSYmRG4obj10LmZyb20uZWRnZXMpLmNhbGwobiwoZnVuY3Rpb24odCl7dmFyIGU9cih0KTtvLmVkZ2VzLnB1c2goZSl9KSk7KGE9aSxoPWZ1bmN0aW9uKGUsaSl7dmFyIG49UWgobyxlLmlkLGkuaWQsdC50eXBlLHQuYXR0cikscz1yKG4pO28uZWRnZXMucHVzaChzKX0sZ24ocz1lKT9EbihzKS5jYWxsKHMsKGZ1bmN0aW9uKHQpe2duKGEpP0RuKGEpLmNhbGwoYSwoZnVuY3Rpb24oZSl7aCh0LGUpfSkpOmgodCxhKX0pKTpnbihhKT9EbihhKS5jYWxsKGEsKGZ1bmN0aW9uKHQpe2gocyx0KX0pKTpoKHMsYSksdC50byBpbnN0YW5jZW9mIE9iamVjdCYmdC50by5lZGdlcykmJkRuKGQ9dC50by5lZGdlcykuY2FsbChkLChmdW5jdGlvbih0KXt2YXIgZT1yKHQpO28uZWRnZXMucHVzaChlKX0pKX0pKX1yZXR1cm4gaS5hdHRyJiYoby5vcHRpb25zPWkuYXR0ciksb312YXIgZGQ9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwscGFyc2VET1Q6RGgsRE9UVG9HcmFwaDpoZH0pO2Z1bmN0aW9uIGxkKHQsZSl7dmFyIGksbz17ZWRnZXM6e2luaGVyaXRDb2xvcjohMX0sbm9kZXM6e2ZpeGVkOiExLHBhcnNlQ29sb3I6ITF9fTtudWxsIT1lJiYobnVsbCE9ZS5maXhlZCYmKG8ubm9kZXMuZml4ZWQ9ZS5maXhlZCksbnVsbCE9ZS5wYXJzZUNvbG9yJiYoby5ub2Rlcy5wYXJzZUNvbG9yPWUucGFyc2VDb2xvciksbnVsbCE9ZS5pbmhlcml0Q29sb3ImJihvLmVkZ2VzLmluaGVyaXRDb2xvcj1lLmluaGVyaXRDb2xvcikpO3ZhciBuPXQuZWRnZXMscj1rbihuKS5jYWxsKG4sKGZ1bmN0aW9uKHQpe3ZhciBlPXtmcm9tOnQuc291cmNlLGlkOnQuaWQsdG86dC50YXJnZXR9O3JldHVybiBudWxsIT10LmF0dHJpYnV0ZXMmJihlLmF0dHJpYnV0ZXM9dC5hdHRyaWJ1dGVzKSxudWxsIT10LmxhYmVsJiYoZS5sYWJlbD10LmxhYmVsKSxudWxsIT10LmF0dHJpYnV0ZXMmJm51bGwhPXQuYXR0cmlidXRlcy50aXRsZSYmKGUudGl0bGU9dC5hdHRyaWJ1dGVzLnRpdGxlKSxcIkRpcmVjdGVkXCI9PT10LnR5cGUmJihlLmFycm93cz1cInRvXCIpLHQuY29sb3ImJiExPT09by5lZGdlcy5pbmhlcml0Q29sb3ImJihlLmNvbG9yPXQuY29sb3IpLGV9KSk7cmV0dXJue25vZGVzOmtuKGk9dC5ub2RlcykuY2FsbChpLChmdW5jdGlvbih0KXt2YXIgZT17aWQ6dC5pZCxmaXhlZDpvLm5vZGVzLmZpeGVkJiZudWxsIT10LngmJm51bGwhPXQueX07cmV0dXJuIG51bGwhPXQuYXR0cmlidXRlcyYmKGUuYXR0cmlidXRlcz10LmF0dHJpYnV0ZXMpLG51bGwhPXQubGFiZWwmJihlLmxhYmVsPXQubGFiZWwpLG51bGwhPXQuc2l6ZSYmKGUuc2l6ZT10LnNpemUpLG51bGwhPXQuYXR0cmlidXRlcyYmbnVsbCE9dC5hdHRyaWJ1dGVzLnRpdGxlJiYoZS50aXRsZT10LmF0dHJpYnV0ZXMudGl0bGUpLG51bGwhPXQudGl0bGUmJihlLnRpdGxlPXQudGl0bGUpLG51bGwhPXQueCYmKGUueD10LngpLG51bGwhPXQueSYmKGUueT10LnkpLG51bGwhPXQuY29sb3ImJighMD09PW8ubm9kZXMucGFyc2VDb2xvcj9lLmNvbG9yPXQuY29sb3I6ZS5jb2xvcj17YmFja2dyb3VuZDp0LmNvbG9yLGJvcmRlcjp0LmNvbG9yLGhpZ2hsaWdodDp7YmFja2dyb3VuZDp0LmNvbG9yLGJvcmRlcjp0LmNvbG9yfSxob3Zlcjp7YmFja2dyb3VuZDp0LmNvbG9yLGJvcmRlcjp0LmNvbG9yfX0pLGV9KSksZWRnZXM6cn19dmFyIGNkPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLHBhcnNlR2VwaGk6bGR9KSx1ZD1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxlbjp7YWRkRGVzY3JpcHRpb246XCJDbGljayBpbiBhbiBlbXB0eSBzcGFjZSB0byBwbGFjZSBhIG5ldyBub2RlLlwiLGFkZEVkZ2U6XCJBZGQgRWRnZVwiLGFkZE5vZGU6XCJBZGQgTm9kZVwiLGJhY2s6XCJCYWNrXCIsY2xvc2U6XCJDbG9zZVwiLGNyZWF0ZUVkZ2VFcnJvcjpcIkNhbm5vdCBsaW5rIGVkZ2VzIHRvIGEgY2x1c3Rlci5cIixkZWw6XCJEZWxldGUgc2VsZWN0ZWRcIixkZWxldGVDbHVzdGVyRXJyb3I6XCJDbHVzdGVycyBjYW5ub3QgYmUgZGVsZXRlZC5cIixlZGdlRGVzY3JpcHRpb246XCJDbGljayBvbiBhIG5vZGUgYW5kIGRyYWcgdGhlIGVkZ2UgdG8gYW5vdGhlciBub2RlIHRvIGNvbm5lY3QgdGhlbS5cIixlZGl0OlwiRWRpdFwiLGVkaXRDbHVzdGVyRXJyb3I6XCJDbHVzdGVycyBjYW5ub3QgYmUgZWRpdGVkLlwiLGVkaXRFZGdlOlwiRWRpdCBFZGdlXCIsZWRpdEVkZ2VEZXNjcmlwdGlvbjpcIkNsaWNrIG9uIHRoZSBjb250cm9sIHBvaW50cyBhbmQgZHJhZyB0aGVtIHRvIGEgbm9kZSB0byBjb25uZWN0IHRvIGl0LlwiLGVkaXROb2RlOlwiRWRpdCBOb2RlXCJ9LGRlOnthZGREZXNjcmlwdGlvbjpcIktsaWNrZSBhdWYgZWluZSBmcmVpZSBTdGVsbGUsIHVtIGVpbmVuIG5ldWVuIEtub3RlbiB6dSBwbGF6aWVyZW4uXCIsYWRkRWRnZTpcIkthbnRlIGhpbnp1ZsO8Z2VuXCIsYWRkTm9kZTpcIktub3RlbiBoaW56dWbDvGdlblwiLGJhY2s6XCJadXLDvGNrXCIsY2xvc2U6XCJTY2hsaWXDn2VuXCIsY3JlYXRlRWRnZUVycm9yOlwiRXMgaXN0IG5pY2h0IG3DtmdsaWNoLCBLYW50ZW4gbWl0IENsdXN0ZXJuIHp1IHZlcmJpbmRlbi5cIixkZWw6XCJMw7ZzY2hlIEF1c3dhaGxcIixkZWxldGVDbHVzdGVyRXJyb3I6XCJDbHVzdGVyIGvDtm5uZW4gbmljaHQgZ2Vsw7ZzY2h0IHdlcmRlbi5cIixlZGdlRGVzY3JpcHRpb246XCJLbGlja2UgYXVmIGVpbmVuIEtub3RlbiB1bmQgemllaGUgZGllIEthbnRlIHp1IGVpbmVtIGFuZGVyZW4gS25vdGVuLCB1bSBkaWVzZSB6dSB2ZXJiaW5kZW4uXCIsZWRpdDpcIkVkaXRpZXJlblwiLGVkaXRDbHVzdGVyRXJyb3I6XCJDbHVzdGVyIGvDtm5uZW4gbmljaHQgZWRpdGllcnQgd2VyZGVuLlwiLGVkaXRFZGdlOlwiS2FudGUgZWRpdGllcmVuXCIsZWRpdEVkZ2VEZXNjcmlwdGlvbjpcIktsaWNrZSBhdWYgZGllIFZlcmJpbmR1bmdzcHVua3RlIHVuZCB6aWVoZSBkaWVzZSBhdWYgZWluZW4gS25vdGVuLCB1bSBzaWUgenUgdmVyYmluZGVuLlwiLGVkaXROb2RlOlwiS25vdGVuIGVkaXRpZXJlblwifSxlczp7YWRkRGVzY3JpcHRpb246XCJIYWdhIGNsaWMgZW4gdW4gbHVnYXIgdmFjw61vIHBhcmEgY29sb2NhciB1biBudWV2byBub2RvLlwiLGFkZEVkZ2U6XCJBw7FhZGlyIGFyaXN0YVwiLGFkZE5vZGU6XCJBw7FhZGlyIG5vZG9cIixiYWNrOlwiQXRyw6FzXCIsY2xvc2U6XCJDZXJyYXJcIixjcmVhdGVFZGdlRXJyb3I6XCJObyBzZSBwdWVkZSBjb25lY3RhciB1bmEgYXJpc3RhIGEgdW4gZ3J1cG8uXCIsZGVsOlwiRWxpbWluYXIgc2VsZWNjacOzblwiLGRlbGV0ZUNsdXN0ZXJFcnJvcjpcIk5vIGVzIHBvc2libGUgZWxpbWluYXIgZ3J1cG9zLlwiLGVkZ2VEZXNjcmlwdGlvbjpcIkhhZ2EgY2xpYyBlbiB1biBub2RvIHkgYXJyYXN0cmUgbGEgYXJpc3RhIGhhY2lhIG90cm8gbm9kbyBwYXJhIGNvbmVjdGFybG9zLlwiLGVkaXQ6XCJFZGl0YXJcIixlZGl0Q2x1c3RlckVycm9yOlwiTm8gZXMgcG9zaWJsZSBlZGl0YXIgZ3J1cG9zLlwiLGVkaXRFZGdlOlwiRWRpdGFyIGFyaXN0YVwiLGVkaXRFZGdlRGVzY3JpcHRpb246XCJIYWdhIGNsaWMgZW4gdW4gcHVudG8gZGUgY29udHJvbCB5IGFycmFzdHJlbG8gYSB1biBub2RvIHBhcmEgY29uZWN0YXJsby5cIixlZGl0Tm9kZTpcIkVkaXRhciBub2RvXCJ9LGl0OnthZGREZXNjcmlwdGlvbjpcIkNsaWNjYSBwZXIgYWdnaXVuZ2VyZSB1biBudW92byBub2RvXCIsYWRkRWRnZTpcIkFnZ2l1bmdpIHVuIHZlcnRpY2VcIixhZGROb2RlOlwiQWdnaXVuZ2kgdW4gbm9kb1wiLGJhY2s6XCJJbmRpZXRyb1wiLGNsb3NlOlwiQ2hpdWRlcmVcIixjcmVhdGVFZGdlRXJyb3I6XCJOb24gc2kgcG9zc29ubyBjb2xsZWdhcmUgdmVydGljaSBhZCB1biBjbHVzdGVyXCIsZGVsOlwiQ2FuY2VsbGEgbGEgc2VsZXppb25lXCIsZGVsZXRlQ2x1c3RlckVycm9yOlwiSSBjbHVzdGVyIG5vbiBwb3Nzb25vIGVzc2VyZSBjYW5jZWxsYXRpXCIsZWRnZURlc2NyaXB0aW9uOlwiQ2xpY2NhIHN1IHVuIG5vZG8gZSB0cmFzY2luYWxvIGFkIHVuIGFsdHJvIG5vZG8gcGVyIGNvbm5ldHRlcmxpLlwiLGVkaXQ6XCJNb2RpZmljYVwiLGVkaXRDbHVzdGVyRXJyb3I6XCJJIGNsdXN0ZXJzIG5vbiBwb3Nzb25vIGVzc2VyZSBtb2RpZmljYXRpLlwiLGVkaXRFZGdlOlwiTW9kaWZpY2EgaWwgdmVydGljZVwiLGVkaXRFZGdlRGVzY3JpcHRpb246XCJDbGljY2Egc3VpIFB1bnRpIGRpIGNvbnRyb2xsbyBlIHRyYXNjaW5hbGkgYWQgdW4gbm9kbyBwZXIgY29ubmV0dGVybGkuXCIsZWRpdE5vZGU6XCJNb2RpZmljYSBpbCBub2RvXCJ9LG5sOnthZGREZXNjcmlwdGlvbjpcIktsaWsgb3AgZWVuIGxlZWcgZ2ViaWVkIG9tIGVlbiBuaWV1d2Ugbm9kZSB0ZSBtYWtlbi5cIixhZGRFZGdlOlwiTGluayB0b2V2b2VnZW5cIixhZGROb2RlOlwiTm9kZSB0b2V2b2VnZW5cIixiYWNrOlwiVGVydWdcIixjbG9zZTpcIlNsdWl0ZW5cIixjcmVhdGVFZGdlRXJyb3I6XCJLYW4gZ2VlbiBsaW5rIG1ha2VuIG5hYXIgZWVuIGNsdXN0ZXIuXCIsZGVsOlwiU2VsZWN0aWUgdmVyd2lqZGVyZW5cIixkZWxldGVDbHVzdGVyRXJyb3I6XCJDbHVzdGVycyBrdW5uZW4gbmlldCB3b3JkZW4gdmVyd2lqZGVyZC5cIixlZGdlRGVzY3JpcHRpb246XCJLbGlrIG9wIGVlbiBub2RlIGVuIHNsZWVwIGRlIGxpbmsgbmFhciBlZW4gYW5kZXJlIG5vZGUgb20gemUgdGUgdmVyYmluZGVuLlwiLGVkaXQ6XCJXaWp6aWdlblwiLGVkaXRDbHVzdGVyRXJyb3I6XCJDbHVzdGVycyBrdW5uZW4gbmlldCB3b3JkZW4gYWFuZ2VwYXN0LlwiLGVkaXRFZGdlOlwiTGluayB3aWp6aWdlblwiLGVkaXRFZGdlRGVzY3JpcHRpb246XCJLbGlrIG9wIGRlIHZlcmJpbmRpbmdzcHVudGVuIGVuIHNsZWVwIHplIG5hYXIgZWVuIG5vZGUgb20gZGFhcm1lZSB0ZSB2ZXJiaW5kZW4uXCIsZWRpdE5vZGU6XCJOb2RlIHdpanppZ2VuXCJ9LHB0OnthZGREZXNjcmlwdGlvbjpcIkNsaXF1ZSBlbSB1bSBlc3Bhw6dvIGVtIGJyYW5jbyBwYXJhIGFkaWNpb25hciB1bSBub3ZvIG7Ds1wiLGFkZEVkZ2U6XCJBZGljaW9uYXIgYXJlc3RhXCIsYWRkTm9kZTpcIkFkaWNpb25hciBuw7NcIixiYWNrOlwiVm9sdGFyXCIsY2xvc2U6XCJGZWNoYXJcIixjcmVhdGVFZGdlRXJyb3I6XCJOw6NvIGZvaSBwb3Nzw612ZWwgbGlua2FyIGFyZXN0YXMgYSB1bSBjbHVzdGVyLlwiLGRlbDpcIlJlbW92ZXIgc2VsZWNpb25hZG9cIixkZWxldGVDbHVzdGVyRXJyb3I6XCJDbHVzdGVycyBuw6NvIHB1ZGVyYW0gc2VyIHJlbW92aWRvcy5cIixlZGdlRGVzY3JpcHRpb246XCJDbGlxdWUgZW0gdW0gbsOzIGUgYXJyYXN0ZSBhIGFyZXN0YSBhdMOpIG91dHJvIG7DsyBwYXJhIGNvbmVjdMOhLWxvc1wiLGVkaXQ6XCJFZGl0YXJcIixlZGl0Q2x1c3RlckVycm9yOlwiQ2x1c3RlcnMgbsOjbyBwdWRlcmFtIHNlciBlZGl0YWRvcy5cIixlZGl0RWRnZTpcIkVkaXRhciBhcmVzdGFcIixlZGl0RWRnZURlc2NyaXB0aW9uOlwiQ2xpcXVlIG5vcyBwb250b3MgZGUgY29udHJvbGUgZSBvcyBhcnJhc3RlIHBhcmEgdW0gbsOzIHBhcmEgY29uZWN0w6EtbG9zXCIsZWRpdE5vZGU6XCJFZGl0YXIgbsOzXCJ9LHJ1OnthZGREZXNjcmlwdGlvbjpcItCa0LvQuNC60L3QuNGC0LUg0LIg0YHQstC+0LHQvtC00L3QvtC1INC80LXRgdGC0L4sINGH0YLQvtCx0Ysg0LTQvtCx0LDQstC40YLRjCDQvdC+0LLRi9C5INGD0LfQtdC7LlwiLGFkZEVkZ2U6XCLQlNC+0LHQsNCy0LjRgtGMINGA0LXQsdGA0L5cIixhZGROb2RlOlwi0JTQvtCx0LDQstC40YLRjCDRg9C30LXQu1wiLGJhY2s6XCLQndCw0LfQsNC0XCIsY2xvc2U6XCLQl9Cw0LrRgNGL0LLQsNGC0YxcIixjcmVhdGVFZGdlRXJyb3I6XCLQndC10LLQvtC30LzQvtC20L3QviDRgdC+0LXQtNC40L3QuNGC0Ywg0YDQtdCx0YDQsCDQsiDQutC70LDRgdGC0LXRgC5cIixkZWw6XCLQo9C00LDQu9C40YLRjCDQstGL0LHRgNCw0L3QvdC+0LVcIixkZWxldGVDbHVzdGVyRXJyb3I6XCLQmtC70LDRgdGC0LXRgNGLINC90LUg0LzQvtCz0YPRgiDQsdGL0YLRjCDRg9C00LDQu9C10L3Ri1wiLGVkZ2VEZXNjcmlwdGlvbjpcItCa0LvQuNC60L3QuNGC0LUg0L3QsCDRg9C30LXQuyDQuCDQv9GA0L7RgtGP0L3QuNGC0LUg0YDQtdCx0YDQviDQuiDQtNGA0YPQs9C+0LzRgyDRg9C30LvRgywg0YfRgtC+0LHRiyDRgdC+0LXQtNC40L3QuNGC0Ywg0LjRhS5cIixlZGl0Olwi0KDQtdC00LDQutGC0LjRgNC+0LLQsNGC0YxcIixlZGl0Q2x1c3RlckVycm9yOlwi0JrQu9Cw0YHRgtC10YDRiyDQvdC10LTQvtGB0YLRg9C/0L3RiyDQtNC70Y8g0YDQtdC00LDQutGC0LjRgNC+0LLQsNC90LjRjy5cIixlZGl0RWRnZTpcItCg0LXQtNCw0LrRgtC40YDQvtCy0LDRgtGMINGA0LXQsdGA0L5cIixlZGl0RWRnZURlc2NyaXB0aW9uOlwi0JrQu9C40LrQvdC40YLQtSDQvdCwINC60L7QvdGC0YDQvtC70YzQvdGL0LUg0YLQvtGH0LrQuCDQuCDQv9C10YDQtdGC0LDRidC40YLQtSDQuNGFINCyINGD0LfQtdC7LCDRh9GC0L7QsdGLINC/0L7QtNC60LvRjtGH0LjRgtGM0YHRjyDQuiDQvdC10LzRgy5cIixlZGl0Tm9kZTpcItCg0LXQtNCw0LrRgtC40YDQvtCy0LDRgtGMINGD0LfQtdC7XCJ9LGNuOnthZGREZXNjcmlwdGlvbjpcIuWNleWHu+epuueZveWkhOaUvue9ruaWsOiKgueCueOAglwiLGFkZEVkZ2U6XCLmt7vliqDov57mjqXnur9cIixhZGROb2RlOlwi5re75Yqg6IqC54K5XCIsYmFjazpcIui/lOWbnlwiLGNsb3NlOlwi6Zec6ZaJXCIsY3JlYXRlRWRnZUVycm9yOlwi5peg5rOV5bCG6L+e5o6l57q/6L+e5o6l5Yiw576k6ZuG44CCXCIsZGVsOlwi5Yig6Zmk6YCJ5a6aXCIsZGVsZXRlQ2x1c3RlckVycm9yOlwi5peg5rOV5Yig6Zmk576k6ZuG44CCXCIsZWRnZURlc2NyaXB0aW9uOlwi5Y2V5Ye75p+Q5Liq6IqC54K55bm25bCG6K+l6L+e5o6l57q/5ouW5Yqo5Yiw5Y+m5LiA5Liq6IqC54K55Lul6L+e5o6l5a6D5Lus44CCXCIsZWRpdDpcIue8lui+kVwiLGVkaXRDbHVzdGVyRXJyb3I6XCLml6Dms5XnvJbovpHnvqTpm4bjgIJcIixlZGl0RWRnZTpcIue8lui+kei/nuaOpee6v1wiLGVkaXRFZGdlRGVzY3JpcHRpb246XCLljZXlh7vmjqfliLboioLngrnlubblsIblroPku6zmi5bliLDoioLngrnkuIrov57mjqXjgIJcIixlZGl0Tm9kZTpcIue8lui+keiKgueCuVwifSx1azp7YWRkRGVzY3JpcHRpb246XCJL0LvRltC60L3RltGC0Ywg0L3QsCDQstGW0LvRjNC90LUg0LzRltGB0YbQtSwg0YnQvtCxINC00L7QtNCw0YLQuCDQvdC+0LLQuNC5INCy0YPQt9C+0LsuXCIsYWRkRWRnZTpcItCU0L7QtNCw0YLQuCDQutGA0LDQuVwiLGFkZE5vZGU6XCLQlNC+0LTQsNGC0Lgg0LLRg9C30L7Qu1wiLGJhY2s6XCLQndCw0LfQsNC0XCIsY2xvc2U6XCLQl9Cw0LrRgNC40YLQuFwiLGNyZWF0ZUVkZ2VFcnJvcjpcItCd0LUg0LzQvtC20LvQuNCy0L4g0L7QsSfRlNC00L3QsNGC0Lgg0LrRgNCw0Zcg0LIg0LPRgNGD0L/Rgy5cIixkZWw6XCLQktC40LTQsNC70LjRgtC4INC+0LHRgNCw0L3QtVwiLGRlbGV0ZUNsdXN0ZXJFcnJvcjpcItCT0YDRg9C/0Lgg0L3QtSDQvNC+0LbRg9GC0Ywg0LHRg9GC0Lgg0LLQuNC00LDQu9C10L3Rli5cIixlZGdlRGVzY3JpcHRpb246XCLQmtC70ZbQutC90ZbRgtGMINC90LAg0LLRg9C30L7QuyDRliDQv9C10YDQtdGC0Y/Qs9C90ZbRgtGMINC60YDQsNC5INC00L4g0ZbQvdGI0L7Qs9C+INCy0YPQt9C70LAsINGJ0L7QsSDRl9GFINC3J9GU0LTQvdCw0YLQuC5cIixlZGl0Olwi0KDQtdC00LDQs9GD0LLQsNGC0LhcIixlZGl0Q2x1c3RlckVycm9yOlwi0JPRgNGD0L/QuCDQvdC10LTQvtGB0YLRg9C/0L3RliDQtNC70Y8g0YDQtdC00LDQs9GD0LLQsNC90L3Rjy5cIixlZGl0RWRnZTpcItCg0LXQtNCw0LPRg9Cy0LDRgtC4INC60YDQsNC5XCIsZWRpdEVkZ2VEZXNjcmlwdGlvbjpcItCa0LvRltC60L3RltGC0Ywg0L3QsCDQutC+0L3RgtGA0L7Qu9GM0L3RliDRgtC+0YfQutC4INGWINC/0LXRgNC10YLRj9Cz0L3RltGC0Ywg0ZfRhSDRgyDQstGD0LfQvtC7LCDRidC+0LEg0L/RltC00LrQu9GO0YfQuNGC0LjRgdGPINC00L4g0L3RjNC+0LPQvi5cIixlZGl0Tm9kZTpcItCg0LXQtNCw0LPRg9Cy0LDRgtC4INCy0YPQt9C+0LtcIn0sZnI6e2FkZERlc2NyaXB0aW9uOlwiQ2xpcXVleiBkYW5zIHVuIGVuZHJvaXQgdmlkZSBwb3VyIHBsYWNlciB1biBuxZN1ZC5cIixhZGRFZGdlOlwiQWpvdXRlciB1biBsaWVuXCIsYWRkTm9kZTpcIkFqb3V0ZXIgdW4gbsWTdWRcIixiYWNrOlwiUmV0b3VyXCIsY2xvc2U6XCJGZXJtZXJcIixjcmVhdGVFZGdlRXJyb3I6XCJJbXBvc3NpYmxlIGRlIGNyw6llciB1biBsaWVuIHZlcnMgdW4gY2x1c3Rlci5cIixkZWw6XCJFZmZhY2VyIGxhIHPDqWxlY3Rpb25cIixkZWxldGVDbHVzdGVyRXJyb3I6XCJMZXMgY2x1c3RlcnMgbmUgcGV1dmVudCBwYXMgw6p0cmUgZWZmYWPDqXMuXCIsZWRnZURlc2NyaXB0aW9uOlwiQ2xpcXVleiBzdXIgdW4gbsWTdWQgZXQgZ2xpc3NleiBsZSBsaWVuIHZlcnMgdW4gYXV0cmUgbsWTdWQgcG91ciBsZXMgY29ubmVjdGVyLlwiLGVkaXQ6XCLDiWRpdGVyXCIsZWRpdENsdXN0ZXJFcnJvcjpcIkxlcyBjbHVzdGVycyBuZSBwZXV2ZW50IHBhcyDDqnRyZSDDqWRpdMOpcy5cIixlZGl0RWRnZTpcIsOJZGl0ZXIgbGUgbGllblwiLGVkaXRFZGdlRGVzY3JpcHRpb246XCJDbGlxdWV6IHN1ciBsZXMgcG9pbnRzIGRlIGNvbnRyw7RsZSBldCBnbGlzc2V6LWxlcyBwb3VyIGNvbm5lY3RlciB1biBuxZN1ZC5cIixlZGl0Tm9kZTpcIsOJZGl0ZXIgbGUgbsWTdWRcIn0sY3M6e2FkZERlc2NyaXB0aW9uOlwiS2x1a251dMOtbSBkbyBwcsOhemRuw6lobyBwcm9zdG9ydSBtxa/FvmV0ZSBwxZlpZGF0IG5vdsO9IHZyY2hvbC5cIixhZGRFZGdlOlwiUMWZaWRhdCBocmFudVwiLGFkZE5vZGU6XCJQxZlpZGF0IHZyY2hvbFwiLGJhY2s6XCJacMSbdFwiLGNsb3NlOlwiWmF2xZnDrXRcIixjcmVhdGVFZGdlRXJyb3I6XCJOZWx6ZSBwxZlpcG9qaXQgaHJhbnUga2Ugc2hsdWt1LlwiLGRlbDpcIlNtYXphdCB2w71ixJtyXCIsZGVsZXRlQ2x1c3RlckVycm9yOlwiTmVsemUgbWF6YXQgc2hsdWt5LlwiLGVkZ2VEZXNjcmlwdGlvbjpcIlDFmWV0YcW+ZW7DrW0geiBqZWRub2hvIHZyY2hvbHUgZG8gZHJ1aMOpaG8gbcWvxb5ldGUgc3Bvaml0IHR5dG8gdnJjaG9seSBub3ZvdSBocmFub3UuXCIsZWRpdDpcIlVwcmF2aXRcIixlZGl0Q2x1c3RlckVycm9yOlwiTmVsemUgdXByYXZvdmF0IHNobHVreS5cIixlZGl0RWRnZTpcIlVwcmF2aXQgaHJhbnVcIixlZGl0RWRnZURlc2NyaXB0aW9uOlwiUMWZZXRhxb5lbsOtbSBrb250cm9sbsOtaG8gdnJjaG9sdSBocmFueSBqaSBtxa/FvmV0ZSBwxZlpcG9qaXQgayBqaW7DqW11IHZyY2hvbHUuXCIsZWRpdE5vZGU6XCJVcHJhdml0IHZyY2hvbFwifX0pO3ZhciBmZD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtQbyh0aGlzLHQpLHRoaXMuTlVNX0lURVJBVElPTlM9NCx0aGlzLmltYWdlPW5ldyBJbWFnZSx0aGlzLmNhbnZhcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpfXJldHVybiBJbyh0LFt7a2V5OlwiaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYoIXRoaXMuaW5pdGlhbGl6ZWQoKSl7dGhpcy5zcmM9dGhpcy5pbWFnZS5zcmM7dmFyIHQ9dGhpcy5pbWFnZS53aWR0aCxlPXRoaXMuaW1hZ2UuaGVpZ2h0O3RoaXMud2lkdGg9dCx0aGlzLmhlaWdodD1lO3ZhciBpPU1hdGguZmxvb3IoZS8yKSxvPU1hdGguZmxvb3IoZS80KSxuPU1hdGguZmxvb3IoZS84KSxyPU1hdGguZmxvb3IoZS8xNikscz1NYXRoLmZsb29yKHQvMiksYT1NYXRoLmZsb29yKHQvNCksaD1NYXRoLmZsb29yKHQvOCksZD1NYXRoLmZsb29yKHQvMTYpO3RoaXMuY2FudmFzLndpZHRoPTMqYSx0aGlzLmNhbnZhcy5oZWlnaHQ9aSx0aGlzLmNvb3JkaW5hdGVzPVtbMCwwLHMsaV0sW3MsMCxhLG9dLFtzLG8saCxuXSxbNSpoLG8sZCxyXV0sdGhpcy5fZmlsbE1pcE1hcCgpfX19LHtrZXk6XCJpbml0aWFsaXplZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuY29vcmRpbmF0ZXN9fSx7a2V5OlwiX2ZpbGxNaXBNYXBcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSxlPXRoaXMuY29vcmRpbmF0ZXNbMF07dC5kcmF3SW1hZ2UodGhpcy5pbWFnZSxlWzBdLGVbMV0sZVsyXSxlWzNdKTtmb3IodmFyIGk9MTtpPHRoaXMuTlVNX0lURVJBVElPTlM7aSsrKXt2YXIgbz10aGlzLmNvb3JkaW5hdGVzW2ktMV0sbj10aGlzLmNvb3JkaW5hdGVzW2ldO3QuZHJhd0ltYWdlKHRoaXMuY2FudmFzLG9bMF0sb1sxXSxvWzJdLG9bM10sblswXSxuWzFdLG5bMl0sblszXSl9fX0se2tleTpcImRyYXdJbWFnZUF0UG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7aWYodGhpcy5pbml0aWFsaXplZCgpKWlmKGU+Mil7ZSo9LjU7Zm9yKHZhciBzPTA7ZT4yJiZzPHRoaXMuTlVNX0lURVJBVElPTlM7KWUqPS41LHMrPTE7cz49dGhpcy5OVU1fSVRFUkFUSU9OUyYmKHM9dGhpcy5OVU1fSVRFUkFUSU9OUy0xKTt2YXIgYT10aGlzLmNvb3JkaW5hdGVzW3NdO3QuZHJhd0ltYWdlKHRoaXMuY2FudmFzLGFbMF0sYVsxXSxhWzJdLGFbM10saSxvLG4scil9ZWxzZSB0LmRyYXdJbWFnZSh0aGlzLmltYWdlLGksbyxuLHIpfX1dKSx0fSgpLHBkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXtQbyh0aGlzLHQpLHRoaXMuaW1hZ2VzPXt9LHRoaXMuaW1hZ2VCcm9rZW49e30sdGhpcy5jYWxsYmFjaz1lfXJldHVybiBJbyh0LFt7a2V5OlwiX3RyeWxvYWRCcm9rZW5VcmxcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dm9pZCAwIT09dCYmdm9pZCAwIT09aSYmKHZvaWQgMCE9PWU/KGkuaW1hZ2Uub25lcnJvcj1mdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJDb3VsZCBub3QgbG9hZCBicm9rZW5JbWFnZTpcIixlKX0saS5pbWFnZS5zcmM9ZSk6Y29uc29sZS53YXJuKFwiTm8gYnJva2VuIHVybCBpbWFnZSBkZWZpbmVkXCIpKX19LHtrZXk6XCJfcmVkcmF3V2l0aEltYWdlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5jYWxsYmFjayYmdGhpcy5jYWxsYmFjayh0KX19LHtrZXk6XCJsb2FkXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLG89dGhpcy5pbWFnZXNbdF07aWYobylyZXR1cm4gbzt2YXIgbj1uZXcgZmQ7cmV0dXJuIHRoaXMuaW1hZ2VzW3RdPW4sbi5pbWFnZS5vbmxvYWQ9ZnVuY3Rpb24oKXtpLl9maXhJbWFnZUNvb3JkaW5hdGVzKG4uaW1hZ2UpLG4uaW5pdCgpLGkuX3JlZHJhd1dpdGhJbWFnZShuKX0sbi5pbWFnZS5vbmVycm9yPWZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBsb2FkIGltYWdlOlwiLHQpLGkuX3RyeWxvYWRCcm9rZW5VcmwodCxlLG4pfSxuLmltYWdlLnNyYz10LG59fSx7a2V5OlwiX2ZpeEltYWdlQ29vcmRpbmF0ZXNcIix2YWx1ZTpmdW5jdGlvbih0KXswPT09dC53aWR0aCYmKGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodCksdC53aWR0aD10Lm9mZnNldFdpZHRoLHQuaGVpZ2h0PXQub2Zmc2V0SGVpZ2h0LGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodCkpfX1dKSx0fSgpLHZkPSFzKChmdW5jdGlvbigpe3JldHVybiBPYmplY3QuaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpfSkpLGdkPW8oKGZ1bmN0aW9uKHQpe3ZhciBlPUwuZixpPUh0KFwibWV0YVwiKSxvPTAsbj1PYmplY3QuaXNFeHRlbnNpYmxlfHxmdW5jdGlvbigpe3JldHVybiEwfSxyPWZ1bmN0aW9uKHQpe2UodCxpLHt2YWx1ZTp7b2JqZWN0SUQ6XCJPXCIrICsrbyx3ZWFrRGF0YTp7fX19KX0scz10LmV4cG9ydHM9e1JFUVVJUkVEOiExLGZhc3RLZXk6ZnVuY3Rpb24odCxlKXtpZighbSh0KSlyZXR1cm5cInN5bWJvbFwiPT10eXBlb2YgdD90OihcInN0cmluZ1wiPT10eXBlb2YgdD9cIlNcIjpcIlBcIikrdDtpZighayh0LGkpKXtpZighbih0KSlyZXR1cm5cIkZcIjtpZighZSlyZXR1cm5cIkVcIjtyKHQpfXJldHVybiB0W2ldLm9iamVjdElEfSxnZXRXZWFrRGF0YTpmdW5jdGlvbih0LGUpe2lmKCFrKHQsaSkpe2lmKCFuKHQpKXJldHVybiEwO2lmKCFlKXJldHVybiExO3IodCl9cmV0dXJuIHRbaV0ud2Vha0RhdGF9LG9uRnJlZXplOmZ1bmN0aW9uKHQpe3JldHVybiB2ZCYmcy5SRVFVSVJFRCYmbih0KSYmIWsodCxpKSYmcih0KSx0fX07ZXRbaV09ITB9KSkseWQ9ZnVuY3Rpb24odCxlKXt0aGlzLnN0b3BwZWQ9dCx0aGlzLnJlc3VsdD1lfSxtZD1mdW5jdGlvbih0LGUsaSl7dmFyIG8sbixyLHMsYSxoLGQsbD1pJiZpLnRoYXQsYz0hKCFpfHwhaS5BU19FTlRSSUVTKSx1PSEoIWl8fCFpLklTX0lURVJBVE9SKSxmPSEoIWl8fCFpLklOVEVSUlVQVEVEKSxwPUEoZSxsLDErYytmKSx2PWZ1bmN0aW9uKHQpe3JldHVybiBvJiZuaShvKSxuZXcgeWQoITAsdCl9LGc9ZnVuY3Rpb24odCl7cmV0dXJuIGM/KFIodCksZj9wKHRbMF0sdFsxXSx2KTpwKHRbMF0sdFsxXSkpOmY/cCh0LHYpOnAodCl9O2lmKHUpbz10O2Vsc2V7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Yobj1jaSh0KSkpdGhyb3cgVHlwZUVycm9yKFwiVGFyZ2V0IGlzIG5vdCBpdGVyYWJsZVwiKTtpZihoaShuKSl7Zm9yKHI9MCxzPUsodC5sZW5ndGgpO3M+cjtyKyspaWYoKGE9Zyh0W3JdKSkmJmEgaW5zdGFuY2VvZiB5ZClyZXR1cm4gYTtyZXR1cm4gbmV3IHlkKCExKX1vPW4uY2FsbCh0KX1mb3IoaD1vLm5leHQ7IShkPWguY2FsbChvKSkuZG9uZTspe3RyeXthPWcoZC52YWx1ZSl9Y2F0Y2godCl7dGhyb3cgbmkobyksdH1pZihcIm9iamVjdFwiPT10eXBlb2YgYSYmYSYmYSBpbnN0YW5jZW9mIHlkKXJldHVybiBhfXJldHVybiBuZXcgeWQoITEpfSxiZD1mdW5jdGlvbih0LGUsaSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgVHlwZUVycm9yKFwiSW5jb3JyZWN0IFwiKyhpP2krXCIgXCI6XCJcIikrXCJpbnZvY2F0aW9uXCIpO3JldHVybiB0fSx3ZD1MLmYsa2Q9V2kuZm9yRWFjaCxfZD1adC5zZXQseGQ9WnQuZ2V0dGVyRm9yLEVkPWZ1bmN0aW9uKHQsZSxpKXt2YXIgbyxuPS0xIT09dC5pbmRleE9mKFwiTWFwXCIpLGg9LTEhPT10LmluZGV4T2YoXCJXZWFrXCIpLGQ9bj9cInNldFwiOlwiYWRkXCIsbD1yW3RdLGM9bCYmbC5wcm90b3R5cGUsdT17fTtpZihhJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBsJiYoaHx8Yy5mb3JFYWNoJiYhcygoZnVuY3Rpb24oKXsobmV3IGwpLmVudHJpZXMoKS5uZXh0KCl9KSkpKXtvPWUoKGZ1bmN0aW9uKGUsaSl7X2QoYmQoZSxvLHQpLHt0eXBlOnQsY29sbGVjdGlvbjpuZXcgbH0pLG51bGwhPWkmJm1kKGksZVtkXSx7dGhhdDplLEFTX0VOVFJJRVM6bn0pfSkpO3ZhciBmPXhkKHQpO2tkKFtcImFkZFwiLFwiY2xlYXJcIixcImRlbGV0ZVwiLFwiZm9yRWFjaFwiLFwiZ2V0XCIsXCJoYXNcIixcInNldFwiLFwia2V5c1wiLFwidmFsdWVzXCIsXCJlbnRyaWVzXCJdLChmdW5jdGlvbih0KXt2YXIgZT1cImFkZFwiPT10fHxcInNldFwiPT10OyEodCBpbiBjKXx8aCYmXCJjbGVhclwiPT10fHxIKG8ucHJvdG90eXBlLHQsKGZ1bmN0aW9uKGksbyl7dmFyIG49Zih0aGlzKS5jb2xsZWN0aW9uO2lmKCFlJiZoJiYhbShpKSlyZXR1cm5cImdldFwiPT10JiZ2b2lkIDA7dmFyIHI9blt0XSgwPT09aT8wOmksbyk7cmV0dXJuIGU/dGhpczpyfSkpfSkpLGh8fHdkKG8ucHJvdG90eXBlLFwic2l6ZVwiLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYodGhpcykuY29sbGVjdGlvbi5zaXplfX0pfWVsc2Ugbz1pLmdldENvbnN0cnVjdG9yKGUsdCxuLGQpLGdkLlJFUVVJUkVEPSEwO3JldHVybiBMZShvLHQsITEsITApLHVbdF09byxxKHtnbG9iYWw6ITAsZm9yY2VkOiEwfSx1KSxofHxpLnNldFN0cm9uZyhvLHQsbiksb30sT2Q9ZnVuY3Rpb24odCxlLGkpe2Zvcih2YXIgbyBpbiBlKWkmJmkudW5zYWZlJiZ0W29dP3Rbb109ZVtvXTpVZSh0LG8sZVtvXSxpKTtyZXR1cm4gdH0sQ2Q9YmUoXCJzcGVjaWVzXCIpLFNkPUwuZixUZD1nZC5mYXN0S2V5LE1kPVp0LnNldCxQZD1adC5nZXR0ZXJGb3IsRGQ9e2dldENvbnN0cnVjdG9yOmZ1bmN0aW9uKHQsZSxpLG8pe3ZhciBuPXQoKGZ1bmN0aW9uKHQscil7YmQodCxuLGUpLE1kKHQse3R5cGU6ZSxpbmRleDpEZShudWxsKSxmaXJzdDp2b2lkIDAsbGFzdDp2b2lkIDAsc2l6ZTowfSksYXx8KHQuc2l6ZT0wKSxudWxsIT1yJiZtZChyLHRbb10se3RoYXQ6dCxBU19FTlRSSUVTOml9KX0pKSxyPVBkKGUpLHM9ZnVuY3Rpb24odCxlLGkpe3ZhciBvLG4scz1yKHQpLGQ9aCh0LGUpO3JldHVybiBkP2QudmFsdWU9aToocy5sYXN0PWQ9e2luZGV4Om49VGQoZSwhMCksa2V5OmUsdmFsdWU6aSxwcmV2aW91czpvPXMubGFzdCxuZXh0OnZvaWQgMCxyZW1vdmVkOiExfSxzLmZpcnN0fHwocy5maXJzdD1kKSxvJiYoby5uZXh0PWQpLGE/cy5zaXplKys6dC5zaXplKyssXCJGXCIhPT1uJiYocy5pbmRleFtuXT1kKSksdH0saD1mdW5jdGlvbih0LGUpe3ZhciBpLG89cih0KSxuPVRkKGUpO2lmKFwiRlwiIT09bilyZXR1cm4gby5pbmRleFtuXTtmb3IoaT1vLmZpcnN0O2k7aT1pLm5leHQpaWYoaS5rZXk9PWUpcmV0dXJuIGl9O3JldHVybiBPZChuLnByb3RvdHlwZSx7Y2xlYXI6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9cih0aGlzKSxlPXQuaW5kZXgsaT10LmZpcnN0O2k7KWkucmVtb3ZlZD0hMCxpLnByZXZpb3VzJiYoaS5wcmV2aW91cz1pLnByZXZpb3VzLm5leHQ9dm9pZCAwKSxkZWxldGUgZVtpLmluZGV4XSxpPWkubmV4dDt0LmZpcnN0PXQubGFzdD12b2lkIDAsYT90LnNpemU9MDp0aGlzLnNpemU9MH0sZGVsZXRlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsaT1yKGUpLG89aChlLHQpO2lmKG8pe3ZhciBuPW8ubmV4dCxzPW8ucHJldmlvdXM7ZGVsZXRlIGkuaW5kZXhbby5pbmRleF0sby5yZW1vdmVkPSEwLHMmJihzLm5leHQ9biksbiYmKG4ucHJldmlvdXM9cyksaS5maXJzdD09byYmKGkuZmlyc3Q9biksaS5sYXN0PT1vJiYoaS5sYXN0PXMpLGE/aS5zaXplLS06ZS5zaXplLS19cmV0dXJuISFvfSxmb3JFYWNoOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxpPXIodGhpcyksbz1BKHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsMyk7ZT1lP2UubmV4dDppLmZpcnN0Oylmb3IobyhlLnZhbHVlLGUua2V5LHRoaXMpO2UmJmUucmVtb3ZlZDspZT1lLnByZXZpb3VzfSxoYXM6ZnVuY3Rpb24odCl7cmV0dXJuISFoKHRoaXMsdCl9fSksT2Qobi5wcm90b3R5cGUsaT97Z2V0OmZ1bmN0aW9uKHQpe3ZhciBlPWgodGhpcyx0KTtyZXR1cm4gZSYmZS52YWx1ZX0sc2V0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHModGhpcywwPT09dD8wOnQsZSl9fTp7YWRkOmZ1bmN0aW9uKHQpe3JldHVybiBzKHRoaXMsdD0wPT09dD8wOnQsdCl9fSksYSYmU2Qobi5wcm90b3R5cGUsXCJzaXplXCIse2dldDpmdW5jdGlvbigpe3JldHVybiByKHRoaXMpLnNpemV9fSksbn0sc2V0U3Ryb25nOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz1lK1wiIEl0ZXJhdG9yXCIsbj1QZChlKSxyPVBkKG8pO0plKHQsZSwoZnVuY3Rpb24odCxlKXtNZCh0aGlzLHt0eXBlOm8sdGFyZ2V0OnQsc3RhdGU6bih0KSxraW5kOmUsbGFzdDp2b2lkIDB9KX0pLChmdW5jdGlvbigpe2Zvcih2YXIgdD1yKHRoaXMpLGU9dC5raW5kLGk9dC5sYXN0O2kmJmkucmVtb3ZlZDspaT1pLnByZXZpb3VzO3JldHVybiB0LnRhcmdldCYmKHQubGFzdD1pPWk/aS5uZXh0OnQuc3RhdGUuZmlyc3QpP1wia2V5c1wiPT1lP3t2YWx1ZTppLmtleSxkb25lOiExfTpcInZhbHVlc1wiPT1lP3t2YWx1ZTppLnZhbHVlLGRvbmU6ITF9Ont2YWx1ZTpbaS5rZXksaS52YWx1ZV0sZG9uZTohMX06KHQudGFyZ2V0PXZvaWQgMCx7dmFsdWU6dm9pZCAwLGRvbmU6ITB9KX0pLGk/XCJlbnRyaWVzXCI6XCJ2YWx1ZXNcIiwhaSwhMCksZnVuY3Rpb24odCl7dmFyIGU9cmUodCksaT1MLmY7YSYmZSYmIWVbQ2RdJiZpKGUsQ2Qse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc319KX0oZSl9fTtFZChcIk1hcFwiLChmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdCh0aGlzLGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzBdOnZvaWQgMCl9fSksRGQpO3ZhciBCZD1GLk1hcCxJZD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtQbyh0aGlzLHQpLHRoaXMuY2xlYXIoKSx0aGlzLl9kZWZhdWx0SW5kZXg9MCx0aGlzLl9ncm91cEluZGV4PTAsdGhpcy5fZGVmYXVsdEdyb3Vwcz1be2JvcmRlcjpcIiMyQjdDRTlcIixiYWNrZ3JvdW5kOlwiIzk3QzJGQ1wiLGhpZ2hsaWdodDp7Ym9yZGVyOlwiIzJCN0NFOVwiLGJhY2tncm91bmQ6XCIjRDJFNUZGXCJ9LGhvdmVyOntib3JkZXI6XCIjMkI3Q0U5XCIsYmFja2dyb3VuZDpcIiNEMkU1RkZcIn19LHtib3JkZXI6XCIjRkZBNTAwXCIsYmFja2dyb3VuZDpcIiNGRkZGMDBcIixoaWdobGlnaHQ6e2JvcmRlcjpcIiNGRkE1MDBcIixiYWNrZ3JvdW5kOlwiI0ZGRkZBM1wifSxob3Zlcjp7Ym9yZGVyOlwiI0ZGQTUwMFwiLGJhY2tncm91bmQ6XCIjRkZGRkEzXCJ9fSx7Ym9yZGVyOlwiI0ZBMEExMFwiLGJhY2tncm91bmQ6XCIjRkI3RTgxXCIsaGlnaGxpZ2h0Ontib3JkZXI6XCIjRkEwQTEwXCIsYmFja2dyb3VuZDpcIiNGRkFGQjFcIn0saG92ZXI6e2JvcmRlcjpcIiNGQTBBMTBcIixiYWNrZ3JvdW5kOlwiI0ZGQUZCMVwifX0se2JvcmRlcjpcIiM0MUE5MDZcIixiYWNrZ3JvdW5kOlwiIzdCRTE0MVwiLGhpZ2hsaWdodDp7Ym9yZGVyOlwiIzQxQTkwNlwiLGJhY2tncm91bmQ6XCIjQTFFQzc2XCJ9LGhvdmVyOntib3JkZXI6XCIjNDFBOTA2XCIsYmFja2dyb3VuZDpcIiNBMUVDNzZcIn19LHtib3JkZXI6XCIjRTEyOUYwXCIsYmFja2dyb3VuZDpcIiNFQjdERjRcIixoaWdobGlnaHQ6e2JvcmRlcjpcIiNFMTI5RjBcIixiYWNrZ3JvdW5kOlwiI0YwQjNGNVwifSxob3Zlcjp7Ym9yZGVyOlwiI0UxMjlGMFwiLGJhY2tncm91bmQ6XCIjRjBCM0Y1XCJ9fSx7Ym9yZGVyOlwiIzdDMjlGMFwiLGJhY2tncm91bmQ6XCIjQUQ4NUU0XCIsaGlnaGxpZ2h0Ontib3JkZXI6XCIjN0MyOUYwXCIsYmFja2dyb3VuZDpcIiNEM0JERjBcIn0saG92ZXI6e2JvcmRlcjpcIiM3QzI5RjBcIixiYWNrZ3JvdW5kOlwiI0QzQkRGMFwifX0se2JvcmRlcjpcIiNDMzdGMDBcIixiYWNrZ3JvdW5kOlwiI0ZGQTgwN1wiLGhpZ2hsaWdodDp7Ym9yZGVyOlwiI0MzN0YwMFwiLGJhY2tncm91bmQ6XCIjRkZDQTY2XCJ9LGhvdmVyOntib3JkZXI6XCIjQzM3RjAwXCIsYmFja2dyb3VuZDpcIiNGRkNBNjZcIn19LHtib3JkZXI6XCIjNDIyMEZCXCIsYmFja2dyb3VuZDpcIiM2RTZFRkRcIixoaWdobGlnaHQ6e2JvcmRlcjpcIiM0MjIwRkJcIixiYWNrZ3JvdW5kOlwiIzlCOUJGRFwifSxob3Zlcjp7Ym9yZGVyOlwiIzQyMjBGQlwiLGJhY2tncm91bmQ6XCIjOUI5QkZEXCJ9fSx7Ym9yZGVyOlwiI0ZENUE3N1wiLGJhY2tncm91bmQ6XCIjRkZDMENCXCIsaGlnaGxpZ2h0Ontib3JkZXI6XCIjRkQ1QTc3XCIsYmFja2dyb3VuZDpcIiNGRkQxRDlcIn0saG92ZXI6e2JvcmRlcjpcIiNGRDVBNzdcIixiYWNrZ3JvdW5kOlwiI0ZGRDFEOVwifX0se2JvcmRlcjpcIiM0QUQ2M0FcIixiYWNrZ3JvdW5kOlwiI0MyRkFCQ1wiLGhpZ2hsaWdodDp7Ym9yZGVyOlwiIzRBRDYzQVwiLGJhY2tncm91bmQ6XCIjRTZGRkUzXCJ9LGhvdmVyOntib3JkZXI6XCIjNEFENjNBXCIsYmFja2dyb3VuZDpcIiNFNkZGRTNcIn19LHtib3JkZXI6XCIjOTkwMDAwXCIsYmFja2dyb3VuZDpcIiNFRTAwMDBcIixoaWdobGlnaHQ6e2JvcmRlcjpcIiNCQjAwMDBcIixiYWNrZ3JvdW5kOlwiI0ZGMzMzM1wifSxob3Zlcjp7Ym9yZGVyOlwiI0JCMDAwMFwiLGJhY2tncm91bmQ6XCIjRkYzMzMzXCJ9fSx7Ym9yZGVyOlwiI0ZGNjAwMFwiLGJhY2tncm91bmQ6XCIjRkY2MDAwXCIsaGlnaGxpZ2h0Ontib3JkZXI6XCIjRkY2MDAwXCIsYmFja2dyb3VuZDpcIiNGRjYwMDBcIn0saG92ZXI6e2JvcmRlcjpcIiNGRjYwMDBcIixiYWNrZ3JvdW5kOlwiI0ZGNjAwMFwifX0se2JvcmRlcjpcIiM5N0MyRkNcIixiYWNrZ3JvdW5kOlwiIzJCN0NFOVwiLGhpZ2hsaWdodDp7Ym9yZGVyOlwiI0QyRTVGRlwiLGJhY2tncm91bmQ6XCIjMkI3Q0U5XCJ9LGhvdmVyOntib3JkZXI6XCIjRDJFNUZGXCIsYmFja2dyb3VuZDpcIiMyQjdDRTlcIn19LHtib3JkZXI6XCIjMzk5NjA1XCIsYmFja2dyb3VuZDpcIiMyNTVDMDNcIixoaWdobGlnaHQ6e2JvcmRlcjpcIiMzOTk2MDVcIixiYWNrZ3JvdW5kOlwiIzI1NUMwM1wifSxob3Zlcjp7Ym9yZGVyOlwiIzM5OTYwNVwiLGJhY2tncm91bmQ6XCIjMjU1QzAzXCJ9fSx7Ym9yZGVyOlwiI0I3MDA1NFwiLGJhY2tncm91bmQ6XCIjRkYwMDdFXCIsaGlnaGxpZ2h0Ontib3JkZXI6XCIjQjcwMDU0XCIsYmFja2dyb3VuZDpcIiNGRjAwN0VcIn0saG92ZXI6e2JvcmRlcjpcIiNCNzAwNTRcIixiYWNrZ3JvdW5kOlwiI0ZGMDA3RVwifX0se2JvcmRlcjpcIiNBRDg1RTRcIixiYWNrZ3JvdW5kOlwiIzdDMjlGMFwiLGhpZ2hsaWdodDp7Ym9yZGVyOlwiI0QzQkRGMFwiLGJhY2tncm91bmQ6XCIjN0MyOUYwXCJ9LGhvdmVyOntib3JkZXI6XCIjRDNCREYwXCIsYmFja2dyb3VuZDpcIiM3QzI5RjBcIn19LHtib3JkZXI6XCIjNDU1N0ZBXCIsYmFja2dyb3VuZDpcIiMwMDBFQTFcIixoaWdobGlnaHQ6e2JvcmRlcjpcIiM2RTZFRkRcIixiYWNrZ3JvdW5kOlwiIzAwMEVBMVwifSxob3Zlcjp7Ym9yZGVyOlwiIzZFNkVGRFwiLGJhY2tncm91bmQ6XCIjMDAwRUExXCJ9fSx7Ym9yZGVyOlwiI0ZGQzBDQlwiLGJhY2tncm91bmQ6XCIjRkQ1QTc3XCIsaGlnaGxpZ2h0Ontib3JkZXI6XCIjRkZEMUQ5XCIsYmFja2dyb3VuZDpcIiNGRDVBNzdcIn0saG92ZXI6e2JvcmRlcjpcIiNGRkQxRDlcIixiYWNrZ3JvdW5kOlwiI0ZENUE3N1wifX0se2JvcmRlcjpcIiNDMkZBQkNcIixiYWNrZ3JvdW5kOlwiIzc0RDY2QVwiLGhpZ2hsaWdodDp7Ym9yZGVyOlwiI0U2RkZFM1wiLGJhY2tncm91bmQ6XCIjNzRENjZBXCJ9LGhvdmVyOntib3JkZXI6XCIjRTZGRkUzXCIsYmFja2dyb3VuZDpcIiM3NEQ2NkFcIn19LHtib3JkZXI6XCIjRUUwMDAwXCIsYmFja2dyb3VuZDpcIiM5OTAwMDBcIixoaWdobGlnaHQ6e2JvcmRlcjpcIiNGRjMzMzNcIixiYWNrZ3JvdW5kOlwiI0JCMDAwMFwifSxob3Zlcjp7Ym9yZGVyOlwiI0ZGMzMzM1wiLGJhY2tncm91bmQ6XCIjQkIwMDAwXCJ9fV0sdGhpcy5vcHRpb25zPXt9LHRoaXMuZGVmYXVsdE9wdGlvbnM9e3VzZURlZmF1bHRHcm91cHM6ITB9LGN0KHRoaXMub3B0aW9ucyx0aGlzLmRlZmF1bHRPcHRpb25zKX1yZXR1cm4gSW8odCxbe2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1bXCJ1c2VEZWZhdWx0R3JvdXBzXCJdO2lmKHZvaWQgMCE9PXQpZm9yKHZhciBpIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsaSkmJi0xPT09TXIoZSkuY2FsbChlLGkpKXt2YXIgbz10W2ldO3RoaXMuYWRkKGksbyl9fX0se2tleTpcImNsZWFyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9ncm91cHM9bmV3IEJkLHRoaXMuX2dyb3VwTmFtZXM9W119fSx7a2V5OlwiZ2V0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9IShhcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSl8fGFyZ3VtZW50c1sxXSxpPXRoaXMuX2dyb3Vwcy5nZXQodCk7aWYodm9pZCAwPT09aSYmZSlpZighMT09PXRoaXMub3B0aW9ucy51c2VEZWZhdWx0R3JvdXBzJiZ0aGlzLl9ncm91cE5hbWVzLmxlbmd0aD4wKXt2YXIgbz10aGlzLl9ncm91cEluZGV4JXRoaXMuX2dyb3VwTmFtZXMubGVuZ3RoOysrdGhpcy5fZ3JvdXBJbmRleCwoaT17fSkuY29sb3I9dGhpcy5fZ3JvdXBzLmdldCh0aGlzLl9ncm91cE5hbWVzW29dKSx0aGlzLl9ncm91cHMuc2V0KHQsaSl9ZWxzZXt2YXIgbj10aGlzLl9kZWZhdWx0SW5kZXgldGhpcy5fZGVmYXVsdEdyb3Vwcy5sZW5ndGg7dGhpcy5fZGVmYXVsdEluZGV4KyssKGk9e30pLmNvbG9yPXRoaXMuX2RlZmF1bHRHcm91cHNbbl0sdGhpcy5fZ3JvdXBzLnNldCh0LGkpfXJldHVybiBpfX0se2tleTpcImFkZFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2dyb3Vwcy5oYXModCl8fHRoaXMuX2dyb3VwTmFtZXMucHVzaCh0KSx0aGlzLl9ncm91cHMuc2V0KHQsZSksZX19XSksdH0oKTtxKHt0YXJnZXQ6XCJOdW1iZXJcIixzdGF0OiEwfSx7aXNOYU46ZnVuY3Rpb24odCl7cmV0dXJuIHQhPXR9fSk7dmFyIHpkPUYuTnVtYmVyLmlzTmFOLEZkPXIuaXNGaW5pdGUsTmQ9TnVtYmVyLmlzRmluaXRlfHxmdW5jdGlvbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmRmQodCl9O3Eoe3RhcmdldDpcIk51bWJlclwiLHN0YXQ6ITB9LHtpc0Zpbml0ZTpOZH0pO3ZhciBBZD1GLk51bWJlci5pc0Zpbml0ZSxSZD1XaS5zb21lLGpkPU9uKFwic29tZVwiKTtxKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohamR9LHtzb21lOmZ1bmN0aW9uKHQpe3JldHVybiBSZCh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pO3ZhciBMZD1ndChcIkFycmF5XCIpLnNvbWUsSGQ9QXJyYXkucHJvdG90eXBlLFdkPWZ1bmN0aW9uKHQpe3ZhciBlPXQuc29tZTtyZXR1cm4gdD09PUhkfHx0IGluc3RhbmNlb2YgQXJyYXkmJmU9PT1IZC5zb21lP0xkOmV9LFZkPWdyLnRyaW0scWQ9ci5wYXJzZUZsb2F0LFVkPTEvcWQoY3IrXCItMFwiKSE9LTEvMD9mdW5jdGlvbih0KXt2YXIgZT1WZChTdHJpbmcodCkpLGk9cWQoZSk7cmV0dXJuIDA9PT1pJiZcIi1cIj09ZS5jaGFyQXQoMCk/LTA6aX06cWQ7cSh7Z2xvYmFsOiEwLGZvcmNlZDpwYXJzZUZsb2F0IT1VZH0se3BhcnNlRmxvYXQ6VWR9KTt2YXIgWWQ9Ri5wYXJzZUZsb2F0LFhkPXppLmYsR2Q9cygoZnVuY3Rpb24oKXtyZXR1cm4hT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoMSl9KSk7cSh7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxmb3JjZWQ6R2R9LHtnZXRPd25Qcm9wZXJ0eU5hbWVzOlhkfSk7dmFyIEtkPUYuT2JqZWN0LCRkPWZ1bmN0aW9uKHQpe3JldHVybiBLZC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpfTtmdW5jdGlvbiBRZCh0LGUpe3ZhciBpPVtcIm5vZGVcIixcImVkZ2VcIixcImxhYmVsXCJdLG89ITAsbj1taChlLFwiY2hvc2VuXCIpO2lmKFwiYm9vbGVhblwiPT10eXBlb2YgbilvPW47ZWxzZSBpZihcIm9iamVjdFwiPT09ZG4obikpe2lmKC0xPT09TXIoaSkuY2FsbChpLHQpKXRocm93IG5ldyBFcnJvcihcImNob29zaWZ5OiBzdWJPcHRpb24gJ1wiK3QrXCInIHNob3VsZCBiZSBvbmUgb2YgJ1wiK2kuam9pbihcIicsICdcIikrXCInXCIpO3ZhciByPW1oKGUsW1wiY2hvc2VuXCIsdF0pO1wiYm9vbGVhblwiIT10eXBlb2YgciYmXCJmdW5jdGlvblwiIT10eXBlb2Ygcnx8KG89cil9cmV0dXJuIG99ZnVuY3Rpb24gWmQodCxlLGkpe2lmKHQud2lkdGg8PTB8fHQuaGVpZ2h0PD0wKXJldHVybiExO2lmKHZvaWQgMCE9PWkpe3ZhciBvPXt4OmUueC1pLngseTplLnktaS55fTtpZigwIT09aS5hbmdsZSl7dmFyIG49LWkuYW5nbGU7ZT17eDpNYXRoLmNvcyhuKSpvLngtTWF0aC5zaW4obikqby55LHk6TWF0aC5zaW4obikqby54K01hdGguY29zKG4pKm8ueX19ZWxzZSBlPW99dmFyIHI9dC54K3Qud2lkdGgscz10LnkrdC53aWR0aDtyZXR1cm4gdC5sZWZ0PGUueCYmcj5lLngmJnQudG9wPGUueSYmcz5lLnl9ZnVuY3Rpb24gSmQodCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQmJlwiXCIhPT10fWZ1bmN0aW9uIHRsKHQsZSxpLG8pe3ZhciBuPW8ueCxyPW8ueTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBvLmRpc3RhbmNlVG9Cb3JkZXIpe3ZhciBzPW8uZGlzdGFuY2VUb0JvcmRlcih0LGUpLGE9TWF0aC5zaW4oZSkqcyxoPU1hdGguY29zKGUpKnM7aD09PXM/KG4rPXMscj1vLnkpOmE9PT1zPyhuPW8ueCxyLT1zKToobis9aCxyLT1hKX1lbHNlIG8uc2hhcGUud2lkdGg+by5zaGFwZS5oZWlnaHQ/KG49by54Ky41Km8uc2hhcGUud2lkdGgscj1vLnktaSk6KG49by54K2kscj1vLnktLjUqby5zaGFwZS5oZWlnaHQpO3JldHVybnt4Om4seTpyfX12YXIgZWw9Z3QoXCJBcnJheVwiKS52YWx1ZXMsaWw9QXJyYXkucHJvdG90eXBlLG9sPXtET01Ub2tlbkxpc3Q6ITAsTm9kZUxpc3Q6ITB9LG5sPWZ1bmN0aW9uKHQpe3ZhciBlPXQudmFsdWVzO3JldHVybiB0PT09aWx8fHQgaW5zdGFuY2VvZiBBcnJheSYmZT09PWlsLnZhbHVlc3x8b2wuaGFzT3duUHJvcGVydHkoTmUodCkpP2VsOmV9LHJsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXtQbyh0aGlzLHQpLHRoaXMubWVhc3VyZVRleHQ9ZSx0aGlzLmN1cnJlbnQ9MCx0aGlzLndpZHRoPTAsdGhpcy5oZWlnaHQ9MCx0aGlzLmxpbmVzPVtdfXJldHVybiBJbyh0LFt7a2V5OlwiX2FkZFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOlwibm9ybWFsXCI7dm9pZCAwPT09dGhpcy5saW5lc1t0XSYmKHRoaXMubGluZXNbdF09e3dpZHRoOjAsaGVpZ2h0OjAsYmxvY2tzOltdfSk7dmFyIG89ZTt2b2lkIDAhPT1lJiZcIlwiIT09ZXx8KG89XCIgXCIpO3ZhciBuPXRoaXMubWVhc3VyZVRleHQobyxpKSxyPWN0KHt9LG5sKG4pKTtyLnRleHQ9ZSxyLndpZHRoPW4ud2lkdGgsci5tb2Q9aSx2b2lkIDAhPT1lJiZcIlwiIT09ZXx8KHIud2lkdGg9MCksdGhpcy5saW5lc1t0XS5ibG9ja3MucHVzaChyKSx0aGlzLmxpbmVzW3RdLndpZHRoKz1yLndpZHRofX0se2tleTpcImN1cldpZHRoXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxpbmVzW3RoaXMuY3VycmVudF07cmV0dXJuIHZvaWQgMD09PXQ/MDp0LndpZHRofX0se2tleTpcImFwcGVuZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpcIm5vcm1hbFwiO3RoaXMuX2FkZCh0aGlzLmN1cnJlbnQsdCxlKX19LHtrZXk6XCJuZXdMaW5lXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOlwibm9ybWFsXCI7dGhpcy5fYWRkKHRoaXMuY3VycmVudCx0LGUpLHRoaXMuY3VycmVudCsrfX0se2tleTpcImRldGVybWluZUxpbmVIZWlnaHRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHRoaXMubGluZXMubGVuZ3RoO3QrKyl7dmFyIGU9dGhpcy5saW5lc1t0XSxpPTA7aWYodm9pZCAwIT09ZS5ibG9ja3MpZm9yKHZhciBvPTA7bzxlLmJsb2Nrcy5sZW5ndGg7bysrKXt2YXIgbj1lLmJsb2Nrc1tvXTtpPG4uaGVpZ2h0JiYoaT1uLmhlaWdodCl9ZS5oZWlnaHQ9aX19fSx7a2V5OlwiZGV0ZXJtaW5lTGFiZWxTaXplXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTAsaT0wO2k8dGhpcy5saW5lcy5sZW5ndGg7aSsrKXt2YXIgbz10aGlzLmxpbmVzW2ldO28ud2lkdGg+dCYmKHQ9by53aWR0aCksZSs9by5oZWlnaHR9dGhpcy53aWR0aD10LHRoaXMuaGVpZ2h0PWV9fSx7a2V5OlwicmVtb3ZlRW1wdHlCbG9ja3NcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTA7ZTx0aGlzLmxpbmVzLmxlbmd0aDtlKyspe3ZhciBpPXRoaXMubGluZXNbZV07aWYoMCE9PWkuYmxvY2tzLmxlbmd0aCYmKGUhPT10aGlzLmxpbmVzLmxlbmd0aC0xfHwwIT09aS53aWR0aCkpe3ZhciBvPXt9O2N0KG8saSksby5ibG9ja3M9W107Zm9yKHZhciBuPXZvaWQgMCxyPVtdLHM9MDtzPGkuYmxvY2tzLmxlbmd0aDtzKyspe3ZhciBhPWkuYmxvY2tzW3NdOzAhPT1hLndpZHRoP3IucHVzaChhKTp2b2lkIDA9PT1uJiYobj1hKX0wPT09ci5sZW5ndGgmJnZvaWQgMCE9PW4mJnIucHVzaChuKSxvLmJsb2Nrcz1yLHQucHVzaChvKX19cmV0dXJuIHR9fSx7a2V5OlwiZmluYWxpemVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZGV0ZXJtaW5lTGluZUhlaWdodHMoKSx0aGlzLmRldGVybWluZUxhYmVsU2l6ZSgpO3ZhciB0PXRoaXMucmVtb3ZlRW1wdHlCbG9ja3MoKTtyZXR1cm57d2lkdGg6dGhpcy53aWR0aCxoZWlnaHQ6dGhpcy5oZWlnaHQsbGluZXM6dH19fV0pLHR9KCksc2w9e1wiPGI+XCI6LzxiPi8sXCI8aT5cIjovPGk+LyxcIjxjb2RlPlwiOi88Y29kZT4vLFwiPC9iPlwiOi88XFwvYj4vLFwiPC9pPlwiOi88XFwvaT4vLFwiPC9jb2RlPlwiOi88XFwvY29kZT4vLFwiKlwiOi9cXCovLF86L18vLFwiYFwiOi9gLyxhZnRlckJvbGQ6L1teKl0vLGFmdGVySXRhbDovW15fXS8sYWZ0ZXJNb25vOi9bXmBdL30sYWw9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe1BvKHRoaXMsdCksdGhpcy50ZXh0PWUsdGhpcy5ib2xkPSExLHRoaXMuaXRhbD0hMSx0aGlzLm1vbm89ITEsdGhpcy5zcGFjaW5nPSExLHRoaXMucG9zaXRpb249MCx0aGlzLmJ1ZmZlcj1cIlwiLHRoaXMubW9kU3RhY2s9W10sdGhpcy5ibG9ja3M9W119cmV0dXJuIElvKHQsW3trZXk6XCJtb2RcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5tb2RTdGFjay5sZW5ndGg/XCJub3JtYWxcIjp0aGlzLm1vZFN0YWNrWzBdfX0se2tleTpcIm1vZE5hbWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5tb2RTdGFjay5sZW5ndGg/XCJub3JtYWxcIjpcIm1vbm9cIj09PXRoaXMubW9kU3RhY2tbMF0/XCJtb25vXCI6dGhpcy5ib2xkJiZ0aGlzLml0YWw/XCJib2xkaXRhbFwiOnRoaXMuYm9sZD9cImJvbGRcIjp0aGlzLml0YWw/XCJpdGFsXCI6dm9pZCAwfX0se2tleTpcImVtaXRCbG9ja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zcGFjaW5nJiYodGhpcy5hZGQoXCIgXCIpLHRoaXMuc3BhY2luZz0hMSksdGhpcy5idWZmZXIubGVuZ3RoPjAmJih0aGlzLmJsb2Nrcy5wdXNoKHt0ZXh0OnRoaXMuYnVmZmVyLG1vZDp0aGlzLm1vZE5hbWUoKX0pLHRoaXMuYnVmZmVyPVwiXCIpfX0se2tleTpcImFkZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe1wiIFwiPT09dCYmKHRoaXMuc3BhY2luZz0hMCksdGhpcy5zcGFjaW5nJiYodGhpcy5idWZmZXIrPVwiIFwiLHRoaXMuc3BhY2luZz0hMSksXCIgXCIhPXQmJih0aGlzLmJ1ZmZlcis9dCl9fSx7a2V5OlwicGFyc2VXU1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiEhL1sgXFx0XS8udGVzdCh0KSYmKHRoaXMubW9ubz90aGlzLmFkZCh0KTp0aGlzLnNwYWNpbmc9ITAsITApfX0se2tleTpcInNldFRhZ1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuZW1pdEJsb2NrKCksdGhpc1t0XT0hMCx0aGlzLm1vZFN0YWNrLnVuc2hpZnQodCl9fSx7a2V5OlwidW5zZXRUYWdcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmVtaXRCbG9jaygpLHRoaXNbdF09ITEsdGhpcy5tb2RTdGFjay5zaGlmdCgpfX0se2tleTpcInBhcnNlU3RhcnRUYWdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiEodGhpcy5tb25vfHx0aGlzW3RdfHwhdGhpcy5tYXRjaChlKSkmJih0aGlzLnNldFRhZyh0KSwhMCl9fSx7a2V5OlwibWF0Y2hcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT0hKGFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdKXx8YXJndW1lbnRzWzFdLGk9dGhpcy5wcmVwYXJlUmVnRXhwKHQpLG89YW4oaSwyKSxuPW9bMF0scj1vWzFdLHM9bi50ZXN0KHRoaXMudGV4dC5zdWJzdHIodGhpcy5wb3NpdGlvbixyKSk7cmV0dXJuIHMmJmUmJih0aGlzLnBvc2l0aW9uKz1yLTEpLHN9fSx7a2V5OlwicGFyc2VFbmRUYWdcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dmFyIG89dGhpcy5tb2QoKT09PXQ7cmV0dXJuISghKG89XCJtb25vXCI9PT10P28mJnRoaXMubW9ubzpvJiYhdGhpcy5tb25vKXx8IXRoaXMubWF0Y2goZSkpJiYodm9pZCAwIT09aT8odGhpcy5wb3NpdGlvbj09PXRoaXMudGV4dC5sZW5ndGgtMXx8dGhpcy5tYXRjaChpLCExKSkmJnRoaXMudW5zZXRUYWcodCk6dGhpcy51bnNldFRhZyh0KSwhMCl9fSx7a2V5OlwicmVwbGFjZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuISF0aGlzLm1hdGNoKHQpJiYodGhpcy5hZGQoZSksdGhpcy5wb3NpdGlvbis9bGVuZ3RoLTEsITApfX0se2tleTpcInByZXBhcmVSZWdFeHBcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZSxpO2lmKHQgaW5zdGFuY2VvZiBSZWdFeHApaT10LGU9MTtlbHNle3ZhciBvPXNsW3RdO2k9dm9pZCAwIT09bz9vOm5ldyBSZWdFeHAodCksZT10Lmxlbmd0aH1yZXR1cm5baSxlXX19XSksdH0oKSxobD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8sbil7dmFyIHI9dGhpcztQbyh0aGlzLHQpLHRoaXMuY3R4PWUsdGhpcy5wYXJlbnQ9aSx0aGlzLnNlbGVjdGVkPW8sdGhpcy5ob3Zlcj1uO3RoaXMubGluZXM9bmV3IHJsKChmdW5jdGlvbih0LGkpe2lmKHZvaWQgMD09PXQpcmV0dXJuIDA7dmFyIHM9ci5wYXJlbnQuZ2V0Rm9ybWF0dGluZ1ZhbHVlcyhlLG8sbixpKSxhPTA7XCJcIiE9PXQmJihhPXIuY3R4Lm1lYXN1cmVUZXh0KHQpLndpZHRoKTtyZXR1cm57d2lkdGg6YSx2YWx1ZXM6c319KSl9cmV0dXJuIElvKHQsW3trZXk6XCJwcm9jZXNzXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoIUpkKHQpKXJldHVybiB0aGlzLmxpbmVzLmZpbmFsaXplKCk7dmFyIGU9dGhpcy5wYXJlbnQuZm9udE9wdGlvbnM7dD0odD10LnJlcGxhY2UoL1xcclxcbi9nLFwiXFxuXCIpKS5yZXBsYWNlKC9cXHIvZyxcIlxcblwiKTt2YXIgaT1TdHJpbmcodCkuc3BsaXQoXCJcXG5cIiksbz1pLmxlbmd0aDtpZihlLm11bHRpKWZvcih2YXIgbj0wO248bztuKyspe3ZhciByPXRoaXMuc3BsaXRCbG9ja3MoaVtuXSxlLm11bHRpKTtpZih2b2lkIDAhPT1yKWlmKDAhPT1yLmxlbmd0aCl7aWYoZS5tYXhXZHQ+MClmb3IodmFyIHM9MDtzPHIubGVuZ3RoO3MrKyl7dmFyIGE9cltzXS5tb2QsaD1yW3NdLnRleHQ7dGhpcy5zcGxpdFN0cmluZ0ludG9MaW5lcyhoLGEsITApfWVsc2UgZm9yKHZhciBkPTA7ZDxyLmxlbmd0aDtkKyspe3ZhciBsPXJbZF0ubW9kLGM9cltkXS50ZXh0O3RoaXMubGluZXMuYXBwZW5kKGMsbCl9dGhpcy5saW5lcy5uZXdMaW5lKCl9ZWxzZSB0aGlzLmxpbmVzLm5ld0xpbmUoXCJcIil9ZWxzZSBpZihlLm1heFdkdD4wKWZvcih2YXIgdT0wO3U8bzt1KyspdGhpcy5zcGxpdFN0cmluZ0ludG9MaW5lcyhpW3VdKTtlbHNlIGZvcih2YXIgZj0wO2Y8bztmKyspdGhpcy5saW5lcy5uZXdMaW5lKGlbZl0pO3JldHVybiB0aGlzLmxpbmVzLmZpbmFsaXplKCl9fSx7a2V5OlwiZGVjb2RlTWFya3VwU3lzdGVtXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9XCJub25lXCI7cmV0dXJuXCJtYXJrZG93blwiPT09dHx8XCJtZFwiPT09dD9lPVwibWFya2Rvd25cIjohMCE9PXQmJlwiaHRtbFwiIT09dHx8KGU9XCJodG1sXCIpLGV9fSx7a2V5Olwic3BsaXRIdG1sQmxvY2tzXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBhbCh0KSxpPWZ1bmN0aW9uKHQpe3JldHVybiEhLyYvLnRlc3QodCkmJihlLnJlcGxhY2UoZS50ZXh0LFwiJmx0O1wiLFwiPFwiKXx8ZS5yZXBsYWNlKGUudGV4dCxcIiZhbXA7XCIsXCImXCIpfHxlLmFkZChcIiZcIiksITApfTtlLnBvc2l0aW9uPGUudGV4dC5sZW5ndGg7KXt2YXIgbz1lLnRleHQuY2hhckF0KGUucG9zaXRpb24pO2UucGFyc2VXUyhvKXx8LzwvLnRlc3QobykmJihlLnBhcnNlU3RhcnRUYWcoXCJib2xkXCIsXCI8Yj5cIil8fGUucGFyc2VTdGFydFRhZyhcIml0YWxcIixcIjxpPlwiKXx8ZS5wYXJzZVN0YXJ0VGFnKFwibW9ub1wiLFwiPGNvZGU+XCIpfHxlLnBhcnNlRW5kVGFnKFwiYm9sZFwiLFwiPC9iPlwiKXx8ZS5wYXJzZUVuZFRhZyhcIml0YWxcIixcIjwvaT5cIil8fGUucGFyc2VFbmRUYWcoXCJtb25vXCIsXCI8L2NvZGU+XCIpKXx8aShvKXx8ZS5hZGQobyksZS5wb3NpdGlvbisrfXJldHVybiBlLmVtaXRCbG9jaygpLGUuYmxvY2tzfX0se2tleTpcInNwbGl0TWFya2Rvd25CbG9ja3NcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcyxpPW5ldyBhbCh0KSxvPSEwLG49ZnVuY3Rpb24odCl7cmV0dXJuISEvXFxcXC8udGVzdCh0KSYmKGkucG9zaXRpb248ZS50ZXh0Lmxlbmd0aCsxJiYoaS5wb3NpdGlvbisrLHQ9ZS50ZXh0LmNoYXJBdChpLnBvc2l0aW9uKSwvIFxcdC8udGVzdCh0KT9pLnNwYWNpbmc9ITA6KGkuYWRkKHQpLG89ITEpKSwhMCl9O2kucG9zaXRpb248aS50ZXh0Lmxlbmd0aDspe3ZhciByPWkudGV4dC5jaGFyQXQoaS5wb3NpdGlvbik7aS5wYXJzZVdTKHIpfHxuKHIpfHwob3x8aS5zcGFjaW5nKSYmKGkucGFyc2VTdGFydFRhZyhcImJvbGRcIixcIipcIil8fGkucGFyc2VTdGFydFRhZyhcIml0YWxcIixcIl9cIil8fGkucGFyc2VTdGFydFRhZyhcIm1vbm9cIixcImBcIikpfHxpLnBhcnNlRW5kVGFnKFwiYm9sZFwiLFwiKlwiLFwiYWZ0ZXJCb2xkXCIpfHxpLnBhcnNlRW5kVGFnKFwiaXRhbFwiLFwiX1wiLFwiYWZ0ZXJJdGFsXCIpfHxpLnBhcnNlRW5kVGFnKFwibW9ub1wiLFwiYFwiLFwiYWZ0ZXJNb25vXCIpfHwoaS5hZGQociksbz0hMSksaS5wb3NpdGlvbisrfXJldHVybiBpLmVtaXRCbG9jaygpLGkuYmxvY2tzfX0se2tleTpcInNwbGl0QmxvY2tzXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLmRlY29kZU1hcmt1cFN5c3RlbShlKTtyZXR1cm5cIm5vbmVcIj09PWk/W3t0ZXh0OnQsbW9kOlwibm9ybWFsXCJ9XTpcIm1hcmtkb3duXCI9PT1pP3RoaXMuc3BsaXRNYXJrZG93bkJsb2Nrcyh0KTpcImh0bWxcIj09PWk/dGhpcy5zcGxpdEh0bWxCbG9ja3ModCk6dm9pZCAwfX0se2tleTpcIm92ZXJNYXhXaWR0aFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuY3R4Lm1lYXN1cmVUZXh0KHQpLndpZHRoO3JldHVybiB0aGlzLmxpbmVzLmN1cldpZHRoKCkrZT50aGlzLnBhcmVudC5mb250T3B0aW9ucy5tYXhXZHR9fSx7a2V5OlwiZ2V0TG9uZ2VzdEZpdFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1cIlwiLGk9MDtpPHQubGVuZ3RoOyl7dmFyIG89ZSsoXCJcIj09PWU/XCJcIjpcIiBcIikrdFtpXTtpZih0aGlzLm92ZXJNYXhXaWR0aChvKSlicmVhaztlPW8saSsrfXJldHVybiBpfX0se2tleTpcImdldExvbmdlc3RGaXRXb3JkXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aCYmIXRoaXMub3Zlck1heFdpZHRoKHZuKHQpLmNhbGwodCwwLGUpKTspZSsrO3JldHVybiBlfX0se2tleTpcInNwbGl0U3RyaW5nSW50b0xpbmVzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOlwibm9ybWFsXCIsaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdO3RoaXMucGFyZW50LmdldEZvcm1hdHRpbmdWYWx1ZXModGhpcy5jdHgsdGhpcy5zZWxlY3RlZCx0aGlzLmhvdmVyLGUpO2Zvcih2YXIgbz0odD0odD10LnJlcGxhY2UoL14oICspL2csXCIkMVxcclwiKSkucmVwbGFjZSgvKFteXFxyXVteIF0qKSggKykvZyxcIiQxXFxyJDJcXHJcIikpLnNwbGl0KFwiXFxyXCIpO28ubGVuZ3RoPjA7KXt2YXIgbj10aGlzLmdldExvbmdlc3RGaXQobyk7aWYoMD09PW4pe3ZhciByPW9bMF0scz10aGlzLmdldExvbmdlc3RGaXRXb3JkKHIpO3RoaXMubGluZXMubmV3TGluZSh2bihyKS5jYWxsKHIsMCxzKSxlKSxvWzBdPXZuKHIpLmNhbGwocixzKX1lbHNle3ZhciBhPW47XCIgXCI9PT1vW24tMV0/bi0tOlwiIFwiPT09b1thXSYmYSsrO3ZhciBoPXZuKG8pLmNhbGwobywwLG4pLmpvaW4oXCJcIik7bj09by5sZW5ndGgmJmk/dGhpcy5saW5lcy5hcHBlbmQoaCxlKTp0aGlzLmxpbmVzLm5ld0xpbmUoaCxlKSxvPXZuKG8pLmNhbGwobyxhKX19fX1dKSx0fSgpLGRsPVtcImJvbGRcIixcIml0YWxcIixcImJvbGRpdGFsXCIsXCJtb25vXCJdLGxsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLGkpe3ZhciBvPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07UG8odGhpcyx0KSx0aGlzLmJvZHk9ZSx0aGlzLnBvaW50VG9TZWxmPSExLHRoaXMuYmFzZVNpemU9dm9pZCAwLHRoaXMuZm9udE9wdGlvbnM9e30sdGhpcy5zZXRPcHRpb25zKGkpLHRoaXMuc2l6ZT17dG9wOjAsbGVmdDowLHdpZHRoOjAsaGVpZ2h0OjAseUxpbmU6MH0sdGhpcy5pc0VkZ2VMYWJlbD1vfXJldHVybiBJbyh0LFt7a2V5Olwic2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHRoaXMuZWxlbWVudE9wdGlvbnM9dCx0aGlzLmluaXRGb250T3B0aW9ucyh0LmZvbnQpLEpkKHQubGFiZWwpP3RoaXMubGFiZWxEaXJ0eT0hMDp0LmxhYmVsPXZvaWQgMCx2b2lkIDAhPT10LmZvbnQmJm51bGwhPT10LmZvbnQpaWYoXCJzdHJpbmdcIj09dHlwZW9mIHQuZm9udCl0aGlzLmJhc2VTaXplPXRoaXMuZm9udE9wdGlvbnMuc2l6ZTtlbHNlIGlmKFwib2JqZWN0XCI9PT1kbih0LmZvbnQpKXt2YXIgZT10LmZvbnQuc2l6ZTt2b2lkIDAhPT1lJiYodGhpcy5iYXNlU2l6ZT1lKX19fSx7a2V5OlwiaW5pdEZvbnRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIGk9dGhpcztuaChkbCwoZnVuY3Rpb24odCl7aS5mb250T3B0aW9uc1t0XT17fX0pKSx0LnBhcnNlRm9udFN0cmluZyh0aGlzLmZvbnRPcHRpb25zLGUpP3RoaXMuZm9udE9wdGlvbnMudmFkanVzdD0wOm5oKGUsKGZ1bmN0aW9uKHQsZSl7bnVsbCE9dCYmXCJvYmplY3RcIiE9PWRuKHQpJiYoaS5mb250T3B0aW9uc1tlXT10KX0pKX19LHtrZXk6XCJjb25zdHJhaW5cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT17Y29uc3RyYWluV2lkdGg6ITEsbWF4V2R0Oi0xLG1pbldkdDotMSxjb25zdHJhaW5IZWlnaHQ6ITEsbWluSGd0Oi0xLHZhbGlnbjpcIm1pZGRsZVwifSxpPW1oKHQsXCJ3aWR0aENvbnN0cmFpbnRcIik7aWYoXCJudW1iZXJcIj09dHlwZW9mIGkpZS5tYXhXZHQ9TnVtYmVyKGkpLGUubWluV2R0PU51bWJlcihpKTtlbHNlIGlmKFwib2JqZWN0XCI9PT1kbihpKSl7dmFyIG89bWgodCxbXCJ3aWR0aENvbnN0cmFpbnRcIixcIm1heGltdW1cIl0pO1wibnVtYmVyXCI9PXR5cGVvZiBvJiYoZS5tYXhXZHQ9TnVtYmVyKG8pKTt2YXIgbj1taCh0LFtcIndpZHRoQ29uc3RyYWludFwiLFwibWluaW11bVwiXSk7XCJudW1iZXJcIj09dHlwZW9mIG4mJihlLm1pbldkdD1OdW1iZXIobikpfXZhciByPW1oKHQsXCJoZWlnaHRDb25zdHJhaW50XCIpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiByKWUubWluSGd0PU51bWJlcihyKTtlbHNlIGlmKFwib2JqZWN0XCI9PT1kbihyKSl7dmFyIHM9bWgodCxbXCJoZWlnaHRDb25zdHJhaW50XCIsXCJtaW5pbXVtXCJdKTtcIm51bWJlclwiPT10eXBlb2YgcyYmKGUubWluSGd0PU51bWJlcihzKSk7dmFyIGE9bWgodCxbXCJoZWlnaHRDb25zdHJhaW50XCIsXCJ2YWxpZ25cIl0pO1wic3RyaW5nXCI9PXR5cGVvZiBhJiYoXCJ0b3BcIiE9PWEmJlwiYm90dG9tXCIhPT1hfHwoZS52YWxpZ249YSkpfXJldHVybiBlfX0se2tleTpcInVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy5zZXRPcHRpb25zKHQsITApLHRoaXMucHJvcGFnYXRlRm9udHMoZSksdGgodGhpcy5mb250T3B0aW9ucyx0aGlzLmNvbnN0cmFpbihlKSksdGhpcy5mb250T3B0aW9ucy5jaG9vc2VyPVFkKFwibGFiZWxcIixlKX19LHtrZXk6XCJhZGp1c3RTaXplc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQ/dC5yaWdodCt0LmxlZnQ6MDt0aGlzLmZvbnRPcHRpb25zLmNvbnN0cmFpbldpZHRoJiYodGhpcy5mb250T3B0aW9ucy5tYXhXZHQtPWUsdGhpcy5mb250T3B0aW9ucy5taW5XZHQtPWUpO3ZhciBpPXQ/dC50b3ArdC5ib3R0b206MDt0aGlzLmZvbnRPcHRpb25zLmNvbnN0cmFpbkhlaWdodCYmKHRoaXMuZm9udE9wdGlvbnMubWluSGd0LT1pKX19LHtrZXk6XCJhZGRGb250T3B0aW9uc1RvUGlsZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDsrK2kpdGhpcy5hZGRGb250VG9QaWxlKHQsZVtpXSl9fSx7a2V5OlwiYWRkRm9udFRvUGlsZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwIT09ZSYmdm9pZCAwIT09ZS5mb250JiZudWxsIT09ZS5mb250KXt2YXIgaT1lLmZvbnQ7dC5wdXNoKGkpfX19LHtrZXk6XCJnZXRCYXNpY09wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIGk9e30sbz0wO288ZS5sZW5ndGg7KytvKXt2YXIgbj1lW29dLHI9e307dC5wYXJzZUZvbnRTdHJpbmcocixuKSYmKG49ciksbmgobiwoZnVuY3Rpb24odCxlKXt2b2lkIDAhPT10JiYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGksZSl8fCgtMSE9PU1yKGRsKS5jYWxsKGRsLGUpP2lbZV09e306aVtlXT10KSl9KSl9cmV0dXJuIGl9fSx7a2V5OlwiZ2V0Rm9udE9wdGlvblwiLHZhbHVlOmZ1bmN0aW9uKGUsaSxvKXtmb3IodmFyIG4scj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgcz1lW3JdO2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLGkpKXtpZihudWxsPT0obj1zW2ldKSljb250aW51ZTt2YXIgYT17fTtpZih0LnBhcnNlRm9udFN0cmluZyhhLG4pJiYobj1hKSxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixvKSlyZXR1cm4gbltvXX19aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZm9udE9wdGlvbnMsbykpcmV0dXJuIHRoaXMuZm9udE9wdGlvbnNbb107dGhyb3cgbmV3IEVycm9yKFwiRGlkIG5vdCBmaW5kIHZhbHVlIGZvciBtdWx0aS1mb250IGZvciBwcm9wZXJ0eTogJ1wiK28rXCInXCIpfX0se2tleTpcImdldEZvbnRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIGk9e30sbz1bXCJjb2xvclwiLFwic2l6ZVwiLFwiZmFjZVwiLFwibW9kXCIsXCJ2YWRqdXN0XCJdLG49MDtuPG8ubGVuZ3RoOysrbil7dmFyIHI9b1tuXTtpW3JdPXRoaXMuZ2V0Rm9udE9wdGlvbih0LGUscil9cmV0dXJuIGl9fSx7a2V5OlwicHJvcGFnYXRlRm9udHNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLGk9W107dGhpcy5hZGRGb250T3B0aW9uc1RvUGlsZShpLHQpLHRoaXMuZm9udE9wdGlvbnM9dGhpcy5nZXRCYXNpY09wdGlvbnMoaSk7Zm9yKHZhciBvPWZ1bmN0aW9uKHQpe3ZhciBvPWRsW3RdLG49ZS5mb250T3B0aW9uc1tvXTtuaChlLmdldEZvbnRPcHRpb25zKGksbyksKGZ1bmN0aW9uKHQsZSl7bltlXT10fSkpLG4uc2l6ZT1OdW1iZXIobi5zaXplKSxuLnZhZGp1c3Q9TnVtYmVyKG4udmFkanVzdCl9LG49MDtuPGRsLmxlbmd0aDsrK24pbyhuKX19LHtrZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjUmJnZvaWQgMCE9PWFyZ3VtZW50c1s1XT9hcmd1bWVudHNbNV06XCJtaWRkbGVcIjtpZih2b2lkIDAhPT10aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsKXt2YXIgcz10aGlzLmZvbnRPcHRpb25zLnNpemUqdGhpcy5ib2R5LnZpZXcuc2NhbGU7dGhpcy5lbGVtZW50T3B0aW9ucy5sYWJlbCYmczx0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZC0xfHwocz49dGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1heFZpc2libGUmJihzPU51bWJlcih0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwubWF4VmlzaWJsZSkvdGhpcy5ib2R5LnZpZXcuc2NhbGUpLHRoaXMuY2FsY3VsYXRlTGFiZWxTaXplKHQsbyxuLGUsaSxyKSx0aGlzLl9kcmF3QmFja2dyb3VuZCh0KSx0aGlzLl9kcmF3VGV4dCh0LGUsdGhpcy5zaXplLnlMaW5lLHIscykpfX19LHtrZXk6XCJfZHJhd0JhY2tncm91bmRcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih2b2lkIDAhPT10aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQmJlwibm9uZVwiIT09dGhpcy5mb250T3B0aW9ucy5iYWNrZ3JvdW5kKXt0LmZpbGxTdHlsZT10aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQ7dmFyIGU9dGhpcy5nZXRTaXplKCk7dC5maWxsUmVjdChlLmxlZnQsZS50b3AsZS53aWR0aCxlLmhlaWdodCl9fX0se2tleTpcIl9kcmF3VGV4dFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106XCJtaWRkbGVcIixuPWFyZ3VtZW50cy5sZW5ndGg+ND9hcmd1bWVudHNbNF06dm9pZCAwLHI9dGhpcy5fc2V0QWxpZ25tZW50KHQsZSxpLG8pLHM9YW4ociwyKTtlPXNbMF0saT1zWzFdLHQudGV4dEFsaWduPVwibGVmdFwiLGUtPXRoaXMuc2l6ZS53aWR0aC8yLHRoaXMuZm9udE9wdGlvbnMudmFsaWduJiZ0aGlzLnNpemUuaGVpZ2h0PnRoaXMuc2l6ZS5sYWJlbEhlaWdodCYmKFwidG9wXCI9PT10aGlzLmZvbnRPcHRpb25zLnZhbGlnbiYmKGktPSh0aGlzLnNpemUuaGVpZ2h0LXRoaXMuc2l6ZS5sYWJlbEhlaWdodCkvMiksXCJib3R0b21cIj09PXRoaXMuZm9udE9wdGlvbnMudmFsaWduJiYoaSs9KHRoaXMuc2l6ZS5oZWlnaHQtdGhpcy5zaXplLmxhYmVsSGVpZ2h0KS8yKSk7Zm9yKHZhciBhPTA7YTx0aGlzLmxpbmVDb3VudDthKyspe3ZhciBoPXRoaXMubGluZXNbYV07aWYoaCYmaC5ibG9ja3Mpe3ZhciBkPTA7dGhpcy5pc0VkZ2VMYWJlbHx8XCJjZW50ZXJcIj09PXRoaXMuZm9udE9wdGlvbnMuYWxpZ24/ZCs9KHRoaXMuc2l6ZS53aWR0aC1oLndpZHRoKS8yOlwicmlnaHRcIj09PXRoaXMuZm9udE9wdGlvbnMuYWxpZ24mJihkKz10aGlzLnNpemUud2lkdGgtaC53aWR0aCk7Zm9yKHZhciBsPTA7bDxoLmJsb2Nrcy5sZW5ndGg7bCsrKXt2YXIgYz1oLmJsb2Nrc1tsXTt0LmZvbnQ9Yy5mb250O3ZhciB1PXRoaXMuX2dldENvbG9yKGMuY29sb3IsbixjLnN0cm9rZUNvbG9yKSxmPWFuKHUsMikscD1mWzBdLHY9ZlsxXTtjLnN0cm9rZVdpZHRoPjAmJih0LmxpbmVXaWR0aD1jLnN0cm9rZVdpZHRoLHQuc3Ryb2tlU3R5bGU9dix0LmxpbmVKb2luPVwicm91bmRcIiksdC5maWxsU3R5bGU9cCxjLnN0cm9rZVdpZHRoPjAmJnQuc3Ryb2tlVGV4dChjLnRleHQsZStkLGkrYy52YWRqdXN0KSx0LmZpbGxUZXh0KGMudGV4dCxlK2QsaStjLnZhZGp1c3QpLGQrPWMud2lkdGh9aSs9aC5oZWlnaHR9fX19LHtrZXk6XCJfc2V0QWxpZ25tZW50XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyl7aWYodGhpcy5pc0VkZ2VMYWJlbCYmXCJob3Jpem9udGFsXCIhPT10aGlzLmZvbnRPcHRpb25zLmFsaWduJiYhMT09PXRoaXMucG9pbnRUb1NlbGYpe2U9MCxpPTA7XCJ0b3BcIj09PXRoaXMuZm9udE9wdGlvbnMuYWxpZ24/KHQudGV4dEJhc2VsaW5lPVwiYWxwaGFiZXRpY1wiLGktPTQpOlwiYm90dG9tXCI9PT10aGlzLmZvbnRPcHRpb25zLmFsaWduPyh0LnRleHRCYXNlbGluZT1cImhhbmdpbmdcIixpKz00KTp0LnRleHRCYXNlbGluZT1cIm1pZGRsZVwifWVsc2UgdC50ZXh0QmFzZWxpbmU9bztyZXR1cm5bZSxpXX19LHtrZXk6XCJfZ2V0Q29sb3JcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dmFyIG89dHx8XCIjMDAwMDAwXCIsbj1pfHxcIiNmZmZmZmZcIjtpZihlPD10aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZCl7dmFyIHI9TWF0aC5tYXgoMCxNYXRoLm1pbigxLDEtKHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkLWUpKSk7bz1zaChvLHIpLG49c2gobixyKX1yZXR1cm5bbyxuXX19LHtrZXk6XCJnZXRUZXh0U2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV0saT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdO3JldHVybiB0aGlzLl9wcm9jZXNzTGFiZWwodCxlLGkpLHt3aWR0aDp0aGlzLnNpemUud2lkdGgsaGVpZ2h0OnRoaXMuc2l6ZS5oZWlnaHQsbGluZUNvdW50OnRoaXMubGluZUNvdW50fX19LHtrZXk6XCJnZXRTaXplXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnNpemUubGVmdCxlPXRoaXMuc2l6ZS50b3AtMTtpZih0aGlzLmlzRWRnZUxhYmVsKXt2YXIgaT0uNSotdGhpcy5zaXplLndpZHRoO3N3aXRjaCh0aGlzLmZvbnRPcHRpb25zLmFsaWduKXtjYXNlXCJtaWRkbGVcIjp0PWksZT0uNSotdGhpcy5zaXplLmhlaWdodDticmVhaztjYXNlXCJ0b3BcIjp0PWksZT0tKHRoaXMuc2l6ZS5oZWlnaHQrMik7YnJlYWs7Y2FzZVwiYm90dG9tXCI6dD1pLGU9Mn19cmV0dXJue2xlZnQ6dCx0b3A6ZSx3aWR0aDp0aGlzLnNpemUud2lkdGgsaGVpZ2h0OnRoaXMuc2l6ZS5oZWlnaHR9fX0se2tleTpcImNhbGN1bGF0ZUxhYmVsU2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106MCxuPWFyZ3VtZW50cy5sZW5ndGg+NCYmdm9pZCAwIT09YXJndW1lbnRzWzRdP2FyZ3VtZW50c1s0XTowLHI9YXJndW1lbnRzLmxlbmd0aD41JiZ2b2lkIDAhPT1hcmd1bWVudHNbNV0/YXJndW1lbnRzWzVdOlwibWlkZGxlXCI7dGhpcy5fcHJvY2Vzc0xhYmVsKHQsZSxpKSx0aGlzLnNpemUubGVmdD1vLS41KnRoaXMuc2l6ZS53aWR0aCx0aGlzLnNpemUudG9wPW4tLjUqdGhpcy5zaXplLmhlaWdodCx0aGlzLnNpemUueUxpbmU9bisuNSooMS10aGlzLmxpbmVDb3VudCkqdGhpcy5mb250T3B0aW9ucy5zaXplLFwiaGFuZ2luZ1wiPT09ciYmKHRoaXMuc2l6ZS50b3ArPS41KnRoaXMuZm9udE9wdGlvbnMuc2l6ZSx0aGlzLnNpemUudG9wKz00LHRoaXMuc2l6ZS55TGluZSs9NCl9fSx7a2V5OlwiZ2V0Rm9ybWF0dGluZ1ZhbHVlc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8pe3ZhciBuPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm5cIm5vcm1hbFwiPT09ZT9cIm1vZFwiPT09aT9cIlwiOnRbaV06dm9pZCAwIT09dFtlXVtpXT90W2VdW2ldOnRbaV19LHI9e2NvbG9yOm4odGhpcy5mb250T3B0aW9ucyxvLFwiY29sb3JcIiksc2l6ZTpuKHRoaXMuZm9udE9wdGlvbnMsbyxcInNpemVcIiksZmFjZTpuKHRoaXMuZm9udE9wdGlvbnMsbyxcImZhY2VcIiksbW9kOm4odGhpcy5mb250T3B0aW9ucyxvLFwibW9kXCIpLHZhZGp1c3Q6bih0aGlzLmZvbnRPcHRpb25zLG8sXCJ2YWRqdXN0XCIpLHN0cm9rZVdpZHRoOnRoaXMuZm9udE9wdGlvbnMuc3Ryb2tlV2lkdGgsc3Ryb2tlQ29sb3I6dGhpcy5mb250T3B0aW9ucy5zdHJva2VDb2xvcn07KGV8fGkpJiYoXCJub3JtYWxcIj09PW8mJiEwPT09dGhpcy5mb250T3B0aW9ucy5jaG9vc2VyJiZ0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsSGlnaGxpZ2h0Qm9sZD9yLm1vZD1cImJvbGRcIjpcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLmZvbnRPcHRpb25zLmNob29zZXImJnRoaXMuZm9udE9wdGlvbnMuY2hvb3NlcihyLHRoaXMuZWxlbWVudE9wdGlvbnMuaWQsZSxpKSk7dmFyIHM9XCJcIjtyZXR1cm4gdm9pZCAwIT09ci5tb2QmJlwiXCIhPT1yLm1vZCYmKHMrPXIubW9kK1wiIFwiKSxzKz1yLnNpemUrXCJweCBcIityLmZhY2UsdC5mb250PXMucmVwbGFjZSgvXCIvZyxcIlwiKSxyLmZvbnQ9dC5mb250LHIuaGVpZ2h0PXIuc2l6ZSxyfX0se2tleTpcImRpZmZlcmVudFN0YXRlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCE9PXRoaXMuc2VsZWN0ZWRTdGF0ZXx8ZSE9PXRoaXMuaG92ZXJTdGF0ZX19LHtrZXk6XCJfcHJvY2Vzc0xhYmVsVGV4dFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8pe3JldHVybiBuZXcgaGwodCx0aGlzLGUsaSkucHJvY2VzcyhvKX19LHtrZXk6XCJfcHJvY2Vzc0xhYmVsXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe2lmKCExIT09dGhpcy5sYWJlbERpcnR5fHx0aGlzLmRpZmZlcmVudFN0YXRlKGUsaSkpe3ZhciBvPXRoaXMuX3Byb2Nlc3NMYWJlbFRleHQodCxlLGksdGhpcy5lbGVtZW50T3B0aW9ucy5sYWJlbCk7dGhpcy5mb250T3B0aW9ucy5taW5XZHQ+MCYmby53aWR0aDx0aGlzLmZvbnRPcHRpb25zLm1pbldkdCYmKG8ud2lkdGg9dGhpcy5mb250T3B0aW9ucy5taW5XZHQpLHRoaXMuc2l6ZS5sYWJlbEhlaWdodD1vLmhlaWdodCx0aGlzLmZvbnRPcHRpb25zLm1pbkhndD4wJiZvLmhlaWdodDx0aGlzLmZvbnRPcHRpb25zLm1pbkhndCYmKG8uaGVpZ2h0PXRoaXMuZm9udE9wdGlvbnMubWluSGd0KSx0aGlzLmxpbmVzPW8ubGluZXMsdGhpcy5saW5lQ291bnQ9by5saW5lcy5sZW5ndGgsdGhpcy5zaXplLndpZHRoPW8ud2lkdGgsdGhpcy5zaXplLmhlaWdodD1vLmhlaWdodCx0aGlzLnNlbGVjdGVkU3RhdGU9ZSx0aGlzLmhvdmVyU3RhdGU9aSx0aGlzLmxhYmVsRGlydHk9ITF9fX0se2tleTpcInZpc2libGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiAwIT09dGhpcy5zaXplLndpZHRoJiYwIT09dGhpcy5zaXplLmhlaWdodCYmdm9pZCAwIT09dGhpcy5lbGVtZW50T3B0aW9ucy5sYWJlbCYmISh0aGlzLmZvbnRPcHRpb25zLnNpemUqdGhpcy5ib2R5LnZpZXcuc2NhbGU8dGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQtMSl9fV0sW3trZXk6XCJwYXJzZUZvbnRTdHJpbmdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKCFlfHxcInN0cmluZ1wiIT10eXBlb2YgZSlyZXR1cm4hMTt2YXIgaT1lLnNwbGl0KFwiIFwiKTtyZXR1cm4gdC5zaXplPStpWzBdLnJlcGxhY2UoXCJweFwiLFwiXCIpLHQuZmFjZT1pWzFdLHQuY29sb3I9aVsyXSwhMH19XSksdH0oKSxjbD1yZShcIlJlZmxlY3RcIixcImNvbnN0cnVjdFwiKSx1bD1zKChmdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIShjbCgoZnVuY3Rpb24oKXt9KSxbXSx0KWluc3RhbmNlb2YgdCl9KSksZmw9IXMoKGZ1bmN0aW9uKCl7Y2woKGZ1bmN0aW9uKCl7fSkpfSkpLHBsPXVsfHxmbDtxKHt0YXJnZXQ6XCJSZWZsZWN0XCIsc3RhdDohMCxmb3JjZWQ6cGwsc2hhbTpwbH0se2NvbnN0cnVjdDpmdW5jdGlvbih0LGUpe04odCksUihlKTt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPDM/dDpOKGFyZ3VtZW50c1syXSk7aWYoZmwmJiF1bClyZXR1cm4gY2wodCxlLGkpO2lmKHQ9PWkpe3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBuZXcgdDtjYXNlIDE6cmV0dXJuIG5ldyB0KGVbMF0pO2Nhc2UgMjpyZXR1cm4gbmV3IHQoZVswXSxlWzFdKTtjYXNlIDM6cmV0dXJuIG5ldyB0KGVbMF0sZVsxXSxlWzJdKTtjYXNlIDQ6cmV0dXJuIG5ldyB0KGVbMF0sZVsxXSxlWzJdLGVbM10pfXZhciBvPVtudWxsXTtyZXR1cm4gby5wdXNoLmFwcGx5KG8sZSksbmV3KHZ0LmFwcGx5KHQsbykpfXZhciBuPWkucHJvdG90eXBlLHI9RGUobShuKT9uOk9iamVjdC5wcm90b3R5cGUpLHM9RnVuY3Rpb24uYXBwbHkuY2FsbCh0LHIsZSk7cmV0dXJuIG0ocyk/czpyfX0pO3ZhciB2bD1GLlJlZmxlY3QuY29uc3RydWN0LGdsPUJyO3Eoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITB9LHtzZXRQcm90b3R5cGVPZjpxZX0pO3ZhciB5bD1GLk9iamVjdC5zZXRQcm90b3R5cGVPZjtmdW5jdGlvbiBtbCh0LGUpe3JldHVybihtbD15bHx8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5fX3Byb3RvX189ZSx0fSkodCxlKX1mdW5jdGlvbiBibCh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTt0LnByb3RvdHlwZT1nbChlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJm1sKHQsZSl9ZnVuY3Rpb24gd2wodCxlKXtyZXR1cm4hZXx8XCJvYmplY3RcIiE9PWRuKGUpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP2Z1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiB0fSh0KTplfXZhciBrbD1lcjtmdW5jdGlvbiBfbCh0KXtyZXR1cm4oX2w9eWw/a2w6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19ffHxrbCh0KX0pKHQpfXZhciB4bD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8pe1BvKHRoaXMsdCksdGhpcy5ib2R5PWksdGhpcy5sYWJlbE1vZHVsZT1vLHRoaXMuc2V0T3B0aW9ucyhlKSx0aGlzLnRvcD12b2lkIDAsdGhpcy5sZWZ0PXZvaWQgMCx0aGlzLmhlaWdodD12b2lkIDAsdGhpcy53aWR0aD12b2lkIDAsdGhpcy5yYWRpdXM9dm9pZCAwLHRoaXMubWFyZ2luPXZvaWQgMCx0aGlzLnJlZnJlc2hOZWVkZWQ9ITAsdGhpcy5ib3VuZGluZ0JveD17dG9wOjAsbGVmdDowLHJpZ2h0OjAsYm90dG9tOjB9fXJldHVybiBJbyh0LFt7a2V5Olwic2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMub3B0aW9ucz10fX0se2tleTpcIl9zZXRNYXJnaW5zXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5tYXJnaW49e30sdGhpcy5vcHRpb25zLm1hcmdpbiYmKFwib2JqZWN0XCI9PWRuKHRoaXMub3B0aW9ucy5tYXJnaW4pPyh0aGlzLm1hcmdpbi50b3A9dGhpcy5vcHRpb25zLm1hcmdpbi50b3AsdGhpcy5tYXJnaW4ucmlnaHQ9dGhpcy5vcHRpb25zLm1hcmdpbi5yaWdodCx0aGlzLm1hcmdpbi5ib3R0b209dGhpcy5vcHRpb25zLm1hcmdpbi5ib3R0b20sdGhpcy5tYXJnaW4ubGVmdD10aGlzLm9wdGlvbnMubWFyZ2luLmxlZnQpOih0aGlzLm1hcmdpbi50b3A9dGhpcy5vcHRpb25zLm1hcmdpbix0aGlzLm1hcmdpbi5yaWdodD10aGlzLm9wdGlvbnMubWFyZ2luLHRoaXMubWFyZ2luLmJvdHRvbT10aGlzLm9wdGlvbnMubWFyZ2luLHRoaXMubWFyZ2luLmxlZnQ9dGhpcy5vcHRpb25zLm1hcmdpbikpLHQuYWRqdXN0U2l6ZXModGhpcy5tYXJnaW4pfX0se2tleTpcIl9kaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7cmV0dXJuIHQmJnRoaXMucmVzaXplKHQpLE1hdGgubWluKE1hdGguYWJzKHRoaXMud2lkdGgvMi9NYXRoLmNvcyhlKSksTWF0aC5hYnModGhpcy5oZWlnaHQvMi9NYXRoLnNpbihlKSkpK2l9fSx7a2V5OlwiZW5hYmxlU2hhZG93XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtlLnNoYWRvdyYmKHQuc2hhZG93Q29sb3I9ZS5zaGFkb3dDb2xvcix0LnNoYWRvd0JsdXI9ZS5zaGFkb3dTaXplLHQuc2hhZG93T2Zmc2V0WD1lLnNoYWRvd1gsdC5zaGFkb3dPZmZzZXRZPWUuc2hhZG93WSl9fSx7a2V5OlwiZGlzYWJsZVNoYWRvd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7ZS5zaGFkb3cmJih0LnNoYWRvd0NvbG9yPVwicmdiYSgwLDAsMCwwKVwiLHQuc2hhZG93Qmx1cj0wLHQuc2hhZG93T2Zmc2V0WD0wLHQuc2hhZG93T2Zmc2V0WT0wKX19LHtrZXk6XCJlbmFibGVCb3JkZXJEYXNoZXNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKCExIT09ZS5ib3JkZXJEYXNoZXMpaWYodm9pZCAwIT09dC5zZXRMaW5lRGFzaCl7dmFyIGk9ZS5ib3JkZXJEYXNoZXM7ITA9PT1pJiYoaT1bNSwxNV0pLHQuc2V0TGluZURhc2goaSl9ZWxzZSBjb25zb2xlLndhcm4oXCJzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBib3JkZXJzIGNhbm5vdCBiZSB1c2VkLlwiKSx0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlcz0hMSxlLmJvcmRlckRhc2hlcz0hMX19LHtrZXk6XCJkaXNhYmxlQm9yZGVyRGFzaGVzXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXshMSE9PWUuYm9yZGVyRGFzaGVzJiYodm9pZCAwIT09dC5zZXRMaW5lRGFzaD90LnNldExpbmVEYXNoKFswXSk6KGNvbnNvbGUud2FybihcInNldExpbmVEYXNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBUaGUgZGFzaGVkIGJvcmRlcnMgY2Fubm90IGJlIHVzZWQuXCIpLHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzPSExLGUuYm9yZGVyRGFzaGVzPSExKSl9fSx7a2V5OlwibmVlZHNSZWZyZXNoXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4hMD09PXRoaXMucmVmcmVzaE5lZWRlZD8odGhpcy5yZWZyZXNoTmVlZGVkPSExLCEwKTp2b2lkIDA9PT10aGlzLndpZHRofHx0aGlzLmxhYmVsTW9kdWxlLmRpZmZlcmVudFN0YXRlKHQsZSl9fSx7a2V5OlwiaW5pdENvbnRleHRGb3JEcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT1lLmJvcmRlcldpZHRoL3RoaXMuYm9keS52aWV3LnNjYWxlO3QubGluZVdpZHRoPU1hdGgubWluKHRoaXMud2lkdGgsaSksdC5zdHJva2VTdHlsZT1lLmJvcmRlckNvbG9yLHQuZmlsbFN0eWxlPWUuY29sb3J9fSx7a2V5OlwicGVyZm9ybVN0cm9rZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9ZS5ib3JkZXJXaWR0aC90aGlzLmJvZHkudmlldy5zY2FsZTt0LnNhdmUoKSxpPjAmJih0aGlzLmVuYWJsZUJvcmRlckRhc2hlcyh0LGUpLHQuc3Ryb2tlKCksdGhpcy5kaXNhYmxlQm9yZGVyRGFzaGVzKHQsZSkpLHQucmVzdG9yZSgpfX0se2tleTpcInBlcmZvcm1GaWxsXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0LnNhdmUoKSx0LmZpbGxTdHlsZT1lLmNvbG9yLHRoaXMuZW5hYmxlU2hhZG93KHQsZSksWHIodCkuY2FsbCh0KSx0aGlzLmRpc2FibGVTaGFkb3codCxlKSx0LnJlc3RvcmUoKSx0aGlzLnBlcmZvcm1TdHJva2UodCxlKX19LHtrZXk6XCJfYWRkQm91bmRpbmdCb3hNYXJnaW5cIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmJvdW5kaW5nQm94LmxlZnQtPXQsdGhpcy5ib3VuZGluZ0JveC50b3AtPXQsdGhpcy5ib3VuZGluZ0JveC5ib3R0b20rPXQsdGhpcy5ib3VuZGluZ0JveC5yaWdodCs9dH19LHtrZXk6XCJfdXBkYXRlQm91bmRpbmdCb3hcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4pe3ZvaWQgMCE9PWkmJnRoaXMucmVzaXplKGksbyxuKSx0aGlzLmxlZnQ9dC10aGlzLndpZHRoLzIsdGhpcy50b3A9ZS10aGlzLmhlaWdodC8yLHRoaXMuYm91bmRpbmdCb3gubGVmdD10aGlzLmxlZnQsdGhpcy5ib3VuZGluZ0JveC50b3A9dGhpcy50b3AsdGhpcy5ib3VuZGluZ0JveC5ib3R0b209dGhpcy50b3ArdGhpcy5oZWlnaHQsdGhpcy5ib3VuZGluZ0JveC5yaWdodD10aGlzLmxlZnQrdGhpcy53aWR0aH19LHtrZXk6XCJ1cGRhdGVCb3VuZGluZ0JveFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbil7dGhpcy5fdXBkYXRlQm91bmRpbmdCb3godCxlLGksbyxuKX19LHtrZXk6XCJnZXREaW1lbnNpb25zRnJvbUxhYmVsXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3RoaXMudGV4dFNpemU9dGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZSh0LGUsaSk7dmFyIG89dGhpcy50ZXh0U2l6ZS53aWR0aCxuPXRoaXMudGV4dFNpemUuaGVpZ2h0O3JldHVybiAwPT09byYmKG89MTQsbj0xNCkse3dpZHRoOm8saGVpZ2h0Om59fX1dKSx0fSgpO2Z1bmN0aW9uIEVsKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIE9sPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9RWwoaSk7ZnVuY3Rpb24gaSh0LG8sbil7dmFyIHI7cmV0dXJuIFBvKHRoaXMsaSksKHI9ZS5jYWxsKHRoaXMsdCxvLG4pKS5fc2V0TWFyZ2lucyhuKSxyfXJldHVybiBJbyhpLFt7a2V5OlwicmVzaXplXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMuc2VsZWN0ZWQsaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dGhpcy5ob3ZlcjtpZih0aGlzLm5lZWRzUmVmcmVzaChlLGkpKXt2YXIgbz10aGlzLmdldERpbWVuc2lvbnNGcm9tTGFiZWwodCxlLGkpO3RoaXMud2lkdGg9by53aWR0aCt0aGlzLm1hcmdpbi5yaWdodCt0aGlzLm1hcmdpbi5sZWZ0LHRoaXMuaGVpZ2h0PW8uaGVpZ2h0K3RoaXMubWFyZ2luLnRvcCt0aGlzLm1hcmdpbi5ib3R0b20sdGhpcy5yYWRpdXM9dGhpcy53aWR0aC8yfX19LHtrZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3RoaXMucmVzaXplKHQsbyxuKSx0aGlzLmxlZnQ9ZS10aGlzLndpZHRoLzIsdGhpcy50b3A9aS10aGlzLmhlaWdodC8yLHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KHQsciksa3QodCx0aGlzLmxlZnQsdGhpcy50b3AsdGhpcy53aWR0aCx0aGlzLmhlaWdodCxyLmJvcmRlclJhZGl1cyksdGhpcy5wZXJmb3JtRmlsbCh0LHIpLHRoaXMudXBkYXRlQm91bmRpbmdCb3goZSxpLHQsbyxuKSx0aGlzLmxhYmVsTW9kdWxlLmRyYXcodCx0aGlzLmxlZnQrdGhpcy50ZXh0U2l6ZS53aWR0aC8yK3RoaXMubWFyZ2luLmxlZnQsdGhpcy50b3ArdGhpcy50ZXh0U2l6ZS5oZWlnaHQvMit0aGlzLm1hcmdpbi50b3AsbyxuKX19LHtrZXk6XCJ1cGRhdGVCb3VuZGluZ0JveFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbil7dGhpcy5fdXBkYXRlQm91bmRpbmdCb3godCxlLGksbyxuKTt2YXIgcj10aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlclJhZGl1czt0aGlzLl9hZGRCb3VuZGluZ0JveE1hcmdpbihyKX19LHtrZXk6XCJkaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0JiZ0aGlzLnJlc2l6ZSh0KTt2YXIgaT10aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7cmV0dXJuIE1hdGgubWluKE1hdGguYWJzKHRoaXMud2lkdGgvMi9NYXRoLmNvcyhlKSksTWF0aC5hYnModGhpcy5oZWlnaHQvMi9NYXRoLnNpbihlKSkpK2l9fV0pLGl9KHhsKTtmdW5jdGlvbiBDbCh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciBTbD1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPUNsKGkpO2Z1bmN0aW9uIGkodCxvLG4pe3ZhciByO3JldHVybiBQbyh0aGlzLGkpLChyPWUuY2FsbCh0aGlzLHQsbyxuKSkubGFiZWxPZmZzZXQ9MCxyLnNlbGVjdGVkPSExLHJ9cmV0dXJuIElvKGksW3trZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3RoaXMub3B0aW9ucz10LHZvaWQgMD09PWUmJnZvaWQgMD09PWl8fHRoaXMuc2V0SW1hZ2VzKGUsaSl9fSx7a2V5Olwic2V0SW1hZ2VzXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtlJiZ0aGlzLnNlbGVjdGVkPyh0aGlzLmltYWdlT2JqPWUsdGhpcy5pbWFnZU9iakFsdD10KToodGhpcy5pbWFnZU9iaj10LHRoaXMuaW1hZ2VPYmpBbHQ9ZSl9fSx7a2V5Olwic3dpdGNoSW1hZ2VzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dCYmIXRoaXMuc2VsZWN0ZWR8fCF0JiZ0aGlzLnNlbGVjdGVkO2lmKHRoaXMuc2VsZWN0ZWQ9dCx2b2lkIDAhPT10aGlzLmltYWdlT2JqQWx0JiZlKXt2YXIgaT10aGlzLmltYWdlT2JqO3RoaXMuaW1hZ2VPYmo9dGhpcy5pbWFnZU9iakFsdCx0aGlzLmltYWdlT2JqQWx0PWl9fX0se2tleTpcIl9nZXRJbWFnZVBhZGRpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXt0b3A6MCxyaWdodDowLGJvdHRvbTowLGxlZnQ6MH07aWYodGhpcy5vcHRpb25zLmltYWdlUGFkZGluZyl7dmFyIGU9dGhpcy5vcHRpb25zLmltYWdlUGFkZGluZztcIm9iamVjdFwiPT1kbihlKT8odC50b3A9ZS50b3AsdC5yaWdodD1lLnJpZ2h0LHQuYm90dG9tPWUuYm90dG9tLHQubGVmdD1lLmxlZnQpOih0LnRvcD1lLHQucmlnaHQ9ZSx0LmJvdHRvbT1lLHQubGVmdD1lKX1yZXR1cm4gdH19LHtrZXk6XCJfcmVzaXplSW1hZ2VcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGU7aWYoITE9PT10aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLnVzZUltYWdlU2l6ZSl7dmFyIGk9MSxvPTE7dGhpcy5pbWFnZU9iai53aWR0aCYmdGhpcy5pbWFnZU9iai5oZWlnaHQmJih0aGlzLmltYWdlT2JqLndpZHRoPnRoaXMuaW1hZ2VPYmouaGVpZ2h0P2k9dGhpcy5pbWFnZU9iai53aWR0aC90aGlzLmltYWdlT2JqLmhlaWdodDpvPXRoaXMuaW1hZ2VPYmouaGVpZ2h0L3RoaXMuaW1hZ2VPYmoud2lkdGgpLHQ9Mip0aGlzLm9wdGlvbnMuc2l6ZSppLGU9Mip0aGlzLm9wdGlvbnMuc2l6ZSpvfWVsc2V7dmFyIG49dGhpcy5fZ2V0SW1hZ2VQYWRkaW5nKCk7dD10aGlzLmltYWdlT2JqLndpZHRoK24ubGVmdCtuLnJpZ2h0LGU9dGhpcy5pbWFnZU9iai5oZWlnaHQrbi50b3Arbi5ib3R0b219dGhpcy53aWR0aD10LHRoaXMuaGVpZ2h0PWUsdGhpcy5yYWRpdXM9LjUqdGhpcy53aWR0aH19LHtrZXk6XCJfZHJhd1Jhd0NpcmNsZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8pe3RoaXMuaW5pdENvbnRleHRGb3JEcmF3KHQsbyksd3QodCxlLGksby5zaXplKSx0aGlzLnBlcmZvcm1GaWxsKHQsbyl9fSx7a2V5OlwiX2RyYXdJbWFnZUF0UG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKDAhPXRoaXMuaW1hZ2VPYmoud2lkdGgpe3QuZ2xvYmFsQWxwaGE9dm9pZCAwIT09ZS5vcGFjaXR5P2Uub3BhY2l0eToxLHRoaXMuZW5hYmxlU2hhZG93KHQsZSk7dmFyIGk9MTshMD09PXRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuaW50ZXJwb2xhdGlvbiYmKGk9dGhpcy5pbWFnZU9iai53aWR0aC90aGlzLndpZHRoL3RoaXMuYm9keS52aWV3LnNjYWxlKTt2YXIgbz10aGlzLl9nZXRJbWFnZVBhZGRpbmcoKSxuPXRoaXMubGVmdCtvLmxlZnQscj10aGlzLnRvcCtvLnRvcCxzPXRoaXMud2lkdGgtby5sZWZ0LW8ucmlnaHQsYT10aGlzLmhlaWdodC1vLnRvcC1vLmJvdHRvbTt0aGlzLmltYWdlT2JqLmRyYXdJbWFnZUF0UG9zaXRpb24odCxpLG4scixzLGEpLHRoaXMuZGlzYWJsZVNoYWRvdyh0LGUpfX19LHtrZXk6XCJfZHJhd0ltYWdlTGFiZWxcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4pe3ZhciByPTA7aWYodm9pZCAwIT09dGhpcy5oZWlnaHQpe3I9LjUqdGhpcy5oZWlnaHQ7dmFyIHM9dGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZSh0LG8sbik7cy5saW5lQ291bnQ+PTEmJihyKz1zLmhlaWdodC8yKX12YXIgYT1pK3I7dGhpcy5vcHRpb25zLmxhYmVsJiYodGhpcy5sYWJlbE9mZnNldD1yKSx0aGlzLmxhYmVsTW9kdWxlLmRyYXcodCxlLGEsbyxuLFwiaGFuZ2luZ1wiKX19XSksaX0oeGwpO2Z1bmN0aW9uIFRsKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIE1sPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9VGwoaSk7ZnVuY3Rpb24gaSh0LG8sbil7dmFyIHI7cmV0dXJuIFBvKHRoaXMsaSksKHI9ZS5jYWxsKHRoaXMsdCxvLG4pKS5fc2V0TWFyZ2lucyhuKSxyfXJldHVybiBJbyhpLFt7a2V5OlwicmVzaXplXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMuc2VsZWN0ZWQsaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dGhpcy5ob3ZlcjtpZih0aGlzLm5lZWRzUmVmcmVzaChlLGkpKXt2YXIgbz10aGlzLmdldERpbWVuc2lvbnNGcm9tTGFiZWwodCxlLGkpLG49TWF0aC5tYXgoby53aWR0aCt0aGlzLm1hcmdpbi5yaWdodCt0aGlzLm1hcmdpbi5sZWZ0LG8uaGVpZ2h0K3RoaXMubWFyZ2luLnRvcCt0aGlzLm1hcmdpbi5ib3R0b20pO3RoaXMub3B0aW9ucy5zaXplPW4vMix0aGlzLndpZHRoPW4sdGhpcy5oZWlnaHQ9bix0aGlzLnJhZGl1cz10aGlzLndpZHRoLzJ9fX0se2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7dGhpcy5yZXNpemUodCxvLG4pLHRoaXMubGVmdD1lLXRoaXMud2lkdGgvMix0aGlzLnRvcD1pLXRoaXMuaGVpZ2h0LzIsdGhpcy5fZHJhd1Jhd0NpcmNsZSh0LGUsaSxyKSx0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KGUsaSksdGhpcy5sYWJlbE1vZHVsZS5kcmF3KHQsdGhpcy5sZWZ0K3RoaXMudGV4dFNpemUud2lkdGgvMit0aGlzLm1hcmdpbi5sZWZ0LGksbyxuKX19LHtrZXk6XCJ1cGRhdGVCb3VuZGluZ0JveFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy5ib3VuZGluZ0JveC50b3A9ZS10aGlzLm9wdGlvbnMuc2l6ZSx0aGlzLmJvdW5kaW5nQm94LmxlZnQ9dC10aGlzLm9wdGlvbnMuc2l6ZSx0aGlzLmJvdW5kaW5nQm94LnJpZ2h0PXQrdGhpcy5vcHRpb25zLnNpemUsdGhpcy5ib3VuZGluZ0JveC5ib3R0b209ZSt0aGlzLm9wdGlvbnMuc2l6ZX19LHtrZXk6XCJkaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnRoaXMucmVzaXplKHQpLC41KnRoaXMud2lkdGh9fV0pLGl9KFNsKTtmdW5jdGlvbiBQbCh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciBEbD1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPVBsKGkpO2Z1bmN0aW9uIGkodCxvLG4scixzKXt2YXIgYTtyZXR1cm4gUG8odGhpcyxpKSwoYT1lLmNhbGwodGhpcyx0LG8sbikpLnNldEltYWdlcyhyLHMpLGF9cmV0dXJuIElvKGksW3trZXk6XCJyZXNpemVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5zZWxlY3RlZCxpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp0aGlzLmhvdmVyLG89dm9pZCAwPT09dGhpcy5pbWFnZU9iai5zcmN8fHZvaWQgMD09PXRoaXMuaW1hZ2VPYmoud2lkdGh8fHZvaWQgMD09PXRoaXMuaW1hZ2VPYmouaGVpZ2h0O2lmKG8pe3ZhciBuPTIqdGhpcy5vcHRpb25zLnNpemU7cmV0dXJuIHRoaXMud2lkdGg9bix0aGlzLmhlaWdodD1uLHZvaWQodGhpcy5yYWRpdXM9LjUqdGhpcy53aWR0aCl9dGhpcy5uZWVkc1JlZnJlc2goZSxpKSYmdGhpcy5fcmVzaXplSW1hZ2UoKX19LHtrZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3RoaXMuc3dpdGNoSW1hZ2VzKG8pLHRoaXMucmVzaXplKCk7dmFyIHM9ZSxhPWk7XCJ0b3AtbGVmdFwiPT09dGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luPyh0aGlzLmxlZnQ9ZSx0aGlzLnRvcD1pLHMrPXRoaXMud2lkdGgvMixhKz10aGlzLmhlaWdodC8yKToodGhpcy5sZWZ0PWUtdGhpcy53aWR0aC8yLHRoaXMudG9wPWktdGhpcy5oZWlnaHQvMiksdGhpcy5fZHJhd1Jhd0NpcmNsZSh0LHMsYSxyKSx0LnNhdmUoKSx0LmNsaXAoKSx0aGlzLl9kcmF3SW1hZ2VBdFBvc2l0aW9uKHQsciksdC5yZXN0b3JlKCksdGhpcy5fZHJhd0ltYWdlTGFiZWwodCxzLGEsbyxuKSx0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KGUsaSl9fSx7a2V5OlwidXBkYXRlQm91bmRpbmdCb3hcIix2YWx1ZTpmdW5jdGlvbih0LGUpe1widG9wLWxlZnRcIj09PXRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuY29vcmRpbmF0ZU9yaWdpbj8odGhpcy5ib3VuZGluZ0JveC50b3A9ZSx0aGlzLmJvdW5kaW5nQm94LmxlZnQ9dCx0aGlzLmJvdW5kaW5nQm94LnJpZ2h0PXQrMip0aGlzLm9wdGlvbnMuc2l6ZSx0aGlzLmJvdW5kaW5nQm94LmJvdHRvbT1lKzIqdGhpcy5vcHRpb25zLnNpemUpOih0aGlzLmJvdW5kaW5nQm94LnRvcD1lLXRoaXMub3B0aW9ucy5zaXplLHRoaXMuYm91bmRpbmdCb3gubGVmdD10LXRoaXMub3B0aW9ucy5zaXplLHRoaXMuYm91bmRpbmdCb3gucmlnaHQ9dCt0aGlzLm9wdGlvbnMuc2l6ZSx0aGlzLmJvdW5kaW5nQm94LmJvdHRvbT1lK3RoaXMub3B0aW9ucy5zaXplKSx0aGlzLmJvdW5kaW5nQm94LmxlZnQ9TWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KSx0aGlzLmJvdW5kaW5nQm94LnJpZ2h0PU1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQrdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKSx0aGlzLmJvdW5kaW5nQm94LmJvdHRvbT1NYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSx0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSt0aGlzLmxhYmVsT2Zmc2V0KX19LHtrZXk6XCJkaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnRoaXMucmVzaXplKHQpLC41KnRoaXMud2lkdGh9fV0pLGl9KFNsKTtmdW5jdGlvbiBCbCh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciBJbD1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPUJsKGkpO2Z1bmN0aW9uIGkodCxvLG4pe3JldHVybiBQbyh0aGlzLGkpLGUuY2FsbCh0aGlzLHQsbyxuKX1yZXR1cm4gSW8oaSxbe2tleTpcInJlc2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLnNlbGVjdGVkLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnRoaXMuaG92ZXIsbz1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106e3NpemU6dGhpcy5vcHRpb25zLnNpemV9O2lmKHRoaXMubmVlZHNSZWZyZXNoKGUsaSkpe3ZhciBuLHI7dGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZSh0LGUsaSk7dmFyIHM9MipvLnNpemU7dGhpcy53aWR0aD1udWxsIT09KG49dGhpcy5jdXN0b21TaXplV2lkdGgpJiZ2b2lkIDAhPT1uP246cyx0aGlzLmhlaWdodD1udWxsIT09KHI9dGhpcy5jdXN0b21TaXplSGVpZ2h0KSYmdm9pZCAwIT09cj9yOnMsdGhpcy5yYWRpdXM9LjUqdGhpcy53aWR0aH19fSx7a2V5OlwiX2RyYXdTaGFwZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyLHMsYSl7dmFyIGgsZD10aGlzO3JldHVybiB0aGlzLnJlc2l6ZSh0LHIscyxhKSx0aGlzLmxlZnQ9by10aGlzLndpZHRoLzIsdGhpcy50b3A9bi10aGlzLmhlaWdodC8yLHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KHQsYSksKGg9ZSxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoT3QsaCk/T3RbaF06ZnVuY3Rpb24odCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsaT1uZXcgQXJyYXkoZT4xP2UtMTowKSxvPTE7bzxlO28rKylpW28tMV09YXJndW1lbnRzW29dO0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGVbaF0uY2FsbCh0LGkpfSkodCxvLG4sYS5zaXplKSx0aGlzLnBlcmZvcm1GaWxsKHQsYSksdm9pZCAwIT09dGhpcy5vcHRpb25zLmljb24mJnZvaWQgMCE9PXRoaXMub3B0aW9ucy5pY29uLmNvZGUmJih0LmZvbnQ9KHI/XCJib2xkIFwiOlwiXCIpK3RoaXMuaGVpZ2h0LzIrXCJweCBcIisodGhpcy5vcHRpb25zLmljb24uZmFjZXx8XCJGb250QXdlc29tZVwiKSx0LmZpbGxTdHlsZT10aGlzLm9wdGlvbnMuaWNvbi5jb2xvcnx8XCJibGFja1wiLHQudGV4dEFsaWduPVwiY2VudGVyXCIsdC50ZXh0QmFzZWxpbmU9XCJtaWRkbGVcIix0LmZpbGxUZXh0KHRoaXMub3B0aW9ucy5pY29uLmNvZGUsbyxuKSkse2RyYXdFeHRlcm5hbExhYmVsOmZ1bmN0aW9uKCl7aWYodm9pZCAwIT09ZC5vcHRpb25zLmxhYmVsKXtkLmxhYmVsTW9kdWxlLmNhbGN1bGF0ZUxhYmVsU2l6ZSh0LHIscyxvLG4sXCJoYW5naW5nXCIpO3ZhciBlPW4rLjUqZC5oZWlnaHQrLjUqZC5sYWJlbE1vZHVsZS5zaXplLmhlaWdodDtkLmxhYmVsTW9kdWxlLmRyYXcodCxvLGUscixzLFwiaGFuZ2luZ1wiKX1kLnVwZGF0ZUJvdW5kaW5nQm94KG8sbil9fX19LHtrZXk6XCJ1cGRhdGVCb3VuZGluZ0JveFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy5ib3VuZGluZ0JveC50b3A9ZS10aGlzLm9wdGlvbnMuc2l6ZSx0aGlzLmJvdW5kaW5nQm94LmxlZnQ9dC10aGlzLm9wdGlvbnMuc2l6ZSx0aGlzLmJvdW5kaW5nQm94LnJpZ2h0PXQrdGhpcy5vcHRpb25zLnNpemUsdGhpcy5ib3VuZGluZ0JveC5ib3R0b209ZSt0aGlzLm9wdGlvbnMuc2l6ZSx2b2lkIDAhPT10aGlzLm9wdGlvbnMubGFiZWwmJnRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aD4wJiYodGhpcy5ib3VuZGluZ0JveC5sZWZ0PU1hdGgubWluKHRoaXMuYm91bmRpbmdCb3gubGVmdCx0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCksdGhpcy5ib3VuZGluZ0JveC5yaWdodD1NYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0K3RoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCksdGhpcy5ib3VuZGluZ0JveC5ib3R0b209TWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sdGhpcy5ib3VuZGluZ0JveC5ib3R0b20rdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodCkpfX1dKSxpfSh4bCk7ZnVuY3Rpb24gemwodCxlKXt2YXIgaT14bih0KTtpZih3byl7dmFyIG89d28odCk7ZSYmKG89YXIobykuY2FsbChvLChmdW5jdGlvbihlKXtyZXR1cm4gRW8odCxlKS5lbnVtZXJhYmxlfSkpKSxpLnB1c2guYXBwbHkoaSxvKX1yZXR1cm4gaX1mdW5jdGlvbiBGbCh0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgaSxvPW51bGwhPWFyZ3VtZW50c1tlXT9hcmd1bWVudHNbZV06e307aWYoZSUyKURuKGk9emwoT2JqZWN0KG8pLCEwKSkuY2FsbChpLChmdW5jdGlvbihlKXt6byh0LGUsb1tlXSl9KSk7ZWxzZSBpZihDbylTbyh0LENvKG8pKTtlbHNle3ZhciBuO0RuKG49emwoT2JqZWN0KG8pKSkuY2FsbChuLChmdW5jdGlvbihlKXtNbyh0LGUsRW8obyxlKSl9KSl9fXJldHVybiB0fWZ1bmN0aW9uIE5sKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIEFsPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9TmwoaSk7ZnVuY3Rpb24gaSh0LG8sbixyKXt2YXIgcztyZXR1cm4gUG8odGhpcyxpKSwocz1lLmNhbGwodGhpcyx0LG8sbixyKSkuY3R4UmVuZGVyZXI9cixzfXJldHVybiBJbyhpLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXt0aGlzLnJlc2l6ZSh0LG8sbixyKSx0aGlzLmxlZnQ9ZS10aGlzLndpZHRoLzIsdGhpcy50b3A9aS10aGlzLmhlaWdodC8yLHQuc2F2ZSgpO3ZhciBzPXRoaXMuY3R4UmVuZGVyZXIoe2N0eDp0LGlkOnRoaXMub3B0aW9ucy5pZCx4OmUseTppLHN0YXRlOntzZWxlY3RlZDpvLGhvdmVyOm59LHN0eWxlOkZsKHt9LHIpLGxhYmVsOnRoaXMub3B0aW9ucy5sYWJlbH0pO2lmKG51bGwhPXMuZHJhd05vZGUmJnMuZHJhd05vZGUoKSx0LnJlc3RvcmUoKSxzLmRyYXdFeHRlcm5hbExhYmVsKXt2YXIgYT1zLmRyYXdFeHRlcm5hbExhYmVsO3MuZHJhd0V4dGVybmFsTGFiZWw9ZnVuY3Rpb24oKXt0LnNhdmUoKSxhKCksdC5yZXN0b3JlKCl9fXJldHVybiBzLm5vZGVEaW1lbnNpb25zJiYodGhpcy5jdXN0b21TaXplV2lkdGg9cy5ub2RlRGltZW5zaW9ucy53aWR0aCx0aGlzLmN1c3RvbVNpemVIZWlnaHQ9cy5ub2RlRGltZW5zaW9ucy5oZWlnaHQpLHN9fSx7a2V5OlwiZGlzdGFuY2VUb0JvcmRlclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIodCxlKX19XSksaX0oSWwpO2Z1bmN0aW9uIFJsKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIGpsPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9UmwoaSk7ZnVuY3Rpb24gaSh0LG8sbil7dmFyIHI7cmV0dXJuIFBvKHRoaXMsaSksKHI9ZS5jYWxsKHRoaXMsdCxvLG4pKS5fc2V0TWFyZ2lucyhuKSxyfXJldHVybiBJbyhpLFt7a2V5OlwicmVzaXplXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe2lmKHRoaXMubmVlZHNSZWZyZXNoKGUsaSkpe3ZhciBvPXRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbCh0LGUsaSkud2lkdGgrdGhpcy5tYXJnaW4ucmlnaHQrdGhpcy5tYXJnaW4ubGVmdDt0aGlzLndpZHRoPW8sdGhpcy5oZWlnaHQ9byx0aGlzLnJhZGl1cz10aGlzLndpZHRoLzJ9fX0se2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7dGhpcy5yZXNpemUodCxvLG4pLHRoaXMubGVmdD1lLXRoaXMud2lkdGgvMix0aGlzLnRvcD1pLXRoaXMuaGVpZ2h0LzIsdGhpcy5pbml0Q29udGV4dEZvckRyYXcodCxyKSx4dCh0LGUtdGhpcy53aWR0aC8yLGktdGhpcy5oZWlnaHQvMix0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLnBlcmZvcm1GaWxsKHQsciksdGhpcy51cGRhdGVCb3VuZGluZ0JveChlLGksdCxvLG4pLHRoaXMubGFiZWxNb2R1bGUuZHJhdyh0LHRoaXMubGVmdCt0aGlzLnRleHRTaXplLndpZHRoLzIrdGhpcy5tYXJnaW4ubGVmdCx0aGlzLnRvcCt0aGlzLnRleHRTaXplLmhlaWdodC8yK3RoaXMubWFyZ2luLnRvcCxvLG4pfX0se2tleTpcImRpc3RhbmNlVG9Cb3JkZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKHQsZSl9fV0pLGl9KHhsKTtmdW5jdGlvbiBMbCh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciBIbD1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPUxsKGkpO2Z1bmN0aW9uIGkodCxvLG4pe3JldHVybiBQbyh0aGlzLGkpLGUuY2FsbCh0aGlzLHQsbyxuKX1yZXR1cm4gSW8oaSxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7cmV0dXJuIHRoaXMuX2RyYXdTaGFwZSh0LFwiZGlhbW9uZFwiLDQsZSxpLG8sbixyKX19LHtrZXk6XCJkaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcih0LGUpfX1dKSxpfShJbCk7ZnVuY3Rpb24gV2wodCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgVmw9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1XbChpKTtmdW5jdGlvbiBpKHQsbyxuKXtyZXR1cm4gUG8odGhpcyxpKSxlLmNhbGwodGhpcyx0LG8sbil9cmV0dXJuIElvKGksW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3JldHVybiB0aGlzLl9kcmF3U2hhcGUodCxcImNpcmNsZVwiLDIsZSxpLG8sbixyKX19LHtrZXk6XCJkaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnRoaXMucmVzaXplKHQpLHRoaXMub3B0aW9ucy5zaXplfX1dKSxpfShJbCk7ZnVuY3Rpb24gcWwodCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgVWw9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1xbChpKTtmdW5jdGlvbiBpKHQsbyxuKXtyZXR1cm4gUG8odGhpcyxpKSxlLmNhbGwodGhpcyx0LG8sbil9cmV0dXJuIElvKGksW3trZXk6XCJyZXNpemVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5zZWxlY3RlZCxpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp0aGlzLmhvdmVyO2lmKHRoaXMubmVlZHNSZWZyZXNoKGUsaSkpe3ZhciBvPXRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbCh0LGUsaSk7dGhpcy5oZWlnaHQ9MipvLmhlaWdodCx0aGlzLndpZHRoPW8ud2lkdGgrby5oZWlnaHQsdGhpcy5yYWRpdXM9LjUqdGhpcy53aWR0aH19fSx7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXt0aGlzLnJlc2l6ZSh0LG8sbiksdGhpcy5sZWZ0PWUtLjUqdGhpcy53aWR0aCx0aGlzLnRvcD1pLS41KnRoaXMuaGVpZ2h0LHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KHQsciksX3QodCx0aGlzLmxlZnQsdGhpcy50b3AsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5wZXJmb3JtRmlsbCh0LHIpLHRoaXMudXBkYXRlQm91bmRpbmdCb3goZSxpLHQsbyxuKSx0aGlzLmxhYmVsTW9kdWxlLmRyYXcodCxlLGksbyxuKX19LHtrZXk6XCJkaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0JiZ0aGlzLnJlc2l6ZSh0KTt2YXIgaT0uNSp0aGlzLndpZHRoLG89LjUqdGhpcy5oZWlnaHQsbj1NYXRoLnNpbihlKSppLHI9TWF0aC5jb3MoZSkqbztyZXR1cm4gaSpvL01hdGguc3FydChuKm4rcipyKX19XSksaX0oeGwpO2Z1bmN0aW9uIFlsKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIFhsPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9WWwoaSk7ZnVuY3Rpb24gaSh0LG8sbil7dmFyIHI7cmV0dXJuIFBvKHRoaXMsaSksKHI9ZS5jYWxsKHRoaXMsdCxvLG4pKS5fc2V0TWFyZ2lucyhuKSxyfXJldHVybiBJbyhpLFt7a2V5OlwicmVzaXplXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3RoaXMubmVlZHNSZWZyZXNoKGUsaSkmJih0aGlzLmljb25TaXplPXt3aWR0aDpOdW1iZXIodGhpcy5vcHRpb25zLmljb24uc2l6ZSksaGVpZ2h0Ok51bWJlcih0aGlzLm9wdGlvbnMuaWNvbi5zaXplKX0sdGhpcy53aWR0aD10aGlzLmljb25TaXplLndpZHRoK3RoaXMubWFyZ2luLnJpZ2h0K3RoaXMubWFyZ2luLmxlZnQsdGhpcy5oZWlnaHQ9dGhpcy5pY29uU2l6ZS5oZWlnaHQrdGhpcy5tYXJnaW4udG9wK3RoaXMubWFyZ2luLmJvdHRvbSx0aGlzLnJhZGl1cz0uNSp0aGlzLndpZHRoKX19LHtrZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3ZhciBzPXRoaXM7cmV0dXJuIHRoaXMucmVzaXplKHQsbyxuKSx0aGlzLm9wdGlvbnMuaWNvbi5zaXplPXRoaXMub3B0aW9ucy5pY29uLnNpemV8fDUwLHRoaXMubGVmdD1lLXRoaXMud2lkdGgvMix0aGlzLnRvcD1pLXRoaXMuaGVpZ2h0LzIsdGhpcy5faWNvbih0LGUsaSxvLG4scikse2RyYXdFeHRlcm5hbExhYmVsOmZ1bmN0aW9uKCl7aWYodm9pZCAwIT09cy5vcHRpb25zLmxhYmVsKXtzLmxhYmVsTW9kdWxlLmRyYXcodCxzLmxlZnQrcy5pY29uU2l6ZS53aWR0aC8yK3MubWFyZ2luLmxlZnQsaStzLmhlaWdodC8yKzUsbyl9cy51cGRhdGVCb3VuZGluZ0JveChlLGkpfX19fSx7a2V5OlwidXBkYXRlQm91bmRpbmdCb3hcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKHRoaXMuYm91bmRpbmdCb3gudG9wPWUtLjUqdGhpcy5vcHRpb25zLmljb24uc2l6ZSx0aGlzLmJvdW5kaW5nQm94LmxlZnQ9dC0uNSp0aGlzLm9wdGlvbnMuaWNvbi5zaXplLHRoaXMuYm91bmRpbmdCb3gucmlnaHQ9dCsuNSp0aGlzLm9wdGlvbnMuaWNvbi5zaXplLHRoaXMuYm91bmRpbmdCb3guYm90dG9tPWUrLjUqdGhpcy5vcHRpb25zLmljb24uc2l6ZSx2b2lkIDAhPT10aGlzLm9wdGlvbnMubGFiZWwmJnRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aD4wKXt0aGlzLmJvdW5kaW5nQm94LmxlZnQ9TWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KSx0aGlzLmJvdW5kaW5nQm94LnJpZ2h0PU1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQrdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKSx0aGlzLmJvdW5kaW5nQm94LmJvdHRvbT1NYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSx0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSt0aGlzLmxhYmVsTW9kdWxlLnNpemUuaGVpZ2h0KzUpfX19LHtrZXk6XCJfaWNvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXt2YXIgcz1OdW1iZXIodGhpcy5vcHRpb25zLmljb24uc2l6ZSk7dm9pZCAwIT09dGhpcy5vcHRpb25zLmljb24uY29kZT8odC5mb250PVtudWxsIT10aGlzLm9wdGlvbnMuaWNvbi53ZWlnaHQ/dGhpcy5vcHRpb25zLmljb24ud2VpZ2h0Om8/XCJib2xkXCI6XCJcIiwobnVsbCE9dGhpcy5vcHRpb25zLmljb24ud2VpZ2h0JiZvPzU6MCkrcytcInB4XCIsdGhpcy5vcHRpb25zLmljb24uZmFjZV0uam9pbihcIiBcIiksdC5maWxsU3R5bGU9dGhpcy5vcHRpb25zLmljb24uY29sb3J8fFwiYmxhY2tcIix0LnRleHRBbGlnbj1cImNlbnRlclwiLHQudGV4dEJhc2VsaW5lPVwibWlkZGxlXCIsdGhpcy5lbmFibGVTaGFkb3codCxyKSx0LmZpbGxUZXh0KHRoaXMub3B0aW9ucy5pY29uLmNvZGUsZSxpKSx0aGlzLmRpc2FibGVTaGFkb3codCxyKSk6Y29uc29sZS5lcnJvcihcIldoZW4gdXNpbmcgdGhlIGljb24gc2hhcGUsIHlvdSBuZWVkIHRvIGRlZmluZSB0aGUgY29kZSBpbiB0aGUgaWNvbiBvcHRpb25zIG9iamVjdC4gVGhpcyBjYW4gYmUgZG9uZSBwZXIgbm9kZSBvciBnbG9iYWxseS5cIil9fSx7a2V5OlwiZGlzdGFuY2VUb0JvcmRlclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIodCxlKX19XSksaX0oeGwpO2Z1bmN0aW9uIEdsKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIEtsPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9R2woaSk7ZnVuY3Rpb24gaSh0LG8sbixyLHMpe3ZhciBhO3JldHVybiBQbyh0aGlzLGkpLChhPWUuY2FsbCh0aGlzLHQsbyxuKSkuc2V0SW1hZ2VzKHIscyksYX1yZXR1cm4gSW8oaSxbe2tleTpcInJlc2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLnNlbGVjdGVkLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnRoaXMuaG92ZXIsbz12b2lkIDA9PT10aGlzLmltYWdlT2JqLnNyY3x8dm9pZCAwPT09dGhpcy5pbWFnZU9iai53aWR0aHx8dm9pZCAwPT09dGhpcy5pbWFnZU9iai5oZWlnaHQ7aWYobyl7dmFyIG49Mip0aGlzLm9wdGlvbnMuc2l6ZTtyZXR1cm4gdGhpcy53aWR0aD1uLHZvaWQodGhpcy5oZWlnaHQ9bil9dGhpcy5uZWVkc1JlZnJlc2goZSxpKSYmdGhpcy5fcmVzaXplSW1hZ2UoKX19LHtrZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3Quc2F2ZSgpLHRoaXMuc3dpdGNoSW1hZ2VzKG8pLHRoaXMucmVzaXplKCk7dmFyIHM9ZSxhPWk7aWYoXCJ0b3AtbGVmdFwiPT09dGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luPyh0aGlzLmxlZnQ9ZSx0aGlzLnRvcD1pLHMrPXRoaXMud2lkdGgvMixhKz10aGlzLmhlaWdodC8yKToodGhpcy5sZWZ0PWUtdGhpcy53aWR0aC8yLHRoaXMudG9wPWktdGhpcy5oZWlnaHQvMiksITA9PT10aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLnVzZUJvcmRlcldpdGhJbWFnZSl7dmFyIGg9dGhpcy5vcHRpb25zLmJvcmRlcldpZHRoLGQ9dGhpcy5vcHRpb25zLmJvcmRlcldpZHRoU2VsZWN0ZWR8fDIqdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoLGw9KG8/ZDpoKS90aGlzLmJvZHkudmlldy5zY2FsZTt0LmxpbmVXaWR0aD1NYXRoLm1pbih0aGlzLndpZHRoLGwpLHQuYmVnaW5QYXRoKCk7dmFyIGM9bz90aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjpuP3RoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5ib3JkZXI6dGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcix1PW8/dGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kOm4/dGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJhY2tncm91bmQ6dGhpcy5vcHRpb25zLmNvbG9yLmJhY2tncm91bmQ7dm9pZCAwIT09ci5vcGFjaXR5JiYoYz1zaChjLHIub3BhY2l0eSksdT1zaCh1LHIub3BhY2l0eSkpLHQuc3Ryb2tlU3R5bGU9Yyx0LmZpbGxTdHlsZT11LHQucmVjdCh0aGlzLmxlZnQtLjUqdC5saW5lV2lkdGgsdGhpcy50b3AtLjUqdC5saW5lV2lkdGgsdGhpcy53aWR0aCt0LmxpbmVXaWR0aCx0aGlzLmhlaWdodCt0LmxpbmVXaWR0aCksWHIodCkuY2FsbCh0KSx0aGlzLnBlcmZvcm1TdHJva2UodCxyKSx0LmNsb3NlUGF0aCgpfXRoaXMuX2RyYXdJbWFnZUF0UG9zaXRpb24odCxyKSx0aGlzLl9kcmF3SW1hZ2VMYWJlbCh0LHMsYSxvLG4pLHRoaXMudXBkYXRlQm91bmRpbmdCb3goZSxpKSx0LnJlc3RvcmUoKX19LHtrZXk6XCJ1cGRhdGVCb3VuZGluZ0JveFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy5yZXNpemUoKSxcInRvcC1sZWZ0XCI9PT10aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4/KHRoaXMubGVmdD10LHRoaXMudG9wPWUpOih0aGlzLmxlZnQ9dC10aGlzLndpZHRoLzIsdGhpcy50b3A9ZS10aGlzLmhlaWdodC8yKSx0aGlzLmJvdW5kaW5nQm94LmxlZnQ9dGhpcy5sZWZ0LHRoaXMuYm91bmRpbmdCb3gudG9wPXRoaXMudG9wLHRoaXMuYm91bmRpbmdCb3guYm90dG9tPXRoaXMudG9wK3RoaXMuaGVpZ2h0LHRoaXMuYm91bmRpbmdCb3gucmlnaHQ9dGhpcy5sZWZ0K3RoaXMud2lkdGgsdm9pZCAwIT09dGhpcy5vcHRpb25zLmxhYmVsJiZ0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGg+MCYmKHRoaXMuYm91bmRpbmdCb3gubGVmdD1NYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQpLHRoaXMuYm91bmRpbmdCb3gucmlnaHQ9TWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5yaWdodCx0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCt0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGgpLHRoaXMuYm91bmRpbmdCb3guYm90dG9tPU1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLHRoaXMuYm91bmRpbmdCb3guYm90dG9tK3RoaXMubGFiZWxPZmZzZXQpKX19LHtrZXk6XCJkaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcih0LGUpfX1dKSxpfShTbCk7ZnVuY3Rpb24gJGwodCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgUWw9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT0kbChpKTtmdW5jdGlvbiBpKHQsbyxuKXtyZXR1cm4gUG8odGhpcyxpKSxlLmNhbGwodGhpcyx0LG8sbil9cmV0dXJuIElvKGksW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3JldHVybiB0aGlzLl9kcmF3U2hhcGUodCxcInNxdWFyZVwiLDIsZSxpLG8sbixyKX19LHtrZXk6XCJkaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcih0LGUpfX1dKSxpfShJbCk7ZnVuY3Rpb24gWmwodCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgSmw9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1abChpKTtmdW5jdGlvbiBpKHQsbyxuKXtyZXR1cm4gUG8odGhpcyxpKSxlLmNhbGwodGhpcyx0LG8sbil9cmV0dXJuIElvKGksW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3JldHVybiB0aGlzLl9kcmF3U2hhcGUodCxcImhleGFnb25cIiw0LGUsaSxvLG4scil9fSx7a2V5OlwiZGlzdGFuY2VUb0JvcmRlclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIodCxlKX19XSksaX0oSWwpO2Z1bmN0aW9uIHRjKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIGVjPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9dGMoaSk7ZnVuY3Rpb24gaSh0LG8sbil7cmV0dXJuIFBvKHRoaXMsaSksZS5jYWxsKHRoaXMsdCxvLG4pfXJldHVybiBJbyhpLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXtyZXR1cm4gdGhpcy5fZHJhd1NoYXBlKHQsXCJzdGFyXCIsNCxlLGksbyxuLHIpfX0se2tleTpcImRpc3RhbmNlVG9Cb3JkZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKHQsZSl9fV0pLGl9KElsKTtmdW5jdGlvbiBpYyh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciBvYz1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPWljKGkpO2Z1bmN0aW9uIGkodCxvLG4pe3ZhciByO3JldHVybiBQbyh0aGlzLGkpLChyPWUuY2FsbCh0aGlzLHQsbyxuKSkuX3NldE1hcmdpbnMobikscn1yZXR1cm4gSW8oaSxbe2tleTpcInJlc2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt0aGlzLm5lZWRzUmVmcmVzaChlLGkpJiYodGhpcy50ZXh0U2l6ZT10aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKHQsZSxpKSx0aGlzLndpZHRoPXRoaXMudGV4dFNpemUud2lkdGgrdGhpcy5tYXJnaW4ucmlnaHQrdGhpcy5tYXJnaW4ubGVmdCx0aGlzLmhlaWdodD10aGlzLnRleHRTaXplLmhlaWdodCt0aGlzLm1hcmdpbi50b3ArdGhpcy5tYXJnaW4uYm90dG9tLHRoaXMucmFkaXVzPS41KnRoaXMud2lkdGgpfX0se2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7dGhpcy5yZXNpemUodCxvLG4pLHRoaXMubGVmdD1lLXRoaXMud2lkdGgvMix0aGlzLnRvcD1pLXRoaXMuaGVpZ2h0LzIsdGhpcy5lbmFibGVTaGFkb3codCxyKSx0aGlzLmxhYmVsTW9kdWxlLmRyYXcodCx0aGlzLmxlZnQrdGhpcy50ZXh0U2l6ZS53aWR0aC8yK3RoaXMubWFyZ2luLmxlZnQsdGhpcy50b3ArdGhpcy50ZXh0U2l6ZS5oZWlnaHQvMit0aGlzLm1hcmdpbi50b3AsbyxuKSx0aGlzLmRpc2FibGVTaGFkb3codCxyKSx0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KGUsaSx0LG8sbil9fSx7a2V5OlwiZGlzdGFuY2VUb0JvcmRlclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIodCxlKX19XSksaX0oeGwpO2Z1bmN0aW9uIG5jKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIHJjPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9bmMoaSk7ZnVuY3Rpb24gaSh0LG8sbil7cmV0dXJuIFBvKHRoaXMsaSksZS5jYWxsKHRoaXMsdCxvLG4pfXJldHVybiBJbyhpLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXtyZXR1cm4gdGhpcy5fZHJhd1NoYXBlKHQsXCJ0cmlhbmdsZVwiLDMsZSxpLG8sbixyKX19LHtrZXk6XCJkaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcih0LGUpfX1dKSxpfShJbCk7ZnVuY3Rpb24gc2ModCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgYWM9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1zYyhpKTtmdW5jdGlvbiBpKHQsbyxuKXtyZXR1cm4gUG8odGhpcyxpKSxlLmNhbGwodGhpcyx0LG8sbil9cmV0dXJuIElvKGksW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3JldHVybiB0aGlzLl9kcmF3U2hhcGUodCxcInRyaWFuZ2xlRG93blwiLDMsZSxpLG8sbixyKX19LHtrZXk6XCJkaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcih0LGUpfX1dKSxpfShJbCk7ZnVuY3Rpb24gaGModCxlKXt2YXIgaT14bih0KTtpZih3byl7dmFyIG89d28odCk7ZSYmKG89YXIobykuY2FsbChvLChmdW5jdGlvbihlKXtyZXR1cm4gRW8odCxlKS5lbnVtZXJhYmxlfSkpKSxpLnB1c2guYXBwbHkoaSxvKX1yZXR1cm4gaX1mdW5jdGlvbiBkYyh0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgaSxvPW51bGwhPWFyZ3VtZW50c1tlXT9hcmd1bWVudHNbZV06e307aWYoZSUyKURuKGk9aGMoT2JqZWN0KG8pLCEwKSkuY2FsbChpLChmdW5jdGlvbihlKXt6byh0LGUsb1tlXSl9KSk7ZWxzZSBpZihDbylTbyh0LENvKG8pKTtlbHNle3ZhciBuO0RuKG49aGMoT2JqZWN0KG8pKSkuY2FsbChuLChmdW5jdGlvbihlKXtNbyh0LGUsRW8obyxlKSl9KSl9fXJldHVybiB0fXZhciBsYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8sbixyLHMpe1BvKHRoaXMsdCksdGhpcy5vcHRpb25zPXZoKHIpLHRoaXMuZ2xvYmFsT3B0aW9ucz1yLHRoaXMuZGVmYXVsdE9wdGlvbnM9cyx0aGlzLmJvZHk9aSx0aGlzLmVkZ2VzPVtdLHRoaXMuaWQ9dm9pZCAwLHRoaXMuaW1hZ2VsaXN0PW8sdGhpcy5ncm91cGxpc3Q9bix0aGlzLng9dm9pZCAwLHRoaXMueT12b2lkIDAsdGhpcy5iYXNlU2l6ZT10aGlzLm9wdGlvbnMuc2l6ZSx0aGlzLmJhc2VGb250U2l6ZT10aGlzLm9wdGlvbnMuZm9udC5zaXplLHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uPSExLHRoaXMuc2VsZWN0ZWQ9ITEsdGhpcy5ob3Zlcj0hMSx0aGlzLmxhYmVsTW9kdWxlPW5ldyBsbCh0aGlzLmJvZHksdGhpcy5vcHRpb25zLCExKSx0aGlzLnNldE9wdGlvbnMoZSl9cmV0dXJuIElvKHQsW3trZXk6XCJhdHRhY2hFZGdlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU7LTE9PT1NcihlPXRoaXMuZWRnZXMpLmNhbGwoZSx0KSYmdGhpcy5lZGdlcy5wdXNoKHQpfX0se2tleTpcImRldGFjaEVkZ2VcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZSxpLG89TXIoZT10aGlzLmVkZ2VzKS5jYWxsKGUsdCk7LTEhPW8mJnFuKGk9dGhpcy5lZGdlcykuY2FsbChpLG8sMSl9fSx7a2V5Olwic2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciBpPXRoaXMub3B0aW9ucy5zaGFwZTtpZihlKXtpZih2b2lkIDAhPT1lLmNvbG9yJiYodGhpcy5fbG9jYWxDb2xvcj1lLmNvbG9yKSx2b2lkIDAhPT1lLmlkJiYodGhpcy5pZD1lLmlkKSx2b2lkIDA9PT10aGlzLmlkKXRocm93IG5ldyBFcnJvcihcIk5vZGUgbXVzdCBoYXZlIGFuIGlkXCIpO3QuY2hlY2tNYXNzKGUsdGhpcy5pZCksdm9pZCAwIT09ZS54JiYobnVsbD09PWUueD8odGhpcy54PXZvaWQgMCx0aGlzLnByZWRlZmluZWRQb3NpdGlvbj0hMSk6KHRoaXMueD1rcihlLngpLHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uPSEwKSksdm9pZCAwIT09ZS55JiYobnVsbD09PWUueT8odGhpcy55PXZvaWQgMCx0aGlzLnByZWRlZmluZWRQb3NpdGlvbj0hMSk6KHRoaXMueT1rcihlLnkpLHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uPSEwKSksdm9pZCAwIT09ZS5zaXplJiYodGhpcy5iYXNlU2l6ZT1lLnNpemUpLHZvaWQgMCE9PWUudmFsdWUmJihlLnZhbHVlPVlkKGUudmFsdWUpKSx0LnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsZSwhMCx0aGlzLmdsb2JhbE9wdGlvbnMsdGhpcy5ncm91cGxpc3QpO3ZhciBvPVtlLHRoaXMub3B0aW9ucyx0aGlzLmRlZmF1bHRPcHRpb25zXTtyZXR1cm4gdGhpcy5jaG9vc2VyPVFkKFwibm9kZVwiLG8pLHRoaXMuX2xvYWRfaW1hZ2VzKCksdGhpcy51cGRhdGVMYWJlbE1vZHVsZShlKSx2b2lkIDAhPT1lLm9wYWNpdHkmJnQuY2hlY2tPcGFjaXR5KGUub3BhY2l0eSkmJih0aGlzLm9wdGlvbnMub3BhY2l0eT1lLm9wYWNpdHkpLHRoaXMudXBkYXRlU2hhcGUoaSksdm9pZCAwIT09ZS5oaWRkZW58fHZvaWQgMCE9PWUucGh5c2ljc319fSx7a2V5OlwiX2xvYWRfaW1hZ2VzXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZigoXCJjaXJjdWxhckltYWdlXCI9PT10aGlzLm9wdGlvbnMuc2hhcGV8fFwiaW1hZ2VcIj09PXRoaXMub3B0aW9ucy5zaGFwZSkmJnZvaWQgMD09PXRoaXMub3B0aW9ucy5pbWFnZSl0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb24gaW1hZ2UgbXVzdCBiZSBkZWZpbmVkIGZvciBub2RlIHR5cGUgJ1wiK3RoaXMub3B0aW9ucy5zaGFwZStcIidcIik7aWYodm9pZCAwIT09dGhpcy5vcHRpb25zLmltYWdlKXtpZih2b2lkIDA9PT10aGlzLmltYWdlbGlzdCl0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBFcnJvcjogTm8gaW1hZ2VzIHByb3ZpZGVkXCIpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuaW1hZ2UpdGhpcy5pbWFnZU9iaj10aGlzLmltYWdlbGlzdC5sb2FkKHRoaXMub3B0aW9ucy5pbWFnZSx0aGlzLm9wdGlvbnMuYnJva2VuSW1hZ2UsdGhpcy5pZCk7ZWxzZXtpZih2b2lkIDA9PT10aGlzLm9wdGlvbnMuaW1hZ2UudW5zZWxlY3RlZCl0aHJvdyBuZXcgRXJyb3IoXCJObyB1bnNlbGVjdGVkIGltYWdlIHByb3ZpZGVkXCIpO3RoaXMuaW1hZ2VPYmo9dGhpcy5pbWFnZWxpc3QubG9hZCh0aGlzLm9wdGlvbnMuaW1hZ2UudW5zZWxlY3RlZCx0aGlzLm9wdGlvbnMuYnJva2VuSW1hZ2UsdGhpcy5pZCksdm9pZCAwIT09dGhpcy5vcHRpb25zLmltYWdlLnNlbGVjdGVkP3RoaXMuaW1hZ2VPYmpBbHQ9dGhpcy5pbWFnZWxpc3QubG9hZCh0aGlzLm9wdGlvbnMuaW1hZ2Uuc2VsZWN0ZWQsdGhpcy5vcHRpb25zLmJyb2tlbkltYWdlLHRoaXMuaWQpOnRoaXMuaW1hZ2VPYmpBbHQ9dm9pZCAwfX19fSx7a2V5OlwiZ2V0Rm9ybWF0dGluZ1ZhbHVlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9e2NvbG9yOnRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kLG9wYWNpdHk6dGhpcy5vcHRpb25zLm9wYWNpdHksYm9yZGVyV2lkdGg6dGhpcy5vcHRpb25zLmJvcmRlcldpZHRoLGJvcmRlckNvbG9yOnRoaXMub3B0aW9ucy5jb2xvci5ib3JkZXIsc2l6ZTp0aGlzLm9wdGlvbnMuc2l6ZSxib3JkZXJEYXNoZXM6dGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMsYm9yZGVyUmFkaXVzOnRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyUmFkaXVzLHNoYWRvdzp0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQsc2hhZG93Q29sb3I6dGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvcixzaGFkb3dTaXplOnRoaXMub3B0aW9ucy5zaGFkb3cuc2l6ZSxzaGFkb3dYOnRoaXMub3B0aW9ucy5zaGFkb3cueCxzaGFkb3dZOnRoaXMub3B0aW9ucy5zaGFkb3cueX07aWYodGhpcy5zZWxlY3RlZHx8dGhpcy5ob3Zlcj8hMD09PXRoaXMuY2hvb3Nlcj90aGlzLnNlbGVjdGVkPyhudWxsIT10aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGhTZWxlY3RlZD90LmJvcmRlcldpZHRoPXRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aFNlbGVjdGVkOnQuYm9yZGVyV2lkdGgqPTIsdC5jb2xvcj10aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQsdC5ib3JkZXJDb2xvcj10aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcix0LnNoYWRvdz10aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQpOnRoaXMuaG92ZXImJih0LmNvbG9yPXRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5iYWNrZ3JvdW5kLHQuYm9yZGVyQ29sb3I9dGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlcix0LnNoYWRvdz10aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQpOlwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuY2hvb3NlciYmKHRoaXMuY2hvb3Nlcih0LHRoaXMub3B0aW9ucy5pZCx0aGlzLnNlbGVjdGVkLHRoaXMuaG92ZXIpLCExPT09dC5zaGFkb3cmJih0LnNoYWRvd0NvbG9yPT09dGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvciYmdC5zaGFkb3dTaXplPT09dGhpcy5vcHRpb25zLnNoYWRvdy5zaXplJiZ0LnNoYWRvd1g9PT10aGlzLm9wdGlvbnMuc2hhZG93LngmJnQuc2hhZG93WT09PXRoaXMub3B0aW9ucy5zaGFkb3cueXx8KHQuc2hhZG93PSEwKSkpOnQuc2hhZG93PXRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZCx2b2lkIDAhPT10aGlzLm9wdGlvbnMub3BhY2l0eSl7dmFyIGU9dGhpcy5vcHRpb25zLm9wYWNpdHk7dC5ib3JkZXJDb2xvcj1zaCh0LmJvcmRlckNvbG9yLGUpLHQuY29sb3I9c2godC5jb2xvcixlKSx0LnNoYWRvd0NvbG9yPXNoKHQuc2hhZG93Q29sb3IsZSl9cmV0dXJuIHR9fSx7a2V5OlwidXBkYXRlTGFiZWxNb2R1bGVcIix2YWx1ZTpmdW5jdGlvbihlKXt2b2lkIDAhPT10aGlzLm9wdGlvbnMubGFiZWwmJm51bGwhPT10aGlzLm9wdGlvbnMubGFiZWx8fCh0aGlzLm9wdGlvbnMubGFiZWw9XCJcIiksdC51cGRhdGVHcm91cE9wdGlvbnModGhpcy5vcHRpb25zLGRjKGRjKHt9LGUpLHt9LHtjb2xvcjplJiZlLmNvbG9yfHx0aGlzLl9sb2NhbENvbG9yfHx2b2lkIDB9KSx0aGlzLmdyb3VwbGlzdCk7dmFyIGk9dGhpcy5ncm91cGxpc3QuZ2V0KHRoaXMub3B0aW9ucy5ncm91cCwhMSksbz1bZSx0aGlzLm9wdGlvbnMsaSx0aGlzLmdsb2JhbE9wdGlvbnMsdGhpcy5kZWZhdWx0T3B0aW9uc107dGhpcy5sYWJlbE1vZHVsZS51cGRhdGUodGhpcy5vcHRpb25zLG8pLHZvaWQgMCE9PXRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemUmJih0aGlzLmJhc2VGb250U2l6ZT10aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplKX19LHtrZXk6XCJ1cGRhdGVTaGFwZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHQ9PT10aGlzLm9wdGlvbnMuc2hhcGUmJnRoaXMuc2hhcGUpdGhpcy5zaGFwZS5zZXRPcHRpb25zKHRoaXMub3B0aW9ucyx0aGlzLmltYWdlT2JqLHRoaXMuaW1hZ2VPYmpBbHQpO2Vsc2Ugc3dpdGNoKHRoaXMub3B0aW9ucy5zaGFwZSl7Y2FzZVwiYm94XCI6dGhpcy5zaGFwZT1uZXcgT2wodGhpcy5vcHRpb25zLHRoaXMuYm9keSx0aGlzLmxhYmVsTW9kdWxlKTticmVhaztjYXNlXCJjaXJjbGVcIjp0aGlzLnNoYXBlPW5ldyBNbCh0aGlzLm9wdGlvbnMsdGhpcy5ib2R5LHRoaXMubGFiZWxNb2R1bGUpO2JyZWFrO2Nhc2VcImNpcmN1bGFySW1hZ2VcIjp0aGlzLnNoYXBlPW5ldyBEbCh0aGlzLm9wdGlvbnMsdGhpcy5ib2R5LHRoaXMubGFiZWxNb2R1bGUsdGhpcy5pbWFnZU9iaix0aGlzLmltYWdlT2JqQWx0KTticmVhaztjYXNlXCJjdXN0b21cIjp0aGlzLnNoYXBlPW5ldyBBbCh0aGlzLm9wdGlvbnMsdGhpcy5ib2R5LHRoaXMubGFiZWxNb2R1bGUsdGhpcy5vcHRpb25zLmN0eFJlbmRlcmVyKTticmVhaztjYXNlXCJkYXRhYmFzZVwiOnRoaXMuc2hhcGU9bmV3IGpsKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSk7YnJlYWs7Y2FzZVwiZGlhbW9uZFwiOnRoaXMuc2hhcGU9bmV3IEhsKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSk7YnJlYWs7Y2FzZVwiZG90XCI6dGhpcy5zaGFwZT1uZXcgVmwodGhpcy5vcHRpb25zLHRoaXMuYm9keSx0aGlzLmxhYmVsTW9kdWxlKTticmVhaztjYXNlXCJlbGxpcHNlXCI6dGhpcy5zaGFwZT1uZXcgVWwodGhpcy5vcHRpb25zLHRoaXMuYm9keSx0aGlzLmxhYmVsTW9kdWxlKTticmVhaztjYXNlXCJpY29uXCI6dGhpcy5zaGFwZT1uZXcgWGwodGhpcy5vcHRpb25zLHRoaXMuYm9keSx0aGlzLmxhYmVsTW9kdWxlKTticmVhaztjYXNlXCJpbWFnZVwiOnRoaXMuc2hhcGU9bmV3IEtsKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSx0aGlzLmltYWdlT2JqLHRoaXMuaW1hZ2VPYmpBbHQpO2JyZWFrO2Nhc2VcInNxdWFyZVwiOnRoaXMuc2hhcGU9bmV3IFFsKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSk7YnJlYWs7Y2FzZVwiaGV4YWdvblwiOnRoaXMuc2hhcGU9bmV3IEpsKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSk7YnJlYWs7Y2FzZVwic3RhclwiOnRoaXMuc2hhcGU9bmV3IGVjKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSk7YnJlYWs7Y2FzZVwidGV4dFwiOnRoaXMuc2hhcGU9bmV3IG9jKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSk7YnJlYWs7Y2FzZVwidHJpYW5nbGVcIjp0aGlzLnNoYXBlPW5ldyByYyh0aGlzLm9wdGlvbnMsdGhpcy5ib2R5LHRoaXMubGFiZWxNb2R1bGUpO2JyZWFrO2Nhc2VcInRyaWFuZ2xlRG93blwiOnRoaXMuc2hhcGU9bmV3IGFjKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSk7YnJlYWs7ZGVmYXVsdDp0aGlzLnNoYXBlPW5ldyBVbCh0aGlzLm9wdGlvbnMsdGhpcy5ib2R5LHRoaXMubGFiZWxNb2R1bGUpfXRoaXMubmVlZHNSZWZyZXNoKCl9fSx7a2V5Olwic2VsZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNlbGVjdGVkPSEwLHRoaXMubmVlZHNSZWZyZXNoKCl9fSx7a2V5OlwidW5zZWxlY3RcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2VsZWN0ZWQ9ITEsdGhpcy5uZWVkc1JlZnJlc2goKX19LHtrZXk6XCJuZWVkc1JlZnJlc2hcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2hhcGUucmVmcmVzaE5lZWRlZD0hMH19LHtrZXk6XCJnZXRUaXRsZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9ucy50aXRsZX19LHtrZXk6XCJkaXN0YW5jZVRvQm9yZGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zaGFwZS5kaXN0YW5jZVRvQm9yZGVyKHQsZSl9fSx7a2V5OlwiaXNGaXhlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5maXhlZC54JiZ0aGlzLm9wdGlvbnMuZml4ZWQueX19LHtrZXk6XCJpc1NlbGVjdGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWxlY3RlZH19LHtrZXk6XCJnZXRWYWx1ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9ucy52YWx1ZX19LHtrZXk6XCJnZXRMYWJlbFNpemVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsTW9kdWxlLnNpemUoKX19LHtrZXk6XCJzZXRWYWx1ZVJhbmdlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe2lmKHZvaWQgMCE9PXRoaXMub3B0aW9ucy52YWx1ZSl7dmFyIG89dGhpcy5vcHRpb25zLnNjYWxpbmcuY3VzdG9tU2NhbGluZ0Z1bmN0aW9uKHQsZSxpLHRoaXMub3B0aW9ucy52YWx1ZSksbj10aGlzLm9wdGlvbnMuc2NhbGluZy5tYXgtdGhpcy5vcHRpb25zLnNjYWxpbmcubWluO2lmKCEwPT09dGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwuZW5hYmxlZCl7dmFyIHI9dGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWF4LXRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbjt0aGlzLm9wdGlvbnMuZm9udC5zaXplPXRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbitvKnJ9dGhpcy5vcHRpb25zLnNpemU9dGhpcy5vcHRpb25zLnNjYWxpbmcubWluK28qbn1lbHNlIHRoaXMub3B0aW9ucy5zaXplPXRoaXMuYmFzZVNpemUsdGhpcy5vcHRpb25zLmZvbnQuc2l6ZT10aGlzLmJhc2VGb250U2l6ZTt0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKCl9fSx7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpO3JldHVybiB0aGlzLnNoYXBlLmRyYXcodCx0aGlzLngsdGhpcy55LHRoaXMuc2VsZWN0ZWQsdGhpcy5ob3ZlcixlKXx8e319fSx7a2V5OlwidXBkYXRlQm91bmRpbmdCb3hcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLnNoYXBlLnVwZGF0ZUJvdW5kaW5nQm94KHRoaXMueCx0aGlzLnksdCl9fSx7a2V5OlwicmVzaXplXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRGb3JtYXR0aW5nVmFsdWVzKCk7dGhpcy5zaGFwZS5yZXNpemUodCx0aGlzLnNlbGVjdGVkLHRoaXMuaG92ZXIsZSl9fSx7a2V5OlwiZ2V0SXRlbXNPblBvaW50XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9W107cmV0dXJuIHRoaXMubGFiZWxNb2R1bGUudmlzaWJsZSgpJiZaZCh0aGlzLmxhYmVsTW9kdWxlLmdldFNpemUoKSx0KSYmZS5wdXNoKHtub2RlSWQ6dGhpcy5pZCxsYWJlbElkOjB9KSxaZCh0aGlzLnNoYXBlLmJvdW5kaW5nQm94LHQpJiZlLnB1c2goe25vZGVJZDp0aGlzLmlkfSksZX19LHtrZXk6XCJpc092ZXJsYXBwaW5nV2l0aFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnNoYXBlLmxlZnQ8dC5yaWdodCYmdGhpcy5zaGFwZS5sZWZ0K3RoaXMuc2hhcGUud2lkdGg+dC5sZWZ0JiZ0aGlzLnNoYXBlLnRvcDx0LmJvdHRvbSYmdGhpcy5zaGFwZS50b3ArdGhpcy5zaGFwZS5oZWlnaHQ+dC50b3B9fSx7a2V5OlwiaXNCb3VuZGluZ0JveE92ZXJsYXBwaW5nV2l0aFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnNoYXBlLmJvdW5kaW5nQm94LmxlZnQ8dC5yaWdodCYmdGhpcy5zaGFwZS5ib3VuZGluZ0JveC5yaWdodD50LmxlZnQmJnRoaXMuc2hhcGUuYm91bmRpbmdCb3gudG9wPHQuYm90dG9tJiZ0aGlzLnNoYXBlLmJvdW5kaW5nQm94LmJvdHRvbT50LnRvcH19XSxbe2tleTpcImNoZWNrT3BhY2l0eVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiAwPD10JiZ0PD0xfX0se2tleTpcImNoZWNrQ29vcmRpbmF0ZU9yaWdpblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10fHxcImNlbnRlclwiPT09dHx8XCJ0b3AtbGVmdFwiPT09dH19LHtrZXk6XCJ1cGRhdGVHcm91cE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbihlLGksbyl7dmFyIG47aWYodm9pZCAwIT09byl7dmFyIHI9ZS5ncm91cDtpZih2b2lkIDAhPT1pJiZ2b2lkIDAhPT1pLmdyb3VwJiZyIT09aS5ncm91cCl0aHJvdyBuZXcgRXJyb3IoXCJ1cGRhdGVHcm91cE9wdGlvbnM6IGdyb3VwIHZhbHVlcyBpbiBvcHRpb25zIGRvbid0IG1hdGNoLlwiKTtpZihcIm51bWJlclwiPT10eXBlb2Ygcnx8XCJzdHJpbmdcIj09dHlwZW9mIHImJlwiXCIhPXIpe3ZhciBzPW8uZ2V0KHIpO3ZvaWQgMCE9PXMub3BhY2l0eSYmdm9pZCAwPT09aS5vcGFjaXR5JiYodC5jaGVja09wYWNpdHkocy5vcGFjaXR5KXx8KGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBmb3Igbm9kZSBvcGFjaXR5LiBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZm91bmQ6IFwiK3Mub3BhY2l0eSkscy5vcGFjaXR5PXZvaWQgMCkpO3ZhciBhPWFyKG49JGQoaSkpLmNhbGwobiwoZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPWlbdF19KSk7YS5wdXNoKFwiZm9udFwiKSxKYShhLGUscyksZS5jb2xvcj1oaChlLmNvbG9yKX19fX0se2tleTpcInBhcnNlT3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKGUsaSl7dmFyIG89YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXSxuPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTp7fSxyPWFyZ3VtZW50cy5sZW5ndGg+ND9hcmd1bWVudHNbNF06dm9pZCAwLHM9W1wiY29sb3JcIixcImZpeGVkXCIsXCJzaGFkb3dcIl07aWYoSmEocyxlLGksbyksdC5jaGVja01hc3MoaSksdm9pZCAwIT09ZS5vcGFjaXR5JiYodC5jaGVja09wYWNpdHkoZS5vcGFjaXR5KXx8KGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBmb3Igbm9kZSBvcGFjaXR5LiBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZm91bmQ6IFwiK2Uub3BhY2l0eSksZS5vcGFjaXR5PXZvaWQgMCkpLHZvaWQgMCE9PWkub3BhY2l0eSYmKHQuY2hlY2tPcGFjaXR5KGkub3BhY2l0eSl8fChjb25zb2xlLmVycm9yKFwiSW52YWxpZCBvcHRpb24gZm9yIG5vZGUgb3BhY2l0eS4gVmFsdWUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGZvdW5kOiBcIitpLm9wYWNpdHkpLGkub3BhY2l0eT12b2lkIDApKSxpLnNoYXBlUHJvcGVydGllcyYmIXQuY2hlY2tDb29yZGluYXRlT3JpZ2luKGkuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4pJiZjb25zb2xlLmVycm9yKFwiSW52YWxpZCBvcHRpb24gZm9yIG5vZGUgY29vcmRpbmF0ZU9yaWdpbiwgZm91bmQ6IFwiK2kuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4pLGdoKGUsaSxcInNoYWRvd1wiLG4pLHZvaWQgMCE9PWkuY29sb3ImJm51bGwhPT1pLmNvbG9yKXt2YXIgYT1oaChpLmNvbG9yKTtRYShlLmNvbG9yLGEpfWVsc2UhMD09PW8mJm51bGw9PT1pLmNvbG9yJiYoZS5jb2xvcj12aChuLmNvbG9yKSk7dm9pZCAwIT09aS5maXhlZCYmbnVsbCE9PWkuZml4ZWQmJihcImJvb2xlYW5cIj09dHlwZW9mIGkuZml4ZWQ/KGUuZml4ZWQueD1pLmZpeGVkLGUuZml4ZWQueT1pLmZpeGVkKToodm9pZCAwIT09aS5maXhlZC54JiZcImJvb2xlYW5cIj09dHlwZW9mIGkuZml4ZWQueCYmKGUuZml4ZWQueD1pLmZpeGVkLngpLHZvaWQgMCE9PWkuZml4ZWQueSYmXCJib29sZWFuXCI9PXR5cGVvZiBpLmZpeGVkLnkmJihlLmZpeGVkLnk9aS5maXhlZC55KSkpLCEwPT09byYmbnVsbD09PWkuZm9udCYmKGUuZm9udD12aChuLmZvbnQpKSx0LnVwZGF0ZUdyb3VwT3B0aW9ucyhlLGksciksdm9pZCAwIT09aS5zY2FsaW5nJiZnaChlLnNjYWxpbmcsaS5zY2FsaW5nLFwibGFiZWxcIixuLnNjYWxpbmcpfX0se2tleTpcImNoZWNrTWFzc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwIT09dC5tYXNzJiZ0Lm1hc3M8PTApe3ZhciBpPVwiXCI7dm9pZCAwIT09ZSYmKGk9XCIgaW4gbm9kZSBpZDogXCIrZSksY29uc29sZS5lcnJvcihcIiVjTmVnYXRpdmUgb3IgemVybyBtYXNzIGRpc2FsbG93ZWRcIitpK1wiLCBzZXR0aW5nIG1hc3MgdG8gMS5cIixNaCksdC5tYXNzPTF9fX1dKSx0fSgpO2Z1bmN0aW9uIGNjKHQsZSl7dmFyIGk7aWYodm9pZCAwPT09Y258fG51bGw9PUNpKHQpKXtpZihnbih0KXx8KGk9ZnVuY3Rpb24odCxlKXt2YXIgaTtpZighdClyZXR1cm47aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIHVjKHQsZSk7dmFyIG89dm4oaT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpLmNhbGwoaSw4LC0xKTtcIk9iamVjdFwiPT09byYmdC5jb25zdHJ1Y3RvciYmKG89dC5jb25zdHJ1Y3Rvci5uYW1lKTtpZihcIk1hcFwiPT09b3x8XCJTZXRcIj09PW8pcmV0dXJuIG1pKHQpO2lmKFwiQXJndW1lbnRzXCI9PT1vfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChvKSlyZXR1cm4gdWModCxlKX0odCkpfHxlJiZ0JiZcIm51bWJlclwiPT10eXBlb2YgdC5sZW5ndGgpe2kmJih0PWkpO3ZhciBvPTAsbj1mdW5jdGlvbigpe307cmV0dXJue3M6bixuOmZ1bmN0aW9uKCl7cmV0dXJuIG8+PXQubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTp0W28rK119fSxlOmZ1bmN0aW9uKHQpe3Rocm93IHR9LGY6bn19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXZhciByLHM9ITAsYT0hMTtyZXR1cm57czpmdW5jdGlvbigpe2k9U2kodCl9LG46ZnVuY3Rpb24oKXt2YXIgdD1pLm5leHQoKTtyZXR1cm4gcz10LmRvbmUsdH0sZTpmdW5jdGlvbih0KXthPSEwLHI9dH0sZjpmdW5jdGlvbigpe3RyeXtzfHxudWxsPT1pLnJldHVybnx8aS5yZXR1cm4oKX1maW5hbGx5e2lmKGEpdGhyb3cgcn19fX1mdW5jdGlvbiB1Yyh0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgaT0wLG89bmV3IEFycmF5KGUpO2k8ZTtpKyspb1tpXT10W2ldO3JldHVybiBvfXZhciBmYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8sbil7dmFyIHIscz10aGlzO2lmKFBvKHRoaXMsdCksdGhpcy5ib2R5PWUsdGhpcy5pbWFnZXM9aSx0aGlzLmdyb3Vwcz1vLHRoaXMubGF5b3V0RW5naW5lPW4sdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlPWJ0KHI9dGhpcy5jcmVhdGUpLmNhbGwocix0aGlzKSx0aGlzLm5vZGVzTGlzdGVuZXJzPXthZGQ6ZnVuY3Rpb24odCxlKXtzLmFkZChlLml0ZW1zKX0sdXBkYXRlOmZ1bmN0aW9uKHQsZSl7cy51cGRhdGUoZS5pdGVtcyxlLmRhdGEsZS5vbGREYXRhKX0scmVtb3ZlOmZ1bmN0aW9uKHQsZSl7cy5yZW1vdmUoZS5pdGVtcyl9fSx0aGlzLmRlZmF1bHRPcHRpb25zPXtib3JkZXJXaWR0aDoxLGJvcmRlcldpZHRoU2VsZWN0ZWQ6dm9pZCAwLGJyb2tlbkltYWdlOnZvaWQgMCxjb2xvcjp7Ym9yZGVyOlwiIzJCN0NFOVwiLGJhY2tncm91bmQ6XCIjOTdDMkZDXCIsaGlnaGxpZ2h0Ontib3JkZXI6XCIjMkI3Q0U5XCIsYmFja2dyb3VuZDpcIiNEMkU1RkZcIn0saG92ZXI6e2JvcmRlcjpcIiMyQjdDRTlcIixiYWNrZ3JvdW5kOlwiI0QyRTVGRlwifX0sb3BhY2l0eTp2b2lkIDAsZml4ZWQ6e3g6ITEseTohMX0sZm9udDp7Y29sb3I6XCIjMzQzNDM0XCIsc2l6ZToxNCxmYWNlOlwiYXJpYWxcIixiYWNrZ3JvdW5kOlwibm9uZVwiLHN0cm9rZVdpZHRoOjAsc3Ryb2tlQ29sb3I6XCIjZmZmZmZmXCIsYWxpZ246XCJjZW50ZXJcIix2YWRqdXN0OjAsbXVsdGk6ITEsYm9sZDp7bW9kOlwiYm9sZFwifSxib2xkaXRhbDp7bW9kOlwiYm9sZCBpdGFsaWNcIn0saXRhbDp7bW9kOlwiaXRhbGljXCJ9LG1vbm86e21vZDpcIlwiLHNpemU6MTUsZmFjZTpcIm1vbm9zcGFjZVwiLHZhZGp1c3Q6Mn19LGdyb3VwOnZvaWQgMCxoaWRkZW46ITEsaWNvbjp7ZmFjZTpcIkZvbnRBd2Vzb21lXCIsY29kZTp2b2lkIDAsc2l6ZTo1MCxjb2xvcjpcIiMyQjdDRTlcIn0saW1hZ2U6dm9pZCAwLGltYWdlUGFkZGluZzp7dG9wOjAscmlnaHQ6MCxib3R0b206MCxsZWZ0OjB9LGxhYmVsOnZvaWQgMCxsYWJlbEhpZ2hsaWdodEJvbGQ6ITAsbGV2ZWw6dm9pZCAwLG1hcmdpbjp7dG9wOjUscmlnaHQ6NSxib3R0b206NSxsZWZ0OjV9LG1hc3M6MSxwaHlzaWNzOiEwLHNjYWxpbmc6e21pbjoxMCxtYXg6MzAsbGFiZWw6e2VuYWJsZWQ6ITEsbWluOjE0LG1heDozMCxtYXhWaXNpYmxlOjMwLGRyYXdUaHJlc2hvbGQ6NX0sY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOmZ1bmN0aW9uKHQsZSxpLG8pe2lmKGU9PT10KXJldHVybi41O3ZhciBuPTEvKGUtdCk7cmV0dXJuIE1hdGgubWF4KDAsKG8tdCkqbil9fSxzaGFkb3c6e2VuYWJsZWQ6ITEsY29sb3I6XCJyZ2JhKDAsMCwwLDAuNSlcIixzaXplOjEwLHg6NSx5OjV9LHNoYXBlOlwiZWxsaXBzZVwiLHNoYXBlUHJvcGVydGllczp7Ym9yZGVyRGFzaGVzOiExLGJvcmRlclJhZGl1czo2LGludGVycG9sYXRpb246ITAsdXNlSW1hZ2VTaXplOiExLHVzZUJvcmRlcldpdGhJbWFnZTohMSxjb29yZGluYXRlT3JpZ2luOlwiY2VudGVyXCJ9LHNpemU6MjUsdGl0bGU6dm9pZCAwLHZhbHVlOnZvaWQgMCx4OnZvaWQgMCx5OnZvaWQgMH0sdGhpcy5kZWZhdWx0T3B0aW9ucy5tYXNzPD0wKXRocm93XCJJbnRlcm5hbCBlcnJvcjogbWFzcyBpbiBkZWZhdWx0T3B0aW9ucyBvZiBOb2Rlc0hhbmRsZXIgbWF5IG5vdCBiZSB6ZXJvIG9yIG5lZ2F0aXZlXCI7dGhpcy5vcHRpb25zPXZoKHRoaXMuZGVmYXVsdE9wdGlvbnMpLHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCl9cmV0dXJuIElvKHQsW3trZXk6XCJiaW5kRXZlbnRMaXN0ZW5lcnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGUsaT10aGlzO3RoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVmcmVzaE5vZGVzXCIsYnQodD10aGlzLnJlZnJlc2gpLmNhbGwodCx0aGlzKSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZWZyZXNoXCIsYnQoZT10aGlzLnJlZnJlc2gpLmNhbGwoZSx0aGlzKSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsKGZ1bmN0aW9uKCl7bmgoaS5ub2Rlc0xpc3RlbmVycywoZnVuY3Rpb24odCxlKXtpLmJvZHkuZGF0YS5ub2RlcyYmaS5ib2R5LmRhdGEubm9kZXMub2ZmKGUsdCl9KSksZGVsZXRlIGkuYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZSxkZWxldGUgaS5ub2Rlc0xpc3RlbmVycy5hZGQsZGVsZXRlIGkubm9kZXNMaXN0ZW5lcnMudXBkYXRlLGRlbGV0ZSBpLm5vZGVzTGlzdGVuZXJzLnJlbW92ZSxkZWxldGUgaS5ub2Rlc0xpc3RlbmVyc30pKX19LHtrZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dCl7aWYobGMucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucyx0KSx2b2lkIDAhPT10Lm9wYWNpdHkmJih6ZCh0Lm9wYWNpdHkpfHwhQWQodC5vcGFjaXR5KXx8dC5vcGFjaXR5PDB8fHQub3BhY2l0eT4xP2NvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBmb3Igbm9kZSBvcGFjaXR5LiBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZm91bmQ6IFwiK3Qub3BhY2l0eSk6dGhpcy5vcHRpb25zLm9wYWNpdHk9dC5vcGFjaXR5KSx2b2lkIDAhPT10LnNoYXBlKWZvcih2YXIgZSBpbiB0aGlzLmJvZHkubm9kZXMpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2RlcyxlKSYmdGhpcy5ib2R5Lm5vZGVzW2VdLnVwZGF0ZVNoYXBlKCk7aWYodm9pZCAwIT09dC5mb250fHx2b2lkIDAhPT10LndpZHRoQ29uc3RyYWludHx8dm9pZCAwIT09dC5oZWlnaHRDb25zdHJhaW50KWZvcih2YXIgaT0wLG89eG4odGhpcy5ib2R5Lm5vZGVzKTtpPG8ubGVuZ3RoO2krKyl7dmFyIG49b1tpXTt0aGlzLmJvZHkubm9kZXNbbl0udXBkYXRlTGFiZWxNb2R1bGUoKSx0aGlzLmJvZHkubm9kZXNbbl0ubmVlZHNSZWZyZXNoKCl9aWYodm9pZCAwIT09dC5zaXplKWZvcih2YXIgciBpbiB0aGlzLmJvZHkubm9kZXMpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2RlcyxyKSYmdGhpcy5ib2R5Lm5vZGVzW3JdLm5lZWRzUmVmcmVzaCgpO3ZvaWQgMD09PXQuaGlkZGVuJiZ2b2lkIDA9PT10LnBoeXNpY3N8fHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIil9fX0se2tleTpcInNldERhdGFcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdLG89dGhpcy5ib2R5LmRhdGEubm9kZXM7aWYoZS5pc0RhdGFWaWV3TGlrZShcImlkXCIsdCkpdGhpcy5ib2R5LmRhdGEubm9kZXM9dDtlbHNlIGlmKGduKHQpKXRoaXMuYm9keS5kYXRhLm5vZGVzPW5ldyBlLkRhdGFTZXQsdGhpcy5ib2R5LmRhdGEubm9kZXMuYWRkKHQpO2Vsc2V7aWYodCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXkgb3IgRGF0YVNldCBleHBlY3RlZFwiKTt0aGlzLmJvZHkuZGF0YS5ub2Rlcz1uZXcgZS5EYXRhU2V0fWlmKG8mJm5oKHRoaXMubm9kZXNMaXN0ZW5lcnMsKGZ1bmN0aW9uKHQsZSl7by5vZmYoZSx0KX0pKSx0aGlzLmJvZHkubm9kZXM9e30sdGhpcy5ib2R5LmRhdGEubm9kZXMpe3ZhciBuPXRoaXM7bmgodGhpcy5ub2Rlc0xpc3RlbmVycywoZnVuY3Rpb24odCxlKXtuLmJvZHkuZGF0YS5ub2Rlcy5vbihlLHQpfSkpO3ZhciByPXRoaXMuYm9keS5kYXRhLm5vZGVzLmdldElkcygpO3RoaXMuYWRkKHIsITApfSExPT09aSYmdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKX19LHtrZXk6XCJhZGRcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGUsaT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdLG89W10sbj0wO248dC5sZW5ndGg7bisrKXtlPXRbbl07dmFyIHI9dGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0KGUpLHM9dGhpcy5jcmVhdGUocik7by5wdXNoKHMpLHRoaXMuYm9keS5ub2Rlc1tlXT1zfXRoaXMubGF5b3V0RW5naW5lLnBvc2l0aW9uSW5pdGlhbGx5KG8pLCExPT09aSYmdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKX19LHtrZXk6XCJ1cGRhdGVcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7Zm9yKHZhciBvPXRoaXMuYm9keS5ub2RlcyxuPSExLHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIHM9dFtyXSxhPW9bc10saD1lW3JdO3ZvaWQgMCE9PWE/YS5zZXRPcHRpb25zKGgpJiYobj0hMCk6KG49ITAsYT10aGlzLmNyZWF0ZShoKSxvW3NdPWEpfW58fHZvaWQgMD09PWl8fChuPVdkKGUpLmNhbGwoZSwoZnVuY3Rpb24odCxlKXt2YXIgbz1pW2VdO3JldHVybiBvJiZvLmxldmVsIT09dC5sZXZlbH0pKSksITA9PT1uP3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik6dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhVXBkYXRlZFwiKX19LHtrZXk6XCJyZW1vdmVcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5ib2R5Lm5vZGVzLGk9MDtpPHQubGVuZ3RoO2krKyl7ZGVsZXRlIGVbdFtpXV19dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKX19LHtrZXk6XCJjcmVhdGVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06bGM7cmV0dXJuIG5ldyBlKHQsdGhpcy5ib2R5LHRoaXMuaW1hZ2VzLHRoaXMuZ3JvdXBzLHRoaXMub3B0aW9ucyx0aGlzLmRlZmF1bHRPcHRpb25zKX19LHtrZXk6XCJyZWZyZXNoXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXTtuaCh0aGlzLmJvZHkubm9kZXMsKGZ1bmN0aW9uKGksbyl7dmFyIG49dC5ib2R5LmRhdGEubm9kZXMuZ2V0KG8pO3ZvaWQgMCE9PW4mJighMD09PWUmJmkuc2V0T3B0aW9ucyh7eDpudWxsLHk6bnVsbH0pLGkuc2V0T3B0aW9ucyh7Zml4ZWQ6ITF9KSxpLnNldE9wdGlvbnMobikpfSkpfX0se2tleTpcImdldFBvc2l0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXt9O2lmKHZvaWQgMCE9PXQpe2lmKCEwPT09Z24odCkpe2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKWlmKHZvaWQgMCE9PXRoaXMuYm9keS5ub2Rlc1t0W2ldXSl7dmFyIG89dGhpcy5ib2R5Lm5vZGVzW3RbaV1dO2VbdFtpXV09e3g6TWF0aC5yb3VuZChvLngpLHk6TWF0aC5yb3VuZChvLnkpfX19ZWxzZSBpZih2b2lkIDAhPT10aGlzLmJvZHkubm9kZXNbdF0pe3ZhciBuPXRoaXMuYm9keS5ub2Rlc1t0XTtlW3RdPXt4Ok1hdGgucm91bmQobi54KSx5Ok1hdGgucm91bmQobi55KX19fWVsc2UgZm9yKHZhciByPTA7cjx0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO3IrKyl7dmFyIHM9dGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tyXV07ZVt0aGlzLmJvZHkubm9kZUluZGljZXNbcl1dPXt4Ok1hdGgucm91bmQocy54KSx5Ok1hdGgucm91bmQocy55KX19cmV0dXJuIGV9fSx7a2V5OlwiZ2V0UG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbih0KXtpZihudWxsPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJObyBpZCB3YXMgc3BlY2lmaWVkIGZvciBnZXRQb3NpdGlvbiBtZXRob2QuXCIpO2lmKG51bGw9PXRoaXMuYm9keS5ub2Rlc1t0XSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJOb2RlSWQgcHJvdmlkZWQgZm9yIGdldFBvc2l0aW9uIGRvZXMgbm90IGV4aXN0LiBQcm92aWRlZDogXCIuY29uY2F0KHQpKTtyZXR1cm57eDpNYXRoLnJvdW5kKHRoaXMuYm9keS5ub2Rlc1t0XS54KSx5Ok1hdGgucm91bmQodGhpcy5ib2R5Lm5vZGVzW3RdLnkpfX19LHtrZXk6XCJzdG9yZVBvc2l0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZT1bXSxpPXRoaXMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKSxvPWNjKGkuZ2V0KCkpO3RyeXtmb3Ioby5zKCk7ISh0PW8ubigpKS5kb25lOyl7dmFyIG49dC52YWx1ZSxyPW4uaWQscz10aGlzLmJvZHkubm9kZXNbcl0sYT1NYXRoLnJvdW5kKHMueCksaD1NYXRoLnJvdW5kKHMueSk7bi54PT09YSYmbi55PT09aHx8ZS5wdXNoKHtpZDpyLHg6YSx5Omh9KX19Y2F0Y2godCl7by5lKHQpfWZpbmFsbHl7by5mKCl9aS51cGRhdGUoZSl9fSx7a2V5OlwiZ2V0Qm91bmRpbmdCb3hcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih2b2lkIDAhPT10aGlzLmJvZHkubm9kZXNbdF0pcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1t0XS5zaGFwZS5ib3VuZGluZ0JveH19LHtrZXk6XCJnZXRDb25uZWN0ZWROb2Rlc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9W107aWYodm9pZCAwIT09dGhpcy5ib2R5Lm5vZGVzW3RdKWZvcih2YXIgbz10aGlzLmJvZHkubm9kZXNbdF0sbj17fSxyPTA7cjxvLmVkZ2VzLmxlbmd0aDtyKyspe3ZhciBzPW8uZWRnZXNbcl07XCJ0b1wiIT09ZSYmcy50b0lkPT1vLmlkP3ZvaWQgMD09PW5bcy5mcm9tSWRdJiYoaS5wdXNoKHMuZnJvbUlkKSxuW3MuZnJvbUlkXT0hMCk6XCJmcm9tXCIhPT1lJiZzLmZyb21JZD09by5pZCYmdm9pZCAwPT09bltzLnRvSWRdJiYoaS5wdXNoKHMudG9JZCksbltzLnRvSWRdPSEwKX1yZXR1cm4gaX19LHtrZXk6XCJnZXRDb25uZWN0ZWRFZGdlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPVtdO2lmKHZvaWQgMCE9PXRoaXMuYm9keS5ub2Rlc1t0XSlmb3IodmFyIGk9dGhpcy5ib2R5Lm5vZGVzW3RdLG89MDtvPGkuZWRnZXMubGVuZ3RoO28rKyllLnB1c2goaS5lZGdlc1tvXS5pZCk7ZWxzZSBjb25zb2xlLmVycm9yKFwiTm9kZUlkIHByb3ZpZGVkIGZvciBnZXRDb25uZWN0ZWRFZGdlcyBkb2VzIG5vdCBleGlzdC4gUHJvdmlkZWQ6IFwiLHQpO3JldHVybiBlfX0se2tleTpcIm1vdmVOb2RlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3ZhciBvPXRoaXM7dm9pZCAwIT09dGhpcy5ib2R5Lm5vZGVzW3RdPyh0aGlzLmJvZHkubm9kZXNbdF0ueD1OdW1iZXIoZSksdGhpcy5ib2R5Lm5vZGVzW3RdLnk9TnVtYmVyKGkpLHFyKChmdW5jdGlvbigpe28uYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIil9KSwwKSk6Y29uc29sZS5lcnJvcihcIk5vZGUgaWQgc3VwcGxpZWQgdG8gbW92ZU5vZGUgZG9lcyBub3QgZXhpc3QuIFByb3ZpZGVkOiBcIix0KX19XSksdH0oKTtxKHt0YXJnZXQ6XCJSZWZsZWN0XCIsc3RhdDohMH0se2dldDpmdW5jdGlvbiB0KGUsaSl7dmFyIG8sbixyPWFyZ3VtZW50cy5sZW5ndGg8Mz9lOmFyZ3VtZW50c1syXTtyZXR1cm4gUihlKT09PXI/ZVtpXToobz1TLmYoZSxpKSk/ayhvLFwidmFsdWVcIik/by52YWx1ZTp2b2lkIDA9PT1vLmdldD92b2lkIDA6by5nZXQuY2FsbChyKTptKG49aWUoZSkpP3QobixpLHIpOnZvaWQgMH19KTt2YXIgcGM9Ri5SZWZsZWN0LmdldCx2Yz14bztmdW5jdGlvbiBnYyh0LGUsaSl7cmV0dXJuKGdjPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBSZWZsZWN0JiZwYz9wYzpmdW5jdGlvbih0LGUsaSl7dmFyIG89ZnVuY3Rpb24odCxlKXtmb3IoOyFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSYmbnVsbCE9PSh0PV9sKHQpKTspO3JldHVybiB0fSh0LGUpO2lmKG8pe3ZhciBuPXZjKG8sZSk7cmV0dXJuIG4uZ2V0P24uZ2V0LmNhbGwoaSk6bi52YWx1ZX19KSh0LGUsaXx8dCl9dmFyIHljPU1hdGguaHlwb3QsbWM9TWF0aC5hYnMsYmM9TWF0aC5zcXJ0LHdjPSEheWMmJnljKDEvMCxOYU4pIT09MS8wO3Eoe3RhcmdldDpcIk1hdGhcIixzdGF0OiEwLGZvcmNlZDp3Y30se2h5cG90OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpLG8sbj0wLHI9MCxzPWFyZ3VtZW50cy5sZW5ndGgsYT0wO3I8czspYTwoaT1tYyhhcmd1bWVudHNbcisrXSkpPyhuPW4qKG89YS9pKSpvKzEsYT1pKTpuKz1pPjA/KG89aS9hKSpvOmk7cmV0dXJuIGE9PT0xLzA/MS8wOmEqYmMobil9fSk7dmFyIGtjPUYuTWF0aC5oeXBvdDtmdW5jdGlvbiBfYyh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciB4Yz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtQbyh0aGlzLHQpfXJldHVybiBJbyh0LG51bGwsW3trZXk6XCJ0cmFuc2Zvcm1cIix2YWx1ZTpmdW5jdGlvbih0LGUpe2duKHQpfHwodD1bdF0pO2Zvcih2YXIgaT1lLnBvaW50Lngsbz1lLnBvaW50Lnksbj1lLmFuZ2xlLHI9ZS5sZW5ndGgscz0wO3M8dC5sZW5ndGg7KytzKXt2YXIgYT10W3NdLGg9YS54Kk1hdGguY29zKG4pLWEueSpNYXRoLnNpbihuKSxkPWEueCpNYXRoLnNpbihuKSthLnkqTWF0aC5jb3Mobik7YS54PWkrcipoLGEueT1vK3IqZH19fSx7a2V5OlwiZHJhd1BhdGhcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3QuYmVnaW5QYXRoKCksdC5tb3ZlVG8oZVswXS54LGVbMF0ueSk7Zm9yKHZhciBpPTE7aTxlLmxlbmd0aDsrK2kpdC5saW5lVG8oZVtpXS54LGVbaV0ueSk7dC5jbG9zZVBhdGgoKX19XSksdH0oKSxFYz1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPV9jKGkpO2Z1bmN0aW9uIGkoKXtyZXR1cm4gUG8odGhpcyxpKSxlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gSW8oaSxudWxsLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYoZS5pbWFnZSl7dC5zYXZlKCksdC50cmFuc2xhdGUoZS5wb2ludC54LGUucG9pbnQueSksdC5yb3RhdGUoTWF0aC5QSS8yK2UuYW5nbGUpO3ZhciBpPW51bGwhPWUuaW1hZ2VXaWR0aD9lLmltYWdlV2lkdGg6ZS5pbWFnZS53aWR0aCxvPW51bGwhPWUuaW1hZ2VIZWlnaHQ/ZS5pbWFnZUhlaWdodDplLmltYWdlLmhlaWdodDtlLmltYWdlLmRyYXdJbWFnZUF0UG9zaXRpb24odCwxLC1pLzIsMCxpLG8pLHQucmVzdG9yZSgpfXJldHVybiExfX1dKSxpfSh4YyksT2M9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1fYyhpKTtmdW5jdGlvbiBpKCl7cmV0dXJuIFBvKHRoaXMsaSksZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIElvKGksbnVsbCxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPVt7eDowLHk6MH0se3g6LTEseTouM30se3g6LS45LHk6MH0se3g6LTEseTotLjN9XTtyZXR1cm4geGMudHJhbnNmb3JtKGksZSkseGMuZHJhd1BhdGgodCxpKSwhMH19XSksaX0oeGMpLENjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCl9cmV0dXJuIElvKHQsbnVsbCxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPVt7eDotMSx5OjB9LHt4OjAseTouM30se3g6LS40LHk6MH0se3g6MCx5Oi0uM31dO3JldHVybiB4Yy50cmFuc2Zvcm0oaSxlKSx4Yy5kcmF3UGF0aCh0LGkpLCEwfX1dKSx0fSgpLFNjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCl9cmV0dXJuIElvKHQsbnVsbCxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXt4Oi0uNCx5OjB9O3hjLnRyYW5zZm9ybShpLGUpLHQuc3Ryb2tlU3R5bGU9dC5maWxsU3R5bGUsdC5maWxsU3R5bGU9XCJyZ2JhKDAsIDAsIDAsIDApXCI7dmFyIG89TWF0aC5QSSxuPWUuYW5nbGUtby8yLHI9ZS5hbmdsZStvLzI7cmV0dXJuIHQuYmVnaW5QYXRoKCksdC5hcmMoaS54LGkueSwuNCplLmxlbmd0aCxuLHIsITEpLHQuc3Ryb2tlKCksITB9fV0pLHR9KCksVGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7UG8odGhpcyx0KX1yZXR1cm4gSW8odCxudWxsLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9e3g6LS4zLHk6MH07eGMudHJhbnNmb3JtKGksZSksdC5zdHJva2VTdHlsZT10LmZpbGxTdHlsZSx0LmZpbGxTdHlsZT1cInJnYmEoMCwgMCwgMCwgMClcIjt2YXIgbz1NYXRoLlBJLG49ZS5hbmdsZStvLzIscj1lLmFuZ2xlKzMqby8yO3JldHVybiB0LmJlZ2luUGF0aCgpLHQuYXJjKGkueCxpLnksLjQqZS5sZW5ndGgsbixyLCExKSx0LnN0cm9rZSgpLCEwfX1dKSx0fSgpLE1jPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCl9cmV0dXJuIElvKHQsbnVsbCxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPVt7eDouMDIseTowfSx7eDotMSx5Oi4zfSx7eDotMSx5Oi0uM31dO3JldHVybiB4Yy50cmFuc2Zvcm0oaSxlKSx4Yy5kcmF3UGF0aCh0LGkpLCEwfX1dKSx0fSgpLFBjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCl9cmV0dXJuIElvKHQsbnVsbCxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPVt7eDowLHk6LjN9LHt4OjAseTotLjN9LHt4Oi0xLHk6MH1dO3JldHVybiB4Yy50cmFuc2Zvcm0oaSxlKSx4Yy5kcmF3UGF0aCh0LGkpLCEwfX1dKSx0fSgpLERjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCl9cmV0dXJuIElvKHQsbnVsbCxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXt4Oi0uNCx5OjB9O3JldHVybiB4Yy50cmFuc2Zvcm0oaSxlKSx3dCh0LGkueCxpLnksLjQqZS5sZW5ndGgpLCEwfX1dKSx0fSgpLEJjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCl9cmV0dXJuIElvKHQsbnVsbCxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPVt7eDowLHk6LjV9LHt4OjAseTotLjV9LHt4Oi0uMTUseTotLjV9LHt4Oi0uMTUseTouNX1dO3JldHVybiB4Yy50cmFuc2Zvcm0oaSxlKSx4Yy5kcmF3UGF0aCh0LGkpLCEwfX1dKSx0fSgpLEljPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCl9cmV0dXJuIElvKHQsbnVsbCxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPVt7eDowLHk6LjN9LHt4OjAseTotLjN9LHt4Oi0uNix5Oi0uM30se3g6LS42LHk6LjN9XTtyZXR1cm4geGMudHJhbnNmb3JtKGksZSkseGMuZHJhd1BhdGgodCxpKSwhMH19XSksdH0oKSx6Yz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtQbyh0aGlzLHQpfXJldHVybiBJbyh0LG51bGwsW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT1be3g6MCx5OjB9LHt4Oi0uNSx5Oi0uM30se3g6LTEseTowfSx7eDotLjUseTouM31dO3JldHVybiB4Yy50cmFuc2Zvcm0oaSxlKSx4Yy5kcmF3UGF0aCh0LGkpLCEwfX1dKSx0fSgpLEZjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCl9cmV0dXJuIElvKHQsbnVsbCxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPVt7eDotMSx5Oi4zfSx7eDotLjUseTowfSx7eDotMSx5Oi0uM30se3g6MCx5OjB9XTtyZXR1cm4geGMudHJhbnNmb3JtKGksZSkseGMuZHJhd1BhdGgodCxpKSwhMH19XSksdH0oKSxOYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtQbyh0aGlzLHQpfXJldHVybiBJbyh0LG51bGwsW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaTtzd2l0Y2goZS50eXBlJiYoaT1lLnR5cGUudG9Mb3dlckNhc2UoKSksaSl7Y2FzZVwiaW1hZ2VcIjpyZXR1cm4gRWMuZHJhdyh0LGUpO2Nhc2VcImNpcmNsZVwiOnJldHVybiBEYy5kcmF3KHQsZSk7Y2FzZVwiYm94XCI6cmV0dXJuIEljLmRyYXcodCxlKTtjYXNlXCJjcm93XCI6cmV0dXJuIENjLmRyYXcodCxlKTtjYXNlXCJjdXJ2ZVwiOnJldHVybiBTYy5kcmF3KHQsZSk7Y2FzZVwiZGlhbW9uZFwiOnJldHVybiB6Yy5kcmF3KHQsZSk7Y2FzZVwiaW52X2N1cnZlXCI6cmV0dXJuIFRjLmRyYXcodCxlKTtjYXNlXCJ0cmlhbmdsZVwiOnJldHVybiBNYy5kcmF3KHQsZSk7Y2FzZVwiaW52X3RyaWFuZ2xlXCI6cmV0dXJuIFBjLmRyYXcodCxlKTtjYXNlXCJiYXJcIjpyZXR1cm4gQmMuZHJhdyh0LGUpO2Nhc2VcInZlZVwiOnJldHVybiBGYy5kcmF3KHQsZSk7Y2FzZVwiYXJyb3dcIjpkZWZhdWx0OnJldHVybiBPYy5kcmF3KHQsZSl9fX1dKSx0fSgpO2Z1bmN0aW9uIEFjKHQsZSl7dmFyIGk9eG4odCk7aWYod28pe3ZhciBvPXdvKHQpO2UmJihvPWFyKG8pLmNhbGwobywoZnVuY3Rpb24oZSl7cmV0dXJuIEVvKHQsZSkuZW51bWVyYWJsZX0pKSksaS5wdXNoLmFwcGx5KGksbyl9cmV0dXJuIGl9ZnVuY3Rpb24gUmModCl7Zm9yKHZhciBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIGksbz1udWxsIT1hcmd1bWVudHNbZV0/YXJndW1lbnRzW2VdOnt9O2lmKGUlMilEbihpPUFjKE9iamVjdChvKSwhMCkpLmNhbGwoaSwoZnVuY3Rpb24oZSl7em8odCxlLG9bZV0pfSkpO2Vsc2UgaWYoQ28pU28odCxDbyhvKSk7ZWxzZXt2YXIgbjtEbihuPUFjKE9iamVjdChvKSkpLmNhbGwobiwoZnVuY3Rpb24oZSl7TW8odCxlLEVvKG8sZSkpfSkpfX1yZXR1cm4gdH12YXIgamM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsaSxvKXtQbyh0aGlzLHQpLHRoaXMuX2JvZHk9aSx0aGlzLl9sYWJlbE1vZHVsZT1vLHRoaXMuY29sb3I9e30sdGhpcy5jb2xvckRpcnR5PSEwLHRoaXMuaG92ZXJXaWR0aD0xLjUsdGhpcy5zZWxlY3Rpb25XaWR0aD0yLHRoaXMuc2V0T3B0aW9ucyhlKSx0aGlzLmZyb21Qb2ludD10aGlzLmZyb20sdGhpcy50b1BvaW50PXRoaXMudG99cmV0dXJuIElvKHQsW3trZXk6XCJjb25uZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmZyb209dGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV0sdGhpcy50bz10aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b119fSx7a2V5OlwiY2xlYW51cFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuITF9fSx7a2V5Olwic2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMub3B0aW9ucz10LHRoaXMuZnJvbT10aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy5mcm9tXSx0aGlzLnRvPXRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXSx0aGlzLmlkPXRoaXMub3B0aW9ucy5pZH19LHtrZXk6XCJkcmF3TGluZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8pe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+NCYmdm9pZCAwIT09YXJndW1lbnRzWzRdP2FyZ3VtZW50c1s0XTp0aGlzLmdldFZpYU5vZGUoKTt0LnN0cm9rZVN0eWxlPXRoaXMuZ2V0Q29sb3IodCxlKSx0LmxpbmVXaWR0aD1lLndpZHRoLCExIT09ZS5kYXNoZXM/dGhpcy5fZHJhd0Rhc2hlZExpbmUodCxlLG4pOnRoaXMuX2RyYXdMaW5lKHQsZSxuKX19LHtrZXk6XCJfZHJhd0xpbmVcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4pe2lmKHRoaXMuZnJvbSE9dGhpcy50byl0aGlzLl9saW5lKHQsZSxpLG8sbik7ZWxzZXt2YXIgcj1hbih0aGlzLl9nZXRDaXJjbGVEYXRhKHQpLDMpLHM9clswXSxhPXJbMV0saD1yWzJdO3RoaXMuX2NpcmNsZSh0LGUscyxhLGgpfX19LHtrZXk6XCJfZHJhd0Rhc2hlZExpbmVcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4pe3QubGluZUNhcD1cInJvdW5kXCI7dmFyIHI9Z24oZS5kYXNoZXMpP2UuZGFzaGVzOls1LDVdO2lmKHZvaWQgMCE9PXQuc2V0TGluZURhc2gpe2lmKHQuc2F2ZSgpLHQuc2V0TGluZURhc2gociksdC5saW5lRGFzaE9mZnNldD0wLHRoaXMuZnJvbSE9dGhpcy50byl0aGlzLl9saW5lKHQsZSxpKTtlbHNle3ZhciBzPWFuKHRoaXMuX2dldENpcmNsZURhdGEodCksMyksYT1zWzBdLGg9c1sxXSxkPXNbMl07dGhpcy5fY2lyY2xlKHQsZSxhLGgsZCl9dC5zZXRMaW5lRGFzaChbMF0pLHQubGluZURhc2hPZmZzZXQ9MCx0LnJlc3RvcmUoKX1lbHNle2lmKHRoaXMuZnJvbSE9dGhpcy50bylFdCh0LHRoaXMuZnJvbS54LHRoaXMuZnJvbS55LHRoaXMudG8ueCx0aGlzLnRvLnkscik7ZWxzZXt2YXIgbD1hbih0aGlzLl9nZXRDaXJjbGVEYXRhKHQpLDMpLGM9bFswXSx1PWxbMV0sZj1sWzJdO3RoaXMuX2NpcmNsZSh0LGUsYyx1LGYpfXRoaXMuZW5hYmxlU2hhZG93KHQsZSksdC5zdHJva2UoKSx0aGlzLmRpc2FibGVTaGFkb3codCxlKX19fSx7a2V5OlwiZmluZEJvcmRlclBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3JldHVybiB0aGlzLmZyb20hPXRoaXMudG8/dGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKHQsZSxpKTp0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodCxlLGkpfX0se2tleTpcImZpbmRCb3JkZXJQb3NpdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih0aGlzLmZyb20hPXRoaXMudG8pcmV0dXJue2Zyb206dGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKHRoaXMuZnJvbSx0KSx0bzp0aGlzLl9maW5kQm9yZGVyUG9zaXRpb24odGhpcy50byx0KX07dmFyIGUsaT1hbih2bihlPXRoaXMuX2dldENpcmNsZURhdGEodCkpLmNhbGwoZSwwLDIpLDIpLG89aVswXSxuPWlbMV07cmV0dXJue2Zyb206dGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSx0LHt4Om8seTpuLGxvdzouMjUsaGlnaDouNixkaXJlY3Rpb246LTF9KSx0bzp0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLHQse3g6byx5Om4sbG93Oi42LGhpZ2g6LjgsZGlyZWN0aW9uOjF9KX19fSx7a2V5OlwiX2dldENpcmNsZURhdGFcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplO3ZvaWQgMCE9PXQmJnZvaWQgMD09PXRoaXMuZnJvbS5zaGFwZS53aWR0aCYmdGhpcy5mcm9tLnNoYXBlLnJlc2l6ZSh0KTt2YXIgaT10bCh0LHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlLGUsdGhpcy5mcm9tKTtyZXR1cm5baS54LGkueSxlXX19LHtrZXk6XCJfcG9pbnRPbkNpcmNsZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8pe3ZhciBuPTIqbypNYXRoLlBJO3JldHVybnt4OnQraSpNYXRoLmNvcyhuKSx5OmUtaSpNYXRoLnNpbihuKX19fSx7a2V5OlwiX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbyxuPWkueCxyPWkueSxzPWkubG93LGE9aS5oaWdoLGg9aS5kaXJlY3Rpb24sZD10aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplLGw9LjUqKHMrYSksYz0wOyEwPT09dGhpcy5vcHRpb25zLmFycm93U3RyaWtldGhyb3VnaCYmKC0xPT09aD9jPXRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tOjE9PT1oJiYoYz10aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG8pKTt2YXIgdT0wO2Rve2w9LjUqKHMrYSksbz10aGlzLl9wb2ludE9uQ2lyY2xlKG4scixkLGwpO3ZhciBmPU1hdGguYXRhbjIodC55LW8ueSx0Lngtby54KSxwPXQuZGlzdGFuY2VUb0JvcmRlcihlLGYpK2MtTWF0aC5zcXJ0KE1hdGgucG93KG8ueC10LngsMikrTWF0aC5wb3coby55LXQueSwyKSk7aWYoTWF0aC5hYnMocCk8LjA1KWJyZWFrO3A+MD9oPjA/cz1sOmE9bDpoPjA/YT1sOnM9bCwrK3V9d2hpbGUoczw9YSYmdTwxMCk7cmV0dXJuIFJjKFJjKHt9LG8pLHt9LHt0Omx9KX19LHtrZXk6XCJnZXRMaW5lV2lkdGhcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiEwPT09dD9NYXRoLm1heCh0aGlzLnNlbGVjdGlvbldpZHRoLC4zL3RoaXMuX2JvZHkudmlldy5zY2FsZSk6ITA9PT1lP01hdGgubWF4KHRoaXMuaG92ZXJXaWR0aCwuMy90aGlzLl9ib2R5LnZpZXcuc2NhbGUpOk1hdGgubWF4KHRoaXMub3B0aW9ucy53aWR0aCwuMy90aGlzLl9ib2R5LnZpZXcuc2NhbGUpfX0se2tleTpcImdldENvbG9yXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZighMSE9PWUuaW5oZXJpdHNDb2xvcil7aWYoXCJib3RoXCI9PT1lLmluaGVyaXRzQ29sb3ImJnRoaXMuZnJvbS5pZCE9PXRoaXMudG8uaWQpe3ZhciBpPXQuY3JlYXRlTGluZWFyR3JhZGllbnQodGhpcy5mcm9tLngsdGhpcy5mcm9tLnksdGhpcy50by54LHRoaXMudG8ueSksbz10aGlzLmZyb20ub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyLG49dGhpcy50by5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXI7cmV0dXJuITE9PT10aGlzLmZyb20uc2VsZWN0ZWQmJiExPT09dGhpcy50by5zZWxlY3RlZD8obz1zaCh0aGlzLmZyb20ub3B0aW9ucy5jb2xvci5ib3JkZXIsZS5vcGFjaXR5KSxuPXNoKHRoaXMudG8ub3B0aW9ucy5jb2xvci5ib3JkZXIsZS5vcGFjaXR5KSk6ITA9PT10aGlzLmZyb20uc2VsZWN0ZWQmJiExPT09dGhpcy50by5zZWxlY3RlZD9uPXRoaXMudG8ub3B0aW9ucy5jb2xvci5ib3JkZXI6ITE9PT10aGlzLmZyb20uc2VsZWN0ZWQmJiEwPT09dGhpcy50by5zZWxlY3RlZCYmKG89dGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuYm9yZGVyKSxpLmFkZENvbG9yU3RvcCgwLG8pLGkuYWRkQ29sb3JTdG9wKDEsbiksaX1yZXR1cm5cInRvXCI9PT1lLmluaGVyaXRzQ29sb3I/c2godGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlcixlLm9wYWNpdHkpOnNoKHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmJvcmRlcixlLm9wYWNpdHkpfXJldHVybiBzaChlLmNvbG9yLGUub3BhY2l0eSl9fSx7a2V5OlwiX2NpcmNsZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbil7dGhpcy5lbmFibGVTaGFkb3codCxlKTt2YXIgcj0wLHM9MipNYXRoLlBJO2lmKCF0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5yZW5kZXJCZWhpbmRUaGVOb2RlKXt2YXIgYT10aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSxoPXRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlK01hdGguUEksZD10aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLHQse3g6aSx5Om8sbG93OmEsaGlnaDpoLGRpcmVjdGlvbjotMX0pLGw9dGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSx0LHt4OmkseTpvLGxvdzphLGhpZ2g6aCxkaXJlY3Rpb246MX0pO3I9TWF0aC5hdGFuMihkLnktbyxkLngtaSkscz1NYXRoLmF0YW4yKGwueS1vLGwueC1pKX10LmJlZ2luUGF0aCgpLHQuYXJjKGksbyxuLHIscywhMSksdC5zdHJva2UoKSx0aGlzLmRpc2FibGVTaGFkb3codCxlKX19LHtrZXk6XCJnZXREaXN0YW5jZVRvRWRnZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXtpZih0aGlzLmZyb20hPXRoaXMudG8pcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9FZGdlKHQsZSxpLG8sbixyKTt2YXIgcz1hbih0aGlzLl9nZXRDaXJjbGVEYXRhKHZvaWQgMCksMyksYT1zWzBdLGg9c1sxXSxkPXNbMl0sbD1hLW4sYz1oLXI7cmV0dXJuIE1hdGguYWJzKE1hdGguc3FydChsKmwrYypjKS1kKX19LHtrZXk6XCJfZ2V0RGlzdGFuY2VUb0xpbmVcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7dmFyIHM9aS10LGE9by1lLGg9KChuLXQpKnMrKHItZSkqYSkvKHMqcythKmEpO2g+MT9oPTE6aDwwJiYoaD0wKTt2YXIgZD10K2gqcy1uLGw9ZStoKmEtcjtyZXR1cm4gTWF0aC5zcXJ0KGQqZCtsKmwpfX0se2tleTpcImdldEFycm93RGF0YVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXt2YXIgcyxhLGgsZCxsLGMsdSxmPXIud2lkdGg7XCJmcm9tXCI9PT1lPyhoPXRoaXMuZnJvbSxkPXRoaXMudG8sbD1yLmZyb21BcnJvd1NjYWxlPDAsYz1NYXRoLmFicyhyLmZyb21BcnJvd1NjYWxlKSx1PXIuZnJvbUFycm93VHlwZSk6XCJ0b1wiPT09ZT8oaD10aGlzLnRvLGQ9dGhpcy5mcm9tLGw9ci50b0Fycm93U2NhbGU8MCxjPU1hdGguYWJzKHIudG9BcnJvd1NjYWxlKSx1PXIudG9BcnJvd1R5cGUpOihoPXRoaXMudG8sZD10aGlzLmZyb20sbD1yLm1pZGRsZUFycm93U2NhbGU8MCxjPU1hdGguYWJzKHIubWlkZGxlQXJyb3dTY2FsZSksdT1yLm1pZGRsZUFycm93VHlwZSk7dmFyIHA9MTUqYyszKmY7aWYoaCE9ZCl7dmFyIHY9cC9rYyhoLngtZC54LGgueS1kLnkpO2lmKFwibWlkZGxlXCIhPT1lKWlmKCEwPT09dGhpcy5vcHRpb25zLnNtb290aC5lbmFibGVkKXt2YXIgZz10aGlzLl9maW5kQm9yZGVyUG9zaXRpb24oaCx0LHt2aWE6aX0pLHk9dGhpcy5nZXRQb2ludChnLnQrdiooXCJmcm9tXCI9PT1lPzE6LTEpLGkpO3M9TWF0aC5hdGFuMihnLnkteS55LGcueC15LngpLGE9Z31lbHNlIHM9TWF0aC5hdGFuMihoLnktZC55LGgueC1kLngpLGE9dGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKGgsdCk7ZWxzZXt2YXIgbT0obD8tdjp2KS8yLGI9dGhpcy5nZXRQb2ludCguNSttLGkpLHc9dGhpcy5nZXRQb2ludCguNS1tLGkpO3M9TWF0aC5hdGFuMihiLnktdy55LGIueC13LngpLGE9dGhpcy5nZXRQb2ludCguNSxpKX19ZWxzZXt2YXIgaz1hbih0aGlzLl9nZXRDaXJjbGVEYXRhKHQpLDMpLF89a1swXSx4PWtbMV0sRT1rWzJdO2lmKFwiZnJvbVwiPT09ZSl7dmFyIE89dGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUsQz10aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZStNYXRoLlBJLFM9dGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSx0LHt4Ol8seTp4LGxvdzpPLGhpZ2g6QyxkaXJlY3Rpb246LTF9KTtzPS0yKlMudCpNYXRoLlBJKzEuNSpNYXRoLlBJKy4xKk1hdGguUEksYT1TfWVsc2UgaWYoXCJ0b1wiPT09ZSl7dmFyIFQ9dGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUsTT10aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZStNYXRoLlBJLFA9dGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSx0LHt4Ol8seTp4LGxvdzpULGhpZ2g6TSxkaXJlY3Rpb246MX0pO3M9LTIqUC50Kk1hdGguUEkrMS41Kk1hdGguUEktMS4xKk1hdGguUEksYT1QfWVsc2V7dmFyIEQ9dGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUvKDIqTWF0aC5QSSk7YT10aGlzLl9wb2ludE9uQ2lyY2xlKF8seCxFLEQpLHM9LTIqRCpNYXRoLlBJKzEuNSpNYXRoLlBJKy4xKk1hdGguUEl9fXJldHVybntwb2ludDphLGNvcmU6e3g6YS54LS45KnAqTWF0aC5jb3MocykseTphLnktLjkqcCpNYXRoLnNpbihzKX0sYW5nbGU6cyxsZW5ndGg6cCx0eXBlOnV9fX0se2tleTpcImRyYXdBcnJvd0hlYWRcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4pe3Quc3Ryb2tlU3R5bGU9dGhpcy5nZXRDb2xvcih0LGUpLHQuZmlsbFN0eWxlPXQuc3Ryb2tlU3R5bGUsdC5saW5lV2lkdGg9ZS53aWR0aCxOYy5kcmF3KHQsbikmJih0aGlzLmVuYWJsZVNoYWRvdyh0LGUpLFhyKHQpLmNhbGwodCksdGhpcy5kaXNhYmxlU2hhZG93KHQsZSkpfX0se2tleTpcImVuYWJsZVNoYWRvd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7ITA9PT1lLnNoYWRvdyYmKHQuc2hhZG93Q29sb3I9ZS5zaGFkb3dDb2xvcix0LnNoYWRvd0JsdXI9ZS5zaGFkb3dTaXplLHQuc2hhZG93T2Zmc2V0WD1lLnNoYWRvd1gsdC5zaGFkb3dPZmZzZXRZPWUuc2hhZG93WSl9fSx7a2V5OlwiZGlzYWJsZVNoYWRvd1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7ITA9PT1lLnNoYWRvdyYmKHQuc2hhZG93Q29sb3I9XCJyZ2JhKDAsMCwwLDApXCIsdC5zaGFkb3dCbHVyPTAsdC5zaGFkb3dPZmZzZXRYPTAsdC5zaGFkb3dPZmZzZXRZPTApfX0se2tleTpcImRyYXdCYWNrZ3JvdW5kXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZighMSE9PWUuYmFja2dyb3VuZCl7dmFyIGk9e3N0cm9rZVN0eWxlOnQuc3Ryb2tlU3R5bGUsbGluZVdpZHRoOnQubGluZVdpZHRoLGRhc2hlczp0LmRhc2hlc307dC5zdHJva2VTdHlsZT1lLmJhY2tncm91bmRDb2xvcix0LmxpbmVXaWR0aD1lLmJhY2tncm91bmRTaXplLHRoaXMuc2V0U3Ryb2tlRGFzaGVkKHQsZS5iYWNrZ3JvdW5kRGFzaGVzKSx0LnN0cm9rZSgpLHQuc3Ryb2tlU3R5bGU9aS5zdHJva2VTdHlsZSx0LmxpbmVXaWR0aD1pLmxpbmVXaWR0aCx0LmRhc2hlcz1pLmRhc2hlcyx0aGlzLnNldFN0cm9rZURhc2hlZCh0LGUuZGFzaGVzKX19fSx7a2V5Olwic2V0U3Ryb2tlRGFzaGVkXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZighMSE9PWUpaWYodm9pZCAwIT09dC5zZXRMaW5lRGFzaCl7dmFyIGk9Z24oZSk/ZTpbNSw1XTt0LnNldExpbmVEYXNoKGkpfWVsc2UgY29uc29sZS53YXJuKFwic2V0TGluZURhc2ggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFRoZSBkYXNoZWQgc3Ryb2tlIGNhbm5vdCBiZSB1c2VkLlwiKTtlbHNlIHZvaWQgMCE9PXQuc2V0TGluZURhc2g/dC5zZXRMaW5lRGFzaChbXSk6Y29uc29sZS53YXJuKFwic2V0TGluZURhc2ggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFRoZSBkYXNoZWQgc3Ryb2tlIGNhbm5vdCBiZSB1c2VkLlwiKX19XSksdH0oKTtmdW5jdGlvbiBMYyh0LGUpe3ZhciBpPXhuKHQpO2lmKHdvKXt2YXIgbz13byh0KTtlJiYobz1hcihvKS5jYWxsKG8sKGZ1bmN0aW9uKGUpe3JldHVybiBFbyh0LGUpLmVudW1lcmFibGV9KSkpLGkucHVzaC5hcHBseShpLG8pfXJldHVybiBpfWZ1bmN0aW9uIEhjKHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciBpLG89bnVsbCE9YXJndW1lbnRzW2VdP2FyZ3VtZW50c1tlXTp7fTtpZihlJTIpRG4oaT1MYyhPYmplY3QobyksITApKS5jYWxsKGksKGZ1bmN0aW9uKGUpe3pvKHQsZSxvW2VdKX0pKTtlbHNlIGlmKENvKVNvKHQsQ28obykpO2Vsc2V7dmFyIG47RG4obj1MYyhPYmplY3QobykpKS5jYWxsKG4sKGZ1bmN0aW9uKGUpe01vKHQsZSxFbyhvLGUpKX0pKX19cmV0dXJuIHR9ZnVuY3Rpb24gV2ModCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgVmM9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1XYyhpKTtmdW5jdGlvbiBpKHQsbyxuKXtyZXR1cm4gUG8odGhpcyxpKSxlLmNhbGwodGhpcyx0LG8sbil9cmV0dXJuIElvKGksW3trZXk6XCJfZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaSxvLG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCkscj0xMCxzPS4yLGE9ITEsaD0xLGQ9MCxsPXRoaXMudG8sYz10aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQ/dGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvOjA7dC5pZD09PXRoaXMuZnJvbS5pZCYmKGw9dGhpcy5mcm9tLGE9ITAsYz10aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQ/dGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb206MCksITE9PT10aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoJiYoYz0wKTt2YXIgdT0wO2Rve289LjUqKGQraCksaT10aGlzLmdldFBvaW50KG8sbik7dmFyIGY9TWF0aC5hdGFuMihsLnktaS55LGwueC1pLngpLHA9bC5kaXN0YW5jZVRvQm9yZGVyKGUsZikrYyx2PU1hdGguc3FydChNYXRoLnBvdyhpLngtbC54LDIpK01hdGgucG93KGkueS1sLnksMikpLGc9cC12O2lmKE1hdGguYWJzKGcpPHMpYnJlYWs7ZzwwPyExPT09YT9kPW86aD1vOiExPT09YT9oPW86ZD1vLCsrdX13aGlsZShkPD1oJiZ1PHIpO3JldHVybiBIYyhIYyh7fSxpKSx7fSx7dDpvfSl9fSx7a2V5OlwiX2dldERpc3RhbmNlVG9CZXppZXJFZGdlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIscyl7dmFyIGEsaCxkLGwsYyx1PTFlOSxmPXQscD1lO2ZvcihoPTE7aDwxMDtoKyspZD0uMSpoLGw9TWF0aC5wb3coMS1kLDIpKnQrMipkKigxLWQpKnMueCtNYXRoLnBvdyhkLDIpKmksYz1NYXRoLnBvdygxLWQsMikqZSsyKmQqKDEtZCkqcy55K01hdGgucG93KGQsMikqbyxoPjAmJih1PShhPXRoaXMuX2dldERpc3RhbmNlVG9MaW5lKGYscCxsLGMsbixyKSk8dT9hOnUpLGY9bCxwPWM7cmV0dXJuIHV9fSx7a2V5OlwiX2JlemllckN1cnZlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyl7dC5iZWdpblBhdGgoKSx0Lm1vdmVUbyh0aGlzLmZyb21Qb2ludC54LHRoaXMuZnJvbVBvaW50LnkpLG51bGwhPWkmJm51bGwhPWkueD9udWxsIT1vJiZudWxsIT1vLng/dC5iZXppZXJDdXJ2ZVRvKGkueCxpLnksby54LG8ueSx0aGlzLnRvUG9pbnQueCx0aGlzLnRvUG9pbnQueSk6dC5xdWFkcmF0aWNDdXJ2ZVRvKGkueCxpLnksdGhpcy50b1BvaW50LngsdGhpcy50b1BvaW50LnkpOnQubGluZVRvKHRoaXMudG9Qb2ludC54LHRoaXMudG9Qb2ludC55KSx0aGlzLmRyYXdCYWNrZ3JvdW5kKHQsZSksdGhpcy5lbmFibGVTaGFkb3codCxlKSx0LnN0cm9rZSgpLHRoaXMuZGlzYWJsZVNoYWRvdyh0LGUpfX0se2tleTpcImdldFZpYU5vZGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpfX1dKSxpfShqYyk7ZnVuY3Rpb24gcWModCl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IXZsKXJldHVybiExO2lmKHZsLnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmwoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaSxvPV9sKHQpO2lmKGUpe3ZhciBuPV9sKHRoaXMpLmNvbnN0cnVjdG9yO2k9dmwobyxhcmd1bWVudHMsbil9ZWxzZSBpPW8uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3bCh0aGlzLGkpfX12YXIgVWM9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1xYyhpKTtmdW5jdGlvbiBpKHQsbyxuKXt2YXIgcjtyZXR1cm4gUG8odGhpcyxpKSwocj1lLmNhbGwodGhpcyx0LG8sbikpLnZpYT1yLnZpYSxyLl9ib3VuZEZ1bmN0aW9uPWZ1bmN0aW9uKCl7ci5wb3NpdGlvbkJlemllck5vZGUoKX0sci5fYm9keS5lbWl0dGVyLm9uKFwiX3JlcG9zaXRpb25CZXppZXJOb2Rlc1wiLHIuX2JvdW5kRnVuY3Rpb24pLHJ9cmV0dXJuIElvKGksW3trZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7Z2MoX2woaS5wcm90b3R5cGUpLFwic2V0T3B0aW9uc1wiLHRoaXMpLmNhbGwodGhpcyx0KTt2YXIgZT0hMTt0aGlzLm9wdGlvbnMucGh5c2ljcyE9PXQucGh5c2ljcyYmKGU9ITApLHRoaXMub3B0aW9ucz10LHRoaXMuaWQ9dGhpcy5vcHRpb25zLmlkLHRoaXMuZnJvbT10aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy5mcm9tXSx0aGlzLnRvPXRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXSx0aGlzLnNldHVwU3VwcG9ydE5vZGUoKSx0aGlzLmNvbm5lY3QoKSwhMD09PWUmJih0aGlzLnZpYS5zZXRPcHRpb25zKHtwaHlzaWNzOnRoaXMub3B0aW9ucy5waHlzaWNzfSksdGhpcy5wb3NpdGlvbkJlemllck5vZGUoKSl9fSx7a2V5OlwiY29ubmVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5mcm9tPXRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dLHRoaXMudG89dGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dLHZvaWQgMD09PXRoaXMuZnJvbXx8dm9pZCAwPT09dGhpcy50b3x8ITE9PT10aGlzLm9wdGlvbnMucGh5c2ljc3x8dGhpcy5mcm9tLmlkPT09dGhpcy50by5pZD90aGlzLnZpYS5zZXRPcHRpb25zKHtwaHlzaWNzOiExfSk6dGhpcy52aWEuc2V0T3B0aW9ucyh7cGh5c2ljczohMH0pfX0se2tleTpcImNsZWFudXBcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9ib2R5LmVtaXR0ZXIub2ZmKFwiX3JlcG9zaXRpb25CZXppZXJOb2Rlc1wiLHRoaXMuX2JvdW5kRnVuY3Rpb24pLHZvaWQgMCE9PXRoaXMudmlhJiYoZGVsZXRlIHRoaXMuX2JvZHkubm9kZXNbdGhpcy52aWEuaWRdLHRoaXMudmlhPXZvaWQgMCwhMCl9fSx7a2V5Olwic2V0dXBTdXBwb3J0Tm9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodm9pZCAwPT09dGhpcy52aWEpe3ZhciB0PVwiZWRnZUlkOlwiK3RoaXMuaWQsZT10aGlzLl9ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlKHtpZDp0LHNoYXBlOlwiY2lyY2xlXCIscGh5c2ljczohMCxoaWRkZW46ITB9KTt0aGlzLl9ib2R5Lm5vZGVzW3RdPWUsdGhpcy52aWE9ZSx0aGlzLnZpYS5wYXJlbnRFZGdlSWQ9dGhpcy5pZCx0aGlzLnBvc2l0aW9uQmV6aWVyTm9kZSgpfX19LHtrZXk6XCJwb3NpdGlvbkJlemllck5vZGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZvaWQgMCE9PXRoaXMudmlhJiZ2b2lkIDAhPT10aGlzLmZyb20mJnZvaWQgMCE9PXRoaXMudG8/KHRoaXMudmlhLng9LjUqKHRoaXMuZnJvbS54K3RoaXMudG8ueCksdGhpcy52aWEueT0uNSoodGhpcy5mcm9tLnkrdGhpcy50by55KSk6dm9pZCAwIT09dGhpcy52aWEmJih0aGlzLnZpYS54PTAsdGhpcy52aWEueT0wKX19LHtrZXk6XCJfbGluZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt0aGlzLl9iZXppZXJDdXJ2ZSh0LGUsaSl9fSx7a2V5OlwiX2dldFZpYUNvb3JkaW5hdGVzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWF9fSx7a2V5OlwiZ2V0VmlhTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlhfX0se2tleTpcImdldFBvaW50XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMudmlhO2lmKHRoaXMuZnJvbT09PXRoaXMudG8pe3ZhciBpPXRoaXMuX2dldENpcmNsZURhdGEoKSxvPWFuKGksMyksbj1vWzBdLHI9b1sxXSxzPW9bMl0sYT0yKk1hdGguUEkqKDEtdCk7cmV0dXJue3g6bitzKk1hdGguc2luKGEpLHk6citzLXMqKDEtTWF0aC5jb3MoYSkpfX1yZXR1cm57eDpNYXRoLnBvdygxLXQsMikqdGhpcy5mcm9tUG9pbnQueCsyKnQqKDEtdCkqZS54K01hdGgucG93KHQsMikqdGhpcy50b1BvaW50LngseTpNYXRoLnBvdygxLXQsMikqdGhpcy5mcm9tUG9pbnQueSsyKnQqKDEtdCkqZS55K01hdGgucG93KHQsMikqdGhpcy50b1BvaW50Lnl9fX0se2tleTpcIl9maW5kQm9yZGVyUG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIodCxlLHRoaXMudmlhKX19LHtrZXk6XCJfZ2V0RGlzdGFuY2VUb0VkZ2VcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvLG4scil7cmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHQsZSxpLG8sbixyLHRoaXMudmlhKX19XSksaX0oVmMpO2Z1bmN0aW9uIFljKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIFhjPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9WWMoaSk7ZnVuY3Rpb24gaSh0LG8sbil7cmV0dXJuIFBvKHRoaXMsaSksZS5jYWxsKHRoaXMsdCxvLG4pfXJldHVybiBJbyhpLFt7a2V5OlwiX2xpbmVcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dGhpcy5fYmV6aWVyQ3VydmUodCxlLGkpfX0se2tleTpcImdldFZpYU5vZGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpfX0se2tleTpcIl9nZXRWaWFDb29yZGluYXRlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZSxpPXRoaXMub3B0aW9ucy5zbW9vdGgucm91bmRuZXNzLG89dGhpcy5vcHRpb25zLnNtb290aC50eXBlLG49TWF0aC5hYnModGhpcy5mcm9tLngtdGhpcy50by54KSxyPU1hdGguYWJzKHRoaXMuZnJvbS55LXRoaXMudG8ueSk7aWYoXCJkaXNjcmV0ZVwiPT09b3x8XCJkaWFnb25hbENyb3NzXCI9PT1vKXt2YXIgcyxhO3M9YT1uPD1yP2kqcjppKm4sdGhpcy5mcm9tLng+dGhpcy50by54JiYocz0tcyksdGhpcy5mcm9tLnk+PXRoaXMudG8ueSYmKGE9LWEpO3ZhciBoPXRoaXMuZnJvbS54K3MsZD10aGlzLmZyb20ueSthO3JldHVyblwiZGlzY3JldGVcIj09PW8mJihuPD1yP2g9bjxpKnI/dGhpcy5mcm9tLng6aDpkPXI8aSpuP3RoaXMuZnJvbS55OmQpLHt4OmgseTpkfX1pZihcInN0cmFpZ2h0Q3Jvc3NcIj09PW8pe3ZhciBsPSgxLWkpKm4sYz0oMS1pKSpyO3JldHVybiBuPD1yPyhsPTAsdGhpcy5mcm9tLnk8dGhpcy50by55JiYoYz0tYykpOih0aGlzLmZyb20ueDx0aGlzLnRvLngmJihsPS1sKSxjPTApLHt4OnRoaXMudG8ueCtsLHk6dGhpcy50by55K2N9fWlmKFwiaG9yaXpvbnRhbFwiPT09byl7dmFyIHU9KDEtaSkqbjtyZXR1cm4gdGhpcy5mcm9tLng8dGhpcy50by54JiYodT0tdSkse3g6dGhpcy50by54K3UseTp0aGlzLmZyb20ueX19aWYoXCJ2ZXJ0aWNhbFwiPT09byl7dmFyIGY9KDEtaSkqcjtyZXR1cm4gdGhpcy5mcm9tLnk8dGhpcy50by55JiYoZj0tZikse3g6dGhpcy5mcm9tLngseTp0aGlzLnRvLnkrZn19aWYoXCJjdXJ2ZWRDV1wiPT09byl7bj10aGlzLnRvLngtdGhpcy5mcm9tLngscj10aGlzLmZyb20ueS10aGlzLnRvLnk7dmFyIHA9TWF0aC5zcXJ0KG4qbityKnIpLHY9TWF0aC5QSSxnPShNYXRoLmF0YW4yKHIsbikrKC41KmkrLjUpKnYpJSgyKnYpO3JldHVybnt4OnRoaXMuZnJvbS54KyguNSppKy41KSpwKk1hdGguc2luKGcpLHk6dGhpcy5mcm9tLnkrKC41KmkrLjUpKnAqTWF0aC5jb3MoZyl9fWlmKFwiY3VydmVkQ0NXXCI9PT1vKXtuPXRoaXMudG8ueC10aGlzLmZyb20ueCxyPXRoaXMuZnJvbS55LXRoaXMudG8ueTt2YXIgeT1NYXRoLnNxcnQobipuK3IqciksbT1NYXRoLlBJLGI9KE1hdGguYXRhbjIocixuKSsoLjUqLWkrLjUpKm0pJSgyKm0pO3JldHVybnt4OnRoaXMuZnJvbS54KyguNSppKy41KSp5Kk1hdGguc2luKGIpLHk6dGhpcy5mcm9tLnkrKC41KmkrLjUpKnkqTWF0aC5jb3MoYil9fXQ9ZT1uPD1yP2kqcjppKm4sdGhpcy5mcm9tLng+dGhpcy50by54JiYodD0tdCksdGhpcy5mcm9tLnk+PXRoaXMudG8ueSYmKGU9LWUpO3ZhciB3PXRoaXMuZnJvbS54K3Qsaz10aGlzLmZyb20ueStlO3JldHVybiBuPD1yP3c9dGhpcy5mcm9tLng8PXRoaXMudG8ueD90aGlzLnRvLng8dz90aGlzLnRvLng6dzp0aGlzLnRvLng+dz90aGlzLnRvLng6dzprPXRoaXMuZnJvbS55Pj10aGlzLnRvLnk/dGhpcy50by55Pms/dGhpcy50by55Oms6dGhpcy50by55PGs/dGhpcy50by55Omsse3g6dyx5Omt9fX0se2tleTpcIl9maW5kQm9yZGVyUG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7fTtyZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKHQsZSxpLnZpYSl9fSx7a2V5OlwiX2dldERpc3RhbmNlVG9FZGdlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuLHIpe3ZhciBzPWFyZ3VtZW50cy5sZW5ndGg+NiYmdm9pZCAwIT09YXJndW1lbnRzWzZdP2FyZ3VtZW50c1s2XTp0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO3JldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZSh0LGUsaSxvLG4scixzKX19LHtrZXk6XCJnZXRQb2ludFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpLGk9dCxvPU1hdGgucG93KDEtaSwyKSp0aGlzLmZyb21Qb2ludC54KzIqaSooMS1pKSplLngrTWF0aC5wb3coaSwyKSp0aGlzLnRvUG9pbnQueCxuPU1hdGgucG93KDEtaSwyKSp0aGlzLmZyb21Qb2ludC55KzIqaSooMS1pKSplLnkrTWF0aC5wb3coaSwyKSp0aGlzLnRvUG9pbnQueTtyZXR1cm57eDpvLHk6bn19fV0pLGl9KFZjKTtmdW5jdGlvbiBHYyh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fWZ1bmN0aW9uIEtjKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyICRjPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9S2MoaSk7ZnVuY3Rpb24gaSh0LG8sbil7cmV0dXJuIFBvKHRoaXMsaSksZS5jYWxsKHRoaXMsdCxvLG4pfXJldHVybiBJbyhpLFt7a2V5OlwiX2xpbmVcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dmFyIG89aVswXSxuPWlbMV07dGhpcy5fYmV6aWVyQ3VydmUodCxlLG8sbil9fSx7a2V5OlwiX2dldFZpYUNvb3JkaW5hdGVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlLGksbyxuPXRoaXMuZnJvbS54LXRoaXMudG8ueCxyPXRoaXMuZnJvbS55LXRoaXMudG8ueSxzPXRoaXMub3B0aW9ucy5zbW9vdGgucm91bmRuZXNzO3JldHVybihNYXRoLmFicyhuKT5NYXRoLmFicyhyKXx8ITA9PT10aGlzLm9wdGlvbnMuc21vb3RoLmZvcmNlRGlyZWN0aW9ufHxcImhvcml6b250YWxcIj09PXRoaXMub3B0aW9ucy5zbW9vdGguZm9yY2VEaXJlY3Rpb24pJiZcInZlcnRpY2FsXCIhPT10aGlzLm9wdGlvbnMuc21vb3RoLmZvcmNlRGlyZWN0aW9uPyhlPXRoaXMuZnJvbS55LG89dGhpcy50by55LHQ9dGhpcy5mcm9tLngtcypuLGk9dGhpcy50by54K3Mqbik6KGU9dGhpcy5mcm9tLnktcypyLG89dGhpcy50by55K3Mqcix0PXRoaXMuZnJvbS54LGk9dGhpcy50by54KSxbe3g6dCx5OmV9LHt4OmkseTpvfV19fSx7a2V5OlwiZ2V0VmlhTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCl9fSx7a2V5OlwiX2ZpbmRCb3JkZXJQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcih0LGUpfX0se2tleTpcIl9nZXREaXN0YW5jZVRvRWRnZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXt2YXIgcz1hcmd1bWVudHMubGVuZ3RoPjYmJnZvaWQgMCE9PWFyZ3VtZW50c1s2XT9hcmd1bWVudHNbNl06dGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKSxhPWFuKHMsMiksaD1hWzBdLGQ9YVsxXTtyZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UyKHQsZSxpLG8sbixyLGgsZCl9fSx7a2V5OlwiZ2V0UG9pbnRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKSxpPWFuKGUsMiksbz1pWzBdLG49aVsxXSxyPXQscz1bTWF0aC5wb3coMS1yLDMpLDMqcipNYXRoLnBvdygxLXIsMiksMypNYXRoLnBvdyhyLDIpKigxLXIpLE1hdGgucG93KHIsMyldLGE9c1swXSp0aGlzLmZyb21Qb2ludC54K3NbMV0qby54K3NbMl0qbi54K3NbM10qdGhpcy50b1BvaW50LngsaD1zWzBdKnRoaXMuZnJvbVBvaW50Lnkrc1sxXSpvLnkrc1syXSpuLnkrc1szXSp0aGlzLnRvUG9pbnQueTtyZXR1cm57eDphLHk6aH19fV0pLGl9KGZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9R2MoaSk7ZnVuY3Rpb24gaSh0LG8sbil7cmV0dXJuIFBvKHRoaXMsaSksZS5jYWxsKHRoaXMsdCxvLG4pfXJldHVybiBJbyhpLFt7a2V5OlwiX2dldERpc3RhbmNlVG9CZXppZXJFZGdlMlwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyLHMsYSl7Zm9yKHZhciBoPTFlOSxkPXQsbD1lLGM9WzAsMCwwLDBdLHU9MTt1PDEwO3UrKyl7dmFyIGY9LjEqdTtjWzBdPU1hdGgucG93KDEtZiwzKSxjWzFdPTMqZipNYXRoLnBvdygxLWYsMiksY1syXT0zKk1hdGgucG93KGYsMikqKDEtZiksY1szXT1NYXRoLnBvdyhmLDMpO3ZhciBwPWNbMF0qdCtjWzFdKnMueCtjWzJdKmEueCtjWzNdKmksdj1jWzBdKmUrY1sxXSpzLnkrY1syXSphLnkrY1szXSpvO2lmKHU+MCl7dmFyIGc9dGhpcy5fZ2V0RGlzdGFuY2VUb0xpbmUoZCxsLHAsdixuLHIpO2g9ZzxoP2c6aH1kPXAsbD12fXJldHVybiBofX1dKSxpfShWYykpO2Z1bmN0aW9uIFFjKHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIFpjPWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9UWMoaSk7ZnVuY3Rpb24gaSh0LG8sbil7cmV0dXJuIFBvKHRoaXMsaSksZS5jYWxsKHRoaXMsdCxvLG4pfXJldHVybiBJbyhpLFt7a2V5OlwiX2xpbmVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3QuYmVnaW5QYXRoKCksdC5tb3ZlVG8odGhpcy5mcm9tUG9pbnQueCx0aGlzLmZyb21Qb2ludC55KSx0LmxpbmVUbyh0aGlzLnRvUG9pbnQueCx0aGlzLnRvUG9pbnQueSksdGhpcy5lbmFibGVTaGFkb3codCxlKSx0LnN0cm9rZSgpLHRoaXMuZGlzYWJsZVNoYWRvdyh0LGUpfX0se2tleTpcImdldFZpYU5vZGVcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJnZXRQb2ludFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybnt4OigxLXQpKnRoaXMuZnJvbVBvaW50LngrdCp0aGlzLnRvUG9pbnQueCx5OigxLXQpKnRoaXMuZnJvbVBvaW50LnkrdCp0aGlzLnRvUG9pbnQueX19fSx7a2V5OlwiX2ZpbmRCb3JkZXJQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9dGhpcy50byxvPXRoaXMuZnJvbTt0LmlkPT09dGhpcy5mcm9tLmlkJiYoaT10aGlzLmZyb20sbz10aGlzLnRvKTt2YXIgbj1NYXRoLmF0YW4yKGkueS1vLnksaS54LW8ueCkscj1pLngtby54LHM9aS55LW8ueSxhPU1hdGguc3FydChyKnIrcypzKSxoPShhLXQuZGlzdGFuY2VUb0JvcmRlcihlLG4pKS9hO3JldHVybnt4OigxLWgpKm8ueCtoKmkueCx5OigxLWgpKm8ueStoKmkueSx0OjB9fX0se2tleTpcIl9nZXREaXN0YW5jZVRvRWRnZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbixyKXtyZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0xpbmUodCxlLGksbyxuLHIpfX1dKSxpfShqYyksSmM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsaSxvLG4scil7aWYoUG8odGhpcyx0KSx2b2lkIDA9PT1pKXRocm93IG5ldyBFcnJvcihcIk5vIGJvZHkgcHJvdmlkZWRcIik7dGhpcy5vcHRpb25zPXZoKG4pLHRoaXMuZ2xvYmFsT3B0aW9ucz1uLHRoaXMuZGVmYXVsdE9wdGlvbnM9cix0aGlzLmJvZHk9aSx0aGlzLmltYWdlbGlzdD1vLHRoaXMuaWQ9dm9pZCAwLHRoaXMuZnJvbUlkPXZvaWQgMCx0aGlzLnRvSWQ9dm9pZCAwLHRoaXMuc2VsZWN0ZWQ9ITEsdGhpcy5ob3Zlcj0hMSx0aGlzLmxhYmVsRGlydHk9ITAsdGhpcy5iYXNlV2lkdGg9dGhpcy5vcHRpb25zLndpZHRoLHRoaXMuYmFzZUZvbnRTaXplPXRoaXMub3B0aW9ucy5mb250LnNpemUsdGhpcy5mcm9tPXZvaWQgMCx0aGlzLnRvPXZvaWQgMCx0aGlzLmVkZ2VUeXBlPXZvaWQgMCx0aGlzLmNvbm5lY3RlZD0hMSx0aGlzLmxhYmVsTW9kdWxlPW5ldyBsbCh0aGlzLmJvZHksdGhpcy5vcHRpb25zLCEwKSx0aGlzLnNldE9wdGlvbnMoZSl9cmV0dXJuIElvKHQsW3trZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoZSl7dmFyIGk9dm9pZCAwIT09ZS5waHlzaWNzJiZ0aGlzLm9wdGlvbnMucGh5c2ljcyE9PWUucGh5c2ljc3x8dm9pZCAwIT09ZS5oaWRkZW4mJih0aGlzLm9wdGlvbnMuaGlkZGVufHwhMSkhPT0oZS5oaWRkZW58fCExKXx8dm9pZCAwIT09ZS5mcm9tJiZ0aGlzLm9wdGlvbnMuZnJvbSE9PWUuZnJvbXx8dm9pZCAwIT09ZS50byYmdGhpcy5vcHRpb25zLnRvIT09ZS50bzt0LnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsZSwhMCx0aGlzLmdsb2JhbE9wdGlvbnMpLHZvaWQgMCE9PWUuaWQmJih0aGlzLmlkPWUuaWQpLHZvaWQgMCE9PWUuZnJvbSYmKHRoaXMuZnJvbUlkPWUuZnJvbSksdm9pZCAwIT09ZS50byYmKHRoaXMudG9JZD1lLnRvKSx2b2lkIDAhPT1lLnRpdGxlJiYodGhpcy50aXRsZT1lLnRpdGxlKSx2b2lkIDAhPT1lLnZhbHVlJiYoZS52YWx1ZT1ZZChlLnZhbHVlKSk7dmFyIG89W2UsdGhpcy5vcHRpb25zLHRoaXMuZGVmYXVsdE9wdGlvbnNdO3JldHVybiB0aGlzLmNob29zZXI9UWQoXCJlZGdlXCIsbyksdGhpcy51cGRhdGVMYWJlbE1vZHVsZShlKSxpPXRoaXMudXBkYXRlRWRnZVR5cGUoKXx8aSx0aGlzLl9zZXRJbnRlcmFjdGlvbldpZHRocygpLHRoaXMuY29ubmVjdCgpLGl9fX0se2tleTpcImdldEZvcm1hdHRpbmdWYWx1ZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PSEwPT09dGhpcy5vcHRpb25zLmFycm93cy50b3x8ITA9PT10aGlzLm9wdGlvbnMuYXJyb3dzLnRvLmVuYWJsZWQsZT0hMD09PXRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbXx8ITA9PT10aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uZW5hYmxlZCxpPSEwPT09dGhpcy5vcHRpb25zLmFycm93cy5taWRkbGV8fCEwPT09dGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuZW5hYmxlZCxvPXRoaXMub3B0aW9ucy5jb2xvci5pbmhlcml0LG49e3RvQXJyb3c6dCx0b0Fycm93U2NhbGU6dGhpcy5vcHRpb25zLmFycm93cy50by5zY2FsZUZhY3Rvcix0b0Fycm93VHlwZTp0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLnR5cGUsdG9BcnJvd1NyYzp0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLnNyYyx0b0Fycm93SW1hZ2VXaWR0aDp0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLmltYWdlV2lkdGgsdG9BcnJvd0ltYWdlSGVpZ2h0OnRoaXMub3B0aW9ucy5hcnJvd3MudG8uaW1hZ2VIZWlnaHQsbWlkZGxlQXJyb3c6aSxtaWRkbGVBcnJvd1NjYWxlOnRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLnNjYWxlRmFjdG9yLG1pZGRsZUFycm93VHlwZTp0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS50eXBlLG1pZGRsZUFycm93U3JjOnRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLnNyYyxtaWRkbGVBcnJvd0ltYWdlV2lkdGg6dGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuaW1hZ2VXaWR0aCxtaWRkbGVBcnJvd0ltYWdlSGVpZ2h0OnRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLmltYWdlSGVpZ2h0LGZyb21BcnJvdzplLGZyb21BcnJvd1NjYWxlOnRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS5zY2FsZUZhY3Rvcixmcm9tQXJyb3dUeXBlOnRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS50eXBlLGZyb21BcnJvd1NyYzp0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uc3JjLGZyb21BcnJvd0ltYWdlV2lkdGg6dGhpcy5vcHRpb25zLmFycm93cy5mcm9tLmltYWdlV2lkdGgsZnJvbUFycm93SW1hZ2VIZWlnaHQ6dGhpcy5vcHRpb25zLmFycm93cy5mcm9tLmltYWdlSGVpZ2h0LGFycm93U3RyaWtldGhyb3VnaDp0aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoLGNvbG9yOm8/dm9pZCAwOnRoaXMub3B0aW9ucy5jb2xvci5jb2xvcixpbmhlcml0c0NvbG9yOm8sb3BhY2l0eTp0aGlzLm9wdGlvbnMuY29sb3Iub3BhY2l0eSxoaWRkZW46dGhpcy5vcHRpb25zLmhpZGRlbixsZW5ndGg6dGhpcy5vcHRpb25zLmxlbmd0aCxzaGFkb3c6dGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkLHNoYWRvd0NvbG9yOnRoaXMub3B0aW9ucy5zaGFkb3cuY29sb3Isc2hhZG93U2l6ZTp0aGlzLm9wdGlvbnMuc2hhZG93LnNpemUsc2hhZG93WDp0aGlzLm9wdGlvbnMuc2hhZG93Lngsc2hhZG93WTp0aGlzLm9wdGlvbnMuc2hhZG93LnksZGFzaGVzOnRoaXMub3B0aW9ucy5kYXNoZXMsd2lkdGg6dGhpcy5vcHRpb25zLndpZHRoLGJhY2tncm91bmQ6dGhpcy5vcHRpb25zLmJhY2tncm91bmQuZW5hYmxlZCxiYWNrZ3JvdW5kQ29sb3I6dGhpcy5vcHRpb25zLmJhY2tncm91bmQuY29sb3IsYmFja2dyb3VuZFNpemU6dGhpcy5vcHRpb25zLmJhY2tncm91bmQuc2l6ZSxiYWNrZ3JvdW5kRGFzaGVzOnRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kLmRhc2hlc307aWYodGhpcy5zZWxlY3RlZHx8dGhpcy5ob3ZlcilpZighMD09PXRoaXMuY2hvb3Nlcil7aWYodGhpcy5zZWxlY3RlZCl7dmFyIHI9dGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoO1wiZnVuY3Rpb25cIj09dHlwZW9mIHI/bi53aWR0aD1yKG4ud2lkdGgpOlwibnVtYmVyXCI9PXR5cGVvZiByJiYobi53aWR0aCs9ciksbi53aWR0aD1NYXRoLm1heChuLndpZHRoLC4zL3RoaXMuYm9keS52aWV3LnNjYWxlKSxuLmNvbG9yPXRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQsbi5zaGFkb3c9dGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkfWVsc2UgaWYodGhpcy5ob3Zlcil7dmFyIHM9dGhpcy5vcHRpb25zLmhvdmVyV2lkdGg7XCJmdW5jdGlvblwiPT10eXBlb2Ygcz9uLndpZHRoPXMobi53aWR0aCk6XCJudW1iZXJcIj09dHlwZW9mIHMmJihuLndpZHRoKz1zKSxuLndpZHRoPU1hdGgubWF4KG4ud2lkdGgsLjMvdGhpcy5ib2R5LnZpZXcuc2NhbGUpLG4uY29sb3I9dGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLG4uc2hhZG93PXRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZH19ZWxzZVwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuY2hvb3NlciYmKHRoaXMuY2hvb3NlcihuLHRoaXMub3B0aW9ucy5pZCx0aGlzLnNlbGVjdGVkLHRoaXMuaG92ZXIpLHZvaWQgMCE9PW4uY29sb3ImJihuLmluaGVyaXRzQ29sb3I9ITEpLCExPT09bi5zaGFkb3cmJihuLnNoYWRvd0NvbG9yPT09dGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvciYmbi5zaGFkb3dTaXplPT09dGhpcy5vcHRpb25zLnNoYWRvdy5zaXplJiZuLnNoYWRvd1g9PT10aGlzLm9wdGlvbnMuc2hhZG93LngmJm4uc2hhZG93WT09PXRoaXMub3B0aW9ucy5zaGFkb3cueXx8KG4uc2hhZG93PSEwKSkpO2Vsc2Ugbi5zaGFkb3c9dGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkLG4ud2lkdGg9TWF0aC5tYXgobi53aWR0aCwuMy90aGlzLmJvZHkudmlldy5zY2FsZSk7cmV0dXJuIG59fSx7a2V5OlwidXBkYXRlTGFiZWxNb2R1bGVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1bdCx0aGlzLm9wdGlvbnMsdGhpcy5nbG9iYWxPcHRpb25zLHRoaXMuZGVmYXVsdE9wdGlvbnNdO3RoaXMubGFiZWxNb2R1bGUudXBkYXRlKHRoaXMub3B0aW9ucyxlKSx2b2lkIDAhPT10aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplJiYodGhpcy5iYXNlRm9udFNpemU9dGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZSl9fSx7a2V5OlwidXBkYXRlRWRnZVR5cGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMub3B0aW9ucy5zbW9vdGgsZT0hMSxpPSEwO3JldHVybiB2b2lkIDAhPT10aGlzLmVkZ2VUeXBlJiYoKHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBVYyYmITA9PT10LmVuYWJsZWQmJlwiZHluYW1pY1wiPT09dC50eXBlfHx0aGlzLmVkZ2VUeXBlIGluc3RhbmNlb2YgJGMmJiEwPT09dC5lbmFibGVkJiZcImN1YmljQmV6aWVyXCI9PT10LnR5cGV8fHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBYYyYmITA9PT10LmVuYWJsZWQmJlwiZHluYW1pY1wiIT09dC50eXBlJiZcImN1YmljQmV6aWVyXCIhPT10LnR5cGV8fHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBaYyYmITE9PT10LnR5cGUuZW5hYmxlZCkmJihpPSExKSwhMD09PWkmJihlPXRoaXMuY2xlYW51cCgpKSksITA9PT1pPyEwPT09dC5lbmFibGVkP1wiZHluYW1pY1wiPT09dC50eXBlPyhlPSEwLHRoaXMuZWRnZVR5cGU9bmV3IFVjKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSkpOlwiY3ViaWNCZXppZXJcIj09PXQudHlwZT90aGlzLmVkZ2VUeXBlPW5ldyAkYyh0aGlzLm9wdGlvbnMsdGhpcy5ib2R5LHRoaXMubGFiZWxNb2R1bGUpOnRoaXMuZWRnZVR5cGU9bmV3IFhjKHRoaXMub3B0aW9ucyx0aGlzLmJvZHksdGhpcy5sYWJlbE1vZHVsZSk6dGhpcy5lZGdlVHlwZT1uZXcgWmModGhpcy5vcHRpb25zLHRoaXMuYm9keSx0aGlzLmxhYmVsTW9kdWxlKTp0aGlzLmVkZ2VUeXBlLnNldE9wdGlvbnModGhpcy5vcHRpb25zKSxlfX0se2tleTpcImNvbm5lY3RcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZGlzY29ubmVjdCgpLHRoaXMuZnJvbT10aGlzLmJvZHkubm9kZXNbdGhpcy5mcm9tSWRdfHx2b2lkIDAsdGhpcy50bz10aGlzLmJvZHkubm9kZXNbdGhpcy50b0lkXXx8dm9pZCAwLHRoaXMuY29ubmVjdGVkPXZvaWQgMCE9PXRoaXMuZnJvbSYmdm9pZCAwIT09dGhpcy50bywhMD09PXRoaXMuY29ubmVjdGVkPyh0aGlzLmZyb20uYXR0YWNoRWRnZSh0aGlzKSx0aGlzLnRvLmF0dGFjaEVkZ2UodGhpcykpOih0aGlzLmZyb20mJnRoaXMuZnJvbS5kZXRhY2hFZGdlKHRoaXMpLHRoaXMudG8mJnRoaXMudG8uZGV0YWNoRWRnZSh0aGlzKSksdGhpcy5lZGdlVHlwZS5jb25uZWN0KCl9fSx7a2V5OlwiZGlzY29ubmVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5mcm9tJiYodGhpcy5mcm9tLmRldGFjaEVkZ2UodGhpcyksdGhpcy5mcm9tPXZvaWQgMCksdGhpcy50byYmKHRoaXMudG8uZGV0YWNoRWRnZSh0aGlzKSx0aGlzLnRvPXZvaWQgMCksdGhpcy5jb25uZWN0ZWQ9ITF9fSx7a2V5OlwiZ2V0VGl0bGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRpdGxlfX0se2tleTpcImlzU2VsZWN0ZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbGVjdGVkfX0se2tleTpcImdldFZhbHVlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlfX0se2tleTpcInNldFZhbHVlUmFuZ2VcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7aWYodm9pZCAwIT09dGhpcy5vcHRpb25zLnZhbHVlKXt2YXIgbz10aGlzLm9wdGlvbnMuc2NhbGluZy5jdXN0b21TY2FsaW5nRnVuY3Rpb24odCxlLGksdGhpcy5vcHRpb25zLnZhbHVlKSxuPXRoaXMub3B0aW9ucy5zY2FsaW5nLm1heC10aGlzLm9wdGlvbnMuc2NhbGluZy5taW47aWYoITA9PT10aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5lbmFibGVkKXt2YXIgcj10aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXgtdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluO3RoaXMub3B0aW9ucy5mb250LnNpemU9dGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluK28qcn10aGlzLm9wdGlvbnMud2lkdGg9dGhpcy5vcHRpb25zLnNjYWxpbmcubWluK28qbn1lbHNlIHRoaXMub3B0aW9ucy53aWR0aD10aGlzLmJhc2VXaWR0aCx0aGlzLm9wdGlvbnMuZm9udC5zaXplPXRoaXMuYmFzZUZvbnRTaXplO3RoaXMuX3NldEludGVyYWN0aW9uV2lkdGhzKCksdGhpcy51cGRhdGVMYWJlbE1vZHVsZSgpfX0se2tleTpcIl9zZXRJbnRlcmFjdGlvbldpZHRoc1wiLHZhbHVlOmZ1bmN0aW9uKCl7XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5vcHRpb25zLmhvdmVyV2lkdGg/dGhpcy5lZGdlVHlwZS5ob3ZlcldpZHRoPXRoaXMub3B0aW9ucy5ob3ZlcldpZHRoKHRoaXMub3B0aW9ucy53aWR0aCk6dGhpcy5lZGdlVHlwZS5ob3ZlcldpZHRoPXRoaXMub3B0aW9ucy5ob3ZlcldpZHRoK3RoaXMub3B0aW9ucy53aWR0aCxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuc2VsZWN0aW9uV2lkdGg/dGhpcy5lZGdlVHlwZS5zZWxlY3Rpb25XaWR0aD10aGlzLm9wdGlvbnMuc2VsZWN0aW9uV2lkdGgodGhpcy5vcHRpb25zLndpZHRoKTp0aGlzLmVkZ2VUeXBlLnNlbGVjdGlvbldpZHRoPXRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aCt0aGlzLm9wdGlvbnMud2lkdGh9fSx7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpO2lmKCFlLmhpZGRlbil7dmFyIGk9dGhpcy5lZGdlVHlwZS5nZXRWaWFOb2RlKCk7dGhpcy5lZGdlVHlwZS5kcmF3TGluZSh0LGUsdGhpcy5zZWxlY3RlZCx0aGlzLmhvdmVyLGkpLHRoaXMuZHJhd0xhYmVsKHQsaSl9fX0se2tleTpcImRyYXdBcnJvd3NcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldEZvcm1hdHRpbmdWYWx1ZXMoKTtpZighZS5oaWRkZW4pe3ZhciBpPXRoaXMuZWRnZVR5cGUuZ2V0VmlhTm9kZSgpLG89e307dGhpcy5lZGdlVHlwZS5mcm9tUG9pbnQ9dGhpcy5lZGdlVHlwZS5mcm9tLHRoaXMuZWRnZVR5cGUudG9Qb2ludD10aGlzLmVkZ2VUeXBlLnRvLGUuZnJvbUFycm93JiYoby5mcm9tPXRoaXMuZWRnZVR5cGUuZ2V0QXJyb3dEYXRhKHQsXCJmcm9tXCIsaSx0aGlzLnNlbGVjdGVkLHRoaXMuaG92ZXIsZSksITE9PT1lLmFycm93U3RyaWtldGhyb3VnaCYmKHRoaXMuZWRnZVR5cGUuZnJvbVBvaW50PW8uZnJvbS5jb3JlKSxlLmZyb21BcnJvd1NyYyYmKG8uZnJvbS5pbWFnZT10aGlzLmltYWdlbGlzdC5sb2FkKGUuZnJvbUFycm93U3JjKSksZS5mcm9tQXJyb3dJbWFnZVdpZHRoJiYoby5mcm9tLmltYWdlV2lkdGg9ZS5mcm9tQXJyb3dJbWFnZVdpZHRoKSxlLmZyb21BcnJvd0ltYWdlSGVpZ2h0JiYoby5mcm9tLmltYWdlSGVpZ2h0PWUuZnJvbUFycm93SW1hZ2VIZWlnaHQpKSxlLnRvQXJyb3cmJihvLnRvPXRoaXMuZWRnZVR5cGUuZ2V0QXJyb3dEYXRhKHQsXCJ0b1wiLGksdGhpcy5zZWxlY3RlZCx0aGlzLmhvdmVyLGUpLCExPT09ZS5hcnJvd1N0cmlrZXRocm91Z2gmJih0aGlzLmVkZ2VUeXBlLnRvUG9pbnQ9by50by5jb3JlKSxlLnRvQXJyb3dTcmMmJihvLnRvLmltYWdlPXRoaXMuaW1hZ2VsaXN0LmxvYWQoZS50b0Fycm93U3JjKSksZS50b0Fycm93SW1hZ2VXaWR0aCYmKG8udG8uaW1hZ2VXaWR0aD1lLnRvQXJyb3dJbWFnZVdpZHRoKSxlLnRvQXJyb3dJbWFnZUhlaWdodCYmKG8udG8uaW1hZ2VIZWlnaHQ9ZS50b0Fycm93SW1hZ2VIZWlnaHQpKSxlLm1pZGRsZUFycm93JiYoby5taWRkbGU9dGhpcy5lZGdlVHlwZS5nZXRBcnJvd0RhdGEodCxcIm1pZGRsZVwiLGksdGhpcy5zZWxlY3RlZCx0aGlzLmhvdmVyLGUpLGUubWlkZGxlQXJyb3dTcmMmJihvLm1pZGRsZS5pbWFnZT10aGlzLmltYWdlbGlzdC5sb2FkKGUubWlkZGxlQXJyb3dTcmMpKSxlLm1pZGRsZUFycm93SW1hZ2VXaWR0aCYmKG8ubWlkZGxlLmltYWdlV2lkdGg9ZS5taWRkbGVBcnJvd0ltYWdlV2lkdGgpLGUubWlkZGxlQXJyb3dJbWFnZUhlaWdodCYmKG8ubWlkZGxlLmltYWdlSGVpZ2h0PWUubWlkZGxlQXJyb3dJbWFnZUhlaWdodCkpLGUuZnJvbUFycm93JiZ0aGlzLmVkZ2VUeXBlLmRyYXdBcnJvd0hlYWQodCxlLHRoaXMuc2VsZWN0ZWQsdGhpcy5ob3ZlcixvLmZyb20pLGUubWlkZGxlQXJyb3cmJnRoaXMuZWRnZVR5cGUuZHJhd0Fycm93SGVhZCh0LGUsdGhpcy5zZWxlY3RlZCx0aGlzLmhvdmVyLG8ubWlkZGxlKSxlLnRvQXJyb3cmJnRoaXMuZWRnZVR5cGUuZHJhd0Fycm93SGVhZCh0LGUsdGhpcy5zZWxlY3RlZCx0aGlzLmhvdmVyLG8udG8pfX19LHtrZXk6XCJkcmF3TGFiZWxcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKHZvaWQgMCE9PXRoaXMub3B0aW9ucy5sYWJlbCl7dmFyIGksbz10aGlzLmZyb20sbj10aGlzLnRvO2lmKHRoaXMubGFiZWxNb2R1bGUuZGlmZmVyZW50U3RhdGUodGhpcy5zZWxlY3RlZCx0aGlzLmhvdmVyKSYmdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZSh0LHRoaXMuc2VsZWN0ZWQsdGhpcy5ob3Zlciksby5pZCE9bi5pZCl7dGhpcy5sYWJlbE1vZHVsZS5wb2ludFRvU2VsZj0hMSxpPXRoaXMuZWRnZVR5cGUuZ2V0UG9pbnQoLjUsZSksdC5zYXZlKCk7dmFyIHI9dGhpcy5fZ2V0Um90YXRpb24odCk7MCE9ci5hbmdsZSYmKHQudHJhbnNsYXRlKHIueCxyLnkpLHQucm90YXRlKHIuYW5nbGUpKSx0aGlzLmxhYmVsTW9kdWxlLmRyYXcodCxpLngsaS55LHRoaXMuc2VsZWN0ZWQsdGhpcy5ob3ZlciksdC5yZXN0b3JlKCl9ZWxzZXt0aGlzLmxhYmVsTW9kdWxlLnBvaW50VG9TZWxmPSEwO3ZhciBzPXRsKHQsdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUsdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2Uuc2l6ZSxvKTtpPXRoaXMuX3BvaW50T25DaXJjbGUocy54LHMueSx0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplLHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlKSx0aGlzLmxhYmVsTW9kdWxlLmRyYXcodCxpLngsaS55LHRoaXMuc2VsZWN0ZWQsdGhpcy5ob3Zlcil9fX19LHtrZXk6XCJnZXRJdGVtc09uUG9pbnRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1bXTtpZih0aGlzLmxhYmVsTW9kdWxlLnZpc2libGUoKSl7dmFyIGk9dGhpcy5fZ2V0Um90YXRpb24oKTtaZCh0aGlzLmxhYmVsTW9kdWxlLmdldFNpemUoKSx0LGkpJiZlLnB1c2goe2VkZ2VJZDp0aGlzLmlkLGxhYmVsSWQ6MH0pfXZhciBvPXtsZWZ0OnQueCx0b3A6dC55fTtyZXR1cm4gdGhpcy5pc092ZXJsYXBwaW5nV2l0aChvKSYmZS5wdXNoKHtlZGdlSWQ6dGhpcy5pZH0pLGV9fSx7a2V5OlwiaXNPdmVybGFwcGluZ1dpdGhcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih0aGlzLmNvbm5lY3RlZCl7dmFyIGU9dGhpcy5mcm9tLngsaT10aGlzLmZyb20ueSxvPXRoaXMudG8ueCxuPXRoaXMudG8ueSxyPXQubGVmdCxzPXQudG9wO3JldHVybiB0aGlzLmVkZ2VUeXBlLmdldERpc3RhbmNlVG9FZGdlKGUsaSxvLG4scixzKTwxMH1yZXR1cm4hMX19LHtrZXk6XCJfZ2V0Um90YXRpb25cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmVkZ2VUeXBlLmdldFZpYU5vZGUoKSxpPXRoaXMuZWRnZVR5cGUuZ2V0UG9pbnQoLjUsZSk7dm9pZCAwIT09dCYmdGhpcy5sYWJlbE1vZHVsZS5jYWxjdWxhdGVMYWJlbFNpemUodCx0aGlzLnNlbGVjdGVkLHRoaXMuaG92ZXIsaS54LGkueSk7dmFyIG89e3g6aS54LHk6dGhpcy5sYWJlbE1vZHVsZS5zaXplLnlMaW5lLGFuZ2xlOjB9O2lmKCF0aGlzLmxhYmVsTW9kdWxlLnZpc2libGUoKSlyZXR1cm4gbztpZihcImhvcml6b250YWxcIj09PXRoaXMub3B0aW9ucy5mb250LmFsaWduKXJldHVybiBvO3ZhciBuPXRoaXMuZnJvbS55LXRoaXMudG8ueSxyPXRoaXMuZnJvbS54LXRoaXMudG8ueCxzPU1hdGguYXRhbjIobixyKTtyZXR1cm4oczwtMSYmcjwwfHxzPjAmJnI8MCkmJihzKz1NYXRoLlBJKSxvLmFuZ2xlPXMsb319LHtrZXk6XCJfcG9pbnRPbkNpcmNsZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8pe3JldHVybnt4OnQraSpNYXRoLmNvcyhvKSx5OmUtaSpNYXRoLnNpbihvKX19fSx7a2V5Olwic2VsZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNlbGVjdGVkPSEwfX0se2tleTpcInVuc2VsZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNlbGVjdGVkPSExfX0se2tleTpcImNsZWFudXBcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VUeXBlLmNsZWFudXAoKX19LHtrZXk6XCJyZW1vdmVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY2xlYW51cCgpLHRoaXMuZGlzY29ubmVjdCgpLGRlbGV0ZSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5pZF19fSx7a2V5OlwiZW5kUG9pbnRzVmFsaWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB2b2lkIDAhPT10aGlzLmJvZHkubm9kZXNbdGhpcy5mcm9tSWRdJiZ2b2lkIDAhPT10aGlzLmJvZHkubm9kZXNbdGhpcy50b0lkXX19XSxbe2tleTpcInBhcnNlT3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXSxvPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTp7fSxuPWFyZ3VtZW50cy5sZW5ndGg+NCYmdm9pZCAwIT09YXJndW1lbnRzWzRdJiZhcmd1bWVudHNbNF0scj1bXCJlbmRQb2ludE9mZnNldFwiLFwiYXJyb3dTdHJpa2V0aHJvdWdoXCIsXCJpZFwiLFwiZnJvbVwiLFwiaGlkZGVuXCIsXCJob3ZlcldpZHRoXCIsXCJsYWJlbEhpZ2hsaWdodEJvbGRcIixcImxlbmd0aFwiLFwibGluZVwiLFwib3BhY2l0eVwiLFwicGh5c2ljc1wiLFwic2NhbGluZ1wiLFwic2VsZWN0aW9uV2lkdGhcIixcInNlbGZSZWZlcmVuY2VTaXplXCIsXCJzZWxmUmVmZXJlbmNlXCIsXCJ0b1wiLFwidGl0bGVcIixcInZhbHVlXCIsXCJ3aWR0aFwiLFwiZm9udFwiLFwiY2hvc2VuXCIsXCJ3aWR0aENvbnN0cmFpbnRcIl07aWYoWmEocix0LGUsaSksdm9pZCAwIT09ZS5lbmRQb2ludE9mZnNldCYmdm9pZCAwIT09ZS5lbmRQb2ludE9mZnNldC5mcm9tJiYoQWQoZS5lbmRQb2ludE9mZnNldC5mcm9tKT90LmVuZFBvaW50T2Zmc2V0LmZyb209ZS5lbmRQb2ludE9mZnNldC5mcm9tOih0LmVuZFBvaW50T2Zmc2V0LmZyb209dm9pZCAwIT09by5lbmRQb2ludE9mZnNldC5mcm9tP28uZW5kUG9pbnRPZmZzZXQuZnJvbTowLGNvbnNvbGUuZXJyb3IoXCJlbmRQb2ludE9mZnNldC5mcm9tIGlzIG5vdCBhIHZhbGlkIG51bWJlclwiKSkpLHZvaWQgMCE9PWUuZW5kUG9pbnRPZmZzZXQmJnZvaWQgMCE9PWUuZW5kUG9pbnRPZmZzZXQudG8mJihBZChlLmVuZFBvaW50T2Zmc2V0LnRvKT90LmVuZFBvaW50T2Zmc2V0LnRvPWUuZW5kUG9pbnRPZmZzZXQudG86KHQuZW5kUG9pbnRPZmZzZXQudG89dm9pZCAwIT09by5lbmRQb2ludE9mZnNldC50bz9vLmVuZFBvaW50T2Zmc2V0LnRvOjAsY29uc29sZS5lcnJvcihcImVuZFBvaW50T2Zmc2V0LnRvIGlzIG5vdCBhIHZhbGlkIG51bWJlclwiKSkpLEpkKGUubGFiZWwpP3QubGFiZWw9ZS5sYWJlbDpKZCh0LmxhYmVsKXx8KHQubGFiZWw9dm9pZCAwKSxnaCh0LGUsXCJzbW9vdGhcIixvKSxnaCh0LGUsXCJzaGFkb3dcIixvKSxnaCh0LGUsXCJiYWNrZ3JvdW5kXCIsbyksdm9pZCAwIT09ZS5kYXNoZXMmJm51bGwhPT1lLmRhc2hlcz90LmRhc2hlcz1lLmRhc2hlczohMD09PWkmJm51bGw9PT1lLmRhc2hlcyYmKHQuZGFzaGVzPUlyKG8uZGFzaGVzKSksdm9pZCAwIT09ZS5zY2FsaW5nJiZudWxsIT09ZS5zY2FsaW5nPyh2b2lkIDAhPT1lLnNjYWxpbmcubWluJiYodC5zY2FsaW5nLm1pbj1lLnNjYWxpbmcubWluKSx2b2lkIDAhPT1lLnNjYWxpbmcubWF4JiYodC5zY2FsaW5nLm1heD1lLnNjYWxpbmcubWF4KSxnaCh0LnNjYWxpbmcsZS5zY2FsaW5nLFwibGFiZWxcIixvLnNjYWxpbmcpKTohMD09PWkmJm51bGw9PT1lLnNjYWxpbmcmJih0LnNjYWxpbmc9SXIoby5zY2FsaW5nKSksdm9pZCAwIT09ZS5hcnJvd3MmJm51bGwhPT1lLmFycm93cylpZihcInN0cmluZ1wiPT10eXBlb2YgZS5hcnJvd3Mpe3ZhciBzPWUuYXJyb3dzLnRvTG93ZXJDYXNlKCk7dC5hcnJvd3MudG8uZW5hYmxlZD0tMSE9TXIocykuY2FsbChzLFwidG9cIiksdC5hcnJvd3MubWlkZGxlLmVuYWJsZWQ9LTEhPU1yKHMpLmNhbGwocyxcIm1pZGRsZVwiKSx0LmFycm93cy5mcm9tLmVuYWJsZWQ9LTEhPU1yKHMpLmNhbGwocyxcImZyb21cIil9ZWxzZXtpZihcIm9iamVjdFwiIT09ZG4oZS5hcnJvd3MpKXRocm93IG5ldyBFcnJvcihcIlRoZSBhcnJvdyBuZXdPcHRpb25zIGNhbiBvbmx5IGJlIGFuIG9iamVjdCBvciBhIHN0cmluZy4gUmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24uIFlvdSB1c2VkOlwiK0xyKGUuYXJyb3dzKSk7Z2godC5hcnJvd3MsZS5hcnJvd3MsXCJ0b1wiLG8uYXJyb3dzKSxnaCh0LmFycm93cyxlLmFycm93cyxcIm1pZGRsZVwiLG8uYXJyb3dzKSxnaCh0LmFycm93cyxlLmFycm93cyxcImZyb21cIixvLmFycm93cyl9ZWxzZSEwPT09aSYmbnVsbD09PWUuYXJyb3dzJiYodC5hcnJvd3M9SXIoby5hcnJvd3MpKTtpZih2b2lkIDAhPT1lLmNvbG9yJiZudWxsIT09ZS5jb2xvcil7dmFyIGE9R2EoZS5jb2xvcik/e2NvbG9yOmUuY29sb3IsaGlnaGxpZ2h0OmUuY29sb3IsaG92ZXI6ZS5jb2xvcixpbmhlcml0OiExLG9wYWNpdHk6MX06ZS5jb2xvcixoPXQuY29sb3I7aWYobil0aChoLG8uY29sb3IsITEsaSk7ZWxzZSBmb3IodmFyIGQgaW4gaClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaCxkKSYmZGVsZXRlIGhbZF07aWYoR2EoaCkpaC5jb2xvcj1oLGguaGlnaGxpZ2h0PWgsaC5ob3Zlcj1oLGguaW5oZXJpdD0hMSx2b2lkIDA9PT1hLm9wYWNpdHkmJihoLm9wYWNpdHk9MSk7ZWxzZXt2YXIgbD0hMTt2b2lkIDAhPT1hLmNvbG9yJiYoaC5jb2xvcj1hLmNvbG9yLGw9ITApLHZvaWQgMCE9PWEuaGlnaGxpZ2h0JiYoaC5oaWdobGlnaHQ9YS5oaWdobGlnaHQsbD0hMCksdm9pZCAwIT09YS5ob3ZlciYmKGguaG92ZXI9YS5ob3ZlcixsPSEwKSx2b2lkIDAhPT1hLmluaGVyaXQmJihoLmluaGVyaXQ9YS5pbmhlcml0KSx2b2lkIDAhPT1hLm9wYWNpdHkmJihoLm9wYWNpdHk9TWF0aC5taW4oMSxNYXRoLm1heCgwLGEub3BhY2l0eSkpKSwhMD09PWw/aC5pbmhlcml0PSExOnZvaWQgMD09PWguaW5oZXJpdCYmKGguaW5oZXJpdD1cImZyb21cIil9fWVsc2UhMD09PWkmJm51bGw9PT1lLmNvbG9yJiYodC5jb2xvcj12aChvLmNvbG9yKSk7ITA9PT1pJiZudWxsPT09ZS5mb250JiYodC5mb250PXZoKG8uZm9udCkpLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLFwic2VsZlJlZmVyZW5jZVNpemVcIikmJihjb25zb2xlLndhcm4oXCJUaGUgc2VsZlJlZmVyZW5jZVNpemUgcHJvcGVydHkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBzZWxmUmVmZXJlbmNlIHByb3BlcnR5IGluc3RlYWQuIFRoZSBzZWxmUmVmZXJlbmNlIGNhbiBiZSBzZXQgbGlrZSB0aGlzZSBzZWxmUmVmZXJlbmNlOntzaXplOjMwLCBhbmdsZTpNYXRoLlBJIC8gNH1cIiksdC5zZWxmUmVmZXJlbmNlLnNpemU9ZS5zZWxmUmVmZXJlbmNlU2l6ZSl9fV0pLHR9KCksdHU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsaSxvKXt2YXIgbixyPXRoaXM7UG8odGhpcyx0KSx0aGlzLmJvZHk9ZSx0aGlzLmltYWdlcz1pLHRoaXMuZ3JvdXBzPW8sdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVFZGdlPWJ0KG49dGhpcy5jcmVhdGUpLmNhbGwobix0aGlzKSx0aGlzLmVkZ2VzTGlzdGVuZXJzPXthZGQ6ZnVuY3Rpb24odCxlKXtyLmFkZChlLml0ZW1zKX0sdXBkYXRlOmZ1bmN0aW9uKHQsZSl7ci51cGRhdGUoZS5pdGVtcyl9LHJlbW92ZTpmdW5jdGlvbih0LGUpe3IucmVtb3ZlKGUuaXRlbXMpfX0sdGhpcy5vcHRpb25zPXt9LHRoaXMuZGVmYXVsdE9wdGlvbnM9e2Fycm93czp7dG86e2VuYWJsZWQ6ITEsc2NhbGVGYWN0b3I6MSx0eXBlOlwiYXJyb3dcIn0sbWlkZGxlOntlbmFibGVkOiExLHNjYWxlRmFjdG9yOjEsdHlwZTpcImFycm93XCJ9LGZyb206e2VuYWJsZWQ6ITEsc2NhbGVGYWN0b3I6MSx0eXBlOlwiYXJyb3dcIn19LGVuZFBvaW50T2Zmc2V0Ontmcm9tOjAsdG86MH0sYXJyb3dTdHJpa2V0aHJvdWdoOiEwLGNvbG9yOntjb2xvcjpcIiM4NDg0ODRcIixoaWdobGlnaHQ6XCIjODQ4NDg0XCIsaG92ZXI6XCIjODQ4NDg0XCIsaW5oZXJpdDpcImZyb21cIixvcGFjaXR5OjF9LGRhc2hlczohMSxmb250Ontjb2xvcjpcIiMzNDM0MzRcIixzaXplOjE0LGZhY2U6XCJhcmlhbFwiLGJhY2tncm91bmQ6XCJub25lXCIsc3Ryb2tlV2lkdGg6MixzdHJva2VDb2xvcjpcIiNmZmZmZmZcIixhbGlnbjpcImhvcml6b250YWxcIixtdWx0aTohMSx2YWRqdXN0OjAsYm9sZDp7bW9kOlwiYm9sZFwifSxib2xkaXRhbDp7bW9kOlwiYm9sZCBpdGFsaWNcIn0saXRhbDp7bW9kOlwiaXRhbGljXCJ9LG1vbm86e21vZDpcIlwiLHNpemU6MTUsZmFjZTpcImNvdXJpZXIgbmV3XCIsdmFkanVzdDoyfX0saGlkZGVuOiExLGhvdmVyV2lkdGg6MS41LGxhYmVsOnZvaWQgMCxsYWJlbEhpZ2hsaWdodEJvbGQ6ITAsbGVuZ3RoOnZvaWQgMCxwaHlzaWNzOiEwLHNjYWxpbmc6e21pbjoxLG1heDoxNSxsYWJlbDp7ZW5hYmxlZDohMCxtaW46MTQsbWF4OjMwLG1heFZpc2libGU6MzAsZHJhd1RocmVzaG9sZDo1fSxjdXN0b21TY2FsaW5nRnVuY3Rpb246ZnVuY3Rpb24odCxlLGksbyl7aWYoZT09PXQpcmV0dXJuLjU7dmFyIG49MS8oZS10KTtyZXR1cm4gTWF0aC5tYXgoMCwoby10KSpuKX19LHNlbGVjdGlvbldpZHRoOjEuNSxzZWxmUmVmZXJlbmNlOntzaXplOjIwLGFuZ2xlOk1hdGguUEkvNCxyZW5kZXJCZWhpbmRUaGVOb2RlOiEwfSxzaGFkb3c6e2VuYWJsZWQ6ITEsY29sb3I6XCJyZ2JhKDAsMCwwLDAuNSlcIixzaXplOjEwLHg6NSx5OjV9LGJhY2tncm91bmQ6e2VuYWJsZWQ6ITEsY29sb3I6XCJyZ2JhKDExMSwxMTEsMTExLDEpXCIsc2l6ZToxMCxkYXNoZXM6ITF9LHNtb290aDp7ZW5hYmxlZDohMCx0eXBlOlwiZHluYW1pY1wiLGZvcmNlRGlyZWN0aW9uOlwibm9uZVwiLHJvdW5kbmVzczouNX0sdGl0bGU6dm9pZCAwLHdpZHRoOjEsdmFsdWU6dm9pZCAwfSx0aCh0aGlzLm9wdGlvbnMsdGhpcy5kZWZhdWx0T3B0aW9ucyksdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKX1yZXR1cm4gSW8odCxbe2tleTpcImJpbmRFdmVudExpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZSxpPXRoaXM7dGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZm9yY2VEaXNhYmxlRHluYW1pY0N1cnZlc1wiLChmdW5jdGlvbih0KXt2YXIgZT0hKGFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdKXx8YXJndW1lbnRzWzFdO1wiZHluYW1pY1wiPT09dCYmKHQ9XCJjb250aW51b3VzXCIpO3ZhciBvPSExO2Zvcih2YXIgbiBpbiBpLmJvZHkuZWRnZXMpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGkuYm9keS5lZGdlcyxuKSl7dmFyIHI9aS5ib2R5LmVkZ2VzW25dLHM9aS5ib2R5LmRhdGEuZWRnZXMuZ2V0KG4pO2lmKG51bGwhPXMpe3ZhciBhPXMuc21vb3RoO3ZvaWQgMCE9PWEmJiEwPT09YS5lbmFibGVkJiZcImR5bmFtaWNcIj09PWEudHlwZSYmKHZvaWQgMD09PXQ/ci5zZXRPcHRpb25zKHtzbW9vdGg6ITF9KTpyLnNldE9wdGlvbnMoe3Ntb290aDp7dHlwZTp0fX0pLG89ITApfX0hMD09PWUmJiEwPT09byYmaS5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhVXBkYXRlZFwiLChmdW5jdGlvbigpe2kucmVjb25uZWN0RWRnZXMoKX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlZnJlc2hFZGdlc1wiLGJ0KHQ9dGhpcy5yZWZyZXNoKS5jYWxsKHQsdGhpcykpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVmcmVzaFwiLGJ0KGU9dGhpcy5yZWZyZXNoKS5jYWxsKGUsdGhpcykpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLChmdW5jdGlvbigpe25oKGkuZWRnZXNMaXN0ZW5lcnMsKGZ1bmN0aW9uKHQsZSl7aS5ib2R5LmRhdGEuZWRnZXMmJmkuYm9keS5kYXRhLmVkZ2VzLm9mZihlLHQpfSkpLGRlbGV0ZSBpLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2UsZGVsZXRlIGkuZWRnZXNMaXN0ZW5lcnMuYWRkLGRlbGV0ZSBpLmVkZ2VzTGlzdGVuZXJzLnVwZGF0ZSxkZWxldGUgaS5lZGdlc0xpc3RlbmVycy5yZW1vdmUsZGVsZXRlIGkuZWRnZXNMaXN0ZW5lcnN9KSl9fSx7a2V5Olwic2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMCE9PXQpe0pjLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsdCwhMCx0aGlzLmRlZmF1bHRPcHRpb25zLCEwKTt2YXIgZT0hMTtpZih2b2lkIDAhPT10LnNtb290aClmb3IodmFyIGkgaW4gdGhpcy5ib2R5LmVkZ2VzKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkuZWRnZXMsaSkmJihlPXRoaXMuYm9keS5lZGdlc1tpXS51cGRhdGVFZGdlVHlwZSgpfHxlKTtpZih2b2lkIDAhPT10LmZvbnQpZm9yKHZhciBvIGluIHRoaXMuYm9keS5lZGdlcylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5LmVkZ2VzLG8pJiZ0aGlzLmJvZHkuZWRnZXNbb10udXBkYXRlTGFiZWxNb2R1bGUoKTt2b2lkIDA9PT10LmhpZGRlbiYmdm9pZCAwPT09dC5waHlzaWNzJiYhMCE9PWV8fHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIil9fX0se2tleTpcInNldERhdGFcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgaT10aGlzLG89YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXSxuPXRoaXMuYm9keS5kYXRhLmVkZ2VzO2lmKGUuaXNEYXRhVmlld0xpa2UoXCJpZFwiLHQpKXRoaXMuYm9keS5kYXRhLmVkZ2VzPXQ7ZWxzZSBpZihnbih0KSl0aGlzLmJvZHkuZGF0YS5lZGdlcz1uZXcgZS5EYXRhU2V0LHRoaXMuYm9keS5kYXRhLmVkZ2VzLmFkZCh0KTtlbHNle2lmKHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5IG9yIERhdGFTZXQgZXhwZWN0ZWRcIik7dGhpcy5ib2R5LmRhdGEuZWRnZXM9bmV3IGUuRGF0YVNldH1pZihuJiZuaCh0aGlzLmVkZ2VzTGlzdGVuZXJzLChmdW5jdGlvbih0LGUpe24ub2ZmKGUsdCl9KSksdGhpcy5ib2R5LmVkZ2VzPXt9LHRoaXMuYm9keS5kYXRhLmVkZ2VzKXtuaCh0aGlzLmVkZ2VzTGlzdGVuZXJzLChmdW5jdGlvbih0LGUpe2kuYm9keS5kYXRhLmVkZ2VzLm9uKGUsdCl9KSk7dmFyIHI9dGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0SWRzKCk7dGhpcy5hZGQociwhMCl9dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dFwiKSwhMT09PW8mJnRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIil9fSx7a2V5OlwiYWRkXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV0saT10aGlzLmJvZHkuZWRnZXMsbz10aGlzLmJvZHkuZGF0YS5lZGdlcyxuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl0scz1pW3JdO3MmJnMuZGlzY29ubmVjdCgpO3ZhciBhPW8uZ2V0KHIse3Nob3dJbnRlcm5hbElkczohMH0pO2lbcl09dGhpcy5jcmVhdGUoYSl9dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dFwiKSwhMT09PWUmJnRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIil9fSx7a2V5OlwidXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuYm9keS5lZGdlcyxpPXRoaXMuYm9keS5kYXRhLmVkZ2VzLG89ITEsbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dLHM9aS5nZXQociksYT1lW3JdO3ZvaWQgMCE9PWE/KGEuZGlzY29ubmVjdCgpLG89YS5zZXRPcHRpb25zKHMpfHxvLGEuY29ubmVjdCgpKToodGhpcy5ib2R5LmVkZ2VzW3JdPXRoaXMuY3JlYXRlKHMpLG89ITApfSEwPT09bz8odGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dFwiKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpKTp0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFVcGRhdGVkXCIpfX0se2tleTpcInJlbW92ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV07aWYoMCE9PXQubGVuZ3RoKXt2YXIgaT10aGlzLmJvZHkuZWRnZXM7bmgodCwoZnVuY3Rpb24odCl7dmFyIGU9aVt0XTt2b2lkIDAhPT1lJiZlLnJlbW92ZSgpfSkpLGUmJnRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIil9fX0se2tleTpcInJlZnJlc2hcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7bmgodGhpcy5ib2R5LmVkZ2VzLChmdW5jdGlvbihlLGkpe3ZhciBvPXQuYm9keS5kYXRhLmVkZ2VzLmdldChpKTt2b2lkIDAhPT1vJiZlLnNldE9wdGlvbnMobyl9KSl9fSx7a2V5OlwiY3JlYXRlXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBKYyh0LHRoaXMuYm9keSx0aGlzLmltYWdlcyx0aGlzLm9wdGlvbnMsdGhpcy5kZWZhdWx0T3B0aW9ucyl9fSx7a2V5OlwicmVjb25uZWN0RWRnZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGU9dGhpcy5ib2R5Lm5vZGVzLGk9dGhpcy5ib2R5LmVkZ2VzO2Zvcih0IGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkmJihlW3RdLmVkZ2VzPVtdKTtmb3IodCBpbiBpKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLHQpKXt2YXIgbz1pW3RdO28uZnJvbT1udWxsLG8udG89bnVsbCxvLmNvbm5lY3QoKX19fSx7a2V5OlwiZ2V0Q29ubmVjdGVkTm9kZXNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1bXTtpZih2b2lkIDAhPT10aGlzLmJvZHkuZWRnZXNbdF0pe3ZhciBpPXRoaXMuYm9keS5lZGdlc1t0XTt2b2lkIDAhPT1pLmZyb21JZCYmZS5wdXNoKGkuZnJvbUlkKSx2b2lkIDAhPT1pLnRvSWQmJmUucHVzaChpLnRvSWQpfXJldHVybiBlfX0se2tleTpcIl91cGRhdGVTdGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fYWRkTWlzc2luZ0VkZ2VzKCksdGhpcy5fcmVtb3ZlSW52YWxpZEVkZ2VzKCl9fSx7a2V5OlwiX3JlbW92ZUludmFsaWRFZGdlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPVtdO25oKHRoaXMuYm9keS5lZGdlcywoZnVuY3Rpb24oaSxvKXt2YXIgbj10LmJvZHkubm9kZXNbaS50b0lkXSxyPXQuYm9keS5ub2Rlc1tpLmZyb21JZF07dm9pZCAwIT09biYmITA9PT1uLmlzQ2x1c3Rlcnx8dm9pZCAwIT09ciYmITA9PT1yLmlzQ2x1c3Rlcnx8dm9pZCAwIT09biYmdm9pZCAwIT09cnx8ZS5wdXNoKG8pfSkpLHRoaXMucmVtb3ZlKGUsITEpfX0se2tleTpcIl9hZGRNaXNzaW5nRWRnZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuYm9keS5kYXRhLmVkZ2VzO2lmKG51bGwhPXQpe3ZhciBlPXRoaXMuYm9keS5lZGdlcyxpPVtdO0RuKHQpLmNhbGwodCwoZnVuY3Rpb24odCxvKXt2b2lkIDA9PT1lW29dJiZpLnB1c2gobyl9KSksdGhpcy5hZGQoaSwhMCl9fX1dKSx0fSgpLGV1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLGksbyl7UG8odGhpcyx0KSx0aGlzLmJvZHk9ZSx0aGlzLnBoeXNpY3NCb2R5PWksdGhpcy5iYXJuZXNIdXRUcmVlLHRoaXMuc2V0T3B0aW9ucyhvKSx0aGlzLl9ybmc9UmEoXCJCQVJORVMgSFVUIFNPTFZFUlwiKX1yZXR1cm4gSW8odCxbe2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLm9wdGlvbnM9dCx0aGlzLnRoZXRhSW52ZXJzZWQ9MS90aGlzLm9wdGlvbnMudGhldGEsdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yPTEtTWF0aC5tYXgoMCxNYXRoLm1pbigxLHRoaXMub3B0aW9ucy5hdm9pZE92ZXJsYXApKX19LHtrZXk6XCJzb2x2ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYoMCE9PXRoaXMub3B0aW9ucy5ncmF2aXRhdGlvbmFsQ29uc3RhbnQmJnRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aD4wKXt2YXIgdCxlPXRoaXMuYm9keS5ub2RlcyxpPXRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLG89aS5sZW5ndGgsbj10aGlzLl9mb3JtQmFybmVzSHV0VHJlZShlLGkpO3RoaXMuYmFybmVzSHV0VHJlZT1uO2Zvcih2YXIgcj0wO3I8bztyKyspKHQ9ZVtpW3JdXSkub3B0aW9ucy5tYXNzPjAmJnRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9ucyhuLnJvb3QsdCl9fX0se2tleTpcIl9nZXRGb3JjZUNvbnRyaWJ1dGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3RoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHQuY2hpbGRyZW4uTlcsZSksdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24odC5jaGlsZHJlbi5ORSxlKSx0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbih0LmNoaWxkcmVuLlNXLGUpLHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHQuY2hpbGRyZW4uU0UsZSl9fSx7a2V5OlwiX2dldEZvcmNlQ29udHJpYnV0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZih0LmNoaWxkcmVuQ291bnQ+MCl7dmFyIGk9dC5jZW50ZXJPZk1hc3MueC1lLngsbz10LmNlbnRlck9mTWFzcy55LWUueSxuPU1hdGguc3FydChpKmkrbypvKTtuKnQuY2FsY1NpemU+dGhpcy50aGV0YUludmVyc2VkP3RoaXMuX2NhbGN1bGF0ZUZvcmNlcyhuLGksbyxlLHQpOjQ9PT10LmNoaWxkcmVuQ291bnQ/dGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb25zKHQsZSk6dC5jaGlsZHJlbi5kYXRhLmlkIT1lLmlkJiZ0aGlzLl9jYWxjdWxhdGVGb3JjZXMobixpLG8sZSx0KX19fSx7a2V5OlwiX2NhbGN1bGF0ZUZvcmNlc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbil7MD09PXQmJihlPXQ9LjEpLHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvcjwxJiZvLnNoYXBlLnJhZGl1cyYmKHQ9TWF0aC5tYXgoLjErdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yKm8uc2hhcGUucmFkaXVzLHQtby5zaGFwZS5yYWRpdXMpKTt2YXIgcj10aGlzLm9wdGlvbnMuZ3Jhdml0YXRpb25hbENvbnN0YW50Km4ubWFzcypvLm9wdGlvbnMubWFzcy9NYXRoLnBvdyh0LDMpLHM9ZSpyLGE9aSpyO3RoaXMucGh5c2ljc0JvZHkuZm9yY2VzW28uaWRdLngrPXMsdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbby5pZF0ueSs9YX19LHtrZXk6XCJfZm9ybUJhcm5lc0h1dFRyZWVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgaSxvPWUubGVuZ3RoLG49dFtlWzBdXS54LHI9dFtlWzBdXS55LHM9dFtlWzBdXS54LGE9dFtlWzBdXS55LGg9MTtoPG87aCsrKXt2YXIgZD10W2VbaF1dLGw9ZC54LGM9ZC55O2Qub3B0aW9ucy5tYXNzPjAmJihsPG4mJihuPWwpLGw+cyYmKHM9bCksYzxyJiYocj1jKSxjPmEmJihhPWMpKX12YXIgdT1NYXRoLmFicyhzLW4pLU1hdGguYWJzKGEtcik7dT4wPyhyLT0uNSp1LGErPS41KnUpOihuKz0uNSp1LHMtPS41KnUpO3ZhciBmPU1hdGgubWF4KDFlLTUsTWF0aC5hYnMocy1uKSkscD0uNSpmLHY9LjUqKG4rcyksZz0uNSoocithKSx5PXtyb290OntjZW50ZXJPZk1hc3M6e3g6MCx5OjB9LG1hc3M6MCxyYW5nZTp7bWluWDp2LXAsbWF4WDp2K3AsbWluWTpnLXAsbWF4WTpnK3B9LHNpemU6ZixjYWxjU2l6ZToxL2YsY2hpbGRyZW46e2RhdGE6bnVsbH0sbWF4V2lkdGg6MCxsZXZlbDowLGNoaWxkcmVuQ291bnQ6NH19O3RoaXMuX3NwbGl0QnJhbmNoKHkucm9vdCk7Zm9yKHZhciBtPTA7bTxvO20rKykoaT10W2VbbV1dKS5vcHRpb25zLm1hc3M+MCYmdGhpcy5fcGxhY2VJblRyZWUoeS5yb290LGkpO3JldHVybiB5fX0se2tleTpcIl91cGRhdGVCcmFuY2hNYXNzXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT10LmNlbnRlck9mTWFzcyxvPXQubWFzcytlLm9wdGlvbnMubWFzcyxuPTEvbztpLng9aS54KnQubWFzcytlLngqZS5vcHRpb25zLm1hc3MsaS54Kj1uLGkueT1pLnkqdC5tYXNzK2UueSplLm9wdGlvbnMubWFzcyxpLnkqPW4sdC5tYXNzPW87dmFyIHI9TWF0aC5tYXgoTWF0aC5tYXgoZS5oZWlnaHQsZS5yYWRpdXMpLGUud2lkdGgpO3QubWF4V2lkdGg9dC5tYXhXaWR0aDxyP3I6dC5tYXhXaWR0aH19LHtrZXk6XCJfcGxhY2VJblRyZWVcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7MT09aSYmdm9pZCAwIT09aXx8dGhpcy5fdXBkYXRlQnJhbmNoTWFzcyh0LGUpO3ZhciBvLG49dC5jaGlsZHJlbi5OVy5yYW5nZTtvPW4ubWF4WD5lLng/bi5tYXhZPmUueT9cIk5XXCI6XCJTV1wiOm4ubWF4WT5lLnk/XCJORVwiOlwiU0VcIix0aGlzLl9wbGFjZUluUmVnaW9uKHQsZSxvKX19LHtrZXk6XCJfcGxhY2VJblJlZ2lvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbz10LmNoaWxkcmVuW2ldO3N3aXRjaChvLmNoaWxkcmVuQ291bnQpe2Nhc2UgMDpvLmNoaWxkcmVuLmRhdGE9ZSxvLmNoaWxkcmVuQ291bnQ9MSx0aGlzLl91cGRhdGVCcmFuY2hNYXNzKG8sZSk7YnJlYWs7Y2FzZSAxOm8uY2hpbGRyZW4uZGF0YS54PT09ZS54JiZvLmNoaWxkcmVuLmRhdGEueT09PWUueT8oZS54Kz10aGlzLl9ybmcoKSxlLnkrPXRoaXMuX3JuZygpKToodGhpcy5fc3BsaXRCcmFuY2gobyksdGhpcy5fcGxhY2VJblRyZWUobyxlKSk7YnJlYWs7Y2FzZSA0OnRoaXMuX3BsYWNlSW5UcmVlKG8sZSl9fX0se2tleTpcIl9zcGxpdEJyYW5jaFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPW51bGw7MT09PXQuY2hpbGRyZW5Db3VudCYmKGU9dC5jaGlsZHJlbi5kYXRhLHQubWFzcz0wLHQuY2VudGVyT2ZNYXNzLng9MCx0LmNlbnRlck9mTWFzcy55PTApLHQuY2hpbGRyZW5Db3VudD00LHQuY2hpbGRyZW4uZGF0YT1udWxsLHRoaXMuX2luc2VydFJlZ2lvbih0LFwiTldcIiksdGhpcy5faW5zZXJ0UmVnaW9uKHQsXCJORVwiKSx0aGlzLl9pbnNlcnRSZWdpb24odCxcIlNXXCIpLHRoaXMuX2luc2VydFJlZ2lvbih0LFwiU0VcIiksbnVsbCE9ZSYmdGhpcy5fcGxhY2VJblRyZWUodCxlKX19LHtrZXk6XCJfaW5zZXJ0UmVnaW9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaSxvLG4scixzPS41KnQuc2l6ZTtzd2l0Y2goZSl7Y2FzZVwiTldcIjppPXQucmFuZ2UubWluWCxvPXQucmFuZ2UubWluWCtzLG49dC5yYW5nZS5taW5ZLHI9dC5yYW5nZS5taW5ZK3M7YnJlYWs7Y2FzZVwiTkVcIjppPXQucmFuZ2UubWluWCtzLG89dC5yYW5nZS5tYXhYLG49dC5yYW5nZS5taW5ZLHI9dC5yYW5nZS5taW5ZK3M7YnJlYWs7Y2FzZVwiU1dcIjppPXQucmFuZ2UubWluWCxvPXQucmFuZ2UubWluWCtzLG49dC5yYW5nZS5taW5ZK3Mscj10LnJhbmdlLm1heFk7YnJlYWs7Y2FzZVwiU0VcIjppPXQucmFuZ2UubWluWCtzLG89dC5yYW5nZS5tYXhYLG49dC5yYW5nZS5taW5ZK3Mscj10LnJhbmdlLm1heFl9dC5jaGlsZHJlbltlXT17Y2VudGVyT2ZNYXNzOnt4OjAseTowfSxtYXNzOjAscmFuZ2U6e21pblg6aSxtYXhYOm8sbWluWTpuLG1heFk6cn0sc2l6ZTouNSp0LnNpemUsY2FsY1NpemU6Mip0LmNhbGNTaXplLGNoaWxkcmVuOntkYXRhOm51bGx9LG1heFdpZHRoOjAsbGV2ZWw6dC5sZXZlbCsxLGNoaWxkcmVuQ291bnQ6MH19fSx7a2V5OlwiX2RlYnVnXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2b2lkIDAhPT10aGlzLmJhcm5lc0h1dFRyZWUmJih0LmxpbmVXaWR0aD0xLHRoaXMuX2RyYXdCcmFuY2godGhpcy5iYXJuZXNIdXRUcmVlLnJvb3QsdCxlKSl9fSx7a2V5OlwiX2RyYXdCcmFuY2hcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dm9pZCAwPT09aSYmKGk9XCIjRkYwMDAwXCIpLDQ9PT10LmNoaWxkcmVuQ291bnQmJih0aGlzLl9kcmF3QnJhbmNoKHQuY2hpbGRyZW4uTlcsZSksdGhpcy5fZHJhd0JyYW5jaCh0LmNoaWxkcmVuLk5FLGUpLHRoaXMuX2RyYXdCcmFuY2godC5jaGlsZHJlbi5TRSxlKSx0aGlzLl9kcmF3QnJhbmNoKHQuY2hpbGRyZW4uU1csZSkpLGUuc3Ryb2tlU3R5bGU9aSxlLmJlZ2luUGF0aCgpLGUubW92ZVRvKHQucmFuZ2UubWluWCx0LnJhbmdlLm1pblkpLGUubGluZVRvKHQucmFuZ2UubWF4WCx0LnJhbmdlLm1pblkpLGUuc3Ryb2tlKCksZS5iZWdpblBhdGgoKSxlLm1vdmVUbyh0LnJhbmdlLm1heFgsdC5yYW5nZS5taW5ZKSxlLmxpbmVUbyh0LnJhbmdlLm1heFgsdC5yYW5nZS5tYXhZKSxlLnN0cm9rZSgpLGUuYmVnaW5QYXRoKCksZS5tb3ZlVG8odC5yYW5nZS5tYXhYLHQucmFuZ2UubWF4WSksZS5saW5lVG8odC5yYW5nZS5taW5YLHQucmFuZ2UubWF4WSksZS5zdHJva2UoKSxlLmJlZ2luUGF0aCgpLGUubW92ZVRvKHQucmFuZ2UubWluWCx0LnJhbmdlLm1heFkpLGUubGluZVRvKHQucmFuZ2UubWluWCx0LnJhbmdlLm1pblkpLGUuc3Ryb2tlKCl9fV0pLHR9KCksaXU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsaSxvKXtQbyh0aGlzLHQpLHRoaXMuX3JuZz1SYShcIlJFUFVMU0lPTiBTT0xWRVJcIiksdGhpcy5ib2R5PWUsdGhpcy5waHlzaWNzQm9keT1pLHRoaXMuc2V0T3B0aW9ucyhvKX1yZXR1cm4gSW8odCxbe2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLm9wdGlvbnM9dH19LHtrZXk6XCJzb2x2ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0LGUsaSxvLG4scixzLGEsaD10aGlzLmJvZHkubm9kZXMsZD10aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcyxsPXRoaXMucGh5c2ljc0JvZHkuZm9yY2VzLGM9dGhpcy5vcHRpb25zLm5vZGVEaXN0YW5jZSx1PS0yLzMvYyxmPTA7ZjxkLmxlbmd0aC0xO2YrKyl7cz1oW2RbZl1dO2Zvcih2YXIgcD1mKzE7cDxkLmxlbmd0aDtwKyspdD0oYT1oW2RbcF1dKS54LXMueCxlPWEueS1zLnksMD09PShpPU1hdGguc3FydCh0KnQrZSplKSkmJih0PWk9LjEqdGhpcy5fcm5nKCkpLGk8MipjJiYocj1pPC41KmM/MTp1KmkrMS4zMzMzMzMzMzMzMzMzMzMzLG89dCooci89aSksbj1lKnIsbFtzLmlkXS54LT1vLGxbcy5pZF0ueS09bixsW2EuaWRdLngrPW8sbFthLmlkXS55Kz1uKX19fV0pLHR9KCksb3U9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsaSxvKXtQbyh0aGlzLHQpLHRoaXMuYm9keT1lLHRoaXMucGh5c2ljc0JvZHk9aSx0aGlzLnNldE9wdGlvbnMobyl9cmV0dXJuIElvKHQsW3trZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5vcHRpb25zPXQsdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yPU1hdGgubWF4KDAsTWF0aC5taW4oMSx0aGlzLm9wdGlvbnMuYXZvaWRPdmVybGFwfHwwKSl9fSx7a2V5Olwic29sdmVcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmJvZHkubm9kZXMsZT10aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcyxpPXRoaXMucGh5c2ljc0JvZHkuZm9yY2VzLG89dGhpcy5vcHRpb25zLm5vZGVEaXN0YW5jZSxuPTA7bjxlLmxlbmd0aC0xO24rKylmb3IodmFyIHI9dFtlW25dXSxzPW4rMTtzPGUubGVuZ3RoO3MrKyl7dmFyIGE9dFtlW3NdXTtpZihyLmxldmVsPT09YS5sZXZlbCl7dmFyIGg9byt0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IqKChyLnNoYXBlLnJhZGl1c3x8MCkvMisoYS5zaGFwZS5yYWRpdXN8fDApLzIpLGQ9YS54LXIueCxsPWEueS1yLnksYz1NYXRoLnNxcnQoZCpkK2wqbCksdT12b2lkIDA7dT1jPGg/LU1hdGgucG93KC4wNSpjLDIpK01hdGgucG93KC4wNSpoLDIpOjAsMCE9PWMmJih1Lz1jKTt2YXIgZj1kKnUscD1sKnU7aVtyLmlkXS54LT1mLGlbci5pZF0ueS09cCxpW2EuaWRdLngrPWYsaVthLmlkXS55Kz1wfX19fV0pLHR9KCksbnU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsaSxvKXtQbyh0aGlzLHQpLHRoaXMuYm9keT1lLHRoaXMucGh5c2ljc0JvZHk9aSx0aGlzLnNldE9wdGlvbnMobyl9cmV0dXJuIElvKHQsW3trZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5vcHRpb25zPXR9fSx7a2V5Olwic29sdmVcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdCxlLGksbyxuLHI9dGhpcy5waHlzaWNzQm9keS5waHlzaWNzRWRnZUluZGljZXMscz10aGlzLmJvZHkuZWRnZXMsYT0wO2E8ci5sZW5ndGg7YSsrKSEwPT09KGU9c1tyW2FdXSkuY29ubmVjdGVkJiZlLnRvSWQhPT1lLmZyb21JZCYmdm9pZCAwIT09dGhpcy5ib2R5Lm5vZGVzW2UudG9JZF0mJnZvaWQgMCE9PXRoaXMuYm9keS5ub2Rlc1tlLmZyb21JZF0mJih2b2lkIDAhPT1lLmVkZ2VUeXBlLnZpYT8odD12b2lkIDA9PT1lLm9wdGlvbnMubGVuZ3RoP3RoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGg6ZS5vcHRpb25zLmxlbmd0aCxpPWUudG8sbz1lLmVkZ2VUeXBlLnZpYSxuPWUuZnJvbSx0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShpLG8sLjUqdCksdGhpcy5fY2FsY3VsYXRlU3ByaW5nRm9yY2UobyxuLC41KnQpKToodD12b2lkIDA9PT1lLm9wdGlvbnMubGVuZ3RoPzEuNSp0aGlzLm9wdGlvbnMuc3ByaW5nTGVuZ3RoOmUub3B0aW9ucy5sZW5ndGgsdGhpcy5fY2FsY3VsYXRlU3ByaW5nRm9yY2UoZS5mcm9tLGUudG8sdCkpKX19LHtrZXk6XCJfY2FsY3VsYXRlU3ByaW5nRm9yY2VcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dmFyIG89dC54LWUueCxuPXQueS1lLnkscj1NYXRoLm1heChNYXRoLnNxcnQobypvK24qbiksLjAxKSxzPXRoaXMub3B0aW9ucy5zcHJpbmdDb25zdGFudCooaS1yKS9yLGE9bypzLGg9bipzO3ZvaWQgMCE9PXRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW3QuaWRdJiYodGhpcy5waHlzaWNzQm9keS5mb3JjZXNbdC5pZF0ueCs9YSx0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1t0LmlkXS55Kz1oKSx2b2lkIDAhPT10aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tlLmlkXSYmKHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW2UuaWRdLngtPWEsdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbZS5pZF0ueS09aCl9fV0pLHR9KCkscnU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsaSxvKXtQbyh0aGlzLHQpLHRoaXMuYm9keT1lLHRoaXMucGh5c2ljc0JvZHk9aSx0aGlzLnNldE9wdGlvbnMobyl9cmV0dXJuIElvKHQsW3trZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5vcHRpb25zPXR9fSx7a2V5Olwic29sdmVcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdCxlLGksbyxuLHIscyxhLGgsZCxsPXRoaXMuYm9keS5lZGdlcyxjPS41LHU9dGhpcy5waHlzaWNzQm9keS5waHlzaWNzRWRnZUluZGljZXMsZj10aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcyxwPXRoaXMucGh5c2ljc0JvZHkuZm9yY2VzLHY9MDt2PGYubGVuZ3RoO3YrKyl7dmFyIGc9Zlt2XTtwW2ddLnNwcmluZ0Z4PTAscFtnXS5zcHJpbmdGeT0wfWZvcih2YXIgeT0wO3k8dS5sZW5ndGg7eSsrKSEwPT09KGU9bFt1W3ldXSkuY29ubmVjdGVkJiYodD12b2lkIDA9PT1lLm9wdGlvbnMubGVuZ3RoP3RoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGg6ZS5vcHRpb25zLmxlbmd0aCxpPWUuZnJvbS54LWUudG8ueCxvPWUuZnJvbS55LWUudG8ueSxhPTA9PT0oYT1NYXRoLnNxcnQoaSppK28qbykpPy4wMTphLG49aSoocz10aGlzLm9wdGlvbnMuc3ByaW5nQ29uc3RhbnQqKHQtYSkvYSkscj1vKnMsZS50by5sZXZlbCE9ZS5mcm9tLmxldmVsPyh2b2lkIDAhPT1wW2UudG9JZF0mJihwW2UudG9JZF0uc3ByaW5nRngtPW4scFtlLnRvSWRdLnNwcmluZ0Z5LT1yKSx2b2lkIDAhPT1wW2UuZnJvbUlkXSYmKHBbZS5mcm9tSWRdLnNwcmluZ0Z4Kz1uLHBbZS5mcm9tSWRdLnNwcmluZ0Z5Kz1yKSk6KHZvaWQgMCE9PXBbZS50b0lkXSYmKHBbZS50b0lkXS54LT1jKm4scFtlLnRvSWRdLnktPWMqciksdm9pZCAwIT09cFtlLmZyb21JZF0mJihwW2UuZnJvbUlkXS54Kz1jKm4scFtlLmZyb21JZF0ueSs9YypyKSkpO3M9MTtmb3IodmFyIG09MDttPGYubGVuZ3RoO20rKyl7dmFyIGI9ZlttXTtoPU1hdGgubWluKHMsTWF0aC5tYXgoLXMscFtiXS5zcHJpbmdGeCkpLGQ9TWF0aC5taW4ocyxNYXRoLm1heCgtcyxwW2JdLnNwcmluZ0Z5KSkscFtiXS54Kz1oLHBbYl0ueSs9ZH1mb3IodmFyIHc9MCxrPTAsXz0wO188Zi5sZW5ndGg7XysrKXt2YXIgeD1mW19dO3crPXBbeF0ueCxrKz1wW3hdLnl9Zm9yKHZhciBFPXcvZi5sZW5ndGgsTz1rL2YubGVuZ3RoLEM9MDtDPGYubGVuZ3RoO0MrKyl7dmFyIFM9ZltDXTtwW1NdLngtPUUscFtTXS55LT1PfX19XSksdH0oKSxzdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8pe1BvKHRoaXMsdCksdGhpcy5ib2R5PWUsdGhpcy5waHlzaWNzQm9keT1pLHRoaXMuc2V0T3B0aW9ucyhvKX1yZXR1cm4gSW8odCxbe2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLm9wdGlvbnM9dH19LHtrZXk6XCJzb2x2ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0LGUsaSxvLG49dGhpcy5ib2R5Lm5vZGVzLHI9dGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMscz10aGlzLnBoeXNpY3NCb2R5LmZvcmNlcyxhPTA7YTxyLmxlbmd0aDthKyspe3Q9LShvPW5bclthXV0pLngsZT0tby55LGk9TWF0aC5zcXJ0KHQqdCtlKmUpLHRoaXMuX2NhbGN1bGF0ZUZvcmNlcyhpLHQsZSxzLG8pfX19LHtrZXk6XCJfY2FsY3VsYXRlRm9yY2VzXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuKXt2YXIgcj0wPT09dD8wOnRoaXMub3B0aW9ucy5jZW50cmFsR3Jhdml0eS90O29bbi5pZF0ueD1lKnIsb1tuLmlkXS55PWkqcn19XSksdH0oKTtmdW5jdGlvbiBhdSh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciBodT1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPWF1KGkpO2Z1bmN0aW9uIGkodCxvLG4pe3ZhciByO3JldHVybiBQbyh0aGlzLGkpLChyPWUuY2FsbCh0aGlzLHQsbyxuKSkuX3JuZz1SYShcIkZPUkNFIEFUTEFTIDIgQkFTRUQgUkVQVUxTSU9OIFNPTFZFUlwiKSxyfXJldHVybiBJbyhpLFt7a2V5OlwiX2NhbGN1bGF0ZUZvcmNlc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbil7MD09PXQmJihlPXQ9LjEqdGhpcy5fcm5nKCkpLHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvcjwxJiZvLnNoYXBlLnJhZGl1cyYmKHQ9TWF0aC5tYXgoLjErdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yKm8uc2hhcGUucmFkaXVzLHQtby5zaGFwZS5yYWRpdXMpKTt2YXIgcj1vLmVkZ2VzLmxlbmd0aCsxLHM9dGhpcy5vcHRpb25zLmdyYXZpdGF0aW9uYWxDb25zdGFudCpuLm1hc3Mqby5vcHRpb25zLm1hc3Mqci9NYXRoLnBvdyh0LDIpLGE9ZSpzLGg9aSpzO3RoaXMucGh5c2ljc0JvZHkuZm9yY2VzW28uaWRdLngrPWEsdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbby5pZF0ueSs9aH19XSksaX0oZXUpO2Z1bmN0aW9uIGR1KHQpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCF2bClyZXR1cm4hMTtpZih2bC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZsKEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGksbz1fbCh0KTtpZihlKXt2YXIgbj1fbCh0aGlzKS5jb25zdHJ1Y3RvcjtpPXZsKG8sYXJndW1lbnRzLG4pfWVsc2UgaT1vLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gd2wodGhpcyxpKX19dmFyIGx1LGN1PWZ1bmN0aW9uKHQpe2JsKGksdCk7dmFyIGU9ZHUoaSk7ZnVuY3Rpb24gaSh0LG8sbil7cmV0dXJuIFBvKHRoaXMsaSksZS5jYWxsKHRoaXMsdCxvLG4pfXJldHVybiBJbyhpLFt7a2V5OlwiX2NhbGN1bGF0ZUZvcmNlc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8sbil7aWYodD4wKXt2YXIgcj1uLmVkZ2VzLmxlbmd0aCsxLHM9dGhpcy5vcHRpb25zLmNlbnRyYWxHcmF2aXR5KnIqbi5vcHRpb25zLm1hc3M7b1tuLmlkXS54PWUqcyxvW24uaWRdLnk9aSpzfX19XSksaX0oc3UpLHV1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXtQbyh0aGlzLHQpLHRoaXMuYm9keT1lLHRoaXMucGh5c2ljc0JvZHk9e3BoeXNpY3NOb2RlSW5kaWNlczpbXSxwaHlzaWNzRWRnZUluZGljZXM6W10sZm9yY2VzOnt9LHZlbG9jaXRpZXM6e319LHRoaXMucGh5c2ljc0VuYWJsZWQ9ITAsdGhpcy5zaW11bGF0aW9uSW50ZXJ2YWw9MWUzLzYwLHRoaXMucmVxdWlyZXNUaW1lb3V0PSEwLHRoaXMucHJldmlvdXNTdGF0ZXM9e30sdGhpcy5yZWZlcmVuY2VTdGF0ZT17fSx0aGlzLmZyZWV6ZUNhY2hlPXt9LHRoaXMucmVuZGVyVGltZXI9dm9pZCAwLHRoaXMuYWRhcHRpdmVUaW1lc3RlcD0hMSx0aGlzLmFkYXB0aXZlVGltZXN0ZXBFbmFibGVkPSExLHRoaXMuYWRhcHRpdmVDb3VudGVyPTAsdGhpcy5hZGFwdGl2ZUludGVydmFsPTMsdGhpcy5zdGFiaWxpemVkPSExLHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb249ITEsdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucz0wLHRoaXMucmVhZHk9ITEsdGhpcy5vcHRpb25zPXt9LHRoaXMuZGVmYXVsdE9wdGlvbnM9e2VuYWJsZWQ6ITAsYmFybmVzSHV0Ont0aGV0YTouNSxncmF2aXRhdGlvbmFsQ29uc3RhbnQ6LTJlMyxjZW50cmFsR3Jhdml0eTouMyxzcHJpbmdMZW5ndGg6OTUsc3ByaW5nQ29uc3RhbnQ6LjA0LGRhbXBpbmc6LjA5LGF2b2lkT3ZlcmxhcDowfSxmb3JjZUF0bGFzMkJhc2VkOnt0aGV0YTouNSxncmF2aXRhdGlvbmFsQ29uc3RhbnQ6LTUwLGNlbnRyYWxHcmF2aXR5Oi4wMSxzcHJpbmdDb25zdGFudDouMDgsc3ByaW5nTGVuZ3RoOjEwMCxkYW1waW5nOi40LGF2b2lkT3ZlcmxhcDowfSxyZXB1bHNpb246e2NlbnRyYWxHcmF2aXR5Oi4yLHNwcmluZ0xlbmd0aDoyMDAsc3ByaW5nQ29uc3RhbnQ6LjA1LG5vZGVEaXN0YW5jZToxMDAsZGFtcGluZzouMDksYXZvaWRPdmVybGFwOjB9LGhpZXJhcmNoaWNhbFJlcHVsc2lvbjp7Y2VudHJhbEdyYXZpdHk6MCxzcHJpbmdMZW5ndGg6MTAwLHNwcmluZ0NvbnN0YW50Oi4wMSxub2RlRGlzdGFuY2U6MTIwLGRhbXBpbmc6LjA5fSxtYXhWZWxvY2l0eTo1MCxtaW5WZWxvY2l0eTouNzUsc29sdmVyOlwiYmFybmVzSHV0XCIsc3RhYmlsaXphdGlvbjp7ZW5hYmxlZDohMCxpdGVyYXRpb25zOjFlMyx1cGRhdGVJbnRlcnZhbDo1MCxvbmx5RHluYW1pY0VkZ2VzOiExLGZpdDohMH0sdGltZXN0ZXA6LjUsYWRhcHRpdmVUaW1lc3RlcDohMCx3aW5kOnt4OjAseTowfX0sY3QodGhpcy5vcHRpb25zLHRoaXMuZGVmYXVsdE9wdGlvbnMpLHRoaXMudGltZXN0ZXA9LjUsdGhpcy5sYXlvdXRGYWlsZWQ9ITEsdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKX1yZXR1cm4gSW8odCxbe2tleTpcImJpbmRFdmVudExpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRQaHlzaWNzXCIsKGZ1bmN0aW9uKCl7dC5pbml0UGh5c2ljcygpfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2xheW91dEZhaWxlZFwiLChmdW5jdGlvbigpe3QubGF5b3V0RmFpbGVkPSEwfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVzZXRQaHlzaWNzXCIsKGZ1bmN0aW9uKCl7dC5zdG9wU2ltdWxhdGlvbigpLHQucmVhZHk9ITF9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkaXNhYmxlUGh5c2ljc1wiLChmdW5jdGlvbigpe3QucGh5c2ljc0VuYWJsZWQ9ITEsdC5zdG9wU2ltdWxhdGlvbigpfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVzdG9yZVBoeXNpY3NcIiwoZnVuY3Rpb24oKXt0LnNldE9wdGlvbnModC5vcHRpb25zKSwhMD09PXQucmVhZHkmJnQuc3RhcnRTaW11bGF0aW9uKCl9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJzdGFydFNpbXVsYXRpb25cIiwoZnVuY3Rpb24oKXshMD09PXQucmVhZHkmJnQuc3RhcnRTaW11bGF0aW9uKCl9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJzdG9wU2ltdWxhdGlvblwiLChmdW5jdGlvbigpe3Quc3RvcFNpbXVsYXRpb24oKX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwoZnVuY3Rpb24oKXt0LnN0b3BTaW11bGF0aW9uKCExKSx0LmJvZHkuZW1pdHRlci5vZmYoKX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhQ2hhbmdlZFwiLChmdW5jdGlvbigpe3QudXBkYXRlUGh5c2ljc0RhdGEoKX0pKX19LHtrZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dClpZighMT09PXQpdGhpcy5vcHRpb25zLmVuYWJsZWQ9ITEsdGhpcy5waHlzaWNzRW5hYmxlZD0hMSx0aGlzLnN0b3BTaW11bGF0aW9uKCk7ZWxzZSBpZighMD09PXQpdGhpcy5vcHRpb25zLmVuYWJsZWQ9ITAsdGhpcy5waHlzaWNzRW5hYmxlZD0hMCx0aGlzLnN0YXJ0U2ltdWxhdGlvbigpO2Vsc2V7dGhpcy5waHlzaWNzRW5hYmxlZD0hMCxKYShbXCJzdGFiaWxpemF0aW9uXCJdLHRoaXMub3B0aW9ucyx0KSxnaCh0aGlzLm9wdGlvbnMsdCxcInN0YWJpbGl6YXRpb25cIiksdm9pZCAwPT09dC5lbmFibGVkJiYodGhpcy5vcHRpb25zLmVuYWJsZWQ9ITApLCExPT09dGhpcy5vcHRpb25zLmVuYWJsZWQmJih0aGlzLnBoeXNpY3NFbmFibGVkPSExLHRoaXMuc3RvcFNpbXVsYXRpb24oKSk7dmFyIGU9dGhpcy5vcHRpb25zLndpbmQ7ZSYmKChcIm51bWJlclwiIT10eXBlb2YgZS54fHx6ZChlLngpKSYmKGUueD0wKSwoXCJudW1iZXJcIiE9dHlwZW9mIGUueXx8emQoZS55KSkmJihlLnk9MCkpLHRoaXMudGltZXN0ZXA9dGhpcy5vcHRpb25zLnRpbWVzdGVwfXRoaXMuaW5pdCgpfX0se2tleTpcImluaXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0O1wiZm9yY2VBdGxhczJCYXNlZFwiPT09dGhpcy5vcHRpb25zLnNvbHZlcj8odD10aGlzLm9wdGlvbnMuZm9yY2VBdGxhczJCYXNlZCx0aGlzLm5vZGVzU29sdmVyPW5ldyBodSh0aGlzLmJvZHksdGhpcy5waHlzaWNzQm9keSx0KSx0aGlzLmVkZ2VzU29sdmVyPW5ldyBudSh0aGlzLmJvZHksdGhpcy5waHlzaWNzQm9keSx0KSx0aGlzLmdyYXZpdHlTb2x2ZXI9bmV3IGN1KHRoaXMuYm9keSx0aGlzLnBoeXNpY3NCb2R5LHQpKTpcInJlcHVsc2lvblwiPT09dGhpcy5vcHRpb25zLnNvbHZlcj8odD10aGlzLm9wdGlvbnMucmVwdWxzaW9uLHRoaXMubm9kZXNTb2x2ZXI9bmV3IGl1KHRoaXMuYm9keSx0aGlzLnBoeXNpY3NCb2R5LHQpLHRoaXMuZWRnZXNTb2x2ZXI9bmV3IG51KHRoaXMuYm9keSx0aGlzLnBoeXNpY3NCb2R5LHQpLHRoaXMuZ3Jhdml0eVNvbHZlcj1uZXcgc3UodGhpcy5ib2R5LHRoaXMucGh5c2ljc0JvZHksdCkpOlwiaGllcmFyY2hpY2FsUmVwdWxzaW9uXCI9PT10aGlzLm9wdGlvbnMuc29sdmVyPyh0PXRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWxSZXB1bHNpb24sdGhpcy5ub2Rlc1NvbHZlcj1uZXcgb3UodGhpcy5ib2R5LHRoaXMucGh5c2ljc0JvZHksdCksdGhpcy5lZGdlc1NvbHZlcj1uZXcgcnUodGhpcy5ib2R5LHRoaXMucGh5c2ljc0JvZHksdCksdGhpcy5ncmF2aXR5U29sdmVyPW5ldyBzdSh0aGlzLmJvZHksdGhpcy5waHlzaWNzQm9keSx0KSk6KHQ9dGhpcy5vcHRpb25zLmJhcm5lc0h1dCx0aGlzLm5vZGVzU29sdmVyPW5ldyBldSh0aGlzLmJvZHksdGhpcy5waHlzaWNzQm9keSx0KSx0aGlzLmVkZ2VzU29sdmVyPW5ldyBudSh0aGlzLmJvZHksdGhpcy5waHlzaWNzQm9keSx0KSx0aGlzLmdyYXZpdHlTb2x2ZXI9bmV3IHN1KHRoaXMuYm9keSx0aGlzLnBoeXNpY3NCb2R5LHQpKSx0aGlzLm1vZGVsT3B0aW9ucz10fX0se2tleTpcImluaXRQaHlzaWNzXCIsdmFsdWU6ZnVuY3Rpb24oKXshMD09PXRoaXMucGh5c2ljc0VuYWJsZWQmJiEwPT09dGhpcy5vcHRpb25zLmVuYWJsZWQ/ITA9PT10aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5lbmFibGVkP3RoaXMuc3RhYmlsaXplKCk6KHRoaXMuc3RhYmlsaXplZD0hMSx0aGlzLnJlYWR5PSEwLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJmaXRcIix7fSx0aGlzLmxheW91dEZhaWxlZCksdGhpcy5zdGFydFNpbXVsYXRpb24oKSk6KHRoaXMucmVhZHk9ITAsdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImZpdFwiKSl9fSx7a2V5Olwic3RhcnRTaW11bGF0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdDshMD09PXRoaXMucGh5c2ljc0VuYWJsZWQmJiEwPT09dGhpcy5vcHRpb25zLmVuYWJsZWQ/KHRoaXMuc3RhYmlsaXplZD0hMSx0aGlzLmFkYXB0aXZlVGltZXN0ZXA9ITEsdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNpemVOb2Rlc1wiKSx2b2lkIDA9PT10aGlzLnZpZXdGdW5jdGlvbiYmKHRoaXMudmlld0Z1bmN0aW9uPWJ0KHQ9dGhpcy5zaW11bGF0aW9uU3RlcCkuY2FsbCh0LHRoaXMpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLHRoaXMudmlld0Z1bmN0aW9uKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0YXJ0UmVuZGVyaW5nXCIpKSk6dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIil9fSx7a2V5Olwic3RvcFNpbXVsYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PSEoYXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0pfHxhcmd1bWVudHNbMF07dGhpcy5zdGFiaWxpemVkPSEwLCEwPT09dCYmdGhpcy5fZW1pdFN0YWJpbGl6ZWQoKSx2b2lkIDAhPT10aGlzLnZpZXdGdW5jdGlvbiYmKHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIix0aGlzLnZpZXdGdW5jdGlvbiksdGhpcy52aWV3RnVuY3Rpb249dm9pZCAwLCEwPT09dCYmdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdG9wUmVuZGVyaW5nXCIpKX19LHtrZXk6XCJzaW11bGF0aW9uU3RlcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9RW4oKTt0aGlzLnBoeXNpY3NUaWNrKCksKEVuKCktdDwuNCp0aGlzLnNpbXVsYXRpb25JbnRlcnZhbHx8ITA9PT10aGlzLnJ1bkRvdWJsZVNwZWVkKSYmITE9PT10aGlzLnN0YWJpbGl6ZWQmJih0aGlzLnBoeXNpY3NUaWNrKCksdGhpcy5ydW5Eb3VibGVTcGVlZD0hMCksITA9PT10aGlzLnN0YWJpbGl6ZWQmJnRoaXMuc3RvcFNpbXVsYXRpb24oKX19LHtrZXk6XCJfZW1pdFN0YWJpbGl6ZWRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06dGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9uczsodGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucz4xfHwhMD09PXRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24pJiZxcigoZnVuY3Rpb24oKXt0LmJvZHkuZW1pdHRlci5lbWl0KFwic3RhYmlsaXplZFwiLHtpdGVyYXRpb25zOmV9KSx0LnN0YXJ0ZWRTdGFiaWxpemF0aW9uPSExLHQuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnM9MH0pLDApfX0se2tleTpcInBoeXNpY3NTdGVwXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmdyYXZpdHlTb2x2ZXIuc29sdmUoKSx0aGlzLm5vZGVzU29sdmVyLnNvbHZlKCksdGhpcy5lZGdlc1NvbHZlci5zb2x2ZSgpLHRoaXMubW92ZU5vZGVzKCl9fSx7a2V5OlwiYWRqdXN0VGltZVN0ZXBcIix2YWx1ZTpmdW5jdGlvbigpeyEwPT09dGhpcy5fZXZhbHVhdGVTdGVwUXVhbGl0eSgpP3RoaXMudGltZXN0ZXA9MS4yKnRoaXMudGltZXN0ZXA6dGhpcy50aW1lc3RlcC8xLjI8dGhpcy5vcHRpb25zLnRpbWVzdGVwP3RoaXMudGltZXN0ZXA9dGhpcy5vcHRpb25zLnRpbWVzdGVwOih0aGlzLmFkYXB0aXZlQ291bnRlcj0tMSx0aGlzLnRpbWVzdGVwPU1hdGgubWF4KHRoaXMub3B0aW9ucy50aW1lc3RlcCx0aGlzLnRpbWVzdGVwLzEuMikpfX0se2tleTpcInBoeXNpY3NUaWNrXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLl9zdGFydFN0YWJpbGl6aW5nKCksITAhPT10aGlzLnN0YWJpbGl6ZWQpe2lmKCEwPT09dGhpcy5hZGFwdGl2ZVRpbWVzdGVwJiYhMD09PXRoaXMuYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQpdGhpcy5hZGFwdGl2ZUNvdW50ZXIldGhpcy5hZGFwdGl2ZUludGVydmFsPT0wPyh0aGlzLnRpbWVzdGVwPTIqdGhpcy50aW1lc3RlcCx0aGlzLnBoeXNpY3NTdGVwKCksdGhpcy5yZXZlcnQoKSx0aGlzLnRpbWVzdGVwPS41KnRoaXMudGltZXN0ZXAsdGhpcy5waHlzaWNzU3RlcCgpLHRoaXMucGh5c2ljc1N0ZXAoKSx0aGlzLmFkanVzdFRpbWVTdGVwKCkpOnRoaXMucGh5c2ljc1N0ZXAoKSx0aGlzLmFkYXB0aXZlQ291bnRlcis9MTtlbHNlIHRoaXMudGltZXN0ZXA9dGhpcy5vcHRpb25zLnRpbWVzdGVwLHRoaXMucGh5c2ljc1N0ZXAoKTshMD09PXRoaXMuc3RhYmlsaXplZCYmdGhpcy5yZXZlcnQoKSx0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zKyt9fX0se2tleTpcInVwZGF0ZVBoeXNpY3NEYXRhXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcz17fSx0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcz1bXSx0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcz1bXTt2YXIgdD10aGlzLmJvZHkubm9kZXMsZT10aGlzLmJvZHkuZWRnZXM7Zm9yKHZhciBpIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsaSkmJiEwPT09dFtpXS5vcHRpb25zLnBoeXNpY3MmJnRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLnB1c2godFtpXS5pZCk7Zm9yKHZhciBvIGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbykmJiEwPT09ZVtvXS5vcHRpb25zLnBoeXNpY3MmJnRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzLnB1c2goZVtvXS5pZCk7Zm9yKHZhciBuPTA7bjx0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGg7bisrKXt2YXIgcj10aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlc1tuXTt0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tyXT17eDowLHk6MH0sdm9pZCAwPT09dGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW3JdJiYodGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW3JdPXt4OjAseTowfSl9Zm9yKHZhciBzIGluIHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllcyl2b2lkIDA9PT10W3NdJiZkZWxldGUgdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW3NdfX0se2tleTpcInJldmVydFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9eG4odGhpcy5wcmV2aW91c1N0YXRlcyksZT10aGlzLmJvZHkubm9kZXMsaT10aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXM7dGhpcy5yZWZlcmVuY2VTdGF0ZT17fTtmb3IodmFyIG89MDtvPHQubGVuZ3RoO28rKyl7dmFyIG49dFtvXTt2b2lkIDAhPT1lW25dPyEwPT09ZVtuXS5vcHRpb25zLnBoeXNpY3MmJih0aGlzLnJlZmVyZW5jZVN0YXRlW25dPXtwb3NpdGlvbnM6e3g6ZVtuXS54LHk6ZVtuXS55fX0saVtuXS54PXRoaXMucHJldmlvdXNTdGF0ZXNbbl0udngsaVtuXS55PXRoaXMucHJldmlvdXNTdGF0ZXNbbl0udnksZVtuXS54PXRoaXMucHJldmlvdXNTdGF0ZXNbbl0ueCxlW25dLnk9dGhpcy5wcmV2aW91c1N0YXRlc1tuXS55KTpkZWxldGUgdGhpcy5wcmV2aW91c1N0YXRlc1tuXX19fSx7a2V5OlwiX2V2YWx1YXRlU3RlcFF1YWxpdHlcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGUsaT10aGlzLmJvZHkubm9kZXMsbz10aGlzLnJlZmVyZW5jZVN0YXRlO2Zvcih2YXIgbiBpbiB0aGlzLnJlZmVyZW5jZVN0YXRlKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnJlZmVyZW5jZVN0YXRlLG4pJiZ2b2lkIDAhPT1pW25dJiYodD1pW25dLngtb1tuXS5wb3NpdGlvbnMueCxlPWlbbl0ueS1vW25dLnBvc2l0aW9ucy55LE1hdGguc3FydChNYXRoLnBvdyh0LDIpK01hdGgucG93KGUsMikpPi4zKSlyZXR1cm4hMTtyZXR1cm4hMH19LHtrZXk6XCJtb3ZlTm9kZXNcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcyxlPTAsaT0wLG89MDtvPHQubGVuZ3RoO28rKyl7dmFyIG49dFtvXSxyPXRoaXMuX3BlcmZvcm1TdGVwKG4pO2U9TWF0aC5tYXgoZSxyKSxpKz1yfXRoaXMuYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQ9aS90Lmxlbmd0aDw1LHRoaXMuc3RhYmlsaXplZD1lPHRoaXMub3B0aW9ucy5taW5WZWxvY2l0eX19LHtrZXk6XCJjYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpKXt0Kz0oZS10aGlzLm1vZGVsT3B0aW9ucy5kYW1waW5nKnQpL2kqdGhpcy50aW1lc3RlcDt2YXIgbz10aGlzLm9wdGlvbnMubWF4VmVsb2NpdHl8fDFlOTtyZXR1cm4gTWF0aC5hYnModCk+byYmKHQ9dD4wP286LW8pLHR9fSx7a2V5OlwiX3BlcmZvcm1TdGVwXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5ib2R5Lm5vZGVzW3RdLGk9dGhpcy5waHlzaWNzQm9keS5mb3JjZXNbdF07dGhpcy5vcHRpb25zLndpbmQmJihpLngrPXRoaXMub3B0aW9ucy53aW5kLngsaS55Kz10aGlzLm9wdGlvbnMud2luZC55KTt2YXIgbz10aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXNbdF07cmV0dXJuIHRoaXMucHJldmlvdXNTdGF0ZXNbdF09e3g6ZS54LHk6ZS55LHZ4Om8ueCx2eTpvLnl9LCExPT09ZS5vcHRpb25zLmZpeGVkLng/KG8ueD10aGlzLmNhbGN1bGF0ZUNvbXBvbmVudFZlbG9jaXR5KG8ueCxpLngsZS5vcHRpb25zLm1hc3MpLGUueCs9by54KnRoaXMudGltZXN0ZXApOihpLng9MCxvLng9MCksITE9PT1lLm9wdGlvbnMuZml4ZWQueT8oby55PXRoaXMuY2FsY3VsYXRlQ29tcG9uZW50VmVsb2NpdHkoby55LGkueSxlLm9wdGlvbnMubWFzcyksZS55Kz1vLnkqdGhpcy50aW1lc3RlcCk6KGkueT0wLG8ueT0wKSxNYXRoLnNxcnQoTWF0aC5wb3coby54LDIpK01hdGgucG93KG8ueSwyKSl9fSx7a2V5OlwiX2ZyZWV6ZU5vZGVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmJvZHkubm9kZXM7Zm9yKHZhciBlIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSkmJnRbZV0ueCYmdFtlXS55KXt2YXIgaT10W2VdLm9wdGlvbnMuZml4ZWQ7dGhpcy5mcmVlemVDYWNoZVtlXT17eDppLngseTppLnl9LGkueD0hMCxpLnk9ITB9fX0se2tleTpcIl9yZXN0b3JlRnJvemVuTm9kZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuYm9keS5ub2Rlcztmb3IodmFyIGUgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSYmdm9pZCAwIT09dGhpcy5mcmVlemVDYWNoZVtlXSYmKHRbZV0ub3B0aW9ucy5maXhlZC54PXRoaXMuZnJlZXplQ2FjaGVbZV0ueCx0W2VdLm9wdGlvbnMuZml4ZWQueT10aGlzLmZyZWV6ZUNhY2hlW2VdLnkpO3RoaXMuZnJlZXplQ2FjaGU9e319fSx7a2V5Olwic3RhYmlsaXplXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLml0ZXJhdGlvbnM7XCJudW1iZXJcIiE9dHlwZW9mIGUmJihlPXRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLml0ZXJhdGlvbnMsY29uc29sZS5lcnJvcihcIlRoZSBzdGFiaWxpemUgbWV0aG9kIG5lZWRzIGEgbnVtZXJpYyBhbW91bnQgb2YgaXRlcmF0aW9ucy4gU3dpdGNoaW5nIHRvIGRlZmF1bHQ6IFwiLGUpKSwwIT09dGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMubGVuZ3RoPyh0aGlzLmFkYXB0aXZlVGltZXN0ZXA9dGhpcy5vcHRpb25zLmFkYXB0aXZlVGltZXN0ZXAsdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNpemVOb2Rlc1wiKSx0aGlzLnN0b3BTaW11bGF0aW9uKCksdGhpcy5zdGFiaWxpemVkPSExLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfYmxvY2tSZWRyYXdcIiksdGhpcy50YXJnZXRJdGVyYXRpb25zPWUsITA9PT10aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5vbmx5RHluYW1pY0VkZ2VzJiZ0aGlzLl9mcmVlemVOb2RlcygpLHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnM9MCxxcigoZnVuY3Rpb24oKXtyZXR1cm4gdC5fc3RhYmlsaXphdGlvbkJhdGNoKCl9KSwwKSk6dGhpcy5yZWFkeT0hMH19LHtrZXk6XCJfc3RhcnRTdGFiaWxpemluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuITAhPT10aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uJiYodGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U3RhYmlsaXppbmdcIiksdGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbj0hMCwhMCl9fSx7a2V5OlwiX3N0YWJpbGl6YXRpb25CYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPWZ1bmN0aW9uKCl7cmV0dXJuITE9PT10LnN0YWJpbGl6ZWQmJnQuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnM8dC50YXJnZXRJdGVyYXRpb25zfSxpPWZ1bmN0aW9uKCl7dC5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YWJpbGl6YXRpb25Qcm9ncmVzc1wiLHtpdGVyYXRpb25zOnQuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMsdG90YWw6dC50YXJnZXRJdGVyYXRpb25zfSl9O3RoaXMuX3N0YXJ0U3RhYmlsaXppbmcoKSYmaSgpO2Zvcih2YXIgbyxuPTA7ZSgpJiZuPHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLnVwZGF0ZUludGVydmFsOyl0aGlzLnBoeXNpY3NUaWNrKCksbisrOyhpKCksZSgpKT9xcihidChvPXRoaXMuX3N0YWJpbGl6YXRpb25CYXRjaCkuY2FsbChvLHRoaXMpLDApOnRoaXMuX2ZpbmFsaXplU3RhYmlsaXphdGlvbigpfX0se2tleTpcIl9maW5hbGl6ZVN0YWJpbGl6YXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfYWxsb3dSZWRyYXdcIiksITA9PT10aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5maXQmJnRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJmaXRcIiksITA9PT10aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5vbmx5RHluYW1pY0VkZ2VzJiZ0aGlzLl9yZXN0b3JlRnJvemVuTm9kZXMoKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhYmlsaXphdGlvbkl0ZXJhdGlvbnNEb25lXCIpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKSwhMD09PXRoaXMuc3RhYmlsaXplZD90aGlzLl9lbWl0U3RhYmlsaXplZCgpOnRoaXMuc3RhcnRTaW11bGF0aW9uKCksdGhpcy5yZWFkeT0hMH19LHtrZXk6XCJfZHJhd0ZvcmNlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMubGVuZ3RoO2UrKyl7dmFyIGk9dGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXNbZV0sbz10aGlzLmJvZHkubm9kZXNbaV0sbj10aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tpXSxyPU1hdGguc3FydChNYXRoLnBvdyhuLngsMikrTWF0aC5wb3cobi54LDIpKSxzPU1hdGgubWluKE1hdGgubWF4KDUsciksMTUpLGE9MypzLGg9Y2goKDE4MC0xODAqTWF0aC5taW4oMSxNYXRoLm1heCgwLC4wMypyKSkpLzM2MCwxLDEpLGQ9e3g6by54KzIwKm4ueCx5Om8ueSsyMCpuLnl9O3QubGluZVdpZHRoPXMsdC5zdHJva2VTdHlsZT1oLHQuYmVnaW5QYXRoKCksdC5tb3ZlVG8oby54LG8ueSksdC5saW5lVG8oZC54LGQueSksdC5zdHJva2UoKTt2YXIgbD1NYXRoLmF0YW4yKG4ueSxuLngpO3QuZmlsbFN0eWxlPWgsTmMuZHJhdyh0LHt0eXBlOlwiYXJyb3dcIixwb2ludDpkLGFuZ2xlOmwsbGVuZ3RoOmF9KSxYcih0KS5jYWxsKHQpfX19XSksdH0oKSxmdT1uZXcgVWludDhBcnJheSgxNik7ZnVuY3Rpb24gcHUoKXtpZighbHUmJiEobHU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGNyeXB0byYmY3J5cHRvLmdldFJhbmRvbVZhbHVlcyYmY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0byl8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBtc0NyeXB0byYmXCJmdW5jdGlvblwiPT10eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzJiZtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0bykpKXRocm93IG5ldyBFcnJvcihcImNyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkXCIpO3JldHVybiBsdShmdSl9dmFyIHZ1PS9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtmdW5jdGlvbiBndSh0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdCYmdnUudGVzdCh0KX1mb3IodmFyIHl1PVtdLG11PTA7bXU8MjU2OysrbXUpeXUucHVzaCgobXUrMjU2KS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtmdW5jdGlvbiBidSh0LGUsaSl7dmFyIG89KHQ9dHx8e30pLnJhbmRvbXx8KHQucm5nfHxwdSkoKTtpZihvWzZdPTE1Jm9bNl18NjQsb1s4XT02MyZvWzhdfDEyOCxlKXtpPWl8fDA7Zm9yKHZhciBuPTA7bjwxNjsrK24pZVtpK25dPW9bbl07cmV0dXJuIGV9cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTowLGk9KHl1W3RbZSswXV0reXVbdFtlKzFdXSt5dVt0W2UrMl1dK3l1W3RbZSszXV0rXCItXCIreXVbdFtlKzRdXSt5dVt0W2UrNV1dK1wiLVwiK3l1W3RbZSs2XV0reXVbdFtlKzddXStcIi1cIit5dVt0W2UrOF1dK3l1W3RbZSs5XV0rXCItXCIreXVbdFtlKzEwXV0reXVbdFtlKzExXV0reXVbdFtlKzEyXV0reXVbdFtlKzEzXV0reXVbdFtlKzE0XV0reXVbdFtlKzE1XV0pLnRvTG93ZXJDYXNlKCk7aWYoIWd1KGkpKXRocm93IFR5cGVFcnJvcihcIlN0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZFwiKTtyZXR1cm4gaX0obyl9dmFyIHd1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCl9cmV0dXJuIElvKHQsbnVsbCxbe2tleTpcImdldFJhbmdlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGUsaT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06W10sbz0xZTksbj0tMWU5LHI9MWU5LHM9LTFlOTtpZihpLmxlbmd0aD4wKWZvcih2YXIgYT0wO2E8aS5sZW5ndGg7YSsrKXI+KGU9dFtpW2FdXSkuc2hhcGUuYm91bmRpbmdCb3gubGVmdCYmKHI9ZS5zaGFwZS5ib3VuZGluZ0JveC5sZWZ0KSxzPGUuc2hhcGUuYm91bmRpbmdCb3gucmlnaHQmJihzPWUuc2hhcGUuYm91bmRpbmdCb3gucmlnaHQpLG8+ZS5zaGFwZS5ib3VuZGluZ0JveC50b3AmJihvPWUuc2hhcGUuYm91bmRpbmdCb3gudG9wKSxuPGUuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tJiYobj1lLnNoYXBlLmJvdW5kaW5nQm94LmJvdHRvbSk7cmV0dXJuIDFlOT09PXImJi0xZTk9PT1zJiYxZTk9PT1vJiYtMWU5PT09biYmKG89MCxuPTAscj0wLHM9MCkse21pblg6cixtYXhYOnMsbWluWTpvLG1heFk6bn19fSx7a2V5OlwiZ2V0UmFuZ2VDb3JlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGUsaT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06W10sbz0xZTksbj0tMWU5LHI9MWU5LHM9LTFlOTtpZihpLmxlbmd0aD4wKWZvcih2YXIgYT0wO2E8aS5sZW5ndGg7YSsrKXI+KGU9dFtpW2FdXSkueCYmKHI9ZS54KSxzPGUueCYmKHM9ZS54KSxvPmUueSYmKG89ZS55KSxuPGUueSYmKG49ZS55KTtyZXR1cm4gMWU5PT09ciYmLTFlOT09PXMmJjFlOT09PW8mJi0xZTk9PT1uJiYobz0wLG49MCxyPTAscz0wKSx7bWluWDpyLG1heFg6cyxtaW5ZOm8sbWF4WTpufX19LHtrZXk6XCJmaW5kQ2VudGVyXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJue3g6LjUqKHQubWF4WCt0Lm1pblgpLHk6LjUqKHQubWF4WSt0Lm1pblkpfX19LHtrZXk6XCJjbG9uZU9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXt9O3JldHVybiB2b2lkIDA9PT1lfHxcIm5vZGVcIj09PWU/KHRoKGksdC5vcHRpb25zLCEwKSxpLng9dC54LGkueT10LnksaS5hbW91bnRPZkNvbm5lY3Rpb25zPXQuZWRnZXMubGVuZ3RoKTp0aChpLHQub3B0aW9ucywhMCksaX19XSksdH0oKTtmdW5jdGlvbiBrdSh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciBfdT1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPWt1KGkpO2Z1bmN0aW9uIGkodCxvLG4scixzLGEpe3ZhciBoO3JldHVybiBQbyh0aGlzLGkpLChoPWUuY2FsbCh0aGlzLHQsbyxuLHIscyxhKSkuaXNDbHVzdGVyPSEwLGguY29udGFpbmVkTm9kZXM9e30saC5jb250YWluZWRFZGdlcz17fSxofXJldHVybiBJbyhpLFt7a2V5OlwiX29wZW5DaGlsZENsdXN0ZXJcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLGk9dGhpcy5ib2R5Lm5vZGVzW3RdO2lmKHZvaWQgMD09PXRoaXMuY29udGFpbmVkTm9kZXNbdF0pdGhyb3cgbmV3IEVycm9yKFwibm9kZSB3aXRoIGlkOiBcIit0K1wiIG5vdCBpbiBjdXJyZW50IGNsdXN0ZXJcIik7aWYoIWkuaXNDbHVzdGVyKXRocm93IG5ldyBFcnJvcihcIm5vZGUgd2l0aCBpZDogXCIrdCtcIiBpcyBub3QgYSBjbHVzdGVyXCIpO2RlbGV0ZSB0aGlzLmNvbnRhaW5lZE5vZGVzW3RdLG5oKGkuZWRnZXMsKGZ1bmN0aW9uKHQpe2RlbGV0ZSBlLmNvbnRhaW5lZEVkZ2VzW3QuaWRdfSkpLG5oKGkuY29udGFpbmVkTm9kZXMsKGZ1bmN0aW9uKHQsaSl7ZS5jb250YWluZWROb2Rlc1tpXT10fSkpLGkuY29udGFpbmVkTm9kZXM9e30sbmgoaS5jb250YWluZWRFZGdlcywoZnVuY3Rpb24odCxpKXtlLmNvbnRhaW5lZEVkZ2VzW2ldPXR9KSksaS5jb250YWluZWRFZGdlcz17fSxuaChpLmVkZ2VzLChmdW5jdGlvbih0KXtuaChlLmVkZ2VzLChmdW5jdGlvbihpKXt2YXIgbyxuLHI9TXIobz1pLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzKS5jYWxsKG8sdC5pZCk7LTEhPT1yJiYobmgodC5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcywoZnVuY3Rpb24odCl7aS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcy5wdXNoKHQpLGUuYm9keS5lZGdlc1t0XS5lZGdlUmVwbGFjZWRCeUlkPWkuaWR9KSkscW4obj1pLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzKS5jYWxsKG4sciwxKSl9KSl9KSksaS5lZGdlcz1bXX19XSksaX0obGMpLHh1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXt2YXIgaT10aGlzO1BvKHRoaXMsdCksdGhpcy5ib2R5PWUsdGhpcy5jbHVzdGVyZWROb2Rlcz17fSx0aGlzLmNsdXN0ZXJlZEVkZ2VzPXt9LHRoaXMub3B0aW9ucz17fSx0aGlzLmRlZmF1bHRPcHRpb25zPXt9LGN0KHRoaXMub3B0aW9ucyx0aGlzLmRlZmF1bHRPcHRpb25zKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXNldERhdGFcIiwoZnVuY3Rpb24oKXtpLmNsdXN0ZXJlZE5vZGVzPXt9LGkuY2x1c3RlcmVkRWRnZXM9e319KSl9cmV0dXJuIElvKHQsW3trZXk6XCJjbHVzdGVyQnlIdWJzaXplXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT10P3Q9dGhpcy5fZ2V0SHViU2l6ZSgpOlwib2JqZWN0XCI9PT1kbih0KSYmKGU9dGhpcy5fY2hlY2tPcHRpb25zKHQpLHQ9dGhpcy5fZ2V0SHViU2l6ZSgpKTtmb3IodmFyIGk9W10sbz0wO288dGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDtvKyspe3ZhciBuPXRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbb11dO24uZWRnZXMubGVuZ3RoPj10JiZpLnB1c2gobi5pZCl9Zm9yKHZhciByPTA7cjxpLmxlbmd0aDtyKyspdGhpcy5jbHVzdGVyQnlDb25uZWN0aW9uKGlbcl0sZSwhMCk7dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKX19LHtrZXk6XCJjbHVzdGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LGk9IShhcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSl8fGFyZ3VtZW50c1sxXTtpZih2b2lkIDA9PT1lLmpvaW5Db25kaXRpb24pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgY2x1c3RlckJ5Tm9kZURhdGEgd2l0aG91dCBhIGpvaW5Db25kaXRpb24gZnVuY3Rpb24gaW4gdGhlIG9wdGlvbnMuXCIpO2U9dGhpcy5fY2hlY2tPcHRpb25zKGUpO3ZhciBvPXt9LG49e307bmgodGhpcy5ib2R5Lm5vZGVzLChmdW5jdGlvbihpLHIpe2kub3B0aW9ucyYmITA9PT1lLmpvaW5Db25kaXRpb24oaS5vcHRpb25zKSYmKG9bcl09aSxuaChpLmVkZ2VzLChmdW5jdGlvbihlKXt2b2lkIDA9PT10LmNsdXN0ZXJlZEVkZ2VzW2UuaWRdJiYobltlLmlkXT1lKX0pKSl9KSksdGhpcy5fY2x1c3RlcihvLG4sZSxpKX19LHtrZXk6XCJjbHVzdGVyQnlFZGdlQ291bnRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMsbz0hKGFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdKXx8YXJndW1lbnRzWzJdO2U9dGhpcy5fY2hlY2tPcHRpb25zKGUpO2Zvcih2YXIgbixyLHMsYT1bXSxoPXt9LGQ9ZnVuY3Rpb24obyl7dmFyIGQ9e30sbD17fSxjPWkuYm9keS5ub2RlSW5kaWNlc1tvXSx1PWkuYm9keS5ub2Rlc1tjXTtpZih2b2lkIDA9PT1oW2NdKXtzPTAscj1bXTtmb3IodmFyIGY9MDtmPHUuZWRnZXMubGVuZ3RoO2YrKyluPXUuZWRnZXNbZl0sdm9pZCAwPT09aS5jbHVzdGVyZWRFZGdlc1tuLmlkXSYmKG4udG9JZCE9PW4uZnJvbUlkJiZzKyssci5wdXNoKG4pKTtpZihzPT09dCl7Zm9yKHZhciBwPWZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PWUuam9pbkNvbmRpdGlvbnx8bnVsbD09PWUuam9pbkNvbmRpdGlvbilyZXR1cm4hMDt2YXIgaT13dS5jbG9uZU9wdGlvbnModCk7cmV0dXJuIGUuam9pbkNvbmRpdGlvbihpKX0sdj0hMCxnPTA7ZzxyLmxlbmd0aDtnKyspe249cltnXTt2YXIgeT1pLl9nZXRDb25uZWN0ZWRJZChuLGMpO2lmKCFwKHUpKXt2PSExO2JyZWFrfWxbbi5pZF09bixkW2NdPXUsZFt5XT1pLmJvZHkubm9kZXNbeV0saFtjXT0hMH1pZih4bihkKS5sZW5ndGg+MCYmeG4obCkubGVuZ3RoPjAmJiEwPT09dil7dmFyIG09ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PGEubGVuZ3RoOysrdClmb3IodmFyIGUgaW4gZClpZih2b2lkIDAhPT1hW3RdLm5vZGVzW2VdKXJldHVybiBhW3RdfSgpO2lmKHZvaWQgMCE9PW0pe2Zvcih2YXIgYiBpbiBkKXZvaWQgMD09PW0ubm9kZXNbYl0mJihtLm5vZGVzW2JdPWRbYl0pO2Zvcih2YXIgdyBpbiBsKXZvaWQgMD09PW0uZWRnZXNbd10mJihtLmVkZ2VzW3ddPWxbd10pfWVsc2UgYS5wdXNoKHtub2RlczpkLGVkZ2VzOmx9KX19fX0sbD0wO2w8dGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDtsKyspZChsKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl0aGlzLl9jbHVzdGVyKGFbY10ubm9kZXMsYVtjXS5lZGdlcyxlLCExKTshMD09PW8mJnRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIil9fSx7a2V5OlwiY2x1c3Rlck91dGxpZXJzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9IShhcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSl8fGFyZ3VtZW50c1sxXTt0aGlzLmNsdXN0ZXJCeUVkZ2VDb3VudCgxLHQsZSl9fSx7a2V5OlwiY2x1c3RlckJyaWRnZXNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT0hKGFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdKXx8YXJndW1lbnRzWzFdO3RoaXMuY2x1c3RlckJ5RWRnZUNvdW50KDIsdCxlKX19LHtrZXk6XCJjbHVzdGVyQnlDb25uZWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaSxvPSEoYXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0pfHxhcmd1bWVudHNbMl07aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJObyBub2RlSWQgc3VwcGxpZWQgdG8gY2x1c3RlckJ5Q29ubmVjdGlvbiFcIik7aWYodm9pZCAwPT09dGhpcy5ib2R5Lm5vZGVzW3RdKXRocm93IG5ldyBFcnJvcihcIlRoZSBub2RlSWQgZ2l2ZW4gdG8gY2x1c3RlckJ5Q29ubmVjdGlvbiBkb2VzIG5vdCBleGlzdCFcIik7dmFyIG49dGhpcy5ib2R5Lm5vZGVzW3RdO3ZvaWQgMD09PShlPXRoaXMuX2NoZWNrT3B0aW9ucyhlLG4pKS5jbHVzdGVyTm9kZVByb3BlcnRpZXMueCYmKGUuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLng9bi54KSx2b2lkIDA9PT1lLmNsdXN0ZXJOb2RlUHJvcGVydGllcy55JiYoZS5jbHVzdGVyTm9kZVByb3BlcnRpZXMueT1uLnkpLHZvaWQgMD09PWUuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkJiYoZS5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQ9e30sZS5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQueD1uLm9wdGlvbnMuZml4ZWQueCxlLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZC55PW4ub3B0aW9ucy5maXhlZC55KTt2YXIgcj17fSxzPXt9LGE9bi5pZCxoPXd1LmNsb25lT3B0aW9ucyhuKTtyW2FdPW47Zm9yKHZhciBkPTA7ZDxuLmVkZ2VzLmxlbmd0aDtkKyspe3ZhciBsPW4uZWRnZXNbZF07aWYodm9pZCAwPT09dGhpcy5jbHVzdGVyZWRFZGdlc1tsLmlkXSl7dmFyIGM9dGhpcy5fZ2V0Q29ubmVjdGVkSWQobCxhKTtpZih2b2lkIDA9PT10aGlzLmNsdXN0ZXJlZE5vZGVzW2NdKWlmKGMhPT1hKWlmKHZvaWQgMD09PWUuam9pbkNvbmRpdGlvbilzW2wuaWRdPWwscltjXT10aGlzLmJvZHkubm9kZXNbY107ZWxzZXt2YXIgdT13dS5jbG9uZU9wdGlvbnModGhpcy5ib2R5Lm5vZGVzW2NdKTshMD09PWUuam9pbkNvbmRpdGlvbihoLHUpJiYoc1tsLmlkXT1sLHJbY109dGhpcy5ib2R5Lm5vZGVzW2NdKX1lbHNlIHNbbC5pZF09bH19dmFyIGY9a24oaT14bihyKSkuY2FsbChpLChmdW5jdGlvbih0KXtyZXR1cm4gclt0XS5pZH0pKTtmb3IodmFyIHAgaW4gcilpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixwKSlmb3IodmFyIHY9cltwXSxnPTA7Zzx2LmVkZ2VzLmxlbmd0aDtnKyspe3ZhciB5PXYuZWRnZXNbZ107TXIoZikuY2FsbChmLHRoaXMuX2dldENvbm5lY3RlZElkKHksdi5pZCkpPi0xJiYoc1t5LmlkXT15KX10aGlzLl9jbHVzdGVyKHIscyxlLG8pfX0se2tleTpcIl9jcmVhdGVDbHVzdGVyRWRnZXNcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSxvKXtmb3IodmFyIG4scixzLGEsaCxkLGw9eG4odCksYz1bXSx1PTA7dTxsLmxlbmd0aDt1Kyspe3M9dFtyPWxbdV1dO2Zvcih2YXIgZj0wO2Y8cy5lZGdlcy5sZW5ndGg7ZisrKW49cy5lZGdlc1tmXSx2b2lkIDA9PT10aGlzLmNsdXN0ZXJlZEVkZ2VzW24uaWRdJiYobi50b0lkPT1uLmZyb21JZD9lW24uaWRdPW46bi50b0lkPT1yPyhhPWkuaWQsZD1oPW4uZnJvbUlkKTooYT1uLnRvSWQsaD1pLmlkLGQ9YSksdm9pZCAwPT09dFtkXSYmYy5wdXNoKHtlZGdlOm4sZnJvbUlkOmgsdG9JZDphfSkpfWZvcih2YXIgcD1bXSx2PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8cC5sZW5ndGg7ZSsrKXt2YXIgaT1wW2VdLG89dC5mcm9tSWQ9PT1pLmZyb21JZCYmdC50b0lkPT09aS50b0lkLG49dC5mcm9tSWQ9PT1pLnRvSWQmJnQudG9JZD09PWkuZnJvbUlkO2lmKG98fG4pcmV0dXJuIGl9cmV0dXJuIG51bGx9LGc9MDtnPGMubGVuZ3RoO2crKyl7dmFyIHk9Y1tnXSxtPXkuZWRnZSxiPXYoeSk7bnVsbD09PWI/KGI9dGhpcy5fY3JlYXRlQ2x1c3RlcmVkRWRnZSh5LmZyb21JZCx5LnRvSWQsbSxvKSxwLnB1c2goYikpOmIuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMucHVzaChtLmlkKSx0aGlzLmJvZHkuZWRnZXNbbS5pZF0uZWRnZVJlcGxhY2VkQnlJZD1iLmlkLHRoaXMuX2JhY2t1cEVkZ2VPcHRpb25zKG0pLG0uc2V0T3B0aW9ucyh7cGh5c2ljczohMX0pfX19LHtrZXk6XCJfY2hlY2tPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307cmV0dXJuIHZvaWQgMD09PXQuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzJiYodC5jbHVzdGVyRWRnZVByb3BlcnRpZXM9e30pLHZvaWQgMD09PXQuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzJiYodC5jbHVzdGVyTm9kZVByb3BlcnRpZXM9e30pLHR9fSx7a2V5OlwiX2NsdXN0ZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dmFyIG89IShhcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXSl8fGFyZ3VtZW50c1szXSxuPVtdO2Zvcih2YXIgciBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpJiZ2b2lkIDAhPT10aGlzLmNsdXN0ZXJlZE5vZGVzW3JdJiZuLnB1c2gocik7Zm9yKHZhciBzPTA7czxuLmxlbmd0aDsrK3MpZGVsZXRlIHRbbltzXV07aWYoMCE9eG4odCkubGVuZ3RoJiYoMSE9eG4odCkubGVuZ3RofHwxPT1pLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5hbGxvd1NpbmdsZU5vZGVDbHVzdGVyKSl7dmFyIGE9dGgoe30saS5jbHVzdGVyTm9kZVByb3BlcnRpZXMpO2lmKHZvaWQgMCE9PWkucHJvY2Vzc1Byb3BlcnRpZXMpe3ZhciBoPVtdO2Zvcih2YXIgZCBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGQpKXt2YXIgbD13dS5jbG9uZU9wdGlvbnModFtkXSk7aC5wdXNoKGwpfXZhciBjPVtdO2Zvcih2YXIgdSBpbiBlKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHUpJiZcImNsdXN0ZXJFZGdlOlwiIT09dS5zdWJzdHIoMCwxMikpe3ZhciBmPXd1LmNsb25lT3B0aW9ucyhlW3VdLFwiZWRnZVwiKTtjLnB1c2goZil9aWYoIShhPWkucHJvY2Vzc1Byb3BlcnRpZXMoYSxoLGMpKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvY2Vzc1Byb3BlcnRpZXMgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIHByb3BlcnRpZXMhXCIpfXZvaWQgMD09PWEuaWQmJihhLmlkPVwiY2x1c3RlcjpcIitidSgpKTt2YXIgcD1hLmlkO3ZvaWQgMD09PWEubGFiZWwmJihhLmxhYmVsPVwiY2x1c3RlclwiKTt2YXIgdj12b2lkIDA7dm9pZCAwPT09YS54JiYodj10aGlzLl9nZXRDbHVzdGVyUG9zaXRpb24odCksYS54PXYueCksdm9pZCAwPT09YS55JiYodm9pZCAwPT09diYmKHY9dGhpcy5fZ2V0Q2x1c3RlclBvc2l0aW9uKHQpKSxhLnk9di55KSxhLmlkPXA7dmFyIGc9dGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlKGEsX3UpO2cuY29udGFpbmVkTm9kZXM9dCxnLmNvbnRhaW5lZEVkZ2VzPWUsZy5jbHVzdGVyRWRnZVByb3BlcnRpZXM9aS5jbHVzdGVyRWRnZVByb3BlcnRpZXMsdGhpcy5ib2R5Lm5vZGVzW2EuaWRdPWcsdGhpcy5fY2x1c3RlckVkZ2VzKHQsZSxhLGkuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKSxhLmlkPXZvaWQgMCwhMD09PW8mJnRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIil9fX0se2tleTpcIl9iYWNrdXBFZGdlT3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZvaWQgMD09PXRoaXMuY2x1c3RlcmVkRWRnZXNbdC5pZF0mJih0aGlzLmNsdXN0ZXJlZEVkZ2VzW3QuaWRdPXtwaHlzaWNzOnQub3B0aW9ucy5waHlzaWNzfSl9fSx7a2V5OlwiX3Jlc3RvcmVFZGdlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5jbHVzdGVyZWRFZGdlc1t0LmlkXTt2b2lkIDAhPT1lJiYodC5zZXRPcHRpb25zKHtwaHlzaWNzOmUucGh5c2ljc30pLGRlbGV0ZSB0aGlzLmNsdXN0ZXJlZEVkZ2VzW3QuaWRdKX19LHtrZXk6XCJpc0NsdXN0ZXJcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dGhpcy5ib2R5Lm5vZGVzW3RdPyEwPT09dGhpcy5ib2R5Lm5vZGVzW3RdLmlzQ2x1c3RlcjooY29uc29sZS5lcnJvcihcIk5vZGUgZG9lcyBub3QgZXhpc3QuXCIpLCExKX19LHtrZXk6XCJfZ2V0Q2x1c3RlclBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlLGk9eG4odCksbz10W2lbMF1dLngsbj10W2lbMF1dLngscj10W2lbMF1dLnkscz10W2lbMF1dLnksYT0xO2E8aS5sZW5ndGg7YSsrKW89KGU9dFtpW2FdXSkueDxvP2UueDpvLG49ZS54Pm4/ZS54Om4scj1lLnk8cj9lLnk6cixzPWUueT5zP2UueTpzO3JldHVybnt4Oi41KihvK24pLHk6LjUqKHIrcyl9fX0se2tleTpcIm9wZW5DbHVzdGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT0hKGFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdKXx8YXJndW1lbnRzWzJdO2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IEVycm9yKFwiTm8gY2x1c3Rlck5vZGVJZCBzdXBwbGllZCB0byBvcGVuQ2x1c3Rlci5cIik7dmFyIG89dGhpcy5ib2R5Lm5vZGVzW3RdO2lmKHZvaWQgMD09PW8pdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNsdXN0ZXJOb2RlSWQgc3VwcGxpZWQgdG8gb3BlbkNsdXN0ZXIgZG9lcyBub3QgZXhpc3QuXCIpO2lmKCEwIT09by5pc0NsdXN0ZXJ8fHZvaWQgMD09PW8uY29udGFpbmVkTm9kZXN8fHZvaWQgMD09PW8uY29udGFpbmVkRWRnZXMpdGhyb3cgbmV3IEVycm9yKFwiVGhlIG5vZGU6XCIrdCtcIiBpcyBub3QgYSB2YWxpZCBjbHVzdGVyLlwiKTt2YXIgbj10aGlzLmZpbmROb2RlKHQpLHI9TXIobikuY2FsbChuLHQpLTE7aWYocj49MCl7dmFyIHM9bltyXSxhPXRoaXMuYm9keS5ub2Rlc1tzXTtyZXR1cm4gYS5fb3BlbkNoaWxkQ2x1c3Rlcih0KSxkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW3RdLHZvaWQoITA9PT1pJiZ0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpKX12YXIgaD1vLmNvbnRhaW5lZE5vZGVzLGQ9by5jb250YWluZWRFZGdlcztpZih2b2lkIDAhPT1lJiZ2b2lkIDAhPT1lLnJlbGVhc2VGdW5jdGlvbiYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5yZWxlYXNlRnVuY3Rpb24pe3ZhciBsPXt9LGM9e3g6by54LHk6by55fTtmb3IodmFyIHUgaW4gaClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaCx1KSl7dmFyIGY9dGhpcy5ib2R5Lm5vZGVzW3VdO2xbdV09e3g6Zi54LHk6Zi55fX12YXIgcD1lLnJlbGVhc2VGdW5jdGlvbihjLGwpO2Zvcih2YXIgdiBpbiBoKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoLHYpKXt2YXIgZz10aGlzLmJvZHkubm9kZXNbdl07dm9pZCAwIT09cFt2XSYmKGcueD12b2lkIDA9PT1wW3ZdLng/by54OnBbdl0ueCxnLnk9dm9pZCAwPT09cFt2XS55P28ueTpwW3ZdLnkpfX1lbHNlIG5oKGgsKGZ1bmN0aW9uKHQpeyExPT09dC5vcHRpb25zLmZpeGVkLngmJih0Lng9by54KSwhMT09PXQub3B0aW9ucy5maXhlZC55JiYodC55PW8ueSl9KSk7Zm9yKHZhciB5IGluIGgpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGgseSkpe3ZhciBtPXRoaXMuYm9keS5ub2Rlc1t5XTttLnZ4PW8udngsbS52eT1vLnZ5LG0uc2V0T3B0aW9ucyh7cGh5c2ljczohMH0pLGRlbGV0ZSB0aGlzLmNsdXN0ZXJlZE5vZGVzW3ldfWZvcih2YXIgYj1bXSx3PTA7dzxvLmVkZ2VzLmxlbmd0aDt3KyspYi5wdXNoKG8uZWRnZXNbd10pO2Zvcih2YXIgaz0wO2s8Yi5sZW5ndGg7aysrKXtmb3IodmFyIF89YltrXSx4PXRoaXMuX2dldENvbm5lY3RlZElkKF8sdCksRT10aGlzLmNsdXN0ZXJlZE5vZGVzW3hdLE89MDtPPF8uY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMubGVuZ3RoO08rKyl7dmFyIEM9Xy5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkc1tPXSxTPXRoaXMuYm9keS5lZGdlc1tDXTtpZih2b2lkIDAhPT1TKWlmKHZvaWQgMCE9PUUpe3ZhciBUPXRoaXMuYm9keS5ub2Rlc1tFLmNsdXN0ZXJJZF07VC5jb250YWluZWRFZGdlc1tTLmlkXT1TLGRlbGV0ZSBkW1MuaWRdO3ZhciBNPVMuZnJvbUlkLFA9Uy50b0lkO1MudG9JZD09eD9QPUUuY2x1c3RlcklkOk09RS5jbHVzdGVySWQsdGhpcy5fY3JlYXRlQ2x1c3RlcmVkRWRnZShNLFAsUyxULmNsdXN0ZXJFZGdlUHJvcGVydGllcyx7aGlkZGVuOiExLHBoeXNpY3M6ITB9KX1lbHNlIHRoaXMuX3Jlc3RvcmVFZGdlKFMpfV8ucmVtb3ZlKCl9Zm9yKHZhciBEIGluIGQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGQsRCkmJnRoaXMuX3Jlc3RvcmVFZGdlKGRbRF0pO2RlbGV0ZSB0aGlzLmJvZHkubm9kZXNbdF0sITA9PT1pJiZ0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpfX0se2tleTpcImdldE5vZGVzSW5DbHVzdGVyXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9W107aWYoITA9PT10aGlzLmlzQ2x1c3Rlcih0KSl7dmFyIGk9dGhpcy5ib2R5Lm5vZGVzW3RdLmNvbnRhaW5lZE5vZGVzO2Zvcih2YXIgbyBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLG8pJiZlLnB1c2godGhpcy5ib2R5Lm5vZGVzW29dLmlkKX1yZXR1cm4gZX19LHtrZXk6XCJmaW5kTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxpPVtdLG89MDt2b2lkIDAhPT10aGlzLmNsdXN0ZXJlZE5vZGVzW3RdJiZvPDEwMDspe2lmKHZvaWQgMD09PShlPXRoaXMuYm9keS5ub2Rlc1t0XSkpcmV0dXJuW107aS5wdXNoKGUuaWQpLHQ9dGhpcy5jbHVzdGVyZWROb2Rlc1t0XS5jbHVzdGVySWQsbysrfXJldHVybiB2b2lkIDA9PT0oZT10aGlzLmJvZHkubm9kZXNbdF0pP1tdOihpLnB1c2goZS5pZCksTm4oaSkuY2FsbChpKSxpKX19LHtrZXk6XCJ1cGRhdGVDbHVzdGVyZWROb2RlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZih2b2lkIDA9PT10KXRocm93IG5ldyBFcnJvcihcIk5vIGNsdXN0ZXJlZE5vZGVJZCBzdXBwbGllZCB0byB1cGRhdGVDbHVzdGVyZWROb2RlLlwiKTtpZih2b2lkIDA9PT1lKXRocm93IG5ldyBFcnJvcihcIk5vIG5ld09wdGlvbnMgc3VwcGxpZWQgdG8gdXBkYXRlQ2x1c3RlcmVkTm9kZS5cIik7aWYodm9pZCAwPT09dGhpcy5ib2R5Lm5vZGVzW3RdKXRocm93IG5ldyBFcnJvcihcIlRoZSBjbHVzdGVyZWROb2RlSWQgc3VwcGxpZWQgdG8gdXBkYXRlQ2x1c3RlcmVkTm9kZSBkb2VzIG5vdCBleGlzdC5cIik7dGhpcy5ib2R5Lm5vZGVzW3RdLnNldE9wdGlvbnMoZSksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKX19LHtrZXk6XCJ1cGRhdGVFZGdlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZih2b2lkIDA9PT10KXRocm93IG5ldyBFcnJvcihcIk5vIHN0YXJ0RWRnZUlkIHN1cHBsaWVkIHRvIHVwZGF0ZUVkZ2UuXCIpO2lmKHZvaWQgMD09PWUpdGhyb3cgbmV3IEVycm9yKFwiTm8gbmV3T3B0aW9ucyBzdXBwbGllZCB0byB1cGRhdGVFZGdlLlwiKTtpZih2b2lkIDA9PT10aGlzLmJvZHkuZWRnZXNbdF0pdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0YXJ0RWRnZUlkIHN1cHBsaWVkIHRvIHVwZGF0ZUVkZ2UgZG9lcyBub3QgZXhpc3QuXCIpO2Zvcih2YXIgaT10aGlzLmdldENsdXN0ZXJlZEVkZ2VzKHQpLG89MDtvPGkubGVuZ3RoO28rKyl7dGhpcy5ib2R5LmVkZ2VzW2lbb11dLnNldE9wdGlvbnMoZSl9dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKX19LHtrZXk6XCJnZXRDbHVzdGVyZWRFZGdlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxpPTA7dm9pZCAwIT09dCYmdm9pZCAwIT09dGhpcy5ib2R5LmVkZ2VzW3RdJiZpPDEwMDspZS5wdXNoKHRoaXMuYm9keS5lZGdlc1t0XS5pZCksdD10aGlzLmJvZHkuZWRnZXNbdF0uZWRnZVJlcGxhY2VkQnlJZCxpKys7cmV0dXJuIE5uKGUpLmNhbGwoZSksZX19LHtrZXk6XCJnZXRCYXNlRWRnZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldEJhc2VFZGdlcyh0KVswXX19LHtrZXk6XCJnZXRCYXNlRWRnZXNcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9W3RdLGk9W10sbz1bXSxuPTA7ZS5sZW5ndGg+MCYmbjwxMDA7KXt2YXIgcj1lLnBvcCgpO2lmKHZvaWQgMCE9PXIpe3ZhciBzPXRoaXMuYm9keS5lZGdlc1tyXTtpZih2b2lkIDAhPT1zKXtuKys7dmFyIGE9cy5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcztpZih2b2lkIDA9PT1hKW8ucHVzaChyKTtlbHNlIGZvcih2YXIgaD0wO2g8YS5sZW5ndGg7KytoKXt2YXIgZD1hW2hdOy0xPT09TXIoZSkuY2FsbChlLGEpJiYtMT09PU1yKGkpLmNhbGwoaSxhKSYmZS5wdXNoKGQpfWkucHVzaChyKX19fXJldHVybiBvfX0se2tleTpcIl9nZXRDb25uZWN0ZWRJZFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQudG9JZCE9ZT90LnRvSWQ6KHQuZnJvbUlkLHQuZnJvbUlkKX19LHtrZXk6XCJfZ2V0SHViU2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wLGk9MCxvPTAsbj0wO248dGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDtuKyspe3ZhciByPXRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbbl1dO3IuZWRnZXMubGVuZ3RoPm8mJihvPXIuZWRnZXMubGVuZ3RoKSx0Kz1yLmVkZ2VzLmxlbmd0aCxlKz1NYXRoLnBvdyhyLmVkZ2VzLmxlbmd0aCwyKSxpKz0xfXQvPWk7dmFyIHM9KGUvPWkpLU1hdGgucG93KHQsMiksYT1NYXRoLnNxcnQocyksaD1NYXRoLmZsb29yKHQrMiphKTtyZXR1cm4gaD5vJiYoaD1vKSxofX0se2tleTpcIl9jcmVhdGVDbHVzdGVyZWRFZGdlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyxuKXt2YXIgcj13dS5jbG9uZU9wdGlvbnMoaSxcImVkZ2VcIik7dGgocixvKSxyLmZyb209dCxyLnRvPWUsci5pZD1cImNsdXN0ZXJFZGdlOlwiK2J1KCksdm9pZCAwIT09biYmdGgocixuKTt2YXIgcz10aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2Uocik7cmV0dXJuIHMuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHM9W2kuaWRdLHMuY29ubmVjdCgpLHRoaXMuYm9keS5lZGdlc1tzLmlkXT1zLHN9fSx7a2V5OlwiX2NsdXN0ZXJFZGdlc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxpLG8pe2lmKGUgaW5zdGFuY2VvZiBKYyl7dmFyIG49ZSxyPXt9O3Jbbi5pZF09bixlPXJ9aWYodCBpbnN0YW5jZW9mIGxjKXt2YXIgcz10LGE9e307YVtzLmlkXT1zLHQ9YX1pZihudWxsPT1pKXRocm93IG5ldyBFcnJvcihcIl9jbHVzdGVyRWRnZXM6IHBhcmFtZXRlciBjbHVzdGVyTm9kZSByZXF1aXJlZFwiKTtmb3IodmFyIGggaW4gdm9pZCAwPT09byYmKG89aS5jbHVzdGVyRWRnZVByb3BlcnRpZXMpLHRoaXMuX2NyZWF0ZUNsdXN0ZXJFZGdlcyh0LGUsaSxvKSxlKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLGgpJiZ2b2lkIDAhPT10aGlzLmJvZHkuZWRnZXNbaF0pe3ZhciBkPXRoaXMuYm9keS5lZGdlc1toXTt0aGlzLl9iYWNrdXBFZGdlT3B0aW9ucyhkKSxkLnNldE9wdGlvbnMoe3BoeXNpY3M6ITF9KX1mb3IodmFyIGwgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxsKSYmKHRoaXMuY2x1c3RlcmVkTm9kZXNbbF09e2NsdXN0ZXJJZDppLmlkLG5vZGU6dGhpcy5ib2R5Lm5vZGVzW2xdfSx0aGlzLmJvZHkubm9kZXNbbF0uc2V0T3B0aW9ucyh7cGh5c2ljczohMX0pKX19LHtrZXk6XCJfZ2V0Q2x1c3Rlck5vZGVGb3JOb2RlXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dCl7dmFyIGU9dGhpcy5jbHVzdGVyZWROb2Rlc1t0XTtpZih2b2lkIDAhPT1lKXt2YXIgaT1lLmNsdXN0ZXJJZDtpZih2b2lkIDAhPT1pKXJldHVybiB0aGlzLmJvZHkubm9kZXNbaV19fX19LHtrZXk6XCJfZmlsdGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT1bXTtyZXR1cm4gbmgodCwoZnVuY3Rpb24odCl7ZSh0KSYmaS5wdXNoKHQpfSkpLGl9fSx7a2V5OlwiX3VwZGF0ZVN0YXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlPXRoaXMsaT1bXSxvPXt9LG49ZnVuY3Rpb24odCl7bmgoZS5ib2R5Lm5vZGVzLChmdW5jdGlvbihlKXshMD09PWUuaXNDbHVzdGVyJiZ0KGUpfSkpfTtmb3IodCBpbiB0aGlzLmNsdXN0ZXJlZE5vZGVzKXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jbHVzdGVyZWROb2Rlcyx0KSl2b2lkIDA9PT10aGlzLmJvZHkubm9kZXNbdF0mJmkucHVzaCh0KX1uKChmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPGkubGVuZ3RoO2UrKylkZWxldGUgdC5jb250YWluZWROb2Rlc1tpW2VdXX0pKTtmb3IodmFyIHI9MDtyPGkubGVuZ3RoO3IrKylkZWxldGUgdGhpcy5jbHVzdGVyZWROb2Rlc1tpW3JdXTtuaCh0aGlzLmNsdXN0ZXJlZEVkZ2VzLChmdW5jdGlvbih0KXt2YXIgaT1lLmJvZHkuZWRnZXNbdF07dm9pZCAwIT09aSYmaS5lbmRQb2ludHNWYWxpZCgpfHwob1t0XT10KX0pKSxuKChmdW5jdGlvbih0KXtuaCh0LmNvbnRhaW5lZEVkZ2VzLChmdW5jdGlvbih0LGUpe3QuZW5kUG9pbnRzVmFsaWQoKXx8b1tlXXx8KG9bZV09ZSl9KSl9KSksbmgodGhpcy5ib2R5LmVkZ2VzLChmdW5jdGlvbih0LGkpe3ZhciBuPSEwLHI9dC5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcztpZih2b2lkIDAhPT1yKXt2YXIgcz0wO25oKHIsKGZ1bmN0aW9uKHQpe3ZhciBpPWUuYm9keS5lZGdlc1t0XTt2b2lkIDAhPT1pJiZpLmVuZFBvaW50c1ZhbGlkKCkmJihzKz0xKX0pKSxuPXM+MH10LmVuZFBvaW50c1ZhbGlkKCkmJm58fChvW2ldPWkpfSkpLG4oKGZ1bmN0aW9uKHQpe25oKG8sKGZ1bmN0aW9uKGkpe2RlbGV0ZSB0LmNvbnRhaW5lZEVkZ2VzW2ldLG5oKHQuZWRnZXMsKGZ1bmN0aW9uKG4scil7bi5pZCE9PWk/bi5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcz1lLl9maWx0ZXIobi5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcywoZnVuY3Rpb24odCl7cmV0dXJuIW9bdF19KSk6dC5lZGdlc1tyXT1udWxsfSkpLHQuZWRnZXM9ZS5fZmlsdGVyKHQuZWRnZXMsKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT09dH0pKX0pKX0pKSxuaChvLChmdW5jdGlvbih0KXtkZWxldGUgZS5jbHVzdGVyZWRFZGdlc1t0XX0pKSxuaChvLChmdW5jdGlvbih0KXtkZWxldGUgZS5ib2R5LmVkZ2VzW3RdfSkpLG5oKHhuKHRoaXMuYm9keS5lZGdlcyksKGZ1bmN0aW9uKHQpe3ZhciBpPWUuYm9keS5lZGdlc1t0XSxvPWUuX2lzQ2x1c3RlcmVkTm9kZShpLmZyb21JZCl8fGUuX2lzQ2x1c3RlcmVkTm9kZShpLnRvSWQpO2lmKG8hPT1lLl9pc0NsdXN0ZXJlZEVkZ2UoaS5pZCkpaWYobyl7dmFyIG49ZS5fZ2V0Q2x1c3Rlck5vZGVGb3JOb2RlKGkuZnJvbUlkKTt2b2lkIDAhPT1uJiZlLl9jbHVzdGVyRWRnZXMoZS5ib2R5Lm5vZGVzW2kuZnJvbUlkXSxpLG4pO3ZhciByPWUuX2dldENsdXN0ZXJOb2RlRm9yTm9kZShpLnRvSWQpO3ZvaWQgMCE9PXImJmUuX2NsdXN0ZXJFZGdlcyhlLmJvZHkubm9kZXNbaS50b0lkXSxpLHIpfWVsc2UgZGVsZXRlIGUuX2NsdXN0ZXJFZGdlc1t0XSxlLl9yZXN0b3JlRWRnZShpKX0pKTtmb3IodmFyIHM9ITEsYT0hMCxoPWZ1bmN0aW9uKCl7dmFyIHQ9W107bigoZnVuY3Rpb24oZSl7dmFyIGk9eG4oZS5jb250YWluZWROb2RlcykubGVuZ3RoLG89ITA9PT1lLm9wdGlvbnMuYWxsb3dTaW5nbGVOb2RlQ2x1c3RlcjsobyYmaTwxfHwhbyYmaTwyKSYmdC5wdXNoKGUuaWQpfSkpO2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7KytpKWUub3BlbkNsdXN0ZXIodFtpXSx7fSwhMSk7YT10Lmxlbmd0aD4wLHM9c3x8YX07YTspaCgpO3MmJnRoaXMuX3VwZGF0ZVN0YXRlKCl9fSx7a2V5OlwiX2lzQ2x1c3RlcmVkTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10aGlzLmNsdXN0ZXJlZE5vZGVzW3RdfX0se2tleTpcIl9pc0NsdXN0ZXJlZEVkZ2VcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dGhpcy5jbHVzdGVyZWRFZGdlc1t0XX19XSksdH0oKTtmdW5jdGlvbiBFdSh0LGUpe3ZhciBpO2lmKHZvaWQgMD09PWNufHxudWxsPT1DaSh0KSl7aWYoZ24odCl8fChpPWZ1bmN0aW9uKHQsZSl7dmFyIGk7aWYoIXQpcmV0dXJuO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXJldHVybiBPdSh0LGUpO3ZhciBvPXZuKGk9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKS5jYWxsKGksOCwtMSk7XCJPYmplY3RcIj09PW8mJnQuY29uc3RydWN0b3ImJihvPXQuY29uc3RydWN0b3IubmFtZSk7aWYoXCJNYXBcIj09PW98fFwiU2V0XCI9PT1vKXJldHVybiBtaSh0KTtpZihcIkFyZ3VtZW50c1wiPT09b3x8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobykpcmV0dXJuIE91KHQsZSl9KHQpKXx8ZSYmdCYmXCJudW1iZXJcIj09dHlwZW9mIHQubGVuZ3RoKXtpJiYodD1pKTt2YXIgbz0wLG49ZnVuY3Rpb24oKXt9O3JldHVybntzOm4sbjpmdW5jdGlvbigpe3JldHVybiBvPj10Lmxlbmd0aD97ZG9uZTohMH06e2RvbmU6ITEsdmFsdWU6dFtvKytdfX0sZTpmdW5jdGlvbih0KXt0aHJvdyB0fSxmOm59fXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX12YXIgcixzPSEwLGE9ITE7cmV0dXJue3M6ZnVuY3Rpb24oKXtpPVNpKHQpfSxuOmZ1bmN0aW9uKCl7dmFyIHQ9aS5uZXh0KCk7cmV0dXJuIHM9dC5kb25lLHR9LGU6ZnVuY3Rpb24odCl7YT0hMCxyPXR9LGY6ZnVuY3Rpb24oKXt0cnl7c3x8bnVsbD09aS5yZXR1cm58fGkucmV0dXJuKCl9ZmluYWxseXtpZihhKXRocm93IHJ9fX19ZnVuY3Rpb24gT3UodCxlKXsobnVsbD09ZXx8ZT50Lmxlbmd0aCkmJihlPXQubGVuZ3RoKTtmb3IodmFyIGk9MCxvPW5ldyBBcnJheShlKTtpPGU7aSsrKW9baV09dFtpXTtyZXR1cm4gb312YXIgQ3U9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsaSl7dmFyIG87UG8odGhpcyx0KSx2b2lkIDAhPT13aW5kb3cmJihvPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSksd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZT12b2lkIDA9PT1vP2Z1bmN0aW9uKHQpe3QoKX06byx0aGlzLmJvZHk9ZSx0aGlzLmNhbnZhcz1pLHRoaXMucmVkcmF3UmVxdWVzdGVkPSExLHRoaXMucmVuZGVyVGltZXI9dm9pZCAwLHRoaXMucmVxdWlyZXNUaW1lb3V0PSEwLHRoaXMucmVuZGVyaW5nQWN0aXZlPSExLHRoaXMucmVuZGVyUmVxdWVzdHM9MCx0aGlzLmFsbG93UmVkcmF3PSEwLHRoaXMuZHJhZ2dpbmc9ITEsdGhpcy56b29taW5nPSExLHRoaXMub3B0aW9ucz17fSx0aGlzLmRlZmF1bHRPcHRpb25zPXtoaWRlRWRnZXNPbkRyYWc6ITEsaGlkZUVkZ2VzT25ab29tOiExLGhpZGVOb2Rlc09uRHJhZzohMX0sY3QodGhpcy5vcHRpb25zLHRoaXMuZGVmYXVsdE9wdGlvbnMpLHRoaXMuX2RldGVybWluZUJyb3dzZXJNZXRob2QoKSx0aGlzLmJpbmRFdmVudExpc3RlbmVycygpfXJldHVybiBJbyh0LFt7a2V5OlwiYmluZEV2ZW50TGlzdGVuZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlPXRoaXM7dGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkcmFnU3RhcnRcIiwoZnVuY3Rpb24oKXtlLmRyYWdnaW5nPSEwfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZHJhZ0VuZFwiLChmdW5jdGlvbigpe2UuZHJhZ2dpbmc9ITF9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJ6b29tXCIsKGZ1bmN0aW9uKCl7ZS56b29taW5nPSEwLHdpbmRvdy5jbGVhclRpbWVvdXQoZS56b29tVGltZW91dElkKSxlLnpvb21UaW1lb3V0SWQ9cXIoKGZ1bmN0aW9uKCl7dmFyIHQ7ZS56b29taW5nPSExLGJ0KHQ9ZS5fcmVxdWVzdFJlZHJhdykuY2FsbCh0LGUpKCl9KSwyNTApfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3Jlc2l6ZU5vZGVzXCIsKGZ1bmN0aW9uKCl7ZS5fcmVzaXplTm9kZXMoKX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZWRyYXdcIiwoZnVuY3Rpb24oKXshMT09PWUucmVuZGVyaW5nQWN0aXZlJiZlLl9yZWRyYXcoKX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9ibG9ja1JlZHJhd1wiLChmdW5jdGlvbigpe2UuYWxsb3dSZWRyYXc9ITF9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfYWxsb3dSZWRyYXdcIiwoZnVuY3Rpb24oKXtlLmFsbG93UmVkcmF3PSEwLGUucmVkcmF3UmVxdWVzdGVkPSExfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3JlcXVlc3RSZWRyYXdcIixidCh0PXRoaXMuX3JlcXVlc3RSZWRyYXcpLmNhbGwodCx0aGlzKSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfc3RhcnRSZW5kZXJpbmdcIiwoZnVuY3Rpb24oKXtlLnJlbmRlclJlcXVlc3RzKz0xLGUucmVuZGVyaW5nQWN0aXZlPSEwLGUuX3N0YXJ0UmVuZGVyaW5nKCl9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfc3RvcFJlbmRlcmluZ1wiLChmdW5jdGlvbigpe2UucmVuZGVyUmVxdWVzdHMtPTEsZS5yZW5kZXJpbmdBY3RpdmU9ZS5yZW5kZXJSZXF1ZXN0cz4wLGUucmVuZGVyVGltZXI9dm9pZCAwfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLChmdW5jdGlvbigpe2UucmVuZGVyUmVxdWVzdHM9MCxlLmFsbG93UmVkcmF3PSExLGUucmVuZGVyaW5nQWN0aXZlPSExLCEwPT09ZS5yZXF1aXJlc1RpbWVvdXQ/Y2xlYXJUaW1lb3V0KGUucmVuZGVyVGltZXIpOndpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShlLnJlbmRlclRpbWVyKSxlLmJvZHkuZW1pdHRlci5vZmYoKX0pKX19LHtrZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dCl7WmEoW1wiaGlkZUVkZ2VzT25EcmFnXCIsXCJoaWRlRWRnZXNPblpvb21cIixcImhpZGVOb2Rlc09uRHJhZ1wiXSx0aGlzLm9wdGlvbnMsdCl9fX0se2tleTpcIl9yZXF1ZXN0TmV4dEZyYW1lXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93KXt2YXIgaSxvPXdpbmRvdztyZXR1cm4hMD09PXRoaXMucmVxdWlyZXNUaW1lb3V0P2k9cXIodCxlKTpvLnJlcXVlc3RBbmltYXRpb25GcmFtZSYmKGk9by5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodCkpLGl9fX0se2tleTpcIl9zdGFydFJlbmRlcmluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ7ITA9PT10aGlzLnJlbmRlcmluZ0FjdGl2ZSYmKHZvaWQgMD09PXRoaXMucmVuZGVyVGltZXImJih0aGlzLnJlbmRlclRpbWVyPXRoaXMuX3JlcXVlc3ROZXh0RnJhbWUoYnQodD10aGlzLl9yZW5kZXJTdGVwKS5jYWxsKHQsdGhpcyksdGhpcy5zaW11bGF0aW9uSW50ZXJ2YWwpKSl9fSx7a2V5OlwiX3JlbmRlclN0ZXBcIix2YWx1ZTpmdW5jdGlvbigpeyEwPT09dGhpcy5yZW5kZXJpbmdBY3RpdmUmJih0aGlzLnJlbmRlclRpbWVyPXZvaWQgMCwhMD09PXRoaXMucmVxdWlyZXNUaW1lb3V0JiZ0aGlzLl9zdGFydFJlbmRlcmluZygpLHRoaXMuX3JlZHJhdygpLCExPT09dGhpcy5yZXF1aXJlc1RpbWVvdXQmJnRoaXMuX3N0YXJ0UmVuZGVyaW5nKCkpfX0se2tleTpcInJlZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInNldFNpemVcIiksdGhpcy5fcmVkcmF3KCl9fSx7a2V5OlwiX3JlcXVlc3RSZWRyYXdcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7ITAhPT10aGlzLnJlZHJhd1JlcXVlc3RlZCYmITE9PT10aGlzLnJlbmRlcmluZ0FjdGl2ZSYmITA9PT10aGlzLmFsbG93UmVkcmF3JiYodGhpcy5yZWRyYXdSZXF1ZXN0ZWQ9ITAsdGhpcy5fcmVxdWVzdE5leHRGcmFtZSgoZnVuY3Rpb24oKXt0Ll9yZWRyYXcoITEpfSksMCkpfX0se2tleTpcIl9yZWRyYXdcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF07aWYoITA9PT10aGlzLmFsbG93UmVkcmF3KXt0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaW5pdFJlZHJhd1wiKSx0aGlzLnJlZHJhd1JlcXVlc3RlZD0hMTt2YXIgZT17ZHJhd0V4dGVybmFsTGFiZWxzOm51bGx9OzAhPT10aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMud2lkdGgmJjAhPT10aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuaGVpZ2h0fHx0aGlzLmNhbnZhcy5zZXRTaXplKCksdGhpcy5jYW52YXMuc2V0VHJhbnNmb3JtKCk7dmFyIGk9dGhpcy5jYW52YXMuZ2V0Q29udGV4dCgpLG89dGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLG49dGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodDtpZihpLmNsZWFyUmVjdCgwLDAsbyxuKSwwPT09dGhpcy5jYW52YXMuZnJhbWUuY2xpZW50V2lkdGgpcmV0dXJuO2lmKGkuc2F2ZSgpLGkudHJhbnNsYXRlKHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLngsdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSksaS5zY2FsZSh0aGlzLmJvZHkudmlldy5zY2FsZSx0aGlzLmJvZHkudmlldy5zY2FsZSksaS5iZWdpblBhdGgoKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYmVmb3JlRHJhd2luZ1wiLGkpLGkuY2xvc2VQYXRoKCksITE9PT10JiYoITE9PT10aGlzLmRyYWdnaW5nfHwhMD09PXRoaXMuZHJhZ2dpbmcmJiExPT09dGhpcy5vcHRpb25zLmhpZGVFZGdlc09uRHJhZykmJighMT09PXRoaXMuem9vbWluZ3x8ITA9PT10aGlzLnpvb21pbmcmJiExPT09dGhpcy5vcHRpb25zLmhpZGVFZGdlc09uWm9vbSkmJnRoaXMuX2RyYXdFZGdlcyhpKSwhMT09PXRoaXMuZHJhZ2dpbmd8fCEwPT09dGhpcy5kcmFnZ2luZyYmITE9PT10aGlzLm9wdGlvbnMuaGlkZU5vZGVzT25EcmFnKXt2YXIgcj10aGlzLl9kcmF3Tm9kZXMoaSx0KSxzPXIuZHJhd0V4dGVybmFsTGFiZWxzO2UuZHJhd0V4dGVybmFsTGFiZWxzPXN9ITE9PT10JiYoITE9PT10aGlzLmRyYWdnaW5nfHwhMD09PXRoaXMuZHJhZ2dpbmcmJiExPT09dGhpcy5vcHRpb25zLmhpZGVFZGdlc09uRHJhZykmJighMT09PXRoaXMuem9vbWluZ3x8ITA9PT10aGlzLnpvb21pbmcmJiExPT09dGhpcy5vcHRpb25zLmhpZGVFZGdlc09uWm9vbSkmJnRoaXMuX2RyYXdBcnJvd3MoaSksbnVsbCE9ZS5kcmF3RXh0ZXJuYWxMYWJlbHMmJmUuZHJhd0V4dGVybmFsTGFiZWxzKCksITE9PT10JiZ0aGlzLl9kcmF3U2VsZWN0aW9uQm94KGkpLGkuYmVnaW5QYXRoKCksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImFmdGVyRHJhd2luZ1wiLGkpLGkuY2xvc2VQYXRoKCksaS5yZXN0b3JlKCksITA9PT10JiZpLmNsZWFyUmVjdCgwLDAsbyxuKX19fSx7a2V5OlwiX3Jlc2l6ZU5vZGVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmNhbnZhcy5zZXRUcmFuc2Zvcm0oKTt2YXIgdD10aGlzLmNhbnZhcy5nZXRDb250ZXh0KCk7dC5zYXZlKCksdC50cmFuc2xhdGUodGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCx0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KSx0LnNjYWxlKHRoaXMuYm9keS52aWV3LnNjYWxlLHRoaXMuYm9keS52aWV3LnNjYWxlKTt2YXIgZSxpPXRoaXMuYm9keS5ub2Rlcztmb3IodmFyIG8gaW4gaSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSxvKSYmKChlPWlbb10pLnJlc2l6ZSh0KSxlLnVwZGF0ZUJvdW5kaW5nQm94KHQsZS5zZWxlY3RlZCkpO3QucmVzdG9yZSgpfX0se2tleTpcIl9kcmF3Tm9kZXNcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGUsaSxvPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV0sbj10aGlzLmJvZHkubm9kZXMscj10aGlzLmJvZHkubm9kZUluZGljZXMscz1bXSxhPVtdLGg9MjAsZD10aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7eDotaCx5Oi1ofSksbD10aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7eDp0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgraCx5OnRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQraH0pLGM9e3RvcDpkLnksbGVmdDpkLngsYm90dG9tOmwueSxyaWdodDpsLnh9LHU9W10sZj0wO2Y8ci5sZW5ndGg7ZisrKWlmKChlPW5bcltmXV0pLmhvdmVyKWEucHVzaChyW2ZdKTtlbHNlIGlmKGUuaXNTZWxlY3RlZCgpKXMucHVzaChyW2ZdKTtlbHNlIGlmKCEwPT09byl7dmFyIHA9ZS5kcmF3KHQpO251bGwhPXAuZHJhd0V4dGVybmFsTGFiZWwmJnUucHVzaChwLmRyYXdFeHRlcm5hbExhYmVsKX1lbHNlIGlmKCEwPT09ZS5pc0JvdW5kaW5nQm94T3ZlcmxhcHBpbmdXaXRoKGMpKXt2YXIgdj1lLmRyYXcodCk7bnVsbCE9di5kcmF3RXh0ZXJuYWxMYWJlbCYmdS5wdXNoKHYuZHJhd0V4dGVybmFsTGFiZWwpfWVsc2UgZS51cGRhdGVCb3VuZGluZ0JveCh0LGUuc2VsZWN0ZWQpO3ZhciBnPXMubGVuZ3RoLHk9YS5sZW5ndGg7Zm9yKGk9MDtpPGc7aSsrKXt2YXIgbT0oZT1uW3NbaV1dKS5kcmF3KHQpO251bGwhPW0uZHJhd0V4dGVybmFsTGFiZWwmJnUucHVzaChtLmRyYXdFeHRlcm5hbExhYmVsKX1mb3IoaT0wO2k8eTtpKyspe3ZhciBiPShlPW5bYVtpXV0pLmRyYXcodCk7bnVsbCE9Yi5kcmF3RXh0ZXJuYWxMYWJlbCYmdS5wdXNoKGIuZHJhd0V4dGVybmFsTGFiZWwpfXJldHVybntkcmF3RXh0ZXJuYWxMYWJlbHM6ZnVuY3Rpb24oKXt2YXIgdCxlPUV1KHUpO3RyeXtmb3IoZS5zKCk7ISh0PWUubigpKS5kb25lOyl7KDAsdC52YWx1ZSkoKX19Y2F0Y2godCl7ZS5lKHQpfWZpbmFsbHl7ZS5mKCl9fX19fSx7a2V5OlwiX2RyYXdFZGdlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmJvZHkuZWRnZXMsaT10aGlzLmJvZHkuZWRnZUluZGljZXMsbz0wO288aS5sZW5ndGg7bysrKXt2YXIgbj1lW2lbb11dOyEwPT09bi5jb25uZWN0ZWQmJm4uZHJhdyh0KX19fSx7a2V5OlwiX2RyYXdBcnJvd3NcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5ib2R5LmVkZ2VzLGk9dGhpcy5ib2R5LmVkZ2VJbmRpY2VzLG89MDtvPGkubGVuZ3RoO28rKyl7dmFyIG49ZVtpW29dXTshMD09PW4uY29ubmVjdGVkJiZuLmRyYXdBcnJvd3ModCl9fX0se2tleTpcIl9kZXRlcm1pbmVCcm93c2VyTWV0aG9kXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93KXt2YXIgdD1uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7dGhpcy5yZXF1aXJlc1RpbWVvdXQ9ITEsKC0xIT1Ncih0KS5jYWxsKHQsXCJtc2llIDkuMFwiKXx8LTEhPU1yKHQpLmNhbGwodCxcInNhZmFyaVwiKSYmTXIodCkuY2FsbCh0LFwiY2hyb21lXCIpPD0tMSkmJih0aGlzLnJlcXVpcmVzVGltZW91dD0hMCl9ZWxzZSB0aGlzLnJlcXVpcmVzVGltZW91dD0hMH19LHtrZXk6XCJfZHJhd1NlbGVjdGlvbkJveFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHRoaXMuYm9keS5zZWxlY3Rpb25Cb3guc2hvdyl7dC5iZWdpblBhdGgoKTt2YXIgZT10aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLmVuZC54LXRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQueCxpPXRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uZW5kLnktdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC55O3QucmVjdCh0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0LngsdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC55LGUsaSksdC5maWxsU3R5bGU9XCJyZ2JhKDE1MSwgMTk0LCAyNTIsIDAuMilcIix0LmZpbGxSZWN0KHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQueCx0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0LnksZSxpKSx0LnN0cm9rZVN0eWxlPVwicmdiYSgxNTEsIDE5NCwgMjUyLCAxKVwiLHQuc3Ryb2tlKCl9ZWxzZSB0LmNsb3NlUGF0aCgpfX1dKSx0fSgpLFN1PUYuc2V0SW50ZXJ2YWw7ZnVuY3Rpb24gVHUodCxlKXtlLmlucHV0SGFuZGxlcj1mdW5jdGlvbih0KXt0LmlzRmlyc3QmJmUodCl9LHQub24oXCJoYW1tZXIuaW5wdXRcIixlLmlucHV0SGFuZGxlcil9ZnVuY3Rpb24gTXUodCxlKXtyZXR1cm4gZS5pbnB1dEhhbmRsZXI9ZnVuY3Rpb24odCl7dC5pc0ZpbmFsJiZlKHQpfSx0Lm9uKFwiaGFtbWVyLmlucHV0XCIsZS5pbnB1dEhhbmRsZXIpfXZhciBQdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7UG8odGhpcyx0KSx0aGlzLmJvZHk9ZSx0aGlzLnBpeGVsUmF0aW89MSx0aGlzLmNhbWVyYVN0YXRlPXt9LHRoaXMuaW5pdGlhbGl6ZWQ9ITEsdGhpcy5jYW52YXNWaWV3Q2VudGVyPXt9LHRoaXMuX2NsZWFudXBDYWxsYmFja3M9W10sdGhpcy5vcHRpb25zPXt9LHRoaXMuZGVmYXVsdE9wdGlvbnM9e2F1dG9SZXNpemU6ITAsaGVpZ2h0OlwiMTAwJVwiLHdpZHRoOlwiMTAwJVwifSxjdCh0aGlzLm9wdGlvbnMsdGhpcy5kZWZhdWx0T3B0aW9ucyksdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKX1yZXR1cm4gSW8odCxbe2tleTpcImJpbmRFdmVudExpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZT10aGlzO3RoaXMuYm9keS5lbWl0dGVyLm9uY2UoXCJyZXNpemVcIiwoZnVuY3Rpb24odCl7MCE9PXQud2lkdGgmJihlLmJvZHkudmlldy50cmFuc2xhdGlvbi54PS41KnQud2lkdGgpLDAhPT10LmhlaWdodCYmKGUuYm9keS52aWV3LnRyYW5zbGF0aW9uLnk9LjUqdC5oZWlnaHQpfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwic2V0U2l6ZVwiLGJ0KHQ9dGhpcy5zZXRTaXplKS5jYWxsKHQsdGhpcykpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLChmdW5jdGlvbigpe2UuaGFtbWVyRnJhbWUuZGVzdHJveSgpLGUuaGFtbWVyLmRlc3Ryb3koKSxlLl9jbGVhblVwKCl9KSl9fSx7a2V5Olwic2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlLGksbyxuLHIscz10aGlzO2lmKHZvaWQgMCE9PXQpe1phKFtcIndpZHRoXCIsXCJoZWlnaHRcIixcImF1dG9SZXNpemVcIl0sdGhpcy5vcHRpb25zLHQpfWlmKHRoaXMuX2NsZWFuVXAoKSwhMD09PXRoaXMub3B0aW9ucy5hdXRvUmVzaXplKXt2YXIgYTtpZih3aW5kb3cuUmVzaXplT2JzZXJ2ZXIpe3ZhciBoPW5ldyBSZXNpemVPYnNlcnZlcigoZnVuY3Rpb24oKXshMD09PXMuc2V0U2l6ZSgpJiZzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIil9KSksZD10aGlzLmZyYW1lO2gub2JzZXJ2ZShkKSx0aGlzLl9jbGVhbnVwQ2FsbGJhY2tzLnB1c2goKGZ1bmN0aW9uKCl7aC51bm9ic2VydmUoZCl9KSl9ZWxzZXt2YXIgbD1TdSgoZnVuY3Rpb24oKXshMD09PXMuc2V0U2l6ZSgpJiZzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIil9KSwxZTMpO3RoaXMuX2NsZWFudXBDYWxsYmFja3MucHVzaCgoZnVuY3Rpb24oKXtjbGVhckludGVydmFsKGwpfSkpfXZhciBjPWJ0KGE9dGhpcy5fb25SZXNpemUpLmNhbGwoYSx0aGlzKTtlPXdpbmRvdyxpPVwicmVzaXplXCIsbz1jLGUuYWRkRXZlbnRMaXN0ZW5lcj8odm9pZCAwPT09biYmKG49ITEpLFwibW91c2V3aGVlbFwiPT09aSYmSm4ocj1uYXZpZ2F0b3IudXNlckFnZW50KS5jYWxsKHIsXCJGaXJlZm94XCIpJiYoaT1cIkRPTU1vdXNlU2Nyb2xsXCIpLGUuYWRkRXZlbnRMaXN0ZW5lcihpLG8sbikpOmUuYXR0YWNoRXZlbnQoXCJvblwiK2ksbyksdGhpcy5fY2xlYW51cENhbGxiYWNrcy5wdXNoKChmdW5jdGlvbigpeyFmdW5jdGlvbih0LGUsaSxvKXt2YXIgbjt0LnJlbW92ZUV2ZW50TGlzdGVuZXI/KHZvaWQgMD09PW8mJihvPSExKSxcIm1vdXNld2hlZWxcIj09PWUmJkpuKG49bmF2aWdhdG9yLnVzZXJBZ2VudCkuY2FsbChuLFwiRmlyZWZveFwiKSYmKGU9XCJET01Nb3VzZVNjcm9sbFwiKSx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSxpLG8pKTp0LmRldGFjaEV2ZW50KFwib25cIitlLGkpfSh3aW5kb3csXCJyZXNpemVcIixjKX0pKX19fSx7a2V5OlwiX2NsZWFuVXBcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGUsaTtEbih0PU5uKGU9cW4oaT10aGlzLl9jbGVhbnVwQ2FsbGJhY2tzKS5jYWxsKGksMCkpLmNhbGwoZSkpLmNhbGwodCwoZnVuY3Rpb24odCl7dHJ5e3QoKX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKHQpfX0pKX19LHtrZXk6XCJfb25SZXNpemVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2V0U2l6ZSgpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpfX0se2tleTpcIl9nZXRDYW1lcmFTdGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnRoaXMucGl4ZWxSYXRpbzshMD09PXRoaXMuaW5pdGlhbGl6ZWQmJih0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzV2lkdGg9dGhpcy5mcmFtZS5jYW52YXMud2lkdGgvdCx0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzSGVpZ2h0PXRoaXMuZnJhbWUuY2FudmFzLmhlaWdodC90LHRoaXMuY2FtZXJhU3RhdGUuc2NhbGU9dGhpcy5ib2R5LnZpZXcuc2NhbGUsdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbj10aGlzLkRPTXRvQ2FudmFzKHt4Oi41KnRoaXMuZnJhbWUuY2FudmFzLndpZHRoL3QseTouNSp0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQvdH0pKX19LHtrZXk6XCJfc2V0Q2FtZXJhU3RhdGVcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHZvaWQgMCE9PXRoaXMuY2FtZXJhU3RhdGUuc2NhbGUmJjAhPT10aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCYmMCE9PXRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCYmMCE9PXRoaXMucGl4ZWxSYXRpbyYmdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c1dpZHRoPjAmJnRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNIZWlnaHQ+MCl7dmFyIHQ9dGhpcy5mcmFtZS5jYW52YXMud2lkdGgvdGhpcy5waXhlbFJhdGlvL3RoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNXaWR0aCxlPXRoaXMuZnJhbWUuY2FudmFzLmhlaWdodC90aGlzLnBpeGVsUmF0aW8vdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c0hlaWdodCxpPXRoaXMuY2FtZXJhU3RhdGUuc2NhbGU7MSE9dCYmMSE9ZT9pPS41KnRoaXMuY2FtZXJhU3RhdGUuc2NhbGUqKHQrZSk6MSE9dD9pPXRoaXMuY2FtZXJhU3RhdGUuc2NhbGUqdDoxIT1lJiYoaT10aGlzLmNhbWVyYVN0YXRlLnNjYWxlKmUpLHRoaXMuYm9keS52aWV3LnNjYWxlPWk7dmFyIG89dGhpcy5ET010b0NhbnZhcyh7eDouNSp0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCx5Oi41KnRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodH0pLG49e3g6by54LXRoaXMuY2FtZXJhU3RhdGUucG9zaXRpb24ueCx5Om8ueS10aGlzLmNhbWVyYVN0YXRlLnBvc2l0aW9uLnl9O3RoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLngrPW4ueCp0aGlzLmJvZHkudmlldy5zY2FsZSx0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55Kz1uLnkqdGhpcy5ib2R5LnZpZXcuc2NhbGV9fX0se2tleTpcIl9wcmVwYXJlVmFsdWVcIix2YWx1ZTpmdW5jdGlvbih0KXtpZihcIm51bWJlclwiPT10eXBlb2YgdClyZXR1cm4gdCtcInB4XCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe2lmKC0xIT09TXIodCkuY2FsbCh0LFwiJVwiKXx8LTEhPT1Ncih0KS5jYWxsKHQsXCJweFwiKSlyZXR1cm4gdDtpZigtMT09PU1yKHQpLmNhbGwodCxcIiVcIikpcmV0dXJuIHQrXCJweFwifXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCB1c2UgdGhlIHZhbHVlIHN1cHBsaWVkIGZvciB3aWR0aCBvciBoZWlnaHQ6XCIrdCl9fSx7a2V5OlwiX2NyZWF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKDt0aGlzLmJvZHkuY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKTspdGhpcy5ib2R5LmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmJvZHkuY29udGFpbmVyLmZpcnN0Q2hpbGQpO2lmKHRoaXMuZnJhbWU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLmZyYW1lLmNsYXNzTmFtZT1cInZpcy1uZXR3b3JrXCIsdGhpcy5mcmFtZS5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIsdGhpcy5mcmFtZS5zdHlsZS5vdmVyZmxvdz1cImhpZGRlblwiLHRoaXMuZnJhbWUudGFiSW5kZXg9MCx0aGlzLmZyYW1lLmNhbnZhcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIix0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUuY2FudmFzKSx0aGlzLmZyYW1lLmNhbnZhcy5nZXRDb250ZXh0KXRoaXMuX3NldFBpeGVsUmF0aW8oKSx0aGlzLnNldFRyYW5zZm9ybSgpO2Vsc2V7dmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTt0LnN0eWxlLmNvbG9yPVwicmVkXCIsdC5zdHlsZS5mb250V2VpZ2h0PVwiYm9sZFwiLHQuc3R5bGUucGFkZGluZz1cIjEwcHhcIix0LmlubmVyVGV4dD1cIkVycm9yOiB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIGNhbnZhc1wiLHRoaXMuZnJhbWUuY2FudmFzLmFwcGVuZENoaWxkKHQpfXRoaXMuYm9keS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSksdGhpcy5ib2R5LnZpZXcuc2NhbGU9MSx0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbj17eDouNSp0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCx5Oi41KnRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodH0sdGhpcy5fYmluZEhhbW1lcigpfX0se2tleTpcIl9iaW5kSGFtbWVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3ZvaWQgMCE9PXRoaXMuaGFtbWVyJiZ0aGlzLmhhbW1lci5kZXN0cm95KCksdGhpcy5kcmFnPXt9LHRoaXMucGluY2g9e30sdGhpcy5oYW1tZXI9bmV3IFNoKHRoaXMuZnJhbWUuY2FudmFzKSx0aGlzLmhhbW1lci5nZXQoXCJwaW5jaFwiKS5zZXQoe2VuYWJsZTohMH0pLHRoaXMuaGFtbWVyLmdldChcInBhblwiKS5zZXQoe3RocmVzaG9sZDo1LGRpcmVjdGlvbjpTaC5ESVJFQ1RJT05fQUxMfSksVHUodGhpcy5oYW1tZXIsKGZ1bmN0aW9uKGUpe3QuYm9keS5ldmVudExpc3RlbmVycy5vblRvdWNoKGUpfSkpLHRoaXMuaGFtbWVyLm9uKFwidGFwXCIsKGZ1bmN0aW9uKGUpe3QuYm9keS5ldmVudExpc3RlbmVycy5vblRhcChlKX0pKSx0aGlzLmhhbW1lci5vbihcImRvdWJsZXRhcFwiLChmdW5jdGlvbihlKXt0LmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Eb3VibGVUYXAoZSl9KSksdGhpcy5oYW1tZXIub24oXCJwcmVzc1wiLChmdW5jdGlvbihlKXt0LmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ib2xkKGUpfSkpLHRoaXMuaGFtbWVyLm9uKFwicGFuc3RhcnRcIiwoZnVuY3Rpb24oZSl7dC5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ1N0YXJ0KGUpfSkpLHRoaXMuaGFtbWVyLm9uKFwicGFubW92ZVwiLChmdW5jdGlvbihlKXt0LmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnKGUpfSkpLHRoaXMuaGFtbWVyLm9uKFwicGFuZW5kXCIsKGZ1bmN0aW9uKGUpe3QuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdFbmQoZSl9KSksdGhpcy5oYW1tZXIub24oXCJwaW5jaFwiLChmdW5jdGlvbihlKXt0LmJvZHkuZXZlbnRMaXN0ZW5lcnMub25QaW5jaChlKX0pKSx0aGlzLmZyYW1lLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwoZnVuY3Rpb24oZSl7dC5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uTW91c2VXaGVlbChlKX0pKSx0aGlzLmZyYW1lLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsKGZ1bmN0aW9uKGUpe3QuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlTW92ZShlKX0pKSx0aGlzLmZyYW1lLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwoZnVuY3Rpb24oZSl7dC5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uQ29udGV4dChlKX0pKSx0aGlzLmhhbW1lckZyYW1lPW5ldyBTaCh0aGlzLmZyYW1lKSxNdSh0aGlzLmhhbW1lckZyYW1lLChmdW5jdGlvbihlKXt0LmJvZHkuZXZlbnRMaXN0ZW5lcnMub25SZWxlYXNlKGUpfSkpfX0se2tleTpcInNldFNpemVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp0aGlzLm9wdGlvbnMud2lkdGgsZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5vcHRpb25zLmhlaWdodDt0PXRoaXMuX3ByZXBhcmVWYWx1ZSh0KSxlPXRoaXMuX3ByZXBhcmVWYWx1ZShlKTt2YXIgaT0hMSxvPXRoaXMuZnJhbWUuY2FudmFzLndpZHRoLG49dGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0LHI9dGhpcy5waXhlbFJhdGlvO2lmKHRoaXMuX3NldFBpeGVsUmF0aW8oKSx0IT10aGlzLm9wdGlvbnMud2lkdGh8fGUhPXRoaXMub3B0aW9ucy5oZWlnaHR8fHRoaXMuZnJhbWUuc3R5bGUud2lkdGghPXR8fHRoaXMuZnJhbWUuc3R5bGUuaGVpZ2h0IT1lKXRoaXMuX2dldENhbWVyYVN0YXRlKHIpLHRoaXMuZnJhbWUuc3R5bGUud2lkdGg9dCx0aGlzLmZyYW1lLnN0eWxlLmhlaWdodD1lLHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLndpZHRoPVwiMTAwJVwiLHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLmhlaWdodD1cIjEwMCVcIix0aGlzLmZyYW1lLmNhbnZhcy53aWR0aD1NYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoKnRoaXMucGl4ZWxSYXRpbyksdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0PU1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0KnRoaXMucGl4ZWxSYXRpbyksdGhpcy5vcHRpb25zLndpZHRoPXQsdGhpcy5vcHRpb25zLmhlaWdodD1lLHRoaXMuY2FudmFzVmlld0NlbnRlcj17eDouNSp0aGlzLmZyYW1lLmNsaWVudFdpZHRoLHk6LjUqdGhpcy5mcmFtZS5jbGllbnRIZWlnaHR9LGk9ITA7ZWxzZXt2YXIgcz1NYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoKnRoaXMucGl4ZWxSYXRpbyksYT1NYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCp0aGlzLnBpeGVsUmF0aW8pO3RoaXMuZnJhbWUuY2FudmFzLndpZHRoPT09cyYmdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0PT09YXx8dGhpcy5fZ2V0Q2FtZXJhU3RhdGUociksdGhpcy5mcmFtZS5jYW52YXMud2lkdGghPT1zJiYodGhpcy5mcmFtZS5jYW52YXMud2lkdGg9cyxpPSEwKSx0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQhPT1hJiYodGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0PWEsaT0hMCl9cmV0dXJuITA9PT1pJiYodGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlc2l6ZVwiLHt3aWR0aDpNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLndpZHRoL3RoaXMucGl4ZWxSYXRpbyksaGVpZ2h0Ok1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0L3RoaXMucGl4ZWxSYXRpbyksb2xkV2lkdGg6TWF0aC5yb3VuZChvL3RoaXMucGl4ZWxSYXRpbyksb2xkSGVpZ2h0Ok1hdGgucm91bmQobi90aGlzLnBpeGVsUmF0aW8pfSksdGhpcy5fc2V0Q2FtZXJhU3RhdGUoKSksdGhpcy5pbml0aWFsaXplZD0hMCxpfX0se2tleTpcImdldENvbnRleHRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZyYW1lLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIil9fSx7a2V5OlwiX2RldGVybWluZVBpeGVsUmF0aW9cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0Q29udGV4dCgpO2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGdldCBjYW52YXggY29udGV4dFwiKTt2YXIgZT0xO3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJihlPXdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfHwxKSxlLyh0LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW98fHQubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW98fHQub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW98fHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpb3x8MSl9fSx7a2V5OlwiX3NldFBpeGVsUmF0aW9cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGl4ZWxSYXRpbz10aGlzLl9kZXRlcm1pbmVQaXhlbFJhdGlvKCl9fSx7a2V5Olwic2V0VHJhbnNmb3JtXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldENvbnRleHQoKTtpZih2b2lkIDA9PT10KXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgY2FudmF4IGNvbnRleHRcIik7dC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLDAsMCx0aGlzLnBpeGVsUmF0aW8sMCwwKX19LHtrZXk6XCJfWGNvbnZlcnRET010b0NhbnZhc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybih0LXRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLngpL3RoaXMuYm9keS52aWV3LnNjYWxlfX0se2tleTpcIl9YY29udmVydENhbnZhc1RvRE9NXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHQqdGhpcy5ib2R5LnZpZXcuc2NhbGUrdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueH19LHtrZXk6XCJfWWNvbnZlcnRET010b0NhbnZhc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybih0LXRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkpL3RoaXMuYm9keS52aWV3LnNjYWxlfX0se2tleTpcIl9ZY29udmVydENhbnZhc1RvRE9NXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHQqdGhpcy5ib2R5LnZpZXcuc2NhbGUrdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueX19LHtrZXk6XCJjYW52YXNUb0RPTVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybnt4OnRoaXMuX1hjb252ZXJ0Q2FudmFzVG9ET00odC54KSx5OnRoaXMuX1ljb252ZXJ0Q2FudmFzVG9ET00odC55KX19fSx7a2V5OlwiRE9NdG9DYW52YXNcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm57eDp0aGlzLl9YY29udmVydERPTXRvQ2FudmFzKHQueCkseTp0aGlzLl9ZY29udmVydERPTXRvQ2FudmFzKHQueSl9fX1dKSx0fSgpO2Z1bmN0aW9uIER1KHQsZSl7dmFyIGk9Y3Qoe25vZGVzOmUsbWluWm9vbUxldmVsOk51bWJlci5NSU5fVkFMVUUsbWF4Wm9vbUxldmVsOjF9LG51bGwhPXQ/dDp7fSk7aWYoIWduKGkubm9kZXMpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJOb2RlcyBoYXMgdG8gYmUgYW4gYXJyYXkgb2YgaWRzLlwiKTtpZigwPT09aS5ub2Rlcy5sZW5ndGgmJihpLm5vZGVzPWUpLCEoXCJudW1iZXJcIj09dHlwZW9mIGkubWluWm9vbUxldmVsJiZpLm1pblpvb21MZXZlbD4wKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWluIHpvb20gbGV2ZWwgaGFzIHRvIGJlIGEgbnVtYmVyIGhpZ2hlciB0aGFuIHplcm8uXCIpO2lmKCEoXCJudW1iZXJcIj09dHlwZW9mIGkubWF4Wm9vbUxldmVsJiZpLm1pblpvb21MZXZlbDw9aS5tYXhab29tTGV2ZWwpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJNYXggem9vbSBsZXZlbCBoYXMgdG8gYmUgYSBudW1iZXIgaGlnaGVyIHRoYW4gbWluIHpvb20gbGV2ZWwuXCIpO3JldHVybiBpfXZhciBCdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpKXt2YXIgbyxuLHI9dGhpcztQbyh0aGlzLHQpLHRoaXMuYm9keT1lLHRoaXMuY2FudmFzPWksdGhpcy5hbmltYXRpb25TcGVlZD0xL3RoaXMucmVuZGVyUmVmcmVzaFJhdGUsdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbj1cImVhc2VJbk91dFF1aW50XCIsdGhpcy5lYXNpbmdUaW1lPTAsdGhpcy5zb3VyY2VTY2FsZT0wLHRoaXMudGFyZ2V0U2NhbGU9MCx0aGlzLnNvdXJjZVRyYW5zbGF0aW9uPTAsdGhpcy50YXJnZXRUcmFuc2xhdGlvbj0wLHRoaXMubG9ja2VkT25Ob2RlSWQ9dm9pZCAwLHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0PXZvaWQgMCx0aGlzLnRvdWNoVGltZT0wLHRoaXMudmlld0Z1bmN0aW9uPXZvaWQgMCx0aGlzLmJvZHkuZW1pdHRlci5vbihcImZpdFwiLGJ0KG89dGhpcy5maXQpLmNhbGwobyx0aGlzKSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJhbmltYXRpb25GaW5pc2hlZFwiLChmdW5jdGlvbigpe3IuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RvcFJlbmRlcmluZ1wiKX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcInVubG9ja05vZGVcIixidChuPXRoaXMucmVsZWFzZU5vZGUpLmNhbGwobix0aGlzKSl9cmV0dXJuIElvKHQsW3trZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307dGhpcy5vcHRpb25zPXR9fSx7a2V5OlwiZml0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXTt0PUR1KHQsdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKTt2YXIgaSxvLG49dGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLHI9dGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodDtpZigwPT09bnx8MD09PXIpbz0xLGk9d3UuZ2V0UmFuZ2UodGhpcy5ib2R5Lm5vZGVzLHQubm9kZXMpO2Vsc2UgaWYoITA9PT1lKXt2YXIgcz0wO2Zvcih2YXIgYSBpbiB0aGlzLmJvZHkubm9kZXMpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2RlcyxhKSl7dmFyIGg9dGhpcy5ib2R5Lm5vZGVzW2FdOyEwPT09aC5wcmVkZWZpbmVkUG9zaXRpb24mJihzKz0xKX1pZihzPi41KnRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGgpcmV0dXJuIHZvaWQgdGhpcy5maXQodCwhMSk7aT13dS5nZXRSYW5nZSh0aGlzLmJvZHkubm9kZXMsdC5ub2Rlcyk7dmFyIGQ9dGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDtvPTEyLjY2Mi8oZCs3LjQxNDcpKy4wOTY0ODIyO3ZhciBsPU1hdGgubWluKG4vNjAwLHIvNjAwKTtvKj1sfWVsc2V7dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNpemVOb2Rlc1wiKSxpPXd1LmdldFJhbmdlKHRoaXMuYm9keS5ub2Rlcyx0Lm5vZGVzKTt2YXIgYz0xLjEqTWF0aC5hYnMoaS5tYXhYLWkubWluWCksdT0xLjEqTWF0aC5hYnMoaS5tYXhZLWkubWluWSksZj1uL2MscD1yL3U7bz1mPD1wP2Y6cH1vPnQubWF4Wm9vbUxldmVsP289dC5tYXhab29tTGV2ZWw6bzx0Lm1pblpvb21MZXZlbCYmKG89dC5taW5ab29tTGV2ZWwpO3ZhciB2PXd1LmZpbmRDZW50ZXIoaSksZz17cG9zaXRpb246dixzY2FsZTpvLGFuaW1hdGlvbjp0LmFuaW1hdGlvbn07dGhpcy5tb3ZlVG8oZyl9fSx7a2V5OlwiZm9jdXNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e307aWYodm9pZCAwIT09dGhpcy5ib2R5Lm5vZGVzW3RdKXt2YXIgaT17eDp0aGlzLmJvZHkubm9kZXNbdF0ueCx5OnRoaXMuYm9keS5ub2Rlc1t0XS55fTtlLnBvc2l0aW9uPWksZS5sb2NrZWRPbk5vZGU9dCx0aGlzLm1vdmVUbyhlKX1lbHNlIGNvbnNvbGUuZXJyb3IoXCJOb2RlOiBcIit0K1wiIGNhbm5vdCBiZSBmb3VuZC5cIil9fSx7a2V5OlwibW92ZVRvXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dCl7aWYobnVsbCE9dC5vZmZzZXQpe2lmKG51bGwhPXQub2Zmc2V0Lngpe2lmKHQub2Zmc2V0Lng9K3Qub2Zmc2V0LngsIUFkKHQub2Zmc2V0LngpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBvcHRpb24gXCJvZmZzZXQueFwiIGhhcyB0byBiZSBhIGZpbml0ZSBudW1iZXIuJyl9ZWxzZSB0Lm9mZnNldC54PTA7aWYobnVsbCE9dC5vZmZzZXQueSl7aWYodC5vZmZzZXQueT0rdC5vZmZzZXQueSwhQWQodC5vZmZzZXQueSkpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9wdGlvbiBcIm9mZnNldC55XCIgaGFzIHRvIGJlIGEgZmluaXRlIG51bWJlci4nKX1lbHNlIHQub2Zmc2V0Lng9MH1lbHNlIHQub2Zmc2V0PXt4OjAseTowfTtpZihudWxsIT10LnBvc2l0aW9uKXtpZihudWxsIT10LnBvc2l0aW9uLngpe2lmKHQucG9zaXRpb24ueD0rdC5wb3NpdGlvbi54LCFBZCh0LnBvc2l0aW9uLngpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBvcHRpb24gXCJwb3NpdGlvbi54XCIgaGFzIHRvIGJlIGEgZmluaXRlIG51bWJlci4nKX1lbHNlIHQucG9zaXRpb24ueD0wO2lmKG51bGwhPXQucG9zaXRpb24ueSl7aWYodC5wb3NpdGlvbi55PSt0LnBvc2l0aW9uLnksIUFkKHQucG9zaXRpb24ueSkpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9wdGlvbiBcInBvc2l0aW9uLnlcIiBoYXMgdG8gYmUgYSBmaW5pdGUgbnVtYmVyLicpfWVsc2UgdC5wb3NpdGlvbi54PTB9ZWxzZSB0LnBvc2l0aW9uPXRoaXMuZ2V0Vmlld1Bvc2l0aW9uKCk7aWYobnVsbCE9dC5zY2FsZSl7aWYodC5zY2FsZT0rdC5zY2FsZSwhKHQuc2NhbGU+MCkpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9wdGlvbiBcInNjYWxlXCIgaGFzIHRvIGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiB6ZXJvLicpfWVsc2UgdC5zY2FsZT10aGlzLmJvZHkudmlldy5zY2FsZTt2b2lkIDA9PT10LmFuaW1hdGlvbiYmKHQuYW5pbWF0aW9uPXtkdXJhdGlvbjowfSksITE9PT10LmFuaW1hdGlvbiYmKHQuYW5pbWF0aW9uPXtkdXJhdGlvbjowfSksITA9PT10LmFuaW1hdGlvbiYmKHQuYW5pbWF0aW9uPXt9KSx2b2lkIDA9PT10LmFuaW1hdGlvbi5kdXJhdGlvbiYmKHQuYW5pbWF0aW9uLmR1cmF0aW9uPTFlMyksdm9pZCAwPT09dC5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb24mJih0LmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbj1cImVhc2VJbk91dFF1YWRcIiksdGhpcy5hbmltYXRlVmlldyh0KX1lbHNlIHQ9e319fSx7a2V5OlwiYW5pbWF0ZVZpZXdcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih2b2lkIDAhPT10KXt0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uPXQuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uLHRoaXMucmVsZWFzZU5vZGUoKSwhMD09PXQubG9ja2VkJiYodGhpcy5sb2NrZWRPbk5vZGVJZD10LmxvY2tlZE9uTm9kZSx0aGlzLmxvY2tlZE9uTm9kZU9mZnNldD10Lm9mZnNldCksMCE9dGhpcy5lYXNpbmdUaW1lJiZ0aGlzLl90cmFuc2l0aW9uUmVkcmF3KCEwKSx0aGlzLnNvdXJjZVNjYWxlPXRoaXMuYm9keS52aWV3LnNjYWxlLHRoaXMuc291cmNlVHJhbnNsYXRpb249dGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24sdGhpcy50YXJnZXRTY2FsZT10LnNjYWxlLHRoaXMuYm9keS52aWV3LnNjYWxlPXRoaXMudGFyZ2V0U2NhbGU7dmFyIGUsaSxvPXRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHt4Oi41KnRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCx5Oi41KnRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHR9KSxuPW8ueC10LnBvc2l0aW9uLngscj1vLnktdC5wb3NpdGlvbi55O2lmKHRoaXMudGFyZ2V0VHJhbnNsYXRpb249e3g6dGhpcy5zb3VyY2VUcmFuc2xhdGlvbi54K24qdGhpcy50YXJnZXRTY2FsZSt0Lm9mZnNldC54LHk6dGhpcy5zb3VyY2VUcmFuc2xhdGlvbi55K3IqdGhpcy50YXJnZXRTY2FsZSt0Lm9mZnNldC55fSwwPT09dC5hbmltYXRpb24uZHVyYXRpb24paWYobnVsbCE9dGhpcy5sb2NrZWRPbk5vZGVJZCl0aGlzLnZpZXdGdW5jdGlvbj1idChlPXRoaXMuX2xvY2tlZFJlZHJhdykuY2FsbChlLHRoaXMpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLHRoaXMudmlld0Z1bmN0aW9uKTtlbHNlIHRoaXMuYm9keS52aWV3LnNjYWxlPXRoaXMudGFyZ2V0U2NhbGUsdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb249dGhpcy50YXJnZXRUcmFuc2xhdGlvbix0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7ZWxzZSB0aGlzLmFuaW1hdGlvblNwZWVkPTEvKDYwKnQuYW5pbWF0aW9uLmR1cmF0aW9uKi4wMDEpfHwxLzYwLHRoaXMuYW5pbWF0aW9uRWFzaW5nRnVuY3Rpb249dC5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb24sdGhpcy52aWV3RnVuY3Rpb249YnQoaT10aGlzLl90cmFuc2l0aW9uUmVkcmF3KS5jYWxsKGksdGhpcyksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsdGhpcy52aWV3RnVuY3Rpb24pLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RhcnRSZW5kZXJpbmdcIil9fX0se2tleTpcIl9sb2NrZWRSZWRyYXdcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuYm9keS5ub2Rlc1t0aGlzLmxvY2tlZE9uTm9kZUlkXS54LGU9dGhpcy5ib2R5Lm5vZGVzW3RoaXMubG9ja2VkT25Ob2RlSWRdLnksaT10aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7eDouNSp0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgseTouNSp0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0fSksbz1pLngtdCxuPWkueS1lLHI9dGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24scz17eDpyLngrbyp0aGlzLmJvZHkudmlldy5zY2FsZSt0aGlzLmxvY2tlZE9uTm9kZU9mZnNldC54LHk6ci55K24qdGhpcy5ib2R5LnZpZXcuc2NhbGUrdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQueX07dGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb249c319LHtrZXk6XCJyZWxlYXNlTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dm9pZCAwIT09dGhpcy5sb2NrZWRPbk5vZGVJZCYmdm9pZCAwIT09dGhpcy52aWV3RnVuY3Rpb24mJih0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsdGhpcy52aWV3RnVuY3Rpb24pLHRoaXMubG9ja2VkT25Ob2RlSWQ9dm9pZCAwLHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0PXZvaWQgMCl9fSx7a2V5OlwiX3RyYW5zaXRpb25SZWRyYXdcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF07dGhpcy5lYXNpbmdUaW1lKz10aGlzLmFuaW1hdGlvblNwZWVkLHRoaXMuZWFzaW5nVGltZT0hMD09PXQ/MTp0aGlzLmVhc2luZ1RpbWU7dmFyIGU9eWhbdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbl0odGhpcy5lYXNpbmdUaW1lKTtpZih0aGlzLmJvZHkudmlldy5zY2FsZT10aGlzLnNvdXJjZVNjYWxlKyh0aGlzLnRhcmdldFNjYWxlLXRoaXMuc291cmNlU2NhbGUpKmUsdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb249e3g6dGhpcy5zb3VyY2VUcmFuc2xhdGlvbi54Kyh0aGlzLnRhcmdldFRyYW5zbGF0aW9uLngtdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi54KSplLHk6dGhpcy5zb3VyY2VUcmFuc2xhdGlvbi55Kyh0aGlzLnRhcmdldFRyYW5zbGF0aW9uLnktdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi55KSplfSx0aGlzLmVhc2luZ1RpbWU+PTEpe3ZhciBpO2lmKHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIix0aGlzLnZpZXdGdW5jdGlvbiksdGhpcy5lYXNpbmdUaW1lPTAsbnVsbCE9dGhpcy5sb2NrZWRPbk5vZGVJZCl0aGlzLnZpZXdGdW5jdGlvbj1idChpPXRoaXMuX2xvY2tlZFJlZHJhdykuY2FsbChpLHRoaXMpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLHRoaXMudmlld0Z1bmN0aW9uKTt0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYW5pbWF0aW9uRmluaXNoZWRcIil9fX0se2tleTpcImdldFNjYWxlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ib2R5LnZpZXcuc2NhbGV9fSx7a2V5OlwiZ2V0Vmlld1Bvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe3g6LjUqdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLHk6LjUqdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodH0pfX1dKSx0fSgpO2Z1bmN0aW9uIEl1KHQpe3ZhciBlLGk9dCYmdC5wcmV2ZW50RGVmYXVsdHx8ITEsbz10JiZ0LmNvbnRhaW5lcnx8d2luZG93LG49e30scj17a2V5ZG93bjp7fSxrZXl1cDp7fX0scz17fTtmb3IoZT05NztlPD0xMjI7ZSsrKXNbU3RyaW5nLmZyb21DaGFyQ29kZShlKV09e2NvZGU6ZS05Nys2NSxzaGlmdDohMX07Zm9yKGU9NjU7ZTw9OTA7ZSsrKXNbU3RyaW5nLmZyb21DaGFyQ29kZShlKV09e2NvZGU6ZSxzaGlmdDohMH07Zm9yKGU9MDtlPD05O2UrKylzW1wiXCIrZV09e2NvZGU6NDgrZSxzaGlmdDohMX07Zm9yKGU9MTtlPD0xMjtlKyspc1tcIkZcIitlXT17Y29kZToxMTErZSxzaGlmdDohMX07Zm9yKGU9MDtlPD05O2UrKylzW1wibnVtXCIrZV09e2NvZGU6OTYrZSxzaGlmdDohMX07c1tcIm51bSpcIl09e2NvZGU6MTA2LHNoaWZ0OiExfSxzW1wibnVtK1wiXT17Y29kZToxMDcsc2hpZnQ6ITF9LHNbXCJudW0tXCJdPXtjb2RlOjEwOSxzaGlmdDohMX0sc1tcIm51bS9cIl09e2NvZGU6MTExLHNoaWZ0OiExfSxzW1wibnVtLlwiXT17Y29kZToxMTAsc2hpZnQ6ITF9LHMubGVmdD17Y29kZTozNyxzaGlmdDohMX0scy51cD17Y29kZTozOCxzaGlmdDohMX0scy5yaWdodD17Y29kZTozOSxzaGlmdDohMX0scy5kb3duPXtjb2RlOjQwLHNoaWZ0OiExfSxzLnNwYWNlPXtjb2RlOjMyLHNoaWZ0OiExfSxzLmVudGVyPXtjb2RlOjEzLHNoaWZ0OiExfSxzLnNoaWZ0PXtjb2RlOjE2LHNoaWZ0OnZvaWQgMH0scy5lc2M9e2NvZGU6Mjcsc2hpZnQ6ITF9LHMuYmFja3NwYWNlPXtjb2RlOjgsc2hpZnQ6ITF9LHMudGFiPXtjb2RlOjksc2hpZnQ6ITF9LHMuY3RybD17Y29kZToxNyxzaGlmdDohMX0scy5hbHQ9e2NvZGU6MTgsc2hpZnQ6ITF9LHMuZGVsZXRlPXtjb2RlOjQ2LHNoaWZ0OiExfSxzLnBhZ2V1cD17Y29kZTozMyxzaGlmdDohMX0scy5wYWdlZG93bj17Y29kZTozNCxzaGlmdDohMX0sc1tcIj1cIl09e2NvZGU6MTg3LHNoaWZ0OiExfSxzW1wiLVwiXT17Y29kZToxODksc2hpZnQ6ITF9LHNbXCJdXCJdPXtjb2RlOjIyMSxzaGlmdDohMX0sc1tcIltcIl09e2NvZGU6MjE5LHNoaWZ0OiExfTt2YXIgYT1mdW5jdGlvbih0KXtkKHQsXCJrZXlkb3duXCIpfSxoPWZ1bmN0aW9uKHQpe2QodCxcImtleXVwXCIpfSxkPWZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwIT09cltlXVt0LmtleUNvZGVdKXtmb3IodmFyIG89cltlXVt0LmtleUNvZGVdLG49MDtuPG8ubGVuZ3RoO24rKykodm9pZCAwPT09b1tuXS5zaGlmdHx8MT09b1tuXS5zaGlmdCYmMT09dC5zaGlmdEtleXx8MD09b1tuXS5zaGlmdCYmMD09dC5zaGlmdEtleSkmJm9bbl0uZm4odCk7MT09aSYmdC5wcmV2ZW50RGVmYXVsdCgpfX07cmV0dXJuIG4uYmluZD1mdW5jdGlvbih0LGUsaSl7aWYodm9pZCAwPT09aSYmKGk9XCJrZXlkb3duXCIpLHZvaWQgMD09PXNbdF0pdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQga2V5OiBcIit0KTt2b2lkIDA9PT1yW2ldW3NbdF0uY29kZV0mJihyW2ldW3NbdF0uY29kZV09W10pLHJbaV1bc1t0XS5jb2RlXS5wdXNoKHtmbjplLHNoaWZ0OnNbdF0uc2hpZnR9KX0sbi5iaW5kQWxsPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpIGluIHZvaWQgMD09PWUmJihlPVwia2V5ZG93blwiKSxzKXMuaGFzT3duUHJvcGVydHkoaSkmJm4uYmluZChpLHQsZSl9LG4uZ2V0S2V5PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiBzKWlmKHMuaGFzT3duUHJvcGVydHkoZSkpe2lmKDE9PXQuc2hpZnRLZXkmJjE9PXNbZV0uc2hpZnQmJnQua2V5Q29kZT09c1tlXS5jb2RlKXJldHVybiBlO2lmKDA9PXQuc2hpZnRLZXkmJjA9PXNbZV0uc2hpZnQmJnQua2V5Q29kZT09c1tlXS5jb2RlKXJldHVybiBlO2lmKHQua2V5Q29kZT09c1tlXS5jb2RlJiZcInNoaWZ0XCI9PWUpcmV0dXJuIGV9cmV0dXJuXCJ1bmtub3duIGtleSwgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIn0sbi51bmJpbmQ9ZnVuY3Rpb24odCxlLGkpe2lmKHZvaWQgMD09PWkmJihpPVwia2V5ZG93blwiKSx2b2lkIDA9PT1zW3RdKXRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleTogXCIrdCk7aWYodm9pZCAwIT09ZSl7dmFyIG89W10sbj1yW2ldW3NbdF0uY29kZV07aWYodm9pZCAwIT09bilmb3IodmFyIGE9MDthPG4ubGVuZ3RoO2ErKyluW2FdLmZuPT1lJiZuW2FdLnNoaWZ0PT1zW3RdLnNoaWZ0fHxvLnB1c2gocltpXVtzW3RdLmNvZGVdW2FdKTtyW2ldW3NbdF0uY29kZV09b31lbHNlIHJbaV1bc1t0XS5jb2RlXT1bXX0sbi5yZXNldD1mdW5jdGlvbigpe3I9e2tleWRvd246e30sa2V5dXA6e319fSxuLmRlc3Ryb3k9ZnVuY3Rpb24oKXtyPXtrZXlkb3duOnt9LGtleXVwOnt9fSxvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsYSwhMCksby5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIixoLCEwKX0sby5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLGEsITApLG8uYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsaCwhMCksbn12YXIgenU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsaSl7dmFyIG89dGhpcztQbyh0aGlzLHQpLHRoaXMuYm9keT1lLHRoaXMuY2FudmFzPWksdGhpcy5pY29uc0NyZWF0ZWQ9ITEsdGhpcy5uYXZpZ2F0aW9uSGFtbWVycz1bXSx0aGlzLmJvdW5kRnVuY3Rpb25zPXt9LHRoaXMudG91Y2hUaW1lPTAsdGhpcy5hY3RpdmF0ZWQ9ITEsdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJhY3RpdmF0ZVwiLChmdW5jdGlvbigpe28uYWN0aXZhdGVkPSEwLG8uY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVhY3RpdmF0ZVwiLChmdW5jdGlvbigpe28uYWN0aXZhdGVkPSExLG8uY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLChmdW5jdGlvbigpe3ZvaWQgMCE9PW8ua2V5Y2hhcm0mJm8ua2V5Y2hhcm0uZGVzdHJveSgpfSkpLHRoaXMub3B0aW9ucz17fX1yZXR1cm4gSW8odCxbe2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt2b2lkIDAhPT10JiYodGhpcy5vcHRpb25zPXQsdGhpcy5jcmVhdGUoKSl9fSx7a2V5OlwiY3JlYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXshMD09PXRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uQnV0dG9ucz8hMT09PXRoaXMuaWNvbnNDcmVhdGVkJiZ0aGlzLmxvYWROYXZpZ2F0aW9uRWxlbWVudHMoKTohMD09PXRoaXMuaWNvbnNDcmVhdGVkJiZ0aGlzLmNsZWFuTmF2aWdhdGlvbigpLHRoaXMuY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpfX0se2tleTpcImNsZWFuTmF2aWdhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYoMCE9dGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5sZW5ndGgpe2Zvcih2YXIgdD0wO3Q8dGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5sZW5ndGg7dCsrKXRoaXMubmF2aWdhdGlvbkhhbW1lcnNbdF0uZGVzdHJveSgpO3RoaXMubmF2aWdhdGlvbkhhbW1lcnM9W119dGhpcy5uYXZpZ2F0aW9uRE9NJiZ0aGlzLm5hdmlnYXRpb25ET00ud3JhcHBlciYmdGhpcy5uYXZpZ2F0aW9uRE9NLndyYXBwZXIucGFyZW50Tm9kZSYmdGhpcy5uYXZpZ2F0aW9uRE9NLndyYXBwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5hdmlnYXRpb25ET00ud3JhcHBlciksdGhpcy5pY29uc0NyZWF0ZWQ9ITF9fSx7a2V5OlwibG9hZE5hdmlnYXRpb25FbGVtZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmNsZWFuTmF2aWdhdGlvbigpLHRoaXMubmF2aWdhdGlvbkRPTT17fTt2YXIgZT1bXCJ1cFwiLFwiZG93blwiLFwibGVmdFwiLFwicmlnaHRcIixcInpvb21JblwiLFwiem9vbU91dFwiLFwiem9vbUV4dGVuZHNcIl0saT1bXCJfbW92ZVVwXCIsXCJfbW92ZURvd25cIixcIl9tb3ZlTGVmdFwiLFwiX21vdmVSaWdodFwiLFwiX3pvb21JblwiLFwiX3pvb21PdXRcIixcIl9maXRcIl07dGhpcy5uYXZpZ2F0aW9uRE9NLndyYXBwZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLm5hdmlnYXRpb25ET00ud3JhcHBlci5jbGFzc05hbWU9XCJ2aXMtbmF2aWdhdGlvblwiLHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubmF2aWdhdGlvbkRPTS53cmFwcGVyKTtmb3IodmFyIG89MDtvPGUubGVuZ3RoO28rKyl7dGhpcy5uYXZpZ2F0aW9uRE9NW2Vbb11dPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5uYXZpZ2F0aW9uRE9NW2Vbb11dLmNsYXNzTmFtZT1cInZpcy1idXR0b24gdmlzLVwiK2Vbb10sdGhpcy5uYXZpZ2F0aW9uRE9NLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5uYXZpZ2F0aW9uRE9NW2Vbb11dKTt2YXIgbixyLHM9bmV3IFNoKHRoaXMubmF2aWdhdGlvbkRPTVtlW29dXSk7aWYoXCJfZml0XCI9PT1pW29dKVR1KHMsYnQobj10aGlzLl9maXQpLmNhbGwobix0aGlzKSk7ZWxzZSBUdShzLGJ0KHI9dGhpcy5iaW5kVG9SZWRyYXcpLmNhbGwocix0aGlzLGlbb10pKTt0aGlzLm5hdmlnYXRpb25IYW1tZXJzLnB1c2gocyl9dmFyIGE9bmV3IFNoKHRoaXMuY2FudmFzLmZyYW1lKTtNdShhLChmdW5jdGlvbigpe3QuX3N0b3BNb3ZlbWVudCgpfSkpLHRoaXMubmF2aWdhdGlvbkhhbW1lcnMucHVzaChhKSx0aGlzLmljb25zQ3JlYXRlZD0hMH19LHtrZXk6XCJiaW5kVG9SZWRyYXdcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZTt2b2lkIDA9PT10aGlzLmJvdW5kRnVuY3Rpb25zW3RdJiYodGhpcy5ib3VuZEZ1bmN0aW9uc1t0XT1idChlPXRoaXNbdF0pLmNhbGwoZSx0aGlzKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIix0aGlzLmJvdW5kRnVuY3Rpb25zW3RdKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0YXJ0UmVuZGVyaW5nXCIpKX19LHtrZXk6XCJ1bmJpbmRGcm9tUmVkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odCl7dm9pZCAwIT09dGhpcy5ib3VuZEZ1bmN0aW9uc1t0XSYmKHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIix0aGlzLmJvdW5kRnVuY3Rpb25zW3RdKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIiksZGVsZXRlIHRoaXMuYm91bmRGdW5jdGlvbnNbdF0pfX0se2tleTpcIl9maXRcIix2YWx1ZTpmdW5jdGlvbigpeyhuZXcgRGF0ZSkudmFsdWVPZigpLXRoaXMudG91Y2hUaW1lPjcwMCYmKHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJmaXRcIix7ZHVyYXRpb246NzAwfSksdGhpcy50b3VjaFRpbWU9KG5ldyBEYXRlKS52YWx1ZU9mKCkpfX0se2tleTpcIl9zdG9wTW92ZW1lbnRcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLmJvdW5kRnVuY3Rpb25zKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvdW5kRnVuY3Rpb25zLHQpJiYodGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLHRoaXMuYm91bmRGdW5jdGlvbnNbdF0pLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RvcFJlbmRlcmluZ1wiKSk7dGhpcy5ib3VuZEZ1bmN0aW9ucz17fX19LHtrZXk6XCJfbW92ZVVwXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55Kz10aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueX19LHtrZXk6XCJfbW92ZURvd25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnktPXRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC55fX0se2tleTpcIl9tb3ZlTGVmdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCs9dGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnh9fSx7a2V5OlwiX21vdmVSaWdodFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueC09dGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnh9fSx7a2V5OlwiX3pvb21JblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5ib2R5LnZpZXcuc2NhbGUsZT10aGlzLmJvZHkudmlldy5zY2FsZSooMSt0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQuem9vbSksaT10aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbixvPWUvdCxuPSgxLW8pKnRoaXMuY2FudmFzLmNhbnZhc1ZpZXdDZW50ZXIueCtpLngqbyxyPSgxLW8pKnRoaXMuY2FudmFzLmNhbnZhc1ZpZXdDZW50ZXIueStpLnkqbzt0aGlzLmJvZHkudmlldy5zY2FsZT1lLHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uPXt4Om4seTpyfSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiem9vbVwiLHtkaXJlY3Rpb246XCIrXCIsc2NhbGU6dGhpcy5ib2R5LnZpZXcuc2NhbGUscG9pbnRlcjpudWxsfSl9fSx7a2V5OlwiX3pvb21PdXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuYm9keS52aWV3LnNjYWxlLGU9dGhpcy5ib2R5LnZpZXcuc2NhbGUvKDErdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnpvb20pLGk9dGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24sbz1lL3Qsbj0oMS1vKSp0aGlzLmNhbnZhcy5jYW52YXNWaWV3Q2VudGVyLngraS54Km8scj0oMS1vKSp0aGlzLmNhbnZhcy5jYW52YXNWaWV3Q2VudGVyLnkraS55Km87dGhpcy5ib2R5LnZpZXcuc2NhbGU9ZSx0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbj17eDpuLHk6cn0sdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInpvb21cIix7ZGlyZWN0aW9uOlwiLVwiLHNjYWxlOnRoaXMuYm9keS52aWV3LnNjYWxlLHBvaW50ZXI6bnVsbH0pfX0se2tleTpcImNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3NcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGUsaSxvLG4scixzLGEsaCxkLGwsYyx1LGYscCx2LGcseSxtLGIsdyxrLF8seCxFPXRoaXM7KHZvaWQgMCE9PXRoaXMua2V5Y2hhcm0mJnRoaXMua2V5Y2hhcm0uZGVzdHJveSgpLCEwPT09dGhpcy5vcHRpb25zLmtleWJvYXJkLmVuYWJsZWQpJiYoITA9PT10aGlzLm9wdGlvbnMua2V5Ym9hcmQuYmluZFRvV2luZG93P3RoaXMua2V5Y2hhcm09SXUoe2NvbnRhaW5lcjp3aW5kb3cscHJldmVudERlZmF1bHQ6ITB9KTp0aGlzLmtleWNoYXJtPUl1KHtjb250YWluZXI6dGhpcy5jYW52YXMuZnJhbWUscHJldmVudERlZmF1bHQ6ITB9KSx0aGlzLmtleWNoYXJtLnJlc2V0KCksITA9PT10aGlzLmFjdGl2YXRlZCYmKGJ0KHQ9dGhpcy5rZXljaGFybSkuY2FsbCh0LFwidXBcIiwoZnVuY3Rpb24oKXtFLmJpbmRUb1JlZHJhdyhcIl9tb3ZlVXBcIil9KSxcImtleWRvd25cIiksYnQoZT10aGlzLmtleWNoYXJtKS5jYWxsKGUsXCJkb3duXCIsKGZ1bmN0aW9uKCl7RS5iaW5kVG9SZWRyYXcoXCJfbW92ZURvd25cIil9KSxcImtleWRvd25cIiksYnQoaT10aGlzLmtleWNoYXJtKS5jYWxsKGksXCJsZWZ0XCIsKGZ1bmN0aW9uKCl7RS5iaW5kVG9SZWRyYXcoXCJfbW92ZUxlZnRcIil9KSxcImtleWRvd25cIiksYnQobz10aGlzLmtleWNoYXJtKS5jYWxsKG8sXCJyaWdodFwiLChmdW5jdGlvbigpe0UuYmluZFRvUmVkcmF3KFwiX21vdmVSaWdodFwiKX0pLFwia2V5ZG93blwiKSxidChuPXRoaXMua2V5Y2hhcm0pLmNhbGwobixcIj1cIiwoZnVuY3Rpb24oKXtFLmJpbmRUb1JlZHJhdyhcIl96b29tSW5cIil9KSxcImtleWRvd25cIiksYnQocj10aGlzLmtleWNoYXJtKS5jYWxsKHIsXCJudW0rXCIsKGZ1bmN0aW9uKCl7RS5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpfSksXCJrZXlkb3duXCIpLGJ0KHM9dGhpcy5rZXljaGFybSkuY2FsbChzLFwibnVtLVwiLChmdW5jdGlvbigpe0UuYmluZFRvUmVkcmF3KFwiX3pvb21PdXRcIil9KSxcImtleWRvd25cIiksYnQoYT10aGlzLmtleWNoYXJtKS5jYWxsKGEsXCItXCIsKGZ1bmN0aW9uKCl7RS5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKX0pLFwia2V5ZG93blwiKSxidChoPXRoaXMua2V5Y2hhcm0pLmNhbGwoaCxcIltcIiwoZnVuY3Rpb24oKXtFLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpfSksXCJrZXlkb3duXCIpLGJ0KGQ9dGhpcy5rZXljaGFybSkuY2FsbChkLFwiXVwiLChmdW5jdGlvbigpe0UuYmluZFRvUmVkcmF3KFwiX3pvb21JblwiKX0pLFwia2V5ZG93blwiKSxidChsPXRoaXMua2V5Y2hhcm0pLmNhbGwobCxcInBhZ2V1cFwiLChmdW5jdGlvbigpe0UuYmluZFRvUmVkcmF3KFwiX3pvb21JblwiKX0pLFwia2V5ZG93blwiKSxidChjPXRoaXMua2V5Y2hhcm0pLmNhbGwoYyxcInBhZ2Vkb3duXCIsKGZ1bmN0aW9uKCl7RS5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKX0pLFwia2V5ZG93blwiKSxidCh1PXRoaXMua2V5Y2hhcm0pLmNhbGwodSxcInVwXCIsKGZ1bmN0aW9uKCl7RS51bmJpbmRGcm9tUmVkcmF3KFwiX21vdmVVcFwiKX0pLFwia2V5dXBcIiksYnQoZj10aGlzLmtleWNoYXJtKS5jYWxsKGYsXCJkb3duXCIsKGZ1bmN0aW9uKCl7RS51bmJpbmRGcm9tUmVkcmF3KFwiX21vdmVEb3duXCIpfSksXCJrZXl1cFwiKSxidChwPXRoaXMua2V5Y2hhcm0pLmNhbGwocCxcImxlZnRcIiwoZnVuY3Rpb24oKXtFLnVuYmluZEZyb21SZWRyYXcoXCJfbW92ZUxlZnRcIil9KSxcImtleXVwXCIpLGJ0KHY9dGhpcy5rZXljaGFybSkuY2FsbCh2LFwicmlnaHRcIiwoZnVuY3Rpb24oKXtFLnVuYmluZEZyb21SZWRyYXcoXCJfbW92ZVJpZ2h0XCIpfSksXCJrZXl1cFwiKSxidChnPXRoaXMua2V5Y2hhcm0pLmNhbGwoZyxcIj1cIiwoZnVuY3Rpb24oKXtFLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbUluXCIpfSksXCJrZXl1cFwiKSxidCh5PXRoaXMua2V5Y2hhcm0pLmNhbGwoeSxcIm51bStcIiwoZnVuY3Rpb24oKXtFLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbUluXCIpfSksXCJrZXl1cFwiKSxidChtPXRoaXMua2V5Y2hhcm0pLmNhbGwobSxcIm51bS1cIiwoZnVuY3Rpb24oKXtFLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbU91dFwiKX0pLFwia2V5dXBcIiksYnQoYj10aGlzLmtleWNoYXJtKS5jYWxsKGIsXCItXCIsKGZ1bmN0aW9uKCl7RS51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIil9KSxcImtleXVwXCIpLGJ0KHc9dGhpcy5rZXljaGFybSkuY2FsbCh3LFwiW1wiLChmdW5jdGlvbigpe0UudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tT3V0XCIpfSksXCJrZXl1cFwiKSxidChrPXRoaXMua2V5Y2hhcm0pLmNhbGwoayxcIl1cIiwoZnVuY3Rpb24oKXtFLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbUluXCIpfSksXCJrZXl1cFwiKSxidChfPXRoaXMua2V5Y2hhcm0pLmNhbGwoXyxcInBhZ2V1cFwiLChmdW5jdGlvbigpe0UudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIil9KSxcImtleXVwXCIpLGJ0KHg9dGhpcy5rZXljaGFybSkuY2FsbCh4LFwicGFnZWRvd25cIiwoZnVuY3Rpb24oKXtFLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbU91dFwiKX0pLFwia2V5dXBcIikpKX19XSksdH0oKTtmdW5jdGlvbiBGdSh0LGUpe3ZhciBpO2lmKHZvaWQgMD09PWNufHxudWxsPT1DaSh0KSl7aWYoZ24odCl8fChpPWZ1bmN0aW9uKHQsZSl7dmFyIGk7aWYoIXQpcmV0dXJuO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXJldHVybiBOdSh0LGUpO3ZhciBvPXZuKGk9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKS5jYWxsKGksOCwtMSk7XCJPYmplY3RcIj09PW8mJnQuY29uc3RydWN0b3ImJihvPXQuY29uc3RydWN0b3IubmFtZSk7aWYoXCJNYXBcIj09PW98fFwiU2V0XCI9PT1vKXJldHVybiBtaSh0KTtpZihcIkFyZ3VtZW50c1wiPT09b3x8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobykpcmV0dXJuIE51KHQsZSl9KHQpKXx8ZSYmdCYmXCJudW1iZXJcIj09dHlwZW9mIHQubGVuZ3RoKXtpJiYodD1pKTt2YXIgbz0wLG49ZnVuY3Rpb24oKXt9O3JldHVybntzOm4sbjpmdW5jdGlvbigpe3JldHVybiBvPj10Lmxlbmd0aD97ZG9uZTohMH06e2RvbmU6ITEsdmFsdWU6dFtvKytdfX0sZTpmdW5jdGlvbih0KXt0aHJvdyB0fSxmOm59fXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX12YXIgcixzPSEwLGE9ITE7cmV0dXJue3M6ZnVuY3Rpb24oKXtpPVNpKHQpfSxuOmZ1bmN0aW9uKCl7dmFyIHQ9aS5uZXh0KCk7cmV0dXJuIHM9dC5kb25lLHR9LGU6ZnVuY3Rpb24odCl7YT0hMCxyPXR9LGY6ZnVuY3Rpb24oKXt0cnl7c3x8bnVsbD09aS5yZXR1cm58fGkucmV0dXJuKCl9ZmluYWxseXtpZihhKXRocm93IHJ9fX19ZnVuY3Rpb24gTnUodCxlKXsobnVsbD09ZXx8ZT50Lmxlbmd0aCkmJihlPXQubGVuZ3RoKTtmb3IodmFyIGk9MCxvPW5ldyBBcnJheShlKTtpPGU7aSsrKW9baV09dFtpXTtyZXR1cm4gb312YXIgQXU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsaSxvKXt2YXIgbixyLHMsYSxoLGQsbCxjLHUsZixwLHYsZztQbyh0aGlzLHQpLHRoaXMuYm9keT1lLHRoaXMuY2FudmFzPWksdGhpcy5zZWxlY3Rpb25IYW5kbGVyPW8sdGhpcy5uYXZpZ2F0aW9uSGFuZGxlcj1uZXcgenUoZSxpKSx0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25UYXA9YnQobj10aGlzLm9uVGFwKS5jYWxsKG4sdGhpcyksdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVG91Y2g9YnQocj10aGlzLm9uVG91Y2gpLmNhbGwocix0aGlzKSx0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Eb3VibGVUYXA9YnQocz10aGlzLm9uRG91YmxlVGFwKS5jYWxsKHMsdGhpcyksdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uSG9sZD1idChhPXRoaXMub25Ib2xkKS5jYWxsKGEsdGhpcyksdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ1N0YXJ0PWJ0KGg9dGhpcy5vbkRyYWdTdGFydCkuY2FsbChoLHRoaXMpLHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWc9YnQoZD10aGlzLm9uRHJhZykuY2FsbChkLHRoaXMpLHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdFbmQ9YnQobD10aGlzLm9uRHJhZ0VuZCkuY2FsbChsLHRoaXMpLHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlV2hlZWw9YnQoYz10aGlzLm9uTW91c2VXaGVlbCkuY2FsbChjLHRoaXMpLHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vblBpbmNoPWJ0KHU9dGhpcy5vblBpbmNoKS5jYWxsKHUsdGhpcyksdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uTW91c2VNb3ZlPWJ0KGY9dGhpcy5vbk1vdXNlTW92ZSkuY2FsbChmLHRoaXMpLHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vblJlbGVhc2U9YnQocD10aGlzLm9uUmVsZWFzZSkuY2FsbChwLHRoaXMpLHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkNvbnRleHQ9YnQodj10aGlzLm9uQ29udGV4dCkuY2FsbCh2LHRoaXMpLHRoaXMudG91Y2hUaW1lPTAsdGhpcy5kcmFnPXt9LHRoaXMucGluY2g9e30sdGhpcy5wb3B1cD12b2lkIDAsdGhpcy5wb3B1cE9iaj12b2lkIDAsdGhpcy5wb3B1cFRpbWVyPXZvaWQgMCx0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXI9YnQoZz10aGlzLmdldFBvaW50ZXIpLmNhbGwoZyx0aGlzKSx0aGlzLm9wdGlvbnM9e30sdGhpcy5kZWZhdWx0T3B0aW9ucz17ZHJhZ05vZGVzOiEwLGRyYWdWaWV3OiEwLGhvdmVyOiExLGtleWJvYXJkOntlbmFibGVkOiExLHNwZWVkOnt4OjEwLHk6MTAsem9vbTouMDJ9LGJpbmRUb1dpbmRvdzohMH0sbmF2aWdhdGlvbkJ1dHRvbnM6ITEsdG9vbHRpcERlbGF5OjMwMCx6b29tVmlldzohMCx6b29tU3BlZWQ6MX0sY3QodGhpcy5vcHRpb25zLHRoaXMuZGVmYXVsdE9wdGlvbnMpLHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCl9cmV0dXJuIElvKHQsW3trZXk6XCJiaW5kRXZlbnRMaXN0ZW5lcnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsKGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHQucG9wdXBUaW1lciksZGVsZXRlIHQuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcn0pKX19LHtrZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dCl7SmEoW1wiaGlkZUVkZ2VzT25EcmFnXCIsXCJoaWRlRWRnZXNPblpvb21cIixcImhpZGVOb2Rlc09uRHJhZ1wiLFwia2V5Ym9hcmRcIixcIm11bHRpc2VsZWN0XCIsXCJzZWxlY3RhYmxlXCIsXCJzZWxlY3RDb25uZWN0ZWRFZGdlc1wiXSx0aGlzLm9wdGlvbnMsdCksZ2godGhpcy5vcHRpb25zLHQsXCJrZXlib2FyZFwiKSx0LnRvb2x0aXAmJihjdCh0aGlzLm9wdGlvbnMudG9vbHRpcCx0LnRvb2x0aXApLHQudG9vbHRpcC5jb2xvciYmKHRoaXMub3B0aW9ucy50b29sdGlwLmNvbG9yPWhoKHQudG9vbHRpcC5jb2xvcikpKX10aGlzLm5hdmlnYXRpb25IYW5kbGVyLnNldE9wdGlvbnModGhpcy5vcHRpb25zKX19LHtrZXk6XCJnZXRQb2ludGVyXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJue3g6dC54LShlPXRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcyxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpLHk6dC55LW9oKHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcyl9O3ZhciBlfX0se2tleTpcIm9uVG91Y2hcIix2YWx1ZTpmdW5jdGlvbih0KXsobmV3IERhdGUpLnZhbHVlT2YoKS10aGlzLnRvdWNoVGltZT41MCYmKHRoaXMuZHJhZy5wb2ludGVyPXRoaXMuZ2V0UG9pbnRlcih0LmNlbnRlciksdGhpcy5kcmFnLnBpbmNoZWQ9ITEsdGhpcy5waW5jaC5zY2FsZT10aGlzLmJvZHkudmlldy5zY2FsZSx0aGlzLnRvdWNoVGltZT0obmV3IERhdGUpLnZhbHVlT2YoKSl9fSx7a2V5Olwib25UYXBcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldFBvaW50ZXIodC5jZW50ZXIpLGk9dGhpcy5zZWxlY3Rpb25IYW5kbGVyLm9wdGlvbnMubXVsdGlzZWxlY3QmJih0LmNoYW5nZWRQb2ludGVyc1swXS5jdHJsS2V5fHx0LmNoYW5nZWRQb2ludGVyc1swXS5tZXRhS2V5KTt0aGlzLmNoZWNrU2VsZWN0aW9uQ2hhbmdlcyhlLGkpLHRoaXMuc2VsZWN0aW9uSGFuZGxlci5jb21taXRBbmRFbWl0KGUsdCksdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImNsaWNrXCIsdCxlKX19LHtrZXk6XCJvbkRvdWJsZVRhcFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0UG9pbnRlcih0LmNlbnRlcik7dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRvdWJsZUNsaWNrXCIsdCxlKX19LHtrZXk6XCJvbkhvbGRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldFBvaW50ZXIodC5jZW50ZXIpLGk9dGhpcy5zZWxlY3Rpb25IYW5kbGVyLm9wdGlvbnMubXVsdGlzZWxlY3Q7dGhpcy5jaGVja1NlbGVjdGlvbkNoYW5nZXMoZSxpKSx0aGlzLnNlbGVjdGlvbkhhbmRsZXIuY29tbWl0QW5kRW1pdChlLHQpLHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJjbGlja1wiLHQsZSksdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImhvbGRcIix0LGUpfX0se2tleTpcIm9uUmVsZWFzZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKChuZXcgRGF0ZSkudmFsdWVPZigpLXRoaXMudG91Y2hUaW1lPjEwKXt2YXIgZT10aGlzLmdldFBvaW50ZXIodC5jZW50ZXIpO3RoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJyZWxlYXNlXCIsdCxlKSx0aGlzLnRvdWNoVGltZT0obmV3IERhdGUpLnZhbHVlT2YoKX19fSx7a2V5Olwib25Db250ZXh0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRQb2ludGVyKHt4OnQuY2xpZW50WCx5OnQuY2xpZW50WX0pO3RoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJvbmNvbnRleHRcIix0LGUpfX0se2tleTpcImNoZWNrU2VsZWN0aW9uQ2hhbmdlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV07ITA9PT1lP3RoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RBZGRpdGlvbmFsT25Qb2ludCh0KTp0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0T25Qb2ludCh0KX19LHtrZXk6XCJfZGV0ZXJtaW5lRGlmZmVyZW5jZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9ZnVuY3Rpb24odCxlKXtmb3IodmFyIGk9W10sbz0wO288dC5sZW5ndGg7bysrKXt2YXIgbj10W29dOy0xPT09TXIoZSkuY2FsbChlLG4pJiZpLnB1c2gobil9cmV0dXJuIGl9O3JldHVybntub2RlczppKHQubm9kZXMsZS5ub2RlcyksZWRnZXM6aSh0LmVkZ2VzLGUuZWRnZXMpfX19LHtrZXk6XCJvbkRyYWdTdGFydFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKCF0aGlzLmRyYWcuZHJhZ2dpbmcpe3ZvaWQgMD09PXRoaXMuZHJhZy5wb2ludGVyJiZ0aGlzLm9uVG91Y2godCk7dmFyIGU9dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdCh0aGlzLmRyYWcucG9pbnRlcik7aWYodGhpcy5kcmFnLmRyYWdnaW5nPSEwLHRoaXMuZHJhZy5zZWxlY3Rpb249W10sdGhpcy5kcmFnLnRyYW5zbGF0aW9uPWN0KHt9LHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uKSx0aGlzLmRyYWcubm9kZUlkPXZvaWQgMCx0LnNyY0V2ZW50LnNoaWZ0S2V5KXt0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnNob3c9ITA7dmFyIGk9dGhpcy5nZXRQb2ludGVyKHQuY2VudGVyKTt0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0PXt4OnRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKGkueCkseTp0aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhpLnkpfSx0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLmVuZD17eDp0aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhpLngpLHk6dGhpcy5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMoaS55KX19aWYodm9pZCAwIT09ZSYmITA9PT10aGlzLm9wdGlvbnMuZHJhZ05vZGVzKXt0aGlzLmRyYWcubm9kZUlkPWUuaWQsITE9PT1lLmlzU2VsZWN0ZWQoKSYmKHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpLHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPYmplY3QoZSkpLHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnU3RhcnRcIix0LHRoaXMuZHJhZy5wb2ludGVyKTt2YXIgbyxuPUZ1KHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVzKCkpO3RyeXtmb3Iobi5zKCk7IShvPW4ubigpKS5kb25lOyl7dmFyIHI9by52YWx1ZSxzPXtpZDpyLmlkLG5vZGU6cix4OnIueCx5OnIueSx4Rml4ZWQ6ci5vcHRpb25zLmZpeGVkLngseUZpeGVkOnIub3B0aW9ucy5maXhlZC55fTtyLm9wdGlvbnMuZml4ZWQueD0hMCxyLm9wdGlvbnMuZml4ZWQueT0hMCx0aGlzLmRyYWcuc2VsZWN0aW9uLnB1c2gocyl9fWNhdGNoKHQpe24uZSh0KX1maW5hbGx5e24uZigpfX1lbHNlIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnU3RhcnRcIix0LHRoaXMuZHJhZy5wb2ludGVyLHZvaWQgMCwhMCl9fX0se2tleTpcIm9uRHJhZ1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7aWYoITAhPT10aGlzLmRyYWcucGluY2hlZCl7dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInVubG9ja05vZGVcIik7dmFyIGk9dGhpcy5nZXRQb2ludGVyKHQuY2VudGVyKSxvPXRoaXMuZHJhZy5zZWxlY3Rpb247aWYobyYmby5sZW5ndGgmJiEwPT09dGhpcy5vcHRpb25zLmRyYWdOb2Rlcyl7dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdnaW5nXCIsdCxpKTt2YXIgbj1pLngtdGhpcy5kcmFnLnBvaW50ZXIueCxyPWkueS10aGlzLmRyYWcucG9pbnRlci55O0RuKG8pLmNhbGwobywoZnVuY3Rpb24odCl7dmFyIGk9dC5ub2RlOyExPT09dC54Rml4ZWQmJihpLng9ZS5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXMoZS5jYW52YXMuX1hjb252ZXJ0Q2FudmFzVG9ET00odC54KStuKSksITE9PT10LnlGaXhlZCYmKGkueT1lLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhlLmNhbnZhcy5fWWNvbnZlcnRDYW52YXNUb0RPTSh0LnkpK3IpKX0pKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpfWVsc2V7aWYodC5zcmNFdmVudC5zaGlmdEtleSl7aWYodGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdnaW5nXCIsdCxpLHZvaWQgMCwhMCksdm9pZCAwPT09dGhpcy5kcmFnLnBvaW50ZXIpcmV0dXJuIHZvaWQgdGhpcy5vbkRyYWdTdGFydCh0KTt0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLmVuZD17eDp0aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhpLngpLHk6dGhpcy5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMoaS55KX0sdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpfWlmKCEwPT09dGhpcy5vcHRpb25zLmRyYWdWaWV3JiYhdC5zcmNFdmVudC5zaGlmdEtleSl7aWYodGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdnaW5nXCIsdCxpLHZvaWQgMCwhMCksdm9pZCAwPT09dGhpcy5kcmFnLnBvaW50ZXIpcmV0dXJuIHZvaWQgdGhpcy5vbkRyYWdTdGFydCh0KTt2YXIgcz1pLngtdGhpcy5kcmFnLnBvaW50ZXIueCxhPWkueS10aGlzLmRyYWcucG9pbnRlci55O3RoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uPXt4OnRoaXMuZHJhZy50cmFuc2xhdGlvbi54K3MseTp0aGlzLmRyYWcudHJhbnNsYXRpb24ueSthfSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIil9fX19fSx7a2V5Olwib25EcmFnRW5kXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZih0aGlzLmRyYWcuZHJhZ2dpbmc9ITEsdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5zaG93KXt2YXIgaTt0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnNob3c9ITE7dmFyIG89dGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbixuPXttaW5YOk1hdGgubWluKG8uc3RhcnQueCxvLmVuZC54KSxtaW5ZOk1hdGgubWluKG8uc3RhcnQueSxvLmVuZC55KSxtYXhYOk1hdGgubWF4KG8uc3RhcnQueCxvLmVuZC54KSxtYXhZOk1hdGgubWF4KG8uc3RhcnQueSxvLmVuZC55KX0scj1hcihpPXRoaXMuYm9keS5ub2RlSW5kaWNlcykuY2FsbChpLChmdW5jdGlvbih0KXt2YXIgaT1lLmJvZHkubm9kZXNbdF07cmV0dXJuIGkueD49bi5taW5YJiZpLng8PW4ubWF4WCYmaS55Pj1uLm1pblkmJmkueTw9bi5tYXhZfSkpO0RuKHIpLmNhbGwociwoZnVuY3Rpb24odCl7cmV0dXJuIGUuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPYmplY3QoZS5ib2R5Lm5vZGVzW3RdKX0pKTt2YXIgcz10aGlzLmdldFBvaW50ZXIodC5jZW50ZXIpO3RoaXMuc2VsZWN0aW9uSGFuZGxlci5jb21taXRBbmRFbWl0KHMsdCksdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdFbmRcIix0LHRoaXMuZ2V0UG9pbnRlcih0LmNlbnRlciksdm9pZCAwLCEwKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIil9ZWxzZXt2YXIgYT10aGlzLmRyYWcuc2VsZWN0aW9uO2EmJmEubGVuZ3RoPyhEbihhKS5jYWxsKGEsKGZ1bmN0aW9uKHQpe3Qubm9kZS5vcHRpb25zLmZpeGVkLng9dC54Rml4ZWQsdC5ub2RlLm9wdGlvbnMuZml4ZWQueT10LnlGaXhlZH0pKSx0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ0VuZFwiLHQsdGhpcy5nZXRQb2ludGVyKHQuY2VudGVyKSksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKSk6KHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnRW5kXCIsdCx0aGlzLmdldFBvaW50ZXIodC5jZW50ZXIpLHZvaWQgMCwhMCksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpKX19fSx7a2V5Olwib25QaW5jaFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0UG9pbnRlcih0LmNlbnRlcik7dGhpcy5kcmFnLnBpbmNoZWQ9ITAsdm9pZCAwPT09dGhpcy5waW5jaC5zY2FsZSYmKHRoaXMucGluY2guc2NhbGU9MSk7dmFyIGk9dGhpcy5waW5jaC5zY2FsZSp0LnNjYWxlO3RoaXMuem9vbShpLGUpfX0se2tleTpcInpvb21cIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKCEwPT09dGhpcy5vcHRpb25zLnpvb21WaWV3KXt2YXIgaT10aGlzLmJvZHkudmlldy5zY2FsZTt0PDFlLTUmJih0PTFlLTUpLHQ+MTAmJih0PTEwKTt2YXIgbz12b2lkIDA7dm9pZCAwIT09dGhpcy5kcmFnJiYhMD09PXRoaXMuZHJhZy5kcmFnZ2luZyYmKG89dGhpcy5jYW52YXMuRE9NdG9DYW52YXModGhpcy5kcmFnLnBvaW50ZXIpKTt2YXIgbj10aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbixyPXQvaSxzPSgxLXIpKmUueCtuLngqcixhPSgxLXIpKmUueStuLnkqcjtpZih0aGlzLmJvZHkudmlldy5zY2FsZT10LHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uPXt4OnMseTphfSxudWxsIT1vKXt2YXIgaD10aGlzLmNhbnZhcy5jYW52YXNUb0RPTShvKTt0aGlzLmRyYWcucG9pbnRlci54PWgueCx0aGlzLmRyYWcucG9pbnRlci55PWgueX10aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIiksaTx0P3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJ6b29tXCIse2RpcmVjdGlvbjpcIitcIixzY2FsZTp0aGlzLmJvZHkudmlldy5zY2FsZSxwb2ludGVyOmV9KTp0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiem9vbVwiLHtkaXJlY3Rpb246XCItXCIsc2NhbGU6dGhpcy5ib2R5LnZpZXcuc2NhbGUscG9pbnRlcjplfSl9fX0se2tleTpcIm9uTW91c2VXaGVlbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKCEwPT09dGhpcy5vcHRpb25zLnpvb21WaWV3KXtpZigwIT09dC5kZWx0YVkpe3ZhciBlPXRoaXMuYm9keS52aWV3LnNjYWxlO2UqPTErKHQuZGVsdGFZPDA/MTotMSkqKC4xKnRoaXMub3B0aW9ucy56b29tU3BlZWQpO3ZhciBpPXRoaXMuZ2V0UG9pbnRlcih7eDp0LmNsaWVudFgseTp0LmNsaWVudFl9KTt0aGlzLnpvb20oZSxpKX10LnByZXZlbnREZWZhdWx0KCl9fX0se2tleTpcIm9uTW91c2VNb3ZlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxpPXRoaXMuZ2V0UG9pbnRlcih7eDp0LmNsaWVudFgseTp0LmNsaWVudFl9KSxvPSExO3ZvaWQgMCE9PXRoaXMucG9wdXAmJighMT09PXRoaXMucG9wdXAuaGlkZGVuJiZ0aGlzLl9jaGVja0hpZGVQb3B1cChpKSwhMT09PXRoaXMucG9wdXAuaGlkZGVuJiYobz0hMCx0aGlzLnBvcHVwLnNldFBvc2l0aW9uKGkueCszLGkueS01KSx0aGlzLnBvcHVwLnNob3coKSkpLCExPT09dGhpcy5vcHRpb25zLmtleWJvYXJkLmJpbmRUb1dpbmRvdyYmITA9PT10aGlzLm9wdGlvbnMua2V5Ym9hcmQuZW5hYmxlZCYmdGhpcy5jYW52YXMuZnJhbWUuZm9jdXMoKSwhMT09PW8mJih2b2lkIDAhPT10aGlzLnBvcHVwVGltZXImJihjbGVhckludGVydmFsKHRoaXMucG9wdXBUaW1lciksdGhpcy5wb3B1cFRpbWVyPXZvaWQgMCksdGhpcy5kcmFnLmRyYWdnaW5nfHwodGhpcy5wb3B1cFRpbWVyPXFyKChmdW5jdGlvbigpe3JldHVybiBlLl9jaGVja1Nob3dQb3B1cChpKX0pLHRoaXMub3B0aW9ucy50b29sdGlwRGVsYXkpKSksITA9PT10aGlzLm9wdGlvbnMuaG92ZXImJnRoaXMuc2VsZWN0aW9uSGFuZGxlci5ob3Zlck9iamVjdCh0LGkpfX0se2tleTpcIl9jaGVja1Nob3dQb3B1cFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHQueCksaT10aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyh0LnkpLG89e2xlZnQ6ZSx0b3A6aSxyaWdodDplLGJvdHRvbTppfSxuPXZvaWQgMD09PXRoaXMucG9wdXBPYmo/dm9pZCAwOnRoaXMucG9wdXBPYmouaWQscj0hMSxzPVwibm9kZVwiO2lmKHZvaWQgMD09PXRoaXMucG9wdXBPYmope2Zvcih2YXIgYSxoPXRoaXMuYm9keS5ub2RlSW5kaWNlcyxkPXRoaXMuYm9keS5ub2RlcyxsPVtdLGM9MDtjPGgubGVuZ3RoO2MrKykhMD09PShhPWRbaFtjXV0pLmlzT3ZlcmxhcHBpbmdXaXRoKG8pJiYocj0hMCx2b2lkIDAhPT1hLmdldFRpdGxlKCkmJmwucHVzaChoW2NdKSk7bC5sZW5ndGg+MCYmKHRoaXMucG9wdXBPYmo9ZFtsW2wubGVuZ3RoLTFdXSxyPSEwKX1pZih2b2lkIDA9PT10aGlzLnBvcHVwT2JqJiYhMT09PXIpe2Zvcih2YXIgdSxmPXRoaXMuYm9keS5lZGdlSW5kaWNlcyxwPXRoaXMuYm9keS5lZGdlcyx2PVtdLGc9MDtnPGYubGVuZ3RoO2crKykhMD09PSh1PXBbZltnXV0pLmlzT3ZlcmxhcHBpbmdXaXRoKG8pJiYhMD09PXUuY29ubmVjdGVkJiZ2b2lkIDAhPT11LmdldFRpdGxlKCkmJnYucHVzaChmW2ddKTt2Lmxlbmd0aD4wJiYodGhpcy5wb3B1cE9iaj1wW3Zbdi5sZW5ndGgtMV1dLHM9XCJlZGdlXCIpfXZvaWQgMCE9PXRoaXMucG9wdXBPYmo/dGhpcy5wb3B1cE9iai5pZCE9PW4mJih2b2lkIDA9PT10aGlzLnBvcHVwJiYodGhpcy5wb3B1cD1uZXcgVGgodGhpcy5jYW52YXMuZnJhbWUpKSx0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0VHlwZT1zLHRoaXMucG9wdXAucG9wdXBUYXJnZXRJZD10aGlzLnBvcHVwT2JqLmlkLHRoaXMucG9wdXAuc2V0UG9zaXRpb24odC54KzMsdC55LTUpLHRoaXMucG9wdXAuc2V0VGV4dCh0aGlzLnBvcHVwT2JqLmdldFRpdGxlKCkpLHRoaXMucG9wdXAuc2hvdygpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzaG93UG9wdXBcIix0aGlzLnBvcHVwT2JqLmlkKSk6dm9pZCAwIT09dGhpcy5wb3B1cCYmKHRoaXMucG9wdXAuaGlkZSgpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJoaWRlUG9wdXBcIikpfX0se2tleTpcIl9jaGVja0hpZGVQb3B1cFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QodCksaT0hMTtpZihcIm5vZGVcIj09PXRoaXMucG9wdXAucG9wdXBUYXJnZXRUeXBlKXtpZih2b2lkIDAhPT10aGlzLmJvZHkubm9kZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXSYmITA9PT0oaT10aGlzLmJvZHkubm9kZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXS5pc092ZXJsYXBwaW5nV2l0aChlKSkpe3ZhciBvPXRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQodCk7aT12b2lkIDAhPT1vJiZvLmlkPT09dGhpcy5wb3B1cC5wb3B1cFRhcmdldElkfX1lbHNlIHZvaWQgMD09PXRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQodCkmJnZvaWQgMCE9PXRoaXMuYm9keS5lZGdlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdJiYoaT10aGlzLmJvZHkuZWRnZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXS5pc092ZXJsYXBwaW5nV2l0aChlKSk7ITE9PT1pJiYodGhpcy5wb3B1cE9iaj12b2lkIDAsdGhpcy5wb3B1cC5oaWRlKCksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImhpZGVQb3B1cFwiKSl9fV0pLHR9KCk7RWQoXCJTZXRcIiwoZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQodGhpcyxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1swXTp2b2lkIDApfX0pLERkKTt2YXIgUnU9Ri5TZXQsanU9Z2QuZ2V0V2Vha0RhdGEsTHU9WnQuc2V0LEh1PVp0LmdldHRlckZvcixXdT1XaS5maW5kLFZ1PVdpLmZpbmRJbmRleCxxdT0wLFV1PWZ1bmN0aW9uKHQpe3JldHVybiB0LmZyb3plbnx8KHQuZnJvemVuPW5ldyBZdSl9LFl1PWZ1bmN0aW9uKCl7dGhpcy5lbnRyaWVzPVtdfSxYdT1mdW5jdGlvbih0LGUpe3JldHVybiBXdSh0LmVudHJpZXMsKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdPT09ZX0pKX07WXUucHJvdG90eXBlPXtnZXQ6ZnVuY3Rpb24odCl7dmFyIGU9WHUodGhpcyx0KTtpZihlKXJldHVybiBlWzFdfSxoYXM6ZnVuY3Rpb24odCl7cmV0dXJuISFYdSh0aGlzLHQpfSxzZXQ6ZnVuY3Rpb24odCxlKXt2YXIgaT1YdSh0aGlzLHQpO2k/aVsxXT1lOnRoaXMuZW50cmllcy5wdXNoKFt0LGVdKX0sZGVsZXRlOmZ1bmN0aW9uKHQpe3ZhciBlPVZ1KHRoaXMuZW50cmllcywoZnVuY3Rpb24oZSl7cmV0dXJuIGVbMF09PT10fSkpO3JldHVybn5lJiZ0aGlzLmVudHJpZXMuc3BsaWNlKGUsMSksISF+ZX19O3ZhciBHdT17Z2V0Q29uc3RydWN0b3I6ZnVuY3Rpb24odCxlLGksbyl7dmFyIG49dCgoZnVuY3Rpb24odCxyKXtiZCh0LG4sZSksTHUodCx7dHlwZTplLGlkOnF1KyssZnJvemVuOnZvaWQgMH0pLG51bGwhPXImJm1kKHIsdFtvXSx7dGhhdDp0LEFTX0VOVFJJRVM6aX0pfSkpLHI9SHUoZSkscz1mdW5jdGlvbih0LGUsaSl7dmFyIG89cih0KSxuPWp1KFIoZSksITApO3JldHVybiEwPT09bj9VdShvKS5zZXQoZSxpKTpuW28uaWRdPWksdH07cmV0dXJuIE9kKG4ucHJvdG90eXBlLHtkZWxldGU6ZnVuY3Rpb24odCl7dmFyIGU9cih0aGlzKTtpZighbSh0KSlyZXR1cm4hMTt2YXIgaT1qdSh0KTtyZXR1cm4hMD09PWk/VXUoZSkuZGVsZXRlKHQpOmkmJmsoaSxlLmlkKSYmZGVsZXRlIGlbZS5pZF19LGhhczpmdW5jdGlvbih0KXt2YXIgZT1yKHRoaXMpO2lmKCFtKHQpKXJldHVybiExO3ZhciBpPWp1KHQpO3JldHVybiEwPT09aT9VdShlKS5oYXModCk6aSYmayhpLGUuaWQpfX0pLE9kKG4ucHJvdG90eXBlLGk/e2dldDpmdW5jdGlvbih0KXt2YXIgZT1yKHRoaXMpO2lmKG0odCkpe3ZhciBpPWp1KHQpO3JldHVybiEwPT09aT9VdShlKS5nZXQodCk6aT9pW2UuaWRdOnZvaWQgMH19LHNldDpmdW5jdGlvbih0LGUpe3JldHVybiBzKHRoaXMsdCxlKX19OnthZGQ6ZnVuY3Rpb24odCl7cmV0dXJuIHModGhpcyx0LCEwKX19KSxufX07bygoZnVuY3Rpb24odCl7dmFyIGUsaT1adC5lbmZvcmNlLG89IXIuQWN0aXZlWE9iamVjdCYmXCJBY3RpdmVYT2JqZWN0XCJpbiByLG49T2JqZWN0LmlzRXh0ZW5zaWJsZSxzPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0KHRoaXMsYXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMF06dm9pZCAwKX19LGE9dC5leHBvcnRzPUVkKFwiV2Vha01hcFwiLHMsR3UpO2lmKEF0JiZvKXtlPUd1LmdldENvbnN0cnVjdG9yKHMsXCJXZWFrTWFwXCIsITApLGdkLlJFUVVJUkVEPSEwO3ZhciBoPWEucHJvdG90eXBlLGQ9aC5kZWxldGUsbD1oLmhhcyxjPWguZ2V0LHU9aC5zZXQ7T2QoaCx7ZGVsZXRlOmZ1bmN0aW9uKHQpe2lmKG0odCkmJiFuKHQpKXt2YXIgbz1pKHRoaXMpO3JldHVybiBvLmZyb3plbnx8KG8uZnJvemVuPW5ldyBlKSxkLmNhbGwodGhpcyx0KXx8by5mcm96ZW4uZGVsZXRlKHQpfXJldHVybiBkLmNhbGwodGhpcyx0KX0saGFzOmZ1bmN0aW9uKHQpe2lmKG0odCkmJiFuKHQpKXt2YXIgbz1pKHRoaXMpO3JldHVybiBvLmZyb3plbnx8KG8uZnJvemVuPW5ldyBlKSxsLmNhbGwodGhpcyx0KXx8by5mcm96ZW4uaGFzKHQpfXJldHVybiBsLmNhbGwodGhpcyx0KX0sZ2V0OmZ1bmN0aW9uKHQpe2lmKG0odCkmJiFuKHQpKXt2YXIgbz1pKHRoaXMpO3JldHVybiBvLmZyb3plbnx8KG8uZnJvemVuPW5ldyBlKSxsLmNhbGwodGhpcyx0KT9jLmNhbGwodGhpcyx0KTpvLmZyb3plbi5nZXQodCl9cmV0dXJuIGMuY2FsbCh0aGlzLHQpfSxzZXQ6ZnVuY3Rpb24odCxvKXtpZihtKHQpJiYhbih0KSl7dmFyIHI9aSh0aGlzKTtyLmZyb3plbnx8KHIuZnJvemVuPW5ldyBlKSxsLmNhbGwodGhpcyx0KT91LmNhbGwodGhpcyx0LG8pOnIuZnJvemVuLnNldCh0LG8pfWVsc2UgdS5jYWxsKHRoaXMsdCxvKTtyZXR1cm4gdGhpc319KX19KSk7dmFyIEt1LCR1LFF1LFp1LEp1LHRmPUYuV2Vha01hcDtcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuXHRQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcblx0cHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5cdFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblx0UkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5cdEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcblx0SU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5cdExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5cdE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1Jcblx0UEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cblx0KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbmZ1bmN0aW9uIGVmKHQsZSl7aWYoIWUuaGFzKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBlLmdldCh0KX1mdW5jdGlvbiBvZih0LGUsaSl7aWYoIWUuaGFzKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBlLnNldCh0LGkpLGl9ZnVuY3Rpb24gbmYodCxlKXt2YXIgaTtpZih2b2lkIDA9PT1jbnx8bnVsbD09Q2kodCkpe2lmKGduKHQpfHwoaT1mdW5jdGlvbih0LGUpe3ZhciBpO2lmKCF0KXJldHVybjtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gcmYodCxlKTt2YXIgbz12bihpPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkuY2FsbChpLDgsLTEpO1wiT2JqZWN0XCI9PT1vJiZ0LmNvbnN0cnVjdG9yJiYobz10LmNvbnN0cnVjdG9yLm5hbWUpO2lmKFwiTWFwXCI9PT1vfHxcIlNldFwiPT09bylyZXR1cm4gbWkodCk7aWYoXCJBcmd1bWVudHNcIj09PW98fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG8pKXJldHVybiByZih0LGUpfSh0KSl8fGUmJnQmJlwibnVtYmVyXCI9PXR5cGVvZiB0Lmxlbmd0aCl7aSYmKHQ9aSk7dmFyIG89MCxuPWZ1bmN0aW9uKCl7fTtyZXR1cm57czpuLG46ZnVuY3Rpb24oKXtyZXR1cm4gbz49dC5sZW5ndGg/e2RvbmU6ITB9Ontkb25lOiExLHZhbHVlOnRbbysrXX19LGU6ZnVuY3Rpb24odCl7dGhyb3cgdH0sZjpufX10aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9dmFyIHIscz0hMCxhPSExO3JldHVybntzOmZ1bmN0aW9uKCl7aT1TaSh0KX0sbjpmdW5jdGlvbigpe3ZhciB0PWkubmV4dCgpO3JldHVybiBzPXQuZG9uZSx0fSxlOmZ1bmN0aW9uKHQpe2E9ITAscj10fSxmOmZ1bmN0aW9uKCl7dHJ5e3N8fG51bGw9PWkucmV0dXJufHxpLnJldHVybigpfWZpbmFsbHl7aWYoYSl0aHJvdyByfX19fWZ1bmN0aW9uIHJmKHQsZSl7KG51bGw9PWV8fGU+dC5sZW5ndGgpJiYoZT10Lmxlbmd0aCk7Zm9yKHZhciBpPTAsbz1uZXcgQXJyYXkoZSk7aTxlO2krKylvW2ldPXRbaV07cmV0dXJuIG99ZnVuY3Rpb24gc2YodCxlKXt2YXIgaSxvPW5ldyBSdSxuPW5mKGUpO3RyeXtmb3Iobi5zKCk7IShpPW4ubigpKS5kb25lOyl7dmFyIHI9aS52YWx1ZTt0LmhhcyhyKXx8by5hZGQocil9fWNhdGNoKHQpe24uZSh0KX1maW5hbGx5e24uZigpfXJldHVybiBvfXZhciBhZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtQbyh0aGlzLHQpLEt1LnNldCh0aGlzLG5ldyBSdSksJHUuc2V0KHRoaXMsbmV3IFJ1KX1yZXR1cm4gSW8odCxbe2tleTpcInNpemVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZWYodGhpcywkdSkuc2l6ZX19LHtrZXk6XCJhZGRcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLGU9bmV3IEFycmF5KHQpLGk9MDtpPHQ7aSsrKWVbaV09YXJndW1lbnRzW2ldO2Zvcih2YXIgbz0wLG49ZTtvPG4ubGVuZ3RoO28rKyl7dmFyIHI9bltvXTtlZih0aGlzLCR1KS5hZGQocil9fX0se2tleTpcImRlbGV0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsZT1uZXcgQXJyYXkodCksaT0wO2k8dDtpKyspZVtpXT1hcmd1bWVudHNbaV07Zm9yKHZhciBvPTAsbj1lO288bi5sZW5ndGg7bysrKXt2YXIgcj1uW29dO2VmKHRoaXMsJHUpLmRlbGV0ZShyKX19fSx7a2V5OlwiY2xlYXJcIix2YWx1ZTpmdW5jdGlvbigpe2VmKHRoaXMsJHUpLmNsZWFyKCl9fSx7a2V5OlwiZ2V0U2VsZWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gbG4oZWYodGhpcywkdSkpfX0se2tleTpcImdldENoYW5nZXNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybnthZGRlZDpsbihzZihlZih0aGlzLEt1KSxlZih0aGlzLCR1KSkpLGRlbGV0ZWQ6bG4oc2YoZWYodGhpcywkdSksZWYodGhpcyxLdSkpKSxwcmV2aW91czpsbihuZXcgUnUoZWYodGhpcyxLdSkpKSxjdXJyZW50OmxuKG5ldyBSdShlZih0aGlzLCR1KSkpfX19LHtrZXk6XCJjb21taXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0Q2hhbmdlcygpO29mKHRoaXMsS3UsZWYodGhpcywkdSkpLG9mKHRoaXMsJHUsbmV3IFJ1KGVmKHRoaXMsS3UpKSk7dmFyIGUsaT1uZih0LmFkZGVkKTt0cnl7Zm9yKGkucygpOyEoZT1pLm4oKSkuZG9uZTspe2UudmFsdWUuc2VsZWN0KCl9fWNhdGNoKHQpe2kuZSh0KX1maW5hbGx5e2kuZigpfXZhciBvLG49bmYodC5kZWxldGVkKTt0cnl7Zm9yKG4ucygpOyEobz1uLm4oKSkuZG9uZTspe28udmFsdWUudW5zZWxlY3QoKX19Y2F0Y2godCl7bi5lKHQpfWZpbmFsbHl7bi5mKCl9cmV0dXJuIHR9fV0pLHR9KCk7S3U9bmV3IHRmLCR1PW5ldyB0Zjt2YXIgaGY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOmZ1bmN0aW9uKCl7fTtQbyh0aGlzLHQpLFF1LnNldCh0aGlzLG5ldyBhZiksWnUuc2V0KHRoaXMsbmV3IGFmKSxKdS5zZXQodGhpcyx2b2lkIDApLG9mKHRoaXMsSnUsZSl9cmV0dXJuIElvKHQsW3trZXk6XCJzaXplTm9kZXNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZWYodGhpcyxRdSkuc2l6ZX19LHtrZXk6XCJzaXplRWRnZXNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZWYodGhpcyxadSkuc2l6ZX19LHtrZXk6XCJnZXROb2Rlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGVmKHRoaXMsUXUpLmdldFNlbGVjdGlvbigpfX0se2tleTpcImdldEVkZ2VzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gZWYodGhpcyxadSkuZ2V0U2VsZWN0aW9uKCl9fSx7a2V5OlwiYWRkTm9kZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0Oyh0PWVmKHRoaXMsUXUpKS5hZGQuYXBwbHkodCxhcmd1bWVudHMpfX0se2tleTpcImFkZEVkZ2VzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdDsodD1lZih0aGlzLFp1KSkuYWRkLmFwcGx5KHQsYXJndW1lbnRzKX19LHtrZXk6XCJkZWxldGVOb2Rlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2VmKHRoaXMsUXUpLmRlbGV0ZSh0KX19LHtrZXk6XCJkZWxldGVFZGdlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2VmKHRoaXMsWnUpLmRlbGV0ZSh0KX19LHtrZXk6XCJjbGVhclwiLHZhbHVlOmZ1bmN0aW9uKCl7ZWYodGhpcyxRdSkuY2xlYXIoKSxlZih0aGlzLFp1KS5jbGVhcigpfX0se2tleTpcImNvbW1pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0LGUsaT17bm9kZXM6ZWYodGhpcyxRdSkuY29tbWl0KCksZWRnZXM6ZWYodGhpcyxadSkuY29tbWl0KCl9LG89YXJndW1lbnRzLmxlbmd0aCxuPW5ldyBBcnJheShvKSxyPTA7cjxvO3IrKyluW3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4odD1lZih0aGlzLEp1KSkuY2FsbC5hcHBseSh0LHBuKGU9W3RoaXMsaV0pLmNhbGwoZSxuKSksaX19XSksdH0oKTtmdW5jdGlvbiBkZih0LGUpe3ZhciBpO2lmKHZvaWQgMD09PWNufHxudWxsPT1DaSh0KSl7aWYoZ24odCl8fChpPWZ1bmN0aW9uKHQsZSl7dmFyIGk7aWYoIXQpcmV0dXJuO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXJldHVybiBsZih0LGUpO3ZhciBvPXZuKGk9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKS5jYWxsKGksOCwtMSk7XCJPYmplY3RcIj09PW8mJnQuY29uc3RydWN0b3ImJihvPXQuY29uc3RydWN0b3IubmFtZSk7aWYoXCJNYXBcIj09PW98fFwiU2V0XCI9PT1vKXJldHVybiBtaSh0KTtpZihcIkFyZ3VtZW50c1wiPT09b3x8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobykpcmV0dXJuIGxmKHQsZSl9KHQpKXx8ZSYmdCYmXCJudW1iZXJcIj09dHlwZW9mIHQubGVuZ3RoKXtpJiYodD1pKTt2YXIgbz0wLG49ZnVuY3Rpb24oKXt9O3JldHVybntzOm4sbjpmdW5jdGlvbigpe3JldHVybiBvPj10Lmxlbmd0aD97ZG9uZTohMH06e2RvbmU6ITEsdmFsdWU6dFtvKytdfX0sZTpmdW5jdGlvbih0KXt0aHJvdyB0fSxmOm59fXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX12YXIgcixzPSEwLGE9ITE7cmV0dXJue3M6ZnVuY3Rpb24oKXtpPVNpKHQpfSxuOmZ1bmN0aW9uKCl7dmFyIHQ9aS5uZXh0KCk7cmV0dXJuIHM9dC5kb25lLHR9LGU6ZnVuY3Rpb24odCl7YT0hMCxyPXR9LGY6ZnVuY3Rpb24oKXt0cnl7c3x8bnVsbD09aS5yZXR1cm58fGkucmV0dXJuKCl9ZmluYWxseXtpZihhKXRocm93IHJ9fX19ZnVuY3Rpb24gbGYodCxlKXsobnVsbD09ZXx8ZT50Lmxlbmd0aCkmJihlPXQubGVuZ3RoKTtmb3IodmFyIGk9MCxvPW5ldyBBcnJheShlKTtpPGU7aSsrKW9baV09dFtpXTtyZXR1cm4gb31RdT1uZXcgdGYsWnU9bmV3IHRmLEp1PW5ldyB0Zjt2YXIgY2Y9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsaSl7dmFyIG89dGhpcztQbyh0aGlzLHQpLHRoaXMuYm9keT1lLHRoaXMuY2FudmFzPWksdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3I9bmV3IGhmLHRoaXMuaG92ZXJPYmo9e25vZGVzOnt9LGVkZ2VzOnt9fSx0aGlzLm9wdGlvbnM9e30sdGhpcy5kZWZhdWx0T3B0aW9ucz17bXVsdGlzZWxlY3Q6ITEsc2VsZWN0YWJsZTohMCxzZWxlY3RDb25uZWN0ZWRFZGdlczohMCxob3ZlckNvbm5lY3RlZEVkZ2VzOiEwfSxjdCh0aGlzLm9wdGlvbnMsdGhpcy5kZWZhdWx0T3B0aW9ucyksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIiwoZnVuY3Rpb24oKXtvLnVwZGF0ZVNlbGVjdGlvbigpfSkpfXJldHVybiBJbyh0LFt7a2V5Olwic2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMCE9PXQpe1phKFtcIm11bHRpc2VsZWN0XCIsXCJob3ZlckNvbm5lY3RlZEVkZ2VzXCIsXCJzZWxlY3RhYmxlXCIsXCJzZWxlY3RDb25uZWN0ZWRFZGdlc1wiXSx0aGlzLm9wdGlvbnMsdCl9fX0se2tleTpcInNlbGVjdE9uUG9pbnRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT0hMTtpZighMD09PXRoaXMub3B0aW9ucy5zZWxlY3RhYmxlKXt2YXIgaT10aGlzLmdldE5vZGVBdCh0KXx8dGhpcy5nZXRFZGdlQXQodCk7dGhpcy51bnNlbGVjdEFsbCgpLHZvaWQgMCE9PWkmJihlPXRoaXMuc2VsZWN0T2JqZWN0KGkpKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIil9cmV0dXJuIGV9fSx7a2V5Olwic2VsZWN0QWRkaXRpb25hbE9uUG9pbnRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT0hMTtpZighMD09PXRoaXMub3B0aW9ucy5zZWxlY3RhYmxlKXt2YXIgaT10aGlzLmdldE5vZGVBdCh0KXx8dGhpcy5nZXRFZGdlQXQodCk7dm9pZCAwIT09aSYmKGU9ITAsITA9PT1pLmlzU2VsZWN0ZWQoKT90aGlzLmRlc2VsZWN0T2JqZWN0KGkpOnRoaXMuc2VsZWN0T2JqZWN0KGkpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKSl9cmV0dXJuIGV9fSx7a2V5OlwiX2luaXRCYXNlRXZlbnRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXt9O3JldHVybiBpLnBvaW50ZXI9e0RPTTp7eDplLngseTplLnl9LGNhbnZhczp0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhlKX0saS5ldmVudD10LGl9fSx7a2V5OlwiZ2VuZXJhdGVDbGlja0V2ZW50XCIsdmFsdWU6ZnVuY3Rpb24odCxlLGksbyl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD40JiZ2b2lkIDAhPT1hcmd1bWVudHNbNF0mJmFyZ3VtZW50c1s0XSxyPXRoaXMuX2luaXRCYXNlRXZlbnQoZSxpKTtpZighMD09PW4pci5ub2Rlcz1bXSxyLmVkZ2VzPVtdO2Vsc2V7dmFyIHM9dGhpcy5nZXRTZWxlY3Rpb24oKTtyLm5vZGVzPXMubm9kZXMsci5lZGdlcz1zLmVkZ2VzfXZvaWQgMCE9PW8mJihyLnByZXZpb3VzU2VsZWN0aW9uPW8pLFwiY2xpY2tcIj09dCYmKHIuaXRlbXM9dGhpcy5nZXRDbGlja2VkSXRlbXMoaSkpLHZvaWQgMCE9PWUuY29udHJvbEVkZ2UmJihyLmNvbnRyb2xFZGdlPWUuY29udHJvbEVkZ2UpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQodCxyKX19LHtrZXk6XCJzZWxlY3RPYmplY3RcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5vcHRpb25zLnNlbGVjdENvbm5lY3RlZEVkZ2VzO2lmKHZvaWQgMCE9PXQpe2lmKHQgaW5zdGFuY2VvZiBsYyl7dmFyIGk7aWYoITA9PT1lKShpPXRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yKS5hZGRFZGdlcy5hcHBseShpLGxuKHQuZWRnZXMpKTt0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5hZGROb2Rlcyh0KX1lbHNlIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmFkZEVkZ2VzKHQpO3JldHVybiEwfXJldHVybiExfX0se2tleTpcImRlc2VsZWN0T2JqZWN0XCIsdmFsdWU6ZnVuY3Rpb24odCl7ITA9PT10LmlzU2VsZWN0ZWQoKSYmKHQuc2VsZWN0ZWQ9ITEsdGhpcy5fcmVtb3ZlRnJvbVNlbGVjdGlvbih0KSl9fSx7a2V5OlwiX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLGk9dGhpcy5ib2R5Lm5vZGVzLG89MDtvPHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7bysrKXt2YXIgbj10aGlzLmJvZHkubm9kZUluZGljZXNbb107aVtuXS5pc092ZXJsYXBwaW5nV2l0aCh0KSYmZS5wdXNoKG4pfXJldHVybiBlfX0se2tleTpcIl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHQpO3JldHVybntsZWZ0OmUueC0xLHRvcDplLnkrMSxyaWdodDplLngrMSxib3R0b206ZS55LTF9fX0se2tleTpcImdldE5vZGVBdFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV0saT10aGlzLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdCh0KSxvPXRoaXMuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKGkpO3JldHVybiBvLmxlbmd0aD4wPyEwPT09ZT90aGlzLmJvZHkubm9kZXNbb1tvLmxlbmd0aC0xXV06b1tvLmxlbmd0aC0xXTp2b2lkIDB9fSx7a2V5OlwiX2dldEVkZ2VzT3ZlcmxhcHBpbmdXaXRoXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIGk9dGhpcy5ib2R5LmVkZ2VzLG89MDtvPHRoaXMuYm9keS5lZGdlSW5kaWNlcy5sZW5ndGg7bysrKXt2YXIgbj10aGlzLmJvZHkuZWRnZUluZGljZXNbb107aVtuXS5pc092ZXJsYXBwaW5nV2l0aCh0KSYmZS5wdXNoKG4pfX19LHtrZXk6XCJfZ2V0QWxsRWRnZXNPdmVybGFwcGluZ1dpdGhcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1bXTtyZXR1cm4gdGhpcy5fZ2V0RWRnZXNPdmVybGFwcGluZ1dpdGgodCxlKSxlfX0se2tleTpcImdldEVkZ2VBdFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0hKGFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdKXx8YXJndW1lbnRzWzFdLGk9dGhpcy5jYW52YXMuRE9NdG9DYW52YXModCksbz0xMCxuPW51bGwscj10aGlzLmJvZHkuZWRnZXMscz0wO3M8dGhpcy5ib2R5LmVkZ2VJbmRpY2VzLmxlbmd0aDtzKyspe3ZhciBhPXRoaXMuYm9keS5lZGdlSW5kaWNlc1tzXSxoPXJbYV07aWYoaC5jb25uZWN0ZWQpe3ZhciBkPWguZnJvbS54LGw9aC5mcm9tLnksYz1oLnRvLngsdT1oLnRvLnksZj1oLmVkZ2VUeXBlLmdldERpc3RhbmNlVG9FZGdlKGQsbCxjLHUsaS54LGkueSk7ZjxvJiYobj1hLG89Zil9fXJldHVybiBudWxsIT09bj8hMD09PWU/dGhpcy5ib2R5LmVkZ2VzW25dOm46dm9pZCAwfX0se2tleTpcIl9hZGRUb0hvdmVyXCIsdmFsdWU6ZnVuY3Rpb24odCl7dCBpbnN0YW5jZW9mIGxjP3RoaXMuaG92ZXJPYmoubm9kZXNbdC5pZF09dDp0aGlzLmhvdmVyT2JqLmVkZ2VzW3QuaWRdPXR9fSx7a2V5OlwiX3JlbW92ZUZyb21TZWxlY3Rpb25cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZTt0IGluc3RhbmNlb2YgbGM/KHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmRlbGV0ZU5vZGVzKHQpLChlPXRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yKS5kZWxldGVFZGdlcy5hcHBseShlLGxuKHQuZWRnZXMpKSk6dGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZGVsZXRlRWRnZXModCl9fSx7a2V5OlwidW5zZWxlY3RBbGxcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmNsZWFyKCl9fSx7a2V5OlwiZ2V0U2VsZWN0ZWROb2RlQ291bnRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5zaXplTm9kZXN9fSx7a2V5OlwiZ2V0U2VsZWN0ZWRFZGdlQ291bnRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5zaXplRWRnZXN9fSx7a2V5OlwiX2hvdmVyQ29ubmVjdGVkRWRnZXNcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQuZWRnZXMubGVuZ3RoO2UrKyl7dmFyIGk9dC5lZGdlc1tlXTtpLmhvdmVyPSEwLHRoaXMuX2FkZFRvSG92ZXIoaSl9fX0se2tleTpcImVtaXRCbHVyRXZlbnRcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dmFyIG89dGhpcy5faW5pdEJhc2VFdmVudCh0LGUpOyEwPT09aS5ob3ZlciYmKGkuaG92ZXI9ITEsaSBpbnN0YW5jZW9mIGxjPyhvLm5vZGU9aS5pZCx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYmx1ck5vZGVcIixvKSk6KG8uZWRnZT1pLmlkLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJibHVyRWRnZVwiLG8pKSl9fSx7a2V5OlwiZW1pdEhvdmVyRXZlbnRcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dmFyIG89dGhpcy5faW5pdEJhc2VFdmVudCh0LGUpLG49ITE7cmV0dXJuITE9PT1pLmhvdmVyJiYoaS5ob3Zlcj0hMCx0aGlzLl9hZGRUb0hvdmVyKGkpLG49ITAsaSBpbnN0YW5jZW9mIGxjPyhvLm5vZGU9aS5pZCx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaG92ZXJOb2RlXCIsbykpOihvLmVkZ2U9aS5pZCx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaG92ZXJFZGdlXCIsbykpKSxufX0se2tleTpcImhvdmVyT2JqZWN0XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLmdldE5vZGVBdChlKTt2b2lkIDA9PT1pJiYoaT10aGlzLmdldEVkZ2VBdChlKSk7dmFyIG89ITE7Zm9yKHZhciBuIGluIHRoaXMuaG92ZXJPYmoubm9kZXMpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuaG92ZXJPYmoubm9kZXMsbikmJih2b2lkIDA9PT1pfHxpIGluc3RhbmNlb2YgbGMmJmkuaWQhPW58fGkgaW5zdGFuY2VvZiBKYykmJih0aGlzLmVtaXRCbHVyRXZlbnQodCxlLHRoaXMuaG92ZXJPYmoubm9kZXNbbl0pLGRlbGV0ZSB0aGlzLmhvdmVyT2JqLm5vZGVzW25dLG89ITApO2Zvcih2YXIgciBpbiB0aGlzLmhvdmVyT2JqLmVkZ2VzKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmhvdmVyT2JqLmVkZ2VzLHIpJiYoITA9PT1vPyh0aGlzLmhvdmVyT2JqLmVkZ2VzW3JdLmhvdmVyPSExLGRlbGV0ZSB0aGlzLmhvdmVyT2JqLmVkZ2VzW3JdKToodm9pZCAwPT09aXx8aSBpbnN0YW5jZW9mIEpjJiZpLmlkIT1yfHxpIGluc3RhbmNlb2YgbGMmJiFpLmhvdmVyKSYmKHRoaXMuZW1pdEJsdXJFdmVudCh0LGUsdGhpcy5ob3Zlck9iai5lZGdlc1tyXSksZGVsZXRlIHRoaXMuaG92ZXJPYmouZWRnZXNbcl0sbz0hMCkpO2lmKHZvaWQgMCE9PWkpe3ZhciBzPXhuKHRoaXMuaG92ZXJPYmouZWRnZXMpLmxlbmd0aCxhPXhuKHRoaXMuaG92ZXJPYmoubm9kZXMpLmxlbmd0aDsob3x8aSBpbnN0YW5jZW9mIEpjJiYwPT09cyYmMD09PWF8fGkgaW5zdGFuY2VvZiBsYyYmMD09PXMmJjA9PT1hKSYmKG89dGhpcy5lbWl0SG92ZXJFdmVudCh0LGUsaSkpLGkgaW5zdGFuY2VvZiBsYyYmITA9PT10aGlzLm9wdGlvbnMuaG92ZXJDb25uZWN0ZWRFZGdlcyYmdGhpcy5faG92ZXJDb25uZWN0ZWRFZGdlcyhpKX0hMD09PW8mJnRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKX19LHtrZXk6XCJjb21taXRXaXRob3V0RW1pdHRpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmNvbW1pdCgpfX0se2tleTpcImNvbW1pdEFuZEVtaXRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPSExLG89dGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuY29tbWl0KCksbj17bm9kZXM6by5ub2Rlcy5wcmV2aW91cyxlZGdlczpvLmVkZ2VzLnByZXZpb3VzfTtvLmVkZ2VzLmRlbGV0ZWQubGVuZ3RoPjAmJih0aGlzLmdlbmVyYXRlQ2xpY2tFdmVudChcImRlc2VsZWN0RWRnZVwiLGUsdCxuKSxpPSEwKSxvLm5vZGVzLmRlbGV0ZWQubGVuZ3RoPjAmJih0aGlzLmdlbmVyYXRlQ2xpY2tFdmVudChcImRlc2VsZWN0Tm9kZVwiLGUsdCxuKSxpPSEwKSxvLm5vZGVzLmFkZGVkLmxlbmd0aD4wJiYodGhpcy5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJzZWxlY3ROb2RlXCIsZSx0KSxpPSEwKSxvLmVkZ2VzLmFkZGVkLmxlbmd0aD4wJiYodGhpcy5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJzZWxlY3RFZGdlXCIsZSx0KSxpPSEwKSwhMD09PWkmJnRoaXMuZ2VuZXJhdGVDbGlja0V2ZW50KFwic2VsZWN0XCIsZSx0KX19LHtrZXk6XCJnZXRTZWxlY3Rpb25cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybntub2Rlczp0aGlzLmdldFNlbGVjdGVkTm9kZUlkcygpLGVkZ2VzOnRoaXMuZ2V0U2VsZWN0ZWRFZGdlSWRzKCl9fX0se2tleTpcImdldFNlbGVjdGVkTm9kZXNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXROb2RlcygpfX0se2tleTpcImdldFNlbGVjdGVkRWRnZXNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXRFZGdlcygpfX0se2tleTpcImdldFNlbGVjdGVkTm9kZUlkc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIGtuKHQ9dGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZ2V0Tm9kZXMoKSkuY2FsbCh0LChmdW5jdGlvbih0KXtyZXR1cm4gdC5pZH0pKX19LHtrZXk6XCJnZXRTZWxlY3RlZEVkZ2VJZHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0O3JldHVybiBrbih0PXRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmdldEVkZ2VzKCkpLmNhbGwodCwoZnVuY3Rpb24odCl7cmV0dXJuIHQuaWR9KSl9fSx7a2V5Olwic2V0U2VsZWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9O2lmKCF0fHwhdC5ub2RlcyYmIXQuZWRnZXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlNlbGVjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIG5vZGVzIGFuZC9vciBlZGdlcyBwcm9wZXJ0aWVzXCIpO2lmKChlLnVuc2VsZWN0QWxsfHx2b2lkIDA9PT1lLnVuc2VsZWN0QWxsKSYmdGhpcy51bnNlbGVjdEFsbCgpLHQubm9kZXMpe3ZhciBpLG89ZGYodC5ub2Rlcyk7dHJ5e2ZvcihvLnMoKTshKGk9by5uKCkpLmRvbmU7KXt2YXIgbj1pLnZhbHVlLHI9dGhpcy5ib2R5Lm5vZGVzW25dO2lmKCFyKXRocm93IG5ldyBSYW5nZUVycm9yKCdOb2RlIHdpdGggaWQgXCInK24rJ1wiIG5vdCBmb3VuZCcpO3RoaXMuc2VsZWN0T2JqZWN0KHIsZS5oaWdobGlnaHRFZGdlcyl9fWNhdGNoKHQpe28uZSh0KX1maW5hbGx5e28uZigpfX1pZih0LmVkZ2VzKXt2YXIgcyxhPWRmKHQuZWRnZXMpO3RyeXtmb3IoYS5zKCk7IShzPWEubigpKS5kb25lOyl7dmFyIGg9cy52YWx1ZSxkPXRoaXMuYm9keS5lZGdlc1toXTtpZighZCl0aHJvdyBuZXcgUmFuZ2VFcnJvcignRWRnZSB3aXRoIGlkIFwiJytoKydcIiBub3QgZm91bmQnKTt0aGlzLnNlbGVjdE9iamVjdChkKX19Y2F0Y2godCl7YS5lKHQpfWZpbmFsbHl7YS5mKCl9fXRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKSx0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5jb21taXQoKX19LHtrZXk6XCJzZWxlY3ROb2Rlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV07aWYoIXR8fHZvaWQgMD09PXQubGVuZ3RoKXRocm93XCJTZWxlY3Rpb24gbXVzdCBiZSBhbiBhcnJheSB3aXRoIGlkc1wiO3RoaXMuc2V0U2VsZWN0aW9uKHtub2Rlczp0fSx7aGlnaGxpZ2h0RWRnZXM6ZX0pfX0se2tleTpcInNlbGVjdEVkZ2VzXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoIXR8fHZvaWQgMD09PXQubGVuZ3RoKXRocm93XCJTZWxlY3Rpb24gbXVzdCBiZSBhbiBhcnJheSB3aXRoIGlkc1wiO3RoaXMuc2V0U2VsZWN0aW9uKHtlZGdlczp0fSl9fSx7a2V5OlwidXBkYXRlU2VsZWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZ2V0Tm9kZXMoKSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLHQuaWQpfHx0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5kZWxldGVOb2Rlcyh0KTtmb3IodmFyIGUgaW4gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZ2V0RWRnZXMoKSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5LmVkZ2VzLGUuaWQpfHx0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5kZWxldGVFZGdlcyhlKX19LHtrZXk6XCJnZXRDbGlja2VkSXRlbXNcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5jYW52YXMuRE9NdG9DYW52YXModCksaT1bXSxvPXRoaXMuYm9keS5ub2RlSW5kaWNlcyxuPXRoaXMuYm9keS5ub2RlcyxyPW8ubGVuZ3RoLTE7cj49MDtyLS0pe3ZhciBzPW5bb1tyXV0uZ2V0SXRlbXNPblBvaW50KGUpO2kucHVzaC5hcHBseShpLHMpfWZvcih2YXIgYT10aGlzLmJvZHkuZWRnZUluZGljZXMsaD10aGlzLmJvZHkuZWRnZXMsZD1hLmxlbmd0aC0xO2Q+PTA7ZC0tKXt2YXIgbD1oW2FbZF1dLmdldEl0ZW1zT25Qb2ludChlKTtpLnB1c2guYXBwbHkoaSxsKX1yZXR1cm4gaX19XSksdH0oKSx1Zj1bXSxmZj11Zi5zb3J0LHBmPXMoKGZ1bmN0aW9uKCl7dWYuc29ydCh2b2lkIDApfSkpLHZmPXMoKGZ1bmN0aW9uKCl7dWYuc29ydChudWxsKX0pKSxnZj1PbihcInNvcnRcIik7cSh7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6cGZ8fCF2Znx8IWdmfSx7c29ydDpmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dD9mZi5jYWxsKGF0KHRoaXMpKTpmZi5jYWxsKGF0KHRoaXMpLE4odCkpfX0pO3ZhciB5Zj1ndChcIkFycmF5XCIpLnNvcnQsbWY9QXJyYXkucHJvdG90eXBlLGJmPWZ1bmN0aW9uKHQpe3ZhciBlPXQuc29ydDtyZXR1cm4gdD09PW1mfHx0IGluc3RhbmNlb2YgQXJyYXkmJmU9PT1tZi5zb3J0P3lmOmV9LHdmPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLGksbyxuKXtOKGkpO3ZhciByPWF0KGUpLHM9dihyKSxhPUsoci5sZW5ndGgpLGg9dD9hLTE6MCxkPXQ/LTE6MTtpZihvPDIpZm9yKDs7KXtpZihoIGluIHMpe249c1toXSxoKz1kO2JyZWFrfWlmKGgrPWQsdD9oPDA6YTw9aCl0aHJvdyBUeXBlRXJyb3IoXCJSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlXCIpfWZvcig7dD9oPj0wOmE+aDtoKz1kKWggaW4gcyYmKG49aShuLHNbaF0saCxyKSk7cmV0dXJuIG59fSxrZj17bGVmdDp3ZighMSkscmlnaHQ6d2YoITApfS5sZWZ0LF9mPU9uKFwicmVkdWNlXCIpO3Eoe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOiFfZnx8IW9lJiZmZT43OSYmZmU8ODN9LHtyZWR1Y2U6ZnVuY3Rpb24odCl7cmV0dXJuIGtmKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoLGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19KTt2YXIgeGY9Z3QoXCJBcnJheVwiKS5yZWR1Y2UsRWY9QXJyYXkucHJvdG90eXBlLE9mPWZ1bmN0aW9uKHQpe3ZhciBlPXQucmVkdWNlO3JldHVybiB0PT09RWZ8fHQgaW5zdGFuY2VvZiBBcnJheSYmZT09PUVmLnJlZHVjZT94ZjplfSxDZj1vKChmdW5jdGlvbih0LGUpeyFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX10Ll9fZXNNb2R1bGU9ITAsdC5zb3J0PXY7dmFyIGk9MzIsbz03LG49MjU2LHI9WzEsMTAsMTAwLDFlMywxZTQsMWU1LDFlNiwxZTcsMWU4LDFlOV07ZnVuY3Rpb24gcyh0KXtyZXR1cm4gdDwxZTU/dDwxMDA/dDwxMD8wOjE6dDwxZTQ/dDwxZTM/MjozOjQ6dDwxZTc/dDwxZTY/NTo2OnQ8MWU5P3Q8MWU4Pzc6ODo5fWZ1bmN0aW9uIGEodCxlKXtpZih0PT09ZSlyZXR1cm4gMDtpZih+fnQ9PT10JiZ+fmU9PT1lKXtpZigwPT09dHx8MD09PWUpcmV0dXJuIHQ8ZT8tMToxO2lmKHQ8MHx8ZTwwKXtpZihlPj0wKXJldHVybi0xO2lmKHQ+PTApcmV0dXJuIDE7dD0tdCxlPS1lfXZhciBpPXModCksbz1zKGUpLG49MDtyZXR1cm4gaTxvPyh0Kj1yW28taS0xXSxlLz0xMCxuPS0xKTppPm8mJihlKj1yW2ktby0xXSx0Lz0xMCxuPTEpLHQ9PT1lP246dDxlPy0xOjF9dmFyIGE9U3RyaW5nKHQpLGg9U3RyaW5nKGUpO3JldHVybiBhPT09aD8wOmE8aD8tMToxfWZ1bmN0aW9uIGgodCl7Zm9yKHZhciBlPTA7dD49aTspZXw9MSZ0LHQ+Pj0xO3JldHVybiB0K2V9ZnVuY3Rpb24gZCh0LGUsaSxvKXt2YXIgbj1lKzE7aWYobj09PWkpcmV0dXJuIDE7aWYobyh0W24rK10sdFtlXSk8MCl7Zm9yKDtuPGkmJm8odFtuXSx0W24tMV0pPDA7KW4rKztsKHQsZSxuKX1lbHNlIGZvcig7bjxpJiZvKHRbbl0sdFtuLTFdKT49MDspbisrO3JldHVybiBuLWV9ZnVuY3Rpb24gbCh0LGUsaSl7Zm9yKGktLTtlPGk7KXt2YXIgbz10W2VdO3RbZSsrXT10W2ldLHRbaS0tXT1vfX1mdW5jdGlvbiBjKHQsZSxpLG8sbil7Zm9yKG89PT1lJiZvKys7bzxpO28rKyl7Zm9yKHZhciByPXRbb10scz1lLGE9bztzPGE7KXt2YXIgaD1zK2E+Pj4xO24ocix0W2hdKTwwP2E9aDpzPWgrMX12YXIgZD1vLXM7c3dpdGNoKGQpe2Nhc2UgMzp0W3MrM109dFtzKzJdO2Nhc2UgMjp0W3MrMl09dFtzKzFdO2Nhc2UgMTp0W3MrMV09dFtzXTticmVhaztkZWZhdWx0OmZvcig7ZD4wOyl0W3MrZF09dFtzK2QtMV0sZC0tfXRbc109cn19ZnVuY3Rpb24gdSh0LGUsaSxvLG4scil7dmFyIHM9MCxhPTAsaD0xO2lmKHIodCxlW2krbl0pPjApe2ZvcihhPW8tbjtoPGEmJnIodCxlW2krbitoXSk+MDspcz1oLChoPTErKGg8PDEpKTw9MCYmKGg9YSk7aD5hJiYoaD1hKSxzKz1uLGgrPW59ZWxzZXtmb3IoYT1uKzE7aDxhJiZyKHQsZVtpK24taF0pPD0wOylzPWgsKGg9MSsoaDw8MSkpPD0wJiYoaD1hKTtoPmEmJihoPWEpO3ZhciBkPXM7cz1uLWgsaD1uLWR9Zm9yKHMrKztzPGg7KXt2YXIgbD1zKyhoLXM+Pj4xKTtyKHQsZVtpK2xdKT4wP3M9bCsxOmg9bH1yZXR1cm4gaH1mdW5jdGlvbiBmKHQsZSxpLG8sbixyKXt2YXIgcz0wLGE9MCxoPTE7aWYocih0LGVbaStuXSk8MCl7Zm9yKGE9bisxO2g8YSYmcih0LGVbaStuLWhdKTwwOylzPWgsKGg9MSsoaDw8MSkpPD0wJiYoaD1hKTtoPmEmJihoPWEpO3ZhciBkPXM7cz1uLWgsaD1uLWR9ZWxzZXtmb3IoYT1vLW47aDxhJiZyKHQsZVtpK24raF0pPj0wOylzPWgsKGg9MSsoaDw8MSkpPD0wJiYoaD1hKTtoPmEmJihoPWEpLHMrPW4saCs9bn1mb3IocysrO3M8aDspe3ZhciBsPXMrKGgtcz4+PjEpO3IodCxlW2krbF0pPDA/aD1sOnM9bCsxfXJldHVybiBofXZhciBwPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChpLHIpe2UodGhpcyx0KSx0aGlzLmFycmF5PW51bGwsdGhpcy5jb21wYXJlPW51bGwsdGhpcy5taW5HYWxsb3A9byx0aGlzLmxlbmd0aD0wLHRoaXMudG1wU3RvcmFnZUxlbmd0aD1uLHRoaXMuc3RhY2tMZW5ndGg9MCx0aGlzLnJ1blN0YXJ0PW51bGwsdGhpcy5ydW5MZW5ndGg9bnVsbCx0aGlzLnN0YWNrU2l6ZT0wLHRoaXMuYXJyYXk9aSx0aGlzLmNvbXBhcmU9cix0aGlzLmxlbmd0aD1pLmxlbmd0aCx0aGlzLmxlbmd0aDwyKm4mJih0aGlzLnRtcFN0b3JhZ2VMZW5ndGg9dGhpcy5sZW5ndGg+Pj4xKSx0aGlzLnRtcD1uZXcgQXJyYXkodGhpcy50bXBTdG9yYWdlTGVuZ3RoKSx0aGlzLnN0YWNrTGVuZ3RoPXRoaXMubGVuZ3RoPDEyMD81OnRoaXMubGVuZ3RoPDE1NDI/MTA6dGhpcy5sZW5ndGg8MTE5MTUxPzE5OjQwLHRoaXMucnVuU3RhcnQ9bmV3IEFycmF5KHRoaXMuc3RhY2tMZW5ndGgpLHRoaXMucnVuTGVuZ3RoPW5ldyBBcnJheSh0aGlzLnN0YWNrTGVuZ3RoKX1yZXR1cm4gdC5wcm90b3R5cGUucHVzaFJ1bj1mdW5jdGlvbih0LGUpe3RoaXMucnVuU3RhcnRbdGhpcy5zdGFja1NpemVdPXQsdGhpcy5ydW5MZW5ndGhbdGhpcy5zdGFja1NpemVdPWUsdGhpcy5zdGFja1NpemUrPTF9LHQucHJvdG90eXBlLm1lcmdlUnVucz1mdW5jdGlvbigpe2Zvcig7dGhpcy5zdGFja1NpemU+MTspe3ZhciB0PXRoaXMuc3RhY2tTaXplLTI7aWYodD49MSYmdGhpcy5ydW5MZW5ndGhbdC0xXTw9dGhpcy5ydW5MZW5ndGhbdF0rdGhpcy5ydW5MZW5ndGhbdCsxXXx8dD49MiYmdGhpcy5ydW5MZW5ndGhbdC0yXTw9dGhpcy5ydW5MZW5ndGhbdF0rdGhpcy5ydW5MZW5ndGhbdC0xXSl0aGlzLnJ1bkxlbmd0aFt0LTFdPHRoaXMucnVuTGVuZ3RoW3QrMV0mJnQtLTtlbHNlIGlmKHRoaXMucnVuTGVuZ3RoW3RdPnRoaXMucnVuTGVuZ3RoW3QrMV0pYnJlYWs7dGhpcy5tZXJnZUF0KHQpfX0sdC5wcm90b3R5cGUuZm9yY2VNZXJnZVJ1bnM9ZnVuY3Rpb24oKXtmb3IoO3RoaXMuc3RhY2tTaXplPjE7KXt2YXIgdD10aGlzLnN0YWNrU2l6ZS0yO3Q+MCYmdGhpcy5ydW5MZW5ndGhbdC0xXTx0aGlzLnJ1bkxlbmd0aFt0KzFdJiZ0LS0sdGhpcy5tZXJnZUF0KHQpfX0sdC5wcm90b3R5cGUubWVyZ2VBdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmNvbXBhcmUsaT10aGlzLmFycmF5LG89dGhpcy5ydW5TdGFydFt0XSxuPXRoaXMucnVuTGVuZ3RoW3RdLHI9dGhpcy5ydW5TdGFydFt0KzFdLHM9dGhpcy5ydW5MZW5ndGhbdCsxXTt0aGlzLnJ1bkxlbmd0aFt0XT1uK3MsdD09PXRoaXMuc3RhY2tTaXplLTMmJih0aGlzLnJ1blN0YXJ0W3QrMV09dGhpcy5ydW5TdGFydFt0KzJdLHRoaXMucnVuTGVuZ3RoW3QrMV09dGhpcy5ydW5MZW5ndGhbdCsyXSksdGhpcy5zdGFja1NpemUtLTt2YXIgYT1mKGlbcl0saSxvLG4sMCxlKTtvKz1hLDAhPShuLT1hKSYmMCE9PShzPXUoaVtvK24tMV0saSxyLHMscy0xLGUpKSYmKG48PXM/dGhpcy5tZXJnZUxvdyhvLG4scixzKTp0aGlzLm1lcmdlSGlnaChvLG4scixzKSl9LHQucHJvdG90eXBlLm1lcmdlTG93PWZ1bmN0aW9uKHQsZSxpLG4pe3ZhciByPXRoaXMuY29tcGFyZSxzPXRoaXMuYXJyYXksYT10aGlzLnRtcCxoPTA7Zm9yKGg9MDtoPGU7aCsrKWFbaF09c1t0K2hdO3ZhciBkPTAsbD1pLGM9dDtpZihzW2MrK109c1tsKytdLDAhPS0tbilpZigxIT09ZSl7Zm9yKHZhciBwPXRoaXMubWluR2FsbG9wOzspe3ZhciB2PTAsZz0wLHk9ITE7ZG97aWYocihzW2xdLGFbZF0pPDApe2lmKHNbYysrXT1zW2wrK10sZysrLHY9MCwwPT0tLW4pe3k9ITA7YnJlYWt9fWVsc2UgaWYoc1tjKytdPWFbZCsrXSx2KyssZz0wLDE9PS0tZSl7eT0hMDticmVha319d2hpbGUoKHZ8Zyk8cCk7aWYoeSlicmVhaztkb3tpZigwIT09KHY9ZihzW2xdLGEsZCxlLDAscikpKXtmb3IoaD0wO2g8djtoKyspc1tjK2hdPWFbZCtoXTtpZihjKz12LGQrPXYsKGUtPXYpPD0xKXt5PSEwO2JyZWFrfX1pZihzW2MrK109c1tsKytdLDA9PS0tbil7eT0hMDticmVha31pZigwIT09KGc9dShhW2RdLHMsbCxuLDAscikpKXtmb3IoaD0wO2g8ZztoKyspc1tjK2hdPXNbbCtoXTtpZihjKz1nLGwrPWcsMD09KG4tPWcpKXt5PSEwO2JyZWFrfX1pZihzW2MrK109YVtkKytdLDE9PS0tZSl7eT0hMDticmVha31wLS19d2hpbGUodj49b3x8Zz49byk7aWYoeSlicmVhaztwPDAmJihwPTApLHArPTJ9aWYodGhpcy5taW5HYWxsb3A9cCxwPDEmJih0aGlzLm1pbkdhbGxvcD0xKSwxPT09ZSl7Zm9yKGg9MDtoPG47aCsrKXNbYytoXT1zW2wraF07c1tjK25dPWFbZF19ZWxzZXtpZigwPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJtZXJnZUxvdyBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZFwiKTtmb3IoaD0wO2g8ZTtoKyspc1tjK2hdPWFbZCtoXX19ZWxzZXtmb3IoaD0wO2g8bjtoKyspc1tjK2hdPXNbbCtoXTtzW2Mrbl09YVtkXX1lbHNlIGZvcihoPTA7aDxlO2grKylzW2MraF09YVtkK2hdfSx0LnByb3RvdHlwZS5tZXJnZUhpZ2g9ZnVuY3Rpb24odCxlLGksbil7dmFyIHI9dGhpcy5jb21wYXJlLHM9dGhpcy5hcnJheSxhPXRoaXMudG1wLGg9MDtmb3IoaD0wO2g8bjtoKyspYVtoXT1zW2kraF07dmFyIGQ9dCtlLTEsbD1uLTEsYz1pK24tMSxwPTAsdj0wO2lmKHNbYy0tXT1zW2QtLV0sMCE9LS1lKWlmKDEhPT1uKXtmb3IodmFyIGc9dGhpcy5taW5HYWxsb3A7Oyl7dmFyIHk9MCxtPTAsYj0hMTtkb3tpZihyKGFbbF0sc1tkXSk8MCl7aWYoc1tjLS1dPXNbZC0tXSx5KyssbT0wLDA9PS0tZSl7Yj0hMDticmVha319ZWxzZSBpZihzW2MtLV09YVtsLS1dLG0rKyx5PTAsMT09LS1uKXtiPSEwO2JyZWFrfX13aGlsZSgoeXxtKTxnKTtpZihiKWJyZWFrO2Rve2lmKDAhPSh5PWUtZihhW2xdLHMsdCxlLGUtMSxyKSkpe2ZvcihlLT15LHY9MSsoYy09eSkscD0xKyhkLT15KSxoPXktMTtoPj0wO2gtLSlzW3YraF09c1twK2hdO2lmKDA9PT1lKXtiPSEwO2JyZWFrfX1pZihzW2MtLV09YVtsLS1dLDE9PS0tbil7Yj0hMDticmVha31pZigwIT0obT1uLXUoc1tkXSxhLDAsbixuLTEscikpKXtmb3Iobi09bSx2PTErKGMtPW0pLHA9MSsobC09bSksaD0wO2g8bTtoKyspc1t2K2hdPWFbcCtoXTtpZihuPD0xKXtiPSEwO2JyZWFrfX1pZihzW2MtLV09c1tkLS1dLDA9PS0tZSl7Yj0hMDticmVha31nLS19d2hpbGUoeT49b3x8bT49byk7aWYoYilicmVhaztnPDAmJihnPTApLGcrPTJ9aWYodGhpcy5taW5HYWxsb3A9ZyxnPDEmJih0aGlzLm1pbkdhbGxvcD0xKSwxPT09bil7Zm9yKHY9MSsoYy09ZSkscD0xKyhkLT1lKSxoPWUtMTtoPj0wO2gtLSlzW3YraF09c1twK2hdO3NbY109YVtsXX1lbHNle2lmKDA9PT1uKXRocm93IG5ldyBFcnJvcihcIm1lcmdlSGlnaCBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZFwiKTtmb3IocD1jLShuLTEpLGg9MDtoPG47aCsrKXNbcCtoXT1hW2hdfX1lbHNle2Zvcih2PTErKGMtPWUpLHA9MSsoZC09ZSksaD1lLTE7aD49MDtoLS0pc1t2K2hdPXNbcCtoXTtzW2NdPWFbbF19ZWxzZSBmb3IocD1jLShuLTEpLGg9MDtoPG47aCsrKXNbcCtoXT1hW2hdfSx0fSgpO2Z1bmN0aW9uIHYodCxlLG8sbil7aWYoIUFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBvbmx5IHNvcnQgYXJyYXlzXCIpO2U/XCJmdW5jdGlvblwiIT10eXBlb2YgZSYmKG49byxvPWUsZT1hKTplPWEsb3x8KG89MCksbnx8KG49dC5sZW5ndGgpO3ZhciByPW4tbztpZighKHI8Mikpe3ZhciBzPTA7aWYocjxpKWModCxvLG4sbysocz1kKHQsbyxuLGUpKSxlKTtlbHNle3ZhciBsPW5ldyBwKHQsZSksdT1oKHIpO2Rve2lmKChzPWQodCxvLG4sZSkpPHUpe3ZhciBmPXI7Zj51JiYoZj11KSxjKHQsbyxvK2YsbytzLGUpLHM9Zn1sLnB1c2hSdW4obyxzKSxsLm1lcmdlUnVucygpLHItPXMsbys9c313aGlsZSgwIT09cik7bC5mb3JjZU1lcmdlUnVucygpfX19fShlKX0pKTtmdW5jdGlvbiBTZih0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhdmwpcmV0dXJuITE7aWYodmwuc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2bChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBpLG89X2wodCk7aWYoZSl7dmFyIG49X2wodGhpcykuY29uc3RydWN0b3I7aT12bChvLGFyZ3VtZW50cyxuKX1lbHNlIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHdsKHRoaXMsaSl9fXZhciBUZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtQbyh0aGlzLHQpfXJldHVybiBJbyh0LFt7a2V5OlwiYWJzdHJhY3RcIix2YWx1ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIkNhbid0IGluc3RhbnRpYXRlIGFic3RyYWN0IGNsYXNzIVwiKX19LHtrZXk6XCJmYWtlX3VzZVwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcImN1cnZlVHlwZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWJzdHJhY3QoKX19LHtrZXk6XCJnZXRQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZha2VfdXNlKHQpLHRoaXMuYWJzdHJhY3QoKX19LHtrZXk6XCJzZXRQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnZvaWQgMDt0aGlzLmZha2VfdXNlKHQsZSxpKSx0aGlzLmFic3RyYWN0KCl9fSx7a2V5OlwiZ2V0VHJlZVNpemVcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5mYWtlX3VzZSh0KSx0aGlzLmFic3RyYWN0KCl9fSx7a2V5Olwic29ydFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuZmFrZV91c2UodCksdGhpcy5hYnN0cmFjdCgpfX0se2tleTpcImZpeFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy5mYWtlX3VzZSh0LGUpLHRoaXMuYWJzdHJhY3QoKX19LHtrZXk6XCJzaGlmdFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy5mYWtlX3VzZSh0LGUpLHRoaXMuYWJzdHJhY3QoKX19XSksdH0oKSxNZj1mdW5jdGlvbih0KXtibChpLHQpO3ZhciBlPVNmKGkpO2Z1bmN0aW9uIGkodCl7dmFyIG87cmV0dXJuIFBvKHRoaXMsaSksKG89ZS5jYWxsKHRoaXMpKS5sYXlvdXQ9dCxvfXJldHVybiBJbyhpLFt7a2V5OlwiY3VydmVUeXBlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm5cImhvcml6b250YWxcIn19LHtrZXk6XCJnZXRQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0Lnh9fSx7a2V5Olwic2V0UG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp2b2lkIDA7dm9pZCAwIT09aSYmdGhpcy5sYXlvdXQuaGllcmFyY2hpY2FsLmFkZFRvT3JkZXJpbmcodCxpKSx0Lng9ZX19LHtrZXk6XCJnZXRUcmVlU2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMubGF5b3V0LmhpZXJhcmNoaWNhbC5nZXRUcmVlU2l6ZSh0aGlzLmxheW91dC5ib2R5Lm5vZGVzLHQpO3JldHVybnttaW46ZS5taW5feCxtYXg6ZS5tYXhfeH19fSx7a2V5Olwic29ydFwiLHZhbHVlOmZ1bmN0aW9uKHQpe0NmLnNvcnQodCwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC54LWUueH0pKX19LHtrZXk6XCJmaXhcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3QueT10aGlzLmxheW91dC5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24qZSx0Lm9wdGlvbnMuZml4ZWQueT0hMH19LHtrZXk6XCJzaGlmdFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy5sYXlvdXQuYm9keS5ub2Rlc1t0XS54Kz1lfX1dKSxpfShUZiksUGY9ZnVuY3Rpb24odCl7YmwoaSx0KTt2YXIgZT1TZihpKTtmdW5jdGlvbiBpKHQpe3ZhciBvO3JldHVybiBQbyh0aGlzLGkpLChvPWUuY2FsbCh0aGlzKSkubGF5b3V0PXQsb31yZXR1cm4gSW8oaSxbe2tleTpcImN1cnZlVHlwZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuXCJ2ZXJ0aWNhbFwifX0se2tleTpcImdldFBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHQueX19LHtrZXk6XCJzZXRQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnZvaWQgMDt2b2lkIDAhPT1pJiZ0aGlzLmxheW91dC5oaWVyYXJjaGljYWwuYWRkVG9PcmRlcmluZyh0LGkpLHQueT1lfX0se2tleTpcImdldFRyZWVTaXplXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5sYXlvdXQuaGllcmFyY2hpY2FsLmdldFRyZWVTaXplKHRoaXMubGF5b3V0LmJvZHkubm9kZXMsdCk7cmV0dXJue21pbjplLm1pbl95LG1heDplLm1heF95fX19LHtrZXk6XCJzb3J0XCIsdmFsdWU6ZnVuY3Rpb24odCl7Q2Yuc29ydCh0LChmdW5jdGlvbih0LGUpe3JldHVybiB0LnktZS55fSkpfX0se2tleTpcImZpeFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dC54PXRoaXMubGF5b3V0Lm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiplLHQub3B0aW9ucy5maXhlZC54PSEwfX0se2tleTpcInNoaWZ0XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLmxheW91dC5ib2R5Lm5vZGVzW3RdLnkrPWV9fV0pLGl9KFRmKSxEZj1XaS5ldmVyeSxCZj1PbihcImV2ZXJ5XCIpO3Eoe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOiFCZn0se2V2ZXJ5OmZ1bmN0aW9uKHQpe3JldHVybiBEZih0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pO3ZhciBJZj1ndChcIkFycmF5XCIpLmV2ZXJ5LHpmPUFycmF5LnByb3RvdHlwZSxGZj1mdW5jdGlvbih0KXt2YXIgZT10LmV2ZXJ5O3JldHVybiB0PT09emZ8fHQgaW5zdGFuY2VvZiBBcnJheSYmZT09PXpmLmV2ZXJ5P0lmOmV9O2Z1bmN0aW9uIE5mKHQsZSl7dmFyIGk7aWYodm9pZCAwPT09Y258fG51bGw9PUNpKHQpKXtpZihnbih0KXx8KGk9ZnVuY3Rpb24odCxlKXt2YXIgaTtpZighdClyZXR1cm47aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIEFmKHQsZSk7dmFyIG89dm4oaT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpLmNhbGwoaSw4LC0xKTtcIk9iamVjdFwiPT09byYmdC5jb25zdHJ1Y3RvciYmKG89dC5jb25zdHJ1Y3Rvci5uYW1lKTtpZihcIk1hcFwiPT09b3x8XCJTZXRcIj09PW8pcmV0dXJuIG1pKHQpO2lmKFwiQXJndW1lbnRzXCI9PT1vfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChvKSlyZXR1cm4gQWYodCxlKX0odCkpfHxlJiZ0JiZcIm51bWJlclwiPT10eXBlb2YgdC5sZW5ndGgpe2kmJih0PWkpO3ZhciBvPTAsbj1mdW5jdGlvbigpe307cmV0dXJue3M6bixuOmZ1bmN0aW9uKCl7cmV0dXJuIG8+PXQubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTp0W28rK119fSxlOmZ1bmN0aW9uKHQpe3Rocm93IHR9LGY6bn19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXZhciByLHM9ITAsYT0hMTtyZXR1cm57czpmdW5jdGlvbigpe2k9U2kodCl9LG46ZnVuY3Rpb24oKXt2YXIgdD1pLm5leHQoKTtyZXR1cm4gcz10LmRvbmUsdH0sZTpmdW5jdGlvbih0KXthPSEwLHI9dH0sZjpmdW5jdGlvbigpe3RyeXtzfHxudWxsPT1pLnJldHVybnx8aS5yZXR1cm4oKX1maW5hbGx5e2lmKGEpdGhyb3cgcn19fX1mdW5jdGlvbiBBZih0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgaT0wLG89bmV3IEFycmF5KGUpO2k8ZTtpKyspb1tpXT10W2ldO3JldHVybiBvfWZ1bmN0aW9uIFJmKHQsZSl7dmFyIGk9bmV3IFJ1O3JldHVybiBEbih0KS5jYWxsKHQsKGZ1bmN0aW9uKHQpe3ZhciBlO0RuKGU9dC5lZGdlcykuY2FsbChlLChmdW5jdGlvbih0KXt0LmNvbm5lY3RlZCYmaS5hZGQodCl9KSl9KSksRG4oaSkuY2FsbChpLChmdW5jdGlvbih0KXt2YXIgaT10LmZyb20uaWQsbz10LnRvLmlkO251bGw9PWVbaV0mJihlW2ldPTApLChudWxsPT1lW29dfHxlW2ldPj1lW29dKSYmKGVbb109ZVtpXSsxKX0pKSxlfWZ1bmN0aW9uIGpmKHQsZSxpLG8pe3ZhciBuLHIscz1JcihudWxsKSxhPU9mKG49bG4obmwobykuY2FsbChvKSkpLmNhbGwobiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCsxK2UuZWRnZXMubGVuZ3RofSksMCksaD1pK1wiSWRcIixkPVwidG9cIj09PWk/MTotMSxsPU5mKG8pO3RyeXt2YXIgYz1mdW5jdGlvbigpe3ZhciBuPWFuKHIudmFsdWUsMiksbD1uWzBdLGM9blsxXTtpZighby5oYXMobCl8fCF0KGMpKXJldHVyblwiY29udGludWVcIjtzW2xdPTA7Zm9yKHZhciB1PVtjXSxmPTAscD12b2lkIDAsdj1mdW5jdGlvbigpe3ZhciB0LG47aWYoIW8uaGFzKGwpKXJldHVyblwiY29udGludWVcIjt2YXIgcj1zW3AuaWRdK2Q7aWYoRG4odD1hcihuPXAuZWRnZXMpLmNhbGwobiwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29ubmVjdGVkJiZ0LnRvIT09dC5mcm9tJiZ0W2ldIT09cCYmby5oYXModC50b0lkKSYmby5oYXModC5mcm9tSWQpfSkpKS5jYWxsKHQsKGZ1bmN0aW9uKHQpe3ZhciBvPXRbaF0sbj1zW29dOyhudWxsPT1ufHxlKHIsbikpJiYoc1tvXT1yLHUucHVzaCh0W2ldKSl9KSksZj5hKXJldHVybnt2Ont2OlJmKG8scyl9fTsrK2Z9O3A9dS5wb3AoKTspe3ZhciBnPXYoKTtpZihcImNvbnRpbnVlXCIhPT1nJiZcIm9iamVjdFwiPT09ZG4oZykpcmV0dXJuIGcudn19O2ZvcihsLnMoKTshKHI9bC5uKCkpLmRvbmU7KXt2YXIgdT1jKCk7aWYoXCJjb250aW51ZVwiIT09dSYmXCJvYmplY3RcIj09PWRuKHUpKXJldHVybiB1LnZ9fWNhdGNoKHQpe2wuZSh0KX1maW5hbGx5e2wuZigpfXJldHVybiBzfXZhciBMZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtQbyh0aGlzLHQpLHRoaXMuY2hpbGRyZW5SZWZlcmVuY2U9e30sdGhpcy5wYXJlbnRSZWZlcmVuY2U9e30sdGhpcy50cmVlcz17fSx0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nPXt9LHRoaXMubGV2ZWxzPXt9LHRoaXMuZGlzdHJpYnV0aW9uSW5kZXg9e30sdGhpcy5pc1RyZWU9ITEsdGhpcy50cmVlSW5kZXg9LTF9cmV0dXJuIElvKHQsW3trZXk6XCJhZGRSZWxhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09dGhpcy5jaGlsZHJlblJlZmVyZW5jZVt0XSYmKHRoaXMuY2hpbGRyZW5SZWZlcmVuY2VbdF09W10pLHRoaXMuY2hpbGRyZW5SZWZlcmVuY2VbdF0ucHVzaChlKSx2b2lkIDA9PT10aGlzLnBhcmVudFJlZmVyZW5jZVtlXSYmKHRoaXMucGFyZW50UmVmZXJlbmNlW2VdPVtdKSx0aGlzLnBhcmVudFJlZmVyZW5jZVtlXS5wdXNoKHQpfX0se2tleTpcImNoZWNrSWZUcmVlXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5wYXJlbnRSZWZlcmVuY2UpaWYodGhpcy5wYXJlbnRSZWZlcmVuY2VbdF0ubGVuZ3RoPjEpcmV0dXJuIHZvaWQodGhpcy5pc1RyZWU9ITEpO3RoaXMuaXNUcmVlPSEwfX0se2tleTpcIm51bVRyZWVzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmVlSW5kZXgrMX19LHtrZXk6XCJzZXRUcmVlSW5kZXhcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZvaWQgMCE9PWUmJnZvaWQgMD09PXRoaXMudHJlZXNbdC5pZF0mJih0aGlzLnRyZWVzW3QuaWRdPWUsdGhpcy50cmVlSW5kZXg9TWF0aC5tYXgoZSx0aGlzLnRyZWVJbmRleCkpfX0se2tleTpcImVuc3VyZUxldmVsXCIsdmFsdWU6ZnVuY3Rpb24odCl7dm9pZCAwPT09dGhpcy5sZXZlbHNbdF0mJih0aGlzLmxldmVsc1t0XT0wKX19LHtrZXk6XCJnZXRNYXhMZXZlbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsaT17fTtyZXR1cm4gZnVuY3Rpb24gdChvKXtpZih2b2lkIDAhPT1pW29dKXJldHVybiBpW29dO3ZhciBuPWUubGV2ZWxzW29dO2lmKGUuY2hpbGRyZW5SZWZlcmVuY2Vbb10pe3ZhciByPWUuY2hpbGRyZW5SZWZlcmVuY2Vbb107aWYoci5sZW5ndGg+MClmb3IodmFyIHM9MDtzPHIubGVuZ3RoO3MrKyluPU1hdGgubWF4KG4sdChyW3NdKSl9cmV0dXJuIGlbb109bixufSh0KX19LHtrZXk6XCJsZXZlbERvd25zdHJlYW1cIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PXRoaXMubGV2ZWxzW2UuaWRdJiYodm9pZCAwPT09dGhpcy5sZXZlbHNbdC5pZF0mJih0aGlzLmxldmVsc1t0LmlkXT0wKSx0aGlzLmxldmVsc1tlLmlkXT10aGlzLmxldmVsc1t0LmlkXSsxKX19LHtrZXk6XCJzZXRNaW5MZXZlbFRvWmVyb1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPTFlOTtmb3IodmFyIGkgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxpKSYmdm9pZCAwIT09dGhpcy5sZXZlbHNbaV0mJihlPU1hdGgubWluKHRoaXMubGV2ZWxzW2ldLGUpKTtmb3IodmFyIG8gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSYmdm9pZCAwIT09dGhpcy5sZXZlbHNbb10mJih0aGlzLmxldmVsc1tvXS09ZSl9fSx7a2V5OlwiZ2V0VHJlZVNpemVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPTFlOSxvPS0xZTksbj0xZTkscj0tMWU5O2Zvcih2YXIgcyBpbiB0aGlzLnRyZWVzKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnRyZWVzLHMpJiZ0aGlzLnRyZWVzW3NdPT09ZSl7dmFyIGE9dFtzXTtpPU1hdGgubWluKGEueCxpKSxvPU1hdGgubWF4KGEueCxvKSxuPU1hdGgubWluKGEueSxuKSxyPU1hdGgubWF4KGEueSxyKX1yZXR1cm57bWluX3g6aSxtYXhfeDpvLG1pbl95Om4sbWF4X3k6cn19fSx7a2V5OlwiaGFzU2FtZVBhcmVudFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9dGhpcy5wYXJlbnRSZWZlcmVuY2VbdC5pZF0sbz10aGlzLnBhcmVudFJlZmVyZW5jZVtlLmlkXTtpZih2b2lkIDA9PT1pfHx2b2lkIDA9PT1vKXJldHVybiExO2Zvcih2YXIgbj0wO248aS5sZW5ndGg7bisrKWZvcih2YXIgcj0wO3I8by5sZW5ndGg7cisrKWlmKGlbbl09PW9bcl0pcmV0dXJuITA7cmV0dXJuITF9fSx7a2V5OlwiaW5TYW1lU3ViTmV0d29ya1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudHJlZXNbdC5pZF09PT10aGlzLnRyZWVzW2UuaWRdfX0se2tleTpcImdldExldmVsc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHhuKHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmcpfX0se2tleTpcImFkZFRvT3JkZXJpbmdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PXRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbZV0mJih0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2VdPVtdKTt2YXIgaT0hMSxvPXRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbZV07Zm9yKHZhciBuIGluIG8paWYob1tuXT09PXQpe2k9ITA7YnJlYWt9aXx8KHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbZV0ucHVzaCh0KSx0aGlzLmRpc3RyaWJ1dGlvbkluZGV4W3QuaWRdPXRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbZV0ubGVuZ3RoLTEpfX1dKSx0fSgpLEhmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXtQbyh0aGlzLHQpLHRoaXMuYm9keT1lLHRoaXMuX3Jlc2V0Uk5HKE1hdGgucmFuZG9tKCkrXCI6XCIrRW4oKSksdGhpcy5zZXRQaHlzaWNzPSExLHRoaXMub3B0aW9ucz17fSx0aGlzLm9wdGlvbnNCYWNrdXA9e3BoeXNpY3M6e319LHRoaXMuZGVmYXVsdE9wdGlvbnM9e3JhbmRvbVNlZWQ6dm9pZCAwLGltcHJvdmVkTGF5b3V0OiEwLGNsdXN0ZXJUaHJlc2hvbGQ6MTUwLGhpZXJhcmNoaWNhbDp7ZW5hYmxlZDohMSxsZXZlbFNlcGFyYXRpb246MTUwLG5vZGVTcGFjaW5nOjEwMCx0cmVlU3BhY2luZzoyMDAsYmxvY2tTaGlmdGluZzohMCxlZGdlTWluaW1pemF0aW9uOiEwLHBhcmVudENlbnRyYWxpemF0aW9uOiEwLGRpcmVjdGlvbjpcIlVEXCIsc29ydE1ldGhvZDpcImh1YnNpemVcIn19LGN0KHRoaXMub3B0aW9ucyx0aGlzLmRlZmF1bHRPcHRpb25zKSx0aGlzLmJpbmRFdmVudExpc3RlbmVycygpfXJldHVybiBJbyh0LFt7a2V5OlwiYmluZEV2ZW50TGlzdGVuZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsKGZ1bmN0aW9uKCl7dC5zZXR1cEhpZXJhcmNoaWNhbExheW91dCgpfSkpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFMb2FkZWRcIiwoZnVuY3Rpb24oKXt0LmxheW91dE5ldHdvcmsoKX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXNldEhpZXJhcmNoaWNhbExheW91dFwiLChmdW5jdGlvbigpe3Quc2V0dXBIaWVyYXJjaGljYWxMYXlvdXQoKX0pKSx0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dFwiLChmdW5jdGlvbigpe2lmKCEwPT09dC5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkKXt2YXIgZT10LmRpcmVjdGlvbi5jdXJ2ZVR5cGUoKTt0LmJvZHkuZW1pdHRlci5lbWl0KFwiX2ZvcmNlRGlzYWJsZUR5bmFtaWNDdXJ2ZXNcIixlLCExKX19KSl9fSx7a2V5Olwic2V0T3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwIT09dCl7dmFyIGk9dGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbCxvPWkuZW5hYmxlZDtpZihaYShbXCJyYW5kb21TZWVkXCIsXCJpbXByb3ZlZExheW91dFwiLFwiY2x1c3RlclRocmVzaG9sZFwiXSx0aGlzLm9wdGlvbnMsdCksZ2godGhpcy5vcHRpb25zLHQsXCJoaWVyYXJjaGljYWxcIiksdm9pZCAwIT09dC5yYW5kb21TZWVkJiZ0aGlzLl9yZXNldFJORyh0LnJhbmRvbVNlZWQpLCEwPT09aS5lbmFibGVkKXJldHVybiEwPT09byYmdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlZnJlc2hcIiwhMCksXCJSTFwiPT09aS5kaXJlY3Rpb258fFwiRFVcIj09PWkuZGlyZWN0aW9uP2kubGV2ZWxTZXBhcmF0aW9uPjAmJihpLmxldmVsU2VwYXJhdGlvbio9LTEpOmkubGV2ZWxTZXBhcmF0aW9uPDAmJihpLmxldmVsU2VwYXJhdGlvbio9LTEpLHRoaXMuc2V0RGlyZWN0aW9uU3RyYXRlZ3koKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2V0SGllcmFyY2hpY2FsTGF5b3V0XCIpLHRoaXMuYWRhcHRBbGxPcHRpb25zRm9ySGllcmFyY2hpY2FsTGF5b3V0KGUpO2lmKCEwPT09bylyZXR1cm4gdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlZnJlc2hcIiksdGgoZSx0aGlzLm9wdGlvbnNCYWNrdXApfXJldHVybiBlfX0se2tleTpcIl9yZXNldFJOR1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuaW5pdGlhbFJhbmRvbVNlZWQ9dCx0aGlzLl9ybmc9UmEodGhpcy5pbml0aWFsUmFuZG9tU2VlZCl9fSx7a2V5OlwiYWRhcHRBbGxPcHRpb25zRm9ySGllcmFyY2hpY2FsTGF5b3V0XCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoITA9PT10aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQpe3ZhciBlPXRoaXMub3B0aW9uc0JhY2t1cC5waHlzaWNzO3ZvaWQgMD09PXQucGh5c2ljc3x8ITA9PT10LnBoeXNpY3M/KHQucGh5c2ljcz17ZW5hYmxlZDp2b2lkIDA9PT1lLmVuYWJsZWR8fGUuZW5hYmxlZCxzb2x2ZXI6XCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIn0sZS5lbmFibGVkPXZvaWQgMD09PWUuZW5hYmxlZHx8ZS5lbmFibGVkLGUuc29sdmVyPWUuc29sdmVyfHxcImJhcm5lc0h1dFwiKTpcIm9iamVjdFwiPT09ZG4odC5waHlzaWNzKT8oZS5lbmFibGVkPXZvaWQgMD09PXQucGh5c2ljcy5lbmFibGVkfHx0LnBoeXNpY3MuZW5hYmxlZCxlLnNvbHZlcj10LnBoeXNpY3Muc29sdmVyfHxcImJhcm5lc0h1dFwiLHQucGh5c2ljcy5zb2x2ZXI9XCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIik6ITEhPT10LnBoeXNpY3MmJihlLnNvbHZlcj1cImJhcm5lc0h1dFwiLHQucGh5c2ljcz17c29sdmVyOlwiaGllcmFyY2hpY2FsUmVwdWxzaW9uXCJ9KTt2YXIgaT10aGlzLmRpcmVjdGlvbi5jdXJ2ZVR5cGUoKTtpZih2b2lkIDA9PT10LmVkZ2VzKXRoaXMub3B0aW9uc0JhY2t1cC5lZGdlcz17c21vb3RoOntlbmFibGVkOiEwLHR5cGU6XCJkeW5hbWljXCJ9fSx0LmVkZ2VzPXtzbW9vdGg6ITF9O2Vsc2UgaWYodm9pZCAwPT09dC5lZGdlcy5zbW9vdGgpdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzPXtzbW9vdGg6e2VuYWJsZWQ6ITAsdHlwZTpcImR5bmFtaWNcIn19LHQuZWRnZXMuc21vb3RoPSExO2Vsc2UgaWYoXCJib29sZWFuXCI9PXR5cGVvZiB0LmVkZ2VzLnNtb290aCl0aGlzLm9wdGlvbnNCYWNrdXAuZWRnZXM9e3Ntb290aDp0LmVkZ2VzLnNtb290aH0sdC5lZGdlcy5zbW9vdGg9e2VuYWJsZWQ6dC5lZGdlcy5zbW9vdGgsdHlwZTppfTtlbHNle3ZhciBvPXQuZWRnZXMuc21vb3RoO3ZvaWQgMCE9PW8udHlwZSYmXCJkeW5hbWljXCIhPT1vLnR5cGUmJihpPW8udHlwZSksdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzPXtzbW9vdGg6e2VuYWJsZWQ6dm9pZCAwPT09by5lbmFibGVkfHxvLmVuYWJsZWQsdHlwZTp2b2lkIDA9PT1vLnR5cGU/XCJkeW5hbWljXCI6by50eXBlLHJvdW5kbmVzczp2b2lkIDA9PT1vLnJvdW5kbmVzcz8uNTpvLnJvdW5kbmVzcyxmb3JjZURpcmVjdGlvbjp2b2lkIDAhPT1vLmZvcmNlRGlyZWN0aW9uJiZvLmZvcmNlRGlyZWN0aW9ufX0sdC5lZGdlcy5zbW9vdGg9e2VuYWJsZWQ6dm9pZCAwPT09by5lbmFibGVkfHxvLmVuYWJsZWQsdHlwZTppLHJvdW5kbmVzczp2b2lkIDA9PT1vLnJvdW5kbmVzcz8uNTpvLnJvdW5kbmVzcyxmb3JjZURpcmVjdGlvbjp2b2lkIDAhPT1vLmZvcmNlRGlyZWN0aW9uJiZvLmZvcmNlRGlyZWN0aW9ufX10aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2ZvcmNlRGlzYWJsZUR5bmFtaWNDdXJ2ZXNcIixpKX1yZXR1cm4gdH19LHtrZXk6XCJwb3NpdGlvbkluaXRpYWxseVwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKCEwIT09dGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkKXt0aGlzLl9yZXNldFJORyh0aGlzLmluaXRpYWxSYW5kb21TZWVkKTtmb3IodmFyIGU9dC5sZW5ndGgrNTAsaT0wO2k8dC5sZW5ndGg7aSsrKXt2YXIgbz10W2ldLG49MipNYXRoLlBJKnRoaXMuX3JuZygpO3ZvaWQgMD09PW8ueCYmKG8ueD1lKk1hdGguY29zKG4pKSx2b2lkIDA9PT1vLnkmJihvLnk9ZSpNYXRoLnNpbihuKSl9fX19LHtrZXk6XCJsYXlvdXROZXR3b3JrXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZighMCE9PXRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCYmITA9PT10aGlzLm9wdGlvbnMuaW1wcm92ZWRMYXlvdXQpe2Zvcih2YXIgdD10aGlzLmJvZHkubm9kZUluZGljZXMsZT0wLGk9MDtpPHQubGVuZ3RoO2krKyl7ITA9PT10aGlzLmJvZHkubm9kZXNbdFtpXV0ucHJlZGVmaW5lZFBvc2l0aW9uJiYoZSs9MSl9aWYoZTwuNSp0Lmxlbmd0aCl7dmFyIG89MCxuPXRoaXMub3B0aW9ucy5jbHVzdGVyVGhyZXNob2xkLHI9e2NsdXN0ZXJOb2RlUHJvcGVydGllczp7c2hhcGU6XCJlbGxpcHNlXCIsbGFiZWw6XCJcIixncm91cDpcIlwiLGZvbnQ6e211bHRpOiExfX0sY2x1c3RlckVkZ2VQcm9wZXJ0aWVzOntsYWJlbDpcIlwiLGZvbnQ6e211bHRpOiExfSxzbW9vdGg6e2VuYWJsZWQ6ITF9fX07aWYodC5sZW5ndGg+bil7Zm9yKHZhciBzPXQubGVuZ3RoO3QubGVuZ3RoPm4mJm88PTEwOyl7bys9MTt2YXIgYT10Lmxlbmd0aDtpZihvJTM9PTA/dGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZy5jbHVzdGVyQnJpZGdlcyhyKTp0aGlzLmJvZHkubW9kdWxlcy5jbHVzdGVyaW5nLmNsdXN0ZXJPdXRsaWVycyhyKSxhPT10Lmxlbmd0aCYmbyUzIT0wKXJldHVybiB0aGlzLl9kZWNsdXN0ZXJBbGwoKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2xheW91dEZhaWxlZFwiKSx2b2lkIGNvbnNvbGUuaW5mbyhcIlRoaXMgbmV0d29yayBjb3VsZCBub3QgYmUgcG9zaXRpb25lZCBieSB0aGlzIHZlcnNpb24gb2YgdGhlIGltcHJvdmVkIGxheW91dCBhbGdvcml0aG0uIFBsZWFzZSBkaXNhYmxlIGltcHJvdmVkTGF5b3V0IGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXCIpfXRoaXMuYm9keS5tb2R1bGVzLmthbWFkYUthd2FpLnNldE9wdGlvbnMoe3NwcmluZ0xlbmd0aDpNYXRoLm1heCgxNTAsMipzKX0pfW8+MTAmJmNvbnNvbGUuaW5mbyhcIlRoZSBjbHVzdGVyaW5nIGRpZG4ndCBzdWNjZWVkIHdpdGhpbiB0aGUgYW1vdW50IG9mIGludGVyYXRpb25zIGFsbG93ZWQsIHByb2dyZXNzaW5nIHdpdGggcGFydGlhbCByZXN1bHQuXCIpLHRoaXMuYm9keS5tb2R1bGVzLmthbWFkYUthd2FpLnNvbHZlKHQsdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLCEwKSx0aGlzLl9zaGlmdFRvQ2VudGVyKCk7Zm9yKHZhciBoPTA7aDx0Lmxlbmd0aDtoKyspe3ZhciBkPXRoaXMuYm9keS5ub2Rlc1t0W2hdXTshMT09PWQucHJlZGVmaW5lZFBvc2l0aW9uJiYoZC54Kz03MCooLjUtdGhpcy5fcm5nKCkpLGQueSs9NzAqKC41LXRoaXMuX3JuZygpKSl9dGhpcy5fZGVjbHVzdGVyQWxsKCksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXBvc2l0aW9uQmV6aWVyTm9kZXNcIil9fX19LHtrZXk6XCJfc2hpZnRUb0NlbnRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXd1LmdldFJhbmdlQ29yZSh0aGlzLmJvZHkubm9kZXMsdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKSxlPXd1LmZpbmRDZW50ZXIodCksaT0wO2k8dGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDtpKyspe3ZhciBvPXRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dO28ueC09ZS54LG8ueS09ZS55fX19LHtrZXk6XCJfZGVjbHVzdGVyQWxsXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9ITA7ITA9PT10Oyl7dD0hMTtmb3IodmFyIGU9MDtlPHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7ZSsrKSEwPT09dGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tlXV0uaXNDbHVzdGVyJiYodD0hMCx0aGlzLmJvZHkubW9kdWxlcy5jbHVzdGVyaW5nLm9wZW5DbHVzdGVyKHRoaXMuYm9keS5ub2RlSW5kaWNlc1tlXSx7fSwhMSkpOyEwPT09dCYmdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKX19fSx7a2V5OlwiZ2V0U2VlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5pdGlhbFJhbmRvbVNlZWR9fSx7a2V5Olwic2V0dXBIaWVyYXJjaGljYWxMYXlvdXRcIix2YWx1ZTpmdW5jdGlvbigpe2lmKCEwPT09dGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkJiZ0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoPjApe3ZhciB0LGUsaT0hMSxvPSExO2ZvcihlIGluIHRoaXMubGFzdE5vZGVPbkxldmVsPXt9LHRoaXMuaGllcmFyY2hpY2FsPW5ldyBMZix0aGlzLmJvZHkubm9kZXMpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2RlcyxlKSYmKHZvaWQgMCE9PSh0PXRoaXMuYm9keS5ub2Rlc1tlXSkub3B0aW9ucy5sZXZlbD8oaT0hMCx0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbZV09dC5vcHRpb25zLmxldmVsKTpvPSEwKTtpZighMD09PW8mJiEwPT09aSl0aHJvdyBuZXcgRXJyb3IoXCJUbyB1c2UgdGhlIGhpZXJhcmNoaWNhbCBsYXlvdXQsIG5vZGVzIHJlcXVpcmUgZWl0aGVyIG5vIHByZWRlZmluZWQgbGV2ZWxzIG9yIGxldmVscyBoYXZlIHRvIGJlIGRlZmluZWQgZm9yIGFsbCBub2Rlcy5cIik7aWYoITA9PT1vKXt2YXIgbj10aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnNvcnRNZXRob2Q7XCJodWJzaXplXCI9PT1uP3RoaXMuX2RldGVybWluZUxldmVsc0J5SHVic2l6ZSgpOlwiZGlyZWN0ZWRcIj09PW4/dGhpcy5fZGV0ZXJtaW5lTGV2ZWxzRGlyZWN0ZWQoKTpcImN1c3RvbVwiPT09biYmdGhpcy5fZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2soKX1mb3IodmFyIHIgaW4gdGhpcy5ib2R5Lm5vZGVzKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMscikmJnRoaXMuaGllcmFyY2hpY2FsLmVuc3VyZUxldmVsKHIpO3ZhciBzPXRoaXMuX2dldERpc3RyaWJ1dGlvbigpO3RoaXMuX2dlbmVyYXRlTWFwKCksdGhpcy5fcGxhY2VOb2Rlc0J5SGllcmFyY2h5KHMpLHRoaXMuX2NvbmRlbnNlSGllcmFyY2h5KCksdGhpcy5fc2hpZnRUb0NlbnRlcigpfX19LHtrZXk6XCJfY29uZGVuc2VIaWVyYXJjaHlcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT0hMSxpPXt9LG89ZnVuY3Rpb24oZSxpKXt2YXIgbz10LmhpZXJhcmNoaWNhbC50cmVlcztmb3IodmFyIG4gaW4gbylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobyxuKSYmb1tuXT09PWUmJnQuZGlyZWN0aW9uLnNoaWZ0KG4saSl9LG49ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10saT0wO2k8dC5oaWVyYXJjaGljYWwubnVtVHJlZXMoKTtpKyspZS5wdXNoKHQuZGlyZWN0aW9uLmdldFRyZWVTaXplKGkpKTtyZXR1cm4gZX0scj1mdW5jdGlvbiBlKGksbyl7aWYoIW9baS5pZF0mJihvW2kuaWRdPSEwLHQuaGllcmFyY2hpY2FsLmNoaWxkcmVuUmVmZXJlbmNlW2kuaWRdKSl7dmFyIG49dC5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2VbaS5pZF07aWYobi5sZW5ndGg+MClmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyllKHQuYm9keS5ub2Rlc1tuW3JdXSxvKX19LHM9ZnVuY3Rpb24oZSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjFlOSxvPTFlOSxuPTFlOSxyPTFlOSxzPS0xZTk7Zm9yKHZhciBhIGluIGUpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsYSkpe3ZhciBoPXQuYm9keS5ub2Rlc1thXSxkPXQuaGllcmFyY2hpY2FsLmxldmVsc1toLmlkXSxsPXQuZGlyZWN0aW9uLmdldFBvc2l0aW9uKGgpLGM9dC5fZ2V0U3BhY2VBcm91bmROb2RlKGgsZSksdT1hbihjLDIpLGY9dVswXSxwPXVbMV07bz1NYXRoLm1pbihmLG8pLG49TWF0aC5taW4ocCxuKSxkPD1pJiYocj1NYXRoLm1pbihsLHIpLHM9TWF0aC5tYXgobCxzKSl9cmV0dXJuW3IscyxvLG5dfSxhPWZ1bmN0aW9uKGUsaSl7dmFyIG89dC5oaWVyYXJjaGljYWwuZ2V0TWF4TGV2ZWwoZS5pZCksbj10LmhpZXJhcmNoaWNhbC5nZXRNYXhMZXZlbChpLmlkKTtyZXR1cm4gTWF0aC5taW4obyxuKX0saD1mdW5jdGlvbihlLGksbyl7Zm9yKHZhciBuPXQuaGllcmFyY2hpY2FsLHI9MDtyPGkubGVuZ3RoO3IrKyl7dmFyIHM9aVtyXSxhPW4uZGlzdHJpYnV0aW9uT3JkZXJpbmdbc107aWYoYS5sZW5ndGg+MSlmb3IodmFyIGg9MDtoPGEubGVuZ3RoLTE7aCsrKXt2YXIgZD1hW2hdLGw9YVtoKzFdO24uaGFzU2FtZVBhcmVudChkLGwpJiZuLmluU2FtZVN1Yk5ldHdvcmsoZCxsKSYmZShkLGwsbyl9fX0sZD1mdW5jdGlvbihpLG8pe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl0saD10LmRpcmVjdGlvbi5nZXRQb3NpdGlvbihpKSxkPXQuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG8pLGw9TWF0aC5hYnMoZC1oKSxjPXQub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmc7aWYobD5jKXt2YXIgdT17fSxmPXt9O3IoaSx1KSxyKG8sZik7dmFyIHA9YShpLG8pLHY9cyh1LHApLGc9cyhmLHApLHk9dlsxXSxtPWdbMF0sYj1nWzJdLHc9TWF0aC5hYnMoeS1tKTtpZih3PmMpe3ZhciBrPXktbStjO2s8LWIrYyYmKGs9LWIrYyksazwwJiYodC5fc2hpZnRCbG9jayhvLmlkLGspLGU9ITAsITA9PT1uJiZ0Ll9jZW50ZXJQYXJlbnQobykpfX19LGw9ZnVuY3Rpb24obyxuKXtmb3IodmFyIGE9bi5pZCxoPW4uZWRnZXMsZD10LmhpZXJhcmNoaWNhbC5sZXZlbHNbbi5pZF0sbD10Lm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbip0Lm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbixjPXt9LHU9W10sZj0wO2Y8aC5sZW5ndGg7ZisrKXt2YXIgcD1oW2ZdO2lmKHAudG9JZCE9cC5mcm9tSWQpe3ZhciB2PXAudG9JZD09YT9wLmZyb206cC50bztjW2hbZl0uaWRdPXYsdC5oaWVyYXJjaGljYWwubGV2ZWxzW3YuaWRdPGQmJnUucHVzaChwKX19dmFyIGc9ZnVuY3Rpb24oZSxpKXtmb3IodmFyIG89MCxuPTA7bjxpLmxlbmd0aDtuKyspaWYodm9pZCAwIT09Y1tpW25dLmlkXSl7dmFyIHI9dC5kaXJlY3Rpb24uZ2V0UG9zaXRpb24oY1tpW25dLmlkXSktZTtvKz1yL01hdGguc3FydChyKnIrbCl9cmV0dXJuIG99LHk9ZnVuY3Rpb24oZSxpKXtmb3IodmFyIG89MCxuPTA7bjxpLmxlbmd0aDtuKyspaWYodm9pZCAwIT09Y1tpW25dLmlkXSl7dmFyIHI9dC5kaXJlY3Rpb24uZ2V0UG9zaXRpb24oY1tpW25dLmlkXSktZTtvLT1sKk1hdGgucG93KHIqcitsLC0xLjUpfXJldHVybiBvfSxtPWZ1bmN0aW9uKGUsaSl7Zm9yKHZhciBvPXQuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG4pLHI9e30scz0wO3M8ZTtzKyspe3ZhciBhPWcobyxpKSxoPXkobyxpKTtpZih2b2lkIDAhPT1yW28tPU1hdGgubWF4KC00MCxNYXRoLm1pbig0MCxNYXRoLnJvdW5kKGEvaCkpKV0pYnJlYWs7cltvXT1zfXJldHVybiBvfSxiPW0obyx1KTshZnVuY3Rpb24obyl7dmFyIGE9dC5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obik7aWYodm9pZCAwPT09aVtuLmlkXSl7dmFyIGg9e307cihuLGgpLGlbbi5pZF09aH12YXIgZD1zKGlbbi5pZF0pLGw9ZFsyXSxjPWRbM10sdT1vLWEsZj0wO3U+MD9mPU1hdGgubWluKHUsYy10Lm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKTp1PDAmJihmPS1NYXRoLm1pbigtdSxsLXQub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpKSwwIT1mJiYodC5fc2hpZnRCbG9jayhuLmlkLGYpLGU9ITApfShiKSxmdW5jdGlvbihpKXt2YXIgbz10LmRpcmVjdGlvbi5nZXRQb3NpdGlvbihuKSxyPWFuKHQuX2dldFNwYWNlQXJvdW5kTm9kZShuKSwyKSxzPXJbMF0sYT1yWzFdLGg9aS1vLGQ9bztoPjA/ZD1NYXRoLm1pbihvKyhhLXQub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpLGkpOmg8MCYmKGQ9TWF0aC5tYXgoby0ocy10Lm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKSxpKSksZCE9PW8mJih0LmRpcmVjdGlvbi5zZXRQb3NpdGlvbihuLGQpLGU9ITApfShiPW0obyxoKSl9OyEwPT09dGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ibG9ja1NoaWZ0aW5nJiYoZnVuY3Rpb24oaSl7dmFyIG89dC5oaWVyYXJjaGljYWwuZ2V0TGV2ZWxzKCk7bz1ObihvKS5jYWxsKG8pO2Zvcih2YXIgbj0wO248aSYmKGU9ITEsaChkLG8sITApLCEwPT09ZSk7bisrKTt9KDUpLGZ1bmN0aW9uKCl7Zm9yKHZhciBlIGluIHQuYm9keS5ub2RlcylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodC5ib2R5Lm5vZGVzLGUpJiZ0Ll9jZW50ZXJQYXJlbnQodC5ib2R5Lm5vZGVzW2VdKX0oKSksITA9PT10aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVkZ2VNaW5pbWl6YXRpb24mJmZ1bmN0aW9uKGkpe3ZhciBvPXQuaGllcmFyY2hpY2FsLmdldExldmVscygpO289Tm4obykuY2FsbChvKTtmb3IodmFyIG49MDtuPGk7bisrKXtlPSExO2Zvcih2YXIgcj0wO3I8by5sZW5ndGg7cisrKWZvcih2YXIgcz1vW3JdLGE9dC5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uT3JkZXJpbmdbc10saD0wO2g8YS5sZW5ndGg7aCsrKWwoMWUzLGFbaF0pO2lmKCEwIT09ZSlicmVha319KDIwKSwhMD09PXRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwucGFyZW50Q2VudHJhbGl6YXRpb24mJmZ1bmN0aW9uKCl7dmFyIGU9dC5oaWVyYXJjaGljYWwuZ2V0TGV2ZWxzKCk7ZT1ObihlKS5jYWxsKGUpO2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKWZvcih2YXIgbz1lW2ldLG49dC5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uT3JkZXJpbmdbb10scj0wO3I8bi5sZW5ndGg7cisrKXQuX2NlbnRlclBhcmVudChuW3JdKX0oKSxmdW5jdGlvbigpe2Zvcih2YXIgZT1uKCksaT0wLHI9MDtyPGUubGVuZ3RoLTE7cisrKXtpKz1lW3JdLm1heC1lW3IrMV0ubWluK3Qub3B0aW9ucy5oaWVyYXJjaGljYWwudHJlZVNwYWNpbmcsbyhyKzEsaSl9fSgpfX0se2tleTpcIl9nZXRTcGFjZUFyb3VuZE5vZGVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPSEwO3ZvaWQgMD09PWUmJihpPSExKTt2YXIgbz10aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbdC5pZF07aWYodm9pZCAwIT09byl7dmFyIG49dGhpcy5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uSW5kZXhbdC5pZF0scj10aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbih0KSxzPXRoaXMuaGllcmFyY2hpY2FsLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW29dLGE9MWU5LGg9MWU5O2lmKDAhPT1uKXt2YXIgZD1zW24tMV07aWYoITA9PT1pJiZ2b2lkIDA9PT1lW2QuaWRdfHwhMT09PWkpYT1yLXRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKGQpfWlmKG4hPXMubGVuZ3RoLTEpe3ZhciBsPXNbbisxXTtpZighMD09PWkmJnZvaWQgMD09PWVbbC5pZF18fCExPT09aSl7dmFyIGM9dGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obCk7aD1NYXRoLm1pbihoLGMtcil9fXJldHVyblthLGhdfXJldHVyblswLDBdfX0se2tleTpcIl9jZW50ZXJQYXJlbnRcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih0aGlzLmhpZXJhcmNoaWNhbC5wYXJlbnRSZWZlcmVuY2VbdC5pZF0pZm9yKHZhciBlPXRoaXMuaGllcmFyY2hpY2FsLnBhcmVudFJlZmVyZW5jZVt0LmlkXSxpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBvPWVbaV0sbj10aGlzLmJvZHkubm9kZXNbb10scj10aGlzLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtvXTtpZih2b2lkIDAhPT1yKXt2YXIgcz10aGlzLl9nZXRDZW50ZXJQb3NpdGlvbihyKSxhPXRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG4pLGg9YW4odGhpcy5fZ2V0U3BhY2VBcm91bmROb2RlKG4pLDIpLGQ9aFswXSxsPWhbMV0sYz1hLXM7KGM8MCYmTWF0aC5hYnMoYyk8bC10aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nfHxjPjAmJk1hdGguYWJzKGMpPGQtdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZykmJnRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKG4scyl9fX19LHtrZXk6XCJfcGxhY2VOb2Rlc0J5SGllcmFyY2h5XCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIHRoaXMucG9zaXRpb25lZE5vZGVzPXt9LHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSkpe3ZhciBpLG89eG4odFtlXSk7bz10aGlzLl9pbmRleEFycmF5VG9Ob2RlcyhvKSxiZihpPXRoaXMuZGlyZWN0aW9uKS5jYWxsKGksbyk7Zm9yKHZhciBuPTAscj0wO3I8by5sZW5ndGg7cisrKXt2YXIgcz1vW3JdO2lmKHZvaWQgMD09PXRoaXMucG9zaXRpb25lZE5vZGVzW3MuaWRdKXt2YXIgYT10aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nLGg9YSpuO24+MCYmKGg9dGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24ob1tyLTFdKSthKSx0aGlzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbihzLGgsZSksdGhpcy5fdmFsaWRhdGVQb3NpdGlvbkFuZENvbnRpbnVlKHMsZSxoKSxuKyt9fX19fSx7a2V5OlwiX3BsYWNlQnJhbmNoTm9kZXNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpLG89dGhpcy5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2VbdF07aWYodm9pZCAwIT09byl7Zm9yKHZhciBuPVtdLHI9MDtyPG8ubGVuZ3RoO3IrKyluLnB1c2godGhpcy5ib2R5Lm5vZGVzW29bcl1dKTtiZihpPXRoaXMuZGlyZWN0aW9uKS5jYWxsKGksbik7Zm9yKHZhciBzPTA7czxuLmxlbmd0aDtzKyspe3ZhciBhPW5bc10saD10aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbYS5pZF07aWYoIShoPmUmJnZvaWQgMD09PXRoaXMucG9zaXRpb25lZE5vZGVzW2EuaWRdKSlyZXR1cm47dmFyIGQ9dGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyxsPXZvaWQgMDtsPTA9PT1zP3RoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHRoaXMuYm9keS5ub2Rlc1t0XSk6dGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obltzLTFdKStkLHRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKGEsbCxoKSx0aGlzLl92YWxpZGF0ZVBvc2l0aW9uQW5kQ29udGludWUoYSxoLGwpfXZhciBjPXRoaXMuX2dldENlbnRlclBvc2l0aW9uKG4pO3RoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKHRoaXMuYm9keS5ub2Rlc1t0XSxjLGUpfX19LHtrZXk6XCJfdmFsaWRhdGVQb3NpdGlvbkFuZENvbnRpbnVlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe2lmKHRoaXMuaGllcmFyY2hpY2FsLmlzVHJlZSl7aWYodm9pZCAwIT09dGhpcy5sYXN0Tm9kZU9uTGV2ZWxbZV0pe3ZhciBvPXRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHRoaXMuYm9keS5ub2Rlc1t0aGlzLmxhc3ROb2RlT25MZXZlbFtlXV0pO2lmKGktbzx0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKXt2YXIgbj1vK3RoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmctaSxyPXRoaXMuX2ZpbmRDb21tb25QYXJlbnQodGhpcy5sYXN0Tm9kZU9uTGV2ZWxbZV0sdC5pZCk7dGhpcy5fc2hpZnRCbG9jayhyLndpdGhDaGlsZCxuKX19dGhpcy5sYXN0Tm9kZU9uTGV2ZWxbZV09dC5pZCx0aGlzLnBvc2l0aW9uZWROb2Rlc1t0LmlkXT0hMCx0aGlzLl9wbGFjZUJyYW5jaE5vZGVzKHQuaWQsZSl9fX0se2tleTpcIl9pbmRleEFycmF5VG9Ob2Rlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxpPTA7aTx0Lmxlbmd0aDtpKyspZS5wdXNoKHRoaXMuYm9keS5ub2Rlc1t0W2ldXSk7cmV0dXJuIGV9fSx7a2V5OlwiX2dldERpc3RyaWJ1dGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZSxpPXt9O2Zvcih0IGluIHRoaXMuYm9keS5ub2RlcylpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLHQpKXtlPXRoaXMuYm9keS5ub2Rlc1t0XTt2YXIgbz12b2lkIDA9PT10aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbdF0/MDp0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbdF07dGhpcy5kaXJlY3Rpb24uZml4KGUsbyksdm9pZCAwPT09aVtvXSYmKGlbb109e30pLGlbb11bdF09ZX1yZXR1cm4gaX19LHtrZXk6XCJfZ2V0QWN0aXZlRWRnZXNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLGk9W107cmV0dXJuIG5oKHQuZWRnZXMsKGZ1bmN0aW9uKHQpe3ZhciBvOy0xIT09TXIobz1lLmJvZHkuZWRnZUluZGljZXMpLmNhbGwobyx0LmlkKSYmaS5wdXNoKHQpfSkpLGl9fSx7a2V5OlwiX2dldEh1YlNpemVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9e307bmgodGhpcy5ib2R5Lm5vZGVJbmRpY2VzLChmdW5jdGlvbihpKXt2YXIgbz10LmJvZHkubm9kZXNbaV0sbj10Ll9nZXRBY3RpdmVFZGdlcyhvKS5sZW5ndGg7ZVtuXT0hMH0pKTt2YXIgaT1bXTtyZXR1cm4gbmgoZSwoZnVuY3Rpb24odCl7aS5wdXNoKE51bWJlcih0KSl9KSksYmYoQ2YpLmNhbGwoQ2YsaSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZS10fSkpLGl9fSx7a2V5OlwiX2RldGVybWluZUxldmVsc0J5SHVic2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMsZT1mdW5jdGlvbihlLGkpe3QuaGllcmFyY2hpY2FsLmxldmVsRG93bnN0cmVhbShlLGkpfSxpPXRoaXMuX2dldEh1YlNpemVzKCksbz1mdW5jdGlvbihvKXt2YXIgbj1pW29dO2lmKDA9PT1uKXJldHVyblwiYnJlYWtcIjtuaCh0LmJvZHkubm9kZUluZGljZXMsKGZ1bmN0aW9uKGkpe3ZhciBvPXQuYm9keS5ub2Rlc1tpXTtuPT09dC5fZ2V0QWN0aXZlRWRnZXMobykubGVuZ3RoJiZ0Ll9jcmF3bE5ldHdvcmsoZSxpKX0pKX0sbj0wO248aS5sZW5ndGg7KytuKXtpZihcImJyZWFrXCI9PT1vKG4pKWJyZWFrfX19LHtrZXk6XCJfZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2tcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5fY3Jhd2xOZXR3b3JrKChmdW5jdGlvbihlLGksbyl7dmFyIG49dC5oaWVyYXJjaGljYWwubGV2ZWxzW2UuaWRdO3ZvaWQgMD09PW4mJihuPXQuaGllcmFyY2hpY2FsLmxldmVsc1tlLmlkXT0xZTUpO3ZhciByPSh3dS5jbG9uZU9wdGlvbnMoZSxcIm5vZGVcIiksd3UuY2xvbmVPcHRpb25zKGksXCJub2RlXCIpLHZvaWQgd3UuY2xvbmVPcHRpb25zKG8sXCJlZGdlXCIpKTt0LmhpZXJhcmNoaWNhbC5sZXZlbHNbaS5pZF09bityfSkpLHRoaXMuaGllcmFyY2hpY2FsLnNldE1pbkxldmVsVG9aZXJvKHRoaXMuYm9keS5ub2Rlcyl9fSx7a2V5OlwiX2RldGVybWluZUxldmVsc0RpcmVjdGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlPXRoaXMsaT1PZih0PXRoaXMuYm9keS5ub2RlSW5kaWNlcykuY2FsbCh0LChmdW5jdGlvbih0LGkpe3JldHVybiB0LnNldChpLGUuYm9keS5ub2Rlc1tpXSksdH0pLG5ldyBCZCk7XCJyb290c1wiPT09dGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5zaGFrZVRvd2FyZHM/dGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzPWZ1bmN0aW9uKHQpe3JldHVybiBqZigoZnVuY3Rpb24oZSl7dmFyIGksbztyZXR1cm4gRmYoaT1hcihvPWUuZWRnZXMpLmNhbGwobywoZnVuY3Rpb24oZSl7cmV0dXJuIHQuaGFzKGUudG9JZCl9KSkpLmNhbGwoaSwoZnVuY3Rpb24odCl7cmV0dXJuIHQuZnJvbT09PWV9KSl9KSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZTx0fSksXCJ0b1wiLHQpfShpKTp0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHM9ZnVuY3Rpb24odCl7cmV0dXJuIGpmKChmdW5jdGlvbihlKXt2YXIgaSxvO3JldHVybiBGZihpPWFyKG89ZS5lZGdlcykuY2FsbChvLChmdW5jdGlvbihlKXtyZXR1cm4gdC5oYXMoZS50b0lkKX0pKSkuY2FsbChpLChmdW5jdGlvbih0KXtyZXR1cm4gdC50bz09PWV9KSl9KSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZT50fSksXCJmcm9tXCIsdCl9KGkpLHRoaXMuaGllcmFyY2hpY2FsLnNldE1pbkxldmVsVG9aZXJvKHRoaXMuYm9keS5ub2Rlcyl9fSx7a2V5OlwiX2dlbmVyYXRlTWFwXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuX2NyYXdsTmV0d29yaygoZnVuY3Rpb24oZSxpKXt0LmhpZXJhcmNoaWNhbC5sZXZlbHNbaS5pZF0+dC5oaWVyYXJjaGljYWwubGV2ZWxzW2UuaWRdJiZ0LmhpZXJhcmNoaWNhbC5hZGRSZWxhdGlvbihlLmlkLGkuaWQpfSkpLHRoaXMuaGllcmFyY2hpY2FsLmNoZWNrSWZUcmVlKCl9fSx7a2V5OlwiX2NyYXdsTmV0d29ya1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpmdW5jdGlvbigpe30saT1hcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCxvPXt9LG49ZnVuY3Rpb24gaShuLHIpe2lmKHZvaWQgMD09PW9bbi5pZF0pe3ZhciBzO3QuaGllcmFyY2hpY2FsLnNldFRyZWVJbmRleChuLHIpLG9bbi5pZF09ITA7Zm9yKHZhciBhPXQuX2dldEFjdGl2ZUVkZ2VzKG4pLGg9MDtoPGEubGVuZ3RoO2grKyl7dmFyIGQ9YVtoXTshMD09PWQuY29ubmVjdGVkJiYocz1kLnRvSWQ9PW4uaWQ/ZC5mcm9tOmQudG8sbi5pZCE9cy5pZCYmKGUobixzLGQpLGkocyxyKSkpfX19O2lmKHZvaWQgMD09PWkpZm9yKHZhciByPTAscz0wO3M8dGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDtzKyspe3ZhciBhPXRoaXMuYm9keS5ub2RlSW5kaWNlc1tzXTtpZih2b2lkIDA9PT1vW2FdKXt2YXIgaD10aGlzLmJvZHkubm9kZXNbYV07bihoLHIpLHIrPTF9fWVsc2V7dmFyIGQ9dGhpcy5ib2R5Lm5vZGVzW2ldO2lmKHZvaWQgMD09PWQpcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcIk5vZGUgbm90IGZvdW5kOlwiLGkpO24oZCl9fX0se2tleTpcIl9zaGlmdEJsb2NrXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLG89e307IWZ1bmN0aW9uIHQobil7aWYoIW9bbl0pe29bbl09ITAsaS5kaXJlY3Rpb24uc2hpZnQobixlKTt2YXIgcj1pLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtuXTtpZih2b2lkIDAhPT1yKWZvcih2YXIgcz0wO3M8ci5sZW5ndGg7cysrKXQocltzXSl9fSh0KX19LHtrZXk6XCJfZmluZENvbW1vblBhcmVudFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9dGhpcyxvPXt9O3JldHVybiBmdW5jdGlvbiB0KGUsbyl7dmFyIG49aS5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW29dO2lmKHZvaWQgMCE9PW4pZm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBzPW5bcl07ZVtzXT0hMCx0KGUscyl9fShvLHQpLGZ1bmN0aW9uIHQoZSxvKXt2YXIgbj1pLmhpZXJhcmNoaWNhbC5wYXJlbnRSZWZlcmVuY2Vbb107aWYodm9pZCAwIT09bilmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIHM9bltyXTtpZih2b2lkIDAhPT1lW3NdKXJldHVybntmb3VuZFBhcmVudDpzLHdpdGhDaGlsZDpvfTt2YXIgYT10KGUscyk7aWYobnVsbCE9PWEuZm91bmRQYXJlbnQpcmV0dXJuIGF9cmV0dXJue2ZvdW5kUGFyZW50Om51bGwsd2l0aENoaWxkOm99fShvLGUpfX0se2tleTpcInNldERpcmVjdGlvblN0cmF0ZWd5XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD1cIlVEXCI9PT10aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbnx8XCJEVVwiPT09dGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb247dGhpcy5kaXJlY3Rpb249dD9uZXcgTWYodGhpcyk6bmV3IFBmKHRoaXMpfX0se2tleTpcIl9nZXRDZW50ZXJQb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0xZTksaT0tMWU5LG89MDtvPHQubGVuZ3RoO28rKyl7dmFyIG49dm9pZCAwO2lmKHZvaWQgMCE9PXRbb10uaWQpbj10W29dO2Vsc2V7dmFyIHI9dFtvXTtuPXRoaXMuYm9keS5ub2Rlc1tyXX12YXIgcz10aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihuKTtlPU1hdGgubWluKGUscyksaT1NYXRoLm1heChpLHMpfXJldHVybi41KihlK2kpfX1dKSx0fSgpO2Z1bmN0aW9uIFdmKHQsZSl7dmFyIGk7aWYodm9pZCAwPT09Y258fG51bGw9PUNpKHQpKXtpZihnbih0KXx8KGk9ZnVuY3Rpb24odCxlKXt2YXIgaTtpZighdClyZXR1cm47aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIFZmKHQsZSk7dmFyIG89dm4oaT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpLmNhbGwoaSw4LC0xKTtcIk9iamVjdFwiPT09byYmdC5jb25zdHJ1Y3RvciYmKG89dC5jb25zdHJ1Y3Rvci5uYW1lKTtpZihcIk1hcFwiPT09b3x8XCJTZXRcIj09PW8pcmV0dXJuIG1pKHQpO2lmKFwiQXJndW1lbnRzXCI9PT1vfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChvKSlyZXR1cm4gVmYodCxlKX0odCkpfHxlJiZ0JiZcIm51bWJlclwiPT10eXBlb2YgdC5sZW5ndGgpe2kmJih0PWkpO3ZhciBvPTAsbj1mdW5jdGlvbigpe307cmV0dXJue3M6bixuOmZ1bmN0aW9uKCl7cmV0dXJuIG8+PXQubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTp0W28rK119fSxlOmZ1bmN0aW9uKHQpe3Rocm93IHR9LGY6bn19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXZhciByLHM9ITAsYT0hMTtyZXR1cm57czpmdW5jdGlvbigpe2k9U2kodCl9LG46ZnVuY3Rpb24oKXt2YXIgdD1pLm5leHQoKTtyZXR1cm4gcz10LmRvbmUsdH0sZTpmdW5jdGlvbih0KXthPSEwLHI9dH0sZjpmdW5jdGlvbigpe3RyeXtzfHxudWxsPT1pLnJldHVybnx8aS5yZXR1cm4oKX1maW5hbGx5e2lmKGEpdGhyb3cgcn19fX1mdW5jdGlvbiBWZih0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgaT0wLG89bmV3IEFycmF5KGUpO2k8ZTtpKyspb1tpXT10W2ldO3JldHVybiBvfXZhciBxZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8sbil7dmFyIHIscyxhPXRoaXM7UG8odGhpcyx0KSx0aGlzLmJvZHk9ZSx0aGlzLmNhbnZhcz1pLHRoaXMuc2VsZWN0aW9uSGFuZGxlcj1vLHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyPW4sdGhpcy5lZGl0TW9kZT0hMSx0aGlzLm1hbmlwdWxhdGlvbkRpdj12b2lkIDAsdGhpcy5lZGl0TW9kZURpdj12b2lkIDAsdGhpcy5jbG9zZURpdj12b2lkIDAsdGhpcy5fZG9tRXZlbnRMaXN0ZW5lckNsZWFudXBRdWV1ZT1bXSx0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zPXt9LHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnM9W10sdGhpcy50b3VjaFRpbWU9MCx0aGlzLnRlbXBvcmFyeUlkcz17bm9kZXM6W10sZWRnZXM6W119LHRoaXMuZ3VpRW5hYmxlZD0hMSx0aGlzLmluTW9kZT0hMSx0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGU9dm9pZCAwLHRoaXMub3B0aW9ucz17fSx0aGlzLmRlZmF1bHRPcHRpb25zPXtlbmFibGVkOiExLGluaXRpYWxseUFjdGl2ZTohMSxhZGROb2RlOiEwLGFkZEVkZ2U6ITAsZWRpdE5vZGU6dm9pZCAwLGVkaXRFZGdlOiEwLGRlbGV0ZU5vZGU6ITAsZGVsZXRlRWRnZTohMCxjb250cm9sTm9kZVN0eWxlOntzaGFwZTpcImRvdFwiLHNpemU6Nixjb2xvcjp7YmFja2dyb3VuZDpcIiNmZjAwMDBcIixib3JkZXI6XCIjM2MzYzNjXCIsaGlnaGxpZ2h0OntiYWNrZ3JvdW5kOlwiIzA3Zjk2OFwiLGJvcmRlcjpcIiMzYzNjM2NcIn19LGJvcmRlcldpZHRoOjIsYm9yZGVyV2lkdGhTZWxlY3RlZDoyfX0sY3QodGhpcy5vcHRpb25zLHRoaXMuZGVmYXVsdE9wdGlvbnMpLHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLChmdW5jdGlvbigpe2EuX2NsZWFuKCl9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIixidChyPXRoaXMuX3Jlc3RvcmUpLmNhbGwocix0aGlzKSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVzZXREYXRhXCIsYnQocz10aGlzLl9yZXN0b3JlKS5jYWxsKHMsdGhpcykpfXJldHVybiBJbyh0LFt7a2V5OlwiX3Jlc3RvcmVcIix2YWx1ZTpmdW5jdGlvbigpeyExIT09dGhpcy5pbk1vZGUmJighMD09PXRoaXMub3B0aW9ucy5pbml0aWFsbHlBY3RpdmU/dGhpcy5lbmFibGVFZGl0TW9kZSgpOnRoaXMuZGlzYWJsZUVkaXRNb2RlKCkpfX0se2tleTpcInNldE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7dm9pZCAwIT09ZSYmKHZvaWQgMCE9PWUubG9jYWxlP3RoaXMub3B0aW9ucy5sb2NhbGU9ZS5sb2NhbGU6dGhpcy5vcHRpb25zLmxvY2FsZT1pLmxvY2FsZSx2b2lkIDAhPT1lLmxvY2FsZXM/dGhpcy5vcHRpb25zLmxvY2FsZXM9ZS5sb2NhbGVzOnRoaXMub3B0aW9ucy5sb2NhbGVzPWkubG9jYWxlcyksdm9pZCAwIT09dCYmKFwiYm9vbGVhblwiPT10eXBlb2YgdD90aGlzLm9wdGlvbnMuZW5hYmxlZD10Oih0aGlzLm9wdGlvbnMuZW5hYmxlZD0hMCx0aCh0aGlzLm9wdGlvbnMsdCkpLCEwPT09dGhpcy5vcHRpb25zLmluaXRpYWxseUFjdGl2ZSYmKHRoaXMuZWRpdE1vZGU9ITApLHRoaXMuX3NldHVwKCkpfX0se2tleTpcInRvZ2dsZUVkaXRNb2RlXCIsdmFsdWU6ZnVuY3Rpb24oKXshMD09PXRoaXMuZWRpdE1vZGU/dGhpcy5kaXNhYmxlRWRpdE1vZGUoKTp0aGlzLmVuYWJsZUVkaXRNb2RlKCl9fSx7a2V5OlwiZW5hYmxlRWRpdE1vZGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZWRpdE1vZGU9ITAsdGhpcy5fY2xlYW4oKSwhMD09PXRoaXMuZ3VpRW5hYmxlZCYmKHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHRoaXMuY2xvc2VEaXYuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpKX19LHtrZXk6XCJkaXNhYmxlRWRpdE1vZGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZWRpdE1vZGU9ITEsdGhpcy5fY2xlYW4oKSwhMD09PXRoaXMuZ3VpRW5hYmxlZCYmKHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLHRoaXMuZWRpdE1vZGVEaXYuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsdGhpcy5fY3JlYXRlRWRpdEJ1dHRvbigpKX19LHtrZXk6XCJzaG93TWFuaXB1bGF0b3JUb29sYmFyXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLl9jbGVhbigpLHRoaXMubWFuaXB1bGF0aW9uRE9NPXt9LCEwPT09dGhpcy5ndWlFbmFibGVkKXt2YXIgdCxlO3RoaXMuZWRpdE1vZGU9ITAsdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIjt2YXIgaT10aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2RlQ291bnQoKSxvPXRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VDb3VudCgpLG49aStvLHI9dGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV0scz0hMTshMSE9PXRoaXMub3B0aW9ucy5hZGROb2RlJiYodGhpcy5fY3JlYXRlQWRkTm9kZUJ1dHRvbihyKSxzPSEwKSwhMSE9PXRoaXMub3B0aW9ucy5hZGRFZGdlJiYoITA9PT1zP3RoaXMuX2NyZWF0ZVNlcGVyYXRvcigxKTpzPSEwLHRoaXMuX2NyZWF0ZUFkZEVkZ2VCdXR0b24ocikpLDE9PT1pJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuZWRpdE5vZGU/KCEwPT09cz90aGlzLl9jcmVhdGVTZXBlcmF0b3IoMik6cz0hMCx0aGlzLl9jcmVhdGVFZGl0Tm9kZUJ1dHRvbihyKSk6MT09PW8mJjA9PT1pJiYhMSE9PXRoaXMub3B0aW9ucy5lZGl0RWRnZSYmKCEwPT09cz90aGlzLl9jcmVhdGVTZXBlcmF0b3IoMyk6cz0hMCx0aGlzLl9jcmVhdGVFZGl0RWRnZUJ1dHRvbihyKSksMCE9PW4mJihpPjAmJiExIT09dGhpcy5vcHRpb25zLmRlbGV0ZU5vZGV8fDA9PT1pJiYhMSE9PXRoaXMub3B0aW9ucy5kZWxldGVFZGdlKSYmKCEwPT09cyYmdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDQpLHRoaXMuX2NyZWF0ZURlbGV0ZUJ1dHRvbihyKSksdGhpcy5fYmluZEVsZW1lbnRFdmVudHModGhpcy5jbG9zZURpdixidCh0PXRoaXMudG9nZ2xlRWRpdE1vZGUpLmNhbGwodCx0aGlzKSksdGhpcy5fdGVtcG9yYXJ5QmluZEV2ZW50KFwic2VsZWN0XCIsYnQoZT10aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIpLmNhbGwoZSx0aGlzKSl9dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIil9fSx7a2V5OlwiYWRkTm9kZU1vZGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0O2lmKCEwIT09dGhpcy5lZGl0TW9kZSYmdGhpcy5lbmFibGVFZGl0TW9kZSgpLHRoaXMuX2NsZWFuKCksdGhpcy5pbk1vZGU9XCJhZGROb2RlXCIsITA9PT10aGlzLmd1aUVuYWJsZWQpe3ZhciBlLGk9dGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07dGhpcy5tYW5pcHVsYXRpb25ET009e30sdGhpcy5fY3JlYXRlQmFja0J1dHRvbihpKSx0aGlzLl9jcmVhdGVTZXBlcmF0b3IoKSx0aGlzLl9jcmVhdGVEZXNjcmlwdGlvbihpLmFkZERlc2NyaXB0aW9ufHx0aGlzLm9wdGlvbnMubG9jYWxlcy5lbi5hZGREZXNjcmlwdGlvbiksdGhpcy5fYmluZEVsZW1lbnRFdmVudHModGhpcy5jbG9zZURpdixidChlPXRoaXMudG9nZ2xlRWRpdE1vZGUpLmNhbGwoZSx0aGlzKSl9dGhpcy5fdGVtcG9yYXJ5QmluZEV2ZW50KFwiY2xpY2tcIixidCh0PXRoaXMuX3BlcmZvcm1BZGROb2RlKS5jYWxsKHQsdGhpcykpfX0se2tleTpcImVkaXROb2RlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzOyEwIT09dGhpcy5lZGl0TW9kZSYmdGhpcy5lbmFibGVFZGl0TW9kZSgpLHRoaXMuX2NsZWFuKCk7dmFyIGU9dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZXMoKVswXTtpZih2b2lkIDAhPT1lKXtpZih0aGlzLmluTW9kZT1cImVkaXROb2RlXCIsXCJmdW5jdGlvblwiIT10eXBlb2YgdGhpcy5vcHRpb25zLmVkaXROb2RlKXRocm93IG5ldyBFcnJvcihcIk5vIGZ1bmN0aW9uIGhhcyBiZWVuIGNvbmZpZ3VyZWQgdG8gaGFuZGxlIHRoZSBlZGl0aW5nIG9mIG5vZGVzLlwiKTtpZighMCE9PWUuaXNDbHVzdGVyKXt2YXIgaT10aCh7fSxlLm9wdGlvbnMsITEpO2lmKGkueD1lLngsaS55PWUueSwyIT09dGhpcy5vcHRpb25zLmVkaXROb2RlLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZnVuY3Rpb24gZm9yIGVkaXQgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLCBjYWxsYmFjaylcIik7dGhpcy5vcHRpb25zLmVkaXROb2RlKGksKGZ1bmN0aW9uKGUpe251bGwhPWUmJlwiZWRpdE5vZGVcIj09PXQuaW5Nb2RlJiZ0LmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkudXBkYXRlKGUpLHQuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpfSkpfWVsc2UgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV0uZWRpdENsdXN0ZXJFcnJvcnx8dGhpcy5vcHRpb25zLmxvY2FsZXMuZW4uZWRpdENsdXN0ZXJFcnJvcil9ZWxzZSB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKX19LHtrZXk6XCJhZGRFZGdlTW9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZSxpLG8sbjtpZighMCE9PXRoaXMuZWRpdE1vZGUmJnRoaXMuZW5hYmxlRWRpdE1vZGUoKSx0aGlzLl9jbGVhbigpLHRoaXMuaW5Nb2RlPVwiYWRkRWRnZVwiLCEwPT09dGhpcy5ndWlFbmFibGVkKXt2YXIgcixzPXRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO3RoaXMubWFuaXB1bGF0aW9uRE9NPXt9LHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24ocyksdGhpcy5fY3JlYXRlU2VwZXJhdG9yKCksdGhpcy5fY3JlYXRlRGVzY3JpcHRpb24ocy5lZGdlRGVzY3JpcHRpb258fHRoaXMub3B0aW9ucy5sb2NhbGVzLmVuLmVkZ2VEZXNjcmlwdGlvbiksdGhpcy5fYmluZEVsZW1lbnRFdmVudHModGhpcy5jbG9zZURpdixidChyPXRoaXMudG9nZ2xlRWRpdE1vZGUpLmNhbGwocix0aGlzKSl9dGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25Ub3VjaFwiLGJ0KHQ9dGhpcy5faGFuZGxlQ29ubmVjdCkuY2FsbCh0LHRoaXMpKSx0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkRyYWdFbmRcIixidChlPXRoaXMuX2ZpbmlzaENvbm5lY3QpLmNhbGwoZSx0aGlzKSksdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnXCIsYnQoaT10aGlzLl9kcmFnQ29udHJvbE5vZGUpLmNhbGwoaSx0aGlzKSksdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25SZWxlYXNlXCIsYnQobz10aGlzLl9maW5pc2hDb25uZWN0KS5jYWxsKG8sdGhpcykpLHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ1N0YXJ0XCIsYnQobj10aGlzLl9kcmFnU3RhcnRFZGdlKS5jYWxsKG4sdGhpcykpLHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uSG9sZFwiLChmdW5jdGlvbigpe30pKX19LHtrZXk6XCJlZGl0RWRnZU1vZGVcIix2YWx1ZTpmdW5jdGlvbigpe2lmKCEwIT09dGhpcy5lZGl0TW9kZSYmdGhpcy5lbmFibGVFZGl0TW9kZSgpLHRoaXMuX2NsZWFuKCksdGhpcy5pbk1vZGU9XCJlZGl0RWRnZVwiLFwib2JqZWN0XCIhPT1kbih0aGlzLm9wdGlvbnMuZWRpdEVkZ2UpfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiB0aGlzLm9wdGlvbnMuZWRpdEVkZ2UuZWRpdFdpdGhvdXREcmFnfHwodGhpcy5lZGdlQmVpbmdFZGl0ZWRJZD10aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlSWRzKClbMF0sdm9pZCAwPT09dGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCkpe2lmKCEwPT09dGhpcy5ndWlFbmFibGVkKXt2YXIgdCxlPXRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO3RoaXMubWFuaXB1bGF0aW9uRE9NPXt9LHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24oZSksdGhpcy5fY3JlYXRlU2VwZXJhdG9yKCksdGhpcy5fY3JlYXRlRGVzY3JpcHRpb24oZS5lZGl0RWRnZURlc2NyaXB0aW9ufHx0aGlzLm9wdGlvbnMubG9jYWxlcy5lbi5lZGl0RWRnZURlc2NyaXB0aW9uKSx0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyh0aGlzLmNsb3NlRGl2LGJ0KHQ9dGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbCh0LHRoaXMpKX1pZih0aGlzLmVkZ2VCZWluZ0VkaXRlZElkPXRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VJZHMoKVswXSx2b2lkIDAhPT10aGlzLmVkZ2VCZWluZ0VkaXRlZElkKXt2YXIgaSxvLG4scixzPXRoaXMuYm9keS5lZGdlc1t0aGlzLmVkZ2VCZWluZ0VkaXRlZElkXSxhPXRoaXMuX2dldE5ld1RhcmdldE5vZGUocy5mcm9tLngscy5mcm9tLnkpLGg9dGhpcy5fZ2V0TmV3VGFyZ2V0Tm9kZShzLnRvLngscy50by55KTt0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5wdXNoKGEuaWQpLHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLnB1c2goaC5pZCksdGhpcy5ib2R5Lm5vZGVzW2EuaWRdPWEsdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2goYS5pZCksdGhpcy5ib2R5Lm5vZGVzW2guaWRdPWgsdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2goaC5pZCksdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25Ub3VjaFwiLGJ0KGk9dGhpcy5fY29udHJvbE5vZGVUb3VjaCkuY2FsbChpLHRoaXMpKSx0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvblRhcFwiLChmdW5jdGlvbigpe30pKSx0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkhvbGRcIiwoZnVuY3Rpb24oKXt9KSksdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnU3RhcnRcIixidChvPXRoaXMuX2NvbnRyb2xOb2RlRHJhZ1N0YXJ0KS5jYWxsKG8sdGhpcykpLHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ1wiLGJ0KG49dGhpcy5fY29udHJvbE5vZGVEcmFnKS5jYWxsKG4sdGhpcykpLHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ0VuZFwiLGJ0KHI9dGhpcy5fY29udHJvbE5vZGVEcmFnRW5kKS5jYWxsKHIsdGhpcykpLHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uTW91c2VNb3ZlXCIsKGZ1bmN0aW9uKCl7fSkpLHRoaXMuX3RlbXBvcmFyeUJpbmRFdmVudChcImJlZm9yZURyYXdpbmdcIiwoZnVuY3Rpb24odCl7dmFyIGU9cy5lZGdlVHlwZS5maW5kQm9yZGVyUG9zaXRpb25zKHQpOyExPT09YS5zZWxlY3RlZCYmKGEueD1lLmZyb20ueCxhLnk9ZS5mcm9tLnkpLCExPT09aC5zZWxlY3RlZCYmKGgueD1lLnRvLngsaC55PWUudG8ueSl9KSksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIil9ZWxzZSB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKX1lbHNle3ZhciBkPXRoaXMuYm9keS5lZGdlc1t0aGlzLmVkZ2VCZWluZ0VkaXRlZElkXTt0aGlzLl9wZXJmb3JtRWRpdEVkZ2UoZC5mcm9tLmlkLGQudG8uaWQpfX19LHtrZXk6XCJkZWxldGVTZWxlY3RlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczshMCE9PXRoaXMuZWRpdE1vZGUmJnRoaXMuZW5hYmxlRWRpdE1vZGUoKSx0aGlzLl9jbGVhbigpLHRoaXMuaW5Nb2RlPVwiZGVsZXRlXCI7dmFyIGU9dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZUlkcygpLGk9dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZUlkcygpLG89dm9pZCAwO2lmKGUubGVuZ3RoPjApe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKWlmKCEwPT09dGhpcy5ib2R5Lm5vZGVzW2Vbbl1dLmlzQ2x1c3RlcilyZXR1cm4gdm9pZCBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXS5kZWxldGVDbHVzdGVyRXJyb3J8fHRoaXMub3B0aW9ucy5sb2NhbGVzLmVuLmRlbGV0ZUNsdXN0ZXJFcnJvcik7XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5vcHRpb25zLmRlbGV0ZU5vZGUmJihvPXRoaXMub3B0aW9ucy5kZWxldGVOb2RlKX1lbHNlIGkubGVuZ3RoPjAmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub3B0aW9ucy5kZWxldGVFZGdlJiYobz10aGlzLm9wdGlvbnMuZGVsZXRlRWRnZSk7aWYoXCJmdW5jdGlvblwiPT10eXBlb2Ygbyl7dmFyIHI9e25vZGVzOmUsZWRnZXM6aX07aWYoMiE9PW8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBmb3IgZGVsZXRlIGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSwgY2FsbGJhY2spXCIpO28ociwoZnVuY3Rpb24oZSl7bnVsbCE9ZSYmXCJkZWxldGVcIj09PXQuaW5Nb2RlPyh0LmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkucmVtb3ZlKGUuZWRnZXMpLHQuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5yZW1vdmUoZS5ub2RlcyksdC5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKSx0LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKSk6KHQuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIiksdC5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCkpfSkpfWVsc2UgdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShpKSx0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkucmVtb3ZlKGUpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIiksdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCl9fSx7a2V5OlwiX3NldHVwXCIsdmFsdWU6ZnVuY3Rpb24oKXshMD09PXRoaXMub3B0aW9ucy5lbmFibGVkPyh0aGlzLmd1aUVuYWJsZWQ9ITAsdGhpcy5fY3JlYXRlV3JhcHBlcnMoKSwhMT09PXRoaXMuZWRpdE1vZGU/dGhpcy5fY3JlYXRlRWRpdEJ1dHRvbigpOnRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpKToodGhpcy5fcmVtb3ZlTWFuaXB1bGF0aW9uRE9NKCksdGhpcy5ndWlFbmFibGVkPSExKX19LHtrZXk6XCJfY3JlYXRlV3JhcHBlcnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0LGU7KHZvaWQgMD09PXRoaXMubWFuaXB1bGF0aW9uRGl2JiYodGhpcy5tYW5pcHVsYXRpb25EaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLm1hbmlwdWxhdGlvbkRpdi5jbGFzc05hbWU9XCJ2aXMtbWFuaXB1bGF0aW9uXCIsITA9PT10aGlzLmVkaXRNb2RlP3RoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiOnRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25EaXYpKSx2b2lkIDA9PT10aGlzLmVkaXRNb2RlRGl2JiYodGhpcy5lZGl0TW9kZURpdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuZWRpdE1vZGVEaXYuY2xhc3NOYW1lPVwidmlzLWVkaXQtbW9kZVwiLCEwPT09dGhpcy5lZGl0TW9kZT90aGlzLmVkaXRNb2RlRGl2LnN0eWxlLmRpc3BsYXk9XCJub25lXCI6dGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIix0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmVkaXRNb2RlRGl2KSksdm9pZCAwPT09dGhpcy5jbG9zZURpdikmJih0aGlzLmNsb3NlRGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksdGhpcy5jbG9zZURpdi5jbGFzc05hbWU9XCJ2aXMtY2xvc2VcIix0aGlzLmNsb3NlRGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIixudWxsIT09KHQ9bnVsbD09PShlPXRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5jbG9zZSkmJnZvaWQgMCE9PXQ/dDp0aGlzLm9wdGlvbnMubG9jYWxlcy5lbi5jbG9zZSksdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5PXRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXksdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jbG9zZURpdikpfX0se2tleTpcIl9nZXROZXdUYXJnZXROb2RlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT10aCh7fSx0aGlzLm9wdGlvbnMuY29udHJvbE5vZGVTdHlsZSk7aS5pZD1cInRhcmdldE5vZGVcIitidSgpLGkuaGlkZGVuPSExLGkucGh5c2ljcz0hMSxpLng9dCxpLnk9ZTt2YXIgbz10aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUoaSk7cmV0dXJuIG8uc2hhcGUuYm91bmRpbmdCb3g9e2xlZnQ6dCxyaWdodDp0LHRvcDplLGJvdHRvbTplfSxvfX0se2tleTpcIl9jcmVhdGVFZGl0QnV0dG9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdDt0aGlzLl9jbGVhbigpLHRoaXMubWFuaXB1bGF0aW9uRE9NPXt9LFhhKHRoaXMuZWRpdE1vZGVEaXYpO3ZhciBlPXRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdLGk9dGhpcy5fY3JlYXRlQnV0dG9uKFwiZWRpdE1vZGVcIixcInZpcy1lZGl0IHZpcy1lZGl0LW1vZGVcIixlLmVkaXR8fHRoaXMub3B0aW9ucy5sb2NhbGVzLmVuLmVkaXQpO3RoaXMuZWRpdE1vZGVEaXYuYXBwZW5kQ2hpbGQoaSksdGhpcy5fYmluZEVsZW1lbnRFdmVudHMoaSxidCh0PXRoaXMudG9nZ2xlRWRpdE1vZGUpLmNhbGwodCx0aGlzKSl9fSx7a2V5OlwiX2NsZWFuXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmluTW9kZT0hMSwhMD09PXRoaXMuZ3VpRW5hYmxlZCYmKFhhKHRoaXMuZWRpdE1vZGVEaXYpLFhhKHRoaXMubWFuaXB1bGF0aW9uRGl2KSx0aGlzLl9jbGVhbnVwRE9NRXZlbnRMaXN0ZW5lcnMoKSksdGhpcy5fY2xlYW51cFRlbXBvcmFyeU5vZGVzQW5kRWRnZXMoKSx0aGlzLl91bmJpbmRUZW1wb3JhcnlVSXMoKSx0aGlzLl91bmJpbmRUZW1wb3JhcnlFdmVudHMoKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVzdG9yZVBoeXNpY3NcIil9fSx7a2V5OlwiX2NsZWFudXBET01FdmVudExpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZSxpPVdmKHFuKHQ9dGhpcy5fZG9tRXZlbnRMaXN0ZW5lckNsZWFudXBRdWV1ZSkuY2FsbCh0LDApKTt0cnl7Zm9yKGkucygpOyEoZT1pLm4oKSkuZG9uZTspeygwLGUudmFsdWUpKCl9fWNhdGNoKHQpe2kuZSh0KX1maW5hbGx5e2kuZigpfX19LHtrZXk6XCJfcmVtb3ZlTWFuaXB1bGF0aW9uRE9NXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9jbGVhbigpLFhhKHRoaXMubWFuaXB1bGF0aW9uRGl2KSxYYSh0aGlzLmVkaXRNb2RlRGl2KSxYYSh0aGlzLmNsb3NlRGl2KSx0aGlzLm1hbmlwdWxhdGlvbkRpdiYmdGhpcy5jYW52YXMuZnJhbWUucmVtb3ZlQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25EaXYpLHRoaXMuZWRpdE1vZGVEaXYmJnRoaXMuY2FudmFzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMuZWRpdE1vZGVEaXYpLHRoaXMuY2xvc2VEaXYmJnRoaXMuY2FudmFzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMuY2xvc2VEaXYpLHRoaXMubWFuaXB1bGF0aW9uRGl2PXZvaWQgMCx0aGlzLmVkaXRNb2RlRGl2PXZvaWQgMCx0aGlzLmNsb3NlRGl2PXZvaWQgMH19LHtrZXk6XCJfY3JlYXRlU2VwZXJhdG9yXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MTt0aGlzLm1hbmlwdWxhdGlvbkRPTVtcInNlcGVyYXRvckxpbmVEaXZcIit0XT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMubWFuaXB1bGF0aW9uRE9NW1wic2VwZXJhdG9yTGluZURpdlwiK3RdLmNsYXNzTmFtZT1cInZpcy1zZXBhcmF0b3ItbGluZVwiLHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKHRoaXMubWFuaXB1bGF0aW9uRE9NW1wic2VwZXJhdG9yTGluZURpdlwiK3RdKX19LHtrZXk6XCJfY3JlYXRlQWRkTm9kZUJ1dHRvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlLGk9dGhpcy5fY3JlYXRlQnV0dG9uKFwiYWRkTm9kZVwiLFwidmlzLWFkZFwiLHQuYWRkTm9kZXx8dGhpcy5vcHRpb25zLmxvY2FsZXMuZW4uYWRkTm9kZSk7dGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoaSksdGhpcy5fYmluZEVsZW1lbnRFdmVudHMoaSxidChlPXRoaXMuYWRkTm9kZU1vZGUpLmNhbGwoZSx0aGlzKSl9fSx7a2V5OlwiX2NyZWF0ZUFkZEVkZ2VCdXR0b25cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZSxpPXRoaXMuX2NyZWF0ZUJ1dHRvbihcImFkZEVkZ2VcIixcInZpcy1jb25uZWN0XCIsdC5hZGRFZGdlfHx0aGlzLm9wdGlvbnMubG9jYWxlcy5lbi5hZGRFZGdlKTt0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChpKSx0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhpLGJ0KGU9dGhpcy5hZGRFZGdlTW9kZSkuY2FsbChlLHRoaXMpKX19LHtrZXk6XCJfY3JlYXRlRWRpdE5vZGVCdXR0b25cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZSxpPXRoaXMuX2NyZWF0ZUJ1dHRvbihcImVkaXROb2RlXCIsXCJ2aXMtZWRpdFwiLHQuZWRpdE5vZGV8fHRoaXMub3B0aW9ucy5sb2NhbGVzLmVuLmVkaXROb2RlKTt0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChpKSx0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhpLGJ0KGU9dGhpcy5lZGl0Tm9kZSkuY2FsbChlLHRoaXMpKX19LHtrZXk6XCJfY3JlYXRlRWRpdEVkZ2VCdXR0b25cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZSxpPXRoaXMuX2NyZWF0ZUJ1dHRvbihcImVkaXRFZGdlXCIsXCJ2aXMtZWRpdFwiLHQuZWRpdEVkZ2V8fHRoaXMub3B0aW9ucy5sb2NhbGVzLmVuLmVkaXRFZGdlKTt0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChpKSx0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhpLGJ0KGU9dGhpcy5lZGl0RWRnZU1vZGUpLmNhbGwoZSx0aGlzKSl9fSx7a2V5OlwiX2NyZWF0ZURlbGV0ZUJ1dHRvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlLGk7aT10aGlzLm9wdGlvbnMucnRsP1widmlzLWRlbGV0ZS1ydGxcIjpcInZpcy1kZWxldGVcIjt2YXIgbz10aGlzLl9jcmVhdGVCdXR0b24oXCJkZWxldGVcIixpLHQuZGVsfHx0aGlzLm9wdGlvbnMubG9jYWxlcy5lbi5kZWwpO3RoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKG8pLHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKG8sYnQoZT10aGlzLmRlbGV0ZVNlbGVjdGVkKS5jYWxsKGUsdGhpcykpfX0se2tleTpcIl9jcmVhdGVCYWNrQnV0dG9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGUsaT10aGlzLl9jcmVhdGVCdXR0b24oXCJiYWNrXCIsXCJ2aXMtYmFja1wiLHQuYmFja3x8dGhpcy5vcHRpb25zLmxvY2FsZXMuZW4uYmFjayk7dGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoaSksdGhpcy5fYmluZEVsZW1lbnRFdmVudHMoaSxidChlPXRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcikuY2FsbChlLHRoaXMpKX19LHtrZXk6XCJfY3JlYXRlQnV0dG9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlLGkpe3ZhciBvPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTpcInZpcy1sYWJlbFwiO3JldHVybiB0aGlzLm1hbmlwdWxhdGlvbkRPTVt0K1wiRGl2XCJdPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksdGhpcy5tYW5pcHVsYXRpb25ET01bdCtcIkRpdlwiXS5jbGFzc05hbWU9XCJ2aXMtYnV0dG9uIFwiK2UsdGhpcy5tYW5pcHVsYXRpb25ET01bdCtcIkxhYmVsXCJdPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5tYW5pcHVsYXRpb25ET01bdCtcIkxhYmVsXCJdLmNsYXNzTmFtZT1vLHRoaXMubWFuaXB1bGF0aW9uRE9NW3QrXCJMYWJlbFwiXS5pbm5lclRleHQ9aSx0aGlzLm1hbmlwdWxhdGlvbkRPTVt0K1wiRGl2XCJdLmFwcGVuZENoaWxkKHRoaXMubWFuaXB1bGF0aW9uRE9NW3QrXCJMYWJlbFwiXSksdGhpcy5tYW5pcHVsYXRpb25ET01bdCtcIkRpdlwiXX19LHtrZXk6XCJfY3JlYXRlRGVzY3JpcHRpb25cIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLm1hbmlwdWxhdGlvbkRPTS5kZXNjcmlwdGlvbkxhYmVsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5tYW5pcHVsYXRpb25ET00uZGVzY3JpcHRpb25MYWJlbC5jbGFzc05hbWU9XCJ2aXMtbm9uZVwiLHRoaXMubWFuaXB1bGF0aW9uRE9NLmRlc2NyaXB0aW9uTGFiZWwuaW5uZXJUZXh0PXQsdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25ET00uZGVzY3JpcHRpb25MYWJlbCl9fSx7a2V5OlwiX3RlbXBvcmFyeUJpbmRFdmVudFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucy5wdXNoKHtldmVudDp0LGJvdW5kRnVuY3Rpb246ZX0pLHRoaXMuYm9keS5lbWl0dGVyLm9uKHQsZSl9fSx7a2V5OlwiX3RlbXBvcmFyeUJpbmRVSVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwPT09dGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW3RdKXRocm93IG5ldyBFcnJvcihcIlRoaXMgVUkgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QuIFR5cG8/IFlvdSB0cmllZDogXCIrdCtcIiBwb3NzaWJsZSBhcmU6IFwiK0xyKHhuKHRoaXMuYm9keS5ldmVudExpc3RlbmVycykpKTt0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW3RdPXRoaXMuYm9keS5ldmVudExpc3RlbmVyc1t0XSx0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnNbdF09ZX19LHtrZXk6XCJfdW5iaW5kVGVtcG9yYXJ5VUlzXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucyx0KSYmKHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1t0XT10aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW3RdLGRlbGV0ZSB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW3RdKTt0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zPXt9fX0se2tleTpcIl91bmJpbmRUZW1wb3JhcnlFdmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8dGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucy5sZW5ndGg7dCsrKXt2YXIgZT10aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zW3RdLmV2ZW50LGk9dGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9uc1t0XS5ib3VuZEZ1bmN0aW9uO3RoaXMuYm9keS5lbWl0dGVyLm9mZihlLGkpfXRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnM9W119fSx7a2V5OlwiX2JpbmRFbGVtZW50RXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgaT1uZXcgU2godCx7fSk7VHUoaSxlKSx0aGlzLl9kb21FdmVudExpc3RlbmVyQ2xlYW51cFF1ZXVlLnB1c2goKGZ1bmN0aW9uKCl7aS5kZXN0cm95KCl9KSk7dmFyIG89ZnVuY3Rpb24odCl7dmFyIGk9dC5rZXlDb2RlLG89dC5rZXk7XCJFbnRlclwiIT09byYmXCIgXCIhPT1vJiYxMyE9PWkmJjMyIT09aXx8ZSgpfTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLG8sITEpLHRoaXMuX2RvbUV2ZW50TGlzdGVuZXJDbGVhbnVwUXVldWUucHVzaCgoZnVuY3Rpb24oKXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLG8sITEpfSkpfX0se2tleTpcIl9jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDx0aGlzLnRlbXBvcmFyeUlkcy5lZGdlcy5sZW5ndGg7dCsrKXt2YXIgZTt0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbdF1dLmRpc2Nvbm5lY3QoKSxkZWxldGUgdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW3RdXTt2YXIgaSxvPU1yKGU9dGhpcy5ib2R5LmVkZ2VJbmRpY2VzKS5jYWxsKGUsdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbdF0pO2lmKC0xIT09bylxbihpPXRoaXMuYm9keS5lZGdlSW5kaWNlcykuY2FsbChpLG8sMSl9Zm9yKHZhciBuPTA7bjx0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5sZW5ndGg7bisrKXt2YXIgcjtkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzW25dXTt2YXIgcyxhPU1yKHI9dGhpcy5ib2R5Lm5vZGVJbmRpY2VzKS5jYWxsKHIsdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbbl0pO2lmKC0xIT09YSlxbihzPXRoaXMuYm9keS5ub2RlSW5kaWNlcykuY2FsbChzLGEsMSl9dGhpcy50ZW1wb3JhcnlJZHM9e25vZGVzOltdLGVkZ2VzOltdfX19LHtrZXk6XCJfY29udHJvbE5vZGVUb3VjaFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpLHRoaXMubGFzdFRvdWNoPXRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcih0LmNlbnRlciksdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb249Y3Qoe30sdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24pfX0se2tleTpcIl9jb250cm9sTm9kZURyYWdTdGFydFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5sYXN0VG91Y2gsZT10aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHQpLGk9dGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzBdXSxvPXRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1sxXV0sbj10aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07dGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlPXZvaWQgMDt2YXIgcj1pLmlzT3ZlcmxhcHBpbmdXaXRoKGUpLHM9by5pc092ZXJsYXBwaW5nV2l0aChlKTshMD09PXI/KHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZT1pLG4uZWRnZVR5cGUuZnJvbT1pKTohMD09PXMmJih0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGU9byxuLmVkZ2VUeXBlLnRvPW8pLHZvaWQgMCE9PXRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSYmdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE9iamVjdCh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpfX0se2tleTpcIl9jb250cm9sTm9kZURyYWdcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZGlzYWJsZVBoeXNpY3NcIik7dmFyIGU9dGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKHQuY2VudGVyKSxpPXRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKGUpO3ZvaWQgMCE9PXRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZT8odGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlLng9aS54LHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS55PWkueSk6dGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIub25EcmFnKHQpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpfX0se2tleTpcIl9jb250cm9sTm9kZURyYWdFbmRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIodC5jZW50ZXIpLGk9dGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChlKSxvPXRoaXMuYm9keS5lZGdlc1t0aGlzLmVkZ2VCZWluZ0VkaXRlZElkXTtpZih2b2lkIDAhPT10aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUpe3RoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO2Zvcih2YXIgbj10aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKGkpLHI9dm9pZCAwLHM9bi5sZW5ndGgtMTtzPj0wO3MtLSlpZihuW3NdIT09dGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlLmlkKXtyPXRoaXMuYm9keS5ub2Rlc1tuW3NdXTticmVha31pZih2b2lkIDAhPT1yJiZ2b2lkIDAhPT10aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUpaWYoITA9PT1yLmlzQ2x1c3RlcilhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXS5jcmVhdGVFZGdlRXJyb3J8fHRoaXMub3B0aW9ucy5sb2NhbGVzLmVuLmNyZWF0ZUVkZ2VFcnJvcik7ZWxzZXt2YXIgYT10aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dO3RoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS5pZD09PWEuaWQ/dGhpcy5fcGVyZm9ybUVkaXRFZGdlKHIuaWQsby50by5pZCk6dGhpcy5fcGVyZm9ybUVkaXRFZGdlKG8uZnJvbS5pZCxyLmlkKX1lbHNlIG8udXBkYXRlRWRnZVR5cGUoKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVzdG9yZVBoeXNpY3NcIik7dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIil9fX0se2tleTpcIl9oYW5kbGVDb25uZWN0XCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoKG5ldyBEYXRlKS52YWx1ZU9mKCktdGhpcy50b3VjaFRpbWU+MTAwKXt0aGlzLmxhc3RUb3VjaD10aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIodC5jZW50ZXIpLHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uPWN0KHt9LHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uKSx0aGlzLmludGVyYWN0aW9uSGFuZGxlci5kcmFnLnBvaW50ZXI9dGhpcy5sYXN0VG91Y2gsdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIuZHJhZy50cmFuc2xhdGlvbj10aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbjt2YXIgZT10aGlzLmxhc3RUb3VjaCxpPXRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQoZSk7aWYodm9pZCAwIT09aSlpZighMD09PWkuaXNDbHVzdGVyKWFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdLmNyZWF0ZUVkZ2VFcnJvcnx8dGhpcy5vcHRpb25zLmxvY2FsZXMuZW4uY3JlYXRlRWRnZUVycm9yKTtlbHNle3ZhciBvPXRoaXMuX2dldE5ld1RhcmdldE5vZGUoaS54LGkueSk7dGhpcy5ib2R5Lm5vZGVzW28uaWRdPW8sdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2goby5pZCk7dmFyIG49dGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVFZGdlKHtpZDpcImNvbm5lY3Rpb25FZGdlXCIrYnUoKSxmcm9tOmkuaWQsdG86by5pZCxwaHlzaWNzOiExLHNtb290aDp7ZW5hYmxlZDohMCx0eXBlOlwiY29udGludW91c1wiLHJvdW5kbmVzczouNX19KTt0aGlzLmJvZHkuZWRnZXNbbi5pZF09bix0aGlzLmJvZHkuZWRnZUluZGljZXMucHVzaChuLmlkKSx0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5wdXNoKG8uaWQpLHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzLnB1c2gobi5pZCl9dGhpcy50b3VjaFRpbWU9KG5ldyBEYXRlKS52YWx1ZU9mKCl9fX0se2tleTpcIl9kcmFnQ29udHJvbE5vZGVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIodC5jZW50ZXIpLGk9dGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChlKSxvPXZvaWQgMDt2b2lkIDAhPT10aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1swXSYmKG89dGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdXS5mcm9tSWQpO2Zvcih2YXIgbj10aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKGkpLHI9dm9pZCAwLHM9bi5sZW5ndGgtMTtzPj0wO3MtLSl7dmFyIGE7aWYoLTE9PT1NcihhPXRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzKS5jYWxsKGEsbltzXSkpe3I9dGhpcy5ib2R5Lm5vZGVzW25bc11dO2JyZWFrfX1pZih0LmNvbnRyb2xFZGdlPXtmcm9tOm8sdG86cj9yLmlkOnZvaWQgMH0sdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImNvbnRyb2xOb2RlRHJhZ2dpbmdcIix0LGUpLHZvaWQgMCE9PXRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzBdKXt2YXIgaD10aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dO2gueD10aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhlLngpLGgueT10aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhlLnkpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpfWVsc2UgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIub25EcmFnKHQpfX0se2tleTpcIl9maW5pc2hDb25uZWN0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKHQuY2VudGVyKSxpPXRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QoZSksbz12b2lkIDA7dm9pZCAwIT09dGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbMF0mJihvPXRoaXMuYm9keS5lZGdlc1t0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1swXV0uZnJvbUlkKTtmb3IodmFyIG49dGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChpKSxyPXZvaWQgMCxzPW4ubGVuZ3RoLTE7cz49MDtzLS0pe3ZhciBhO2lmKC0xPT09TXIoYT10aGlzLnRlbXBvcmFyeUlkcy5ub2RlcykuY2FsbChhLG5bc10pKXtyPXRoaXMuYm9keS5ub2Rlc1tuW3NdXTticmVha319dGhpcy5fY2xlYW51cFRlbXBvcmFyeU5vZGVzQW5kRWRnZXMoKSx2b2lkIDAhPT1yJiYoITA9PT1yLmlzQ2x1c3Rlcj9hbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXS5jcmVhdGVFZGdlRXJyb3J8fHRoaXMub3B0aW9ucy5sb2NhbGVzLmVuLmNyZWF0ZUVkZ2VFcnJvcik6dm9pZCAwIT09dGhpcy5ib2R5Lm5vZGVzW29dJiZ2b2lkIDAhPT10aGlzLmJvZHkubm9kZXNbci5pZF0mJnRoaXMuX3BlcmZvcm1BZGRFZGdlKG8sci5pZCkpLHQuY29udHJvbEVkZ2U9e2Zyb206byx0bzpyP3IuaWQ6dm9pZCAwfSx0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiY29udHJvbE5vZGVEcmFnRW5kXCIsdCxlKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKX19LHtrZXk6XCJfZHJhZ1N0YXJ0RWRnZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMubGFzdFRvdWNoO3RoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnU3RhcnRcIix0LGUsdm9pZCAwLCEwKX19LHtrZXk6XCJfcGVyZm9ybUFkZE5vZGVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLGk9e2lkOmJ1KCkseDp0LnBvaW50ZXIuY2FudmFzLngseTp0LnBvaW50ZXIuY2FudmFzLnksbGFiZWw6XCJuZXdcIn07aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5vcHRpb25zLmFkZE5vZGUpe2lmKDIhPT10aGlzLm9wdGlvbnMuYWRkTm9kZS5sZW5ndGgpdGhyb3cgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCksbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIGZvciBhZGQgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLGNhbGxiYWNrKVwiKTt0aGlzLm9wdGlvbnMuYWRkTm9kZShpLChmdW5jdGlvbih0KXtudWxsIT10JiZcImFkZE5vZGVcIj09PWUuaW5Nb2RlJiZlLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkuYWRkKHQpLGUuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpfSkpfWVsc2UgdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLmFkZChpKSx0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKX19LHtrZXk6XCJfcGVyZm9ybUFkZEVkZ2VcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMsbz17ZnJvbTp0LHRvOmV9O2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub3B0aW9ucy5hZGRFZGdlKXtpZigyIT09dGhpcy5vcHRpb25zLmFkZEVkZ2UubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBmb3IgY29ubmVjdCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsY2FsbGJhY2spXCIpO3RoaXMub3B0aW9ucy5hZGRFZGdlKG8sKGZ1bmN0aW9uKHQpe251bGwhPXQmJlwiYWRkRWRnZVwiPT09aS5pbk1vZGUmJihpLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkuYWRkKHQpLGkuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpLGkuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpKX0pKX1lbHNlIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5hZGQobyksdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCksdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCl9fSx7a2V5OlwiX3BlcmZvcm1FZGl0RWRnZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9dGhpcyxvPXtpZDp0aGlzLmVkZ2VCZWluZ0VkaXRlZElkLGZyb206dCx0bzplLGxhYmVsOnRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldCh0aGlzLmVkZ2VCZWluZ0VkaXRlZElkKS5sYWJlbH0sbj10aGlzLm9wdGlvbnMuZWRpdEVkZ2U7aWYoXCJvYmplY3RcIj09PWRuKG4pJiYobj1uLmVkaXRXaXRob3V0RHJhZyksXCJmdW5jdGlvblwiPT10eXBlb2Ygbil7aWYoMiE9PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBmb3IgZWRpdCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsIGNhbGxiYWNrKVwiKTtuKG8sKGZ1bmN0aW9uKHQpe251bGw9PXR8fFwiZWRpdEVkZ2VcIiE9PWkuaW5Nb2RlPyhpLmJvZHkuZWRnZXNbby5pZF0udXBkYXRlRWRnZVR5cGUoKSxpLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKSxpLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKSk6KGkuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS51cGRhdGUodCksaS5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCksaS5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCkpfSkpfWVsc2UgdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnVwZGF0ZShvKSx0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKSx0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKX19XSksdH0oKSxVZj1cInN0cmluZ1wiLFlmPVwiYm9vbGVhblwiLFhmPVwibnVtYmVyXCIsR2Y9XCJhcnJheVwiLEtmPVwib2JqZWN0XCIsJGY9W1wiYXJyb3dcIixcImJhclwiLFwiYm94XCIsXCJjaXJjbGVcIixcImNyb3dcIixcImN1cnZlXCIsXCJkaWFtb25kXCIsXCJpbWFnZVwiLFwiaW52X2N1cnZlXCIsXCJpbnZfdHJpYW5nbGVcIixcInRyaWFuZ2xlXCIsXCJ2ZWVcIl0sUWY9e2JvcmRlcldpZHRoOntudW1iZXI6WGZ9LGJvcmRlcldpZHRoU2VsZWN0ZWQ6e251bWJlcjpYZix1bmRlZmluZWQ6XCJ1bmRlZmluZWRcIn0sYnJva2VuSW1hZ2U6e3N0cmluZzpVZix1bmRlZmluZWQ6XCJ1bmRlZmluZWRcIn0sY2hvc2VuOntsYWJlbDp7Ym9vbGVhbjpZZixmdW5jdGlvbjpcImZ1bmN0aW9uXCJ9LG5vZGU6e2Jvb2xlYW46WWYsZnVuY3Rpb246XCJmdW5jdGlvblwifSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWZ9fSxjb2xvcjp7Ym9yZGVyOntzdHJpbmc6VWZ9LGJhY2tncm91bmQ6e3N0cmluZzpVZn0saGlnaGxpZ2h0Ontib3JkZXI6e3N0cmluZzpVZn0sYmFja2dyb3VuZDp7c3RyaW5nOlVmfSxfX3R5cGVfXzp7b2JqZWN0OktmLHN0cmluZzpVZn19LGhvdmVyOntib3JkZXI6e3N0cmluZzpVZn0sYmFja2dyb3VuZDp7c3RyaW5nOlVmfSxfX3R5cGVfXzp7b2JqZWN0OktmLHN0cmluZzpVZn19LF9fdHlwZV9fOntvYmplY3Q6S2Ysc3RyaW5nOlVmfX0sb3BhY2l0eTp7bnVtYmVyOlhmLHVuZGVmaW5lZDpcInVuZGVmaW5lZFwifSxmaXhlZDp7eDp7Ym9vbGVhbjpZZn0seTp7Ym9vbGVhbjpZZn0sX190eXBlX186e29iamVjdDpLZixib29sZWFuOllmfX0sZm9udDp7YWxpZ246e3N0cmluZzpVZn0sY29sb3I6e3N0cmluZzpVZn0sc2l6ZTp7bnVtYmVyOlhmfSxmYWNlOntzdHJpbmc6VWZ9LGJhY2tncm91bmQ6e3N0cmluZzpVZn0sc3Ryb2tlV2lkdGg6e251bWJlcjpYZn0sc3Ryb2tlQ29sb3I6e3N0cmluZzpVZn0sdmFkanVzdDp7bnVtYmVyOlhmfSxtdWx0aTp7Ym9vbGVhbjpZZixzdHJpbmc6VWZ9LGJvbGQ6e2NvbG9yOntzdHJpbmc6VWZ9LHNpemU6e251bWJlcjpYZn0sZmFjZTp7c3RyaW5nOlVmfSxtb2Q6e3N0cmluZzpVZn0sdmFkanVzdDp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLHN0cmluZzpVZn19LGJvbGRpdGFsOntjb2xvcjp7c3RyaW5nOlVmfSxzaXplOntudW1iZXI6WGZ9LGZhY2U6e3N0cmluZzpVZn0sbW9kOntzdHJpbmc6VWZ9LHZhZGp1c3Q6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZixzdHJpbmc6VWZ9fSxpdGFsOntjb2xvcjp7c3RyaW5nOlVmfSxzaXplOntudW1iZXI6WGZ9LGZhY2U6e3N0cmluZzpVZn0sbW9kOntzdHJpbmc6VWZ9LHZhZGp1c3Q6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZixzdHJpbmc6VWZ9fSxtb25vOntjb2xvcjp7c3RyaW5nOlVmfSxzaXplOntudW1iZXI6WGZ9LGZhY2U6e3N0cmluZzpVZn0sbW9kOntzdHJpbmc6VWZ9LHZhZGp1c3Q6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZixzdHJpbmc6VWZ9fSxfX3R5cGVfXzp7b2JqZWN0OktmLHN0cmluZzpVZn19LGdyb3VwOntzdHJpbmc6VWYsbnVtYmVyOlhmLHVuZGVmaW5lZDpcInVuZGVmaW5lZFwifSxoZWlnaHRDb25zdHJhaW50OnttaW5pbXVtOntudW1iZXI6WGZ9LHZhbGlnbjp7c3RyaW5nOlVmfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWYsbnVtYmVyOlhmfX0saGlkZGVuOntib29sZWFuOllmfSxpY29uOntmYWNlOntzdHJpbmc6VWZ9LGNvZGU6e3N0cmluZzpVZn0sc2l6ZTp7bnVtYmVyOlhmfSxjb2xvcjp7c3RyaW5nOlVmfSx3ZWlnaHQ6e3N0cmluZzpVZixudW1iZXI6WGZ9LF9fdHlwZV9fOntvYmplY3Q6S2Z9fSxpZDp7c3RyaW5nOlVmLG51bWJlcjpYZn0saW1hZ2U6e3NlbGVjdGVkOntzdHJpbmc6VWYsdW5kZWZpbmVkOlwidW5kZWZpbmVkXCJ9LHVuc2VsZWN0ZWQ6e3N0cmluZzpVZix1bmRlZmluZWQ6XCJ1bmRlZmluZWRcIn0sX190eXBlX186e29iamVjdDpLZixzdHJpbmc6VWZ9fSxpbWFnZVBhZGRpbmc6e3RvcDp7bnVtYmVyOlhmfSxyaWdodDp7bnVtYmVyOlhmfSxib3R0b206e251bWJlcjpYZn0sbGVmdDp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLG51bWJlcjpYZn19LGxhYmVsOntzdHJpbmc6VWYsdW5kZWZpbmVkOlwidW5kZWZpbmVkXCJ9LGxhYmVsSGlnaGxpZ2h0Qm9sZDp7Ym9vbGVhbjpZZn0sbGV2ZWw6e251bWJlcjpYZix1bmRlZmluZWQ6XCJ1bmRlZmluZWRcIn0sbWFyZ2luOnt0b3A6e251bWJlcjpYZn0scmlnaHQ6e251bWJlcjpYZn0sYm90dG9tOntudW1iZXI6WGZ9LGxlZnQ6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZixudW1iZXI6WGZ9fSxtYXNzOntudW1iZXI6WGZ9LHBoeXNpY3M6e2Jvb2xlYW46WWZ9LHNjYWxpbmc6e21pbjp7bnVtYmVyOlhmfSxtYXg6e251bWJlcjpYZn0sbGFiZWw6e2VuYWJsZWQ6e2Jvb2xlYW46WWZ9LG1pbjp7bnVtYmVyOlhmfSxtYXg6e251bWJlcjpYZn0sbWF4VmlzaWJsZTp7bnVtYmVyOlhmfSxkcmF3VGhyZXNob2xkOntudW1iZXI6WGZ9LF9fdHlwZV9fOntvYmplY3Q6S2YsYm9vbGVhbjpZZn19LGN1c3RvbVNjYWxpbmdGdW5jdGlvbjp7ZnVuY3Rpb246XCJmdW5jdGlvblwifSxfX3R5cGVfXzp7b2JqZWN0OktmfX0sc2hhZG93OntlbmFibGVkOntib29sZWFuOllmfSxjb2xvcjp7c3RyaW5nOlVmfSxzaXplOntudW1iZXI6WGZ9LHg6e251bWJlcjpYZn0seTp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWZ9fSxzaGFwZTp7c3RyaW5nOltcImN1c3RvbVwiLFwiZWxsaXBzZVwiLFwiY2lyY2xlXCIsXCJkYXRhYmFzZVwiLFwiYm94XCIsXCJ0ZXh0XCIsXCJpbWFnZVwiLFwiY2lyY3VsYXJJbWFnZVwiLFwiZGlhbW9uZFwiLFwiZG90XCIsXCJzdGFyXCIsXCJ0cmlhbmdsZVwiLFwidHJpYW5nbGVEb3duXCIsXCJzcXVhcmVcIixcImljb25cIixcImhleGFnb25cIl19LGN0eFJlbmRlcmVyOntmdW5jdGlvbjpcImZ1bmN0aW9uXCJ9LHNoYXBlUHJvcGVydGllczp7Ym9yZGVyRGFzaGVzOntib29sZWFuOllmLGFycmF5OkdmfSxib3JkZXJSYWRpdXM6e251bWJlcjpYZn0saW50ZXJwb2xhdGlvbjp7Ym9vbGVhbjpZZn0sdXNlSW1hZ2VTaXplOntib29sZWFuOllmfSx1c2VCb3JkZXJXaXRoSW1hZ2U6e2Jvb2xlYW46WWZ9LGNvb3JkaW5hdGVPcmlnaW46e3N0cmluZzpbXCJjZW50ZXJcIixcInRvcC1sZWZ0XCJdfSxfX3R5cGVfXzp7b2JqZWN0OktmfX0sc2l6ZTp7bnVtYmVyOlhmfSx0aXRsZTp7c3RyaW5nOlVmLGRvbTpcImRvbVwiLHVuZGVmaW5lZDpcInVuZGVmaW5lZFwifSx2YWx1ZTp7bnVtYmVyOlhmLHVuZGVmaW5lZDpcInVuZGVmaW5lZFwifSx3aWR0aENvbnN0cmFpbnQ6e21pbmltdW06e251bWJlcjpYZn0sbWF4aW11bTp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWYsbnVtYmVyOlhmfX0seDp7bnVtYmVyOlhmfSx5OntudW1iZXI6WGZ9LF9fdHlwZV9fOntvYmplY3Q6S2Z9fSxaZj17Y29uZmlndXJlOntlbmFibGVkOntib29sZWFuOllmfSxmaWx0ZXI6e2Jvb2xlYW46WWYsc3RyaW5nOlVmLGFycmF5OkdmLGZ1bmN0aW9uOlwiZnVuY3Rpb25cIn0sY29udGFpbmVyOntkb206XCJkb21cIn0sc2hvd0J1dHRvbjp7Ym9vbGVhbjpZZn0sX190eXBlX186e29iamVjdDpLZixib29sZWFuOllmLHN0cmluZzpVZixhcnJheTpHZixmdW5jdGlvbjpcImZ1bmN0aW9uXCJ9fSxlZGdlczp7YXJyb3dzOnt0bzp7ZW5hYmxlZDp7Ym9vbGVhbjpZZn0sc2NhbGVGYWN0b3I6e251bWJlcjpYZn0sdHlwZTp7c3RyaW5nOiRmfSxpbWFnZUhlaWdodDp7bnVtYmVyOlhmfSxpbWFnZVdpZHRoOntudW1iZXI6WGZ9LHNyYzp7c3RyaW5nOlVmfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWZ9fSxtaWRkbGU6e2VuYWJsZWQ6e2Jvb2xlYW46WWZ9LHNjYWxlRmFjdG9yOntudW1iZXI6WGZ9LHR5cGU6e3N0cmluZzokZn0saW1hZ2VXaWR0aDp7bnVtYmVyOlhmfSxpbWFnZUhlaWdodDp7bnVtYmVyOlhmfSxzcmM6e3N0cmluZzpVZn0sX190eXBlX186e29iamVjdDpLZixib29sZWFuOllmfX0sZnJvbTp7ZW5hYmxlZDp7Ym9vbGVhbjpZZn0sc2NhbGVGYWN0b3I6e251bWJlcjpYZn0sdHlwZTp7c3RyaW5nOiRmfSxpbWFnZVdpZHRoOntudW1iZXI6WGZ9LGltYWdlSGVpZ2h0OntudW1iZXI6WGZ9LHNyYzp7c3RyaW5nOlVmfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWZ9fSxfX3R5cGVfXzp7c3RyaW5nOltcImZyb21cIixcInRvXCIsXCJtaWRkbGVcIl0sb2JqZWN0OktmfX0sZW5kUG9pbnRPZmZzZXQ6e2Zyb206e251bWJlcjpYZn0sdG86e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZixudW1iZXI6WGZ9fSxhcnJvd1N0cmlrZXRocm91Z2g6e2Jvb2xlYW46WWZ9LGJhY2tncm91bmQ6e2VuYWJsZWQ6e2Jvb2xlYW46WWZ9LGNvbG9yOntzdHJpbmc6VWZ9LHNpemU6e251bWJlcjpYZn0sZGFzaGVzOntib29sZWFuOllmLGFycmF5OkdmfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWZ9fSxjaG9zZW46e2xhYmVsOntib29sZWFuOllmLGZ1bmN0aW9uOlwiZnVuY3Rpb25cIn0sZWRnZTp7Ym9vbGVhbjpZZixmdW5jdGlvbjpcImZ1bmN0aW9uXCJ9LF9fdHlwZV9fOntvYmplY3Q6S2YsYm9vbGVhbjpZZn19LGNvbG9yOntjb2xvcjp7c3RyaW5nOlVmfSxoaWdobGlnaHQ6e3N0cmluZzpVZn0saG92ZXI6e3N0cmluZzpVZn0saW5oZXJpdDp7c3RyaW5nOltcImZyb21cIixcInRvXCIsXCJib3RoXCJdLGJvb2xlYW46WWZ9LG9wYWNpdHk6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZixzdHJpbmc6VWZ9fSxkYXNoZXM6e2Jvb2xlYW46WWYsYXJyYXk6R2Z9LGZvbnQ6e2NvbG9yOntzdHJpbmc6VWZ9LHNpemU6e251bWJlcjpYZn0sZmFjZTp7c3RyaW5nOlVmfSxiYWNrZ3JvdW5kOntzdHJpbmc6VWZ9LHN0cm9rZVdpZHRoOntudW1iZXI6WGZ9LHN0cm9rZUNvbG9yOntzdHJpbmc6VWZ9LGFsaWduOntzdHJpbmc6W1wiaG9yaXpvbnRhbFwiLFwidG9wXCIsXCJtaWRkbGVcIixcImJvdHRvbVwiXX0sdmFkanVzdDp7bnVtYmVyOlhmfSxtdWx0aTp7Ym9vbGVhbjpZZixzdHJpbmc6VWZ9LGJvbGQ6e2NvbG9yOntzdHJpbmc6VWZ9LHNpemU6e251bWJlcjpYZn0sZmFjZTp7c3RyaW5nOlVmfSxtb2Q6e3N0cmluZzpVZn0sdmFkanVzdDp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLHN0cmluZzpVZn19LGJvbGRpdGFsOntjb2xvcjp7c3RyaW5nOlVmfSxzaXplOntudW1iZXI6WGZ9LGZhY2U6e3N0cmluZzpVZn0sbW9kOntzdHJpbmc6VWZ9LHZhZGp1c3Q6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZixzdHJpbmc6VWZ9fSxpdGFsOntjb2xvcjp7c3RyaW5nOlVmfSxzaXplOntudW1iZXI6WGZ9LGZhY2U6e3N0cmluZzpVZn0sbW9kOntzdHJpbmc6VWZ9LHZhZGp1c3Q6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZixzdHJpbmc6VWZ9fSxtb25vOntjb2xvcjp7c3RyaW5nOlVmfSxzaXplOntudW1iZXI6WGZ9LGZhY2U6e3N0cmluZzpVZn0sbW9kOntzdHJpbmc6VWZ9LHZhZGp1c3Q6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZixzdHJpbmc6VWZ9fSxfX3R5cGVfXzp7b2JqZWN0OktmLHN0cmluZzpVZn19LGhpZGRlbjp7Ym9vbGVhbjpZZn0saG92ZXJXaWR0aDp7ZnVuY3Rpb246XCJmdW5jdGlvblwiLG51bWJlcjpYZn0sbGFiZWw6e3N0cmluZzpVZix1bmRlZmluZWQ6XCJ1bmRlZmluZWRcIn0sbGFiZWxIaWdobGlnaHRCb2xkOntib29sZWFuOllmfSxsZW5ndGg6e251bWJlcjpYZix1bmRlZmluZWQ6XCJ1bmRlZmluZWRcIn0scGh5c2ljczp7Ym9vbGVhbjpZZn0sc2NhbGluZzp7bWluOntudW1iZXI6WGZ9LG1heDp7bnVtYmVyOlhmfSxsYWJlbDp7ZW5hYmxlZDp7Ym9vbGVhbjpZZn0sbWluOntudW1iZXI6WGZ9LG1heDp7bnVtYmVyOlhmfSxtYXhWaXNpYmxlOntudW1iZXI6WGZ9LGRyYXdUaHJlc2hvbGQ6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZixib29sZWFuOllmfX0sY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOntmdW5jdGlvbjpcImZ1bmN0aW9uXCJ9LF9fdHlwZV9fOntvYmplY3Q6S2Z9fSxzZWxlY3Rpb25XaWR0aDp7ZnVuY3Rpb246XCJmdW5jdGlvblwiLG51bWJlcjpYZn0sc2VsZlJlZmVyZW5jZVNpemU6e251bWJlcjpYZn0sc2VsZlJlZmVyZW5jZTp7c2l6ZTp7bnVtYmVyOlhmfSxhbmdsZTp7bnVtYmVyOlhmfSxyZW5kZXJCZWhpbmRUaGVOb2RlOntib29sZWFuOllmfSxfX3R5cGVfXzp7b2JqZWN0OktmfX0sc2hhZG93OntlbmFibGVkOntib29sZWFuOllmfSxjb2xvcjp7c3RyaW5nOlVmfSxzaXplOntudW1iZXI6WGZ9LHg6e251bWJlcjpYZn0seTp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWZ9fSxzbW9vdGg6e2VuYWJsZWQ6e2Jvb2xlYW46WWZ9LHR5cGU6e3N0cmluZzpbXCJkeW5hbWljXCIsXCJjb250aW51b3VzXCIsXCJkaXNjcmV0ZVwiLFwiZGlhZ29uYWxDcm9zc1wiLFwic3RyYWlnaHRDcm9zc1wiLFwiaG9yaXpvbnRhbFwiLFwidmVydGljYWxcIixcImN1cnZlZENXXCIsXCJjdXJ2ZWRDQ1dcIixcImN1YmljQmV6aWVyXCJdfSxyb3VuZG5lc3M6e251bWJlcjpYZn0sZm9yY2VEaXJlY3Rpb246e3N0cmluZzpbXCJob3Jpem9udGFsXCIsXCJ2ZXJ0aWNhbFwiLFwibm9uZVwiXSxib29sZWFuOllmfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWZ9fSx0aXRsZTp7c3RyaW5nOlVmLHVuZGVmaW5lZDpcInVuZGVmaW5lZFwifSx3aWR0aDp7bnVtYmVyOlhmfSx3aWR0aENvbnN0cmFpbnQ6e21heGltdW06e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZixib29sZWFuOllmLG51bWJlcjpYZn19LHZhbHVlOntudW1iZXI6WGYsdW5kZWZpbmVkOlwidW5kZWZpbmVkXCJ9LF9fdHlwZV9fOntvYmplY3Q6S2Z9fSxncm91cHM6e3VzZURlZmF1bHRHcm91cHM6e2Jvb2xlYW46WWZ9LF9fYW55X186UWYsX190eXBlX186e29iamVjdDpLZn19LGludGVyYWN0aW9uOntkcmFnTm9kZXM6e2Jvb2xlYW46WWZ9LGRyYWdWaWV3Ontib29sZWFuOllmfSxoaWRlRWRnZXNPbkRyYWc6e2Jvb2xlYW46WWZ9LGhpZGVFZGdlc09uWm9vbTp7Ym9vbGVhbjpZZn0saGlkZU5vZGVzT25EcmFnOntib29sZWFuOllmfSxob3Zlcjp7Ym9vbGVhbjpZZn0sa2V5Ym9hcmQ6e2VuYWJsZWQ6e2Jvb2xlYW46WWZ9LHNwZWVkOnt4OntudW1iZXI6WGZ9LHk6e251bWJlcjpYZn0sem9vbTp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmfX0sYmluZFRvV2luZG93Ontib29sZWFuOllmfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWZ9fSxtdWx0aXNlbGVjdDp7Ym9vbGVhbjpZZn0sbmF2aWdhdGlvbkJ1dHRvbnM6e2Jvb2xlYW46WWZ9LHNlbGVjdGFibGU6e2Jvb2xlYW46WWZ9LHNlbGVjdENvbm5lY3RlZEVkZ2VzOntib29sZWFuOllmfSxob3ZlckNvbm5lY3RlZEVkZ2VzOntib29sZWFuOllmfSx0b29sdGlwRGVsYXk6e251bWJlcjpYZn0sem9vbVZpZXc6e2Jvb2xlYW46WWZ9LHpvb21TcGVlZDp7bnVtYmVyOlhmfSxfX3R5cGVfXzp7b2JqZWN0OktmfX0sbGF5b3V0OntyYW5kb21TZWVkOnt1bmRlZmluZWQ6XCJ1bmRlZmluZWRcIixudW1iZXI6WGYsc3RyaW5nOlVmfSxpbXByb3ZlZExheW91dDp7Ym9vbGVhbjpZZn0sY2x1c3RlclRocmVzaG9sZDp7bnVtYmVyOlhmfSxoaWVyYXJjaGljYWw6e2VuYWJsZWQ6e2Jvb2xlYW46WWZ9LGxldmVsU2VwYXJhdGlvbjp7bnVtYmVyOlhmfSxub2RlU3BhY2luZzp7bnVtYmVyOlhmfSx0cmVlU3BhY2luZzp7bnVtYmVyOlhmfSxibG9ja1NoaWZ0aW5nOntib29sZWFuOllmfSxlZGdlTWluaW1pemF0aW9uOntib29sZWFuOllmfSxwYXJlbnRDZW50cmFsaXphdGlvbjp7Ym9vbGVhbjpZZn0sZGlyZWN0aW9uOntzdHJpbmc6W1wiVURcIixcIkRVXCIsXCJMUlwiLFwiUkxcIl19LHNvcnRNZXRob2Q6e3N0cmluZzpbXCJodWJzaXplXCIsXCJkaXJlY3RlZFwiXX0sc2hha2VUb3dhcmRzOntzdHJpbmc6W1wibGVhdmVzXCIsXCJyb290c1wiXX0sX190eXBlX186e29iamVjdDpLZixib29sZWFuOllmfX0sX190eXBlX186e29iamVjdDpLZn19LG1hbmlwdWxhdGlvbjp7ZW5hYmxlZDp7Ym9vbGVhbjpZZn0saW5pdGlhbGx5QWN0aXZlOntib29sZWFuOllmfSxhZGROb2RlOntib29sZWFuOllmLGZ1bmN0aW9uOlwiZnVuY3Rpb25cIn0sYWRkRWRnZTp7Ym9vbGVhbjpZZixmdW5jdGlvbjpcImZ1bmN0aW9uXCJ9LGVkaXROb2RlOntmdW5jdGlvbjpcImZ1bmN0aW9uXCJ9LGVkaXRFZGdlOntlZGl0V2l0aG91dERyYWc6e2Z1bmN0aW9uOlwiZnVuY3Rpb25cIn0sX190eXBlX186e29iamVjdDpLZixib29sZWFuOllmLGZ1bmN0aW9uOlwiZnVuY3Rpb25cIn19LGRlbGV0ZU5vZGU6e2Jvb2xlYW46WWYsZnVuY3Rpb246XCJmdW5jdGlvblwifSxkZWxldGVFZGdlOntib29sZWFuOllmLGZ1bmN0aW9uOlwiZnVuY3Rpb25cIn0sY29udHJvbE5vZGVTdHlsZTpRZixfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWZ9fSxub2RlczpRZixwaHlzaWNzOntlbmFibGVkOntib29sZWFuOllmfSxiYXJuZXNIdXQ6e3RoZXRhOntudW1iZXI6WGZ9LGdyYXZpdGF0aW9uYWxDb25zdGFudDp7bnVtYmVyOlhmfSxjZW50cmFsR3Jhdml0eTp7bnVtYmVyOlhmfSxzcHJpbmdMZW5ndGg6e251bWJlcjpYZn0sc3ByaW5nQ29uc3RhbnQ6e251bWJlcjpYZn0sZGFtcGluZzp7bnVtYmVyOlhmfSxhdm9pZE92ZXJsYXA6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZn19LGZvcmNlQXRsYXMyQmFzZWQ6e3RoZXRhOntudW1iZXI6WGZ9LGdyYXZpdGF0aW9uYWxDb25zdGFudDp7bnVtYmVyOlhmfSxjZW50cmFsR3Jhdml0eTp7bnVtYmVyOlhmfSxzcHJpbmdMZW5ndGg6e251bWJlcjpYZn0sc3ByaW5nQ29uc3RhbnQ6e251bWJlcjpYZn0sZGFtcGluZzp7bnVtYmVyOlhmfSxhdm9pZE92ZXJsYXA6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZn19LHJlcHVsc2lvbjp7Y2VudHJhbEdyYXZpdHk6e251bWJlcjpYZn0sc3ByaW5nTGVuZ3RoOntudW1iZXI6WGZ9LHNwcmluZ0NvbnN0YW50OntudW1iZXI6WGZ9LG5vZGVEaXN0YW5jZTp7bnVtYmVyOlhmfSxkYW1waW5nOntudW1iZXI6WGZ9LF9fdHlwZV9fOntvYmplY3Q6S2Z9fSxoaWVyYXJjaGljYWxSZXB1bHNpb246e2NlbnRyYWxHcmF2aXR5OntudW1iZXI6WGZ9LHNwcmluZ0xlbmd0aDp7bnVtYmVyOlhmfSxzcHJpbmdDb25zdGFudDp7bnVtYmVyOlhmfSxub2RlRGlzdGFuY2U6e251bWJlcjpYZn0sZGFtcGluZzp7bnVtYmVyOlhmfSxhdm9pZE92ZXJsYXA6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZn19LG1heFZlbG9jaXR5OntudW1iZXI6WGZ9LG1pblZlbG9jaXR5OntudW1iZXI6WGZ9LHNvbHZlcjp7c3RyaW5nOltcImJhcm5lc0h1dFwiLFwicmVwdWxzaW9uXCIsXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIixcImZvcmNlQXRsYXMyQmFzZWRcIl19LHN0YWJpbGl6YXRpb246e2VuYWJsZWQ6e2Jvb2xlYW46WWZ9LGl0ZXJhdGlvbnM6e251bWJlcjpYZn0sdXBkYXRlSW50ZXJ2YWw6e251bWJlcjpYZn0sb25seUR5bmFtaWNFZGdlczp7Ym9vbGVhbjpZZn0sZml0Ontib29sZWFuOllmfSxfX3R5cGVfXzp7b2JqZWN0OktmLGJvb2xlYW46WWZ9fSx0aW1lc3RlcDp7bnVtYmVyOlhmfSxhZGFwdGl2ZVRpbWVzdGVwOntib29sZWFuOllmfSx3aW5kOnt4OntudW1iZXI6WGZ9LHk6e251bWJlcjpYZn0sX190eXBlX186e29iamVjdDpLZn19LF9fdHlwZV9fOntvYmplY3Q6S2YsYm9vbGVhbjpZZn19LGF1dG9SZXNpemU6e2Jvb2xlYW46WWZ9LGNsaWNrVG9Vc2U6e2Jvb2xlYW46WWZ9LGxvY2FsZTp7c3RyaW5nOlVmfSxsb2NhbGVzOntfX2FueV9fOnthbnk6XCJhbnlcIn0sX190eXBlX186e29iamVjdDpLZn19LGhlaWdodDp7c3RyaW5nOlVmfSx3aWR0aDp7c3RyaW5nOlVmfSxfX3R5cGVfXzp7b2JqZWN0OktmfX0sSmY9e25vZGVzOntib3JkZXJXaWR0aDpbMSwwLDEwLDFdLGJvcmRlcldpZHRoU2VsZWN0ZWQ6WzIsMCwxMCwxXSxjb2xvcjp7Ym9yZGVyOltcImNvbG9yXCIsXCIjMkI3Q0U5XCJdLGJhY2tncm91bmQ6W1wiY29sb3JcIixcIiM5N0MyRkNcIl0saGlnaGxpZ2h0Ontib3JkZXI6W1wiY29sb3JcIixcIiMyQjdDRTlcIl0sYmFja2dyb3VuZDpbXCJjb2xvclwiLFwiI0QyRTVGRlwiXX0saG92ZXI6e2JvcmRlcjpbXCJjb2xvclwiLFwiIzJCN0NFOVwiXSxiYWNrZ3JvdW5kOltcImNvbG9yXCIsXCIjRDJFNUZGXCJdfX0sb3BhY2l0eTpbMCwwLDEsLjFdLGZpeGVkOnt4OiExLHk6ITF9LGZvbnQ6e2NvbG9yOltcImNvbG9yXCIsXCIjMzQzNDM0XCJdLHNpemU6WzE0LDAsMTAwLDFdLGZhY2U6W1wiYXJpYWxcIixcInZlcmRhbmFcIixcInRhaG9tYVwiXSxiYWNrZ3JvdW5kOltcImNvbG9yXCIsXCJub25lXCJdLHN0cm9rZVdpZHRoOlswLDAsNTAsMV0sc3Ryb2tlQ29sb3I6W1wiY29sb3JcIixcIiNmZmZmZmZcIl19LGhpZGRlbjohMSxsYWJlbEhpZ2hsaWdodEJvbGQ6ITAscGh5c2ljczohMCxzY2FsaW5nOnttaW46WzEwLDAsMjAwLDFdLG1heDpbMzAsMCwyMDAsMV0sbGFiZWw6e2VuYWJsZWQ6ITEsbWluOlsxNCwwLDIwMCwxXSxtYXg6WzMwLDAsMjAwLDFdLG1heFZpc2libGU6WzMwLDAsMjAwLDFdLGRyYXdUaHJlc2hvbGQ6WzUsMCwyMCwxXX19LHNoYWRvdzp7ZW5hYmxlZDohMSxjb2xvcjpcInJnYmEoMCwwLDAsMC41KVwiLHNpemU6WzEwLDAsMjAsMV0seDpbNSwtMzAsMzAsMV0seTpbNSwtMzAsMzAsMV19LHNoYXBlOltcImVsbGlwc2VcIixcImJveFwiLFwiY2lyY2xlXCIsXCJkYXRhYmFzZVwiLFwiZGlhbW9uZFwiLFwiZG90XCIsXCJzcXVhcmVcIixcInN0YXJcIixcInRleHRcIixcInRyaWFuZ2xlXCIsXCJ0cmlhbmdsZURvd25cIixcImhleGFnb25cIl0sc2hhcGVQcm9wZXJ0aWVzOntib3JkZXJEYXNoZXM6ITEsYm9yZGVyUmFkaXVzOls2LDAsMjAsMV0saW50ZXJwb2xhdGlvbjohMCx1c2VJbWFnZVNpemU6ITF9LHNpemU6WzI1LDAsMjAwLDFdfSxlZGdlczp7YXJyb3dzOnt0bzp7ZW5hYmxlZDohMSxzY2FsZUZhY3RvcjpbMSwwLDMsLjA1XSx0eXBlOlwiYXJyb3dcIn0sbWlkZGxlOntlbmFibGVkOiExLHNjYWxlRmFjdG9yOlsxLDAsMywuMDVdLHR5cGU6XCJhcnJvd1wifSxmcm9tOntlbmFibGVkOiExLHNjYWxlRmFjdG9yOlsxLDAsMywuMDVdLHR5cGU6XCJhcnJvd1wifX0sZW5kUG9pbnRPZmZzZXQ6e2Zyb206WzAsLTEwLDEwLDFdLHRvOlswLC0xMCwxMCwxXX0sYXJyb3dTdHJpa2V0aHJvdWdoOiEwLGNvbG9yOntjb2xvcjpbXCJjb2xvclwiLFwiIzg0ODQ4NFwiXSxoaWdobGlnaHQ6W1wiY29sb3JcIixcIiM4NDg0ODRcIl0saG92ZXI6W1wiY29sb3JcIixcIiM4NDg0ODRcIl0saW5oZXJpdDpbXCJmcm9tXCIsXCJ0b1wiLFwiYm90aFwiLCEwLCExXSxvcGFjaXR5OlsxLDAsMSwuMDVdfSxkYXNoZXM6ITEsZm9udDp7Y29sb3I6W1wiY29sb3JcIixcIiMzNDM0MzRcIl0sc2l6ZTpbMTQsMCwxMDAsMV0sZmFjZTpbXCJhcmlhbFwiLFwidmVyZGFuYVwiLFwidGFob21hXCJdLGJhY2tncm91bmQ6W1wiY29sb3JcIixcIm5vbmVcIl0sc3Ryb2tlV2lkdGg6WzIsMCw1MCwxXSxzdHJva2VDb2xvcjpbXCJjb2xvclwiLFwiI2ZmZmZmZlwiXSxhbGlnbjpbXCJob3Jpem9udGFsXCIsXCJ0b3BcIixcIm1pZGRsZVwiLFwiYm90dG9tXCJdfSxoaWRkZW46ITEsaG92ZXJXaWR0aDpbMS41LDAsNSwuMV0sbGFiZWxIaWdobGlnaHRCb2xkOiEwLHBoeXNpY3M6ITAsc2NhbGluZzp7bWluOlsxLDAsMTAwLDFdLG1heDpbMTUsMCwxMDAsMV0sbGFiZWw6e2VuYWJsZWQ6ITAsbWluOlsxNCwwLDIwMCwxXSxtYXg6WzMwLDAsMjAwLDFdLG1heFZpc2libGU6WzMwLDAsMjAwLDFdLGRyYXdUaHJlc2hvbGQ6WzUsMCwyMCwxXX19LHNlbGVjdGlvbldpZHRoOlsxLjUsMCw1LC4xXSxzZWxmUmVmZXJlbmNlU2l6ZTpbMjAsMCwyMDAsMV0sc2VsZlJlZmVyZW5jZTp7c2l6ZTpbMjAsMCwyMDAsMV0sYW5nbGU6W01hdGguUEkvMiwtNipNYXRoLlBJLDYqTWF0aC5QSSxNYXRoLlBJLzhdLHJlbmRlckJlaGluZFRoZU5vZGU6ITB9LHNoYWRvdzp7ZW5hYmxlZDohMSxjb2xvcjpcInJnYmEoMCwwLDAsMC41KVwiLHNpemU6WzEwLDAsMjAsMV0seDpbNSwtMzAsMzAsMV0seTpbNSwtMzAsMzAsMV19LHNtb290aDp7ZW5hYmxlZDohMCx0eXBlOltcImR5bmFtaWNcIixcImNvbnRpbnVvdXNcIixcImRpc2NyZXRlXCIsXCJkaWFnb25hbENyb3NzXCIsXCJzdHJhaWdodENyb3NzXCIsXCJob3Jpem9udGFsXCIsXCJ2ZXJ0aWNhbFwiLFwiY3VydmVkQ1dcIixcImN1cnZlZENDV1wiLFwiY3ViaWNCZXppZXJcIl0sZm9yY2VEaXJlY3Rpb246W1wiaG9yaXpvbnRhbFwiLFwidmVydGljYWxcIixcIm5vbmVcIl0scm91bmRuZXNzOlsuNSwwLDEsLjA1XX0sd2lkdGg6WzEsMCwzMCwxXX0sbGF5b3V0OntoaWVyYXJjaGljYWw6e2VuYWJsZWQ6ITEsbGV2ZWxTZXBhcmF0aW9uOlsxNTAsMjAsNTAwLDVdLG5vZGVTcGFjaW5nOlsxMDAsMjAsNTAwLDVdLHRyZWVTcGFjaW5nOlsyMDAsMjAsNTAwLDVdLGJsb2NrU2hpZnRpbmc6ITAsZWRnZU1pbmltaXphdGlvbjohMCxwYXJlbnRDZW50cmFsaXphdGlvbjohMCxkaXJlY3Rpb246W1wiVURcIixcIkRVXCIsXCJMUlwiLFwiUkxcIl0sc29ydE1ldGhvZDpbXCJodWJzaXplXCIsXCJkaXJlY3RlZFwiXSxzaGFrZVRvd2FyZHM6W1wibGVhdmVzXCIsXCJyb290c1wiXX19LGludGVyYWN0aW9uOntkcmFnTm9kZXM6ITAsZHJhZ1ZpZXc6ITAsaGlkZUVkZ2VzT25EcmFnOiExLGhpZGVFZGdlc09uWm9vbTohMSxoaWRlTm9kZXNPbkRyYWc6ITEsaG92ZXI6ITEsa2V5Ym9hcmQ6e2VuYWJsZWQ6ITEsc3BlZWQ6e3g6WzEwLDAsNDAsMV0seTpbMTAsMCw0MCwxXSx6b29tOlsuMDIsMCwuMSwuMDA1XX0sYmluZFRvV2luZG93OiEwfSxtdWx0aXNlbGVjdDohMSxuYXZpZ2F0aW9uQnV0dG9uczohMSxzZWxlY3RhYmxlOiEwLHNlbGVjdENvbm5lY3RlZEVkZ2VzOiEwLGhvdmVyQ29ubmVjdGVkRWRnZXM6ITAsdG9vbHRpcERlbGF5OlszMDAsMCwxZTMsMjVdLHpvb21WaWV3OiEwLHpvb21TcGVlZDpbMSwuMSwyLC4xXX0sbWFuaXB1bGF0aW9uOntlbmFibGVkOiExLGluaXRpYWxseUFjdGl2ZTohMX0scGh5c2ljczp7ZW5hYmxlZDohMCxiYXJuZXNIdXQ6e3RoZXRhOlsuNSwuMSwxLC4wNV0sZ3Jhdml0YXRpb25hbENvbnN0YW50OlstMmUzLC0zZTQsMCw1MF0sY2VudHJhbEdyYXZpdHk6Wy4zLDAsMTAsLjA1XSxzcHJpbmdMZW5ndGg6Wzk1LDAsNTAwLDVdLHNwcmluZ0NvbnN0YW50OlsuMDQsMCwxLjIsLjAwNV0sZGFtcGluZzpbLjA5LDAsMSwuMDFdLGF2b2lkT3ZlcmxhcDpbMCwwLDEsLjAxXX0sZm9yY2VBdGxhczJCYXNlZDp7dGhldGE6Wy41LC4xLDEsLjA1XSxncmF2aXRhdGlvbmFsQ29uc3RhbnQ6Wy01MCwtNTAwLDAsMV0sY2VudHJhbEdyYXZpdHk6Wy4wMSwwLDEsLjAwNV0sc3ByaW5nTGVuZ3RoOls5NSwwLDUwMCw1XSxzcHJpbmdDb25zdGFudDpbLjA4LDAsMS4yLC4wMDVdLGRhbXBpbmc6Wy40LDAsMSwuMDFdLGF2b2lkT3ZlcmxhcDpbMCwwLDEsLjAxXX0scmVwdWxzaW9uOntjZW50cmFsR3Jhdml0eTpbLjIsMCwxMCwuMDVdLHNwcmluZ0xlbmd0aDpbMjAwLDAsNTAwLDVdLHNwcmluZ0NvbnN0YW50OlsuMDUsMCwxLjIsLjAwNV0sbm9kZURpc3RhbmNlOlsxMDAsMCw1MDAsNV0sZGFtcGluZzpbLjA5LDAsMSwuMDFdfSxoaWVyYXJjaGljYWxSZXB1bHNpb246e2NlbnRyYWxHcmF2aXR5OlsuMiwwLDEwLC4wNV0sc3ByaW5nTGVuZ3RoOlsxMDAsMCw1MDAsNV0sc3ByaW5nQ29uc3RhbnQ6Wy4wMSwwLDEuMiwuMDA1XSxub2RlRGlzdGFuY2U6WzEyMCwwLDUwMCw1XSxkYW1waW5nOlsuMDksMCwxLC4wMV0sYXZvaWRPdmVybGFwOlswLDAsMSwuMDFdfSxtYXhWZWxvY2l0eTpbNTAsMCwxNTAsMV0sbWluVmVsb2NpdHk6Wy4xLC4wMSwuNSwuMDFdLHNvbHZlcjpbXCJiYXJuZXNIdXRcIixcImZvcmNlQXRsYXMyQmFzZWRcIixcInJlcHVsc2lvblwiLFwiaGllcmFyY2hpY2FsUmVwdWxzaW9uXCJdLHRpbWVzdGVwOlsuNSwuMDEsMSwuMDFdLHdpbmQ6e3g6WzAsLTEwLDEwLC4xXSx5OlswLC0xMCwxMCwuMV19fX0sdHA9ZnVuY3Rpb24odCxlLGkpe3ZhciBvO3JldHVybiEoIUpuKHQpLmNhbGwodCxcInBoeXNpY3NcIil8fCFKbihvPUpmLnBoeXNpY3Muc29sdmVyKS5jYWxsKG8sZSl8fGkucGh5c2ljcy5zb2x2ZXI9PT1lfHxcIndpbmRcIj09PWUpfSxlcD1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxjb25maWd1cmF0b3JIaWRlT3B0aW9uOnRwLGFsbE9wdGlvbnM6WmYsY29uZmlndXJlT3B0aW9uczpKZn0pLGlwPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe1BvKHRoaXMsdCl9cmV0dXJuIElvKHQsW3trZXk6XCJnZXREaXN0YW5jZXNcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7Zm9yKHZhciBvPXt9LG49dC5lZGdlcyxyPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBzPXt9O29bZVtyXV09cztmb3IodmFyIGE9MDthPGUubGVuZ3RoO2ErKylzW2VbYV1dPXI9PWE/MDoxZTl9Zm9yKHZhciBoPTA7aDxpLmxlbmd0aDtoKyspe3ZhciBkPW5baVtoXV07ITA9PT1kLmNvbm5lY3RlZCYmdm9pZCAwIT09b1tkLmZyb21JZF0mJnZvaWQgMCE9PW9bZC50b0lkXSYmKG9bZC5mcm9tSWRdW2QudG9JZF09MSxvW2QudG9JZF1bZC5mcm9tSWRdPTEpfWZvcih2YXIgbD1lLmxlbmd0aCxjPTA7YzxsO2MrKylmb3IodmFyIHU9ZVtjXSxmPW9bdV0scD0wO3A8bC0xO3ArKylmb3IodmFyIHY9ZVtwXSxnPW9bdl0seT1wKzE7eTxsO3krKyl7dmFyIG09ZVt5XSxiPW9bbV0sdz1NYXRoLm1pbihnW21dLGdbdV0rZlttXSk7Z1ttXT13LGJbdl09d31yZXR1cm4gb319XSksdH0oKSxvcD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG8pe1BvKHRoaXMsdCksdGhpcy5ib2R5PWUsdGhpcy5zcHJpbmdMZW5ndGg9aSx0aGlzLnNwcmluZ0NvbnN0YW50PW8sdGhpcy5kaXN0YW5jZVNvbHZlcj1uZXcgaXB9cmV0dXJuIElvKHQsW3trZXk6XCJzZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7dCYmKHQuc3ByaW5nTGVuZ3RoJiYodGhpcy5zcHJpbmdMZW5ndGg9dC5zcHJpbmdMZW5ndGgpLHQuc3ByaW5nQ29uc3RhbnQmJih0aGlzLnNwcmluZ0NvbnN0YW50PXQuc3ByaW5nQ29uc3RhbnQpKX19LHtrZXk6XCJzb2x2ZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXSxvPXRoaXMuZGlzdGFuY2VTb2x2ZXIuZ2V0RGlzdGFuY2VzKHRoaXMuYm9keSx0LGUpO3RoaXMuX2NyZWF0ZUxfbWF0cml4KG8pLHRoaXMuX2NyZWF0ZUtfbWF0cml4KG8pLHRoaXMuX2NyZWF0ZUVfbWF0cml4KCk7Zm9yKHZhciBuPS4wMSxyPTEscz0wLGE9TWF0aC5tYXgoMWUzLE1hdGgubWluKDEwKnRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGgsNmUzKSksaD01LGQ9MWU5LGw9MCxjPTAsdT0wLGY9MCxwPTA7ZD5uJiZzPGE7KXtzKz0xO3ZhciB2PXRoaXMuX2dldEhpZ2hlc3RFbmVyZ3lOb2RlKGkpLGc9YW4odiw0KTtmb3IobD1nWzBdLGQ9Z1sxXSxjPWdbMl0sdT1nWzNdLGY9ZCxwPTA7Zj5yJiZwPGg7KXtwKz0xLHRoaXMuX21vdmVOb2RlKGwsYyx1KTt2YXIgeT10aGlzLl9nZXRFbmVyZ3kobCksbT1hbih5LDMpO2Y9bVswXSxjPW1bMV0sdT1tWzJdfX19fSx7a2V5OlwiX2dldEhpZ2hlc3RFbmVyZ3lOb2RlXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuYm9keS5ub2RlSW5kaWNlcyxpPXRoaXMuYm9keS5ub2RlcyxvPTAsbj1lWzBdLHI9MCxzPTAsYT0wO2E8ZS5sZW5ndGg7YSsrKXt2YXIgaD1lW2FdO2lmKCEwIT09aVtoXS5wcmVkZWZpbmVkUG9zaXRpb258fCEwPT09aVtoXS5pc0NsdXN0ZXImJiEwPT09dHx8ITAhPT1pW2hdLm9wdGlvbnMuZml4ZWQueHx8ITAhPT1pW2hdLm9wdGlvbnMuZml4ZWQueSl7dmFyIGQ9YW4odGhpcy5fZ2V0RW5lcmd5KGgpLDMpLGw9ZFswXSxjPWRbMV0sdT1kWzJdO288bCYmKG89bCxuPWgscj1jLHM9dSl9fXJldHVybltuLG8scixzXX19LHtrZXk6XCJfZ2V0RW5lcmd5XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YW4odGhpcy5FX3N1bXNbdF0sMiksaT1lWzBdLG89ZVsxXTtyZXR1cm5bTWF0aC5zcXJ0KE1hdGgucG93KGksMikrTWF0aC5wb3cobywyKSksaSxvXX19LHtrZXk6XCJfbW92ZU5vZGVcIix2YWx1ZTpmdW5jdGlvbih0LGUsaSl7Zm9yKHZhciBvPXRoaXMuYm9keS5ub2RlSW5kaWNlcyxuPXRoaXMuYm9keS5ub2RlcyxyPTAscz0wLGE9MCxoPW5bdF0ueCxkPW5bdF0ueSxsPXRoaXMuS19tYXRyaXhbdF0sYz10aGlzLkxfbWF0cml4W3RdLHU9MDt1PG8ubGVuZ3RoO3UrKyl7dmFyIGY9b1t1XTtpZihmIT09dCl7dmFyIHA9bltmXS54LHY9bltmXS55LGc9bFtmXSx5PWNbZl0sbT0xL01hdGgucG93KE1hdGgucG93KGgtcCwyKStNYXRoLnBvdyhkLXYsMiksMS41KTtyKz1nKigxLXkqTWF0aC5wb3coZC12LDIpKm0pLHMrPWcqKHkqKGgtcCkqKGQtdikqbSksYSs9ZyooMS15Kk1hdGgucG93KGgtcCwyKSptKX19dmFyIGI9KGUvcitpL3MpLyhzL3ItYS9zKSx3PS0ocypiK2UpL3I7blt0XS54Kz13LG5bdF0ueSs9Yix0aGlzLl91cGRhdGVFX21hdHJpeCh0KX19LHtrZXk6XCJfY3JlYXRlTF9tYXRyaXhcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmJvZHkubm9kZUluZGljZXMsaT10aGlzLnNwcmluZ0xlbmd0aDt0aGlzLkxfbWF0cml4PVtdO2Zvcih2YXIgbz0wO288ZS5sZW5ndGg7bysrKXt0aGlzLkxfbWF0cml4W2Vbb11dPXt9O2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXRoaXMuTF9tYXRyaXhbZVtvXV1bZVtuXV09aSp0W2Vbb11dW2Vbbl1dfX19LHtrZXk6XCJfY3JlYXRlS19tYXRyaXhcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmJvZHkubm9kZUluZGljZXMsaT10aGlzLnNwcmluZ0NvbnN0YW50O3RoaXMuS19tYXRyaXg9W107Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDtvKyspe3RoaXMuS19tYXRyaXhbZVtvXV09e307Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspdGhpcy5LX21hdHJpeFtlW29dXVtlW25dXT1pKk1hdGgucG93KHRbZVtvXV1bZVtuXV0sLTIpfX19LHtrZXk6XCJfY3JlYXRlRV9tYXRyaXhcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuYm9keS5ub2RlSW5kaWNlcyxlPXRoaXMuYm9keS5ub2Rlczt0aGlzLkVfbWF0cml4PXt9LHRoaXMuRV9zdW1zPXt9O2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKXRoaXMuRV9tYXRyaXhbdFtpXV09W107Zm9yKHZhciBvPTA7bzx0Lmxlbmd0aDtvKyspe2Zvcih2YXIgbj10W29dLHI9ZVtuXS54LHM9ZVtuXS55LGE9MCxoPTAsZD1vO2Q8dC5sZW5ndGg7ZCsrKXt2YXIgbD10W2RdO2lmKGwhPT1uKXt2YXIgYz1lW2xdLngsdT1lW2xdLnksZj0xL01hdGguc3FydChNYXRoLnBvdyhyLWMsMikrTWF0aC5wb3cocy11LDIpKTt0aGlzLkVfbWF0cml4W25dW2RdPVt0aGlzLktfbWF0cml4W25dW2xdKihyLWMtdGhpcy5MX21hdHJpeFtuXVtsXSooci1jKSpmKSx0aGlzLktfbWF0cml4W25dW2xdKihzLXUtdGhpcy5MX21hdHJpeFtuXVtsXSoocy11KSpmKV0sdGhpcy5FX21hdHJpeFtsXVtvXT10aGlzLkVfbWF0cml4W25dW2RdLGErPXRoaXMuRV9tYXRyaXhbbl1bZF1bMF0saCs9dGhpcy5FX21hdHJpeFtuXVtkXVsxXX19dGhpcy5FX3N1bXNbbl09W2EsaF19fX0se2tleTpcIl91cGRhdGVFX21hdHJpeFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmJvZHkubm9kZUluZGljZXMsaT10aGlzLmJvZHkubm9kZXMsbz10aGlzLkVfbWF0cml4W3RdLG49dGhpcy5LX21hdHJpeFt0XSxyPXRoaXMuTF9tYXRyaXhbdF0scz1pW3RdLngsYT1pW3RdLnksaD0wLGQ9MCxsPTA7bDxlLmxlbmd0aDtsKyspe3ZhciBjPWVbbF07aWYoYyE9PXQpe3ZhciB1PW9bbF0sZj11WzBdLHA9dVsxXSx2PWlbY10ueCxnPWlbY10ueSx5PTEvTWF0aC5zcXJ0KE1hdGgucG93KHMtdiwyKStNYXRoLnBvdyhhLWcsMikpLG09bltjXSoocy12LXJbY10qKHMtdikqeSksYj1uW2NdKihhLWctcltjXSooYS1nKSp5KTtvW2xdPVttLGJdLGgrPW0sZCs9Yjt2YXIgdz10aGlzLkVfc3Vtc1tjXTt3WzBdKz1tLWYsd1sxXSs9Yi1wfX10aGlzLkVfc3Vtc1t0XT1baCxkXX19XSksdH0oKTtmdW5jdGlvbiBucCh0LGUsaSl7dmFyIG8sbixyLHMsYT10aGlzO2lmKCEodGhpcyBpbnN0YW5jZW9mIG5wKSl0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3JcIik7dGhpcy5vcHRpb25zPXt9LHRoaXMuZGVmYXVsdE9wdGlvbnM9e2xvY2FsZTpcImVuXCIsbG9jYWxlczp1ZCxjbGlja1RvVXNlOiExfSxjdCh0aGlzLm9wdGlvbnMsdGhpcy5kZWZhdWx0T3B0aW9ucyksdGhpcy5ib2R5PXtjb250YWluZXI6dCxub2Rlczp7fSxub2RlSW5kaWNlczpbXSxlZGdlczp7fSxlZGdlSW5kaWNlczpbXSxlbWl0dGVyOntvbjpidChvPXRoaXMub24pLmNhbGwobyx0aGlzKSxvZmY6YnQobj10aGlzLm9mZikuY2FsbChuLHRoaXMpLGVtaXQ6YnQocj10aGlzLmVtaXQpLmNhbGwocix0aGlzKSxvbmNlOmJ0KHM9dGhpcy5vbmNlKS5jYWxsKHMsdGhpcyl9LGV2ZW50TGlzdGVuZXJzOntvblRhcDpmdW5jdGlvbigpe30sb25Ub3VjaDpmdW5jdGlvbigpe30sb25Eb3VibGVUYXA6ZnVuY3Rpb24oKXt9LG9uSG9sZDpmdW5jdGlvbigpe30sb25EcmFnU3RhcnQ6ZnVuY3Rpb24oKXt9LG9uRHJhZzpmdW5jdGlvbigpe30sb25EcmFnRW5kOmZ1bmN0aW9uKCl7fSxvbk1vdXNlV2hlZWw6ZnVuY3Rpb24oKXt9LG9uUGluY2g6ZnVuY3Rpb24oKXt9LG9uTW91c2VNb3ZlOmZ1bmN0aW9uKCl7fSxvblJlbGVhc2U6ZnVuY3Rpb24oKXt9LG9uQ29udGV4dDpmdW5jdGlvbigpe319LGRhdGE6e25vZGVzOm51bGwsZWRnZXM6bnVsbH0sZnVuY3Rpb25zOntjcmVhdGVOb2RlOmZ1bmN0aW9uKCl7fSxjcmVhdGVFZGdlOmZ1bmN0aW9uKCl7fSxnZXRQb2ludGVyOmZ1bmN0aW9uKCl7fX0sbW9kdWxlczp7fSx2aWV3OntzY2FsZToxLHRyYW5zbGF0aW9uOnt4OjAseTowfX0sc2VsZWN0aW9uQm94OntzaG93OiExLHBvc2l0aW9uOntzdGFydDp7eDowLHk6MH0sZW5kOnt4OjAseTowfX19fSx0aGlzLmJpbmRFdmVudExpc3RlbmVycygpLHRoaXMuaW1hZ2VzPW5ldyBwZCgoZnVuY3Rpb24oKXtyZXR1cm4gYS5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpfSkpLHRoaXMuZ3JvdXBzPW5ldyBJZCx0aGlzLmNhbnZhcz1uZXcgUHUodGhpcy5ib2R5KSx0aGlzLnNlbGVjdGlvbkhhbmRsZXI9bmV3IGNmKHRoaXMuYm9keSx0aGlzLmNhbnZhcyksdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXI9bmV3IEF1KHRoaXMuYm9keSx0aGlzLmNhbnZhcyx0aGlzLnNlbGVjdGlvbkhhbmRsZXIpLHRoaXMudmlldz1uZXcgQnUodGhpcy5ib2R5LHRoaXMuY2FudmFzKSx0aGlzLnJlbmRlcmVyPW5ldyBDdSh0aGlzLmJvZHksdGhpcy5jYW52YXMpLHRoaXMucGh5c2ljcz1uZXcgdXUodGhpcy5ib2R5KSx0aGlzLmxheW91dEVuZ2luZT1uZXcgSGYodGhpcy5ib2R5KSx0aGlzLmNsdXN0ZXJpbmc9bmV3IHh1KHRoaXMuYm9keSksdGhpcy5tYW5pcHVsYXRpb249bmV3IHFmKHRoaXMuYm9keSx0aGlzLmNhbnZhcyx0aGlzLnNlbGVjdGlvbkhhbmRsZXIsdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIpLHRoaXMubm9kZXNIYW5kbGVyPW5ldyBmYyh0aGlzLmJvZHksdGhpcy5pbWFnZXMsdGhpcy5ncm91cHMsdGhpcy5sYXlvdXRFbmdpbmUpLHRoaXMuZWRnZXNIYW5kbGVyPW5ldyB0dSh0aGlzLmJvZHksdGhpcy5pbWFnZXMsdGhpcy5ncm91cHMpLHRoaXMuYm9keS5tb2R1bGVzLmthbWFkYUthd2FpPW5ldyBvcCh0aGlzLmJvZHksMTUwLC4wNSksdGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZz10aGlzLmNsdXN0ZXJpbmcsdGhpcy5jYW52YXMuX2NyZWF0ZSgpLHRoaXMuc2V0T3B0aW9ucyhpKSx0aGlzLnNldERhdGEoZSl9Q3QobnAucHJvdG90eXBlKSxucC5wcm90b3R5cGUuc2V0T3B0aW9ucz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKG51bGw9PT10JiYodD12b2lkIDApLHZvaWQgMCE9PXQpeyEwPT09UGgudmFsaWRhdGUodCxaZikmJmNvbnNvbGUuZXJyb3IoXCIlY0Vycm9ycyBoYXZlIGJlZW4gZm91bmQgaW4gdGhlIHN1cHBsaWVkIG9wdGlvbnMgb2JqZWN0LlwiLE1oKTtpZihaYShbXCJsb2NhbGVcIixcImxvY2FsZXNcIixcImNsaWNrVG9Vc2VcIl0sdGhpcy5vcHRpb25zLHQpLHZvaWQgMCE9PXQubG9jYWxlJiYodC5sb2NhbGU9ZnVuY3Rpb24odCxlKXt0cnl7dmFyIGk9YW4oZS5zcGxpdCgvWy1fIC9dLywyKSwyKSxvPWlbMF0sbj1pWzFdLHI9bnVsbCE9bz9vLnRvTG93ZXJDYXNlKCk6bnVsbCxzPW51bGwhPW4/bi50b1VwcGVyQ2FzZSgpOm51bGw7aWYociYmcyl7dmFyIGEsaD1yK1wiLVwiK3M7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsaCkpcmV0dXJuIGg7Y29uc29sZS53YXJuKHBuKGE9XCJVbmtub3duIHZhcmlhbnQgXCIuY29uY2F0KHMsXCIgb2YgbGFuZ3VhZ2UgXCIpKS5jYWxsKGEscixcIi5cIikpfWlmKHIpe3ZhciBkPXI7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZCkpcmV0dXJuIGQ7Y29uc29sZS53YXJuKFwiVW5rbm93biBsYW5ndWFnZSBcIi5jb25jYXQocikpfXJldHVybiBjb25zb2xlLndhcm4oXCJVbmtub3duIGxvY2FsZSBcIi5jb25jYXQoZSxcIiwgZmFsbGluZyBiYWNrIHRvIEVuZ2xpc2guXCIpKSxcImVuXCJ9Y2F0Y2godCl7cmV0dXJuIGNvbnNvbGUuZXJyb3IodCksY29uc29sZS53YXJuKFwiVW5leHBlY3RlZCBlcnJvciB3aGlsZSBub3JtYWxpemluZyBsb2NhbGUgXCIuY29uY2F0KGUsXCIsIGZhbGxpbmcgYmFjayB0byBFbmdsaXNoLlwiKSksXCJlblwifX0odC5sb2NhbGVzfHx0aGlzLm9wdGlvbnMubG9jYWxlcyx0LmxvY2FsZSkpLHQ9dGhpcy5sYXlvdXRFbmdpbmUuc2V0T3B0aW9ucyh0LmxheW91dCx0KSx0aGlzLmNhbnZhcy5zZXRPcHRpb25zKHQpLHRoaXMuZ3JvdXBzLnNldE9wdGlvbnModC5ncm91cHMpLHRoaXMubm9kZXNIYW5kbGVyLnNldE9wdGlvbnModC5ub2RlcyksdGhpcy5lZGdlc0hhbmRsZXIuc2V0T3B0aW9ucyh0LmVkZ2VzKSx0aGlzLnBoeXNpY3Muc2V0T3B0aW9ucyh0LnBoeXNpY3MpLHRoaXMubWFuaXB1bGF0aW9uLnNldE9wdGlvbnModC5tYW5pcHVsYXRpb24sdCx0aGlzLm9wdGlvbnMpLHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLnNldE9wdGlvbnModC5pbnRlcmFjdGlvbiksdGhpcy5yZW5kZXJlci5zZXRPcHRpb25zKHQuaW50ZXJhY3Rpb24pLHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZXRPcHRpb25zKHQuaW50ZXJhY3Rpb24pLHZvaWQgMCE9PXQuZ3JvdXBzJiZ0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVmcmVzaE5vZGVzXCIpLFwiY29uZmlndXJlXCJpbiB0JiYodGhpcy5jb25maWd1cmF0b3J8fCh0aGlzLmNvbmZpZ3VyYXRvcj1uZXcgQ2godGhpcyx0aGlzLmJvZHkuY29udGFpbmVyLEpmLHRoaXMuY2FudmFzLnBpeGVsUmF0aW8sdHApKSx0aGlzLmNvbmZpZ3VyYXRvci5zZXRPcHRpb25zKHQuY29uZmlndXJlKSksdGhpcy5jb25maWd1cmF0b3ImJiEwPT09dGhpcy5jb25maWd1cmF0b3Iub3B0aW9ucy5lbmFibGVkKXt2YXIgaT17bm9kZXM6e30sZWRnZXM6e30sbGF5b3V0Ont9LGludGVyYWN0aW9uOnt9LG1hbmlwdWxhdGlvbjp7fSxwaHlzaWNzOnt9LGdsb2JhbDp7fX07dGgoaS5ub2Rlcyx0aGlzLm5vZGVzSGFuZGxlci5vcHRpb25zKSx0aChpLmVkZ2VzLHRoaXMuZWRnZXNIYW5kbGVyLm9wdGlvbnMpLHRoKGkubGF5b3V0LHRoaXMubGF5b3V0RW5naW5lLm9wdGlvbnMpLHRoKGkuaW50ZXJhY3Rpb24sdGhpcy5zZWxlY3Rpb25IYW5kbGVyLm9wdGlvbnMpLHRoKGkuaW50ZXJhY3Rpb24sdGhpcy5yZW5kZXJlci5vcHRpb25zKSx0aChpLmludGVyYWN0aW9uLHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLm9wdGlvbnMpLHRoKGkubWFuaXB1bGF0aW9uLHRoaXMubWFuaXB1bGF0aW9uLm9wdGlvbnMpLHRoKGkucGh5c2ljcyx0aGlzLnBoeXNpY3Mub3B0aW9ucyksdGgoaS5nbG9iYWwsdGhpcy5jYW52YXMub3B0aW9ucyksdGgoaS5nbG9iYWwsdGhpcy5vcHRpb25zKSx0aGlzLmNvbmZpZ3VyYXRvci5zZXRNb2R1bGVPcHRpb25zKGkpfXZvaWQgMCE9PXQuY2xpY2tUb1VzZT8hMD09PXQuY2xpY2tUb1VzZT92b2lkIDA9PT10aGlzLmFjdGl2YXRvciYmKHRoaXMuYWN0aXZhdG9yPW5ldyBPaCh0aGlzLmNhbnZhcy5mcmFtZSksdGhpcy5hY3RpdmF0b3Iub24oXCJjaGFuZ2VcIiwoZnVuY3Rpb24oKXtlLmJvZHkuZW1pdHRlci5lbWl0KFwiYWN0aXZhdGVcIil9KSkpOih2b2lkIDAhPT10aGlzLmFjdGl2YXRvciYmKHRoaXMuYWN0aXZhdG9yLmRlc3Ryb3koKSxkZWxldGUgdGhpcy5hY3RpdmF0b3IpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJhY3RpdmF0ZVwiKSk6dGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImFjdGl2YXRlXCIpLHRoaXMuY2FudmFzLnNldFNpemUoKSx0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpfX0sbnAucHJvdG90eXBlLl91cGRhdGVWaXNpYmxlSW5kaWNlcz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuYm9keS5ub2RlcyxlPXRoaXMuYm9keS5lZGdlcztmb3IodmFyIGkgaW4gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzPVtdLHRoaXMuYm9keS5lZGdlSW5kaWNlcz1bXSx0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGkpJiYodGhpcy5jbHVzdGVyaW5nLl9pc0NsdXN0ZXJlZE5vZGUoaSl8fCExIT09dFtpXS5vcHRpb25zLmhpZGRlbnx8dGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2godFtpXS5pZCkpO2Zvcih2YXIgbyBpbiBlKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG8pKXt2YXIgbj1lW29dLHI9dFtuLmZyb21JZF0scz10W24udG9JZF0sYT12b2lkIDAhPT1yJiZ2b2lkIDAhPT1zOyF0aGlzLmNsdXN0ZXJpbmcuX2lzQ2x1c3RlcmVkRWRnZShvKSYmITE9PT1uLm9wdGlvbnMuaGlkZGVuJiZhJiYhMT09PXIub3B0aW9ucy5oaWRkZW4mJiExPT09cy5vcHRpb25zLmhpZGRlbiYmdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLnB1c2gobi5pZCl9fSxucC5wcm90b3R5cGUuYmluZEV2ZW50TGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhQ2hhbmdlZFwiLChmdW5jdGlvbigpe3QuZWRnZXNIYW5kbGVyLl91cGRhdGVTdGF0ZSgpLHQuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YVVwZGF0ZWRcIil9KSksdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YVVwZGF0ZWRcIiwoZnVuY3Rpb24oKXt0LmNsdXN0ZXJpbmcuX3VwZGF0ZVN0YXRlKCksdC5fdXBkYXRlVmlzaWJsZUluZGljZXMoKSx0Ll91cGRhdGVWYWx1ZVJhbmdlKHQuYm9keS5ub2RlcyksdC5fdXBkYXRlVmFsdWVSYW5nZSh0LmJvZHkuZWRnZXMpLHQuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIiksdC5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpfSkpfSxucC5wcm90b3R5cGUuc2V0RGF0YT1mdW5jdGlvbih0KXtpZih0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVzZXRQaHlzaWNzXCIpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzZXREYXRhXCIpLHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpLHQmJnQuZG90JiYodC5ub2Rlc3x8dC5lZGdlcykpdGhyb3cgbmV3IFN5bnRheEVycm9yKCdEYXRhIG11c3QgY29udGFpbiBlaXRoZXIgcGFyYW1ldGVyIFwiZG90XCIgb3IgIHBhcmFtZXRlciBwYWlyIFwibm9kZXNcIiBhbmQgXCJlZGdlc1wiLCBidXQgbm90IGJvdGguJyk7aWYodGhpcy5zZXRPcHRpb25zKHQmJnQub3B0aW9ucyksdCYmdC5kb3Qpe2NvbnNvbGUud2FybihcIlRoZSBkb3QgcHJvcGVydHkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgc3RhdGljIGNvbnZlcnREb3QgbWV0aG9kIHRvIGNvbnZlcnQgRE9UIGludG8gdmlzLm5ldHdvcmsgZm9ybWF0IGFuZCB1c2UgdGhlIG5vcm1hbCBkYXRhIGZvcm1hdCB3aXRoIG5vZGVzIGFuZCBlZGdlcy4gVGhpcyBjb252ZXJ0ZXIgaXMgdXNlZCBsaWtlIHRoaXM6IHZhciBkYXRhID0gdmlzLm5ldHdvcmsuY29udmVydERvdChkb3RTdHJpbmcpO1wiKTt2YXIgZT1oZCh0LmRvdCk7dGhpcy5zZXREYXRhKGUpfWVsc2UgaWYodCYmdC5nZXBoaSl7Y29uc29sZS53YXJuKFwiVGhlIGdlcGhpIHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIHN0YXRpYyBjb252ZXJ0R2VwaGkgbWV0aG9kIHRvIGNvbnZlcnQgZ2VwaGkgaW50byB2aXMubmV0d29yayBmb3JtYXQgYW5kIHVzZSB0aGUgbm9ybWFsIGRhdGEgZm9ybWF0IHdpdGggbm9kZXMgYW5kIGVkZ2VzLiBUaGlzIGNvbnZlcnRlciBpcyB1c2VkIGxpa2UgdGhpczogdmFyIGRhdGEgPSB2aXMubmV0d29yay5jb252ZXJ0R2VwaGkoZ2VwaGlKc29uKTtcIik7dmFyIGk9bGQodC5nZXBoaSk7dGhpcy5zZXREYXRhKGkpfWVsc2UgdGhpcy5ub2Rlc0hhbmRsZXIuc2V0RGF0YSh0JiZ0Lm5vZGVzLCEwKSx0aGlzLmVkZ2VzSGFuZGxlci5zZXREYXRhKHQmJnQuZWRnZXMsITApLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIiksdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhTG9hZGVkXCIpLHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJpbml0UGh5c2ljc1wiKX0sbnAucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImRlc3Ryb3lcIiksdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCksdGhpcy5vZmYoKSxkZWxldGUgdGhpcy5ncm91cHMsZGVsZXRlIHRoaXMuY2FudmFzLGRlbGV0ZSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIsZGVsZXRlIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLGRlbGV0ZSB0aGlzLnZpZXcsZGVsZXRlIHRoaXMucmVuZGVyZXIsZGVsZXRlIHRoaXMucGh5c2ljcyxkZWxldGUgdGhpcy5sYXlvdXRFbmdpbmUsZGVsZXRlIHRoaXMuY2x1c3RlcmluZyxkZWxldGUgdGhpcy5tYW5pcHVsYXRpb24sZGVsZXRlIHRoaXMubm9kZXNIYW5kbGVyLGRlbGV0ZSB0aGlzLmVkZ2VzSGFuZGxlcixkZWxldGUgdGhpcy5jb25maWd1cmF0b3IsZGVsZXRlIHRoaXMuaW1hZ2VzLHRoaXMuYm9keS5ub2RlcylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLHQpJiZkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW3RdO2Zvcih2YXIgZSBpbiB0aGlzLmJvZHkuZWRnZXMpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5lZGdlcyxlKSYmZGVsZXRlIHRoaXMuYm9keS5lZGdlc1tlXTtYYSh0aGlzLmJvZHkuY29udGFpbmVyKX0sbnAucHJvdG90eXBlLl91cGRhdGVWYWx1ZVJhbmdlPWZ1bmN0aW9uKHQpe3ZhciBlLGk9dm9pZCAwLG89dm9pZCAwLG49MDtmb3IoZSBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpKXt2YXIgcj10W2VdLmdldFZhbHVlKCk7dm9pZCAwIT09ciYmKGk9dm9pZCAwPT09aT9yOk1hdGgubWluKHIsaSksbz12b2lkIDA9PT1vP3I6TWF0aC5tYXgocixvKSxuKz1yKX1pZih2b2lkIDAhPT1pJiZ2b2lkIDAhPT1vKWZvcihlIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSkmJnRbZV0uc2V0VmFsdWVSYW5nZShpLG8sbil9LG5wLnByb3RvdHlwZS5pc0FjdGl2ZT1mdW5jdGlvbigpe3JldHVybiF0aGlzLmFjdGl2YXRvcnx8dGhpcy5hY3RpdmF0b3IuYWN0aXZlfSxucC5wcm90b3R5cGUuc2V0U2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNhbnZhcy5zZXRTaXplLmFwcGx5KHRoaXMuY2FudmFzLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5jYW52YXNUb0RPTT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNhbnZhcy5jYW52YXNUb0RPTS5hcHBseSh0aGlzLmNhbnZhcyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuRE9NdG9DYW52YXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMuYXBwbHkodGhpcy5jYW52YXMsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmZpbmROb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2x1c3RlcmluZy5maW5kTm9kZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmlzQ2x1c3Rlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNsdXN0ZXJpbmcuaXNDbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUub3BlbkNsdXN0ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbHVzdGVyaW5nLm9wZW5DbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuY2x1c3Rlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmdldE5vZGVzSW5DbHVzdGVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2x1c3RlcmluZy5nZXROb2Rlc0luQ2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmNsdXN0ZXJCeUNvbm5lY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmNsdXN0ZXJCeUNvbm5lY3Rpb24uYXBwbHkodGhpcy5jbHVzdGVyaW5nLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5jbHVzdGVyQnlIdWJzaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyQnlIdWJzaXplLmFwcGx5KHRoaXMuY2x1c3RlcmluZyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUudXBkYXRlQ2x1c3RlcmVkTm9kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNsdXN0ZXJpbmcudXBkYXRlQ2x1c3RlcmVkTm9kZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmdldENsdXN0ZXJlZEVkZ2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2x1c3RlcmluZy5nZXRDbHVzdGVyZWRFZGdlcy5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmdldEJhc2VFZGdlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2x1c3RlcmluZy5nZXRCYXNlRWRnZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmdldEJhc2VFZGdlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNsdXN0ZXJpbmcuZ2V0QmFzZUVkZ2VzLmFwcGx5KHRoaXMuY2x1c3RlcmluZyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUudXBkYXRlRWRnZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNsdXN0ZXJpbmcudXBkYXRlRWRnZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmNsdXN0ZXJPdXRsaWVycz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3Rlck91dGxpZXJzLmFwcGx5KHRoaXMuY2x1c3RlcmluZyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0U2VlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxheW91dEVuZ2luZS5nZXRTZWVkLmFwcGx5KHRoaXMubGF5b3V0RW5naW5lLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5lbmFibGVFZGl0TW9kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5lbmFibGVFZGl0TW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZGlzYWJsZUVkaXRNb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmRpc2FibGVFZGl0TW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuYWRkTm9kZU1vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uYWRkTm9kZU1vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmVkaXROb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVkaXROb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5lZGl0Tm9kZU1vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiRGVwcmVjYXRlZDogUGxlYXNlIHVzZSBlZGl0Tm9kZSBpbnN0ZWFkIG9mIGVkaXROb2RlTW9kZS5cIiksdGhpcy5tYW5pcHVsYXRpb24uZWRpdE5vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmFkZEVkZ2VNb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmFkZEVkZ2VNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5lZGl0RWRnZU1vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZWRpdEVkZ2VNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5kZWxldGVTZWxlY3RlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5kZWxldGVTZWxlY3RlZC5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0UG9zaXRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldFBvc2l0aW9ucy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlcixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0UG9zaXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0UG9zaXRpb24uYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLnN0b3JlUG9zaXRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLnN0b3JlUG9zaXRpb25zLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5tb3ZlTm9kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzSGFuZGxlci5tb3ZlTm9kZS5hcHBseSh0aGlzLm5vZGVzSGFuZGxlcixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3g9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0Qm91bmRpbmdCb3guYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmdldENvbm5lY3RlZE5vZGVzPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10aGlzLmJvZHkubm9kZXNbdF0/dGhpcy5ub2Rlc0hhbmRsZXIuZ2V0Q29ubmVjdGVkTm9kZXMuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsYXJndW1lbnRzKTp0aGlzLmVkZ2VzSGFuZGxlci5nZXRDb25uZWN0ZWROb2Rlcy5hcHBseSh0aGlzLmVkZ2VzSGFuZGxlcixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkRWRnZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0Q29ubmVjdGVkRWRnZXMuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLnN0YXJ0U2ltdWxhdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBoeXNpY3Muc3RhcnRTaW11bGF0aW9uLmFwcGx5KHRoaXMucGh5c2ljcyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuc3RvcFNpbXVsYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5waHlzaWNzLnN0b3BTaW11bGF0aW9uLmFwcGx5KHRoaXMucGh5c2ljcyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuc3RhYmlsaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGh5c2ljcy5zdGFiaWxpemUuYXBwbHkodGhpcy5waHlzaWNzLGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5nZXRTZWxlY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGlvbi5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLnNldFNlbGVjdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2V0U2VsZWN0aW9uLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlcixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0U2VsZWN0ZWROb2Rlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2RlSWRzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlcixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRFZGdlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlSWRzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlcixhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZ2V0Tm9kZUF0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdC5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsYXJndW1lbnRzKTtyZXR1cm4gdm9pZCAwIT09dCYmdm9pZCAwIT09dC5pZD90LmlkOnR9LG5wLnByb3RvdHlwZS5nZXRFZGdlQXQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0RWRnZUF0LmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlcixhcmd1bWVudHMpO3JldHVybiB2b2lkIDAhPT10JiZ2b2lkIDAhPT10LmlkP3QuaWQ6dH0sbnAucHJvdG90eXBlLnNlbGVjdE5vZGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3ROb2Rlcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLnNlbGVjdEVkZ2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RFZGdlcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLnVuc2VsZWN0QWxsPWZ1bmN0aW9uKCl7dGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlcixhcmd1bWVudHMpLHRoaXMuc2VsZWN0aW9uSGFuZGxlci5jb21taXRXaXRob3V0RW1pdHRpbmcuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyKSx0aGlzLnJlZHJhdygpfSxucC5wcm90b3R5cGUucmVkcmF3PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVuZGVyZXIucmVkcmF3LmFwcGx5KHRoaXMucmVuZGVyZXIsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmdldFNjYWxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlldy5nZXRTY2FsZS5hcHBseSh0aGlzLnZpZXcsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmdldFZpZXdQb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcuZ2V0Vmlld1Bvc2l0aW9uLmFwcGx5KHRoaXMudmlldyxhcmd1bWVudHMpfSxucC5wcm90b3R5cGUuZml0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlldy5maXQuYXBwbHkodGhpcy52aWV3LGFyZ3VtZW50cyl9LG5wLnByb3RvdHlwZS5tb3ZlVG89ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3Lm1vdmVUby5hcHBseSh0aGlzLnZpZXcsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmZvY3VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlldy5mb2N1cy5hcHBseSh0aGlzLnZpZXcsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLnJlbGVhc2VOb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlldy5yZWxlYXNlTm9kZS5hcHBseSh0aGlzLnZpZXcsYXJndW1lbnRzKX0sbnAucHJvdG90eXBlLmdldE9wdGlvbnNGcm9tQ29uZmlndXJhdG9yPWZ1bmN0aW9uKCl7dmFyIHQ9e307cmV0dXJuIHRoaXMuY29uZmlndXJhdG9yJiYodD10aGlzLmNvbmZpZ3VyYXRvci5nZXRPcHRpb25zLmFwcGx5KHRoaXMuY29uZmlndXJhdG9yKSksdH07dmFyIHJwPWhkO3QuTmV0d29yaz1ucCx0Lk5ldHdvcmtJbWFnZXM9cGQsdC5uZXR3b3JrRE9UUGFyc2VyPWRkLHQubmV0d29ya0dlcGhpUGFyc2VyPWNkLHQubmV0d29ya09wdGlvbnM9ZXAsdC5wYXJzZURPVE5ldHdvcms9cnAsdC5wYXJzZUdlcGhpTmV0d29yaz1sZCxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpcy1uZXR3b3JrLm1pbi5qcy5tYXBcbiIsInJlcXVpcmUoXCJsZWFmbGV0L2Rpc3QvbGVhZmxldC5jc3NcIik7XG5yZXF1aXJlKCdAaWNvbmlmeS9pY29uaWZ5Jyk7XG5yZXF1aXJlKCdsZWFmbGV0Jyk7XG5yZXF1aXJlKCcuL3BnX3BhcnNlcl9icm93c2VyaWZpZWQuanMnKTtcblxubGV0IHZpc0RhdGEgPSByZXF1aXJlKCd2aXMtZGF0YScpO1xubGV0IHZpc05ldHdvcmsgPSByZXF1aXJlKCd2aXMtbmV0d29yaycpO1xuXG5jb25zdCBkZWZhdWx0V2lkdGggPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEJsaXR6Ym9hcmQge1xuICBzdGF0aWMgZm9udExvYWRlZCA9IGZhbHNlO1xuICBzdGF0aWMgZGVmYXVsdENvbmZpZyA9IHtcbiAgICBkb3VibGVDbGlja1dhaXQ6IDIwMCxcbiAgICBub2RlOiB7XG4gICAgICBjYXB0aW9uOiBbJ2lkJ10sXG4gICAgICBkZWZhdWx0SWNvbjogdHJ1ZSxcbiAgICAgIHRodW1ibmFpbDogJ3RodW1ibmFpbCcsXG4gICAgICBzYXR1cmF0aW9uOiAnMTAwJScsXG4gICAgICBicmlnaHRuZXNzOiAnMzclJyxcbiAgICAgIGxpbWl0OiA1MDBcbiAgICB9LFxuICAgIGVkZ2U6IHtcbiAgICAgIGNhcHRpb246IFsnbGFiZWwnXSxcbiAgICAgIHNhdHVyYXRpb246ICcwJScsXG4gICAgICBicmlnaHRuZXNzOiAnNjIlJyxcbiAgICAgIGxpbWl0OiAxMDAwMCxcbiAgICAgIHdpZHRoOiBkZWZhdWx0V2lkdGhcbiAgICB9LFxuICAgIHpvb206IHsgXG4gICAgICBtYXg6IDMuMCxcbiAgICAgIG1pbjogMC4yNSxcbiAgICB9LFxuICAgIGxheW91dFNldHRpbmdzOiB7XG4gICAgICB0aW1lX2Zyb206ICdmcm9tJyxcbiAgICAgIHRpbWVfdG86ICd0bycsXG4gICAgICBsbmc6ICdsbmcnLFxuICAgICAgbGF0OiAnbGF0J1xuICAgIH0sXG4gICAgc3R5bGU6IFwiYm9yZGVyOiBzb2xpZCAxcHggc2lsdmVyOyBiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQod2hpdGUsIHNpbHZlcik7XCIsXG4gICAgZXh0cmFPcHRpb25zOiB7XG4gICAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgICBrZXlib2FyZDogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3RhdGljIHRvb2x0aXBNYXhXaWR0aCA9IDYwMDtcbiAgc3RhdGljIGljb25QcmVmaXhlcyA9IFsnZmEtc29saWQ6JywgJ2lvbjonLCAnYng6YngtJywgJ2dyaWRpY29uczonLCAnYWthci1pY29uczonXTtcbiAgc3RhdGljIGljb25TaXplQ29lZiA9IDEuNTtcbiAgc3RhdGljIG1pblNjYWxlT25NYXAgPSAwLjM7XG4gIHN0YXRpYyBtYXhTY2FsZU9uTWFwID0gMS4wO1xuICBzdGF0aWMgbWFwQ29udGFpbmVySWQgPSAnbWFwJztcbiAgc3RhdGljIGVkZ2VEZWxpbWl0ZXIgPSAnLSc7XG4gIHN0YXRpYyBub2RlVGVtcGxhdGUgPSB7XG4gICAgaWQ6IG51bGwsXG4gICAgbGFiZWxzOiBbXSxcbiAgICBwcm9wZXJ0aWVzOiB7fVxuICB9XG4gIHN0YXRpYyBlZGdlVGVtcGxhdGUgPSB7XG4gICAgZnJvbTogbnVsbCxcbiAgICB0bzogbnVsbCxcbiAgICBkaXJlY3Rpb246ICctPicsXG4gICAgbGFiZWxzOiBbXSxcbiAgICBwcm9wZXJ0aWVzOiB7fVxuICB9XG5cbiAgc3RhdGljIGxvYWRlZEljb25zID0ge307XG4gIFxuICBzdGF0aWMgcmVuZGVyZWRDb2xvcnMgPSB7fTtcbiAgXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMubm9kZUNvbG9yTWFwID0ge307XG4gICAgdGhpcy5leHBhbmRlZE5vZGVzID0gW107XG4gICAgdGhpcy5ub2RlTWFwID0ge307XG4gICAgdGhpcy5jb25maWcgPSB7IG5vZGU6IHt9LCBlZGdlOiB7fX07XG4gICAgdGhpcy5ub2RlTGluZU1hcCA9IHt9O1xuICAgIHRoaXMuZWRnZU1hcCA9IHt9O1xuICAgIHRoaXMuZWRnZUxpbmVNYXAgPSB7fTtcbiAgICB0aGlzLnByZXZab29tUG9zaXRpb24gPSBudWxsO1xuICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICB0aGlzLmVsZW1lbnRXaXRoVG9vbHRpcCA9IG51bGw7XG4gICAgXG4gICAgdGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIFxuICAgIHRoaXMubmV0d29ya0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMubmV0d29ya0NvbnRhaW5lci5zdHlsZSA9IHRoaXMubmV0d29ya0NvbnRhaW5lck9yaWdpbmFsU3R5bGUgPSBgXG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIHRvcDogMDtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB6LWluZGV4OiAyO1xuICAgIGA7XG4gICAgXG4gICAgdGhpcy5tYXBDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLm1hcENvbnRhaW5lci5zdHlsZSA9IGBcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgdG9wOiAwO1xuICAgICAgbGVmdDogMDtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHotaW5kZXg6IDE7XG4gICAgYDtcbiAgICB0aGlzLm1hcCA9IG51bGw7XG4gICAgdGhpcy50b29sdGlwRHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLnRvb2x0aXBEdW1teS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy50b29sdGlwRHVtbXkuY2xhc3NMaXN0LmFkZCgnYmxpdHpib2FyZC10b29sdGlwJyk7XG4gICAgdGhpcy50b29sdGlwRHVtbXkuc3R5bGVbJ2JhY2tncm91bmQtY29sb3InXSA9ICdyZ2JhKDAsIDAsIDAsIDApJztcbiAgICB0aGlzLnRvb2x0aXBEdW1teS5zdHlsZVsnei1pbmRleCddID0gJzk5OCc7XG5cbiAgICB0aGlzLnRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgdGhpcy50b29sdGlwLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy50b29sdGlwLmNsYXNzTGlzdC5hZGQoJ2JsaXR6Ym9hcmQtdG9vbHRpcHRleHQnKTtcbiAgICB0aGlzLnRvb2x0aXAuY2xhc3NMaXN0LmFkZCgnYmxpdHpib2FyZC10b29sdGlwdGV4dC10b3AnKTtcbiAgICB0aGlzLnRvb2x0aXAuc3R5bGVbJ3otaW5kZXgnXSA9ICc5OTknO1xuXG5cbiAgICB0aGlzLm1pblRpbWUgPSBuZXcgRGF0ZSg4NjQwMDAwMDAwMDAwMDAwKTtcbiAgICB0aGlzLm1heFRpbWUgPSBuZXcgRGF0ZSgtODY0MDAwMDAwMDAwMDAwMCk7XG4gICAgXG4gICAgdGhpcy5wcmV2TW91c2VFdmVudD0gbnVsbDtcbiAgICB0aGlzLnRpbWVTY2FsZSA9IDEwMDA7XG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudExhdExuZyA9IG51bGw7XG4gICAgdGhpcy5yZWRyYXdUaW1lciA9IG51bGw7XG4gICAgdGhpcy5vbk5vZGVBZGRlZCA9IFtdO1xuICAgIHRoaXMub25FZGdlQWRkZWQgPSBbXTtcbiAgICB0aGlzLm9uTm9kZUZvY3VzZWQgPSBbXTtcbiAgICB0aGlzLm9uRWRnZUZvY3VzZWQgPSBbXTtcbiAgICB0aGlzLm9uVXBkYXRlZCA9IFtdO1xuICAgIHRoaXMuYmVmb3JlUGFyc2UgPSBbXTtcbiAgICB0aGlzLm9uUGFyc2VFcnJvciA9IFtdO1xuICAgIHRoaXMubWF4TGluZSA9IDA7XG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25UaW1lcklkID0gbnVsbDtcbiAgICB0aGlzLnNjcmVlbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuc2NyZWVuVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuc2NyZWVuVGV4dC5zdHlsZSA9IGBcbiAgICAgIGZvbnQtc2l6ZTogMnJlbTtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcbiAgICAgIHBhZGRpbmc6IDEwcHg7XG4gICAgYDtcbiAgICB0aGlzLnNjcmVlbi5hcHBlbmRDaGlsZCh0aGlzLnNjcmVlblRleHQpO1xuICAgIHRoaXMuc2NyZWVuVGV4dC5pbm5lclRleHQgPSBcIk5vdyBsb2FkaW5nLi4uXCI7XG4gICAgdGhpcy5zY3JlZW4uc3R5bGUgPSBgXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICB6LWluZGV4OiAzO1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBkaXNwbGF5OiBub25lO1xuICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgZm9udC1zaXplOiAycmVtO1xuICAgIGA7XG4gICAgdGhpcy5kb3VibGVDbGlja1RpbWVyID0gbnVsbDtcbiAgICBcbiAgICBsZXQgYmxpdHpib2FyZCA9IHRoaXM7XG5cbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zY3JlZW4pO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm5ldHdvcmtDb250YWluZXIpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm1hcENvbnRhaW5lcik7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnRvb2x0aXBEdW1teSk7XG4gICAgdGhpcy50b29sdGlwRHVtbXkuYXBwZW5kQ2hpbGQodGhpcy50b29sdGlwKTtcbiAgICB0aGlzLnRvb2x0aXAuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIChlKSA9PiB7XG4gICAgICBpZihlLnJlbGF0ZWRUYXJnZXQgIT09IGJsaXR6Ym9hcmQubmV0d29yay5jYW52YXMuZ2V0Q29udGV4dCgpLmNhbnZhcylcbiAgICAgICAgYmxpdHpib2FyZC5oaWRlVG9vbHRpcCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCAoZSkgPT4ge1xuICAgICAgaWYoYmxpdHpib2FyZC5jb25maWcubGF5b3V0ID09PSAnbWFwJylcbiAgICAgIHtcbiAgICAgICAgaWYoKGUuZGVsdGFZIDwgMCAmJiBibGl0emJvYXJkLm1hcC5fem9vbSA8IGJsaXR6Ym9hcmQubWFwLmdldE1heFpvb20oKSkgfHxcbiAgICAgICAgICAoZS5kZWx0YVkgPiAwICYmIGJsaXR6Ym9hcmQubWFwLl96b29tID4gYmxpdHpib2FyZC5tYXAuZ2V0TWluWm9vbSgpKSApIHtcbiAgICAgICAgICBpZighYmxpdHpib2FyZC5jdXJyZW50TGF0TG5nKSB7XG4gICAgICAgICAgICBibGl0emJvYXJkLmN1cnJlbnRMYXRMbmcgPSBibGl0emJvYXJkLm1hcC5tb3VzZUV2ZW50VG9MYXRMbmcoZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJsaXR6Ym9hcmQubWFwLnNldFpvb21Bcm91bmQoYmxpdHpib2FyZC5jdXJyZW50TGF0TG5nLCBibGl0emJvYXJkLm1hcC5fem9vbSAtIGUuZGVsdGFZICogMC4wMywge2FuaW1hdGU6IGZhbHNlfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1NjYWxlID0gYmxpdHpib2FyZC5tYXAuX3pvb20gLyAxMiArIDAuNDtcbiAgICAgICAgbmV3U2NhbGUgPSBNYXRoLm1pbihCbGl0emJvYXJkLm1heFNjYWxlT25NYXAsIE1hdGgubWF4KG5ld1NjYWxlLCBCbGl0emJvYXJkLm1pblNjYWxlT25NYXApKTtcbiAgICAgICAgc2V0VGltZW91dCggKCkgPT4ge1xuICAgICAgICAgIGJsaXR6Ym9hcmQubmV0d29yay5tb3ZlVG8oe3NjYWxlOiBuZXdTY2FsZX0pO1xuICAgICAgICAgIGJsaXR6Ym9hcmQudXBkYXRlTm9kZUxvY2F0aW9uT25NYXAoKTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgICBibGl0emJvYXJkLm1hcC5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIEluaGliaXQgem9vbSBvbiB2aXMtbmV0d29ya1xuICAgICAgfVxuICAgIH0sIHRydWUpO1xuICAgIFxuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgKGUpID0+IHtcbiAgICAgIGJsaXR6Ym9hcmQuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9LCB0cnVlKTtcblxuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoZSkgPT4ge1xuICAgICAgYmxpdHpib2FyZC5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIH0sIHRydWUpO1xuICAgIFxuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIChlKSA9PiB7XG4gICAgICBpZihibGl0emJvYXJkLmRyYWdnaW5nICYmIGJsaXR6Ym9hcmQuY29uZmlnLmxheW91dCA9PT0gJ21hcCcgJiYgYmxpdHpib2FyZC5wcmV2TW91c2VFdmVudCkge1xuICAgICAgICBibGl0emJvYXJkLm1hcC5wYW5CeShbYmxpdHpib2FyZC5wcmV2TW91c2VFdmVudC54IC0gZS54LCBibGl0emJvYXJkLnByZXZNb3VzZUV2ZW50LnkgLSBlLnldLCB7YW5pbWF0ZTogZmFsc2V9KTtcbiAgICAgIH1cbiAgICAgIGlmKGJsaXR6Ym9hcmQuZWxlbWVudFdpdGhUb29sdGlwPy5lZGdlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcExvY2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBibGl0emJvYXJkLnByZXZNb3VzZUV2ZW50ID0gZTtcbiAgICAgIGJsaXR6Ym9hcmQuY3VycmVudExhdExuZyA9IG51bGw7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIChlKSA9PiB7XG4gICAgICBpZihibGl0emJvYXJkLmNvbmZpZy5sYXlvdXQgPT09ICdtYXAnKSB7XG4gICAgICAgIGJsaXR6Ym9hcmQubWFwLnBhblRvKGJsaXR6Ym9hcmQubWFwLm1vdXNlRXZlbnRUb0xhdExuZyhlKSk7XG4gICAgICB9XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZSkgPT4ge1xuICAgICAgYmxpdHpib2FyZC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICBibGl0emJvYXJkLnByZXZNb3VzZUV2ZW50ID0gZTtcbiAgICB9LCB0cnVlKTtcbiAgICBcbiAgICB0aGlzLmFwcGx5RHluYW1pY1N0eWxlKGBcbiAgICAgIC5ibGl0emJvYXJkLXRvb2x0aXAge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IGRvdHRlZCBibGFjaztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLmJsaXR6Ym9hcmQtdG9vbHRpcCAuYmxpdHpib2FyZC10b29sdGlwdGV4dCB7XG4gICAgICAgIG1heC13aWR0aDogJHtCbGl0emJvYXJkLnRvb2x0aXBNYXhXaWR0aH1weDtcbiAgICAgICAgbWluLXdpZHRoOiAyMDBweDtcbiAgICAgICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjcpO1xuICAgICAgICBjb2xvcjogI2ZmZjtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICAgIHBhZGRpbmc6IDVweDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC5ibGl0emJvYXJkLXRvb2x0aXAgLmJsaXR6Ym9hcmQtdG9vbHRpcHRleHQtdG9wIHtcbiAgICAgICAgYm90dG9tOiAxMjUlO1xuICAgICAgICBsZWZ0OiA1MCU7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAtNnB4O1xuICAgICAgfVxuICAgICAgXG4gICAgICAuYmxpdHpib2FyZC10b29sdGlwIC5ibGl0emJvYXJkLXRvb2x0aXB0ZXh0LWJvdHRvbSB7XG4gICAgICAgIGJvdHRvbTogMTAwJTtcbiAgICAgICAgbGVmdDogNTAlO1xuICAgICAgICBtYXJnaW4tbGVmdDogLTZweDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgXG4gICAgICAuYmxpdHpib2FyZC10b29sdGlwIC5ibGl0emJvYXJkLXRvb2x0aXB0ZXh0LWxlZnQge1xuICAgICAgICB0b3A6IDUwJTtcbiAgICAgICAgbGVmdDogMCU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC5ibGl0emJvYXJkLXRvb2x0aXAgLmJsaXR6Ym9hcmQtdG9vbHRpcHRleHQtcmlnaHQge1xuICAgICAgICB0b3A6IC01MCU7XG4gICAgICAgIGxlZnQ6IDEwMCU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIFxuICAgICAgLmJsaXR6Ym9hcmQtdG9vbHRpcCAuYmxpdHpib2FyZC10b29sdGlwdGV4dDo6YWZ0ZXIge1xuICAgICAgICBjb250ZW50OiBcIlwiO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGJvcmRlci13aWR0aDogNnB4O1xuICAgICAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xuICAgICAgfVxuICAgICAgXG4gICAgICAuYmxpdHpib2FyZC10b29sdGlwIC5ibGl0emJvYXJkLXRvb2x0aXB0ZXh0LWJvdHRvbTo6YWZ0ZXIge1xuICAgICAgICB0b3A6IC0xMnB4O1xuICAgICAgICBsZWZ0OiA1MCU7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzU1NSB0cmFuc3BhcmVudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLmJsaXR6Ym9hcmQtdG9vbHRpcCAuYmxpdHpib2FyZC10b29sdGlwdGV4dC1sZWZ0OjphZnRlciB7XG4gICAgICAgIHRvcDogNTAlO1xuICAgICAgICBsZWZ0OiAxMDAlO1xuICAgICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICM1NTU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC5ibGl0emJvYXJkLXRvb2x0aXAgLmJsaXR6Ym9hcmQtdG9vbHRpcHRleHQtdG9wOjphZnRlciB7XG4gICAgICAgIHRvcDogMTAwJTtcbiAgICAgICAgbGVmdDogNTAlO1xuICAgICAgICBib3JkZXItY29sb3I6ICM1NTUgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIC5ibGl0emJvYXJkLXRvb2x0aXAgLmJsaXR6Ym9hcmQtdG9vbHRpcHRleHQtcmlnaHQ6OmFmdGVyIHtcbiAgICAgICAgdG9wOiA1MCU7XG4gICAgICAgIGxlZnQ6IC0xMnB4O1xuICAgICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50ICM1NTUgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC5ibGl0emJvYXJkLXRvb2x0aXB0ZXh0IHRoLCAuYmxpdHpib2FyZC10b29sdGlwdGV4dCB0ZCB7XG4gICAgICAgIHRleHQtYWxpZ246IGxlZnQ7XG4gICAgICAgIHBhZGRpbmctbGVmdDogMTBweDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLmJsaXR6Ym9hcmQtdG9vbHRpcCBhIHtcbiAgICAgICAgY29sb3I6ICM4OEJCRkY7XG4gICAgICB9XG4gICAgYCk7XG4gIH1cblxuICBzdGF0aWMgYmxpdHpQcm94eSA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmIChwcm9wID09PSAnbGFiZWwnKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQubGFiZWxzWzBdO1xuICAgICAgfVxuICAgICAgaWYgKCEocHJvcCBpbiB0YXJnZXQpICYmIHByb3AgaW4gdGFyZ2V0LnByb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wcm9wZXJ0aWVzW3Byb3BdWzBdOyBcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICB9XG4gIH1cblxuICBhcHBseUR5bmFtaWNTdHlsZShjc3MpIHtcbiAgICB2YXIgc3R5bGVUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHZhciBkeW5hbWljU3R5bGVDc3MgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHN0eWxlVGFnLmFwcGVuZENoaWxkKGR5bmFtaWNTdHlsZUNzcyk7XG4gICAgdmFyIGhlYWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgaGVhZGVyLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcbiAgfTtcblxuICBnZXRIZXhDb2xvcnMoY29sb3JTdHIpIHtcbiAgICBsZXQgY29tcHV0ZWQgPSBCbGl0emJvYXJkLnJlbmRlcmVkQ29sb3JzW2NvbG9yU3RyXTtcbiAgICBpZihjb21wdXRlZCkge1xuICAgICAgcmV0dXJuIGNvbXB1dGVkO1xuICAgIH1cbiAgICBsZXQgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGEuc3R5bGUuY29sb3IgPSBjb2xvclN0cjtcbiAgICBsZXQgY29sb3JzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSkgKS5jb2xvci5tYXRjaCgvXFxkKy9nKS5tYXAoZnVuY3Rpb24oYSl7IHJldHVybiBwYXJzZUludChhLDEwKTsgfSk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhKTtcbiAgICBCbGl0emJvYXJkLnJlbmRlcmVkQ29sb3JzW2NvbG9yU3RyXSA9IGNvbG9ycztcbiAgICByZXR1cm4gY29sb3JzO1xuICB9XG4gIFxuICBoYXNOb2RlKG5vZGVfaWQpIHtcbiAgICByZXR1cm4gISF0aGlzLm5vZGVNYXBbbm9kZV9pZF07XG4gIH1cbiAgXG4gIGhhc0VkZ2UoZnJvbSwgdG8sIGxhYmVsID0gbnVsbCkge1xuICAgIGZvcihsZXQgZWRnZSBvZiB0aGlzLmdyYXBoLmVkZ2VzKSB7XG4gICAgICBpZihlZGdlLmZyb20gPT09IGZyb20gJiYgZWRnZS50byA9PT0gdG8gJiYgKCFsYWJlbCB8fCBlZGdlLmxhYmVscy5pbmNsdWRlcyhsYWJlbCkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIFxuICBnZXRBbGxOb2RlcyhsYWJlbCA9IG51bGwpIHtcbiAgICBpZihsYWJlbClcbiAgICAgIHJldHVybiB0aGlzLmdyYXBoLm5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUubGFiZWxzLmluY2x1ZGVzKGxhYmVsKSkubWFwKG5vZGUgPT4gdGhpcy5nZXROb2RlKG5vZGUuaWQpKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5ncmFwaC5ub2Rlcy5tYXAobm9kZSA9PiB0aGlzLmdldE5vZGUobm9kZS5pZCkpO1xuICB9XG5cbiAgZ2V0Tm9kZShub2RlX2lkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eSh0aGlzLm5vZGVNYXBbbm9kZV9pZF0sIEJsaXR6Ym9hcmQuYmxpdHpQcm94eSk7XG4gIH1cbiAgXG4gIGdldEVkZ2UoZWRnZV9pZCkge1xuICAgIHJldHVybiBuZXcgUHJveHkodGhpcy5lZGdlTWFwW2VkZ2VfaWRdLCBCbGl0emJvYXJkLmJsaXR6UHJveHkpO1xuICB9XG4gIFxuICBjYWxjTm9kZVBvc2l0aW9uKHBnTm9kZSkge1xuICAgIGxldCB4LCB5LCBmaXhlZCwgd2lkdGg7XG4gICAgaWYodGhpcy5jb25maWcubGF5b3V0ID09PSAndGltZWxpbmUnICYmIHRoaXMudGltZUludGVydmFsID4gMCkge1xuICAgICAgeCA9IG51bGw7XG4gICAgICBmaXhlZCA9IGZhbHNlO1xuICAgICAgbGV0IGZyb21Qcm9wID0gdGhpcy5jb25maWcubGF5b3V0U2V0dGluZ3MudGltZV9mcm9tO1xuICAgICAgbGV0IHRvUHJvcCA9IHRoaXMuY29uZmlnLmxheW91dFNldHRpbmdzLnRpbWVfdG87XG4gICAgICBsZXQgZnJvbSA9IHRoaXMubWF4VGltZTtcbiAgICAgIGxldCB0byA9IHRoaXMubWluVGltZTtcblxuICAgICAgZm9yIChsZXQgcHJvcCBvZiBPYmplY3Qua2V5cyhwZ05vZGUucHJvcGVydGllcykpIHtcbiAgICAgICAgaWYgKHByb3AgPT09IGZyb21Qcm9wIHx8IHByb3AgPT09IHRvUHJvcCkge1xuICAgICAgICAgIGZyb20gPSBuZXcgRGF0ZShNYXRoLm1pbihmcm9tLCBuZXcgRGF0ZShwZ05vZGUucHJvcGVydGllc1twcm9wXVswXSkpKTtcbiAgICAgICAgICB0byA9IG5ldyBEYXRlKE1hdGgubWF4KHRvLCBuZXcgRGF0ZShwZ05vZGUucHJvcGVydGllc1twcm9wXVswXSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIFxuICAgICAgaWYoZnJvbSA8PSB0bykge1xuICAgICAgICBmaXhlZCA9IHRydWU7XG4gICAgICAgIGxldCBmcm9tUG9zaXRpb24gPSB0aGlzLnRpbWVTY2FsZSAqIChmcm9tLmdldFRpbWUoKSAtIHRoaXMubWluVGltZS5nZXRUaW1lKCkpICogMS4wIC8gdGhpcy50aW1lSW50ZXJ2YWwgLSB0aGlzLnRpbWVTY2FsZSAqIDAuNTtcbiAgICAgICAgbGV0IHRvUG9zaXRpb24gPSB0aGlzLnRpbWVTY2FsZSAqICh0by5nZXRUaW1lKCkgLSB0aGlzLm1pblRpbWUuZ2V0VGltZSgpKSAqIDEuMCAvIHRoaXMudGltZUludGVydmFsIC0gdGhpcy50aW1lU2NhbGUgKiAwLjU7XG4gICAgICAgIHggPSAoZnJvbVBvc2l0aW9uICsgdG9Qb3NpdGlvbikgLyAyO1xuICAgICAgICBpZihmcm9tID09PSB0bykge1xuICAgICAgICAgIHdpZHRoID0gZnJvbVBvc2l0aW9uIC0gdG9Qb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aWR0aCA9IDI1O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZih0aGlzLmNvbmZpZy5sYXlvdXQgPT0gJ2N1c3RvbScpIHtcbiAgICAgICAgaWYgKHBnTm9kZS5wcm9wZXJ0aWVzW3RoaXMuY29uZmlnLmxheW91dFNldHRpbmdzLnhdIHx8IHBnTm9kZS5wcm9wZXJ0aWVzW3RoaXMuY29uZmlnLmxheW91dFNldHRpbmdzLnldKSB7XG4gICAgICAgICAgeCA9IHBhcnNlSW50KHBnTm9kZS5wcm9wZXJ0aWVzW3RoaXMuY29uZmlnLmxheW91dFNldHRpbmdzLnhdWzBdKTtcbiAgICAgICAgICB5ID0gcGFyc2VJbnQocGdOb2RlLnByb3BlcnRpZXNbdGhpcy5jb25maWcubGF5b3V0U2V0dGluZ3MueV1bMF0pO1xuICAgICAgICAgIGZpeGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IG51bGw7XG4gICAgICAgIHkgPSBudWxsO1xuICAgICAgICBmaXhlZCA9IHRoaXMuY29uZmlnLmxheW91dCA9PT0gJ2hpZXJhcmNoaWNhbCc7XG4gICAgICAgIHdpZHRoID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHt4LCB5LCBmaXhlZCwgd2lkdGh9O1xuICB9XG5cbiAgcmV0cmlldmVUaHVtYm5haWxVcmwobm9kZSkge1xuICAgIGlmKHRoaXMuY29uZmlnLm5vZGUudGh1bWJuYWlsKSB7XG4gICAgICByZXR1cm4gbm9kZS5wcm9wZXJ0aWVzW3RoaXMuY29uZmlnLm5vZGUudGh1bWJuYWlsXT8uWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBcbiAgdG9vbHRpcFBvc2l0aW9uKCkge1xuICAgIGlmKHdpbmRvdy5pbm5lcldpZHRoIDwgd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2TW91c2VFdmVudC5jbGllbnRZIDwgd2luZG93LmlubmVySGVpZ2h0IC8gMiA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByZXZNb3VzZUV2ZW50LmNsaWVudFggPCB3aW5kb3cuaW5uZXJXaWR0aCAvIDIgPyAncmlnaHQnIDogJ2xlZnQnO1xuICB9XG4gIFxuICB1cGRhdGVUb29sdGlwTG9jYXRpb24oKSB7XG4gICAgaWYoIXRoaXMuZWxlbWVudFdpdGhUb29sdGlwKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBwb3NpdGlvbiwgb2Zmc2V0ID0gMTA7XG4gICAgaWYodGhpcy5lbGVtZW50V2l0aFRvb2x0aXAubm9kZSkge1xuICAgICAgcG9zaXRpb24gPSB0aGlzLm5ldHdvcmsuY2FudmFzVG9ET00odGhpcy5uZXR3b3JrLmdldFBvc2l0aW9uKHRoaXMuZWxlbWVudFdpdGhUb29sdGlwLm5vZGUuaWQpKTtcbiAgICAgIGxldCBjbGllbnRSZWN0ID0gdGhpcy5jb250YWluZXIuZ2V0Q2xpZW50UmVjdHMoKVswXTtcbiAgICAgIHBvc2l0aW9uLnggKz0gY2xpZW50UmVjdC54O1xuICAgICAgcG9zaXRpb24ueSArPSBjbGllbnRSZWN0Lnk7XG4gICAgICBvZmZzZXQgKz0gdGhpcy5lbGVtZW50V2l0aFRvb2x0aXAubm9kZS5zaXplICogdGhpcy5uZXR3b3JrLmdldFNjYWxlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHRoaXMucHJldk1vdXNlRXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogdGhpcy5wcmV2TW91c2VFdmVudC5jbGllbnRZXG4gICAgICB9O1xuICAgIH1cbiAgICBwb3NpdGlvbi54ICs9IHdpbmRvdy5zY3JvbGxYO1xuICAgIHBvc2l0aW9uLnkgKz0gd2luZG93LnNjcm9sbFk7XG4gICAgXG4gICAgc3dpdGNoKHRoaXMudG9vbHRpcFBvc2l0aW9uKCkpIHtcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICB0aGlzLnRvb2x0aXAuY2xhc3NMaXN0LmFkZCgnYmxpdHpib2FyZC10b29sdGlwdGV4dC1sZWZ0Jyk7XG4gICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdibGl0emJvYXJkLXRvb2x0aXB0ZXh0LXRvcCcpO1xuICAgICAgICB0aGlzLnRvb2x0aXAuY2xhc3NMaXN0LnJlbW92ZSgnYmxpdHpib2FyZC10b29sdGlwdGV4dC1yaWdodCcpO1xuICAgICAgICB0aGlzLnRvb2x0aXAuY2xhc3NMaXN0LnJlbW92ZSgnYmxpdHpib2FyZC10b29sdGlwdGV4dC1ib3R0b20nKTtcbiAgICAgICAgcG9zaXRpb24ueCAtPSBvZmZzZXQ7XG4gICAgICAgIHBvc2l0aW9uLnggLT0gdGhpcy50b29sdGlwLmNsaWVudFdpZHRoO1xuICAgICAgICBwb3NpdGlvbi55IC09IHRoaXMudG9vbHRpcC5jbGllbnRIZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdibGl0emJvYXJkLXRvb2x0aXB0ZXh0LWxlZnQnKTtcbiAgICAgICAgdGhpcy50b29sdGlwLmNsYXNzTGlzdC5hZGQoJ2JsaXR6Ym9hcmQtdG9vbHRpcHRleHQtdG9wJyk7XG4gICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdibGl0emJvYXJkLXRvb2x0aXB0ZXh0LXJpZ2h0Jyk7XG4gICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdibGl0emJvYXJkLXRvb2x0aXB0ZXh0LWJvdHRvbScpO1xuICAgICAgICBwb3NpdGlvbi54IC09IHRoaXMudG9vbHRpcC5jbGllbnRXaWR0aCAvIDI7XG4gICAgICAgIHBvc2l0aW9uLnkgLT0gb2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgdGhpcy50b29sdGlwLmNsYXNzTGlzdC5yZW1vdmUoJ2JsaXR6Ym9hcmQtdG9vbHRpcHRleHQtbGVmdCcpO1xuICAgICAgICB0aGlzLnRvb2x0aXAuY2xhc3NMaXN0LnJlbW92ZSgnYmxpdHpib2FyZC10b29sdGlwdGV4dC10b3AnKTtcbiAgICAgICAgdGhpcy50b29sdGlwLmNsYXNzTGlzdC5hZGQoJ2JsaXR6Ym9hcmQtdG9vbHRpcHRleHQtcmlnaHQnKTtcbiAgICAgICAgdGhpcy50b29sdGlwLmNsYXNzTGlzdC5yZW1vdmUoJ2JsaXR6Ym9hcmQtdG9vbHRpcHRleHQtYm90dG9tJyk7XG4gICAgICAgIHBvc2l0aW9uLnggKz0gb2Zmc2V0O1xuICAgICAgICBwb3NpdGlvbi55IC09IHRoaXMudG9vbHRpcC5jbGllbnRIZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdibGl0emJvYXJkLXRvb2x0aXB0ZXh0LWxlZnQnKTtcbiAgICAgICAgdGhpcy50b29sdGlwLmNsYXNzTGlzdC5yZW1vdmUoJ2JsaXR6Ym9hcmQtdG9vbHRpcHRleHQtdG9wJyk7XG4gICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdibGl0emJvYXJkLXRvb2x0aXB0ZXh0LXJpZ2h0Jyk7XG4gICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QuYWRkKCdibGl0emJvYXJkLXRvb2x0aXB0ZXh0LWJvdHRvbScpO1xuICAgICAgICBwb3NpdGlvbi54IC09IHRoaXMudG9vbHRpcC5jbGllbnRXaWR0aCAvIDI7XG4gICAgICAgIHBvc2l0aW9uLnkgKz0gdGhpcy50b29sdGlwLmNsaWVudEhlaWdodDtcbiAgICAgICAgcG9zaXRpb24ueSArPSBvZmZzZXQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMudG9vbHRpcER1bW15LnN0eWxlLmxlZnQgPSBgJHtwb3NpdGlvbi54fXB4YDtcbiAgICB0aGlzLnRvb2x0aXBEdW1teS5zdHlsZS50b3AgPSBgJHtwb3NpdGlvbi55fXB4YDtcbiAgfVxuICBcbiAgc2hvd1Rvb2x0aXAoKSB7XG4gICAgdGhpcy51cGRhdGVUb29sdGlwTG9jYXRpb24oKTtcbiAgICBsZXQgdGl0bGUgPSB0aGlzLmVsZW1lbnRXaXRoVG9vbHRpcC5ub2RlID8gdGhpcy5lbGVtZW50V2l0aFRvb2x0aXAubm9kZS5fdGl0bGUgOiB0aGlzLmVsZW1lbnRXaXRoVG9vbHRpcC5lZGdlLl90aXRsZTtcbiAgICBpZighdGl0bGUpXG4gICAgICByZXR1cm47XG4gICAgXG4gICAgdGhpcy50b29sdGlwLmlubmVySFRNTCA9IHRpdGxlO1xuICAgIHRoaXMudG9vbHRpcC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfVxuICBcbiAgaGlkZVRvb2x0aXAoKSB7XG4gICAgaWYodGhpcy5lbGVtZW50V2l0aFRvb2x0aXApIHtcbiAgICAgIHRoaXMudG9vbHRpcC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy5lbGVtZW50V2l0aFRvb2x0aXAgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHRvVmlzTm9kZShwZ05vZGUsIHByb3BzLCBleHRyYU9wdGlvbnMgPSBudWxsKSB7XG4gICAgY29uc3QgZ3JvdXAgPSBbLi4ucGdOb2RlLmxhYmVsc10uc29ydCgpLmpvaW4oJ18nKTtcbiAgICBpZighdGhpcy5ub2RlQ29sb3JNYXBbZ3JvdXBdKSB7XG4gICAgICB0aGlzLm5vZGVDb2xvck1hcFtncm91cF0gPSBnZXRSYW5kb21Db2xvcihncm91cCwgdGhpcy5jb25maWcubm9kZS5zYXR1cmF0aW9uLCB0aGlzLmNvbmZpZy5ub2RlLmJyaWdodG5lc3MpO1xuICAgIH1cbiAgICBcbiAgICBsZXQgeCwgeSwgZml4ZWQsIHdpZHRoO1xuICAgICh7eCwgeSwgZml4ZWQsIHdpZHRofSA9IHRoaXMuY2FsY05vZGVQb3NpdGlvbihwZ05vZGUpKTtcblxuICAgIGxldCB1cmwgPSByZXRyaWV2ZUh0dHBVcmwocGdOb2RlKTtcbiAgICBsZXQgdGh1bWJuYWlsVXJsID0gdGhpcy5yZXRyaWV2ZVRodW1ibmFpbFVybChwZ05vZGUpO1xuICAgIGxldCBleHBhbmRlZCA9IHRoaXMuZXhwYW5kZWROb2Rlcy5pbmNsdWRlcyhwZ05vZGUuaWQpO1xuXG4gICAgbGV0IGRlZ3JlZSA9ICBwZ05vZGUucHJvcGVydGllc1snZGVncmVlJ107XG4gICAgbGV0IGJsaXR6Ym9hcmQgPSB0aGlzO1xuICAgIGlmKGRlZ3JlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWdyZWUgPSBkZWdyZWVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZ3JlZSA9IDI7IC8vIGFzc3VtZSBkZWdyZWUgdG8gYmUgdHdvIChkZWZhdWx0KVxuICAgIH1cblxuICAgIGxldCBjb2xvciA9IHRoaXMucmV0cmlldmVDb25maWdQcm9wKHBnTm9kZSwgJ25vZGUnLCAnY29sb3InKTtcbiAgICBsZXQgb3BhY2l0eSA9IHBhcnNlRmxvYXQodGhpcy5yZXRyaWV2ZUNvbmZpZ1Byb3AocGdOb2RlLCAnbm9kZScsICdvcGFjaXR5JykpO1xuICAgIGxldCBzaXplICA9IHBhcnNlRmxvYXQodGhpcy5yZXRyaWV2ZUNvbmZpZ1Byb3AocGdOb2RlLCAnbm9kZScsICdzaXplJykpO1xuICAgIGxldCB0b29sdGlwICA9IHRoaXMucmV0cmlldmVDb25maWdQcm9wKHBnTm9kZSwgJ25vZGUnLCAndGl0bGUnKTtcblxuICAgIGNvbG9yID0gY29sb3IgfHwgdGhpcy5ub2RlQ29sb3JNYXBbZ3JvdXBdO1xuICAgIFxuICAgIGlmKG9wYWNpdHkgPCAxKSB7XG4gICAgICBsZXQgcmdiID0gdGhpcy5nZXRIZXhDb2xvcnMoY29sb3IpO1xuICAgICAgY29sb3IgPSBgcmdiYSgke3JnYlswXX0sICR7cmdiWzFdfSwgJHtyZ2JbMl19LCAke29wYWNpdHl9KWA7XG4gICAgfVxuXG4gICAgbGV0IGF0dHJzID0ge1xuICAgICAgaWQ6IHBnTm9kZS5pZCxcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIGxhYmVsOiBjcmVhdGVMYWJlbFRleHQocGdOb2RlLCBwcm9wcyksXG4gICAgICBzaGFwZTogJ2RvdCcsXG4gICAgICBzaXplOiBzaXplIHx8IDI1LFxuICAgICAgZGVncmVlOiBkZWdyZWUsXG4gICAgICBfdGl0bGU6IHRvb2x0aXAgIT0gbnVsbCA/IHRvb2x0aXAgOiB0aGlzLmNyZWF0ZVRpdGxlKHBnTm9kZSksXG4gICAgICBmaXhlZDoge1xuICAgICAgICB4OiBmaXhlZCxcbiAgICAgICAgeTogdGhpcy5jb25maWcubGF5b3V0ID09PSAndGltZWxpbmUnID8gZmFsc2UgOiBmaXhlZFxuICAgICAgfSxcbiAgICAgIGJvcmRlcldpZHRoOiB1cmwgPyAzIDogMSxcbiAgICAgIHVybDogdXJsLFxuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICBjaG9zZW46IHRoaXMucmV0cmlldmVDb25maWdQcm9wKHBnTm9kZSwgJ25vZGUnLCAnY2hvc2VuJyksXG4gICAgICBmb250OiB7XG4gICAgICAgIGNvbG9yOiB1cmwgPyAnYmx1ZScgOiAnYmxhY2snLFxuICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgIH0sXG4gICAgICBmaXhlZEJ5VGltZTogZml4ZWRcbiAgICB9O1xuICAgIFxuICAgIGxldCBvdGhlclByb3BzID0gdGhpcy5yZXRyaWV2ZUNvbmZpZ1Byb3BBbGwocGdOb2RlLFxuICAgICAgJ25vZGUnLCBbJ2NvbG9yJywgJ3NpemUnLCAnb3BhY2l0eScsICd0aXRsZSddKTtcbiAgICBcbiAgICBmb3IobGV0IGtleSBvZiBPYmplY3Qua2V5cyhvdGhlclByb3BzKSkge1xuICAgICAgYXR0cnNba2V5XSA9IG90aGVyUHJvcHNba2V5XSB8fCBhdHRyc1trZXldO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBpY29uUmVnaXN0ZXJlcihuYW1lKSB7XG4gICAgICByZXR1cm4gKGljb25zKSA9PiB7XG4gICAgICAgIGlmIChpY29ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGV0IGljb24gPSBudWxsO1xuICAgICAgICAgIGlmKGljb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgaWNvbiB3aXRoIHRoZSBoaWdoZXN0IHByaW9yaXR5IFxuICAgICAgICAgICAgZm9yIChsZXQgcHJlZml4IG9mIEJsaXR6Ym9hcmQuaWNvblByZWZpeGVzKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgb2YgaWNvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYCR7aS5wcmVmaXh9OiR7aS5uYW1lfWAuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICBpY29uID0gaTsgXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGljb24pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpY29uID0gaWNvbiB8fCBpY29uc1swXTtcbiAgICAgICAgICBsZXQgc2l6ZSA9IGF0dHJzLnNpemUgKiBCbGl0emJvYXJkLmljb25TaXplQ29lZjtcbiAgICAgICAgICBsZXQgc3ZnID0gSWNvbmlmeS5yZW5kZXJTVkcoYCR7aWNvbi5wcmVmaXh9OiR7aWNvbi5uYW1lfWAsIHtcbiAgICAgICAgICAgIHdpZHRoOiBzaXplLFxuICAgICAgICAgICAgaGVpZ2h0OiBzaXplXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGV0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgIHN2Zy5xdWVyeVNlbGVjdG9yQWxsKFwicGF0aCxjaXJjbGUsZWxsaXBzZSxyZWN0XCIpLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgICAgIHBhdGguc3R5bGUuZmlsbCA9IFwid2hpdGVcIjtcbiAgICAgICAgICAgIHBhdGguc3R5bGUuc3Ryb2tlID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGltZy5zcmMgPSAnZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsJyArIGVuY29kZVVSSUNvbXBvbmVudChzdmcub3V0ZXJIVE1MKTtcbiAgICAgICAgICBCbGl0emJvYXJkLmxvYWRlZEljb25zW25hbWVdID0gaW1nO1xuICAgICAgICAgIGlmKGJsaXR6Ym9hcmQpIHtcbiAgICAgICAgICAgIGlmIChibGl0emJvYXJkLnJlZHJhd1RpbWVyKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChibGl0emJvYXJkLnJlZHJhd1RpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsaXR6Ym9hcmQucmVkcmF3VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHsgIC8vIEFkZCBkZWxheSB0byBhdm9pZCByZWRyYXcgdG9vIG9mZW5cbiAgICAgICAgICAgICAgYmxpdHpib2FyZC5uZXR3b3JrLnJlZHJhdygpO1xuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZvcihsZXQgbGFiZWwgb2YgcGdOb2RlLmxhYmVscykge1xuICAgICAgbGV0IGljb247XG4gICAgICBpZiAoaWNvbiA9IHRoaXMuY29uZmlnLm5vZGUuaWNvbj8uW2xhYmVsXSkge1xuICAgICAgICBpZihpY29uLmluY2x1ZGVzKCc6JykpIHsgLy8gRm9yIGljb25zIGluIGljb25pZnlcbiAgICAgICAgICBJY29uaWZ5LmxvYWRJY29ucyhbaWNvbl0sIGljb25SZWdpc3RlcmVyKGljb24pKTtcbiAgICAgICAgICBhdHRyc1snY3VzdG9tSWNvbiddID0ge1xuICAgICAgICAgICAgbmFtZTogaWNvblxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7IC8vIEZvciBpY29uIGNvZGVzIGluIElvbmljb25zICh0byBiZSBiYWNrd2FyZCBjb21wYXRpYmxlKVxuICAgICAgICAgIGxldCBjb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChpY29uLCAxNikpO1xuICAgICAgICAgIGF0dHJzWydjdXN0b21JY29uJ10gPSB7XG4gICAgICAgICAgICBmYWNlOiAnSW9uaWNvbnMnLFxuICAgICAgICAgICAgc2l6ZTogYXR0cnMuc2l6ZSAqIDEuNSxcbiAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICBjb2xvcjogJ3doaXRlJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cblxuICAgIGlmKCFhdHRyc1snY3VzdG9tSWNvbiddICYmIHRoaXMuY29uZmlnLm5vZGUuZGVmYXVsdEljb24pIHtcbiAgICAgIGZvcihsZXQgbGFiZWwgb2YgcGdOb2RlLmxhYmVscykge1xuICAgICAgICBsZXQgbG93ZXJMYWJlbCA9IGxhYmVsLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghQmxpdHpib2FyZC5sb2FkZWRJY29uc1tsb3dlckxhYmVsXSkge1xuICAgICAgICAgIEJsaXR6Ym9hcmQubG9hZGVkSWNvbnNbbG93ZXJMYWJlbF0gPSAncmV0cmlldmluZy4uLic7IC8vIEp1c3QgYSBwbGFjZWhvbGRlciB0byBhdm9pZCBkdXBsaWNhdGUgZmV0Y2hpbmdcbiAgICAgICAgICBJY29uaWZ5LmxvYWRJY29ucyhcbiAgICAgICAgICAgIEJsaXR6Ym9hcmQuaWNvblByZWZpeGVzLm1hcCgocHJlZml4KSA9PiBwcmVmaXggKyBsb3dlckxhYmVsKSxcbiAgICAgICAgICAgIGljb25SZWdpc3RlcmVyKGxvd2VyTGFiZWwpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZih0aHVtYm5haWxVcmwpIHtcbiAgICAgIGF0dHJzWydzaGFwZSddID0gJ2ltYWdlJztcbiAgICAgIGF0dHJzWydpbWFnZSddID0gdGh1bWJuYWlsVXJsO1xuICAgIH1cbiAgICBhdHRycyA9IE9iamVjdC5hc3NpZ24oYXR0cnMsIGV4dHJhT3B0aW9ucyk7XG4gICAgcmV0dXJuIGF0dHJzO1xuICB9XG4gIFxuICByZXRyaWV2ZVByb3AocGdFbGVtLCBjb25maWcsIGxvYWRGdW5jdGlvbiA9IHRydWUpIHtcbiAgICBpZigodHlwZW9mIGNvbmZpZykgPT09ICdmdW5jdGlvbicgJiYgbG9hZEZ1bmN0aW9uKSB7XG4gICAgICByZXR1cm4gY29uZmlnKG5ldyBQcm94eShwZ0VsZW0sIEJsaXR6Ym9hcmQuYmxpdHpQcm94eSkpO1xuICAgIH0gZWxzZSBpZigodHlwZW9mIGNvbmZpZykgPT09ICdzdHJpbmcnICYmIGNvbmZpZy5zdGFydHNXaXRoKCdAJykpIHtcbiAgICAgIHJldHVybiBwZ0VsZW0ucHJvcGVydGllc1tjb25maWcuc3Vic3RyKDEpXT8uWzBdO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnOyAvLyByZXR1cm4gYXMgY29uc3RhbnRcbiAgfVxuICBcbiAgcmV0cmlldmVDb25maWdQcm9wKHBnRWxlbSwgdHlwZSwgcHJvcE5hbWUsIGxvYWRGdW5jdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBsYWJlbHMgPSBwZ0VsZW0ubGFiZWxzLmpvaW4oJ18nKTtcbiAgICBsZXQgcHJvcENvbmZpZyA9IHRoaXMuY29uZmlnPy5bdHlwZV1bcHJvcE5hbWVdO1xuICAgIGlmICgodHlwZW9mIHByb3BDb25maWcpID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVQcm9wKHBnRWxlbSwgcHJvcENvbmZpZ1tsYWJlbHNdLCBsb2FkRnVuY3Rpb24pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJldHJpZXZlUHJvcChwZ0VsZW0sIHByb3BDb25maWcsIGxvYWRGdW5jdGlvbik7XG4gIH1cblxuICByZXRyaWV2ZUNvbmZpZ1Byb3BBbGwocGdFbGVtLCB0eXBlLCBleGNlcHQpIHtcbiAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuY29uZmlnPy5bdHlwZV0pO1xuICAgIGxldCBwcm9wcyA9IHt9O1xuICAgIGZvcihsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmKGV4Y2VwdC5pbmNsdWRlcyhrZXkpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIC8vIFRPRE86IEhvdyBjYW4gd2UgYWxsb3cgZnVuY3Rpb25zIGZvciBhcmJpdHJhcnkgY29uZmlnP1xuICAgICAgcHJvcHNba2V5XSA9IHRoaXMucmV0cmlldmVDb25maWdQcm9wKHBnRWxlbSwgdHlwZSwga2V5LCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuICBcbiAgdG9WaXNFZGdlKHBnRWRnZSwgcHJvcHMgPSB0aGlzLmNvbmZpZy5lZGdlLmNhcHRpb24sIGlkKSB7XG4gICAgY29uc3QgZWRnZUxhYmVsID0gcGdFZGdlLmxhYmVscy5qb2luKCdfJyk7XG4gICAgaWYgKCF0aGlzLmVkZ2VDb2xvck1hcFtlZGdlTGFiZWxdKSB7XG4gICAgICB0aGlzLmVkZ2VDb2xvck1hcFtlZGdlTGFiZWxdID0gZ2V0UmFuZG9tQ29sb3IoZWRnZUxhYmVsLCB0aGlzLmNvbmZpZy5lZGdlLnNhdHVyYXRpb24gfHwgJzAlJywgdGhpcy5jb25maWcuZWRnZS5icmlnaHRuZXNzIHx8ICczMCUnKTtcbiAgICB9XG4gICAgbGV0IGNvbG9yID0gdGhpcy5yZXRyaWV2ZUNvbmZpZ1Byb3AocGdFZGdlLCAnZWRnZScsICdjb2xvcicpO1xuICAgIGxldCBvcGFjaXR5ID0gcGFyc2VGbG9hdCh0aGlzLnJldHJpZXZlQ29uZmlnUHJvcChwZ0VkZ2UsICdlZGdlJywgJ29wYWNpdHknKSkgfHwgMTtcbiAgICBsZXQgd2lkdGggPSBwYXJzZUZsb2F0KHRoaXMucmV0cmlldmVDb25maWdQcm9wKHBnRWRnZSwgJ2VkZ2UnLCd3aWR0aCcpKTtcbiAgICBsZXQgdG9vbHRpcCAgPSB0aGlzLnJldHJpZXZlQ29uZmlnUHJvcChwZ0VkZ2UsICdlZGdlJywgJ3RpdGxlJyk7XG5cbiAgICBjb2xvciA9IGNvbG9yIHx8IHRoaXMuZWRnZUNvbG9yTWFwW2VkZ2VMYWJlbF07XG5cbiAgICBpZihvcGFjaXR5IDwgMSkge1xuICAgICAgbGV0IHJnYiA9IHRoaXMuZ2V0SGV4Q29sb3JzKGNvbG9yKTtcbiAgICAgIGNvbG9yID0gYHJnYmEoJHtyZ2JbMF19LCAke3JnYlsxXX0sICR7cmdiWzJdfSwgJHtvcGFjaXR5fSlgO1xuICAgIH1cbiAgICBcbiAgICBsZXQgYXR0cnMgPSB7XG4gICAgICBpZDogaWQsXG4gICAgICBmcm9tOiBwZ0VkZ2UuZnJvbSxcbiAgICAgIHRvOiBwZ0VkZ2UudG8sXG4gICAgICBjb2xvcjogY29sb3IsXG4gICAgICBsYWJlbDogY3JlYXRlTGFiZWxUZXh0KHBnRWRnZSwgcHJvcHMpLFxuICAgICAgX3RpdGxlOiB0b29sdGlwICE9IG51bGwgPyB0b29sdGlwIDogdGhpcy5jcmVhdGVUaXRsZShwZ0VkZ2UpLFxuICAgICAgcmVtb3RlSWQ6IGlkLFxuICAgICAgd2lkdGg6IHdpZHRoIHx8IGRlZmF1bHRXaWR0aCxcbiAgICAgIGhvdmVyV2lkdGg6IDAuNSxcbiAgICAgIHNtb290aDogdGhpcy5tYXAgPyBmYWxzZSA6IHsgcm91bmRuZXNzOiAxIH0sXG4gICAgICBjaG9zZW46IHRoaXMucmV0cmlldmVDb25maWdQcm9wKHBnRWRnZSwgJ2VkZ2UnLCAnY2hvc2VuJyksXG4gICAgICBhcnJvd3M6IHtcbiAgICAgICAgdG86IHtcbiAgICAgICAgICBlbmFibGVkOiBwZ0VkZ2UuZGlyZWN0aW9uID09ICctPicgfHwgcGdFZGdlLnVuZGlyZWN0ZWQgPT09ICdmYWxzZSdcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IG90aGVyUHJvcHMgPSB0aGlzLnJldHJpZXZlQ29uZmlnUHJvcEFsbChwZ0VkZ2UsXG4gICAgICAnZWRnZScsIFsnY29sb3InLCAnb3BhY2l0eScsICd3aWR0aCcsICd0aXRsZSddKTtcblxuICAgIGZvcihsZXQga2V5IG9mIE9iamVjdC5rZXlzKG90aGVyUHJvcHMpKSB7XG4gICAgICBhdHRyc1trZXldID0gb3RoZXJQcm9wc1trZXldIHx8IGF0dHJzW2tleV07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBhdHRycztcbiAgfVxuICBcbiAgaW5jbHVkZXNOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5ncmFwaC5ub2Rlcy5maWx0ZXIoZSA9PiBlLmlkID09PSBub2RlLmlkKS5sZW5ndGggPiAwO1xuICB9XG4gIFxuICBhZGROb2RlKG5vZGUsIHVwZGF0ZSA9IHRydWUpIHtcbiAgICB0aGlzLmFkZE5vZGVzKFtub2RlXSwgdXBkYXRlKTtcbiAgfVxuICBcbiAgYWRkTm9kZXMobm9kZXMsIHVwZGF0ZSA9IHRydWUpIHtcbiAgICBsZXQgbmV3Tm9kZXM7XG4gICAgaWYgKHR5cGVvZiBub2RlcyA9PT0gJ3N0cmluZycgfHwgbm9kZXMgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIGxldCBwZyA9IHRoaXMudHJ5UGdQYXJzZShub2Rlcyk7XG4gICAgICBuZXdOb2RlcyA9IHBnLm5vZGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdOb2RlcyA9IG5vZGVzO1xuICAgIH1cbiAgICBuZXdOb2RlcyA9IG5ld05vZGVzLmZpbHRlcihub2RlID0+ICF0aGlzLmluY2x1ZGVzTm9kZShub2RlKSkubWFwKChub2RlKSA9PiB7XG4gICAgICBsZXQgbWFwcGVkID0gZGVlcE1lcmdlKEJsaXR6Ym9hcmQubm9kZVRlbXBsYXRlLCBub2RlKTtcbiAgICAgICsrdGhpcy5tYXhMaW5lO1xuICAgICAgbWFwcGVkLmxvY2F0aW9uID0ge1xuICAgICAgICBzdGFydDoge1xuICAgICAgICAgIGxpbmU6IHRoaXMubWF4TGluZSxcbiAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgIGxpbmU6IHRoaXMubWF4TGluZSArIDEsXG4gICAgICAgICAgY29sdW1uOiAwLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwcGVkO1xuICAgIH0pO1xuICAgIHRoaXMuZ3JhcGgubm9kZXMgPSB0aGlzLmdyYXBoLm5vZGVzLmNvbmNhdChuZXdOb2Rlcyk7XG4gICAgZm9yKGxldCBjYWxsYmFjayBvZiB0aGlzLm9uTm9kZUFkZGVkKSB7XG4gICAgICAvLyBUT0RPOiBUaGUgYXJndW1lbnQgc2hvdWxkIGJlIHByb3h5IGluc3RlYWQgb2YgcGxhaW4gb2JqZWN0c1xuICAgICAgY2FsbGJhY2sobmV3Tm9kZXMpO1xuICAgIH1cbiAgICBpZih1cGRhdGUpXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIFxuICBhZGRFZGdlKGVkZ2UsIHVwZGF0ZSA9IHRydWUpIHtcbiAgICB0aGlzLmFkZEVkZ2VzKFtlZGdlXSwgdXBkYXRlKTtcbiAgfVxuICBcbiAgaGlnaGxpZ2h0Tm9kZVBhdGgobm9kZXMpIHtcbiAgICBsZXQgbm9kZUlkcyA9IG5vZGVzO1xuICAgIGlmKG5vZGVzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIG5vZGVzWzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgbm9kZUlkcyA9IG5vZGVzLm1hcCgobikgPT4gbi5pZCk7XG4gICAgfVxuICAgIGxldCBlZGdlSWRzID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IG5vZGVJZHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBlZGdlSWRzLnB1c2goYCR7bm9kZUlkc1tpXX0ke0JsaXR6Ym9hcmQuZWRnZURlbGltaXRlcn0ke25vZGVJZHNbaSArIDFdfWApO1xuICAgIH1cbiAgICB0aGlzLm5ldHdvcmsuc2VsZWN0RWRnZXMoZWRnZUlkcyk7XG4gIH1cblxuICBhZGRFZGdlcyhlZGdlcywgdXBkYXRlID0gdHJ1ZSkge1xuICAgIGxldCBuZXdFZGdlcztcbiAgICBpZiAodHlwZW9mIGVkZ2VzID09PSAnc3RyaW5nJyB8fCBlZGdlcyBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgbGV0IHBnID0gdGhpcy50cnlQZ1BhcnNlKGVkZ2VzKTtcbiAgICAgIG5ld0VkZ2VzID0gcGcuZWRnZXNcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RWRnZXMgPSBlZGdlc1xuICAgIH1cbiAgICBuZXdFZGdlcyA9IG5ld0VkZ2VzLm1hcCgoZWRnZSkgPT4ge1xuICAgICAgbGV0IG1hcHBlZCA9IGRlZXBNZXJnZShCbGl0emJvYXJkLmVkZ2VUZW1wbGF0ZSwgZWRnZSk7XG4gICAgICArK3RoaXMubWF4TGluZTtcbiAgICAgIG1hcHBlZC5sb2NhdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICBsaW5lOiB0aGlzLm1heExpbmUsXG4gICAgICAgICAgY29sdW1uOiAwLCBcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgbGluZTogdGhpcy5tYXhMaW5lICsgMSxcbiAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfSk7XG4gICAgdGhpcy5ncmFwaC5lZGdlcyA9IHRoaXMuZ3JhcGguZWRnZXMuY29uY2F0KG5ld0VkZ2VzKTtcbiAgICBmb3IobGV0IGNhbGxiYWNrIG9mIHRoaXMub25FZGdlQWRkZWQpIHtcbiAgICAgIC8vIFRPRE86IFRoZSBhcmd1bWVudCBzaG91bGQgYmUgcHJveHkgaW5zdGVhZCBvZiBwbGFpbiBvYmplY3RzXG4gICAgICBjYWxsYmFjayhuZXdFZGdlcyk7XG4gICAgfVxuICAgIGlmKHVwZGF0ZSlcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuXG4gIHRyeVBnUGFyc2UocGcpIHtcbiAgICBmb3IobGV0IGNhbGxiYWNrIG9mIHRoaXMuYmVmb3JlUGFyc2UpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcGdQYXJzZXIucGFyc2UocGcpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZm9yKGxldCBjYWxsYmFjayBvZiB0aGlzLm9uUGFyc2VFcnJvcikge1xuICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlVGl0bGUoZWxlbSkge1xuICAgIGxldCBmbGF0dGVuZF9wcm9wcyA9IE9iamVjdC5lbnRyaWVzKGVsZW0ucHJvcGVydGllcykucmVkdWNlKChhY2MsIHByb3ApID0+XG4gICAgICBhY2MuY29uY2F0KGA8dHIgdmFsaWduPVwidG9wXCI+PHRkPiR7cHJvcFswXX08L3RkPjx0ZD4gJHtjb252ZXJ0VG9IeXBlckxpbmtJZlVSTChwcm9wWzFdKX08L3RkPjwvdHI+YCksIFtdKTtcbiAgICBpZiAoIWVsZW0uZnJvbSkgLy8gZm9yIG5vZGVzXG4gICAge1xuICAgICAgbGV0IGlkVGV4dCA9IGA8dHI+PHRkPjxiPiR7ZWxlbS5pZH08L2I+PC90ZD48dGQ+IDxiPiR7d3JhcFRleHQoZWxlbS5sYWJlbHMubWFwKChsKSA9PiAnOicgKyBsKS5qb2luKCcgJyksIHRydWUpfTwvYj48L3RkPjwvdHI+YDtcbiAgICAgIGZsYXR0ZW5kX3Byb3BzLnNwbGljZSgwLCAwLCBpZFRleHQpO1xuICAgIH0gZWxzZSBpZihlbGVtLmxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgaWRUZXh0ID0gYDx0cj48dGQ+PGI+JHt3cmFwVGV4dChlbGVtLmxhYmVscy5tYXAoKGwpID0+ICc6JyArIGwpLmpvaW4oJyAnKSwgdHJ1ZSl9IDwvYj48L3RkPjx0ZD48L3RkPjwvdHI+YDtcbiAgICAgIGZsYXR0ZW5kX3Byb3BzLnNwbGljZSgwLCAwLCBpZFRleHQpO1xuICAgIH1cbiAgICBpZiAoZmxhdHRlbmRfcHJvcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGA8dGFibGUgc3R5bGU9J2ZpeGVkJz4ke2ZsYXR0ZW5kX3Byb3BzLmpvaW4oJycpfTwvdGFibGU+YDtcbiAgfVxuXG5cblxuICBzZXRHcmFwaChpbnB1dCwgdXBkYXRlID0gdHJ1ZSkge1xuICAgIHRoaXMubm9kZUNvbG9yTWFwID0ge307XG4gICAgdGhpcy5lZGdlQ29sb3JNYXAgPSB7fTtcbiAgICB0aGlzLnByZXZNb3VzZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgbGV0IG5ld1BnO1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgIG5ld1BnID0gdGhpcy50cnlQZ1BhcnNlKCcnKTsgLy8gU2V0IGVtcHR5IHBnXG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ld1BnID0gSlNPTi5wYXJzZShpbnB1dCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFN5bnRheEVycm9yKVxuICAgICAgICAgIG5ld1BnID0gdGhpcy50cnlQZ1BhcnNlKGlucHV0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3UGcgPSBpbnB1dDtcbiAgICB9XG4gICAgaWYgKG5ld1BnID09PSBudWxsIHx8IG5ld1BnID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5ncmFwaCA9IG5ld1BnO1xuXG4gICAgaWYodXBkYXRlKVxuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG5cblxuICBzZXRDb25maWcoY29uZmlnLCB1cGRhdGUgPSB0cnVlKSB7XG4gICAgdGhpcy5jb25maWcgPSBkZWVwTWVyZ2UoQmxpdHpib2FyZC5kZWZhdWx0Q29uZmlnLCBjb25maWcpO1xuICAgIGlmKGNvbmZpZy5sYXlvdXQgPT09ICdoaWVyYXJjaGljYWwnKSB7XG4gICAgICAvLyBSZW1vdmUgcmVkdW5kYW50IHNldHRpbmdzIHdoZW4gbGF5b3V0IGlzIGhpZXJhcmNoaWNhbFxuICAgICAgdGhpcy5jb25maWcubGF5b3V0U2V0dGluZ3MgPSBjb25maWcubGF5b3V0U2V0dGluZ3M7XG4gICAgfVxuICAgIGlmKHVwZGF0ZSlcbiAgICAgIHRoaXMudXBkYXRlKGZhbHNlKTtcbiAgfVxuICBcbiAgdmFsaWRhdGVHcmFwaCgpIHtcbiAgICAvLyBJZiBkdXBsaWNhdGlvbiBvZiBub2RlcyBleGlzdCwgcmFpc2UgZXJyb3IgXG4gICAgZnVuY3Rpb24gbm9udW5pcXVlTm9kZXMobm9kZXMpIHtcbiAgICAgIGxldCBub251bmlxdWUgPSBuZXcgU2V0KCk7XG4gICAgICBsZXQgbm9kZU1hcCA9IHt9IC8vIGlkIC0+IG5vZGVcbiAgICAgIGZvcihsZXQgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICBpZihub2RlTWFwW25vZGUuaWRdKSB7XG4gICAgICAgICAgbm9udW5pcXVlLmFkZChub2RlTWFwW25vZGUuaWRdKTtcbiAgICAgICAgICBub251bmlxdWUuYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVNYXBbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsuLi5ub251bmlxdWVdO1xuICAgIH1cblxuICAgIGxldCBub251bmlxdWUgPSBub251bmlxdWVOb2Rlcyh0aGlzLmdyYXBoLm5vZGVzKTtcbiAgICBpZihub251bmlxdWUubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IER1cGxpY2F0ZU5vZGVFcnJvcihub251bmlxdWUpO1xuICAgIH1cbiAgICBcbiAgICBpZih0aGlzLmdyYXBoLm5vZGVzLmxlbmd0aCA+PSB0aGlzLmNvbmZpZy5ub2RlLmxpbWl0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBudW1iZXIgb2Ygbm9kZXMgZXhjZWVkcyB0aGUgY3VycmVudCBsaW1pdDogJHt0aGlzLmNvbmZpZy5ub2RlLmxpbWl0fS4gYCArXG4gICAgICAgIGBZb3UgY2FuIGNoYW5nZSBpdCB2aWEgbm9kZS5saW1pdCBpbiB5b3VyIGNvbmZpZy5gKTtcbiAgICB9XG5cbiAgICBpZih0aGlzLmdyYXBoLmVkZ2VzLmxlbmd0aCA+PSB0aGlzLmNvbmZpZy5lZGdlLmxpbWl0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBudW1iZXIgb2YgZWRnZXMgZXhjZWVkcyB0aGUgY3VycmVudCBsaW1pdDogJHt0aGlzLmNvbmZpZy5lZGdlLmxpbWl0fS4gYCArXG4gICAgICAgIGBZb3UgY2FuIGNoYW5nZSBpdCB2aWEgZWRnZS5saW1pdCBpbiB5b3VyIGNvbmZpZy5gKTtcbiAgICB9XG5cbiAgICAvLyBJZiBlZGdlIHJlZmVycyB0byB1bmRlZmluZWQgbm9kZXMsIGNyZWF0ZSB3YXJuaW5nc1xuICAgIGZvcihsZXQgZWRnZSBvZiB0aGlzLmdyYXBoLmVkZ2VzKSB7XG4gICAgICBpZighdGhpcy5ub2RlTWFwW2VkZ2UuZnJvbV0pIHtcbiAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgICBsb2NhdGlvbjogZWRnZS5sb2NhdGlvbixcbiAgICAgICAgICBtZXNzYWdlOiBgU291cmNlIG5vZGUgaXMgdW5kZWZpbmVkOiAke2VkZ2UuZnJvbX1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYoIXRoaXMubm9kZU1hcFtlZGdlLnRvXSkge1xuICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2goe1xuICAgICAgICAgIGxvY2F0aW9uOiBlZGdlLmxvY2F0aW9uLFxuICAgICAgICAgIG1lc3NhZ2U6IGBUYXJnZXQgbm9kZSBpcyB1bmRlZmluZWQ6ICR7ZWRnZS50b31gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgdXBkYXRlKGFwcGx5RGlmZiA9IHRydWUpIHtcbiAgICBsZXQgYmxpdHpib2FyZCA9IHRoaXM7XG4gICAgdGhpcy53YXJuaW5ncyA9IFtdO1xuICAgIGFwcGx5RGlmZiA9IGFwcGx5RGlmZiAmJiB0aGlzLm5vZGVEYXRhU2V0ICYmIHRoaXMuZWRnZURhdGFTZXQ7XG4gICAgXG4gICAgaWYodGhpcy5jb25maWcuc3R5bGUgJiYgdGhpcy5jb25maWcubGF5b3V0ICE9PSAnbWFwJykge1xuICAgICAgdGhpcy5uZXR3b3JrQ29udGFpbmVyLnN0eWxlID0gdGhpcy5uZXR3b3JrQ29udGFpbmVyT3JpZ2luYWxTdHlsZSArICcgJyArIHRoaXMuY29uZmlnLnN0eWxlO1xuICAgIH1cblxuICAgIGlmKGFwcGx5RGlmZikge1xuICAgICAgbGV0IG5vZGVzVG9EZWxldGUgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMubm9kZU1hcCkpO1xuICAgICAgbGV0IG5ld0VkZ2VNYXAgPSB7fTtcblxuICAgICAgdGhpcy5ub2RlTGluZU1hcCA9IHt9O1xuICAgICAgdGhpcy5lZGdlTGluZU1hcCA9IHt9O1xuICAgICAgdGhpcy5tYXhMaW5lID0gMDtcbiAgICAgIHRoaXMuZ3JhcGgubm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgbGV0IGV4aXN0aW5nTm9kZSA9IHRoaXMubm9kZU1hcFtub2RlLmlkXTtcbiAgICAgICAgaWYoZXhpc3RpbmdOb2RlKSB7XG4gICAgICAgICAgaWYoIW5vZGVFcXVhbHMobm9kZSwgZXhpc3RpbmdOb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlRGF0YVNldC5yZW1vdmUoZXhpc3RpbmdOb2RlKTtcbiAgICAgICAgICAgIGxldCB2aXNOb2RlID0gdGhpcy50b1Zpc05vZGUobm9kZSwgdGhpcy5jb25maWcubm9kZS5jYXB0aW9uKTtcbiAgICAgICAgICAgIHRoaXMubm9kZURhdGFTZXQudXBkYXRlKHZpc05vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgdmlzTm9kZSA9IHRoaXMudG9WaXNOb2RlKG5vZGUsIHRoaXMuY29uZmlnLm5vZGUuY2FwdGlvbik7XG4gICAgICAgICAgdGhpcy5ub2RlRGF0YVNldC5hZGQodmlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlTWFwW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgbm9kZXNUb0RlbGV0ZS5kZWxldGUobm9kZS5pZCk7XG4gICAgICAgIGlmKG5vZGUubG9jYXRpb24pIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gbm9kZS5sb2NhdGlvbi5zdGFydC5saW5lOyBpIDw9IG5vZGUubG9jYXRpb24uZW5kLmxpbmU7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCBub2RlLmxvY2F0aW9uLmVuZC5saW5lIHx8IG5vZGUubG9jYXRpb24uZW5kLmNvbHVtbiA+IDEpXG4gICAgICAgICAgICAgIHRoaXMubm9kZUxpbmVNYXBbaV0gPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm1heExpbmUgPSBNYXRoLm1heCh0aGlzLm1heExpbmUsIG5vZGUubG9jYXRpb24uZW5kLmxpbmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5ncmFwaC5lZGdlcy5mb3JFYWNoKGVkZ2UgPT4ge1xuICAgICAgICBsZXQgaWQgPSB0aGlzLnRvTm9kZVBhaXJTdHJpbmcoZWRnZSk7XG4gICAgICAgIHdoaWxlKG5ld0VkZ2VNYXBbaWRdKSB7XG4gICAgICAgICAgaWQgKz0gJ18nO1xuICAgICAgICB9XG4gICAgICAgIGVkZ2UuaWQgPSBpZDtcbiAgICAgICAgbmV3RWRnZU1hcFtpZF0gPSBlZGdlO1xuICAgICAgICBsZXQgdmlzRWRnZSA9IHRoaXMudG9WaXNFZGdlKGVkZ2UsIHRoaXMuY29uZmlnLmVkZ2UuY2FwdGlvbiwgaWQpO1xuICAgICAgICB0aGlzLmVkZ2VEYXRhU2V0LnVwZGF0ZSh2aXNFZGdlKTtcbiAgICAgICAgaWYoZWRnZS5sb2NhdGlvbikge1xuICAgICAgICAgIGZvciAobGV0IGkgPSBlZGdlLmxvY2F0aW9uLnN0YXJ0LmxpbmU7IGkgPD0gZWRnZS5sb2NhdGlvbi5lbmQubGluZTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IGVkZ2UubG9jYXRpb24uZW5kLmxpbmUgfHwgZWRnZS5sb2NhdGlvbi5lbmQuY29sdW1uID4gMSlcbiAgICAgICAgICAgICAgdGhpcy5lZGdlTGluZU1hcFtpXSA9IHZpc0VkZ2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubWF4TGluZSA9IE1hdGgubWF4KHRoaXMubWF4TGluZSwgZWRnZS5sb2NhdGlvbi5lbmQubGluZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBub2Rlc1RvRGVsZXRlLmZvckVhY2goKG5vZGVJZCkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5ub2RlTWFwW25vZGVJZF07XG4gICAgICB9KTtcbiAgICAgIHRoaXMubm9kZURhdGFTZXQucmVtb3ZlKFsuLi5ub2Rlc1RvRGVsZXRlXSk7XG5cbiAgICAgIGxldCBlZGdlc1RvRGVsZXRlID0gW107XG4gICAgICBmb3IobGV0IGVkZ2VJZCBvZiBPYmplY3Qua2V5cyh0aGlzLmVkZ2VNYXApKSB7XG4gICAgICAgIGlmKCFuZXdFZGdlTWFwW2VkZ2VJZF0pIHtcbiAgICAgICAgICBlZGdlc1RvRGVsZXRlLnB1c2goZWRnZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5lZGdlRGF0YVNldC5yZW1vdmUoZWRnZXNUb0RlbGV0ZSk7XG4gICAgICB0aGlzLmVkZ2VNYXAgPSBuZXdFZGdlTWFwO1xuICAgICAgaWYodGhpcy5tYXApIHtcbiAgICAgICAgYmxpdHpib2FyZC51cGRhdGVOb2RlTG9jYXRpb25Pbk1hcCgpO1xuICAgICAgfVxuICAgICAgaWYodGhpcy5jb25maWcubGF5b3V0ID09PSAndGltZWxpbmUnKSB7XG4gICAgICAgIGJsaXR6Ym9hcmQudXBkYXRlTm9kZUxvY2F0aW9uT25UaW1lTGluZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aGlzLnByZXZab29tUG9zaXRpb24gPSBudWxsO1xuICAgIFxuICAgIHRoaXMubWluVGltZSA9IG5ldyBEYXRlKDg2NDAwMDAwMDAwMDAwMDApO1xuICAgIHRoaXMubWF4VGltZSA9IG5ldyBEYXRlKC04NjQwMDAwMDAwMDAwMDAwKTtcbiAgICBcbiAgICBpZih0aGlzLmNvbmZpZy5sYXlvdXQgPT09ICd0aW1lbGluZScpIHtcbiAgICAgIGxldCBmcm9tUHJvcCA9IHRoaXMuY29uZmlnLmxheW91dFNldHRpbmdzLnRpbWVfZnJvbTtcbiAgICAgIGxldCB0b1Byb3AgPSB0aGlzLmNvbmZpZy5sYXlvdXRTZXR0aW5ncy50aW1lX3RvO1xuICAgICAgXG4gICAgICB0aGlzLmdyYXBoLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIGZvciAobGV0IHByb3Agb2YgT2JqZWN0LmtleXMobm9kZS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgIGlmIChwcm9wID09PSBmcm9tUHJvcCB8fCBwcm9wID09PSB0b1Byb3ApIHtcbiAgICAgICAgICAgIHRoaXMubWluVGltZSA9IG5ldyBEYXRlKE1hdGgubWluKHRoaXMubWluVGltZSwgbmV3IERhdGUobm9kZS5wcm9wZXJ0aWVzW3Byb3BdWzBdKSkpO1xuICAgICAgICAgICAgdGhpcy5tYXhUaW1lID0gbmV3IERhdGUoTWF0aC5tYXgodGhpcy5tYXhUaW1lLCBuZXcgRGF0ZShub2RlLnByb3BlcnRpZXNbcHJvcF1bMF0pKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMudGltZUludGVydmFsID0gdGhpcy5tYXhUaW1lIC0gdGhpcy5taW5UaW1lO1xuICAgIH1cblxuXG4gICAgaWYoYXBwbHlEaWZmKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlR3JhcGgoKTtcblxuICAgICAgZm9yKGxldCBjYWxsYmFjayBvZiB0aGlzLm9uVXBkYXRlZCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubm9kZVByb3BzID0gbmV3IFNldChbJ2lkJywgJ2xhYmVsJ10pO1xuICAgIHRoaXMuZWRnZVByb3BzID0gbmV3IFNldChbJ2xhYmVsJ10pO1xuICAgIHRoaXMuZ3JhcGgubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgdGhpcy5ub2RlTWFwW25vZGUuaWRdID0gbm9kZTtcbiAgICAgIGlmKG5vZGUubG9jYXRpb24pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGUubG9jYXRpb24uc3RhcnQubGluZTsgaSA8PSBub2RlLmxvY2F0aW9uLmVuZC5saW5lOyBpKyspXG4gICAgICAgICAgaWYgKGkgPCBub2RlLmxvY2F0aW9uLmVuZC5saW5lIHx8IG5vZGUubG9jYXRpb24uZW5kLmNvbHVtbiA+IDEpXG4gICAgICAgICAgICB0aGlzLm5vZGVMaW5lTWFwW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5rZXlzKG5vZGUucHJvcGVydGllcykuZmlsdGVyKChwcm9wKSA9PiBwcm9wICE9ICdkZWdyZWUnKS5mb3JFYWNoKHRoaXMubm9kZVByb3BzLmFkZCwgdGhpcy5ub2RlUHJvcHMpO1xuICAgIH0pO1xuICAgIHRoaXMuZ3JhcGguZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgT2JqZWN0LmtleXMoZWRnZS5wcm9wZXJ0aWVzKS5mb3JFYWNoKHRoaXMuZWRnZVByb3BzLmFkZCwgdGhpcy5lZGdlUHJvcHMpO1xuICAgIH0pO1xuXG4gICAgdGhpcy52YWxpZGF0ZUdyYXBoKCk7XG5cblxuICAgIGxldCBkZWZhdWx0Tm9kZVByb3BzID0gdGhpcy5jb25maWcubm9kZS5jYXB0aW9uO1xuICAgIGxldCBkZWZhdWx0RWRnZVByb3BzID0gdGhpcy5jb25maWcuZWRnZS5jYXB0aW9uO1xuXG4gICAgdGhpcy5ub2RlRGF0YVNldCA9IG5ldyB2aXNEYXRhLkRhdGFTZXQoKTtcbiAgICB0aGlzLm5vZGVEYXRhU2V0LmFkZCh0aGlzLmdyYXBoLm5vZGVzLm1hcCgobm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMudG9WaXNOb2RlKG5vZGUsIGRlZmF1bHROb2RlUHJvcHMpO1xuICAgIH0pKTtcbiAgICBcbiAgICB0aGlzLmVkZ2VNYXAgPSB7fTtcbiAgICB0aGlzLmVkZ2VEYXRhU2V0ID0gbmV3IHZpc0RhdGEuRGF0YVNldCh0aGlzLmdyYXBoLmVkZ2VzLm1hcCgoZWRnZSkgPT4ge1xuICAgICAgbGV0IGlkID0gdGhpcy50b05vZGVQYWlyU3RyaW5nKGVkZ2UpO1xuICAgICAgd2hpbGUodGhpcy5lZGdlTWFwW2lkXSkge1xuICAgICAgICBpZCArPSAnXyc7XG4gICAgICB9XG4gICAgICBsZXQgdmlzRWRnZSA9IHRoaXMudG9WaXNFZGdlKGVkZ2UsIGRlZmF1bHRFZGdlUHJvcHMsIGlkKTtcbiAgICAgIHRoaXMuZWRnZU1hcFt2aXNFZGdlLmlkXSA9IGVkZ2U7XG4gICAgICBpZihlZGdlLmxvY2F0aW9uKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBlZGdlLmxvY2F0aW9uLnN0YXJ0LmxpbmU7IGkgPD0gZWRnZS5sb2NhdGlvbi5lbmQubGluZTsgaSsrKVxuICAgICAgICAgIGlmIChpIDwgZWRnZS5sb2NhdGlvbi5lbmQubGluZSB8fCBlZGdlLmxvY2F0aW9uLmVuZC5jb2x1bW4gPiAxKVxuICAgICAgICAgICAgdGhpcy5lZGdlTGluZU1hcFtpXSA9IHZpc0VkZ2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aXNFZGdlO1xuICAgIH0pKTtcblxuXG5cbiAgICAvLyBjcmVhdGUgYSBuZXR3b3JrXG4gICAgbGV0IGRhdGEgPSB7XG4gICAgICBub2RlczogdGhpcy5ub2RlRGF0YVNldCxcbiAgICAgIGVkZ2VzOiB0aGlzLmVkZ2VEYXRhU2V0XG4gICAgfTtcblxuICAgIGxldCBsYXlvdXQgPSB7XG4gICAgICByYW5kb21TZWVkOiAxXG4gICAgfTtcblxuICAgIGlmKHRoaXMuY29uZmlnLmxheW91dCA9PT0gJ2hpZXJhcmNoaWNhbCcpIHtcbiAgICAgIGxheW91dC5oaWVyYXJjaGljYWwgPSB0aGlzLmNvbmZpZy5sYXlvdXRTZXR0aW5ncztcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5b3V0LmhpZXJhcmNoaWNhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGxheW91dDpcbiAgICAgICAgbGF5b3V0LFxuICAgICAgaW50ZXJhY3Rpb246IHtcbiAgICAgICAgZHJhZ05vZGVzOiB0aGlzLmNvbmZpZy5sYXlvdXQgIT09ICdtYXAnLFxuICAgICAgICBkcmFnVmlldzogdGhpcy5jb25maWcubGF5b3V0ICE9PSAnbWFwJyxcbiAgICAgICAgem9vbVZpZXc6IHRoaXMuY29uZmlnLmxheW91dCAhPT0gJ21hcCcsXG4gICAgICAgIGhvdmVyOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHBoeXNpY3M6IHtcbiAgICAgICAgZW5hYmxlZDogdGhpcy5jb25maWcubGF5b3V0ICE9PSAnbWFwJyAmJiB0aGlzLmNvbmZpZy5sYXlvdXQgIT09ICdoaWVyYXJjaGljYWwnLFxuICAgICAgICBiYXJuZXNIdXQ6IHtcbiAgICAgICAgICBzcHJpbmdDb25zdGFudDogIHRoaXMuY29uZmlnLmxheW91dCA9PT0gJ3RpbWVsaW5lJyA/IDAuMDA0IDogMC4wMTZcbiAgICAgICAgfSxcbiAgICAgICAgc3RhYmlsaXphdGlvbjoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIGl0ZXJhdGlvbnM6IDIwMCxcbiAgICAgICAgICB1cGRhdGVJbnRlcnZhbDogMjVcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1hbmlwdWxhdGlvbjogZmFsc2UsXG5cbiAgICAgIGVkZ2VzOiB7XG4gICAgICAgIGFycm93czoge1xuICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgc2NhbGVGYWN0b3I6IDAuMyxcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyb3dcIlxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgdGhpcy5jb25maWcuZXh0cmFPcHRpb25zKTtcbiAgICB0aGlzLm5ldHdvcmsgPSBuZXcgdmlzTmV0d29yay5OZXR3b3JrKHRoaXMubmV0d29ya0NvbnRhaW5lciwgZGF0YSwgdGhpcy5vcHRpb25zKTtcblxuICAgIGlmKHRoaXMuY29uZmlnLmxheW91dCA9PT0gJ21hcCcpIHtcbiAgICAgIHRoaXMubWFwQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgdGhpcy5uZXR3b3JrQ29udGFpbmVyLnN0eWxlLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgbGV0IHN0YXRpc3RpY3MgPSBzdGF0aXN0aWNzT2ZNYXAoKTtcbiAgICAgIGxldCBjZW50ZXIgPSB0aGlzLmNvbmZpZz8ubGF5b3V0U2V0dGluZ3M/LmNlbnRlciB8fCBzdGF0aXN0aWNzLmNlbnRlcjtcbiAgICAgIGlmKHRoaXMubWFwKSB7XG4gICAgICAgIHRoaXMubWFwLnBhblRvKGNlbnRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1hcCA9IEwubWFwKHRoaXMubWFwQ29udGFpbmVyLCB7XG4gICAgICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICAgICAgem9vbTogc3RhdGlzdGljcy5zY2FsZSxcbiAgICAgICAgICBtaW5ab29tOiAzLFxuICAgICAgICAgIHpvb21TbmFwOiAwLjAxLFxuICAgICAgICAgIHpvb21Db250cm9sOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0aWxlTGF5ZXIgPSBMLnRpbGVMYXllcignaHR0cHM6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmcnLCB7XG4gICAgICAgICAgYXR0cmlidXRpb246ICfCqSA8YSBocmVmPVwiaHR0cDovL29zbS5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzLCA8YSBocmVmPVwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktc2EvMi4wL1wiPkNDLUJZLVNBPC9hPicsXG4gICAgICAgIH0pO1xuICAgICAgICB0aWxlTGF5ZXIuYWRkVG8odGhpcy5tYXApO1xuXG4gICAgICAgIHRoaXMubWFwLm9uKCdtb3ZlJywgKCkgPT4gYmxpdHpib2FyZC51cGRhdGVOb2RlTG9jYXRpb25Pbk1hcCgpKTtcbiAgICAgICAgdGhpcy5tYXAub24oJ3pvb20nLCAoKSA9PiBibGl0emJvYXJkLnVwZGF0ZU5vZGVMb2NhdGlvbk9uTWFwKCkpO1xuICAgICAgfVxuICAgICAgYmxpdHpib2FyZC5uZXR3b3JrLm1vdmVUbyh7c2NhbGU6IDEuMH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1hcENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgaWYodGhpcy5tYXApIHtcbiAgICAgICAgdGhpcy5tYXAucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hcCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5uZXR3b3JrLmNhbnZhcy5ib2R5LmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgIC8vIEtleSAwXG4gICAgICBpZihlLmtleUNvZGUgPT09IDQ4KVxuICAgICAgICBibGl0emJvYXJkLm5ldHdvcmsuZml0KHthbmltYXRpb246IHRydWV9KTtcbiAgICB9KTtcblxuXG4gICAgdGhpcy5uZXR3b3JrLm9uKCd6b29tJywgKGUpID0+IHtcbiAgICAgIGJsaXR6Ym9hcmQudXBkYXRlVG9vbHRpcExvY2F0aW9uKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm5ldHdvcmsub24oJ3Jlc2l6ZScsIChlKSA9PiB7XG4gICAgICBpZihibGl0emJvYXJkLmNvbmZpZy5sYXlvdXQgPT09ICdtYXAnKSB7XG4gICAgICAgIC8vIEZpeCBzY2FsZSB0byAxLjAgKGRlbGF5IGlzIG5lZWRlZCB0byBvdmVycmlkZSBzY2FsZSBzZXQgYnkgdmlzLW5ldHdvcmspICBcbiAgICAgICAgbGV0IG5ld1NjYWxlID0gTWF0aC5taW4oQmxpdHpib2FyZC5tYXhTY2FsZU9uTWFwLCBNYXRoLm1heChibGl0emJvYXJkLm5ldHdvcmsuZ2V0U2NhbGUoKSwgQmxpdHpib2FyZC5taW5TY2FsZU9uTWFwKSk7XG4gICAgICAgIHNldFRpbWVvdXQoICgpID0+IHtcbiAgICAgICAgICBibGl0emJvYXJkLm5ldHdvcmsubW92ZVRvKHtzY2FsZTogbmV3U2NhbGV9KTtcbiAgICAgICAgICBibGl0emJvYXJkLnVwZGF0ZU5vZGVMb2NhdGlvbk9uTWFwKCk7XG4gICAgICAgIH0sIDEwKTsgXG4gICAgICAgIGJsaXR6Ym9hcmQubWFwLmludmFsaWRhdGVTaXplKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG5cbiAgICB0aGlzLm5ldHdvcmsub24oJ2RyYWdTdGFydCcsIChlKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlRGF0YVNldC5nZXQoZS5ub2Rlc1swXSk7XG4gICAgICBpZihlLm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5ub2RlRGF0YVNldC51cGRhdGUoe1xuICAgICAgICAgIGlkOiBlLm5vZGVzWzBdLFxuICAgICAgICAgIGZpeGVkOiBub2RlLmZpeGVkQnlUaW1lID8ge3g6IHRydWUsIHk6IHRydWUgfSA6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuXG4gICAgZnVuY3Rpb24gc3RhdGlzdGljc09mTWFwKCkge1xuICAgICAgbGV0IGxuZ0tleSA9ICBibGl0emJvYXJkLmNvbmZpZy5sYXlvdXRTZXR0aW5ncy5sbmc7XG4gICAgICBsZXQgbGF0S2V5ID0gIGJsaXR6Ym9hcmQuY29uZmlnLmxheW91dFNldHRpbmdzLmxhdDtcbiAgICAgIGxldCBsbmdTdW0gPSAwLCBsYXRTdW0gPSAwLCBjb3VudCA9IDAsXG4gICAgICAgIGxuZ01heCA9IE51bWJlci5NSU5fVkFMVUUsIGxuZ01pbiA9IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIGxhdE1heCA9IE51bWJlci5NSU5fVkFMVUUsIGxhdE1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICBibGl0emJvYXJkLmdyYXBoLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIGlmKG5vZGUucHJvcGVydGllc1tsYXRLZXldICYmIG5vZGUucHJvcGVydGllc1tsbmdLZXldKSB7XG4gICAgICAgICAgbGV0IGxuZyA9IHBhcnNlRmxvYXQobm9kZS5wcm9wZXJ0aWVzW2xuZ0tleV1bMF0pO1xuICAgICAgICAgIGxldCBsYXQgPSBwYXJzZUZsb2F0KG5vZGUucHJvcGVydGllc1tsYXRLZXldWzBdKTtcbiAgICAgICAgICBsbmdTdW0gKz0gbG5nO1xuICAgICAgICAgIGxhdFN1bSArPSBsYXQ7XG4gICAgICAgICAgbG5nTWF4ID0gTWF0aC5tYXgobG5nLCBsbmdNYXgpO1xuICAgICAgICAgIGxuZ01pbiA9IE1hdGgubWluKGxuZywgbG5nTWluKTtcbiAgICAgICAgICBsYXRNYXggPSBNYXRoLm1heChsYXQsIGxhdE1heCk7XG4gICAgICAgICAgbGF0TWluID0gTWF0aC5taW4obGF0LCBsYXRNaW4pO1xuICAgICAgICAgICsrY291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYoY291bnQgPT09IDApXG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjZW50ZXI6IFtsYXRTdW0gLyBjb3VudCwgbG5nU3VtIC8gY291bnRdLFxuICAgICAgICBzY2FsZTogTWF0aC5tYXgoIC1NYXRoLmxvZzIoTWF0aC5tYXgoTWF0aC5hYnMobG5nTWF4IC0gbG5nTWluKSwgTWF0aC5hYnMobGF0TWF4IC0gbGF0TWluKSkgLyAxMDAwKSwgMClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgXG4gICAgdGhpcy5uZXR3b3JrLm9uKFwiem9vbVwiLCBmdW5jdGlvbigpe1xuICAgICAgbGV0IHBvcyA9IGJsaXR6Ym9hcmQubmV0d29yay5nZXRWaWV3UG9zaXRpb24oKTtcbiAgICAgIGlmKGJsaXR6Ym9hcmQuY29uZmlnLnpvb20/Lm1pbiAmJiBibGl0emJvYXJkLm5ldHdvcmsuZ2V0U2NhbGUoKSA8IGJsaXR6Ym9hcmQuY29uZmlnLnpvb20ubWluKVxuICAgICAge1xuICAgICAgICBibGl0emJvYXJkLm5ldHdvcmsubW92ZVRvKHtcbiAgICAgICAgICBwb3NpdGlvbjogYmxpdHpib2FyZC5wcmV2Wm9vbVBvc2l0aW9uLFxuICAgICAgICAgIHNjYWxlOiBibGl0emJvYXJkLmNvbmZpZy56b29tPy5taW5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKGJsaXR6Ym9hcmQuY29uZmlnLnpvb20/Lm1heCAmJiBibGl0emJvYXJkLm5ldHdvcmsuZ2V0U2NhbGUoKSA+IGJsaXR6Ym9hcmQuY29uZmlnLnpvb20ubWF4KXtcbiAgICAgICAgYmxpdHpib2FyZC5uZXR3b3JrLm1vdmVUbyh7XG4gICAgICAgICAgcG9zaXRpb246IGJsaXR6Ym9hcmQucHJldlpvb21Qb3NpdGlvbixcbiAgICAgICAgICBzY2FsZTogYmxpdHpib2FyZC5jb25maWcuem9vbS5tYXgsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxpdHpib2FyZC5wcmV2Wm9vbVBvc2l0aW9uID0gcG9zO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGlmKHRoaXMubWFwKSB7XG4gICAgICB0aGlzLnVwZGF0ZU5vZGVMb2NhdGlvbk9uTWFwKCk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubmV0d29yay5vbihcImhvdmVyTm9kZVwiLCAoZSkgPT4ge1xuICAgICAgdGhpcy5uZXR3b3JrLmNhbnZhcy5ib2R5LmNvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlRGF0YVNldC5nZXQoZS5ub2RlKTtcbiAgICAgIGlmKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUudXJsKSB7XG4gICAgICAgICAgdGhpcy5uZXR3b3JrLmNhbnZhcy5ib2R5LmNvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgdGhpcy5ub2RlRGF0YVNldC51cGRhdGUoe1xuICAgICAgICAgICAgaWQ6IGUubm9kZSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzg4ODhmZicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLm5vZGUub25Ib3Zlcikge1xuICAgICAgICAgIHRoaXMuY29uZmlnLm5vZGUub25Ib3Zlcih0aGlzLmdldE5vZGUoZS5ub2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuZWxlbWVudFdpdGhUb29sdGlwID0ge1xuICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zaG93VG9vbHRpcCgpO1xuICAgICAgfSBlbHNlIGlmKG5vZGUgJiYgbm9kZS5kZWdyZWUgPiAxICYmICF0aGlzLmV4cGFuZGVkTm9kZXMuaW5jbHVkZXMoZS5ub2RlKSkge1xuICAgICAgICB0aGlzLm5ldHdvcmsuY2FudmFzLmJvZHkuY29udGFpbmVyLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMubmV0d29yay5vbihcImhvdmVyRWRnZVwiLCAoZSkgPT4ge1xuICAgICAgY29uc3QgZWRnZSA9IHRoaXMuZWRnZURhdGFTZXQuZ2V0KGUuZWRnZSk7XG4gICAgICBpZiAoZWRnZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRXaXRoVG9vbHRpcCA9IHtcbiAgICAgICAgICBlZGdlOiBlZGdlLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBlLmV2ZW50Lm9mZnNldFgsXG4gICAgICAgICAgICB5OiBlLmV2ZW50Lm9mZnNldFksXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNob3dUb29sdGlwKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm5ldHdvcmsub24oXCJzZWxlY3ROb2RlXCIsIChlKSA9PiB7XG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2Ugc2hvdyBmaXhlZCB0b29sdGlwIG9uIHNlbGVjdGlvbj9cbiAgICAgIC8vIGlmKCF0aGlzLm5ldHdvcmsuZ2V0U2VsZWN0ZWROb2RlcygpLmxlbmd0aCAmJiAhdGhpcy5uZXR3b3JrLmdldFNlbGVjdGVkRWRnZXMoKS5sZW5ndGgpIHtcbiAgICAgIC8vICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZURhdGFTZXQuZ2V0KGUubm9kZXNbMF0pO1xuICAgICAgLy8gICBpZiAobm9kZSkge1xuICAgICAgLy8gICAgIHRoaXMuZWxlbWVudFdpdGhUb29sdGlwID0ge1xuICAgICAgLy8gICAgICAgbm9kZTogbm9kZVxuICAgICAgLy8gICAgIH07XG4gICAgICAvLyAgICAgdGhpcy5zaG93VG9vbHRpcCgpO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm5ldHdvcmsub24oXCJzZWxlY3RFZGdlXCIsIChlKSA9PiB7XG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2Ugc2hvdyBmaXhlZCB0b29sdGlwIG9uIHNlbGVjdGlvbj9cbiAgICAgIC8vIGlmKCF0aGlzLm5ldHdvcmsuZ2V0U2VsZWN0ZWROb2RlcygpLmxlbmd0aCAmJiAhdGhpcy5uZXR3b3JrLmdldFNlbGVjdGVkRWRnZXMoKS5sZW5ndGgpIHtcbiAgICAgIC8vICAgY29uc3QgZWRnZSA9IHRoaXMuZWRnZURhdGFTZXQuZ2V0KGUuZWRnZXNbMF0pO1xuICAgICAgLy8gICBpZiAoZWRnZSkge1xuICAgICAgLy8gICAgIHRoaXMuZWxlbWVudFdpdGhUb29sdGlwID0ge1xuICAgICAgLy8gICAgICAgZWRnZTogZWRnZSxcbiAgICAgIC8vICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAvLyAgICAgICAgIHg6IGUueCxcbiAgICAgIC8vICAgICAgICAgeTogZS55LFxuICAgICAgLy8gICAgICAgfVxuICAgICAgLy8gICAgIH07XG4gICAgICAvLyAgICAgdGhpcy5zaG93VG9vbHRpcCgpO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG4gICAgfSk7XG4gICAgXG5cbiAgICBmdW5jdGlvbiBwbG90VGltZXMoc3RhcnRUaW1lLCBpbnRlcnZhbCwgaW50ZXJ2YWxVbml0LCB0aW1lRm9yT25lUGl4ZWwsIG9mZnNldFgsIG9mZnNldFksIHJpZ2h0TW9zdFgsIGNvbnRleHQsIHNjYWxlKSB7XG4gICAgICBsZXQgY3VycmVudFRpbWUgPSBuZXcgRGF0ZShzdGFydFRpbWUpO1xuICAgICAgc3dpdGNoKGludGVydmFsVW5pdCkge1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICBjdXJyZW50VGltZSA9IG5ldyBEYXRlKGN1cnJlbnRUaW1lLmdldEZ1bGxZZWFyKCkgIC0gY3VycmVudFRpbWUuZ2V0RnVsbFllYXIoKSAlIGludGVydmFsLCAwLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoY3VycmVudFRpbWUuZ2V0RnVsbFllYXIoKSwgY3VycmVudFRpbWUuZ2V0TW9udGgoKSAtIGN1cnJlbnRUaW1lLmdldE1vbnRoKCkgJSBpbnRlcnZhbCwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgY3VycmVudFRpbWUgPSBuZXcgRGF0ZShjdXJyZW50VGltZS5nZXRGdWxsWWVhcigpLCBjdXJyZW50VGltZS5nZXRNb250aCgpLCBjdXJyZW50VGltZS5nZXREYXRlKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHdoaWxlKCsraSA8IDEwMCkge1xuICAgICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSAtb2Zmc2V0WCArIChjdXJyZW50VGltZSAtIHN0YXJ0VGltZSkgLyB0aW1lRm9yT25lUGl4ZWw7XG4gICAgICAgIGlmKG5leHRQb3NpdGlvbiA+IHJpZ2h0TW9zdFgpIGJyZWFrO1xuICAgICAgICBpZihpbnRlcnZhbFVuaXQgPT09ICd5ZWFyJylcbiAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KGN1cnJlbnRUaW1lLmdldEZ1bGxZZWFyKCksIG5leHRQb3NpdGlvbiwgLW9mZnNldFkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgY29udGV4dC5maWxsVGV4dChjdXJyZW50VGltZS50b0xvY2FsZURhdGVTdHJpbmcoKSwgbmV4dFBvc2l0aW9uLCAtb2Zmc2V0WSk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKG5leHRQb3NpdGlvbiwgLW9mZnNldFkpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhuZXh0UG9zaXRpb24sIC1vZmZzZXRZICsgMjUgLyBzY2FsZSk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIHN3aXRjaChpbnRlcnZhbFVuaXQpIHtcbiAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lLnNldEZ1bGxZZWFyKGN1cnJlbnRUaW1lLmdldEZ1bGxZZWFyKCkgKyBpbnRlcnZhbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICBjdXJyZW50VGltZS5zZXRNb250aChjdXJyZW50VGltZS5nZXRNb250aCgpICsgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lLnNldERhdGUoY3VycmVudFRpbWUuZ2V0RGF0ZSgpICsgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aGlzLm5ldHdvcmsub24oXCJhZnRlckRyYXdpbmdcIiwgKGN0eCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVUb29sdGlwTG9jYXRpb24oKTtcbiAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLmdyYXBoLm5vZGVzKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLm5vZGVEYXRhU2V0LmdldChub2RlLmlkKTtcbiAgICAgICAgaWYobm9kZSAmJiBub2RlLnNoYXBlICE9PSAnaW1hZ2UnICYmIChub2RlLmN1c3RvbUljb24gfHwgdGhpcy5jb25maWcubm9kZS5kZWZhdWx0SWNvbikpIHtcbiAgICAgICAgICBsZXQgcG9zaXRpb24gPSB0aGlzLm5ldHdvcmsuZ2V0UG9zaXRpb24obm9kZS5pZCk7XG4gICAgICAgICAgbGV0IHBnTm9kZSA9IHRoaXMubm9kZU1hcFtub2RlLmlkXTtcbiAgICAgICAgICBpZihub2RlLmN1c3RvbUljb24pIHtcbiAgICAgICAgICAgIGlmKG5vZGUuY3VzdG9tSWNvbi5uYW1lICYmIEJsaXR6Ym9hcmQubG9hZGVkSWNvbnNbbm9kZS5jdXN0b21JY29uLm5hbWVdKSB7IC8vIEljb25peVxuICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKEJsaXR6Ym9hcmQubG9hZGVkSWNvbnNbbm9kZS5jdXN0b21JY29uLm5hbWVdLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnggLSBub2RlLnNpemUgKiBCbGl0emJvYXJkLmljb25TaXplQ29lZiAvIDIsIHBvc2l0aW9uLnkgLSBub2RlLnNpemUgKiBCbGl0emJvYXJkLmljb25TaXplQ29lZiAvIDIsXG4gICAgICAgICAgICAgICAgbm9kZS5zaXplICogQmxpdHpib2FyZC5pY29uU2l6ZUNvZWYsIFxuICAgICAgICAgICAgICAgIG5vZGUuc2l6ZSAqIEJsaXR6Ym9hcmQuaWNvblNpemVDb2VmKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIElvbmljb25zXG4gICAgICAgICAgICAgIGN0eC5mb250ID0gYCR7bm9kZS5jdXN0b21JY29uLnNpemV9cHggSW9uaWNvbnNgO1xuICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICAgICAgICAgIGN0eC5maWxsVGV4dChub2RlLmN1c3RvbUljb24uY29kZSwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCFwZ05vZGUpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBsYWJlbCBvZiBwZ05vZGUubGFiZWxzKSB7XG4gICAgICAgICAgICAgIGxldCBsb3dlckxhYmVsID0gbGFiZWwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKEJsaXR6Ym9hcmQubG9hZGVkSWNvbnNbbG93ZXJMYWJlbF0pIHtcbiAgICAgICAgICAgICAgICBpZihCbGl0emJvYXJkLmxvYWRlZEljb25zW2xvd2VyTGFiZWxdICE9ICdyZXRyaWV2aW5nLi4uJylcbiAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoQmxpdHpib2FyZC5sb2FkZWRJY29uc1tsb3dlckxhYmVsXSwgcG9zaXRpb24ueCAtIG5vZGUuc2l6ZSAqIEJsaXR6Ym9hcmQuaWNvblNpemVDb2VmIC8gMixcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24ueSAtIG5vZGUuc2l6ZSAqIEJsaXR6Ym9hcmQuaWNvblNpemVDb2VmIC8gMixcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zaXplICogQmxpdHpib2FyZC5pY29uU2l6ZUNvZWYsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2l6ZSAqIEJsaXR6Ym9hcmQuaWNvblNpemVDb2VmKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgIGlmKHRoaXMuY29uZmlnLmxheW91dCA9PT0gJ3RpbWVsaW5lJyl7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLm5ldHdvcmsuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgY29uc3QgdmlldyA9IHRoaXMubmV0d29yay5jYW52YXMuYm9keS52aWV3O1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gKHZpZXcudHJhbnNsYXRpb24ueSAtIDIwKSAvIHZpZXcuc2NhbGU7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSB2aWV3LnRyYW5zbGF0aW9uLnggLyB2aWV3LnNjYWxlO1xuICAgICAgICBjb25zdCB0aW1lRm9yT25lUGl4ZWwgPSAodGhpcy5tYXhUaW1lIC0gdGhpcy5taW5UaW1lKSAvIHRoaXMudGltZVNjYWxlO1xuICAgICAgICBjb25zdCB0aW1lT25MZWZ0RWRnZSA9IG5ldyBEYXRlKCgodGhpcy5tYXhUaW1lLmdldFRpbWUoKSArIHRoaXMubWluVGltZS5nZXRUaW1lKCkpIC8gMikgLSB0aW1lRm9yT25lUGl4ZWwgKiBvZmZzZXRYKTtcbiAgICAgICAgY29uc3QgY2xpZW50V2lkdGggPSB0aGlzLm5ldHdvcmsuY2FudmFzLmJvZHkuY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgICBjb25zdCByaWdodE1vc3QgPSAtb2Zmc2V0WCArIGNsaWVudFdpZHRoIC8gdmlldy5zY2FsZTtcbiAgICAgICAgY29uc3Qgb25lTW9udGggPSAzMSAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XG4gICAgICAgIGNvbnN0IG9uZURheSA9IDI0ICogNjAgKiA2MCAqIDEwMDA7XG4gICAgICAgIGNvbnN0IHR3b01vbnRoID0gb25lTW9udGggKiAyO1xuICAgICAgICBjb25zdCBmb3VyTW9udGggPSB0d29Nb250aCAqIDI7XG4gICAgICAgIGNvbnN0IG9uZVllYXIgPSAzNjUgKiBvbmVEYXk7XG4gICAgICAgIGNvbnN0IG1pbkRpc3RhbmNlID0gMjAwO1xuICAgICAgICBjb250ZXh0LmZvbnQgPSAoMjAgLyB2aWV3LnNjYWxlKS50b1N0cmluZygpICsgXCJweCBBcmlhbFwiO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiYmx1ZVwiO1xuICAgICAgICBjb25zdCBtaW5pbXVtSW50ZXJ2YWwgPSB0aW1lRm9yT25lUGl4ZWwgKiBtaW5EaXN0YW5jZSAvIHZpZXcuc2NhbGU7XG4gICAgICAgIGlmKG1pbmltdW1JbnRlcnZhbCA+IG9uZVllYXIgKSB7XG4gICAgICAgICAgcGxvdFRpbWVzKHRpbWVPbkxlZnRFZGdlLCBtaW5pbXVtSW50ZXJ2YWwgLyBvbmVZZWFyLCAneWVhcicsIHRpbWVGb3JPbmVQaXhlbCwgb2Zmc2V0WCwgb2Zmc2V0WSwgcmlnaHRNb3N0LCBjb250ZXh0LCB2aWV3LnNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKG1pbmltdW1JbnRlcnZhbCA+IGZvdXJNb250aCApIHtcbiAgICAgICAgICBwbG90VGltZXModGltZU9uTGVmdEVkZ2UsIDQsICdtb250aCcsIHRpbWVGb3JPbmVQaXhlbCwgb2Zmc2V0WCwgb2Zmc2V0WSwgcmlnaHRNb3N0LCBjb250ZXh0LCB2aWV3LnNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKG1pbmltdW1JbnRlcnZhbCA+IHR3b01vbnRoKSB7XG4gICAgICAgICAgcGxvdFRpbWVzKHRpbWVPbkxlZnRFZGdlLCAyLCAnbW9udGgnLCB0aW1lRm9yT25lUGl4ZWwsIG9mZnNldFgsIG9mZnNldFksIHJpZ2h0TW9zdCwgY29udGV4dCwgdmlldy5zY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihtaW5pbXVtSW50ZXJ2YWwgPiBvbmVNb250aCkge1xuICAgICAgICAgIHBsb3RUaW1lcyh0aW1lT25MZWZ0RWRnZSwgMSwgJ21vbnRoJywgdGltZUZvck9uZVBpeGVsLCBvZmZzZXRYLCBvZmZzZXRZLCByaWdodE1vc3QsIGNvbnRleHQsIHZpZXcuc2NhbGUpO1xuICAgICAgICB9IGVsc2UgaWYobWluaW11bUludGVydmFsID4gb25lRGF5ICogMTYpIHtcbiAgICAgICAgICBwbG90VGltZXModGltZU9uTGVmdEVkZ2UsIDE2LCAnZGF5JywgdGltZUZvck9uZVBpeGVsLCBvZmZzZXRYLCBvZmZzZXRZLCByaWdodE1vc3QsIGNvbnRleHQsIHZpZXcuc2NhbGUpO1xuICAgICAgICB9IGVsc2UgaWYobWluaW11bUludGVydmFsID4gb25lRGF5ICogOCkge1xuICAgICAgICAgIHBsb3RUaW1lcyh0aW1lT25MZWZ0RWRnZSwgOCwgJ2RheScsIHRpbWVGb3JPbmVQaXhlbCwgb2Zmc2V0WCwgb2Zmc2V0WSwgcmlnaHRNb3N0LCBjb250ZXh0LCB2aWV3LnNjYWxlKTtcbiAgICAgICAgfSBlbHNlIGlmKG1pbmltdW1JbnRlcnZhbCA+IG9uZURheSAqIDQpIHtcbiAgICAgICAgICBwbG90VGltZXModGltZU9uTGVmdEVkZ2UsIDQsICdkYXknLCB0aW1lRm9yT25lUGl4ZWwsIG9mZnNldFgsIG9mZnNldFksIHJpZ2h0TW9zdCwgY29udGV4dCwgdmlldy5zY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZihtaW5pbXVtSW50ZXJ2YWwgPiBvbmVEYXkgKiAyKSB7XG4gICAgICAgICAgcGxvdFRpbWVzKHRpbWVPbkxlZnRFZGdlLCAyLCAnZGF5JywgdGltZUZvck9uZVBpeGVsLCBvZmZzZXRYLCBvZmZzZXRZLCByaWdodE1vc3QsIGNvbnRleHQsIHZpZXcuc2NhbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBsb3RUaW1lcyh0aW1lT25MZWZ0RWRnZSwgMSwgJ2RheScsIHRpbWVGb3JPbmVQaXhlbCwgb2Zmc2V0WCwgb2Zmc2V0WSwgcmlnaHRNb3N0LCBjb250ZXh0LCB2aWV3LnNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMubmV0d29yay5vbihcImJsdXJOb2RlXCIsIChwYXJhbXMpID0+IHtcbiAgICAgIHRoaXMubmV0d29yay5jYW52YXMuYm9keS5jb250YWluZXIuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgbGV0IG5vZGUgPSB0aGlzLm5vZGVEYXRhU2V0LmdldChwYXJhbXMubm9kZSk7XG4gICAgICBpZihub2RlICYmIG5vZGUudXJsKSB7XG4gICAgICAgIHRoaXMubm9kZURhdGFTZXQudXBkYXRlKHtcbiAgICAgICAgICBpZDogcGFyYW1zLm5vZGUsXG4gICAgICAgICAgY29sb3I6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5oaWRlVG9vbHRpcCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5uZXR3b3JrLm9uKFwiYmx1ckVkZ2VcIiwgKHBhcmFtcykgPT4ge1xuICAgICAgdGhpcy5oaWRlVG9vbHRpcCgpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFCbGl0emJvYXJkLmZvbnRMb2FkZWQgJiYgZG9jdW1lbnQuZm9udHMpIHtcbiAgICAgIEJsaXR6Ym9hcmQuZm9udExvYWRlZCA9IHRydWU7XG4gICAgICBsZXQgYmxpdHpib2FyZCA9IHRoaXM7XG4gICAgICAvLyBEZWNlbnQgYnJvd3NlcnM6IE1ha2Ugc3VyZSB0aGUgZm9udHMgYXJlIGxvYWRlZC5cbiAgICAgIGRvY3VtZW50LmZvbnRzLmxvYWQoJ25vcm1hbCBub3JtYWwgNDAwIDI0cHgvMSBcIkZvbnRBd2Vzb21lXCInKVxuICAgICAgICAuY2F0Y2goXG4gICAgICAgICAgY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUsIFwiRmFpbGVkIHRvIGxvYWQgRm9udCBBd2Vzb21lIDQuXCIpXG4gICAgICAgICkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGJsaXR6Ym9hcmQubmV0d29yay5yZWRyYXcoKTtcbiAgICAgIH0pXG4gICAgICAgIC5jYXRjaChcbiAgICAgICAgICBjb25zb2xlLmVycm9yLmJpbmQoXG4gICAgICAgICAgICBjb25zb2xlLFxuICAgICAgICAgICAgXCJGYWlsZWQgdG8gcmVuZGVyIHRoZSBuZXR3b3JrIHdpdGggRm9udCBBd2Vzb21lIDQuXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xpY2tIYW5kbGVyKGUpIHtcbiAgICAgIGJsaXR6Ym9hcmQuZG91YmxlQ2xpY2tUaW1lciA9IG51bGw7XG4gICAgICBpZiAoZS5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChibGl0emJvYXJkLmNvbmZpZy5ub2RlLm9uQ2xpY2spIHtcbiAgICAgICAgICBibGl0emJvYXJkLmNvbmZpZy5ub2RlLm9uQ2xpY2soYmxpdHpib2FyZC5nZXROb2RlKGUubm9kZXNbMF0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlLmVkZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGJsaXR6Ym9hcmQuY29uZmlnLmVkZ2Uub25DbGljaykge1xuICAgICAgICAgIGJsaXR6Ym9hcmQuY29uZmlnLmVkZ2Uub25DbGljayhibGl0emJvYXJkLmdldEVkZ2UoZS5lZGdlc1swXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5uZXR3b3JrLm9uKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgIGlmKCF0aGlzLmRvdWJsZUNsaWNrVGltZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmRvdWJsZUNsaWNrV2FpdCA8PSAwKSB7XG4gICAgICAgICAgY2xpY2tIYW5kbGVyKGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gY2xpY2tIYW5kbGVyKGUpLCB0aGlzLmNvbmZpZy5kb3VibGVDbGlja1dhaXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBcbiAgICB0aGlzLm5ldHdvcmsub24oXCJkb3VibGVDbGlja1wiLCAoZSkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlQ2xpY2tUaW1lcik7XG4gICAgICB0aGlzLmRvdWJsZUNsaWNrVGltZXIgPSBudWxsO1xuICAgICAgaWYoZS5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmKHRoaXMuY29uZmlnLm5vZGUub25Eb3VibGVDbGljaykge1xuICAgICAgICAgIHRoaXMuY29uZmlnLm5vZGUub25Eb3VibGVDbGljayh0aGlzLmdldE5vZGUoZS5ub2Rlc1swXSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoZS5lZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmKHRoaXMuY29uZmlnLmVkZ2Uub25Eb3VibGVDbGljaykge1xuICAgICAgICAgIHRoaXMuY29uZmlnLmVkZ2Uub25Eb3VibGVDbGljayh0aGlzLmdldEVkZ2UoZS5lZGdlc1swXSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibGl0emJvYXJkLm5ldHdvcmsuZml0KHthbmltYXRpb246IHRydWV9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvcihsZXQgY2FsbGJhY2sgb2YgdGhpcy5vblVwZGF0ZWQpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cblxuICBzY3JvbGxOb2RlSW50b1ZpZXcobm9kZSwgc2VsZWN0ID0gdHJ1ZSkge1xuICAgIGlmKHR5cGVvZihub2RlKSA9PT0gJ3N0cmluZycpXG4gICAgICBub2RlID0gdGhpcy5ub2RlTWFwW25vZGVdO1xuICAgIGlmKCFub2RlKVxuICAgICAgcmV0dXJuO1xuXG4gICAgaWYodGhpcy5jb25maWcubGF5b3V0ID09PSAnbWFwJykge1xuICAgICAgdGhpcy5zY3JvbGxNYXBUb05vZGUodGhpcy5ub2RlTWFwW25vZGUuaWRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY3JvbGxOZXR3b3JrVG9Qb3NpdGlvbih0aGlzLm5ldHdvcmsuZ2V0UG9zaXRpb24obm9kZS5pZCkpO1xuICAgIH1cbiAgICBpZihzZWxlY3QpXG4gICAgICB0aGlzLm5ldHdvcmsuc2VsZWN0Tm9kZXMoW25vZGUuaWRdKTtcblxuICAgIGZvcihsZXQgY2FsbGJhY2sgb2YgdGhpcy5vbk5vZGVGb2N1c2VkKSB7XG4gICAgICAvLyBUT0RPOiBUaGUgYXJndW1lbnQgc2hvdWxkIGJlIHByb3h5IGluc3RlYWQgb2YgcGxhaW4gb2JqZWN0c1xuICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgfVxuICB9XG4gIFxuICBzY3JvbGxOZXR3b3JrVG9Qb3NpdGlvbihwb3NpdGlvbikge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnNjcm9sbEFuaW1hdGlvblRpbWVySWQpO1xuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uVGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgYW5pbWF0aW9uT3B0aW9uID0ge1xuICAgICAgICBzY2FsZTogMS4wLFxuICAgICAgICBhbmltYXRpb246XG4gICAgICAgICAge1xuICAgICAgICAgICAgZHVyYXRpb246IDUwMCxcbiAgICAgICAgICAgIGVhc2luZ0Z1bnRjaW9uOiBcImVhc2VJbk91dFF1YWRcIlxuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLm5ldHdvcmsubW92ZVRvKHsgLi4ue3Bvc2l0aW9uOiBwb3NpdGlvbn0sIC4uLmFuaW1hdGlvbk9wdGlvbiB9KTtcbiAgICB9LCAyMDApOyAvLyBTZXQgZGVsYXkgdG8gYXZvaWQgY2FsbGluZyBtb3ZlVG8oKSB0b28gbXVjaCAoc2VlbSB0byBjYXVzZSBzb21lIGJ1ZyBvbiBhbmltYXRpb24pXG4gIH1cbiAgXG4gIHVwZGF0ZU5vZGVMb2NhdGlvbk9uTWFwKCkge1xuICAgIGxldCBub2RlUG9zaXRpb25zID0gW107XG4gICAgbGV0IGxuZ0tleSA9ICB0aGlzLmNvbmZpZy5sYXlvdXRTZXR0aW5ncy5sbmc7XG4gICAgbGV0IGxhdEtleSA9ICB0aGlzLmNvbmZpZy5sYXlvdXRTZXR0aW5ncy5sYXQ7XG4gICAgdGhpcy5ncmFwaC5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgaWYobm9kZS5wcm9wZXJ0aWVzW2xhdEtleV0gJiYgbm9kZS5wcm9wZXJ0aWVzW2xuZ0tleV0pIHtcbiAgICAgICAgbGV0IHBvaW50ID0gdGhpcy5tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChbbm9kZS5wcm9wZXJ0aWVzW2xhdEtleV1bMF0sIG5vZGUucHJvcGVydGllc1tsbmdLZXldWzBdXSk7XG4gICAgICAgIHBvaW50ID0gdGhpcy5uZXR3b3JrLkRPTXRvQ2FudmFzKHBvaW50KTtcbiAgICAgICAgbm9kZVBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICB4OiBwb2ludC54LCB5OiBwb2ludC55LCBmaXhlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLm5vZGVEYXRhU2V0LnVwZGF0ZShub2RlUG9zaXRpb25zKTtcbiAgfVxuXG5cbiAgdXBkYXRlTm9kZUxvY2F0aW9uT25UaW1lTGluZSgpIHtcbiAgICBsZXQgbm9kZVBvc2l0aW9ucyA9IFtdO1xuICAgIHRoaXMuZ3JhcGgubm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGxldCB4LCB5LCBmaXhlZCwgd2lkdGg7XG4gICAgICAoe3gsIHksIGZpeGVkLCB3aWR0aH0gPSB0aGlzLmNhbGNOb2RlUG9zaXRpb24obm9kZSkpO1xuICAgICAgbm9kZVBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgIHgsIHlcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMubm9kZURhdGFTZXQudXBkYXRlKG5vZGVQb3NpdGlvbnMpO1xuICB9XG4gIFxuICBzY3JvbGxNYXBUb05vZGUobm9kZSkge1xuICAgIGxldCBsbmdLZXkgPSB0aGlzLmNvbmZpZy5sYXlvdXRTZXR0aW5ncy5sbmc7XG4gICAgbGV0IGxhdEtleSA9IHRoaXMuY29uZmlnLmxheW91dFNldHRpbmdzLmxhdDtcbiAgICB0aGlzLm1hcC5wYW5Ubyhbbm9kZS5wcm9wZXJ0aWVzW2xhdEtleV1bMF0gLG5vZGUucHJvcGVydGllc1tsbmdLZXldWzBdXSk7XG4gIH1cbiAgXG4gIHNjcm9sbEVkZ2VJbnRvVmlldyhlZGdlLCBzZWxlY3QgPSB0cnVlKSB7XG4gICAgaWYodHlwZW9mKGVkZ2UpID09PSAnc3RyaW5nJykge1xuICAgICAgZWRnZSA9IHRoaXMuZWRnZU1hcFtlZGdlXTtcbiAgICB9XG5cbiAgICBpZih0aGlzLmNvbmZpZy5sYXlvdXQgPT09ICdtYXAnKSB7XG4gICAgICB0aGlzLnNjcm9sbE1hcFRvTm9kZSh0aGlzLm5vZGVNYXBbZWRnZS5mcm9tXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZyb20gPSB0aGlzLm5ldHdvcmsuZ2V0UG9zaXRpb24oZWRnZS5mcm9tKTtcbiAgICAgIGNvbnN0IHRvID0gdGhpcy5uZXR3b3JrLmdldFBvc2l0aW9uKGVkZ2UudG8pO1xuICAgICAgdGhpcy5zY3JvbGxOZXR3b3JrVG9Qb3NpdGlvbih7IHg6IChmcm9tLnggKyB0by54KSAvIDIsIHk6IChmcm9tLnkgKyB0by55KSAvMiB9KTtcbiAgICB9XG4gICAgaWYoc2VsZWN0KSB7XG4gICAgICB0aGlzLm5ldHdvcmsuc2VsZWN0RWRnZXMoW2VkZ2UuaWRdKTtcbiAgICB9XG5cbiAgICBmb3IobGV0IGNhbGxiYWNrIG9mIHRoaXMub25FZGdlRm9jdXNlZCkge1xuICAgICAgLy8gVE9ETzogVGhlIGFyZ3VtZW50IHNob3VsZCBiZSBwcm94eSBpbnN0ZWFkIG9mIHBsYWluIG9iamVjdHNcbiAgICAgIGNhbGxiYWNrKGVkZ2UpO1xuICAgIH1cbiAgfVxuICBcbiAgc2hvd0xvYWRlcih0ZXh0ID0gXCJOb3cgbG9hZGluZy4uLlwiKSB7XG4gICAgdGhpcy5zY3JlZW4uc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICB0aGlzLnNjcmVlblRleHQuaW5uZXJUZXh0ID0gdGV4dDtcbiAgICB0aGlzLnNjcmVlblRleHQuc3R5bGUuZGlzcGxheSA9IHRleHQgPyAnYmxvY2snIDogJ25vbmUnO1xuICB9XG4gIFxuICBoaWRlTG9hZGVyKCkge1xuICAgIHRoaXMuc2NyZWVuLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cblxuICB0b05vZGVQYWlyU3RyaW5nKHBnRWRnZSkge1xuICAgIHJldHVybiBgJHtwZ0VkZ2UuZnJvbX0ke0JsaXR6Ym9hcmQuZWRnZURlbGltaXRlcn0ke3BnRWRnZS50b31gO1xuICB9XG59XG5cblxuXG5mdW5jdGlvbiBhcnJheUVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGEpICYmXG4gICAgQXJyYXkuaXNBcnJheShiKSAmJlxuICAgIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJlxuICAgIGEuZXZlcnkoKHZhbCwgaW5kZXgpID0+IHZhbCA9PT0gYltpbmRleF0pO1xufVxuXG5mdW5jdGlvbiBub2RlRXF1YWxzKG5vZGUxLCBub2RlMikge1xuICBpZihub2RlMS5pZCAhPSBub2RlMi5pZCB8fCAhYXJyYXlFcXVhbHMobm9kZTEubGFiZWxzLCBub2RlMi5sYWJlbHMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBub2RlMUtleXMgPSBPYmplY3Qua2V5cyhub2RlMS5wcm9wZXJ0aWVzKTtcbiAgbGV0IG5vZGUyS2V5cyA9IE9iamVjdC5rZXlzKG5vZGUyLnByb3BlcnRpZXMpO1xuICBpZihub2RlMUtleXMubGVuZ3RoICE9IG5vZGUyS2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yKGxldCBrZXkgb2Ygbm9kZTFLZXlzKSB7XG4gICAgaWYoIWFycmF5RXF1YWxzKG5vZGUxLnByb3BlcnRpZXNba2V5XSwgbm9kZTIucHJvcGVydGllc1trZXldKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG5jbGFzcyBEdXBsaWNhdGVOb2RlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG5vZGVzKSB7XG4gICAgc3VwZXIoYER1cGxpY2F0ZSBub2RlOiAke25vZGVzLm1hcChuID0+IG4uaWQpLmpvaW4oJywgJyl9YCk7XG4gICAgdGhpcy5uYW1lID0gXCJOb2RlRHVwbGljYXRpb25FcnJvclwiO1xuICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5EdXBsaWNhdGVOb2RlRXJyb3IgPSBEdXBsaWNhdGVOb2RlRXJyb3I7XG5cblxuZnVuY3Rpb24gZGVlcE1lcmdlKHRhcmdldCwgc291cmNlKSB7XG4gIGNvbnN0IGlzT2JqZWN0ID0gb2JqID0+IG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmopO1xuICBsZXQgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcbiAgaWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGZvciAoY29uc3QgW3NvdXJjZUtleSwgc291cmNlVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcbiAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGFyZ2V0W3NvdXJjZUtleV07XG4gICAgICBpZiAoaXNPYmplY3Qoc291cmNlVmFsdWUpICYmIHRhcmdldC5oYXNPd25Qcm9wZXJ0eShzb3VyY2VLZXkpKSB7XG4gICAgICAgIHJlc3VsdFtzb3VyY2VLZXldID0gZGVlcE1lcmdlKHRhcmdldFZhbHVlLCBzb3VyY2VWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHtbc291cmNlS2V5XTogc291cmNlVmFsdWV9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmV0cmlldmVIdHRwVXJsKG5vZGUpIHtcbiAgbGV0IGNhbmRpZGF0ZXMgPSBbXTtcbiAgZm9yKGxldCBlbnRyeSBvZiBPYmplY3QuZW50cmllcyhub2RlLnByb3BlcnRpZXMpKSB7XG4gICAgZm9yKGxldCBwcm9wIG9mIGVudHJ5WzFdKSB7XG4gICAgICBpZih0eXBlb2YocHJvcCkgPT09ICdzdHJpbmcnICYmIChwcm9wLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSB8fCBwcm9wLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpKSkge1xuICAgICAgICBpZihlbnRyeVswXS50b0xvd2VyQ2FzZSgpID09ICd1cmwnKVxuICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goW2VudHJ5WzBdLCBwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzWzBdO1xufVxuXG5cblxuXG5mdW5jdGlvbiB3cmFwVGV4dChzdHIsIGFzSHRtbCkge1xuICBpZighc3RyKVxuICAgIHJldHVybiBzdHI7XG4gIGlmKEFycmF5LmlzQXJyYXkoc3RyKSlcbiAgICBzdHIgPSBzdHJbMF07XG4gIGNvbnN0IG1heFdpZHRoID0gNDA7XG4gIGxldCBuZXdMaW5lU3RyID0gYXNIdG1sID8gXCI8YnI+XCIgOiBcIlxcblwiLCByZXMgPSAnJztcbiAgd2hpbGUgKHN0ci5sZW5ndGggPiBtYXhXaWR0aCkge1xuICAgIHJlcyArPSBzdHIuc2xpY2UoMCwgbWF4V2lkdGgpICsgbmV3TGluZVN0cjtcbiAgICBzdHIgPSBzdHIuc2xpY2UobWF4V2lkdGgpO1xuICB9XG4gIHJldHVybiByZXMgKyBzdHI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxhYmVsVGV4dChlbGVtLCBwcm9wcyA9IG51bGwpIHtcbiAgaWYgKHByb3BzICE9IG51bGwpIHtcbiAgICAvLyBVc2Ugd2hpdGVzcGFjZSBpbnN0ZWFkIG9mIGVtcHR5IHN0cmluZyBpZiBubyBwcm9wcyBhcmUgc3BlY2lmaWVkIGJlY2F1c2UgVmlzLmpzIGNhbm5vdCB1cGRhdGUgbGFiZWwgd2l0aCBlbXB0eSBzdHJpbmcpXG4gICAgcmV0dXJuIHByb3BzLmxlbmd0aCA/IHByb3BzLm1hcCgocHJvcCkgPT4gcHJvcCA9PT0gJ2lkJyA/IGVsZW0uaWQgOiAocHJvcCA9PT0gJ2xhYmVsJyA/IGVsZW0ubGFiZWxzIDogd3JhcFRleHQoZWxlbS5wcm9wZXJ0aWVzW3Byb3BdKSkpLmZpbHRlcigodmFsKSA9PiB2YWwpLmpvaW4oJ1xcbicpIDogJyAnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb0h5cGVyTGlua0lmVVJMKHRleHQpIHtcbiAgaWYoIXRleHQpXG4gICAgcmV0dXJuIHRleHQ7XG4gIGlmKEFycmF5LmlzQXJyYXkodGV4dCkpXG4gICAgdGV4dCA9IHRleHRbMF07XG4gIGlmKHRleHQuc3RhcnRzV2l0aCgnaHR0cDovLycpIHx8IHRleHQuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSApIHtcbiAgICByZXR1cm4gYDxhIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XCIke3RleHR9XCI+JHt3cmFwVGV4dCh0ZXh0KX08L2E+YDtcbiAgfVxuICByZXR1cm4gd3JhcFRleHQodGV4dCk7XG59XG5cbi8vIENyZWF0ZSByYW5kb20gY29sb3JzLCB3aXRoIHN0ciBhcyBzZWVkLCBhbmQgd2l0aCBmaXhlZCBzYXR1cmF0aW9uIGFuZCBsaWdodG5lc3NcbmZ1bmN0aW9uIGdldFJhbmRvbUNvbG9yKHN0ciwgc2F0dXJhdGlvbiwgYnJpZ2h0bmVzcykge1xuICBsZXQgaGFzaCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaGFzaCA9IHN0ci5jaGFyQ29kZUF0KGkpICsgKChoYXNoIDw8IDUpIC0gaGFzaCk7XG4gICAgaGFzaCA9IGhhc2ggJiBoYXNoO1xuICB9XG4gIGxldCBodWUgPSBoYXNoICUgMzYwO1xuICByZXR1cm4gJ2hzbCgnICsgaHVlICsgYCwgJHtzYXR1cmF0aW9ufSwgJHticmlnaHRuZXNzfSlgO1xufVxuXG5mdW5jdGlvbiBpc0RhdGVTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBpc05hTihzdHIpICYmICFpc05hTihEYXRlLnBhcnNlKHN0cikpXG59XG5cbmZ1bmN0aW9uIGh0bWxUaXRsZShodG1sKSB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICByZXR1cm4gY29udGFpbmVyO1xufVxuIiwiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogR2VuZXJhdGVkIGJ5IFBFRy5qcyAwLjEwLjAuXG4gKlxuICogaHR0cDovL3BlZ2pzLm9yZy9cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gcGVnJHN1YmNsYXNzKGNoaWxkLCBwYXJlbnQpIHtcbiAgZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9XG4gIGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTtcbn1cblxuZnVuY3Rpb24gcGVnJFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgbG9jYXRpb24pIHtcbiAgdGhpcy5tZXNzYWdlICA9IG1lc3NhZ2U7XG4gIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgdGhpcy5mb3VuZCAgICA9IGZvdW5kO1xuICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gIHRoaXMubmFtZSAgICAgPSBcIlN5bnRheEVycm9yXCI7XG5cbiAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgcGVnJFN5bnRheEVycm9yKTtcbiAgfVxufVxuXG5wZWckc3ViY2xhc3MocGVnJFN5bnRheEVycm9yLCBFcnJvcik7XG5cbnBlZyRTeW50YXhFcnJvci5idWlsZE1lc3NhZ2UgPSBmdW5jdGlvbihleHBlY3RlZCwgZm91bmQpIHtcbiAgdmFyIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOUyA9IHtcbiAgICAgICAgbGl0ZXJhbDogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gXCJcXFwiXCIgKyBsaXRlcmFsRXNjYXBlKGV4cGVjdGF0aW9uLnRleHQpICsgXCJcXFwiXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJjbGFzc1wiOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xuICAgICAgICAgIHZhciBlc2NhcGVkUGFydHMgPSBcIlwiLFxuICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGF0aW9uLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlc2NhcGVkUGFydHMgKz0gZXhwZWN0YXRpb24ucGFydHNbaV0gaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICA/IGNsYXNzRXNjYXBlKGV4cGVjdGF0aW9uLnBhcnRzW2ldWzBdKSArIFwiLVwiICsgY2xhc3NFc2NhcGUoZXhwZWN0YXRpb24ucGFydHNbaV1bMV0pXG4gICAgICAgICAgICAgIDogY2xhc3NFc2NhcGUoZXhwZWN0YXRpb24ucGFydHNbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBcIltcIiArIChleHBlY3RhdGlvbi5pbnZlcnRlZCA/IFwiXlwiIDogXCJcIikgKyBlc2NhcGVkUGFydHMgKyBcIl1cIjtcbiAgICAgICAgfSxcblxuICAgICAgICBhbnk6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYW55IGNoYXJhY3RlclwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuZDogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gXCJlbmQgb2YgaW5wdXRcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBvdGhlcjogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gZXhwZWN0YXRpb24uZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgZnVuY3Rpb24gaGV4KGNoKSB7XG4gICAgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXRlcmFsRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgIC5yZXBsYWNlKC9cIi9nLCAgJ1xcXFxcIicpXG4gICAgICAucmVwbGFjZSgvXFwwL2csICdcXFxcMCcpXG4gICAgICAucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpXG4gICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpXG4gICAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpXG4gICAgICAucmVwbGFjZSgvW1xceDAwLVxceDBGXS9nLCAgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDdGLVxceDlGXS9nLCBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4JyAgKyBoZXgoY2gpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgIC5yZXBsYWNlKC9cXF0vZywgJ1xcXFxdJylcbiAgICAgIC5yZXBsYWNlKC9cXF4vZywgJ1xcXFxeJylcbiAgICAgIC5yZXBsYWNlKC8tL2csICAnXFxcXC0nKVxuICAgICAgLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKVxuICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKVxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKVxuICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKVxuICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwRl0vZywgICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceDAnICsgaGV4KGNoKTsgfSlcbiAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg3Ri1cXHg5Rl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceCcgICsgaGV4KGNoKTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgcmV0dXJuIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOU1tleHBlY3RhdGlvbi50eXBlXShleHBlY3RhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGVkKGV4cGVjdGVkKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9ucyA9IG5ldyBBcnJheShleHBlY3RlZC5sZW5ndGgpLFxuICAgICAgICBpLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdGlvbnNbaV0gPSBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGVkW2ldKTtcbiAgICB9XG5cbiAgICBkZXNjcmlwdGlvbnMuc29ydCgpO1xuXG4gICAgaWYgKGRlc2NyaXB0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGkgPSAxLCBqID0gMTsgaSA8IGRlc2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGVzY3JpcHRpb25zW2kgLSAxXSAhPT0gZGVzY3JpcHRpb25zW2ldKSB7XG4gICAgICAgICAgZGVzY3JpcHRpb25zW2pdID0gZGVzY3JpcHRpb25zW2ldO1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVzY3JpcHRpb25zLmxlbmd0aCA9IGo7XG4gICAgfVxuXG4gICAgc3dpdGNoIChkZXNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF07XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uc1swXSArIFwiIG9yIFwiICsgZGVzY3JpcHRpb25zWzFdO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIilcbiAgICAgICAgICArIFwiLCBvciBcIlxuICAgICAgICAgICsgZGVzY3JpcHRpb25zW2Rlc2NyaXB0aW9ucy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUZvdW5kKGZvdW5kKSB7XG4gICAgcmV0dXJuIGZvdW5kID8gXCJcXFwiXCIgKyBsaXRlcmFsRXNjYXBlKGZvdW5kKSArIFwiXFxcIlwiIDogXCJlbmQgb2YgaW5wdXRcIjtcbiAgfVxuXG4gIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZCkgKyBcIiBidXQgXCIgKyBkZXNjcmliZUZvdW5kKGZvdW5kKSArIFwiIGZvdW5kLlwiO1xufTtcblxuZnVuY3Rpb24gcGVnJHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XG5cbiAgdmFyIHBlZyRGQUlMRUQgPSB7fSxcblxuICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucyA9IHsgUEc6IHBlZyRwYXJzZVBHIH0sXG4gICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gID0gcGVnJHBhcnNlUEcsXG5cbiAgICAgIHBlZyRjMCA9IGZ1bmN0aW9uKGxpbmVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZXM6IGxpbmVzLm1hcChsID0+IGwubm9kZSkuZmlsdGVyKHYgPT4gdiksXG4gICAgICAgICAgZWRnZXM6IGxpbmVzLm1hcChsID0+IGwuZWRnZSkuZmlsdGVyKHYgPT4gdiksXG4gICAgICAgICAgbm9kZUNvdW50OiBub2RlQ291bnQsXG4gICAgICAgICAgZWRnZUNvdW50OiBlZGdlQ291bnQsXG4gICAgICAgICAgbm9kZUxhYmVsczogbm9kZUxhYmVsSGFzaCxcbiAgICAgICAgICBlZGdlTGFiZWxzOiBlZGdlTGFiZWxIYXNoLFxuICAgICAgICAgIG5vZGVQcm9wZXJ0aWVzOiBub2RlUHJvcEhhc2gsXG4gICAgICAgICAgZWRnZVByb3BlcnRpZXM6IGVkZ2VQcm9wSGFzaFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGVnJGMxID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBlZyRjMiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlZGdlOiBlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwZWckYzMgPSBmdW5jdGlvbihpZCwgbCwgcCkge1xuICAgICAgICBsZXQgcHJvcE9iaiA9IHt9O1xuICAgICAgICBwLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgaWYgKHByb3BPYmpbcHJvcC5rZXldKSB7XG4gICAgICAgICAgICBwcm9wT2JqW3Byb3Aua2V5XS5wdXNoKHByb3AudmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wT2JqW3Byb3Aua2V5XSA9IFtwcm9wLnZhbHVlXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm9kZVByb3BIYXNoW3Byb3Aua2V5XSA9IHRydWU7XG4gICAgICAgICAgaWYgKG5vZGVQcm9wSGFzaFtwcm9wLmtleV0pIHtcbiAgICAgICAgICAgIG5vZGVQcm9wSGFzaFtwcm9wLmtleV0rKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZVByb3BIYXNoW3Byb3Aua2V5XSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBub2RlQ291bnQrKztcblxuICAgICAgICBsLmZvckVhY2gobGFiZWwgPT4ge1xuICAgICAgICAgIGlmIChub2RlTGFiZWxIYXNoW2xhYmVsXSkge1xuICAgICAgICAgICAgbm9kZUxhYmVsSGFzaFtsYWJlbF0rKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZUxhYmVsSGFzaFtsYWJlbF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uKCksXG4gICAgICAgICAgbGFiZWxzOiBsLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BPYmpcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBlZyRjNCA9IGZ1bmN0aW9uKGYsIGQsIHQsIGwsIHApIHtcbiAgICAgICAgbGV0IHByb3BPYmogPSB7fTtcbiAgICAgICAgcC5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgIGlmIChwcm9wT2JqW3Byb3Aua2V5XSkge1xuICAgICAgICAgICAgcHJvcE9ialtwcm9wLmtleV0ucHVzaChwcm9wLnZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcE9ialtwcm9wLmtleV0gPSBbcHJvcC52YWx1ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVkZ2VQcm9wSGFzaFtwcm9wLmtleV0gPSB0cnVlO1xuICAgICAgICAgIGlmIChlZGdlUHJvcEhhc2hbcHJvcC5rZXldKSB7XG4gICAgICAgICAgICBlZGdlUHJvcEhhc2hbcHJvcC5rZXldKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkZ2VQcm9wSGFzaFtwcm9wLmtleV0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWRnZUNvdW50Kys7XG5cbiAgICAgICAgbC5mb3JFYWNoKGxhYmVsID0+IHtcbiAgICAgICAgICBpZiAoZWRnZUxhYmVsSGFzaFtsYWJlbF0pIHtcbiAgICAgICAgICAgIGVkZ2VMYWJlbEhhc2hbbGFiZWxdKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkZ2VMYWJlbEhhc2hbbGFiZWxdID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnJvbTogZixcbiAgICAgICAgICB0bzogdCxcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24oKSxcbiAgICAgICAgICBkaXJlY3Rpb246IGQsXG4gICAgICAgICAgbGFiZWxzOiBsLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BPYmpcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBlZyRjNSA9IFwiOlwiLFxuICAgICAgcGVnJGM2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjpcIiwgZmFsc2UpLFxuICAgICAgcGVnJGM3ID0gZnVuY3Rpb24obCkge1xuICAgICAgICByZXR1cm4gbFxuICAgICAgfSxcbiAgICAgIHBlZyRjOCA9IGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBrZXk6IGssXG4gICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBlZyRjOSA9IFwiLS1cIixcbiAgICAgIHBlZyRjMTAgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLS1cIiwgZmFsc2UpLFxuICAgICAgcGVnJGMxMSA9IFwiLT5cIixcbiAgICAgIHBlZyRjMTIgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLT5cIiwgZmFsc2UpLFxuICAgICAgcGVnJGMxMyA9IFwiLVwiLFxuICAgICAgcGVnJGMxNCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCItXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMTUgPSBcIi5cIixcbiAgICAgIHBlZyRjMTYgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLlwiLCBmYWxzZSksXG4gICAgICBwZWckYzE3ID0gL15bMC05XS8sXG4gICAgICBwZWckYzE4ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIjBcIiwgXCI5XCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgIHBlZyRjMTkgPSBcIjBcIixcbiAgICAgIHBlZyRjMjAgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiMFwiLCBmYWxzZSksXG4gICAgICBwZWckYzIxID0gL15bMS05XS8sXG4gICAgICBwZWckYzIyID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIjFcIiwgXCI5XCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgIHBlZyRjMjMgPSAvXltlRV0vLFxuICAgICAgcGVnJGMyNCA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcImVcIiwgXCJFXCJdLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgcGVnJGMyNSA9IFwiK1wiLFxuICAgICAgcGVnJGMyNiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIrXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMjcgPSBcIidcIixcbiAgICAgIHBlZyRjMjggPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiJ1wiLCBmYWxzZSksXG4gICAgICBwZWckYzI5ID0gXCJcXFwiXCIsXG4gICAgICBwZWckYzMwID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlxcXCJcIiwgZmFsc2UpLFxuICAgICAgcGVnJGMzMSA9IFwiXFxcXFwiLFxuICAgICAgcGVnJGMzMiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJcXFxcXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMzMgPSBcImJcIixcbiAgICAgIHBlZyRjMzQgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiYlwiLCBmYWxzZSksXG4gICAgICBwZWckYzM1ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlxcYlwiO1xuICAgICAgfSxcbiAgICAgIHBlZyRjMzYgPSBcImZcIixcbiAgICAgIHBlZyRjMzcgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiZlwiLCBmYWxzZSksXG4gICAgICBwZWckYzM4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlxcZlwiO1xuICAgICAgfSxcbiAgICAgIHBlZyRjMzkgPSBcIm5cIixcbiAgICAgIHBlZyRjNDAgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiblwiLCBmYWxzZSksXG4gICAgICBwZWckYzQxID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlxcblwiO1xuICAgICAgfSxcbiAgICAgIHBlZyRjNDIgPSBcInJcIixcbiAgICAgIHBlZyRjNDMgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiclwiLCBmYWxzZSksXG4gICAgICBwZWckYzQ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlxcclwiO1xuICAgICAgfSxcbiAgICAgIHBlZyRjNDUgPSBcInRcIixcbiAgICAgIHBlZyRjNDYgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidFwiLCBmYWxzZSksXG4gICAgICBwZWckYzQ3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlxcdFwiO1xuICAgICAgfSxcbiAgICAgIHBlZyRjNDggPSBcInZcIixcbiAgICAgIHBlZyRjNDkgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidlwiLCBmYWxzZSksXG4gICAgICBwZWckYzUwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlxceDBCXCI7XG4gICAgICB9LFxuICAgICAgcGVnJGM1MSA9IHBlZyRhbnlFeHBlY3RhdGlvbigpLFxuICAgICAgcGVnJGM1MiA9IGZ1bmN0aW9uKGNoYXIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXI7XG4gICAgICB9LFxuICAgICAgcGVnJGM1MyA9IGZ1bmN0aW9uKGVzYykge1xuICAgICAgICByZXR1cm4gZXNjO1xuICAgICAgfSxcbiAgICAgIHBlZyRjNTQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRleHQoKTtcbiAgICAgIH0sXG4gICAgICBwZWckYzU1ID0gZnVuY3Rpb24oY2hhcnMpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgICAgfSxcbiAgICAgIHBlZyRjNTYgPSBmdW5jdGlvbihjaGFycykgeyBcbiAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgICAgfSxcbiAgICAgIHBlZyRjNTcgPSAvXlsgXFx0XS8sXG4gICAgICBwZWckYzU4ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiIFwiLCBcIlxcdFwiXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgIHBlZyRjNTkgPSAvXls6IFxcdFxcclxcbl0vLFxuICAgICAgcGVnJGM2MCA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcIjpcIiwgXCIgXCIsIFwiXFx0XCIsIFwiXFxyXCIsIFwiXFxuXCJdLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgcGVnJGM2MSA9IC9eW146IFxcdFxcclxcbl0vLFxuICAgICAgcGVnJGM2MiA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcIjpcIiwgXCIgXCIsIFwiXFx0XCIsIFwiXFxyXCIsIFwiXFxuXCJdLCB0cnVlLCBmYWxzZSksXG4gICAgICBwZWckYzYzID0gL15bXFxyXFxuXS8sXG4gICAgICBwZWckYzY0ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiXFxyXCIsIFwiXFxuXCJdLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgcGVnJGM2NSA9IC9eW15cXHJcXG5dLyxcbiAgICAgIHBlZyRjNjYgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCJcXHJcIiwgXCJcXG5cIl0sIHRydWUsIGZhbHNlKSxcblxuICAgICAgcGVnJGN1cnJQb3MgICAgICAgICAgPSAwLFxuICAgICAgcGVnJHNhdmVkUG9zICAgICAgICAgPSAwLFxuICAgICAgcGVnJHBvc0RldGFpbHNDYWNoZSAgPSBbeyBsaW5lOiAxLCBjb2x1bW46IDEgfV0sXG4gICAgICBwZWckbWF4RmFpbFBvcyAgICAgICA9IDAsXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkICA9IFtdLFxuICAgICAgcGVnJHNpbGVudEZhaWxzICAgICAgPSAwLFxuXG4gICAgICBwZWckcmVzdWx0O1xuXG4gIGlmIChcInN0YXJ0UnVsZVwiIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlRnVuY3Rpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3RhcnQgcGFyc2luZyBmcm9tIHJ1bGUgXFxcIlwiICsgb3B0aW9ucy5zdGFydFJ1bGUgKyBcIlxcXCIuXCIpO1xuICAgIH1cblxuICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbnNbb3B0aW9ucy5zdGFydFJ1bGVdO1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7XG4gIH1cblxuICBmdW5jdGlvbiBleHBlY3RlZChkZXNjcmlwdGlvbiwgbG9jYXRpb24pIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uICE9PSB2b2lkIDAgPyBsb2NhdGlvbiA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcylcblxuICAgIHRocm93IHBlZyRidWlsZFN0cnVjdHVyZWRFcnJvcihcbiAgICAgIFtwZWckb3RoZXJFeHBlY3RhdGlvbihkZXNjcmlwdGlvbildLFxuICAgICAgaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpLFxuICAgICAgbG9jYXRpb25cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgbG9jYXRpb24pIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uICE9PSB2b2lkIDAgPyBsb2NhdGlvbiA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcylcblxuICAgIHRocm93IHBlZyRidWlsZFNpbXBsZUVycm9yKG1lc3NhZ2UsIGxvY2F0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24odGV4dCwgaWdub3JlQ2FzZSkge1xuICAgIHJldHVybiB7IHR5cGU6IFwibGl0ZXJhbFwiLCB0ZXh0OiB0ZXh0LCBpZ25vcmVDYXNlOiBpZ25vcmVDYXNlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckY2xhc3NFeHBlY3RhdGlvbihwYXJ0cywgaW52ZXJ0ZWQsIGlnbm9yZUNhc2UpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImNsYXNzXCIsIHBhcnRzOiBwYXJ0cywgaW52ZXJ0ZWQ6IGludmVydGVkLCBpZ25vcmVDYXNlOiBpZ25vcmVDYXNlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckYW55RXhwZWN0YXRpb24oKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJhbnlcIiB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGVuZEV4cGVjdGF0aW9uKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiZW5kXCIgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRvdGhlckV4cGVjdGF0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpIHtcbiAgICB2YXIgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcG9zXSwgcDtcblxuICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICByZXR1cm4gZGV0YWlscztcbiAgICB9IGVsc2Uge1xuICAgICAgcCA9IHBvcyAtIDE7XG4gICAgICB3aGlsZSAoIXBlZyRwb3NEZXRhaWxzQ2FjaGVbcF0pIHtcbiAgICAgICAgcC0tO1xuICAgICAgfVxuXG4gICAgICBkZXRhaWxzID0gcGVnJHBvc0RldGFpbHNDYWNoZVtwXTtcbiAgICAgIGRldGFpbHMgPSB7XG4gICAgICAgIGxpbmU6ICAgZGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IGRldGFpbHMuY29sdW1uXG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAocCA8IHBvcykge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwKSA9PT0gMTApIHtcbiAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgfVxuXG4gICAgICAgIHArKztcbiAgICAgIH1cblxuICAgICAgcGVnJHBvc0RldGFpbHNDYWNoZVtwb3NdID0gZGV0YWlscztcbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRjb21wdXRlTG9jYXRpb24oc3RhcnRQb3MsIGVuZFBvcykge1xuICAgIHZhciBzdGFydFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoc3RhcnRQb3MpLFxuICAgICAgICBlbmRQb3NEZXRhaWxzICAgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoZW5kUG9zKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydDoge1xuICAgICAgICBvZmZzZXQ6IHN0YXJ0UG9zLFxuICAgICAgICBsaW5lOiAgIHN0YXJ0UG9zRGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IHN0YXJ0UG9zRGV0YWlscy5jb2x1bW5cbiAgICAgIH0sXG4gICAgICBlbmQ6IHtcbiAgICAgICAgb2Zmc2V0OiBlbmRQb3MsXG4gICAgICAgIGxpbmU6ICAgZW5kUG9zRGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IGVuZFBvc0RldGFpbHMuY29sdW1uXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRmYWlsKGV4cGVjdGVkKSB7XG4gICAgaWYgKHBlZyRjdXJyUG9zIDwgcGVnJG1heEZhaWxQb3MpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAocGVnJGN1cnJQb3MgPiBwZWckbWF4RmFpbFBvcykge1xuICAgICAgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgPSBbXTtcbiAgICB9XG5cbiAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGJ1aWxkU2ltcGxlRXJyb3IobWVzc2FnZSwgbG9jYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IHBlZyRTeW50YXhFcnJvcihtZXNzYWdlLCBudWxsLCBudWxsLCBsb2NhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoZXhwZWN0ZWQsIGZvdW5kLCBsb2NhdGlvbikge1xuICAgIHJldHVybiBuZXcgcGVnJFN5bnRheEVycm9yKFxuICAgICAgcGVnJFN5bnRheEVycm9yLmJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBmb3VuZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZVBHKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IFtdO1xuICAgIHMyID0gcGVnJHBhcnNlTm9kZU9yRWRnZSgpO1xuICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEucHVzaChzMik7XG4gICAgICBzMiA9IHBlZyRwYXJzZU5vZGVPckVkZ2UoKTtcbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZUVPRigpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMChzMSk7XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlTm9kZU9yRWRnZSgpIHtcbiAgICB2YXIgczAsIHMxO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZU5vZGUoKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgczEgPSBwZWckYzEoczEpO1xuICAgIH1cbiAgICBzMCA9IHMxO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlRWRnZSgpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMihzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJHBhcnNlRW1wdHlMaW5lKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlTm9kZSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VLZXkoKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gW107XG4gICAgICBzMyA9IHBlZyRwYXJzZUxhYmVsKCk7XG4gICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgIHMzID0gcGVnJHBhcnNlTGFiZWwoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IFtdO1xuICAgICAgICBzNCA9IHBlZyRwYXJzZVByb3BlcnR5KCk7XG4gICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlUHJvcGVydHkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IFtdO1xuICAgICAgICAgIHM1ID0gcGVnJHBhcnNlV1MoKTtcbiAgICAgICAgICB3aGlsZSAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0LnB1c2goczUpO1xuICAgICAgICAgICAgczUgPSBwZWckcGFyc2VXUygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlRW5kT2ZMaW5lKCk7XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGMzKHMxLCBzMiwgczMpO1xuICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZUVkZ2UoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNywgczgsIHM5O1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZUtleSgpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBbXTtcbiAgICAgIHMzID0gcGVnJHBhcnNlV1MoKTtcbiAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZVdTKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IHBlZyRwYXJzZURpcmVjdGlvbigpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IFtdO1xuICAgICAgICAgIHM1ID0gcGVnJHBhcnNlV1MoKTtcbiAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNC5wdXNoKHM1KTtcbiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VXUygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczUgPSBwZWckcGFyc2VLZXkoKTtcbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNiA9IFtdO1xuICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZUxhYmVsKCk7XG4gICAgICAgICAgICAgIHdoaWxlIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM2LnB1c2goczcpO1xuICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlTGFiZWwoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzNyA9IFtdO1xuICAgICAgICAgICAgICAgIHM4ID0gcGVnJHBhcnNlUHJvcGVydHkoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM3LnB1c2goczgpO1xuICAgICAgICAgICAgICAgICAgczggPSBwZWckcGFyc2VQcm9wZXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM4ID0gW107XG4gICAgICAgICAgICAgICAgICBzOSA9IHBlZyRwYXJzZVdTKCk7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoczkgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczgucHVzaChzOSk7XG4gICAgICAgICAgICAgICAgICAgIHM5ID0gcGVnJHBhcnNlV1MoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzOSA9IHBlZyRwYXJzZUVuZE9mTGluZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoczkgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjNChzMSwgczMsIHM1LCBzNiwgczcpO1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VMYWJlbCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IFtdO1xuICAgIHMyID0gcGVnJHBhcnNlRGVsaW1pdGVyKCk7XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlRGVsaW1pdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgIHMyID0gcGVnJGM1O1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IFtdO1xuICAgICAgICBzNCA9IHBlZyRwYXJzZVdTKCk7XG4gICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlV1MoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZUtleSgpO1xuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjNyhzNCk7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZVByb3BlcnR5KCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNjtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBbXTtcbiAgICBzMiA9IHBlZyRwYXJzZURlbGltaXRlcigpO1xuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICBzMiA9IHBlZyRwYXJzZURlbGltaXRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VLZXkoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IFtdO1xuICAgICAgICBzNCA9IHBlZyRwYXJzZVdTKCk7XG4gICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlV1MoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgICAgICBzNCA9IHBlZyRjNTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gW107XG4gICAgICAgICAgICBzNiA9IHBlZyRwYXJzZVdTKCk7XG4gICAgICAgICAgICB3aGlsZSAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczUucHVzaChzNik7XG4gICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlV1MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZVZhbHVlKCk7XG4gICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJGM4KHMyLCBzNik7XG4gICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZURpcmVjdGlvbigpIHtcbiAgICB2YXIgczA7XG5cbiAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGM5KSB7XG4gICAgICBzMCA9IHBlZyRjOTtcbiAgICAgIHBlZyRjdXJyUG9zICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMCk7IH1cbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGMxMSkge1xuICAgICAgICBzMCA9IHBlZyRjMTE7XG4gICAgICAgIHBlZyRjdXJyUG9zICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMik7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VOdW1iZXIoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2O1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ1KSB7XG4gICAgICBzMSA9IHBlZyRjMTM7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTQpOyB9XG4gICAgfVxuICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlSW50ZWdlcigpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDYpIHtcbiAgICAgICAgICBzNCA9IHBlZyRjMTU7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE2KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM1ID0gW107XG4gICAgICAgICAgaWYgKHBlZyRjMTcudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczYgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE4KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNS5wdXNoKHM2KTtcbiAgICAgICAgICAgICAgaWYgKHBlZyRjMTcudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICAgIHM2ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHM2ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTgpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gW3M0LCBzNV07XG4gICAgICAgICAgICBzMyA9IHM0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczQgPSBwZWckcGFyc2VFeHAoKTtcbiAgICAgICAgICBpZiAoczQgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMSA9IFtzMSwgczIsIHMzLCBzNF07XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZUludGVnZXIoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0OCkge1xuICAgICAgczAgPSBwZWckYzE5O1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIwKTsgfVxuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAocGVnJGMyMS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIyKTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gW107XG4gICAgICAgIGlmIChwZWckYzE3LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE4KTsgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICAgIGlmIChwZWckYzE3LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgIHMzID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxOCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBbczEsIHMyXTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlRXhwKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQ7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChwZWckYzIzLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyNCk7IH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ1KSB7XG4gICAgICAgIHMyID0gcGVnJGMxMztcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE0KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDMpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMjU7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI2KTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gW107XG4gICAgICAgIGlmIChwZWckYzE3LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE4KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczMucHVzaChzNCk7XG4gICAgICAgICAgICBpZiAocGVnJGMxNy50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE4KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBbczEsIHMyLCBzM107XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZUVzY2FwZWRDaGFyKCkge1xuICAgIHZhciBzMCwgczE7XG5cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM5KSB7XG4gICAgICBzMCA9IHBlZyRjMjc7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjgpOyB9XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNCkge1xuICAgICAgICBzMCA9IHBlZyRjMjk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkyKSB7XG4gICAgICAgICAgczAgPSBwZWckYzMxO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMik7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTgpIHtcbiAgICAgICAgICAgIHMxID0gcGVnJGMzMztcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzNCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGMzNSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTAyKSB7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGMzNjtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM3KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjMzgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMTApIHtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMzk7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQwKTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJGM0MSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMTQpIHtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGM0MjtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0Myk7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGM0NCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTE2KSB7XG4gICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGM0NTtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ2KTsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjNDcoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjNDg7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ5KTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGM1MCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlRG91YmxlUXVvdGVkQ2hhcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckY3VyclBvcztcbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM0KSB7XG4gICAgICBzMiA9IHBlZyRjMjk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzApOyB9XG4gICAgfVxuICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mikge1xuICAgICAgICBzMiA9IHBlZyRjMzE7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMik7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHZvaWQgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcGVnJGN1cnJQb3MpIHtcbiAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTEpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM1MihzMik7XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTIpIHtcbiAgICAgICAgczEgPSBwZWckYzMxO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzIpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VFc2NhcGVkQ2hhcigpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNTMoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VTaW5nbGVRdW90ZWRDaGFyKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRjdXJyUG9zO1xuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzkpIHtcbiAgICAgIHMyID0gcGVnJGMyNztcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyOCk7IH1cbiAgICB9XG4gICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkyKSB7XG4gICAgICAgIHMyID0gcGVnJGMzMTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMyKTsgfVxuICAgICAgfVxuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gdm9pZCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMxO1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwZWckY3VyclBvcykge1xuICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1MSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzUyKHMyKTtcbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mikge1xuICAgICAgICBzMSA9IHBlZyRjMzE7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZUVzY2FwZWRDaGFyKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM1MyhzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZUtleSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlTnVtYmVyKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICBzMyA9IHBlZyRwYXJzZVNQRUNJQUxfQ0hBUigpO1xuICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMjtcbiAgICAgICAgczIgPSB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM1NCgpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM0KSB7XG4gICAgICAgIHMxID0gcGVnJGMyOTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMwKTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gW107XG4gICAgICAgIHMzID0gcGVnJHBhcnNlRG91YmxlUXVvdGVkQ2hhcigpO1xuICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZURvdWJsZVF1b3RlZENoYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM0KSB7XG4gICAgICAgICAgICBzMyA9IHBlZyRjMjk7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzApOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjNTUoczIpO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM5KSB7XG4gICAgICAgICAgczEgPSBwZWckYzI3O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyOCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IFtdO1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlU2luZ2xlUXVvdGVkQ2hhcigpO1xuICAgICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgICBzMyA9IHBlZyRwYXJzZVNpbmdsZVF1b3RlZENoYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM5KSB7XG4gICAgICAgICAgICAgIHMzID0gcGVnJGMyNztcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI4KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjNTYoczIpO1xuICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIHMxID0gW107XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VOT05fU1BFQ0lBTF9DSEFSKCk7XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlTk9OX1NQRUNJQUxfQ0hBUigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjNTUoczEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlVmFsdWUoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM0KSB7XG4gICAgICBzMSA9IHBlZyRjMjk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzApOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBbXTtcbiAgICAgIHMzID0gcGVnJHBhcnNlRG91YmxlUXVvdGVkQ2hhcigpO1xuICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICBzMyA9IHBlZyRwYXJzZURvdWJsZVF1b3RlZENoYXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM0KSB7XG4gICAgICAgICAgczMgPSBwZWckYzI5O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNTUoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzOSkge1xuICAgICAgICBzMSA9IHBlZyRjMjc7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyOCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IFtdO1xuICAgICAgICBzMyA9IHBlZyRwYXJzZVNpbmdsZVF1b3RlZENoYXIoKTtcbiAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VTaW5nbGVRdW90ZWRDaGFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzOSkge1xuICAgICAgICAgICAgczMgPSBwZWckYzI3O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI4KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzU2KHMyKTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBbXTtcbiAgICAgICAgczIgPSBwZWckcGFyc2VOT05fU1BFQ0lBTF9DSEFSKCk7XG4gICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTgpIHtcbiAgICAgICAgICAgIHMyID0gcGVnJGM1O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgICBzMiA9IHBlZyRwYXJzZU5PTl9TUEVDSUFMX0NIQVIoKTtcbiAgICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgICAgICAgICAgczIgPSBwZWckYzU7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM1NShzMSk7XG4gICAgICAgIH1cbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VXUygpIHtcbiAgICB2YXIgczA7XG5cbiAgICBpZiAocGVnJGM1Ny50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTgpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlU1BFQ0lBTF9DSEFSKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChwZWckYzU5LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2MCk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VOT05fU1BFQ0lBTF9DSEFSKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChwZWckYzYxLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2Mik7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VORVdMSU5FKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChwZWckYzYzLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2NCk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VOT05fTkVXTElORSgpIHtcbiAgICB2YXIgczA7XG5cbiAgICBpZiAocGVnJGM2NS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjYpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlRU9GKCkge1xuICAgIHZhciBzMCwgczE7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIGlmIChpbnB1dC5sZW5ndGggPiBwZWckY3VyclBvcykge1xuICAgICAgczEgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzUxKTsgfVxuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gdm9pZCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZUVuZE9mTGluZSgpIHtcbiAgICB2YXIgczA7XG5cbiAgICBzMCA9IHBlZyRwYXJzZUVPRigpO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckcGFyc2VORVdMSU5FKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlRGVsaW1pdGVyKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQ7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gW107XG4gICAgczIgPSBwZWckcGFyc2VXUygpO1xuICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEucHVzaChzMik7XG4gICAgICBzMiA9IHBlZyRwYXJzZVdTKCk7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VORVdMSU5FKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBbXTtcbiAgICAgICAgczQgPSBwZWckcGFyc2VXUygpO1xuICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICB3aGlsZSAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgICAgczQgPSBwZWckcGFyc2VXUygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBbczEsIHMyLCBzM107XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gW107XG4gICAgICBzMSA9IHBlZyRwYXJzZVdTKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAucHVzaChzMSk7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2VXUygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlRW1wdHlMaW5lKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IFtdO1xuICAgIHMyID0gcGVnJHBhcnNlV1MoKTtcbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgczIgPSBwZWckcGFyc2VXUygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VFT0YoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IFtzMSwgczJdO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgczIgPSBwZWckcGFyc2VXUygpO1xuICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICBzMiA9IHBlZyRwYXJzZVdTKCk7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VORVdMSU5FKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxID0gW3MxLCBzMl07XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG5cbiAgICBsZXQgbm9kZUNvdW50ID0gMDtcbiAgICBsZXQgZWRnZUNvdW50ID0gMDtcbiAgICBsZXQgbm9kZUxhYmVsSGFzaCA9IHt9O1xuICAgIGxldCBlZGdlTGFiZWxIYXNoID0ge307XG4gICAgbGV0IG5vZGVQcm9wSGFzaCA9IHt9O1xuICAgIGxldCBlZGdlUHJvcEhhc2ggPSB7fTtcblxuXG4gIHBlZyRyZXN1bHQgPSBwZWckc3RhcnRSdWxlRnVuY3Rpb24oKTtcblxuICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBlZyRyZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHBlZyRmYWlsKHBlZyRlbmRFeHBlY3RhdGlvbigpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLFxuICAgICAgcGVnJG1heEZhaWxQb3MgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQXQocGVnJG1heEZhaWxQb3MpIDogbnVsbCxcbiAgICAgIHBlZyRtYXhGYWlsUG9zIDwgaW5wdXQubGVuZ3RoXG4gICAgICAgID8gcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckbWF4RmFpbFBvcywgcGVnJG1heEZhaWxQb3MgKyAxKVxuICAgICAgICA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJG1heEZhaWxQb3MsIHBlZyRtYXhGYWlsUG9zKVxuICAgICk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFN5bnRheEVycm9yOiBwZWckU3ludGF4RXJyb3IsXG4gIHBhcnNlOiAgICAgICBwZWckcGFyc2Vcbn07XG5cbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucGdQYXJzZXIgPSByZXF1aXJlKCcuL3BnX3BhcnNlci5qcycpO1xuXG5sZXQgY29yZVBhcnNlID0gcGdQYXJzZXIucGFyc2U7XG5mdW5jdGlvbiByZW1vdmVDb21tZW50KHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSgvXigoKFwiW15cIlxcXFxdKihcXFxcLlteXCJcXFxcXSopKlwiKXxbXiNcIl0pKikoIy4qKSQvZ20sICckMScpO1xufVxucGdQYXJzZXIucGFyc2UgPSAodGV4dCkgPT4gY29yZVBhcnNlKHJlbW92ZUNvbW1lbnQodGV4dCkpO1xuXG59LHtcIi4vcGdfcGFyc2VyLmpzXCI6MX1dfSx7fSxbMl0pO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdClcblx0XHRzY3JpcHRVcmwgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY1xuXHRpZiAoIXNjcmlwdFVybCkge1xuXHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG5cdFx0aWYoc2NyaXB0cy5sZW5ndGgpIHNjcmlwdFVybCA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5zcmNcblx0fVxufVxuLy8gV2hlbiBzdXBwb3J0aW5nIGJyb3dzZXJzIHdoZXJlIGFuIGF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgeW91IG11c3Qgc3BlY2lmeSBhbiBvdXRwdXQucHVibGljUGF0aCBtYW51YWxseSB2aWEgY29uZmlndXJhdGlvblxuLy8gb3IgcGFzcyBhbiBlbXB0eSBzdHJpbmcgKFwiXCIpIGFuZCBzZXQgdGhlIF9fd2VicGFja19wdWJsaWNfcGF0aF9fIHZhcmlhYmxlIGZyb20geW91ciBjb2RlIHRvIHVzZSB5b3VyIG93biBsb2dpYy5cbmlmICghc2NyaXB0VXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbnNjcmlwdFVybCA9IHNjcmlwdFVybC5yZXBsYWNlKC8jLiokLywgXCJcIikucmVwbGFjZSgvXFw/LiokLywgXCJcIikucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIi9cIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBzY3JpcHRVcmw7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5iID0gZG9jdW1lbnQuYmFzZVVSSSB8fCBzZWxmLmxvY2F0aW9uLmhyZWY7XG5cbi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4vLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbi8vIFtyZXNvbHZlLCByZWplY3QsIFByb21pc2VdID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxudmFyIGluc3RhbGxlZENodW5rcyA9IHtcblx0XCJtYWluXCI6IDBcbn07XG5cbi8vIG5vIGNodW5rIG9uIGRlbWFuZCBsb2FkaW5nXG5cbi8vIG5vIHByZWZldGNoaW5nXG5cbi8vIG5vIHByZWxvYWRlZFxuXG4vLyBubyBITVJcblxuLy8gbm8gSE1SIG1hbmlmZXN0XG5cbi8vIG5vIG9uIGNodW5rcyBsb2FkZWRcblxuLy8gbm8ganNvbnAgZnVuY3Rpb24iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5jID0gdW5kZWZpbmVkOyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2JsaXR6Ym9hcmQuanNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=